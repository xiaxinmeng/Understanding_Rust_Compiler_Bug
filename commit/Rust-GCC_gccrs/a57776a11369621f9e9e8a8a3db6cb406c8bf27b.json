{"sha": "a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU3Nzc2YTExMzY5NjIxZjllOWU4YThhM2RiNmNiNDA2YzhiZjI3Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T18:02:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T18:02:10Z"}, "message": "Support for aliasing with variable strides\n\nThis patch adds runtime alias checks for loops with variable strides,\nso that we can vectorise them even without a restrict qualifier.\nThere are several parts to doing this:\n\n1) For accesses like:\n\n     x[i * n] += 1;\n\n   we need to check whether n (and thus the DR_STEP) is nonzero.\n   vect_analyze_data_ref_dependence records values that need to be\n   checked in this way, then prune_runtime_alias_test_list records a\n   bounds check on DR_STEP being outside the range [0, 0].\n\n2) For accesses like:\n\n     x[i * n] = x[i * n + 1] + 1;\n\n   we simply need to test whether abs (n) >= 2.\n   prune_runtime_alias_test_list looks for cases like this and tries\n   to guess whether it is better to use this kind of check or a check\n   for non-overlapping ranges.  (We could do an OR of the two conditions\n   at runtime, but that isn't implemented yet.)\n\n3) Checks for overlapping ranges need to cope with variable strides.\n   At present the \"length\" of each segment in a range check is\n   represented as an offset from the base that lies outside the\n   touched range, in the same direction as DR_STEP.  The length\n   can therefore be negative and is sometimes conservative.\n\n   With variable steps it's easier to reaon about if we split\n   this into two:\n\n     seg_len:\n       distance travelled from the first iteration of interest\n       to the last, e.g. DR_STEP * (VF - 1)\n\n     access_size:\n       the number of bytes accessed in each iteration\n\n   with access_size always being a positive constant and seg_len\n   possibly being variable.  We can then combine alias checks\n   for two accesses that are a constant number of bytes apart by\n   adjusting the access size to account for the gap.  This leaves\n   the segment length unchanged, which allows the check to be combined\n   with further accesses.\n\n   When seg_len is positive, the runtime alias check has the form:\n\n        base_a >= base_b + seg_len_b + access_size_b\n     || base_b >= base_a + seg_len_a + access_size_a\n\n   In many accesses the base will be aligned to the access size, which\n   allows us to skip the addition:\n\n        base_a > base_b + seg_len_b\n     || base_b > base_a + seg_len_a\n\n   A similar saving is possible with \"negative\" lengths.\n\n   The patch therefore tracks the alignment in addition to seg_len\n   and access_size.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vec_lower_bound): New structure.\n\t(_loop_vec_info): Add check_nonzero and lower_bounds.\n\t(LOOP_VINFO_CHECK_NONZERO): New macro.\n\t(LOOP_VINFO_LOWER_BOUNDS): Likewise.\n\t(LOOP_REQUIRES_VERSIONING_FOR_ALIAS): Check lower_bounds too.\n\t* tree-data-ref.h (dr_with_seg_len): Add access_size and align\n\tfields.  Make seg_len the distance travelled, not including the\n\taccess size.\n\t(dr_direction_indicator): Declare.\n\t(dr_zero_step_indicator): Likewise.\n\t(dr_known_forward_stride_p): Likewise.\n\t* tree-data-ref.c: Include stringpool.h, tree-vrp.h and\n\ttree-ssanames.h.\n\t(runtime_alias_check_p): Allow runtime alias checks with\n\tvariable strides.\n\t(operator ==): Compare access_size and align.\n\t(prune_runtime_alias_test_list): Rework for new distinction between\n\tthe access_size and seg_len.\n\t(create_intersect_range_checks_index): Likewise.  Cope with polynomial\n\tsegment lengths.\n\t(get_segment_min_max): New function.\n\t(create_intersect_range_checks): Use it.\n\t(dr_step_indicator): New function.\n\t(dr_direction_indicator): Likewise.\n\t(dr_zero_step_indicator): Likewise.\n\t(dr_known_forward_stride_p): Likewise.\n\t* tree-loop-distribution.c (data_ref_segment_size): Return\n\tDR_STEP * (niters - 1).\n\t(compute_alias_check_pairs): Update call to the dr_with_seg_len\n\tconstructor.\n\t* tree-vect-data-refs.c (vect_check_nonzero_value): New function.\n\t(vect_preserves_scalar_order_p): New function, split out from...\n\t(vect_analyze_data_ref_dependence): ...here.  Check for zero steps.\n\t(vect_vfa_segment_size): Return DR_STEP * (length_factor - 1).\n\t(vect_vfa_access_size): New function.\n\t(vect_vfa_align): Likewise.\n\t(vect_compile_time_alias): Take access_size_a and access_b arguments.\n\t(dump_lower_bound): New function.\n\t(vect_check_lower_bound): Likewise.\n\t(vect_small_gap_p): Likewise.\n\t(vectorizable_with_step_bound_p): Likewise.\n\t(vect_prune_runtime_alias_test_list): Ignore cross-iteration\n\tdepencies if the vectorization factor is 1.  Convert the checks\n\tfor nonzero steps into checks on the bounds of DR_STEP.  Try using\n\ta bunds check for variable steps if the minimum required step is\n\trelatively small. Update calls to the dr_with_seg_len\n\tconstructor and to vect_compile_time_alias.\n\t* tree-vect-loop-manip.c (vect_create_cond_for_lower_bounds): New\n\tfunction.\n\t(vect_loop_versioning): Call it.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Clear LOOP_VINFO_LOWER_BOUNDS\n\twhen retrying.\n\t(vect_estimate_min_profitable_iters): Account for any bounds checks.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-cond-1.c: Expect loop vectorization rather\n\tthan SLP vectorization.\n\t* gcc.dg/vect/vect-alias-check-10.c: New test.\n\t* gcc.dg/vect/vect-alias-check-11.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-12.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-8.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-9.c: Likewise.\n\t* gcc.target/aarch64/sve/strided_load_8.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_1.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_1.h: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_1_run.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_2.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_2_run.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_3.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_3_run.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_4.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_4_run.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_5.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_5_run.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_6.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_6_run.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_7.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_7_run.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_8.c: Likewise.\n\t* gcc.target/aarch64/sve/var_stride_8_run.c: Likewise.\n\t* gfortran.dg/vect/vect-alias-check-1.F90: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256644", "tree": {"sha": "a9dd82784464ea1a418d7c88730dad9f05ef9840", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9dd82784464ea1a418d7c88730dad9f05ef9840"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/comments", "author": null, "committer": null, "parents": [{"sha": "f307441ac4d58d5a1690081f95b63b70b3e90b48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f307441ac4d58d5a1690081f95b63b70b3e90b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f307441ac4d58d5a1690081f95b63b70b3e90b48"}], "stats": {"total": 1965, "additions": 1720, "deletions": 245}, "files": [{"sha": "37656fa68aeb2db542e49e3425198fb17df2cc68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -1,3 +1,61 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vectorizer.h (vec_lower_bound): New structure.\n+\t(_loop_vec_info): Add check_nonzero and lower_bounds.\n+\t(LOOP_VINFO_CHECK_NONZERO): New macro.\n+\t(LOOP_VINFO_LOWER_BOUNDS): Likewise.\n+\t(LOOP_REQUIRES_VERSIONING_FOR_ALIAS): Check lower_bounds too.\n+\t* tree-data-ref.h (dr_with_seg_len): Add access_size and align\n+\tfields.  Make seg_len the distance travelled, not including the\n+\taccess size.\n+\t(dr_direction_indicator): Declare.\n+\t(dr_zero_step_indicator): Likewise.\n+\t(dr_known_forward_stride_p): Likewise.\n+\t* tree-data-ref.c: Include stringpool.h, tree-vrp.h and\n+\ttree-ssanames.h.\n+\t(runtime_alias_check_p): Allow runtime alias checks with\n+\tvariable strides.\n+\t(operator ==): Compare access_size and align.\n+\t(prune_runtime_alias_test_list): Rework for new distinction between\n+\tthe access_size and seg_len.\n+\t(create_intersect_range_checks_index): Likewise.  Cope with polynomial\n+\tsegment lengths.\n+\t(get_segment_min_max): New function.\n+\t(create_intersect_range_checks): Use it.\n+\t(dr_step_indicator): New function.\n+\t(dr_direction_indicator): Likewise.\n+\t(dr_zero_step_indicator): Likewise.\n+\t(dr_known_forward_stride_p): Likewise.\n+\t* tree-loop-distribution.c (data_ref_segment_size): Return\n+\tDR_STEP * (niters - 1).\n+\t(compute_alias_check_pairs): Update call to the dr_with_seg_len\n+\tconstructor.\n+\t* tree-vect-data-refs.c (vect_check_nonzero_value): New function.\n+\t(vect_preserves_scalar_order_p): New function, split out from...\n+\t(vect_analyze_data_ref_dependence): ...here.  Check for zero steps.\n+\t(vect_vfa_segment_size): Return DR_STEP * (length_factor - 1).\n+\t(vect_vfa_access_size): New function.\n+\t(vect_vfa_align): Likewise.\n+\t(vect_compile_time_alias): Take access_size_a and access_b arguments.\n+\t(dump_lower_bound): New function.\n+\t(vect_check_lower_bound): Likewise.\n+\t(vect_small_gap_p): Likewise.\n+\t(vectorizable_with_step_bound_p): Likewise.\n+\t(vect_prune_runtime_alias_test_list): Ignore cross-iteration\n+\tdepencies if the vectorization factor is 1.  Convert the checks\n+\tfor nonzero steps into checks on the bounds of DR_STEP.  Try using\n+\ta bunds check for variable steps if the minimum required step is\n+\trelatively small. Update calls to the dr_with_seg_len\n+\tconstructor and to vect_compile_time_alias.\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_lower_bounds): New\n+\tfunction.\n+\t(vect_loop_versioning): Call it.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Clear LOOP_VINFO_LOWER_BOUNDS\n+\twhen retrying.\n+\t(vect_estimate_min_profitable_iters): Account for any bounds checks.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "612489f4cf2531c7af2ce3f87aaaf32030bfa10b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -1,3 +1,34 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/vect/bb-slp-cond-1.c: Expect loop vectorization rather\n+\tthan SLP vectorization.\n+\t* gcc.dg/vect/vect-alias-check-10.c: New test.\n+\t* gcc.dg/vect/vect-alias-check-11.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-12.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-8.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-9.c: Likewise.\n+\t* gcc.target/aarch64/sve/strided_load_8.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_1.h: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_1_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_2_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_3_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_4_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_5_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_6_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_7.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_7_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_8.c: Likewise.\n+\t* gcc.target/aarch64/sve/var_stride_8_run.c: Likewise.\n+\t* gfortran.dg/vect/vect-alias-check-1.F90: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "4bd286bf08c68961f78637693b05a092c8ffb0f7", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-cond-1.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-cond-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-cond-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-cond-1.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -45,10 +45,6 @@ int main ()\n   return 0;\n }\n \n-/* Basic blocks of if-converted loops are vectorized from within the loop\n-   vectorizer pass.  In this case it is really a deficiency in loop\n-   vectorization data dependence analysis that causes us to require\n-   basic block vectorization in the first place.  */\n-\n-/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"vect\" { target vect_element_align } } } */\n+/* { dg-final { scan-tree-dump {(no need for alias check [^\\n]* when VF is 1|no alias between [^\\n]* when [^\\n]* is outside \\(-16, 16\\))} \"vect\" { target vect_element_align } } } */\n+/* { dg-final { scan-tree-dump-times \"loop vectorized\" 1 \"vect\" { target vect_element_align } } } */\n "}, {"sha": "d4eea873ccb78d740ecbd6510f10c0d7deff7a17", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-10.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-10.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-do run } */\n+\n+#define N 87\n+#define M 6\n+\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef signed short ss;\n+typedef unsigned short us;\n+typedef int si;\n+typedef unsigned int ui;\n+typedef signed long long sll;\n+typedef unsigned long long ull;\n+\n+#define FOR_EACH_TYPE(M) \\\n+  M (sc) M (uc) \\\n+  M (ss) M (us) \\\n+  M (si) M (ui) \\\n+  M (sll) M (ull) \\\n+  M (float) M (double)\n+\n+#define TEST_VALUE(I) ((I) * 5 / 2)\n+\n+#define ADD_TEST(TYPE)\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\\\n+  test_##TYPE (TYPE *a, int step)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\ta[i * step + 0] = a[i * step + 0] + 1;\t\\\n+\ta[i * step + 1] = a[i * step + 1] + 2;\t\\\n+\ta[i * step + 2] = a[i * step + 2] + 4;\t\\\n+\ta[i * step + 3] = a[i * step + 3] + 8;\t\\\n+      }\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\\\n+  ref_##TYPE (TYPE *a, int step)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\ta[i * step + 0] = a[i * step + 0] + 1;\t\\\n+\ta[i * step + 1] = a[i * step + 1] + 2;\t\\\n+\ta[i * step + 2] = a[i * step + 2] + 4;\t\\\n+\ta[i * step + 3] = a[i * step + 3] + 8;\t\\\n+\tasm volatile (\"\");\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+#define DO_TEST(TYPE)\t\t\t\t\t\\\n+  for (int j = -M; j <= M; ++j)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TYPE a[N * M], b[N * M];\t\t\t\t\\\n+      for (int i = 0; i < N * M; ++i)\t\t\t\\\n+\ta[i] = b[i] = TEST_VALUE (i);\t\t\t\\\n+      int offset = (j < 0 ? N * M - 4 : 0);\t\t\\\n+      test_##TYPE (a + offset, j);\t\t\t\\\n+      ref_##TYPE (b + offset, j);\t\t\t\\\n+      if (__builtin_memcmp (a, b, sizeof (a)) != 0)\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+    }\n+\n+FOR_EACH_TYPE (ADD_TEST)\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (DO_TEST)\n+  return 0;\n+}"}, {"sha": "601e17fd1dcbc1a6f929c727e008e0271ef68865", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-11.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-11.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do run } */\n+\n+#define N 87\n+#define M 6\n+\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef signed short ss;\n+typedef unsigned short us;\n+typedef int si;\n+typedef unsigned int ui;\n+typedef signed long long sll;\n+typedef unsigned long long ull;\n+\n+#define FOR_EACH_TYPE(M) \\\n+  M (sc) M (uc) \\\n+  M (ss) M (us) \\\n+  M (si) M (ui) \\\n+  M (sll) M (ull) \\\n+  M (float) M (double)\n+\n+#define TEST_VALUE1(I) ((I) * 5 / 2)\n+#define TEST_VALUE2(I) ((I) * 11 / 5)\n+\n+#define ADD_TEST(TYPE)\t\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\t\\\n+  test_##TYPE (TYPE *restrict a, TYPE *restrict b,\t\\\n+\t       int step)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tTYPE r1 = a[i * step + 0] += 1;\t\t\t\\\n+\ta[i * step + 1] += 2;\t\t\t\t\\\n+\ta[i * step + 2] += 4;\t\t\t\t\\\n+\ta[i * step + 3] += 8;\t\t\t\t\\\n+\tb[i] += r1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\t\\\n+  ref_##TYPE (TYPE *restrict a, TYPE *restrict b,\t\\\n+\t      int step)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tTYPE r1 = a[i * step + 0] += 1;\t\t\t\\\n+\ta[i * step + 1] += 2;\t\t\t\t\\\n+\ta[i * step + 2] += 4;\t\t\t\t\\\n+\ta[i * step + 3] += 8;\t\t\t\t\\\n+\tb[i] += r1;\t\t\t\t\t\\\n+\tasm volatile (\"\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+#define DO_TEST(TYPE)\t\t\t\t\t\\\n+  for (int j = -M; j <= M; ++j)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TYPE a1[N * M], a2[N * M], b1[N], b2[N];\t\t\\\n+      for (int i = 0; i < N * M; ++i)\t\t\t\\\n+\ta1[i] = a2[i] = TEST_VALUE1 (i);\t\t\\\n+      for (int i = 0; i < N; ++i)\t\t\t\\\n+\tb1[i] = b2[i] = TEST_VALUE2 (i);\t\t\\\n+      int offset = (j < 0 ? N * M - 4 : 0);\t\t\\\n+      test_##TYPE (a1 + offset, b1, j);\t\t\t\\\n+      ref_##TYPE (a2 + offset, b2, j);\t\t\t\\\n+      if (__builtin_memcmp (a1, a2, sizeof (a1)) != 0)\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+      if (__builtin_memcmp (b1, b2, sizeof (b1)) != 0)\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+    }\n+\n+FOR_EACH_TYPE (ADD_TEST)\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (DO_TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* is outside \\(-2, 2\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* is outside \\(-3, 3\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* is outside \\(-4, 4\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {run-time check [^\\n]* abs \\([^*]*\\) >= 4} \"vect\" { target vect_int } } } */\n+\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 2[)]* is outside \\(-4, 4\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 2[)]* is outside \\(-6, 6\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 2[)]* is outside \\(-8, 8\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {run-time check [^\\n]* abs \\([^*]* \\* 2[)]* >= 8} \"vect\" { target vect_int } } } */\n+\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 4[)]* is outside \\(-8, 8\\)} \"vect\" { target { vect_int || vect_float } } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 4[)]* is outside \\(-12, 12\\)} \"vect\" { target { vect_int || vect_float } } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 4[)]* is outside \\(-16, 16\\)} \"vect\" { target { vect_int || vect_float } } } } */\n+/* { dg-final { scan-tree-dump {run-time check [^\\n]* abs \\([^*]* \\* 4[)]* >= 16} \"vect\" { target { vect_int || vect_float } } } } */\n+\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 8[)]* is outside \\(-16, 16\\)} \"vect\" { target vect_double } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 8[)]* is outside \\(-24, 24\\)} \"vect\" { target vect_double } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* step[^ ]* \\* 8[)]* is outside \\(-32, 32\\)} \"vect\" { target vect_double } } } */\n+/* { dg-final { scan-tree-dump {run-time check [^\\n]* abs \\([^*]* \\* 8[)]* >= 32} \"vect\" { target vect_double } } } */"}, {"sha": "a44c9bb52587747a9457a4a1b2c61c089ce60d4f", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-12.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-12.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do run } */\n+\n+#define N 87\n+#define M 7\n+\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef signed short ss;\n+typedef unsigned short us;\n+typedef int si;\n+typedef unsigned int ui;\n+typedef signed long long sll;\n+typedef unsigned long long ull;\n+\n+#define FOR_EACH_TYPE(M) \\\n+  M (sc) M (uc) \\\n+  M (ss) M (us) \\\n+  M (si) M (ui) \\\n+  M (sll) M (ull) \\\n+  M (float) M (double)\n+\n+#define TEST_VALUE1(I) ((I) * 5 / 2)\n+#define TEST_VALUE2(I) ((I) * 11 / 5)\n+\n+#define ADD_TEST(TYPE)\t\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\t\\\n+  test_##TYPE (TYPE *restrict a, TYPE *restrict b,\t\\\n+\t       int step)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    step = step & M;\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tTYPE r1 = a[i * step + 0] += 1;\t\t\t\\\n+\ta[i * step + 1] += 2;\t\t\t\t\\\n+\ta[i * step + 2] += 4;\t\t\t\t\\\n+\ta[i * step + 3] += 8;\t\t\t\t\\\n+\tb[i] += r1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\t\\\n+  ref_##TYPE (TYPE *restrict a, TYPE *restrict b,\t\\\n+\t      int step)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (unsigned short i = 0; i < N; ++i)\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tTYPE r1 = a[i * step + 0] += 1;\t\t\t\\\n+\ta[i * step + 1] += 2;\t\t\t\t\\\n+\ta[i * step + 2] += 4;\t\t\t\t\\\n+\ta[i * step + 3] += 8;\t\t\t\t\\\n+\tb[i] += r1;\t\t\t\t\t\\\n+\tasm volatile (\"\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+#define DO_TEST(TYPE)\t\t\t\t\t\\\n+  for (int j = 0; j <= M; ++j)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TYPE a1[N * M], a2[N * M], b1[N], b2[N];\t\t\\\n+      for (int i = 0; i < N * M; ++i)\t\t\t\\\n+\ta1[i] = a2[i] = TEST_VALUE1 (i);\t\t\\\n+      for (int i = 0; i < N; ++i)\t\t\t\\\n+\tb1[i] = b2[i] = TEST_VALUE2 (i);\t\t\\\n+      test_##TYPE (a1, b1, j);\t\t\t\t\\\n+      ref_##TYPE (a2, b2, j);\t\t\t\t\\\n+      if (__builtin_memcmp (a1, a2, sizeof (a1)) != 0)\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+      if (__builtin_memcmp (b1, b2, sizeof (b1)) != 0)\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+    }\n+\n+FOR_EACH_TYPE (ADD_TEST)\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (DO_TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* is outside \\[0, 2\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* is outside \\[0, 3\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* is outside \\[0, 4\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {run-time check [^\\n]* unsigned \\([^*]*\\) >= 4} \"vect\" { target vect_int } } } */\n+\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 2[)]* is outside \\[0, 4\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 2[)]* is outside \\[0, 6\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 2[)]* is outside \\[0, 8\\)} \"vect\" { target vect_int } } } */\n+/* { dg-final { scan-tree-dump {run-time check [^\\n]* unsigned \\([^*]* \\* 2[)]* >= 8} \"vect\" { target vect_int } } } */\n+\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 4[)]* is outside \\[0, 8\\)} \"vect\" { target { vect_int || vect_float } }} } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 4[)]* is outside \\[0, 12\\)} \"vect\" { target { vect_int || vect_float } }} } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 4[)]* is outside \\[0, 16\\)} \"vect\" { target { vect_int || vect_float } }} } */\n+/* { dg-final { scan-tree-dump {run-time check [^\\n]* unsigned \\([^*]* \\* 4[)]* >= 16} \"vect\" { target { vect_int || vect_float } }} } */\n+\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 8[)]* is outside \\[0, 16\\)} \"vect\" { target vect_double } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 8[)]* is outside \\[0, 24\\)} \"vect\" { target vect_double } } } */\n+/* { dg-final { scan-tree-dump {no alias between [^\\n]* when [^\\n]* [_a-z][^ ]* \\* 8[)]* is outside \\[0, 32\\)} \"vect\" { target vect_double } } } */\n+/* { dg-final { scan-tree-dump {run-time check [^\\n]* unsigned \\([^*]* \\* 8[)]* >= 32} \"vect\" { target vect_double } } } */"}, {"sha": "5aeaf2173dc6681a364332354404e321d5e51d9e", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-8.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-8.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do run } */\n+\n+#define N 200\n+#define DIST 32\n+\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef signed short ss;\n+typedef unsigned short us;\n+typedef int si;\n+typedef unsigned int ui;\n+typedef signed long long sll;\n+typedef unsigned long long ull;\n+\n+#define FOR_EACH_TYPE(M) \\\n+  M (sc) M (uc) \\\n+  M (ss) M (us) \\\n+  M (si) M (ui) \\\n+  M (sll) M (ull) \\\n+  M (float) M (double)\n+\n+#define TEST_VALUE(I) ((I) * 5 / 2)\n+\n+#define ADD_TEST(TYPE)\t\t\t\t\\\n+  TYPE a_##TYPE[N * 2];\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\\\n+  test_##TYPE (int x, int y)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\\\n+      a_##TYPE[i + x] += a_##TYPE[i + y];\t\\\n+  }\n+\n+#define DO_TEST(TYPE)\t\t\t\t\t\t\\\n+  for (int i = 0; i < DIST * 2; ++i)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      for (int j = 0; j < N + DIST * 2; ++j)\t\t\t\\\n+\ta_##TYPE[j] = TEST_VALUE (j);\t\t\t\t\\\n+      test_##TYPE (i, DIST);\t\t\t\t\t\\\n+      for (int j = 0; j < N + DIST * 2; ++j)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  TYPE expected;\t\t\t\t\t\\\n+\t  if (j < i || j >= i + N)\t\t\t\t\\\n+\t    expected = TEST_VALUE (j);\t\t\t\t\\\n+\t  else if (i <= DIST)\t\t\t\t\t\\\n+\t    expected = ((TYPE) TEST_VALUE (j)\t\t\t\\\n+\t\t\t+ (TYPE) TEST_VALUE (j - i + DIST));\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    expected = ((TYPE) TEST_VALUE (j)\t\t\t\\\n+\t\t\t+ a_##TYPE[j - i + DIST]);\t\t\\\n+\t  if (expected != a_##TYPE[j])\t\t\t\t\\\n+\t    __builtin_abort ();\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\n+\n+FOR_EACH_TYPE (ADD_TEST)\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (DO_TEST)\n+  return 0;\n+}"}, {"sha": "9bc38af3692a9e9d7c02c9693fa0718507366fc1", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-9.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-9.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do run } */\n+\n+#define N 200\n+#define M 4\n+\n+typedef signed char sc;\n+typedef unsigned char uc;\n+typedef signed short ss;\n+typedef unsigned short us;\n+typedef int si;\n+typedef unsigned int ui;\n+typedef signed long long sll;\n+typedef unsigned long long ull;\n+\n+#define FOR_EACH_TYPE(M) \\\n+  M (sc) M (uc) \\\n+  M (ss) M (us) \\\n+  M (si) M (ui) \\\n+  M (sll) M (ull) \\\n+  M (float) M (double)\n+\n+#define TEST_VALUE(I) ((I) * 5 / 2)\n+\n+#define ADD_TEST(TYPE)\t\t\t\t\\\n+  void __attribute__((noinline, noclone))\t\\\n+  test_##TYPE (TYPE *a, TYPE *b)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; i += 2)\t\t\\\n+      {\t\t\t\t\t\t\\\n+\ta[i + 0] = b[i + 0] + 2;\t\t\\\n+\ta[i + 1] = b[i + 1] + 3;\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+#define DO_TEST(TYPE)\t\t\t\t\t\\\n+  for (int j = 1; j < M; ++j)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      TYPE a[N + M];\t\t\t\t\t\\\n+      for (int i = 0; i < N + M; ++i)\t\t\t\\\n+\ta[i] = TEST_VALUE (i);\t\t\t\t\\\n+      test_##TYPE (a + j, a);\t\t\t\t\\\n+      for (int i = 0; i < N; i += 2)\t\t\t\\\n+\tif (a[i + j] != (TYPE) (a[i] + 2)\t\t\\\n+\t    || a[i + j + 1] != (TYPE) (a[i + 1] + 3))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+    }\n+\n+FOR_EACH_TYPE (ADD_TEST)\n+\n+int\n+main (void)\n+{\n+  FOR_EACH_TYPE (DO_TEST)\n+  return 0;\n+}"}, {"sha": "cd618013e44ee54304a623a804b77fc42cb73288", "filename": "gcc/testsuite/gcc.target/aarch64/sve/strided_load_8.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstrided_load_8.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+void\n+foo (double *x, int m)\n+{\n+  for (int i = 0; i < 256; ++i)\n+    x[i * m] += x[i * m];\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tcbz\\tw1,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, } 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, } 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\t} 1 } } */"}, {"sha": "68baba9e9657482f4bc64b9cfc9e3bde86f59bb0", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TYPE int\n+#define SIZE 257\n+\n+void __attribute__ ((weak))\n+f (TYPE *x, TYPE *y, unsigned short n, long m __attribute__((unused)))\n+{\n+  for (int i = 0; i < SIZE; ++i)\n+    x[i * n] += y[i * n];\n+}\n+\n+/* { dg-final { scan-assembler {\\tld1w\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tst1w\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tldr\\tw[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstr\\tw[0-9]+} } } */\n+/* Should multiply by (VF-1)*4 rather than (257-1)*4.  */\n+/* { dg-final { scan-assembler-not {, 1024} } } */\n+/* { dg-final { scan-assembler-not {\\t.bfiz\\t} } } */\n+/* { dg-final { scan-assembler-not {lsl[^\\n]*[, ]10} } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tx[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tw[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-not {\\tcsel\\tx[0-9]+} } } */\n+/* Two range checks and a check for n being zero.  */\n+/* { dg-final { scan-assembler-times {\\tcmp\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */"}, {"sha": "43b098ff41349bdbd06ef38b33d9e5ec2ff9aae8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_1.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1.h?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,61 @@\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define MARGIN 6\n+\n+void __attribute__ ((weak, optimize (\"no-tree-vectorize\")))\n+test (int n, int m, int offset)\n+{\n+  int abs_n = (n < 0 ? -n : n);\n+  int abs_m = (m < 0 ? -m : m);\n+  int max_i = (abs_n > abs_m ? abs_n : abs_m);\n+  int abs_offset = (offset < 0 ? -offset : offset);\n+  int size = MARGIN * 2 + max_i * SIZE + abs_offset;\n+  TYPE *array = (TYPE *) __builtin_alloca (size * sizeof (TYPE));\n+  for (int i = 0; i < size; ++i)\n+    array[i] = i;\n+  int base_x = offset < 0 ? MARGIN - offset : MARGIN;\n+  int base_y = offset < 0 ? MARGIN : MARGIN + offset;\n+  int start_x = n < 0 ? base_x - n * (SIZE - 1) : base_x;\n+  int start_y = m < 0 ? base_y - m * (SIZE - 1) : base_y;\n+  f (&array[start_x], &array[start_y], n, m);\n+  int j = 0;\n+  int start = (n < 0 ? size - 1 : 0);\n+  int end = (n < 0 ? -1 : size);\n+  int inc = (n < 0 ? -1 : 1);\n+  for (int i = start; i != end; i += inc)\n+    {\n+      if (j == SIZE || i != start_x + j * n)\n+\t{\n+\t  if (array[i] != i)\n+\t    abort ();\n+\t}\n+      else if (n == 0)\n+\t{\n+\t  TYPE sum = i;\n+\t  for (; j < SIZE; j++)\n+\t    {\n+\t      int next_y = start_y + j * m;\n+\t      if (n >= 0 ? next_y < i : next_y > i)\n+\t\tsum += array[next_y];\n+\t      else if (next_y == i)\n+\t\tsum += sum;\n+\t      else\n+\t\tsum += next_y;\n+\t    }\n+\t  if (array[i] != sum)\n+\t    abort ();\n+\t}\n+      else\n+\t{\n+\t  int next_y = start_y + j * m;\n+\t  TYPE base = i;\n+\t  if (n >= 0 ? next_y < i : next_y > i)\n+\t    base += array[next_y];\n+\t  else\n+\t    base += next_y;\n+\t  if (array[i] != base)\n+\t    abort ();\n+\t  j += 1;\n+\t}\n+    }\n+}"}, {"sha": "65bb9fde50604fee1a9a9a22136446b90052be07", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_1_run.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_1_run.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"var_stride_1.c\"\n+#include \"var_stride_1.h\"\n+\n+int\n+main (void)\n+{\n+  for (int n = 0; n < 10; ++n)\n+    for (int offset = -33; offset <= 33; ++offset)\n+      test (n, n, offset);\n+  return 0;\n+}"}, {"sha": "112e84f70127838ee7cdbf7b00035bc5b7e1c27b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TYPE int\n+#define SIZE 257\n+\n+void __attribute__ ((weak))\n+f (TYPE *x, TYPE *y, unsigned short n, unsigned short m)\n+{\n+  for (int i = 0; i < SIZE; ++i)\n+    x[i * n] += y[i * m];\n+}\n+\n+/* { dg-final { scan-assembler {\\tld1w\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tst1w\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tldr\\tw[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstr\\tw[0-9]+} } } */\n+/* Should multiply by (257-1)*4 rather than (VF-1)*4.  */\n+/* { dg-final { scan-assembler-times {\\tadd\\tx[0-9]+, x[0-9]+, x[0-9]+, lsl 10\\n} 2 } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tx[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tw[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-not {\\tcsel\\tx[0-9]+} } } */\n+/* Two range checks and a check for n being zero.  (m being zero is OK.)  */\n+/* { dg-final { scan-assembler-times {\\tcmp\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */"}, {"sha": "313136ae9e029b4db1f7948455f0ebaa0fe9751d", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_2_run.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_2_run.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"var_stride_2.c\"\n+#include \"var_stride_1.h\"\n+\n+int\n+main (void)\n+{\n+  for (int n = 0; n < 10; ++n)\n+    for (int m = 0; m < 10; ++m)\n+      for (int offset = -17; offset <= 17; ++offset)\n+\t{\n+\t  test (n, m, offset);\n+\t  test (n, m, offset + n * (SIZE - 1));\n+\t}\n+  return 0;\n+}"}, {"sha": "70792ff9f332441a69124e6672df48ce2ce4ec32", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TYPE int\n+#define SIZE 257\n+\n+void __attribute__ ((weak))\n+f (TYPE *x, TYPE *y, int n, long m __attribute__((unused)))\n+{\n+  for (int i = 0; i < SIZE; ++i)\n+    x[i * n] += y[i * n];\n+}\n+\n+/* { dg-final { scan-assembler {\\tld1w\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tst1w\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tldr\\tw[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstr\\tw[0-9]+} } } */\n+/* Should multiply by (VF-1)*4 rather than (257-1)*4.  */\n+/* { dg-final { scan-assembler-not {, 1024} } } */\n+/* { dg-final { scan-assembler-not {\\t.bfiz\\t} } } */\n+/* { dg-final { scan-assembler-not {lsl[^\\n]*[, ]10} } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tx[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler {\\tcmp\\tw2, 0} } } */\n+/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+} 2 } } */\n+/* Two range checks and a check for n being zero.  */\n+/* { dg-final { scan-assembler {\\tcmp\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */"}, {"sha": "e10e70da91f7157dbc7de44946d6cdf0754550a3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_3_run.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_3_run.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"var_stride_3.c\"\n+#include \"var_stride_1.h\"\n+\n+int\n+main (void)\n+{\n+  for (int n = -10; n < 10; ++n)\n+    for (int offset = -33; offset <= 33; ++offset)\n+      test (n, n, offset);\n+  return 0;\n+}"}, {"sha": "4bcdb5d0cc123ba4f115134ad21c542af9a49242", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_4.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TYPE int\n+#define SIZE 257\n+\n+void __attribute__ ((weak))\n+f (TYPE *x, TYPE *y, int n, int m)\n+{\n+  for (int i = 0; i < SIZE; ++i)\n+    x[i * n] += y[i * m];\n+}\n+\n+/* { dg-final { scan-assembler {\\tld1w\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tst1w\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tldr\\tw[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstr\\tw[0-9]+} } } */\n+/* Should multiply by (257-1)*4 rather than (VF-1)*4.  */\n+/* { dg-final { scan-assembler-times {\\tlsl\\tx[0-9]+, x[0-9]+, 10\\n} 2 } } */\n+/* { dg-final { scan-assembler {\\tcmp\\tw2, 0} } } */\n+/* { dg-final { scan-assembler {\\tcmp\\tw3, 0} } } */\n+/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+} 4 } } */\n+/* Two range checks and a check for n being zero.  (m being zero is OK.)  */\n+/* { dg-final { scan-assembler {\\tcmp\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */"}, {"sha": "7b8645e3baa722d47a0abc5ab64f5f1b17d98e4f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_4_run.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_4_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_4_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_4_run.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"var_stride_4.c\"\n+#include \"var_stride_1.h\"\n+\n+int\n+main (void)\n+{\n+  for (int n = -10; n < 10; ++n)\n+    for (int m = -10; m < 10; ++m)\n+      for (int offset = -17; offset <= 17; ++offset)\n+\t{\n+\t  test (n, m, offset);\n+\t  test (n, m, offset + n * (SIZE - 1));\n+\t}\n+  return 0;\n+}"}, {"sha": "688f3be61d77df6d6322762c82a0d927776bfc1b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_5.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TYPE double\n+#define SIZE 257\n+\n+void __attribute__ ((weak))\n+f (TYPE *x, TYPE *y, long n, long m __attribute__((unused)))\n+{\n+  for (int i = 0; i < SIZE; ++i)\n+    x[i * n] += y[i * n];\n+}\n+\n+/* { dg-final { scan-assembler {\\tld1d\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tst1d\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tldr\\td[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstr\\td[0-9]+} } } */\n+/* Should multiply by (VF-1)*8 rather than (257-1)*8.  */\n+/* { dg-final { scan-assembler-not {, 2048} } } */\n+/* { dg-final { scan-assembler-not {\\t.bfiz\\t} } } */\n+/* { dg-final { scan-assembler-not {lsl[^\\n]*[, ]11} } } */\n+/* { dg-final { scan-assembler {\\tcmp\\tx[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tw[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+} 2 } } */\n+/* Two range checks and a check for n being zero.  */\n+/* { dg-final { scan-assembler {\\tcmp\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */"}, {"sha": "3360d0eab9b3d60aa879e688e884d06dae11a136", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_5_run.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_5_run.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"var_stride_5.c\"\n+#include \"var_stride_1.h\"\n+\n+int\n+main (void)\n+{\n+  for (int n = -10; n < 10; ++n)\n+    for (int offset = -33; offset <= 33; ++offset)\n+      test (n, n, offset);\n+  return 0;\n+}"}, {"sha": "37e5d0f8fedf417b0c07abc88df353a587d15d61", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_6.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_6.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TYPE long\n+#define SIZE 257\n+\n+void __attribute__ ((weak))\n+f (TYPE *x, TYPE *y, long n, long m)\n+{\n+  for (int i = 0; i < SIZE; ++i)\n+    x[i * n] += y[i * m];\n+}\n+\n+/* { dg-final { scan-assembler {\\tld1d\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tst1d\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tldr\\tx[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstr\\tx[0-9]+} } } */\n+/* Should multiply by (257-1)*8 rather than (VF-1)*8.  */\n+/* { dg-final { scan-assembler-times {lsl\\tx[0-9]+, x[0-9]+, 11} 2 } } */\n+/* { dg-final { scan-assembler {\\tcmp\\tx[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tw[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+} 4 } } */\n+/* Two range checks and a check for n being zero.  (m being zero is OK.)  */\n+/* { dg-final { scan-assembler {\\tcmp\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */"}, {"sha": "8efaf4b8cdcdbb3fc6f1f57fa28b87b74156cdb8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_6_run.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_6_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_6_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_6_run.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"var_stride_6.c\"\n+#include \"var_stride_1.h\"\n+\n+int\n+main (void)\n+{\n+  for (int n = -10; n < 10; ++n)\n+    for (int m = -10; m < 10; ++m)\n+      for (int offset = -17; offset <= 17; ++offset)\n+\t{\n+\t  test (n, m, offset);\n+\t  test (n, m, offset + n * (SIZE - 1));\n+\t}\n+  return 0;\n+}"}, {"sha": "65e2035475fb26b1b0d5c0d09b9e38127b131f52", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_7.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_7.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TYPE double\n+#define SIZE 257\n+\n+void __attribute__ ((weak))\n+f (TYPE *x, TYPE *y, long n, long m __attribute__((unused)))\n+{\n+  for (int i = 0; i < SIZE; ++i)\n+    x[i * n] += y[i];\n+}\n+\n+/* { dg-final { scan-assembler {\\tld1d\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tst1d\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tldr\\td[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstr\\td[0-9]+} } } */\n+/* Should multiply by (257-1)*8 rather than (VF-1)*8.  */\n+/* { dg-final { scan-assembler-times {\\tadd\\tx[0-9]+, x1, 2048} 1 } } */\n+/* { dg-final { scan-assembler-times {lsl\\tx[0-9]+, x[0-9]+, 11} 1 } } */\n+/* { dg-final { scan-assembler {\\tcmp\\tx[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tw[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+} 2 } } */\n+/* Two range checks and a check for n being zero.  */\n+/* { dg-final { scan-assembler {\\tcmp\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 2 } } */"}, {"sha": "5795145549ad9404e9a9a7ce9b4076fb70fb226b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_7_run.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_7_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_7_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_7_run.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"var_stride_7.c\"\n+#include \"var_stride_1.h\"\n+\n+int\n+main (void)\n+{\n+  for (int n = -10; n < 10; ++n)\n+    for (int offset = -33; offset <= 33; ++offset)\n+      test (n, 1, offset);\n+  return 0;\n+}"}, {"sha": "5224a5f3caae55d530ee349baa8a55737f1cf647", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_8.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_8.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TYPE long\n+#define SIZE 257\n+\n+void\n+f (TYPE *x, TYPE *y, long n __attribute__((unused)), long m)\n+{\n+  for (int i = 0; i < SIZE; ++i)\n+    x[i] += y[i * m];\n+}\n+\n+/* { dg-final { scan-assembler {\\tld1d\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tst1d\\tz[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tldr\\tx[0-9]+} } } */\n+/* { dg-final { scan-assembler {\\tstr\\tx[0-9]+} } } */\n+/* Should multiply by (257-1)*8 rather than (VF-1)*8.  */\n+/* { dg-final { scan-assembler-times {\\tadd\\tx[0-9]+, x0, 2048} 1 } } */\n+/* { dg-final { scan-assembler-times {lsl\\tx[0-9]+, x[0-9]+, 11} 1 } } */\n+/* { dg-final { scan-assembler {\\tcmp\\tx[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-not {\\tcmp\\tw[0-9]+, 0} } } */\n+/* { dg-final { scan-assembler-times {\\tcsel\\tx[0-9]+} 2 } } */\n+/* Two range checks only; doesn't matter whether n is zero.  */\n+/* { dg-final { scan-assembler {\\tcmp\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tccmp\\t} 1 } } */"}, {"sha": "6d4b2a19581461556d91866b8f6caf5ea8e1e47b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/var_stride_8_run.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_8_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_8_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvar_stride_8_run.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do run { target { aarch64_sve_hw } } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"var_stride_8.c\"\n+#include \"var_stride_1.h\"\n+\n+int\n+main (void)\n+{\n+  for (int n = -10; n < 10; ++n)\n+    for (int offset = -33; offset <= 33; ++offset)\n+      test (1, n, offset);\n+  return 0;\n+}"}, {"sha": "ea9ba85de7c6e633fea63ffd3e6a714b0aedcfa4", "filename": "gcc/testsuite/gfortran.dg/vect/vect-alias-check-1.F90", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-alias-check-1.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-alias-check-1.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-alias-check-1.F90?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -0,0 +1,102 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline\" }\n+\n+#define N 200\n+\n+#define TEST_VALUE(I) ((I) * 5 / 2)\n+\n+subroutine setup(a)\n+  real :: a(N)\n+  do i = 1, N\n+     a(i) = TEST_VALUE(i)\n+  end do\n+end subroutine\n+\n+subroutine check(a, x, gap)\n+  real :: a(N), temp, x\n+  integer :: gap\n+  do i = 1, N - gap\n+     temp = a(i + gap) + x\n+     if (a(i) /= temp) call abort\n+  end do\n+  do i = N - gap + 1, N\n+     temp = TEST_VALUE(i)\n+     if (a(i) /= temp) call abort\n+  end do\n+end subroutine\n+\n+subroutine testa(a, x, base, n)\n+  real :: a(n), x\n+  integer :: base, n\n+  do i = n, 2, -1\n+     a(base + i - 1) = a(base + i) + x\n+  end do\n+end subroutine testa\n+\n+subroutine testb(a, x, base, n)\n+  real :: a(n), x\n+  integer :: base\n+  do i = n, 4, -1\n+     a(base + i - 3) = a(base + i) + x\n+  end do\n+end subroutine testb\n+\n+subroutine testc(a, x, base, n)\n+  real :: a(n), x\n+  integer :: base\n+  do i = n, 8, -1\n+     a(base + i - 7) = a(base + i) + x\n+  end do\n+end subroutine testc\n+\n+subroutine testd(a, x, base, n)\n+  real :: a(n), x\n+  integer :: base\n+  do i = n, 16, -1\n+     a(base + i - 15) = a(base + i) + x\n+  end do\n+end subroutine testd\n+\n+subroutine teste(a, x, base, n)\n+  real :: a(n), x\n+  integer :: base\n+  do i = n, 32, -1\n+     a(base + i - 31) = a(base + i) + x\n+  end do\n+end subroutine teste\n+\n+subroutine testf(a, x, base, n)\n+  real :: a(n), x\n+  integer :: base\n+  do i = n, 64, -1\n+     a(base + i - 63) = a(base + i) + x\n+  end do\n+end subroutine testf\n+\n+program main\n+  real :: a(N)\n+\n+  call setup(a)\n+  call testa(a, 91.0, 0, N)\n+  call check(a, 91.0, 1)\n+\n+  call setup(a)\n+  call testb(a, 55.0, 0, N)\n+  call check(a, 55.0, 3)\n+\n+  call setup(a)\n+  call testc(a, 72.0, 0, N)\n+  call check(a, 72.0, 7)\n+\n+  call setup(a)\n+  call testd(a, 69.0, 0, N)\n+  call check(a, 69.0, 15)\n+\n+  call setup(a)\n+  call teste(a, 44.0, 0, N)\n+  call check(a, 44.0, 31)\n+\n+  call setup(a)\n+  call testf(a, 39.0, 0, N)\n+  call check(a, 39.0, 63)\n+end program"}, {"sha": "e39067d71348fbdeebc8a0172823c0a9ae1bafce", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 322, "deletions": 179, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -95,6 +95,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-affine.h\"\n #include \"params.h\"\n #include \"builtins.h\"\n+#include \"stringpool.h\"\n+#include \"tree-vrp.h\"\n+#include \"tree-ssanames.h\"\n \n static struct datadep_stats\n {\n@@ -1305,18 +1308,6 @@ runtime_alias_check_p (ddr_p ddr, struct loop *loop, bool speed_p)\n       return false;\n     }\n \n-  /* FORNOW: We don't support creating runtime alias tests for non-constant\n-     step.  */\n-  if (TREE_CODE (DR_STEP (DDR_A (ddr))) != INTEGER_CST\n-      || TREE_CODE (DR_STEP (DDR_B (ddr))) != INTEGER_CST)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf (MSG_MISSED_OPTIMIZATION,\n-                     \"runtime alias check not supported for non-constant \"\n-\t\t     \"step\\n\");\n-      return false;\n-    }\n-\n   return true;\n }\n \n@@ -1331,11 +1322,13 @@ static bool\n operator == (const dr_with_seg_len& d1,\n \t     const dr_with_seg_len& d2)\n {\n-  return operand_equal_p (DR_BASE_ADDRESS (d1.dr),\n-\t\t\t  DR_BASE_ADDRESS (d2.dr), 0)\n-\t   && data_ref_compare_tree (DR_OFFSET (d1.dr), DR_OFFSET (d2.dr)) == 0\n-\t   && data_ref_compare_tree (DR_INIT (d1.dr), DR_INIT (d2.dr)) == 0\n-\t   && data_ref_compare_tree (d1.seg_len, d2.seg_len) == 0;\n+  return (operand_equal_p (DR_BASE_ADDRESS (d1.dr),\n+\t\t\t   DR_BASE_ADDRESS (d2.dr), 0)\n+\t  && data_ref_compare_tree (DR_OFFSET (d1.dr), DR_OFFSET (d2.dr)) == 0\n+\t  && data_ref_compare_tree (DR_INIT (d1.dr), DR_INIT (d2.dr)) == 0\n+\t  && data_ref_compare_tree (d1.seg_len, d2.seg_len) == 0\n+\t  && known_eq (d1.access_size, d2.access_size)\n+\t  && d1.align == d2.align);\n }\n \n /* Comparison function for sorting objects of dr_with_seg_len_pair_t\n@@ -1415,7 +1408,7 @@ comp_dr_with_seg_len_pair (const void *pa_, const void *pb_)\n \n void\n prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n-\t\t\t       poly_uint64 factor)\n+\t\t\t       poly_uint64)\n {\n   /* Sort the collected data ref pairs so that we can scan them once to\n      combine all possible aliasing checks.  */\n@@ -1461,6 +1454,8 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t    }\n \n \t  poly_int64 init_a1, init_a2;\n+\t  /* Only consider cases in which the distance between the initial\n+\t     DR_A1 and the initial DR_A2 is known at compile time.  */\n \t  if (!operand_equal_p (DR_BASE_ADDRESS (dr_a1->dr),\n \t\t\t\tDR_BASE_ADDRESS (dr_a2->dr), 0)\n \t      || !operand_equal_p (DR_OFFSET (dr_a1->dr),\n@@ -1480,141 +1475,79 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t      std::swap (init_a1, init_a2);\n \t    }\n \n-\t  /* Only merge const step data references.  */\n-\t  poly_int64 step_a1, step_a2;\n-\t  if (!poly_int_tree_p (DR_STEP (dr_a1->dr), &step_a1)\n-\t      || !poly_int_tree_p (DR_STEP (dr_a2->dr), &step_a2))\n-\t    continue;\n+\t  /* Work out what the segment length would be if we did combine\n+\t     DR_A1 and DR_A2:\n \n-\t  bool neg_step = maybe_lt (step_a1, 0) || maybe_lt (step_a2, 0);\n+\t     - If DR_A1 and DR_A2 have equal lengths, that length is\n+\t       also the combined length.\n \n-\t  /* DR_A1 and DR_A2 must go in the same direction.  */\n-\t  if (neg_step && (maybe_gt (step_a1, 0) || maybe_gt (step_a2, 0)))\n-\t    continue;\n+\t     - If DR_A1 and DR_A2 both have negative \"lengths\", the combined\n+\t       length is the lower bound on those lengths.\n \n-\t  poly_uint64 seg_len_a1 = 0, seg_len_a2 = 0;\n-\t  bool const_seg_len_a1 = poly_int_tree_p (dr_a1->seg_len,\n-\t\t\t\t\t\t   &seg_len_a1);\n-\t  bool const_seg_len_a2 = poly_int_tree_p (dr_a2->seg_len,\n-\t\t\t\t\t\t   &seg_len_a2);\n-\n-\t  /* We need to compute merged segment length at compilation time for\n-\t     dr_a1 and dr_a2, which is impossible if either one has non-const\n-\t     segment length.  */\n-\t  if ((!const_seg_len_a1 || !const_seg_len_a2)\n-\t      && maybe_ne (step_a1, step_a2))\n-\t    continue;\n+\t     - If DR_A1 and DR_A2 both have positive lengths, the combined\n+\t       length is the upper bound on those lengths.\n \n-\t  bool do_remove = false;\n-\t  poly_uint64 diff = init_a2 - init_a1;\n-\t  poly_uint64 min_seg_len_b;\n-\t  tree new_seg_len;\n+\t     Other cases are unlikely to give a useful combination.\n \n-\t  if (!poly_int_tree_p (dr_b1->seg_len, &min_seg_len_b))\n+\t     The lengths both have sizetype, so the sign is taken from\n+\t     the step instead.  */\n+\t  if (!operand_equal_p (dr_a1->seg_len, dr_a2->seg_len, 0))\n \t    {\n-\t      tree step_b = DR_STEP (dr_b1->dr);\n-\t      if (!tree_fits_shwi_p (step_b))\n+\t      poly_uint64 seg_len_a1, seg_len_a2;\n+\t      if (!poly_int_tree_p (dr_a1->seg_len, &seg_len_a1)\n+\t\t  || !poly_int_tree_p (dr_a2->seg_len, &seg_len_a2))\n \t\tcontinue;\n-\t      min_seg_len_b = factor * abs_hwi (tree_to_shwi (step_b));\n-\t    }\n-\n-\t  /* Now we try to merge alias check dr_a1 & dr_b and dr_a2 & dr_b.\n-\n-\t     Case A:\n-\t       check if the following condition is satisfied:\n-\n-\t       DIFF - SEGMENT_LENGTH_A < SEGMENT_LENGTH_B\n \n-\t       where DIFF = DR_A2_INIT - DR_A1_INIT.  However,\n-\t       SEGMENT_LENGTH_A or SEGMENT_LENGTH_B may not be constant so we\n-\t       have to make a best estimation.  We can get the minimum value\n-\t       of SEGMENT_LENGTH_B as a constant, represented by MIN_SEG_LEN_B,\n-\t       then either of the following two conditions can guarantee the\n-\t       one above:\n+\t      tree indicator_a = dr_direction_indicator (dr_a1->dr);\n+\t      if (TREE_CODE (indicator_a) != INTEGER_CST)\n+\t\tcontinue;\n \n-\t       1: DIFF <= MIN_SEG_LEN_B\n-\t       2: DIFF - SEGMENT_LENGTH_A < MIN_SEG_LEN_B\n-\t\t  Because DIFF - SEGMENT_LENGTH_A is done in sizetype, we need\n-\t\t  to take care of wrapping behavior in it.\n+\t      tree indicator_b = dr_direction_indicator (dr_a2->dr);\n+\t      if (TREE_CODE (indicator_b) != INTEGER_CST)\n+\t\tcontinue;\n \n-\t     Case B:\n-\t       If the left segment does not extend beyond the start of the\n-\t       right segment the new segment length is that of the right\n-\t       plus the segment distance.  The condition is like:\n+\t      int sign_a = tree_int_cst_sgn (indicator_a);\n+\t      int sign_b = tree_int_cst_sgn (indicator_b);\n \n-\t       DIFF >= SEGMENT_LENGTH_A   ;SEGMENT_LENGTH_A is a constant.\n+\t      poly_uint64 new_seg_len;\n+\t      if (sign_a <= 0 && sign_b <= 0)\n+\t\tnew_seg_len = lower_bound (seg_len_a1, seg_len_a2);\n+\t      else if (sign_a >= 0 && sign_b >= 0)\n+\t\tnew_seg_len = upper_bound (seg_len_a1, seg_len_a2);\n+\t      else\n+\t\tcontinue;\n \n-\t     Note 1: Case A.2 and B combined together effectively merges every\n-\t     dr_a1 & dr_b and dr_a2 & dr_b when SEGMENT_LENGTH_A is const.\n+\t      dr_a1->seg_len = build_int_cst (TREE_TYPE (dr_a1->seg_len),\n+\t\t\t\t\t      new_seg_len);\n+\t      dr_a1->align = MIN (dr_a1->align, known_alignment (new_seg_len));\n+\t    }\n \n-\t     Note 2: Above description is based on positive DR_STEP, we need to\n-\t     take care of negative DR_STEP for wrapping behavior.  See PR80815\n-\t     for more information.  */\n-\t  if (neg_step)\n-\t    {\n-\t      /* Adjust diff according to access size of both references.  */\n-\t      diff += tree_to_poly_uint64\n-\t\t(TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a2->dr))));\n-\t      diff -= tree_to_poly_uint64\n-\t\t(TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a1->dr))));\n-\t      /* Case A.1.  */\n-\t      if (known_le (diff, min_seg_len_b)\n-\t\t  /* Case A.2 and B combined.  */\n-\t\t  || const_seg_len_a2)\n-\t\t{\n-\t\t  if (const_seg_len_a1 || const_seg_len_a2)\n-\t\t    new_seg_len\n-\t\t      = build_int_cstu (sizetype,\n-\t\t\t\t\tlower_bound (seg_len_a1 - diff,\n-\t\t\t\t\t\t     seg_len_a2));\n-\t\t  else\n-\t\t    new_seg_len\n-\t\t      = size_binop (MINUS_EXPR, dr_a2->seg_len,\n-\t\t\t\t    build_int_cstu (sizetype, diff));\n+\t  /* This is always positive due to the swap above.  */\n+\t  poly_uint64 diff = init_a2 - init_a1;\n \n-\t\t  dr_a2->seg_len = new_seg_len;\n-\t\t  do_remove = true;\n-\t\t}\n-\t    }\n-\t  else\n+\t  /* The new check will start at DR_A1.  Make sure that its access\n+\t     size encompasses the initial DR_A2.  */\n+\t  if (maybe_lt (dr_a1->access_size, diff + dr_a2->access_size))\n \t    {\n-\t      /* Case A.1.  */\n-\t      if (known_le (diff, min_seg_len_b)\n-\t\t  /* Case A.2 and B combined.  */\n-\t\t  || const_seg_len_a1)\n-\t\t{\n-\t\t  if (const_seg_len_a1 && const_seg_len_a2)\n-\t\t    new_seg_len\n-\t\t      = build_int_cstu (sizetype,\n-\t\t\t\t\tupper_bound (seg_len_a2 + diff,\n-\t\t\t\t\t\t     seg_len_a1));\n-\t\t  else\n-\t\t    new_seg_len\n-\t\t      = size_binop (PLUS_EXPR, dr_a2->seg_len,\n-\t\t\t\t    build_int_cstu (sizetype, diff));\n-\n-\t\t  dr_a1->seg_len = new_seg_len;\n-\t\t  do_remove = true;\n-\t\t}\n+\t      dr_a1->access_size = upper_bound (dr_a1->access_size,\n+\t\t\t\t\t\tdiff + dr_a2->access_size);\n+\t      unsigned int new_align = known_alignment (dr_a1->access_size);\n+\t      dr_a1->align = MIN (dr_a1->align, new_align);\n \t    }\n-\n-\t  if (do_remove)\n+\t  if (dump_enabled_p ())\n \t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf (MSG_NOTE, \"merging ranges for \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a1->dr));\n-\t\t  dump_printf (MSG_NOTE,  \", \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b1->dr));\n-\t\t  dump_printf (MSG_NOTE,  \" and \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a2->dr));\n-\t\t  dump_printf (MSG_NOTE,  \", \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));\n-\t\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n-\t      alias_pairs->ordered_remove (neg_step ? i - 1 : i);\n-\t      i--;\n+\t      dump_printf (MSG_NOTE, \"merging ranges for \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a1->dr));\n+\t      dump_printf (MSG_NOTE,  \", \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b1->dr));\n+\t      dump_printf (MSG_NOTE,  \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a2->dr));\n+\t      dump_printf (MSG_NOTE,  \", \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n+\t  alias_pairs->ordered_remove (i);\n+\t  i--;\n \t}\n     }\n }\n@@ -1654,7 +1587,9 @@ create_intersect_range_checks_index (struct loop *loop, tree *cond_expr,\n       || DR_NUM_DIMENSIONS (dr_a.dr) != DR_NUM_DIMENSIONS (dr_b.dr))\n     return false;\n \n-  if (!tree_fits_uhwi_p (dr_a.seg_len) || !tree_fits_uhwi_p (dr_b.seg_len))\n+  poly_uint64 seg_len1, seg_len2;\n+  if (!poly_int_tree_p (dr_a.seg_len, &seg_len1)\n+      || !poly_int_tree_p (dr_b.seg_len, &seg_len2))\n     return false;\n \n   if (!tree_fits_shwi_p (DR_STEP (dr_a.dr)))\n@@ -1669,19 +1604,42 @@ create_intersect_range_checks_index (struct loop *loop, tree *cond_expr,\n   gcc_assert (TREE_CODE (DR_STEP (dr_a.dr)) == INTEGER_CST);\n \n   bool neg_step = tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0;\n-  unsigned HOST_WIDE_INT abs_step\n-    = absu_hwi (tree_to_shwi (DR_STEP (dr_a.dr)));\n+  unsigned HOST_WIDE_INT abs_step = tree_to_shwi (DR_STEP (dr_a.dr));\n+  if (neg_step)\n+    {\n+      abs_step = -abs_step;\n+      seg_len1 = -seg_len1;\n+      seg_len2 = -seg_len2;\n+    }\n+  else\n+    {\n+      /* Include the access size in the length, so that we only have one\n+\t tree addition below.  */\n+      seg_len1 += dr_a.access_size;\n+      seg_len2 += dr_b.access_size;\n+    }\n \n-  unsigned HOST_WIDE_INT seg_len1 = tree_to_uhwi (dr_a.seg_len);\n-  unsigned HOST_WIDE_INT seg_len2 = tree_to_uhwi (dr_b.seg_len);\n   /* Infer the number of iterations with which the memory segment is accessed\n      by DR.  In other words, alias is checked if memory segment accessed by\n      DR_A in some iterations intersect with memory segment accessed by DR_B\n      in the same amount iterations.\n      Note segnment length is a linear function of number of iterations with\n      DR_STEP as the coefficient.  */\n-  unsigned HOST_WIDE_INT niter_len1 = (seg_len1 + abs_step - 1) / abs_step;\n-  unsigned HOST_WIDE_INT niter_len2 = (seg_len2 + abs_step - 1) / abs_step;\n+  poly_uint64 niter_len1, niter_len2;\n+  if (!can_div_trunc_p (seg_len1 + abs_step - 1, abs_step, &niter_len1)\n+      || !can_div_trunc_p (seg_len2 + abs_step - 1, abs_step, &niter_len2))\n+    return false;\n+\n+  poly_uint64 niter_access1 = 0, niter_access2 = 0;\n+  if (neg_step)\n+    {\n+      /* Divide each access size by the byte step, rounding up.  */\n+      if (!can_div_trunc_p (dr_a.access_size - abs_step - 1,\n+\t\t\t    abs_step, &niter_access1)\n+\t  || !can_div_trunc_p (dr_b.access_size + abs_step - 1,\n+\t\t\t       abs_step, &niter_access2))\n+\treturn false;\n+    }\n \n   unsigned int i;\n   for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n@@ -1732,12 +1690,22 @@ create_intersect_range_checks_index (struct loop *loop, tree *cond_expr,\n       /* Adjust ranges for negative step.  */\n       if (neg_step)\n \t{\n-\t  min1 = fold_build2 (MINUS_EXPR, TREE_TYPE (min1), max1, idx_step);\n-\t  max1 = fold_build2 (MINUS_EXPR, TREE_TYPE (min1),\n-\t\t\t      CHREC_LEFT (access1), idx_step);\n-\t  min2 = fold_build2 (MINUS_EXPR, TREE_TYPE (min2), max2, idx_step);\n-\t  max2 = fold_build2 (MINUS_EXPR, TREE_TYPE (min2),\n-\t\t\t      CHREC_LEFT (access2), idx_step);\n+\t  /* IDX_LEN1 and IDX_LEN2 are negative in this case.  */\n+\t  std::swap (min1, max1);\n+\t  std::swap (min2, max2);\n+\n+\t  /* As with the lengths just calculated, we've measured the access\n+\t     sizes in iterations, so multiply them by the index step.  */\n+\t  tree idx_access1\n+\t    = fold_build2 (MULT_EXPR, TREE_TYPE (min1), idx_step,\n+\t\t\t   build_int_cst (TREE_TYPE (min1), niter_access1));\n+\t  tree idx_access2\n+\t    = fold_build2 (MULT_EXPR, TREE_TYPE (min2), idx_step,\n+\t\t\t   build_int_cst (TREE_TYPE (min2), niter_access2));\n+\n+\t  /* MINUS_EXPR because the above values are negative.  */\n+\t  max1 = fold_build2 (MINUS_EXPR, TREE_TYPE (max1), max1, idx_access1);\n+\t  max2 = fold_build2 (MINUS_EXPR, TREE_TYPE (max2), max2, idx_access2);\n \t}\n       tree part_cond_expr\n \t= fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n@@ -1752,6 +1720,89 @@ create_intersect_range_checks_index (struct loop *loop, tree *cond_expr,\n   return true;\n }\n \n+/* If ALIGN is nonzero, set up *SEQ_MIN_OUT and *SEQ_MAX_OUT so that for\n+   every address ADDR accessed by D:\n+\n+     *SEQ_MIN_OUT <= ADDR (== ADDR & -ALIGN) <= *SEQ_MAX_OUT\n+\n+   In this case, every element accessed by D is aligned to at least\n+   ALIGN bytes.\n+\n+   If ALIGN is zero then instead set *SEG_MAX_OUT so that:\n+\n+     *SEQ_MIN_OUT <= ADDR < *SEQ_MAX_OUT.  */\n+\n+static void\n+get_segment_min_max (const dr_with_seg_len &d, tree *seg_min_out,\n+\t\t     tree *seg_max_out, HOST_WIDE_INT align)\n+{\n+  /* Each access has the following pattern:\n+\n+\t  <- |seg_len| ->\n+\t  <--- A: -ve step --->\n+\t  +-----+-------+-----+-------+-----+\n+\t  | n-1 | ,.... |  0  | ..... | n-1 |\n+\t  +-----+-------+-----+-------+-----+\n+\t\t\t<--- B: +ve step --->\n+\t\t\t<- |seg_len| ->\n+\t\t\t|\n+\t\t   base address\n+\n+     where \"n\" is the number of scalar iterations covered by the segment.\n+     (This should be VF for a particular pair if we know that both steps\n+     are the same, otherwise it will be the full number of scalar loop\n+     iterations.)\n+\n+     A is the range of bytes accessed when the step is negative,\n+     B is the range when the step is positive.\n+\n+     If the access size is \"access_size\" bytes, the lowest addressed byte is:\n+\n+\t base + (step < 0 ? seg_len : 0)   [LB]\n+\n+     and the highest addressed byte is always below:\n+\n+\t base + (step < 0 ? 0 : seg_len) + access_size   [UB]\n+\n+     Thus:\n+\n+\t LB <= ADDR < UB\n+\n+     If ALIGN is nonzero, all three values are aligned to at least ALIGN\n+     bytes, so:\n+\n+\t LB <= ADDR <= UB - ALIGN\n+\n+     where \"- ALIGN\" folds naturally with the \"+ access_size\" and often\n+     cancels it out.\n+\n+     We don't try to simplify LB and UB beyond this (e.g. by using\n+     MIN and MAX based on whether seg_len rather than the stride is\n+     negative) because it is possible for the absolute size of the\n+     segment to overflow the range of a ssize_t.\n+\n+     Keeping the pointer_plus outside of the cond_expr should allow\n+     the cond_exprs to be shared with other alias checks.  */\n+  tree indicator = dr_direction_indicator (d.dr);\n+  tree neg_step = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t       fold_convert (ssizetype, indicator),\n+\t\t\t       ssize_int (0));\n+  tree addr_base = fold_build_pointer_plus (DR_BASE_ADDRESS (d.dr),\n+\t\t\t\t\t    DR_OFFSET (d.dr));\n+  addr_base = fold_build_pointer_plus (addr_base, DR_INIT (d.dr));\n+  tree seg_len = fold_convert (sizetype, d.seg_len);\n+\n+  tree min_reach = fold_build3 (COND_EXPR, sizetype, neg_step,\n+\t\t\t\tseg_len, size_zero_node);\n+  tree max_reach = fold_build3 (COND_EXPR, sizetype, neg_step,\n+\t\t\t\tsize_zero_node, seg_len);\n+  max_reach = fold_build2 (PLUS_EXPR, sizetype, max_reach,\n+\t\t\t   size_int (d.access_size - align));\n+\n+  *seg_min_out = fold_build_pointer_plus (addr_base, min_reach);\n+  *seg_max_out = fold_build_pointer_plus (addr_base, max_reach);\n+}\n+\n /* Given two data references and segment lengths described by DR_A and DR_B,\n    create expression checking if the two addresses ranges intersect with\n    each other:\n@@ -1768,43 +1819,48 @@ create_intersect_range_checks (struct loop *loop, tree *cond_expr,\n   if (create_intersect_range_checks_index (loop, cond_expr, dr_a, dr_b))\n     return;\n \n-  tree segment_length_a = dr_a.seg_len;\n-  tree segment_length_b = dr_b.seg_len;\n-  tree addr_base_a = DR_BASE_ADDRESS (dr_a.dr);\n-  tree addr_base_b = DR_BASE_ADDRESS (dr_b.dr);\n-  tree offset_a = DR_OFFSET (dr_a.dr), offset_b = DR_OFFSET (dr_b.dr);\n-\n-  offset_a = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_a),\n-\t\t\t  offset_a, DR_INIT (dr_a.dr));\n-  offset_b = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_b),\n-\t\t\t  offset_b, DR_INIT (dr_b.dr));\n-  addr_base_a = fold_build_pointer_plus (addr_base_a, offset_a);\n-  addr_base_b = fold_build_pointer_plus (addr_base_b, offset_b);\n-\n-  tree seg_a_min = addr_base_a;\n-  tree seg_a_max = fold_build_pointer_plus (addr_base_a, segment_length_a);\n-  /* For negative step, we need to adjust address range by TYPE_SIZE_UNIT\n-     bytes, e.g., int a[3] -> a[1] range is [a+4, a+16) instead of\n-     [a, a+12) */\n-  if (tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0)\n+  unsigned HOST_WIDE_INT min_align;\n+  tree_code cmp_code;\n+  if (TREE_CODE (DR_STEP (dr_a.dr)) == INTEGER_CST\n+      && TREE_CODE (DR_STEP (dr_b.dr)) == INTEGER_CST)\n     {\n-      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a.dr)));\n-      seg_a_min = fold_build_pointer_plus (seg_a_max, unit_size);\n-      seg_a_max = fold_build_pointer_plus (addr_base_a, unit_size);\n+      /* In this case adding access_size to seg_len is likely to give\n+\t a simple X * step, where X is either the number of scalar\n+\t iterations or the vectorization factor.  We're better off\n+\t keeping that, rather than subtracting an alignment from it.\n+\n+\t In this case the maximum values are exclusive and so there is\n+\t no alias if the maximum of one segment equals the minimum\n+\t of another.  */\n+      min_align = 0;\n+      cmp_code = LE_EXPR;\n     }\n-\n-  tree seg_b_min = addr_base_b;\n-  tree seg_b_max = fold_build_pointer_plus (addr_base_b, segment_length_b);\n-  if (tree_int_cst_compare (DR_STEP (dr_b.dr), size_zero_node) < 0)\n+  else\n     {\n-      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_b.dr)));\n-      seg_b_min = fold_build_pointer_plus (seg_b_max, unit_size);\n-      seg_b_max = fold_build_pointer_plus (addr_base_b, unit_size);\n+      /* Calculate the minimum alignment shared by all four pointers,\n+\t then arrange for this alignment to be subtracted from the\n+\t exclusive maximum values to get inclusive maximum values.\n+\t This \"- min_align\" is cumulative with a \"+ access_size\"\n+\t in the calculation of the maximum values.  In the best\n+\t (and common) case, the two cancel each other out, leaving\n+\t us with an inclusive bound based only on seg_len.  In the\n+\t worst case we're simply adding a smaller number than before.\n+\n+\t Because the maximum values are inclusive, there is an alias\n+\t if the maximum value of one segment is equal to the minimum\n+\t value of the other.  */\n+      min_align = MIN (dr_a.align, dr_b.align);\n+      cmp_code = LT_EXPR;\n     }\n+\n+  tree seg_a_min, seg_a_max, seg_b_min, seg_b_max;\n+  get_segment_min_max (dr_a, &seg_a_min, &seg_a_max, min_align);\n+  get_segment_min_max (dr_b, &seg_b_min, &seg_b_max, min_align);\n+\n   *cond_expr\n     = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\tfold_build2 (LE_EXPR, boolean_type_node, seg_a_max, seg_b_min),\n-\tfold_build2 (LE_EXPR, boolean_type_node, seg_b_max, seg_a_min));\n+\tfold_build2 (cmp_code, boolean_type_node, seg_a_max, seg_b_min),\n+\tfold_build2 (cmp_code, boolean_type_node, seg_b_max, seg_a_min));\n }\n \n /* Create a conditional expression that represents the run-time checks for\n@@ -5271,3 +5327,90 @@ free_data_refs (vec<data_reference_p> datarefs)\n     free_data_ref (dr);\n   datarefs.release ();\n }\n+\n+/* Common routine implementing both dr_direction_indicator and\n+   dr_zero_step_indicator.  Return USEFUL_MIN if the indicator is known\n+   to be >= USEFUL_MIN and -1 if the indicator is known to be negative.\n+   Return the step as the indicator otherwise.  */\n+\n+static tree\n+dr_step_indicator (struct data_reference *dr, int useful_min)\n+{\n+  tree step = DR_STEP (dr);\n+  STRIP_NOPS (step);\n+  /* Look for cases where the step is scaled by a positive constant\n+     integer, which will often be the access size.  If the multiplication\n+     doesn't change the sign (due to overflow effects) then we can\n+     test the unscaled value instead.  */\n+  if (TREE_CODE (step) == MULT_EXPR\n+      && TREE_CODE (TREE_OPERAND (step, 1)) == INTEGER_CST\n+      && tree_int_cst_sgn (TREE_OPERAND (step, 1)) > 0)\n+    {\n+      tree factor = TREE_OPERAND (step, 1);\n+      step = TREE_OPERAND (step, 0);\n+\n+      /* Strip widening and truncating conversions as well as nops.  */\n+      if (CONVERT_EXPR_P (step)\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (step, 0))))\n+\tstep = TREE_OPERAND (step, 0);\n+      tree type = TREE_TYPE (step);\n+\n+      /* Get the range of step values that would not cause overflow.  */\n+      widest_int minv = (wi::to_widest (TYPE_MIN_VALUE (ssizetype))\n+\t\t\t / wi::to_widest (factor));\n+      widest_int maxv = (wi::to_widest (TYPE_MAX_VALUE (ssizetype))\n+\t\t\t / wi::to_widest (factor));\n+\n+      /* Get the range of values that the unconverted step actually has.  */\n+      wide_int step_min, step_max;\n+      if (TREE_CODE (step) != SSA_NAME\n+\t  || get_range_info (step, &step_min, &step_max) != VR_RANGE)\n+\t{\n+\t  step_min = wi::to_wide (TYPE_MIN_VALUE (type));\n+\t  step_max = wi::to_wide (TYPE_MAX_VALUE (type));\n+\t}\n+\n+      /* Check whether the unconverted step has an acceptable range.  */\n+      signop sgn = TYPE_SIGN (type);\n+      if (wi::les_p (minv, widest_int::from (step_min, sgn))\n+\t  && wi::ges_p (maxv, widest_int::from (step_max, sgn)))\n+\t{\n+\t  if (wi::ge_p (step_min, useful_min, sgn))\n+\t    return ssize_int (useful_min);\n+\t  else if (wi::lt_p (step_max, 0, sgn))\n+\t    return ssize_int (-1);\n+\t  else\n+\t    return fold_convert (ssizetype, step);\n+\t}\n+    }\n+  return DR_STEP (dr);\n+}\n+\n+/* Return a value that is negative iff DR has a negative step.  */\n+\n+tree\n+dr_direction_indicator (struct data_reference *dr)\n+{\n+  return dr_step_indicator (dr, 0);\n+}\n+\n+/* Return a value that is zero iff DR has a zero step.  */\n+\n+tree\n+dr_zero_step_indicator (struct data_reference *dr)\n+{\n+  return dr_step_indicator (dr, 1);\n+}\n+\n+/* Return true if DR is known to have a nonnegative (but possibly zero)\n+   step.  */\n+\n+bool\n+dr_known_forward_stride_p (struct data_reference *dr)\n+{\n+  tree indicator = dr_direction_indicator (dr);\n+  tree neg_step_val = fold_binary (LT_EXPR, boolean_type_node,\n+\t\t\t\t   fold_convert (ssizetype, indicator),\n+\t\t\t\t   ssize_int (0));\n+  return neg_step_val && integer_zerop (neg_step_val);\n+}"}, {"sha": "63094a7b64efe8232c96c37e79683f27a730f55d", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -203,11 +203,20 @@ typedef struct data_reference *data_reference_p;\n \n struct dr_with_seg_len\n {\n-  dr_with_seg_len (data_reference_p d, tree len)\n-    : dr (d), seg_len (len) {}\n+  dr_with_seg_len (data_reference_p d, tree len, unsigned HOST_WIDE_INT size,\n+\t\t   unsigned int a)\n+    : dr (d), seg_len (len), access_size (size), align (a) {}\n \n   data_reference_p dr;\n+  /* The offset of the last access that needs to be checked minus\n+     the offset of the first.  */\n   tree seg_len;\n+  /* A value that, when added to abs (SEG_LEN), gives the total number of\n+     bytes in the segment.  */\n+  poly_uint64 access_size;\n+  /* The minimum common alignment of DR's start address, SEG_LEN and\n+     ACCESS_SIZE.  */\n+  unsigned int align;\n };\n \n /* This struct contains two dr_with_seg_len objects with aliasing data\n@@ -475,6 +484,10 @@ extern void prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *,\n \t\t\t\t\t   poly_uint64);\n extern void create_runtime_alias_checks (struct loop *,\n \t\t\t\t\t vec<dr_with_seg_len_pair_t> *, tree*);\n+extern tree dr_direction_indicator (struct data_reference *);\n+extern tree dr_zero_step_indicator (struct data_reference *);\n+extern bool dr_known_forward_stride_p (struct data_reference *);\n+\n /* Return true when the base objects of data references A and B are\n    the same memory object.  */\n "}, {"sha": "a3d76e419586efcca81628a6fde44db981b96ba8", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -2330,16 +2330,12 @@ break_alias_scc_partitions (struct graph *rdg,\n static tree\n data_ref_segment_size (struct data_reference *dr, tree niters)\n {\n-  tree segment_length;\n-\n-  if (integer_zerop (DR_STEP (dr)))\n-    segment_length = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n-  else\n-    segment_length = size_binop (MULT_EXPR,\n-\t\t\t\t fold_convert (sizetype, DR_STEP (dr)),\n-\t\t\t\t fold_convert (sizetype, niters));\n-\n-  return segment_length;\n+  niters = size_binop (MINUS_EXPR,\n+\t\t       fold_convert (sizetype, niters),\n+\t\t       size_one_node);\n+  return size_binop (MULT_EXPR,\n+\t\t     fold_convert (sizetype, DR_STEP (dr)),\n+\t\t     fold_convert (sizetype, niters));\n }\n \n /* Return true if LOOP's latch is dominated by statement for data reference\n@@ -2394,9 +2390,16 @@ compute_alias_check_pairs (struct loop *loop, vec<ddr_p> *alias_ddrs,\n       else\n \tseg_length_b = data_ref_segment_size (dr_b, niters);\n \n+      unsigned HOST_WIDE_INT access_size_a\n+\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a))));\n+      unsigned HOST_WIDE_INT access_size_b\n+\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_b))));\n+      unsigned int align_a = TYPE_ALIGN_UNIT (TREE_TYPE (DR_REF (dr_a)));\n+      unsigned int align_b = TYPE_ALIGN_UNIT (TREE_TYPE (DR_REF (dr_b)));\n+\n       dr_with_seg_len_pair_t dr_with_seg_len_pair\n-\t  (dr_with_seg_len (dr_a, seg_length_a),\n-\t   dr_with_seg_len (dr_b, seg_length_b));\n+\t(dr_with_seg_len (dr_a, seg_length_a, access_size_a, align_a),\n+\t dr_with_seg_len (dr_b, seg_length_b, access_size_b, align_b));\n \n       /* Canonicalize pairs by sorting the two DR members.  */\n       if (comp_res > 0)"}, {"sha": "684b7c587eae43ecb3fcf80d2268809e32b18d3e", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 320, "deletions": 45, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -169,6 +169,50 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n   return true;\n }\n \n+/* Record that loop LOOP_VINFO needs to check that VALUE is nonzero.  */\n+\n+static void\n+vect_check_nonzero_value (loop_vec_info loop_vinfo, tree value)\n+{\n+  vec<tree> checks = LOOP_VINFO_CHECK_NONZERO (loop_vinfo);\n+  for (unsigned int i = 0; i < checks.length(); ++i)\n+    if (checks[i] == value)\n+      return;\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"need run-time check that \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, value);\n+      dump_printf (MSG_NOTE, \" is nonzero\\n\");\n+    }\n+  LOOP_VINFO_CHECK_NONZERO (loop_vinfo).safe_push (value);\n+}\n+\n+/* Return true if we know that the order of vectorized STMT_A and\n+   vectorized STMT_B will be the same as the order of STMT_A and STMT_B.\n+   At least one of the statements is a write.  */\n+\n+static bool\n+vect_preserves_scalar_order_p (gimple *stmt_a, gimple *stmt_b)\n+{\n+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (stmt_a);\n+  stmt_vec_info stmtinfo_b = vinfo_for_stmt (stmt_b);\n+\n+  /* Single statements are always kept in their original order.  */\n+  if (!STMT_VINFO_GROUPED_ACCESS (stmtinfo_a)\n+      && !STMT_VINFO_GROUPED_ACCESS (stmtinfo_b))\n+    return true;\n+\n+  /* STMT_A and STMT_B belong to overlapping groups.  All loads in a\n+     group are emitted at the position of the first scalar load and all\n+     stores in a group are emitted at the position of the last scalar store.\n+     Thus writes will happen no earlier than their current position\n+     (but could happen later) while reads will happen no later than their\n+     current position (but could happen earlier).  Reordering is therefore\n+     only possible if the first access is a write.  */\n+  gimple *earlier_stmt = get_earlier_stmt (stmt_a, stmt_b);\n+  return !DR_IS_WRITE (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt)));\n+}\n \n /* A subroutine of vect_analyze_data_ref_dependence.  Handle\n    DDR_COULD_BE_INDEPENDENT_P ddr DDR that has a known set of dependence\n@@ -414,22 +458,27 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t\t... = a[i];\n \t\ta[i+1] = ...;\n \t     where loads from the group interleave with the store.  */\n-\t  if (STMT_VINFO_GROUPED_ACCESS (stmtinfo_a)\n-\t      || STMT_VINFO_GROUPED_ACCESS (stmtinfo_b))\n+\t  if (!vect_preserves_scalar_order_p (DR_STMT (dra), DR_STMT (drb)))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"READ_WRITE dependence in interleaving.\\n\");\n+\t      return true;\n+\t    }\n+\n+\t  if (!loop->force_vectorize)\n \t    {\n-\t      gimple *earlier_stmt;\n-\t      earlier_stmt = get_earlier_stmt (DR_STMT (dra), DR_STMT (drb));\n-\t      if (DR_IS_WRITE\n-\t\t    (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt))))\n+\t      tree indicator = dr_zero_step_indicator (dra);\n+\t      if (TREE_CODE (indicator) != INTEGER_CST)\n+\t\tvect_check_nonzero_value (loop_vinfo, indicator);\n+\t      else if (integer_zerop (indicator))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"READ_WRITE dependence in interleaving.\"\n-\t\t\t\t     \"\\n\");\n+\t\t\t\t \"access also has a zero step\\n\");\n \t\t  return true;\n \t\t}\n \t    }\n-\n \t  continue;\n \t}\n \n@@ -3030,52 +3079,73 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \n /* Function vect_vfa_segment_size.\n \n-   Create an expression that computes the size of segment\n-   that will be accessed for a data reference.  The functions takes into\n-   account that realignment loads may access one more vector.\n-\n    Input:\n      DR: The data reference.\n      LENGTH_FACTOR: segment length to consider.\n \n-   Return an expression whose value is the size of segment which will be\n-   accessed by DR.  */\n+   Return a value suitable for the dr_with_seg_len::seg_len field.\n+   This is the \"distance travelled\" by the pointer from the first\n+   iteration in the segment to the last.  Note that it does not include\n+   the size of the access; in effect it only describes the first byte.  */\n \n static tree\n vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n {\n-  tree segment_length;\n+  length_factor = size_binop (MINUS_EXPR,\n+\t\t\t      fold_convert (sizetype, length_factor),\n+\t\t\t      size_one_node);\n+  return size_binop (MULT_EXPR, fold_convert (sizetype, DR_STEP (dr)),\n+\t\t     length_factor);\n+}\n \n-  if (integer_zerop (DR_STEP (dr)))\n-    segment_length = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n-  else\n-    segment_length = size_binop (MULT_EXPR,\n-\t\t\t\t fold_convert (sizetype, DR_STEP (dr)),\n-\t\t\t\t fold_convert (sizetype, length_factor));\n+/* Return a value that, when added to abs (vect_vfa_segment_size (dr)),\n+   gives the worst-case number of bytes covered by the segment.  */\n \n-  if (vect_supportable_dr_alignment (dr, false)\n-\t== dr_explicit_realign_optimized)\n+static unsigned HOST_WIDE_INT\n+vect_vfa_access_size (data_reference *dr)\n+{\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (DR_STMT (dr));\n+  tree ref_type = TREE_TYPE (DR_REF (dr));\n+  unsigned HOST_WIDE_INT ref_size = tree_to_uhwi (TYPE_SIZE_UNIT (ref_type));\n+  unsigned HOST_WIDE_INT access_size = ref_size;\n+  if (GROUP_FIRST_ELEMENT (stmt_vinfo))\n     {\n-      tree vector_size = TYPE_SIZE_UNIT\n-\t\t\t  (STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr))));\n-\n-      segment_length = size_binop (PLUS_EXPR, segment_length, vector_size);\n+      gcc_assert (GROUP_FIRST_ELEMENT (stmt_vinfo) == DR_STMT (dr));\n+      access_size *= GROUP_SIZE (stmt_vinfo) - GROUP_GAP (stmt_vinfo);\n+    }\n+  if (STMT_VINFO_VEC_STMT (stmt_vinfo)\n+      && (vect_supportable_dr_alignment (dr, false)\n+\t  == dr_explicit_realign_optimized))\n+    {\n+      /* We might access a full vector's worth.  */\n+      tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n+      access_size += tree_to_uhwi (TYPE_SIZE_UNIT (vectype)) - ref_size;\n     }\n-  return segment_length;\n+  return access_size;\n+}\n+\n+/* Get the minimum alignment for all the scalar accesses that DR describes.  */\n+\n+static unsigned int\n+vect_vfa_align (const data_reference *dr)\n+{\n+  return TYPE_ALIGN_UNIT (TREE_TYPE (DR_REF (dr)));\n }\n \n /* Function vect_no_alias_p.\n \n    Given data references A and B with equal base and offset, see whether\n    the alias relation can be decided at compilation time.  Return 1 if\n    it can and the references alias, 0 if it can and the references do\n-   not alias, and -1 if we cannot decide at compile time.  SEGMENT_LENGTH_A\n-   and SEGMENT_LENGTH_B are the memory lengths accessed by A and B\n-   respectively.  */\n+   not alias, and -1 if we cannot decide at compile time.  SEGMENT_LENGTH_A,\n+   SEGMENT_LENGTH_B, ACCESS_SIZE_A and ACCESS_SIZE_B are the equivalent\n+   of dr_with_seg_len::{seg_len,access_size} for A and B.  */\n \n static int\n vect_compile_time_alias (struct data_reference *a, struct data_reference *b,\n-\t\t\t tree segment_length_a, tree segment_length_b)\n+\t\t\t tree segment_length_a, tree segment_length_b,\n+\t\t\t unsigned HOST_WIDE_INT access_size_a,\n+\t\t\t unsigned HOST_WIDE_INT access_size_b)\n {\n   poly_offset_int offset_a = wi::to_poly_offset (DR_INIT (a));\n   poly_offset_int offset_b = wi::to_poly_offset (DR_INIT (b));\n@@ -3088,18 +3158,21 @@ vect_compile_time_alias (struct data_reference *a, struct data_reference *b,\n   if (tree_int_cst_compare (DR_STEP (a), size_zero_node) < 0)\n     {\n       const_length_a = (-wi::to_poly_wide (segment_length_a)).force_uhwi ();\n-      offset_a = (offset_a + vect_get_scalar_dr_size (a)) - const_length_a;\n+      offset_a = (offset_a + access_size_a) - const_length_a;\n     }\n   else\n     const_length_a = tree_to_poly_uint64 (segment_length_a);\n   if (tree_int_cst_compare (DR_STEP (b), size_zero_node) < 0)\n     {\n       const_length_b = (-wi::to_poly_wide (segment_length_b)).force_uhwi ();\n-      offset_b = (offset_b + vect_get_scalar_dr_size (b)) - const_length_b;\n+      offset_b = (offset_b + access_size_b) - const_length_b;\n     }\n   else\n     const_length_b = tree_to_poly_uint64 (segment_length_b);\n \n+  const_length_a += access_size_a;\n+  const_length_b += access_size_b;\n+\n   if (ranges_known_overlap_p (offset_a, const_length_a,\n \t\t\t      offset_b, const_length_b))\n     return 1;\n@@ -3149,6 +3222,108 @@ dependence_distance_ge_vf (data_dependence_relation *ddr,\n   return true;\n }\n \n+/* Dump LOWER_BOUND using flags DUMP_KIND.  Dumps are known to be enabled.  */\n+\n+static void\n+dump_lower_bound (int dump_kind, const vec_lower_bound &lower_bound)\n+{\n+  dump_printf (dump_kind, \"%s (\", lower_bound.unsigned_p ? \"unsigned\" : \"abs\");\n+  dump_generic_expr (dump_kind, TDF_SLIM, lower_bound.expr);\n+  dump_printf (dump_kind, \") >= \");\n+  dump_dec (dump_kind, lower_bound.min_value);\n+}\n+\n+/* Record that the vectorized loop requires the vec_lower_bound described\n+   by EXPR, UNSIGNED_P and MIN_VALUE.  */\n+\n+static void\n+vect_check_lower_bound (loop_vec_info loop_vinfo, tree expr, bool unsigned_p,\n+\t\t\tpoly_uint64 min_value)\n+{\n+  vec<vec_lower_bound> lower_bounds = LOOP_VINFO_LOWER_BOUNDS (loop_vinfo);\n+  for (unsigned int i = 0; i < lower_bounds.length (); ++i)\n+    if (operand_equal_p (lower_bounds[i].expr, expr, 0))\n+      {\n+\tunsigned_p &= lower_bounds[i].unsigned_p;\n+\tmin_value = upper_bound (lower_bounds[i].min_value, min_value);\n+\tif (lower_bounds[i].unsigned_p != unsigned_p\n+\t    || maybe_lt (lower_bounds[i].min_value, min_value))\n+\t  {\n+\t    lower_bounds[i].unsigned_p = unsigned_p;\n+\t    lower_bounds[i].min_value = min_value;\n+\t    if (dump_enabled_p ())\n+\t      {\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"updating run-time check to \");\n+\t\tdump_lower_bound (MSG_NOTE, lower_bounds[i]);\n+\t\tdump_printf (MSG_NOTE, \"\\n\");\n+\t      }\n+\t  }\n+\treturn;\n+      }\n+\n+  vec_lower_bound lower_bound (expr, unsigned_p, min_value);\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"need a run-time check that \");\n+      dump_lower_bound (MSG_NOTE, lower_bound);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+  LOOP_VINFO_LOWER_BOUNDS (loop_vinfo).safe_push (lower_bound);\n+}\n+\n+/* Return true if it's unlikely that the step of the vectorized form of DR\n+   will span fewer than GAP bytes.  */\n+\n+static bool\n+vect_small_gap_p (loop_vec_info loop_vinfo, data_reference *dr, poly_int64 gap)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n+  HOST_WIDE_INT count\n+    = estimated_poly_value (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n+  if (GROUP_FIRST_ELEMENT (stmt_info))\n+    count *= GROUP_SIZE (vinfo_for_stmt (GROUP_FIRST_ELEMENT (stmt_info)));\n+  return estimated_poly_value (gap) <= count * vect_get_scalar_dr_size (dr);\n+}\n+\n+/* Return true if we know that there is no alias between DR_A and DR_B\n+   when abs (DR_STEP (DR_A)) >= N for some N.  When returning true, set\n+   *LOWER_BOUND_OUT to this N.  */\n+\n+static bool\n+vectorizable_with_step_bound_p (data_reference *dr_a, data_reference *dr_b,\n+\t\t\t\tpoly_uint64 *lower_bound_out)\n+{\n+  /* Check that there is a constant gap of known sign between DR_A\n+     and DR_B.  */\n+  poly_int64 init_a, init_b;\n+  if (!operand_equal_p (DR_BASE_ADDRESS (dr_a), DR_BASE_ADDRESS (dr_b), 0)\n+      || !operand_equal_p (DR_OFFSET (dr_a), DR_OFFSET (dr_b), 0)\n+      || !operand_equal_p (DR_STEP (dr_a), DR_STEP (dr_b), 0)\n+      || !poly_int_tree_p (DR_INIT (dr_a), &init_a)\n+      || !poly_int_tree_p (DR_INIT (dr_b), &init_b)\n+      || !ordered_p (init_a, init_b))\n+    return false;\n+\n+  /* Sort DR_A and DR_B by the address they access.  */\n+  if (maybe_lt (init_b, init_a))\n+    {\n+      std::swap (init_a, init_b);\n+      std::swap (dr_a, dr_b);\n+    }\n+\n+  /* If the two accesses could be dependent within a scalar iteration,\n+     make sure that we'd retain their order.  */\n+  if (maybe_gt (init_a + vect_get_scalar_dr_size (dr_a), init_b)\n+      && !vect_preserves_scalar_order_p (DR_STMT (dr_a), DR_STMT (dr_b)))\n+    return false;\n+\n+  /* There is no alias if abs (DR_STEP) is greater than or equal to\n+     the bytes spanned by the combination of the two accesses.  */\n+  *lower_bound_out = init_b + vect_get_scalar_dr_size (dr_b) - init_a;\n+  return true;\n+}\n+\n /* Function vect_prune_runtime_alias_test_list.\n \n    Prune a list of ddrs to be tested at run-time by versioning for alias.\n@@ -3178,6 +3353,19 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_prune_runtime_alias_test_list ===\\n\");\n \n+  /* Step values are irrelevant for aliasing if the number of vector\n+     iterations is equal to the number of scalar iterations (which can\n+     happen for fully-SLP loops).  */\n+  bool ignore_step_p = known_eq (LOOP_VINFO_VECT_FACTOR (loop_vinfo), 1U);\n+\n+  if (!ignore_step_p)\n+    {\n+      /* Convert the checks for nonzero steps into bound tests.  */\n+      tree value;\n+      FOR_EACH_VEC_ELT (LOOP_VINFO_CHECK_NONZERO (loop_vinfo), i, value)\n+\tvect_check_lower_bound (loop_vinfo, value, true, 1);\n+    }\n+\n   if (may_alias_ddrs.is_empty ())\n     return true;\n \n@@ -3191,9 +3379,12 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   FOR_EACH_VEC_ELT (may_alias_ddrs, i, ddr)\n     {\n       int comp_res;\n+      poly_uint64 lower_bound;\n       struct data_reference *dr_a, *dr_b;\n       gimple *dr_group_first_a, *dr_group_first_b;\n       tree segment_length_a, segment_length_b;\n+      unsigned HOST_WIDE_INT access_size_a, access_size_b;\n+      unsigned int align_a, align_b;\n       gimple *stmt_a, *stmt_b;\n \n       /* Ignore the alias if the VF we chose ended up being no greater\n@@ -3221,28 +3412,96 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n       dr_a = DDR_A (ddr);\n       stmt_a = DR_STMT (DDR_A (ddr));\n+\n+      dr_b = DDR_B (ddr);\n+      stmt_b = DR_STMT (DDR_B (ddr));\n+\n+      /* Skip the pair if inter-iteration dependencies are irrelevant\n+\t and intra-iteration dependencies are guaranteed to be honored.  */\n+      if (ignore_step_p\n+\t  && (vect_preserves_scalar_order_p (stmt_a, stmt_b)\n+\t      || vectorizable_with_step_bound_p (dr_a, dr_b, &lower_bound)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"no need for alias check between \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a));\n+\t      dump_printf (MSG_NOTE, \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b));\n+\t      dump_printf (MSG_NOTE, \" when VF is 1\\n\");\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* See whether we can handle the alias using a bounds check on\n+\t the step, and whether that's likely to be the best approach.\n+\t (It might not be, for example, if the minimum step is much larger\n+\t than the number of bytes handled by one vector iteration.)  */\n+      if (!ignore_step_p\n+\t  && TREE_CODE (DR_STEP (dr_a)) != INTEGER_CST\n+\t  && vectorizable_with_step_bound_p (dr_a, dr_b, &lower_bound)\n+\t  && (vect_small_gap_p (loop_vinfo, dr_a, lower_bound)\n+\t      || vect_small_gap_p (loop_vinfo, dr_b, lower_bound)))\n+\t{\n+\t  bool unsigned_p = dr_known_forward_stride_p (dr_a);\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location, \"no alias between \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a));\n+\t      dump_printf (MSG_NOTE, \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b));\n+\t      dump_printf (MSG_NOTE, \" when the step \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_STEP (dr_a));\n+\t      dump_printf (MSG_NOTE, \" is outside \");\n+\t      if (unsigned_p)\n+\t\tdump_printf (MSG_NOTE, \"[0\");\n+\t      else\n+\t\t{\n+\t\t  dump_printf (MSG_NOTE, \"(\");\n+\t\t  dump_dec (MSG_NOTE, poly_int64 (-lower_bound));\n+\t\t}\n+\t      dump_printf (MSG_NOTE, \", \");\n+\t      dump_dec (MSG_NOTE, lower_bound);\n+\t      dump_printf (MSG_NOTE, \")\\n\");\n+\t    }\n+\t  vect_check_lower_bound (loop_vinfo, DR_STEP (dr_a), unsigned_p,\n+\t\t\t\t  lower_bound);\n+\t  continue;\n+\t}\n+\n       dr_group_first_a = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n       if (dr_group_first_a)\n \t{\n \t  stmt_a = dr_group_first_a;\n \t  dr_a = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_a));\n \t}\n \n-      dr_b = DDR_B (ddr);\n-      stmt_b = DR_STMT (DDR_B (ddr));\n       dr_group_first_b = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_b));\n       if (dr_group_first_b)\n \t{\n \t  stmt_b = dr_group_first_b;\n \t  dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_b));\n \t}\n \n-      if (!operand_equal_p (DR_STEP (dr_a), DR_STEP (dr_b), 0))\n-\tlength_factor = scalar_loop_iters;\n+      if (ignore_step_p)\n+\t{\n+\t  segment_length_a = size_zero_node;\n+\t  segment_length_b = size_zero_node;\n+\t}\n       else\n-\tlength_factor = size_int (vect_factor);\n-      segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n-      segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n+\t{\n+\t  if (!operand_equal_p (DR_STEP (dr_a), DR_STEP (dr_b), 0))\n+\t    length_factor = scalar_loop_iters;\n+\t  else\n+\t    length_factor = size_int (vect_factor);\n+\t  segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n+\t  segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n+\t}\n+      access_size_a = vect_vfa_access_size (dr_a);\n+      access_size_b = vect_vfa_access_size (dr_b);\n+      align_a = vect_vfa_align (dr_a);\n+      align_b = vect_vfa_align (dr_b);\n \n       comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (dr_a),\n \t\t\t\t\tDR_BASE_ADDRESS (dr_b));\n@@ -3259,7 +3518,22 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t{\n \t  int res = vect_compile_time_alias (dr_a, dr_b,\n \t\t\t\t\t     segment_length_a,\n-\t\t\t\t\t     segment_length_b);\n+\t\t\t\t\t     segment_length_b,\n+\t\t\t\t\t     access_size_a,\n+\t\t\t\t\t     access_size_b);\n+\t  if (res >= 0 && dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"can tell at compile time that \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a));\n+\t      dump_printf (MSG_NOTE, \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b));\n+\t      if (res == 0)\n+\t\tdump_printf (MSG_NOTE, \" do not alias\\n\");\n+\t      else\n+\t\tdump_printf (MSG_NOTE, \" alias\\n\");\n+\t    }\n+\n \t  if (res == 0)\n \t    continue;\n \n@@ -3273,8 +3547,8 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t}\n \n       dr_with_seg_len_pair_t dr_with_seg_len_pair\n-\t  (dr_with_seg_len (dr_a, segment_length_a),\n-\t   dr_with_seg_len (dr_b, segment_length_b));\n+\t(dr_with_seg_len (dr_a, segment_length_a, access_size_a, align_a),\n+\t dr_with_seg_len (dr_b, segment_length_b, access_size_b, align_b));\n \n       /* Canonicalize pairs by sorting the two DR members.  */\n       if (comp_res > 0)\n@@ -3287,6 +3561,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n   unsigned int count = (comp_alias_ddrs.length ()\n \t\t\t+ check_unequal_addrs.length ());\n+\n   dump_printf_loc (MSG_NOTE, vect_location,\n \t\t   \"improved number of alias checks from %d to %d\\n\",\n \t\t   may_alias_ddrs.length (), count);"}, {"sha": "53684e57e9490f3ffef6eea46f40a08a9a1669ee", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -2875,6 +2875,31 @@ vect_create_cond_for_unequal_addrs (loop_vec_info loop_vinfo, tree *cond_expr)\n     }\n }\n \n+/* Create an expression that is true when all lower-bound conditions for\n+   the vectorized loop are met.  Chain this condition with *COND_EXPR.  */\n+\n+static void\n+vect_create_cond_for_lower_bounds (loop_vec_info loop_vinfo, tree *cond_expr)\n+{\n+  vec<vec_lower_bound> lower_bounds = LOOP_VINFO_LOWER_BOUNDS (loop_vinfo);\n+  for (unsigned int i = 0; i < lower_bounds.length (); ++i)\n+    {\n+      tree expr = lower_bounds[i].expr;\n+      tree type = unsigned_type_for (TREE_TYPE (expr));\n+      expr = fold_convert (type, expr);\n+      poly_uint64 bound = lower_bounds[i].min_value;\n+      if (!lower_bounds[i].unsigned_p)\n+\t{\n+\t  expr = fold_build2 (PLUS_EXPR, type, expr,\n+\t\t\t      build_int_cstu (type, bound - 1));\n+\t  bound += bound - 1;\n+\t}\n+      tree part_cond_expr = fold_build2 (GE_EXPR, boolean_type_node, expr,\n+\t\t\t\t\t build_int_cstu (type, bound));\n+      chain_cond_expr (cond_expr, part_cond_expr);\n+    }\n+}\n+\n /* Function vect_create_cond_for_alias_checks.\n \n    Create a conditional expression that represents the run-time checks for\n@@ -2986,6 +3011,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n   if (version_alias)\n     {\n       vect_create_cond_for_unequal_addrs (loop_vinfo, &cond_expr);\n+      vect_create_cond_for_lower_bounds (loop_vinfo, &cond_expr);\n       vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr);\n     }\n "}, {"sha": "64b9ce3fd2306f707a1989dcee8bce63b415c859", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -2475,6 +2475,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t}\n     }\n   /* Free optimized alias test DDRS.  */\n+  LOOP_VINFO_LOWER_BOUNDS (loop_vinfo).truncate (0);\n   LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).release ();\n   LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).release ();\n   /* Reset target cost data.  */\n@@ -3673,6 +3674,18 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t/* Count LEN - 1 ANDs and LEN comparisons.  */\n \t(void) add_stmt_cost (target_cost_data, len * 2 - 1, scalar_stmt,\n \t\t\t      NULL, 0, vect_prologue);\n+      len = LOOP_VINFO_LOWER_BOUNDS (loop_vinfo).length ();\n+      if (len)\n+\t{\n+\t  /* Count LEN - 1 ANDs and LEN comparisons.  */\n+\t  unsigned int nstmts = len * 2 - 1;\n+\t  /* +1 for each bias that needs adding.  */\n+\t  for (unsigned int i = 0; i < len; ++i)\n+\t    if (!LOOP_VINFO_LOWER_BOUNDS (loop_vinfo)[i].unsigned_p)\n+\t      nstmts += 1;\n+\t  (void) add_stmt_cost (target_cost_data, nstmts, scalar_stmt,\n+\t\t\t\tNULL, 0, vect_prologue);\n+\t}\n       dump_printf (MSG_NOTE,\n                    \"cost model: Adding cost of checks for loop \"\n                    \"versioning aliasing.\\n\");"}, {"sha": "56e875f20caaf8f576f803fe0a093ca9106e851d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a57776a11369621f9e9e8a8a3db6cb406c8bf27b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a57776a11369621f9e9e8a8a3db6cb406c8bf27b", "patch": "@@ -174,6 +174,18 @@ typedef struct _slp_instance {\n    loop to be valid.  */\n typedef std::pair<tree, tree> vec_object_pair;\n \n+/* Records that vectorization is only possible if abs (EXPR) >= MIN_VALUE.\n+   UNSIGNED_P is true if we can assume that abs (EXPR) == EXPR.  */\n+struct vec_lower_bound {\n+  vec_lower_bound () {}\n+  vec_lower_bound (tree e, bool u, poly_uint64 m)\n+    : expr (e), unsigned_p (u), min_value (m) {}\n+\n+  tree expr;\n+  bool unsigned_p;\n+  poly_uint64 min_value;\n+};\n+\n /* Vectorizer state common between loop and basic-block vectorization.  */\n struct vec_info {\n   enum vec_kind { bb, loop };\n@@ -406,6 +418,14 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Check that the addresses of each pair of objects is unequal.  */\n   auto_vec<vec_object_pair> check_unequal_addrs;\n \n+  /* List of values that are required to be nonzero.  This is used to check\n+     whether things like \"x[i * n] += 1;\" are safe and eventually gets added\n+     to the checks for lower bounds below.  */\n+  auto_vec<tree> check_nonzero;\n+\n+  /* List of values that need to be checked for a minimum value.  */\n+  auto_vec<vec_lower_bound> lower_bounds;\n+\n   /* Statements in the loop that have data references that are candidates for a\n      runtime (loop versioning) misalignment check.  */\n   auto_vec<gimple *> may_misalign_stmts;\n@@ -514,6 +534,8 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_MAY_ALIAS_DDRS(L)       (L)->may_alias_ddrs\n #define LOOP_VINFO_COMP_ALIAS_DDRS(L)      (L)->comp_alias_ddrs\n #define LOOP_VINFO_CHECK_UNEQUAL_ADDRS(L)  (L)->check_unequal_addrs\n+#define LOOP_VINFO_CHECK_NONZERO(L)        (L)->check_nonzero\n+#define LOOP_VINFO_LOWER_BOUNDS(L)         (L)->lower_bounds\n #define LOOP_VINFO_GROUPED_STORES(L)       (L)->grouped_stores\n #define LOOP_VINFO_SLP_INSTANCES(L)        (L)->slp_instances\n #define LOOP_VINFO_SLP_UNROLLING_FACTOR(L) (L)->slp_unrolling_factor\n@@ -534,7 +556,8 @@ typedef struct _loop_vec_info : public vec_info {\n   ((L)->may_misalign_stmts.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)\t\t\\\n   ((L)->comp_alias_ddrs.length () > 0 \\\n-   || (L)->check_unequal_addrs.length () > 0)\n+   || (L)->check_unequal_addrs.length () > 0 \\\n+   || (L)->lower_bounds.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_NITERS(L)\t\t\\\n   (LOOP_VINFO_NITERS_ASSUMPTIONS (L))\n #define LOOP_REQUIRES_VERSIONING(L)\t\t\t\\"}]}