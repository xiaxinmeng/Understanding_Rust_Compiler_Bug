{"sha": "e02fbefc82748bc33629bcb6a7ef3e6302711908", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAyZmJlZmM4Mjc0OGJjMzM2MjliY2I2YTdlZjNlNjMwMjcxMTkwOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-02-19T21:42:25Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-02-19T21:42:25Z"}, "message": "(schedule_insns): If there was no first scheduling pass,\n\nsplit instructions after reload.\n(update_flow_info): Tolerate some idiosyncrasies after reload.\n\nFrom-SVN: r13666", "tree": {"sha": "fd1052f64fe1d85a36e7aaf1fe0d6312142628ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd1052f64fe1d85a36e7aaf1fe0d6312142628ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e02fbefc82748bc33629bcb6a7ef3e6302711908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02fbefc82748bc33629bcb6a7ef3e6302711908", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02fbefc82748bc33629bcb6a7ef3e6302711908", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02fbefc82748bc33629bcb6a7ef3e6302711908/comments", "author": null, "committer": null, "parents": [{"sha": "101c1a3d93648d82511f33d826f1c64d33371463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/101c1a3d93648d82511f33d826f1c64d33371463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/101c1a3d93648d82511f33d826f1c64d33371463"}], "stats": {"total": 43, "additions": 41, "deletions": 2}, "files": [{"sha": "edd5f656d9c169b348a4d96e9e646d2cfbf34546", "filename": "gcc/sched.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02fbefc82748bc33629bcb6a7ef3e6302711908/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02fbefc82748bc33629bcb6a7ef3e6302711908/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=e02fbefc82748bc33629bcb6a7ef3e6302711908", "patch": "@@ -4452,6 +4452,15 @@ update_flow_info (notes, first, last, orig_insn)\n \t\t pattern, so we can safely ignore it.  */\n \t      if (insn == first)\n \t\t{\n+\t\t  /* After reload, REG_DEAD notes come sometimes an\n+\t\t     instruction after the register actually dies.  */\n+\t\t  if (reload_completed && REG_NOTE_KIND (note) == REG_DEAD)\n+\t\t    {\n+\t\t      XEXP (note, 1) = REG_NOTES (insn);\n+\t\t      REG_NOTES (insn) = note;\n+\t\t      break;\n+\t\t    }\n+\t\t\t\n \t\t  if (REG_NOTE_KIND (note) != REG_UNUSED)\n \t\t    abort ();\n \n@@ -4480,6 +4489,15 @@ update_flow_info (notes, first, last, orig_insn)\n \t\t     uses it.  */\n \t\t  break;\n \t\t}\n+\t      /* If this note refers to a multiple word hard\n+\t\t register, it may have been split into several smaller\n+\t\t hard register references.  We could split the notes,\n+\t\t but simply dropping them is good enough.  */\n+\t      if (GET_CODE (orig_dest) == REG\n+\t\t  && REGNO (orig_dest) < FIRST_PSEUDO_REGISTER\n+\t\t  && HARD_REGNO_NREGS (REGNO (orig_dest),\n+\t\t\t\t       GET_MODE (orig_dest)) > 1)\n+\t\t    break;\n \t      /* It must be set somewhere, fail if we couldn't find where it\n \t\t was set.  */\n \t      if (insn == last)\n@@ -4516,7 +4534,22 @@ update_flow_info (notes, first, last, orig_insn)\n \t      /* The original dest must still be set someplace.  Abort if we\n \t\t couldn't find it.  */\n \t      if (insn == first)\n-\t\tabort ();\n+\t\t{\n+\t\t  /* However, if this note refers to a multiple word hard\n+\t\t     register, it may have been split into several smaller\n+\t\t     hard register references.  We could split the notes,\n+\t\t     but simply dropping them is good enough.  */\n+\t\t  if (GET_CODE (orig_dest) == REG\n+\t\t      && REGNO (orig_dest) < FIRST_PSEUDO_REGISTER\n+\t\t      && HARD_REGNO_NREGS (REGNO (orig_dest),\n+\t\t\t\t\t   GET_MODE (orig_dest)) > 1)\n+\t\t    break;\n+\t\t  /* Likewise for multi-word memory references.  */\n+\t\t  if (GET_CODE (orig_dest) == MEM\n+\t\t      && SIZE_FOR_MODE (orig_dest) > MOVE_MAX)\n+\t\t    break;\n+\t\t  abort ();\n+\t\t}\n \t    }\n \t  break;\n \n@@ -4563,6 +4596,9 @@ update_flow_info (notes, first, last, orig_insn)\n \t  break;\n \n \tcase REG_INC:\n+\t  /* reload sometimes leaves obsolete REG_INC notes around.  */\n+\t  if (reload_completed)\n+\t    break;\n \t  /* This should be moved to whichever instruction now has the\n \t     increment operation.  */\n \t  abort ();\n@@ -4945,7 +4981,10 @@ schedule_insns (dump_file)\n \n \t  /* Split insns here to get max fine-grain parallelism.  */\n \t  prev = PREV_INSN (insn);\n-\t  if (reload_completed == 0)\n+\t  /* It is probably not worthwhile to try to split again in the\n+\t     second pass.  However, if flag_schedule_insns is not set,\n+\t     the first and only (if any) scheduling pass is after reload.  */\n+\t  if (reload_completed == 0 || ! flag_schedule_insns)\n \t    {\n \t      rtx last, first = PREV_INSN (insn);\n \t      rtx notes = REG_NOTES (insn);"}]}