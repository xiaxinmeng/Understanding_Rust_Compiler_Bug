{"sha": "6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2YTA3ZDI5OTU1ZTgwOGZjY2Q2M2VlMmNhMzRlYzIxN2UxOWI1Yw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-07T22:50:11Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-07T22:50:11Z"}, "message": "except.c (start_dynamic_handler): Fix so that we can use __builtin_setjmp...\n\n\t* except.c (start_dynamic_handler): Fix so that we can use\n \t__builtin_setjmp, and default to using __builtin_setjmp instead of\n \tsetjmp.\n\t* expr.c (expand_builtin_setjmp): New routine, split out from\n\texisting inline code from expand_builtin.\n\t(expand_builtin): Split out code into expand_builtin_setjmp.\n\t* expr.h (expand_builtin_setjmp): Add declaration.\n\t* libgcc2.c (__sjthrow): Default to using __builtin_setjmp instead\n \tof setjmp.\n\t(__sjpopnthrow): Likewise.\n\t* optabs.c (init_optabs): Likewise.\n\nFrom-SVN: r14045", "tree": {"sha": "cb529c4d7f439546438820c79f061fa0ec0e5666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb529c4d7f439546438820c79f061fa0ec0e5666"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/comments", "author": null, "committer": null, "parents": [{"sha": "24f2dbd6f70dd5ae6b3069f7587b3a6ba4e2211f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24f2dbd6f70dd5ae6b3069f7587b3a6ba4e2211f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24f2dbd6f70dd5ae6b3069f7587b3a6ba4e2211f"}], "stats": {"total": 353, "additions": 190, "deletions": 163}, "files": [{"sha": "91afbc3052b60e4c5e57e771c0b04f887d5026a2", "filename": "gcc/except.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "patch": "@@ -693,9 +693,9 @@ add_partial_entry (handler)\n    when there are no more elements in the dynamic handler chain, when\n    the value is &top_elt from libgcc2.c.  Immediately after the\n    pointer, is an area suitable for setjmp/longjmp when\n-   USE_BUILTIN_SETJMP isn't defined, and an area suitable for\n-   __builtin_setjmp/__builtin_longjmp when USE_BUILTIN_SETJMP is\n-   defined.\n+   DONT_USE_BUILTIN_SETJMP is defined, and an area suitable for\n+   __builtin_setjmp/__builtin_longjmp when DONT_USE_BUILTIN_SETJMP\n+   isn't defined.\n \n    This routine is here to facilitate the porting of this code to\n    systems with threads.  One can either replace the routine we emit a\n@@ -843,10 +843,10 @@ static void\n start_dynamic_handler ()\n {\n   rtx dhc, dcc;\n-  rtx x, arg;\n+  rtx x, arg, buf;\n   int size;\n \n-#ifdef USE_BUILTIN_SETJMP\n+#ifndef DONT_USE_BUILTIN_SETJMP\n   /* The number of Pmode words for the setjmp buffer, when using the\n      builtin setjmp/longjmp, see expand_builtin, case\n      BUILT_IN_LONGJMP.  */\n@@ -882,10 +882,14 @@ start_dynamic_handler ()\n   emit_move_insn (dcc, const0_rtx);\n \n   /* The jmpbuf starts two words into the area allocated.  */\n+  buf = plus_constant (XEXP (arg, 0), GET_MODE_SIZE (Pmode)*2);\n \n+#ifdef DONT_USE_BUILTIN_SETJMP\n   x = emit_library_call_value (setjmp_libfunc, NULL_RTX, 1, SImode, 1,\n-\t\t\t       plus_constant (XEXP (arg, 0), GET_MODE_SIZE (Pmode)*2),\n-\t\t\t       Pmode);\n+\t\t\t       buf, Pmode);\n+#else\n+  x = expand_builtin_setjmp (buf, NULL_RTX);\n+#endif\n \n   /* If we come back here for a catch, transfer control to the\n      handler.  */"}, {"sha": "4e3c981682bd7733dd8ea44d7af2f4da10d25e28", "filename": "gcc/expr.c", "status": "modified", "additions": 164, "deletions": 151, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "patch": "@@ -7880,6 +7880,169 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n #endif\n   return tem;\n }\n+\n+/* __builtin_setjmp is passed a pointer to an array of five words (not\n+   all will be used on all machines).  It operates similarly to the C\n+   library function of the same name, but is more efficient.  Much of\n+   the code below (and for longjmp) is copied from the handling of\n+   non-local gotos.\n+\n+   NOTE: This is intended for use by GNAT and the exception handling\n+   scheme in the compiler and will only work in the method used by\n+   them.  */\n+\n+rtx\n+expand_builtin_setjmp (buf_addr, target)\n+     rtx buf_addr;\n+     rtx target;\n+{\n+  rtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();\n+  enum machine_mode sa_mode = Pmode, value_mode;\n+  rtx stack_save;\n+  int old_inhibit_defer_pop = inhibit_defer_pop;\n+  int return_pops\n+    =  RETURN_POPS_ARGS (get_identifier (\"__dummy\"),\n+\t\t\t build_function_type (void_type_node, NULL_TREE),\n+\t\t\t 0);\n+  rtx next_arg_reg;\n+  CUMULATIVE_ARGS args_so_far;\n+  rtx op0;\n+  int i;\n+\n+  value_mode = TYPE_MODE (integer_type_node);\n+\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  buf_addr = convert_memory_address (Pmode, buf_addr);\n+#endif\n+\n+  buf_addr = force_reg (Pmode, buf_addr);\n+\n+  if (target == 0 || GET_CODE (target) != REG\n+      || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+    target = gen_reg_rtx (value_mode);\n+\n+  emit_queue ();\n+\n+  CONST_CALL_P (emit_note (NULL_PTR, NOTE_INSN_SETJMP)) = 1;\n+  current_function_calls_setjmp = 1;\n+\n+  /* We store the frame pointer and the address of lab1 in the buffer\n+     and use the rest of it for the stack save area, which is\n+     machine-dependent.  */\n+  emit_move_insn (gen_rtx (MEM, Pmode, buf_addr),\n+\t\t  virtual_stack_vars_rtx);\n+  emit_move_insn\n+    (validize_mem (gen_rtx (MEM, Pmode,\n+\t\t\t    plus_constant (buf_addr,\n+\t\t\t\t\t   GET_MODE_SIZE (Pmode)))),\n+     gen_rtx (LABEL_REF, Pmode, lab1));\n+\n+#ifdef HAVE_save_stack_nonlocal\n+  if (HAVE_save_stack_nonlocal)\n+    sa_mode = insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0];\n+#endif\n+\n+  stack_save = gen_rtx (MEM, sa_mode,\n+\t\t\tplus_constant (buf_addr,\n+\t\t\t\t       2 * GET_MODE_SIZE (Pmode)));\n+  emit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n+\n+#ifdef HAVE_setjmp\n+  if (HAVE_setjmp)\n+    emit_insn (gen_setjmp ());\n+#endif\n+\n+  /* Set TARGET to zero and branch around the other case.  */\n+  emit_move_insn (target, const0_rtx);\n+  emit_jump_insn (gen_jump (lab2));\n+  emit_barrier ();\n+  emit_label (lab1);\n+\n+  /* Note that setjmp clobbers FP when we get here, so we have to make\n+     sure it's marked as used by this function.  */\n+  emit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));\n+\n+  /* Mark the static chain as clobbered here so life information\n+     doesn't get messed up for it.  */\n+  emit_insn (gen_rtx (CLOBBER, VOIDmode, static_chain_rtx));\n+\n+  /* Now put in the code to restore the frame pointer, and argument\n+     pointer, if needed.  The code below is from expand_end_bindings\n+     in stmt.c; see detailed documentation there.  */\n+#ifdef HAVE_nonlocal_goto\n+  if (! HAVE_nonlocal_goto)\n+#endif\n+    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n+\n+  current_function_has_nonlocal_goto = 1;\n+\n+#if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+  if (fixed_regs[ARG_POINTER_REGNUM])\n+    {\n+#ifdef ELIMINABLE_REGS\n+      static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;\n+\n+      for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)\n+\tif (elim_regs[i].from == ARG_POINTER_REGNUM\n+\t    && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n+\t  break;\n+\n+      if (i == sizeof elim_regs / sizeof elim_regs [0])\n+#endif\n+\t{\n+\t  /* Now restore our arg pointer from the address at which it\n+\t     was saved in our stack frame.\n+\t     If there hasn't be space allocated for it yet, make\n+\t     some now.  */\n+\t  if (arg_pointer_save_area == 0)\n+\t    arg_pointer_save_area\n+\t      = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n+\t  emit_move_insn (virtual_incoming_args_rtx,\n+\t\t\t  copy_to_reg (arg_pointer_save_area));\n+\t}\n+    }\n+#endif\n+\n+#ifdef HAVE_nonlocal_goto_receiver\n+  if (HAVE_nonlocal_goto_receiver)\n+    emit_insn (gen_nonlocal_goto_receiver ());\n+#endif\n+  /* The static chain pointer contains the address of dummy function.\n+     We need to call it here to handle some PIC cases of restoring a\n+     global pointer.  Then return 1.  */\n+  op0 = copy_to_mode_reg (Pmode, static_chain_rtx);\n+\n+  /* We can't actually call emit_library_call here, so do everything\n+     it does, which isn't much for a libfunc with no args.  */\n+  op0 = memory_address (FUNCTION_MODE, op0);\n+\n+  INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE,\n+\t\t\tgen_rtx (SYMBOL_REF, Pmode, \"__dummy\"), 1);\n+  next_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);\n+\n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#ifdef HAVE_call_pop\n+  if (HAVE_call_pop)\n+    emit_call_insn (gen_call_pop (gen_rtx (MEM, FUNCTION_MODE, op0),\n+\t\t\t\t  const0_rtx, next_arg_reg,\n+\t\t\t\t  GEN_INT (return_pops)));\n+  else\n+#endif\n+#endif\n+\n+#ifdef HAVE_call\n+    if (HAVE_call)\n+      emit_call_insn (gen_call (gen_rtx (MEM, FUNCTION_MODE, op0),\n+\t\t\t\tconst0_rtx, next_arg_reg, const0_rtx));\n+    else\n+#endif\n+      abort ();\n+\n+  emit_move_insn (target, const1_rtx);\n+  emit_label (lab2);\n+  return target;\n+}\n+\n \f\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n@@ -8718,15 +8881,6 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       break;\n #endif\n \n-      /* __builtin_setjmp is passed a pointer to an array of five words\n-\t (not all will be used on all machines).  It operates similarly to\n-\t the C library function of the same name, but is more efficient.\n-\t Much of the code below (and for longjmp) is copied from the handling\n-\t of non-local gotos.\n-\n-\t NOTE: This is intended for use by GNAT and will only work in\n-\t the method used by it.  This code will likely NOT survive to \n-\t the GCC 2.8.0 release.  */\n     case BUILT_IN_SETJMP:\n       if (arglist == 0\n \t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n@@ -8735,148 +8889,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       {\n \trtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n \t\t\t\t    VOIDmode, 0);\n-\trtx lab1 = gen_label_rtx (), lab2 = gen_label_rtx ();\n-\tenum machine_mode sa_mode = Pmode;\n-\trtx stack_save;\n-\tint old_inhibit_defer_pop = inhibit_defer_pop;\n-\tint return_pops\n-\t  =  RETURN_POPS_ARGS (get_identifier (\"__dummy\"),\n-\t\t\t       build_function_type (void_type_node, NULL_TREE),\n-\t\t\t       0);\n-\trtx next_arg_reg;\n-\tCUMULATIVE_ARGS args_so_far;\n-\tint i;\n-\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\tbuf_addr = convert_memory_address (Pmode, buf_addr);\n-#endif\n-\n-\tbuf_addr = force_reg (Pmode, buf_addr);\n-\n-\tif (target == 0 || GET_CODE (target) != REG\n-\t    || REGNO (target) < FIRST_PSEUDO_REGISTER)\n-\t  target = gen_reg_rtx (value_mode);\n-\n-\temit_queue ();\n-\n-\tCONST_CALL_P (emit_note (NULL_PTR, NOTE_INSN_SETJMP)) = 1;\n-\tcurrent_function_calls_setjmp = 1;\n-\n-\t/* We store the frame pointer and the address of lab1 in the buffer\n-\t   and use the rest of it for the stack save area, which is\n-\t   machine-dependent.  */\n-\temit_move_insn (gen_rtx (MEM, Pmode, buf_addr),\n-\t\t\tvirtual_stack_vars_rtx);\n-\temit_move_insn\n-\t  (validize_mem (gen_rtx (MEM, Pmode,\n-\t\t\t\t  plus_constant (buf_addr,\n-\t\t\t\t\t\t GET_MODE_SIZE (Pmode)))),\n-\t   gen_rtx (LABEL_REF, Pmode, lab1));\n-\n-#ifdef HAVE_save_stack_nonlocal\n-\tif (HAVE_save_stack_nonlocal)\n-\t  sa_mode = insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0];\n-#endif\n-\n-\tstack_save = gen_rtx (MEM, sa_mode,\n-\t\t\t      plus_constant (buf_addr,\n-\t\t\t\t\t     2 * GET_MODE_SIZE (Pmode)));\n-\temit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n-\n-#ifdef HAVE_setjmp\n-\tif (HAVE_setjmp)\n-\t  emit_insn (gen_setjmp ());\n-#endif\n-\n-\t/* Set TARGET to zero and branch around the other case.  */\n-\temit_move_insn (target, const0_rtx);\n-\temit_jump_insn (gen_jump (lab2));\n-\temit_barrier ();\n-\temit_label (lab1);\n-\n-\t/* Note that setjmp clobbers FP when we get here, so we have to\n-\t   make sure it's marked as used by this function.   */\n-\temit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));\n-\n-\t/* Mark the static chain as clobbered here so life information\n-\t   doesn't get messed up for it.  */\n-\temit_insn (gen_rtx (CLOBBER, VOIDmode, static_chain_rtx));\n-\n-\t/* Now put in the code to restore the frame pointer, and argument\n-\t   pointer, if needed.  The code below is from expand_end_bindings\n-\t   in stmt.c; see detailed documentation there.  */\n-#ifdef HAVE_nonlocal_goto\n-\tif (! HAVE_nonlocal_goto)\n-#endif\n-\t  emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n-\n-\tcurrent_function_has_nonlocal_goto = 1;\n-\n-#if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\tif (fixed_regs[ARG_POINTER_REGNUM])\n-\t  {\n-#ifdef ELIMINABLE_REGS\n-\t    static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;\n-\n-\t    for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)\n-\t      if (elim_regs[i].from == ARG_POINTER_REGNUM\n-\t\t  && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n-\t\tbreak;\n-\n-\t    if (i == sizeof elim_regs / sizeof elim_regs [0])\n-#endif\n-\t      {\n-\t\t/* Now restore our arg pointer from the address at which it\n-\t\t   was saved in our stack frame.\n-\t\t   If there hasn't be space allocated for it yet, make\n-\t\t   some now.  */\n-\t\tif (arg_pointer_save_area == 0)\n-\t\t  arg_pointer_save_area\n-\t\t    = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n-\t\temit_move_insn (virtual_incoming_args_rtx,\n-\t\t\t\tcopy_to_reg (arg_pointer_save_area));\n-\t      }\n-\t  }\n-#endif\n-\n-#ifdef HAVE_nonlocal_goto_receiver\n-\tif (HAVE_nonlocal_goto_receiver)\n-\t  emit_insn (gen_nonlocal_goto_receiver ());\n-#endif\n-\t/* The static chain pointer contains the address of dummy function.\n-\t   We need to call it here to handle some PIC cases of restoring\n-\t   a global pointer.  Then return 1.  */\n-\top0 = copy_to_mode_reg (Pmode, static_chain_rtx);\n-\n-\t/* We can't actually call emit_library_call here, so do everything\n-\t   it does, which isn't much for a libfunc with no args.  */\n-\top0 = memory_address (FUNCTION_MODE, op0);\n-\n-\tINIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE,\n-\t\t\t      gen_rtx (SYMBOL_REF, Pmode, \"__dummy\"), 1);\n-\tnext_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);\n-\n-#ifndef ACCUMULATE_OUTGOING_ARGS\n-#ifdef HAVE_call_pop\n-\tif (HAVE_call_pop)\n-\t  emit_call_insn (gen_call_pop (gen_rtx (MEM, FUNCTION_MODE, op0),\n-\t\t\t\t\tconst0_rtx, next_arg_reg,\n-\t\t\t\t\tGEN_INT (return_pops)));\n-\telse\n-#endif\n-#endif\n-\n-#ifdef HAVE_call\n-\tif (HAVE_call)\n-\t  emit_call_insn (gen_call (gen_rtx (MEM, FUNCTION_MODE, op0),\n-\t\t\t\t    const0_rtx, next_arg_reg, const0_rtx));\n-\telse\n-#endif\n-\t    abort ();\n-\n-\temit_move_insn (target, const1_rtx);\n-\temit_label (lab2);\n-\treturn target;\n+\treturn expand_builtin_setjmp (buf_addr, target);\n       }\n \n       /* __builtin_longjmp is passed a pointer to an array of five words"}, {"sha": "bb957b75f1271dec4f2640e8c5538214c6f95761", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "patch": "@@ -685,6 +685,8 @@ extern rtx store_expr PROTO((tree, rtx, int));\n    Useful after calling expand_expr with 1 as sum_ok.  */\n extern rtx force_operand PROTO((rtx, rtx));\n \n+extern rtx expand_builtin_setjmp PROTO((rtx, rtx));\n+\n #ifdef TREE_CODE\n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null."}, {"sha": "09b6a15dcc691d0d90f3417547f0c4dc7955a5bb", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "patch": "@@ -3120,7 +3120,7 @@ __terminate ()\n    is raised when using the setjmp/longjmp exception handling codegen\n    method.  */\n \n-extern longjmp (void *, int);\n+extern void longjmp (void *, int);\n \n extern void *__eh_type;\n \n@@ -3169,7 +3169,11 @@ __sjthrow ()\n       buf[0] = (*dhc);\n \n       /* try { */\n+#ifdef DONT_USE_BUILTIN_SETJMP\n       if (! setjmp (&buf[2]))\n+#else\n+      if (! __builtin_setjmp (&buf[2]))\n+#endif\n \t{\n \t  *dhc = buf;\n \t  while (cleanup[0])\n@@ -3206,10 +3210,10 @@ __sjthrow ()\n \n   /* And then we jump to the handler.  */\n \n-#ifdef USE_BUILTIN_SETJMP\n-  __builtin_longjmp (jmpbuf, 1);\n-#else\n+#ifdef DONT_USE_BUILTIN_SETJMP\n   longjmp (jmpbuf, 1);\n+#else\n+  __builtin_longjmp (jmpbuf, 1);\n #endif\n }\n \n@@ -3240,7 +3244,11 @@ __sjpopnthrow ()\n       buf[0] = (*dhc);\n \n       /* try { */\n+#ifdef DONT_USE_BUILTIN_SETJMP\n       if (! setjmp (&buf[2]))\n+#else\n+      if (! __builtin_setjmp (&buf[2]))\n+#endif\n \t{\n \t  *dhc = buf;\n \t  while (cleanup[0])"}, {"sha": "992660d0c870e0e8b9cc9318579f78e234bb85f1", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6a07d29955e808fccd63ee2ca34ec217e19b5c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6e6a07d29955e808fccd63ee2ca34ec217e19b5c", "patch": "@@ -4277,7 +4277,7 @@ init_optabs ()\n   sjthrow_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__sjthrow\");\n   sjpopnthrow_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__sjpopnthrow\");\n   terminate_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__terminate\");\n-#ifdef USE_BUILTIN_SETJMP\n+#ifndef DONT_USE_BUILTIN_SETJMP\n   setjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__builtin_setjmp\");\n   longjmp_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"__builtin_longjmp\");\n #else"}]}