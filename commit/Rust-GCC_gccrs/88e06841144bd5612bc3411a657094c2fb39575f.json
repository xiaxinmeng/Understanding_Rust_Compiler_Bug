{"sha": "88e06841144bd5612bc3411a657094c2fb39575f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhlMDY4NDExNDRiZDU2MTJiYzM0MTFhNjU3MDk0YzJmYjM5NTc1Zg==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-07-05T18:45:40Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-07-05T18:45:40Z"}, "message": "double-int.h (fit_double_type): Remove declaration.\n\n\t* double-int.h (fit_double_type): Remove declaration.\n\t* double-int.c (fit_double_type): Remove function.\n\t* tree.h (int_fits_type_p): Adjust prototype.\n\t* tree.c (int_fits_type_p): Return bool. Use double_int_fits_to_tree_p\n\tinstead of fit_double_type.\n\t(build_int_cst_type): Use double_int_to_tree and shwi_to_double_int\n\tinstead of fit_double_type and build_int_cst_wide.\n\t* builtins.c (): Use double_int_fits_to_tree_p and double_int_to_tree\n\tinstead of fit_double_type and build_int_cst_wide.\n\t(fold_builtin_object_size): Use double_int_fits_to_tree_p instead\n\tof fit_double_type.\n\nFrom-SVN: r161847", "tree": {"sha": "57d6c25d9e2e26c53247cf44ec59628e7d5a7f44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57d6c25d9e2e26c53247cf44ec59628e7d5a7f44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88e06841144bd5612bc3411a657094c2fb39575f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e06841144bd5612bc3411a657094c2fb39575f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e06841144bd5612bc3411a657094c2fb39575f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e06841144bd5612bc3411a657094c2fb39575f/comments", "author": null, "committer": null, "parents": [{"sha": "92eb4438684a217e0f6968d0ab996424c7af055f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92eb4438684a217e0f6968d0ab996424c7af055f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92eb4438684a217e0f6968d0ab996424c7af055f"}], "stats": {"total": 162, "additions": 48, "deletions": 114}, "files": [{"sha": "8cf4196dc30c2866463383bc6b3325f47a80774c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88e06841144bd5612bc3411a657094c2fb39575f", "patch": "@@ -1,3 +1,17 @@\n+2010-07-05  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* double-int.h (fit_double_type): Remove declaration.\n+\t* double-int.c (fit_double_type): Remove function.\n+\t* tree.h (int_fits_type_p): Adjust prototype.\n+\t* tree.c (int_fits_type_p): Return bool. Use double_int_fits_to_tree_p\n+\tinstead of fit_double_type.\n+\t(build_int_cst_type): Use double_int_to_tree and shwi_to_double_int\n+\tinstead of fit_double_type and build_int_cst_wide.\n+\t* builtins.c (): Use double_int_fits_to_tree_p and double_int_to_tree\n+\tinstead of fit_double_type and build_int_cst_wide.\n+\t(fold_builtin_object_size): Use double_int_fits_to_tree_p instead\n+\tof fit_double_type.\n+\n 2010-07-05  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.h (cgraph_node, cgraph_varpool_node): Update docmentation of"}, {"sha": "046593e08bb84cd43eb0ceb7148a8ae96163ed3d", "filename": "gcc/builtins.c", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=88e06841144bd5612bc3411a657094c2fb39575f", "patch": "@@ -7626,8 +7626,7 @@ fold_builtin_int_roundingfn (location_t loc, tree fndecl, tree arg)\n \t{\n \t  tree itype = TREE_TYPE (TREE_TYPE (fndecl));\n \t  tree ftype = TREE_TYPE (arg);\n-\t  unsigned HOST_WIDE_INT lo2;\n-\t  HOST_WIDE_INT hi, lo;\n+\t  double_int val;\n \t  REAL_VALUE_TYPE r;\n \n \t  switch (DECL_FUNCTION_CODE (fndecl))\n@@ -7651,9 +7650,9 @@ fold_builtin_int_roundingfn (location_t loc, tree fndecl, tree arg)\n \t      gcc_unreachable ();\n \t    }\n \n-\t  REAL_VALUE_TO_INT (&lo, &hi, r);\n-\t  if (!fit_double_type (lo, hi, &lo2, &hi, itype))\n-\t    return build_int_cst_wide (itype, lo2, hi);\n+\t  real_to_integer2 ((HOST_WIDE_INT *)&val.low, &val.high, &r);\n+\t  if (double_int_fits_to_tree_p (itype, val))\n+\t    return double_int_to_tree (itype, val);\n \t}\n     }\n \n@@ -12036,7 +12035,7 @@ maybe_emit_free_warning (tree exp)\n tree\n fold_builtin_object_size (tree ptr, tree ost)\n {\n-  tree ret = NULL_TREE;\n+  unsigned HOST_WIDE_INT bytes;\n   int object_size_type;\n \n   if (!validate_arg (ptr, POINTER_TYPE)\n@@ -12059,31 +12058,25 @@ fold_builtin_object_size (tree ptr, tree ost)\n     return build_int_cst_type (size_type_node, object_size_type < 2 ? -1 : 0);\n \n   if (TREE_CODE (ptr) == ADDR_EXPR)\n-    ret = build_int_cstu (size_type_node,\n-\t\t\t  compute_builtin_object_size (ptr, object_size_type));\n-\n+    {\n+      bytes = compute_builtin_object_size (ptr, object_size_type);\n+      if (double_int_fits_to_tree_p (size_type_node,\n+\t\t\t\t     uhwi_to_double_int (bytes)))\n+\treturn build_int_cstu (size_type_node, bytes);\n+    }\n   else if (TREE_CODE (ptr) == SSA_NAME)\n     {\n-      unsigned HOST_WIDE_INT bytes;\n-\n       /* If object size is not known yet, delay folding until\n        later.  Maybe subsequent passes will help determining\n        it.  */\n       bytes = compute_builtin_object_size (ptr, object_size_type);\n-      if (bytes != (unsigned HOST_WIDE_INT) (object_size_type < 2\n-\t\t\t\t\t     ? -1 : 0))\n-\tret = build_int_cstu (size_type_node, bytes);\n+      if (bytes != (unsigned HOST_WIDE_INT) (object_size_type < 2 ? -1 : 0)\n+          && double_int_fits_to_tree_p (size_type_node,\n+\t\t\t\t\tuhwi_to_double_int (bytes)))\n+\treturn build_int_cstu (size_type_node, bytes);\n     }\n \n-  if (ret)\n-    {\n-      unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (ret);\n-      HOST_WIDE_INT high = TREE_INT_CST_HIGH (ret);\n-      if (fit_double_type (low, high, &low, &high, TREE_TYPE (ret)))\n-\tret = NULL_TREE;\n-    }\n-\n-  return ret;\n+  return NULL_TREE;\n }\n \n /* Fold a call to the __mem{cpy,pcpy,move,set}_chk builtin."}, {"sha": "924e91b6c905ef4e9ba90ebcb62fc8e8d6334023", "filename": "gcc/double-int.c", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=88e06841144bd5612bc3411a657094c2fb39575f", "patch": "@@ -69,71 +69,6 @@ decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n   *hi = words[2] + words[3] * BASE;\n }\n \n-/* Force the double-word integer L1, H1 to be within the range of the\n-   integer type TYPE.  Stores the properly truncated and sign-extended\n-   double-word integer in *LV, *HV.  Returns true if the operation\n-   overflows, that is, argument and result are different.  */\n-\n-int\n-fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\t unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, const_tree type)\n-{\n-  unsigned HOST_WIDE_INT low0 = l1;\n-  HOST_WIDE_INT high0 = h1;\n-  unsigned int prec = TYPE_PRECISION (type);\n-  int sign_extended_type;\n-\n-  /* Size types *are* sign extended.  */\n-  sign_extended_type = (!TYPE_UNSIGNED (type)\n-\t\t\t|| (TREE_CODE (type) == INTEGER_TYPE\n-\t\t\t    && TYPE_IS_SIZETYPE (type)));\n-\n-  /* First clear all bits that are beyond the type's precision.  */\n-  if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n-    ;\n-  else if (prec > HOST_BITS_PER_WIDE_INT)\n-    h1 &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n-  else\n-    {\n-      h1 = 0;\n-      if (prec < HOST_BITS_PER_WIDE_INT)\n-\tl1 &= ~((HOST_WIDE_INT) (-1) << prec);\n-    }\n-\n-  /* Then do sign extension if necessary.  */\n-  if (!sign_extended_type)\n-    /* No sign extension */;\n-  else if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n-    /* Correct width already.  */;\n-  else if (prec > HOST_BITS_PER_WIDE_INT)\n-    {\n-      /* Sign extend top half? */\n-      if (h1 & ((unsigned HOST_WIDE_INT)1\n-\t\t<< (prec - HOST_BITS_PER_WIDE_INT - 1)))\n-\th1 |= (HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT);\n-    }\n-  else if (prec == HOST_BITS_PER_WIDE_INT)\n-    {\n-      if ((HOST_WIDE_INT)l1 < 0)\n-\th1 = -1;\n-    }\n-  else\n-    {\n-      /* Sign extend bottom half? */\n-      if (l1 & ((unsigned HOST_WIDE_INT)1 << (prec - 1)))\n-\t{\n-\t  h1 = -1;\n-\t  l1 |= (HOST_WIDE_INT)(-1) << prec;\n-\t}\n-    }\n-\n-  *lv = l1;\n-  *hv = h1;\n-\n-  /* If the value didn't fit, signal overflow.  */\n-  return l1 != low0 || h1 != high0;\n-}\n-\n /* Add two doubleword integers with doubleword result.\n    Return nonzero if the operation overflows according to UNSIGNED_P.\n    Each argument is given as two `HOST_WIDE_INT' pieces."}, {"sha": "00ec4efdad1566c82b9a1f68243b284f1345e5f4", "filename": "gcc/double-int.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=88e06841144bd5612bc3411a657094c2fb39575f", "patch": "@@ -270,9 +270,6 @@ double_int_equal_p (double_int cst1, double_int cst2)\n \n /* Legacy interface with decomposed high/low parts.  */\n \n-extern int fit_double_type (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t    const_tree);\n extern int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,"}, {"sha": "b5a99f9de1db96d1d2e5e9de66dedcb5523dedae", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=88e06841144bd5612bc3411a657094c2fb39575f", "patch": "@@ -1049,14 +1049,9 @@ build_int_cst (tree type, HOST_WIDE_INT low)\n tree\n build_int_cst_type (tree type, HOST_WIDE_INT low)\n {\n-  unsigned HOST_WIDE_INT low1;\n-  HOST_WIDE_INT hi;\n-\n   gcc_assert (type);\n \n-  fit_double_type (low, low < 0 ? -1 : 0, &low1, &hi, type);\n-\n-  return build_int_cst_wide (type, low1, hi);\n+  return double_int_to_tree (type, shwi_to_double_int (low));\n }\n \n /* Constructs tree in type TYPE from with value given by CST.  Signedness\n@@ -7900,10 +7895,10 @@ get_narrower (tree op, int *unsignedp_ptr)\n   return win;\n }\n \f\n-/* Nonzero if integer constant C has a value that is permissible\n+/* Returns true if integer constant C has a value that is permissible\n    for type TYPE (an INTEGER_TYPE).  */\n \n-int\n+bool\n int_fits_type_p (const_tree c, const_tree type)\n {\n   tree type_low_bound, type_high_bound;\n@@ -7932,7 +7927,7 @@ int_fits_type_p (const_tree c, const_tree type)\n   /* If at least one bound of the type is a constant integer, we can check\n      ourselves and maybe make a decision. If no such decision is possible, but\n      this type is a subtype, try checking against that.  Otherwise, use\n-     fit_double_type, which checks against the precision.\n+     double_int_fits_to_tree_p, which checks against the precision.\n \n      Compute the status for each possibly constant bound, and return if we see\n      one does not match. Use ok_for_xxx_bound for this purpose, assigning -1\n@@ -7953,12 +7948,12 @@ int_fits_type_p (const_tree c, const_tree type)\n \t  int t_neg = (unsc && double_int_negative_p (dd));\n \n \t  if (c_neg && !t_neg)\n-\t    return 0;\n+\t    return false;\n \t  if ((c_neg || !t_neg) && double_int_ucmp (dc, dd) < 0)\n-\t    return 0;\n+\t    return false;\n \t}\n       else if (double_int_cmp (dc, dd, unsc) < 0)\n-\treturn 0;\n+\treturn false;\n       ok_for_low_bound = true;\n     }\n   else\n@@ -7978,30 +7973,30 @@ int_fits_type_p (const_tree c, const_tree type)\n \t  int t_neg = (unsc && double_int_negative_p (dd));\n \n \t  if (t_neg && !c_neg)\n-\t    return 0;\n+\t    return false;\n \t  if ((t_neg || !c_neg) && double_int_ucmp (dc, dd) > 0)\n-\t    return 0;\n+\t    return false;\n \t}\n       else if (double_int_cmp (dc, dd, unsc) > 0)\n-\treturn 0;\n+\treturn false;\n       ok_for_high_bound = true;\n     }\n   else\n     ok_for_high_bound = false;\n \n   /* If the constant fits both bounds, the result is known.  */\n   if (ok_for_low_bound && ok_for_high_bound)\n-    return 1;\n+    return true;\n \n   /* Perform some generic filtering which may allow making a decision\n      even if the bounds are not constant.  First, negative integers\n      never fit in unsigned types, */\n   if (TYPE_UNSIGNED (type) && !unsc && double_int_negative_p (dc))\n-    return 0;\n+    return false;\n \n   /* Second, narrower types always fit in wider ones.  */\n   if (TYPE_PRECISION (type) > TYPE_PRECISION (TREE_TYPE (c)))\n-    return 1;\n+    return true;\n \n   /* Third, unsigned integers with top bit set never fit signed types.  */\n   if (! TYPE_UNSIGNED (type) && unsc)\n@@ -8010,11 +8005,11 @@ int_fits_type_p (const_tree c, const_tree type)\n       if (prec < HOST_BITS_PER_WIDE_INT)\n \t{\n \t  if (((((unsigned HOST_WIDE_INT) 1) << prec) & dc.low) != 0)\n-\t    return 0;\n+\t    return false;\n         }\n       else if (((((unsigned HOST_WIDE_INT) 1)\n \t\t << (prec - HOST_BITS_PER_WIDE_INT)) & dc.high) != 0)\n-\treturn 0;\n+\treturn false;\n     }\n \n   /* If we haven't been able to decide at this point, there nothing more we\n@@ -8028,8 +8023,8 @@ int_fits_type_p (const_tree c, const_tree type)\n       goto retry;\n     }\n \n-  /* Or to fit_double_type, if nothing else.  */\n-  return !fit_double_type (dc.low, dc.high, &dc.low, &dc.high, type);\n+  /* Or to double_int_fits_to_tree_p, if nothing else.  */\n+  return double_int_fits_to_tree_p (type, dc);\n }\n \n /* Stores bounds of an integer TYPE in MIN and MAX.  If TYPE has non-constant"}, {"sha": "59f6b3a96b87552aa0abe830b22210cb33ce9cc6", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e06841144bd5612bc3411a657094c2fb39575f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=88e06841144bd5612bc3411a657094c2fb39575f", "patch": "@@ -5049,7 +5049,7 @@ extern tree strip_float_extensions (tree);\n extern int really_constant_p (const_tree);\n extern bool decl_address_invariant_p (const_tree);\n extern bool decl_address_ip_invariant_p (const_tree);\n-extern int int_fits_type_p (const_tree, const_tree);\n+extern bool int_fits_type_p (const_tree, const_tree);\n #ifndef GENERATOR_FILE\n extern void get_type_static_bounds (const_tree, mpz_t, mpz_t);\n #endif"}]}