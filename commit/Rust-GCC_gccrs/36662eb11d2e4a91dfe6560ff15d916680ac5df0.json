{"sha": "36662eb11d2e4a91dfe6560ff15d916680ac5df0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY2NjJlYjExZDJlNGE5MWRmZTY1NjBmZjE1ZDkxNjY4MGFjNWRmMA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-11-22T14:12:46Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-11-22T14:12:46Z"}, "message": "predicates.md (d_register_operand, [...]): New predicates.\n\n\t* config/bfin/predicates.md (d_register_operand, mem_p_address_operand,\n\tmem_i_address_operand): New predicates.\n\t* config/bfin/bfin.c (bfin_issue_rate): New function.\n\t(TARGET_SCHED_ISSUE_RATE): New macro.\n\t* config/bfin/bfin.md (addrtype): New attribute.\n\t(slot0, slot1, slot2, store, pregs): New cpu_units.\n\t(core): Now a define_reservation.\n\t(alu): Remove some insn types from this reservation.\n\t(dsp32, load32, loadp, loadi, store32, storep, storei, multi): New\n\tinsn reservations.\n\t(dummy reservation): Don't trigger for mcld insns.\n\t(absence_sets): Two new absence sets to enforce slot ordering.\n\t(popsi_insn): Set addrtype.\n\nFrom-SVN: r119090", "tree": {"sha": "55e183690650b3c1e52563f544b5eabce067ce94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55e183690650b3c1e52563f544b5eabce067ce94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36662eb11d2e4a91dfe6560ff15d916680ac5df0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36662eb11d2e4a91dfe6560ff15d916680ac5df0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36662eb11d2e4a91dfe6560ff15d916680ac5df0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36662eb11d2e4a91dfe6560ff15d916680ac5df0/comments", "author": null, "committer": null, "parents": [{"sha": "98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98b44b0eeac41545f8b4d236ba5b3fe1562203aa"}], "stats": {"total": 139, "additions": 132, "deletions": 7}, "files": [{"sha": "500152838dcf58e133798d46a00505a33ab4451e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36662eb11d2e4a91dfe6560ff15d916680ac5df0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36662eb11d2e4a91dfe6560ff15d916680ac5df0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36662eb11d2e4a91dfe6560ff15d916680ac5df0", "patch": "@@ -1,3 +1,19 @@\n+2006-11-22  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/predicates.md (d_register_operand, mem_p_address_operand,\n+\tmem_i_address_operand): New predicates.\n+\t* config/bfin/bfin.c (bfin_issue_rate): New function.\n+\t(TARGET_SCHED_ISSUE_RATE): New macro.\n+\t* config/bfin/bfin.md (addrtype): New attribute.\n+\t(slot0, slot1, slot2, store, pregs): New cpu_units.\n+\t(core): Now a define_reservation.\n+\t(alu): Remove some insn types from this reservation.\n+\t(dsp32, load32, loadp, loadi, store32, storep, storei, multi): New\n+\tinsn reservations.\n+\t(dummy reservation): Don't trigger for mcld insns.\n+\t(absence_sets): Two new absence sets to enforce slot ordering.\n+\t(popsi_insn): Set addrtype.\n+\n 2006-11-22  Ira Rosen  <irar@il.ibm.com>\n \n \t* doc/c-tree.texi: Document new tree codes."}, {"sha": "8a0026857171eea72dee8503f4801c71a288618f", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36662eb11d2e4a91dfe6560ff15d916680ac5df0/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36662eb11d2e4a91dfe6560ff15d916680ac5df0/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=36662eb11d2e4a91dfe6560ff15d916680ac5df0", "patch": "@@ -2816,8 +2816,15 @@ bfin_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp)\n     }\n   return false;\n }\n-\n \f\n+/* Implement TARGET_SCHED_ISSUE_RATE.  */\n+\n+static int\n+bfin_issue_rate (void)\n+{\n+  return 3;\n+}\n+\n static int\n bfin_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n {\n@@ -4527,6 +4534,9 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST bfin_adjust_cost\n \n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE bfin_issue_rate\n+\n #undef TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_true\n #undef TARGET_PROMOTE_FUNCTION_ARGS"}, {"sha": "de4b8b48bbd6f992fd46cc4128c4c552bf579163", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36662eb11d2e4a91dfe6560ff15d916680ac5df0/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36662eb11d2e4a91dfe6560ff15d916680ac5df0/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=36662eb11d2e4a91dfe6560ff15d916680ac5df0", "patch": "@@ -160,28 +160,94 @@\n   \"move,mvi,mcld,mcst,dsp32,mult,alu0,shft,brcc,br,call,misc,sync,compare,dummy\"\n   (const_string \"misc\"))\n \n+(define_attr \"addrtype\" \"32bit,preg,ireg\"\n+  (cond [(and (eq_attr \"type\" \"mcld\")\n+\t      (and (match_operand 0 \"d_register_operand\" \"\")\n+\t\t   (match_operand 1 \"mem_p_address_operand\" \"\")))\n+\t   (const_string \"preg\")\n+\t (and (eq_attr \"type\" \"mcld\")\n+\t      (and (match_operand 0 \"d_register_operand\" \"\")\n+\t\t   (match_operand 1 \"mem_i_address_operand\" \"\")))\n+\t   (const_string \"ireg\")\n+\t (and (eq_attr \"type\" \"mcst\")\n+\t      (and (match_operand 1 \"d_register_operand\" \"\")\n+\t\t   (match_operand 0 \"mem_p_address_operand\" \"\")))\n+\t   (const_string \"preg\")\n+\t (and (eq_attr \"type\" \"mcst\")\n+\t      (and (match_operand 1 \"d_register_operand\" \"\")\n+\t\t   (match_operand 0 \"mem_i_address_operand\" \"\")))\n+\t   (const_string \"ireg\")]\n+\t(const_string \"32bit\")))\n+\n ;; Scheduling definitions\n \n (define_automaton \"bfin\")\n \n-(define_cpu_unit \"core\" \"bfin\")\n+(define_cpu_unit \"slot0\" \"bfin\")\n+(define_cpu_unit \"slot1\" \"bfin\")\n+(define_cpu_unit \"slot2\" \"bfin\")\n+\n+;; Three units used to enforce parallel issue restrictions:\n+;; only one of the 16 bit slots can use a P register in an address,\n+;; and only one them can be a store.\n+(define_cpu_unit \"store\" \"bfin\")\n+(define_cpu_unit \"pregs\" \"bfin\")\n+\n+(define_reservation \"core\" \"slot0+slot1+slot2\")\n \n (define_insn_reservation \"alu\" 1\n-  (eq_attr \"type\" \"move,mvi,mcst,dsp32,alu0,shft,brcc,br,call,misc,sync,compare\")\n+  (eq_attr \"type\" \"move,mvi,alu0,shft,brcc,br,call,misc,sync,compare\")\n   \"core\")\n \n (define_insn_reservation \"imul\" 3\n   (eq_attr \"type\" \"mult\")\n   \"core*3\")\n \n-(define_insn_reservation \"load\" 1\n-  (eq_attr \"type\" \"mcld\")\n+(define_insn_reservation \"dsp32\" 1\n+  (eq_attr \"type\" \"dsp32\")\n+  \"slot0\")\n+\n+(define_insn_reservation \"load32\" 1\n+  (and (not (eq_attr \"seq_insns\" \"multi\"))\n+       (and (eq_attr \"type\" \"mcld\") (eq_attr \"addrtype\" \"32bit\")))\n+  \"core\")\n+\n+(define_insn_reservation \"loadp\" 1\n+  (and (not (eq_attr \"seq_insns\" \"multi\"))\n+       (and (eq_attr \"type\" \"mcld\") (eq_attr \"addrtype\" \"preg\")))\n+  \"(slot1|slot2)+pregs\")\n+\n+(define_insn_reservation \"loadi\" 1\n+  (and (not (eq_attr \"seq_insns\" \"multi\"))\n+       (and (eq_attr \"type\" \"mcld\") (eq_attr \"addrtype\" \"ireg\")))\n+  \"(slot1|slot2)\")\n+\n+(define_insn_reservation \"store32\" 1\n+  (and (not (eq_attr \"seq_insns\" \"multi\"))\n+       (and (eq_attr \"type\" \"mcst\") (eq_attr \"addrtype\" \"32bit\")))\n   \"core\")\n \n+(define_insn_reservation \"storep\" 1\n+  (and (not (eq_attr \"seq_insns\" \"multi\"))\n+       (and (eq_attr \"type\" \"mcst\") (eq_attr \"addrtype\" \"preg\")))\n+  \"(slot1|slot2)+pregs+store\")\n+\n+(define_insn_reservation \"storei\" 1\n+  (and (not (eq_attr \"seq_insns\" \"multi\"))\n+       (and (eq_attr \"type\" \"mcst\") (eq_attr \"addrtype\" \"ireg\")))\n+  \"(slot1|slot2)+store\")\n+\n+(define_insn_reservation \"multi\" 2\n+  (eq_attr \"seq_insns\" \"multi\")\n+  \"core\")\n+\n+(absence_set \"slot0\" \"slot1,slot2\")\n+(absence_set \"slot1\" \"slot2\")\n+\n ;; Make sure genautomata knows about the maximum latency that can be produced\n ;; by the adjust_cost function.\n (define_insn_reservation \"dummy\" 5\n-  (eq_attr \"type\" \"mcld\")\n+  (eq_attr \"type\" \"dummy\")\n   \"core\")\n \f\n ;; Operand and operator predicates\n@@ -254,7 +320,6 @@\n \n \t(const_int 2)))\n \n-\n ;; Classify the insns into those that are one instruction and those that\n ;; are more than one in sequence.\n (define_attr \"seq_insns\" \"single,multi\"\n@@ -445,6 +510,7 @@\n   \"\"\n   \"%0 = [SP++];\"\n   [(set_attr \"type\" \"mcld\")\n+   (set_attr \"addrtype\" \"preg\")\n    (set_attr \"length\" \"2\")])\n \n ;; The first alternative is used to make reload choose a limited register"}, {"sha": "a0a796009ebcf7f8f3fd0fc7da6224c17cef5945", "filename": "gcc/config/bfin/predicates.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36662eb11d2e4a91dfe6560ff15d916680ac5df0/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36662eb11d2e4a91dfe6560ff15d916680ac5df0/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fpredicates.md?ref=36662eb11d2e4a91dfe6560ff15d916680ac5df0", "patch": "@@ -76,6 +76,11 @@\n   return 1;\n })\n \n+;; Return nonzero if OP is a D register.\n+(define_predicate \"d_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"D_REGNO_P (REGNO (op))\")))\n+\n ;; Return nonzero if OP is a LC register.\n (define_predicate \"lc_register_operand\"\n   (and (match_code \"reg\")\n@@ -171,3 +176,31 @@\n ;; Test for an operator valid in a conditional branch\n (define_predicate \"bfin_cbranch_operator\"\n   (match_code \"eq,ne\"))\n+\n+;; The following two are used to compute the addrtype attribute.  They return\n+;; true if passed a memory address usable for a 16-bit load or store using a\n+;; P or I register, respectively.  If neither matches, we know we have a\n+;; 32 bit instruction.\n+(define_predicate \"mem_p_address_operand\"\n+  (match_code \"mem\")\n+{\n+  if (effective_address_32bit_p (op, mode))\n+    return 0;\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == PLUS || GET_RTX_CLASS (GET_CODE (op)) == RTX_AUTOINC)\n+    op = XEXP (op, 0);\n+  gcc_assert (REG_P (op));\n+  return PREG_P (op);\n+})\n+\n+(define_predicate \"mem_i_address_operand\"\n+  (match_code \"mem\")\n+{\n+  if (effective_address_32bit_p (op, mode))\n+    return 0;\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == PLUS || GET_RTX_CLASS (GET_CODE (op)) == RTX_AUTOINC)\n+    op = XEXP (op, 0);\n+  gcc_assert (REG_P (op));\n+  return IREG_P (op);\n+})"}]}