{"sha": "6cc309c9234d18f69b2c70ec0220becf3b0f58f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNjMzA5YzkyMzRkMThmNjliMmM3MGVjMDIyMGJlY2YzYjBmNThmNQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-11-14T00:59:09Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-11-14T00:59:09Z"}, "message": "re PR fortran/33162 (INTRINSIC functions as ACTUAL argument)\n\n2007-11-11  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/33162\n\t* decl.c (match_procedure_decl): Remove TODO and allow intrinsics in\n\tPROCEDURE declarations.  Set attr.untyped to allow the interface to be\n\tresolved later where the symbol type will be set.\n\t* interface.c (compare_intr_interfaces): Remove static from pointer\n\tdeclarations.  Add type and kind checks for dummy function arguments.\n\t(compare_actual_formal_intr): New function to compare an actual\n\targument with an intrinsic function. (gfc_procedures_use): Add check for\n\tinterface that points to an intrinsic function, use the new function.\n\t* resolve.c (resolve_specific_f0): Resolve the intrinsic interface.\n\t(resolve_specific_s0): Ditto.\n\nFrom-SVN: r130168", "tree": {"sha": "c296e0620442c1d321dbe2b55bcada779f15b955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c296e0620442c1d321dbe2b55bcada779f15b955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cc309c9234d18f69b2c70ec0220becf3b0f58f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cc309c9234d18f69b2c70ec0220becf3b0f58f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cc309c9234d18f69b2c70ec0220becf3b0f58f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/comments", "author": null, "committer": null, "parents": [{"sha": "7cbb9e290262fc10104e673248332e1a889ac1b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbb9e290262fc10104e673248332e1a889ac1b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cbb9e290262fc10104e673248332e1a889ac1b4"}], "stats": {"total": 143, "additions": 129, "deletions": 14}, "files": [{"sha": "3b3a2fdec1dbb594359f80f299d4d14339a0c298", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6cc309c9234d18f69b2c70ec0220becf3b0f58f5", "patch": "@@ -1,3 +1,17 @@\n+2007-11-11  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/33162\n+\t* decl.c (match_procedure_decl): Remove TODO and allow intrinsics in\n+\tPROCEDURE declarations.  Set attr.untyped to allow the interface to be\n+\tresolved later where the symbol type will be set.\n+\t* interface.c (compare_intr_interfaces): Remove static from pointer\n+\tdeclarations.  Add type and kind checks for dummy function arguments.\n+\t(compare_actual_formal_intr): New function to compare an actual\n+\targument with an intrinsic function. (gfc_procedures_use): Add check for\n+\tinterface that points to an intrinsic function, use the new function.\n+\t* resolve.c (resolve_specific_f0): Resolve the intrinsic interface.\n+\t(resolve_specific_s0): Ditto.\n+\n 2007-11-13  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/34080"}, {"sha": "29b02ea4cfd41092b01c49b50cd86725d2ac00a8", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=6cc309c9234d18f69b2c70ec0220becf3b0f58f5", "patch": "@@ -3968,19 +3968,9 @@ match_procedure_decl (void)\n \t\t    \"in PROCEDURE statement at %C\", proc_if->name);\n \t  return MATCH_ERROR;\n \t}\n-      /* TODO: Allow intrinsics with gfc_intrinsic_actual_ok\n-\t (proc_if->name, 0) after PR33162 is fixed.  */\n-      if (proc_if->attr.intrinsic)\n-\t{\n-\t  gfc_error (\"Fortran 2003: Support for intrinsic procedure '%s' \"\n-\t\t     \"in PROCEDURE statement at %C not yet implemented \"\n-\t\t     \"in gfortran\", proc_if->name);\n-\t  return MATCH_ERROR;\n-\t}\n     }\n \n got_ts:\n-\n   if (gfc_match (\" )\") != MATCH_YES)\n     {\n       gfc_current_locus = entry_loc;\n@@ -3995,7 +3985,6 @@ match_procedure_decl (void)\n   /* Get procedure symbols.  */\n   for(num=1;;num++)\n     {\n-\n       m = gfc_match_symbol (&sym, 0);\n       if (m == MATCH_NO)\n \tgoto syntax;\n@@ -4040,7 +4029,10 @@ match_procedure_decl (void)\n \n       /* Set interface.  */\n       if (proc_if != NULL)\n-\tsym->interface = proc_if;\n+\t{\n+\t  sym->interface = proc_if;\n+\t  sym->attr.untyped = 1;\n+\t}\n       else if (current_ts.type != BT_UNKNOWN)\n \t{\n \t  sym->interface = gfc_new_symbol (\"\", gfc_current_ns);"}, {"sha": "650cd217de3842b90c1eaf93f67b1b2fd91d1fcb", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=6cc309c9234d18f69b2c70ec0220becf3b0f58f5", "patch": "@@ -977,13 +977,25 @@ compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, int generic_flag)\n static int\n compare_intr_interfaces (gfc_symbol *s1, gfc_symbol *s2)\n {\n-  static gfc_formal_arglist *f, *f1;\n-  static gfc_intrinsic_arg *fi, *f2;\n+  gfc_formal_arglist *f, *f1;\n+  gfc_intrinsic_arg *fi, *f2;\n   gfc_intrinsic_sym *isym;\n \n   if (s1->attr.function != s2->attr.function\n       || s1->attr.subroutine != s2->attr.subroutine)\n     return 0;\t\t/* Disagreement between function/subroutine.  */\n+  \n+  /* If the arguments are functions, check type and kind.  */\n+  \n+  if (s1->attr.dummy && s1->attr.function && s2->attr.function)\n+    {\n+      if (s1->ts.type != s2->ts.type)\n+\treturn 0;\n+      if (s1->ts.kind != s2->ts.kind)\n+\treturn 0;\n+      if (s1->attr.if_source == IFSRC_DECL)\n+\treturn 1;\n+    }\n \n   isym = gfc_find_function (s2->name);\n   \n@@ -1024,6 +1036,55 @@ compare_intr_interfaces (gfc_symbol *s1, gfc_symbol *s2)\n }\n \n \n+/* Compare an actual argument list with an intrinsic argument list.  */\n+\n+static int\n+compare_actual_formal_intr (gfc_actual_arglist **ap, gfc_symbol *s2)\n+{\n+  gfc_actual_arglist *a;\n+  gfc_intrinsic_arg *fi, *f2;\n+  gfc_intrinsic_sym *isym;\n+\n+  isym = gfc_find_function (s2->name);\n+  \n+  /* This should already have been checked in\n+     resolve.c (resolve_actual_arglist).  */\n+  gcc_assert (isym);\n+\n+  f2 = isym->formal;\n+\n+  /* Special case.  */\n+  if (*ap == NULL && f2 == NULL)\n+    return 1;\n+  \n+  /* First scan through the actual argument list and check the intrinsic.  */\n+  fi = f2;\n+  for (a = *ap; a; a = a->next)\n+    {\n+      if (fi == NULL)\n+\treturn 0;\n+      if ((fi->ts.type != a->expr->ts.type)\n+\t  || (fi->ts.kind != a->expr->ts.kind))\n+\treturn 0;\n+      fi = fi->next;\n+    }\n+\n+  /* Now scan through the intrinsic argument list and check the formal.  */\n+  a = *ap;\n+  for (fi = f2; fi; fi = fi->next)\n+    {\n+      if (a == NULL)\n+\treturn 0;\n+      if ((fi->ts.type != a->expr->ts.type)\n+\t  || (fi->ts.kind != a->expr->ts.kind))\n+\treturn 0;\n+      a = a->next;\n+    }\n+\n+  return 1;\n+}\n+\n+\n /* Given a pointer to an interface pointer, remove duplicate\n    interfaces and make sure that all symbols are either functions or\n    subroutines.  Returns nonzero if something goes wrong.  */\n@@ -2225,6 +2286,20 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n     gfc_warning (\"Procedure '%s' called with an implicit interface at %L\",\n \t\t sym->name, where);\n \n+  if (sym->interface && sym->interface->attr.intrinsic)\n+    {\n+      gfc_intrinsic_sym *isym;\n+      isym = gfc_find_function (sym->interface->name);\n+      if (isym != NULL)\n+\t{\n+\t  if (compare_actual_formal_intr (ap, sym->interface))\n+\t    return;\n+\t  gfc_error (\"Type/rank mismatch in argument '%s' at %L\",\n+\t\t     sym->name, where);\n+\t  return;\n+\t}\n+    }\n+\n   if (sym->attr.if_source == IFSRC_UNKNOWN\n       || !compare_actual_formal (ap, sym->formal, 0,\n \t\t\t\t sym->attr.elemental, where))"}, {"sha": "3f3ef03aba6aeee88143276a4bb6fe4c4ba0c43b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc309c9234d18f69b2c70ec0220becf3b0f58f5/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6cc309c9234d18f69b2c70ec0220becf3b0f58f5", "patch": "@@ -1074,6 +1074,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t  if (sym->ts.type == BT_UNKNOWN && sym->attr.intrinsic)\n \t    {\n \t      gfc_intrinsic_sym *isym;\n+\n \t      isym = gfc_find_function (sym->name);\n \t      if (isym == NULL || !isym->specific)\n \t\t{\n@@ -1083,6 +1084,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t\t  return FAILURE;\n \t\t}\n \t      sym->ts = isym->ts;\n+\t      sym->attr.intrinsic = 1;\n \t      sym->attr.function = 1;\n \t    }\n \t  goto argument_list;\n@@ -1487,6 +1489,22 @@ resolve_specific_f0 (gfc_symbol *sym, gfc_expr *expr)\n {\n   match m;\n \n+  /* See if we have an intrinsic interface.  */\n+\n+  if (sym->interface != NULL && sym->interface->attr.intrinsic)\n+    {\n+      gfc_intrinsic_sym *isym;\n+      isym = gfc_find_function (sym->interface->name);\n+\n+      /* Existance of isym should be checked already.  */\n+      gcc_assert (isym);\n+\n+      sym->ts = isym->ts;\n+      sym->attr.function = 1;\n+      sym->attr.proc = PROC_EXTERNAL;\n+      goto found;\n+    }\n+\n   if (sym->attr.external || sym->attr.if_source == IFSRC_IFBODY)\n     {\n       if (sym->attr.dummy)\n@@ -2513,6 +2531,22 @@ resolve_specific_s0 (gfc_code *c, gfc_symbol *sym)\n {\n   match m;\n \n+  /* See if we have an intrinsic interface.  */\n+  if (sym->interface != NULL && !sym->interface->attr.abstract\n+      && !sym->interface->attr.subroutine)\n+    {\n+      gfc_intrinsic_sym *isym;\n+\n+      isym = gfc_find_function (sym->interface->name);\n+\n+      /* Existance of isym should be checked already.  */\n+      gcc_assert (isym);\n+\n+      sym->ts = isym->ts;\n+      sym->attr.function = 1;\n+      goto found;\n+    }\n+\n   if(sym->attr.is_iso_c)\n     {\n       m = gfc_iso_c_sub_interface (c,sym);"}]}