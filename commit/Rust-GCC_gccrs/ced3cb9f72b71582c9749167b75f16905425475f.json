{"sha": "ced3cb9f72b71582c9749167b75f16905425475f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VkM2NiOWY3MmI3MTU4MmM5NzQ5MTY3Yjc1ZjE2OTA1NDI1NDc1Zg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-09-30T13:48:55Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-09-30T13:48:55Z"}, "message": "PR libstdc++/30085 (again)\n\n2008-09-30  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR libstdc++/30085 (again)\n\t* include/debug/unordered_map (unordered_map<>, unordered_multimap<>):\n\tDo not derive from _Safe_association, derive from _GLIBCXX_STD_D::\n\tunordered_map / unordered_multimap; add missing member functions.\n\t* include/debug/unordered_set (unordered_set<>, unordered_multiset<>):\n\tLikewise for _GLIBCXX_STD_D::unordered_set / unordered_multiset.\n\t* include/debug/safe_association.h: Remove.\n\t* include/Makefile.am: Adjust.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/23_containers/unordered_multimap/init-list.cc: Remove\n\txfail.\n\nFrom-SVN: r140786", "tree": {"sha": "400e99a4bab4047166e4e2712047bdb45ef241d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/400e99a4bab4047166e4e2712047bdb45ef241d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ced3cb9f72b71582c9749167b75f16905425475f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced3cb9f72b71582c9749167b75f16905425475f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced3cb9f72b71582c9749167b75f16905425475f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced3cb9f72b71582c9749167b75f16905425475f/comments", "author": null, "committer": null, "parents": [{"sha": "1847ea4d9f7d3e7e33764a1fea399d66e528c8e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1847ea4d9f7d3e7e33764a1fea399d66e528c8e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1847ea4d9f7d3e7e33764a1fea399d66e528c8e2"}], "stats": {"total": 1140, "additions": 782, "deletions": 358}, "files": [{"sha": "82fbe09a561d7e6add11e9ca7f20b8c1df4ff239", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=ced3cb9f72b71582c9749167b75f16905425475f", "patch": "@@ -696,7 +696,6 @@ debug_headers = \\\n \t${debug_srcdir}/map.h \\\n \t${debug_srcdir}/multimap.h \\\n \t${debug_srcdir}/multiset.h \\\n-\t${debug_srcdir}/safe_association.h \\\n \t${debug_srcdir}/safe_base.h \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\"}, {"sha": "b26375817f095502f624848a331357db714c021d", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=ced3cb9f72b71582c9749167b75f16905425475f", "patch": "@@ -953,7 +953,6 @@ debug_headers = \\\n \t${debug_srcdir}/map.h \\\n \t${debug_srcdir}/multimap.h \\\n \t${debug_srcdir}/multiset.h \\\n-\t${debug_srcdir}/safe_association.h \\\n \t${debug_srcdir}/safe_base.h \\\n \t${debug_srcdir}/safe_iterator.h \\\n \t${debug_srcdir}/safe_iterator.tcc \\"}, {"sha": "de8945301f65d8e73793084e10a9489d7f4cc77c", "filename": "libstdc++-v3/include/debug/safe_association.h", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1847ea4d9f7d3e7e33764a1fea399d66e528c8e2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1847ea4d9f7d3e7e33764a1fea399d66e528c8e2/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h?ref=1847ea4d9f7d3e7e33764a1fea399d66e528c8e2", "patch": "@@ -1,222 +0,0 @@\n-// Safe associated container base class implementation  -*- C++ -*-\n-\n-// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file debug/safe_association.h\n- *  This file is a GNU debug extension to the Standard C++ Library.\n- */\n-\n-#ifndef _GLIBCXX_DEBUG_SAFE_ASSOCIATION_H\n-#define _GLIBCXX_DEBUG_SAFE_ASSOCIATION_H 1\n-\n-#include <debug/debug.h>\n-#include <debug/macros.h>\n-#include <debug/functions.h>\n-#include <debug/formatter.h>\n-#include <debug/safe_sequence.h>\n-\n-namespace __gnu_debug\n-{\n-  /**\n-   * @brief Base class for constructing a \"safe\" associated container type.\n-   *\n-   * The class template %_Safe_association simplifies the construction of\n-   * \"safe\" associated containers.\n-   */\n-  template<typename _Base>\n-    class _Safe_association \n-    : public _Base\n-    {\n-    public:\n-      typedef typename _Base::size_type       size_type;\n-      typedef typename _Base::hasher          hasher;\n-      typedef typename _Base::key_equal       key_equal;\n-      typedef typename _Base::allocator_type allocator_type;\n-\n-      typedef typename _Base::key_type        key_type;\n-      typedef typename _Base::value_type      value_type;\n-      typedef typename _Base::difference_type difference_type;\n-      typedef typename _Base::reference       reference;\n-      typedef typename _Base::const_reference const_reference;\n-\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, \n-\t\t\t\t\t  _Safe_association>\n-                                              iterator;\n-      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n-\t\t\t\t\t  _Safe_association>\n-                                              const_iterator;\n-\n-      _Safe_association() { }\n-\n-      explicit _Safe_association(size_type __n) : _Base(__n) { }\n-\n-      _Safe_association(size_type __n, const hasher& __hf) \n-      : _Base(__n, __hf) { }\n-\n-      _Safe_association(size_type __n, const hasher& __hf, \n-\t\t\tconst key_equal& __eql,\n-\t\t\tconst allocator_type& __a = allocator_type())\n-      : _Base(__n, __hf, __eql, __a) { }\n-\n-      template<typename _InputIter>\n-        _Safe_association(_InputIter __f, _InputIter __l)\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l) { }\n-\n-      template<typename _InputIter>\n-        _Safe_association(_InputIter __f, _InputIter __l, size_type __n)\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n) { }\n-\n-      template<typename _InputIter>\n-        _Safe_association(_InputIter __f, _InputIter __l, size_type __n,\n-\t\t      const hasher& __hf)\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf) \n-        { }\n-\n-      template<typename _InputIter>\n-        _Safe_association(_InputIter __f, _InputIter __l, size_type __n,\n-\t\t\t  const hasher& __hf, const key_equal& __eql,\n-\t\t\t  const allocator_type& __a = allocator_type())\n-\t: _Base(__gnu_debug::__check_valid_range(__f, __l), \n-\t\t__l, __n, __hf, __eql, __a) \n-        { }\n-\n-      _Safe_association(std::initializer_list<value_type> __l,\n-\t\t\tsize_type __n,\n-\t\t\tconst hasher& __hf,\n-\t\t\tconst key_equal& __eql,\n-\t\t\tconst allocator_type& __a = allocator_type())\n-      : _Base(__l, __n, __hf, __eql, __a)\n-      { }\n-\n-      _Safe_association(const _Base& __x) : _Base(__x) { }\n-\n-      _Safe_association(_Safe_association&& __x)\n-      : _Base(std::forward<_Base>(__x)) { }\n-\n-      using _Base::size;\n-      using _Base::max_size;\n-      using _Base::empty;\n-      using _Base::get_allocator;\n-      using _Base::key_eq;\n-\n-      using _Base::count;\n-      using _Base::bucket_count;\n-      using _Base::max_bucket_count;\n-      using _Base::bucket;\n-      using _Base::bucket_size;\n-      using _Base::load_factor;\n-\n-      const_iterator\n-      begin() const { return const_iterator(_Base::begin(), this); }\n-\n-      const_iterator\n-      end() const   { return const_iterator(_Base::end(), this); }\n-\n-      std::pair<iterator, bool>\n-      insert(const value_type& __obj)\n-      {\n-\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n-\t__pair_type __res = _Base::insert(__obj);\n-\treturn std::make_pair(iterator(__res.first, this), __res.second);\n-      }\n-\n-      void\n-      insert(const value_type* __first, const value_type* __last)\n-      {\n-\t__glibcxx_check_valid_range(__first, __last);\n-\t_Base::insert(__first, __last);\n-      }\n-\n-      template<typename _InputIter>\n-        void\n-        insert(_InputIter __first, _InputIter __last)\n-        {\n-\t  __glibcxx_check_valid_range(__first, __last);\n-\t  _Base::insert(__first.base(), __last.base());\n-\t}\n-\n-      void\n-      insert(std::initializer_list<value_type> __l)\n-      { _Base::insert(__l); }\n-\n-      const_iterator\n-      find(const key_type& __key) const\n-      { return const_iterator(_Base::find(__key), this); }\n-\n-      std::pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __key) const\n-      {\n-\ttypedef typename _Base::const_iterator _Base_iterator;\n-\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n-\t__pair_type __res = _Base::equal_range(__key);\n-\treturn std::make_pair(const_iterator(__res.first, this),\n-\t\t\t      const_iterator(__res.second, this));\n-      }\n-\n-      size_type\n-      erase(const key_type& __key)\n-      {\n-\tsize_type __ret(0);\n-\titerator __victim(_Base::find(__key), this);\n-\tif (__victim != end())\n-\t  {\n-\t    this->erase(__victim);\n-\t    __ret = 1;\n-\t  }\n-\treturn __ret;\n-      }\n-\n-      iterator\n-      erase(iterator __it)\n-      {\n-\t__glibcxx_check_erase(__it);\n-\t__it._M_invalidate();\n-\treturn iterator(_Base::erase(__it.base()));\n-      }\n-\n-      iterator\n-      erase(iterator __first, iterator __last)\n-      {\n-\t__glibcxx_check_erase_range(__first, __last);\n-\tfor (iterator __tmp = __first; __tmp != __last;)\n-\t{\n-\t  iterator __victim = __tmp++;\n-\t  __victim._M_invalidate();\n-\t}\n-\treturn iterator(_Base::erase(__first.base(), __last.base()));\n-      }\n-\n-      _Base&\n-      _M_base() { return *this; }\n-\n-      const _Base&\n-      _M_base() const { return *this; }\n-    };\n-} // namespace __gnu_debug\n-\n-#endif"}, {"sha": "dcd76ad98940b5342674003e232e79e910cad650", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 391, "deletions": 65, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=ced3cb9f72b71582c9749167b75f16905425475f", "patch": "@@ -1,6 +1,6 @@\n // Debugging unordered_map/unordered_multimap implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -40,65 +40,81 @@\n #else\n # include <c++0x_warning.h>\n #endif\n-#include <initializer_list>\n-#include <debug/safe_association.h>\n-#include <debug/safe_iterator.h>\n \n-#define _GLIBCXX_BASE unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\n-#define _GLIBCXX_STD_BASE _GLIBCXX_STD_D::_GLIBCXX_BASE\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+#include <initializer_list>\n \n namespace std\n {\n namespace __debug\n {\n   template<typename _Key, typename _Tp,\n-\t   typename _Hash  = std::hash<_Key>,\n+\t   typename _Hash = std::hash<_Key>,\n \t   typename _Pred = std::equal_to<_Key>,\n-\t   typename _Alloc =  std::allocator<_Key> >\n+\t   typename _Alloc = std::allocator<_Key> >\n     class unordered_map\n-    : public __gnu_debug::_Safe_association<_GLIBCXX_STD_BASE>,\n-      public __gnu_debug::_Safe_sequence<_GLIBCXX_BASE>\n+    : public _GLIBCXX_STD_D::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>,\n+      public __gnu_debug::_Safe_sequence<unordered_map<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t       _Pred, _Alloc> >\n     {\n-      typedef typename _GLIBCXX_STD_BASE _Base;\n-      typedef __gnu_debug::_Safe_association<_Base> _Safe_assoc;\n+      typedef _GLIBCXX_STD_D::unordered_map<_Key, _Tp, _Hash,\n+\t\t\t\t\t    _Pred, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<unordered_map> _Safe_base;\n \n     public:\n-      typedef typename _Safe_assoc::size_type       size_type;\n-      typedef typename _Safe_assoc::value_type      value_type;\n-      typedef typename _Safe_assoc::hasher          hasher;\n-      typedef typename _Safe_assoc::key_equal       key_equal;\n-      typedef typename _Safe_assoc::allocator_type allocator_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+\t\t\t\t\t  unordered_map> iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t  unordered_map> const_iterator;\n \n       explicit\n       unordered_map(size_type __n = 10,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Safe_assoc(__n, __hf, __eql, __a)\n-      { }\n+      : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n         unordered_map(_InputIterator __f, _InputIterator __l, \n \t\t      size_type __n = 10,\n \t\t      const hasher& __hf = hasher(), \n \t\t      const key_equal& __eql = key_equal(), \n \t\t      const allocator_type& __a = allocator_type())\n-\t: _Safe_assoc(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n,\n+\t\t__hf, __eql, __a), _Safe_base() { }\n \n-      unordered_map(const _Safe_assoc& __x) \n-      : _Safe_assoc(__x), _Safe_base() { }\n+      unordered_map(const unordered_map& __x) \n+      : _Base(__x), _Safe_base() { }\n \n-      unordered_map(unordered_map&& __x) \n-      : _Safe_assoc(std::forward<_Safe_assoc>(__x)), _Safe_base() { }\n+      unordered_map(const _Base& __x)\n+      : _Base(__x), _Safe_base() { }\n+\n+      unordered_map(unordered_map&& __x)\n+      : _Base(std::forward<unordered_map>(__x)), _Safe_base() { }\n \n       unordered_map(initializer_list<value_type> __l,\n \t\t    size_type __n = 10,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-\t: _Safe_assoc(__l, __n, __hf, __eql, __a) { }\n+      : _Base(__l, __n, __hf, __eql, __a), _Safe_base() { }\n+\n+      unordered_map&\n+      operator=(const unordered_map& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n \n       unordered_map&\n       operator=(unordered_map&& __x)\n@@ -120,7 +136,7 @@ namespace __debug\n       void\n       swap(unordered_map&& __x)\n       {\n-\t_Safe_assoc::swap(__x);\n+\t_Base::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n \n@@ -131,13 +147,168 @@ namespace __debug\n \tthis->_M_invalidate_all();\n       }\n \n+      iterator \n+      begin()\n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      // local versions\n+      using _Base::begin;\n+      using _Base::end;\n+      using _Base::cbegin;\n+      using _Base::cend;\n+\n+      std::pair<iterator, bool>\n+      insert(const value_type& __obj)\n+      {\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(__obj);\n+\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+      }\n+\n+      iterator\n+      insert(iterator, const value_type& __obj)\n+      {\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(__obj);\n+\treturn iterator(__res.first, this);\n+      }\n+\n+      const_iterator\n+      insert(const_iterator, const value_type& __obj)\n+      {\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(__obj);\n+\treturn const_iterator(__res.first, this);\n+      }\n+\n+      void\n+      insert(std::initializer_list<value_type> __l)\n+      { _Base::insert(__l); }\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first, __last);\n+\t}\n+\n+      iterator\n+      find(const key_type& __key)\n+      { return iterator(_Base::find(__key), this); }\n+\n+      const_iterator\n+      find(const key_type& __key) const\n+      { return const_iterator(_Base::find(__key), this); }\n+\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __key)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+\n+      size_type\n+      erase(const key_type& __key)\n+      {\n+\tsize_type __ret(0);\n+\titerator __victim(_Base::find(__key), this);\n+\tif (__victim != end())\n+\t  {\n+\t    this->erase(__victim);\n+\t    __ret = 1;\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      iterator\n+      erase(iterator __it)\n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\treturn iterator(_Base::erase(__it.base()), this);\n+      }\n+\n+      const_iterator\n+      erase(const_iterator __it)\n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\treturn const_iterator(_Base::erase(__it.base()), this);\n+      }\n+\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\treturn iterator(_Base::erase(__first.base(),\n+\t\t\t\t     __last.base()), this);\n+      }\n+\n+      const_iterator\n+      erase(const_iterator __first, const_iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (const_iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  const_iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\treturn const_iterator(_Base::erase(__first.base(),\n+\t\t\t\t\t   __last.base()), this);\n+      }\n+\n+      _Base&\n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n     private:\n       void\n       _M_invalidate_all()\n       {\n \ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(this->_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n       }\n     };\n \n@@ -162,59 +333,74 @@ namespace __debug\n \t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&& __y)\n     { __x.swap(__y); }\n \n-#undef _GLIBCXX_BASE\n-#undef _GLIBCXX_STD_BASE\n-#define _GLIBCXX_STD_BASE _GLIBCXX_STD_D::_GLIBCXX_BASE\n-#define _GLIBCXX_BASE unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\n \n   template<typename _Key, typename _Tp,\n-\t   typename _Hash  = std::hash<_Key>,\n+\t   typename _Hash = std::hash<_Key>,\n \t   typename _Pred = std::equal_to<_Key>,\n-\t   typename _Alloc =  std::allocator<_Key> >\n+\t   typename _Alloc = std::allocator<_Key> >\n     class unordered_multimap\n-    : public __gnu_debug::_Safe_association<_GLIBCXX_STD_BASE>,\n-      public __gnu_debug::_Safe_sequence<_GLIBCXX_BASE>\n+    : public _GLIBCXX_STD_D::unordered_multimap<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t_Pred, _Alloc>,\n+      public __gnu_debug::_Safe_sequence<unordered_multimap<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t\t    _Pred, _Alloc> >\n     {\n-      typedef typename _GLIBCXX_STD_BASE _Base;\n-      typedef __gnu_debug::_Safe_association<_Base> _Safe_assoc;\n+      typedef _GLIBCXX_STD_D::unordered_multimap<_Key, _Tp, _Hash,\n+\t\t\t\t\t\t _Pred, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<unordered_multimap> _Safe_base;\n \n     public:\n-      typedef typename _Safe_assoc::size_type       size_type;\n-      typedef typename _Safe_assoc::value_type      value_type;\n-      typedef typename _Safe_assoc::hasher          hasher;\n-      typedef typename _Safe_assoc::key_equal       key_equal;\n-      typedef typename _Safe_assoc::allocator_type allocator_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+\t\t\t\t\t  unordered_multimap> iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t  unordered_multimap> const_iterator;\n \n       explicit\n       unordered_multimap(size_type __n = 10,\n-\t\t    const hasher& __hf = hasher(),\n-\t\t    const key_equal& __eql = key_equal(),\n-\t\t    const allocator_type& __a = allocator_type())\n-      : _Safe_assoc(__n, __hf, __eql, __a)\n-      { }\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n         unordered_multimap(_InputIterator __f, _InputIterator __l, \n-\t\t      size_type __n = 10,\n-\t\t      const hasher& __hf = hasher(), \n-\t\t      const key_equal& __eql = key_equal(), \n-\t\t      const allocator_type& __a = allocator_type())\n-\t: _Safe_assoc(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t\t\t   size_type __n = 10,\n+\t\t\t   const hasher& __hf = hasher(), \n+\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const allocator_type& __a = allocator_type())\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n,\n+\t\t__hf, __eql, __a), _Safe_base() { }\n+\n+      unordered_multimap(const unordered_multimap& __x) \n+      : _Base(__x), _Safe_base() { }\n+\n+      unordered_multimap(const _Base& __x) \n+      : _Base(__x), _Safe_base() { }\n+\n+      unordered_multimap(unordered_multimap&& __x) \n+      : _Base(std::forward<unordered_multimap>(__x)), _Safe_base() { }\n \n       unordered_multimap(initializer_list<value_type> __l,\n \t\t\t size_type __n = 10,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-\t: _Safe_assoc(__l, __n, __hf, __eql, __a) { }\n-\n-      unordered_multimap(const _Safe_assoc& __x) \n-      : _Safe_assoc(__x), _Safe_base() { }\n+      : _Base(__l, __n, __hf, __eql, __a), _Safe_base() { }\n \n-      unordered_multimap(unordered_multimap&& __x) \n-      : _Safe_assoc(std::forward<_Safe_assoc>(__x)), _Safe_base() { }\n+      unordered_multimap&\n+      operator=(const unordered_multimap& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n \n       unordered_multimap&\n       operator=(unordered_multimap&& __x)\n@@ -236,7 +422,7 @@ namespace __debug\n       void\n       swap(unordered_multimap&& __x)\n       {\n-\t_Safe_assoc::swap(__x);\n+\t_Base::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n \n@@ -247,13 +433,156 @@ namespace __debug\n \tthis->_M_invalidate_all();\n       }\n \n+      iterator \n+      begin()\n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      // local versions\n+      using _Base::begin;\n+      using _Base::end;\n+      using _Base::cbegin;\n+      using _Base::cend;\n+\n+      iterator\n+      insert(const value_type& __obj)\n+      { return iterator(_Base::insert(__obj), this); }\n+\n+      iterator\n+      insert(iterator, const value_type& __obj)\n+      { return iterator(_Base::insert(__obj), this); }\n+\n+      const_iterator\n+      insert(const_iterator, const value_type& __obj)\n+      { return const_iterator(_Base::insert(__obj), this); }\n+\n+      void\n+      insert(std::initializer_list<value_type> __l)\n+      { _Base::insert(__l); }\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first, __last);\n+\t}\n+\n+      iterator\n+      find(const key_type& __key)\n+      { return iterator(_Base::find(__key), this); }\n+\n+      const_iterator\n+      find(const key_type& __key) const\n+      { return const_iterator(_Base::find(__key), this); }\n+\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __key)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+\n+      size_type\n+      erase(const key_type& __key)\n+      {\n+\tsize_type __ret(0);\n+\titerator __victim(_Base::find(__key), this);\n+\tif (__victim != end())\n+\t  {\n+\t    this->erase(__victim);\n+\t    __ret = 1;\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      iterator\n+      erase(iterator __it)\n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\treturn iterator(_Base::erase(__it.base()), this);\n+      }\n+\n+      const_iterator\n+      erase(const_iterator __it)\n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\treturn const_iterator(_Base::erase(__it.base()), this);\n+      }\n+\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\treturn iterator(_Base::erase(__first.base(),\n+\t\t\t\t     __last.base()), this);\n+      }\n+\n+      const_iterator\n+      erase(const_iterator __first, const_iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (const_iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  const_iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\treturn const_iterator(_Base::erase(__first.base(),\n+\t\t\t\t\t   __last.base()), this);\n+      }\n+\n+      _Base&\n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n     private:\n       void\n       _M_invalidate_all()\n       {\n \ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(this->_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n       }\n     };\n \n@@ -281,7 +610,4 @@ namespace __debug\n } // namespace __debug\n } // namespace std\n \n-#undef _GLIBCXX_BASE\n-#undef _GLIBCXX_STD_BASE\n-\n #endif"}, {"sha": "7414cfc6b9783d2aa5f78ff96ecdc7fad065506c", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 391, "deletions": 67, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=ced3cb9f72b71582c9749167b75f16905425475f", "patch": "@@ -1,6 +1,6 @@\n // Debugging unordered_set/unordered_multiset implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2004, 2005, 2006, 2007\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -41,65 +41,80 @@\n # include <c++0x_warning.h>\n #endif\n \n-#include <initializer_list>\n-#include <debug/safe_association.h>\n+#include <debug/safe_sequence.h>\n #include <debug/safe_iterator.h>\n-\n-#define _GLIBCXX_BASE unordered_set<_Value, _Hash, _Pred, _Alloc>\n-#define _GLIBCXX_STD_BASE _GLIBCXX_STD_D::_GLIBCXX_BASE\n+#include <initializer_list>\n \n namespace std\n {\n namespace __debug\n {\n   template<typename _Value,\n-\t   typename _Hash  = std::hash<_Value>,\n+\t   typename _Hash = std::hash<_Value>,\n \t   typename _Pred = std::equal_to<_Value>,\n-\t   typename _Alloc =  std::allocator<_Value> >\n+\t   typename _Alloc = std::allocator<_Value> >\n     class unordered_set\n-    : public __gnu_debug::_Safe_association<_GLIBCXX_STD_BASE>,\n-      public __gnu_debug::_Safe_sequence<_GLIBCXX_BASE>\n+    : public _GLIBCXX_STD_D::unordered_set<_Value, _Hash, _Pred, _Alloc>,\n+      public __gnu_debug::_Safe_sequence<unordered_set<_Value, _Hash,\n+\t\t\t\t\t\t       _Pred, _Alloc> >\n     {\n-      typedef typename _GLIBCXX_STD_BASE _Base;\n-      typedef __gnu_debug::_Safe_association<_Base> _Safe_assoc;\n+      typedef _GLIBCXX_STD_D::unordered_set<_Value, _Hash,\n+\t\t\t\t\t    _Pred, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<unordered_set> _Safe_base;\n \n     public:\n-      typedef typename _Safe_assoc::size_type       size_type;\n-      typedef typename _Safe_assoc::value_type      value_type;\n-      typedef typename _Safe_assoc::hasher          hasher;\n-      typedef typename _Safe_assoc::key_equal       key_equal;\n-      typedef typename _Safe_assoc::allocator_type allocator_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+\t\t\t\t\t  unordered_set> iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t  unordered_set> const_iterator;\n \n       explicit\n       unordered_set(size_type __n = 10,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-      : _Safe_assoc(__n, __hf, __eql, __a)\n-      { }\n+      : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n         unordered_set(_InputIterator __f, _InputIterator __l, \n \t\t      size_type __n = 10,\n \t\t      const hasher& __hf = hasher(), \n \t\t      const key_equal& __eql = key_equal(), \n \t\t      const allocator_type& __a = allocator_type())\n-\t: _Safe_assoc(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n,\n+\t\t__hf, __eql, __a), _Safe_base() { }\n+\n+      unordered_set(const unordered_set& __x) \n+      : _Base(__x), _Safe_base() { }\n+\n+      unordered_set(const _Base& __x) \n+      : _Base(__x), _Safe_base() { }\n+\n+      unordered_set(unordered_set&& __x) \n+      : _Base(std::forward<unordered_set>(__x)), _Safe_base() { }\n \n       unordered_set(initializer_list<value_type> __l,\n \t\t    size_type __n = 10,\n \t\t    const hasher& __hf = hasher(),\n \t\t    const key_equal& __eql = key_equal(),\n \t\t    const allocator_type& __a = allocator_type())\n-\t: _Safe_assoc(__l, __n, __hf, __eql, __a) { }\n-\n-      unordered_set(const _Safe_assoc& __x) \n-      : _Safe_assoc(__x), _Safe_base() { }\n+      : _Base(__l, __n, __hf, __eql, __a), _Safe_base() { }\n \n-      unordered_set(unordered_set&& __x) \n-      : _Safe_assoc(std::forward<_Safe_assoc>(__x)), _Safe_base() { }\n+      unordered_set&\n+      operator=(const unordered_set& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n \n       unordered_set&\n       operator=(unordered_set&& __x)\n@@ -121,7 +136,7 @@ namespace __debug\n       void\n       swap(unordered_set&& __x)\n       {\n-\t_Safe_assoc::swap(__x);\n+\t_Base::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n \n@@ -132,13 +147,168 @@ namespace __debug\n \tthis->_M_invalidate_all();\n       }\n \n+      iterator \n+      begin()\n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      // local versions\n+      using _Base::begin;\n+      using _Base::end;\n+      using _Base::cbegin;\n+      using _Base::cend;\n+\n+      std::pair<iterator, bool>\n+      insert(const value_type& __obj)\n+      {\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(__obj);\n+\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+      }\n+\n+      iterator\n+      insert(iterator, const value_type& __obj)\n+      {\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(__obj);\n+\treturn iterator(__res.first, this);\n+      }\n+\n+      const_iterator\n+      insert(const_iterator, const value_type& __obj)\n+      {\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(__obj);\n+\treturn const_iterator(__res.first, this);\n+      }\n+\n+      void\n+      insert(std::initializer_list<value_type> __l)\n+      { _Base::insert(__l); }\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first, __last);\n+\t}\n+\n+      iterator\n+      find(const key_type& __key)\n+      { return iterator(_Base::find(__key), this); }\n+\n+      const_iterator\n+      find(const key_type& __key) const\n+      { return const_iterator(_Base::find(__key), this); }\n+\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __key)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+\n+      size_type\n+      erase(const key_type& __key)\n+      {\n+\tsize_type __ret(0);\n+\titerator __victim(_Base::find(__key), this);\n+\tif (__victim != end())\n+\t  {\n+\t    this->erase(__victim);\n+\t    __ret = 1;\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      iterator\n+      erase(iterator __it)\n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\treturn iterator(_Base::erase(__it.base()), this);\n+      }\n+\n+      const_iterator\n+      erase(const_iterator __it)\n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\treturn const_iterator(_Base::erase(__it.base()), this);\n+      }\n+\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\treturn iterator(_Base::erase(__first.base(),\n+\t\t\t\t     __last.base()), this);\n+      }\n+\n+      const_iterator\n+      erase(const_iterator __first, const_iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (const_iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  const_iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\treturn const_iterator(_Base::erase(__first.base(),\n+\t\t\t\t\t   __last.base()), this);\n+      }\n+\n+      _Base&\n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n     private:\n       void\n       _M_invalidate_all()\n       {\n \ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(this->_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n       }\n     };\n \n@@ -160,59 +330,73 @@ namespace __debug\n \t unordered_set<_Value, _Hash, _Pred, _Alloc>&& __y)\n     { __x.swap(__y); }\n \n-#undef _GLIBCXX_BASE\n-#undef _GLIBCXX_STD_BASE\n-#define _GLIBCXX_STD_BASE _GLIBCXX_STD_D::_GLIBCXX_BASE\n-#define _GLIBCXX_BASE unordered_multiset<_Value, _Hash, _Pred, _Alloc>\n \n   template<typename _Value,\n-\t   typename _Hash  = std::hash<_Value>,\n+\t   typename _Hash = std::hash<_Value>,\n \t   typename _Pred = std::equal_to<_Value>,\n-\t   typename _Alloc =  std::allocator<_Value> >\n+\t   typename _Alloc = std::allocator<_Value> >\n     class unordered_multiset\n-    : public __gnu_debug::_Safe_association<_GLIBCXX_STD_BASE>,\n-      public __gnu_debug::_Safe_sequence<_GLIBCXX_BASE>\n+    : public _GLIBCXX_STD_D::unordered_multiset<_Value, _Hash, _Pred, _Alloc>,\n+      public __gnu_debug::_Safe_sequence<unordered_multiset<_Value, _Hash,\n+\t\t\t\t\t\t\t    _Pred, _Alloc> >\n     {\n-      typedef typename _GLIBCXX_STD_BASE _Base;\n-      typedef __gnu_debug::_Safe_association<_Base> _Safe_assoc;\n+      typedef _GLIBCXX_STD_D::unordered_multiset<_Value, _Hash,\n+\t\t\t\t\t\t _Pred, _Alloc> _Base;\n       typedef __gnu_debug::_Safe_sequence<unordered_multiset> _Safe_base;\n \n     public:\n-      typedef typename _Safe_assoc::size_type       size_type;\n-      typedef typename _Safe_assoc::value_type      value_type;\n-      typedef typename _Safe_assoc::hasher          hasher;\n-      typedef typename _Safe_assoc::key_equal       key_equal;\n-      typedef typename _Safe_assoc::allocator_type allocator_type;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::allocator_type  allocator_type;\n+\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,\n+\t\t\t\t\t  unordered_multiset> iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t  unordered_multiset> const_iterator;\n \n       explicit\n       unordered_multiset(size_type __n = 10,\n-\t\t    const hasher& __hf = hasher(),\n-\t\t    const key_equal& __eql = key_equal(),\n-\t\t    const allocator_type& __a = allocator_type())\n-      : _Safe_assoc(__n, __hf, __eql, __a)\n-      { }\n+\t\t\t const hasher& __hf = hasher(),\n+\t\t\t const key_equal& __eql = key_equal(),\n+\t\t\t const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a) { }\n \n       template<typename _InputIterator>\n         unordered_multiset(_InputIterator __f, _InputIterator __l, \n-\t\t      size_type __n = 10,\n-\t\t      const hasher& __hf = hasher(), \n-\t\t      const key_equal& __eql = key_equal(), \n-\t\t      const allocator_type& __a = allocator_type())\n-\t: _Safe_assoc(__f, __l, __n, __hf, __eql, __a)\n-        { }\n+\t\t\t   size_type __n = 10,\n+\t\t\t   const hasher& __hf = hasher(), \n+\t\t\t   const key_equal& __eql = key_equal(), \n+\t\t\t   const allocator_type& __a = allocator_type())\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n,\n+\t\t__hf, __eql, __a), _Safe_base() { }\n+\n+      unordered_multiset(const unordered_multiset& __x) \n+      : _Base(__x), _Safe_base() { }\n+\n+      unordered_multiset(const _Base& __x) \n+      : _Base(__x), _Safe_base() { }\n+\n+      unordered_multiset(unordered_multiset&& __x) \n+      : _Base(std::forward<unordered_multiset>(__x)), _Safe_base() { }\n \n       unordered_multiset(initializer_list<value_type> __l,\n \t\t\t size_type __n = 10,\n \t\t\t const hasher& __hf = hasher(),\n \t\t\t const key_equal& __eql = key_equal(),\n \t\t\t const allocator_type& __a = allocator_type())\n-\t: _Safe_assoc(__l, __n, __hf, __eql, __a) { }\n-\n-      unordered_multiset(const _Safe_assoc& __x) \n-      : _Safe_assoc(__x), _Safe_base() { }\n+      : _Base(__l, __n, __hf, __eql, __a), _Safe_base() { }\n \n-      unordered_multiset(unordered_multiset&& __x) \n-      : _Safe_assoc(std::forward<_Safe_assoc>(__x)), _Safe_base() { }\n+      unordered_multiset&\n+      operator=(const unordered_multiset& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n \n       unordered_multiset&\n       operator=(unordered_multiset&& __x)\n@@ -234,24 +418,167 @@ namespace __debug\n       void\n       swap(unordered_multiset&& __x)\n       {\n-\t_Safe_assoc::swap(__x);\n+\t_Base::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n \n-     void\n+      void\n       clear()\n       {\n \t_Base::clear();\n \tthis->_M_invalidate_all();\n       }\n \n+      iterator\n+      begin()\n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      // local versions\n+      using _Base::begin;\n+      using _Base::end;\n+      using _Base::cbegin;\n+      using _Base::cend;\n+\n+      iterator\n+      insert(const value_type& __obj)\n+      { return iterator(_Base::insert(__obj), this); }\n+\n+      iterator\n+      insert(iterator, const value_type& __obj)\n+      { return iterator(_Base::insert(__obj), this); }\n+\n+      const_iterator\n+      insert(const_iterator, const value_type& __obj)\n+      { return const_iterator(_Base::insert(__obj), this); }\n+\n+      void\n+      insert(std::initializer_list<value_type> __l)\n+      { _Base::insert(__l); }\n+\n+      template<typename _InputIterator>\n+        void\n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first, __last);\n+\t}\n+\n+      iterator\n+      find(const key_type& __key)\n+      { return iterator(_Base::find(__key), this); }\n+\n+      const_iterator\n+      find(const key_type& __key) const\n+      { return const_iterator(_Base::find(__key), this); }\n+\n+      std::pair<iterator, iterator>\n+      equal_range(const key_type& __key)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+\n+      std::pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\ttypedef std::pair<_Base_iterator, _Base_iterator> __pair_type;\n+\t__pair_type __res = _Base::equal_range(__key);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+\n+      size_type\n+      erase(const key_type& __key)\n+      {\n+\tsize_type __ret(0);\n+\titerator __victim(_Base::find(__key), this);\n+\tif (__victim != end())\n+\t  {\n+\t    this->erase(__victim);\n+\t    __ret = 1;\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      iterator\n+      erase(iterator __it)\n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\treturn iterator(_Base::erase(__it.base()), this);\n+      }\n+\n+      const_iterator\n+      erase(const_iterator __it)\n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\treturn const_iterator(_Base::erase(__it.base()), this);\n+      }\n+\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\treturn iterator(_Base::erase(__first.base(),\n+\t\t\t\t     __last.base()), this);\n+      }\n+\n+      const_iterator\n+      erase(const_iterator __first, const_iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (const_iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  const_iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\treturn const_iterator(_Base::erase(__first.base(),\n+\t\t\t\t\t   __last.base()), this);\n+      }\n+\n+      _Base&\n+      _M_base() { return *this; }\n+\n+      const _Base&\n+      _M_base() const { return *this; }\n+\n     private:\n       void\n       _M_invalidate_all()\n       {\n \ttypedef typename _Base::const_iterator _Base_const_iterator;\n \ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(this->_M_base().end()));\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n       }\n     };\n \n@@ -276,7 +603,4 @@ namespace __debug\n } // namespace __debug\n } // namespace std\n \n-#undef _GLIBCXX_BASE\n-#undef _GLIBCXX_STD_BASE\n-\n #endif"}, {"sha": "5faba7f57f9c5ea6b4dbe121c7066d16b9036476", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/init-list.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finit-list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3cb9f72b71582c9749167b75f16905425475f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finit-list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finit-list.cc?ref=ced3cb9f72b71582c9749167b75f16905425475f", "patch": "@@ -26,8 +26,6 @@\n // the GNU General Public License.\n \n // { dg-options \"-std=gnu++0x\" }\n-// XFAIL this test until debug mode container is fixed.\n-// { dg-excess-errors \"\" }\n \n #include <set>\n #include <unordered_map>"}]}