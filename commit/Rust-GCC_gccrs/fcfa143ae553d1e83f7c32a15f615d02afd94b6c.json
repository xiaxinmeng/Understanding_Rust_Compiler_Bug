{"sha": "fcfa143ae553d1e83f7c32a15f615d02afd94b6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNmYTE0M2FlNTUzZDFlODNmN2MzMmExNWY2MTVkMDJhZmQ5NGI2Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-04-07T08:04:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-04-07T08:04:26Z"}, "message": "re PR tree-optimization/26135 (store copyprop not effective)\n\n2006-04-07  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/26135\n\t* tree-ssa-copy.c (stmt_may_generate_copy): Handle memory\n\tloads for store copy-prop.\n\t(copy_prop_visit_stmt): Likewise.\n\n\t* gcc.dg/tree-ssa/ssa-copyprop-1.c: New testcase.\n\nFrom-SVN: r112749", "tree": {"sha": "274ecfebe98b30c94224543eddf17c99df847ef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/274ecfebe98b30c94224543eddf17c99df847ef5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcfa143ae553d1e83f7c32a15f615d02afd94b6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcfa143ae553d1e83f7c32a15f615d02afd94b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcfa143ae553d1e83f7c32a15f615d02afd94b6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/comments", "author": null, "committer": null, "parents": [{"sha": "b8cf62e42fc5ea65ba7da8ebe2e990486ce588d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8cf62e42fc5ea65ba7da8ebe2e990486ce588d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8cf62e42fc5ea65ba7da8ebe2e990486ce588d3"}], "stats": {"total": 59, "additions": 57, "deletions": 2}, "files": [{"sha": "505f08430e8d8e6a93d05561dd9ab21c36327f73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fcfa143ae553d1e83f7c32a15f615d02afd94b6c", "patch": "@@ -1,4 +1,11 @@\n-2006-03-05  Robert Millan  <robertmh@gnu.org>\n+2006-04-07  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/26135\n+\t* tree-ssa-copy.c (stmt_may_generate_copy): Handle memory\n+\tloads for store copy-prop.\n+\t(copy_prop_visit_stmt): Likewise.\n+\n+2006-04-05  Robert Millan  <robertmh@gnu.org>\n \n \t* gcc/config/i386/linux.h:  Add a comment to mark macros that are\n \tbeing overriden in config/k*bsd-gnu.h."}, {"sha": "b1543eaa02ae0420a8dc9f598f502167a6bfa46f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fcfa143ae553d1e83f7c32a15f615d02afd94b6c", "patch": "@@ -1,3 +1,8 @@\n+2006-04-07  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/26135\n+\t* gcc.dg/tree-ssa/ssa-copyprop-1.c: New testcase.\n+\n 2006-04-06  Jan Hubicka  <jh@suse.cz>\n \n \tPR profile/26399"}, {"sha": "4308cea78665fcff35445dfc3ec009472a2b3156", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-1.c?ref=fcfa143ae553d1e83f7c32a15f615d02afd94b6c", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-dominator-opts -fdump-tree-store_copyprop-details\" } */\n+\n+typedef struct { int i; int j; } A;\n+int foo(A *a, int i)\n+{\n+  a->i = i;\n+  return a->i;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return i\" \"store_copyprop\" } } */\n+/* { dg-final { cleanup-tree-dump \"store_copyprop\" } } */"}, {"sha": "fca44d76c05572b4189b73797632fe8394647acb", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcfa143ae553d1e83f7c32a15f615d02afd94b6c/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=fcfa143ae553d1e83f7c32a15f615d02afd94b6c", "patch": "@@ -376,7 +376,10 @@ stmt_may_generate_copy (tree stmt)\n   /* Otherwise, the only statements that generate useful copies are\n      assignments whose RHS is just an SSA name that doesn't flow\n      through abnormal edges.  */\n-  return TREE_CODE (rhs) == SSA_NAME && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs);\n+  return (do_store_copy_prop\n+\t  && TREE_CODE (lhs) == SSA_NAME)\n+\t || (TREE_CODE (rhs) == SSA_NAME\n+\t     && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs));\n }\n \n \n@@ -681,6 +684,34 @@ copy_prop_visit_stmt (tree stmt, edge *taken_edge_p, tree *result_p)\n \t see if the lattice value of its output has changed.  */\n       retval = copy_prop_visit_assignment (stmt, result_p);\n     }\n+  else if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME\n+\t   && do_store_copy_prop\n+\t   && stmt_makes_single_load (stmt))\n+    {\n+      /* If the statement is a copy assignment with a memory load\n+\t on the RHS, see if we know the value of this load and\n+\t update the lattice accordingly.  */\n+      prop_value_t *val = get_value_loaded_by (stmt, copy_of);\n+      if (val\n+\t  && val->mem_ref\n+\t  && is_gimple_reg (val->value)\n+\t  && operand_equal_p (val->mem_ref, TREE_OPERAND (stmt, 1), 0))\n+        {\n+\t  bool changed;\n+\t  changed = set_copy_of_val (TREE_OPERAND (stmt, 0),\n+\t\t\t\t     val->value, val->mem_ref);\n+\t  if (changed)\n+\t    {\n+\t      *result_p = TREE_OPERAND (stmt, 0);\n+\t      retval = SSA_PROP_INTERESTING;\n+\t    }\n+\t  else\n+\t    retval = SSA_PROP_NOT_INTERESTING;\n+\t}\n+      else\n+        retval = SSA_PROP_VARYING;\n+    }\n   else if (TREE_CODE (stmt) == COND_EXPR)\n     {\n       /* See if we can determine which edge goes out of a conditional"}]}