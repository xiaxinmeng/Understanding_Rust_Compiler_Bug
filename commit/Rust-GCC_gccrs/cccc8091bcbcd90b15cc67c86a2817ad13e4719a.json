{"sha": "cccc8091bcbcd90b15cc67c86a2817ad13e4719a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NjYzgwOTFiY2JjZDkwYjE1Y2M2N2M4NmEyODE3YWQxM2U0NzE5YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-23T14:20:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-23T14:20:10Z"}, "message": "(exact_real_inverse): New function, if REAL_ARITHMETIC.\n\nFrom-SVN: r13002", "tree": {"sha": "44168380f1ebf929a9f9ff93150800545db9b3be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44168380f1ebf929a9f9ff93150800545db9b3be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cccc8091bcbcd90b15cc67c86a2817ad13e4719a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cccc8091bcbcd90b15cc67c86a2817ad13e4719a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cccc8091bcbcd90b15cc67c86a2817ad13e4719a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cccc8091bcbcd90b15cc67c86a2817ad13e4719a/comments", "author": null, "committer": null, "parents": [{"sha": "c0eccde6cfcfc5923c2f71917793cf9df5881e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0eccde6cfcfc5923c2f71917793cf9df5881e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0eccde6cfcfc5923c2f71917793cf9df5881e7d"}], "stats": {"total": 62, "additions": 62, "deletions": 0}, "files": [{"sha": "f7e22eae3bbee36c817fc9da86ffed201c76c1fc", "filename": "gcc/real.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cccc8091bcbcd90b15cc67c86a2817ad13e4719a/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cccc8091bcbcd90b15cc67c86a2817ad13e4719a/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=cccc8091bcbcd90b15cc67c86a2817ad13e4719a", "patch": "@@ -1043,6 +1043,68 @@ real_value_truncate (mode, arg)\n   return (r);\n }\n \n+/* Try to change R into its exact multiplicative inverse in machine mode\n+   MODE.  Return nonzero function value if successful.  */\n+\n+int\n+exact_real_inverse (mode, r)\n+     enum machine_mode mode;\n+     REAL_VALUE_TYPE *r;\n+{\n+  unsigned EMUSHORT e[NE], einv[NE];\n+  REAL_VALUE_TYPE rinv;\n+  int i;\n+\n+  GET_REAL (r, e);\n+\n+  /* Test for input in range.  Don't transform IEEE special values.  */\n+  if (eisinf (e) || eisnan (e) || (ecmp (e, ezero) == 0))\n+    return 0;\n+\n+  /* Test for a power of 2: all significand bits zero except the MSB.\n+     We are assuming the target has binary (or hex) arithmetic.  */\n+  if (e[NE - 2] != 0x8000)\n+    return 0;\n+\n+  for (i = 0; i < NE - 2; i++)\n+    {\n+      if (e[i] != 0)\n+\treturn 0;\n+    }\n+\n+  /* Compute the inverse and truncate it to the required mode.  */\n+  ediv (e, eone, einv);\n+  PUT_REAL (einv, &rinv);\n+  rinv = real_value_truncate (mode, rinv);\n+\n+#ifdef CHECK_FLOAT_VALUE\n+  /* This check is not redundant.  It may, for example, flush\n+     a supposedly IEEE denormal value to zero.  */\n+  i = 0;\n+  if (CHECK_FLOAT_VALUE (mode, rinv, i))\n+    return 0;\n+#endif\n+  GET_REAL (&rinv, einv);\n+\n+  /* Check the bits again, because the truncation might have\n+     generated an arbitrary saturation value on overflow.  */\n+  if (einv[NE - 2] != 0x8000)\n+    return 0;\n+\n+  for (i = 0; i < NE - 2; i++)\n+    {\n+      if (einv[i] != 0)\n+\treturn 0;\n+    }\n+\n+  /* Fail if the computed inverse is out of range.  */\n+  if (eisinf (einv) || eisnan (einv) || (ecmp (einv, ezero) == 0))\n+    return 0;\n+\n+  /* Output the reciprocal and return success flag.  */\n+  PUT_REAL (einv, r);\n+  return 1;\n+}\n #endif /* REAL_ARITHMETIC defined */\n \n /* Used for debugging--print the value of R in human-readable format"}]}