{"sha": "ada61c3d4774b98d42b53e99836abd695969fbc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRhNjFjM2Q0Nzc0Yjk4ZDQyYjUzZTk5ODM2YWJkNjk1OTY5ZmJjNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-02-23T22:05:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-02-23T22:05:19Z"}, "message": "re PR tree-optimization/79389 (30% performance regression in SciMark2 MonteCarlo)\n\n\tPR tree-optimization/79389\n\t* ifcvt.c (struct noce_if_info): Add rev_cond field.\n\t(noce_reversed_cond_code): New function.\n\t(noce_emit_store_flag): Use rev_cond if non-NULL instead of\n\treversed_comparison_code.  Formatting fix.\n\t(noce_try_store_flag): Test rev_cond != NULL in addition to\n\treversed_comparison_code.\n\t(noce_try_store_flag_constants): Likewise.\n\t(noce_try_store_flag_mask): Likewise.\n\t(noce_try_addcc): Use rev_cond if non-NULL instead of\n\treversed_comparison_code.\n\t(noce_try_cmove_arith): Likewise.  Formatting fixes.\n\t(noce_try_minmax, noce_try_abs): Clear rev_cond.\n\t(noce_find_if_block): Initialize rev_cond.\n\t(find_cond_trap): Call noce_get_condition with then_bb == trap_bb\n\tinstead of false as last argument never attempt to reverse it\n\tafterwards.\n\nFrom-SVN: r245690", "tree": {"sha": "be0895ee3e183c6faea1c9333e9467ba519248ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be0895ee3e183c6faea1c9333e9467ba519248ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ada61c3d4774b98d42b53e99836abd695969fbc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada61c3d4774b98d42b53e99836abd695969fbc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ada61c3d4774b98d42b53e99836abd695969fbc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada61c3d4774b98d42b53e99836abd695969fbc6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d822f3d585da1f9be6ab62245073625385a0e34f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d822f3d585da1f9be6ab62245073625385a0e34f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d822f3d585da1f9be6ab62245073625385a0e34f"}], "stats": {"total": 112, "additions": 80, "deletions": 32}, "files": [{"sha": "ffb5e25510e21d6203854c1aa35ddcd1d4f32ebe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada61c3d4774b98d42b53e99836abd695969fbc6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada61c3d4774b98d42b53e99836abd695969fbc6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ada61c3d4774b98d42b53e99836abd695969fbc6", "patch": "@@ -1,3 +1,23 @@\n+2017-02-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/79389\n+\t* ifcvt.c (struct noce_if_info): Add rev_cond field.\n+\t(noce_reversed_cond_code): New function.\n+\t(noce_emit_store_flag): Use rev_cond if non-NULL instead of\n+\treversed_comparison_code.  Formatting fix.\n+\t(noce_try_store_flag): Test rev_cond != NULL in addition to\n+\treversed_comparison_code.\n+\t(noce_try_store_flag_constants): Likewise.\n+\t(noce_try_store_flag_mask): Likewise.\n+\t(noce_try_addcc): Use rev_cond if non-NULL instead of\n+\treversed_comparison_code.\n+\t(noce_try_cmove_arith): Likewise.  Formatting fixes.\n+\t(noce_try_minmax, noce_try_abs): Clear rev_cond.\n+\t(noce_find_if_block): Initialize rev_cond.\n+\t(find_cond_trap): Call noce_get_condition with then_bb == trap_bb\n+\tinstead of false as last argument never attempt to reverse it\n+\tafterwards.\n+\n 2017-02-23  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/79663"}, {"sha": "4fd1744643ec1b5ccc1e944e3a1ffc0d90aa9138", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ada61c3d4774b98d42b53e99836abd695969fbc6/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ada61c3d4774b98d42b53e99836abd695969fbc6/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ada61c3d4774b98d42b53e99836abd695969fbc6", "patch": "@@ -777,6 +777,9 @@ struct noce_if_info\n   /* The jump condition.  */\n   rtx cond;\n \n+  /* Reversed jump condition.  */\n+  rtx rev_cond;\n+\n   /* New insns should be inserted before this one.  */\n   rtx_insn *cond_earliest;\n \n@@ -843,6 +846,17 @@ static int noce_try_minmax (struct noce_if_info *);\n static int noce_try_abs (struct noce_if_info *);\n static int noce_try_sign_mask (struct noce_if_info *);\n \n+/* Return the comparison code for reversed condition for IF_INFO,\n+   or UNKNOWN if reversing the condition is not possible.  */\n+\n+static inline enum rtx_code\n+noce_reversed_cond_code (struct noce_if_info *if_info)\n+{\n+  if (if_info->rev_cond)\n+    return GET_CODE (if_info->rev_cond);\n+  return reversed_comparison_code (if_info->cond, if_info->jump);\n+}\n+\n /* Return TRUE if SEQ is a good candidate as a replacement for the\n    if-convertible sequence described in IF_INFO.  */\n \n@@ -888,6 +902,14 @@ noce_emit_store_flag (struct noce_if_info *if_info, rtx x, int reversep,\n       if (if_info->then_else_reversed)\n \treversep = !reversep;\n     }\n+  else if (reversep\n+\t   && if_info->rev_cond\n+\t   && general_operand (XEXP (if_info->rev_cond, 0), VOIDmode)\n+\t   && general_operand (XEXP (if_info->rev_cond, 1), VOIDmode))\n+    {\n+      cond = if_info->rev_cond;\n+      reversep = false;\n+    }\n \n   if (reversep)\n     code = reversed_comparison_code (cond, if_info->jump);\n@@ -898,7 +920,7 @@ noce_emit_store_flag (struct noce_if_info *if_info, rtx x, int reversep,\n       && (normalize == 0 || STORE_FLAG_VALUE == normalize))\n     {\n       rtx src = gen_rtx_fmt_ee (code, GET_MODE (x), XEXP (cond, 0),\n-\t\t\t    XEXP (cond, 1));\n+\t\t\t\tXEXP (cond, 1));\n       rtx set = gen_rtx_SET (x, src);\n \n       start_sequence ();\n@@ -1209,8 +1231,7 @@ noce_try_store_flag (struct noce_if_info *if_info)\n   else if (if_info->b == const0_rtx\n \t   && CONST_INT_P (if_info->a)\n \t   && INTVAL (if_info->a) == STORE_FLAG_VALUE\n-\t   && (reversed_comparison_code (if_info->cond, if_info->jump)\n-\t       != UNKNOWN))\n+\t   && noce_reversed_cond_code (if_info) != UNKNOWN)\n     reversep = 1;\n   else\n     return FALSE;\n@@ -1371,9 +1392,7 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \n       diff = trunc_int_for_mode (diff, mode);\n \n-      can_reverse = (reversed_comparison_code (if_info->cond, if_info->jump)\n-\t\t     != UNKNOWN);\n-\n+      can_reverse = noce_reversed_cond_code (if_info) != UNKNOWN;\n       reversep = false;\n       if (diff == STORE_FLAG_VALUE || diff == -STORE_FLAG_VALUE)\n \t{\n@@ -1553,11 +1572,18 @@ noce_try_addcc (struct noce_if_info *if_info)\n \n   if (GET_CODE (if_info->a) == PLUS\n       && rtx_equal_p (XEXP (if_info->a, 0), if_info->b)\n-      && (reversed_comparison_code (if_info->cond, if_info->jump)\n-\t  != UNKNOWN))\n+      && noce_reversed_cond_code (if_info) != UNKNOWN)\n     {\n-      rtx cond = if_info->cond;\n-      enum rtx_code code = reversed_comparison_code (cond, if_info->jump);\n+      rtx cond = if_info->rev_cond;\n+      enum rtx_code code;\n+\n+      if (cond == NULL_RTX)\n+\t{\n+\t  cond = if_info->cond;\n+\t  code = reversed_comparison_code (cond, if_info->jump);\n+\t}\n+      else\n+\tcode = GET_CODE (cond);\n \n       /* First try to use addcc pattern.  */\n       if (general_operand (XEXP (cond, 0), VOIDmode)\n@@ -1652,9 +1678,7 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n \n   if ((if_info->a == const0_rtx\n        && rtx_equal_p (if_info->b, if_info->x))\n-      || ((reversep = (reversed_comparison_code (if_info->cond,\n-\t\t\t\t\t\t if_info->jump)\n-\t\t       != UNKNOWN))\n+      || ((reversep = (noce_reversed_cond_code (if_info) != UNKNOWN))\n \t  && if_info->b == const0_rtx\n \t  && rtx_equal_p (if_info->a, if_info->x)))\n     {\n@@ -2086,6 +2110,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   rtx target;\n   int is_mem = 0;\n   enum rtx_code code;\n+  rtx cond = if_info->cond;\n   rtx_insn *ifcvt_seq;\n \n   /* A conditional move from two memory sources is equivalent to a\n@@ -2117,7 +2142,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n \t  x = y;\n   */\n \n-  code = GET_CODE (if_info->cond);\n+  code = GET_CODE (cond);\n   insn_a = if_info->insn_a;\n   insn_b = if_info->insn_b;\n \n@@ -2127,7 +2152,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n     return FALSE;\n \n   /* Possibly rearrange operands to make things come out more natural.  */\n-  if (reversed_comparison_code (if_info->cond, if_info->jump) != UNKNOWN)\n+  if (noce_reversed_cond_code (if_info) != UNKNOWN)\n     {\n       int reversep = 0;\n       if (rtx_equal_p (b, x))\n@@ -2137,7 +2162,13 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n \n       if (reversep)\n \t{\n-\t  code = reversed_comparison_code (if_info->cond, if_info->jump);\n+\t  if (if_info->rev_cond)\n+\t    {\n+\t      cond = if_info->rev_cond;\n+\t      code = GET_CODE (cond);\n+\t    }\n+\t  else\n+\t    code = reversed_comparison_code (cond, if_info->jump);\n \t  std::swap (a, b);\n \t  std::swap (insn_a, insn_b);\n \t  std::swap (a_simple, b_simple);\n@@ -2173,7 +2204,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   rtx emit_b = NULL_RTX;\n   rtx_insn *tmp_insn = NULL;\n   bool modified_in_a = false;\n-  bool  modified_in_b = false;\n+  bool modified_in_b = false;\n   /* If either operand is complex, load it into a register first.\n      The best way to do this is to copy the original insn.  In this\n      way we preserve any clobbers etc that the insn may have had.\n@@ -2231,7 +2262,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n \t      rtx tmp_reg = tmp_b ? tmp_b : gen_reg_rtx (GET_MODE (b));\n \t      emit_b = gen_rtx_SET (tmp_reg, b);\n \t      b = tmp_reg;\n-\t  }\n+\t    }\n \t}\n     }\n \n@@ -2286,8 +2317,8 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   else\n     goto end_seq_and_fail;\n \n-  target = noce_emit_cmove (if_info, x, code, XEXP (if_info->cond, 0),\n-\t\t\t    XEXP (if_info->cond, 1), a, b);\n+  target = noce_emit_cmove (if_info, x, code, XEXP (cond, 0), XEXP (cond, 1),\n+\t\t\t    a, b);\n \n   if (! target)\n     goto end_seq_and_fail;\n@@ -2576,6 +2607,7 @@ noce_try_minmax (struct noce_if_info *if_info)\n   emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATION (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n+  if_info->rev_cond = NULL_RTX;\n   if_info->transform_name = \"noce_try_minmax\";\n \n   return TRUE;\n@@ -2743,6 +2775,7 @@ noce_try_abs (struct noce_if_info *if_info)\n   emit_insn_before_setloc (seq, if_info->jump, INSN_LOCATION (if_info->insn_a));\n   if_info->cond = cond;\n   if_info->cond_earliest = earliest;\n+  if_info->rev_cond = NULL_RTX;\n   if_info->transform_name = \"noce_try_abs\";\n \n   return TRUE;\n@@ -4064,6 +4097,11 @@ noce_find_if_block (basic_block test_bb, edge then_edge, edge else_edge,\n   if_info.else_bb = else_bb;\n   if_info.join_bb = join_bb;\n   if_info.cond = cond;\n+  rtx_insn *rev_cond_earliest;\n+  if_info.rev_cond = noce_get_condition (jump, &rev_cond_earliest,\n+\t\t\t\t\t !then_else_reversed);\n+  gcc_assert (if_info.rev_cond == NULL_RTX\n+\t      || rev_cond_earliest == cond_earliest);\n   if_info.cond_earliest = cond_earliest;\n   if_info.jump = jump;\n   if_info.then_else_reversed = then_else_reversed;\n@@ -4634,7 +4672,6 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   rtx_insn *trap, *jump;\n   rtx cond;\n   rtx_insn *cond_earliest;\n-  enum rtx_code code;\n \n   /* Locate the block with the trap instruction.  */\n   /* ??? While we look for no successors, we really ought to allow\n@@ -4654,7 +4691,7 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n   jump = BB_END (test_bb);\n-  cond = noce_get_condition (jump, &cond_earliest, false);\n+  cond = noce_get_condition (jump, &cond_earliest, then_bb == trap_bb);\n   if (! cond)\n     return FALSE;\n \n@@ -4670,17 +4707,8 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n   if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n     return FALSE;\n \n-  /* Reverse the comparison code, if necessary.  */\n-  code = GET_CODE (cond);\n-  if (then_bb == trap_bb)\n-    {\n-      code = reversed_comparison_code (cond, jump);\n-      if (code == UNKNOWN)\n-\treturn FALSE;\n-    }\n-\n   /* Attempt to generate the conditional trap.  */\n-  rtx_insn *seq = gen_cond_trap (code, copy_rtx (XEXP (cond, 0)),\n+  rtx_insn *seq = gen_cond_trap (GET_CODE (cond), copy_rtx (XEXP (cond, 0)),\n \t\t\t\t copy_rtx (XEXP (cond, 1)),\n \t\t\t\t TRAP_CODE (PATTERN (trap)));\n   if (seq == NULL)"}]}