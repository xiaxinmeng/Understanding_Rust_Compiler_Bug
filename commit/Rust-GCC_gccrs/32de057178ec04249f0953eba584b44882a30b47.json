{"sha": "32de057178ec04249f0953eba584b44882a30b47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJkZTA1NzE3OGVjMDQyNDlmMDk1M2ViYTU4NGI0NDg4MmEzMGI0Nw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-12-29T19:16:33Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-12-29T19:16:33Z"}, "message": "* expr.c (save_noncopied_parts, expand_expr): Use new assign_temp function.\n\nFrom-SVN: r10902", "tree": {"sha": "668ac9f87c226e0017dc644db6b6a7153ab25f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/668ac9f87c226e0017dc644db6b6a7153ab25f8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32de057178ec04249f0953eba584b44882a30b47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32de057178ec04249f0953eba584b44882a30b47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32de057178ec04249f0953eba584b44882a30b47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32de057178ec04249f0953eba584b44882a30b47/comments", "author": null, "committer": null, "parents": [{"sha": "4079e525ef2f574952d284768f03ae6d04053d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4079e525ef2f574952d284768f03ae6d04053d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4079e525ef2f574952d284768f03ae6d04053d6b"}], "stats": {"total": 66, "additions": 7, "deletions": 59}, "files": [{"sha": "16147dce96405789ed6f3ec5af7bd2122b8aed13", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 59, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32de057178ec04249f0953eba584b44882a30b47/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32de057178ec04249f0953eba584b44882a30b47/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=32de057178ec04249f0953eba584b44882a30b47", "patch": "@@ -4110,9 +4110,7 @@ save_noncopied_parts (lhs, list)\n \ttree part = TREE_VALUE (tail);\n \ttree part_type = TREE_TYPE (part);\n \ttree to_be_saved = build (COMPONENT_REF, part_type, lhs, part);\n-\trtx target = assign_stack_temp (TYPE_MODE (part_type),\n-\t\t\t\t\tint_size_in_bytes (part_type), 0);\n-\tMEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (part_type);\n+\trtx target = assign_temp (part_type, 0, 1);\n \tif (! memory_address_p (TYPE_MODE (part_type), XEXP (target, 0)))\n \t  target = change_address (target, TYPE_MODE (part_type), NULL_RTX);\n \tparts = tree_cons (to_be_saved,\n@@ -4675,16 +4673,7 @@ expand_expr (exp, target, tmode, modifier)\n \t}\n       if (SAVE_EXPR_RTL (exp) == 0)\n \t{\n-\t  if (mode == BLKmode)\n-\t    {\n-\t      temp\n-\t\t= assign_stack_temp (mode, int_size_in_bytes (type), 0);\n-\t      MEM_IN_STRUCT_P (temp) = AGGREGATE_TYPE_P (type);\n-\t    }\n-\t  else if (mode == VOIDmode)\n-\t    temp = const0_rtx;\n-\t  else\n-\t    temp = gen_reg_rtx (promote_mode (type, mode, &unsignedp, 0));\n+\t  temp = assign_temp (type, 0, 0);\n \n \t  SAVE_EXPR_RTL (exp) = temp;\n \t  if (!optimize && GET_CODE (temp) == REG)\n@@ -4876,17 +4865,7 @@ expand_expr (exp, target, tmode, modifier)\n       else\n \t{\n \t  if (target == 0 || ! safe_from_p (target, exp))\n-\t    {\n-\t      if (mode != BLKmode && ! TREE_ADDRESSABLE (exp))\n-\t\ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n-\t      else\n-\t\t{\n-\t\t  target\n-\t\t    = assign_stack_temp (mode, int_size_in_bytes (type), 0);\n-\t\t  if (AGGREGATE_TYPE_P (type))\n-\t\t    MEM_IN_STRUCT_P (target) = 1;\n-\t\t}\n-\t    }\n+\t    target = assign_temp (type, 0, TREE_ADDRESSABLE (exp));\n \n \t  if (TREE_READONLY (exp))\n \t    {\n@@ -5457,21 +5436,7 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  tree valtype = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t  if (target == 0)\n-\t    {\n-\t      if (mode == BLKmode)\n-\t\t{\n-\t\t  if (TYPE_SIZE (type) == 0\n-\t\t      || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-\t\t    abort ();\n-\t\t  target = assign_stack_temp (BLKmode,\n-\t\t\t\t\t      (TREE_INT_CST_LOW (TYPE_SIZE (type))\n-\t\t\t\t\t       + BITS_PER_UNIT - 1)\n-\t\t\t\t\t      / BITS_PER_UNIT, 0);\n-\t\t  MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (type);\n-\t\t}\n-\t      else\n-\t\ttarget = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);\n-\t    }\n+\t    target = assign_temp (type, 0, 0);\n \n \t  if (GET_CODE (target) == MEM)\n \t    /* Store data into beginning of memory target.  */\n@@ -6174,20 +6139,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t && ! (GET_CODE (original_target) == MEM\n \t\t       && MEM_VOLATILE_P (original_target)))\n \t  temp = original_target;\n-\telse if (mode == BLKmode)\n-\t  {\n-\t    if (TYPE_SIZE (type) == 0\n-\t\t|| TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n-\t      abort ();\n-\n-\t    temp = assign_stack_temp (BLKmode,\n-\t\t\t\t      (TREE_INT_CST_LOW (TYPE_SIZE (type))\n-\t\t\t\t       + BITS_PER_UNIT - 1)\n-\t\t\t\t      / BITS_PER_UNIT, 0);\n-\t    MEM_IN_STRUCT_P (temp) = AGGREGATE_TYPE_P (type);\n-\t  }\n \telse\n-\t  temp = gen_reg_rtx (mode);\n+\t  temp = assign_temp (type, 0, 0);\n \n \t/* Check for X ? A + B : A.  If we have this, we can copy\n \t   A to the output and conditionally add B.  Similarly for unary\n@@ -6501,8 +6454,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      }\n \t    else\n \t      {\n-\t\ttarget = assign_stack_temp (mode, int_size_in_bytes (type), 2);\n-\t\tMEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (type);\n+\t\ttarget = assign_temp (type, 2, 1);\n \t\t/* All temp slots at this level must not conflict.  */\n \t\tpreserve_temp_slots (target);\n \t\tDECL_RTL (slot) = target;\n@@ -6709,11 +6661,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      /* If this object is in a register, it must be not\n \t\t be BLKmode. */\n \t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\t      enum machine_mode inner_mode = TYPE_MODE (inner_type);\n-\t      rtx memloc\n-\t\t= assign_stack_temp (inner_mode,\n-\t\t\t\t     int_size_in_bytes (inner_type), 1);\n-\t      MEM_IN_STRUCT_P (memloc) = AGGREGATE_TYPE_P (inner_type);\n+\t      rtx memloc = assign_temp (inner_type, 1, 1);\n \n \t      mark_temp_addr_taken (memloc);\n \t      emit_move_insn (memloc, op0);"}]}