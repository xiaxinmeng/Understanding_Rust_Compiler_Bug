{"sha": "652a3e3ac3e3a9643f12235031032b03a59b3a76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUyYTNlM2FjM2UzYTk2NDNmMTIyMzUwMzEwMzJiMDNhNTliM2E3Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-02-06T15:52:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-02-06T15:52:17Z"}, "message": "re PR debug/59575 (ICE in maybe_record_trace_start, at dwarf2cfi.c:2239)\n\n\tPR target/59575\n\t* config/arm/arm.c (emit_multi_reg_push): Add dwarf_regs_mask argument,\n\tdon't record in REG_FRAME_RELATED_EXPR registers not set in that\n\tbitmask.\n\t(arm_expand_prologue): Adjust all callers.\n\t(arm_unwind_emit_sequence): Allow saved, but not important for unwind\n\tinfo, registers also at the lowest numbered registers side.  Use\n\tgcc_assert instead of abort, and SET_SRC/SET_DEST macros instead of\n\tXEXP.\n\n\t* gcc.target/arm/pr59575.c: New test.\n\nFrom-SVN: r207563", "tree": {"sha": "b707edfae5f169109bf6ff9569f73407f10ca08a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b707edfae5f169109bf6ff9569f73407f10ca08a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/652a3e3ac3e3a9643f12235031032b03a59b3a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/652a3e3ac3e3a9643f12235031032b03a59b3a76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/652a3e3ac3e3a9643f12235031032b03a59b3a76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/652a3e3ac3e3a9643f12235031032b03a59b3a76/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "af116cae675e31b999844b7243c01bed9517c51c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af116cae675e31b999844b7243c01bed9517c51c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af116cae675e31b999844b7243c01bed9517c51c"}], "stats": {"total": 161, "additions": 96, "deletions": 65}, "files": [{"sha": "8b15078eade276700347988f6f94e48f739074ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652a3e3ac3e3a9643f12235031032b03a59b3a76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652a3e3ac3e3a9643f12235031032b03a59b3a76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=652a3e3ac3e3a9643f12235031032b03a59b3a76", "patch": "@@ -1,5 +1,15 @@\n 2014-02-06  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/59575\n+\t* config/arm/arm.c (emit_multi_reg_push): Add dwarf_regs_mask argument,\n+\tdon't record in REG_FRAME_RELATED_EXPR registers not set in that\n+\tbitmask.\n+\t(arm_expand_prologue): Adjust all callers.\n+\t(arm_unwind_emit_sequence): Allow saved, but not important for unwind\n+\tinfo, registers also at the lowest numbered registers side.  Use\n+\tgcc_assert instead of abort, and SET_SRC/SET_DEST macros instead of\n+\tXEXP.\n+\n \tPR debug/59992\n \t* var-tracking.c (adjust_mems): Before adding a SET\n \tto amd->side_effects, adjust it's SET_SRC using"}, {"sha": "f870cf9a4d89fe8ae80d93fdbd2abfc93071ecce", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 83, "deletions": 65, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652a3e3ac3e3a9643f12235031032b03a59b3a76/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652a3e3ac3e3a9643f12235031032b03a59b3a76/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=652a3e3ac3e3a9643f12235031032b03a59b3a76", "patch": "@@ -177,7 +177,7 @@ static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static tree arm_builtin_decl (unsigned, bool);\n static void emit_constant_insn (rtx cond, rtx pattern);\n static rtx emit_set_insn (rtx, rtx);\n-static rtx emit_multi_reg_push (unsigned long);\n+static rtx emit_multi_reg_push (unsigned long, unsigned long);\n static int arm_arg_partial_bytes (cumulative_args_t, enum machine_mode,\n \t\t\t\t  tree, bool);\n static rtx arm_function_arg (cumulative_args_t, enum machine_mode,\n@@ -19573,28 +19573,33 @@ arm_emit_strd_push (unsigned long saved_regs_mask)\n /* Generate and emit an insn that we will recognize as a push_multi.\n    Unfortunately, since this insn does not reflect very well the actual\n    semantics of the operation, we need to annotate the insn for the benefit\n-   of DWARF2 frame unwind information.  */\n+   of DWARF2 frame unwind information.  DWARF_REGS_MASK is a subset of\n+   MASK for registers that should be annotated for DWARF2 frame unwind\n+   information.  */\n static rtx\n-emit_multi_reg_push (unsigned long mask)\n+emit_multi_reg_push (unsigned long mask, unsigned long dwarf_regs_mask)\n {\n   int num_regs = 0;\n-  int num_dwarf_regs;\n+  int num_dwarf_regs = 0;\n   int i, j;\n   rtx par;\n   rtx dwarf;\n   int dwarf_par_index;\n   rtx tmp, reg;\n \n+  /* We don't record the PC in the dwarf frame information.  */\n+  dwarf_regs_mask &= ~(1 << PC_REGNUM);\n+\n   for (i = 0; i <= LAST_ARM_REGNUM; i++)\n-    if (mask & (1 << i))\n-      num_regs++;\n+    {\n+      if (mask & (1 << i))\n+\tnum_regs++;\n+      if (dwarf_regs_mask & (1 << i))\n+\tnum_dwarf_regs++;\n+    }\n \n   gcc_assert (num_regs && num_regs <= 16);\n-\n-  /* We don't record the PC in the dwarf frame information.  */\n-  num_dwarf_regs = num_regs;\n-  if (mask & (1 << PC_REGNUM))\n-    num_dwarf_regs--;\n+  gcc_assert ((dwarf_regs_mask & ~mask) == 0);\n \n   /* For the body of the insn we are going to generate an UNSPEC in\n      parallel with several USEs.  This allows the insn to be recognized\n@@ -19660,14 +19665,13 @@ emit_multi_reg_push (unsigned long mask)\n \t\t\t\t\t   gen_rtvec (1, reg),\n \t\t\t\t\t   UNSPEC_PUSH_MULT));\n \n-\t  if (i != PC_REGNUM)\n+\t  if (dwarf_regs_mask & (1 << i))\n \t    {\n \t      tmp = gen_rtx_SET (VOIDmode,\n \t\t\t\t gen_frame_mem (SImode, stack_pointer_rtx),\n \t\t\t\t reg);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n-\t      XVECEXP (dwarf, 0, dwarf_par_index) = tmp;\n-\t      dwarf_par_index++;\n+\t      XVECEXP (dwarf, 0, dwarf_par_index++) = tmp;\n \t    }\n \n \t  break;\n@@ -19682,7 +19686,7 @@ emit_multi_reg_push (unsigned long mask)\n \n \t  XVECEXP (par, 0, j) = gen_rtx_USE (VOIDmode, reg);\n \n-\t  if (i != PC_REGNUM)\n+\t  if (dwarf_regs_mask & (1 << i))\n \t    {\n \t      tmp\n \t\t= gen_rtx_SET (VOIDmode,\n@@ -20689,7 +20693,7 @@ arm_expand_prologue (void)\n \t  /* Interrupt functions must not corrupt any registers.\n \t     Creating a frame pointer however, corrupts the IP\n \t     register, so we must push it first.  */\n-\t  emit_multi_reg_push (1 << IP_REGNUM);\n+\t  emit_multi_reg_push (1 << IP_REGNUM, 1 << IP_REGNUM);\n \n \t  /* Do not set RTX_FRAME_RELATED_P on this insn.\n \t     The dwarf stack unwinding code only wants to see one\n@@ -20750,7 +20754,8 @@ arm_expand_prologue (void)\n \t      if (cfun->machine->uses_anonymous_args)\n \t\t{\n \t\t  insn\n-\t\t    = emit_multi_reg_push ((0xf0 >> (args_to_push / 4)) & 0xf);\n+\t\t    = emit_multi_reg_push ((0xf0 >> (args_to_push / 4)) & 0xf,\n+\t\t\t\t\t   (0xf0 >> (args_to_push / 4)) & 0xf);\n \t\t  emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);\n \t\t  saved_pretend_args = 1;\n \t\t}\n@@ -20794,7 +20799,8 @@ arm_expand_prologue (void)\n       /* Push the argument registers, or reserve space for them.  */\n       if (cfun->machine->uses_anonymous_args)\n \tinsn = emit_multi_reg_push\n-\t  ((0xf0 >> (args_to_push / 4)) & 0xf);\n+\t  ((0xf0 >> (args_to_push / 4)) & 0xf,\n+\t   (0xf0 >> (args_to_push / 4)) & 0xf);\n       else\n \tinsn = emit_insn\n \t  (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n@@ -20819,6 +20825,8 @@ arm_expand_prologue (void)\n \n   if (live_regs_mask)\n     {\n+      unsigned long dwarf_regs_mask = live_regs_mask;\n+\n       saved_regs += bit_count (live_regs_mask) * 4;\n       if (optimize_size && !frame_pointer_needed\n \t  && saved_regs == offsets->saved_regs - offsets->saved_args)\n@@ -20845,25 +20853,22 @@ arm_expand_prologue (void)\n \t  && current_tune->prefer_ldrd_strd\n           && !optimize_function_for_size_p (cfun))\n         {\n+\t  gcc_checking_assert (live_regs_mask == dwarf_regs_mask);\n           if (TARGET_THUMB2)\n-            {\n-              thumb2_emit_strd_push (live_regs_mask);\n-            }\n+\t    thumb2_emit_strd_push (live_regs_mask);\n           else if (TARGET_ARM\n                    && !TARGET_APCS_FRAME\n                    && !IS_INTERRUPT (func_type))\n-            {\n-              arm_emit_strd_push (live_regs_mask);\n-            }\n+\t    arm_emit_strd_push (live_regs_mask);\n           else\n             {\n-              insn = emit_multi_reg_push (live_regs_mask);\n+\t      insn = emit_multi_reg_push (live_regs_mask, live_regs_mask);\n               RTX_FRAME_RELATED_P (insn) = 1;\n             }\n         }\n       else\n         {\n-          insn = emit_multi_reg_push (live_regs_mask);\n+\t  insn = emit_multi_reg_push (live_regs_mask, dwarf_regs_mask);\n           RTX_FRAME_RELATED_P (insn) = 1;\n         }\n     }\n@@ -28694,7 +28699,13 @@ arm_dwarf_register_span (rtx rtl)\n /* Emit unwind directives for a store-multiple instruction or stack pointer\n    push during alignment.\n    These should only ever be generated by the function prologue code, so\n-   expect them to have a particular form.  */\n+   expect them to have a particular form.\n+   The store-multiple instruction sometimes pushes pc as the last register,\n+   although it should not be tracked into unwind information, or for -Os\n+   sometimes pushes some dummy registers before first register that needs\n+   to be tracked in unwind information; such dummy registers are there just\n+   to avoid separate stack adjustment, and will not be restored in the\n+   epilogue.  */\n \n static void\n arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n@@ -28705,32 +28716,43 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n   int reg_size;\n   unsigned reg;\n   unsigned lastreg;\n+  unsigned padfirst = 0, padlast = 0;\n   rtx e;\n \n   e = XVECEXP (p, 0, 0);\n-  if (GET_CODE (e) != SET)\n-    abort ();\n+  gcc_assert (GET_CODE (e) == SET);\n \n   /* First insn will adjust the stack pointer.  */\n-  if (GET_CODE (e) != SET\n-      || !REG_P (XEXP (e, 0))\n-      || REGNO (XEXP (e, 0)) != SP_REGNUM\n-      || GET_CODE (XEXP (e, 1)) != PLUS)\n-    abort ();\n+  gcc_assert (GET_CODE (e) == SET\n+\t      && REG_P (SET_DEST (e))\n+\t      && REGNO (SET_DEST (e)) == SP_REGNUM\n+\t      && GET_CODE (SET_SRC (e)) == PLUS);\n \n-  offset = -INTVAL (XEXP (XEXP (e, 1), 1));\n+  offset = -INTVAL (XEXP (SET_SRC (e), 1));\n   nregs = XVECLEN (p, 0) - 1;\n+  gcc_assert (nregs);\n \n-  reg = REGNO (XEXP (XVECEXP (p, 0, 1), 1));\n+  reg = REGNO (SET_SRC (XVECEXP (p, 0, 1)));\n   if (reg < 16)\n     {\n+      /* For -Os dummy registers can be pushed at the beginning to\n+\t avoid separate stack pointer adjustment.  */\n+      e = XVECEXP (p, 0, 1);\n+      e = XEXP (SET_DEST (e), 0);\n+      if (GET_CODE (e) == PLUS)\n+\tpadfirst = INTVAL (XEXP (e, 1));\n+      gcc_assert (padfirst == 0 || optimize_size);\n       /* The function prologue may also push pc, but not annotate it as it is\n \t never restored.  We turn this into a stack pointer adjustment.  */\n-      if (nregs * 4 == offset - 4)\n-\t{\n-\t  fprintf (asm_out_file, \"\\t.pad #4\\n\");\n-\t  offset -= 4;\n-\t}\n+      e = XVECEXP (p, 0, nregs);\n+      e = XEXP (SET_DEST (e), 0);\n+      if (GET_CODE (e) == PLUS)\n+\tpadlast = offset - INTVAL (XEXP (e, 1)) - 4;\n+      else\n+\tpadlast = offset - 4;\n+      gcc_assert (padlast == 0 || padlast == 4);\n+      if (padlast == 4)\n+\tfprintf (asm_out_file, \"\\t.pad #4\\n\");\n       reg_size = 4;\n       fprintf (asm_out_file, \"\\t.save {\");\n     }\n@@ -28741,29 +28763,26 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n     }\n   else\n     /* Unknown register type.  */\n-    abort ();\n+    gcc_unreachable ();\n \n   /* If the stack increment doesn't match the size of the saved registers,\n      something has gone horribly wrong.  */\n-  if (offset != nregs * reg_size)\n-    abort ();\n+  gcc_assert (offset == padfirst + nregs * reg_size + padlast);\n \n-  offset = 0;\n+  offset = padfirst;\n   lastreg = 0;\n   /* The remaining insns will describe the stores.  */\n   for (i = 1; i <= nregs; i++)\n     {\n       /* Expect (set (mem <addr>) (reg)).\n          Where <addr> is (reg:SP) or (plus (reg:SP) (const_int)).  */\n       e = XVECEXP (p, 0, i);\n-      if (GET_CODE (e) != SET\n-\t  || !MEM_P (XEXP (e, 0))\n-\t  || !REG_P (XEXP (e, 1)))\n-\tabort ();\n+      gcc_assert (GET_CODE (e) == SET\n+\t\t  && MEM_P (SET_DEST (e))\n+\t\t  && REG_P (SET_SRC (e)));\n \n-      reg = REGNO (XEXP (e, 1));\n-      if (reg < lastreg)\n-\tabort ();\n+      reg = REGNO (SET_SRC (e));\n+      gcc_assert (reg >= lastreg);\n \n       if (i != 1)\n \tfprintf (asm_out_file, \", \");\n@@ -28776,23 +28795,22 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n \n #ifdef ENABLE_CHECKING\n       /* Check that the addresses are consecutive.  */\n-      e = XEXP (XEXP (e, 0), 0);\n+      e = XEXP (SET_DEST (e), 0);\n       if (GET_CODE (e) == PLUS)\n-\t{\n-\t  offset += reg_size;\n-\t  if (!REG_P (XEXP (e, 0))\n-\t      || REGNO (XEXP (e, 0)) != SP_REGNUM\n-\t      || !CONST_INT_P (XEXP (e, 1))\n-\t      || offset != INTVAL (XEXP (e, 1)))\n-\t    abort ();\n-\t}\n-      else if (i != 1\n-\t       || !REG_P (e)\n-\t       || REGNO (e) != SP_REGNUM)\n-\tabort ();\n+\tgcc_assert (REG_P (XEXP (e, 0))\n+\t\t    && REGNO (XEXP (e, 0)) == SP_REGNUM\n+\t\t    && CONST_INT_P (XEXP (e, 1))\n+\t\t    && offset == INTVAL (XEXP (e, 1)));\n+      else\n+\tgcc_assert (i == 1\n+\t\t    && REG_P (e)\n+\t\t    && REGNO (e) == SP_REGNUM);\n+      offset += reg_size;\n #endif\n     }\n   fprintf (asm_out_file, \"}\\n\");\n+  if (padfirst)\n+    fprintf (asm_out_file, \"\\t.pad #%d\\n\", padfirst);\n }\n \n /*  Emit unwind directives for a SET.  */"}, {"sha": "2cac8d2cf3329da2e1efd8854c5dbd9aff09d7ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652a3e3ac3e3a9643f12235031032b03a59b3a76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652a3e3ac3e3a9643f12235031032b03a59b3a76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=652a3e3ac3e3a9643f12235031032b03a59b3a76", "patch": "@@ -1,5 +1,8 @@\n 2014-02-06  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/59575\n+\t* gcc.target/arm/pr59575.c: New test.\n+\n \tPR debug/59992\n \t* gcc.dg/pr59992.c: New test.\n "}]}