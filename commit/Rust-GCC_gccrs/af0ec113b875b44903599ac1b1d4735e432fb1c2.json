{"sha": "af0ec113b875b44903599ac1b1d4735e432fb1c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYwZWMxMTNiODc1YjQ0OTAzNTk5YWMxYjFkNDczNWU0MzJmYjFjMg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-06T21:14:50Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-06T21:14:50Z"}, "message": "vax-protos.h: Add a prototype for vax_notice_update_cc.\n\n\t* config/vax/vax-protos.h: Add a prototype for\n\tvax_notice_update_cc.\n\t* config/vax/vax.c (vax_notice_update_cc): New.\n\t* config/vax/vax.h (NOTICE_UPDATE_CC): Call\n\tvax_notice_update_cc.\n\nFrom-SVN: r79032", "tree": {"sha": "bcf973453c68a7c4b9cd9c097caaea48c510003e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcf973453c68a7c4b9cd9c097caaea48c510003e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af0ec113b875b44903599ac1b1d4735e432fb1c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0ec113b875b44903599ac1b1d4735e432fb1c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af0ec113b875b44903599ac1b1d4735e432fb1c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0ec113b875b44903599ac1b1d4735e432fb1c2/comments", "author": null, "committer": null, "parents": [{"sha": "aaef9b06ac9ea6d57345f70e22327a122d6d897c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaef9b06ac9ea6d57345f70e22327a122d6d897c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaef9b06ac9ea6d57345f70e22327a122d6d897c"}], "stats": {"total": 134, "additions": 79, "deletions": 55}, "files": [{"sha": "86dd3376858e246cf9ec793da633c456d767ba44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0ec113b875b44903599ac1b1d4735e432fb1c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0ec113b875b44903599ac1b1d4735e432fb1c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af0ec113b875b44903599ac1b1d4735e432fb1c2", "patch": "@@ -1,3 +1,11 @@\n+2004-03-06  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/vax/vax-protos.h: Add a prototype for\n+\tvax_notice_update_cc.\n+\t* config/vax/vax.c (vax_notice_update_cc): New.\n+\t* config/vax/vax.h (NOTICE_UPDATE_CC): Call\n+\tvax_notice_update_cc.\n+\n 2004-03-06  David Edelsohn  <edelsohn@gnu.org>\n \n \t* collect2.c (main): Only export initfunc and finifunc if"}, {"sha": "f97d31ae7916e6593ebab62048e02b326c746291", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0ec113b875b44903599ac1b1d4735e432fb1c2/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0ec113b875b44903599ac1b1d4735e432fb1c2/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=af0ec113b875b44903599ac1b1d4735e432fb1c2", "patch": "@@ -25,6 +25,7 @@ extern const char *rev_cond_name (rtx);\n extern void split_quadword_operands (rtx *, rtx *, int);\n extern void print_operand_address (FILE *, rtx);\n extern int vax_float_literal (rtx);\n+extern void vax_notice_update_cc (rtx, rtx);\n #endif /* RTX_CODE */\n \n #ifdef REAL_VALUE_TYPE"}, {"sha": "da1b481d159b1d4d8f42d19fe817fb32842c9a7d", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0ec113b875b44903599ac1b1d4735e432fb1c2/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0ec113b875b44903599ac1b1d4735e432fb1c2/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=af0ec113b875b44903599ac1b1d4735e432fb1c2", "patch": "@@ -788,3 +788,72 @@ vax_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n {\n   return gen_rtx_REG (Pmode, VAX_STRUCT_VALUE_REGNUM);\n }\n+\n+/* Worker function for NOTICE_UPDATE_CC.  */\n+\n+void\n+vax_notice_update_cc (rtx exp, rtx insn ATTRIBUTE_UNUSED)\n+{\n+  if (GET_CODE (exp) == SET)\n+    {\n+      if (GET_CODE (SET_SRC (exp)) == CALL)\n+\tCC_STATUS_INIT;\n+      else if (GET_CODE (SET_DEST (exp)) != ZERO_EXTRACT\n+\t       && GET_CODE (SET_DEST (exp)) != PC)\n+\t{\n+\t  cc_status.flags = 0;\n+\t  /* The integer operations below don't set carry or\n+\t     set it in an incompatible way.  That's ok though\n+\t     as the Z bit is all we need when doing unsigned\n+\t     comparisons on the result of these insns (since\n+\t     they're always with 0).  Set CC_NO_OVERFLOW to\n+\t     generate the correct unsigned branches.  */\n+\t  switch (GET_CODE (SET_SRC (exp)))\n+\t    {\n+\t    case NEG:\n+\t      if (GET_MODE_CLASS (GET_MODE (exp)) == MODE_FLOAT)\n+\t \tbreak;\n+\t    case AND:\n+\t    case IOR:\n+\t    case XOR:\n+\t    case NOT:\n+\t    case MEM:\n+\t    case REG:\n+\t      cc_status.flags = CC_NO_OVERFLOW;\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t  cc_status.value1 = SET_DEST (exp);\n+\t  cc_status.value2 = SET_SRC (exp);\n+\t}\n+    }\n+  else if (GET_CODE (exp) == PARALLEL\n+\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n+    {\n+      if (GET_CODE (SET_SRC (XVECEXP (exp, 0, 0))) == CALL)\n+\tCC_STATUS_INIT;\n+      else if (GET_CODE (SET_DEST (XVECEXP (exp, 0, 0))) != PC)\n+\t{\n+\t  cc_status.flags = 0;\n+\t  cc_status.value1 = SET_DEST (XVECEXP (exp, 0, 0));\n+\t  cc_status.value2 = SET_SRC (XVECEXP (exp, 0, 0));\n+\t}\n+      else\n+\t/* PARALLELs whose first element sets the PC are aob,\n+\t   sob insns.  They do change the cc's.  */\n+\tCC_STATUS_INIT;\n+    }\n+  else\n+    CC_STATUS_INIT;\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\n+      && cc_status.value2\n+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n+    cc_status.value2 = 0;\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\n+      && cc_status.value2\n+      && GET_CODE (cc_status.value2) == MEM)\n+    cc_status.value2 = 0;\n+  /* Actual condition, one line up, should be that value2's address\n+     depends on value1, but that is too much of a pain.  */\n+}"}, {"sha": "3bc04b9f24bb181d352c458743710580798c8c8b", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af0ec113b875b44903599ac1b1d4735e432fb1c2/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af0ec113b875b44903599ac1b1d4735e432fb1c2/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=af0ec113b875b44903599ac1b1d4735e432fb1c2", "patch": "@@ -866,61 +866,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    Do not alter them if the instruction would not alter the cc's.  */\n \n #define NOTICE_UPDATE_CC(EXP, INSN) \\\n-{ if (GET_CODE (EXP) == SET)\t\t\t\t\t\\\n-    { if (GET_CODE (SET_SRC (EXP)) == CALL)\t\t\t\\\n-\tCC_STATUS_INIT;\t\t\t\t\t\t\\\n-      else if (GET_CODE (SET_DEST (EXP)) != ZERO_EXTRACT\t\\\n-\t       && GET_CODE (SET_DEST (EXP)) != PC)\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  cc_status.flags = 0;\t\t\t\t\t\\\n-\t  /* The integer operations below don't set carry or\t\\\n-\t     set it in an incompatible way.  That's ok though\t\\\n-\t     as the Z bit is all we need when doing unsigned\t\\\n-\t     comparisons on the result of these insns (since\t\\\n-\t     they're always with 0).  Set CC_NO_OVERFLOW to\t\\\n-\t     generate the correct unsigned branches.  */\t\\\n-\t  switch (GET_CODE (SET_SRC (EXP)))\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\\\n-\t    case NEG:\t\t\t\t\t\t\\\n-\t      if (GET_MODE_CLASS (GET_MODE (EXP)) == MODE_FLOAT)\\\n-\t \tbreak;\t\t\t\t\t\t\\\n-\t    case AND:\t\t\t\t\t\t\\\n-\t    case IOR:\t\t\t\t\t\t\\\n-\t    case XOR:\t\t\t\t\t\t\\\n-\t    case NOT:\t\t\t\t\t\t\\\n-\t    case MEM:\t\t\t\t\t\t\\\n-\t    case REG:\t\t\t\t\t\t\\\n-\t      cc_status.flags = CC_NO_OVERFLOW;\t\t\t\\\n-\t      break;\t\t\t\t\t\t\\\n-\t    default:\t\t\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\\\n-\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\\\n-\t  cc_status.value2 = SET_SRC (EXP); } }\t\t\t\\\n-  else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n-\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (SET_SRC (XVECEXP (EXP, 0, 0))) == CALL)\t\\\n-\tCC_STATUS_INIT;\t\t\t\t\t        \\\n-      else if (GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) != PC) \\\n-\t{ cc_status.flags = 0;\t\t\t\t\t\\\n-\t  cc_status.value1 = SET_DEST (XVECEXP (EXP, 0, 0));\t\\\n-\t  cc_status.value2 = SET_SRC (XVECEXP (EXP, 0, 0)); }   \\\n-      else\t\t\t\t\t\t\t\\\n-\t/* PARALLELs whose first element sets the PC are aob,   \\\n-\t   sob insns.  They do change the cc's.  */\t\t\\\n-\tCC_STATUS_INIT; }\t\t\t\t\t\\\n-  else CC_STATUS_INIT;\t\t\t\t\t\t\\\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n-      && cc_status.value2\t\t\t\t\t\\\n-      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n-    cc_status.value2 = 0;\t\t\t\t\t\\\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\\\n-      && cc_status.value2\t\t\t\t\t\\\n-      && GET_CODE (cc_status.value2) == MEM)\t\t\t\\\n-    cc_status.value2 = 0; }\n-/* Actual condition, one line up, should be that value2's address\n-   depends on value1, but that is too much of a pain.  */\n+  vax_notice_update_cc ((EXP), (INSN))\n \n #define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \\\n { if (cc_status.flags & CC_NO_OVERFLOW)\t\t\t\t\\"}]}