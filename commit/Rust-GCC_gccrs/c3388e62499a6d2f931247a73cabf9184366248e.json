{"sha": "c3388e62499a6d2f931247a73cabf9184366248e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMzODhlNjI0OTlhNmQyZjkzMTI0N2E3M2NhYmY5MTg0MzY2MjQ4ZQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-05-12T20:57:38Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-05-12T20:57:38Z"}, "message": "Implement -Wmisleading-indentation\n\ngcc/ChangeLog:\n\t* doc/invoke.texi (Warning Options): Add -Wmisleading-indentation.\n\t(-Wmisleading-indentation): New option.\n\t* Makefile.in (C_COMMON_OBJS): Add c-family/c-indentation.o.\n\ngcc/c-family/ChangeLog:\n\t* c-common.h (warn_for_misleading_indentation): New prototype.\n\t* c-indentation.c: New file.\n\t* c.opt (Wmisleading-indentation): New option.\n\ngcc/c/ChangeLog:\n\t* c-parser.c (c_parser_if_body): Add param \"if_loc\", use it\n\tto add a call to warn_for_misleading_indentation.\n\t(c_parser_else_body): Likewise, adding param \"else_loc\".\n\t(c_parser_if_statement): Check for misleading indentation.\n\t(c_parser_while_statement): Likewise.\n\t(c_parser_for_statement): Likewise.\n\ngcc/cp/ChangeLog:\n\t* parser.c (cp_parser_selection_statement): Add location and\n\tguard_kind arguments to calls to\n\tcp_parser_implicitly_scoped_statement.\n\t(cp_parser_iteration_statement): Likewise for calls to\n\tcp_parser_already_scoped_statement.\n\t(cp_parser_implicitly_scoped_statement): Add \"guard_loc\" and\n\t\"guard_kind\" params; use them to warn for misleading\n\tindentation.\n\t(cp_parser_already_scoped_statement): Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* c-c++-common/Wmisleading-indentation.c: New testcase.\n\t* c-c++-common/Wmisleading-indentation-2.c: New testcase.\n\t* c-c++-common/Wmisleading-indentation-2.md: New file.\n\nlibcpp/ChangeLog:\n\t* directives.c (do_line): Set seen_line_directive on line_table.\n\t(do_linemarker): Likewise.\n\t* include/line-map.h (struct line_maps): Add new field\n\t\"seen_line_directive\".\n\nFrom-SVN: r223098", "tree": {"sha": "59ac6b4ba6d59fb6b6bc0da54eaa2c8c9b71068d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59ac6b4ba6d59fb6b6bc0da54eaa2c8c9b71068d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3388e62499a6d2f931247a73cabf9184366248e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3388e62499a6d2f931247a73cabf9184366248e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3388e62499a6d2f931247a73cabf9184366248e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3388e62499a6d2f931247a73cabf9184366248e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f06ed65044c0cba7f9cb8d6d8a8b99ee81953e4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f06ed65044c0cba7f9cb8d6d8a8b99ee81953e4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f06ed65044c0cba7f9cb8d6d8a8b99ee81953e4e"}], "stats": {"total": 1132, "additions": 1107, "deletions": 25}, "files": [{"sha": "c23794a1558f55a265c648cae477b488c49f49ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -1,3 +1,9 @@\n+2015-05-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* doc/invoke.texi (Warning Options): Add -Wmisleading-indentation.\n+\t(-Wmisleading-indentation): New option.\n+\t* Makefile.in (C_COMMON_OBJS): Add c-family/c-indentation.o.\n+\n 2015-05-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.h (TARGET_SUPPORTS_WIDE_INT): New define."}, {"sha": "fe22236cc0d21d89196e1f1ffa2d7189f601cbe5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -1145,8 +1145,8 @@ c-family-warn = $(STRICT_WARN)\n \n # Language-specific object files shared by all C-family front ends.\n C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n-  c-family/c-format.o c-family/c-gimplify.o c-family/c-lex.o \\\n-  c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o \\\n+  c-family/c-format.o c-family/c-gimplify.o c-family/c-indentation.o \\\n+  c-family/c-lex.o c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o \\\n   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \\\n   c-family/c-semantics.o c-family/c-ada-spec.o \\\n   c-family/c-cilkplus.o \\"}, {"sha": "52b4d5cb7a40b824671fff8504a7e701f635df5b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -1,3 +1,9 @@\n+2015-05-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-common.h (warn_for_misleading_indentation): New prototype.\n+\t* c-indentation.c: New file.\n+\t* c.opt (Wmisleading-indentation): New option.\n+\n 2015-05-12  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/66010"}, {"sha": "444d80d3fed61fcb1320dc89baa941c15574e9a1", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -1429,4 +1429,12 @@ extern bool contains_cilk_spawn_stmt (tree);\n extern tree cilk_for_number_of_iterations (tree);\n extern bool check_no_cilk (tree, const char *, const char *,\n \t\t           location_t loc = UNKNOWN_LOCATION);\n+/* In c-indentation.c.  */\n+extern void\n+warn_for_misleading_indentation (location_t guard_loc,\n+\t\t\t\t location_t body_loc,\n+\t\t\t\t location_t next_stmt_loc,\n+\t\t\t\t enum cpp_ttype next_tok_type,\n+\t\t\t\t const char *guard_kind);\n+\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "94565f6daa24ad019cb24782a3fcdbe13146c27f", "filename": "gcc/c-family/c-indentation.c", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -0,0 +1,384 @@\n+/* Implementation of -Wmisleading-indentation\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"vec.h\"\n+#include \"double-int.h\"\n+#include \"input.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"wide-int.h\"\n+#include \"inchash.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"stor-layout.h\"\n+#include \"input.h\"\n+#include \"c-common.h\"\n+\n+extern cpp_options *cpp_opts;\n+\n+/* Convert libcpp's notion of a column (a 1-based char count) to\n+   the \"visual column\" (0-based column, respecting tabs), by reading the\n+   relevant line.\n+   Returns true if a conversion was possible, writing the result to OUT,\n+   otherwise returns false.  */\n+\n+static bool\n+get_visual_column (expanded_location exploc, unsigned int *out)\n+{\n+  int line_len;\n+  const char *line = location_get_source_line (exploc, &line_len);\n+  if (!line)\n+    return false;\n+  unsigned int vis_column = 0;\n+  for (int i = 1; i < exploc.column; i++)\n+    {\n+      unsigned char ch = line[i - 1];\n+      if (ch == '\\t')\n+       {\n+\t /* Round up to nearest tab stop. */\n+\t const unsigned int tab_width = cpp_opts->tabstop;\n+\t vis_column = ((vis_column + tab_width) / tab_width) * tab_width;\n+       }\n+      else\n+       vis_column++;\n+    }\n+\n+  *out = vis_column;\n+  return true;\n+}\n+\n+/* Is the token at LOC the first non-whitespace on its line?\n+   Helper function for should_warn_for_misleading_indentation.  */\n+\n+static bool\n+is_first_nonwhitespace_on_line (expanded_location exploc)\n+{\n+  int line_len;\n+  const char *line = location_get_source_line (exploc, &line_len);\n+\n+   /* If we can't determine it, return false so that we don't issue a\n+      warning.  This is sometimes the case for input files\n+      containing #line directives, and these are often for autogenerated\n+      sources (e.g. from .md files), where it's not clear that it's\n+      meaningful to look at indentation.  */\n+  if (!line)\n+    return false;\n+\n+  for (int i = 1; i < exploc.column; i++)\n+    {\n+      unsigned char ch = line[i - 1];\n+      if (!ISSPACE (ch))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Does the given source line appear to contain a #if directive?\n+   (or #ifdef/#ifndef).  Ignore the possibility of it being inside a\n+   comment, for simplicity.\n+   Helper function for detect_preprocessor_logic.  */\n+\n+static bool\n+line_contains_hash_if (const char *file, int line_num)\n+{\n+  expanded_location exploc;\n+  exploc.file = file;\n+  exploc.line = line_num;\n+  exploc.column = 1;\n+\n+  int line_len;\n+  const char *line = location_get_source_line (exploc, &line_len);\n+  if (!line)\n+    return false;\n+\n+  int idx;\n+\n+  /* Skip leading whitespace.  */\n+  for (idx = 0; idx < line_len; idx++)\n+    if (!ISSPACE (line[idx]))\n+      break;\n+  if (idx == line_len)\n+    return false;\n+\n+  /* Require a '#' character.  */\n+  if (line[idx] != '#')\n+    return false;\n+  idx++;\n+\n+  /* Skip whitespace.  */\n+  while (idx < line_len)\n+    {\n+      if (!ISSPACE (line[idx]))\n+\tbreak;\n+      idx++;\n+    }\n+\n+  /* Match #if/#ifdef/#ifndef.  */\n+  if (idx + 2 <= line_len)\n+    if (line[idx] == 'i')\n+      if (line[idx + 1] == 'f')\n+\treturn true;\n+\n+  return false;\n+}\n+\n+\n+/* Determine if there is preprocessor logic between\n+   BODY_EXPLOC and NEXT_STMT_EXPLOC, to ensure that we don't\n+   issue a warning for cases like this:\n+\n+\tif (flagA)\n+\t  foo ();\n+\t  ^ BODY_EXPLOC\n+      #if SOME_CONDITION_THAT_DOES_NOT_HOLD\n+\tif (flagB)\n+      #endif\n+\t  bar ();\n+\t  ^ NEXT_STMT_EXPLOC\n+\n+   despite \"bar ();\" being visually aligned below \"foo ();\" and\n+   being (as far as the parser sees) the next token.\n+\n+   Return true if such logic is detected.  */\n+\n+static bool\n+detect_preprocessor_logic (expanded_location body_exploc,\n+\t\t\t   expanded_location next_stmt_exploc)\n+{\n+  gcc_assert (next_stmt_exploc.file == body_exploc.file);\n+  gcc_assert (next_stmt_exploc.line > body_exploc.line);\n+\n+  if (next_stmt_exploc.line - body_exploc.line < 4)\n+    return false;\n+\n+  /* Is there a #if/#ifdef/#ifndef directive somewhere in the lines\n+     between the given locations?\n+\n+     This is something of a layering violation, but by necessity,\n+     given the nature of what we're testing for.  For example,\n+     in theory we could be fooled by a #if within a comment, but\n+     it's unlikely to matter.  */\n+  for (int line = body_exploc.line + 1; line < next_stmt_exploc.line; line++)\n+    if (line_contains_hash_if (body_exploc.file, line))\n+      return true;\n+\n+  /* Not found.  */\n+  return false;\n+}\n+\n+\n+/* Helper function for warn_for_misleading_indentation; see\n+   description of that function below.  */\n+\n+static bool\n+should_warn_for_misleading_indentation (location_t guard_loc,\n+\t\t\t\t\tlocation_t body_loc,\n+\t\t\t\t\tlocation_t next_stmt_loc,\n+\t\t\t\t\tenum cpp_ttype next_tok_type)\n+{\n+  /* Don't attempt to compare the indentation of BODY_LOC and NEXT_STMT_LOC\n+     if either are within macros.  */\n+  if (linemap_location_from_macro_expansion_p (line_table, body_loc)\n+      || linemap_location_from_macro_expansion_p (line_table, next_stmt_loc))\n+    return false;\n+\n+  /* Don't attempt to compare indentation if #line or # 44 \"file\"-style\n+     directives are present, suggesting generated code.\n+\n+     All bets are off if these are present: the file that the #line\n+     directive could have an entirely different coding layout to C/C++\n+     (e.g. .md files).\n+\n+     To determine if a #line is present, in theory we could look for a\n+     map with reason == LC_RENAME_VERBATIM.  However, if there has\n+     subsequently been a long line requiring a column number larger than\n+     that representable by the original LC_RENAME_VERBATIM map, then\n+     we'll have a map with reason LC_RENAME.\n+     Rather than attempting to search all of the maps for a\n+     LC_RENAME_VERBATIM, instead we have libcpp set a flag whenever one\n+     is seen, and we check for the flag here.\n+  */\n+  if (line_table->seen_line_directive)\n+    return false;\n+\n+  if (next_tok_type == CPP_CLOSE_BRACE)\n+    return false;\n+\n+  /* Don't warn here about spurious semicolons.  */\n+  if (next_tok_type == CPP_SEMICOLON)\n+    return false;\n+\n+  expanded_location body_exploc\n+    = expand_location_to_spelling_point (body_loc);\n+  expanded_location next_stmt_exploc\n+    = expand_location_to_spelling_point (next_stmt_loc);\n+\n+  /* They must be in the same file.  */\n+  if (next_stmt_exploc.file != body_exploc.file)\n+    return false;\n+\n+  /* If NEXT_STMT_LOC and BODY_LOC are on the same line, consider\n+     the location of the guard.\n+\n+     Cases where we want to issue a warning:\n+\n+       if (flag)\n+         foo ();  bar ();\n+                  ^ WARN HERE\n+\n+       if (flag) foo (); bar ();\n+                         ^ WARN HERE\n+\n+     Cases where we don't want to issue a warning:\n+\n+       various_code (); if (flag) foo (); bar (); more_code ();\n+                                          ^ DON'T WARN HERE.  */\n+  if (next_stmt_exploc.line == body_exploc.line)\n+    {\n+      expanded_location guard_exploc\n+\t= expand_location_to_spelling_point (guard_loc);\n+      if (guard_exploc.file != body_exploc.file)\n+\treturn true;\n+      if (guard_exploc.line < body_exploc.line)\n+\t/* The guard is on a line before a line that contains both\n+\t   the body and the next stmt.  */\n+\treturn true;\n+      else if (guard_exploc.line == body_exploc.line)\n+\t{\n+\t  /* They're all on the same line.  */\n+\t  gcc_assert (guard_exploc.file == next_stmt_exploc.file);\n+\t  gcc_assert (guard_exploc.line == next_stmt_exploc.line);\n+\t  /* Heuristic: only warn if the guard is the first thing\n+\t     on its line.  */\n+\t  if (is_first_nonwhitespace_on_line (guard_exploc))\n+\t    return true;\n+\t}\n+    }\n+\n+  /* If NEXT_STMT_LOC is on a line after BODY_LOC, consider\n+     their relative locations, and of the guard.\n+\n+     Cases where we want to issue a warning:\n+        if (flag)\n+          foo ();\n+          bar ();\n+          ^ WARN HERE\n+\n+     Cases where we don't want to issue a warning:\n+        if (flag)\n+        foo ();\n+        bar ();\n+        ^ DON'T WARN HERE (autogenerated code?)\n+\n+\tif (flagA)\n+\t  foo ();\n+      #if SOME_CONDITION_THAT_DOES_NOT_HOLD\n+\tif (flagB)\n+      #endif\n+\t  bar ();\n+\t  ^ DON'T WARN HERE\n+  */\n+  if (next_stmt_exploc.line > body_exploc.line)\n+    {\n+      /* Determine if GUARD_LOC and NEXT_STMT_LOC are aligned on the same\n+\t \"visual column\"...  */\n+      unsigned int next_stmt_vis_column;\n+      unsigned int body_vis_column;\n+      /* If we can't determine it, don't issue a warning.  This is sometimes\n+\t the case for input files containing #line directives, and these\n+\t are often for autogenerated sources (e.g. from .md files), where\n+\t it's not clear that it's meaningful to look at indentation.  */\n+      if (!get_visual_column (next_stmt_exploc, &next_stmt_vis_column))\n+\treturn false;\n+      if (!get_visual_column (body_exploc, &body_vis_column))\n+\treturn false;\n+      if (next_stmt_vis_column == body_vis_column)\n+\t{\n+\t  /* Don't warn if they aren't aligned on the same column\n+\t     as the guard itself (suggesting autogenerated code that\n+\t     doesn't bother indenting at all).  */\n+\t  expanded_location guard_exploc\n+\t    = expand_location_to_spelling_point (guard_loc);\n+\t  unsigned int guard_vis_column;\n+\t  if (!get_visual_column (guard_exploc, &guard_vis_column))\n+\t    return false;\n+\t  if (guard_vis_column == body_vis_column)\n+\t    return false;\n+\n+\t  /* Don't warn if there is multiline preprocessor logic between\n+\t     the two statements. */\n+\t  if (detect_preprocessor_logic (body_exploc, next_stmt_exploc))\n+\t    return false;\n+\n+\t  /* Otherwise, they are visually aligned: issue a warning.  */\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Called by the C/C++ frontends when we have a guarding statement at\n+   GUARD_LOC containing a statement at BODY_LOC, where the block wasn't\n+   written using braces, like this:\n+\n+     if (flag)\n+       foo ();\n+\n+   along with the location of the next token, at NEXT_STMT_LOC,\n+   so that we can detect followup statements that are within\n+   the same \"visual block\" as the guarded statement, but which\n+   aren't logically grouped within the guarding statement, such\n+   as:\n+\n+     GUARD_LOC\n+     |\n+     V\n+     if (flag)\n+       foo (); <- BODY_LOC\n+       bar (); <- NEXT_STMT_LOC\n+\n+   In the above, \"bar ();\" isn't guarded by the \"if\", but\n+   is indented to misleadingly suggest that it is in the same\n+   block as \"foo ();\".\n+\n+   GUARD_KIND identifies the kind of clause e.g. \"if\", \"else\" etc.  */\n+\n+void\n+warn_for_misleading_indentation (location_t guard_loc,\n+\t\t\t\t location_t body_loc,\n+\t\t\t\t location_t next_stmt_loc,\n+\t\t\t\t enum cpp_ttype next_tok_type,\n+\t\t\t\t const char *guard_kind)\n+{\n+  if (should_warn_for_misleading_indentation (guard_loc,\n+\t\t\t\t\t      body_loc,\n+\t\t\t\t\t      next_stmt_loc,\n+\t\t\t\t\t      next_tok_type))\n+    if (warning_at (next_stmt_loc, OPT_Wmisleading_indentation,\n+\t\t    \"statement is indented as if it were guarded by...\"))\n+      inform (guard_loc,\n+\t      \"...this %qs clause, but it is not\", guard_kind);\n+}"}, {"sha": "285952ea5fdfd10e0d574e1a924b6334694f7695", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -553,6 +553,10 @@ Wmemset-transposed-args\n C ObjC C++ ObjC++ Var(warn_memset_transposed_args) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn about suspicious calls to memset where the third argument is constant literal zero and the second is not\n \n+Wmisleading-indentation\n+C C++ Common Var(warn_misleading_indentation) Warning\n+Warn when the indentation of the code does not reflect the block structure\n+\n Wmissing-braces\n C ObjC C++ ObjC++ Var(warn_missing_braces) Warning LangEnabledBy(C ObjC,Wall)\n Warn about possibly missing braces around initializers"}, {"sha": "f1c40738b41e7f3f188ff6fcb1c5096b7c2b958d", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -1,3 +1,12 @@\n+2015-05-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-parser.c (c_parser_if_body): Add param \"if_loc\", use it\n+\tto add a call to warn_for_misleading_indentation.\n+\t(c_parser_else_body): Likewise, adding param \"else_loc\".\n+\t(c_parser_if_statement): Check for misleading indentation.\n+\t(c_parser_while_statement): Likewise.\n+\t(c_parser_for_statement): Likewise.\n+\n 2015-05-08  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/64918"}, {"sha": "36438d0254029751aba76c599b55836f0627ca52", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -5185,7 +5185,7 @@ c_parser_c99_block_statement (c_parser *parser)\n    parser->in_if_block.  */\n \n static tree\n-c_parser_if_body (c_parser *parser, bool *if_p)\n+c_parser_if_body (c_parser *parser, bool *if_p, location_t if_loc)\n {\n   tree block = c_begin_compound_stmt (flag_isoc99);\n   location_t body_loc = c_parser_peek_token (parser)->location;\n@@ -5203,7 +5203,15 @@ c_parser_if_body (c_parser *parser, bool *if_p)\n   else if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     add_stmt (c_parser_compound_statement (parser));\n   else\n-    c_parser_statement_after_labels (parser);\n+    {\n+      c_parser_statement_after_labels (parser);\n+      if (!c_parser_next_token_is_keyword (parser, RID_ELSE))\n+\twarn_for_misleading_indentation (if_loc, body_loc,\n+\t\t\t\t\t c_parser_peek_token (parser)->location,\n+\t\t\t\t\t c_parser_peek_token (parser)->type,\n+\t\t\t\t\t \"if\");\n+    }\n+\n   return c_end_compound_stmt (body_loc, block, flag_isoc99);\n }\n \n@@ -5212,9 +5220,9 @@ c_parser_if_body (c_parser *parser, bool *if_p)\n    specially for the sake of -Wempty-body warnings.  */\n \n static tree\n-c_parser_else_body (c_parser *parser)\n+c_parser_else_body (c_parser *parser, location_t else_loc)\n {\n-  location_t else_loc = c_parser_peek_token (parser)->location;\n+  location_t body_loc = c_parser_peek_token (parser)->location;\n   tree block = c_begin_compound_stmt (flag_isoc99);\n   c_parser_all_labels (parser);\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n@@ -5227,8 +5235,14 @@ c_parser_else_body (c_parser *parser)\n       c_parser_consume_token (parser);\n     }\n   else\n-    c_parser_statement_after_labels (parser);\n-  return c_end_compound_stmt (else_loc, block, flag_isoc99);\n+    {\n+      c_parser_statement_after_labels (parser);\n+      warn_for_misleading_indentation (else_loc, body_loc,\n+\t\t\t\t       c_parser_peek_token (parser)->location,\n+\t\t\t\t       c_parser_peek_token (parser)->type,\n+\t\t\t\t       \"else\");\n+    }\n+  return c_end_compound_stmt (body_loc, block, flag_isoc99);\n }\n \n /* Parse an if statement (C90 6.6.4, C99 6.8.4).\n@@ -5250,6 +5264,7 @@ c_parser_if_statement (c_parser *parser)\n   tree if_stmt;\n \n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_IF));\n+  location_t if_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n@@ -5261,12 +5276,13 @@ c_parser_if_statement (c_parser *parser)\n     }\n   in_if_block = parser->in_if_block;\n   parser->in_if_block = true;\n-  first_body = c_parser_if_body (parser, &first_if);\n+  first_body = c_parser_if_body (parser, &first_if, if_loc);\n   parser->in_if_block = in_if_block;\n   if (c_parser_next_token_is_keyword (parser, RID_ELSE))\n     {\n+      location_t else_loc = c_parser_peek_token (parser)->location;\n       c_parser_consume_token (parser);\n-      second_body = c_parser_else_body (parser);\n+      second_body = c_parser_else_body (parser, else_loc);\n     }\n   else\n     second_body = NULL_TREE;\n@@ -5346,6 +5362,7 @@ c_parser_while_statement (c_parser *parser, bool ivdep)\n   tree block, cond, body, save_break, save_cont;\n   location_t loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_WHILE));\n+  location_t while_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n@@ -5362,7 +5379,16 @@ c_parser_while_statement (c_parser *parser, bool ivdep)\n   c_break_label = NULL_TREE;\n   save_cont = c_cont_label;\n   c_cont_label = NULL_TREE;\n+\n+  location_t body_loc = UNKNOWN_LOCATION;\n+  if (c_parser_peek_token (parser)->type != CPP_OPEN_BRACE)\n+    body_loc = c_parser_peek_token (parser)->location;\n   body = c_parser_c99_block_statement (parser);\n+  warn_for_misleading_indentation (while_loc, body_loc,\n+\t\t\t\t   c_parser_peek_token (parser)->location,\n+\t\t\t\t   c_parser_peek_token (parser)->type,\n+\t\t\t\t   \"while\");\n+\n   c_finish_loop (loc, cond, NULL, body, c_break_label, c_cont_label, true);\n   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n   c_break_label = save_break;\n@@ -5640,7 +5666,16 @@ c_parser_for_statement (c_parser *parser, bool ivdep)\n   c_break_label = NULL_TREE;\n   save_cont = c_cont_label;\n   c_cont_label = NULL_TREE;\n+\n+  location_t body_loc = UNKNOWN_LOCATION;\n+  if (c_parser_peek_token (parser)->type != CPP_OPEN_BRACE)\n+    body_loc = c_parser_peek_token (parser)->location;\n   body = c_parser_c99_block_statement (parser);\n+  warn_for_misleading_indentation (for_loc, body_loc,\n+\t\t\t\t   c_parser_peek_token (parser)->location,\n+\t\t\t\t   c_parser_peek_token (parser)->type,\n+\t\t\t\t   \"for\");\n+\n   if (is_foreach_statement)\n     objc_finish_foreach_loop (loc, object_expression, collection_expression, body, c_break_label, c_cont_label);\n   else"}, {"sha": "b119f7bc4f2a912c50456e4f8754b2c05232ce36", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -1,3 +1,15 @@\n+2015-05-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* parser.c (cp_parser_selection_statement): Add location and\n+\tguard_kind arguments to calls to\n+\tcp_parser_implicitly_scoped_statement.\n+\t(cp_parser_iteration_statement): Likewise for calls to\n+\tcp_parser_already_scoped_statement.\n+\t(cp_parser_implicitly_scoped_statement): Add \"guard_loc\" and\n+\t\"guard_kind\" params; use them to warn for misleading\n+\tindentation.\n+\t(cp_parser_already_scoped_statement): Likewise.\n+\n 2015-05-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* class.c (fixup_type_variants): Do not copy TYPE_METHODS"}, {"sha": "432aa1cab93dc21f80eea9d4cd0ecf99f04b8a59", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -2065,9 +2065,9 @@ static void cp_parser_declaration_statement\n   (cp_parser *);\n \n static tree cp_parser_implicitly_scoped_statement\n-  (cp_parser *, bool *);\n+  (cp_parser *, bool *, location_t, const char *);\n static void cp_parser_already_scoped_statement\n-  (cp_parser *);\n+  (cp_parser *, location_t, const char *);\n \n /* Declarations [gram.dcl.dcl] */\n \n@@ -10174,7 +10174,8 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t\tnested_if = false;\n \t      }\n \t    else\n-\t      cp_parser_implicitly_scoped_statement (parser, &nested_if);\n+\t      cp_parser_implicitly_scoped_statement (parser, &nested_if,\n+\t\t\t\t\t\t     token->location, \"if\");\n \t    parser->in_statement = in_statement;\n \n \t    finish_then_clause (statement);\n@@ -10184,7 +10185,8 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t\t\t\t\t\tRID_ELSE))\n \t      {\n \t\t/* Consume the `else' keyword.  */\n-\t\tcp_lexer_consume_token (parser->lexer);\n+\t\tlocation_t else_tok_loc\n+\t\t  = cp_lexer_consume_token (parser->lexer)->location;\n \t\tbegin_else_clause (statement);\n \t\t/* Parse the else-clause.  */\n \t        if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n@@ -10198,7 +10200,8 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t\t    cp_lexer_consume_token (parser->lexer);\n \t\t  }\n \t\telse\n-\t\t  cp_parser_implicitly_scoped_statement (parser, NULL);\n+\t\t  cp_parser_implicitly_scoped_statement (parser, NULL,\n+\t\t\t\t\t\t\t else_tok_loc, \"else\");\n \n \t\tfinish_else_clause (statement);\n \n@@ -10238,7 +10241,8 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t    in_statement = parser->in_statement;\n \t    parser->in_switch_statement_p = true;\n \t    parser->in_statement |= IN_SWITCH_STMT;\n-\t    cp_parser_implicitly_scoped_statement (parser, NULL);\n+\t    cp_parser_implicitly_scoped_statement (parser, NULL,\n+\t\t\t\t\t\t   0, \"switch\");\n \t    parser->in_switch_statement_p = in_switch_statement_p;\n \t    parser->in_statement = in_statement;\n \n@@ -10783,6 +10787,7 @@ static tree\n cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n {\n   cp_token *token;\n+  location_t tok_loc;\n   enum rid keyword;\n   tree statement;\n   unsigned char in_statement;\n@@ -10792,6 +10797,8 @@ cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n   if (!token)\n     return error_mark_node;\n \n+  tok_loc = token->location;\n+\n   /* Remember whether or not we are already within an iteration\n      statement.  */\n   in_statement = parser->in_statement;\n@@ -10815,7 +10822,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t/* Parse the dependent statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n-\tcp_parser_already_scoped_statement (parser);\n+\tcp_parser_already_scoped_statement (parser, tok_loc, \"while\");\n \tparser->in_statement = in_statement;\n \t/* We're done with the while-statement.  */\n \tfinish_while_stmt (statement);\n@@ -10830,7 +10837,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n \tstatement = begin_do_stmt ();\n \t/* Parse the body of the do-statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n-\tcp_parser_implicitly_scoped_statement (parser, NULL);\n+\tcp_parser_implicitly_scoped_statement (parser, NULL, 0, \"do\");\n \tparser->in_statement = in_statement;\n \tfinish_do_body (statement);\n \t/* Look for the `while' keyword.  */\n@@ -10860,7 +10867,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n \n \t/* Parse the body of the for-statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n-\tcp_parser_already_scoped_statement (parser);\n+\tcp_parser_already_scoped_statement (parser, tok_loc, \"for\");\n \tparser->in_statement = in_statement;\n \n \t/* We're done with the for-statement.  */\n@@ -11129,7 +11136,9 @@ cp_parser_declaration_statement (cp_parser* parser)\n    Returns the new statement.  */\n \n static tree\n-cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p)\n+cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p,\n+\t\t\t\t       location_t guard_loc,\n+\t\t\t\t       const char *guard_kind)\n {\n   tree statement;\n \n@@ -11152,9 +11161,18 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p)\n       /* Create a compound-statement.  */\n       statement = begin_compound_stmt (0);\n       /* Parse the dependent-statement.  */\n+      location_t body_loc = cp_lexer_peek_token (parser->lexer)->location;\n       cp_parser_statement (parser, NULL_TREE, false, if_p);\n       /* Finish the dummy compound-statement.  */\n       finish_compound_stmt (statement);\n+      cp_token *next_tok = cp_lexer_peek_token (parser->lexer);\n+      if (next_tok->keyword != RID_ELSE)\n+        {\n+          location_t next_stmt_loc = next_tok->location;\n+          warn_for_misleading_indentation (guard_loc, body_loc,\n+                                           next_stmt_loc, next_tok->type,\n+                                           guard_kind);\n+        }\n     }\n \n   /* Return the statement.  */\n@@ -11167,11 +11185,20 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p)\n    scope.  */\n \n static void\n-cp_parser_already_scoped_statement (cp_parser* parser)\n+cp_parser_already_scoped_statement (cp_parser* parser, location_t guard_loc,\n+\t\t\t\t    const char *guard_kind)\n {\n   /* If the token is a `{', then we must take special action.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n-    cp_parser_statement (parser, NULL_TREE, false, NULL);\n+    {\n+      location_t body_loc = cp_lexer_peek_token (parser->lexer)->location;\n+      cp_parser_statement (parser, NULL_TREE, false, NULL);\n+      cp_token *next_tok = cp_lexer_peek_token (parser->lexer);\n+      location_t next_stmt_loc = next_tok->location;\n+      warn_for_misleading_indentation (guard_loc, body_loc,\n+                                       next_stmt_loc, next_tok->type,\n+                                       guard_kind);\n+    }\n   else\n     {\n       /* Avoid calling cp_parser_compound_statement, so that we"}, {"sha": "117b5d99dfc7ad2c60225c21c4f8d65f726695fc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -262,7 +262,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-int-to-pointer-cast -Wno-invalid-offsetof @gol\n -Winvalid-pch -Wlarger-than=@var{len}  -Wunsafe-loop-optimizations @gol\n -Wlogical-op -Wlogical-not-parentheses -Wlong-long @gol\n--Wmain -Wmaybe-uninitialized -Wmemset-transposed-args -Wmissing-braces @gol\n+-Wmain -Wmaybe-uninitialized -Wmemset-transposed-args @gol\n+-Wmisleading-indentation -Wmissing-braces @gol\n -Wmissing-field-initializers -Wmissing-include-dirs @gol\n -Wno-multichar  -Wnonnull  -Wnormalized=@r{[}none@r{|}id@r{|}nfc@r{|}nfkc@r{]} @gol\n -Wodr  -Wno-overflow  -Wopenmp-simd @gol\n@@ -3766,6 +3767,45 @@ arguments, two, or three arguments of appropriate types.  This warning\n is enabled by default in C++ and is enabled by either @option{-Wall}\n or @option{-Wpedantic}.\n \n+@item -Wmisleading-indentation @r{(C and C++ only)}\n+@opindex Wmisleading-indentation\n+@opindex Wno-misleading-indentation\n+Warn when the indentation of the code does not reflect the block structure.\n+Specifically, a warning is issued for @code{if}, @code{else}, @code{while}, and\n+@code{for} clauses with a guarded statement that does not use braces,\n+followed by an unguarded statement with the same indentation.\n+\n+This warning is disabled by default.\n+\n+In the following example, the call to ``bar'' is misleadingly indented as\n+if it were guarded by the ``if'' conditional.\n+\n+@smallexample\n+  if (some_condition ())\n+    foo ();\n+    bar ();  /* Gotcha: this is not guarded by the \"if\".  */\n+@end smallexample\n+\n+In the case of mixed tabs and spaces, the warning uses the\n+@option{-ftabstop=} option to determine if the statements line up\n+(defaulting to 8).\n+\n+The warning is not issued for code involving multiline preprocessor logic\n+such as the following example.\n+\n+@smallexample\n+  if (flagA)\n+    foo (0);\n+#if SOME_CONDITION_THAT_DOES_NOT_HOLD\n+  if (flagB)\n+#endif\n+    foo (1);\n+@end smallexample\n+\n+The warning is not issued after a @code{#line} directive, since this\n+typically indicates autogenerated code, and no assumptions can be made\n+about the layout of the file that the directive references.\n+\n @item -Wmissing-braces\n @opindex Wmissing-braces\n @opindex Wno-missing-braces"}, {"sha": "60f7d30482452a62e67d1c98c88ab2f454256774", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -1,3 +1,9 @@\n+2015-05-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-c++-common/Wmisleading-indentation.c: New testcase.\n+\t* c-c++-common/Wmisleading-indentation-2.c: New testcase.\n+\t* c-c++-common/Wmisleading-indentation-2.md: New file.\n+\n 2015-05-12 Sandra Loosemore <sandra@codesourcery.com>\n \n \t* gcc.target/nios2/nios2-trap-insn.c: Expect \"trap\" instead of"}, {"sha": "b4ee700ec297755c0a3d4695837bdbe108a3c42d", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-2.c?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-options \"-Wmisleading-indentation\" } */\n+/* { dg-do compile } */\n+\n+/* Based on get_attr_athlon_decode from the generated insn-attrtab.c\n+   for x86_64.\n+   A #line directive, followed by a very long line to ensure that\n+   we're in a fresh line_map.\n+\n+   This should not generate a misleading indentation warning.\n+\n+   This needs to be in its own file since -Wmisleading-indentation stops\n+   after seeing a #line directive.  */\n+void fn ()\n+{\n+  switch (0)\n+    {\n+#line 6 \"../../../../src/gcc/testsuite/c-c++-common/Wmisleading-indentation-2.md\"\n+    case 0:\n+      if (0)\n+        {\n+\t  return;\n+        }\n+\n+    case 1:\n+      if (0)\n+        {\n+\t  return;\n+        }\n+      else\n+        {\n+\t  return;\n+        }\n+\n+      /**********************************************************************************************************************************/\n+      if (0)\n+        {\n+\t  return;\n+        }\n+      else if (0)\n+        {\n+\t  return;\n+        }\n+      else if (0)\n+        {\n+\t  return;\n+        }\n+      else\n+        {\n+\t  return;\n+        }\n+\n+    default:\n+      return;\n+\n+    }\n+}"}, {"sha": "44bc13adf9df62926893d266ed1a8f322841f970", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation-2.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-2.md?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -0,0 +1,46 @@\n+;; Support file for testcase Wmisleading-indentation.c\n+;; Adapted from gcc/config/i386/i386.md\n+(define_attr \"cpu\" \"none,pentium,pentiumpro,geode,k6,athlon,k8,core2,nehalem,\n+\t\t    atom,slm,generic,amdfam10,bdver1,bdver2,bdver3,bdver4,\n+\t\t    btver2,knl\"\n+  (const (symbol_ref \"ix86_schedule\")))\n+\n+;; A basic instruction type.  Refinements due to arguments to be\n+;; provided in other attributes.\n+(define_attr \"type\"\n+  \"other,multi,\n+   alu,alu1,negnot,imov,imovx,lea,\n+   incdec,ishift,ishiftx,ishift1,rotate,rotatex,rotate1,\n+   imul,imulx,idiv,icmp,test,ibr,setcc,icmov,\n+   push,pop,call,callv,leave,\n+   str,bitmanip,\n+   fmov,fop,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,\n+   fxch,fistp,fisttp,frndint,\n+   sse,ssemov,sseadd,sseadd1,sseiadd,sseiadd1,\n+   ssemul,sseimul,ssediv,sselog,sselog1,\n+   sseishft,sseishft1,ssecmp,ssecomi,\n+   ssecvt,ssecvt1,sseicvt,sseins,\n+   sseshuf,sseshuf1,ssemuladd,sse4arg,\n+   lwp,mskmov,msklog,\n+   mmx,mmxmov,mmxadd,mmxmul,mmxcmp,mmxcvt,mmxshft,\n+   mpxmov,mpxmk,mpxchk,mpxld,mpxst\"\n+  (const_string \"other\"))\n+\n+;; Main data type used by the insn\n+(define_attr \"mode\"\n+  \"unknown,none,QI,HI,SI,DI,TI,OI,XI,SF,DF,XF,TF,V16SF,V8SF,V4DF,V4SF,\n+  V2DF,V2SF,V1DF,V8DF\"\n+  (const_string \"unknown\"))\n+\n+;; The CPU unit operations uses.\n+(define_attr \"unit\" \"integer,i387,sse,mmx,unknown\"\n+  (cond [(eq_attr \"type\" \"fmov,fop,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,\n+\t\t\t  fxch,fistp,fisttp,frndint\")\n+\t   (const_string \"i387\")\n+\t (eq_attr \"type\" \"sse,ssemov,sseadd,sseadd1,sseiadd,sseiadd1,\n+\t\t\t  ssemul,sseimul,ssediv,sselog,sselog1,\n+\t\t\t  sseishft,sseishft1,ssecmp,ssecomi,\n+\t\t\t  ssecvt,ssecvt1,sseicvt,sseins,\n+\t\t\t  sseshuf,sseshuf1,ssemuladd,sse4arg,mskmov\")\n+\t   (const_string \"sse\")\n+\t (const_string \"integer\")))"}, {"sha": "3dbbb8b17d3554c6d8fa0223685b07042f51443e", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation.c", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation.c?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -0,0 +1,431 @@\n+/* { dg-options \"-Wmisleading-indentation -Wall\" } */\n+/* { dg-do compile } */\n+\n+extern int foo (int);\n+extern int bar (int, int);\n+extern int flagA;\n+extern int flagB;\n+extern int flagC;\n+extern int flagD;\n+\n+int\n+fn_1 (int flag)\n+{\n+  int x = 4, y = 5;\n+  if (flag) /* { dg-message \"3: ...this 'if' clause, but it is not\" } */\n+    x = 3;\n+    y = 2; /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+  return x * y;\n+}\n+\n+int\n+fn_2 (int flag, int x, int y)\n+{\n+  if (flag) /* { dg-message \"3: ...this 'if' clause, but it is not\" } */\n+    x++; y++; /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+\n+  return x * y;\n+}\n+\n+int\n+fn_3 (int flag)\n+{\n+  int x = 4, y = 5;\n+  if (flag)\n+    x = 3;\n+  else /* { dg-message \"3: ...this 'else' clause, but it is not\" } */\n+    x = 2;\n+    y = 2; /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+  return x * y;\n+}\n+\n+void\n+fn_4 (double *a, double *b, double *c)\n+{\n+  int i = 0;\n+  while (i < 10) /* { dg-message \"3: ...this 'while' clause, but it is not\" } */\n+    a[i] = b[i] * c[i];\n+    i++; /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void\n+fn_5 (double *a, double *b, double *sum, double *prod)\n+{\n+  int i = 0;\n+  for (i = 0; i < 10; i++) /* { dg-output \"3: ...this 'for' clause, but it is not\" } */\n+    sum[i] = a[i] * b[i];\n+    prod[i] = a[i] * b[i]; /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+/* Based on CVE-2014-1266 aka \"goto fail\" */\n+int fn_6 (int a, int b, int c)\n+{\n+\tint err;\n+\n+\t/* ... */\n+\tif ((err = foo (a)) != 0)\n+\t\tgoto fail;\n+\tif ((err = foo (b)) != 0) /* { dg-message \"2: ...this 'if' clause, but it is not\" } */\n+\t\tgoto fail;\n+\t\tgoto fail; /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+\tif ((err = foo (c)) != 0)\n+\t\tgoto fail;\n+\t/* ... */\n+\n+fail:\n+\treturn err;\n+}\n+\n+int fn_7 (int p, int q, int r, int s, int t)\n+{\n+  if (bar (p, q))\n+    {\n+      if (p) /* { dg-message \"7: ...this 'if' clause, but it is not\" } */\n+        q++; r++; /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+      t++;\n+    }\n+  return p + q + r + s + t;\n+}\n+\n+int fn_8 (int a, int b, int c)\n+{\n+  /* This should *not* be flagged as misleading indentation.  */\n+  if (a) return b; else return c;\n+}\n+\n+void fn_9 (int flag)\n+{\n+  if (flag) /* { dg-message \"3: ...this 'if' clause, but it is not\" } */\n+    foo (0);\n+    foo (1); /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void fn_10 (int flag)\n+{\n+  if (flag) /* { dg-message \"3: ...this 'if' clause, but it is not\" } */\n+    if (flag / 2)\n+      {\n+        foo (0);\n+        foo (1);\n+      }\n+    foo (2); /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+  foo (3);\n+}\n+\n+void fn_11 (void)\n+{\n+  if (flagA)\n+    if (flagB)\n+      if (flagC) /* { dg-message \"7: ...this 'if' clause, but it is not\" } */\n+        foo (0);\n+        bar (1, 2); /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void fn_12 (void)\n+{\n+  if (flagA)\n+    if (flagB) /* { dg-message \"5: ...this 'if' clause, but it is not\" } */\n+      if (flagC)\n+        foo (0);\n+      bar (1, 2); /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void fn_13 (void)\n+{\n+  if (flagA) /* { dg-message \"3: ...this 'if' clause, but it is not\" } */\n+    if (flagB)\n+      if (flagC)\n+        foo (0);\n+    bar (1, 2); /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+#define FOR_EACH(VAR, START, STOP) \\\n+  for ((VAR) = (START); (VAR) < (STOP); (VAR++)) /* { dg-message \"3: ...this 'for' clause, but it is not\" } */\n+\n+void fn_14 (void)\n+{\n+  int i;\n+  FOR_EACH (i, 0, 10) /* { dg-message \"3: in expansion of macro\" } */\n+    foo (i);\n+    bar (i, i); /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+#undef FOR_EACH\n+\n+#define FOR_EACH(VAR, START, STOP) for ((VAR) = (START); (VAR) < (STOP); (VAR++)) /* { dg-message \"36: ...this 'for' clause, but it is not\" } */\n+void fn_15 (void)\n+{\n+  int i;\n+  FOR_EACH (i, 0, 10) /* { dg-message \"3: in expansion of macro\" } */\n+    foo (i);\n+    bar (i, i); /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+#undef FOR_EACH\n+\n+void fn_16_spaces (void)\n+{\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    while (flagA)\n+      if (flagB) /* { dg-message \"7: ...this 'if' clause, but it is not\" } */\n+        foo (0);\n+        foo (1); /* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void fn_16_tabs (void)\n+{\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    while (flagA)\n+      if (flagB) /* { dg-message \"7: ...this 'if' clause, but it is not\" } */\n+\tfoo (0);\n+\tfoo (1);/* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void fn_17_spaces (void)\n+{\n+  int i;\n+  for (i = 0; i < 10; i++) /* { dg-message \"3: ...this 'for' clause, but it is not\" } */\n+    while (flagA)\n+      if (flagB)\n+        foo (0);\n+    foo (1);/* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void fn_17_tabs (void)\n+{\n+  int i;\n+  for (i = 0; i < 10; i++) /* { dg-message \"3: ...this 'for' clause, but it is not\" } */\n+    while (flagA)\n+      if (flagB)\n+\tfoo (0);\n+    foo (1);/* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void fn_18_spaces (void)\n+{\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    while (flagA) /* { dg-message \"5: ...this 'while' clause, but it is not\" } */\n+      if (flagB)\n+        foo (0);\n+      foo (1);/* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+void fn_18_tabs (void)\n+{\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    while (flagA) /* { dg-message \"5: ...this 'while' clause, but it is not\" } */\n+      if (flagB)\n+\tfoo (0);\n+      foo (1);/* { dg-warning \"statement is indented as if it were guarded by...\" } */\n+}\n+\n+/* This shouldn't lead to a warning.  */\n+int fn_19 (void) { if (flagA) return 1; else return 0; }\n+\n+/* A deeply-nested mixture of spaces and tabs, adapted from\n+   c-c++-common/pr60101.c.\n+   This should not lead to a warning.  */\n+void\n+fn_20 (unsigned int l)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < 10; i++)\n+    {\n+      unsigned int n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11;\n+\n+      for (n0 = 0; n0 < l; n0++)\n+\tfor (n1 = 0; n1 < l; n1++)\n+\t  for (n2 = 0; n2 < l; n2++)\n+\t    for (n3 = 0; n3 < l; n3++)\n+\t      for (n4 = 0; n4 < l; n4++)\n+\t\tfor (n5 = 0; n5 < l; n5++)\n+\t\t  for (n6 = 0; n6 < l; n6++)\n+\t\t    for (n7 = 0; n7 < l; n7++)\n+\t\t      for (n8 = 0; n8 < l; n8++)\n+\t\t\tfor (n9 = 0; n9 < l; n9++)\n+\t\t\t  for (n10 = 0; n10 < l; n10++)\n+\t\t\t    for (n11 = 0; n11 < l; n11++)\n+\t\t\t      {\n+\t\t\t\tif (flagA)\n+\t\t\t\t  foo (0);\n+\t\t\t\tfoo (1);\n+\t\t\t      }\n+      foo (2);\n+    }\n+}\n+\n+/* Another nested mix of tabs and spaces that shouldn't lead to a warning,\n+   with a preprocessor directive thrown in for good measure\n+   (adapted from libgomp/loop.c: gomp_loop_init).  */\n+void fn_21 (void)\n+{\n+  foo (0);\n+  if (flagA)\n+    {\n+      foo (1);\n+\n+#if 1\n+      {\n+\tfoo (2);\n+\tif (flagB)\n+\t  {\n+\t    if (flagC)\n+\t      foo (3);\n+\t    else\n+\t      foo (4);\n+\t  }\n+\telse if (flagD)\n+\t  foo (5);\n+\telse\n+\t  foo (6);\n+      }\n+#endif\n+    }\n+}\n+\n+/* The conditionals within the following macros shouldn't be warned about.\n+   Adapted from libgomp/driver.c: gomp_load_plugin_for_device.  */\n+int fn_22 (void)\n+{\n+  int err = 0;\n+\n+#define DLSYM()\t\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      err = foo (0);\t\t\t\t\t\t\t\\\n+      if (err)\t\t\t\t\t\t\t\t\\\n+\tgoto out;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+#define DLSYM_OPT()\t\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      err = foo (1);\t\t\t\t\t\t\t\\\n+      if (err)\t\t\t\t\t\t\t\t\\\n+        foo (2);\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        foo (3);\t\t\t\t\t\t\t\\\n+      foo (4);\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+  DLSYM ();\n+  DLSYM_OPT ();\n+#undef DLSYM\n+#undef DLSYM_OPT\n+\n+ out:\n+  return err;\n+}\n+\n+/* This shouldn't be warned about.  */\n+void fn_23 (void) { foo (0); foo (1); if (flagA) foo (2); foo (3); foo (4); }\n+\n+/* Code that simply doesn't bother indenting anywhere (e.g. autogenerated\n+   code) shouldn't be warned about.  */\n+void fn_24 (void)\n+{\n+  foo (0);\n+  if (flagA)\n+  foo (1);\n+  foo (2);\n+}\n+\n+/* Adapted from libiberty/regex.c; an example of a conditional in a\n+   macro where the successor statement begins with a macro arg:\n+\n+\t    if (num < 0)\n+\t      num = 0;\n+\t    num = num * 10 + c - '0';\n+\t    ^ this successor statement\n+\n+   and hence \"num\" has a spelling location at the argument of the\n+   macro usage site (\"lower_bound\"), we want the definition of the\n+   parameter (\"num\") for the indentation comparison to be meaninful.\n+\n+   This should not generate a misleading indentation warning.  */\n+\n+# define GET_UNSIGNED_NUMBER(num) \\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    while (flagA)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (flagB)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (num < 0)\t\t\t\t\t\t\\\n+\t      num = 0;\t\t\t\t\t\t\t\\\n+\t    num = num * 10 + c - '0';\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+void fn_25 (int c, int lower_bound, int upper_bound)\n+{\n+  GET_UNSIGNED_NUMBER (lower_bound);\n+}\n+#undef GET_UNSIGNED_NUMBER\n+\n+/* Example adapted from libdecnumber/decNumber.c:decExpOp that shouldn't\n+   trigger a warning.  */\n+void fn_26 (void)\n+{\n+  if (flagA) {\n+    if (flagB) foo (0); }\n+  foo (1);\n+}\n+\n+/* Ensure that we don't get confused by mixed tabs and spaces; the line\n+   \"foo (1);\" has leading spaces before a tab, but this should not\n+   lead to a warning from -Wmisleading-indentation.  */\n+void fn_27 (void)\n+{\n+\t      if (flagA)\n+\t\tfoo (0);\n+  \t      foo (1);\n+}\n+\n+/* Example adapted from gcc/cgraph.h:symtab_node::get_availability of\n+   a spurious trailing semicolon that shouldn't generate a warning.  */\n+void fn_28 (void)\n+{\n+  if (flagA)\n+    foo (0);\n+  else\n+    foo (1);;\n+}\n+\n+/* However, other kinds of spurious semicolons can be a problem.  Sadly\n+   we don't yet report for the misleading-indented \"foo (1);\" in the\n+   following, due to the spurious semicolon.  */\n+void fn_29 (void)\n+{\n+  if (flagA)\n+    if (flagB)\n+      foo (0);;\n+    foo (1);\n+}\n+\n+/* Adapted from usage site of #ifdef HAVE_cc0.  This should not lead\n+   to a warning from -Wmisleading-indentation.  */\n+void fn_30 (void)\n+{\n+  if (flagA)\n+    foo (0);\n+#if SOME_CONDITION_THAT_DOES_NOT_HOLD\n+  if (flagB)\n+#endif\n+    foo (1);\n+}\n+\n+/* This shouldn't lead to a warning.  */\n+void fn_31 (void)\n+{\n+  if (flagA)\n+    foo (0);\n+  else if (flagB)\n+    foo (1);\n+  else if (flagC)\n+    foo (2);\n+  else\n+    foo (3);\n+}"}, {"sha": "c0f04ac044547e52c6ac122a2a1ae164d7640907", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -1,3 +1,10 @@\n+2015-05-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* directives.c (do_line): Set seen_line_directive on line_table.\n+\t(do_linemarker): Likewise.\n+\t* include/line-map.h (struct line_maps): Add new field\n+\t\"seen_line_directive\".\n+\n 2015-05-08  Jason Merrill  <jason@redhat.com>\n \n \t* include/cpplib.h: Add CPP_W_CXX11_COMPAT."}, {"sha": "356ec135100d9c9d7e32b87b9b55fcfc3227daa7", "filename": "libcpp/directives.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -911,7 +911,7 @@ strtolinenum (const uchar *str, size_t len, linenum_type *nump, bool *wrapped)\n static void\n do_line (cpp_reader *pfile)\n {\n-  const struct line_maps *line_table = pfile->line_table;\n+  struct line_maps *line_table = pfile->line_table;\n   const struct line_map *map = LINEMAPS_LAST_ORDINARY_MAP (line_table);\n \n   /* skip_rest_of_line() may cause line table to be realloc()ed so note down\n@@ -965,6 +965,7 @@ do_line (cpp_reader *pfile)\n   skip_rest_of_line (pfile);\n   _cpp_do_file_change (pfile, LC_RENAME_VERBATIM, new_file, new_lineno,\n \t\t       map_sysp);\n+  line_table->seen_line_directive = true;\n }\n \n /* Interpret the # 44 \"file\" [flags] notation, which has slightly\n@@ -973,7 +974,7 @@ do_line (cpp_reader *pfile)\n static void\n do_linemarker (cpp_reader *pfile)\n {\n-  const struct line_maps *line_table = pfile->line_table;\n+  struct line_maps *line_table = pfile->line_table;\n   const struct line_map *map = LINEMAPS_LAST_ORDINARY_MAP (line_table);\n   const cpp_token *token;\n   const char *new_file = ORDINARY_MAP_FILE_NAME (map);\n@@ -1052,6 +1053,7 @@ do_linemarker (cpp_reader *pfile)\n   pfile->line_table->highest_location--;\n \n   _cpp_do_file_change (pfile, reason, new_file, new_lineno, new_sysp);\n+  line_table->seen_line_directive = true;\n }\n \n /* Arrange the file_change callback.  pfile->line has changed to"}, {"sha": "ddeaf0c1954bb40e6ead87d83213c83b2980dac1", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3388e62499a6d2f931247a73cabf9184366248e/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3388e62499a6d2f931247a73cabf9184366248e/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=c3388e62499a6d2f931247a73cabf9184366248e", "patch": "@@ -386,6 +386,9 @@ struct GTY(()) line_maps {\n   /* The special location value that is used as spelling location for\n      built-in tokens.  */\n   source_location builtin_location;\n+\n+  /* True if we've seen a #line or # 44 \"file\" directive.  */\n+  bool seen_line_directive;\n };\n \n /* Returns the pointer to the memory region where information about"}]}