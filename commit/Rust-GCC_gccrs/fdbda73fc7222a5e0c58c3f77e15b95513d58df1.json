{"sha": "fdbda73fc7222a5e0c58c3f77e15b95513d58df1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRiZGE3M2ZjNzIyMmE1ZTBjNThjM2Y3N2UxNWI5NTUxM2Q1OGRmMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2004-07-12T18:01:44Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2004-07-12T18:01:44Z"}, "message": "re PR rtl-optimization/15921 (gcc.c-torture/compile/920501-4.c fails on powerpc-*)\n\n2004-07-12 Vladimir Makarov <vmakarov@redhat.com>\n\n\tPR rtl-optimization/15921\n\t* Makefile.in (global.o): Add recog.h.\n\n\t* global.c (recog.h): Add the include-clause.\n\t(bb_info): New member earlyclobber.\n\t(allocate_bb_info, free_bb_info): Initialize/finish the new\n\tmember.\n\t(earlyclobber_regclass, earlyclobber_regclass_length): The new\n\tglobal variables.\n\t(check_earlyclobber, regclass_intersect,\n\tmark_reg_use_for_earlyclobber, mark_reg_use_for_earlyclobber_1):\n\tNew functions.\n\t(calculate_local_reg_bb_info): Calculate value of earlyclobber.\n\t(make_accurate_live_analysis): Modify pavin.\n\nFrom-SVN: r84569", "tree": {"sha": "3c211d262e7948268c9f1e2152391cfef08a1bb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c211d262e7948268c9f1e2152391cfef08a1bb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdbda73fc7222a5e0c58c3f77e15b95513d58df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbda73fc7222a5e0c58c3f77e15b95513d58df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdbda73fc7222a5e0c58c3f77e15b95513d58df1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbda73fc7222a5e0c58c3f77e15b95513d58df1/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3143d517e48ff2f8d99c9069a4df2263c49021d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3143d517e48ff2f8d99c9069a4df2263c49021d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3143d517e48ff2f8d99c9069a4df2263c49021d8"}], "stats": {"total": 185, "additions": 181, "deletions": 4}, "files": [{"sha": "577cb62611b7ef70635fe8a93cd579627bb3b6ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbda73fc7222a5e0c58c3f77e15b95513d58df1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbda73fc7222a5e0c58c3f77e15b95513d58df1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdbda73fc7222a5e0c58c3f77e15b95513d58df1", "patch": "@@ -1,3 +1,20 @@\n+2004-07-12 Vladimir Makarov <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/15921\n+\t* Makefile.in (global.o): Add recog.h.\n+\t\n+\t* global.c (recog.h): Add the include-clause.\n+\t(bb_info): New member earlyclobber.\n+\t(allocate_bb_info, free_bb_info): Initialize/finish the new\n+\tmember.\n+\t(earlyclobber_regclass, earlyclobber_regclass_length): The new\n+\tglobal variables.\n+\t(check_earlyclobber, regclass_intersect,\n+\tmark_reg_use_for_earlyclobber, mark_reg_use_for_earlyclobber_1):\n+\tNew functions.\n+\t(calculate_local_reg_bb_info): Calculate value of earlyclobber.\n+\t(make_accurate_live_analysis): Modify pavin.\n+\t\n 2004-07-12  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-cfg.c (find_taken_edge): Statically compute the truth"}, {"sha": "6d55e06941b8441137b0aa3d2d6657da247ccaad", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbda73fc7222a5e0c58c3f77e15b95513d58df1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbda73fc7222a5e0c58c3f77e15b95513d58df1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fdbda73fc7222a5e0c58c3f77e15b95513d58df1", "patch": "@@ -2006,9 +2006,9 @@ local-alloc.o : local-alloc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_\n bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(GTM_H) $(RTL_H) $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) $(REGS_H) $(GGC_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n-global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n-   reload.h function.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h output.h \\\n-   toplev.h $(TM_P_H)\n+global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n+   reload.h function.h $(RECOG_H) $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h\\\n+   insn-config.h output.h toplev.h $(TM_P_H)\n varray.o : varray.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h $(GGC_H) errors.h \\\n    $(HASHTAB_H)\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) coretypes.h vec.h $(GGC_H) errors.h"}, {"sha": "ab508444de45aba6acc595d26a9910f6e3f33851", "filename": "gcc/global.c", "status": "modified", "additions": 161, "deletions": 1, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbda73fc7222a5e0c58c3f77e15b95513d58df1/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbda73fc7222a5e0c58c3f77e15b95513d58df1/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=fdbda73fc7222a5e0c58c3f77e15b95513d58df1", "patch": "@@ -34,6 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"regs.h\"\n #include \"function.h\"\n #include \"insn-config.h\"\n+#include \"recog.h\"\n #include \"reload.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n@@ -309,6 +310,10 @@ static void reg_dies (int, enum machine_mode, struct insn_chain *);\n \n static void allocate_bb_info (void);\n static void free_bb_info (void);\n+static void check_earlyclobber (rtx);\n+static bool regclass_intersect (enum reg_class, enum reg_class);\n+static void mark_reg_use_for_earlyclobber_1 (rtx *, void *);\n+static int mark_reg_use_for_earlyclobber (rtx *, void *);\n static void calculate_local_reg_bb_info (void);\n static void set_up_bb_rts_numbers (void);\n static int rpost_cmp (const void *, const void *);\n@@ -2000,6 +2005,9 @@ struct bb_info\n {\n   /* The basic block reverse post-order number.  */\n   int rts_number;\n+  /* Registers used uninitialized in an insn in which there is an\n+     early clobbered register might get the same hard register.  */\n+  bitmap earlyclobber;\n   /* Registers correspondingly killed (clobbered) and defined but not\n      killed afterward in the basic block.  */\n   bitmap killed, avloc;\n@@ -2032,6 +2040,7 @@ allocate_bb_info (void)\n   FOR_EACH_BB (bb)\n     {\n       bb_info = bb->aux;\n+      bb_info->earlyclobber = BITMAP_XMALLOC ();\n       bb_info->avloc = BITMAP_XMALLOC ();\n       bb_info->killed = BITMAP_XMALLOC ();\n       bb_info->pavin = BITMAP_XMALLOC ();\n@@ -2057,6 +2066,7 @@ free_bb_info (void)\n       BITMAP_XFREE (bb_info->pavin);\n       BITMAP_XFREE (bb_info->killed);\n       BITMAP_XFREE (bb_info->avloc);\n+      BITMAP_XFREE (bb_info->earlyclobber);\n     }\n   free_aux_for_blocks ();\n }\n@@ -2086,6 +2096,144 @@ mark_reg_change (rtx reg, rtx setter, void *data)\n     bitmap_clear_bit (bb_info->avloc, regno);\n }\n \n+/* Classes of registers which could be early clobbered in the current\n+   insn.  */\n+\n+static varray_type earlyclobber_regclass;\n+\n+/* The function stores classes of registers which could be early\n+   clobbered in INSN.  */\n+\n+static void\n+check_earlyclobber (rtx insn)\n+{\n+  int opno;\n+\n+  extract_insn (insn);\n+\n+  VARRAY_POP_ALL (earlyclobber_regclass);\n+  for (opno = 0; opno < recog_data.n_operands; opno++)\n+    {\n+      char c;\n+      bool amp_p;\n+      int i;\n+      enum reg_class class;\n+      const char *p = recog_data.constraints[opno];\n+\n+      class = NO_REGS;\n+      amp_p = false;\n+      for (;;)\n+\t{\n+\t  c = *p;\n+\t  switch (c)\n+\t    {\n+\t    case '=':  case '+':  case '?':\n+\t    case '#':  case '!':\n+\t    case '*':  case '%':\n+\t    case 'm':  case '<':  case '>':  case 'V':  case 'o':\n+\t    case 'E':  case 'F':  case 'G':  case 'H':\n+\t    case 's':  case 'i':  case 'n':\n+\t    case 'I':  case 'J':  case 'K':  case 'L':\n+\t    case 'M':  case 'N':  case 'O':  case 'P':\n+\t    case 'X':\n+\t    case '0': case '1':  case '2':  case '3':  case '4':\n+\t    case '5': case '6':  case '7':  case '8':  case '9':\n+\t      /* These don't say anything we care about.  */\n+\t      break;\n+\n+\t    case '&':\n+\t      amp_p = true;\n+\t      break;\n+\t    case '\\0':\n+\t    case ',':\n+\t      if (amp_p && class != NO_REGS)\n+\t\t{\n+\t\t  for (i = VARRAY_ACTIVE_SIZE (earlyclobber_regclass) - 1;\n+\t\t       i >= 0; i--)\n+\t\t    if (VARRAY_INT (earlyclobber_regclass, i) == (int) class)\n+\t\t      break;\n+\t\t  if (i < 0)\n+\t\t    VARRAY_PUSH_INT (earlyclobber_regclass, (int) class);\n+\t\t}\n+\t      \n+\t      amp_p = false;\n+\t      class = NO_REGS;\n+\t      break;\n+\n+\t    case 'r':\n+\t      class = GENERAL_REGS;\n+\t      break;\n+\n+\t    default:\n+\t      class = REG_CLASS_FROM_CONSTRAINT (c, p);\n+\t      break;\n+\t    }\n+\t  if (c == '\\0')\n+\t    break;\n+\t  p += CONSTRAINT_LEN (c, p);\n+\t}\n+    }\n+}\n+\n+/* The function returns true if register classes C1 and C2 inetrsect.  */\n+\n+static bool\n+regclass_intersect (enum reg_class c1, enum reg_class c2)\n+{\n+  HARD_REG_SET rs, zero;\n+\n+  CLEAR_HARD_REG_SET (zero);\n+  COPY_HARD_REG_SET(rs, reg_class_contents [c1]);\n+  AND_HARD_REG_SET (rs, reg_class_contents [c2]);\n+  GO_IF_HARD_REG_EQUAL (zero, rs, yes);\n+  return true;\n+ yes:\n+  return false;\n+}\n+\n+/* The function checks that pseudo-register *X has a class\n+   intersecting with the class of pseudo-register could be early\n+   clobbered in the same insn.  */\n+\n+static int\n+mark_reg_use_for_earlyclobber (rtx *x, void *data ATTRIBUTE_UNUSED)\n+{\n+  enum reg_class pref_class, alt_class;\n+  int i, regno;\n+  basic_block bb = data;\n+  struct bb_info *bb_info = BB_INFO (bb);\n+\n+  if (GET_CODE (*x) == REG && REGNO (*x) >= FIRST_PSEUDO_REGISTER)\n+    {\n+      regno = REGNO (*x);\n+      if (bitmap_bit_p (bb_info->killed, regno)\n+\t  || bitmap_bit_p (bb_info->avloc, regno))\n+\treturn 0;\n+      pref_class = reg_preferred_class (regno);\n+      alt_class = reg_alternate_class (regno);\n+      for (i = VARRAY_ACTIVE_SIZE (earlyclobber_regclass) - 1; i >= 0; i--)\n+\tif (regclass_intersect (VARRAY_INT (earlyclobber_regclass, i),\n+\t\t\t\tpref_class)\n+\t    || (VARRAY_INT (earlyclobber_regclass, i) != NO_REGS\n+\t\t&& regclass_intersect (VARRAY_INT (earlyclobber_regclass, i),\n+\t\t\t\t       alt_class)))\n+\t  {\n+\t    bitmap_set_bit (bb_info->earlyclobber, regno);\n+\t    break;\n+\t  }\n+    }\n+  return 0;\n+}\n+\n+/* The function processes all pseudo-registers in *X with the aid of\n+   previous function.  */\n+\n+static void\n+mark_reg_use_for_earlyclobber_1 (rtx *x, void *data)\n+{\n+  for_each_rtx (x, mark_reg_use_for_earlyclobber, data);\n+}\n+\n /* The function calculates local info for each basic block.  */\n \n static void\n@@ -2094,12 +2242,18 @@ calculate_local_reg_bb_info (void)\n   basic_block bb;\n   rtx insn, bound;\n \n+  VARRAY_INT_INIT (earlyclobber_regclass, 20,\n+\t\t   \"classes of registers early clobbered in an insn\");\n   FOR_EACH_BB (bb)\n     {\n       bound = NEXT_INSN (BB_END (bb));\n       for (insn = BB_HEAD (bb); insn != bound; insn = NEXT_INSN (insn))\n \tif (INSN_P (insn))\n-\t  note_stores (PATTERN (insn), mark_reg_change, bb);\n+\t  {\n+\t    note_stores (PATTERN (insn), mark_reg_change, bb);\n+\t    check_earlyclobber (insn);\n+\t    note_uses (&PATTERN (insn), mark_reg_use_for_earlyclobber_1, bb);\n+\t  }\n     }\n }\n \n@@ -2229,6 +2383,12 @@ make_accurate_live_analysis (void)\n     {\n       bb_info = BB_INFO (bb);\n       \n+      /* Reload can assign the same hard register to uninitialized\n+\t pseudo-register and early clobbered pseudo-register in an\n+\t insn if the pseudo-register is used first time in given BB\n+\t and not lived at the BB start.  To prevent this we don't\n+\t change life information for such pseudo-registers.  */\n+      bitmap_a_or_b (bb_info->pavin, bb_info->pavin, bb_info->earlyclobber);\n       bitmap_a_and_b (bb->global_live_at_start, bb->global_live_at_start,\n \t\t      bb_info->pavin);\n       bitmap_a_and_b (bb->global_live_at_end, bb->global_live_at_end,"}]}