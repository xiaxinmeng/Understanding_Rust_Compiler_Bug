{"sha": "1b0cb6fc469d36d98f81507153e505190a78efab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIwY2I2ZmM0NjlkMzZkOThmODE1MDcxNTNlNTA1MTkwYTc4ZWZhYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-27T10:33:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-27T10:33:04Z"}, "message": "(expand_end_case): Use old type of INDEX_EXPR when making a constant.\n\nFrom-SVN: r7359", "tree": {"sha": "11f94ab6b9aa60e585529dfae24065433c18bc47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11f94ab6b9aa60e585529dfae24065433c18bc47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b0cb6fc469d36d98f81507153e505190a78efab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b0cb6fc469d36d98f81507153e505190a78efab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b0cb6fc469d36d98f81507153e505190a78efab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b0cb6fc469d36d98f81507153e505190a78efab/comments", "author": null, "committer": null, "parents": [{"sha": "3061cc5422b176d0b0f7a283582098f777f73ec7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3061cc5422b176d0b0f7a283582098f777f73ec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3061cc5422b176d0b0f7a283582098f777f73ec7"}], "stats": {"total": 47, "additions": 22, "deletions": 25}, "files": [{"sha": "40d515438241d4806f933f9f7b06f74aba54deca", "filename": "gcc/stmt.c", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b0cb6fc469d36d98f81507153e505190a78efab/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b0cb6fc469d36d98f81507153e505190a78efab/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1b0cb6fc469d36d98f81507153e505190a78efab", "patch": "@@ -4214,7 +4214,7 @@ expand_end_case (orig_index)\n   register int i;\n   rtx before_case;\n   register struct nesting *thiscase = case_stack;\n-  tree index_expr;\n+  tree index_expr, index_type;\n   int unsignedp;\n \n   if (output_bytecode)\n@@ -4225,12 +4225,13 @@ expand_end_case (orig_index)\n \n   table_label = gen_label_rtx ();\n   index_expr = thiscase->data.case_stmt.index_expr;\n-  unsignedp = TREE_UNSIGNED (TREE_TYPE (index_expr));\n+  index_type = TREE_TYPE (index_expr);\n+  unsignedp = TREE_UNSIGNED (index_type);\n \n   do_pending_stack_adjust ();\n \n   /* An ERROR_MARK occurs for various reasons including invalid data type.  */\n-  if (TREE_TYPE (index_expr) != error_mark_node)\n+  if (index_type != error_mark_node)\n     {\n       /* If switch expression was an enumerated type, check that all\n \t enumeration literals are covered by the cases.\n@@ -4284,8 +4285,8 @@ expand_end_case (orig_index)\n \t  if (TREE_CODE (n->high) != INTEGER_CST)\n \t    abort ();\n \n-\t  n->low = convert (TREE_TYPE (index_expr), n->low);\n-\t  n->high = convert (TREE_TYPE (index_expr), n->high);\n+\t  n->low = convert (index_type, n->low);\n+\t  n->high = convert (index_type, n->high);\n \n \t  /* Count the elements and track the largest and smallest\n \t     of them (treating them as signed even if they are not).  */\n@@ -4310,10 +4311,9 @@ expand_end_case (orig_index)\n \n       /* Compute span of values.  */\n       if (count != 0)\n-\trange = fold (build (MINUS_EXPR, TREE_TYPE (index_expr),\n-\t\t\t     maxval, minval));\n+\trange = fold (build (MINUS_EXPR, index_type, maxval, minval));\n \n-      if (count == 0 || TREE_CODE (TREE_TYPE (index_expr)) == ERROR_MARK)\n+      if (count == 0)\n \t{\n \t  expand_expr (index_expr, const0_rtx, VOIDmode, 0);\n \t  emit_queue ();\n@@ -4387,22 +4387,19 @@ expand_end_case (orig_index)\n \t\t  index_expr\n \t\t    = build_int_2 (INTVAL (index),\n \t\t\t\t   unsignedp || INTVAL (index) >= 0 ? 0 : -1);\n-\t\t  index_expr = convert (TREE_TYPE (index_expr), index_expr);\n+\t\t  index_expr = convert (index_type, index_expr);\n \t\t}\n \n \t      /* For constant index expressions we need only\n \t\t issue a unconditional branch to the appropriate\n \t\t target code.  The job of removing any unreachable\n \t\t code is left to the optimisation phase if the\n \t\t \"-O\" option is specified.  */\n-\t      for (n = thiscase->data.case_stmt.case_list;\n-\t\t   n;\n-\t\t   n = n->right)\n-\t\t{\n-\t\t  if (! tree_int_cst_lt (index_expr, n->low)\n-\t\t      && ! tree_int_cst_lt (n->high, index_expr))\n-\t\t    break;\n-\t\t}\n+\t      for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n+\t\tif (! tree_int_cst_lt (index_expr, n->low)\n+\t\t    && ! tree_int_cst_lt (n->high, index_expr))\n+\t\t  break;\n+\n \t      if (n)\n \t\temit_jump (label_rtx (n->code_label));\n \t      else\n@@ -4430,7 +4427,7 @@ expand_end_case (orig_index)\n \t      balance_case_nodes (&thiscase->data.case_stmt.case_list, \n \t\t\t\t  NULL_PTR);\n \t      emit_case_nodes (index, thiscase->data.case_stmt.case_list,\n-\t\t\t       default_label, TREE_TYPE (index_expr));\n+\t\t\t       default_label, index_type);\n \t      emit_jump_if_reachable (default_label);\n \t    }\n \t}\n@@ -4446,14 +4443,14 @@ expand_end_case (orig_index)\n \t      enum machine_mode op_mode;\n \n \t      /* Convert the index to SImode.  */\n-\t      if (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (index_expr)))\n+\t      if (GET_MODE_BITSIZE (TYPE_MODE (index_type))\n \t\t  > GET_MODE_BITSIZE (index_mode))\n \t\t{\n-\t\t  enum machine_mode omode = TYPE_MODE (TREE_TYPE (index_expr));\n+\t\t  enum machine_mode omode = TYPE_MODE (index_type);\n \t\t  rtx rangertx = expand_expr (range, NULL_RTX, VOIDmode, 0);\n \n \t\t  /* We must handle the endpoints in the original mode.  */\n-\t\t  index_expr = build (MINUS_EXPR, TREE_TYPE (index_expr),\n+\t\t  index_expr = build (MINUS_EXPR, index_type,\n \t\t\t\t      index_expr, minval);\n \t\t  minval = integer_zero_node;\n \t\t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n@@ -4464,7 +4461,7 @@ expand_end_case (orig_index)\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (TYPE_MODE (TREE_TYPE (index_expr)) != index_mode)\n+\t\t  if (TYPE_MODE (index_type) != index_mode)\n \t\t    index_expr = convert (type_for_size (index_bits, 0),\n \t\t\t\t\t  index_expr);\n \t\t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n@@ -4501,15 +4498,14 @@ expand_end_case (orig_index)\n \t  if (! win && HAVE_tablejump)\n \t    {\n \t      index_expr = convert (thiscase->data.case_stmt.nominal_type,\n-\t\t\t\t    fold (build (MINUS_EXPR,\n-\t\t\t\t\t\t TREE_TYPE (index_expr),\n+\t\t\t\t    fold (build (MINUS_EXPR, index_type,\n \t\t\t\t\t\t index_expr, minval)));\n \t      index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n \t      emit_queue ();\n \t      index = protect_from_queue (index, 0);\n \t      do_pending_stack_adjust ();\n \n-\t      do_tablejump (index, TYPE_MODE (TREE_TYPE (index_expr)),\n+\t      do_tablejump (index, TYPE_MODE (index_type),\n \t\t\t    expand_expr (range, NULL_RTX, VOIDmode, 0),\n \t\t\t    table_label, default_label);\n \t      win = 1;\n@@ -4576,6 +4572,7 @@ expand_end_case (orig_index)\n       reorder_insns (before_case, get_last_insn (),\n \t\t     thiscase->data.case_stmt.start);\n     }\n+\n   if (thiscase->exit_label)\n     emit_label (thiscase->exit_label);\n "}]}