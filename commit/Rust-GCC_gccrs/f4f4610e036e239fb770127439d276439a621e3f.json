{"sha": "f4f4610e036e239fb770127439d276439a621e3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRmNDYxMGUwMzZlMjM5ZmI3NzAxMjc0MzlkMjc2NDM5YTYyMWUzZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-04-13T17:54:03Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-04-13T17:54:03Z"}, "message": "re PR c++/10300 (use of array-new (nothrow) in segfaults on NULL return)\n\n\tPR c++/10300\n\t* init.c (build_new_1): Reorganize.\n\n\tPR c++/10300\n\t* g++.dg/init/new5.C: New test.\n\nFrom-SVN: r65550", "tree": {"sha": "7fbe33dd676b1ebf539390363ab3eabc1f30a1a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fbe33dd676b1ebf539390363ab3eabc1f30a1a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4f4610e036e239fb770127439d276439a621e3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f4610e036e239fb770127439d276439a621e3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f4610e036e239fb770127439d276439a621e3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f4610e036e239fb770127439d276439a621e3f/comments", "author": null, "committer": null, "parents": [{"sha": "5de601cf5728d16ed4f406909bedaaa7230a7040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5de601cf5728d16ed4f406909bedaaa7230a7040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5de601cf5728d16ed4f406909bedaaa7230a7040"}], "stats": {"total": 157, "additions": 97, "deletions": 60}, "files": [{"sha": "b520d2c1bb292826c32b84b5f88f46b5728d5c81", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4610e036e239fb770127439d276439a621e3f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4610e036e239fb770127439d276439a621e3f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f4f4610e036e239fb770127439d276439a621e3f", "patch": "@@ -1,3 +1,8 @@\n+2003-04-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/10300\n+\t* init.c (build_new_1): Reorganize.\n+\n 2003-04-12  Zack Weinberg  <zack@codesourcery.com>\n \n \t* class.c (initialize_array)"}, {"sha": "d4beb0b751cd3d3480feb074518bdf6549943ea3", "filename": "gcc/cp/init.c", "status": "modified", "additions": 69, "deletions": 60, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4610e036e239fb770127439d276439a621e3f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4610e036e239fb770127439d276439a621e3f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f4f4610e036e239fb770127439d276439a621e3f", "patch": "@@ -2154,13 +2154,24 @@ build_new_1 (exp)\n      tree exp;\n {\n   tree placement, init;\n-  tree type, true_type, size, rval, t;\n+  tree true_type, size, rval, t;\n+  /* The type of the new-expression.  (This type is always a pointer\n+     type.)  */\n+  tree pointer_type;\n+  /* The type pointed to by POINTER_TYPE.  */\n+  tree type;\n+  /* The type being allocated.  For \"new T[...]\" this will be an\n+     ARRAY_TYPE.  */\n   tree full_type;\n+  /* A pointer type pointing to to the FULL_TYPE.  */\n+  tree full_pointer_type;\n   tree outer_nelts = NULL_TREE;\n   tree nelts = NULL_TREE;\n-  tree alloc_call, alloc_expr, alloc_node;\n+  tree alloc_call, alloc_expr;\n+  /* The address returned by the call to \"operator new\".  This node is\n+     a VAR_DECL and is therefore reusable.  */\n+  tree alloc_node;\n   tree alloc_fn;\n-  tree cookie_expr, init_expr;\n   int has_array = 0;\n   enum tree_code code;\n   int nothrow, check_new;\n@@ -2175,6 +2186,14 @@ build_new_1 (exp)\n      function.  */\n   bool placement_allocation_fn_p;\n   tree args = NULL_TREE;\n+  /* True if the storage must be initialized, either by a constructor\n+     or due to an explicit new-intiailizer.  */\n+  bool is_initialized;\n+  /* The address of the thing allocated, not including any cookie.  In\n+     particular, if an array cookie is in use, DATA_ADDR is the\n+     address of the first array element.  This node is a VAR_DECL, and\n+     is therefore reusable.  */\n+  tree data_addr;\n \n   placement = TREE_OPERAND (exp, 0);\n   type = TREE_OPERAND (exp, 1);\n@@ -2218,6 +2237,13 @@ build_new_1 (exp)\n   if (abstract_virtuals_error (NULL_TREE, true_type))\n     return error_mark_node;\n \n+  is_initialized = (TYPE_NEEDS_CONSTRUCTING (type) || init);\n+  if (CP_TYPE_CONST_P (true_type) && !is_initialized)\n+    {\n+      error (\"uninitialized const in `new' of `%#T'\", true_type);\n+      return error_mark_node;\n+    }\n+\n   size = size_in_bytes (true_type);\n   if (has_array)\n     size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n@@ -2321,44 +2347,49 @@ build_new_1 (exp)\n   nothrow = TYPE_NOTHROW_P (TREE_TYPE (alloc_fn));\n   check_new = (flag_check_new || nothrow) && ! use_java_new;\n \n-  alloc_expr = alloc_call;\n-\n-  if (cookie_size)\n-    /* Adjust so we're pointing to the start of the object.  */\n-    alloc_expr = build (PLUS_EXPR, TREE_TYPE (alloc_expr),\n-\t\t\talloc_expr, cookie_size);\n+  /* In the simple case, we can stop now.  */\n+  pointer_type = build_pointer_type (type);\n+  if (!cookie_size && !is_initialized)\n+    return build_nop (pointer_type, alloc_call);\n \n   /* While we're working, use a pointer to the type we've actually\n-     allocated.  */\n-  alloc_expr = convert (build_pointer_type (full_type), alloc_expr);\n-\n-  /* Now save the allocation expression so we only evaluate it once.  */\n-  alloc_expr = get_target_expr (alloc_expr);\n+     allocated. Store the result of the call in a variable so that we\n+     can use it more than once.  */\n+  full_pointer_type = build_pointer_type (full_type);\n+  alloc_expr = get_target_expr (build_nop (full_pointer_type, alloc_call));\n   alloc_node = TREE_OPERAND (alloc_expr, 0);\n+  rval = NULL_TREE;\n \n-  /* Now initialize the cookie.  */\n   if (cookie_size)\n     {\n       tree cookie;\n+      tree cookie_expr;\n+\n+      /* Adjust so we're pointing to the start of the object.  */\n+      data_addr = get_target_expr (build (PLUS_EXPR, full_pointer_type,\n+\t\t\t\t\t  alloc_node, cookie_size));\n \n       /* Store the number of bytes allocated so that we can know how\n \t many elements to destroy later.  We use the last sizeof\n \t (size_t) bytes to store the number of elements.  */\n       cookie = build (MINUS_EXPR, build_pointer_type (sizetype),\n-\t\t      alloc_node, size_in_bytes (sizetype));\n+\t\t      data_addr, size_in_bytes (sizetype));\n       cookie = build_indirect_ref (cookie, NULL);\n \n-      cookie_expr = build (MODIFY_EXPR, void_type_node, cookie, nelts);\n+      cookie_expr = build (MODIFY_EXPR, sizetype, cookie, nelts);\n       TREE_SIDE_EFFECTS (cookie_expr) = 1;\n+      rval = build (COMPOUND_EXPR, void_type_node, data_addr, cookie_expr);\n+      data_addr = TREE_OPERAND (data_addr, 0);\n     }\n   else\n-    cookie_expr = NULL_TREE;\n+    data_addr = alloc_node;\n \n   /* Now initialize the allocated object.  */\n-  init_expr = NULL_TREE;\n-  if (TYPE_NEEDS_CONSTRUCTING (type) || init)\n+  if (is_initialized)\n     {\n-      init_expr = build_indirect_ref (alloc_node, NULL);\n+      tree init_expr;\n+\n+      init_expr = build_indirect_ref (data_addr, NULL);\n \n       if (init == void_zero_node)\n \tinit = build_default_init (full_type, nelts);\n@@ -2415,22 +2446,13 @@ build_new_1 (exp)\n \t  tree cleanup;\n \t  int flags = (LOOKUP_NORMAL \n \t\t       | (globally_qualified_p * LOOKUP_GLOBAL));\n-\t  tree delete_node;\n-\n-\t  if (cookie_size)\n-\t    /* Subtract the padding back out to get to the pointer returned\n-\t       from operator new.  */\n-\t    delete_node = fold (build (MINUS_EXPR, TREE_TYPE (alloc_node),\n-\t\t\t\t       alloc_node, cookie_size));\n-\t  else\n-\t    delete_node = alloc_node;\n \n \t  /* The Standard is unclear here, but the right thing to do\n-             is to use the same method for finding deallocation\n-             functions that we use for finding allocation functions.  */\n+\t     is to use the same method for finding deallocation\n+\t     functions that we use for finding allocation functions.  */\n \t  flags |= LOOKUP_SPECULATIVELY;\n \n-\t  cleanup = build_op_delete_call (dcode, delete_node, size, flags,\n+\t  cleanup = build_op_delete_call (dcode, alloc_node, size, flags,\n \t\t\t\t\t  (placement_allocation_fn_p \n \t\t\t\t\t   ? alloc_call : NULL_TREE));\n \n@@ -2480,40 +2502,27 @@ build_new_1 (exp)\n \t\t\t\tend));\n \t    }\n \t}\n-    }\n-  else if (CP_TYPE_CONST_P (true_type))\n-    error (\"uninitialized const in `new' of `%#T'\", true_type);\n-\n-  /* Now build up the return value in reverse order.  */\n \n-  rval = alloc_node;\n+      if (rval)\n+\trval = build (COMPOUND_EXPR, TREE_TYPE (init_expr), rval, init_expr);\n+      else\n+\trval = init_expr;\n+    }\n \n-  if (init_expr)\n-    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), init_expr, rval);\n-  if (cookie_expr)\n-    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), cookie_expr, rval);\n+  rval = build (COMPOUND_EXPR, TREE_TYPE (alloc_node), rval, data_addr);\n \n-  if (rval == alloc_node)\n-    /* If we didn't modify anything, strip the TARGET_EXPR and return the\n-       (adjusted) call.  */\n-    rval = TREE_OPERAND (alloc_expr, 1);\n-  else\n+  if (check_new)\n     {\n-      if (check_new)\n-\t{\n-\t  tree ifexp = cp_build_binary_op (NE_EXPR, alloc_node,\n-\t\t\t\t\t   integer_zero_node);\n-\t  rval = build_conditional_expr (ifexp, rval, alloc_node);\n-\t}\n-\n-      rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n+      tree ifexp = cp_build_binary_op (NE_EXPR, alloc_node, integer_zero_node);\n+      rval = build_conditional_expr (ifexp, rval, alloc_node);\n     }\n \n-  /* Now strip the outer ARRAY_TYPE, so we return a pointer to the first\n-     element.  */\n-  rval = convert (build_pointer_type (type), rval);\n+  /* Perform the allocation before anything else, so that ALLOC_NODE\n+     has been initialized before we start using it.  */\n+  rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n \n-  return rval;\n+  /* Convert to the final type.  */\n+  return build_nop (pointer_type, rval);\n }\n \f\n static tree"}, {"sha": "b7366d617b10b369fe8da942c0e2382aceed7e0f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4610e036e239fb770127439d276439a621e3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4610e036e239fb770127439d276439a621e3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f4f4610e036e239fb770127439d276439a621e3f", "patch": "@@ -1,3 +1,8 @@\n+2003-04-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/10300\n+\t* g++.dg/init/new5.C: New test.\n+\n 2003-04-12  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/7910"}, {"sha": "3a5981e075cae68d684298e9331ef5115ae29458", "filename": "gcc/testsuite/g++.dg/init/new5.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4f4610e036e239fb770127439d276439a621e3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4f4610e036e239fb770127439d276439a621e3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew5.C?ref=f4f4610e036e239fb770127439d276439a621e3f", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do run }\n+\n+#include <new>\n+    \n+void * operator new[](size_t, std::nothrow_t const &) throw()\n+{ return NULL; }\n+\n+struct X {\n+    struct Inner { ~Inner() {} };\n+\n+    X() {\n+      Inner * ic = new (std::nothrow) Inner[1]; // SegFault here\n+    }\n+};\n+\n+int main() {\n+   X table;\n+}"}]}