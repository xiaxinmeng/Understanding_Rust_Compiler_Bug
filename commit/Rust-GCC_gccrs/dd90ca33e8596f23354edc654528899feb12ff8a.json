{"sha": "dd90ca33e8596f23354edc654528899feb12ff8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ5MGNhMzNlODU5NmYyMzM1NGVkYzY1NDUyODg5OWZlYjEyZmY4YQ==", "commit": {"author": {"name": "Fritz Reese", "email": "fritzoreese@gmail.com", "date": "2016-10-25T18:27:51Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2016-10-25T18:27:51Z"}, "message": "Convert logical ops on integers to bitwise equivalent with -fdec.\n\n\tgcc/fortran/\n\t* gfortran.texi: Document.\n\t* resolve.c (logical_to_bitwise): New function.\n\t* resolve.c (resolve_operator): Wrap operands with logical_to_bitwise.\n\n\tgcc/testsuite/gfortran.dg/\n\t* dec_bitwise_ops_1.f90, dec_bitwise_ops_2.f90: New testcases.\n\nFrom-SVN: r241534", "tree": {"sha": "fbdb5797ca5232f6667b955ea9acce9be96c3d3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbdb5797ca5232f6667b955ea9acce9be96c3d3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd90ca33e8596f23354edc654528899feb12ff8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd90ca33e8596f23354edc654528899feb12ff8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd90ca33e8596f23354edc654528899feb12ff8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd90ca33e8596f23354edc654528899feb12ff8a/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2be1b7965039fa6949225f36de3f0b3ad2673fad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be1b7965039fa6949225f36de3f0b3ad2673fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be1b7965039fa6949225f36de3f0b3ad2673fad"}], "stats": {"total": 415, "additions": 415, "deletions": 0}, "files": [{"sha": "f517550c86305712f630e2acb06e860fa0729abb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=dd90ca33e8596f23354edc654528899feb12ff8a", "patch": "@@ -1,3 +1,9 @@\n+2016-10-25  Fritz Reese <fritzoreese@gmail.com>\n+\n+\t* gfortran.texi: Document.\n+\t* resolve.c (logical_to_bitwise): New function.\n+\t* resolve.c (resolve_operator): Wrap operands with logical_to_bitwise.\n+\n 2016-10-25  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/72770"}, {"sha": "0278bd6eef75b9b95604a082cc1511ab365a04f9", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=dd90ca33e8596f23354edc654528899feb12ff8a", "patch": "@@ -1469,6 +1469,7 @@ compatibility extensions along with those enabled by @option{-std=legacy}.\n * TYPE as an alias for PRINT::\n * %LOC as an rvalue::\n * .XOR. operator::\n+* Bitwise logical operators::\n @end menu\n \n @node Old-style kind specifications\n@@ -2567,6 +2568,43 @@ GNU Fortran supports @code{.XOR.} as a logical operator with @code{-std=legacy}\n for compatibility with legacy code. @code{.XOR.} is equivalent to\n @code{.NEQV.}. That is, the output is true if and only if the inputs differ.\n \n+@node Bitwise logical operators\n+@subsection Bitwise logical operators\n+@cindex logical, bitwise\n+\n+With @option{-fdec}, GNU Fortran relaxes the type constraints on\n+logical operators to allow integer operands, and performs the corresponding\n+bitwise operation instead.  This flag is for compatibility only, and should be\n+avoided in new code.  Consider:\n+\n+@smallexample\n+  INTEGER :: i, j\n+  i = z'33'\n+  j = z'cc'\n+  print *, i .AND. j\n+@end smallexample\n+\n+In this example, compiled with @option{-fdec}, GNU Fortran will\n+replace the @code{.AND.} operation with a call to the intrinsic\n+@code{@ref{IAND}} function, yielding the bitwise-and of @code{i} and @code{j}.\n+\n+Note that this conversion will occur if at least one operand is of integral\n+type.  As a result, a logical operand will be converted to an integer when the\n+other operand is an integer in a logical operation.  In this case,\n+@code{.TRUE.} is converted to @code{1} and @code{.FALSE.} to @code{0}.\n+\n+Here is the mapping of logical operator to bitwise intrinsic used with\n+@option{-fdec}:\n+\n+@multitable @columnfractions .25 .25 .5\n+@headitem Operator @tab Intrinsic @tab Bitwise operation\n+@item @code{.NOT.} @tab @code{@ref{NOT}} @tab complement\n+@item @code{.AND.} @tab @code{@ref{IAND}} @tab intersection\n+@item @code{.OR.} @tab @code{@ref{IOR}} @tab union\n+@item @code{.NEQV.} @tab @code{@ref{IEOR}} @tab exclusive or\n+@item @code{.EQV.} @tab @code{@ref{NOT}(@ref{IEOR})} @tab complement of exclusive or\n+@end multitable\n+\n \n @node Extensions not implemented in GNU Fortran\n @section Extensions not implemented in GNU Fortran"}, {"sha": "8cee007af1751fa8facc98f5e53eb9f4d37873d2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=dd90ca33e8596f23354edc654528899feb12ff8a", "patch": "@@ -3522,6 +3522,88 @@ compare_shapes (gfc_expr *op1, gfc_expr *op2)\n   return t;\n }\n \n+/* Convert a logical operator to the corresponding bitwise intrinsic call.\n+   For example A .AND. B becomes IAND(A, B).  */\n+static gfc_expr *\n+logical_to_bitwise (gfc_expr *e)\n+{\n+  gfc_expr *tmp, *op1, *op2;\n+  gfc_isym_id isym;\n+  gfc_actual_arglist *args = NULL;\n+\n+  gcc_assert (e->expr_type == EXPR_OP);\n+\n+  isym = GFC_ISYM_NONE;\n+  op1 = e->value.op.op1;\n+  op2 = e->value.op.op2;\n+\n+  switch (e->value.op.op)\n+    {\n+    case INTRINSIC_NOT:\n+      isym = GFC_ISYM_NOT;\n+      break;\n+    case INTRINSIC_AND:\n+      isym = GFC_ISYM_IAND;\n+      break;\n+    case INTRINSIC_OR:\n+      isym = GFC_ISYM_IOR;\n+      break;\n+    case INTRINSIC_NEQV:\n+      isym = GFC_ISYM_IEOR;\n+      break;\n+    case INTRINSIC_EQV:\n+      /* \"Bitwise eqv\" is just the complement of NEQV === IEOR.\n+\t Change the old expression to NEQV, which will get replaced by IEOR,\n+\t and wrap it in NOT.  */\n+      tmp = gfc_copy_expr (e);\n+      tmp->value.op.op = INTRINSIC_NEQV;\n+      tmp = logical_to_bitwise (tmp);\n+      isym = GFC_ISYM_NOT;\n+      op1 = tmp;\n+      op2 = NULL;\n+      break;\n+    default:\n+      gfc_internal_error (\"logical_to_bitwise(): Bad intrinsic\");\n+    }\n+\n+  /* Inherit the original operation's operands as arguments.  */\n+  args = gfc_get_actual_arglist ();\n+  args->expr = op1;\n+  if (op2)\n+    {\n+      args->next = gfc_get_actual_arglist ();\n+      args->next->expr = op2;\n+    }\n+\n+  /* Convert the expression to a function call.  */\n+  e->expr_type = EXPR_FUNCTION;\n+  e->value.function.actual = args;\n+  e->value.function.isym = gfc_intrinsic_function_by_id (isym);\n+  e->value.function.name = e->value.function.isym->name;\n+  e->value.function.esym = NULL;\n+\n+  /* Make up a pre-resolved function call symtree if we need to.  */\n+  if (!e->symtree || !e->symtree->n.sym)\n+    {\n+      gfc_symbol *sym;\n+      gfc_get_ha_sym_tree (e->value.function.isym->name, &e->symtree);\n+      sym = e->symtree->n.sym;\n+      sym->result = sym;\n+      sym->attr.flavor = FL_PROCEDURE;\n+      sym->attr.function = 1;\n+      sym->attr.elemental = 1;\n+      sym->attr.pure = 1;\n+      sym->attr.referenced = 1;\n+      gfc_intrinsic_symbol (sym);\n+      gfc_commit_symbol (sym);\n+    }\n+\n+  args->name = e->value.function.isym->formal->name;\n+  if (e->value.function.isym->formal->next)\n+    args->next->name = e->value.function.isym->formal->next->name;\n+\n+  return e;\n+}\n \n /* Resolve an operator expression node.  This can involve replacing the\n    operation with a user defined function call.  */\n@@ -3628,13 +3710,36 @@ resolve_operator (gfc_expr *e)\n \t  break;\n \t}\n \n+      /* Logical ops on integers become bitwise ops with -fdec.  */\n+      else if (flag_dec\n+\t       && (op1->ts.type == BT_INTEGER || op2->ts.type == BT_INTEGER))\n+\t{\n+\t  e->ts.type = BT_INTEGER;\n+\t  e->ts.kind = gfc_kind_max (op1, op2);\n+\t  if (op1->ts.type != e->ts.type || op1->ts.kind != e->ts.kind)\n+\t    gfc_convert_type (op1, &e->ts, 1);\n+\t  if (op2->ts.type != e->ts.type || op2->ts.kind != e->ts.kind)\n+\t    gfc_convert_type (op2, &e->ts, 1);\n+\t  e = logical_to_bitwise (e);\n+\t  return resolve_function (e);\n+\t}\n+\n       sprintf (msg, _(\"Operands of logical operator %%<%s%%> at %%L are %s/%s\"),\n \t       gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),\n \t       gfc_typename (&op2->ts));\n \n       goto bad_op;\n \n     case INTRINSIC_NOT:\n+      /* Logical ops on integers become bitwise ops with -fdec.  */\n+      if (flag_dec && op1->ts.type == BT_INTEGER)\n+\t{\n+\t  e->ts.type = BT_INTEGER;\n+\t  e->ts.kind = op1->ts.kind;\n+\t  e = logical_to_bitwise (e);\n+\t  return resolve_function (e);\n+\t}\n+\n       if (op1->ts.type == BT_LOGICAL)\n \t{\n \t  e->ts.type = BT_LOGICAL;"}, {"sha": "decdae89d1b2997cf66b84de1564e63150e37039", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dd90ca33e8596f23354edc654528899feb12ff8a", "patch": "@@ -1,3 +1,8 @@\n+2016-10-25  Fritz Reese <fritzoreese@gmail.com>\n+\n+\t* gfortran.dg/dec_bitwise_ops_1.f90: New test.\n+\t* gfortran.dg/dec_bitwise_ops_2.f90: New test.\n+\n 2016-10-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt59.adb: New test."}, {"sha": "491577cc5537a1f596ed7811910a01f7b997a0cc", "filename": "gcc/testsuite/gfortran.dg/dec_bitwise_ops_1.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_bitwise_ops_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_bitwise_ops_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_bitwise_ops_1.f90?ref=dd90ca33e8596f23354edc654528899feb12ff8a", "patch": "@@ -0,0 +1,106 @@\n+! { dg-do run }\n+! { dg-options \"-fdec\" }\n+!\n+! Runtime tests to verify logical-to-bitwise operations perform as expected\n+! with -fdec.\n+!\n+\n+subroutine assert(expected, actual, str)\n+  implicit none\n+  character(*), intent(in) :: str\n+  integer, intent(in)      :: expected, actual\n+  if (actual .ne. expected) then\n+    write (*, '(A,I4,I4)') str, expected, actual\n+    call abort()\n+  endif\n+end subroutine\n+\n+implicit none\n+\n+integer expected, expected_expr\n+integer output_vars, output_const, output_expr\n+integer op1, op2, mult\n+\n+mult = 3\n+op1 = 3\n+op2 = 5\n+\n+!!!! AND -> IAND\n+\n+expected      = IAND(op1, op2)\n+expected_expr = mult*expected\n+\n+output_const  = 3 .AND. 5\n+output_vars   = op1 .AND. op2\n+output_expr   = mult * (op1 .AND. op2)\n+\n+call assert(expected, output_vars,      \"( ) and\")\n+call assert(expected, output_const,     \"(c) and\")\n+call assert(expected_expr, output_expr, \"(x) and\")\n+\n+!!!! EQV -> NOT IEOR\n+\n+expected   = NOT(IEOR(op1, op2))\n+expected_expr = mult*expected\n+\n+output_const    = 3 .EQV. 5\n+output_vars     = op1 .EQV. op2\n+output_expr     = mult * (op1 .EQV. op2)\n+\n+call assert(expected, output_vars,       \"( ) EQV\")\n+call assert(expected, output_const,      \"(c) EQV\")\n+call assert(expected_expr, output_expr,  \"(x) EQV\")\n+\n+!!!! NEQV -> IEOR\n+\n+expected   = IEOR(op1, op2)\n+expected_expr = mult*expected\n+\n+output_const    = 3 .NEQV. 5\n+output_vars     = op1 .NEQV. op2\n+output_expr     = mult * (op1 .NEQV. op2)\n+\n+call assert(expected, output_vars,       \"( ) NEQV\")\n+call assert(expected, output_const,      \"(c) NEQV\")\n+call assert(expected_expr, output_expr,  \"(x) NEQV\")\n+\n+!!!! NOT -> NOT\n+\n+expected   = NOT(op2)\n+expected_expr = mult*expected\n+\n+output_const    = .NOT. 5\n+output_vars     = .NOT. op2\n+output_expr     = mult * (.NOT. op2)\n+\n+call assert(expected, output_vars,       \"( ) NOT\")\n+call assert(expected, output_const,      \"(c) NOT\")\n+call assert(expected_expr, output_expr,  \"(x) NOT\")\n+\n+!!!! OR -> IOR\n+\n+expected   = IOR(op1, op2)\n+expected_expr = mult*expected\n+\n+output_const    = 3 .OR. 5\n+output_vars     = op1 .OR. op2\n+output_expr     = mult * (op1 .OR. op2)\n+\n+call assert(expected, output_vars,       \"( ) OR\")\n+call assert(expected, output_const,      \"(c) OR\")\n+call assert(expected_expr, output_expr,  \"(x) OR\")\n+\n+!!!! XOR -> IEOR, not to be confused with .XOR.\n+\n+expected  = IEOR(op1, op2)\n+expected_expr = mult*expected\n+\n+output_const    = 3 .XOR. 5\n+output_vars     = op1 .XOR. op2\n+output_expr     = mult * (op1 .XOR. op2)\n+\n+call assert(expected, output_vars,       \"( ) XOR\")\n+call assert(expected, output_const,      \"(c) XOR\")\n+call assert(expected_expr, output_expr,  \"(x) XOR\")\n+\n+end"}, {"sha": "5559a875b35023bc5f4075100c12ccbee007d941", "filename": "gcc/testsuite/gfortran.dg/dec_bitwise_ops_2.f90", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_bitwise_ops_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd90ca33e8596f23354edc654528899feb12ff8a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_bitwise_ops_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdec_bitwise_ops_2.f90?ref=dd90ca33e8596f23354edc654528899feb12ff8a", "patch": "@@ -0,0 +1,155 @@\n+! { dg-do run }\n+! { dg-options \"-fdec\" }\n+!\n+! Runtime tests to verify bitwise ops perform appropriate conversions\n+! with -fdec.\n+!\n+\n+subroutine assert(expected, actual, str)\n+  implicit none\n+  character(*), intent(in) :: str\n+  integer, intent(in)      :: expected, actual(9)\n+  integer :: i\n+  do i=1,9\n+    if (expected .ne. actual(i)) then\n+      write (*, '(A,I8,I8)') str, expected, actual(i)\n+      call abort()\n+    endif\n+  enddo\n+end subroutine\n+\n+implicit none\n+\n+logical(1), volatile :: op1_1l\n+integer(1), volatile :: op1_1, op2_1\n+\n+logical(2), volatile :: op1_2l\n+integer(2), volatile :: op1_2, op2_2\n+\n+logical(4), volatile :: op1_4l\n+integer(4), volatile :: op1_4, op2_4\n+\n+integer, volatile :: expect, outs(9)\n+\n+\n+op1_1l = .true.\n+op1_2l = .true.\n+op1_4l = .true.\n+op1_1 = 117_1\n+op1_2 = 117_2\n+op1_4 = 117_4\n+op2_1 =  49_1\n+op2_2 =  49_2\n+op2_4 =  49_4\n+\n+!!! Explicit integer operands\n+\n+expect = IAND(op1_1, op2_1)\n+outs(1) = op1_1 .AND. op2_1\n+outs(2) = op1_1 .AND. op2_2\n+outs(3) = op1_1 .AND. op2_4\n+outs(4) = op1_2 .AND. op2_1\n+outs(5) = op1_2 .AND. op2_2\n+outs(6) = op1_2 .AND. op2_4\n+outs(7) = op1_4 .AND. op2_1\n+outs(8) = op1_4 .AND. op2_2\n+outs(9) = op1_4 .AND. op2_4\n+call assert(expect, outs, \"AND\")\n+\n+expect = IOR(op1_1, op2_1)\n+outs(1) = op1_1 .OR. op2_1\n+outs(2) = op1_1 .OR. op2_2\n+outs(3) = op1_1 .OR. op2_4\n+outs(4) = op1_2 .OR. op2_1\n+outs(5) = op1_2 .OR. op2_2\n+outs(6) = op1_2 .OR. op2_4\n+outs(7) = op1_4 .OR. op2_1\n+outs(8) = op1_4 .OR. op2_2\n+outs(9) = op1_4 .OR. op2_4\n+\n+call assert(expect, outs, \"OR\")\n+\n+expect = NOT(IEOR(op1_1, op2_1))\n+outs(1) = op1_1 .EQV. op2_1\n+outs(2) = op1_1 .EQV. op2_2\n+outs(3) = op1_1 .EQV. op2_4\n+outs(4) = op1_2 .EQV. op2_1\n+outs(5) = op1_2 .EQV. op2_2\n+outs(6) = op1_2 .EQV. op2_4\n+outs(7) = op1_4 .EQV. op2_1\n+outs(8) = op1_4 .EQV. op2_2\n+outs(9) = op1_4 .EQV. op2_4\n+\n+call assert(expect, outs, \"EQV\")\n+\n+expect = IEOR(op1_1, op2_1)\n+outs(1) = op1_1 .NEQV. op2_1\n+outs(2) = op1_1 .NEQV. op2_2\n+outs(3) = op1_1 .NEQV. op2_4\n+outs(4) = op1_2 .NEQV. op2_1\n+outs(5) = op1_2 .NEQV. op2_2\n+outs(6) = op1_2 .NEQV. op2_4\n+outs(7) = op1_4 .NEQV. op2_1\n+outs(8) = op1_4 .NEQV. op2_2\n+outs(9) = op1_4 .NEQV. op2_4\n+\n+call assert(expect, outs, \"NEQV\")\n+\n+!!! Logical -> Integer operand conversions\n+op1_1 = op1_1l\n+op1_2 = op1_2l\n+op1_4 = op1_4l\n+\n+expect = IAND(op1_1, op2_1)\n+outs(1) = op1_1l .AND. op2_1 ! implicit conversions\n+outs(2) = op1_1l .AND. op2_2\n+outs(3) = op1_1l .AND. op2_4\n+outs(4) = op1_2l .AND. op2_1\n+outs(5) = op1_2l .AND. op2_2\n+outs(6) = op1_2l .AND. op2_4\n+outs(7) = op1_4l .AND. op2_1\n+outs(8) = op1_4l .AND. op2_2\n+outs(9) = op1_4l .AND. op2_4\n+call assert(expect, outs, \"AND\")\n+\n+expect = IOR(op1_1, op2_1)\n+outs(1) = op1_1l .OR. op2_1 ! implicit conversions\n+outs(2) = op1_1l .OR. op2_2\n+outs(3) = op1_1l .OR. op2_4\n+outs(4) = op1_2l .OR. op2_1\n+outs(5) = op1_2l .OR. op2_2\n+outs(6) = op1_2l .OR. op2_4\n+outs(7) = op1_4l .OR. op2_1\n+outs(8) = op1_4l .OR. op2_2\n+outs(9) = op1_4l .OR. op2_4\n+\n+call assert(expect, outs, \"OR\")\n+\n+expect = NOT(IEOR(op1_1, op2_1))\n+outs(1) = op1_1l .EQV. op2_1 ! implicit conversions\n+outs(2) = op1_1l .EQV. op2_2\n+outs(3) = op1_1l .EQV. op2_4\n+outs(4) = op1_2l .EQV. op2_1\n+outs(5) = op1_2l .EQV. op2_2\n+outs(6) = op1_2l .EQV. op2_4\n+outs(7) = op1_4l .EQV. op2_1\n+outs(8) = op1_4l .EQV. op2_2\n+outs(9) = op1_4l .EQV. op2_4\n+\n+call assert(expect, outs, \"EQV\")\n+\n+expect = IEOR(op1_1, op2_1)\n+outs(1) = op1_1l .NEQV. op2_1 ! implicit conversions\n+outs(2) = op1_1l .NEQV. op2_2\n+outs(3) = op1_1l .NEQV. op2_4\n+outs(4) = op1_2l .NEQV. op2_1\n+outs(5) = op1_2l .NEQV. op2_2\n+outs(6) = op1_2l .NEQV. op2_4\n+outs(7) = op1_4l .NEQV. op2_1\n+outs(8) = op1_4l .NEQV. op2_2\n+outs(9) = op1_4l .NEQV. op2_4\n+\n+call assert(expect, outs, \"NEQV\")\n+\n+\n+end"}]}