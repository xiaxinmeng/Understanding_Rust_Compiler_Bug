{"sha": "db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI1YWU0M2ZmMmNlNDlmMWNiZTY2YTBlMTZmNGUwNzliNzAyNTgwYg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-11-29T00:59:16Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-11-29T00:59:16Z"}, "message": "49th Cygnus<->FSF merge\n\nFrom-SVN: r8570", "tree": {"sha": "572fd369f71d068ba440682b16fe5848cd15d1cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/572fd369f71d068ba440682b16fe5848cd15d1cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/comments", "author": null, "committer": null, "parents": [{"sha": "c7a7ac465ec752e3c21494ff810e95e851f36ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a7ac465ec752e3c21494ff810e95e851f36ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a7ac465ec752e3c21494ff810e95e851f36ac3"}], "stats": {"total": 2770, "additions": 1795, "deletions": 975}, "files": [{"sha": "a5372a58547e742b461b219dbbdbb99fd3bc9e3c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 426, "deletions": 70, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -1,3 +1,8 @@\n+Mon Nov 28 16:44:41 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* Makefile.in: Make is easier to decide where parse.[ch] will be\n+\tbuilt.\n+\n Thu Nov 17 20:11:24 1994  Doug Evans  <dje@cygnus.com>\n \n \t* cp/Make-lang.in (CXX_INSTALL_NAME) Use program_transform_name.\n@@ -12,33 +17,236 @@ Thu Nov  3 18:48:19 1994  Paul Eggert  <eggert@twinsun.com>\n \t* Makefile.in (spew.o, lex.o, pt.o):\n \tDepend on $(srcdir)/parse.h, not parse.h.\n \n-Sat Oct 29 07:18:52 1994  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)\n+Mon Nov 28 13:53:03 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (THROW): Fix precedence of throw expressions.\n+\n+Mon Nov 28 13:15:16 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_unary_op): Allow promotions from bool to int on\n+\tunary ~.\n+\n+Sun Nov 27 00:16:21 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* method.c (build_overload_name): Use DECL_ASSEMBLER_NAME for\n+\tclasses when appropriate.\n+\t(build_overload_nested_name): When dealing with a function context,\n+\tuse ASM_FORMAT_PRIVATE_NAME to tweak the name of the function to\n+\tavoid conflicts between local classes of the same name.\n+\n+Wed Nov 23 17:59:42 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gxx.gperf, parse.y, lex.h, hash.h, lex.c (init_lex), delc.c\n+\t(duplicate_decls, grokdeclarator), cp-tree.h: Add support for\n+\t`explicit'.\n+\t* cvt.c (convert_to_reference, cp_convert, build_type_conversion_1,\n+\tbuild_type_conversion): Use LOOKUP_ONLYCONVERTING in\n+\tbuild_method_calls so that non-converting constructors are not used.\n+\t* call.c (build_method_call): If we shouldn't use a non-converting\n+\tconstructor, then don't.\n+\n+Wed Nov 23 14:46:56 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (build_method_call): Don't try to synthesize methods yet.\n+\n+Tue Nov 22 12:45:21 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (push_template_decls): Create CONST_DECLs for template\n+\tconstant parameters, not VAR_DECLs.\n+\n+Sat Nov 19 15:28:31 1994  Jim Wilson  (wilson@chestnut.cygnus.com)\n+\n+\t* typeck.c (build_binary_op_nodefault): Can shorten shift only if\n+\tshift count is less than size in bits of arg0.\n+\n+Thu Nov 17 15:30:50 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gxx.gperf, hash.h, lex.c (init_lex, real_yylex), parse.y: Add new\n+\tANSI keywords and, and_eq, bitand, bitor, explicit, namespace, not,\n+\tnot_eq, or, or_eq, typename, using, xor, xor_eq to g++.  Still need\n+\tto add support for explicit, namespace, typename, and using, support\n+\tfor the rest is already in.\n+\n+Thu Nov 17 10:56:50 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck2.c (build_m_component_ref): Check the basetype of the\n+\tmember pointer against the main variant of the object type.\n+\n+Mon Nov 14 14:21:52 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (convert_to_reference): Make sure that the original expr\n+\tgets its type back when converting a reference.\n+\n+\t* method.c (build_overload_name): Clear numeric_outputed_need_bar here.\n+\t(build_decl_overload): Instead of here.\n+\n+Tue Nov  8 17:11:24 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (cp_convert): Don't build a TARGET_EXPR if we're not in a\n+\tfunction.\n+\n+\t* typeck.c (convert_for_initialization): Handle initialization from\n+\ta TARGET_EXPR.\n+\n+Sun Nov  6 01:34:24 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\t* pt.c (lookup_nested_type_by_name): Fix list-walking logic.\n+\t(tsubst): When replacing a TEMPLATE_TYPE_PARM, propagate\n+\tTYPE_READONLY and TYPE_VOLATILE from the argument.\n+\t(unify): When unifying with a TEMPLATE_TYPE_PARM, remove cv-quals\n+\tpresent in parm from arg.\n+\t(type_unification): Strip REFERENCE_TYPE from the argument type.\n+\t(unify): Don't strip REFERENCE_TYPE from the argument type.\n+\n+Sat Nov  5 22:42:15 1994  Greg McGary  (gkm@magilla.cichlid.com)\n+\n+\t* pt.c (do_type_instantiation): Check to see if there's a\n+\tIDENTIFIER_TEMPLATE on a class before calling\n+\tinstantiate_member_templates().\n+\n+Fri Nov  4 19:04:18 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (get_bad_cast_node): New routine to support compile time\n+\tthrows of bad_cast.\n+\t* gc.c (build_dynamic_cast): Support throwing of bad_cast at compile\n+\ttime.\n+\n+Fri Nov  4 11:12:00 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c: Add hppa support.\n+\n+Fri Nov  4 10:50:50 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c: Add rs6000 support.\n+\n+Thu Nov  3 14:24:23 1994  Mike Stump  <mrs@cygnus.com>\n \n-\t* g++.c (main): Cast arg to bzero to avoid warning.\n+\t* except.c (do_unwind): Add i[34]86 support.\n+\n+Thu Nov  3 00:10:46 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\t* pt.c (do_pending_expansions): Unset TREE_PUBLIC on implicit\n+\tinstantiations.\n+\n+Wed Nov  2 15:08:24 1994  Kung Hsu  (kung@mexican.cygnus.com)\n+\n+\t* decl.c (finish_function): emit types used in method parameters\n+\tinto symbol table.\n+\n+Wed Nov  2 15:05:47 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\t* pt.c (process_template_parm): Allow pointer to member function\n+\ttemplate parameter types.\n+\t(uses_template_parms): Handle pointer to member function\n+\tCONSTRUCTORs.\n+\n+\t* g++.c (main): Cast first argument of bzero to (char *).\n+\tPass -lstdc++ instead of -lg++ unless we are invoked as 'g++'.\n+\n+Mon Oct 31 14:50:48 1994  Kung Hsu  (kung@mexican.cygnus.com)\n+\n+\t* gc.c (build_dynamic_cast): rewrite to make it work.\n+\t* class.c (finish_vtbls): build more vtables if flag_rtti is on.\n+\t* class.c (modify_all_direct_vtables): ditto.\n+\t* init.c (expand_direct_vtbls_init): expand more vtables if\n+\tflag_rtti is on.\n+\t* decl.c (init_type_desc): add default return.\n+\n+Tue Oct 25 17:13:09 1994  Kung Hsu  (kung@mexican.cygnus.com)\n+\n+\t* tree.c (debug_binfo): get rid of the initial size entry of\n+\tvtable.\n+\t* cp-tree.h: change flag_dossier to flag rtti, define type\n+\tdescriptor type nodes.\n+\t* decl.c (init_type_desc): new function to initialize type\n+\tdescriptor type nodes.\n+\t* decl.c (record_builtin_type): change flag_dossier to flag_rtti.\n+\t* lex.c (init_lex): ditto.\n+\t* decl.c : change variable flag_dossier to flag_rtti.\n+\t* decl.c (duplicate_decls): get rid initial size entry of vtable.\n+\t* decl.c (hack_incomplete_structures): take out assert 164.\n+\t* search.c (get_abstract_virtuals_1): ditto.\n+\t* search.c (dfs_init_vbase_pointers): change CLASSTYPE_DOSSIER to\n+\tCLASSTYPE_RTTI.\n+\t* parse.y: ditto.\n+\t* class.c (prepare_fresh_vtable): for virtual bases, get right\n+\toffset.\n+\t* class.c (add_virtual_function): change flag_dossier to\n+\tflag_rtti.\n+\t* class.c (modify_one_vtable): modify the right rtti entry.\n+\t* class.c (override_one_vtable): get rid of size entry.\n+\t* class.c (finish_struct): change flag_dossier to flag_rtti, and\n+\tbuild extra vtables, build type descriptors for polymorphic\n+\tclasses.\n+\t* gc.c (build_headof): make headof() works correctly with new\n+\trtti.\n+\t* gc.c (build_typeid): make this function work with new rtti.\n+\t* gc.c (get_typeid): make this function work with new rtti.\n+\t* gc.c (build_bltn_desc): new function for new rtti.\n+\t* gc.c (build_user_desc): ditto.\n+\t* gc.c (build_class_desc): ditto.\n+\t* gc.c (build_ptr_desc): ditto.\n+\t* gc.c (build_attr_desc): ditto.\n+\t* gc.c (build_func_desc): ditto.\n+\t* gc.c (build_ptmf_desc): ditto.\n+\t* gc.c (build_ptmd_desc): ditto.\n+\t* gc.c (build_t_desc): ditto.\n+\t* gc.c : comment out old build_t_desc, build_i_desc, build_m_desc.\n+\n+Tue Oct 25 13:37:41 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\t* call.c (convert_harshness): Check for TREE_UNSIGNED differences\n+\tafter checking for integral conversions.\n \n Sun Oct 23 13:19:55 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * decl2.c: Declare flag_access_control.\n-        (struct lang_f_options): Add access-control.\n-        * expr.c (cplus_expand_expr, NEW_EXPR): Unset flag_access_control\n-        for the call to expand_aggr_init to copy the object out of the\n-        pcc_struct_return slot.\n-        * search.c (compute_access): if (!flag_access_control) return\n-        access_public.\n+\t* decl2.c: Declare flag_access_control.\n+\t(struct lang_f_options): Add access-control.\n+\t* expr.c (cplus_expand_expr, NEW_EXPR): Unset flag_access_control\n+\tfor the call to expand_aggr_init to copy the object out of the\n+\tpcc_struct_return slot.\n+\t* search.c (compute_access): if (!flag_access_control) return\n+\taccess_public.\n \n Fri Oct 21 00:32:54 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * decl.c (init_decl_processing): Use __pure_virtual for abort_fndecl\n-        instead of abort, since the OSF/1 dynamic linker doesn't like to see\n-        relocation entries for abort.\n+\t* lex.c (cons_up_default_function): Don't try to defer method\n+\tsynthesis now.\n+\n+\t* decl.c (init_decl_processing): Use __pure_virtual for abort_fndecl\n+\tinstead of abort, since the OSF/1 dynamic linker doesn't like to see\n+\trelocation entries for abort.\n+\n+\t* tree.c (array_type_nelts_total): Use sizetype, not\n+\tinteger_type_node.\n+\t(array_type_nelts_top): Ditto.\n \n-        * tree.c (array_type_nelts_total): Use sizetype, not\n-        integer_type_node.\n-        (array_type_nelts_top): Ditto.\n+Thu Oct 20 15:48:27 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Added handling for catch parameters\n+\t(CATCHPARM).\n+\t* except.c (expand_start_catch_block): Use the new CATCHPARM context\n+\tinstead of NORMAL.\n+\t* except.c (expand_throw): Don't let convert_to_reference complain\n+\tabout what we are doing.\n+\n+Thu Oct 20 12:55:24 1994  Jim Wilson  (wilson@cygnus.com)\n+\n+\t* method.c (emit_thunk): Call instantiate_virtual_regs.\n+\n+Wed Oct 19 14:15:33 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_exception_blocks): Make sure throw code doesn't\n+\tget put in function that won't be output.\n \n Mon Oct 17 18:03:15 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * decl.c (init_decl_processing): Make alloca a builtin.\n+\t* decl.c (init_decl_processing): Make alloca a builtin.\n+\n+Thu Oct 27 21:10:25 1994  Craig Burley  (craig@burley)\n+\n+\t* g++.c (main): Only decrement \"added\" and set \"library\" to\n+\tNULL when \"library\" != NULL (just like 940829 fix).\n \n Mon Oct 17 15:56:11 1994  Mike Stump  <mrs@cygnus.com>\n \n@@ -51,47 +259,74 @@ Fri Oct 14 18:54:48 1994  Mike Stump  <mrs@cygnus.com>\n \t* class.c (modify_one_vtable): Since the DECL_CONTEXT of fndecl can\n \tbe set just below, use current_fndecl instead.\n \n+Fri Oct 14 15:12:22 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\t* init.c (expand_aggr_vbase_init_1): Don't call expand_aggr_init_1\n+\twith LOOKUP_SPECULATIVELY.\n+\t(expand_default_init): Abort if build_method_call returns NULL_TREE.\n+\n+\t* typeck.c (build_modify_expr): Don't just build a MODIFY_EXPR if\n+\tthe rhs is a TARGET_EXPR.\n+\n+\t* parse.y (left_curly): Anonymous types are not affected by #pragma\n+\tinterface/implementation.\n+\n+\t* method.c (synthesize_method): Don't call setup_vtbl_ptr for the\n+\tdefault constructor if it isn't needed.\n+\n+\t* lex.c (cons_up_default_function): Do synthesize methods for\n+\tanonymous types if necessary.\n+\n Thu Oct 13 17:44:55 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * method.c (build_decl_overload): Set numeric_outputed_need_bar to 0.\n+\t* method.c (build_decl_overload): Set numeric_outputed_need_bar to 0.\n \n Wed Oct 12 13:27:57 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * lex.c (real_yylex): Use HOST_BITS_PER_WIDE_INT to determine the\n-        bitmask for lexing character constants.\n+\t* typeck.c (build_modify_expr): Understand how to copy an aggregate.\n+\n+\t* init.c (expand_default_init): Ditto.  Also remove some of the\n+\tcrufty code that assumes methods will not be synthesized properly.\n+\n+\t* lex.c (cons_up_default_function): If the containing type has no\n+\tname, these functions should never need to be called, so just\n+\tdeclare them.\n \n-        * call.c (build_method_call): Disable code that tries to do tricky\n-        stuff with a default parameter that is a constructor call, but\n-        actually does other tricky stuff that breaks things.\n+\t* lex.c (real_yylex): Use HOST_BITS_PER_WIDE_INT to determine the\n+\tbitmask for lexing character constants.\n+\n+\t* call.c (build_method_call): Disable code that tries to do tricky\n+\tstuff with a default parameter that is a constructor call, but\n+\tactually does other tricky stuff that breaks things.\n \n Wed Oct 12 16:14:01 1994  Benoit Belley  <belley@cae.ca>\n \n-        * decl.c (finish_enum): Disable code which forces enums to be signed,\n-        since this conflicts with their use as bitfields. type_promotes_to\n-        handles promotion of enums of underlying unsigned types to signed\n-        integer types.\n+\t* decl.c (finish_enum): Disable code which forces enums to be signed,\n+\tsince this conflicts with their use as bitfields. type_promotes_to\n+\thandles promotion of enums of underlying unsigned types to signed\n+\tinteger types.\n \n Wed Oct 12 13:24:03 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * cvt.c (type_promotes_to): Also promote enums to long if\n-        appropriate.\n+\t* cvt.c (type_promotes_to): Also promote enums to long if\n+\tappropriate.\n \n-        * typeck.c (default_conversion): Don't expect type_promotes_to to\n-        return a main variant.\n+\t* typeck.c (default_conversion): Don't expect type_promotes_to to\n+\treturn a main variant.\n \n Wed Oct 12 12:19:45 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * call.c (build_scoped_method_call): Don't lose side effects in the\n-        object expression when calling a non-existent destructor.\n+\t* call.c (build_scoped_method_call): Don't lose side effects in the\n+\tobject expression when calling a non-existent destructor.\n \n Fri Sep  2 19:05:21 1994  Rohan Lenard  (rjl@iassf.easams.com.au)\n \n-        * call.c (build_scoped_method_call): Remove erroneous error message\n-        when destructor call is written as a scoped call.\n+\t* call.c (build_scoped_method_call): Remove erroneous error message\n+\twhen destructor call is written as a scoped call.\n \n Tue Oct 11 23:48:31 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n-  \n-        * various: Cast pointer arguments to bzero and bcopy to char *.\n+\n+\t* various: Cast pointer arguments to bzero and bcopy to char *.\n \n Tue Oct 11 19:34:32 1994  Mike Stump  <mrs@cygnus.com>\n \n@@ -101,61 +336,172 @@ Tue Oct 11 19:34:32 1994  Mike Stump  <mrs@cygnus.com>\n \toffset to put into the vtable for the this parameter, make sure we\n \tdon't offset from a parent of the DECL_CONTEXT of the function.\n \n+Tue Oct 11 16:10:52 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\t* pt.c (do_function_instantiation): Set DECL_EXTERNAL and\n+\tTREE_STATIC when setting DECL_INTERFACE_KNOWN.\n+\t(do_type_instantiation): Ditto.\n+\n+\t* lex.c (cons_up_default_function): Set DECL_INTERFACE_KNOWN,\n+\tDECL_EXTERNAL and TREE_STATIC as appropriate.\n+\n+\t* decl2.c (finish_file): Also synthesize methods that don't have\n+\tDECL_EXTERNAL set.  Set interface_unknown before doing so.\n+\n+\t* decl.c (start_function): If DECL_INTERFACE_KNOWN is set on the\n+\tfunction decl, don't muck with TREE_PUBLIC and DECL_EXTERNAL.\n+\n Mon Oct 10 00:56:53 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * lex.c (cons_up_default_function): Mark methods in a template class\n-        as template instances.  Store the values of interface_unknown and\n-        interface_only for do_pending_inlines.\n-        (do_pending_inlines): Use them.\n+\t* lex.c (cons_up_default_function): Mark methods in a template class\n+\tas template instances.  Store the values of interface_unknown and\n+\tinterface_only for do_pending_inlines.\n+\t(do_pending_inlines): Use them.\n+\n+\t* decl2.c (finish_file): If we haven't seen a definition of a\n+\tfunction declared static, make the decl non-PUBLIC so compile_file\n+\tcan give an error.\n \n Sun Oct  9 02:42:29 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * method.c (do_build_copy_constructor): Handle anonymous unions.\n-        (do_build_assign_ref): Ditto.\n-        (largest_union_member): Move from lex.c.\n+\t* method.c (do_build_copy_constructor): Handle anonymous unions.\n+\t(do_build_assign_ref): Ditto.\n+\t(largest_union_member): Move from lex.c.\n+\n+Sat Oct  8 14:59:43 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\tRe-implement g++'s vague linkage independent of TREE_PUBLIC.\n+\t* pt.c (instantiate_member_templates): Lose redundant\n+\t-fexternal-templates handling.\n+\t(tsubst): Set TREE_PUBLIC and DECL_EXTERNAL on new decls.  Don't set\n+\tTREE_STATIC or DECL_INTERFACE_KNOWN.\n+\t(do_pending_expansions): Predicate on DECL_INTERFACE_KNOWN instead\n+\tof DECL_EXTERNAL for explicit instantiations.\n+\t(do_function_instantiation): Do the new thing.\n+\t(do_type_instantiation): Ditto.\n+\t(instantiate_template): Deal with member templates defined in a .cc\n+\tfile with -fexternal-templates.\n+\t* except.c (expand_exception_blocks): Use DECL_LINKAGE_KNOWN to\n+\tdecide whether to stick builtin_throw here.\n+\t* decl2.c (import_export_inline): Predicate on DECL_INTERFACE_KNOWN\n+\trather than TREE_PUBLIC.  Generally fix rules.\n+\t(finish_file): Use DECL_INITIAL to determine whether or not a method\n+\thas been synthesized, rather than TREE_ASM_WRITTEN.\n+\t* decl.c (warn_extern_redeclared_static): Use DECL_PUBLIC instead of\n+\tTREE_PUBLIC.\n+\t(pushdecl): Ditto.\n+\t(duplicate_decls): Ditto.  Deal with DECL_DECLARED_STATIC and\n+\tDECL_INTERFACE_KNOWN. \n+\t(redeclaration_error_message): Fix checking for conflicting linkage.\n+\t(define_function): Set DECL_INTERFACE_KNOWN.\n+\t(grokfndecl): Function decls are PUBLIC until we are sure about\n+\ttheir linkage.  Set DECL_DECLARED_STATIC as needed.\n+\t(start_function): Deal with linkage.  Move pushdecl after linkage\n+\tmagic.\n+\t(finish_function): Don't set TREE_ASM_WRITTEN on discarded inlines.\n+\t* cp-tree.h (lang_decl_flags): Add interface_known and\n+\tdeclared_static.\n+\t(DECL_INTERFACE_KNOWN): New macro.\n+\t(DECL_DECLARED_STATIC): New macro.\n+\t(DECL_PUBLIC): New macro.\n+\n+\tClean up bogus use of TREE_PUBLIC.\n+\t* class.c (alter_access): Fix mistaken use of TREE_PUBLIC (it\n+\tdoesn't correspond to TREE_PROTECTED and TREE_PRIVATE).\n+\t* init.c (do_friend): Don't arbitrarily set TREE_PUBLIC.\n \n Wed Oct  5 13:44:41 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * call.c (build_overload_call_real): Don't immediately do\n-        array->pointer conversion.\n+\t* call.c (build_overload_call_real): Don't immediately do\n+\tarray->pointer conversion.\n \n-        * pt.c (type_unification): If not passing to a reference, strip\n-        cv-quals.  Also handle array->pointer conversion.\n+\t* pt.c (type_unification): If not passing to a reference, strip\n+\tcv-quals.  Also handle array->pointer conversion.\n \n Tue Oct  4 17:45:37 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * decl.c (grokdeclarator): Don't warn about applying const to a\n-        const typedef or template type parameter.\n+\t* decl.c (grokdeclarator): Don't warn about applying const to a\n+\tconst typedef or template type parameter.\n+\n+\t* decl2.c (finish_file): Also synthesize methods after walking the\n+\tvtables.  Ugly ugly ugly.\n \n Mon Oct  3 15:02:41 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * decl.c (shadow_tag): Remove obsolete code for pushing tags and\n-        dealing with exceptions.\n+\t* various: Remove lingering remnants of old exception handling code.\n+\n+\t* decl2.c (finish_file): Synthesize methods before walking the\n+\tvtables, so that the vtables get emitted as needed.\n+\n+\t* decl.c (shadow_tag): Remove obsolete code for pushing tags and\n+\tdealing with exceptions.\n+\n+Mon Oct  3 13:05:27 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>\n+\n+\t* Make-lang.in (g++-cross): Depend upon version.o and $(LIBDEPS).\n+\n+Mon Oct  3 02:59:28 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\t* decl2.c (finish_file): Fix inline handling.\n \n Sun Oct  2 00:21:56 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n \n-        * parse.y (expr_or_declarator): Add '(' expr_or_declarator ')' rule.\n-        (direct_notype_declarator): Ditto.\n-        (complex_direct_notype_declarator): Remove it here.\n+\t* decl.c (grokdeclarator): Handle redundant scope even better.\n+\t({push,pop}_cp_function_context): Take toplev parameter.\n \n-Sat Oct  1 21:42:18 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\t* method.c (synthesize_method): Pass toplev parameter to\n+\t{push,pop}_cp_function_context depending on decl_function_context\n+\t(fndecl).\n \n-        * init.c (resolve_offset_ref): Fix types used in resolving .*\n-        expressions.\n+\t* typeck.c (build_x_unary_op): Unary & on OFFSET_REFs is always the\n+\tbuilt-in version.\n \n-Thu Sep 29 16:15:36 1994  Michael I Bushnell  <mib@churchy.gnu.ai.mit.edu>\n+\t* method.c (synthesize_method): Don't be confused by __in_chrg\n+\tparameter.\n \n-\t* g++.c: Rework last change so it's done like collect.c (and \n-\tgcc.c).\n+\t* class.c (popclass): Set C_C_D like start_function does.\n \n-Wed Sep 28 19:19:01 1994  Brendan Kehoe  (brendan@mole.gnu.ai.mit.edu)\n+\t* decl.c (grokdeclarator): Handle redundant scope better.\n \n-\t* except.c (register_exception_table): Use Pmode, not PTRmode.\n+\t* parse.y (expr_or_declarator): Add '(' expr_or_declarator ')' rule.\n+\t(direct_notype_declarator): Ditto.\n+\t(complex_direct_notype_declarator): Remove it here.\n \n-Wed Sep 14 10:17:27 1994  Michael I Bushnell  <mib@churchy.gnu.ai.mit.edu>\n+Sat Oct  1 21:42:18 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n-\t* g++.c: Include <sys/errno.h> in case `errno' is a macro\n-\tas permitted by ANSI C.\n+\t* init.c (resolve_offset_ref): Fix types used in resolving .*\n+\texpressions.\n+\n+Sat Oct  1 15:18:49 1994  Jason Merrill  (jason@phydeaux.cygnus.com)\n+\n+\tBeginnings of work to synthesize methods only when needed.\n+\t* call.c (build_method_call): Synthesize methods as necessary\n+\t(currently never necessary).\n+\t* class.c (popclass): Don't try to set C_C_D here, as it'll end up\n+\ton the wrong obstack.\n+\t* decl.c (push_cp_function_context): Mostly copied from\n+\tpush_c_function_context.\n+\t(pop_cp_function_context): Similarly.\n+\t(finish_function): Reverse order of poplevel and pop_nested_class so\n+\tthat current_class_decl is restored properly.  \n+\t(start_function): Ditto.\n+\t(finish_function): Add parameter 'nested'.  Don't call\n+\tpermanent_allocation if (nested).\n+\t* various: Pass extra parameter to finish_function.\t\n+\t* decl2.c (finish_file): Reorganize end-of-file inline handling,\n+\tsynthesizing methods as necessary.\n+\t* lex.c (cons_up_default_function): Call mark_inline_for_output.\n+\tOnly synthesize methods immediately if #pragma implementation\n+\t(currently disabled).\n+\t(do_pending_inlines): Call synthesize_method.\n+\t* method.c (synthesize_method): New function; all method synthesis\n+\tgoes through here.  Calls do_build_assign_ref and\n+\tdo_build_copy_constructor.\n+\t(build_default_constructor): Remove.\n+\t(build_dtor): Ditto.\n+\t(build_assign_ref): Rename to do_build_assign_ref and remove stuff\n+\tdone by synthesize_method.\n+\t(build_copy_constructor): Similarly.\n \n Thu Sep 29 16:58:52 1994  Mike Stump  <mrs@cygnus.com>\n \n@@ -282,12 +628,12 @@ Sun Sep 18 10:12:12 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* *.c: Use cp_build_type_variant instead of c_build_type_variant.\n \n \t* pt.c (do_type_instantiation): Don't try to instantiate nested\n-        enums.\n+\tenums.\n \n Tue Sep 13 10:56:58 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* cvt.c (build_up_reference): Handle preincrement and predecrement\n-        properly.\n+\tproperly.\n \n Tue Sep 13 09:51:59 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \n@@ -466,7 +812,7 @@ Sun Aug 21 23:07:35 1994  Gerald Baumgartner  (gb@cs.purdue.edu)\n \t* class.c (finish_struct): Move setting of CLASSTYPE_INTERFACE and\n \tCLASSTYPE_VTABLE_NEEDS_WRITING for signatures up to left_curly time.\n \t* decl.c (xref_tag): Move setting of CLASSTYPE_INTERFACE and\n-        CLASSTYPE_VTABLE_NEEDS_WRITING for signatures down to left_curly time.\n+\tCLASSTYPE_VTABLE_NEEDS_WRITING for signatures down to left_curly time.\n \t* parse.y (left_curly): New final resting place for setting\n \tCLASSTYPE_INTERFACE and CLASSTYPE_VTABLE_NEEDS_WRITING for signatures.\n \n@@ -486,12 +832,22 @@ Thu Aug 18 16:24:43 1994  Mike Stump  (mrs@cygnus.com)\n \n \t* error.c (dump_decl): Handle NULL args.\n \n+Thu Sep 29 16:15:36 1994  Michael I Bushnell  <mib@churchy.gnu.ai.mit.edu>\n+\n+\t* g++.c: Rework last change so it's done like collect.c (and \n+\tgcc.c).\n+\n+Wed Sep 14 10:17:27 1994  Michael I Bushnell  <mib@churchy.gnu.ai.mit.edu>\n+\n+\t* g++.c: Include <sys/errno.h> in case `errno' is a macro\n+\tas permitted by ANSI C.\n+\n Thu Aug 18 12:48:09 1994  Mike Stump  (mrs@cygnus.com)\n \n \t* class.c (finish_struct): Move setting of CLASSTYPE_INTERFACE and\n \tCLASSTYPE_VTABLE_NEEDS_WRITING up to left_curly time.\n \t* decl.c (xref_tag): Move setting of CLASSTYPE_INTERFACE and\n-        CLASSTYPE_VTABLE_NEEDS_WRITING down to left_curly time.\n+\tCLASSTYPE_VTABLE_NEEDS_WRITING down to left_curly time.\n \t* parse.y (left_curly): New final resting place for setting\n \tCLASSTYPE_INTERFACE and CLASSTYPE_VTABLE_NEEDS_WRITING.\n \n@@ -851,7 +1207,7 @@ Fri Jul  8 12:59:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* method.c (hack_identifier): Fix for new overloading.\n \n \t* typeck.c (build_binary_op_nodefault): Don't mess with division by\n-        zero.\n+\tzero.\n \n Fri Jul  8 13:20:28 1994  Gerald Baumgartner  (gb@cs.purdue.edu)\n "}, {"sha": "7a7da70ed4ebaed149179f933efd7d2ac076c5fa", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -61,7 +61,7 @@ g++: $(srcdir)/cp/g++.c $(CONFIG_H) $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o g++ $(srcdir)/cp/g++.c $(LIBS)\n \n # Create a version of the g++ driver which calls the cross-compiler.\n-g++-cross: $(srcdir)/cp/g++.c\n+g++-cross: $(srcdir)/cp/g++.c version.o $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(INCLUDES) $(LDFLAGS) -o g++-cross \\\n \t   -DGCC_NAME=\\\"$(GCC_CROSS_NAME)\\\" $(srcdir)/cp/g++.c version.o $(LIBS)\n "}, {"sha": "ed7c63f6128d16def7b096f47e27345d082109d9", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -187,15 +187,26 @@ RTL_H = $(srcdir)/../rtl.h $(srcdir)/../rtl.def \\\n TREE_H = $(srcdir)/../tree.h $(srcdir)/../real.h $(srcdir)/../tree.def \\\n \t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n CXX_TREE_H = $(TREE_H) cp-tree.h tree.def\n+PARSE_H = $(srcdir)/parse.h\n+PARSE_C = $(srcdir)/parse.c\n \n-parse.o : $(srcdir)/parse.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n+parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n-  `echo $(srcdir)/parse.c | sed 's,^\\./,,'`\n-\n-$(srcdir)/parse.c $(srcdir)/parse.h : $(srcdir)/parse.y\n+  `echo $(PARSE_C) | sed 's,^\\./,,'`\n+\n+#$(PARSE_C) $(PARSE_H) : $(srcdir)/parse.y\n+#\t@echo expect 1 shift/reduce confict and 34 reduce/reduce conflicts.\n+#\tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n+#\tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n+$(PARSE_C) $(PARSE_H) : stamp-parse ; @true\n+stamp-parse: $(srcdir)/parse.y\n \t@echo expect 1 shift/reduce confict and 34 reduce/reduce conflicts.\n-\tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n-\tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n+\t$(BISON) $(BISONFLAGS) -d $(srcdir)/parse.y\n+\tgrep '^#define[ \t]*YYEMPTY' y.tab.c >>y.tab.h\n+\t$(srcdir)/../move-if-change y.tab.c $(PARSE_C)\n+\t$(srcdir)/../move-if-change y.tab.h $(PARSE_H)\n+\tcp $(PARSE_C) y.tab.c\n+\ttouch stamp-parse\n \n # hash.h really depends on $(srcdir)/gxx.gperf.\n # But this would screw things for people that don't have gperf,\n@@ -206,9 +217,9 @@ $(srcdir)/hash.h:\n \t\t$(srcdir)/gxx.gperf >$(srcdir)/hash.h\n \n spew.o : spew.c $(CONFIG_H) $(CXX_TREE_H) \\\n-  $(srcdir)/parse.h $(srcdir)/../flags.h lex.h\n+  $(PARSE_H) $(srcdir)/../flags.h lex.h\n lex.o : lex.c $(CONFIG_H) $(CXX_TREE_H) \\\n-  $(srcdir)/parse.h input.c $(srcdir)/../flags.h hash.h lex.h\n+  $(PARSE_H) input.c $(srcdir)/../flags.h hash.h lex.h\n decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h\n decl2.o : decl2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n@@ -229,7 +240,7 @@ expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../expr.h ../insn-codes.h\n edsel.o : edsel.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h $(srcdir)/../flags.h\n xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../input.h\n-pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(srcdir)/parse.h\n+pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H)\n error.o : error.c $(CONFIG_H) $(CXX_TREE_H)\n errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H)\n sig.o : sig.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h"}, {"sha": "436fc313ebc677911a0a367cfb0ceccf7ee7f923", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -525,13 +525,6 @@ convert_harshness (type, parmtype, parm)\n       else\n \tpenalty = 2;\n \n-      if (TREE_UNSIGNED (ttl) ^ TREE_UNSIGNED (intype))\n-\t{\n-\t  ttl = unsigned_type (ttl);\n-\t  intype = unsigned_type (intype);\n-\t  penalty += 2;\n-\t}\n-\n       ttr = intype;\n \n       /* If the initializer is not an lvalue, then it does not\n@@ -551,6 +544,13 @@ convert_harshness (type, parmtype, parm)\n \t  return h;\n \t}\n \n+      if (TREE_UNSIGNED (ttl) ^ TREE_UNSIGNED (intype))\n+\t{\n+\t  ttl = unsigned_type (ttl);\n+\t  ttr = intype = unsigned_type (intype);\n+\t  penalty += 2;\n+\t}\n+\n       if (ttl == ttr)\n \t{\n \t  if (penalty > 2)\n@@ -2197,6 +2197,12 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t      cp->function = function;\n \t\t      cp->basetypes = basetype_path;\n \n+\t\t      /* Don't allow non-converting constructors to convert. */\n+\t\t      if (flags & LOOKUP_ONLYCONVERTING\n+\t\t\t  && DECL_LANG_SPECIFIC (function)\n+\t\t\t  && DECL_NONCONVERTING_P (function))\n+\t\t\tcontinue;\n+\n \t\t      /* No \"two-level\" conversions.  */\n \t\t      if (flags & LOOKUP_NO_CONVERSION\n \t\t\t  && (cp->h.code & USER_CODE))\n@@ -2434,6 +2440,13 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   /* Declare external function if necessary. */\n   assemble_external (function);\n \n+#if 0\n+  if (DECL_ARTIFICIAL (function) && ! flag_no_inline\n+      && DECL_SAVED_INSNS (function) == 0\n+      && ! TREE_ASM_WRITTEN (function))\n+    synthesize_method (function);\n+#endif\n+\n   fntype = TREE_TYPE (function);\n   if (TREE_CODE (fntype) == POINTER_TYPE)\n     fntype = TREE_TYPE (fntype);"}, {"sha": "5b89370eface1219b58f41e59bbdb13e199249f1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 130, "deletions": 65, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -659,7 +659,7 @@ prepare_fresh_vtable (binfo, for_type)\n      for_type, and we really want different names.  (mrs) */\n   tree name = build_type_pathname (VTABLE_NAME_FORMAT, basetype, for_type);\n   tree new_decl = build_decl (VAR_DECL, name, TREE_TYPE (orig_decl));\n-  tree path;\n+  tree path, offset;\n   int result;\n \n   /* Remember which class this vtable is really for.  */\n@@ -676,11 +676,18 @@ prepare_fresh_vtable (binfo, for_type)\n \n   /* Make fresh virtual list, so we can smash it later.  */\n   BINFO_VIRTUALS (binfo) = copy_list (BINFO_VIRTUALS (binfo));\n+\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    offset = BINFO_OFFSET (binfo_member (BINFO_TYPE (binfo), \n+\t\t\t    CLASSTYPE_VBASECLASSES (for_type)));\n+  else\n+    offset = BINFO_OFFSET (binfo);\n+\n   /* Install the value for `headof' if that's what we're doing.  */\n-  if (flag_dossier)\n-    TREE_VALUE (TREE_CHAIN (BINFO_VIRTUALS (binfo)))\n-      = build_vtable_entry (size_binop (MINUS_EXPR, integer_zero_node, BINFO_OFFSET (binfo)),\n-\t\t\t    FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (TREE_CHAIN (BINFO_VIRTUALS (binfo)))));\n+  if (flag_rtti)\n+    TREE_VALUE (BINFO_VIRTUALS (binfo))\n+      = build_vtable_entry (size_binop (MINUS_EXPR, integer_zero_node, offset),\n+\t    FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (BINFO_VIRTUALS (binfo))));\n \n #ifdef GATHER_STATISTICS\n   n_vtables += 1;\n@@ -803,11 +810,13 @@ add_virtual_function (pending_virtuals, has_virtual, fndecl, t)\n     {\n       tree entry;\n \n-      if (flag_dossier && *has_virtual == 0)\n+      if (flag_rtti && *has_virtual == 0)\n \t{\n-\t  /* CLASSTYPE_DOSSIER is only used as a Boolean (NULL or not). */\n-\t  CLASSTYPE_DOSSIER (t) = integer_one_node;\n+\t  /* CLASSTYPE_RTTI is only used as a Boolean (NULL or not). */\n+\t  CLASSTYPE_RTTI (t) = integer_one_node;\n+#if 0\n \t  *has_virtual = 1;\n+#endif\n         }\n \n       /* Build a new INT_CST for this DECL_VINDEX.  */\n@@ -1083,19 +1092,21 @@ alter_access (t, fdecl, access)\n \terror (\"conflicting access specifications for field `%s', ignored\",\n \t       IDENTIFIER_POINTER (DECL_NAME (fdecl)));\n     }\n-  else if (TREE_PRIVATE (fdecl) && access != access_private)\n-    cp_error_at (\"cannot make private `%D' non-private\", fdecl);\n+  else if (TREE_PRIVATE (fdecl))\n+    {\n+      if (access != access_private)\n+\tcp_error_at (\"cannot make private `%D' non-private\", fdecl);\n+      goto alter;\n+    }\n   else if (TREE_PROTECTED (fdecl))\n     {\n-      if (access == access_public)\n-\tcp_error_at (\"cannot make protected `%D' public\", fdecl);\n+      if (access != access_protected)\n+\tcp_error_at (\"cannot make protected `%D' non-protected\", fdecl);\n       goto alter;\n     }\n   /* ARM 11.3: an access declaration may not be used to restrict access\n      to a member that is accessible in the base class.  */\n-  else if (TREE_PUBLIC (fdecl)\n-\t   && (access == access_private\n-\t       || access == access_protected))\n+  else if (access != access_public)\n     cp_error_at (\"cannot reduce access of public member `%D'\", fdecl);\n   else if (elem == NULL_TREE)\n     {\n@@ -2120,7 +2131,7 @@ finish_vtbls (binfo, do_self, t)\n \t{\n \t  base_binfo = binfo_member (BINFO_TYPE (base_binfo), CLASSTYPE_VBASECLASSES (t));\n \t}\n-      finish_vtbls (base_binfo, is_not_base_vtable, t);\n+      finish_vtbls (base_binfo, (is_not_base_vtable || flag_rtti), t);\n     }\n }\n \n@@ -2239,12 +2250,34 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n      tree binfo, t, fndecl, pfn;\n {\n   tree virtuals = BINFO_VIRTUALS (binfo);\n+  tree old_rtti;\n   unsigned HOST_WIDE_INT n;\n   \n-  n = 0;\n-  /* Skip initial vtable length field and RTTI fake object. */\n-  for (; virtuals && n < 1 + flag_dossier; n++)\n-      virtuals = TREE_CHAIN (virtuals);\n+  /* update rtti entry */\n+  if (flag_rtti)\n+    {\n+      if (binfo == TYPE_BINFO (t))\n+\t{\n+\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t    build_vtable (TYPE_BINFO (DECL_CONTEXT (CLASSTYPE_VFIELD (t))), t);\n+\t}\n+      else\n+\t{\n+\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t    prepare_fresh_vtable (binfo, t);\n+\t}\n+      old_rtti = get_vtable_entry_n (BINFO_VIRTUALS (binfo), 0);\n+      if (old_rtti)\n+\tTREE_VALUE (old_rtti) = build_vtable_entry (\n+\tDELTA_FROM_VTABLE_ENTRY (TREE_VALUE (old_rtti)), \n+        build_t_desc (t, 0));\n+    }\n+  if (fndecl == NULL_TREE) return;\n+\n+  /* Skip RTTI fake object. */\n+  n = 1;\n+  if (virtuals)\n+    virtuals = TREE_CHAIN (virtuals);\n   while (virtuals)\n     {\n       tree current_fndecl = TREE_VALUE (virtuals);\n@@ -2330,7 +2363,7 @@ modify_all_direct_vtables (binfo, do_self, t, fndecl, pfn)\n       int is_not_base_vtable =\n \ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n       if (! TREE_VIA_VIRTUAL (base_binfo))\n-\tmodify_all_direct_vtables (base_binfo, is_not_base_vtable, t, fndecl, pfn);\n+\tmodify_all_direct_vtables (base_binfo, (is_not_base_vtable || flag_rtti), t, fndecl, pfn);\n     }\n }\n \n@@ -2345,10 +2378,10 @@ fixup_vtable_deltas (binfo, t)\n   tree virtuals = BINFO_VIRTUALS (binfo);\n   unsigned HOST_WIDE_INT n;\n   \n-  n = 0;\n-  /* Skip initial vtable length field and RTTI fake object. */\n-  for (; virtuals && n < 1 + flag_dossier; n++)\n-      virtuals = TREE_CHAIN (virtuals);\n+  /* Skip RTTI fake object. */\n+  n = 1;\n+  if (virtuals)\n+    virtuals = TREE_CHAIN (virtuals);\n   while (virtuals)\n     {\n       tree fndecl = TREE_VALUE (virtuals);\n@@ -2489,21 +2522,9 @@ override_one_vtable (binfo, old, t)\n   if (BINFO_NEW_VTABLE_MARKED (binfo))\n     choose = NEITHER;\n \n-  /* Skip size entry. */\n-  virtuals = TREE_CHAIN (virtuals);\n   /* Skip RTTI fake object. */\n-  if (flag_dossier)\n-    {\n-      virtuals = TREE_CHAIN (virtuals);\n-    }\n-\n-  /* Skip size entry. */\n+  virtuals = TREE_CHAIN (virtuals);\n   old_virtuals = TREE_CHAIN (old_virtuals);\n-  /* Skip RTTI fake object. */\n-  if (flag_dossier)\n-    {\n-      old_virtuals = TREE_CHAIN (old_virtuals);\n-    }\n \n   while (virtuals)\n     {\n@@ -2789,8 +2810,10 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n     }\n #endif\n \n-  if (flag_dossier)\n+#if 0\n+  if (flag_rtti)\n     build_t_desc (t, 0);\n+#endif\n \n   TYPE_BINFO (t) = NULL_TREE;\n \n@@ -3303,7 +3326,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  tail = &TREE_CHAIN (dtor);\n \n \t  if (DECL_VINDEX (dtor) == NULL_TREE\n-\t      && ! CLASSTYPE_DECLARED_EXCEPTION (t)\n \t      && (needs_virtual_dtor\n \t\t  || pending_virtuals != NULL_TREE\n \t\t  || pending_hard_virtuals != NULL_TREE))\n@@ -3319,6 +3341,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   *tail_user_methods = NULL_TREE;\n \n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n+  if (flag_rtti && (max_has_virtual > 0 || needs_virtual_dtor) && \n+\thas_virtual == 0)\n+    has_virtual = 1;\n \n   if (! fn_fields)\n     nonprivate_method = 1;\n@@ -3374,7 +3399,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       method_vec = finish_struct_methods (t, fn_fields, nonprivate_method);\n \n       if (TYPE_HAS_CONSTRUCTOR (t)\n-\t  && ! CLASSTYPE_DECLARED_EXCEPTION (t)\n \t  && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n \t  && DECL_FRIENDLIST (TYPE_NAME (t)) == NULL_TREE)\n \t{\n@@ -3485,7 +3509,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       DECL_FCONTEXT (vfield) = t;\n       DECL_FIELD_SIZE (vfield) = 0;\n       DECL_ALIGN (vfield) = TYPE_ALIGN (ptr_type_node);\n-      if (CLASSTYPE_DOSSIER (t))\n+      if (CLASSTYPE_RTTI (t))\n \t{\n \t  /* vfield is always first entry in structure.  */\n \t  TREE_CHAIN (vfield) = fields;\n@@ -3680,14 +3704,16 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       vbases = CLASSTYPE_VBASECLASSES (t);\n       CLASSTYPE_N_VBASECLASSES (t) = list_length (vbases);\n \n+      /* The rtti code should do this.  (mrs) */\n+#if 0 \n       while (vbases)\n \t{\n-\t  /* The rtti code should do this.  (mrs) */\n-\t  /* Update dossier info with offsets for virtual baseclasses.  */\n-\t  if (flag_dossier && ! BINFO_NEW_VTABLE_MARKED (vbases))\n+\t  /* Update rtti info with offsets for virtual baseclasses.  */\n+\t  if (flag_rtti && ! BINFO_NEW_VTABLE_MARKED (vbases))\n \t    prepare_fresh_vtable (vbases, t);\n \t  vbases = TREE_CHAIN (vbases);\n \t}\n+#endif\n \n       {\n \t/* Now fixup overrides of all functions in vtables from all\n@@ -3750,6 +3776,15 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n #ifdef NOTQUITE\n   cp_warning (\"Doing hard virtuals for %T...\", t);\n #endif\n+\n+  if (has_virtual > max_has_virtual)\n+    max_has_virtual = has_virtual;\n+  if (max_has_virtual > 0)\n+    TYPE_VIRTUAL_P (t) = 1;\n+\n+  if (flag_rtti && TYPE_VIRTUAL_P (t) && !pending_hard_virtuals)\n+    modify_all_vtables (t, NULL_TREE, NULL_TREE);\n+\n   while (pending_hard_virtuals)\n     {\n       modify_all_vtables (t,\n@@ -3761,19 +3796,27 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n   /* Under our model of GC, every C++ class gets its own virtual\n      function table, at least virtually.  */\n-  if (pending_virtuals || CLASSTYPE_DOSSIER (t))\n+  if (pending_virtuals || (flag_rtti && TYPE_VIRTUAL_P (t)))\n     {\n       pending_virtuals = nreverse (pending_virtuals);\n       /* We must enter these virtuals into the table.  */\n       if (first_vfn_base_index < 0)\n \t{\n-\t  if (flag_dossier)\n+\t  if (flag_rtti)\n \t    pending_virtuals = tree_cons (NULL_TREE,\n-\t\t\t\t\t  build_vtable_entry (integer_zero_node,\n-\t\t\t\t\t\t\t      build_t_desc (t, 0)),\n-\t\t\t\t\t  pending_virtuals);\n+\t\tbuild_vtable_entry (integer_zero_node, build_t_desc (t, 0)),\n+\t        pending_virtuals);\n+\t  else \n+            pending_virtuals = tree_cons (NULL_TREE,\n+                build_vtable_entry (integer_zero_node, integer_zero_node),\n+                pending_virtuals);\n+\n+#if 0\n+\t  /* The size is no longer used. */\n+\t  /* now we put the size of the vtable as first entry */\n \t  pending_virtuals = tree_cons (NULL_TREE, the_null_vtable_entry,\n \t\t\t\t\tpending_virtuals);\n+#endif\n \t  build_vtable (NULL_TREE, t);\n \t}\n       else\n@@ -3784,9 +3827,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t  if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n \t    build_vtable (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), first_vfn_base_index), t);\n \n-\t  /* Update the dossier pointer for this class.  */\n-\t  if (flag_dossier)\n-\t    TREE_VALUE (TREE_CHAIN (TYPE_BINFO_VIRTUALS (t)))\n+\t  /* Update the rtti pointer for this class.  */\n+\t  if (flag_rtti)\n+\t    TREE_VALUE (TYPE_BINFO_VIRTUALS (t))\n \t      = build_vtable_entry (integer_zero_node, build_t_desc (t, 0));\n \t}\n \n@@ -3815,11 +3858,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \tCLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n \n-  if (has_virtual > max_has_virtual)\n-    max_has_virtual = has_virtual;\n   if (max_has_virtual || first_vfn_base_index >= 0)\n     {\n-      TYPE_VIRTUAL_P (t) = 1;\n       CLASSTYPE_VSIZE (t) = has_virtual;\n       if (first_vfn_base_index >= 0)\n \t{\n@@ -3970,7 +4010,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   else if (TYPE_NEEDS_CONSTRUCTING (t))\n     build_class_init_list (t);\n \n-  if (! CLASSTYPE_DECLARED_EXCEPTION (t) && ! IS_SIGNATURE (t))\n+  if (! IS_SIGNATURE (t))\n     embrace_waiting_friends (t);\n \n   /* Write out inline function definitions.  */\n@@ -4022,32 +4062,46 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   finish_vtbls (TYPE_BINFO (t), 1, t);\n   TYPE_BEING_DEFINED (t) = 0;\n \n-  if (flag_dossier && CLASSTYPE_VTABLE_NEEDS_WRITING (t))\n+  if (flag_rtti && TYPE_VIRTUAL_P (t) && CLASSTYPE_VTABLE_NEEDS_WRITING (t))\n     {\n       tree variants;\n-      tree tdecl;\n+      tree tdecl, td;\n \n       /* Now instantiate its type descriptors.  */\n-      tdecl = TREE_OPERAND (build_t_desc (t, 1), 0);\n+      td = build_t_desc (t, 1);\n+      if (td == NULL_TREE)\n+\t{\n+\t  cp_error (\"failed to build type descriptor node of '%T', maybe typeinfo.h not included\", t);\n+\t  tdecl = NULL_TREE;\n+\t}\n+      else\n+        tdecl = TREE_OPERAND (td, 0);\n+\n+#if 0\n+      /* I see no need for building the following TD */\n       variants = TYPE_POINTER_TO (t);\n       build_type_variant (variants, 1, 0);\n       while (variants)\n \t{\n \t  build_t_desc (variants, 1);\n \t  variants = TYPE_NEXT_VARIANT (variants);\n \t}\n+#endif\n       variants = build_reference_type (t);\n       build_type_variant (variants, 1, 0);\n       while (variants)\n \t{\n \t  build_t_desc (variants, 1);\n \t  variants = TYPE_NEXT_VARIANT (variants);\n \t}\n-      DECL_CONTEXT (tdecl) = t;\n+      if (tdecl != NULL_TREE)\n+        DECL_CONTEXT (tdecl) = t;\n     }\n+#if 0\n   /* Still need to instantiate this C struct's type descriptor.  */\n-  else if (flag_dossier && ! CLASSTYPE_DOSSIER (t))\n+  else if (flag_rtti && ! CLASSTYPE_RTTI (t))\n     build_t_desc (t, 1);\n+#endif\n \n #if 0\n   if (TYPE_NAME (t) && TYPE_IDENTIFIER (t))\n@@ -4450,9 +4504,20 @@ popclass (modify)\n \t  if (TREE_CODE (TREE_TYPE (current_class_decl)) == POINTER_TYPE)\n \t    {\n \t      tree temp;\n-\t      /* Can't call build_indirect_ref here, because it has special\n-\t\t logic to return C_C_D given this argument.  */\n-\t      C_C_D = build1 (INDIRECT_REF, current_class_type, current_class_decl);\n+\t      if (CLASSTYPE_INST_VAR (current_class_type) == NULL_TREE)\n+\t\t{\n+\t\t  /* Can't call build_indirect_ref here, because it has special\n+\t\t     logic to return C_C_D given this argument.  */\n+\t\t  C_C_D = build1 (INDIRECT_REF, current_class_type, current_class_decl);\n+\t\t  CLASSTYPE_INST_VAR (current_class_type) = C_C_D;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  C_C_D = CLASSTYPE_INST_VAR (current_class_type);\n+\t\t  /* `current_class_decl' is different for every\n+\t\t     function we compile.  */\n+\t\t  TREE_OPERAND (C_C_D, 0) = current_class_decl;\n+\t\t}\n \t      temp = TREE_TYPE (TREE_TYPE (current_class_decl));\n \t      TREE_READONLY (C_C_D) = TYPE_READONLY (temp);\n \t      TREE_SIDE_EFFECTS (C_C_D) = TYPE_VOLATILE (temp);"}, {"sha": "98e2dd9641b717d4fc154cddecac7ab1b2aa7efd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -408,7 +408,7 @@ struct lang_type\n       unsigned interface_only : 1;\n       unsigned interface_unknown : 1;\n       unsigned needs_virtual_reinit : 1;\n-      unsigned declared_exception : 1;\n+      unsigned vec_delete_takes_size : 1;\n       unsigned declared_class : 1;\n       unsigned being_defined : 1;\n       unsigned redefined : 1;\n@@ -442,13 +442,12 @@ struct lang_type\n       unsigned has_const_init_ref : 1;\n       unsigned has_complex_init_ref : 1;\n       unsigned has_complex_assign_ref : 1;\n-      unsigned vec_delete_takes_size : 1;\n       unsigned has_abstract_assign_ref : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 19;\n+      unsigned dummy : 20;\n \n       unsigned n_vancestors : 16;\n     } type_flags;\n@@ -495,7 +494,7 @@ struct lang_type\n   char *mi_matrix;\n   union tree_node *conversions[last_conversion_type];\n \n-  union tree_node *dossier;\n+  union tree_node *rtti;\n \n   union tree_node *methods;\n \n@@ -629,8 +628,8 @@ struct lang_type\n    signature reference type.  */\n #define SIGNATURE_REFERENCE_TO(NODE) (TYPE_LANG_SPECIFIC(NODE)->signature_reference_to)\n \n-/* The is the VAR_DECL that contains NODE's dossier.  */\n-#define CLASSTYPE_DOSSIER(NODE) (TYPE_LANG_SPECIFIC(NODE)->dossier)\n+/* The is the VAR_DECL that contains NODE's rtti.  */\n+#define CLASSTYPE_RTTI(NODE) (TYPE_LANG_SPECIFIC(NODE)->rtti)\n \n /* List of all explicit methods (chained using DECL_NEXT_METHOD),\n    in order they were parsed. */\n@@ -816,8 +815,6 @@ struct lang_type\n \n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n #define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_class)\n-/* Say whether this node was declared as a \"class\" or a \"struct\".  */\n-#define CLASSTYPE_DECLARED_EXCEPTION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_exception)\n /* whether this can be globalized.  */\n #define CLASSTYPE_NO_GLOBALIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.no_globalize)\n \n@@ -947,7 +944,10 @@ struct lang_decl_flags\n   unsigned saved_inline : 1;\n   unsigned use_template : 2;\n \n-  unsigned dummy : 8;\n+  unsigned interface_known : 1;\n+  unsigned declared_static : 1;\n+  unsigned nonconverting : 1;\n+  unsigned dummy : 5;\n \n   tree access;\n   tree context;\n@@ -1032,6 +1032,10 @@ struct lang_decl\n    is mutable.  */\n #define DECL_MUTABLE_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.mutable_flag)\n \n+/* Nonzero for _DECL means that this constructor is a non-converting\n+   constructor.  */\n+#define DECL_NONCONVERTING_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.nonconverting)\n+\n /* Nonzero for FUNCTION_DECL means that this member function\n    exists as part of an abstract class's interface.  */\n #define DECL_ABSTRACT_VIRTUAL_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.abstract_virtual)\n@@ -1322,6 +1326,18 @@ struct lang_decl\n #define SET_CLASSTYPE_EXPLICIT_INSTANTIATION(NODE) \\\n   (CLASSTYPE_USE_TEMPLATE(NODE) = 3)\n \n+/* We know what we're doing with this decl now.  */\n+#define DECL_INTERFACE_KNOWN(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.interface_known)\n+\n+/* This decl was declared to have internal linkage.  */\n+#define DECL_DECLARED_STATIC(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.declared_static)\n+\n+#define DECL_PUBLIC(NODE) \\\n+  (TREE_CODE (NODE) == FUNCTION_DECL ? ! DECL_DECLARED_STATIC (NODE) \\\n+   : TREE_PUBLIC (NODE))\n+\n #define THUNK_DELTA(DECL) ((DECL)->decl.frame_size.i)\n \n /* ...and for unexpanded-parameterized-type nodes.  */\n@@ -1330,7 +1346,7 @@ struct lang_decl\n \n /* An enumeration of the kind of tags that C++ accepts.  */\n enum tag_types { record_type, class_type, union_type, enum_type,\n-\t\t   exception_type, signature_type };\n+\t\t   signature_type };\n \n /* Zero means prototype weakly, as in ANSI C (no args means nothing).\n    Each language context defines how this variable should be set.  */\n@@ -1387,8 +1403,14 @@ extern tree void_zero_node;\n extern tree default_function_type;\n extern tree vtable_entry_type;\n extern tree sigtable_entry_type;\n-extern tree __t_desc_type_node, __i_desc_type_node, __m_desc_type_node;\n-extern tree Type_info_type_node;\n+extern tree __t_desc_type_node;\n+extern tree __tp_desc_type_node;\n+extern tree __access_mode_type_node;\n+extern tree __bltn_desc_type_node, __user_desc_type_node;\n+extern tree __class_desc_type_node, __attr_desc_type_node;\n+extern tree __ptr_desc_type_node, __func_desc_type_node;\n+extern tree __ptmf_desc_type_node, __ptmd_desc_type_node;\n+extern tree type_info_type_node;\n extern tree class_star_type_node;\n extern tree this_identifier;\n extern tree pfn_identifier;\n@@ -1402,7 +1424,7 @@ extern tree error_mark_list;\n \n extern tree ptr_type_node, const_ptr_type_node;\n extern tree class_type_node, record_type_node, union_type_node, enum_type_node;\n-extern tree exception_type_node, unknown_type_node;\n+extern tree unknown_type_node;\n extern tree opaque_type_node, signature_type_node;\n \n /* Node for \"pointer to (virtual) function\".\n@@ -1419,11 +1441,6 @@ extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n extern tree integer_two_node, integer_three_node;\n extern tree bool_type_node, true_node, false_node;\n \n-/* in except.c */\n-extern tree current_exception_type;\n-extern tree current_exception_decl;\n-extern tree current_exception_object;\n-\n /* in pt.c  */\n /* PARM_VEC is a vector of template parameters, either IDENTIFIER_NODEs or\n    PARM_DECLs.  BINDINGS, if non-null, is a vector of bindings for those\n@@ -1715,9 +1732,9 @@ extern int flag_int_enum_equivalence;\n \n extern int flag_gc;\n \n-/* Nonzero means generate 'dossiers' that give run-time type information.  */\n+/* Nonzero means generate 'rtti' that give run-time type information.  */\n \n-extern int flag_dossier;\n+extern int flag_rtti;\n \n /* Nonzero means do emit exported implementations of functions even if\n    they can be inlined.  */\n@@ -1782,7 +1799,8 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define LOOKUP_GLOBAL (16)\n #define LOOKUP_HAS_IN_CHARGE (32)\n #define LOOKUP_SPECULATIVELY (64)\n-/* 128 & 256 are free */\n+#define LOOKUP_ONLYCONVERTING (128)\n+/* 256 is free */\n #define LOOKUP_NO_CONVERSION (512)\n #define LOOKUP_DESTRUCTOR (512)\n \n@@ -1953,7 +1971,7 @@ extern tree grok_enum_decls\t\t\tPROTO((tree, tree));\n extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n extern void store_parm_decls\t\t\tPROTO((void));\n extern void store_return_init\t\t\tPROTO((tree, tree));\n-extern void finish_function\t\t\tPROTO((int, int));\n+extern void finish_function\t\t\tPROTO((int, int, int));\n extern tree start_method\t\t\tPROTO((tree, tree, tree));\n extern tree finish_method\t\t\tPROTO((tree));\n extern void hack_incomplete_structures\t\tPROTO((tree));"}, {"sha": "783d1f24ea0810bedecf35fe1ae47052fc38148c", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 81, "deletions": 88, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -663,10 +663,12 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \n       if (form == REFERENCE_TYPE)\n \t{\n-\t  rval = copy_node (expr);\n-\t  TREE_TYPE (rval) = build_pointer_type (TREE_TYPE (TREE_TYPE (expr)));\n-\t  rval = cp_convert (build_pointer_type (TREE_TYPE (reftype)), rval,\n+\t  tree type = TREE_TYPE (expr);\n+\t  tree tmp = copy_node (expr);\n+\t  TREE_TYPE (tmp) = build_pointer_type (TREE_TYPE (TREE_TYPE (expr)));\n+\t  rval = cp_convert (build_pointer_type (TREE_TYPE (reftype)), tmp,\n \t\t\t     convtype, flags);\n+\t  TREE_TYPE (tmp) = type;\n \t  TREE_TYPE (rval) = reftype;\n \t  return rval;\n \t}\n@@ -725,7 +727,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  && (rval = build_method_call\n \t      (NULL_TREE, constructor_name_full (type),\n \t       build_tree_list (NULL_TREE, expr), TYPE_BINFO (type),\n-\t       LOOKUP_NO_CONVERSION|LOOKUP_SPECULATIVELY)))\n+\t       LOOKUP_NO_CONVERSION|LOOKUP_SPECULATIVELY\n+\t       | LOOKUP_ONLYCONVERTING)))\n \t{\n \t  tree init;\n \n@@ -736,7 +739,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t      init = build_method_call (t, constructor_name_full (type),\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n \t\t\t\t\tTYPE_BINFO (type),\n-\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION\n+\t\t\t\t\t| LOOKUP_ONLYCONVERTING);\n \n \t      if (init == error_mark_node)\n \t\treturn error_mark_node;\n@@ -750,7 +754,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t      init = build_method_call (NULL_TREE, constructor_name_full (type),\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n \t\t\t\t\tTYPE_BINFO (type),\n-\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+\t\t\t\t\tLOOKUP_NORMAL|LOOKUP_NO_CONVERSION\n+\t\t\t\t\t|LOOKUP_ONLYCONVERTING);\n \n \t      if (init == error_mark_node)\n \t\treturn error_mark_node;\n@@ -1283,12 +1288,9 @@ cp_convert (type, expr, convtype, flags)\n   if (IS_AGGR_TYPE_CODE (code))\n     {\n       tree dtype = TREE_TYPE (e);\n+      tree ctor = NULL_TREE;\n+      tree conversion = NULL_TREE;\n \n-      if (TREE_CODE (dtype) == REFERENCE_TYPE)\n-\t{\n-\t  e = convert_from_reference (e);\n-\t  dtype = TREE_TYPE (e);\n-\t}\n       dtype = TYPE_MAIN_VARIANT (dtype);\n \n       /* Conversion of object pointers or signature pointers/references\n@@ -1321,87 +1323,78 @@ cp_convert (type, expr, convtype, flags)\n \t There may be some ambiguity between using a constructor\n \t vs. using a type conversion operator when both apply.  */\n \n-      else if (IS_AGGR_TYPE (dtype))\n-\t{\n-\t  tree binfo;\n-\n-\t  tree conversion;\n-\n-\t  if (! DERIVED_FROM_P (type, dtype) && TYPE_HAS_CONVERSION (dtype))\n-\t    conversion = build_type_conversion (CONVERT_EXPR, type, e, 1);\n-\t  else\n-\t    conversion = NULL_TREE;\n-\n-\t  if (TYPE_HAS_CONSTRUCTOR (type))\n-\t    {\n-\t      tree rval = build_method_call (NULL_TREE, constructor_name_full (type),\n-\t\t\t\t\t     build_tree_list (NULL_TREE, e),\n-\t\t\t\t\t     TYPE_BINFO (type),\n-\t\t\t\t\t     conversion ? LOOKUP_NO_CONVERSION : 0);\n+      if (IS_AGGR_TYPE (dtype) && ! DERIVED_FROM_P (type, dtype)\n+\t  && TYPE_HAS_CONVERSION (dtype))\n+\tconversion = build_type_conversion (CONVERT_EXPR, type, e, 1);\n \n-\t      if (rval != error_mark_node)\n-\t\t{\n-\t\t  if (conversion)\n-\t\t    {\n-\t\t      error (\"both constructor and type conversion operator apply\");\n-\t\t      return error_mark_node;\n-\t\t    }\n-\t\t  /* call to constructor successful.  */\n-\t\t  rval = build_cplus_new (type, rval, 1);\n-\t\t  return rval;\n-\t\t}\n-\t    }\n-\t  /* Type conversion successful/applies.  */\n-\t  if (conversion)\n-\t    {\n-\t      if (conversion == error_mark_node)\n-\t\terror (\"ambiguous pointer conversion\");\n-\t      return conversion;\n-\t    }\n-\n-\t  /* now try normal C++ assignment semantics.  */\n-\t  binfo = TYPE_BINFO (dtype);\n-\t  if (BINFO_TYPE (binfo) == type\n-\t      || (binfo = get_binfo (type, dtype, 1)))\n-\t    {\n-\t      if (binfo == error_mark_node)\n-\t\treturn error_mark_node;\n-\t    }\n-\t  if (binfo != NULL_TREE)\n-\t    {\n-\t      if (lvalue_p (e))\n-\t\t{\n-\t\t  e = build_unary_op (ADDR_EXPR, e, 0);\n+      if (conversion == error_mark_node)\n+\t{\n+\t  error (\"ambiguous pointer conversion\");\n+\t  return conversion;\n+\t}\n \n-\t\t  if (! BINFO_OFFSET_ZEROP (binfo))\n-\t\t    e = build (PLUS_EXPR, TYPE_POINTER_TO (type),\n-\t\t\t       e, BINFO_OFFSET (binfo));\n-\t\t  return build1 (INDIRECT_REF, type, e);\n-\t\t}\n+      if (TYPE_HAS_CONSTRUCTOR (type))\n+\tctor = build_method_call (NULL_TREE, constructor_name_full (type),\n+\t\t\t\t  build_tree_list (NULL_TREE, e),\n+\t\t\t\t  TYPE_BINFO (type),\n+\t\t\t\t  LOOKUP_NORMAL | LOOKUP_SPECULATIVELY\n+\t\t\t\t  | LOOKUP_ONLYCONVERTING\n+\t\t\t\t  | (conversion ? LOOKUP_NO_CONVERSION : 0));\n \n-\t      sorry (\"addressable aggregates\");\n-\t      return error_mark_node;\n-\t    }\n-\t  error (\"conversion between incompatible aggregate types requested\");\n+      if (ctor == error_mark_node)\n+\t{\n+\t  cp_error (\"in conversion to type `%T'\", type);\n \t  return error_mark_node;\n \t}\n-      /* conversion from non-aggregate to aggregate type requires\n-         constructor.  */\n-      else if (TYPE_HAS_CONSTRUCTOR (type))\n+      \n+      if (conversion && ctor)\n \t{\n-\t  tree rval;\n-\t  tree init = build_method_call (NULL_TREE, constructor_name_full (type),\n-\t\t\t\t\t build_tree_list (NULL_TREE, e),\n-\t\t\t\t\t TYPE_BINFO (type), LOOKUP_NORMAL);\n-\t  if (init == error_mark_node)\n+\t  error (\"both constructor and type conversion operator apply\");\n+\t  return error_mark_node;\n+\t}\n+      else if (conversion)\n+\treturn conversion;\n+      else if (ctor)\n+\t{\n+\t  if (current_function_decl)\n+\t    /* We can't pass 1 to the with_cleanup_p arg here, because that\n+\t       screws up passing classes by value.  */\n+\t    ctor = build_cplus_new (type, ctor, 0);\n+\t  else\n \t    {\n-\t      cp_error (\"in conversion to type `%T'\", type);\n-\t      return error_mark_node;\n+\t      register tree parm = TREE_OPERAND (ctor, 1);\n+\n+\t      /* Initializers for static variables and parameters\n+\t\t have to handle doing the initialization and\n+\t\t cleanup themselves.  */\n+\t      my_friendly_assert (TREE_CODE (ctor) == CALL_EXPR, 322);\n+#if 0\n+\t      /* The following assertion fails in cases where we\n+\t\t are initializing a static member variable of a\n+\t\t particular instance of a template class with a\n+\t\t call to a constructor of the given instance, as\n+\t\t in:\n+\t\t \n+\t\t TMPL<int> object = TMPL<int>();\n+\t\t \n+\t\t Curiously, the assertion does not fail if we do\n+\t\t the same thing for a static member of a\n+\t\t non-template class, as in:\n+\t\t \n+\t\t T object = T();\n+\t\t \n+\t\t I can't see why we should care here whether or not\n+\t\t the initializer expression involves a call to\n+\t\t `new', so for the time being, it seems best to\n+\t\t just avoid doing this assertion.  */\n+\t      my_friendly_assert (TREE_CALLS_NEW (TREE_VALUE (parm)),\n+\t\t\t\t  323);\n+#endif\n+\t      TREE_VALUE (parm) = NULL_TREE;\n+\t      ctor = build_indirect_ref (ctor, NULL_PTR);\n+\t      TREE_HAS_CONSTRUCTOR (ctor) = 1;\n \t    }\n-\t  /* We can't pass 1 to the with_cleanup_p arg here, because that\n-             screws up passing classes by value.  */\n-\t  rval = build_cplus_new (type, init, 0);\n-\t  return rval;\n+\t  return ctor;\n \t}\n     }\n \n@@ -1483,9 +1476,9 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n   int flags;\n \n   if (for_sure == 0)\n-    flags = LOOKUP_PROTECT;\n+    flags = LOOKUP_PROTECT|LOOKUP_ONLYCONVERTING;\n   else\n-    flags = LOOKUP_NORMAL;\n+    flags = LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING;\n \n   rval = build_method_call (expr, typename, NULL_TREE, NULL_TREE, flags);\n   if (rval == error_mark_node)\n@@ -1615,9 +1608,9 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t      int flags;\n \n \t      if (for_sure == 0)\n-\t\tflags = LOOKUP_PROTECT;\n+\t\tflags = LOOKUP_PROTECT|LOOKUP_ONLYCONVERTING;\n \t      else\n-\t\tflags = LOOKUP_NORMAL;\n+\t\tflags = LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING;\n \t      rval = build_method_call (expr,\n \t\t\t\t\tconstructor_name_full (typename),\n \t\t\t\t\tNULL_TREE, NULL_TREE, flags);"}, {"sha": "60fe14fd46ed4d93ccd5ff277d4c151756edb88a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 364, "deletions": 178, "changes": 542, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -234,11 +234,27 @@ tree int_ftype_cptr_cptr_sizet;\n /* C++ extensions */\n tree vtable_entry_type;\n tree delta_type_node;\n-tree __t_desc_type_node, __i_desc_type_node, __m_desc_type_node;\n+#if 0\n+/* Old rtti stuff. */\n+tree __baselist_desc_type_node;\n+tree __i_desc_type_node, __m_desc_type_node;\n tree __t_desc_array_type, __i_desc_array_type, __m_desc_array_type;\n+#endif\n+tree __t_desc_type_node, __tp_desc_type_node;\n+tree __access_mode_type_node;\n+tree __bltn_desc_type_node, __user_desc_type_node, __class_desc_type_node;\n+tree __ptr_desc_type_node, __attr_desc_type_node, __func_desc_type_node;\n+tree __ptmf_desc_type_node, __ptmd_desc_type_node;\n+#if 0\n+/* Not needed yet?  May be needed one day?  */\n+tree __bltn_desc_array_type, __user_desc_array_type, __class_desc_array_type;\n+tree __ptr_desc_array_type, __attr_dec_array_type, __func_desc_array_type;\n+tree __ptmf_desc_array_type, __ptmd_desc_array_type;\n+#endif\n+\n tree class_star_type_node;\n tree class_type_node, record_type_node, union_type_node, enum_type_node;\n-tree exception_type_node, unknown_type_node;\n+tree unknown_type_node;\n tree opaque_type_node, signature_type_node;\n tree sigtable_entry_type;\n tree maybe_gc_cleanup;\n@@ -1729,10 +1745,7 @@ pushtag (name, type, globalize)\n         TYPE_NAME (type) = name;\n       \n       /* Do C++ gratuitous typedefing.  */\n-      if (IDENTIFIER_TYPE_VALUE (name) != type\n-\t  && (TREE_CODE (type) != RECORD_TYPE\n-\t      || b->parm_flag != 2\n-\t      || !CLASSTYPE_DECLARED_EXCEPTION (type)))\n+      if (IDENTIFIER_TYPE_VALUE (name) != type)\n         {\n           register tree d;\n \t  int newdecl = 0;\n@@ -2055,7 +2068,7 @@ warn_extern_redeclared_static (newdecl, olddecl)\n     return;\n \n   name = DECL_ASSEMBLER_NAME (newdecl);\n-  if (TREE_PUBLIC (name) && ! TREE_PUBLIC (newdecl))\n+  if (TREE_PUBLIC (name) && ! DECL_PUBLIC (newdecl))\n     {\n       /* It's okay to redeclare an ANSI built-in function as static,\n \t or to declare a non-ANSI built-in function as anything.  */\n@@ -2119,7 +2132,7 @@ duplicate_decls (newdecl, olddecl)\n       /* If you declare a built-in or predefined function name as static,\n \t the old definition is overridden, but optionally warn this was a\n \t bad choice of name.  Ditto for overloads.  */\n-      if (! TREE_PUBLIC (newdecl)\n+      if (! DECL_PUBLIC (newdecl)\n \t  || (TREE_CODE (newdecl) == FUNCTION_DECL\n \t      && DECL_LANGUAGE (newdecl) != DECL_LANGUAGE (olddecl)))\n \t{\n@@ -2453,33 +2466,29 @@ duplicate_decls (newdecl, olddecl)\n     {\n       TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n       DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n+      TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n \n-      if (TREE_CODE (newdecl) != FUNCTION_DECL)\n-\tTREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n+      if (TREE_CODE (newdecl) == FUNCTION_DECL)\n+\t{\n+\t  DECL_DECLARED_STATIC (newdecl) = DECL_DECLARED_STATIC (olddecl);\n+\t  DECL_INTERFACE_KNOWN (newdecl) = DECL_INTERFACE_KNOWN (olddecl);\n+\t}\n     }\n   else\n     {\n       TREE_STATIC (olddecl) = TREE_STATIC (newdecl);\n-      /* A `const' which was not declared `extern' and is\n-\t in static storage is invisible.  */\n+      /* A `const' which was not declared `extern' gets internal linkage.  */\n       if (TREE_CODE (newdecl) == VAR_DECL\n-\t  && TREE_READONLY (newdecl) && TREE_STATIC (newdecl)\n-\t  && ! DECL_THIS_EXTERN (newdecl))\n+\t  && TREE_READONLY (newdecl) && ! DECL_THIS_EXTERN (newdecl))\n \tTREE_PUBLIC (newdecl) = 0;\n-      else if (TREE_CODE (newdecl) != FUNCTION_DECL)\n-\tTREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n-    }\n+      else\n+\t{\n+\t  TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n \n-  /* For functions, static overrides non-static.  */\n-  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n-    {\n-      TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n-      /* This is since we don't automatically\n-\t copy the attributes of NEWDECL into OLDDECL.  */\n-      TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n-      /* If this clears `static', clear it in the identifier too.  */\n-      if (! TREE_PUBLIC (olddecl))\n-\tTREE_PUBLIC (DECL_ASSEMBLER_NAME (olddecl)) = 0;\n+\t  /* If this clears PUBLIC, clear it in the identifier too.  */\n+\t  if (TREE_CODE (newdecl) == FUNCTION_DECL && ! TREE_PUBLIC (olddecl))\n+\t    TREE_PUBLIC (DECL_ASSEMBLER_NAME (olddecl)) = 0;\n+\t}\n     }\n \n   /* If either decl says `inline', this fn is inline,\n@@ -2551,6 +2560,7 @@ duplicate_decls (newdecl, olddecl)\n     {\n       DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);\n       DECL_ACCESS (newdecl) = DECL_ACCESS (olddecl);\n+      DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);\n     }\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n@@ -2843,7 +2853,7 @@ pushdecl (x)\n \n \t  /* If the first global decl has external linkage,\n \t     warn if we later see static one.  */\n-\t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n+\t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && DECL_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n \n \t  /* Don't install a TYPE_DECL if we already have another\n@@ -3376,10 +3386,10 @@ redeclaration_error_message (newdecl, olddecl)\n       if (DECL_LANG_SPECIFIC (olddecl) && DECL_ABSTRACT_VIRTUAL_P (olddecl))\n \treturn 0;\n \n-      /* Declarations of functions can insist on internal linkage\n-\t but they can't be inconsistent with internal linkage,\n-\t so there can be no error on that account.\n-\t However defining the same name twice is no good.  */\n+      /* We'll complain about linkage mismatches in\n+         warn_extern_redeclared_static.  */\n+\n+      /* defining the same name twice is no good.  */\n       if (DECL_INITIAL (olddecl) != NULL_TREE\n \t  && DECL_INITIAL (newdecl) != NULL_TREE\n \t  /* However, defining once as extern inline and a second\n@@ -3415,13 +3425,12 @@ redeclaration_error_message (newdecl, olddecl)\n   else if (current_binding_level == global_binding_level)\n     {\n       /* Objects declared at top level:  */\n+      /* Insist that the linkage match.  */\n+      if (! TREE_PUBLIC (newdecl) && TREE_PUBLIC (olddecl))\n+\treturn \"conflicting declarations of `%#D'\";\n       /* If at least one is a reference, it's ok.  */\n       if (DECL_EXTERNAL (newdecl) || DECL_EXTERNAL (olddecl))\n \treturn 0;\n-      /* Now we have two tentative defs, or one tentative and one real def.  */\n-      /* Insist that the linkage match.  */\n-      if (TREE_PUBLIC (olddecl) != TREE_PUBLIC (newdecl))\n-\treturn \"conflicting declarations of `%#D'\";\n       /* Reject two definitions.  */\n       return \"redefinition of `%#D'\";\n     }\n@@ -4134,7 +4143,7 @@ record_builtin_type (rid_index, name, type)\n \t}\n     }\n \n-  if (flag_dossier)\n+  if (flag_rtti)\n     {\n       if (builtin_type_tdescs_len+5 >= builtin_type_tdescs_max)\n \t{\n@@ -4254,7 +4263,7 @@ init_decl_processing ()\n #endif\n \n   gcc_obstack_init (&decl_obstack);\n-  if (flag_dossier)\n+  if (flag_rtti)\n     {\n       builtin_type_tdescs_max = 100;\n       builtin_type_tdescs_arr = (tree *)xmalloc (100 * sizeof (tree));\n@@ -4839,7 +4848,8 @@ init_decl_processing ()\n       record_builtin_type (RID_MAX, SIGTABLE_PTR_TYPE, sigtable_entry_type);\n     }\n \n-  if (flag_dossier)\n+#if 0\n+  if (flag_rtti)\n     {\n       /* Must build __t_desc type.  Currently, type descriptors look like this:\n \n@@ -4950,9 +4960,7 @@ init_decl_processing ()\n \t\t\t   integer_type_node);\n     }\n \n-  /* Now, C++.  */\n-  current_lang_name = lang_name_cplusplus;\n-  if (flag_dossier)\n+  if (flag_rtti)\n     {\n       int i = builtin_type_tdescs_len;\n       while (i > 0)\n@@ -4962,6 +4970,10 @@ init_decl_processing ()\n \t  TREE_PUBLIC (TREE_OPERAND (tdesc, 0)) = 1;\n \t}\n     }\n+#endif /*flag_rtti*/\n+\n+  /* Now, C++.  */\n+  current_lang_name = lang_name_cplusplus;\n \n   auto_function (ansi_opname[(int) NEW_EXPR],\n \t\t build_function_type (ptr_type_node,\n@@ -5016,6 +5028,74 @@ init_decl_processing ()\n   init_function_format_info ();\n }\n \n+/* initialize type descriptor type node of various rtti type. */\n+\n+int\n+init_type_desc()\n+{\n+  tree tdecl;\n+\n+  tdecl = lookup_name (get_identifier (\"type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __t_desc_type_node = TREE_TYPE(tdecl);\n+  __tp_desc_type_node = build_pointer_type (__t_desc_type_node);\n+\n+#if 0\n+  tdecl = lookup_name (get_identifier (\"__baselist_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __baselist_desc_type_node = TREE_TYPE (tdecl);\n+#endif\n+\n+  tdecl = lookup_name (get_identifier (\"__builtin_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __bltn_desc_type_node = TREE_TYPE (tdecl);\n+\n+  tdecl = lookup_name (get_identifier (\"__user_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __user_desc_type_node = TREE_TYPE (tdecl);\n+\n+  tdecl = lookup_name (get_identifier (\"__class_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __class_desc_type_node = TREE_TYPE (tdecl);\n+\n+  tdecl = lookup_field (__class_desc_type_node, \n+\tget_identifier (\"access_mode\"), 0, 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __access_mode_type_node = TREE_TYPE (tdecl);\n+\n+  tdecl = lookup_name (get_identifier (\"__attr_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __attr_desc_type_node = TREE_TYPE (tdecl);\n+\n+  tdecl = lookup_name (get_identifier (\"__pointer_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __ptr_desc_type_node = TREE_TYPE (tdecl);\n+\n+  tdecl = lookup_name (get_identifier (\"__func_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __func_desc_type_node = TREE_TYPE (tdecl);\n+\n+  tdecl = lookup_name (get_identifier (\"__ptmf_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __ptmf_desc_type_node = TREE_TYPE (tdecl);\n+\n+  tdecl = lookup_name (get_identifier (\"__ptmd_type_info\"), 0);\n+  if (tdecl == NULL_TREE)\n+    return 0;\n+  __ptmd_desc_type_node = TREE_TYPE (tdecl);\n+\n+  return 1;\n+}\n /* Make a definition for a builtin function named NAME and whose data type\n    is TYPE.  TYPE should be a function type with argument types.\n    FUNCTION_CODE tells later passes how to compile calls to this function.\n@@ -5035,6 +5115,7 @@ define_function (name, type, function_code, pfn, library_name)\n   tree decl = build_lang_decl (FUNCTION_DECL, get_identifier (name), type);\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n+  DECL_INTERFACE_KNOWN (decl) = 1;\n \n   /* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,\n      we cannot change DECL_ASSEMBLER_NAME until we have installed this\n@@ -5213,11 +5294,6 @@ start_decl (declarator, declspecs, initialized, raises)\n       pop_obstacks ();\n     }\n \n-  /* Interesting work for this is done in `finish_exception_decl'.  */\n-  if (TREE_CODE (type) == RECORD_TYPE\n-      && CLASSTYPE_DECLARED_EXCEPTION (type))\n-    return decl;\n-\n   /* Corresponding pop_obstacks is done in `finish_decl'.  */\n   push_obstacks_nochange ();\n \n@@ -5258,9 +5334,6 @@ start_decl (declarator, declspecs, initialized, raises)\n           DECL_ARGUMENTS (decl) = args;\n         }\n       d = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n-      if (interface_unknown && flag_external_templates\n-\t  && ! DECL_IN_SYSTEM_HEADER (decl))\n-\twarn_if_unknown_interface ();\n       TREE_PUBLIC (d) = TREE_PUBLIC (decl);\n       TREE_STATIC (d) = TREE_STATIC (decl);\n       DECL_EXTERNAL (d) = (DECL_EXTERNAL (decl)\n@@ -5751,12 +5824,6 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t\t\t\tDECL_CONTEXT (decl) == NULL_TREE, 0);\n       goto finish_end;\n     }\n-  if (type != error_mark_node && IS_AGGR_TYPE (type)\n-      && CLASSTYPE_DECLARED_EXCEPTION (type))\n-    {\n-      CLASSTYPE_GOT_SEMICOLON (type) = 1;\n-      goto finish_end;\n-    }\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n       ttype = target_type (type);\n@@ -6158,7 +6225,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t  else if (toplev && ! TREE_PUBLIC (decl))\n \t    {\n \t      /* If this is a static const, change its apparent linkage\n-\t\t if it belongs to a #pragma interface.  */\n+\t         if it belongs to a #pragma interface.  */\n \t      if (!interface_unknown)\n \t\t{\n \t\t  TREE_PUBLIC (decl) = 1;\n@@ -6623,8 +6690,14 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       DECL_CLASS_CONTEXT (decl) = ctype;\n     }\n \n+  /* All function decls start out public; we'll fix their linkage later (at\n+     definition or EOF) if appropriate.  */\n+  TREE_PUBLIC (decl) = 1;\n+\n   if (publicp)\n-    TREE_PUBLIC (decl) = 1;\n+    ;\n+  else\n+    DECL_DECLARED_STATIC (decl) = 1;\n \n   DECL_EXTERNAL (decl) = 1;\n   if (quals != NULL_TREE && TREE_CODE (type) == FUNCTION_TYPE)\n@@ -6876,7 +6949,7 @@ build_ptrmemfunc_type (type)\n   t = make_lang_type (RECORD_TYPE);\n \n   /* Let the front-end know this is a pointer to member function. */\n-  TYPE_PTRMEMFUNC_FLAG(t) = 1;\n+  TYPE_PTRMEMFUNC_FLAG (t) = 1;\n   /* and not really an aggregate.  */\n   IS_AGGR_TYPE (t) = 0;\n \n@@ -6920,6 +6993,7 @@ build_ptrmemfunc_type (type)\n       try to parse.\n      PARM for a parameter declaration (either within a function prototype\n       or before a function body).  Make a PARM_DECL, or return void_type_node.\n+     CATCHPARM for a parameter declaration before a catch clause.\n      TYPENAME if for a typename (in a cast or sizeof).\n       Don't make a DECL node; just return the ..._TYPE node.\n      FIELD for a struct or union field; make a FIELD_DECL.\n@@ -6972,7 +7046,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n   int longlong = 0;\n   int constp;\n   int volatilep;\n-  int virtualp, friendp, inlinep, staticp;\n+  int virtualp, explicitp, friendp, inlinep, staticp;\n   int explicit_int = 0;\n   int explicit_char = 0;\n   int opaque_typedef = 0;\n@@ -7553,6 +7627,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n     warning (\"duplicate `volatile'\");\n #endif\n   virtualp = RIDBIT_SETP (RID_VIRTUAL, specbits);\n+  RIDBIT_RESET (RID_VIRTUAL, specbits);\n+  explicitp = RIDBIT_SETP (RID_EXPLICIT, specbits) != 0;\n+  RIDBIT_RESET (RID_EXPLICIT, specbits);\n \n   if (RIDBIT_SETP (RID_STATIC, specbits))\n     staticp = 1 + (decl_context == FIELD);\n@@ -7564,37 +7641,36 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       staticp = 0;\n     }\n   friendp = RIDBIT_SETP (RID_FRIEND, specbits);\n-  RIDBIT_RESET (RID_VIRTUAL, specbits);\n   RIDBIT_RESET (RID_FRIEND, specbits);\n \n   if (RIDBIT_SETP (RID_MUTABLE, specbits))\n     {\n       if (decl_context == PARM)\n \t{\n-\t  error (\"non-member `%s' cannot be declared mutable\", name);\n+\t  error (\"non-member `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n       else if (friendp || decl_context == TYPENAME)\n \t{\n-\t  error (\"non-object member `%s' cannot be declared mutable\", name);\n+\t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n       else if (staticp)\n \t{\n-\t  error (\"static `%s' cannot be declared mutable\", name);\n+\t  error (\"static `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n #if 0\n       if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n \t{\n-\t  error (\"non-object member `%s' cannot be declared mutable\", name);\n+\t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n       /* Because local typedefs are parsed twice, we don't want this\n \t message here. */\n       else if (decl_context != FIELD)\n \t{\n-\t  error (\"non-member `%s' cannot be declared mutable\", name);\n+\t  error (\"non-member `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n #endif\n@@ -7682,7 +7758,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n     error (\"multiple storage classes in declaration of `%s'\", name);\n   else if (decl_context != NORMAL && nclasses > 0)\n     {\n-      if (decl_context == PARM\n+      if ((decl_context == PARM || decl_context == CATCHPARM)\n \t  && (RIDBIT_SETP (RID_REGISTER, specbits)\n \t      || RIDBIT_SETP (RID_AUTO, specbits)))\n \t;\n@@ -7782,7 +7858,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t     op ? operator_name_string (tmp) : name);\n \t    }\n \t  else\n-\t    error ((decl_context == PARM\n+\t    error (((decl_context == PARM || decl_context == CATCHPARM)\n \t\t    ? \"storage class specified for parameter `%s'\"\n \t\t    : \"storage class specified for typename\"), name);\n \t  RIDBIT_RESET (RID_REGISTER, specbits);\n@@ -8107,6 +8183,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t  }\n \t\telse            /* it's a constructor. */\n \t\t  {\n+\t\t    if (explicitp == 1)\n+\t\t      explicitp = 2;\n \t\t    /* ANSI C++ June 5 1992 WP 12.1.2.  A constructor may\n \t\t       not be declared const or volatile.  A constructor may\n \t\t       not be virtual.  A constructor may not be static.  */\n@@ -8389,10 +8467,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t/* This is the `standard' use of the scoping operator:\n \t\t   basetype :: member .  */\n \n-\t\tif (TREE_CODE (type) == FUNCTION_TYPE)\n+\t\tif (ctype == current_class_type)\n+\t\t  cp_pedwarn (\"extra qualification `%T::' on member `%s' ignored\",\n+\t\t\t      ctype, name);\n+\t\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t\t  {\n \t\t    if (current_class_type == NULL_TREE\n-\t\t\t|| TYPE_MAIN_VARIANT (ctype) == current_class_type\n \t\t\t|| friendp)\n \t\t      type = build_cplus_method_type (build_type_variant (ctype, constp, volatilep),\n \t\t\t\t\t\t      TREE_TYPE (type), TYPE_ARG_TYPES (type));\n@@ -8403,19 +8483,14 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\treturn void_type_node;\n \t\t      }\n \t\t  }\n-\t\telse if (TYPE_MAIN_VARIANT (ctype) == current_class_type)\n-\t\t  {\n-\t\t    if (extra_warnings)\n-\t\t      cp_warning (\"redundant qualification `%T' on member `%s' ignored\",\n-\t\t\t\t  ctype, name);\n-\t\t    type = build_offset_type (ctype, type);\n-\t\t  }\n \t\telse if (TYPE_SIZE (ctype) != NULL_TREE\n \t\t\t || (RIDBIT_SETP (RID_TYPEDEF, specbits)))\n \t\t  {\n \t\t    tree t;\n \t\t    /* have to move this code elsewhere in this function.\n-\t\t       this code is used for i.e., typedef int A::M; M *pm; */\n+\t\t       this code is used for i.e., typedef int A::M; M *pm;\n+\n+\t\t       It is?  How? jason 10/2/94 */\n \n \t\t    if (explicit_int == -1 && decl_context == FIELD\n \t\t\t&& funcdef_flag == 0)\n@@ -8441,7 +8516,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\t\t/* Don't include destructor with constructors.  */\n \t\t\t\tt = DECL_CHAIN (TREE_VALUE (t));\n \t\t\t\tif (t == NULL_TREE)\n-\t\t\t\t  error (\"class `%s' does not have any constructors\", IDENTIFIER_POINTER (sname));\n+\t\t\t\t  cp_error (\"`%T' does not have any constructors\",\n+\t\t\t\t\t    ctype);\n \t\t\t\tt = build_tree_list (NULL_TREE, t);\n \t\t\t      }\n \t\t\t    t = build_lang_field_decl (FIELD_DECL, build_nt (SCOPE_REF, ctype, t), type);\n@@ -8456,15 +8532,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t\t    if (current_class_type)\n \t\t      {\n-\t\t\tif (TYPE_MAIN_VARIANT (ctype) != current_class_type)\n-\t\t\t  {\n-\t\t\t    cp_error (\"cannot declare member `%T::%s' within `%T'\",\n-\t\t\t\t   ctype, name, current_class_type);\n-\t\t\t    return void_type_node;\n-\t\t\t  }\n-\t\t\telse if (extra_warnings)\n-\t\t\t  cp_warning (\"extra qualification `%T' on member `%s' ignored\",\n-\t\t\t\t   ctype, name);\n+\t\t\tcp_error (\"cannot declare member `%T::%s' within `%T'\",\n+\t\t\t\t  ctype, name, current_class_type);\n+\t\t\treturn void_type_node;\n \t\t      }\n \t\t    type = build_offset_type (ctype, type);\n \t\t  }\n@@ -8526,6 +8596,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t}\n     }\n \n+  if (explicitp == 1)\n+    {\n+      error (\"only constructors can be declared `explicit'\");\n+      explicitp = 0;\n+    }\n+\n   /* Now TYPE has the actual type.  */\n \n   /* If this is declaring a typedef name, return a TYPE_DECL.  */\n@@ -8658,6 +8734,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       return type;\n     }\n   else if (declarator == NULL_TREE && decl_context != PARM\n+\t   && decl_context != CATCHPARM\n \t   && TREE_CODE (type) != UNION_TYPE\n \t   && ! bitfield)\n     {\n@@ -8803,6 +8880,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n \n+\t    if (explicitp == 2)\n+\t      DECL_NONCONVERTING_P (decl) = 1;\n+\n \t    DECL_INLINE (decl) = inlinep;\n \t  }\n \telse if (TREE_CODE (type) == METHOD_TYPE)\n@@ -8817,20 +8897,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t    DECL_INLINE (decl) = inlinep;\n \t  }\n-\telse if (TREE_CODE (type) == RECORD_TYPE\n-\t\t && CLASSTYPE_DECLARED_EXCEPTION (type))\n-\t  {\n-\t    /* Handle a class-local exception declaration.  */\n-\t    decl = build_lang_field_decl (VAR_DECL, declarator, type);\n-\t    if (ctype == NULL_TREE)\n-\t      ctype = current_class_type;\n-\t    return void_type_node;\n-\t  }\n \telse if (TYPE_SIZE (type) == NULL_TREE && !staticp\n \t\t && (TREE_CODE (type) != ARRAY_TYPE || initialized == 0))\n \t  {\n-\t    error (\"field `%s' has incomplete type\",\n-\t\t   IDENTIFIER_POINTER (declarator));\n+\t    cp_error (\"field `%D' has incomplete type\", declarator);\n \n \t    /* If we're instantiating a template, tell them which\n \t       instantiation made the field's type be incomplete.  */\n@@ -8839,9 +8909,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t&& IDENTIFIER_TEMPLATE (DECL_NAME (TYPE_NAME (current_class_type)))\n \t\t&& declspecs && TREE_VALUE (declspecs)\n \t\t&& TREE_TYPE (TREE_VALUE (declspecs)) == type)\n-\t      error (\"  in instantiation of template `%s'\",\n-\t\t     TYPE_NAME_STRING (current_class_type));\n-\t\t\n+\t      cp_error (\"  in instantiation of template `%T'\",\n+\t\t\tcurrent_class_type);\n+\n \t    type = error_mark_node;\n \t    decl = NULL_TREE;\n \t  }\n@@ -9062,6 +9132,31 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       {\n \t/* It's a variable.  */\n \n+\tif (decl_context == CATCHPARM)\n+\t  {\n+\t    if (ctype)\n+\t      {\n+\t\tctype = NULL_TREE;\n+\t\terror (\"cannot use `::' in parameter declaration\");\n+\t      }\n+\n+\t    /* A parameter declared as an array of T is really a pointer to T.\n+\t       One declared as a function is really a pointer to a function.\n+\t       One declared as a member is really a pointer to member.  */\n+\n+\t    if (TREE_CODE (type) == ARRAY_TYPE)\n+\t      {\n+\t\t/* Transfer const-ness of array into that of type pointed to. */\n+\t\ttype = build_pointer_type\n+\t\t  (cp_build_type_variant (TREE_TYPE (type), constp, volatilep));\n+\t\tvolatilep = constp = 0;\n+\t      }\n+\t    else if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t      type = build_pointer_type (type);\n+\t    else if (TREE_CODE (type) == OFFSET_TYPE)\n+\t      type = build_pointer_type (type);\n+\t  }\n+\n \t/* An uninitialized decl with `extern' is a reference.  */\n \tdecl = grokvardecl (type, declarator, specbits, initialized);\n \tbad_specifiers (decl, \"variable\", virtualp, quals != NULL_TREE,\n@@ -9850,7 +9945,6 @@ xref_tag (code_type_node, name, binfo, globalize)\n     {\n     case record_type:\n     case class_type:\n-    case exception_type:\n     case signature_type:\n       code = RECORD_TYPE;\n       len = list_length (binfo);\n@@ -9949,17 +10043,6 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t  if (flag_cadillac)\n \t    cadillac_start_enum (ref);\n \t}\n-      else if (tag_code == exception_type)\n-\t{\n-\t  ref = make_lang_type (code);\n-\t  /* Enable us to recognize when an exception type is created in\n-\t     class context.  To do nested classes correctly, this should\n-\t     probably be cleared out when we leave this class's scope.  */\n-\t  CLASSTYPE_DECLARED_EXCEPTION (ref) = 1;\n-\t  pushtag (name, ref, globalize);\n-\t  if (flag_cadillac)\n-\t    cadillac_start_struct (ref);\n-\t}\n       else\n \t{\n \t  struct binding_level *old_b = class_binding_level;\n@@ -9990,17 +10073,6 @@ xref_tag (code_type_node, name, binfo, globalize)\n     }\n   else\n     {\n-      if (IS_AGGR_TYPE_CODE (code))\n-\t{\n-\t  if (IS_AGGR_TYPE (ref)\n-\t      && ((tag_code == exception_type)\n-\t\t  != (CLASSTYPE_DECLARED_EXCEPTION (ref) == 1)))\n-\t    {\n-\t      cp_error (\"type `%T' is both exception and aggregate type\", ref);\n-\t      CLASSTYPE_DECLARED_EXCEPTION (ref) = (tag_code == exception_type);\n-\t    }\n-\t}\n-\n       /* If it no longer looks like a nested type, make sure it's\n \t in global scope.  */\n       if (b == global_binding_level && !class_binding_level\n@@ -10666,29 +10738,20 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n      (This does not mean `static' in the C sense!)  */\n   TREE_STATIC (decl1) = 1;\n \n-  /* Record the decl so that the function name is defined.\n-     If we already have a decl for this name, and it is a FUNCTION_DECL,\n-     use the old decl.  */\n-\n-  if (pre_parsed_p == 0)\n-    {\n-      current_function_decl = decl1 = pushdecl (decl1);\n-      DECL_MAIN_VARIANT (decl1) = decl1;\n-      fntype = TREE_TYPE (decl1);\n-    }\n-  else\n-    current_function_decl = decl1;\n-\n+  if (DECL_INTERFACE_KNOWN (decl1))\n+    /* We know.  */;\n   /* If this function belongs to an interface, it is public.\n      If it belongs to someone else's interface, it is also external.\n      It doesn't matter whether it's inline or not.  */\n-  if (interface_unknown == 0\n-      && ! TREE_PUBLIC (decl1))\n+  else if (interface_unknown == 0)\n     {\n-      TREE_PUBLIC (decl1) = 1;\n-      DECL_EXTERNAL (decl1)\n-\t= (interface_only\n-\t   || (DECL_INLINE (decl1) && ! flag_implement_inlines));\n+      if (DECL_DECLARED_STATIC (decl1) || DECL_TEMPLATE_INSTANTIATION (decl1))\n+\tDECL_EXTERNAL (decl1)\n+\t  = (interface_only\n+\t     || (DECL_INLINE (decl1) && ! flag_implement_inlines));\n+      else\n+\tDECL_EXTERNAL (decl1) = current_extern_inline;\n+      DECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n   else\n     {\n@@ -10698,12 +10761,32 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t defining how to inline.  So set DECL_EXTERNAL in that case.  */\n       DECL_EXTERNAL (decl1) = current_extern_inline;\n \n-      DECL_DEFER_OUTPUT (decl1)\n-\t= DECL_INLINE (decl1) && ! TREE_PUBLIC (decl1)\n-\t  && (DECL_FUNCTION_MEMBER_P (decl1)\n-\t      || DECL_TEMPLATE_INSTANTIATION (decl1));\n+      if (DECL_INLINE (decl1) && (DECL_FUNCTION_MEMBER_P (decl1)\n+\t\t\t\t  || DECL_TEMPLATE_INSTANTIATION (decl1)))\n+\t/* We know nothing yet */;\n+      else\n+\t{\n+\t  DECL_INTERFACE_KNOWN (decl1) = 1;\n+\t  if (DECL_DECLARED_STATIC (decl1))\n+\t    TREE_PUBLIC (decl1) = 0;\n+\t}\n+\n+      DECL_DEFER_OUTPUT (decl1) = ! DECL_INTERFACE_KNOWN (decl1);\n     }\n \n+  /* Record the decl so that the function name is defined.\n+     If we already have a decl for this name, and it is a FUNCTION_DECL,\n+     use the old decl.  */\n+\n+  if (pre_parsed_p == 0)\n+    {\n+      current_function_decl = decl1 = pushdecl (decl1);\n+      DECL_MAIN_VARIANT (decl1) = decl1;\n+      fntype = TREE_TYPE (decl1);\n+    }\n+  else\n+    current_function_decl = decl1;\n+\n   if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1))\n     {\n       if (TREE_CODE (fntype) == METHOD_TYPE)\n@@ -10716,18 +10799,6 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n     }\n   restype = TREE_TYPE (fntype);\n \n-  pushlevel (0);\n-  current_binding_level->parm_flag = 1;\n-\n-  /* Save the parm names or decls from this function's declarator\n-     where store_parm_decls will find them.  */\n-  current_function_parms = last_function_parms;\n-  current_function_parm_tags = last_function_parm_tags;\n-\n-  GNU_xref_function (decl1, current_function_parms);\n-\n-  make_function_rtl (decl1);\n-\n   if (ctype)\n     {\n       push_nested_class (ctype, 1);\n@@ -10777,6 +10848,18 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \tpush_memoized_context (0, 1);\n     }\n \n+  pushlevel (0);\n+  current_binding_level->parm_flag = 1;\n+\n+  /* Save the parm names or decls from this function's declarator\n+     where store_parm_decls will find them.  */\n+  current_function_parms = last_function_parms;\n+  current_function_parm_tags = last_function_parm_tags;\n+\n+  GNU_xref_function (decl1, current_function_parms);\n+\n+  make_function_rtl (decl1);\n+\n   /* Allocate further tree nodes temporarily during compilation\n      of this function only.  Tiemann moved up here from bottom of fn.  */\n   temporary_allocation ();\n@@ -10972,9 +11055,11 @@ store_parm_decls ()\n       if (flag_gc)\n \texpand_expr (build_function_call (lookup_name (get_identifier (\"__gc_main\"), 0), NULL_TREE),\n \t\t     0, VOIDmode, 0);\n-\n-      if (flag_dossier)\n+#if 0\n+      /* done at a differnet time */\n+      if (flag_rtti)\n \toutput_builtin_tdesc_entries ();\n+#endif\n     }\n }\n \n@@ -11043,9 +11128,10 @@ store_return_init (return_id, init)\n    constructors.  */\n \n void\n-finish_function (lineno, call_poplevel)\n+finish_function (lineno, call_poplevel, nested)\n      int lineno;\n      int call_poplevel;\n+     int nested;\n {\n   register tree fndecl = current_function_decl;\n   tree fntype, ctype = NULL_TREE;\n@@ -11072,7 +11158,7 @@ finish_function (lineno, call_poplevel)\n       store_parm_decls ();\n     }\n \n-  if (write_symbols != NO_DEBUG && TREE_CODE (fntype) != METHOD_TYPE)\n+  if (write_symbols != NO_DEBUG /*&& TREE_CODE (fntype) != METHOD_TYPE*/)\n     {\n       tree ttype = target_type (fntype);\n       tree parmdecl;\n@@ -11442,19 +11528,6 @@ finish_function (lineno, call_poplevel)\n       expand_label (no_return_label);\n     }\n \n-  /* reset scope for C++: if we were in the scope of a class,\n-     then when we finish this function, we are not longer so.\n-     This cannot be done until we know for sure that no more\n-     class members will ever be referenced in this function\n-     (i.e., calls to destructors).  */\n-  if (current_class_name)\n-    {\n-      ctype = current_class_type;\n-      pop_nested_class (1);\n-    }\n-  else\n-    pop_memoized_context (1);\n-\n   /* Generate rtl for function exit.  */\n   expand_function_end (input_filename, lineno, 1);\n \n@@ -11468,6 +11541,19 @@ finish_function (lineno, call_poplevel)\n     my_friendly_abort (122);\n   poplevel (1, 0, 1);\n \n+  /* reset scope for C++: if we were in the scope of a class,\n+     then when we finish this function, we are not longer so.\n+     This cannot be done until we know for sure that no more\n+     class members will ever be referenced in this function\n+     (i.e., calls to destructors).  */\n+  if (current_class_name)\n+    {\n+      ctype = current_class_type;\n+      pop_nested_class (1);\n+    }\n+  else\n+    pop_memoized_context (1);\n+\n   /* Must mark the RESULT_DECL as being in this function.  */\n   DECL_CONTEXT (DECL_RESULT (fndecl)) = DECL_INITIAL (fndecl);\n \n@@ -11554,7 +11640,8 @@ finish_function (lineno, call_poplevel)\n   /* Free all the tree nodes making up this function.  */\n   /* Switch back to allocating nodes permanently\n      until we start another function.  */\n-  permanent_allocation (1);\n+  if (! nested)\n+    permanent_allocation (1);\n \n   if (flag_cadillac)\n     cadillac_finish_function (fndecl);\n@@ -11802,7 +11889,9 @@ hack_incomplete_structures (type)\n \t\t\t    decl);\n \t      }\n \t  }\n+\t/*\n \tmy_friendly_assert (current_binding_level->n_incomplete > 0, 164);\n+\t*/\n \t--current_binding_level->n_incomplete;\n       }\n }\n@@ -11980,3 +12069,100 @@ id_in_current_class (id)\n {\n   return !!purpose_member (id, class_binding_level->class_shadowed);\n }\n+\n+struct cp_function\n+{\n+  int returns_value;\n+  int returns_null;\n+  int warn_about_return_type;\n+  int extern_inline;\n+  int assigns_this;\n+  int just_assigned_this;\n+  int parms_stored;\n+  tree named_labels;\n+  tree shadowed_labels;\n+  tree ctor_label;\n+  tree dtor_label;\n+  rtx result_rtx;\n+  struct cp_function *next;\n+  struct binding_level *binding_level;\n+};\n+\n+struct cp_function *cp_function_chain;\n+\n+/* Save and reinitialize the variables\n+   used during compilation of a C++ function.  */\n+\n+void\n+push_cp_function_context (toplev)\n+     int toplev;\n+{\n+  struct cp_function *p\n+    = (struct cp_function *) xmalloc (sizeof (struct cp_function));\n+\n+  push_function_context_to (toplev);\n+\n+  p->next = cp_function_chain;\n+  cp_function_chain = p;\n+\n+  p->named_labels = named_labels;\n+  p->shadowed_labels = shadowed_labels;\n+  p->returns_value = current_function_returns_value;\n+  p->returns_null = current_function_returns_null;\n+  p->warn_about_return_type = warn_about_return_type;\n+  p->extern_inline = current_extern_inline;\n+  p->binding_level = current_binding_level;\n+  p->ctor_label = ctor_label;\n+  p->dtor_label = dtor_label;\n+  p->assigns_this = current_function_assigns_this;\n+  p->just_assigned_this = current_function_just_assigned_this;\n+  p->parms_stored = current_function_parms_stored;\n+  p->result_rtx = original_result_rtx;\n+}\n+\n+/* Restore the variables used during compilation of a C++ function.  */\n+\n+void\n+pop_cp_function_context (toplev)\n+     int toplev;\n+{\n+  struct cp_function *p = cp_function_chain;\n+  tree link;\n+\n+  /* Bring back all the labels that were shadowed.  */\n+  for (link = shadowed_labels; link; link = TREE_CHAIN (link))\n+    if (DECL_NAME (TREE_VALUE (link)) != 0)\n+      SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (TREE_VALUE (link)),\n+\t\t\t\t  TREE_VALUE (link));\n+\n+#if 0\n+  if (DECL_SAVED_INSNS (current_function_decl) == 0)\n+    {\n+      /* Stop pointing to the local nodes about to be freed.  */\n+      /* But DECL_INITIAL must remain nonzero so we know this\n+\t was an actual function definition.  */\n+      DECL_INITIAL (current_function_decl) = error_mark_node;\n+      DECL_ARGUMENTS (current_function_decl) = 0;\n+    }\n+#endif\n+\n+  pop_function_context_from (toplev);\n+\n+  cp_function_chain = p->next;\n+\n+  named_labels = p->named_labels;\n+  shadowed_labels = p->shadowed_labels;\n+  current_function_returns_value = p->returns_value;\n+  current_function_returns_null = p->returns_null;\n+  warn_about_return_type = p->warn_about_return_type;\n+  current_extern_inline = p->extern_inline;\n+  current_binding_level = p->binding_level;\n+  ctor_label = p->ctor_label;\n+  dtor_label = p->dtor_label;\n+  current_function_assigns_this = p->assigns_this;\n+  current_function_just_assigned_this = p->just_assigned_this;\n+  current_function_parms_stored = p->parms_stored;\n+  original_result_rtx = p->result_rtx;\n+\n+  free (p);\n+}"}, {"sha": "d0dfe8aac8700d6070afe000cbae4e990a14b88c", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -22,6 +22,7 @@ enum decl_context\n { NORMAL,\t\t\t/* Ordinary declaration */\n   FUNCDEF,\t\t\t/* Function definition */\n   PARM,\t\t\t\t/* Declaration of parm before function body */\n+  CATCHPARM,\t\t\t/* Declaration of catch parm */\n   FIELD,\t\t\t/* Declaration inside struct or union */\n   BITFIELD,\t\t\t/* Likewise but with specified width */\n   TYPENAME,\t\t\t/* Typename (inside cast or sizeof)  */"}, {"sha": "49318707ddd1aa37cfa7ad4ab9ec66dc87a6328c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 87, "deletions": 75, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -301,9 +301,9 @@ int flag_cadillac;\n    that can be collected when they become garbage.  */\n int flag_gc;\n \n-/* Controls whether compiler generates 'dossiers' that give\n+/* Controls whether compiler generates 'type descriptor' that give\n    run-time type information.  */\n-int flag_dossier;\n+int flag_rtti = 0;\n \n /* Nonzero if we wish to output cross-referencing information\n    for the GNU class browser.  */\n@@ -365,7 +365,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"dollars-in-identifiers\", &dollars_in_ident, 1},\n   {\"enum-int-equiv\", &flag_int_enum_equivalence, 1},\n   {\"gc\", &flag_gc, 1},\n-  {\"dossier\", &flag_dossier, 1},\n+  {\"rtti\", &flag_rtti, 1},\n   {\"xref\", &flag_gnu_xref, 1},\n   {\"nonnull-objects\", &flag_assume_nonnull_objects, 1},\n   {\"implement-inlines\", &flag_implement_inlines, 1},\n@@ -442,14 +442,14 @@ lang_decode_option (p)\n \t{\n \t  flag_gc = 1;\n \t  /* This must come along for the ride.  */\n-\t  flag_dossier = 1;\n+\t  flag_rtti = 1;\n \t  found = 1;\n \t}\n       else if (! strcmp (p, \"no-gc\"))\n \t{\n \t  flag_gc = 0;\n \t  /* This must come along for the ride.  */\n-\t  flag_dossier = 0;\n+\t  flag_rtti = 0;\n \t  found = 1;\n \t}\n       else if (! strcmp (p, \"alt-external-templates\"))\n@@ -707,15 +707,10 @@ grok_x_components (specs, components)\n \t    tcode = class_type_node;\n \t  else if (IS_SIGNATURE(t))\n \t    tcode = signature_type_node;\n-\t  else if (CLASSTYPE_DECLARED_EXCEPTION(t))\n-\t    tcode = exception_type_node;\n \t  \n \t  t = xref_defn_tag(tcode, TYPE_IDENTIFIER(t), NULL_TREE);\n \t  if (TYPE_CONTEXT(t))\n \t    CLASSTYPE_NO_GLOBALIZE(t) = 1;\n-\t  if (TYPE_LANG_SPECIFIC (t)\n-\t      && CLASSTYPE_DECLARED_EXCEPTION (t))\n-\t    shadow_tag (specs);\n \t  return NULL_TREE;\n \t  break;\n \n@@ -2170,7 +2165,9 @@ finish_table (name, type, init, publicp)\n   if (TREE_VALUE (init) == integer_zero_node\n       && TREE_CHAIN (init) == NULL_TREE)\n     {\n+#if 0\n       if (empty_table == NULL_TREE)\n+#endif\n \t{\n \t  empty_table = get_temp_name (atype, 1);\n \t  init = build (CONSTRUCTOR, atype, NULL_TREE, init);\n@@ -2347,9 +2344,6 @@ mark_vtable_entries (decl)\n {\n   tree entries = TREE_CHAIN (CONSTRUCTOR_ELTS (DECL_INITIAL (decl)));\n \n-  if (flag_dossier)\n-    entries = TREE_CHAIN (entries);\n-\n   for (; entries; entries = TREE_CHAIN (entries))\n     {\n       tree fnaddr = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries));\n@@ -2439,14 +2433,18 @@ finish_vtable_vardecl (prev, vars)\n \n       /* Stuff this virtual function table's size into\n \t `pfn' slot of `the_null_vtable_entry'.  */\n+#if 0\n+      /* we do not put size as first entry any more */\n       tree nelts = array_type_nelts (TREE_TYPE (vars));\n       if (flag_vtable_thunks)\n \tTREE_VALUE (CONSTRUCTOR_ELTS (DECL_INITIAL (vars))) = nelts;\n       else\n \tSET_FNADDR_FROM_VTABLE_ENTRY (the_null_vtable_entry, nelts);\n-      /* Kick out the dossier before writing out the vtable.  */\n-      if (flag_dossier)\n-\trest_of_decl_compilation (TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (TREE_CHAIN (CONSTRUCTOR_ELTS (DECL_INITIAL (vars))))), 0), 0, 1, 1);\n+#endif\n+\n+      /* Kick out the type descriptor before writing out the vtable.  */\n+      if (flag_rtti)\n+\trest_of_decl_compilation (TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (CONSTRUCTOR_ELTS (DECL_INITIAL (vars)))), 0), 0, 1, 1);\n \n       /* Write it out.  */\n       mark_vtable_entries (vars);\n@@ -2565,30 +2563,32 @@ void\n import_export_inline (decl)\n      tree decl;\n {\n-  if (TREE_PUBLIC (decl))\n+  if (DECL_INTERFACE_KNOWN (decl))\n     return;\n \n-  /* If an explicit instantiation doesn't have TREE_PUBLIC set, it was with\n-     'extern'.  */\n-  if (DECL_EXPLICIT_INSTANTIATION (decl)\n-      || (DECL_IMPLICIT_INSTANTIATION (decl) && ! flag_implicit_templates))\n+  if (DECL_TEMPLATE_INSTANTIATION (decl))\n     {\n-      TREE_PUBLIC (decl) = 1;\n-      DECL_EXTERNAL (decl) = 1;\n+      if (DECL_IMPLICIT_INSTANTIATION (decl) && flag_implicit_templates)\n+\tTREE_PUBLIC (decl) = 0;\n+      else\n+\tDECL_EXTERNAL (decl) = 1;\n     }\n   else if (DECL_FUNCTION_MEMBER_P (decl))\n     {\n       tree ctype = DECL_CLASS_CONTEXT (decl);\n       if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n \t{\n-\t  TREE_PUBLIC (decl) = 1;\n \t  DECL_EXTERNAL (decl)\n \t    = (CLASSTYPE_INTERFACE_ONLY (ctype)\n \t       || (DECL_INLINE (decl) && ! flag_implement_inlines));\n \t}\n+      else\n+\tTREE_PUBLIC (decl) = 0;\n     }\n+  else\n+    TREE_PUBLIC (decl) = 0;\n }\n-  \n+\n extern int parse_time, varconst_time;\n \n #define TIMEVAR(VAR, BODY)    \\\n@@ -2693,7 +2693,7 @@ finish_file ()\n   poplevel (1, 0, 0);\n   pop_momentary ();\n \n-  finish_function (lineno, 0);\n+  finish_function (lineno, 0, 0);\n \n   assemble_destructor (IDENTIFIER_POINTER (fnname));\n \n@@ -2818,7 +2818,7 @@ finish_file ()\n       poplevel (1, 0, 0);\n       pop_momentary ();\n \n-      finish_function (lineno, 0);\n+      finish_function (lineno, 0, 0);\n       assemble_constructor (IDENTIFIER_POINTER (fnname));\n     }\n \n@@ -2871,74 +2871,86 @@ finish_file ()\n   pushdecl (vars);\n #endif\n \n+  interface_unknown = 1;\n+  interface_only = 0;\n+\n+  for (vars = saved_inlines; vars; vars = TREE_CHAIN (vars))\n+    {\n+      tree decl = TREE_VALUE (vars);\n+\n+      if (DECL_ARTIFICIAL (decl)\n+\t  && ! DECL_INITIAL (decl)\n+\t  && (TREE_USED (decl) || ! DECL_EXTERNAL (decl)))\n+\tsynthesize_method (decl);\n+    }\n+\n   walk_vtables ((void (*)())0, finish_vtable_vardecl);\n   if (flag_handle_signatures)\n     walk_sigtables ((void (*)())0, finish_sigtable_vardecl);\n \n+  for (vars = saved_inlines; vars; vars = TREE_CHAIN (vars))\n+    {\n+      tree decl = TREE_VALUE (vars);\n+\n+      if (DECL_ARTIFICIAL (decl)\n+\t  && ! DECL_INITIAL (decl)\n+\t  && TREE_USED (decl))\n+\tsynthesize_method (decl);\n+    }\n+\n   for (vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n     {\n       if (TREE_CODE (vars) == THUNK_DECL)\n \temit_thunk (vars);\n+      else if (TREE_CODE (vars) == FUNCTION_DECL\n+\t       && ! DECL_INTERFACE_KNOWN (vars)\n+\t       && DECL_DECLARED_STATIC (vars))\n+\tTREE_PUBLIC (vars) = 0;\n     }\n \n+  /* Now write out inline functions which had their addresses taken and\n+     which were not declared virtual and which were not declared `extern\n+     inline'.  */\n   {\n-    int reconsider = 0;\t\t/* More may be referenced; check again */\n-    tree delayed = NULL_TREE;\t/* These might be referenced later */\n+    int reconsider = 1;\t\t/* More may be referenced; check again */\n+    saved_inlines = tree_cons (NULL_TREE, NULL_TREE, saved_inlines);\n \n-    /* Now write out inline functions which had their addresses taken and\n-       which were not declared virtual and which were not declared `extern\n-       inline'.  */\n-    while (saved_inlines)\n+    while (reconsider)\n       {\n-\ttree decl = TREE_VALUE (saved_inlines);\n-\tsaved_inlines = TREE_CHAIN (saved_inlines);\n-\t/* Redefinition of a member function can cause DECL_SAVED_INSNS to be\n-\t   0; don't crash.  */\n-\tif (TREE_ASM_WRITTEN (decl) || DECL_SAVED_INSNS (decl) == 0)\n-\t  continue;\n-\timport_export_inline (decl);\n-\tif (TREE_PUBLIC (decl)\n-\t    || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n-\t    || flag_keep_inline_functions)\n+\ttree last = saved_inlines;\n+\ttree place = TREE_CHAIN (saved_inlines);\n+\treconsider = 0;\n+\n+\tfor (; place; place = TREE_CHAIN (place))\n \t  {\n-\t    if (DECL_EXTERNAL (decl))\n-\t      assemble_external (decl);\n-\t    else\n+\t    tree decl = TREE_VALUE (place);\n+\n+\t    if (TREE_ASM_WRITTEN (decl) || DECL_SAVED_INSNS (decl) == 0)\n \t      {\n-\t\treconsider = 1;\n-\t\ttemporary_allocation ();\n-\t\toutput_inline_function (decl);\n-\t\tpermanent_allocation (1);\n+\t\tTREE_CHAIN (last) = TREE_CHAIN (place);\n+\t\tcontinue;\n \t      }\n-\t  }\n-\telse if (TREE_USED (decl)\n-\t\t || TREE_USED (DECL_ASSEMBLER_NAME (decl)))\n-\t  delayed = tree_cons (NULL_TREE, decl, delayed);\n-      }\n-\n-    if (reconsider && delayed)\n-      {\n-\twhile (reconsider)\n-\t  {\n-\t    tree place;\n-\t    reconsider = 0;\n-\t    for (place = delayed; place; place = TREE_CHAIN (place))\n+\t    import_export_inline (decl);\n+\t    if (TREE_PUBLIC (decl)\n+\t\t|| TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n+\t\t|| flag_keep_inline_functions)\n \t      {\n-\t\ttree decl = TREE_VALUE (place);\n-\t\tif (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n-\t\t    && ! TREE_ASM_WRITTEN (decl))\n+\t\tTREE_CHAIN (last) = TREE_CHAIN (place);\n+\n+\t\tif (DECL_EXTERNAL (decl))\n+\t\t  assemble_external (decl);\n+\t\telse\n \t\t  {\n-\t\t    if (DECL_EXTERNAL (decl))\n-\t\t      assemble_external (decl);\n-\t\t    else\n-\t\t      {\n-\t\t\treconsider = 1;\n-\t\t\ttemporary_allocation ();\n-\t\t\toutput_inline_function (decl);\n-\t\t\tpermanent_allocation (1);\n-\t\t      }\n+\t\t    reconsider = 1;\n+\t\t    temporary_allocation ();\n+\t\t    output_inline_function (decl);\n+\t\t    permanent_allocation (1);\n \t\t  }\n+\n+\t\tcontinue;\n \t      }\n+\n+\t    last = place;\n \t  }\n       }\n   }"}, {"sha": "4d6ac7372f8aa14cee28e15597c30837ffdade14", "filename": "gcc/cp/except.c", "status": "modified", "additions": 115, "deletions": 62, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -43,6 +43,9 @@ tree builtin_return_address_fndecl;\n #define TRY_NEW_EH\n #endif\n #endif\n+#if defined(__i386) || defined(__rs6000) || defined(__hppa)\n+#define TRY_NEW_EH\n+#endif\n #endif\n \n #ifndef TRY_NEW_EH\n@@ -188,60 +191,6 @@ easy_expand_asm (str)\n   expand_asm (build_string (strlen (str)+1, str));\n }\n \n-/* unwind the stack. */\n-static void\n-do_unwind (throw_label)\n-     rtx throw_label;\n-{\n-#ifdef sparc\n-  extern FILE *asm_out_file;\n-  tree fcall;\n-  tree params;\n-  rtx return_val_rtx;\n-\n-  /* call to  __builtin_return_address () */\n-  params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n-  fcall = build_function_call (BuiltinReturnAddress, params);\n-  return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n-  /* In the return, the new pc is pc+8, as the value comming in is\n-     really the address of the call insn, not the next insn.  */\n-  emit_move_insn (return_val_rtx, plus_constant(gen_rtx (LABEL_REF,\n-\t\t\t\t\t\t\t Pmode,\n-\t\t\t\t\t\t\t throw_label), -8));\n-  /* We use three values, PC, type, and value */\n-  easy_expand_asm (\"st %l0,[%fp]\");\n-  easy_expand_asm (\"st %l1,[%fp+4]\");\n-  easy_expand_asm (\"st %l2,[%fp+8]\");\n-  easy_expand_asm (\"ret\");\n-  easy_expand_asm (\"restore\");\n-  emit_barrier ();\n-#endif\n-#if m88k\n-  rtx temp_frame = frame_pointer_rtx;\n-\n-  temp_frame = memory_address (Pmode, temp_frame);\n-  temp_frame = copy_to_reg (gen_rtx (MEM, Pmode, temp_frame));\n-\n-  /* hopefully this will successfully pop the frame! */\n-  emit_move_insn (frame_pointer_rtx, temp_frame);\n-  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-  emit_move_insn (arg_pointer_rtx, frame_pointer_rtx);\n-  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (stack_pointer_rtx, 0))));\n-\n-#if 0\n-  emit_insn (gen_add2_insn (arg_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t   -(HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n-\n-  emit_move_insn (stack_pointer_rtx, arg_pointer_rtx);\n-\n-  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n-#endif\n-#endif\n-}\n-\n-\n \n #if 0\n /* This is the startup, and finish stuff per exception table. */\n@@ -834,10 +783,26 @@ init_exception_processing ()\n \n   pop_lang_context ();\n   throw_label = gen_label_rtx ();\n+#ifdef sparc\n   saved_pc = gen_rtx (REG, Pmode, 16);\n   saved_throw_type = gen_rtx (REG, Pmode, 17);\n   saved_throw_value = gen_rtx (REG, Pmode, 18);\n-\n+#endif\n+#ifdef __i386\n+  saved_pc = gen_rtx (REG, Pmode, 3);\n+  saved_throw_type = gen_rtx (REG, Pmode, 4);\n+  saved_throw_value = gen_rtx (REG, Pmode, 5);\n+#endif\n+#ifdef __rs6000\n+  saved_pc = gen_rtx (REG, Pmode, 12);\n+  saved_throw_type = gen_rtx (REG, Pmode, 13);\n+  saved_throw_value = gen_rtx (REG, Pmode, 14);\n+#endif\n+#ifdef __hppa\n+  saved_pc = gen_rtx (REG, Pmode, 5);\n+  saved_throw_type = gen_rtx (REG, Pmode, 6);\n+  saved_throw_value = gen_rtx (REG, Pmode, 7);\n+#endif\n   new_eh_queue (&ehqueue);\n   new_eh_queue (&eh_table_output_queue);\n   new_eh_stack (&ehstack);\n@@ -1112,7 +1077,7 @@ expand_start_catch_block (declspecs, declarator)\n   if (declspecs)\n     {\n       tree init_type;\n-      decl = grokdeclarator (declarator, declspecs, NORMAL, 1, NULL_TREE);\n+      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n \n       /* Figure out the type that the initializer is. */\n       init_type = TREE_TYPE (decl);\n@@ -1247,6 +1212,82 @@ do_function_call (func, params, return_type)\n   return NULL_RTX;\n }\n \n+/* unwind the stack. */\n+static void\n+do_unwind (throw_label)\n+     rtx throw_label;\n+{\n+#ifdef sparc\n+  extern FILE *asm_out_file;\n+  tree fcall;\n+  tree params;\n+  rtx return_val_rtx;\n+\n+  /* call to  __builtin_return_address () */\n+  params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  fcall = build_function_call (BuiltinReturnAddress, params);\n+  return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n+  /* In the return, the new pc is pc+8, as the value comming in is\n+     really the address of the call insn, not the next insn.  */\n+  emit_move_insn (return_val_rtx, plus_constant(gen_rtx (LABEL_REF,\n+\t\t\t\t\t\t\t Pmode,\n+\t\t\t\t\t\t\t throw_label), -8));\n+  /* We use three values, PC, type, and value */\n+  easy_expand_asm (\"st %l0,[%fp]\");\n+  easy_expand_asm (\"st %l1,[%fp+4]\");\n+  easy_expand_asm (\"st %l2,[%fp+8]\");\n+  easy_expand_asm (\"ret\");\n+  easy_expand_asm (\"restore\");\n+  emit_barrier ();\n+#endif\n+#if defined(__i386) || defined(__rs6000) || defined(__hppa)\n+  extern FILE *asm_out_file;\n+  tree fcall;\n+  tree params;\n+  rtx return_val_rtx;\n+\n+  /* call to  __builtin_return_address () */\n+  params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n+  fcall = build_function_call (BuiltinReturnAddress, params);\n+  return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n+#if 0\n+  /* I would like to do this here, but doesn't seem to work. */\n+  emit_move_insn (return_val_rtx, gen_rtx (LABEL_REF,\n+\t\t\t\t\t   Pmode,\n+\t\t\t\t\t   throw_label));\n+  /* So, for now, just pass throw label to stack unwinder. */\n+#endif\n+  /* We use three values, PC, type, and value */\n+  params = tree_cons (NULL_TREE, make_tree (ptr_type_node,\n+\t\t\t\t\t    gen_rtx (LABEL_REF, Pmode, throw_label)), NULL_TREE);\n+  \n+  do_function_call (Unwind, params, NULL_TREE);\n+  emit_barrier ();\n+#endif\n+#if m88k\n+  rtx temp_frame = frame_pointer_rtx;\n+\n+  temp_frame = memory_address (Pmode, temp_frame);\n+  temp_frame = copy_to_reg (gen_rtx (MEM, Pmode, temp_frame));\n+\n+  /* hopefully this will successfully pop the frame! */\n+  emit_move_insn (frame_pointer_rtx, temp_frame);\n+  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+  emit_move_insn (arg_pointer_rtx, frame_pointer_rtx);\n+  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (stack_pointer_rtx, 0))));\n+\n+#if 0\n+  emit_insn (gen_add2_insn (arg_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t\t   -(HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n+\n+  emit_move_insn (stack_pointer_rtx, arg_pointer_rtx);\n+\n+  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n+#endif\n+#endif\n+}\n \n /* is called from expand_excpetion_blocks () to generate the code in a function\n    to \"throw\" if anything in the function needs to preform a throw.\n@@ -1306,6 +1347,12 @@ expand_builtin_throw ()\n \n   emit_jump_insn (gen_beq (gotta_call_terminate));\n \n+#ifndef sparc\n+  /* On the SPARC, __builtin_return_address is already -8, no need to\n+     subtract any more from it. */\n+  emit_insn (gen_add2_insn (return_val_rtx, GEN_INT (-1)));\n+#endif\n+\n   /* yes it did */\n   emit_move_insn (saved_pc, return_val_rtx);\n   do_unwind (throw_label);\n@@ -1344,7 +1391,8 @@ expand_exception_blocks ()\n   {\n     static int have_done = 0;\n     if (! have_done && TREE_PUBLIC (current_function_decl)\n-\t&& ! DECL_INLINE (current_function_decl))\n+\t&& DECL_INTERFACE_KNOWN (current_function_decl)\n+\t&& ! DECL_EXTERNAL (current_function_decl))\n       {\n \thave_done = 1;\n \texpand_builtin_throw ();\n@@ -1394,7 +1442,7 @@ expand_throw (exp)\n \trtx throw_value_rtx;\n \n \temit_move_insn (saved_throw_type, throw_type_rtx);\n-\texp = convert_to_reference (build_reference_type (build_type_variant (TREE_TYPE (exp), 1, 0)), exp, CONV_STATIC, LOOKUP_COMPLAIN, NULL_TREE);\n+\texp = convert_to_reference (build_reference_type (build_type_variant (TREE_TYPE (exp), 1, 0)), exp, CONV_STATIC, LOOKUP_COMPLAIN, error_mark_node);\n \tif (exp == error_mark_node)\n \t  error (\"  in thrown expression\");\n \tthrow_value_rtx = expand_expr (build_unary_op (ADDR_EXPR, exp, 0), NULL_RTX, VOIDmode, 0);\n@@ -1437,7 +1485,8 @@ build_exception_table ()\n \t /* Beginning marker for table. */\n \t ASM_OUTPUT_ALIGN (asm_out_file, 2);\n \t ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_TABLE__\");\n-\t fprintf (asm_out_file, \"        .word   0, 0, 0\\n\");\n+\t output_exception_table_entry (asm_out_file,\n+\t\t\t\t       const0_rtx, const0_rtx, const0_rtx);\n        }\n      count++;\n      output_exception_table_entry (asm_out_file,\n@@ -1449,7 +1498,8 @@ build_exception_table ()\n     {\n       /* Ending marker for table. */\n       ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_END__\");\n-      fprintf (asm_out_file, \"        .word   -1, -1, -1\\n\");\n+      output_exception_table_entry (asm_out_file,\n+\t\t\t\t    constm1_rtx, constm1_rtx, constm1_rtx);\n     }\n \n #endif /* TRY_NEW_EH */\n@@ -1472,7 +1522,10 @@ tree\n build_throw (e)\n      tree e;\n {\n-  e = build1 (THROW_EXPR, void_type_node, e);\n-  TREE_SIDE_EFFECTS (e) = 1;\n+  if (e != error_mark_node)\n+    {\n+      e = build1 (THROW_EXPR, void_type_node, e);\n+      TREE_SIDE_EFFECTS (e) = 1;\n+    }\n   return e;\n }"}, {"sha": "2ed6f80d3044ebdbd98c50da12c9dea62019df20", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -27,14 +27,19 @@ __volatile, TYPE_QUAL, RID_VOLATILE\n __volatile__, TYPE_QUAL, RID_VOLATILE\n __wchar_t, TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,\n asm, ASM_KEYWORD, NORID,\n+and, ANDAND, NORID,\n+and_eq, ASSIGN, NORID,\n auto, SCSPEC, RID_AUTO,\n+bitand, '&', NORID,\n+bitor, '|', NORID,\n bool, TYPESPEC, RID_BOOL,\n break, BREAK, NORID,\n case, CASE, NORID,\n catch, CATCH, NORID,\n char, TYPESPEC, RID_CHAR,\n class, AGGR, RID_CLASS,\n classof, CLASSOF, NORID,\n+compl, '~', NORID,\n const, TYPE_QUAL, RID_CONST,\n const_cast, CONST_CAST, NORID,\n continue, CONTINUE, NORID,\n@@ -45,6 +50,7 @@ double, TYPESPEC, RID_DOUBLE,\n dynamic_cast, DYNAMIC_CAST, NORID,\n else, ELSE, NORID,\n enum, ENUM, NORID,\n+explicit, SCSPEC, RID_EXPLICIT,\n extern, SCSPEC, RID_EXTERN,\n false, CXX_FALSE, NORID,\n float, TYPESPEC, RID_FLOAT,\n@@ -57,8 +63,13 @@ inline, SCSPEC, RID_INLINE,\n int, TYPESPEC, RID_INT,\n long, TYPESPEC, RID_LONG,\n mutable, SCSPEC, RID_MUTABLE,\n+namespace, NAMESPACE, NORID,\n new, NEW, NORID,\n+not, '!', NORID,\n+not_eq, EQCOMPARE, NORID,\n operator, OPERATOR, NORID,\n+or, OROR, NORID,\n+or_eq, ASSIGN, NORID,\n overload, OVERLOAD, NORID,\n private, VISSPEC, RID_PRIVATE,\n protected, VISSPEC, RID_PROTECTED,\n@@ -75,17 +86,21 @@ static, SCSPEC, RID_STATIC,\n static_cast, STATIC_CAST, NORID,\n struct, AGGR, RID_RECORD,\n switch, SWITCH, NORID,\n+template, TEMPLATE, RID_TEMPLATE,\n this, THIS, NORID,\n throw, THROW, NORID,\n-template, TEMPLATE, RID_TEMPLATE,\n true, CXX_TRUE, NORID,\n try, TRY, NORID,\n typedef, SCSPEC, RID_TYPEDEF,\n-typeof, TYPEOF, NORID,\n+typename, TYPENAME_KEYWORD, NORID,\n typeid, TYPEID, NORID,\n+typeof, TYPEOF, NORID,\n union, AGGR, RID_UNION,\n unsigned, TYPESPEC, RID_UNSIGNED,\n+using, USING, NORID,\n virtual, SCSPEC, RID_VIRTUAL,\n void, TYPESPEC, RID_VOID,\n volatile, TYPE_QUAL, RID_VOLATILE,\n while, WHILE, NORID,\n+xor, '^', NORID,\n+xor_eq, ASSIGN, NORID,"}, {"sha": "fc9157cc9e2a852d04a469630e08d0ccbc971ca8", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -1185,7 +1185,7 @@ On an rs6000, xlC stores exception objects on that stack, under the try\n block.  When is unwinds down into a handler, the frame pointer is\n adjusted back to the normal value for the frame in which the handler\n resides, and the stack pointer is left unchanged from the time at which\n-the object was throwed.  This is so that there is always someplace for\n+the object was thrown.  This is so that there is always someplace for\n the exception object, and nothing can overwrite it, once we start\n throwing.  The only bad part, is that the stack remains large.\n "}, {"sha": "6f6a97ad85dc4396c68db686f721790cde1ad1bc", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 119, "deletions": 95, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -1,14 +1,14 @@\n /* C code produced by gperf version 2.5 (GNU C++ version) */\n-/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ /deneb/blob/jason/g++/small/devo/gcc/cp/gxx.gperf  */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../devo/gcc/cp/gxx.gperf  */\n /* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 86\n+#define TOTAL_KEYWORDS 101\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 171\n-/* maximum key range = 168, duplicates = 0 */\n+#define MAX_HASH_VALUE 210\n+/* maximum key range = 207, duplicates = 0 */\n \n #ifdef __GNUC__\n inline\n@@ -20,19 +20,19 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172, 172, 172, 172, 172, 172,\n-     172, 172, 172, 172, 172,   0, 172,  36,   1,  61,\n-       0,   0,  30,  44,  44,  35, 172,   7,  12,  53,\n-      40,  17,   6, 172,  28,   2,   4,  35,  31,  51,\n-       5,   7, 172, 172, 172, 172, 172, 172,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211, 211, 211, 211, 211, 211,\n+     211, 211, 211, 211, 211,   0, 211,  35,   1,  69,\n+      61,   0,  19,  65,  20, 100, 211,   5,  11,  52,\n+       3,  25,   6,   2,  31,  26,   4,  41,  24,  64,\n+      10,  24, 211, 211, 211, 211, 211, 211,\n     };\n   register int hval = len;\n \n@@ -65,120 +65,144 @@ is_reserved_word (str, len)\n     {\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"else\",  ELSE, NORID,},\n-      {\"\",}, \n-      {\"delete\",  DELETE, NORID,},\n-      {\"double\",  TYPESPEC, RID_DOUBLE,},\n+      {\"\",}, {\"\",}, {\"\",}, \n       {\"true\",  CXX_TRUE, NORID,},\n-      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n-      {\"typeid\",  TYPEID, NORID,},\n-      {\"\",}, \n-      {\"this\",  THIS, NORID,},\n+      {\"extern\",  SCSPEC, RID_EXTERN,},\n+      {\"not\",  '!', NORID,},\n+      {\"not_eq\",  EQCOMPARE, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"__inline\",  SCSPEC, RID_INLINE},\n       {\"\",}, \n-      {\"try\",  TRY, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"do\",  DO, NORID,},\n+      {\"__inline__\",  SCSPEC, RID_INLINE},\n       {\"\",}, \n-      {\"static_cast\",  STATIC_CAST, NORID,},\n+      {\"xor_eq\",  ASSIGN, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, \n       {\"template\",  TEMPLATE, RID_TEMPLATE,},\n-      {\"protected\",  VISSPEC, RID_PROTECTED,},\n+      {\"\",}, {\"\",}, \n+      {\"__alignof__\",  ALIGNOF, NORID},\n+      {\"__extension__\",  EXTENSION, NORID},\n+      {\"bool\",  TYPESPEC, RID_BOOL,},\n       {\"\",}, \n-      {\"__classof__\",  CLASSOF, NORID},\n+      {\"typeof\",  TYPEOF, NORID,},\n+      {\"\",}, \n+      {\"try\",  TRY, NORID,},\n+      {\"or_eq\",  ASSIGN, NORID,},\n+      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n       {\"\",}, \n       {\"__headof__\",  HEADOF, NORID},\n       {\"\",}, \n-      {\"bool\",  TYPESPEC, RID_BOOL,},\n+      {\"private\",  VISSPEC, RID_PRIVATE,},\n       {\"__const__\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n       {\"__const\",  TYPE_QUAL, RID_CONST},\n       {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"__typeof__\",  TYPEOF, NORID},\n-      {\"void\",  TYPESPEC, RID_VOID,},\n-      {\"friend\",  SCSPEC, RID_FRIEND,},\n+      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"and_eq\",  ASSIGN, NORID,},\n+      {\"xor\",  '^', NORID,},\n+      {\"static_cast\",  STATIC_CAST, NORID,},\n+      {\"break\",  BREAK, NORID,},\n+      {\"namespace\",  NAMESPACE, NORID,},\n+      {\"__classof__\",  CLASSOF, NORID},\n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n       {\"false\",  CXX_FALSE, NORID,},\n       {\"sizeof\",  SIZEOF, NORID,},\n-      {\"short\",  TYPESPEC, RID_SHORT,},\n-      {\"typeof\",  TYPEOF, NORID,},\n-      {\"\",}, \n-      {\"int\",  TYPESPEC, RID_INT,},\n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n-      {\"private\",  VISSPEC, RID_PRIVATE,},\n-      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n-      {\"extern\",  SCSPEC, RID_EXTERN,},\n-      {\"struct\",  AGGR, RID_RECORD,},\n-      {\"signed\",  TYPESPEC, RID_SIGNED,},\n-      {\"break\",  BREAK, NORID,},\n-      {\"__attribute\",  ATTRIBUTE, NORID},\n-      {\"default\",  DEFAULT, NORID,},\n-      {\"__attribute__\",  ATTRIBUTE, NORID},\n-      {\"__classof\",  CLASSOF, NORID},\n-      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n       {\"__headof\",  HEADOF, NORID},\n-      {\"switch\",  SWITCH, NORID,},\n-      {\"__label__\",  LABEL, NORID},\n-      {\"__extension__\",  EXTENSION, NORID},\n-      {\"\",}, \n-      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n       {\"for\",  FOR, NORID,},\n-      {\"__typeof\",  TYPEOF, NORID},\n-      {\"__alignof__\",  ALIGNOF, NORID},\n       {\"\",}, \n-      {\"case\",  CASE, NORID,},\n+      {\"__label__\",  LABEL, NORID},\n+      {\"switch\",  SWITCH, NORID,},\n       {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n-      {\"if\",  IF, NORID,},\n-      {\"while\",  WHILE, NORID,},\n+      {\"or\",  OROR, NORID,},\n+      {\"__typeof__\",  TYPEOF, NORID},\n+      {\"this\",  THIS, NORID,},\n       {\"\",}, \n-      {\"class\",  AGGR, RID_CLASS,},\n-      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n-      {\"const\",  TYPE_QUAL, RID_CONST,},\n-      {\"static\",  SCSPEC, RID_STATIC,},\n-      {\"auto\",  SCSPEC, RID_AUTO,},\n+      {\"bitor\",  '|', NORID,},\n       {\"float\",  TYPESPEC, RID_FLOAT,},\n-      {\"inline\",  SCSPEC, RID_INLINE,},\n-      {\"throw\",  THROW, NORID,},\n-      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n+      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n+      {\"__classof\",  CLASSOF, NORID},\n+      {\"short\",  TYPESPEC, RID_SHORT,},\n+      {\"delete\",  DELETE, NORID,},\n+      {\"double\",  TYPESPEC, RID_DOUBLE,},\n       {\"\",}, \n-      {\"headof\",  HEADOF, NORID,},\n+      {\"new\",  NEW, NORID,},\n+      {\"typeid\",  TYPEID, NORID,},\n       {\"\",}, \n-      {\"goto\",  GOTO, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"public\",  VISSPEC, RID_PUBLIC,},\n-      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"case\",  CASE, NORID,},\n+      {\"union\",  AGGR, RID_UNION,},\n+      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"struct\",  AGGR, RID_RECORD,},\n       {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n-      {\"__inline\",  SCSPEC, RID_INLINE},\n-      {\"overload\",  OVERLOAD, NORID,},\n-      {\"__inline__\",  SCSPEC, RID_INLINE},\n-      {\"__alignof\",  ALIGNOF, NORID},\n-      {\"asm\",  ASM_KEYWORD, NORID,},\n+      {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"while\",  WHILE, NORID,},\n+      {\"return\",  RETURN, NORID,},\n       {\"\",}, \n-      {\"new\",  NEW, NORID,},\n+      {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n+      {\"protected\",  VISSPEC, RID_PROTECTED,},\n+      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n+      {\"friend\",  SCSPEC, RID_FRIEND,},\n+      {\"\",}, \n+      {\"do\",  DO, NORID,},\n+      {\"auto\",  SCSPEC, RID_AUTO,},\n+      {\"asm\",  ASM_KEYWORD, NORID,},\n+      {\"compl\",  '~', NORID,},\n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n       {\"\",}, \n       {\"mutable\",  SCSPEC, RID_MUTABLE,},\n-      {\"union\",  AGGR, RID_UNION,},\n-      {\"operator\",  OPERATOR, NORID,},\n-      {\"register\",  SCSPEC, RID_REGISTER,},\n-      {\"\",}, {\"\",}, \n-      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n       {\"\",}, \n-      {\"long\",  TYPESPEC, RID_LONG,},\n+      {\"signed\",  TYPESPEC, RID_SIGNED,},\n+      {\"\",}, \n+      {\"throw\",  THROW, NORID,},\n+      {\"and\",  ANDAND, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"continue\",  CONTINUE, NORID,},\n-      {\"return\",  RETURN, NORID,},\n+      {\"bitand\",  '&', NORID,},\n+      {\"const\",  TYPE_QUAL, RID_CONST,},\n+      {\"static\",  SCSPEC, RID_STATIC,},\n+      {\"headof\",  HEADOF, NORID,},\n+      {\"int\",  TYPESPEC, RID_INT,},\n       {\"enum\",  ENUM, NORID,},\n+      {\"\",}, \n+      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n+      {\"default\",  DEFAULT, NORID,},\n+      {\"\",}, \n+      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n+      {\"using\",  USING, NORID,},\n+      {\"__attribute\",  ATTRIBUTE, NORID},\n+      {\"\",}, \n+      {\"__attribute__\",  ATTRIBUTE, NORID},\n+      {\"\",}, \n+      {\"goto\",  GOTO, NORID,},\n+      {\"operator\",  OPERATOR, NORID,},\n+      {\"if\",  IF, NORID,},\n+      {\"continue\",  CONTINUE, NORID,},\n+      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n       {\"\",}, {\"\",}, \n-      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n-      {\"\",}, {\"\",}, \n-      {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"char\",  TYPESPEC, RID_CHAR,},\n+      {\"class\",  AGGR, RID_CLASS,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"char\",  TYPESPEC, RID_CHAR,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"classof\",  CLASSOF, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"long\",  TYPESPEC, RID_LONG,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"overload\",  OVERLOAD, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"catch\",  CATCH, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n+      {\"register\",  SCSPEC, RID_REGISTER,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"const_cast\",  CONST_CAST, NORID,},\n+      {\"\",}, {\"\",}, \n+      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"catch\",  CATCH, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "777ebe5ea986112fced17ebc911b010981b61aeb", "filename": "gcc/cp/init.c", "status": "modified", "additions": 47, "deletions": 125, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -125,6 +125,7 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n   tree real_binfos = BINFO_BASETYPES (real_binfo);\n   tree binfos = BINFO_BASETYPES (binfo);\n   int i, n_baselinks = real_binfos ? TREE_VEC_LENGTH (real_binfos) : 0;\n+  int has_expanded = 0;\n \n   for (i = 0; i < n_baselinks; i++)\n     {\n@@ -133,16 +134,20 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n       int is_not_base_vtable =\n \ti != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (real_binfo));\n       if (! TREE_VIA_VIRTUAL (real_base_binfo))\n-\texpand_direct_vtbls_init (real_base_binfo, base_binfo,\n-\t\t\t\t  is_not_base_vtable, can_elide, addr);\n+\t{\n+\t  expand_direct_vtbls_init (real_base_binfo, base_binfo,\n+\t\t  (is_not_base_vtable || flag_rtti), can_elide, addr);\n+\t  if (is_not_base_vtable && flag_rtti)\n+\t    has_expanded = 1;\n+\t}\n     }\n #if 0\n   /* Before turning this on, make sure it is correct.  */\n   if (can_elide  && ! BINFO_MODIFIED (binfo))\n     return;\n #endif\n   /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (real_binfo)))\n+  if (init_self && !has_expanded && CLASSTYPE_VFIELDS (BINFO_TYPE (real_binfo)))\n     {\n       tree base_ptr = convert_pointer_to_real (binfo, addr);\n       expand_virtual_init (real_binfo, base_ptr);\n@@ -421,13 +426,14 @@ emit_base_init (t, immediately)\n \t      switch (n_baseclasses)\n \t\t{\n \t\tcase 0:\n-\t\t  error (\"type `%s' does not have a base class to initialize\",\n-\t\t\t IDENTIFIER_POINTER (current_class_name));\n+\t\t  cp_error (\"`%T' does not have a base class to initialize\",\n+\t\t\t    current_class_type);\n \t\t  return;\n \t\tcase 1:\n \t\t  break;\n \t\tdefault:\n-\t\t  error (\"unnamed initializer ambiguous for type `%s' which uses multiple inheritance\", IDENTIFIER_POINTER (current_class_name));\n+\t\t  cp_error (\"unnamed initializer ambiguous for `%T' which uses multiple inheritance\",\n+\t\t\t    current_class_type);\n \t\t  return;\n \t\t}\n \t      binfo = TREE_VEC_ELT (binfos, 0);\n@@ -449,9 +455,9 @@ emit_base_init (t, immediately)\n \t\t      break;\n \t\t  if (i < 0)\n \t\t    {\n-\t\t      error (\"type `%s' is not an immediate base class of type `%s'\",\n-\t\t\t     IDENTIFIER_POINTER (basename),\n-\t\t\t     IDENTIFIER_POINTER (current_class_name));\n+\t\t      cp_error (\"`%T' is not an immediate base class of `%T'\",\n+\t\t\t\tIDENTIFIER_TYPE_VALUE (basename),\n+\t\t\t\tcurrent_class_type);\n \t\t      continue;\n \t\t    }\n \t\t}\n@@ -641,9 +647,8 @@ emit_base_init (t, immediately)\n \n \t      if (TREE_STATIC (member))\n \t\t{\n-\t\t  error_with_aggr_type (DECL_FIELD_CONTEXT (member),\n-\t\t\t\t\t\"field `%s::%s' is static; only point of initialization is its declaration\",\n-\t\t\t\t\tIDENTIFIER_POINTER (TREE_PURPOSE (init_list)));\n+\t\t  cp_error (\"field `%#D' is static; only point of initialization is its declaration\",\n+\t\t\t    member);\n \t\t  continue;\n \t\t}\n \n@@ -745,8 +750,7 @@ expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n   if (init)\n     init = TREE_PURPOSE (init);\n   /* Call constructors, but don't set up vtables.  */\n-  expand_aggr_init_1 (binfo, exp, ref, init, 0,\n-\t\t      LOOKUP_COMPLAIN|LOOKUP_SPECULATIVELY);\n+  expand_aggr_init_1 (binfo, exp, ref, init, 0, LOOKUP_COMPLAIN);\n   expand_cleanups_to (NULL_TREE);\n   CLEAR_BINFO_VBASE_INIT_MARKED (binfo);\n }\n@@ -1196,12 +1200,12 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n      out, then look hard.  */\n   tree rval;\n   tree parms;\n-  int xxref_init_possible;\n \n   if (init == NULL_TREE || TREE_CODE (init) == TREE_LIST)\n     {\n       parms = init;\n-      if (parms) init = TREE_VALUE (parms);\n+      if (parms)\n+\tinit = TREE_VALUE (parms);\n     }\n   else if (TREE_CODE (init) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (init))\n     {\n@@ -1213,16 +1217,6 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n   else\n     parms = build_tree_list (NULL_TREE, init);\n \n-  if (TYPE_HAS_INIT_REF (type)\n-      || init == NULL_TREE\n-      || TREE_CHAIN (parms) != NULL_TREE)\n-    xxref_init_possible = 0;\n-  else\n-    {\n-      xxref_init_possible = LOOKUP_SPECULATIVELY;\n-      flags &= ~LOOKUP_COMPLAIN;\n-    }\n-\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n       if (true_exp == exp)\n@@ -1232,114 +1226,43 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n       flags |= LOOKUP_HAS_IN_CHARGE;\n     }\n \n-  rval = build_method_call (exp, constructor_name_full (type),\n-\t\t\t    parms, binfo, flags|xxref_init_possible);\n-  if (rval == NULL_TREE && xxref_init_possible)\n-    {\n-      /* It is an error to implement a default copy constructor if\n-\t (see ARM 12.8 for details) ... one case being if another\n-\t copy constructor already exists. */\n-      tree init_type = TREE_TYPE (init);\n-      if (TREE_CODE (init_type) == REFERENCE_TYPE)\n-\tinit_type = TREE_TYPE (init_type);\n-      if (TYPE_MAIN_VARIANT (init_type) == TYPE_MAIN_VARIANT (type)\n-\t  || (IS_AGGR_TYPE (init_type)\n-\t      && UNIQUELY_DERIVED_FROM_P (type, init_type)))\n-\t{\n-\t  if (type == BINFO_TYPE (binfo)\n-\t      && TYPE_USES_VIRTUAL_BASECLASSES (type))\n-\t    {\n-\t      tree addr = build_unary_op (ADDR_EXPR, exp, 0);\n-\t      expand_aggr_vbase_init (binfo, exp, addr, NULL_TREE);\n-\n-\t      expand_indirect_vtbls_init (binfo, exp, addr, 1);\n-\t    }\n-\t  expand_expr_stmt (build_modify_expr (exp, INIT_EXPR, init));\n-\t  return;\n-\t}\n-      else\n-\trval = build_method_call (exp, constructor_name_full (type), parms,\n-\t\t\t\t  binfo, flags);\n-    }\n-\n-  /* Private, protected, or otherwise unavailable.  */\n-  if (rval == error_mark_node && (flags&LOOKUP_COMPLAIN))\n-    cp_error (\"in base initialization for class `%T'\", binfo);\n-  /* A valid initialization using constructor.  */\n-  else if (rval != error_mark_node && rval != NULL_TREE)\n+  if (init && TREE_CHAIN (parms) == NULL_TREE\n+      && TYPE_HAS_CONSTRUCTOR (type)\n+      && ! TYPE_NEEDS_CONSTRUCTING (type)\n+      && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (init)))\n     {\n-      /* p. 222: if the base class assigns to `this', then that\n-\t value is used in the derived class.  */\n-      if ((flag_this_is_variable & 1) && alias_this)\n-\t{\n-\t  TREE_TYPE (rval) = TREE_TYPE (current_class_decl);\n-\t  expand_assignment (current_class_decl, rval, 0, 0);\n-\t}\n-      else\n-\texpand_expr_stmt (rval);\n+      rval = build (INIT_EXPR, type, exp, init);\n+      TREE_SIDE_EFFECTS (rval) = 1;\n+      expand_expr_stmt (rval);\n     }\n-  else if (parms && TREE_CHAIN (parms) == NULL_TREE)\n+  else\n     {\n-      /* If we are initializing one aggregate value\n-\t from another, and though there are constructors,\n-\t and none accept the initializer, just do a bitwise\n-\t copy.\n-\n-\t The above sounds wrong, ``If a class has any copy\n-\t constructor defined, the default copy constructor will\n-\t not be generated.'' 12.8 Copying Class Objects  (mrs)\n-\n-\t @@ This should reject initializer which a constructor\n-\t @@ rejected on access gounds, but there is\n-\t @@ no way right now to recognize that case with\n-\t @@ just `error_mark_node'.  */\n-      tree itype;\n-      init = TREE_VALUE (parms);\n-      itype = TREE_TYPE (init);\n-      if (TREE_CODE (itype) == REFERENCE_TYPE)\n-\t{\n-\t  init = convert_from_reference (init);\n-\t  itype = TREE_TYPE (init);\n-\t}\n-      itype = TYPE_MAIN_VARIANT (itype);\n+      rval = build_method_call (exp, constructor_name_full (type),\n+\t\t\t\tparms, binfo, flags);\n \n-      /* This is currently how the default X(X&) constructor\n-\t is implemented.  */\n-      if (comptypes (TYPE_MAIN_VARIANT (type), itype, 0))\n-\t{\n-#if 0\n-\t  warning (\"bitwise copy in initialization of type `%s'\",\n-\t\t   TYPE_NAME_STRING (type));\n-#endif\n-\t  rval = build (INIT_EXPR, type, exp, init);\n-\t  expand_expr_stmt (rval);\n-\t}\n-      else\n+      /* Private, protected, or otherwise unavailable.  */\n+      if (rval == error_mark_node)\n \t{\n-\t  cp_error (\"in base initialization for class `%T',\", binfo);\n-\t  cp_error (\"invalid initializer to constructor for type `%T'\", type);\n-\t  return;\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    cp_error (\"in base initialization for %sclass `%T'\",\n+\t\t      TREE_VIA_VIRTUAL (binfo) ? \"virtual base \" : \"\",\n+\t\t      binfo);\n \t}\n-    }\n-  else\n-    {\n-      if (init == NULL_TREE)\n-\tmy_friendly_assert (parms == NULL_TREE, 210);\n-      if (parms == NULL_TREE && TREE_VIA_VIRTUAL (binfo))\n-\tcp_error (\"virtual baseclass `%T' does not have default initializer\", binfo);\n+      else if (rval == NULL_TREE)\n+\tmy_friendly_abort (361);\n       else\n \t{\n-\t  cp_error (\"in base initialization for class `%T',\", binfo);\n-\t  /* This will make an error message for us.  */\n-\t  build_method_call (exp, constructor_name_full (type), parms, binfo,\n-\t\t\t     (TYPE_USES_VIRTUAL_BASECLASSES (type)\n-\t\t\t      ? LOOKUP_NORMAL|LOOKUP_HAS_IN_CHARGE\n-\t\t\t      : LOOKUP_NORMAL));\n+\t  /* p. 222: if the base class assigns to `this', then that\n+\t     value is used in the derived class.  */\n+\t  if ((flag_this_is_variable & 1) && alias_this)\n+\t    {\n+\t      TREE_TYPE (rval) = TREE_TYPE (current_class_decl);\n+\t      expand_assignment (current_class_decl, rval, 0, 0);\n+\t    }\n+\t  else\n+\t    expand_expr_stmt (rval);\n \t}\n-      return;\n     }\n-  /* Constructor has been called, but vtables may be for TYPE\n-     rather than for FOR_TYPE.  */\n }\n \n /* This function is responsible for initializing EXP with INIT\n@@ -2707,7 +2630,6 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n     {\n       /* raw \"main\", and builtin functions never gets overloaded,\n \t but they can become friends.  */\n-      TREE_PUBLIC (decl) = 1;\n       add_friend (current_class_type, decl);\n       DECL_FRIEND_P (decl) = 1;\n       decl = void_type_node;"}, {"sha": "9d85c47d5afaaa0f0b048e79deafd7e405991ae1", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 95, "deletions": 32, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -660,6 +660,9 @@ init_lex ()\n   ridpointers[(int) RID_VIRTUAL] = get_identifier (\"virtual\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_VIRTUAL],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_VIRTUAL]));\n+  ridpointers[(int) RID_EXPLICIT] = get_identifier (\"explicit\");\n+  SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_EXPLICIT],\n+\t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_EXPLICIT]));\n   ridpointers[(int) RID_FRIEND] = get_identifier (\"friend\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_FRIEND],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_FRIEND]));\n@@ -681,11 +684,6 @@ init_lex ()\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_MUTABLE],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_MUTABLE]));\n \n-  /* Exception handling extensions.  */\n-  exception_type_node = build_int_2 (exception_type, 0);\n-  TREE_TYPE (exception_type_node) = exception_type_node;\n-  ridpointers[(int) RID_EXCEPTION] = exception_type_node;\n-\n   /* Signature handling extensions.  */\n   signature_type_node = build_int_2 (signature_type, 0);\n   TREE_TYPE (signature_type_node) = signature_type_node;\n@@ -790,7 +788,7 @@ init_lex ()\n     }\n #endif\n \n-  if (! (flag_gc || flag_dossier))\n+  if (! (flag_gc || flag_rtti))\n     {\n       UNSET_RESERVED_WORD (\"classof\");\n       UNSET_RESERVED_WORD (\"headof\");\n@@ -806,6 +804,17 @@ init_lex ()\n     UNSET_RESERVED_WORD (\"asm\");\n   if (flag_no_asm || flag_traditional)\n     UNSET_RESERVED_WORD (\"typeof\");\n+  if (!flag_ansi)\n+    {\n+      /* These are new ANSI keywords that may break code.  */\n+      UNSET_RESERVED_WORD (\"and\");\n+      UNSET_RESERVED_WORD (\"bitand\");\n+      UNSET_RESERVED_WORD (\"bitor\");\n+      UNSET_RESERVED_WORD (\"compl\");\n+      UNSET_RESERVED_WORD (\"not\");\n+      UNSET_RESERVED_WORD (\"or\");\n+      UNSET_RESERVED_WORD (\"xor\");\n+    }\n \n   token_count = init_parse ();\n   interface_unknown = 1;\n@@ -1125,19 +1134,7 @@ do_pending_inlines ()\n \t    DECL_PENDING_INLINE_INFO (f) = 0;\n \t    interface_unknown = t->interface == 1;\n \t    interface_only = t->interface == 0;\n-\t    switch (- t->lineno)\n-\t      {\n-\t      case 0: case 1:\n-\t\tbuild_dtor (f); break;\n-\t      case 2:\n-\t\tbuild_default_constructor (f); break;\n-\t      case 3: case 4:\n-\t\tbuild_copy_constructor (f); break;\n-\t      case 5: case 6:\n-\t\tbuild_assign_ref (f); break;\n-\t      default:\n-\t\t;\n-\t      }\n+\t    synthesize_method (f);\n \t    if (tail)\n \t      tail->next = t->next;\n \t    else\n@@ -1712,6 +1709,7 @@ cons_up_default_function (type, name, kind)\n   tree fn, args;\n   tree argtype;\n   int retref = 0;\n+  int complex = 0;\n \n   name = constructor_name (name);\n   switch (kind)\n@@ -1722,10 +1720,13 @@ cons_up_default_function (type, name, kind)\n       /* Fall through...  */\n     case 0:\n       name = build_parse_node (BIT_NOT_EXPR, name);\n-      /* Fall through...  */\n+      args = void_list_node;\n+      break;\n+\n     case 2:\n       /* Default constructor.  */\n       args = void_list_node;\n+      complex = TYPE_NEEDS_CONSTRUCTING (type);\n       break;\n \n     case 3:\n@@ -1739,6 +1740,7 @@ cons_up_default_function (type, name, kind)\n \t\t\tbuild_tree_list (hash_tree_chain (argtype, NULL_TREE),\n \t\t\t\t\t get_identifier (\"_ctor_arg\")),\n \t\t\tvoid_list_node);\n+      complex = TYPE_HAS_COMPLEX_INIT_REF (type);\n       break;\n \n     case 5:\n@@ -1755,6 +1757,7 @@ cons_up_default_function (type, name, kind)\n \t\t\tbuild_tree_list (hash_tree_chain (argtype, NULL_TREE),\n \t\t\t\t\t get_identifier (\"_ctor_arg\")),\n \t\t\tvoid_list_node);\n+      complex = TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n       break;\n \n     default:\n@@ -1777,20 +1780,34 @@ cons_up_default_function (type, name, kind)\n   if (fn == void_type_node)\n     return fn;\n \n-  if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+  if (processing_template_defn)\n     SET_DECL_IMPLICIT_INSTANTIATION (fn);\n \n-  /* This kludge should go away when synthesized methods are handled\n-     properly, i.e. only when needed.  */\n-  {\n-    struct pending_inline *t;\n-    t = (struct pending_inline *)\n-      obstack_alloc (&synth_obstack, sizeof (struct pending_inline));\n-    t->lineno = -kind;\n-    t->can_free = 0;\n-    t->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n-    store_pending_inline (fn, t);\n-  }\n+  if (CLASSTYPE_INTERFACE_KNOWN (type))\n+    {\n+      DECL_INTERFACE_KNOWN (fn) = 1;\n+      DECL_EXTERNAL (fn) = (CLASSTYPE_INTERFACE_ONLY (type)\n+\t\t\t    || ! flag_implement_inlines);\n+      TREE_STATIC (fn) = ! DECL_EXTERNAL (fn);\n+    }\n+\n+  /* When on-the-fly synthesis works properly, remove the second and third\n+     conditions here.  */\n+  if (flag_keep_inline_functions\n+      || ! flag_no_inline\n+      || complex\n+      || ! DECL_EXTERNAL (fn))\n+    {\n+      struct pending_inline *t;\n+      t = (struct pending_inline *)\n+\tobstack_alloc (&synth_obstack, sizeof (struct pending_inline));\n+      t->lineno = -kind;\n+      t->can_free = 0;\n+      t->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n+      store_pending_inline (fn, t);\n+    }\n+  else\n+    mark_inline_for_output (fn);\n \n #ifdef DEBUG_DEFAULT_FUNCTIONS\n   { char *fn_type = NULL;\n@@ -3474,6 +3491,52 @@ real_yylex ()\n \t\t  else\n \t\t    yylval.ttype = old_ttype;\n \t\t}\n+\t      else if (ptr->token == EQCOMPARE)\n+\t\t{\n+\t\t  yylval.code = NE_EXPR;\n+\t\t  token_buffer[0] = '!';\n+\t\t  token_buffer[1] = '=';\n+\t\t  token_buffer[2] = 0;\n+\t\t}\n+\t      else if (ptr->token == ASSIGN)\n+\t\t{\n+\t\t  if (strcmp (\"and_eq\", token_buffer) == 0)\n+\t\t    {\n+\t\t      yylval.code = BIT_AND_EXPR;\n+\t\t      token_buffer[0] = '&';\n+\t\t    }\n+\t\t  else if (strcmp (\"or_eq\", token_buffer) == 0)\n+\t\t    {\n+\t\t      yylval.code = BIT_IOR_EXPR;\n+\t\t      token_buffer[0] = '|';\n+\t\t    }\n+\t\t  else if (strcmp (\"xor_eq\", token_buffer) == 0)\n+\t\t    {\n+\t\t      yylval.code = BIT_XOR_EXPR;\n+\t\t      token_buffer[0] = '^';\n+\t\t    }\n+\t\t  token_buffer[1] = '=';\n+\t\t  token_buffer[2] = 0;\n+\t\t}\n+\t      else if (ptr->token == '&')\n+\t\t{\n+\t\t  yylval.code = BIT_AND_EXPR;\n+\t\t  token_buffer[0] = '&';\n+\t\t  token_buffer[1] = 0;\n+\t\t}\n+\t      else if (ptr->token == '|')\n+\t\t{\n+\t\t  yylval.code = BIT_IOR_EXPR;\n+\t\t  token_buffer[0] = '|';\n+\t\t  token_buffer[1] = 0;\n+\t\t}\n+\t      else if (ptr->token == '^')\n+\t\t{\n+\t\t  yylval.code = BIT_XOR_EXPR;\n+\t\t  token_buffer[0] = '^';\n+\t\t  token_buffer[1] = 0;\n+\t\t}\n+\n \t      value = (int) ptr->token;\n \t    }\n \t}"}, {"sha": "105ca3a875d4b8c5b679854caf3072bb673b8624", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -58,6 +58,7 @@ enum rid\n   RID_VOLATILE,\n   RID_FRIEND,\n   RID_VIRTUAL,\n+  RID_EXPLICIT,\n   RID_SIGNED,\n   RID_AUTO,\n   RID_MUTABLE,"}, {"sha": "90dd4df3ba01f2074c9dbf69a1d38248a6026c7a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 80, "deletions": 31, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -59,6 +59,7 @@ static char *scratch_firstobj;\n \t\t IDENTIFIER_LENGTH (ID)))\n # define OB_PUTCP(S) (obstack_grow (&scratch_obstack, (S), strlen (S)))\n # define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n+# define OB_LAST() (obstack_next_free (&scratch_obstack)[-1])\n \n #ifdef NO_AUTO_OVERLOAD\n int is_overloaded ();\n@@ -317,19 +318,39 @@ static int numeric_outputed_need_bar;\n static void build_overload_identifier ();\n \n static void\n-build_overload_nested_name (context)\n-     tree context;\n+build_overload_nested_name (decl)\n+     tree decl;\n {\n-  /* We use DECL_NAME here, because pushtag now sets the DECL_ASSEMBLER_NAME.  */\n-  tree name = DECL_NAME (context);\n-  if (DECL_CONTEXT (context))\n+  if (DECL_CONTEXT (decl))\n     {\n-      context = DECL_CONTEXT (context);\n+      tree context = DECL_CONTEXT (decl);\n       if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n-\tcontext = TYPE_NAME (context);\n+\tcontext = TYPE_MAIN_DECL (context);\n       build_overload_nested_name (context);\n     }\n-  build_overload_identifier (name);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      tree name = DECL_ASSEMBLER_NAME (decl);\n+      char *label;\n+      extern int var_labelno;\n+\n+      ASM_FORMAT_PRIVATE_NAME (label, IDENTIFIER_POINTER (name), var_labelno);\n+      var_labelno++;\n+\n+      if (numeric_outputed_need_bar)\n+\t{\n+\t  OB_PUTC ('_');\n+\t  numeric_outputed_need_bar = 0;\n+\t}\n+      icat (strlen (label));\n+      OB_PUTCP (label);\n+    }\n+  else\t\t\t\t/* TYPE_DECL */\n+    {\n+      tree name = DECL_NAME (decl);\n+      build_overload_identifier (name);\n+    }\n }\n \n static void\n@@ -514,6 +535,7 @@ build_overload_name (parmtypes, begin, end)\n   tree parmtype;\n \n   if (begin) OB_INIT ();\n+  numeric_outputed_need_bar = 0;\n \n   if ((just_one = (TREE_CODE (parmtypes) != TREE_LIST)))\n     {\n@@ -761,6 +783,13 @@ build_overload_name (parmtypes, begin, end)\n \t    if (TREE_CODE (name) == TYPE_DECL)\n \t      {\n \t\ttree context = name;\n+\n+\t\t/* If DECL_ASSEMBLER_NAME has been set properly, use it. */\n+\t\tif (DECL_ASSEMBLER_NAME (context) != DECL_NAME (context))\n+\t\t  {\n+\t\t    OB_PUTID (DECL_ASSEMBLER_NAME (context));\n+\t\t    break;\n+\t\t  }\n \t\twhile (DECL_CONTEXT (context))\n \t\t  {\n \t\t    i += 1;\n@@ -779,8 +808,8 @@ build_overload_name (parmtypes, begin, end)\n \t\ticat (i);\n \t\tif (i > 9)\n \t\t  OB_PUTC ('_');\n-                numeric_outputed_need_bar = 0;\n-\t\tbuild_overload_nested_name (TYPE_NAME (parmtype));\n+\t\tnumeric_outputed_need_bar = 0;\n+\t\tbuild_overload_nested_name (TYPE_MAIN_DECL (parmtype));\n \t      }\n \t    else\n \t      build_overload_identifier (name);\n@@ -920,7 +949,6 @@ build_decl_overload (dname, parms, for_method)\n     {\n       ALLOCATE_TYPEVEC (parms);\n       nofold = 0;\n-      numeric_outputed_need_bar = 0;\n       if (for_method)\n \t{\n \t  build_overload_name (TREE_VALUE (parms), 0, 0);\n@@ -1906,6 +1934,10 @@ emit_thunk (thunk_fndecl)\n \n   unshare_all_rtl (insns);\n \n+  /* Instantiate all virtual registers.  */\n+\n+  instantiate_virtual_regs (current_function_decl, get_insns ());\n+\n   /* We are no longer anticipating cse in this function, at least.  */\n \n   cse_not_expected = 1;\n@@ -1971,16 +2003,6 @@ emit_thunk (thunk_fndecl)\n \f\n /* Code for synthesizing methods which have default semantics defined.  */\n \n-void\n-build_default_constructor (fndecl)\n-     tree fndecl;\n-{\n-  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n-  store_parm_decls ();\n-  setup_vtbl_ptr ();\n-  finish_function (lineno, 0);\n-}\n-\n /* For the anonymous union in TYPE, return the member that is at least as\n    large as the rest of the members, so we can copy it.  */\n static tree\n@@ -2000,14 +2022,12 @@ largest_union_member (type)\n \n /* Generate code for default X(X&) constructor.  */\n void\n-build_copy_constructor (fndecl)\n+do_build_copy_constructor (fndecl)\n      tree fndecl;\n {\n   tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n   tree t;\n \n-  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n-  store_parm_decls ();\n   clear_last_expr ();\n   push_momentary ();\n \n@@ -2085,17 +2105,15 @@ build_copy_constructor (fndecl)\n     }\n \n   pop_momentary ();\n-  finish_function (lineno, 0);\n }\n \n void\n-build_assign_ref (fndecl)\n+do_build_assign_ref (fndecl)\n      tree fndecl;\n {\n   tree parm = TREE_CHAIN (DECL_ARGUMENTS (fndecl));\n \n-  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n-  store_parm_decls ();\n+  clear_last_expr ();\n   push_momentary ();\n \n   parm = convert_from_reference (parm);\n@@ -2158,14 +2176,45 @@ build_assign_ref (fndecl)\n     }\n   c_expand_return (C_C_D);\n   pop_momentary ();\n-  finish_function (lineno, 0);\n }\n \n+void push_cp_function_context ();\n+void pop_cp_function_context ();\n+\n void\n-build_dtor (fndecl)\n+synthesize_method (fndecl)\n      tree fndecl;\n {\n+  int nested = (current_function_decl != NULL_TREE);\n+  int toplev = (decl_function_context (fndecl) == NULL_TREE);\n+  char *f = input_filename;\n+\n+  if (nested)\n+    push_cp_function_context (toplev);\n+\n+  input_filename = DECL_SOURCE_FILE (fndecl);\n+  extract_interface_info ();\n   start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n   store_parm_decls ();\n-  finish_function (lineno, 0);\n+\n+  if (DECL_NAME (fndecl) == ansi_opname[MODIFY_EXPR])\n+    do_build_assign_ref (fndecl);\n+  else if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fndecl)))\n+    ;\n+  else\n+    {\n+      tree arg_chain = FUNCTION_ARG_CHAIN (fndecl);\n+      if (DECL_CONSTRUCTOR_FOR_VBASE_P (fndecl))\n+\targ_chain = TREE_CHAIN (arg_chain);\n+      if (arg_chain != void_list_node)\n+\tdo_build_copy_constructor (fndecl);\n+      else if (TYPE_NEEDS_CONSTRUCTING (current_class_type))\n+\tsetup_vtbl_ptr ();\n+    }\n+\n+  finish_function (lineno, 0, nested);\n+  input_filename = f;\n+  extract_interface_info ();\n+  if (nested)\n+    pop_cp_function_context (toplev);\n }"}, {"sha": "c04d608fd1dd884532c197c078b5b000f310e76b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -150,6 +150,7 @@ empty_parms ()\n %token <ttype> AGGR\n %token <itype> VISSPEC\n %token DELETE NEW OVERLOAD THIS OPERATOR CXX_TRUE CXX_FALSE\n+%token NAMESPACE TYPENAME_KEYWORD USING\n %token LEFT_RIGHT TEMPLATE\n %token TYPEID DYNAMIC_CAST STATIC_CAST REINTERPRET_CAST CONST_CAST\n %token <itype> SCOPE\n@@ -170,6 +171,7 @@ empty_parms ()\n \n %left '{' ',' ';'\n \n+%nonassoc THROW\n %right <code> ASSIGN '='\n %right <code> '?' ':'\n %left <code> OROR\n@@ -190,7 +192,7 @@ empty_parms ()\n %left <code> POINTSAT '.' '(' '['\n \n %right SCOPE\t\t\t/* C++ extension */\n-%nonassoc NEW DELETE TRY CATCH THROW\n+%nonassoc NEW DELETE TRY CATCH\n \n %type <code> unop\n \n@@ -430,9 +432,7 @@ template_def:\n \t\t{\n \t\t  yychar = ':';\n \t\ttemplate1:\n-\t\t  if (current_aggr == exception_type_node)\n-\t\t    error (\"template type must define an aggregate or union\");\n-\t\t  else if (current_aggr == signature_type_node)\n+\t\t  if (current_aggr == signature_type_node)\n \t\t    sorry (\"template type defining a signature\");\n \t\t  /* Maybe pedantic warning for union?\n \t\t     How about an enum? :-)  */\n@@ -564,7 +564,7 @@ datadef:\n fndef:\n \t  fn.def1 base_init compstmt_or_error\n \t\t{\n-\t\t  finish_function (lineno, 1);\n+\t\t  finish_function (lineno, 1, 0);\n \t\t  /* finish_function performs these three statements:\n \n \t\t     expand_end_bindings (getdecls (), 1, 0);\n@@ -577,7 +577,7 @@ fndef:\n \t\t}\n \t| fn.def1 return_init base_init compstmt_or_error\n \t\t{\n-\t\t  finish_function (lineno, 1);\n+\t\t  finish_function (lineno, 1, 0);\n \t\t  /* finish_function performs these three statements:\n \n \t\t     expand_end_bindings (getdecls (), 1, 0);\n@@ -589,13 +589,13 @@ fndef:\n \t\t  if ($<ttype>$) process_next_inline ($<ttype>$);\n \t\t}\n \t| fn.def1 nodecls compstmt_or_error\n-\t\t{ finish_function (lineno, 0);\n+\t\t{ finish_function (lineno, 0, 0);\n \t\t  if ($<ttype>$) process_next_inline ($<ttype>$); }\n \t| fn.def1 return_init ';' nodecls compstmt_or_error\n-\t\t{ finish_function (lineno, 0);\n+\t\t{ finish_function (lineno, 0, 0);\n \t\t  if ($<ttype>$) process_next_inline ($<ttype>$); }\n \t| fn.def1 return_init nodecls compstmt_or_error\n-\t\t{ finish_function (lineno, 0);\n+\t\t{ finish_function (lineno, 0, 0);\n \t\t  if ($<ttype>$) process_next_inline ($<ttype>$); }\n \t| typed_declspecs declarator error\n \t\t{}\n@@ -1148,7 +1148,7 @@ sub_cast_expr:\n \t\t    {\n \t\t      tree type = IDENTIFIER_TYPE_VALUE ($3);\n \t\t      if (! IS_SIGNATURE(type))\n-\t\t\t$$ = CLASSTYPE_DOSSIER (type);\n+\t\t\t$$ = CLASSTYPE_RTTI (type);\n \t\t      else\n \t\t\t{\n \t\t\t  sorry (\"signature name as argument of `classof'\");\n@@ -2109,9 +2109,6 @@ structsp:\n \n \t\t  if (TREE_CODE ($$) == ENUMERAL_TYPE)\n \t\t    /* $$ = $1 from default rule.  */;\n-\t\t  else if (CLASSTYPE_DECLARED_EXCEPTION ($$))\n-\t\t    {\n-\t\t    }\n \t\t  else\n \t\t    {\n \t\t      $$ = finish_struct ($$, $3, semi);\n@@ -2435,8 +2432,12 @@ left_curly: '{'\n \t\t      int needs_writing;\n \t\t      tree name = TYPE_IDENTIFIER (t);\n \n-\t\t      CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-\t\t      SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n+\t\t      if (! ANON_AGGRNAME_P (name))\n+\t\t\t{\n+\t\t\t  CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n+\t\t\t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n+\t\t\t    (t, interface_unknown);\n+\t\t\t}\n \n \t\t      /* Record how to set the access of this class's\n \t\t\t virtual functions.  If write_virtuals == 2 or 3, then\n@@ -3422,7 +3423,7 @@ handler_args:\n \t\t{ expand_start_catch_block ($2, $3); }\n \t| '(' typed_typespecs after_type_declarator ')'\n \t\t{ expand_start_catch_block ($2, $3); }\n-\t*/\n+\tThis allows reference parameters... */\n \t| '(' parm ')'\n \t\t{ expand_start_catch_block (TREE_PURPOSE ($2),\n \t\t\t\t\t    TREE_VALUE ($2)); }"}, {"sha": "655535abd47796e2bb2421a5c01f44d6bc166468", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 86, "deletions": 71, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -97,8 +97,7 @@ process_template_parm (list, next)\n \t\t\t     PARM, 0, NULL_TREE);\n       /* A template parameter is not modifiable.  */\n       TREE_READONLY (parm) = 1;\n-      if (TREE_CODE (TREE_TYPE (parm)) == RECORD_TYPE\n-\t  || TREE_CODE (TREE_TYPE (parm)) == UNION_TYPE)\n+      if (IS_AGGR_TYPE (TREE_TYPE (parm)))\n \t{\n \t  sorry (\"aggregate template parameter types\");\n \t  TREE_TYPE (parm) = void_type_node;\n@@ -466,7 +465,7 @@ coerce_template_parms (parms, arglist, in_decl)\n \t      tree a = TREE_OPERAND (val, 0);\n \t      if ((TREE_CODE (a) == VAR_DECL\n \t\t   || TREE_CODE (a) == FUNCTION_DECL)\n-\t\t  && !TREE_PUBLIC (a))\n+\t\t  && ! DECL_PUBLIC (a))\n \t\t{\n \t\t  cp_error (\"address of non-extern `%E' cannot be used as template argument\", a);\n \t\t  val = error_mark_node;\n@@ -683,7 +682,8 @@ push_template_decls (parmlist, arglist, class_level)\n \t  val = digest_init (TREE_TYPE (parm), arg, (tree *) 0);\n \t  if (val != error_mark_node)\n \t    {\n-\t      decl = build_decl (VAR_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n+\t      decl = build_decl (CONST_DECL, DECL_NAME (parm),\n+\t\t\t\t TREE_TYPE (parm));\n \t      DECL_INITIAL (decl) = val;\n \t      TREE_READONLY (decl) = 1;\n \t    }\n@@ -834,6 +834,11 @@ uses_template_parms (t)\n     case UNINSTANTIATED_P_TYPE:\n       return 1;\n \n+    case CONSTRUCTOR:\n+      if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n+\treturn uses_template_parms (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (t)));\n+      /* else fall through */\n+\n     default:\n       switch (TREE_CODE_CLASS (TREE_CODE (t)))\n \t{\n@@ -898,19 +903,6 @@ instantiate_member_templates (classname)\n \t\t\t\t     &TREE_VEC_ELT (parmvec, 0));\n \t  type = IDENTIFIER_TYPE_VALUE (id);\n \t  my_friendly_assert (type != 0, 277);\n-\t  if (flag_external_templates)\n-\t    {\n-\t      if (CLASSTYPE_INTERFACE_UNKNOWN (type))\n-\t\t{\n-\t\t  DECL_EXTERNAL (t2) = 0;\n-\t\t  TREE_PUBLIC (t2) = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  DECL_EXTERNAL (t2) = CLASSTYPE_INTERFACE_ONLY (type);\n-\t\t  TREE_PUBLIC (t2) = 1;\n-\t\t}\n-\t    }\n \t  break;\n \tcase 1:\n \t  /* Failure.  */\n@@ -1116,15 +1108,11 @@ lookup_nested_type_by_name (ctype, name)\n {\n   tree t;\n \n-  t = TREE_VALUE(CLASSTYPE_TAGS(ctype)); \n-  while (t)\n-  {\n-    if (strcmp(IDENTIFIER_POINTER(name), IDENTIFIER_POINTER(TYPE_IDENTIFIER(t)))\n- == 0)\n-      return t;\n-    else \n-      t = TREE_CHAIN(t);\n-  }\n+  for (t = CLASSTYPE_TAGS (ctype); t; t = TREE_CHAIN (t))\n+    {\n+      if (name == TREE_PURPOSE (t))\n+\treturn TREE_VALUE (t);\n+    }\n   return NULL_TREE;\n }\n \n@@ -1198,9 +1186,12 @@ tsubst (t, args, nargs, in_decl)\n \t tsubst (TYPE_MAX_VALUE (t), args, nargs, in_decl));\n \n     case TEMPLATE_TYPE_PARM:\n-      return cp_build_type_variant (args[TEMPLATE_TYPE_IDX (t)],\n-\t\t\t\t   TYPE_READONLY (t),\n-\t\t\t\t   TYPE_VOLATILE (t));\n+      {\n+\ttree arg = args[TEMPLATE_TYPE_IDX (t)];\n+\treturn cp_build_type_variant\n+\t  (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n+\t   TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n+      }\n \n     case TEMPLATE_CONST_PARM:\n       return args[TEMPLATE_CONST_IDX (t)];\n@@ -1404,9 +1395,10 @@ tsubst (t, args, nargs, in_decl)\n \t\t}\n \t    }\n \t  }\n-\tTREE_PUBLIC (r) = TREE_PUBLIC (t);\n-\tDECL_EXTERNAL (r) = DECL_EXTERNAL (t);\n-\tTREE_STATIC (r) = TREE_STATIC (t);\n+\tTREE_PUBLIC (r) = 1;\n+\tDECL_EXTERNAL (r) = 1;\n+\tTREE_STATIC (r) = 0;\n+\tDECL_INTERFACE_KNOWN (r) = 0;\n \tDECL_INLINE (r) = DECL_INLINE (t);\n \t{\n #if 0\t\t\t\t/* Maybe later.  -jason  */\n@@ -1719,10 +1711,21 @@ instantiate_template (tmpl, targ_ptr)\n \tinput_filename = p->filename = t->filename;\n \n \textract_interface_info ();\n-\t\n-\tif (interface_unknown && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (tmpl))\n-\t  warn_if_unknown_interface ();\n-\tif (interface_unknown || !flag_external_templates)\n+\n+\tif (interface_unknown && flag_external_templates)\n+\t  {\n+\t    if (DECL_CLASS_CONTEXT (fndecl)\n+\t\t&& CLASSTYPE_INTERFACE_KNOWN (DECL_CLASS_CONTEXT (fndecl)))\n+\t      {\n+\t\tinterface_unknown = 0;\n+\t\tinterface_only\n+\t\t  = CLASSTYPE_INTERFACE_ONLY (DECL_CLASS_CONTEXT (fndecl));\n+\t      }\n+\t    else if (! DECL_IN_SYSTEM_HEADER (tmpl))\n+\t      warn_if_unknown_interface ();\n+\t  }\n+\n+\tif (interface_unknown || ! flag_external_templates)\n \t  p->interface = 1;\t\t/* unknown */\n \telse\n \t  p->interface = interface_only ? 0 : 2;\n@@ -2008,6 +2011,9 @@ type_unification (tparms, targs, parms, args, nsubsts, subr)\n \t  arg = TREE_TYPE (arg);\n \t}\n #endif\n+      if (TREE_CODE (arg) == REFERENCE_TYPE)\n+\targ = TREE_TYPE (arg);\n+\n       if (TREE_CODE (parm) != REFERENCE_TYPE)\n \t{\n \t  if (TREE_CODE (arg) == FUNCTION_TYPE\n@@ -2068,9 +2074,6 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n   if (arg == parm)\n     return 0;\n \n-  if (TREE_CODE (arg) == REFERENCE_TYPE)\n-    arg = TREE_TYPE (arg);\n-\n   switch (TREE_CODE (parm))\n     {\n     case TEMPLATE_TYPE_PARM:\n@@ -2082,13 +2085,21 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \t  return 1;\n \t}\n       idx = TEMPLATE_TYPE_IDX (parm);\n+#if 0\n       /* Template type parameters cannot contain cv-quals; i.e.\n          template <class T> void f (T& a, T& b) will not generate\n \t void f (const int& a, const int& b).  */\n       if (TYPE_READONLY (arg) > TYPE_READONLY (parm)\n \t  || TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm))\n \treturn 1;\n       arg = TYPE_MAIN_VARIANT (arg);\n+#else\n+      {\n+\tint constp = TYPE_READONLY (arg) > TYPE_READONLY (parm);\n+\tint volatilep = TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm);\n+\targ = cp_build_type_variant (arg, constp, volatilep);\n+      }\n+#endif\n       /* Simple cases: Value already set, does match or doesn't.  */\n       if (targs[idx] == arg)\n \treturn 0;\n@@ -2205,22 +2216,19 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n     case UNINSTANTIATED_P_TYPE:\n       {\n \ttree a;\n-\t/* Unification of something that is not a template fails. (mrs) */\n-\tif (TYPE_NAME (arg) == 0)\n+\t/* Unification of something that is not a class fails.  */\n+\tif (! IS_AGGR_TYPE (arg))\n \t  return 1;\n \ta = IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (arg));\n-\t/* Unification of something that is not a template fails. (mrs) */\n-\tif (a == 0)\n-\t  return 1;\n-\tif (UPT_TEMPLATE (parm) != TREE_PURPOSE (a))\n-\t  /* different templates */\n-\t  return 1;\n-\treturn unify (tparms, targs, ntparms, UPT_PARMS (parm), TREE_VALUE (a),\n-\t\t      nsubsts);\n+\tif (a && UPT_TEMPLATE (parm) == TREE_PURPOSE (a))\n+\t  return unify (tparms, targs, ntparms, UPT_PARMS (parm),\n+\t\t\tTREE_VALUE (a), nsubsts);\n+\t/* FIXME: Should check base conversions here.  */\n+\treturn 1;\n       }\n \n     case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (parm))\n+      if (TYPE_PTRMEMFUNC_FLAG (parm))\n \treturn unify (tparms, targs, ntparms, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n \t\t      arg, nsubsts);\n \n@@ -2295,6 +2303,9 @@ do_pending_expansions ()\n       else if (! flag_implicit_templates)\n \tDECIDE (0);\n \n+      /* OK, it was an implicit instantiation.  */\n+      TREE_PUBLIC (t) = 0;\n+\n       /* If it's a method, let the class type decide it.\n \t @@ What if the method template is in a separate file?\n \t Maybe both file contexts should be taken into account?\n@@ -2425,17 +2436,14 @@ do_function_instantiation (declspecs, declarator, storage)\n   if (flag_external_templates)\n     return;\n \n-  if (DECL_EXPLICIT_INSTANTIATION (result) && TREE_PUBLIC (result))\n-    return;\n-\n   SET_DECL_EXPLICIT_INSTANTIATION (result);\n+  TREE_PUBLIC (result) = 1;\n \n   if (storage == NULL_TREE)\n     {\n-      TREE_PUBLIC (result) = 1;\n-      DECL_EXTERNAL (result) = (DECL_INLINE (result)\n-\t\t\t\t&& ! flag_implement_inlines);\n-      TREE_STATIC (result) = ! DECL_EXTERNAL (result);\n+      DECL_INTERFACE_KNOWN (result) = 1;\n+      DECL_EXTERNAL (result) = 0;\n+      TREE_STATIC (result) = 1;\n     }\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     ;\n@@ -2475,7 +2483,7 @@ do_type_instantiation (name, storage)\n     }\n \n   /* We've already instantiated this.  */\n-  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && CLASSTYPE_INTERFACE_KNOWN (t))\n+  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && ! CLASSTYPE_INTERFACE_ONLY (t))\n     {\n       if (! extern_p)\n \tcp_pedwarn (\"multiple explicit instantiation of `%#T'\", t);\n@@ -2485,22 +2493,29 @@ do_type_instantiation (name, storage)\n   if (! CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n     {\n       SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n+      SET_CLASSTYPE_INTERFACE_KNOWN (t);\n+      CLASSTYPE_INTERFACE_ONLY (t) = extern_p;\n+      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! extern_p;\n+      TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = extern_p;\n       if (! extern_p)\n \t{\n-\t  SET_CLASSTYPE_INTERFACE_KNOWN (t);\n-\t  CLASSTYPE_INTERFACE_ONLY (t) = 0;\n-\t  CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n \t  CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n-\t  TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n \t  rest_of_type_compilation (t, 1);\n \t}\n     }\n-\n-  instantiate_member_templates (TYPE_IDENTIFIER (t));\n-\n-  /* this should really be done by instantiate_member_templates */\n+  \n   {\n-    tree tmp = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n+    tree tmp;\n+    /* Classes nested in template classes currently don't have an\n+       IDENTIFIER_TEMPLATE--their out-of-line members are handled\n+       by the enclosing template class.  Note that there are name\n+       conflict bugs with this approach. */\n+    tmp = TYPE_IDENTIFIER (t);\n+    if (IDENTIFIER_TEMPLATE (tmp))\n+      instantiate_member_templates (tmp);\n+\n+    /* this should really be done by instantiate_member_templates */\n+    tmp = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (t), 0);\n     for (; tmp; tmp = TREE_CHAIN (tmp))\n       {\n \tif (DECL_TEMPLATE_SPECIALIZATION (tmp)\n@@ -2509,12 +2524,12 @@ do_type_instantiation (name, storage)\n \t  continue;\n \n \tSET_DECL_EXPLICIT_INSTANTIATION (tmp);\n+\tTREE_PUBLIC (tmp) = 1;\n \tif (! extern_p)\n \t  {\n-\t    TREE_PUBLIC (tmp) = 1;\n-\t    DECL_EXTERNAL (tmp) = (DECL_INLINE (tmp)\n-\t\t\t\t   && ! flag_implement_inlines);\n-\t    TREE_STATIC (tmp) = ! DECL_EXTERNAL (tmp);\n+\t    DECL_INTERFACE_KNOWN (tmp) = 1;\n+\t    DECL_EXTERNAL (tmp) = 0;\n+\t    TREE_STATIC (tmp) = 1;\n \t  }\n       }\n "}, {"sha": "9fb8e63d9bdca709f8c8aa93b00f339ad8de2a48", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -377,8 +377,8 @@ pop_memoized_context (use_old)\n     type_stack = (struct type_level *)type_stack->base.prev;\n }\n \f\n-#if 0\t\t\t\t/* unused */\n /* This is the newer recursive depth first search routine. */\n+#if 0\t\t\t\t/* unused */\n /* Return non-zero if PARENT is directly derived from TYPE.  By directly\n    we mean it's only one step up the inheritance lattice.  We check this\n    by walking horizontally across the types that TYPE directly inherits\n@@ -1995,12 +1995,9 @@ get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n   /* Should we use something besides CLASSTYPE_VFIELDS? */\n   if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n+      /* Get around first entry reserved for RTTI.  */\n       tree tmp = TREE_CHAIN (BINFO_VIRTUALS (binfo));\n \n-      /* Get around dossier entry if there is one.  */\n-      if (flag_dossier)\n-\ttmp = TREE_CHAIN (tmp);\n-\n       while (tmp)\n \t{\n \t  tree base_pfn = FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (tmp));\n@@ -2417,10 +2414,10 @@ dfs_init_vbase_pointers (binfo)\n \n   CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n \n-  /* If there is a dossier, it is the first field, though perhaps from\n+  /* If there is a rtti, it is the first field, though perhaps from\n      the base class.  Otherwise, the first fields are virtual base class\n      pointer fields.  */\n-  if (CLASSTYPE_DOSSIER (type) && VFIELD_NAME_P (DECL_NAME (fields)))\n+  if (CLASSTYPE_RTTI (type) && VFIELD_NAME_P (DECL_NAME (fields)))\n     /* Get past vtable for the object.  */\n     fields = TREE_CHAIN (fields);\n "}, {"sha": "13b88f675ec78f26445ec0706f82b3dbf2d190ab", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -1250,9 +1250,8 @@ debug_binfo (elem)\n   virtuals = BINFO_VIRTUALS (elem);\n   if (virtuals != 0)\n     {\n+      /* skip the rtti type descriptor entry */\n       virtuals = TREE_CHAIN (virtuals);\n-      if (flag_dossier)\n-\tvirtuals = TREE_CHAIN (virtuals);\n     }\n   i = 1;\n   while (virtuals)"}, {"sha": "f7289e1af9330a3a46050b3d2a8681bc738ff069", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -3404,6 +3404,10 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    unsigned_arg = TREE_UNSIGNED (TREE_TYPE (op0));\n \n \t  if (TYPE_PRECISION (TREE_TYPE (arg0)) < TYPE_PRECISION (result_type)\n+\t      /* We can shorten only if the shift count is less than the\n+\t\t number of bits in the smaller type size.  */\n+\t      && TREE_INT_CST_HIGH (op1) == 0\n+\t      && TYPE_PRECISION (TREE_TYPE (arg0)) > TREE_INT_CST_LOW (op1)\n \t      /* If arg is sign-extended and then unsigned-shifted,\n \t\t we can simulate this with a signed shift in arg's type\n \t\t only if the extended result is at least twice as wide\n@@ -3756,8 +3760,12 @@ build_x_unary_op (code, xarg)\n {\n   /* & rec, on incomplete RECORD_TYPEs is the simple opr &, not an\n      error message. */\n-  if (code != ADDR_EXPR || TREE_CODE (TREE_TYPE (xarg)) != RECORD_TYPE\n-      || TYPE_SIZE (TREE_TYPE (xarg)))\n+  if (code == ADDR_EXPR\n+      && ((IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (xarg)))\n+\t   && TYPE_SIZE (TREE_TYPE (xarg)) == NULL_TREE)\n+\t  || (TREE_CODE (xarg) == OFFSET_REF)))\n+    /* don't look for a function */;\n+  else\n     {\n       tree rval = build_opfncall (code, LOOKUP_SPECULATIVELY, xarg,\n \t\t\t\t  NULL_TREE, NULL_TREE);\n@@ -3813,6 +3821,9 @@ build_unary_op (code, xarg, noconvert)\n   if (typecode == ENUMERAL_TYPE)\n     typecode = INTEGER_TYPE;\n \n+  if (typecode == BOOLEAN_TYPE && ! noconvert)\n+    typecode = INTEGER_TYPE;\n+\n   isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n \n   switch (code)\n@@ -5435,7 +5446,14 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   if (modifycode == INIT_EXPR)\n     {\n-      if (TYPE_LANG_SPECIFIC (lhstype) && TYPE_HAS_CONSTRUCTOR (lhstype))\n+      if (! IS_AGGR_TYPE (lhstype))\n+\t/* Do the default thing */;\n+      else if (! TYPE_HAS_CONSTRUCTOR (lhstype))\n+\tcp_error (\"`%T' has no constructors\", lhstype);\n+      else if (! TYPE_NEEDS_CONSTRUCTING (lhstype)\n+\t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n+\t/* Do the default thing */;\n+      else\n \t{\n \t  result = build_method_call (lhs, constructor_name_full (lhstype),\n \t\t\t\t      build_tree_list (NULL_TREE, rhs),\n@@ -5449,7 +5467,17 @@ build_modify_expr (lhs, modifycode, rhs)\n     {\n #if 1\n       /* `operator=' is not an inheritable operator.  */\n-      if (TYPE_LANG_SPECIFIC (lhstype) && TYPE_HAS_ASSIGNMENT (lhstype))\n+      if (! IS_AGGR_TYPE (lhstype))\n+\t/* Do the default thing */;\n+      else if (! TYPE_HAS_ASSIGNMENT (lhstype))\n+\tcp_error (\"`%T' does not define operator=\", lhstype);\n+      else if (! TYPE_HAS_REAL_ASSIGNMENT (lhstype)\n+\t       && ! TYPE_HAS_COMPLEX_ASSIGN_REF (lhstype)\n+\t       /* FIXME find some way to deal with TARGET_EXPRs here.  */\n+\t       && TREE_CODE (newrhs) != TARGET_EXPR\n+\t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n+\t/* Do the default thing */;\n+      else\n \t{\n \t  result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n \t\t\t\t   lhs, rhs, make_node (NOP_EXPR));\n@@ -5655,6 +5683,8 @@ build_modify_expr (lhs, modifycode, rhs)\n   if (TREE_SIDE_EFFECTS (newrhs))\n     newrhs = stabilize_reference (newrhs);\n \n+#if 0\n+  /* This is now done by generating X(X&) and operator=(X&). */\n   /* C++: The semantics of C++ differ from those of C when an\n      assignment of an aggregate is desired.  Assignment in C++ is\n      now defined as memberwise assignment of non-static members\n@@ -5673,14 +5703,6 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  || (TREE_CODE (TREE_TYPE (newrhs)) == RECORD_TYPE\n \t      && UNIQUELY_DERIVED_FROM_P (lhstype, TREE_TYPE (newrhs)))))\n     {\n-      /* This was decided in finish_struct.  */\n-      if (modifycode == INIT_EXPR)\n-\tcp_error (\"can't generate default copy constructor for `%T'\", lhstype);\n-      else\n-\tcp_error (\"can't generate default assignment operator for `%T'\",\n-\t\t  lhstype);\n-#if 0\n-      /* This is now done by generating X(X&) and operator=(X&). */\n       tree vbases = CLASSTYPE_VBASECLASSES (lhstype);\n       tree lhs_addr = build_unary_op (ADDR_EXPR, lhs, 0);\n       tree rhs_addr;\n@@ -5756,8 +5778,8 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\t\t\t       TYPE_BINFO (lhstype)),\n \t\t\t  result);\n       return build_compound_expr (result);\n-#endif\n     }\n+#endif\n \n   /* Convert new value to destination type.  */\n \n@@ -5811,13 +5833,15 @@ build_modify_expr (lhs, modifycode, rhs)\n     }\n   else\n     {\n+#if 0\n       if (IS_AGGR_TYPE (lhstype))\n \t{\n \t  if (result = build_opfncall (MODIFY_EXPR,\n \t\t\t\t       LOOKUP_NORMAL, lhs, newrhs,\n \t\t\t\t       make_node (NOP_EXPR)))\n \t    return result;\n \t}\n+#endif\n       /* Avoid warnings on enum bit fields. */\n       if (TREE_CODE (olhstype) == ENUMERAL_TYPE\n \t  && TREE_CODE (lhstype) == INTEGER_TYPE)\n@@ -6603,8 +6627,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n      `convert_for_initialization'.  They should otherwise be\n      bashed before coming here.  */\n   else if (codel == REFERENCE_TYPE)\n-    /* Force an abort.  */\n-    my_friendly_assert (codel != REFERENCE_TYPE, 317);\n+    my_friendly_abort (317);\n   else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (rhs)))\n     {\n       tree nrhs = build1 (NOP_EXPR, type, rhs);\n@@ -6742,6 +6765,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t    }\n \t  /* Handle the case of default parameter initialization and\n \t     initialization of static variables.  */\n+\t  else if (TREE_CODE (rhs) == TARGET_EXPR)\n+\t    return rhs;\n \t  else if (TREE_CODE (rhs) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (rhs))\n \t    {\n \t      my_friendly_assert (TREE_CODE (TREE_OPERAND (rhs, 0)) == CALL_EXPR, 318);"}, {"sha": "417eda0c835bcba711f1462ab09d8e2fa8ea081e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db5ae43ff2ce49f1cbe66a0e16f4e079b702580b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=db5ae43ff2ce49f1cbe66a0e16f4e079b702580b", "patch": "@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 360.  Free: 261.  */\n+/* First used: 0 (reserved), Last used: 361.  Free: */\n \n static int abortcount = 0;\n \n@@ -1342,6 +1342,7 @@ build_m_component_ref (datum, component)\n \n   if (TREE_CODE (objtype) == REFERENCE_TYPE)\n     objtype = TREE_TYPE (objtype);\n+  objtype = TYPE_MAIN_VARIANT (objtype);\n \n   if (! IS_AGGR_TYPE (objtype))\n     {"}]}