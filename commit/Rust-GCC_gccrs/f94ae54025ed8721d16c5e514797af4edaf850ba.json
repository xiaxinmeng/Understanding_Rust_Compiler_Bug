{"sha": "f94ae54025ed8721d16c5e514797af4edaf850ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk0YWU1NDAyNWVkODcyMWQxNmM1ZTUxNDc5N2FmNGVkYWY4NTBiYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-02-24T02:14:49Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-02-24T02:14:49Z"}, "message": "lang-options.h: Added -Wdeprecated.\n\n\t* lang-options.h: Added -Wdeprecated.\n\t* gcj.texi (Warnings): Document -Wdeprecated.\n\t* java-tree.h (flag_deprecated): Declare.\n\t* lang.c (lang_W_options): Added deprecated.\n\t(flag_deprecated): New global.\n\t* chartables.h: Rebuilt.\n\t* gen-table.pl (process_one): Look at whitespace.\n\t(print_tables): Define LETTER_SPACE, LETTER_MASK.\n\t* parse.h (CLEAR_DEPRECATED): New macro.\n\t(CHECK_DEPRECATED_NO_RESET): New macro.\n\t* jcf-parse.c (handle_deprecated): New function.\n\t(HANDLE_DEPRECATED_ATTRIBUTE): New define.\n\t* jcf-reader.c (get_attribute): Handle Deprecated attribute.\n\t* parse.y (resolve_type_during_patch): Check deprecation.\n\t(jdep_resolve_class): Likewise.\n\t(process_imports): Likewise.\n\t(resolve_expression_name): Likewise.\n\t(check_deprecation): Strip arrays from decl.  Check\n\tflag_deprecated.\n\t(patch_method_invocation): Also check the particular constructor\n\tfor deprecation.\n\t(register_fields): Use CHECK_DEPRECATED_NO_RESET in loop.\n\t* jcf-write.c (append_deprecated_attribute): New function.\n\t(generate_classfile): Generate deprecated attribute when\n\tappropriate.\n\t* lex.c (java_parse_doc_section): Return type now void.  Rewrote.\n\t(java_lex) [case '*']: Simplify logic.\n\t(java_start_char_p): Use LETTER_MASK.\n\t(java_part_char_p): Likewise.\n\t(java_space_char_p): New function.\n\nFrom-SVN: r63350", "tree": {"sha": "d282aebf536e61a47d7f1fade565cbb3e83027e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d282aebf536e61a47d7f1fade565cbb3e83027e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f94ae54025ed8721d16c5e514797af4edaf850ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f94ae54025ed8721d16c5e514797af4edaf850ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f94ae54025ed8721d16c5e514797af4edaf850ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f94ae54025ed8721d16c5e514797af4edaf850ba/comments", "author": null, "committer": null, "parents": [{"sha": "804b2c48eab2cb65fb0ae268c8a40e91c24777ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804b2c48eab2cb65fb0ae268c8a40e91c24777ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804b2c48eab2cb65fb0ae268c8a40e91c24777ff"}], "stats": {"total": 5444, "additions": 2832, "deletions": 2612}, "files": [{"sha": "ef8e919c612bbb18e543befca8428f306472023c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -1,3 +1,36 @@\n+2003-02-23  Tom Tromey  <tromey@redhat.com>\n+\n+\t* lang-options.h: Added -Wdeprecated.\n+\t* gcj.texi (Warnings): Document -Wdeprecated.\n+\t* java-tree.h (flag_deprecated): Declare.\n+\t* lang.c (lang_W_options): Added deprecated.\n+\t(flag_deprecated): New global.\n+\t* chartables.h: Rebuilt.\n+\t* gen-table.pl (process_one): Look at whitespace.\n+\t(print_tables): Define LETTER_SPACE, LETTER_MASK.\n+\t* parse.h (CLEAR_DEPRECATED): New macro.\n+\t(CHECK_DEPRECATED_NO_RESET): New macro.\n+\t* jcf-parse.c (handle_deprecated): New function.\n+\t(HANDLE_DEPRECATED_ATTRIBUTE): New define.\n+\t* jcf-reader.c (get_attribute): Handle Deprecated attribute.\n+\t* parse.y (resolve_type_during_patch): Check deprecation.\n+\t(jdep_resolve_class): Likewise.\n+\t(process_imports): Likewise.\n+\t(resolve_expression_name): Likewise.\n+\t(check_deprecation): Strip arrays from decl.  Check\n+\tflag_deprecated.\n+\t(patch_method_invocation): Also check the particular constructor\n+\tfor deprecation.\n+\t(register_fields): Use CHECK_DEPRECATED_NO_RESET in loop.\n+\t* jcf-write.c (append_deprecated_attribute): New function.\n+\t(generate_classfile): Generate deprecated attribute when\n+\tappropriate.\n+\t* lex.c (java_parse_doc_section): Return type now void.  Rewrote.\n+\t(java_lex) [case '*']: Simplify logic.\n+\t(java_start_char_p): Use LETTER_MASK.\n+\t(java_part_char_p): Likewise.\n+\t(java_space_char_p): New function.\n+\n 2003-02-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tChange base class access representation."}, {"sha": "7cb5f86cb62038a118d782f0be49533ae34934ab", "filename": "gcc/java/chartables.h", "status": "modified", "additions": 2552, "deletions": 2545, "changes": 5097, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fchartables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fchartables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fchartables.h?ref=f94ae54025ed8721d16c5e514797af4edaf850ba"}, {"sha": "849602441eac0050e649d215b2cea1370829f377", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -341,6 +341,9 @@ This option will cause @command{gcj} not to warn when a source file is\n newer than its matching class file.  By default @command{gcj} will warn\n about this.\n \n+@item -Wno-deprecated\n+Warn if a deprecated class, method, or field is referred to.\n+\n @item -Wunused\n This is the same as @command{gcc}'s @code{-Wunused}.\n "}, {"sha": "df06687f4d4634e92577213217b9f2333814f6f2", "filename": "gcc/java/gen-table.pl", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fgen-table.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fgen-table.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgen-table.pl?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -1,6 +1,6 @@\n #! /usr/bin/perl\n \n-#    Copyright (C) 2000, 2001 Free Software Foundation\n+#    Copyright (C) 2000, 2001, 2003 Free Software Foundation\n \n #    This program is free software; you can redistribute it and/or modify\n #    it under the terms of the GNU General Public License as published by\n@@ -130,15 +130,15 @@ sub process_one\n {\n     my ($code, @fields) = @_;\n \n-    my $value = '';\n+    my @value = ();\n     my $type = $fields[$CATEGORY];\n \n     # See if the character is a valid identifier start.\n     if ($type =~ /L./\t\t# Letter\n \t|| $type eq 'Pc'\t# Connecting punctuation\n \t|| $type eq 'Sc')\t# Currency symbol\n     {\n-\t$value = 'LETTER_START';\n+\tpush (@value, 'LETTER_START');\n     }\n \n     # See if the character is a valid identifier member.\n@@ -159,23 +159,29 @@ sub process_one\n \t    && $code <= 0x206f)\n \t|| $code == 0xfeff)\t# ZWNBSP\n     {\n-\tif ($value eq '')\n-\t{\n-\t    $value = 'LETTER_PART';\n-\t}\n-\telse\n-\t{\n-\t    $value = 'LETTER_PART | ' . $value;\n-\t}\n+\tpush (@value, 'LETTER_PART');\n+    }\n+\n+    if (($type =~ /Z./\n+\t # Java treats some values specially as non-spaces.\n+\t && $code != 0x00a0\n+\t && $code != 0x2007\n+\t && $code != 0x202f)\n+\t# And for our purposes there are some that should be specially\n+\t# treated as spaces.\n+\t|| $code == 0x000b\n+\t|| ($code >= 0x001c && $code <= 0x001f))\n+    {\n+\tpush (@value, 'LETTER_SPACE');\n     }\n \n-    if ($value eq '')\n+    if (! @value)\n     {\n \t$value = '0';\n     }\n     else\n     {\n-\t$value = '(' . $value . ')';\n+\t$value = '(' . join (' | ', @value) . ')';\n     }\n \n     $map[$code] = $value;\n@@ -196,7 +202,9 @@ sub print_tables\n     print OUT \"#define GCC_CHARTABLES_H\\n\\n\";\n \n     print OUT \"#define LETTER_START 1\\n\";\n-    print OUT \"#define LETTER_PART  2\\n\\n\";\n+    print OUT \"#define LETTER_PART  2\\n\";\n+    print OUT \"#define LETTER_SPACE 4\\n\\n\";\n+    print OUT \"#define LETTER_MASK  7\\n\\n\";\n \n     for ($count = 0; $count <= $last; $count += 256)\n     {"}, {"sha": "adfd77eee462d27a7e2f40fe8a96532260dc5b77", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -176,6 +176,9 @@ extern int flag_jni;\n \n extern int flag_extraneous_semicolon;\n \n+/* When nonzero, report use of deprecated classes, methods, or fields.  */\n+extern int flag_deprecated;\n+\n /* When nonzero, always check for a non gcj generated classes archive.  */\n \n extern int flag_force_classes_archive_check;"}, {"sha": "8daceccf4dd17e6919d23f8c200637ea0751f5e4", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -102,10 +102,28 @@ static void parse_source_file_1 (tree, FILE *);\n static void parse_source_file_2 (void);\n static void parse_source_file_3 (void);\n static void parse_class_file (void);\n+static void handle_deprecated (void);\n static void set_source_filename (JCF *, int);\n static void jcf_parse (struct JCF*);\n static void load_inner_classes (tree);\n \n+/* Handle \"Deprecated\" attribute.  */\n+static void\n+handle_deprecated (void)\n+{\n+  if (current_field != NULL_TREE)\n+    FIELD_DEPRECATED (current_field) = 1;\n+  else if (current_method != NULL_TREE)\n+    METHOD_DEPRECATED (current_method) = 1;\n+  else if (current_class != NULL_TREE)\n+    CLASS_DEPRECATED (TYPE_NAME (current_class)) = 1;\n+  else\n+    {\n+      /* Shouldn't happen.  */\n+      abort ();\n+    }\n+}\n+\n /* Handle \"SourceFile\" attribute. */\n \n static void\n@@ -200,6 +218,8 @@ set_source_filename (JCF *jcf, int index)\n   DECL_FUNCTION_THROWS (current_method) = nreverse (list); \\\n }\n \n+#define HANDLE_DEPRECATED_ATTRIBUTE()  handle_deprecated ()\n+\n /* Link seen inner classes to their outer context and register the\n    inner class to its outer context. They will be later loaded.  */\n #define HANDLE_INNERCLASSES_ATTRIBUTE(COUNT) \\"}, {"sha": "9b3ad1617730ff2617eaf7763671750a5b88be68", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -220,6 +220,13 @@ get_attribute (JCF *jcf)\n       HANDLE_GCJCOMPILED_ATTRIBUTE ();\n     }\n   else\n+#endif\n+#ifdef HANDLE_DEPRECATED_ATTRIBUTE\n+  if (MATCH_ATTRIBUTE (\"Deprecated\"))\n+    {\n+      HANDLE_DEPRECATED_ATTRIBUTE ();\n+    }\n+  else\n #endif\n     {\n #ifdef PROCESS_OTHER_ATTRIBUTE"}, {"sha": "583cff929c6217d0ce29402593e3ab740f4039a4", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -341,6 +341,7 @@ static void emit_jsr (struct jcf_block *, struct jcf_partial *);\n static void call_cleanups (struct jcf_block *, struct jcf_partial *);\n static char *make_class_file_name (tree);\n static unsigned char *append_synthetic_attribute (struct jcf_partial *);\n+static void append_deprecated_attribute (struct jcf_partial *);\n static void append_innerclasses_attribute (struct jcf_partial *, tree);\n static void append_innerclasses_attribute_entry (struct jcf_partial *, tree, tree);\n static void append_gcj_attribute (struct jcf_partial *, tree);\n@@ -2871,8 +2872,11 @@ generate_classfile (tree clas, struct jcf_partial *state)\n       if (have_value)\n \tattr_count++;\n \n-      if (FIELD_THISN (part) || FIELD_LOCAL_ALIAS (part) || FIELD_SYNTHETIC (part))\n+      if (FIELD_THISN (part) || FIELD_LOCAL_ALIAS (part)\n+\t  || FIELD_SYNTHETIC (part))\n \tattr_count++;\n+      if (FIELD_DEPRECATED (part))\n+  \tattr_count++;\n \n       PUT2 (attr_count);  /* attributes_count */\n       if (have_value)\n@@ -2894,6 +2898,8 @@ generate_classfile (tree clas, struct jcf_partial *state)\n       if (FIELD_THISN (part) || FIELD_LOCAL_ALIAS (part)\n \t  || FIELD_SYNTHETIC (part))\n \tptr = append_synthetic_attribute (state);\n+      if (FIELD_DEPRECATED (part))\n+ \tappend_deprecated_attribute (state);\n       fields_count++;\n     }\n   ptr = fields_count_ptr;  UNSAFE_PUT2 (fields_count);\n@@ -2929,6 +2935,9 @@ generate_classfile (tree clas, struct jcf_partial *state)\n \t  i++;\n \t  synthetic_p = 1;\n \t}\n+      /* Make room for Deprecated attribute.  */\n+      if (METHOD_DEPRECATED (part))\n+ \ti++;\n \n       PUT2 (i);   /* attributes_count */\n \n@@ -3069,6 +3078,10 @@ generate_classfile (tree clas, struct jcf_partial *state)\n \t      PUT2 (i);\n \t    }\n \t}\n+\n+      if (METHOD_DEPRECATED (part))\n+ \tappend_deprecated_attribute (state);\n+ \n       methods_count++;\n       current_function_decl = save_function;\n     }\n@@ -3092,6 +3105,9 @@ generate_classfile (tree clas, struct jcf_partial *state)\n     i++;\n   PUT2 (i);\t\t\t/* attributes_count */\n \n+  if (CLASS_DEPRECATED (TYPE_NAME (clas)))\n+    i++;\n+\n   /* generate the SourceFile attribute. */\n   if (SourceFile_node == NULL_TREE) \n     {\n@@ -3105,6 +3121,8 @@ generate_classfile (tree clas, struct jcf_partial *state)\n   PUT2 (i);\n   append_gcj_attribute (state, clas);\n   append_innerclasses_attribute (state, clas);\n+  if (CLASS_DEPRECATED (TYPE_NAME (clas)))\n+    append_deprecated_attribute (state);\n \n   /* New finally generate the contents of the constant pool chunk. */\n   i = count_constant_pool_bytes (&state->cpool);\n@@ -3133,6 +3151,17 @@ append_synthetic_attribute (struct jcf_partial *state)\n   return ptr;\n }\n \n+static void\n+append_deprecated_attribute (struct jcf_partial *state)\n+{\n+  unsigned char *ptr = append_chunk (NULL, 6, state);\n+  int i;\n+ \n+  i = find_utf8_constant (&state->cpool, get_identifier (\"Deprecated\"));\n+  PUT2 (i);\t\t/* Attribute string index */\n+  PUT4 (0);\t\t/* Attribute length */\n+}\n+\n static void\n append_gcj_attribute (struct jcf_partial *state, tree class)\n {"}, {"sha": "e0e69ee530763878123bceb61d6f507592479844", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -55,6 +55,8 @@ DEFINE_LANG_NAME (\"Java\")\n     N_(\"Warn if deprecated empty statements are found\") },\n   { \"-Wout-of-date\",\n     N_(\"Warn if .class files are out of date\") },\n+  { \"-Wdeprecated\",\n+    N_(\"Warn if deprecated class, method, or field is used\") },\n   { \"-fforce-classes-archive-check\", \n     N_(\"Always check for non gcj generated classes archives\") },\n   { \"-fno-optimize-static-class-initialization\","}, {"sha": "daa2e4957b81860c3058aee951fd5e027f74a8ab", "filename": "gcc/java/lang.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -168,6 +168,9 @@ const char *current_encoding = NULL;\n /* When nonzero, report the now deprecated empty statements.  */\n int flag_extraneous_semicolon;\n \n+/* When nonzero, report use of deprecated classes, methods, or fields.  */\n+int flag_deprecated = 1;\n+\n /* When nonzero, always check for a non gcj generated classes archive.  */\n int flag_force_classes_archive_check;\n \n@@ -218,7 +221,8 @@ lang_W_options[] =\n {\n   { \"redundant-modifiers\", &flag_redundant, 1 },\n   { \"extraneous-semicolon\", &flag_extraneous_semicolon, 1 },\n-  { \"out-of-date\", &flag_newer, 1 }\n+  { \"out-of-date\", &flag_newer, 1 },\n+  { \"deprecated\", &flag_deprecated, 1 }\n };\n \n JCF *current_jcf;"}, {"sha": "bf263ba3567fc8a987aeb9961c29118c9c8cbdb0", "filename": "gcc/java/lex.c", "status": "modified", "additions": 104, "deletions": 41, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -51,7 +51,8 @@ static void java_store_unicode (struct java_line *, unicode_t, int);\n static int java_parse_escape_sequence (void);\n static int java_start_char_p (unicode_t);\n static int java_part_char_p (unicode_t);\n-static int java_parse_doc_section (int);\n+static int java_space_char_p (unicode_t);\n+static void java_parse_doc_section (int);\n static void java_parse_end_comment (int);\n static int java_get_unicode (void);\n static int java_read_unicode (java_lexer *, int *);\n@@ -673,53 +674,92 @@ java_parse_end_comment (int c)\n    of a documentation comment line (ignoring white space and any `*'\n    character). Parsed keyword(s): @DEPRECATED.  */\n \n-static int\n+static void\n java_parse_doc_section (int c)\n {\n-  int valid_tag = 0, seen_star = 0;\n+  int last_was_star;\n \n-  while (JAVA_WHITE_SPACE_P (c) || (c == '*') || c == '\\n')\n+  /* We reset this here, because only the most recent doc comment\n+     applies to the following declaration.  */\n+  ctxp->deprecated = 0;\n+\n+  /* We loop over all the lines of the comment.  We'll eventually exit\n+     if we hit EOF prematurely, or when we see the comment\n+     terminator.  */\n+  while (1)\n     {\n-      switch (c)\n+      /* These first steps need only be done if we're still looking\n+\t for the deprecated tag.  If we've already seen it, we might\n+\t as well skip looking for it again.  */\n+      if (! ctxp->deprecated)\n \t{\n-\tcase '*':\n-\t  seen_star = 1;\n-\t  break;\n-\tcase '\\n': /* ULT */\n-\t  valid_tag = 1;\n-\tdefault:\n-\t  seen_star = 0;\n-\t}\n-      c = java_get_unicode();\n-    }\n+\t  /* Skip whitespace and '*'s.  We must also check for the end\n+\t     of the comment here.  */\n+\t  while (JAVA_WHITE_SPACE_P (c) || c == '*')\n+\t    {\n+\t      last_was_star = (c == '*');\n+\t      c = java_get_unicode ();\n+\t      if (last_was_star && c == '/')\n+\t\t{\n+\t\t  /* We just saw the comment terminator.  */\n+\t\t  return;\n+\t\t}\n+\t    }\n \n-  if (c == UEOF)\n-    java_lex_error (\"Comment not terminated at end of input\", 0);\n+\t  if (c == UEOF)\n+\t    goto eof;\n \n-  if (seen_star && (c == '/'))\n-    return 1;\t\t\t/* Goto step1 in caller.  */\n+\t  if (c == '@')\n+\t    {\n+\t      const char *deprecated = \"@deprecated\";\n+\t      int i;\n \n-  /* We're parsing `@deprecated'.  */\n-  if (valid_tag && (c == '@'))\n-    {\n-      char tag [11];\n-      int  tag_index = 0;\n+\t      for (i = 0; deprecated[i]; ++i)\n+\t\t{\n+\t\t  if (c != deprecated[i])\n+\t\t    break;\n+\t\t  /* We write the code in this way, with the\n+\t\t     update at the end, so that after the loop\n+\t\t     we're left with the next character in C.  */\n+\t\t  c = java_get_unicode ();\n+\t\t}\n+\n+\t      if (c == UEOF)\n+\t\tgoto eof;\n+\n+\t      /* @deprecated must be followed by a space or newline.\n+\t\t We also allow a '*' in case it appears just before\n+\t\t the end of a comment.  In this position only we also\n+\t\t must allow any Unicode space character.  */\n+\t      if (c == ' ' || c == '\\n' || c == '*' || java_space_char_p (c))\n+\t\t{\n+\t\t  if (! deprecated[i])\n+\t\t    ctxp->deprecated = 1;\n+\t\t}\n+\t    }\n+\t}\n \n-      while (tag_index < 10 && c != UEOF && c != ' ' && c != '\\n')\n+      /* We've examined the relevant content from this line.  Now we\n+\t skip the remaining characters and start over with the next\n+\t line.  We also check for end of comment here.  */\n+      while (c != '\\n' && c != UEOF)\n \t{\n+\t  last_was_star = (c == '*');\n \t  c = java_get_unicode ();\n-\t  tag [tag_index++] = c;\n+\t  if (last_was_star && c == '/')\n+\t    return;\n \t}\n \n       if (c == UEOF)\n-\tjava_lex_error (\"Comment not terminated at end of input\", 0);\n-      tag [tag_index] = '\\0';\n-\n-      if (!strcmp (tag, \"deprecated\"))\n-\tctxp->deprecated = 1;\n+\tgoto eof;\n+      /* We have to advance past the \\n.  */\n+      c = java_get_unicode ();\n+      if (c == UEOF)\n+\tgoto eof;\n     }\n-  java_unget_unicode ();\n-  return 0;\n+\n+ eof:\n+  java_lex_error (\"Comment not terminated at end of input\", 0);\n }\n \n /* Return true if C is a valid start character for a Java identifier.\n@@ -733,7 +773,7 @@ java_start_char_p (unicode_t c)\n   unsigned long val = (unsigned long) page;\n   int flags;\n \n-  if ((val & ~ (LETTER_PART | LETTER_START)) != 0)\n+  if ((val & ~ LETTER_MASK) != 0)\n     flags = page[c & 255];\n   else\n     flags = val;\n@@ -752,14 +792,31 @@ java_part_char_p (unicode_t c)\n   unsigned long val = (unsigned long) page;\n   int flags;\n \n-  if ((val & ~ (LETTER_PART | LETTER_START)) != 0)\n+  if ((val & ~ LETTER_MASK) != 0)\n     flags = page[c & 255];\n   else\n     flags = val;\n \n   return flags & LETTER_PART;\n }\n \n+/* Return true if C is whitespace.  */\n+static int\n+java_space_char_p (unicode_t c)\n+{\n+  unsigned int hi = c / 256;\n+  const char *const page = type_table[hi];\n+  unsigned long val = (unsigned long) page;\n+  int flags;\n+\n+  if ((val & ~ LETTER_MASK) != 0)\n+    flags = page[c & 255];\n+  else\n+    flags = val;\n+\n+  return flags & LETTER_SPACE;\n+}\n+\n static int\n java_parse_escape_sequence (void)\n {\n@@ -940,13 +997,19 @@ java_lex (YYSTYPE *java_lval)\n \tcase '*':\n \t  if ((c = java_get_unicode ()) == '*')\n \t    {\n-\t      if ((c = java_get_unicode ()) == '/')\n-\t\tgoto step1;\t/* Empty documentation comment.  */\n-\t      else if (java_parse_doc_section (c))\n-\t\tgoto step1;\n+\t      c = java_get_unicode ();\n+\t      if (c == '/')\n+\t\t{\n+\t\t  /* Empty documentation comment.  We have to reset\n+\t\t     the deprecation marker as only the most recent\n+\t\t     doc comment applies.  */\n+\t\t  ctxp->deprecated = 0;\n+\t\t}\n+\t      else\n+\t\tjava_parse_doc_section (c);\n \t    }\n-\n-\t  java_parse_end_comment ((c = java_get_unicode ()));\n+\t  else\n+\t    java_parse_end_comment ((c = java_get_unicode ()));\n \t  goto step1;\n \t  break;\n \tdefault:"}, {"sha": "17806dc21a89a367b4f7ce532e9fe07cd1a5f9a0", "filename": "gcc/java/parse.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -700,6 +700,14 @@ typedef struct jdeplist_s jdeplist;\n       java_check_regular_methods ((CLASS));\t\\\n   }\n \n+#define CLEAR_DEPRECATED  ctxp->deprecated = 0\n+\n+#define CHECK_DEPRECATED_NO_RESET(DECL)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    if (ctxp->deprecated)\t\t\t\\\n+      DECL_DEPRECATED (DECL) = 1;\t\t\\\n+  }\n+\n /* Using and reseting the @deprecated tag flag */\n #define CHECK_DEPRECATED(DECL)\t\t\t\\\n   {\t\t\t\t\t\t\\"}, {"sha": "6745cec95ba732815af3db7a742074921306700c", "filename": "gcc/java/parse.y", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f94ae54025ed8721d16c5e514797af4edaf850ba/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=f94ae54025ed8721d16c5e514797af4edaf850ba", "patch": "@@ -4289,7 +4289,7 @@ register_fields (int flags, tree type, tree variable_list)\n       else\n \tlineno = EXPR_WFL_LINENO (cl);\n       field_decl = add_field (class_type, current_name, real_type, flags);\n-      CHECK_DEPRECATED (field_decl);\n+      CHECK_DEPRECATED_NO_RESET (field_decl);\n \n       /* If the field denotes a final instance variable, then we\n \t allocate a LANG_DECL_SPECIFIC part to keep track of its\n@@ -4347,6 +4347,8 @@ register_fields (int flags, tree type, tree variable_list)\n \t  DECL_INITIAL (field_decl) = TREE_OPERAND (init, 1);\n \t}\n     }\n+\n+  CLEAR_DEPRECATED;\n   lineno = saved_lineno;\n }\n \n@@ -5460,6 +5462,10 @@ jdep_resolve_class (jdep *dep)\n       decl = resolve_class (JDEP_ENCLOSING (dep), JDEP_TO_RESOLVE (dep),\n \t\t\t    JDEP_DECL (dep), JDEP_WFL (dep));\n       JDEP_RESOLVED (dep, decl);\n+      /* If there is no WFL, that's ok.  We generate this warning\n+\t elsewhere.  */\n+      if (JDEP_WFL (dep) != NULL_TREE)\n+\tcheck_deprecation (JDEP_WFL (dep), decl);\n     }\n \n   if (!decl)\n@@ -6647,7 +6653,11 @@ process_imports (void)\n \n \t  /* We found it, we can bail out */\n \t  if (IDENTIFIER_CLASS_VALUE (to_be_found))\n-\t    break;\n+\t    {\n+\t      check_deprecation (TREE_PURPOSE (import),\n+\t\t\t\t IDENTIFIER_CLASS_VALUE (to_be_found));\n+\t      break;\n+\t    }\n \n \t  /* We haven't found it. Maybe we're trying to access an\n \t     inner class.  The only way for us to know is to try again\n@@ -9154,6 +9164,8 @@ resolve_expression_name (tree id, tree *orig)\n \t      if (FIELD_LOCAL_ALIAS_USED (decl))\n \t\tname = DECL_NAME (decl);\n \n+\t      check_deprecation (id, decl);\n+\n \t      /* Instance variable (8.3.1.1) can't appear within\n \t\t static method, static initializer or initializer for\n \t\t a static variable. */\n@@ -9952,22 +9964,40 @@ not_accessible_p (tree reference, tree member, tree where, int from_super)\n static void\n check_deprecation (tree wfl, tree decl)\n {\n-  const char *file = DECL_SOURCE_FILE (decl);\n+  const char *file;\n+  tree elt;\n+\n+  if (! flag_deprecated)\n+    return;\n+\n+  /* We want to look at the element type of arrays here, so we strip\n+     all surrounding array types.  */\n+  if (TYPE_ARRAY_P (TREE_TYPE (decl)))\n+    {\n+      elt = TREE_TYPE (decl);\n+      while (TYPE_ARRAY_P (elt))\n+\telt = TYPE_ARRAY_ELEMENT (elt);\n+      /* We'll end up with a pointer type, so we use TREE_TYPE to go\n+\t to the record.  */\n+      decl = TYPE_NAME (TREE_TYPE (elt));\n+    }\n+  file = DECL_SOURCE_FILE (decl);\n+\n   /* Complain if the field is deprecated and the file it was defined\n      in isn't compiled at the same time the file which contains its\n      use is */\n   if (DECL_DEPRECATED (decl)\n       && !IS_A_COMMAND_LINE_FILENAME_P (get_identifier (file)))\n     {\n-      char the [20];\n+      const char *the;\n       switch (TREE_CODE (decl))\n \t{\n \tcase FUNCTION_DECL:\n-\t  strcpy (the, \"method\");\n+\t  the = \"method\";\n \t  break;\n \tcase FIELD_DECL:\n \tcase VAR_DECL:\n-\t  strcpy (the, \"field\");\n+\t  the = \"field\";\n \t  break;\n \tcase TYPE_DECL:\n \t  parse_warning_context (wfl, \"The class `%s' has been deprecated\",\n@@ -10336,11 +10366,10 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n     }\n \n   /* Deprecation check: check whether the method being invoked or the\n-     instance-being-created's type are deprecated. */\n+     instance-being-created's type are deprecated.  */\n   if (TREE_CODE (patch) == NEW_CLASS_EXPR)\n     check_deprecation (wfl, TYPE_NAME (DECL_CONTEXT (list)));\n-  else\n-    check_deprecation (wfl, list);\n+  check_deprecation (wfl, list);\n \n   /* If invoking a innerclass constructor, there are hidden parameters\n      to pass */\n@@ -13383,7 +13412,7 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n \t}\n       break;\n \n-      /* 15.19.1 Type Comparison Operator instaceof */\n+      /* 15.19.1 Type Comparison Operator instanceof */\n     case INSTANCEOF_EXPR:\n \n       TREE_TYPE (node) = boolean_type_node;\n@@ -14134,10 +14163,14 @@ resolve_type_during_patch (tree type)\n \t\t\t       IDENTIFIER_POINTER (EXPR_WFL_NODE (type)));\n \t  return NULL_TREE;\n \t}\n+\n+      check_deprecation (type, type_decl);\n+\n       return TREE_TYPE (type_decl);\n     }\n   return type;\n }\n+\n /* 5.5 Casting Conversion. error_mark_node is returned if an error is\n    found. Otherwise NODE or something meant to replace it is returned.  */\n "}]}