{"sha": "8df3dbb75b31332a750459ed78f79c06e63a509c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRmM2RiYjc1YjMxMzMyYTc1MDQ1OWVkNzhmNzljMDZlNjNhNTA5Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-11-15T04:04:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-11-15T04:04:03Z"}, "message": "re PR middle-end/18480 (ICE in emit_group_move with recent change)\n\n        PR 18480\n        * calls.c (struct arg_data): Add parallel_value.\n        (precompute_register_parameters): Set it.\n        (load_register_parameters): Use it.\n        (store_one_arg): Also set it here.\n\nFrom-SVN: r90649", "tree": {"sha": "d05dc008468c762c2853856bd22d3a9a9b7a7b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d05dc008468c762c2853856bd22d3a9a9b7a7b40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8df3dbb75b31332a750459ed78f79c06e63a509c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df3dbb75b31332a750459ed78f79c06e63a509c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8df3dbb75b31332a750459ed78f79c06e63a509c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df3dbb75b31332a750459ed78f79c06e63a509c/comments", "author": null, "committer": null, "parents": [{"sha": "18522563e0d346db259fc6404b54c95e4155ae48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18522563e0d346db259fc6404b54c95e4155ae48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18522563e0d346db259fc6404b54c95e4155ae48"}], "stats": {"total": 23, "additions": 21, "deletions": 2}, "files": [{"sha": "7c2e32d500496bd94c31d586727006b33ef325cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df3dbb75b31332a750459ed78f79c06e63a509c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df3dbb75b31332a750459ed78f79c06e63a509c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8df3dbb75b31332a750459ed78f79c06e63a509c", "patch": "@@ -1,3 +1,11 @@\n+2004-11-14  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 18480\n+\t* calls.c (struct arg_data): Add parallel_value.\n+\t(precompute_register_parameters): Set it.\n+\t(load_register_parameters): Use it.\n+\t(store_one_arg): Also set it here.\n+\n 2004-11-14  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/18431"}, {"sha": "720ffb7de76ac08cc36a8058afed15213215cecf", "filename": "gcc/calls.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df3dbb75b31332a750459ed78f79c06e63a509c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df3dbb75b31332a750459ed78f79c06e63a509c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=8df3dbb75b31332a750459ed78f79c06e63a509c", "patch": "@@ -64,6 +64,9 @@ struct arg_data\n      This is not the same register as for normal calls on machines with\n      register windows.  */\n   rtx tail_call_reg;\n+  /* If REG is a PARALLEL, this is a copy of VALUE pulled into the correct\n+     form for emit_group_move.  */\n+  rtx parallel_value;\n   /* If REG was promoted from the actual mode of the argument expression,\n      indicates whether the promotion is sign- or zero-extended.  */\n   int unsignedp;\n@@ -686,7 +689,7 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,\n \tif (GET_CODE (args[i].reg) == PARALLEL)\n \t  {\n \t    tree type = TREE_TYPE (args[i].tree_value);\n-\t    args[i].value\n+\t    args[i].parallel_value\n \t      = emit_group_load_into_temps (args[i].reg, args[i].value,\n \t\t\t\t\t    type, int_size_in_bytes (type));\n \t  }\n@@ -1466,7 +1469,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t     locations.  The Irix 6 ABI has examples of this.  */\n \n \t  if (GET_CODE (reg) == PARALLEL)\n-\t    emit_group_move (reg, args[i].value);\n+\t    emit_group_move (reg, args[i].parallel_value);\n \n \t  /* If simple case, just do move.  If normal partial, store_one_arg\n \t     has already loaded the register for us.  In all other cases,\n@@ -4187,6 +4190,14 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \targ->value = arg->stack_slot;\n     }\n \n+  if (arg->reg && GET_CODE (arg->reg) == PARALLEL)\n+    {\n+      tree type = TREE_TYPE (arg->tree_value);\n+      arg->parallel_value\n+\t= emit_group_load_into_temps (arg->reg, arg->value, type,\n+\t\t\t\t      int_size_in_bytes (type));\n+    }\n+\n   /* Mark all slots this store used.  */\n   if (ACCUMULATE_OUTGOING_ARGS && !(flags & ECF_SIBCALL)\n       && argblock && ! variable_size && arg->stack)"}]}