{"sha": "7a32a925c5f52ac95f4af8ca77ec7d77cc42282a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EzMmE5MjVjNWY1MmFjOTVmNGFmOGNhNzdlYzdkNzdjYzQyMjgyYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-11-23T23:27:23Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-11-23T23:27:23Z"}, "message": "combine.c (gen_lowpart_for_combine): Factor out mode of x as well as mode sizes into local temporaries.\n\n        * combine.c (gen_lowpart_for_combine): Factor out mode of x as well\n        as mode sizes into local temporaries.  Unify failure path.\n\nFrom-SVN: r91118", "tree": {"sha": "1a8ff7bb494da9e7f9329eeeca7982c1eeebc7b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a8ff7bb494da9e7f9329eeeca7982c1eeebc7b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a32a925c5f52ac95f4af8ca77ec7d77cc42282a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a32a925c5f52ac95f4af8ca77ec7d77cc42282a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a32a925c5f52ac95f4af8ca77ec7d77cc42282a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a32a925c5f52ac95f4af8ca77ec7d77cc42282a/comments", "author": null, "committer": null, "parents": [{"sha": "b5b3e36a98b42afa15fe85a1e2296e9b1d4ac37f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b3e36a98b42afa15fe85a1e2296e9b1d4ac37f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5b3e36a98b42afa15fe85a1e2296e9b1d4ac37f"}], "stats": {"total": 71, "additions": 37, "deletions": 34}, "files": [{"sha": "81149d2f80a921154755a58391218fcb0092172b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a32a925c5f52ac95f4af8ca77ec7d77cc42282a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a32a925c5f52ac95f4af8ca77ec7d77cc42282a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a32a925c5f52ac95f4af8ca77ec7d77cc42282a", "patch": "@@ -14,6 +14,11 @@\n \t* doc/tm.texi (c_register_pragma_with_expansion,\n \tHANDLE_PRAGMA_PACK_WITH_EXPANSION): Document.\n \n+2004-11-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* combine.c (gen_lowpart_for_combine): Factor out mode of x as well\n+\tas mode sizes into local temporaries.  Unify failure path.\n+\n 2004-11-23  Richard Henderson  <rth@redhat.com>\n \n \t* emit-rtl.c, rtl.h (subreg_hard_regno): Remove."}, {"sha": "ce198bbc10af1fbd6bf7f741988f380f16400572", "filename": "gcc/combine.c", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a32a925c5f52ac95f4af8ca77ec7d77cc42282a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a32a925c5f52ac95f4af8ca77ec7d77cc42282a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7a32a925c5f52ac95f4af8ca77ec7d77cc42282a", "patch": "@@ -9308,42 +9308,44 @@ recog_for_combine (rtx *pnewpat, rtx insn, rtx *pnotes)\n    An insn containing that will not be recognized.  */\n \n static rtx\n-gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n+gen_lowpart_for_combine (enum machine_mode omode, rtx x)\n {\n+  enum machine_mode imode = GET_MODE (x);\n+  unsigned int osize = GET_MODE_SIZE (omode);\n+  unsigned int isize = GET_MODE_SIZE (imode);\n   rtx result;\n \n-  if (GET_MODE (x) == mode)\n+  if (omode == imode)\n     return x;\n \n-  /* Return identity if this is a CONST or symbolic\n-     reference.  */\n-  if (mode == Pmode\n+  /* Return identity if this is a CONST or symbolic reference.  */\n+  if (omode == Pmode\n       && (GET_CODE (x) == CONST\n \t  || GET_CODE (x) == SYMBOL_REF\n \t  || GET_CODE (x) == LABEL_REF))\n     return x;\n \n   /* We can only support MODE being wider than a word if X is a\n      constant integer or has a mode the same size.  */\n-\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && ! ((GET_MODE (x) == VOIDmode\n+  if (GET_MODE_SIZE (omode) > UNITS_PER_WORD\n+      && ! ((imode == VOIDmode\n \t     && (GET_CODE (x) == CONST_INT\n \t\t || GET_CODE (x) == CONST_DOUBLE))\n-\t    || GET_MODE_SIZE (GET_MODE (x)) == GET_MODE_SIZE (mode)))\n-    return gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n+\t    || isize == osize))\n+    goto fail;\n \n   /* X might be a paradoxical (subreg (mem)).  In that case, gen_lowpart\n      won't know what to do.  So we will strip off the SUBREG here and\n      process normally.  */\n   if (GET_CODE (x) == SUBREG && MEM_P (SUBREG_REG (x)))\n     {\n       x = SUBREG_REG (x);\n-      if (GET_MODE (x) == mode)\n+      if (GET_MODE (x) == omode)\n \treturn x;\n     }\n \n-  result = gen_lowpart_common (mode, x);\n+  result = gen_lowpart_common (omode, x);\n+\n #ifdef CANNOT_CHANGE_MODE_CLASS\n   if (result != 0 && GET_CODE (result) == SUBREG)\n     record_subregs_of_mode (result);\n@@ -9359,33 +9361,28 @@ gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n       /* Refuse to work on a volatile memory ref or one with a mode-dependent\n \t address.  */\n       if (MEM_VOLATILE_P (x) || mode_dependent_address_p (XEXP (x, 0)))\n-\treturn gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n+\tgoto fail;\n \n       /* If we want to refer to something bigger than the original memref,\n \t generate a paradoxical subreg instead.  That will force a reload\n \t of the original memref X.  */\n-      if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode))\n-\treturn gen_rtx_SUBREG (mode, x, 0);\n+      if (isize < osize)\n+\treturn gen_rtx_SUBREG (omode, x, 0);\n \n       if (WORDS_BIG_ENDIAN)\n-\toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n-\t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n+\toffset = MAX (isize, UNITS_PER_WORD) - MAX (osize, UNITS_PER_WORD);\n \n+      /* Adjust the address so that the address-after-the-data is unchanged. */\n       if (BYTES_BIG_ENDIAN)\n-\t{\n-\t  /* Adjust the address so that the address-after-the-data is\n-\t     unchanged.  */\n-\t  offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n-\t\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n-\t}\n+\toffset -= MIN (UNITS_PER_WORD, osize) - MIN (UNITS_PER_WORD, isize);\n \n-      return adjust_address_nv (x, mode, offset);\n+      return adjust_address_nv (x, omode, offset);\n     }\n \n   /* If X is a comparison operator, rewrite it in a new mode.  This\n      probably won't match, but may allow further simplifications.  */\n   else if (COMPARISON_P (x))\n-    return gen_rtx_fmt_ee (GET_CODE (x), mode, XEXP (x, 0), XEXP (x, 1));\n+    return gen_rtx_fmt_ee (GET_CODE (x), omode, XEXP (x, 0), XEXP (x, 1));\n \n   /* If we couldn't simplify X any other way, just enclose it in a\n      SUBREG.  Normally, this SUBREG won't match, but some patterns may\n@@ -9394,21 +9391,22 @@ gen_lowpart_for_combine (enum machine_mode mode, rtx x)\n     {\n       int offset = 0;\n       rtx res;\n-      enum machine_mode sub_mode = GET_MODE (x);\n \n-      offset = subreg_lowpart_offset (mode, sub_mode);\n-      if (sub_mode == VOIDmode)\n+      offset = subreg_lowpart_offset (omode, imode);\n+      if (imode == VOIDmode)\n \t{\n-\t  sub_mode = int_mode_for_mode (mode);\n-\t  x = gen_lowpart_common (sub_mode, x);\n-\t  if (x == 0)\n-\t    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n+\t  imode = int_mode_for_mode (omode);\n+\t  x = gen_lowpart_common (imode, x);\n+\t  if (x == NULL)\n+\t    goto fail;\n \t}\n-      res = simplify_gen_subreg (mode, x, sub_mode, offset);\n+      res = simplify_gen_subreg (omode, x, imode, offset);\n       if (res)\n \treturn res;\n-      return gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n     }\n+\n+ fail:\n+  return gen_rtx_CLOBBER (imode, const0_rtx);\n }\n \f\n /* These routines make binary and unary operations by first seeing if they"}]}