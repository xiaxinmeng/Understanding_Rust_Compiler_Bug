{"sha": "c59e1214f746c120caf4849daeffc11681f9d660", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU5ZTEyMTRmNzQ2YzEyMGNhZjQ4NDlkYWVmZmMxMTY4MWY5ZDY2MA==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2012-06-18T18:06:54Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2012-06-18T18:06:54Z"}, "message": "As a result of the previous changes, epilogue_insns pattern can only be generated in Thumb1.\n\nAs a result of the previous changes, epilogue_insns pattern can only be\ngenerated in Thumb1. After removing other cases in define_insn for\nepilogue_insns, the function arm_output_epilogue becomes dead code and can\nbe eliminated, along with all its helper functions.\n\ngcc/\n\n2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n            Sameera Deshpande  <sameera.deshpande@arm.com>\n            Greta Yorsh  <greta.yorsh@arm.com>\n\n        * config/arm/arm-protos.h (arm_output_epilogue): Remove.\n        * config/arm/arm.c (print_multi_reg): Remove.\n        (vfp_output_fldmd): Likewise.\n        (arm_output_epilogue): Likewise.\n        * config/arm/arm.md (epilogue_insns): Update condition and code.\n\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\nCo-Authored-By: Sameera Deshpande <sameera.deshpande@arm.com>\n\nFrom-SVN: r188745", "tree": {"sha": "7ab5dda29f244b059e98a2c3c2393e6b8f265fcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ab5dda29f244b059e98a2c3c2393e6b8f265fcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c59e1214f746c120caf4849daeffc11681f9d660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59e1214f746c120caf4849daeffc11681f9d660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c59e1214f746c120caf4849daeffc11681f9d660", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59e1214f746c120caf4849daeffc11681f9d660/comments", "author": null, "committer": null, "parents": [{"sha": "482baa63f3076b7d954f3b152514a0d69f11a74a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482baa63f3076b7d954f3b152514a0d69f11a74a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/482baa63f3076b7d954f3b152514a0d69f11a74a"}], "stats": {"total": 541, "additions": 11, "deletions": 530}, "files": [{"sha": "97659f8003568e35921095a630123c2abf11e716", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59e1214f746c120caf4849daeffc11681f9d660/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59e1214f746c120caf4849daeffc11681f9d660/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c59e1214f746c120caf4849daeffc11681f9d660", "patch": "@@ -1,3 +1,13 @@\n+2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n+            Sameera Deshpande  <sameera.deshpande@arm.com>\n+            Greta Yorsh  <greta.yorsh@arm.com>\n+\n+        * config/arm/arm-protos.h (arm_output_epilogue): Remove.\n+        * config/arm/arm.c (print_multi_reg): Remove.\n+        (vfp_output_fldmd): Likewise.\n+        (arm_output_epilogue): Likewise.\n+        * config/arm/arm.md (epilogue_insns): Update condition and code.\n+\n 2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n             Sameera Deshpande  <sameera.deshpande@arm.com>\n             Greta Yorsh  <greta.yorsh@arm.com>"}, {"sha": "76e1abd0b1f3223c4fb5d7ec9c05e2cac4c34218", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59e1214f746c120caf4849daeffc11681f9d660/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59e1214f746c120caf4849daeffc11681f9d660/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c59e1214f746c120caf4849daeffc11681f9d660", "patch": "@@ -28,7 +28,6 @@ extern int use_return_insn (int, rtx);\n extern enum reg_class arm_regno_class (int);\n extern void arm_load_pic_register (unsigned long);\n extern int arm_volatile_func (void);\n-extern const char *arm_output_epilogue (rtx);\n extern void arm_expand_prologue (void);\n extern void arm_expand_epilogue (bool);\n extern void thumb2_expand_return (void);"}, {"sha": "627b436e1af4c22374191d328605040dd48c25b2", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 525, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59e1214f746c120caf4849daeffc11681f9d660/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59e1214f746c120caf4849daeffc11681f9d660/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c59e1214f746c120caf4849daeffc11681f9d660", "patch": "@@ -13659,86 +13659,6 @@ fp_const_from_val (REAL_VALUE_TYPE *r)\n   return \"0\";\n }\n \n-/* Output the operands of a LDM/STM instruction to STREAM.\n-   MASK is the ARM register set mask of which only bits 0-15 are important.\n-   REG is the base register, either the frame pointer or the stack pointer,\n-   INSTR is the possibly suffixed load or store instruction.\n-   RFE is nonzero if the instruction should also copy spsr to cpsr.  */\n-\n-static void\n-print_multi_reg (FILE *stream, const char *instr, unsigned reg,\n-\t\t unsigned long mask, int rfe)\n-{\n-  unsigned i;\n-  bool not_first = FALSE;\n-\n-  gcc_assert (!rfe || (mask & (1 << PC_REGNUM)));\n-  fputc ('\\t', stream);\n-  asm_fprintf (stream, instr, reg);\n-  fputc ('{', stream);\n-\n-  for (i = 0; i <= LAST_ARM_REGNUM; i++)\n-    if (mask & (1 << i))\n-      {\n-\tif (not_first)\n-\t  fprintf (stream, \", \");\n-\n-\tasm_fprintf (stream, \"%r\", i);\n-\tnot_first = TRUE;\n-      }\n-\n-  if (rfe)\n-    fprintf (stream, \"}^\\n\");\n-  else\n-    fprintf (stream, \"}\\n\");\n-}\n-\n-\n-/* Output a FLDMD instruction to STREAM.\n-   BASE if the register containing the address.\n-   REG and COUNT specify the register range.\n-   Extra registers may be added to avoid hardware bugs.\n-\n-   We output FLDMD even for ARMv5 VFP implementations.  Although\n-   FLDMD is technically not supported until ARMv6, it is believed\n-   that all VFP implementations support its use in this context.  */\n-\n-static void\n-vfp_output_fldmd (FILE * stream, unsigned int base, int reg, int count)\n-{\n-  int i;\n-\n-  /* Workaround ARM10 VFPr1 bug.  */\n-  if (count == 2 && !arm_arch6)\n-    {\n-      if (reg == 15)\n-\treg--;\n-      count++;\n-    }\n-\n-  /* FLDMD may not load more than 16 doubleword registers at a time. Split the\n-     load into multiple parts if we have to handle more than 16 registers.  */\n-  if (count > 16)\n-    {\n-      vfp_output_fldmd (stream, base, reg, 16);\n-      vfp_output_fldmd (stream, base, reg + 16, count - 16);\n-      return;\n-    }\n-\n-  fputc ('\\t', stream);\n-  asm_fprintf (stream, \"fldmfdd\\t%r!, {\", base);\n-\n-  for (i = reg; i < reg + count; i++)\n-    {\n-      if (i > reg)\n-\tfputs (\", \", stream);\n-      asm_fprintf (stream, \"d%d\", i);\n-    }\n-  fputs (\"}\\n\", stream);\n-\n-}\n-\n-\n /* OPERANDS[0] is the entire list of insns that constitute pop,\n    OPERANDS[1] is the base register, RETURN_PC is true iff return insn\n    is in the list, UPDATE is true iff the list contains explicit\n@@ -15833,451 +15753,6 @@ arm_output_function_prologue (FILE *f, HOST_WIDE_INT frame_size)\n \n }\n \n-const char *\n-arm_output_epilogue (rtx sibling)\n-{\n-  int reg;\n-  unsigned long saved_regs_mask;\n-  unsigned long func_type;\n-  /* Floats_offset is the offset from the \"virtual\" frame.  In an APCS\n-     frame that is $fp + 4 for a non-variadic function.  */\n-  int floats_offset = 0;\n-  rtx operands[3];\n-  FILE * f = asm_out_file;\n-  unsigned int lrm_count = 0;\n-  int really_return = (sibling == NULL);\n-  int start_reg;\n-  arm_stack_offsets *offsets;\n-\n-  /* If we have already generated the return instruction\n-     then it is futile to generate anything else.  */\n-  if (use_return_insn (FALSE, sibling) &&\n-      (cfun->machine->return_used_this_function != 0))\n-    return \"\";\n-\n-  func_type = arm_current_func_type ();\n-\n-  if (IS_NAKED (func_type))\n-    /* Naked functions don't have epilogues.  */\n-    return \"\";\n-\n-  if (IS_VOLATILE (func_type) && TARGET_ABORT_NORETURN)\n-    {\n-      rtx op;\n-\n-      /* A volatile function should never return.  Call abort.  */\n-      op = gen_rtx_SYMBOL_REF (Pmode, NEED_PLT_RELOC ? \"abort(PLT)\" : \"abort\");\n-      assemble_external_libcall (op);\n-      output_asm_insn (\"bl\\t%a0\", &op);\n-\n-      return \"\";\n-    }\n-\n-  /* If we are throwing an exception, then we really must be doing a\n-     return, so we can't tail-call.  */\n-  gcc_assert (!crtl->calls_eh_return || really_return);\n-\n-  offsets = arm_get_frame_offsets ();\n-  saved_regs_mask = offsets->saved_regs_mask;\n-\n-  if (TARGET_IWMMXT)\n-    lrm_count = bit_count (saved_regs_mask);\n-\n-  floats_offset = offsets->saved_args;\n-  /* Compute how far away the floats will be.  */\n-  for (reg = 0; reg <= LAST_ARM_REGNUM; reg++)\n-    if (saved_regs_mask & (1 << reg))\n-      floats_offset += 4;\n-\n-  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n-    {\n-      /* This variable is for the Virtual Frame Pointer, not VFP regs.  */\n-      int vfp_offset = offsets->frame;\n-\n-      if (TARGET_FPA_EMU2)\n-\t{\n-\t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n-\t    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n-\t      {\n-\t\tfloats_offset += 12;\n-\t\tasm_fprintf (f, \"\\tldfe\\t%r, [%r, #-%d]\\n\",\n-\t\t\t     reg, FP_REGNUM, floats_offset - vfp_offset);\n-\t      }\n-\t}\n-      else\n-\t{\n-\t  start_reg = LAST_FPA_REGNUM;\n-\n-\t  for (reg = LAST_FPA_REGNUM; reg >= FIRST_FPA_REGNUM; reg--)\n-\t    {\n-\t      if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n-\t\t{\n-\t\t  floats_offset += 12;\n-\n-\t\t  /* We can't unstack more than four registers at once.  */\n-\t\t  if (start_reg - reg == 3)\n-\t\t    {\n-\t\t      asm_fprintf (f, \"\\tlfm\\t%r, 4, [%r, #-%d]\\n\",\n-\t\t\t           reg, FP_REGNUM, floats_offset - vfp_offset);\n-\t\t      start_reg = reg - 1;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (reg != start_reg)\n-\t\t    asm_fprintf (f, \"\\tlfm\\t%r, %d, [%r, #-%d]\\n\",\n-\t\t\t\t reg + 1, start_reg - reg,\n-\t\t\t\t FP_REGNUM, floats_offset - vfp_offset);\n-\t\t  start_reg = reg - 1;\n-\t\t}\n-\t    }\n-\n-\t  /* Just in case the last register checked also needs unstacking.  */\n-\t  if (reg != start_reg)\n-\t    asm_fprintf (f, \"\\tlfm\\t%r, %d, [%r, #-%d]\\n\",\n-\t\t\t reg + 1, start_reg - reg,\n-\t\t\t FP_REGNUM, floats_offset - vfp_offset);\n-\t}\n-\n-      if (TARGET_HARD_FLOAT && TARGET_VFP)\n-\t{\n-\t  int saved_size;\n-\n-\t  /* The fldmd insns do not have base+offset addressing\n-             modes, so we use IP to hold the address.  */\n-\t  saved_size = arm_get_vfp_saved_size ();\n-\n-\t  if (saved_size > 0)\n-\t    {\n-\t      floats_offset += saved_size;\n-\t      asm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\", IP_REGNUM,\n-\t\t\t   FP_REGNUM, floats_offset - vfp_offset);\n-\t    }\n-\t  start_reg = FIRST_VFP_REGNUM;\n-\t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n-\t    {\n-\t      if ((!df_regs_ever_live_p (reg) || call_used_regs[reg])\n-\t\t  && (!df_regs_ever_live_p (reg + 1) || call_used_regs[reg + 1]))\n-\t\t{\n-\t\t  if (start_reg != reg)\n-\t\t    vfp_output_fldmd (f, IP_REGNUM,\n-\t\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n-\t\t\t\t      (reg - start_reg) / 2);\n-\t\t  start_reg = reg + 2;\n-\t\t}\n-\t    }\n-\t  if (start_reg != reg)\n-\t    vfp_output_fldmd (f, IP_REGNUM,\n-\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n-\t\t\t      (reg - start_reg) / 2);\n-\t}\n-\n-      if (TARGET_IWMMXT)\n-\t{\n-\t  /* The frame pointer is guaranteed to be non-double-word aligned.\n-\t     This is because it is set to (old_stack_pointer - 4) and the\n-\t     old_stack_pointer was double word aligned.  Thus the offset to\n-\t     the iWMMXt registers to be loaded must also be non-double-word\n-\t     sized, so that the resultant address *is* double-word aligned.\n-\t     We can ignore floats_offset since that was already included in\n-\t     the live_regs_mask.  */\n-\t  lrm_count += (lrm_count % 2 ? 2 : 1);\n-\n-\t  for (reg = LAST_IWMMXT_REGNUM; reg >= FIRST_IWMMXT_REGNUM; reg--)\n-\t    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n-\t      {\n-\t\tasm_fprintf (f, \"\\twldrd\\t%r, [%r, #-%d]\\n\",\n-\t\t\t     reg, FP_REGNUM, lrm_count * 4);\n-\t\tlrm_count += 2;\n-\t      }\n-\t}\n-\n-      /* saved_regs_mask should contain the IP, which at the time of stack\n-\t frame generation actually contains the old stack pointer.  So a\n-\t quick way to unwind the stack is just pop the IP register directly\n-\t into the stack pointer.  */\n-      gcc_assert (saved_regs_mask & (1 << IP_REGNUM));\n-      saved_regs_mask &= ~ (1 << IP_REGNUM);\n-      saved_regs_mask |=   (1 << SP_REGNUM);\n-\n-      /* There are two registers left in saved_regs_mask - LR and PC.  We\n-\t only need to restore the LR register (the return address), but to\n-\t save time we can load it directly into the PC, unless we need a\n-\t special function exit sequence, or we are not really returning.  */\n-      if (really_return\n-\t  && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n-\t  && !crtl->calls_eh_return)\n-\t/* Delete the LR from the register mask, so that the LR on\n-\t   the stack is loaded into the PC in the register mask.  */\n-\tsaved_regs_mask &= ~ (1 << LR_REGNUM);\n-      else\n-\tsaved_regs_mask &= ~ (1 << PC_REGNUM);\n-\n-      /* We must use SP as the base register, because SP is one of the\n-         registers being restored.  If an interrupt or page fault\n-         happens in the ldm instruction, the SP might or might not\n-         have been restored.  That would be bad, as then SP will no\n-         longer indicate the safe area of stack, and we can get stack\n-         corruption.  Using SP as the base register means that it will\n-         be reset correctly to the original value, should an interrupt\n-         occur.  If the stack pointer already points at the right\n-         place, then omit the subtraction.  */\n-      if (offsets->outgoing_args != (1 + (int) bit_count (saved_regs_mask))\n-\t  || cfun->calls_alloca)\n-\tasm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\", SP_REGNUM, FP_REGNUM,\n-\t\t     4 * bit_count (saved_regs_mask));\n-      print_multi_reg (f, \"ldmfd\\t%r, \", SP_REGNUM, saved_regs_mask, 0);\n-\n-      if (IS_INTERRUPT (func_type))\n-\t/* Interrupt handlers will have pushed the\n-\t   IP onto the stack, so restore it now.  */\n-\tprint_multi_reg (f, \"ldmfd\\t%r!, \", SP_REGNUM, 1 << IP_REGNUM, 0);\n-    }\n-  else\n-    {\n-      /* This branch is executed for ARM mode (non-apcs frames) and\n-\t Thumb-2 mode. Frame layout is essentially the same for those\n-\t cases, except that in ARM mode frame pointer points to the\n-\t first saved register, while in Thumb-2 mode the frame pointer points\n-\t to the last saved register.\n-\n-\t It is possible to make frame pointer point to last saved\n-\t register in both cases, and remove some conditionals below.\n-\t That means that fp setup in prologue would be just \"mov fp, sp\"\n-\t and sp restore in epilogue would be just \"mov sp, fp\", whereas\n-\t now we have to use add/sub in those cases. However, the value\n-\t of that would be marginal, as both mov and add/sub are 32-bit\n-\t in ARM mode, and it would require extra conditionals\n-\t in arm_expand_prologue to distinguish ARM-apcs-frame case\n-\t (where frame pointer is required to point at first register)\n-\t and ARM-non-apcs-frame. Therefore, such change is postponed\n-\t until real need arise.  */\n-      unsigned HOST_WIDE_INT amount;\n-      int rfe;\n-      /* Restore stack pointer if necessary.  */\n-      if (TARGET_ARM && frame_pointer_needed)\n-\t{\n-\t  operands[0] = stack_pointer_rtx;\n-\t  operands[1] = hard_frame_pointer_rtx;\n-\n-\t  operands[2] = GEN_INT (offsets->frame - offsets->saved_regs);\n-\t  output_add_immediate (operands);\n-\t}\n-      else\n-\t{\n-\t  if (frame_pointer_needed)\n-\t    {\n-\t      /* For Thumb-2 restore sp from the frame pointer.\n-\t\t Operand restrictions mean we have to incrememnt FP, then copy\n-\t\t to SP.  */\n-\t      amount = offsets->locals_base - offsets->saved_regs;\n-\t      operands[0] = hard_frame_pointer_rtx;\n-\t    }\n-\t  else\n-\t    {\n-\t      unsigned long count;\n-\t      operands[0] = stack_pointer_rtx;\n-\t      amount = offsets->outgoing_args - offsets->saved_regs;\n-\t      /* pop call clobbered registers if it avoids a\n-\t         separate stack adjustment.  */\n-\t      count = offsets->saved_regs - offsets->saved_args;\n-\t      if (optimize_size\n-\t\t  && count != 0\n-\t\t  && !crtl->calls_eh_return\n-\t\t  && bit_count(saved_regs_mask) * 4 == count\n-\t\t  && !IS_INTERRUPT (func_type)\n-\t\t  && !IS_STACKALIGN (func_type)\n-\t\t  && !crtl->tail_call_emit)\n-\t\t{\n-\t\t  unsigned long mask;\n-                  /* Preserve return values, of any size.  */\n-\t\t  mask = (1 << ((arm_size_return_regs() + 3) / 4)) - 1;\n-\t\t  mask ^= 0xf;\n-\t\t  mask &= ~saved_regs_mask;\n-\t\t  reg = 0;\n-\t\t  while (bit_count (mask) * 4 > amount)\n-\t\t    {\n-\t\t      while ((mask & (1 << reg)) == 0)\n-\t\t\treg++;\n-\t\t      mask &= ~(1 << reg);\n-\t\t    }\n-\t\t  if (bit_count (mask) * 4 == amount) {\n-\t\t      amount = 0;\n-\t\t      saved_regs_mask |= mask;\n-\t\t  }\n-\t\t}\n-\t    }\n-\n-\t  if (amount)\n-\t    {\n-\t      operands[1] = operands[0];\n-\t      operands[2] = GEN_INT (amount);\n-\t      output_add_immediate (operands);\n-\t    }\n-\t  if (frame_pointer_needed)\n-\t    asm_fprintf (f, \"\\tmov\\t%r, %r\\n\",\n-\t\t\t SP_REGNUM, HARD_FRAME_POINTER_REGNUM);\n-\t}\n-\n-      if (TARGET_FPA_EMU2)\n-\t{\n-\t  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n-\t    if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n-\t      asm_fprintf (f, \"\\tldfe\\t%r, [%r], #12\\n\",\n-\t\t\t   reg, SP_REGNUM);\n-\t}\n-      else\n-\t{\n-\t  start_reg = FIRST_FPA_REGNUM;\n-\n-\t  for (reg = FIRST_FPA_REGNUM; reg <= LAST_FPA_REGNUM; reg++)\n-\t    {\n-\t      if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n-\t\t{\n-\t\t  if (reg - start_reg == 3)\n-\t\t    {\n-\t\t      asm_fprintf (f, \"\\tlfmfd\\t%r, 4, [%r]!\\n\",\n-\t\t\t\t   start_reg, SP_REGNUM);\n-\t\t      start_reg = reg + 1;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (reg != start_reg)\n-\t\t    asm_fprintf (f, \"\\tlfmfd\\t%r, %d, [%r]!\\n\",\n-\t\t\t\t start_reg, reg - start_reg,\n-\t\t\t\t SP_REGNUM);\n-\n-\t\t  start_reg = reg + 1;\n-\t\t}\n-\t    }\n-\n-\t  /* Just in case the last register checked also needs unstacking.  */\n-\t  if (reg != start_reg)\n-\t    asm_fprintf (f, \"\\tlfmfd\\t%r, %d, [%r]!\\n\",\n-\t\t\t start_reg, reg - start_reg, SP_REGNUM);\n-\t}\n-\n-      if (TARGET_HARD_FLOAT && TARGET_VFP)\n-\t{\n-\t  int end_reg = LAST_VFP_REGNUM + 1;\n-\n-\t  /* Scan the registers in reverse order.  We need to match\n-\t     any groupings made in the prologue and generate matching\n-\t     pop operations.  */\n-\t  for (reg = LAST_VFP_REGNUM - 1; reg >= FIRST_VFP_REGNUM; reg -= 2)\n-\t    {\n-\t      if ((!df_regs_ever_live_p (reg) || call_used_regs[reg])\n-\t\t  && (!df_regs_ever_live_p (reg + 1)\n-\t\t      || call_used_regs[reg + 1]))\n-\t\t{\n-\t\t  if (end_reg > reg + 2)\n-\t\t    vfp_output_fldmd (f, SP_REGNUM,\n-\t\t\t\t      (reg + 2 - FIRST_VFP_REGNUM) / 2,\n-\t\t\t\t      (end_reg - (reg + 2)) / 2);\n-\t\t  end_reg = reg;\n-\t\t}\n-\t    }\n-\t  if (end_reg > reg + 2)\n-\t    vfp_output_fldmd (f, SP_REGNUM, 0,\n-\t\t\t      (end_reg - (reg + 2)) / 2);\n-\t}\n-\n-      if (TARGET_IWMMXT)\n-\tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n-\t  if (df_regs_ever_live_p (reg) && !call_used_regs[reg])\n-\t    asm_fprintf (f, \"\\twldrd\\t%r, [%r], #8\\n\", reg, SP_REGNUM);\n-\n-      /* If we can, restore the LR into the PC.  */\n-      if (ARM_FUNC_TYPE (func_type) != ARM_FT_INTERWORKED\n-\t  && (TARGET_ARM || ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)\n-\t  && !IS_STACKALIGN (func_type)\n-\t  && really_return\n-\t  && crtl->args.pretend_args_size == 0\n-\t  && saved_regs_mask & (1 << LR_REGNUM)\n-\t  && !crtl->calls_eh_return)\n-\t{\n-\t  saved_regs_mask &= ~ (1 << LR_REGNUM);\n-\t  saved_regs_mask |=   (1 << PC_REGNUM);\n-\t  rfe = IS_INTERRUPT (func_type);\n-\t}\n-      else\n-\trfe = 0;\n-\n-      /* Load the registers off the stack.  If we only have one register\n-\t to load use the LDR instruction - it is faster.  For Thumb-2\n-\t always use pop and the assembler will pick the best instruction.*/\n-      if (TARGET_ARM && saved_regs_mask == (1 << LR_REGNUM)\n-\t  && !IS_INTERRUPT(func_type))\n-\t{\n-\t  asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM, SP_REGNUM);\n-\t}\n-      else if (saved_regs_mask)\n-\t{\n-\t  if (saved_regs_mask & (1 << SP_REGNUM))\n-\t    /* Note - write back to the stack register is not enabled\n-\t       (i.e. \"ldmfd sp!...\").  We know that the stack pointer is\n-\t       in the list of registers and if we add writeback the\n-\t       instruction becomes UNPREDICTABLE.  */\n-\t    print_multi_reg (f, \"ldmfd\\t%r, \", SP_REGNUM, saved_regs_mask,\n-\t\t\t     rfe);\n-\t  else if (TARGET_ARM)\n-\t    print_multi_reg (f, \"ldmfd\\t%r!, \", SP_REGNUM, saved_regs_mask,\n-\t\t\t     rfe);\n-\t  else\n-\t    print_multi_reg (f, \"pop\\t\", SP_REGNUM, saved_regs_mask, 0);\n-\t}\n-\n-      if (crtl->args.pretend_args_size)\n-\t{\n-\t  /* Unwind the pre-pushed regs.  */\n-\t  operands[0] = operands[1] = stack_pointer_rtx;\n-\t  operands[2] = GEN_INT (crtl->args.pretend_args_size);\n-\t  output_add_immediate (operands);\n-\t}\n-    }\n-\n-  /* We may have already restored PC directly from the stack.  */\n-  if (!really_return || saved_regs_mask & (1 << PC_REGNUM))\n-    return \"\";\n-\n-  /* Stack adjustment for exception handler.  */\n-  if (crtl->calls_eh_return)\n-    asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n-\t\t ARM_EH_STACKADJ_REGNUM);\n-\n-  /* Generate the return instruction.  */\n-  switch ((int) ARM_FUNC_TYPE (func_type))\n-    {\n-    case ARM_FT_ISR:\n-    case ARM_FT_FIQ:\n-      asm_fprintf (f, \"\\tsubs\\t%r, %r, #4\\n\", PC_REGNUM, LR_REGNUM);\n-      break;\n-\n-    case ARM_FT_EXCEPTION:\n-      asm_fprintf (f, \"\\tmovs\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n-      break;\n-\n-    case ARM_FT_INTERWORKED:\n-      asm_fprintf (f, \"\\tbx\\t%r\\n\", LR_REGNUM);\n-      break;\n-\n-    default:\n-      if (IS_STACKALIGN (func_type))\n-\t{\n-\t  /* See comment in arm_expand_prologue.  */\n-\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", SP_REGNUM, 0);\n-\t}\n-      if (arm_arch5 || arm_arch4t)\n-\tasm_fprintf (f, \"\\tbx\\t%r\\n\", LR_REGNUM);\n-      else\n-\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n-      break;\n-    }\n-\n-  return \"\";\n-}\n-\n static void\n arm_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n \t\t\t      HOST_WIDE_INT frame_size ATTRIBUTE_UNUSED)"}, {"sha": "f4ced7b1e2ba8abbea27148db501de1124f8faae", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59e1214f746c120caf4849daeffc11681f9d660/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59e1214f746c120caf4849daeffc11681f9d660/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=c59e1214f746c120caf4849daeffc11681f9d660", "patch": "@@ -10619,11 +10619,8 @@\n \n (define_insn \"*epilogue_insns\"\n   [(unspec_volatile [(return)] VUNSPEC_EPILOGUE)]\n-  \"TARGET_EITHER\"\n+  \"TARGET_THUMB1\"\n   \"*\n-  if (TARGET_32BIT)\n-    return arm_output_epilogue (NULL);\n-  else /* TARGET_THUMB1 */\n     return thumb1_unexpanded_epilogue ();\n   \"\n   ; Length is absolute worst case"}]}