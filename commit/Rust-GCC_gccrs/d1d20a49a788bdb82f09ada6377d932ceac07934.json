{"sha": "d1d20a49a788bdb82f09ada6377d932ceac07934", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFkMjBhNDlhNzg4YmRiODJmMDlhZGE2Mzc3ZDkzMmNlYWMwNzkzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T18:00:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T18:00:41Z"}, "message": "Use single-iteration epilogues when peeling for gaps\n\nThis patch adds support for fully-masking loops that require peeling\nfor gaps.  It peels exactly one scalar iteration and uses the masked\nloop to handle the rest.  Previously we would fall back on using a\nstandard unmasked loop instead.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-loop-manip.c (vect_gen_scalar_loop_niters): Replace\n\tvfm1 with a bound_epilog parameter.\n\t(vect_do_peeling): Update calls accordingly, and move the prologue\n\tcall earlier in the function.  Treat the base bound_epilog as 0 for\n\tfully-masked loops and retain vf - 1 for other loops.  Add 1 to\n\tthis base when peeling for gaps.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Allow peeling for gaps\n\twith fully-masked loops.\n\t(vect_estimate_min_profitable_iters): Handle the single peeled\n\titeration in that case.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/struct_vect_18.c: Check the number\n\tof branches.\n\t* gcc.target/aarch64/sve/struct_vect_19.c: Likewise.\n\t* gcc.target/aarch64/sve/struct_vect_20.c: New test.\n\t* gcc.target/aarch64/sve/struct_vect_20_run.c: Likewise.\n\t* gcc.target/aarch64/sve/struct_vect_21.c: Likewise.\n\t* gcc.target/aarch64/sve/struct_vect_21_run.c: Likewise.\n\t* gcc.target/aarch64/sve/struct_vect_22.c: Likewise.\n\t* gcc.target/aarch64/sve/struct_vect_22_run.c: Likewise.\n\t* gcc.target/aarch64/sve/struct_vect_23.c: Likewise.\n\t* gcc.target/aarch64/sve/struct_vect_23_run.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256635", "tree": {"sha": "da9369ee0298c56a7f3c618a641a99026cd3d33c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da9369ee0298c56a7f3c618a641a99026cd3d33c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1d20a49a788bdb82f09ada6377d932ceac07934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d20a49a788bdb82f09ada6377d932ceac07934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1d20a49a788bdb82f09ada6377d932ceac07934", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d20a49a788bdb82f09ada6377d932ceac07934/comments", "author": null, "committer": null, "parents": [{"sha": "4aa157e8d2aec2e4f9e97dcee86068135e0dcb2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aa157e8d2aec2e4f9e97dcee86068135e0dcb2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aa157e8d2aec2e4f9e97dcee86068135e0dcb2f"}], "stats": {"total": 508, "additions": 458, "deletions": 50}, "files": [{"sha": "e5e7bf76d9b97c9f51c84cea6c81df3e050d6cb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -1,3 +1,18 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-loop-manip.c (vect_gen_scalar_loop_niters): Replace\n+\tvfm1 with a bound_epilog parameter.\n+\t(vect_do_peeling): Update calls accordingly, and move the prologue\n+\tcall earlier in the function.  Treat the base bound_epilog as 0 for\n+\tfully-masked loops and retain vf - 1 for other loops.  Add 1 to\n+\tthis base when peeling for gaps.\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Allow peeling for gaps\n+\twith fully-masked loops.\n+\t(vect_estimate_min_profitable_iters): Handle the single peeled\n+\titeration in that case.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "bedb8e36af0d9630517f005d41035b84f90ac0b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -1,3 +1,19 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.target/aarch64/sve/struct_vect_18.c: Check the number\n+\tof branches.\n+\t* gcc.target/aarch64/sve/struct_vect_19.c: Likewise.\n+\t* gcc.target/aarch64/sve/struct_vect_20.c: New test.\n+\t* gcc.target/aarch64/sve/struct_vect_20_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/struct_vect_21.c: Likewise.\n+\t* gcc.target/aarch64/sve/struct_vect_21_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/struct_vect_22.c: Likewise.\n+\t* gcc.target/aarch64/sve/struct_vect_22_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/struct_vect_23.c: Likewise.\n+\t* gcc.target/aarch64/sve/struct_vect_23_run.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8b93b4cfbd30ffef94dd2fea69928ddca765118a", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_18.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_18.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -42,3 +42,6 @@ TEST (test)\n /* { dg-final { scan-assembler-times {\\tstr\\ts} 1 } } */\n /* { dg-final { scan-assembler-times {\\tldr\\td} 2 } } */\n /* { dg-final { scan-assembler-times {\\tstr\\td} 1 } } */\n+\n+/* The only branches should be in the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tb[a-z]+\\t} 4 } } */"}, {"sha": "6a67e1839a509ad459f13757d8bf949e3c4ae998", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_19.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_19.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -40,3 +40,8 @@ TEST (test)\n /* { dg-final { scan-assembler-times {\\tstr\\ts} 1 } } */\n /* { dg-final { scan-assembler-times {\\tldr\\td} 2 } } */\n /* { dg-final { scan-assembler-times {\\tstr\\td} 1 } } */\n+\n+/* Each function should have three branches: one directly to the exit\n+   (n <= 0), one to the single scalar epilogue iteration (n == 1),\n+   and one branch-back for the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tb[a-z]+\\t} 12 } } */"}, {"sha": "6d616ebb1d67807b47482fb200121166e8bbc4ee", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_20.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_20.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define N 2000\n+\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME (TYPE *restrict dest, TYPE *restrict src)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      dest[i] += src[i * 2];\t\t\t\t\t\\\n+  }\n+\n+#define TEST(NAME) \\\n+  TEST_LOOP (NAME##_i8, signed char) \\\n+  TEST_LOOP (NAME##_i16, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, float) \\\n+  TEST_LOOP (NAME##_f64, double)\n+\n+TEST (test)\n+\n+/* Check the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld2b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld2h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld2w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld2d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 1 } } */\n+\n+/* Check the scalar tail.  */\n+/* { dg-final { scan-assembler-times {\\tldrb\\tw} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstrb\\tw} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldrh\\tw} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstrh\\tw} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\ts} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\ts} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\td} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\td} 1 } } */\n+\n+/* The only branches should be in the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tb[a-z]+\\t} 4 } } */"}, {"sha": "978f02bbc13618cadcb5791bbb0e1099bba80947", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_20_run.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_20_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_20_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_20_run.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"struct_vect_20.c\"\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE out[N];\t\t\t\t\t\\\n+    TYPE in[N * 2];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tout[i] = i * 7 / 2;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tin[i] = i * 9 / 2;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    NAME (out, in);\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tTYPE expected = i * 7 / 2 + in[i * 2];\t\t\\\n+\tif (out[i] != expected)\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "4758c9d4ca41e6206541e7ffd13fad279864f213", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_21.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_21.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME (TYPE *restrict dest, TYPE *restrict src, int n)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      dest[i] += src[i * 2];\t\t\t\t\t\\\n+  }\n+\n+#define TEST(NAME) \\\n+  TEST_LOOP (NAME##_i8, signed char) \\\n+  TEST_LOOP (NAME##_i16, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, float) \\\n+  TEST_LOOP (NAME##_f64, double)\n+\n+TEST (test)\n+\n+/* Check the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld2b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld2h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld2w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld2d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 1 } } */\n+\n+/* Check the scalar tail.  */\n+/* { dg-final { scan-assembler-times {\\tldrb\\tw} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstrb\\tw} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldrh\\tw} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstrh\\tw} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\ts} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\ts} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\td} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\td} 1 } } */\n+\n+/* Each function should have three branches: one directly to the exit\n+   (n <= 0), one to the single scalar epilogue iteration (n == 1),\n+   and one branch-back for the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tb[a-z]+\\t} 12 } } */"}, {"sha": "1f21929e90b3e98e55d9a0aad3576aa459d0cbdb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_21_run.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_21_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_21_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_21_run.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"struct_vect_21.c\"\n+\n+#define N 1000\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE out[N];\t\t\t\t\\\n+    TYPE in[N * 2];\t\t\t\t\\\n+    int counts[] = { 0, 1, N - 1 };\t\t\\\n+    for (int j = 0; j < 3; ++j)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tint count = counts[j];\t\t\t\\\n+\tfor (int i = 0; i < N; ++i)\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    out[i] = i * 7 / 2;\t\t\t\\\n+\t    asm volatile (\"\" ::: \"memory\");\t\\\n+\t  }\t\t\t\t\t\\\n+\tfor (int i = 0; i < N * 2; ++i)\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    in[i] = i * 9 / 2;\t\t\t\\\n+\t    asm volatile (\"\" ::: \"memory\");\t\\\n+\t  }\t\t\t\t\t\\\n+\tNAME (out, in, count);\t\t\t\\\n+\tfor (int i = 0; i < N; ++i)\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    TYPE expected = i * 7 / 2;\t\t\\\n+\t    if (i < count)\t\t\t\\\n+\t      expected += in[i * 2];\t\t\\\n+\t    if (out[i] != expected)\t\t\\\n+\t      __builtin_abort ();\t\t\\\n+\t    asm volatile (\"\" ::: \"memory\");\t\\\n+\t  }\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "322b561d7ff4672bd9ee57fed50d2930c0de692b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_22.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_22.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define N 2000\n+\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME (TYPE *restrict dest, TYPE *restrict src)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      dest[i] += src[i * 4];\t\t\t\t\t\\\n+  }\n+\n+#define TEST(NAME) \\\n+  TEST_LOOP (NAME##_i8, signed char) \\\n+  TEST_LOOP (NAME##_i16, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, float) \\\n+  TEST_LOOP (NAME##_f64, double)\n+\n+TEST (test)\n+\n+/* Check the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld4b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld4h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld4w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld4d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 1 } } */\n+\n+/* Check the scalar tail.  */\n+/* { dg-final { scan-assembler-times {\\tldrb\\tw} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstrb\\tw} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldrh\\tw} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstrh\\tw} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\ts} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\ts} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\td} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\td} 1 } } */\n+\n+/* The only branches should be in the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tb[a-z]+\\t} 4 } } */"}, {"sha": "e9386f5bc3b630f1627cec5360b57299460c180b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_22_run.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_22_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_22_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_22_run.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"struct_vect_22.c\"\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    TYPE out[N];\t\t\t\t\t\\\n+    TYPE in[N * 4];\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tout[i] = i * 7 / 2;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * 4; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tin[i] = i * 9 / 2;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    NAME (out, in);\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tTYPE expected = i * 7 / 2 + in[i * 4];\t\t\\\n+\tif (out[i] != expected)\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "1698a2e25b42be5c96c75110b92dadbe3d9f7b1b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_23.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_23.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\\\n+  NAME (TYPE *restrict dest, TYPE *restrict src, int n)\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      dest[i] += src[i * 4];\t\t\t\t\t\\\n+  }\n+\n+#define TEST(NAME) \\\n+  TEST_LOOP (NAME##_i8, signed char) \\\n+  TEST_LOOP (NAME##_i16, unsigned short) \\\n+  TEST_LOOP (NAME##_f32, float) \\\n+  TEST_LOOP (NAME##_f64, double)\n+\n+TEST (test)\n+\n+/* Check the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld4b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld4h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld4w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tld4d\\t} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 1 } } */\n+\n+/* Check the scalar tail.  */\n+/* { dg-final { scan-assembler-times {\\tldrb\\tw} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstrb\\tw} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldrh\\tw} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstrh\\tw} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\ts} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\ts} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tldr\\td} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tstr\\td} 1 } } */\n+\n+/* Each function should have three branches: one directly to the exit\n+   (n <= 0), one to the single scalar epilogue iteration (n == 1),\n+   and one branch-back for the vectorized loop.  */\n+/* { dg-final { scan-assembler-times {\\tb[a-z]+\\t} 12 } } */"}, {"sha": "55906d78b04bb1704feffd3815c671605dd60d29", "filename": "gcc/testsuite/gcc.target/aarch64/sve/struct_vect_23_run.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_23_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_23_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fstruct_vect_23_run.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"struct_vect_23.c\"\n+\n+#define N 1000\n+\n+#undef TEST_LOOP\n+#define TEST_LOOP(NAME, TYPE)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE out[N];\t\t\t\t\\\n+    TYPE in[N * 4];\t\t\t\t\\\n+    int counts[] = { 0, 1, N - 1 };\t\t\\\n+    for (int j = 0; j < 3; ++j)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tint count = counts[j];\t\t\t\\\n+\tfor (int i = 0; i < N; ++i)\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    out[i] = i * 7 / 2;\t\t\t\\\n+\t    asm volatile (\"\" ::: \"memory\");\t\\\n+\t  }\t\t\t\t\t\\\n+\tfor (int i = 0; i < N * 4; ++i)\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    in[i] = i * 9 / 2;\t\t\t\\\n+\t    asm volatile (\"\" ::: \"memory\");\t\\\n+\t  }\t\t\t\t\t\\\n+\tNAME (out, in, count);\t\t\t\\\n+\tfor (int i = 0; i < N; ++i)\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    TYPE expected = i * 7 / 2;\t\t\\\n+\t    if (i < count)\t\t\t\\\n+\t      expected += in[i * 4];\t\t\\\n+\t    if (out[i] != expected)\t\t\\\n+\t      __builtin_abort ();\t\t\\\n+\t    asm volatile (\"\" ::: \"memory\");\t\\\n+\t  }\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+int __attribute__ ((optimize (1)))\n+main (void)\n+{\n+  TEST (test);\n+  return 0;\n+}"}, {"sha": "a2b49899699cb875a0eb99a0d7553d338dcf719c", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -618,8 +618,9 @@ vect_set_loop_masks_directly (struct loop *loop, loop_vec_info loop_vinfo,\n \n /* Make LOOP iterate NITERS times using masking and WHILE_ULT calls.\n    LOOP_VINFO describes the vectorization of LOOP.  NITERS is the\n-   number of iterations of the original scalar loop.  NITERS_MAYBE_ZERO\n-   and FINAL_IV are as for vect_set_loop_condition.\n+   number of iterations of the original scalar loop that should be\n+   handled by the vector loop.  NITERS_MAYBE_ZERO and FINAL_IV are\n+   as for vect_set_loop_condition.\n \n    Insert the branch-back condition before LOOP_COND_GSI and return the\n    final gcond.  */\n@@ -1836,23 +1837,24 @@ vect_build_loop_niters (loop_vec_info loop_vinfo, bool *new_var_p)\n /* Calculate the number of iterations above which vectorized loop will be\n    preferred than scalar loop.  NITERS_PROLOG is the number of iterations\n    of prolog loop.  If it's integer const, the integer number is also passed\n-   in INT_NITERS_PROLOG.  BOUND_PROLOG is the upper bound (included) of\n-   number of iterations of prolog loop.  VFM1 is vector factor minus one.\n-   If CHECK_PROFITABILITY is true, TH is the threshold below which scalar\n-   (rather than vectorized) loop will be executed.  This function stores\n-   upper bound (included) of the result in BOUND_SCALAR.  */\n+   in INT_NITERS_PROLOG.  BOUND_PROLOG is the upper bound (inclusive) of the\n+   number of iterations of the prolog loop.  BOUND_EPILOG is the corresponding\n+   value for the epilog loop.  If CHECK_PROFITABILITY is true, TH is the\n+   threshold below which the scalar (rather than vectorized) loop will be\n+   executed.  This function stores the upper bound (inclusive) of the result\n+   in BOUND_SCALAR.  */\n \n static tree\n vect_gen_scalar_loop_niters (tree niters_prolog, int int_niters_prolog,\n-\t\t\t     int bound_prolog, poly_int64 vfm1, int th,\n+\t\t\t     int bound_prolog, poly_int64 bound_epilog, int th,\n \t\t\t     poly_uint64 *bound_scalar,\n \t\t\t     bool check_profitability)\n {\n   tree type = TREE_TYPE (niters_prolog);\n   tree niters = fold_build2 (PLUS_EXPR, type, niters_prolog,\n-\t\t\t     build_int_cst (type, vfm1));\n+\t\t\t     build_int_cst (type, bound_epilog));\n \n-  *bound_scalar = vfm1 + bound_prolog;\n+  *bound_scalar = bound_prolog + bound_epilog;\n   if (check_profitability)\n     {\n       /* TH indicates the minimum niters of vectorized loop, while we\n@@ -1861,18 +1863,18 @@ vect_gen_scalar_loop_niters (tree niters_prolog, int int_niters_prolog,\n       /* Peeling for constant times.  */\n       if (int_niters_prolog >= 0)\n \t{\n-\t  *bound_scalar = upper_bound (int_niters_prolog + vfm1, th);\n+\t  *bound_scalar = upper_bound (int_niters_prolog + bound_epilog, th);\n \t  return build_int_cst (type, *bound_scalar);\n \t}\n-      /* Peeling for unknown times.  Note BOUND_PROLOG is the upper\n-\t bound (inlcuded) of niters of prolog loop.  */\n-      if (known_ge (th, vfm1 + bound_prolog))\n+      /* Peeling an unknown number of times.  Note that both BOUND_PROLOG\n+\t and BOUND_EPILOG are inclusive upper bounds.  */\n+      if (known_ge (th, bound_prolog + bound_epilog))\n \t{\n \t  *bound_scalar = th;\n \t  return build_int_cst (type, th);\n \t}\n       /* Need to do runtime comparison.  */\n-      else if (maybe_gt (th, vfm1))\n+      else if (maybe_gt (th, bound_epilog))\n \t{\n \t  *bound_scalar = upper_bound (*bound_scalar, th);\n \t  return fold_build2 (MAX_EXPR, type,\n@@ -2405,14 +2407,20 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   tree type = TREE_TYPE (niters), guard_cond;\n   basic_block guard_bb, guard_to;\n   profile_probability prob_prolog, prob_vector, prob_epilog;\n-  int bound_prolog = 0;\n-  poly_uint64 bound_scalar = 0;\n   int estimated_vf;\n   int prolog_peeling = 0;\n   if (!vect_use_loop_mask_for_alignment_p (loop_vinfo))\n     prolog_peeling = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-  bool epilog_peeling = (LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)\n-\t\t\t || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));\n+\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  poly_uint64 bound_epilog = 0;\n+  if (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n+      && LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo))\n+    bound_epilog += vf - 1;\n+  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+    bound_epilog += 1;\n+  bool epilog_peeling = maybe_ne (bound_epilog, 0U);\n+  poly_uint64 bound_scalar = bound_epilog;\n \n   if (!prolog_peeling && !epilog_peeling)\n     return NULL;\n@@ -2423,7 +2431,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n     estimated_vf = 3;\n   prob_prolog = prob_epilog = profile_probability::guessed_always ()\n \t\t\t.apply_scale (estimated_vf - 1, estimated_vf);\n-  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n   struct loop *prolog, *epilog = NULL, *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct loop *first_loop = loop;\n@@ -2438,14 +2445,29 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n     }\n   initialize_original_copy_tables ();\n \n+  /* Record the anchor bb at which the guard should be placed if the scalar\n+     loop might be preferred.  */\n+  basic_block anchor = loop_preheader_edge (loop)->src;\n+\n+  /* Generate the number of iterations for the prolog loop.  We do this here\n+     so that we can also get the upper bound on the number of iterations.  */\n+  tree niters_prolog;\n+  int bound_prolog = 0;\n+  if (prolog_peeling)\n+    niters_prolog = vect_gen_prolog_loop_niters (loop_vinfo, anchor,\n+\t\t\t\t\t\t &bound_prolog);\n+  else\n+    niters_prolog = build_int_cst (type, 0);\n+\n   /* Prolog loop may be skipped.  */\n   bool skip_prolog = (prolog_peeling != 0);\n   /* Skip to epilog if scalar loop may be preferred.  It's only needed\n      when we peel for epilog loop and when it hasn't been checked with\n      loop versioning.  */\n-  bool skip_vector = ((!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t\t       && !LOOP_REQUIRES_VERSIONING (loop_vinfo))\n-\t\t      || !vf.is_constant ());\n+  bool skip_vector = (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t\t      ? maybe_lt (LOOP_VINFO_INT_NITERS (loop_vinfo),\n+\t\t\t\t  bound_prolog + bound_epilog)\n+\t\t      : !LOOP_REQUIRES_VERSIONING (loop_vinfo));\n   /* Epilog loop must be executed if the number of iterations for epilog\n      loop is known at compile time, otherwise we need to add a check at\n      the end of vector loop and skip to the end of epilog loop.  */\n@@ -2456,9 +2478,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     skip_epilog = false;\n \n-  /* Record the anchor bb at which guard should be placed if scalar loop\n-     may be preferred.  */\n-  basic_block anchor = loop_preheader_edge (loop)->src;\n   if (skip_vector)\n     {\n       split_edge (loop_preheader_edge (loop));\n@@ -2476,7 +2495,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t}\n     }\n \n-  tree niters_prolog = build_int_cst (type, 0);\n   source_location loop_loc = find_loop_location (loop);\n   struct loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n   if (prolog_peeling)\n@@ -2500,9 +2518,7 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       first_loop = prolog;\n       reset_original_copy_tables ();\n \n-      /* Generate and update the number of iterations for prolog loop.  */\n-      niters_prolog = vect_gen_prolog_loop_niters (loop_vinfo, anchor,\n-\t\t\t\t\t\t   &bound_prolog);\n+      /* Update the number of iterations for prolog loop.  */\n       tree step_prolog = build_one_cst (TREE_TYPE (niters_prolog));\n       vect_set_loop_condition (prolog, NULL, niters_prolog,\n \t\t\t       step_prolog, NULL_TREE, false);\n@@ -2577,10 +2593,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       if (skip_vector)\n \t{\n \t  /* Additional epilogue iteration is peeled if gap exists.  */\n-\t  bool peel_for_gaps = LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo);\n \t  tree t = vect_gen_scalar_loop_niters (niters_prolog, prolog_peeling,\n-\t\t\t\t\t\tbound_prolog,\n-\t\t\t\t\t\tpeel_for_gaps ? vf : vf - 1,\n+\t\t\t\t\t\tbound_prolog, bound_epilog,\n \t\t\t\t\t\tth, &bound_scalar,\n \t\t\t\t\t\tcheck_profitability);\n \t  /* Build guard against NITERSM1 since NITERS may overflow.  */\n@@ -2664,14 +2678,12 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       else\n \tslpeel_update_phi_nodes_for_lcssa (epilog);\n \n-      unsigned HOST_WIDE_INT bound1, bound2;\n-      if (vf.is_constant (&bound1) && bound_scalar.is_constant (&bound2))\n+      unsigned HOST_WIDE_INT bound;\n+      if (bound_scalar.is_constant (&bound))\n \t{\n-\t  bound1 -= LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) ? 1 : 2;\n-\t  if (bound2)\n-\t    /* We share epilog loop with scalar version loop.  */\n-\t    bound1 = MAX (bound1, bound2 - 1);\n-\t  record_niter_bound (epilog, bound1, false, true);\n+\t  gcc_assert (bound != 0);\n+\t  /* -1 to convert loop iterations to latch iterations.  */\n+\t  record_niter_bound (epilog, bound - 1, false, true);\n \t}\n \n       delete_update_ssa ();"}, {"sha": "4b9226ff83c83d4ec953f9193963e5c32cc9963d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d20a49a788bdb82f09ada6377d932ceac07934/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d1d20a49a788bdb82f09ada6377d932ceac07934", "patch": "@@ -2260,16 +2260,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       return false;\n     }\n \n-  if (LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo)\n-      && LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n-    {\n-      LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo) = false;\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"can't use a fully-masked loop because peeling for\"\n-\t\t\t \" gaps is required.\\n\");\n-    }\n-\n   /* Decide whether to use a fully-masked loop for this vectorization\n      factor.  */\n   LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n@@ -3714,6 +3704,23 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     {\n       peel_iters_prologue = 0;\n       peel_iters_epilogue = 0;\n+\n+      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+\t{\n+\t  /* We need to peel exactly one iteration.  */\n+\t  peel_iters_epilogue += 1;\n+\t  stmt_info_for_cost *si;\n+\t  int j;\n+\t  FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n+\t\t\t    j, si)\n+\t    {\n+\t      struct _stmt_vec_info *stmt_info\n+\t\t= si->stmt ? vinfo_for_stmt (si->stmt) : NULL;\n+\t      (void) add_stmt_cost (target_cost_data, si->count,\n+\t\t\t\t    si->kind, stmt_info, si->misalign,\n+\t\t\t\t    vect_epilogue);\n+\t    }\n+\t}\n     }\n   else if (npeel < 0)\n     {"}]}