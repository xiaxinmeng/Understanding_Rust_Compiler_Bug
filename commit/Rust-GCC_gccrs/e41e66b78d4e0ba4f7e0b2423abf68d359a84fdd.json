{"sha": "e41e66b78d4e0ba4f7e0b2423abf68d359a84fdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQxZTY2Yjc4ZDRlMGJhNGY3ZTBiMjQyM2FiZjY4ZDM1OWE4NGZkZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-09-23T00:27:46Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-09-23T00:28:24Z"}, "message": "libbacktrace: handle pc == low correctly\n\n\t* dwarf.c (report_inlined_functions): Handle PC == -1 and PC ==\n\tp->low.\n\t(dwarf_lookup_pc): Likewise.", "tree": {"sha": "18a9b3da74a1b12b1693571347000334eb1e3c5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18a9b3da74a1b12b1693571347000334eb1e3c5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e41e66b78d4e0ba4f7e0b2423abf68d359a84fdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41e66b78d4e0ba4f7e0b2423abf68d359a84fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e41e66b78d4e0ba4f7e0b2423abf68d359a84fdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41e66b78d4e0ba4f7e0b2423abf68d359a84fdd/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "521d2711409b1af89d2d802879c2bbd716200cb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/521d2711409b1af89d2d802879c2bbd716200cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/521d2711409b1af89d2d802879c2bbd716200cb6"}], "stats": {"total": 38, "additions": 27, "deletions": 11}, "files": [{"sha": "582f34bc816b27b305e805507d1967182d33b127", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41e66b78d4e0ba4f7e0b2423abf68d359a84fdd/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41e66b78d4e0ba4f7e0b2423abf68d359a84fdd/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=e41e66b78d4e0ba4f7e0b2423abf68d359a84fdd", "patch": "@@ -3558,6 +3558,11 @@ report_inlined_functions (uintptr_t pc, struct function *function,\n   if (function->function_addrs_count == 0)\n     return 0;\n \n+  /* Our search isn't safe if pc == -1, as that is the sentinel\n+     value.  */\n+  if (pc + 1 == 0)\n+    return 0;\n+\n   p = ((struct function_addrs *)\n        bsearch (&pc, function->function_addrs,\n \t\tfunction->function_addrs_count,\n@@ -3567,9 +3572,12 @@ report_inlined_functions (uintptr_t pc, struct function *function,\n     return 0;\n \n   /* Here pc >= p->low && pc < (p + 1)->low.  The function_addrs are\n-     sorted by low, so we are at the end of a range of function_addrs\n-     with the same low alue.  Walk backward and use the first range\n-     that includes pc.  */\n+     sorted by low, so if pc > p->low we are at the end of a range of\n+     function_addrs with the same low value.  If pc == p->low walk\n+     forward to the end of the range with that low value.  Then walk\n+     backward and use the first range that includes pc.  */\n+  while (pc == (p + 1)->low)\n+    ++p;\n   match = NULL;\n   while (1)\n     {\n@@ -3636,8 +3644,10 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n \n   *found = 1;\n \n-  /* Find an address range that includes PC.  */\n-  entry = (ddata->addrs_count == 0\n+  /* Find an address range that includes PC.  Our search isn't safe if\n+     PC == -1, as we use that as a sentinel value, so skip the search\n+     in that case.  */\n+  entry = (ddata->addrs_count == 0 || pc + 1 == 0\n \t   ? NULL\n \t   : bsearch (&pc, ddata->addrs, ddata->addrs_count,\n \t\t      sizeof (struct unit_addrs), unit_addrs_search));\n@@ -3649,9 +3659,12 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n     }\n \n   /* Here pc >= entry->low && pc < (entry + 1)->low.  The unit_addrs\n-     are sorted by low, so we are at the end of a range of unit_addrs\n-     with the same low value.  Walk backward and use the first range\n-     that includes pc.  */\n+     are sorted by low, so if pc > p->low we are at the end of a range\n+     of unit_addrs with the same low value.  If pc == p->low walk\n+     forward to the end of the range with that low value.  Then walk\n+     backward and use the first range that includes pc.  */\n+  while (pc == (entry + 1)->low)\n+    ++entry;\n   found_entry = 0;\n   while (1)\n     {\n@@ -3832,9 +3845,12 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n     return callback (data, pc, ln->filename, ln->lineno, NULL);\n \n   /* Here pc >= p->low && pc < (p + 1)->low.  The function_addrs are\n-     sorted by low, so we are at the end of a range of function_addrs\n-     with the same low alue.  Walk backward and use the first range\n-     that includes pc.  */\n+     sorted by low, so if pc > p->low we are at the end of a range of\n+     function_addrs with the same low value.  If pc == p->low walk\n+     forward to the end of the range with that low value.  Then walk\n+     backward and use the first range that includes pc.  */\n+  while (pc == (p + 1)->low)\n+    ++p;\n   fmatch = NULL;\n   while (1)\n     {"}]}