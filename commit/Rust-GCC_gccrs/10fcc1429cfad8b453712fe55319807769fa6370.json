{"sha": "10fcc1429cfad8b453712fe55319807769fa6370", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBmY2MxNDI5Y2ZhZDhiNDUzNzEyZmU1NTMxOTgwNzc2OWZhNjM3MA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-08-16T17:07:15Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-08-16T17:07:15Z"}, "message": "-Wmisleading-indentation: fix ICE in get_visual_column (PR c++/70693)\n\nPR c++/70693 reports a crash within -Wmisleading-indentation in\nget_visual_column, reading past the end of a source line.\n\nThe issue occurs due to a stray carriage return aka '\\r' aka ^M, occurring\ntowards the end of line 35 of attachment 38289 - but not at the end itself.\n\nThis carriage return confuses our line numbering: from that point in the\nfile, the lexer (and thus location_t values) use line numbers that are\none larger than those seen by input.c, \"cat -n\" and emacs.\n\nThis discrepancy between the lexer's line numbering and input.c's line\nnumbering leads to an out-of-range read in get_visual_column (trying to\nread column 8, to locate the first non-whitespace on the line containing\n\"break;\", but finding the next line, which is only 4 characters long).\n\nThis patch fixes the ICE by adding a range check to get_visual_column\nbefore accessing the input.c line buffer.  This is arguably papering\nover the root cause, but there are presumably other ways of triggering\nsuch an out-of-range read by writing to the source file after the lexer\nbut before -Wmisleading-indentation, and we ought to be not ICE in the\nface of that.\n\ngcc/c-family/ChangeLog:\n\tPR c++/70693\n\t* c-common.c (selftest::c_family_tests): Call\n\tselftest::c_indentation_c_tests.\n\t* c-common.h (selftest::c_indentation_c_tests): New decl.\n\t* c-indentation.c: Include \"selftest.h\".\n\t(next_tab_stop): Add \"tab_width\" param, rather than accessing\n\tcpp_opts.\n\t(get_visual_column): Likewise.  Clarify comment.  Bulletproof\n\tagainst reading past the end of the line.\n\t(get_first_nws_vis_column): Add \"tab_width\" param.\n\t(detect_intervening_unindent): Likewise.\n\t(should_warn_for_misleading_indentation): Read tab width from\n\tcpp_opts and pass around.\n\t(selftest::test_next_tab_stop): New test.\n\t(selftest::assert_get_visual_column_succeeds): New function.\n\t(ASSERT_GET_VISUAL_COLUMN_SUCCEEDS): New macro.\n\t(selftest::assert_get_visual_column_fails): New function.\n\t(ASSERT_GET_VISUAL_COLUMN_FAILS): New macro.\n\t(selftest::test_get_visual_column): New test.\n\t(selftest::c_indentation_c_tests): New function.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/70693\n\t* c-c++-common/Wmisleading-indentation-pr70693.c: New test.\n\nFrom-SVN: r263595", "tree": {"sha": "06a490d2e4fe9e8d28d89eba5bc097b27b811ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06a490d2e4fe9e8d28d89eba5bc097b27b811ad6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10fcc1429cfad8b453712fe55319807769fa6370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10fcc1429cfad8b453712fe55319807769fa6370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10fcc1429cfad8b453712fe55319807769fa6370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10fcc1429cfad8b453712fe55319807769fa6370/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "012d429b84046483721291425c9fcdbd167bbaf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012d429b84046483721291425c9fcdbd167bbaf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/012d429b84046483721291425c9fcdbd167bbaf4"}], "stats": {"total": 234, "additions": 220, "deletions": 14}, "files": [{"sha": "8cd6f4c4bc7b3842f41d25d04d926eb8e9de1e2c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=10fcc1429cfad8b453712fe55319807769fa6370", "patch": "@@ -1,3 +1,26 @@\n+2018-08-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/70693\n+\t* c-common.c (selftest::c_family_tests): Call\n+\tselftest::c_indentation_c_tests.\n+\t* c-common.h (selftest::c_indentation_c_tests): New decl.\n+\t* c-indentation.c: Include \"selftest.h\".\n+\t(next_tab_stop): Add \"tab_width\" param, rather than accessing\n+\tcpp_opts.\n+\t(get_visual_column): Likewise.  Clarify comment.  Bulletproof\n+\tagainst reading past the end of the line.\n+\t(get_first_nws_vis_column): Add \"tab_width\" param.\n+\t(detect_intervening_unindent): Likewise.\n+\t(should_warn_for_misleading_indentation): Read tab width from\n+\tcpp_opts and pass around.\n+\t(selftest::test_next_tab_stop): New test.\n+\t(selftest::assert_get_visual_column_succeeds): New function.\n+\t(ASSERT_GET_VISUAL_COLUMN_SUCCEEDS): New macro.\n+\t(selftest::assert_get_visual_column_fails): New function.\n+\t(ASSERT_GET_VISUAL_COLUMN_FAILS): New macro.\n+\t(selftest::test_get_visual_column): New test.\n+\t(selftest::c_indentation_c_tests): New function.\n+\n 2018-08-16  Nathan Sidwell  <nathan@acm.org>\n \n \t* c-ada-spec.c (count_ada_macro): Use cpp_user_macro_p."}, {"sha": "95cff215d608e3b83d79f105d1ac69828ed5c72c", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=10fcc1429cfad8b453712fe55319807769fa6370", "patch": "@@ -8370,6 +8370,7 @@ c_family_tests (void)\n {\n   c_common_c_tests ();\n   c_format_c_tests ();\n+  c_indentation_c_tests ();\n   c_pretty_print_c_tests ();\n   c_spellcheck_cc_tests ();\n }"}, {"sha": "9b05e60525074b88ecf24f003534ecd937dbba4f", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=10fcc1429cfad8b453712fe55319807769fa6370", "patch": "@@ -1338,6 +1338,7 @@ namespace selftest {\n   /* Declarations for specific families of tests within c-family,\n      by source file, in alphabetical order.  */\n   extern void c_format_c_tests (void);\n+  extern void c_indentation_c_tests (void);\n   extern void c_pretty_print_c_tests (void);\n   extern void c_spellcheck_cc_tests (void);\n "}, {"sha": "436d61b3c9af0a0632e7ba18a0c53266c1f00171", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 178, "deletions": 14, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=10fcc1429cfad8b453712fe55319807769fa6370", "patch": "@@ -23,15 +23,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"c-common.h\"\n #include \"c-indentation.h\"\n+#include \"selftest.h\"\n \n extern cpp_options *cpp_opts;\n \n /* Round up VIS_COLUMN to nearest tab stop. */\n \n static unsigned int\n-next_tab_stop (unsigned int vis_column)\n+next_tab_stop (unsigned int vis_column, unsigned int tab_width)\n {\n-  const unsigned int tab_width = cpp_opts->tabstop;\n   vis_column = ((vis_column + tab_width) / tab_width) * tab_width;\n   return vis_column;\n }\n@@ -43,12 +43,13 @@ next_tab_stop (unsigned int vis_column)\n    Returns true if a conversion was possible, writing the result to OUT,\n    otherwise returns false.  If FIRST_NWS is not NULL, then write to it\n    the visual column corresponding to the first non-whitespace character\n-   on the line.  */\n+   on the line (up to or before EXPLOC).  */\n \n static bool\n get_visual_column (expanded_location exploc, location_t loc,\n \t\t   unsigned int *out,\n-\t\t   unsigned int *first_nws)\n+\t\t   unsigned int *first_nws,\n+\t\t   unsigned int tab_width)\n {\n   /* PR c++/68819: if the column number is zero, we presumably\n      had a location_t > LINE_MAP_MAX_LOCATION_WITH_COLS, and so\n@@ -73,6 +74,8 @@ get_visual_column (expanded_location exploc, location_t loc,\n   char_span line = location_get_source_line (exploc.file, exploc.line);\n   if (!line)\n     return false;\n+  if ((size_t)exploc.column > line.length ())\n+    return false;\n   unsigned int vis_column = 0;\n   for (int i = 1; i < exploc.column; i++)\n     {\n@@ -85,7 +88,7 @@ get_visual_column (expanded_location exploc, location_t loc,\n \t}\n \n       if (ch == '\\t')\n-\tvis_column = next_tab_stop (vis_column);\n+\tvis_column = next_tab_stop (vis_column, tab_width);\n       else\n        vis_column++;\n     }\n@@ -106,7 +109,8 @@ get_visual_column (expanded_location exploc, location_t loc,\n \n static bool\n get_first_nws_vis_column (const char *file, int line_num,\n-\t\t\t  unsigned int *first_nws)\n+\t\t\t  unsigned int *first_nws,\n+\t\t\t  unsigned int tab_width)\n {\n   gcc_assert (first_nws);\n \n@@ -125,7 +129,7 @@ get_first_nws_vis_column (const char *file, int line_num,\n \t}\n \n       if (ch == '\\t')\n-\tvis_column = next_tab_stop (vis_column);\n+\tvis_column = next_tab_stop (vis_column, tab_width);\n       else\n \tvis_column++;\n     }\n@@ -178,15 +182,16 @@ static bool\n detect_intervening_unindent (const char *file,\n \t\t\t     int body_line,\n \t\t\t     int next_stmt_line,\n-\t\t\t     unsigned int vis_column)\n+\t\t\t     unsigned int vis_column,\n+\t\t\t     unsigned int tab_width)\n {\n   gcc_assert (file);\n   gcc_assert (next_stmt_line > body_line);\n \n   for (int line = body_line + 1; line < next_stmt_line; line++)\n     {\n       unsigned int line_vis_column;\n-      if (get_first_nws_vis_column (file, line, &line_vis_column))\n+      if (get_first_nws_vis_column (file, line, &line_vis_column, tab_width))\n \tif (line_vis_column < vis_column)\n \t  return true;\n     }\n@@ -289,6 +294,8 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n   expanded_location next_stmt_exploc = expand_location (next_stmt_loc);\n   expanded_location guard_exploc = expand_location (guard_loc);\n \n+  const unsigned int tab_width = cpp_opts->tabstop;\n+\n   /* They must be in the same file.  */\n   if (next_stmt_exploc.file != body_exploc.file)\n     return false;\n@@ -334,7 +341,7 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t  unsigned int guard_line_first_nws;\n \t  if (!get_visual_column (guard_exploc, guard_loc,\n \t\t\t\t  &guard_vis_column,\n-\t\t\t\t  &guard_line_first_nws))\n+\t\t\t\t  &guard_line_first_nws, tab_width))\n \t    return false;\n \t  /* Heuristic: only warn if the guard is the first thing\n \t     on its line.  */\n@@ -394,15 +401,15 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t it's not clear that it's meaningful to look at indentation.  */\n       if (!get_visual_column (next_stmt_exploc, next_stmt_loc,\n \t\t\t      &next_stmt_vis_column,\n-\t\t\t      &next_stmt_line_first_nws))\n+\t\t\t      &next_stmt_line_first_nws, tab_width))\n \treturn false;\n       if (!get_visual_column (body_exploc, body_loc,\n \t\t\t      &body_vis_column,\n-\t\t\t      &body_line_first_nws))\n+\t\t\t      &body_line_first_nws, tab_width))\n \treturn false;\n       if (!get_visual_column (guard_exploc, guard_loc,\n \t\t\t      &guard_vis_column,\n-\t\t\t      &guard_line_first_nws))\n+\t\t\t      &guard_line_first_nws, tab_width))\n \treturn false;\n \n       /* If the line where the next stmt starts has non-whitespace\n@@ -486,7 +493,7 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t  int vis_column = MIN (next_stmt_vis_column, body_vis_column);\n \t  if (detect_intervening_unindent (body_exploc.file, body_exploc.line,\n \t\t\t\t\t   next_stmt_exploc.line,\n-\t\t\t\t\t   vis_column))\n+\t\t\t\t\t   vis_column, tab_width))\n \t    return false;\n \n \t  /* Otherwise, they are visually aligned: issue a warning.  */\n@@ -611,3 +618,160 @@ warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t\tguard_tinfo_to_string (guard_tinfo.keyword));\n     }\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that next_tab_stop works as expected.  */\n+\n+static void\n+test_next_tab_stop ()\n+{\n+  const unsigned int tab_width = 8;\n+\n+  ASSERT_EQ (next_tab_stop (0, tab_width), 8);\n+  ASSERT_EQ (next_tab_stop (1, tab_width), 8);\n+  ASSERT_EQ (next_tab_stop (7, tab_width), 8);\n+\n+  ASSERT_EQ (next_tab_stop (8, tab_width), 16);\n+  ASSERT_EQ (next_tab_stop (9, tab_width), 16);\n+  ASSERT_EQ (next_tab_stop (15, tab_width), 16);\n+\n+  ASSERT_EQ (next_tab_stop (16, tab_width), 24);\n+  ASSERT_EQ (next_tab_stop (17, tab_width), 24);\n+  ASSERT_EQ (next_tab_stop (23, tab_width), 24);\n+}\n+\n+/* Verify that the given call to get_visual_column succeeds, with\n+   the given results.  */\n+\n+static void\n+assert_get_visual_column_succeeds (const location &loc,\n+\t\t\t\t   const char *file, int line, int column,\n+\t\t\t\t   const unsigned int tab_width,\n+\t\t\t\t   unsigned int expected_visual_column,\n+\t\t\t\t   unsigned int expected_first_nws)\n+{\n+  expanded_location exploc;\n+  exploc.file = file;\n+  exploc.line = line;\n+  exploc.column = column;\n+  exploc.data = NULL;\n+  exploc.sysp = false;\n+  unsigned int actual_visual_column;\n+  unsigned int actual_first_nws;\n+  bool result = get_visual_column (exploc, UNKNOWN_LOCATION,\n+\t\t\t\t   &actual_visual_column,\n+\t\t\t\t   &actual_first_nws, tab_width);\n+  ASSERT_TRUE_AT (loc, result);\n+  ASSERT_EQ_AT (loc, actual_visual_column, expected_visual_column);\n+  ASSERT_EQ_AT (loc, actual_first_nws, expected_first_nws);\n+}\n+\n+/* Verify that the given call to get_visual_column succeeds, with\n+   the given results.  */\n+\n+#define ASSERT_GET_VISUAL_COLUMN_SUCCEEDS(FILENAME, LINE, COLUMN,\t\\\n+\t\t\t\t\t  TAB_WIDTH,\t\t\t\\\n+\t\t\t\t\t  EXPECTED_VISUAL_COLUMN,\t\\\n+\t\t\t\t\t  EXPECTED_FIRST_NWS)\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    assert_get_visual_column_succeeds (SELFTEST_LOCATION,\t\t\\\n+\t\t\t\t       FILENAME, LINE, COLUMN,\t\t\\\n+\t\t\t\t       TAB_WIDTH,\t\t\t\\\n+\t\t\t\t       EXPECTED_VISUAL_COLUMN,\t\t\\\n+\t\t\t\t       EXPECTED_FIRST_NWS);\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Verify that the given call to get_visual_column fails gracefully.  */\n+\n+static void\n+assert_get_visual_column_fails (const location &loc,\n+\t\t\t\tconst char *file, int line, int column,\n+\t\t\t\tconst unsigned int tab_width)\n+{\n+  expanded_location exploc;\n+  exploc.file = file;\n+  exploc.line = line;\n+  exploc.column = column;\n+  exploc.data = NULL;\n+  exploc.sysp = false;\n+  unsigned int actual_visual_column;\n+  unsigned int actual_first_nws;\n+  bool result = get_visual_column (exploc, UNKNOWN_LOCATION,\n+\t\t\t\t   &actual_visual_column,\n+\t\t\t\t   &actual_first_nws, tab_width);\n+  ASSERT_FALSE_AT (loc, result);\n+}\n+\n+/* Verify that the given call to get_visual_column fails gracefully.  */\n+\n+#define ASSERT_GET_VISUAL_COLUMN_FAILS(FILENAME, LINE, COLUMN,\t\\\n+\t\t\t\t       TAB_WIDTH)\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\\\n+    assert_get_visual_column_fails (SELFTEST_LOCATION,\t\t\\\n+\t\t\t\t    FILENAME, LINE, COLUMN,\t\\\n+\t\t\t\t    TAB_WIDTH);\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Verify that get_visual_column works as expected.  */\n+\n+static void\n+test_get_visual_column ()\n+{\n+  /* Create a tempfile with a mixture of tabs and spaces.\n+\n+     Both lines have either a space or a tab, then \" line N\",\n+     for 8 characters in total.\n+\n+     1-based \"columns\" (w.r.t. to line 1):\n+     .....................0000000001111.\n+     .....................1234567890123.  */\n+  const char *content = (\"  line 1\\n\"\n+\t\t\t \"\\t line 2\\n\");\n+  line_table_test ltt;\n+  temp_source_file tmp (SELFTEST_LOCATION, \".txt\", content);\n+\n+  const unsigned int tab_width = 8;\n+  const char *file = tmp.get_filename ();\n+\n+  /* Line 1 (space-based indentation).  */\n+  {\n+    const int line = 1;\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 1, tab_width, 0, 0);\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 2, tab_width, 1, 1);\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 3, tab_width, 2, 2);\n+    /* first_nws should have stopped increasing.  */\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 4, tab_width, 3, 2);\n+    /* Verify the end-of-line boundary.  */\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 8, tab_width, 7, 2);\n+    ASSERT_GET_VISUAL_COLUMN_FAILS (file, line, 9, tab_width);\n+  }\n+\n+  /* Line 2 (tab-based indentation).  */\n+  {\n+    const int line = 2;\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 1, tab_width, 0, 0);\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 2, tab_width, 8, 8);\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 3, tab_width, 9, 9);\n+    /* first_nws should have stopped increasing.  */\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 4, tab_width, 10, 9);\n+    /* Verify the end-of-line boundary.  */\n+    ASSERT_GET_VISUAL_COLUMN_SUCCEEDS (file, line, 8, tab_width, 14, 9);\n+    ASSERT_GET_VISUAL_COLUMN_FAILS (file, line, 9, tab_width);\n+  }\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+c_indentation_c_tests ()\n+{\n+  test_next_tab_stop ();\n+  test_get_visual_column ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "cb402d46c633c255772c5ade31892c9aefe54ede", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10fcc1429cfad8b453712fe55319807769fa6370", "patch": "@@ -1,3 +1,8 @@\n+2018-08-16  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/70693\n+\t* c-c++-common/Wmisleading-indentation-pr70693.c: New test.\n+\n 2018-08-16  Vlad Lazar  <vlad.lazar@arm.com>\n \n \t* gcc.target/aarch64/imm_choice_comparison.c: New test."}, {"sha": "0869b11fb33baee474df2d95d7469f3f4cd47e11", "filename": "gcc/testsuite/c-c++-common/Wmisleading-indentation-pr70693.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-pr70693.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10fcc1429cfad8b453712fe55319807769fa6370/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-pr70693.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWmisleading-indentation-pr70693.c?ref=10fcc1429cfad8b453712fe55319807769fa6370", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-options \"-Wmisleading-indentation\" } */\n+\n+int in_what; /* \r       */\n+\n+void process_char(char c) {\n+    switch( 0 ) {\n+      case 0:\n+      \tif( c == '>' ) in_what = 0;\n+      \tbreak;\n+    \n+    }\n+}"}]}