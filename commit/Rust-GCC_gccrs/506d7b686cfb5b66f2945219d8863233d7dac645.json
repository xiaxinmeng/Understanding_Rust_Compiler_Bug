{"sha": "506d7b686cfb5b66f2945219d8863233d7dac645", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA2ZDdiNjg2Y2ZiNWI2NmYyOTQ1MjE5ZDg4NjMyMzNkN2RhYzY0NQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-05-04T12:52:41Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-05-04T12:52:41Z"}, "message": "tm.texi (LEGITIMIZE_ADDRESS): Revise documentation.\n\n2009-05-04  Paolo Bonzini  <bonzini@gnu.org>\n\n \t* doc/tm.texi (LEGITIMIZE_ADDRESS): Revise documentation.\n\t* gcc/defaults.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/explow.c (memory_address): Use target hook.\n\t* gcc/targhooks.c (default_legitimize_address): New.\n\t* gcc/targhooks.h (default_legitimize_address): New.\n\t* gcc/target.h (legitimize_address): New.\n\t* gcc/target-def.h (TARGET_LEGITIMIZE_ADDRESS): New.\n\t(TARGET_INITIALIZER): Include it.\n\t* gcc/system.h (LEGITIMIZE_ADDRESS): Poison.\n\n\t* config/bfin/bfin-protos.h (legitimize_address): Remove.\n\t* config/bfin/bfin.c (legitimize_address): Remove.\n\t* config/bfin/bfin.h (LEGITIMIZE_ADDRESS): Remove.\n\t* config/m68hc11/m68hc11-protos.h (m68hc11_legitimize_address): Remove.\n\t* config/m68hc11/m68hc11.c (m68hc11_legitimize_address): Remove.\n\t* config/m68hc11/m68hc11.h (LEGITIMIZE_ADDRESS): Remove.\n\n\t* gcc/config/arm/arm.h (LEGITIMIZE_ADDRESS, ARM_LEGITIMIZE_ADDRESS,\n\tTHUMB_LEGITIMIZE_ADDRESS, THUMB2_LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/s390/s390.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/m32c/m32c.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/sparc/sparc.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/m32r/m32r.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/i386/i386.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/sh/sh.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/avr/avr.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/m68hc11/m68hc11.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/iq2000/iq2000.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/mn10300/mn10300.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/m68k/m68k.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/score/score.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/pa/pa.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/mips/mips.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/alpha/alpha.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/frv/frv.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/spu/spu.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/xtensa/xtensa.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/cris/cris.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/rs6000/rs6000.h (LEGITIMIZE_ADDRESS): Delete.\n\t* gcc/config/picochip/picochip.h (LEGITIMIZE_ADDRESS): Delete.\n\n\t* gcc/config/s390/s390-protos.h (legitimize_address): Delete.\n\t* gcc/config/m32c/m32c-protos.h (m32c_legitimize_address): Delete.\n\t* gcc/config/sparc/sparc-protos.h (legitimize_address): Delete.\n\t* gcc/config/i386/i386-protos.h (legitimize_address): Delete.\n\t* gcc/config/avr/avr-protos.h (legitimize_address): Delete.\n\t* gcc/config/mn10300/mn10300-protos.h (legitimize_address): Delete.\n\t* gcc/config/score/score-protos.h (score_legitimize_address): Delete.\n\t* gcc/config/arm/arm-protos.h (arm_legitimize_address,\n\t(thumb_legitimize_address): Delete.\n\t* gcc/config/pa/pa-protos.h (hppa_legitimize_address): Delete.\n\t* gcc/config/mips/mips-protos.h (mips_legitimize_address): Delete.\n\t* gcc/config/alpha/alpha-protos.h (alpha_legitimize_address): Delete.\n\t* gcc/config/frv/frv-protos.h (frv_legitimize_address): Delete.\n\t* gcc/config/spu/spu-protos.h (spu_legitimize_address): Delete.\n\t* gcc/config/xtensa/xtensa-protos.h (xtensa_legitimize_address): Delete.\n\t* gcc/config/rs6000/rs6000-protos.h (rs6000_legitimize_address): Delete.\n\n\t* config/arm/arm.c (arm_legitimize_address): Maybe call Thumb version.\n\t* config/m32c/m32c.c (m32c_legitimize_address): Standardize.\n\t* config/m32r/m32r.c (m32r_legitimize_address): New.\n\t* config/m68k/m68k.c (m68k_legitimize_address): New.\n\t* config/score/score.c (score_legitimize_address): Standardize.\n\t* config/score/score3.c (score3_legitimize_address): Standardize.\n\t* config/score/score3.h (score3_legitimize_address): Adjust.\n\t* config/score/score7.c (score7_legitimize_address): Standardize.\n\t* config/score/score7.h (score7_legitimize_address): Adjust.\n\t* config/sh/sh.c (sh_legitimize_address): New.\n\t* config/iq2000/iq2000.c (iq2000_legitimize_address): New.\n\n\t* gcc/config/s390/s390.c (legitimize_address): Rename to...\n \t(s390_legitimize_address): ... this.\n\t* gcc/config/sparc/sparc.c (legitimize_address): Rename to...\n\t(sparc_legitimize_address): ... this.\n\t* gcc/config/i386/i386.c (legitimize_address): Rename to...\n\t(ix86_legitimize_address): ... this.\n\t* gcc/config/avr/avr.c (legitimize_address): Rename to...\n\t(avr_legitimize_address): ... this.\n\t* gcc/config/mn10300/mn10300.c (legitimize_address): Rename to...\n\t(mn10300_legitimize_address): ... this.\n\t* config/alpha/alpha.c (alpha_legitimize_address): Wrap...\n\t(alpha_legitimize_address_1): ... the old alpha_legitimize_address.\n\t(alpha_expand_mov): Adjust call.\n\n\t* config/frv/frv.c (frv_legitimize_address): Return x on failure.\n\t* config/spu/spu.c (spu_legitimize_address): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_legitimize_address): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_legitimize_address): Likewise.\n\nFrom-SVN: r147098", "tree": {"sha": "90120b7cfa3d00ed190fd39a0de8459271199a48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90120b7cfa3d00ed190fd39a0de8459271199a48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/506d7b686cfb5b66f2945219d8863233d7dac645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506d7b686cfb5b66f2945219d8863233d7dac645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/506d7b686cfb5b66f2945219d8863233d7dac645", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506d7b686cfb5b66f2945219d8863233d7dac645/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "67beaaa685fd5a4659cf725d109871a486b5c175", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67beaaa685fd5a4659cf725d109871a486b5c175", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67beaaa685fd5a4659cf725d109871a486b5c175"}], "stats": {"total": 1150, "additions": 507, "deletions": 643}, "files": [{"sha": "ad44ff2428b08ac32dc52db008600dc58dacdb38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1,3 +1,94 @@\n+2009-05-04  Paolo Bonzini  <bonzini@gnu.org>\n+\n+ \t* doc/tm.texi (LEGITIMIZE_ADDRESS): Revise documentation.\n+\t* gcc/defaults.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/explow.c (memory_address): Use target hook.\n+\t* gcc/targhooks.c (default_legitimize_address): New.\n+\t* gcc/targhooks.h (default_legitimize_address): New.\n+\t* gcc/target.h (legitimize_address): New.\n+\t* gcc/target-def.h (TARGET_LEGITIMIZE_ADDRESS): New.\n+\t(TARGET_INITIALIZER): Include it.\n+\t* gcc/system.h (LEGITIMIZE_ADDRESS): Poison.\n+\n+\t* config/bfin/bfin-protos.h (legitimize_address): Remove.\n+\t* config/bfin/bfin.c (legitimize_address): Remove.\n+\t* config/bfin/bfin.h (LEGITIMIZE_ADDRESS): Remove.\n+\t* config/m68hc11/m68hc11-protos.h (m68hc11_legitimize_address): Remove.\n+\t* config/m68hc11/m68hc11.c (m68hc11_legitimize_address): Remove.\n+\t* config/m68hc11/m68hc11.h (LEGITIMIZE_ADDRESS): Remove.\n+\n+\t* gcc/config/arm/arm.h (LEGITIMIZE_ADDRESS, ARM_LEGITIMIZE_ADDRESS,\n+\tTHUMB_LEGITIMIZE_ADDRESS, THUMB2_LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/s390/s390.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/m32c/m32c.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/sparc/sparc.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/m32r/m32r.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/i386/i386.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/sh/sh.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/avr/avr.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/m68hc11/m68hc11.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/iq2000/iq2000.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/mn10300/mn10300.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/m68k/m68k.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/score/score.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/pa/pa.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/mips/mips.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/alpha/alpha.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/frv/frv.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/spu/spu.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/xtensa/xtensa.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/cris/cris.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/rs6000/rs6000.h (LEGITIMIZE_ADDRESS): Delete.\n+\t* gcc/config/picochip/picochip.h (LEGITIMIZE_ADDRESS): Delete.\n+\n+\t* gcc/config/s390/s390-protos.h (legitimize_address): Delete.\n+\t* gcc/config/m32c/m32c-protos.h (m32c_legitimize_address): Delete.\n+\t* gcc/config/sparc/sparc-protos.h (legitimize_address): Delete.\n+\t* gcc/config/i386/i386-protos.h (legitimize_address): Delete.\n+\t* gcc/config/avr/avr-protos.h (legitimize_address): Delete.\n+\t* gcc/config/mn10300/mn10300-protos.h (legitimize_address): Delete.\n+\t* gcc/config/score/score-protos.h (score_legitimize_address): Delete.\n+\t* gcc/config/arm/arm-protos.h (arm_legitimize_address,\n+\t(thumb_legitimize_address): Delete.\n+\t* gcc/config/pa/pa-protos.h (hppa_legitimize_address): Delete.\n+\t* gcc/config/mips/mips-protos.h (mips_legitimize_address): Delete.\n+\t* gcc/config/alpha/alpha-protos.h (alpha_legitimize_address): Delete.\n+\t* gcc/config/frv/frv-protos.h (frv_legitimize_address): Delete.\n+\t* gcc/config/spu/spu-protos.h (spu_legitimize_address): Delete.\n+\t* gcc/config/xtensa/xtensa-protos.h (xtensa_legitimize_address): Delete.\n+\t* gcc/config/rs6000/rs6000-protos.h (rs6000_legitimize_address): Delete.\n+\n+\t* config/arm/arm.c (arm_legitimize_address): Maybe call Thumb version.\n+\t* config/m32c/m32c.c (m32c_legitimize_address): Standardize.\n+\t* config/m32r/m32r.c (m32r_legitimize_address): New.\n+\t* config/m68k/m68k.c (m68k_legitimize_address): New.\n+\t* config/score/score.c (score_legitimize_address): Standardize.\n+\t* config/score/score3.c (score3_legitimize_address): Standardize.\n+\t* config/score/score3.h (score3_legitimize_address): Adjust.\n+\t* config/score/score7.c (score7_legitimize_address): Standardize.\n+\t* config/score/score7.h (score7_legitimize_address): Adjust.\n+\t* config/sh/sh.c (sh_legitimize_address): New.\n+\t* config/iq2000/iq2000.c (iq2000_legitimize_address): New.\n+\n+\t* gcc/config/s390/s390.c (legitimize_address): Rename to...\n+ \t(s390_legitimize_address): ... this.\n+\t* gcc/config/sparc/sparc.c (legitimize_address): Rename to...\n+\t(sparc_legitimize_address): ... this.\n+\t* gcc/config/i386/i386.c (legitimize_address): Rename to...\n+\t(ix86_legitimize_address): ... this.\n+\t* gcc/config/avr/avr.c (legitimize_address): Rename to...\n+\t(avr_legitimize_address): ... this.\n+\t* gcc/config/mn10300/mn10300.c (legitimize_address): Rename to...\n+\t(mn10300_legitimize_address): ... this.\n+\t* config/alpha/alpha.c (alpha_legitimize_address): Wrap...\n+\t(alpha_legitimize_address_1): ... the old alpha_legitimize_address.\n+\t(alpha_expand_mov): Adjust call.\n+\n+\t* config/frv/frv.c (frv_legitimize_address): Return x on failure.\n+\t* config/spu/spu.c (spu_legitimize_address): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_legitimize_address): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_legitimize_address): Likewise.\n+\n 2009-05-04  Joseph Myers  <joseph@codesourcery.com>\n \n \t* intl.c (locale_encoding, locale_utf8): New."}, {"sha": "66c68aebc9152ad4826b82707654d565200b548a", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -39,7 +39,6 @@ extern rtx alpha_tablejump_best_label (rtx);\n \n extern bool alpha_legitimate_constant_p (rtx);\n extern bool alpha_legitimate_address_p (enum machine_mode, rtx, int);\n-extern rtx alpha_legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx alpha_legitimize_reload_address (rtx, enum machine_mode,\n \t\t\t\t\t    int, int, int);\n "}, {"sha": "bb6542a37f9b45af392a1d8b051b76ecc029f89b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -917,8 +917,8 @@ get_tls_get_addr (void)\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.  */\n \n-rtx\n-alpha_legitimize_address (rtx x, rtx scratch, enum machine_mode mode)\n+static rtx\n+alpha_legitimize_address_1 (rtx x, rtx scratch, enum machine_mode mode)\n {\n   HOST_WIDE_INT addend;\n \n@@ -1112,6 +1112,18 @@ alpha_legitimize_address (rtx x, rtx scratch, enum machine_mode mode)\n   }\n }\n \n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  Return X or the new, valid address.  */\n+\n+static rtx\n+alpha_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t  enum machine_mode mode)\n+{\n+  rtx new_x = alpha_legitimize_address_1 (x, NULL_RTX, mode);\n+  return new_x ? new_x : x;\n+}\n+\n /* Primarily this is required for TLS symbols, but given that our move\n    patterns *ought* to be able to handle any symbol at any time, we\n    should never be spilling symbolic operands to the constant pool, ever.  */\n@@ -2137,7 +2149,7 @@ alpha_expand_mov (enum machine_mode mode, rtx *operands)\n   /* Allow legitimize_address to perform some simplifications.  */\n   if (mode == Pmode && symbolic_operand (operands[1], mode))\n     {\n-      tmp = alpha_legitimize_address (operands[1], operands[0], mode);\n+      tmp = alpha_legitimize_address_1 (operands[1], operands[0], mode);\n       if (tmp)\n \t{\n \t  if (tmp == operands[0])\n@@ -10725,6 +10737,9 @@ alpha_init_libfuncs (void)\n #undef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS alpha_init_libfuncs\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS alpha_legitimize_address\n+\n #if TARGET_ABI_UNICOSMK\n #undef TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START unicosmk_file_start"}, {"sha": "f33e8e63854e35934e15f9e97a118b4513d06404", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1009,20 +1009,6 @@ do {\t\t\t\t\t\t\\\n } while (0)\n #endif\n \n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  rtx new_x = alpha_legitimize_address (X, NULL_RTX, MODE);\t\\\n-  if (new_x)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      X = new_x;\t\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.  */"}, {"sha": "34d266b139be339959306e3203c971b7300a867b", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -58,8 +58,6 @@ extern int arm_legitimate_address_p  (enum machine_mode, rtx, RTX_CODE, int);\n extern int thumb1_legitimate_address_p (enum machine_mode, rtx, int);\n extern int thumb2_legitimate_address_p  (enum machine_mode, rtx, int);\n extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);\n-extern rtx arm_legitimize_address (rtx, rtx, enum machine_mode);\n-extern rtx thumb_legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n \t\t\t\t\t    int);\n extern int arm_const_double_rtx (rtx);"}, {"sha": "e6d2c5c67dc4265763fe53d1c0ac8d0107084f11", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -73,6 +73,8 @@ static int arm_address_register_rtx_p (rtx, int);\n static int arm_legitimate_index_p (enum machine_mode, rtx, RTX_CODE, int);\n static int thumb2_legitimate_index_p (enum machine_mode, rtx, int);\n static int thumb1_base_register_rtx_p (rtx, enum machine_mode, int);\n+static rtx arm_legitimize_address (rtx, rtx, enum machine_mode);\n+static rtx thumb_legitimize_address (rtx, rtx, enum machine_mode);\n inline static int thumb1_index_register_rtx_p (rtx, int);\n static int thumb_far_jump_used_p (void);\n static bool thumb_force_lr_save (void);\n@@ -205,6 +207,9 @@ static bool arm_allocate_stack_slots_for_args (void);\n #define TARGET_MERGE_DECL_ATTRIBUTES merge_dllimport_decl_attributes\n #endif\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS arm_legitimize_address\n+\n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE arm_attribute_table\n \n@@ -4590,6 +4595,14 @@ legitimize_tls_address (rtx x, rtx reg)\n rtx\n arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n {\n+  if (!TARGET_ARM)\n+    {\n+      /* TODO: legitimize_address for Thumb2.  */\n+      if (TARGET_THUMB2)\n+        return x;\n+      return thumb_legitimize_address (x, orig_x, mode);\n+    }\n+\n   if (arm_tls_symbol_p (x))\n     return legitimize_tls_address (x, NULL_RTX);\n "}, {"sha": "e7bc7a7a2d53039fe5481abce956885c1a26d5c1", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -2204,36 +2204,6 @@ typedef struct\n     THUMB1_GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)\n \n \f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.  */\n-#define ARM_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n-do {\t\t\t\t\t\t\t\\\n-  X = arm_legitimize_address (X, OLDX, MODE);\t\t\\\n-} while (0)\n-\n-/* ??? Implement LEGITIMIZE_ADDRESS for thumb2.  */\n-#define THUMB2_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n-do {\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define THUMB1_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n-do {\t\t\t\t\t\t\t\\\n-  X = thumb_legitimize_address (X, OLDX, MODE);\t\t\\\n-} while (0)\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  if (TARGET_ARM)\t\t\t\t\t\\\n-    ARM_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN);\t\\\n-  else if (TARGET_THUMB2)\t\t\t\t\\\n-    THUMB2_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN);\t\\\n-  else\t\t\t\t\t\t\t\\\n-    THUMB1_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN);\t\\\n-\t\t\t\t\t\t\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\\\n-} while (0)\n-\n /* Define this for compatibility reasons. */\n #define HANDLE_PRAGMA_PACK_PUSH_POP\n "}, {"sha": "44246901b32c937293f55f2d700e8f4f2224a906", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -98,7 +98,6 @@ extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n \n extern enum reg_class preferred_reload_class (rtx x, enum reg_class rclass);\n extern int extra_constraint_Q (rtx x);\n-extern rtx legitimize_address (rtx x, rtx oldx, enum machine_mode mode);\n extern int adjust_insn_length (rtx insn, int len);\n extern rtx avr_libcall_value (enum machine_mode mode);\n extern const char *output_reload_inhi (rtx insn, rtx *operands, int *len);"}, {"sha": "449c0ee4f89da6f6d31e9c9f9f3878eeb4dcff14", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -62,6 +62,7 @@ static const char *cond_string (enum rtx_code);\n static int avr_num_arg_regs (enum machine_mode, tree);\n \n static RTX_CODE compare_condition (rtx insn);\n+static rtx avr_legitimize_address (rtx, rtx, enum machine_mode);\n static int compare_sign_p (rtx insn);\n static tree avr_handle_progmem_attribute (tree *, tree, tree, int, bool *);\n static tree avr_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n@@ -349,6 +350,9 @@ static const struct mcu_type_s avr_mcu_types[] = {\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG avr_reorg\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS avr_legitimize_address\n+\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY avr_return_in_memory\n \n@@ -1164,7 +1168,7 @@ legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n    memory address for an operand of mode MODE  */\n \n rtx\n-legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n+avr_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n {\n   x = oldx;\n   if (TARGET_ALL_DEBUG)"}, {"sha": "79d81b94923b03daaa5fd920fdd9ff24c3ae6731", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -435,13 +435,6 @@ extern int avr_reg_order[];\n \n #define REG_OK_FOR_INDEX_P(X) 0\n \n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  (X) = legitimize_address (X, OLDX, MODE);\t\t\t\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-}\n-\n #define XEXP_(X,Y) (X)\n \n /* LEGITIMIZE_RELOAD_ADDRESS will allow register R26/27 to be used, where it"}, {"sha": "33de846da95e7ba2378e00e96dd0d222eddfdc24", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -109,7 +109,6 @@ extern char *bfin_asm_long (void);\n extern char *bfin_asm_short (void);\n extern int log2constp (unsigned HOST_WIDE_INT);\n \n-extern rtx legitimize_address (rtx, rtx, Mmode);\n extern bool bfin_legitimate_constant_p (rtx);\n extern int hard_regno_mode_ok (int, Mmode);\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\t  "}, {"sha": "17201c652e179ec6145be2cce63c704de4674ddd", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1418,22 +1418,6 @@ bfin_return_addr_rtx (int count)\n   return get_hard_reg_initial_val (Pmode, REG_RETS);\n }\n \n-/* Try machine-dependent ways of modifying an illegitimate address X\n-   to be legitimate.  If we find one, return the new, valid address,\n-   otherwise return NULL_RTX.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE is the mode of the memory reference.  */\n-\n-rtx\n-legitimize_address (rtx x ATTRIBUTE_UNUSED, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return NULL_RTX;\n-}\n-\n static rtx\n bfin_delegitimize_address (rtx orig_x)\n {"}, {"sha": "d97fe8faaf4351b69f52e576a16e0a45c5049de2", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -948,25 +948,6 @@ typedef struct {\n   } while (0);\n #endif\n \n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n- */\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)    \\\n-do {\t\t\t\t\t       \\\n-   rtx _q = legitimize_address(X, OLDX, MODE); \\\n-   if (_q) { X = _q; goto WIN; }\t       \\\n-} while (0)\n-\n #define HAVE_POST_INCREMENT 1\n #define HAVE_POST_DECREMENT 1\n #define HAVE_PRE_DECREMENT  1"}, {"sha": "47936d6e73e69a084c5f9cf7bda65b977efd4053", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1189,16 +1189,6 @@ struct cum_args {int regs;};\n # define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n #endif\n \n-/* For now, don't do anything.  GCC does a good job most often.\n-\n-    Maybe we could do something about gcc:s misbehavior when it\n-   recalculates frame offsets for local variables, from fp+offs to\n-   sp+offs.  The resulting address expression gets screwed up\n-   sometimes, but I'm not sure that it may be fixed here, since it is\n-   already split up in several instructions (Is this still true?).\n-   FIXME: Check and adjust for gcc-2.9x.  */\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN) {}\n-\n /* Fix reloads known to cause suboptimal spilling.  */\n #define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, INDL, WIN)\t\\\n   do\t\t\t\t\t\t\t\t\t\\"}, {"sha": "c34d02cf96fde81cd81ac54538f56f636ddd6cb6", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -49,7 +49,6 @@ extern int frv_initial_elimination_offset\t(int, int);\n #ifdef RTX_CODE\n extern int frv_legitimate_address_p\t\t(enum machine_mode, rtx,\n \t\t\t\t\t\t int, int, int);\n-extern rtx frv_legitimize_address\t\t(rtx, rtx, enum machine_mode);\n extern rtx frv_find_base_term\t\t\t(rtx);\n \n #ifdef TREE_CODE"}, {"sha": "4e8c1b24cf8e7f2540bad129049e62e9740039a9", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -303,6 +303,7 @@ static int frv_check_constant_argument\t\t(enum insn_code, int, rtx);\n static rtx frv_legitimize_target\t\t(enum insn_code, rtx);\n static rtx frv_legitimize_argument\t\t(enum insn_code, int, rtx);\n static rtx frv_legitimize_tls_address\t\t(rtx, enum tls_model);\n+static rtx frv_legitimize_address\t\t(rtx, rtx, enum machine_mode);\n static rtx frv_expand_set_builtin\t\t(enum insn_code, tree, rtx);\n static rtx frv_expand_unop_builtin\t\t(enum insn_code, tree, rtx);\n static rtx frv_expand_binop_builtin\t\t(enum insn_code, tree, rtx);\n@@ -433,6 +434,9 @@ static bool frv_secondary_reload                (bool, rtx, enum reg_class,\n #undef  TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE frv_issue_rate\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS frv_legitimize_address\n+\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL frv_function_ok_for_sibcall\n #undef TARGET_CANNOT_FORCE_CONST_MEM\n@@ -3661,7 +3665,7 @@ frv_legitimize_address (rtx x,\n         return frv_legitimize_tls_address (x, model);\n     }\n \n-  return NULL_RTX;\n+  return x;\n }\n \f\n /* Test whether a local function descriptor is canonical, i.e.,"}, {"sha": "b6fdca4aa0a43360667a25568ee97889a0afb30c", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -2120,16 +2120,6 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n    will reload one or both registers only if neither labeling works.  */\n #define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n \n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  rtx new_x = frv_legitimize_address (X, OLDX, MODE);\t\\\n-  if (new_x)\t\t\t\t\t\t\\\n-    { \t\t\t\t\t\t\t\\\n-      (X) = new_x; \t\t\t\t\t\\\n-      goto WIN; \t\t\t\t\t\\\n-    } \t\t\t\t\t\t\t\\\n-} while (0)\n-\n #define FIND_BASE_TERM frv_find_base_term\n \n /* A C expression that is nonzero if X is a legitimate constant for an"}, {"sha": "badea0d4335004e5201dff2b948aa9861475dc44", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -57,7 +57,6 @@ extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);\n extern int legitimate_pic_address_disp_p (rtx);\n extern int legitimate_address_p (enum machine_mode, rtx, int);\n-extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n \n extern void print_reg (rtx, int, FILE*);\n extern void print_operand (FILE*, rtx, int);"}, {"sha": "b0974ff912fff9d80242024b920232b405d7bcef", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -9767,7 +9767,7 @@ get_thread_pointer (int to_reg)\n   return reg;\n }\n \n-/* A subroutine of legitimize_address and ix86_expand_move.  FOR_MOV is\n+/* A subroutine of ix86_legitimize_address and ix86_expand_move.  FOR_MOV is\n    false if we expect this to be used for a memory address and true if\n    we expect to load the address into a register.  */\n \n@@ -10025,8 +10025,9 @@ legitimize_dllimport_symbol (rtx symbol, bool want_reg)\n    When -fpic is used, special handling is needed for symbolic references.\n    See comments by legitimize_pic_address in i386.c for details.  */\n \n-rtx\n-legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, enum machine_mode mode)\n+static rtx\n+ix86_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode)\n {\n   int changed = 0;\n   unsigned log;\n@@ -30044,6 +30045,9 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ix86_return_in_memory\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS ix86_legitimize_address\n+\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE ix86_attribute_table\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES"}, {"sha": "4aafd9c92fe4c5e9a4b4391676b6f89828f4d047", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1850,34 +1850,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define FIND_BASE_TERM(X) ix86_find_base_term (X)\n \n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For the 80386, we handle X+REG by loading X into a register R and\n-   using R+REG.  R will go in a general reg and indexing will be used.\n-   However, if REG is a broken-out memory address or multiplication,\n-   nothing needs to be done because REG can certainly go in a general reg.\n-\n-   When -fpic is used, special handling is needed for symbolic references.\n-   See comments by legitimize_pic_address in i386.c for details.  */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  (X) = legitimize_address ((X), (OLDX), (MODE));\t\t\t\\\n-  if (memory_address_p ((MODE), (X)))\t\t\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and\n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */"}, {"sha": "3b9e1166b27c958a0823d99f311fb15685f95011", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -165,6 +165,7 @@ static void iq2000_setup_incoming_varargs (CUMULATIVE_ARGS *,\n static bool iq2000_rtx_costs          (rtx, int, int, int *, bool);\n static int  iq2000_address_cost       (rtx, bool);\n static section *iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n+static rtx  iq2000_legitimize_address (rtx, rtx, enum machine_mode);\n static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static int  iq2000_arg_partial_bytes  (CUMULATIVE_ARGS *, enum machine_mode,\n@@ -186,6 +187,9 @@ static void iq2000_va_start\t      (tree, rtx);\n #undef  TARGET_ASM_SELECT_SECTION\n #define TARGET_ASM_SELECT_SECTION\tiq2000_select_section\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS\tiq2000_legitimize_address\n+\n /* The assembler supports switchable .bss sections, but\n    iq2000_select_section doesn't yet make use of them.  */\n #undef  TARGET_HAVE_SWITCHABLE_BSS_SECTIONS\n@@ -3214,6 +3218,73 @@ print_operand (FILE *file, rtx op, int letter)\n     output_addr_const (file, op);\n }\n \n+\n+/* For the IQ2000, transform:\n+\n+        memory(X + <large int>)\n+   into:\n+        Y = <large int> & ~0x7fff;\n+        Z = X + Y\n+        memory (Z + (<large int> & 0x7fff));\n+*/\n+\n+rtx\n+iq2000_legitimize_address (rtx xinsn, rtx old_x ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode)\n+{\n+  if (TARGET_DEBUG_B_MODE)\n+    {\n+      GO_PRINTF (\"\\n========== LEGITIMIZE_ADDRESS\\n\");\n+      GO_DEBUG_RTX (xinsn);\n+    }\n+\n+  if (iq2000_check_split (xinsn, mode))\n+    {\n+      return gen_rtx_LO_SUM (Pmode,\n+                             copy_to_mode_reg (Pmode,\n+                                               gen_rtx_HIGH (Pmode, xinsn)),\n+                             xinsn);\n+    }\n+\n+  if (GET_CODE (xinsn) == PLUS)\n+    {\n+      rtx xplus0 = XEXP (xinsn, 0);\n+      rtx xplus1 = XEXP (xinsn, 1);\n+      enum rtx_code code0 = GET_CODE (xplus0);\n+      enum rtx_code code1 = GET_CODE (xplus1);\n+\n+      if (code0 != REG && code1 == REG)\n+        {\n+          xplus0 = XEXP (xinsn, 1);\n+          xplus1 = XEXP (xinsn, 0);\n+          code0 = GET_CODE (xplus0);\n+          code1 = GET_CODE (xplus1);\n+        }\n+\n+      if (code0 == REG && REG_MODE_OK_FOR_BASE_P (xplus0, mode)\n+          && code1 == CONST_INT && !SMALL_INT (xplus1))\n+        {\n+          rtx int_reg = gen_reg_rtx (Pmode);\n+          rtx ptr_reg = gen_reg_rtx (Pmode);\n+\n+          emit_move_insn (int_reg,\n+                          GEN_INT (INTVAL (xplus1) & ~ 0x7fff));\n+\n+          emit_insn (gen_rtx_SET (VOIDmode,\n+                                  ptr_reg,\n+                                  gen_rtx_PLUS (Pmode, xplus0, int_reg)));\n+\n+          return plus_constant (ptr_reg, INTVAL (xplus1) & 0x7fff);\n+        }\n+    }\n+\n+  if (TARGET_DEBUG_B_MODE)\n+    GO_PRINTF (\"LEGITIMIZE_ADDRESS could not fix.\\n\");\n+\n+  return xinsn;\n+}\n+\n+\n static bool\n iq2000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int * total,\n \t\t  bool speed ATTRIBUTE_UNUSED)"}, {"sha": "30642b2a13f44c7ac96597ccadb06a91d17f0c17", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -544,72 +544,6 @@ typedef struct iq2000_args\n \n #define REG_OK_FOR_INDEX_P(X) 0\n \n-\n-/* For the IQ2000, transform:\n-\n-\tmemory(X + <large int>)\n-   into:\n-\tY = <large int> & ~0x7fff;\n-\tZ = X + Y\n-\tmemory (Z + (<large int> & 0x7fff));\n-*/\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx xinsn = (X);\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      GO_PRINTF (\"\\n========== LEGITIMIZE_ADDRESS\\n\");\t\t\t\\\n-      GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (iq2000_check_split (X, MODE))\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      X = gen_rtx_LO_SUM (Pmode,\t\t\t\t\t\\\n-\t\t\t  copy_to_mode_reg (Pmode,\t\t\t\\\n-\t\t\t\t\t    gen_rtx_HIGH (Pmode, X)),\t\\\n-\t\t\t  X);\t\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\t\\\n-      rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\t\\\n-      enum rtx_code code0 = GET_CODE (xplus0);\t\t\t\t\\\n-      enum rtx_code code1 = GET_CODE (xplus1);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (code0 != REG && code1 == REG)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  xplus0 = XEXP (xinsn, 1);\t\t\t\t\t\\\n-\t  xplus1 = XEXP (xinsn, 0);\t\t\t\t\t\\\n-\t  code0 = GET_CODE (xplus0);\t\t\t\t\t\\\n-\t  code1 = GET_CODE (xplus1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (code0 == REG && REG_MODE_OK_FOR_BASE_P (xplus0, MODE)\t\t\\\n-\t  && code1 == CONST_INT && !SMALL_INT (xplus1))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx int_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n-\t  rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  emit_move_insn (int_reg,\t\t\t\t\t\\\n-\t\t\t  GEN_INT (INTVAL (xplus1) & ~ 0x7fff));\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  emit_insn (gen_rtx_SET (VOIDmode,\t\t\t\t\\\n-\t\t\t\t  ptr_reg,\t\t\t\t\\\n-\t\t\t\t  gen_rtx_PLUS (Pmode, xplus0, int_reg))); \\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  X = plus_constant (ptr_reg, INTVAL (xplus1) & 0x7fff);\t\\\n-\t  goto WIN;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\\\n-    GO_PRINTF (\"LEGITIMIZE_ADDRESS could not fix.\\n\");\t\t\t\\\n-}\n-\n #define LEGITIMATE_CONSTANT_P(X) (1)\n \n \f"}, {"sha": "650c918b44aa0d89457603edb5e99520d91e9acb", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -79,7 +79,6 @@ rtx  m32c_incoming_return_addr_rtx (void);\n void m32c_initialize_trampoline (rtx, rtx, rtx);\n int  m32c_legitimate_address_p (MM, rtx, int);\n int  m32c_legitimate_constant_p (rtx);\n-int  m32c_legitimize_address (rtx *, rtx, MM);\n int  m32c_legitimize_reload_address (rtx *, MM, int, int, int);\n rtx  m32c_libcall_value (MM);\n int  m32c_limit_reload_class (MM, int);"}, {"sha": "6d386e3d8fd5e438957837ba37491f088c419b5d", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1938,33 +1938,33 @@ m32c_reg_ok_for_base_p (rtx x, int strict)\n    displacement range.  We deal with this by attempting to reload $fb\n    itself into an address register; that seems to result in the best\n    code.  */\n-int\n-m32c_legitimize_address (rtx * x ATTRIBUTE_UNUSED,\n-\t\t\t rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS m32c_legitimize_address\n+static rtx\n+m32c_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode)\n {\n #if DEBUG0\n   fprintf (stderr, \"m32c_legitimize_address for mode %s\\n\", mode_name[mode]);\n-  debug_rtx (*x);\n+  debug_rtx (x);\n   fprintf (stderr, \"\\n\");\n #endif\n \n-  if (GET_CODE (*x) == PLUS\n-      && GET_CODE (XEXP (*x, 0)) == REG\n-      && REGNO (XEXP (*x, 0)) == FB_REGNO\n-      && GET_CODE (XEXP (*x, 1)) == CONST_INT\n-      && (INTVAL (XEXP (*x, 1)) < -128\n-\t  || INTVAL (XEXP (*x, 1)) > (128 - GET_MODE_SIZE (mode))))\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && REGNO (XEXP (x, 0)) == FB_REGNO\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && (INTVAL (XEXP (x, 1)) < -128\n+\t  || INTVAL (XEXP (x, 1)) > (128 - GET_MODE_SIZE (mode))))\n     {\n       /* reload FB to A_REGS */\n       rtx temp = gen_reg_rtx (Pmode);\n-      *x = copy_rtx (*x);\n-      emit_insn (gen_rtx_SET (VOIDmode, temp, XEXP (*x, 0)));\n-      XEXP (*x, 0) = temp;\n-      return 1;\n+      x = copy_rtx (x);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, XEXP (x, 0)));\n+      XEXP (x, 0) = temp;\n     }\n \n-  return 0;\n+  return x;\n }\n \n /* Implements LEGITIMIZE_RELOAD_ADDRESS.  See comment above.  */"}, {"sha": "cb2b8bea1f0e67766f9b8d57ea4042bb5ad1b86a", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -587,10 +587,6 @@ typedef struct m32c_cumulative_args\n \n /* #define FIND_BASE_TERM(X) when we do unspecs for symrefs */\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN) \\\n-\tif (m32c_legitimize_address(&(X),OLDX,MODE)) \\\n-\t  goto WIN;\n-\n #define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN) \\\n \tif (m32c_legitimize_reload_address(&(X),MODE,OPNUM,TYPE,IND_LEVELS)) \\\n \t  goto WIN;"}, {"sha": "656c0eae1bef01ead193108872782c48f15c7dde", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -70,6 +70,7 @@ static void  init_reg_tables (void);\n static void  block_move_call (rtx, rtx, rtx);\n static int   m32r_is_insn (rtx);\n const struct attribute_spec m32r_attribute_table[];\n+static rtx   m32r_legitimize_address (rtx, rtx, enum machine_mode);\n static tree  m32r_handle_model_attribute (tree *, tree, tree, int, bool *);\n static void  m32r_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void  m32r_output_function_epilogue (FILE *, HOST_WIDE_INT);\n@@ -95,6 +96,9 @@ static int m32r_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m32r_attribute_table\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS m32r_legitimize_address\n+\n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n #undef  TARGET_ASM_ALIGNED_SI_OP\n@@ -1728,6 +1732,16 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n \n   return orig;\n }\n+\n+static rtx\n+m32r_legitimize_address (rtx x, rtx orig_x ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (flag_pic)\n+    return m32r_legitimize_pic_address (x, NULL_RTX);\n+  else\n+    return x;\n+}\n \f\n /* Nested function support.  */\n "}, {"sha": "9bc0fa98a0a84d09618435ae7480fea8a03cda52", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1169,29 +1169,6 @@ L2:     .word STATIC\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t \\\n-  do\t\t\t\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t \\\n-      if (flag_pic)\t\t\t\t\t\t \\\n-\t(X) = m32r_legitimize_pic_address (X, NULL_RTX);\t \\\n-      if (memory_address_p (MODE, X))\t\t\t\t \\\n-\tgoto WIN;\t\t\t\t\t\t \\\n-    }\t\t\t\t\t\t\t\t \\\n-  while (0)\n-\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\t\\"}, {"sha": "5412e1d3eea825747b9a990c1f40c3469205a2f3", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -50,8 +50,6 @@ extern enum reg_class preferred_reload_class (rtx, enum reg_class);\n \n extern int m68hc11_go_if_legitimate_address (rtx, enum machine_mode, int);\n \n-extern int m68hc11_legitimize_address (rtx*, rtx, enum machine_mode);\n-\n extern void m68hc11_notice_update_cc (rtx, rtx);\n extern void m68hc11_notice_keep_cc (rtx);\n "}, {"sha": "5050fa464156267ffc445925ba713c3b5337132f", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -789,14 +789,6 @@ m68hc11_go_if_legitimate_address (rtx operand, enum machine_mode mode,\n   return result;\n }\n \n-int\n-m68hc11_legitimize_address (rtx *operand ATTRIBUTE_UNUSED,\n-                            rtx old_operand ATTRIBUTE_UNUSED,\n-                            enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return 0;\n-}\n-\n \n int\n m68hc11_reload_operands (rtx operands[])"}, {"sha": "351765926018c66c375fa669f70a955cc2e775a1", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1205,28 +1205,6 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n #endif\n \n \n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-  \n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-  \n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-  \n-   It is always safe for this macro to do nothing.\n-   It exists to recognize opportunities to optimize the output.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)                     \\\n-{ rtx operand = (X);                                            \\\n-  if (m68hc11_legitimize_address (&operand, (OLDX), (MODE)))\t\\\n-    {                                                           \\\n-      (X) = operand;                                            \\\n-      GO_IF_LEGITIMATE_ADDRESS (MODE,X,WIN);                    \\\n-    }                                                           \\\n-}\n-\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n "}, {"sha": "e4bb1e2b4a2e892a12fcb5f0d2d9a4e2551e28ad", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -143,6 +143,7 @@ static tree m68k_handle_fndecl_attribute (tree *node, tree name,\n static void m68k_compute_frame_layout (void);\n static bool m68k_save_reg (unsigned int regno, bool interrupt_handler);\n static bool m68k_ok_for_sibcall_p (tree, tree);\n+static rtx m68k_legitimize_address (rtx, rtx, enum machine_mode);\n static bool m68k_rtx_costs (rtx, int, int, int *, bool);\n #if M68K_HONOR_TARGET_STRICT_ALIGNMENT\n static bool m68k_return_in_memory (const_tree, const_tree);\n@@ -195,6 +196,9 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_ASM_FILE_START_APP_OFF\n #define TARGET_ASM_FILE_START_APP_OFF true\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS m68k_legitimize_address\n+\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST m68k_sched_adjust_cost\n \n@@ -1422,6 +1426,83 @@ m68k_legitimize_sibcall_address (rtx x)\n   return replace_equiv_address (x, gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM));\n }\n \n+/* Convert X to a legitimate address and return it if successful.  Otherwise\n+   return X.\n+\n+   For the 68000, we handle X+REG by loading X into a register R and\n+   using R+REG.  R will go in an address reg and indexing will be used.\n+   However, if REG is a broken-out memory address or multiplication,\n+   nothing needs to be done because REG can certainly go in an address reg.  */\n+\n+rtx\n+m68k_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n+{\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      int ch = (x) != (oldx);\n+      int copied = 0;\n+\n+#define COPY_ONCE(Y) if (!copied) { Y = copy_rtx (Y); copied = ch = 1; }\n+\n+      if (GET_CODE (XEXP (x, 0)) == MULT)\n+\t{\n+\t  COPY_ONCE (x);\n+\t  XEXP (x, 0) = force_operand (XEXP (x, 0), 0);\n+\t}\n+      if (GET_CODE (XEXP (x, 1)) == MULT)\n+\t{\n+\t  COPY_ONCE (x);\n+\t  XEXP (x, 1) = force_operand (XEXP (x, 1), 0);\n+\t}\n+      if (ch)\n+\t{\n+          if (GET_CODE (XEXP (x, 1)) == REG\n+\t      && GET_CODE (XEXP (x, 0)) == REG)\n+\t    {\n+\t      if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t        {\n+\t          COPY_ONCE (x);\n+\t          x = force_operand (x, 0);\n+\t        }\n+\t      return x;\n+\t    }\n+\t  if (memory_address_p (mode, x))\n+\t    return x;\n+\t}\n+      if (GET_CODE (XEXP (x, 0)) == REG\n+\t  || (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n+\t      && GET_MODE (XEXP (XEXP (x, 0), 0)) == HImode))\n+\t{\n+\t  rtx temp = gen_reg_rtx (Pmode);\n+\t  rtx val = force_operand (XEXP (x, 1), 0);\n+\t  emit_move_insn (temp, val);\n+\t  COPY_ONCE (x);\n+\t  XEXP (x, 1) = temp;\n+\t  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t      && GET_CODE (XEXP (x, 0)) == REG)\n+\t    x = force_operand (x, 0);\n+\t}\n+      else if (GET_CODE (XEXP (x, 1)) == REG\n+\t       || (GET_CODE (XEXP (x, 1)) == SIGN_EXTEND\n+\t\t   && GET_CODE (XEXP (XEXP (x, 1), 0)) == REG\n+\t\t   && GET_MODE (XEXP (XEXP (x, 1), 0)) == HImode))\n+\t{\n+\t  rtx temp = gen_reg_rtx (Pmode);\n+\t  rtx val = force_operand (XEXP (x, 0), 0);\n+\t  emit_move_insn (temp, val);\n+\t  COPY_ONCE (x);\n+\t  XEXP (x, 0) = temp;\n+\t  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t      && GET_CODE (XEXP (x, 1)) == REG)\n+\t    x = force_operand (x, 0);\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n+ \n /* Output a dbCC; jCC sequence.  Note we do not handle the \n    floating point version of this sequence (Fdbcc).  We also\n    do not handle alternative conditions when CC_NO_OVERFLOW is"}, {"sha": "875667dc42852d7bba4feb05204c13d8d157f741", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 1, "deletions": 48, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -765,56 +765,9 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n+\f\n /* This address is OK as it stands.  */\n #define PIC_CASE_VECTOR_ADDRESS(index) index\n-\f\n-/* For the 68000, we handle X+REG by loading X into a register R and\n-   using R+REG.  R will go in an address reg and indexing will be used.\n-   However, if REG is a broken-out memory address or multiplication,\n-   nothing needs to be done because REG can certainly go in an address reg.  */\n-#define COPY_ONCE(Y) if (!copied) { Y = copy_rtx (Y); copied = ch = 1; }\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   \\\n-{ register int ch = (X) != (OLDX);\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { int copied = 0;\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) == MULT)\t\t\t\t\\\n-\t{ COPY_ONCE (X); XEXP (X, 0) = force_operand (XEXP (X, 0), 0);}\t\\\n-      if (GET_CODE (XEXP (X, 1)) == MULT)\t\t\t\t\\\n-\t{ COPY_ONCE (X); XEXP (X, 1) = force_operand (XEXP (X, 1), 0);}\t\\\n-      if (ch && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\\\n-\t{ if (TARGET_COLDFIRE_FPU\t\t\t\t\t\\\n-\t      && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\\\n-\t    { COPY_ONCE (X); X = force_operand (X, 0);}\t\t\t\\\n-\t  goto WIN; }\t\t\t\t\t\t\t\\\n-      if (ch) { GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN); }\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-\t       || (GET_CODE (XEXP (X, 0)) == SIGN_EXTEND\t\t\\\n-\t\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\\\n-\t\t   && GET_MODE (XEXP (XEXP (X, 0), 0)) == HImode))\t\\\n-\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n-\t  register rtx val = force_operand (XEXP (X, 1), 0);\t\t\\\n-\t  emit_move_insn (temp, val);\t\t\t\t\t\\\n-\t  COPY_ONCE (X);\t\t\t\t\t\t\\\n-\t  XEXP (X, 1) = temp;\t\t\t\t\t\t\\\n-\t  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n-\t      && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\\\n-\t    X = force_operand (X, 0);\t\t\t\t\t\\\n-\t  goto WIN; }\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t       || (GET_CODE (XEXP (X, 1)) == SIGN_EXTEND\t\t\\\n-\t\t   && GET_CODE (XEXP (XEXP (X, 1), 0)) == REG\t\t\\\n-\t\t   && GET_MODE (XEXP (XEXP (X, 1), 0)) == HImode))\t\\\n-\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n-\t  register rtx val = force_operand (XEXP (X, 0), 0);\t\t\\\n-\t  emit_move_insn (temp, val);\t\t\t\t\t\\\n-\t  COPY_ONCE (X);\t\t\t\t\t\t\\\n-\t  XEXP (X, 0) = temp;\t\t\t\t\t\t\\\n-\t  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n-\t      && GET_CODE (XEXP (X, 1)) == REG)\t\t\t\t\\\n-\t    X = force_operand (X, 0);\t\t\t\t\t\\\n-\t  goto WIN; }}}\n-\f\n #define CASE_VECTOR_MODE HImode\n #define CASE_VECTOR_PC_RELATIVE 1\n "}, {"sha": "b95461a4c4f9b942b8e07d01ec0817658b7aaf24", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -196,7 +196,6 @@ extern rtx mips_pic_base_register (rtx);\n extern rtx mips_got_load (rtx, rtx, enum mips_symbol_type);\n extern bool mips_split_symbol (rtx, rtx, enum machine_mode, rtx *);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n-extern bool mips_legitimize_address (rtx *, enum machine_mode);\n extern void mips_move_integer (rtx, rtx, unsigned HOST_WIDE_INT);\n extern bool mips_legitimize_move (enum machine_mode, rtx, rtx);\n "}, {"sha": "b40ba3ba5fe8d04ae0120d92c0109478220e7d9b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -2848,41 +2848,36 @@ mips_force_address (rtx x, enum machine_mode mode)\n   return x;\n }\n \n-/* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n+/* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n    be legitimized in a way that the generic machinery might not expect,\n-   put the new address in *XLOC and return true.  MODE is the mode of\n+   return a new address, otherwise return NULL.  MODE is the mode of\n    the memory being accessed.  */\n \n-bool\n-mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n+static rtx\n+mips_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode)\n {\n   rtx base, addr;\n   HOST_WIDE_INT offset;\n \n-  if (mips_tls_symbol_p (*xloc))\n-    {\n-      *xloc = mips_legitimize_tls_address (*xloc);\n-      return true;\n-    }\n+  if (mips_tls_symbol_p (x))\n+    return mips_legitimize_tls_address (x);\n \n   /* See if the address can split into a high part and a LO_SUM.  */\n-  if (mips_split_symbol (NULL, *xloc, mode, &addr))\n-    {\n-      *xloc = mips_force_address (addr, mode);\n-      return true;\n-    }\n+  if (mips_split_symbol (NULL, x, mode, &addr))\n+    return mips_force_address (addr, mode);\n \n   /* Handle BASE + OFFSET using mips_add_offset.  */\n-  mips_split_plus (*xloc, &base, &offset);\n+  mips_split_plus (x, &base, &offset);\n   if (offset != 0)\n     {\n       if (!mips_valid_base_register_p (base, mode, false))\n \tbase = copy_to_mode_reg (Pmode, base);\n       addr = mips_add_offset (NULL, base, offset);\n-      *xloc = mips_force_address (addr, mode);\n-      return true;\n+      return mips_force_address (addr, mode);\n     }\n-  return false;\n+\n+  return x;\n }\n \n /* Load VALUE into DEST.  TEMP is as for mips_force_temporary.  */\n@@ -14749,6 +14744,9 @@ mips_final_postscan_insn (FILE *file, rtx insn, rtx *opvec, int noperands)\n #undef TARGET_ASM_ALIGNED_DI_OP\n #define TARGET_ASM_ALIGNED_DI_OP \"\\t.dword\\t\"\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS mips_legitimize_address\n+\n #undef TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE mips_output_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE"}, {"sha": "5c68688cccee6df104fa4fc221235ffee25e1376", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -2526,13 +2526,6 @@ typedef struct mips_args {\n \n #define LEGITIMATE_CONSTANT_P(X) (mips_const_insns (X) > 0)\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    if (mips_legitimize_address (&(X), MODE))\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-\n /* This handles the magic '..CURRENT_FUNCTION' symbol, which means\n    'the start of the function that this code is output in'.  */\n "}, {"sha": "935cb8f81f6a57d8d107cf97949643aa999dd7c9", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -21,7 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifdef RTX_CODE\n \n extern void mn10300_override_options (void);\n-extern struct rtx_def *legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx legitimize_pic_address (rtx, rtx);\n extern int legitimate_pic_operand_p (rtx);\n extern bool legitimate_address_p (enum machine_mode, rtx, int);"}, {"sha": "ceb77e862c26827e4b04ee75ce15e5aa12119b04", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -76,6 +76,7 @@ static void mn10300_file_start (void);\n static bool mn10300_return_in_memory (const_tree, const_tree);\n static rtx mn10300_builtin_saveregs (void);\n static void mn10300_va_start (tree, rtx);\n+static rtx mn10300_legitimize_address (rtx, rtx, enum machine_mode);\n static bool mn10300_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static int mn10300_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n@@ -86,6 +87,9 @@ static unsigned int mn10300_case_values_threshold (void);\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS mn10300_legitimize_address\n+\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS mn10300_rtx_costs\n #undef TARGET_ADDRESS_COST\n@@ -1795,8 +1799,8 @@ symbolic_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n    But on a few ports with segmented architectures and indexed addressing\n    (mn10300, hppa) it is used to rewrite certain problematical addresses.  */\n rtx\n-legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n+mn10300_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (flag_pic && ! legitimate_pic_operand_p (x))\n     x = legitimize_pic_address (oldx, NULL_RTX);"}, {"sha": "b35894435a20e23748aca83c420c1c392e1966cc", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -693,24 +693,6 @@ do\t\t\t\t\t\t\t\\\n while (0)\n \n \f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)  \\\n-{ rtx orig_x = (X);\t\t\t\t\\\n-  (X) = legitimize_address (X, OLDX, MODE);\t\\\n-  if ((X) != orig_x && memory_address_p (MODE, X)) \\\n-    goto WIN; }\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */"}, {"sha": "3cd1f8580bcc2817b3225029d64cae9ddd8b12d5", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -29,8 +29,6 @@ extern int following_call (rtx);\n extern int function_label_operand (rtx, enum machine_mode);\n extern int lhs_lshift_cint_operand (rtx, enum machine_mode);\n \n-extern rtx hppa_legitimize_address (rtx, rtx, enum machine_mode);\n-\n /* Define functions in pa.c and used in insn-output.c.  */\n \n extern const char *output_and (rtx *);"}, {"sha": "80f5fe90bc23eeca87839998afa39f234854749d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -131,6 +131,7 @@ static bool pa_scalar_mode_supported_p (enum machine_mode);\n static bool pa_commutative_p (const_rtx x, int outer_code);\n static void copy_fp_args (rtx) ATTRIBUTE_UNUSED;\n static int length_fp_args (rtx) ATTRIBUTE_UNUSED;\n+static rtx hppa_legitimize_address (rtx, rtx, enum machine_mode);\n static inline void pa_file_start_level (void) ATTRIBUTE_UNUSED;\n static inline void pa_file_start_space (int) ATTRIBUTE_UNUSED;\n static inline void pa_file_start_file (int) ATTRIBUTE_UNUSED;\n@@ -228,6 +229,9 @@ static size_t n_deferred_plabels = 0;\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE pa_output_function_epilogue\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS hppa_legitimize_address\n+\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST pa_adjust_cost\n #undef TARGET_SCHED_ADJUST_PRIORITY"}, {"sha": "303bdd341df247529129450dd42dd5cefaf17ac0", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1421,26 +1421,6 @@ do { \t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n \n-\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n-{ rtx orig_x = (X);\t\t\t\t\\\n-  (X) = hppa_legitimize_address (X, OLDX, MODE);\t\\\n-  if ((X) != orig_x && memory_address_p (MODE, X)) \\\n-    goto WIN; }\n \f\n #define TARGET_ASM_SELECT_SECTION  pa_select_section\n "}, {"sha": "7c32ebeec428131c9b90a1b8a3b2e60fa58d8743", "filename": "gcc/config/picochip/picochip.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -504,10 +504,6 @@ extern const enum reg_class picochip_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n #endif /* !REG_OK_STRICT */\n \n-/* extern struct rtx_def *picochip_legitimize_address */\n-/* \tPARAMS ((struct rtx_def *, struct rtx_def *, int)); */\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN);\n-\n /* Legitimize reload address tries machine dependent means of\n    reloading addresses.  There seems to be a strange error in gcc,\n    which necessitates this macro.  Consider:"}, {"sha": "4b8f5220a51fdcbb277796f1f313eac903a0b5c2", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -107,7 +107,6 @@ extern rtx create_TOC_reference (rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);\n-extern rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,\n \t\t\t\t\t     int, int, int, int *);\n extern int rs6000_legitimate_address (enum machine_mode, rtx, int);"}, {"sha": "b6bc88b0a69b6e401e892aba21c6a1d3836f4c9c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -917,6 +917,7 @@ static rtx generate_set_vrsave (rtx, rs6000_stack_t *, int);\n int easy_vector_constant (rtx, enum machine_mode);\n static rtx rs6000_dwarf_register_span (rtx);\n static void rs6000_init_dwarf_reg_sizes_extra (tree);\n+static rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n static rtx rs6000_legitimize_tls_address (rtx, enum tls_model);\n static void rs6000_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static rtx rs6000_tls_get_addr (void);\n@@ -1103,6 +1104,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE rs6000_output_function_epilogue\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS rs6000_legitimize_address\n+\n #undef  TARGET_SCHED_VARIABLE_ISSUE\n #define TARGET_SCHED_VARIABLE_ISSUE rs6000_variable_issue\n \n@@ -3873,7 +3877,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t\t      || mode == DImode)))\n     {\n       if (mode == DImode)\n-\treturn NULL_RTX;\n+\treturn x;\n       /* We accept [reg + reg] and [reg + OFFSET].  */\n \n       if (GET_CODE (x) == PLUS)\n@@ -3945,7 +3949,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return create_TOC_reference (x);\n     }\n   else\n-    return NULL_RTX;\n+    return x;\n }\n \n /* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL."}, {"sha": "f11ea1fe2492ea188cb56a0ce798ba3a8dd47d4d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1812,38 +1812,6 @@ typedef struct rs6000_args\n     goto ADDR;\t\t\t\t\t\t\t\\\n }\n \f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   On RS/6000, first check for the sum of a register with a constant\n-   integer that is out of range.  If so, generate code to add the\n-   constant with the low-order 16 bits masked to the register and force\n-   this result into another register (this can be done with `cau').\n-   Then generate an address of REG+(CONST&0xffff), allowing for the\n-   possibility of bit 16 being a one.\n-\n-   Then check for the sum of a register and something not constant, try to\n-   load the other things into a register and return the sum.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{  rtx result = rs6000_legitimize_address (X, OLDX, MODE);\t\\\n-   if (result != NULL_RTX)\t\t\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\\\n-       (X) = result;\t\t\t\t\t\t\\\n-       goto WIN;\t\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\\\n-}\n-\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c."}, {"sha": "3bde1c14b48f4ef03dde68591e8427a0e2790289", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -74,7 +74,6 @@ extern int legitimate_constant_p (rtx);\n extern bool legitimate_reload_constant_p (rtx);\n extern bool legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx legitimize_pic_address (rtx, rtx);\n-extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx legitimize_reload_address (rtx, enum machine_mode, int, int);\n extern enum reg_class s390_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class s390_secondary_input_reload_class (enum reg_class,"}, {"sha": "e2ed4a0d407e092341e26cc6cb6bf8372c10181f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -3734,9 +3734,9 @@ emit_symbolic_move (rtx *operands)\n    When -fpic is used, special handling is needed for symbolic references.\n    See comments by legitimize_pic_address for details.  */\n \n-rtx\n-legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n+static rtx\n+s390_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx constant_term = const0_rtx;\n \n@@ -9909,6 +9909,9 @@ s390_reorg (void)\n #undef TARGET_DELEGITIMIZE_ADDRESS\n #define TARGET_DELEGITIMIZE_ADDRESS s390_delegitimize_address\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS s390_legitimize_address\n+\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY s390_return_in_memory\n "}, {"sha": "2b4d7ce72cac89f052b922398168b17c5090084b", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -764,16 +764,6 @@ used in insn definitions or inline assemblies.  */\n }\n #endif\n \n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.  */\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)                          \\\n-{                                                                       \\\n-  (X) = legitimize_address (X, OLDX, MODE);                             \\\n-  if (memory_address_p (MODE, X))                                       \\\n-    goto WIN;                                                           \\\n-}\n-\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c.  */"}, {"sha": "d6739b8cf4ca7ba2f9f40be7b0c98b24a7d74462", "filename": "gcc/config/score/score-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -72,7 +72,6 @@ extern enum reg_class score_preferred_reload_class (rtx x,\n extern HOST_WIDE_INT score_initial_elimination_offset (int from, int to);\n extern void score_print_operand (FILE *file, rtx op, int letter);\n extern void score_print_operand_address (FILE *file, rtx addr);\n-extern int score_legitimize_address (rtx *xloc);\n extern int score_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n                                     enum machine_mode mode,\n                                     tree type, bool named);"}, {"sha": "2ac3021bf5eec3bb90722082af1b90edad1c52a1", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -68,6 +68,9 @@\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION            score_handle_option\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS\tscore_legitimize_address\n+\n #undef  TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE         score_issue_rate\n \n@@ -540,16 +543,17 @@ score_address_p (enum machine_mode mode, rtx x, int strict)\n   gcc_unreachable ();\n }\n \n-/* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n+/* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n    be legitimized in a way that the generic machinery might not expect,\n-   put the new address in *XLOC and return true.  */\n-int\n-score_legitimize_address (rtx *xloc)\n+   return the new address, else return X.  */\n+static rtx\n+score_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (TARGET_SCORE5 || TARGET_SCORE5U || TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_legitimize_address (xloc);\n+    return score7_legitimize_address (x);\n   else if (TARGET_SCORE3)\n-    return score3_legitimize_address (xloc);\n+    return score3_legitimize_address (x);\n \n   gcc_unreachable ();\n }"}, {"sha": "d9fe8e656252d089fed678033181acfcdf3ec6d8", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -778,12 +778,6 @@ typedef struct score_args\n \n #define REG_OK_FOR_INDEX_P(X) 0\n \n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)   \\\n-  do {                                           \\\n-    if (score_legitimize_address (&(X)))         \\\n-      goto WIN;                                  \\\n-  } while (0)\n-\n #define LEGITIMATE_CONSTANT_P(X)        1\n \n /* Condition Code Status.  */"}, {"sha": "9e41452c03db31675f36cb20ede027bb5585a214", "filename": "gcc/config/score/score3.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -414,31 +414,28 @@ score3_split_symbol (rtx temp, rtx addr)\n   return gen_rtx_LO_SUM (Pmode, high, addr);\n }\n \n-/* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n+/* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n    be legitimized in a way that the generic machinery might not expect,\n-   put the new address in *XLOC and return true.  */\n-int\n-score3_legitimize_address (rtx *xloc)\n+   return the new address.  */\n+rtx\n+score3_legitimize_address (rtx x)\n {\n   enum score_symbol_type symbol_type;\n \n-  if (score3_symbolic_constant_p (*xloc, &symbol_type)\n+  if (score3_symbolic_constant_p (x, &symbol_type)\n       && symbol_type == SYMBOL_GENERAL)\n-    {\n-      *xloc = score3_split_symbol (0, *xloc);\n-      return 1;\n-    }\n+    return score3_split_symbol (0, x);\n \n-  if (GET_CODE (*xloc) == PLUS\n-      && GET_CODE (XEXP (*xloc, 1)) == CONST_INT)\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     {\n-      rtx reg = XEXP (*xloc, 0);\n+      rtx reg = XEXP (x, 0);\n       if (!score3_valid_base_register_p (reg, 0))\n         reg = copy_to_mode_reg (Pmode, reg);\n-      *xloc = score3_add_offset (reg, INTVAL (XEXP (*xloc, 1)));\n-      return 1;\n+      return score3_add_offset (reg, INTVAL (XEXP (x, 1)));\n     }\n-  return 0;\n+\n+  return x;\n }\n \n /* Fill INFO with information about a single argument.  CUM is the"}, {"sha": "c46a8e694d9870918f37ae0e365fd77270c20ea9", "filename": "gcc/config/score/score3.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore3.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -78,7 +78,7 @@ extern void score3_output_mi_thunk (FILE *file,\n                                     HOST_WIDE_INT delta,\n                                     HOST_WIDE_INT vcall_offset,\n                                     tree function);\n-extern int score3_legitimize_address (rtx *xloc);\n+extern rtx score3_legitimize_address (rtx x);\n extern void\n score3_function_prologue (FILE *file,\n                           HOST_WIDE_INT size ATTRIBUTE_UNUSED);"}, {"sha": "dc532764edd94f61604dc43fae7c875878c4d0ac", "filename": "gcc/config/score/score7.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -413,31 +413,28 @@ score7_split_symbol (rtx temp, rtx addr)\n   return gen_rtx_LO_SUM (Pmode, high, addr);\n }\n \n-/* This function is used to implement LEGITIMIZE_ADDRESS.  If *XLOC can\n+/* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n    be legitimized in a way that the generic machinery might not expect,\n-   put the new address in *XLOC and return true.  */\n-int\n-score7_legitimize_address (rtx *xloc)\n+   return the new address.  */\n+rtx\n+score7_legitimize_address (rtx x)\n {\n   enum score_symbol_type symbol_type;\n \n-  if (score7_symbolic_constant_p (*xloc, &symbol_type)\n+  if (score7_symbolic_constant_p (x, &symbol_type)\n       && symbol_type == SYMBOL_GENERAL)\n-    {\n-      *xloc = score7_split_symbol (0, *xloc);\n-      return 1;\n-    }\n+    return score7_split_symbol (0, x);\n \n-  if (GET_CODE (*xloc) == PLUS\n-      && GET_CODE (XEXP (*xloc, 1)) == CONST_INT)\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     {\n-      rtx reg = XEXP (*xloc, 0);\n+      rtx reg = XEXP (x, 0);\n       if (!score7_valid_base_register_p (reg, 0))\n         reg = copy_to_mode_reg (Pmode, reg);\n-      *xloc = score7_add_offset (reg, INTVAL (XEXP (*xloc, 1)));\n-      return 1;\n+      return score7_add_offset (reg, INTVAL (XEXP (x, 1)));\n     }\n-  return 0;\n+\n+  return x;\n }\n \n /* Fill INFO with information about a single argument.  CUM is the"}, {"sha": "e2033c744988bd3ad781f7e11e6d5345150218c5", "filename": "gcc/config/score/score7.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fscore%2Fscore7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -78,7 +78,7 @@ extern void score7_output_mi_thunk (FILE *file,\n                                     HOST_WIDE_INT delta,\n                                     HOST_WIDE_INT vcall_offset,\n                                     tree function);\n-extern int score7_legitimize_address (rtx *xloc);\n+extern rtx score7_legitimize_address (rtx x);\n extern void\n score7_function_prologue (FILE *file,\n                           HOST_WIDE_INT size ATTRIBUTE_UNUSED);"}, {"sha": "9834d62d13b1eb1937adc3f46579477fdc3ff4bc", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -245,6 +245,7 @@ static bool sh_rtx_costs (rtx, int, int, int *, bool);\n static int sh_address_cost (rtx, bool);\n static int sh_pr_n_sets (void);\n static rtx sh_allocate_initial_value (rtx);\n+static rtx sh_legitimize_address (rtx, rtx, enum machine_mode);\n static int shmedia_target_regs_stack_space (HARD_REG_SET *);\n static int shmedia_reserve_space_for_target_registers_p (int, HARD_REG_SET *);\n static int shmedia_target_regs_stack_adjust (HARD_REG_SET *);\n@@ -374,6 +375,9 @@ static int sh2a_function_vector_p (tree);\n #undef TARGET_SCHED_INIT\n #define TARGET_SCHED_INIT sh_md_init\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS sh_legitimize_address\n+\n #undef TARGET_CANNOT_MODIFY_JUMPS_P\n #define TARGET_CANNOT_MODIFY_JUMPS_P sh_cannot_modify_jumps_p\n #undef TARGET_BRANCH_TARGET_REGISTER_CLASS\n@@ -8868,6 +8872,60 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n   return orig;\n }\n \n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   Otherwise, return X.\n+\n+   For the SH, if X is almost suitable for indexing, but the offset is\n+   out of range, convert it into a normal form so that CSE has a chance\n+   of reducing the number of address registers used.  */\n+\n+static rtx\n+sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n+{\n+  if (flag_pic)\n+    x = legitimize_pic_address (oldx, mode, NULL_RTX);\n+\n+  if (GET_CODE (x) == PLUS\n+      && (GET_MODE_SIZE (mode) == 4\n+\t  || GET_MODE_SIZE (mode) == 8)\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && BASE_REGISTER_RTX_P (XEXP (x, 0))\n+      && ! TARGET_SHMEDIA\n+      && ! ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && mode == DFmode)\n+      && ! (TARGET_SH2E && mode == SFmode))\n+    {\n+      rtx index_rtx = XEXP (x, 1);\n+      HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\n+      rtx sum;\n+\n+      /* On rare occasions, we might get an unaligned pointer\n+\t that is indexed in a way to give an aligned address.\n+\t Therefore, keep the lower two bits in offset_base.  */\n+      /* Instead of offset_base 128..131 use 124..127, so that\n+\t simple add suffices.  */\n+      if (offset > 127)\n+\toffset_base = ((offset + 4) & ~60) - 4;\n+      else\n+\toffset_base = offset & ~60;\n+\n+      /* Sometimes the normal form does not suit DImode.  We\n+\t could avoid that by using smaller ranges, but that\n+\t would give less optimized code when SImode is\n+\t prevalent.  */\n+      if (GET_MODE_SIZE (mode) + offset - offset_base <= 64)\n+\t{\n+\t  sum = expand_binop (Pmode, add_optab, XEXP (x, 0),\n+\t\t\t      GEN_INT (offset_base), NULL_RTX, 0,\n+\t\t\t      OPTAB_LIB_WIDEN);\n+\n+\t  return gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base));\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n /* Mark the use of a constant in the literal table. If the constant\n    has multiple labels, make it unique.  */\n static rtx"}, {"sha": "71e202a87ddb969e78882a39a43a402e6b5e6537", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -2444,68 +2444,6 @@ struct sh_args {\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For the SH, if X is almost suitable for indexing, but the offset is\n-   out of range, convert it into a normal form so that cse has a chance\n-   of reducing the number of address registers used.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\t\t\\\n-    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\\\n-      && (GET_MODE_SIZE (MODE) == 4\t\t\t\t\\\n-\t  || GET_MODE_SIZE (MODE) == 8)\t\t\t\t\\\n-      && GET_CODE (XEXP ((X), 1)) == CONST_INT\t\t\t\\\n-      && BASE_REGISTER_RTX_P (XEXP ((X), 0))\t\t\t\\\n-      && ! TARGET_SHMEDIA\t\t\t\t\t\\\n-      && ! ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && (MODE) == DFmode)\t\t\t\\\n-      && ! (TARGET_SH2E && (MODE) == SFmode))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      rtx index_rtx = XEXP ((X), 1);\t\t\t\t\\\n-      HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\t\\\n-      rtx sum;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      GO_IF_LEGITIMATE_INDEX ((MODE), index_rtx, WIN);\t\t\\\n-      /* On rare occasions, we might get an unaligned pointer\t\\\n-\t that is indexed in a way to give an aligned address.\t\\\n-\t Therefore, keep the lower two bits in offset_base.  */ \\\n-      /* Instead of offset_base 128..131 use 124..127, so that\t\\\n-\t simple add suffices.  */\t\t\t\t\\\n-      if (offset > 127)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  offset_base = ((offset + 4) & ~60) - 4;\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\toffset_base = offset & ~60;\t\t\t\t\\\n-      /* Sometimes the normal form does not suit DImode.  We\t\\\n-\t could avoid that by using smaller ranges, but that\t\\\n-\t would give less optimized code when SImode is\t\t\\\n-\t prevalent.  */\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) + offset - offset_base <= 64)\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  sum = expand_binop (Pmode, add_optab, XEXP ((X), 0),\t\\\n-\t\t\t      GEN_INT (offset_base), NULL_RTX, 0, \\\n-\t\t\t      OPTAB_LIB_WIDEN);\t\t\t\\\n-                                                                \\\n-\t  (X) = gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base)); \\\n-\t  goto WIN;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n /* A C compound statement that attempts to replace X, which is an address\n    that needs reloading, with a valid memory address for an operand of\n    mode MODE.  WIN is a C statement label elsewhere in the code."}, {"sha": "40ac75e130c509e032ef641e52bc9019daff1ad2", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -72,7 +72,6 @@ extern bool legitimate_pic_operand_p (rtx);\n extern int legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern rtx legitimize_tls_address (rtx);\n-extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n extern void sparc_emit_call_insn (rtx, rtx);\n extern void sparc_defer_case_vector (rtx, rtx, int);\n extern bool sparc_expand_move (enum machine_mode, rtx *);"}, {"sha": "ab2b57bbcd9a513a090662c70bd2fdeb1c0fcc1b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -412,6 +412,7 @@ static bool sparc_strict_argument_naming (CUMULATIVE_ARGS *);\n static void sparc_va_start (tree, rtx);\n static tree sparc_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool sparc_vector_mode_supported_p (enum machine_mode);\n+static rtx sparc_legitimize_address (rtx, rtx, enum machine_mode);\n static bool sparc_pass_by_reference (CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, const_tree, bool);\n static int sparc_arg_partial_bytes (CUMULATIVE_ARGS *,\n@@ -492,6 +493,9 @@ static bool fpu_option_set = false;\n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS sparc_init_builtins\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS sparc_legitimize_address\n+\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN sparc_expand_builtin\n #undef TARGET_FOLD_BUILTIN\n@@ -3370,10 +3374,13 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n    OLDX is the address as it was before break_out_memory_refs was called.\n    In some cases it is useful to look at this to decide what needs to be done.\n \n-   MODE is the mode of the operand pointed to by X.  */\n+   MODE is the mode of the operand pointed to by X.\n+\n+   On SPARC, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n \n rtx\n-legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, enum machine_mode mode)\n+sparc_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t  enum machine_mode mode)\n {\n   rtx orig_x = x;\n "}, {"sha": "d21900135e2239c63bbbf2b1aaddcf5500b7b8f9", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -1923,27 +1923,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n }\n \f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-/* On SPARC, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n-{\t\t\t\t\t\t\\\n-  (X) = legitimize_address (X, OLDX, MODE);\t\\\n-  if (memory_address_p (MODE, X))\t\t\\\n-    goto WIN;\t\t\t\t\t\\\n-}\n-\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n    macro is used in only one place: `find_reloads_address' in reload.c."}, {"sha": "06e02ba0b483e2a5cf232c4a89e2313ee9a0b515", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -57,7 +57,6 @@ extern int spu_constant_address_p (rtx x);\n extern int spu_legitimate_constant_p (rtx x);\n extern int spu_legitimate_address (enum machine_mode mode, rtx x,\n \t\t\t\t   int reg_ok_strict);\n-extern rtx spu_legitimize_address (rtx x, rtx oldx, enum machine_mode mode);\n extern int spu_initial_elimination_offset (int from, int to);\n extern rtx spu_function_value (const_tree type, const_tree func);\n extern rtx spu_function_arg (int cum, enum machine_mode mode, tree type,"}, {"sha": "61113aa51da93c4f774cb7b5754ed61a292092ff", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -201,6 +201,7 @@ static void spu_init_libfuncs (void);\n static bool spu_return_in_memory (const_tree type, const_tree fntype);\n static void fix_range (const char *);\n static void spu_encode_section_info (tree, rtx, int);\n+static rtx spu_legitimize_address (rtx, rtx, enum machine_mode);\n static tree spu_builtin_mul_widen_even (tree);\n static tree spu_builtin_mul_widen_odd (tree);\n static tree spu_builtin_mask_for_load (void);\n@@ -280,6 +281,9 @@ spu_libgcc_shift_count_mode (void);\n #undef TARGET_UNWIND_WORD_MODE\n #define TARGET_UNWIND_WORD_MODE spu_unwind_word_mode\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS spu_legitimize_address\n+\n /* The .8byte directive doesn't seem to work well for a 32 bit\n    architecture. */\n #undef TARGET_ASM_UNALIGNED_DI_OP\n@@ -3683,7 +3687,7 @@ spu_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,\n    register.  */\n rtx\n spu_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\tenum machine_mode mode)\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx op0, op1;\n   /* Make sure both operands are registers.  */\n@@ -3706,10 +3710,8 @@ spu_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       else if (GET_CODE (op1) != REG)\n \top1 = force_reg (Pmode, op1);\n       x = gen_rtx_PLUS (Pmode, op0, op1);\n-      if (spu_legitimate_address (mode, x, 0))\n-\treturn x;\n     }\n-  return NULL_RTX;\n+  return x;\n }\n \n /* Handle an attribute requiring a FUNCTION_DECL; arguments as in"}, {"sha": "ed92715cd01eb36e62d8da52e725de02a36da4b5", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -427,15 +427,6 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n \tgoto ADDR;\t\t\t\t\t\t\\\n     }\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN) \\\n-  {  rtx result = spu_legitimize_address (X, OLDX, MODE);\t\\\n-     if (result != NULL_RTX)\t\t\t\t\t\\\n-       {\t\t\t\t\t\t\t\\\n-\t (X) = result;\t\t\t\t\t\t\\\n-\t goto WIN;\t\t\t\t\t\t\\\n-       }\t\t\t\t\t\t\t\\\n-  }\n-\n #define LEGITIMATE_CONSTANT_P(X) spu_legitimate_constant_p(X)\n \n \f"}, {"sha": "5f8cd74fe36b4e5c01f3b7008408fb4c326af70b", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -55,7 +55,6 @@ extern char *xtensa_emit_bit_branch (bool, bool, rtx *);\n extern char *xtensa_emit_movcc (bool, bool, bool, rtx *);\n extern char *xtensa_emit_call (int, rtx *);\n extern bool xtensa_legitimate_address_p (enum machine_mode, rtx, bool);\n-extern rtx xtensa_legitimize_address (rtx, rtx, enum machine_mode);\n extern bool xtensa_tls_referenced_p (rtx);\n \n #ifdef TREE_CODE"}, {"sha": "50467b4602cf38c3229d7ca2c2a6631692375298", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -132,6 +132,7 @@ static rtx gen_conditional_move (rtx);\n static rtx fixup_subreg_mem (rtx);\n static struct machine_function * xtensa_init_machine_status (void);\n static rtx xtensa_legitimize_tls_address (rtx);\n+static rtx xtensa_legitimize_address (rtx, rtx, enum machine_mode);\n static bool xtensa_return_in_msb (const_tree);\n static void printx (FILE *, signed int);\n static void xtensa_function_epilogue (FILE *, HOST_WIDE_INT);\n@@ -175,6 +176,9 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS (TARGET_DEFAULT | MASK_FUSED_MADD)\n \n+#undef TARGET_LEGITIMIZE_ADDRESS\n+#define TARGET_LEGITIMIZE_ADDRESS xtensa_legitimize_address\n+\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS xtensa_rtx_costs\n #undef TARGET_ADDRESS_COST\n@@ -1873,7 +1877,7 @@ xtensa_legitimize_address (rtx x,\n \t}\n     }\n \n-  return NULL_RTX;\n+  return x;\n }\n \n "}, {"sha": "73f68ef315f08ff13356128e2ee53c5458a327f5", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -810,17 +810,6 @@ typedef struct xtensa_args\n    && GET_CODE (X) != LABEL_REF\t\t\t\t\t\t\\\n    && GET_CODE (X) != CONST)\n \n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    rtx new_x = xtensa_legitimize_address (X, OLDX, MODE);\t\t\\\n-    if (new_x)\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tX = new_x;\t\t\t\t\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-\n /* Treat constant-pool references as \"mode dependent\" since they can\n    only be accessed with SImode loads.  This works around a bug in the\n    combiner where a constant pool reference is temporarily converted"}, {"sha": "8ed40d93b5474da93929e96b2ab8e6cb744dc5da", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -878,10 +878,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define SHIFT_COUNT_TRUNCATED 0\n #endif\n \n-#ifndef LEGITIMIZE_ADDRESS\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n-#endif\n-\n #ifndef LEGITIMATE_PIC_OPERAND_P\n #define LEGITIMATE_PIC_OPERAND_P(X) 1\n #endif"}, {"sha": "4c9b16279b5ebaab686d5f9878d557e36b61865d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -5443,32 +5443,26 @@ The typical use of this macro is to handle addresses containing\n a label_ref or symbol_ref within an UNSPEC@.\n @end defmac\n \n-@defmac LEGITIMIZE_ADDRESS (@var{x}, @var{oldx}, @var{mode}, @var{win})\n-A C compound statement that attempts to replace @var{x} with a valid\n-memory address for an operand of mode @var{mode}.  @var{win} will be a\n-C statement label elsewhere in the code; the macro definition may use\n-\n-@smallexample\n-GO_IF_LEGITIMATE_ADDRESS (@var{mode}, @var{x}, @var{win});\n-@end smallexample\n-\n-@noindent\n-to avoid further processing if the address has become legitimate.\n+@deftypefn {Target Hook} rtx TARGET_LEGITIMIZE_ADDRESS (rtx @var{x}, rtx @var{oldx}, enum machine_mode @var{mode})\n+This hook is given an invalid memory address @var{x} for an\n+operand of mode @var{mode} and should try to return a valid memory\n+address.\n \n @findex break_out_memory_refs\n @var{x} will always be the result of a call to @code{break_out_memory_refs},\n and @var{oldx} will be the operand that was given to that function to produce\n @var{x}.\n \n-The code generated by this macro should not alter the substructure of\n+The code of the hook should not alter the substructure of\n @var{x}.  If it transforms @var{x} into a more legitimate form, it\n-should assign @var{x} (which will always be a C variable) a new value.\n+should return the new @var{x}.\n \n-It is not necessary for this macro to come up with a legitimate\n-address.  The compiler has standard ways of doing so in all cases.  In\n-fact, it is safe to omit this macro.  But often a\n-machine-dependent strategy can generate better code.\n-@end defmac\n+It is not necessary for this hook to come up with a legitimate address.\n+The compiler has standard ways of doing so in all cases.  In fact, it\n+is safe to omit this hook or make it return @var{x} if it cannot find\n+a valid way to legitimize the address.  But often a machine-dependent\n+strategy can generate better code.\n+@end deftypefn\n \n @defmac LEGITIMIZE_RELOAD_ADDRESS (@var{x}, @var{mode}, @var{opnum}, @var{type}, @var{ind_levels}, @var{win})\n A C compound statement that attempts to replace @var{x}, which is an address"}, {"sha": "2e8f64885017f273721cddca4e7f1e8b4c6c5dec", "filename": "gcc/explow.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -446,7 +446,12 @@ memory_address (enum machine_mode mode, rtx x)\n \t in certain cases.  This is not necessary since the code\n \t below can handle all possible cases, but machine-dependent\n \t transformations can make better code.  */\n-      LEGITIMIZE_ADDRESS (x, oldx, mode, done);\n+      {\n+        rtx orig_x = x;\n+        x = targetm.legitimize_address (x, oldx, mode);\n+\tif (orig_x != x && memory_address_p (mode, x))\n+\t  goto done;\n+      }\n \n       /* PLUS and MULT can appear in special ways\n \t as the result of attempts to make an address usable for indexing."}, {"sha": "223a9dd01b44d5e9d6343c4bab5294be85d89710", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -681,7 +681,7 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tMUST_PASS_IN_STACK FUNCTION_ARG_PASS_BY_REFERENCE               \\\n         VECTOR_MODE_SUPPORTED_P TARGET_SUPPORTS_HIDDEN \t\t\t\\\n \tFUNCTION_ARG_PARTIAL_NREGS ASM_OUTPUT_DWARF_DTPREL\t\t\\\n-\tALLOCATE_INITIAL_VALUE\n+\tALLOCATE_INITIAL_VALUE LEGITIMIZE_ADDRESS\n \n /* Other obsolete target macros, or macros that used to be in target\n    headers and were not used, and may be obsolete or may never have"}, {"sha": "0039f9a438f60a7292404b9ac4d55d46a6a49bfd", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -486,6 +486,7 @@\n #define TARGET_CANNOT_FORCE_CONST_MEM hook_bool_rtx_false\n #define TARGET_CANNOT_COPY_INSN_P NULL\n #define TARGET_COMMUTATIVE_P hook_bool_const_rtx_commutative_p\n+#define TARGET_LEGITIMIZE_ADDRESS default_legitimize_address\n #define TARGET_DELEGITIMIZE_ADDRESS hook_rtx_rtx_identity\n #define TARGET_USE_BLOCKS_FOR_CONSTANT_P hook_bool_mode_const_rtx_false\n #define TARGET_MIN_ANCHOR_OFFSET 0\n@@ -869,6 +870,7 @@\n   TARGET_CANNOT_FORCE_CONST_MEM,\t\t\\\n   TARGET_CANNOT_COPY_INSN_P,\t\t\t\\\n   TARGET_COMMUTATIVE_P,\t\t\t\t\\\n+  TARGET_LEGITIMIZE_ADDRESS,\t\t\t\\\n   TARGET_DELEGITIMIZE_ADDRESS,\t\t\t\\\n   TARGET_USE_BLOCKS_FOR_CONSTANT_P,\t\t\\\n   TARGET_MIN_ANCHOR_OFFSET,\t\t\t\\"}, {"sha": "63fab54c42eb0fbbb8642113e8a74846d5c9410f", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -603,6 +603,10 @@ struct gcc_target\n   /* True if X is considered to be commutative.  */\n   bool (* commutative_p) (const_rtx, int);\n \n+  /* Given an invalid address X for a given machine mode, try machine-specific\n+     ways to make it legitimate.  Return X or an invalid address on failure.  */\n+  rtx (* legitimize_address) (rtx, rtx, enum machine_mode);\n+\n   /* Given an address RTX, undo the effects of LEGITIMIZE_ADDRESS.  */\n   rtx (* delegitimize_address) (rtx);\n "}, {"sha": "1dd6c7c6de8aaf4324a4da325381ddbc89e0e194", "filename": "gcc/targhooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -111,6 +111,13 @@ default_return_in_memory (const_tree type,\n   return (TYPE_MODE (type) == BLKmode);\n }\n \n+rtx\n+default_legitimize_address (rtx x, rtx orig_x ATTRIBUTE_UNUSED,\n+\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return x;\n+}\n+\n rtx\n default_expand_builtin_saveregs (void)\n {"}, {"sha": "19b78cbca336e4829d2a402d1338ebff359e6e13", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506d7b686cfb5b66f2945219d8863233d7dac645/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=506d7b686cfb5b66f2945219d8863233d7dac645", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n extern void default_external_libcall (rtx);\n+extern rtx default_legitimize_address (rtx, rtx, enum machine_mode);\n \n extern int default_unspec_may_trap_p (const_rtx, unsigned);\n "}]}