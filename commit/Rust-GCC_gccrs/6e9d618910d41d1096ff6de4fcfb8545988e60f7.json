{"sha": "6e9d618910d41d1096ff6de4fcfb8545988e60f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU5ZDYxODkxMGQ0MWQxMDk2ZmY2ZGU0ZmNmYjg1NDU5ODhlNjBmNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-09-09T12:11:22Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-09-09T12:11:22Z"}, "message": "lookup11.C: New test.\n\n\t* g++.old-deja/g++.other/lookup11.C: New test.\n\t* g++.old-deja/g++.bugs/900428_01.C: Rework now we understand\n\twhat is permitted and what we want.\n\t* g++.old-deja/g++.jason/rfg4.C: Rework to remove ill-formed\n\toverload use.\n\t* g++.old-deja/g++.jason/rfg5.C: Likewise\n\nFrom-SVN: r29234", "tree": {"sha": "8439a942994ee25c0a38c06155df4a4ae039a556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8439a942994ee25c0a38c06155df4a4ae039a556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e9d618910d41d1096ff6de4fcfb8545988e60f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9d618910d41d1096ff6de4fcfb8545988e60f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e9d618910d41d1096ff6de4fcfb8545988e60f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9d618910d41d1096ff6de4fcfb8545988e60f7/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02cac427d515af0b0855cda11124997fc76a13b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02cac427d515af0b0855cda11124997fc76a13b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02cac427d515af0b0855cda11124997fc76a13b9"}], "stats": {"total": 272, "additions": 244, "deletions": 28}, "files": [{"sha": "c8844e50b13cd8a97d5910971071dea7ce154758", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e9d618910d41d1096ff6de4fcfb8545988e60f7", "patch": "@@ -1,3 +1,12 @@\n+Thu Sep  9 12:32:57 BST 1999  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.old-deja/g++.other/lookup11.C: New test.\n+\t* g++.old-deja/g++.bugs/900428_01.C: Rework now we understand\n+\twhat is permitted and what we want.\n+\t* g++.old-deja/g++.jason/rfg4.C: Rework to remove ill-formed\n+\toverload use.\n+\t* g++.old-deja/g++.jason/rfg5.C: Likewise\n+\n Wed Sep  8 09:39:56 BST 1999  Nathan Sidwell  <nathan@acm.org>\n \n \t* g++.old-deja/g++.other/sizeof3.C: New test."}, {"sha": "ecbda0c5167ec5705fb1989db2985497073ab059", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900428_01.C", "status": "modified", "additions": 139, "deletions": 26, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900428_01.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900428_01.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900428_01.C?ref=6e9d618910d41d1096ff6de4fcfb8545988e60f7", "patch": "@@ -10,42 +10,155 @@\n // because the abstract semantics seem to require the evaluation of such\n // values whether they are volatile or not.\n \n+// [expr.static.cast/4, stmt.expr/1, expr.comma/1] show that expressions do\n+// not under go lvalue to rvalue decay, unless the value is actually used.\n+// This can be surprising when the object is volatile. We interpret a\n+// dereference of pointer to volatile to be a read.\n+\n // keywords: incomplete types, evaluation, volatile qualifier\n // Build don't link: \n \n-int i;\n+int *ip_fn ();\n+int &ir_fn ();\n+volatile int *vip_fn ();\n+volatile int &vir_fn ();\n+\n+void int_test (int i, int *p, volatile int *vp, int &r, volatile int &vr)\n+{\n+  int j;\n+  volatile int vj;\n+  \n+  *p;\t\t\t\t// ok, no warning\n+  (void)*p;\t\t\t// ok, no warning\n+  (void)(i ? j : *p);\t        // ok, no warning\n+  (void)(i ? *p : j);\t        // ok, no warning\n+  (void)((void)1, *p);\t        // ok, no warning\n+\n+  *vp;\t\t\t\t// ok, no warning\n+  (void)*vp;\t\t\t// ok, no warning\n+  (void)(i ? vj : *vp);\t        // ok, no warning\n+  (void)(i ? *vp : vj);\t        // ok, no warning\n+  (void)((void)1, *vp);         // ok, no warning\n+\n+  r;\t\t\t\t// ok, no warning\n+  (void)r;\t\t\t// ok, no warning\n+  (void)(i ? j : r);\t        // ok, no warning\n+  (void)(i ? r : j);\t        // ok, no warning\n+  (void)((void)1, r);\t        // ok, no warning\n+\n+  vr;\t\t\t\t// WARNING - reference not accessed\n+  (void)vr;\t\t\t// WARNING - reference not accessed\n+  (void)(i ? vj : vr);\t        // WARNING - reference not accessed\n+  (void)(i ? vr : vj);\t        // WARNING - reference not accessed\n+  (void)((void)1, vr);          // WARNING - reference not accessed\n+  \n+  *ip_fn ();\t\t\t// ok, no warning\n+  *vip_fn ();\t\t\t// ok, no warning\n+  ir_fn ();\t\t\t// ok, no warning\n+  vir_fn ();\t\t\t// WARNING - reference not accessed\n+}\n \n-void *pv;\n-volatile void *pvv;\n-struct s;               // ERROR - forward declaration\n-extern struct s es, *ps;  // ERROR - defined here\n-extern volatile struct s evs, *pvs; // ERROR - defined here\n+struct S;\n+S *sp_fn ();\n+S &sr_fn ();\n+volatile S *vsp_fn ();\n+volatile S &vsr_fn ();\n \n-void pv_test ()\n+void incomplete_test (int i, S *p, volatile S *vp, S &r, volatile S &vr)\n {\n-  *pv;\t\t\t// ERROR - invalid void\n-  (i ? *pv : *pv);\t// ERROR - invalid void\n-  *pv, *pv;\t\t// ERROR - invalid void\n+  extern S j;\n+  extern volatile S vj;\n+  \n+  *p;\t\t\t\t// ok, no warning\n+  (void)*p;\t\t\t// ok, no warning\n+  (void)(i ? j : *p);\t        // ok, no warning\n+  (void)(i ? *p : j);\t        // ok, no warning\n+  (void)((void)1, *p);\t        // ok, no warning\n \n-  *pvv;\t\t\t// ERROR - invalid void\n-  (i ? *pvv : *pvv);\t// ERROR - invalid void\n-  *pvv, *pvv;\t\t// ERROR - invalid void\n+  *vp;\t\t\t\t// WARNING - incomplete not accessed\n+  (void)*vp;\t\t\t// WARNING - incomplete not accessed\n+  (void)(i ? vj : *vp);\t        // WARNING - incomplete not accessed\n+  (void)(i ? *vp : vj);\t        // WARNING - incomplete not accessed\n+  (void)((void)1, *vp);         // WARNING - incomplete not accessed\n \n-  es;\t\t\t// ERROR - incomplete\n-  (i ? es : es);\t// ERROR - undefined type\n-  es, es;\t\t// ERROR - incomplete\n+  r;\t\t\t\t// ok, no warning\n+  (void)r;\t\t\t// ok, no warning\n+  (void)(i ? j : r);\t        // ok, no warning\n+  (void)(i ? r : j);\t        // ok, no warning\n+  (void)((void)1, r);\t        // ok, no warning\n \n-  evs;\t\t\t// ERROR - incomplete\n-  (i ? evs : evs);\t// ERROR - undefined type\n-  evs, evs;\t\t// ERROR - incomplete\n+  vr;\t\t\t\t// WARNING - reference not accessed\n+  (void)vr;\t\t\t// WARNING - reference not accessed\n+  (void)(i ? vj : vr);\t        // WARNING - reference not accessed\n+  (void)(i ? vr : vj);\t        // WARNING - reference not accessed\n+  (void)((void)1, vr);          // WARNING - reference not accessed\n+  \n+  *sp_fn ();\t\t\t// ok, no warning\n+  *vsp_fn ();\t\t\t// WARNING - incomplete not accessed\n+  sr_fn ();\t\t\t// ok, no warning\n+  vsr_fn ();\t\t\t// WARNING - reference not accessed\n+}\n+\n+struct T {int m;};\n+T *tp_fn ();\n+T &tr_fn ();\n+volatile T *vtp_fn ();\n+volatile T &vtr_fn ();\n+\n+void complete_test (int i, T *p, volatile T *vp, T &r, volatile T &vr)\n+{\n+  T j;\n+  volatile T vj;\n+  \n+  *p;\t\t\t\t// ok, no warning\n+  (void)*p;\t\t\t// ok, no warning\n+  (void)(i ? j : *p);\t        // ok, no warning\n+  (void)(i ? *p : j);\t        // ok, no warning\n+  (void)((void)1, *p);\t        // ok, no warning\n \n-  *ps;\t\t\t// ERROR - undefined type\n-  (i ? *ps : *ps);\t// ERROR - undefined type\n-  *ps, *ps;\t\t// ERROR - undefined type\n+  *vp;\t\t\t\t// ok, no warning\n+  (void)*vp;\t\t\t// ok, no warning\n+  (void)(i ? vj : *vp);\t        // ok, no warning\n+  (void)(i ? *vp : vj);\t        // ok, no warning\n+  (void)((void)1, *vp);         // ok, no warning\n \n-  *pvs;\t\t\t// ERROR - undefined type\n-  (i ? *pvs : *pvs);\t// ERROR - undefined type\n-  *pvs, *pvs;\t\t// ERROR - undefined type\n+  r;\t\t\t\t// ok, no warning\n+  (void)r;\t\t\t// ok, no warning\n+  (void)(i ? j : r);\t        // ok, no warning\n+  (void)(i ? r : j);\t        // ok, no warning\n+  (void)((void)1, r);\t        // ok, no warning\n+\n+  vr;\t\t\t\t// WARNING - reference not accessed\n+  (void)vr;\t\t\t// WARNING - reference not accessed\n+  (void)(i ? vj : vr);\t        // WARNING - reference not accessed\n+  (void)(i ? vr : vj);\t        // WARNING - reference not accessed\n+  (void)((void)1, vr);          // WARNING - reference not accessed\n+  \n+  *tp_fn ();\t\t\t// ok, no warning\n+  *vtp_fn ();\t\t\t// ok, no warning\n+  tr_fn ();\t\t\t// ok, no warning\n+  vtr_fn ();\t\t\t// ok, no warningWARNING - reference not accessed\n }\n \n-int main () { return 0; }\n+void extern_test ()\n+{\n+  extern S es;\n+  extern volatile S ves;\n+  extern T et;\n+  extern volatile T vet;\n+  \n+  extern S &esr;\n+  extern volatile S &vesr;\n+  extern T &etr;\n+  extern volatile T &vetr;\n+  \n+  es;\t\t\t\t// ok, no warning\n+  ves;\t\t\t\t// WARNING - incomplete not accessed\n+  et;\t\t\t\t// ok, no warning\n+  vet;\t\t\t\t// ok, no warning\n+  \n+  esr;\t\t\t\t// ok, no warning\n+  vesr;\t\t\t\t// WARNING - incomplete not accessed\n+  etr;\t\t\t\t// ok, no warning\n+  vetr;\t\t\t\t// WARNING - reference not accessed\n+}"}, {"sha": "1f5805531bbddbc492542a619b41d63d366f82f1", "filename": "gcc/testsuite/g++.old-deja/g++.jason/rfg4.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg4.C?ref=6e9d618910d41d1096ff6de4fcfb8545988e60f7", "patch": "@@ -8,5 +8,6 @@ void f2(double) { }\n void\n test ()\n {\n-    i ? f1 : f2;\t\t// gets bogus error - improper overloading\n+  void (*ptr) (double);\n+  ptr = i ? f1 : f2;\t\t// gets bogus error - improper overloading\n }"}, {"sha": "ca3539ba955db9e58c01d50c5105f41003ed174f", "filename": "gcc/testsuite/g++.old-deja/g++.jason/rfg5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg5.C?ref=6e9d618910d41d1096ff6de4fcfb8545988e60f7", "patch": "@@ -6,5 +6,5 @@ int *func () { return 0; }\n void\n test ()\n {\n-  *func;\t\t\t// gets bogus error - improper overloading\n+  int *(*p)() = *func;\t\t\t// gets bogus error - improper overloading\n }"}, {"sha": "fdd83ae220768ae32e416a1fdb79599023bb6e58", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload11.C", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e9d618910d41d1096ff6de4fcfb8545988e60f7/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload11.C?ref=6e9d618910d41d1096ff6de4fcfb8545988e60f7", "patch": "@@ -0,0 +1,93 @@\n+// Build don't link:\n+\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 5 Sep 1999 <nathan@acm.org>\n+\n+// [over.match] 13.3 tells us where overload resolution occurs.\n+// [over.match.call] 13.3.1.1 says that in\n+//  (...( postfix-expression )...) (expression-list)\n+// the postfix-expression must be the name of a function (amongst some other\n+// choices). This means comma and conditional exprs cannot be placed there.\n+// This clause is the only one I can find which bans\n+//  (cond ? fna : fnb) (arglist)\n+// which would be a major headache to have to implement.\n+// [over.over] 13.4 tells us when the use of a function name w/o arguments is\n+// resolved to the address of a particular function. These are determined by\n+// the context of the function name, and it does allow more complicated primary\n+// expressions.\n+\n+// Using a naked function name is rather strange, we used to warn about it\n+// (rather inconsistently), but subsequent changes broke the warning. Make\n+// sure that doesn't happen again.\n+\n+// excess errors test - XFAIL\n+\n+void ovl (int);          // ERROR - candidate\n+void ovl (float);        // ERROR - candidate\n+void fn (int);\n+void fna (int);\n+\n+int main (int argc, char **argv)\n+{\n+  void (*ptr) (int);\n+  void (*vptr) ();\n+  \n+  (ovl) (1);                // ok\n+  (&ovl) (1);               // ERROR - not suitable for overload resolution\n+  (ovl) ();                 // ERROR - no matching candidates\n+  (&ovl) ();                // ERROR - not suitable for overload resolution\n+  \n+  // 13.3.1.1 indicates that the following are errors -- the primary expression\n+  // is not the name of a function.\n+  (0, ovl) (1);             // ERROR - not suitable for overload resolution\n+  (0, &ovl) (1);            // ERROR - not suitable for overload resolution\n+  (argc ? ovl : ovl) (1);   // ERROR - not suitable for overload resolution\n+  (argc ? &ovl : &ovl) (1); // ERROR - not suitable for overload resolution\n+  \n+  (fn) (1);                 // ok\n+  (&fn) (1);                // ok (no overload resolution)\n+  (0, fn) (1);              // ok (no overload resolution)\n+  (0, &fn) (1);             // ok (no overload resolution)\n+  (argc ? fna : fn) (1);    // ok (no overload resolution)\n+  (argc ? &fna : &fn) (1);  // ok (no overload resolution)\n+  \n+  ptr = (ovl);              // ok\n+  ptr = (&ovl);             // ok\n+  // 13.4 indicates these are ok.\n+  ptr = (0, ovl);           // ok\n+  ptr = (0, &ovl);          // ok\n+  ptr = (argc ? ovl : ovl); // ok\n+  ptr = (argc ? &ovl : &ovl);// ok\n+  \n+  vptr = (ovl);              // ERROR - no matching candidates\n+  vptr = (&ovl);             // ERROR - no matching candidates\n+  vptr = (0, ovl);           // ERROR - no matching candidates\n+  vptr = (0, &ovl);          // ERROR - no matching candidates\n+  vptr = (argc ? ovl : ovl); // ERROR - no matching candidates\n+  vptr = (argc ? &ovl : &ovl);// ERROR - no matching candidates\n+  \n+  ptr = (fn);\n+  ptr = (&fn);\n+  ptr = (0, fn);\n+  ptr = (0, &fn);\n+  ptr = (argc ? fna : fn);\n+  ptr = (argc ? &fna : &fn);\n+  \n+  f;                // WARNING - not a call\n+  ovl;              // ERROR - not suitable for overload\n+  &ovl;             // ERROR - not suitable for overload\n+  (void)f;          // ok\n+  (void)ovl;        // ERROR - not suitable for overload\n+  (void)&ovl;       // ERROR - not suitable for overload\n+  static_cast<void>(f);          // ok\n+  static_cast<void>(ovl);        // ERROR - not suitable for overload\n+  static_cast<void>(&ovl);       // ERROR - not suitable for overload\n+  ((void)1, f);             // WARNING - not a call XFAIL\n+  ((void)1, ovl);           // ERROR - not suitable for overload\n+  ((void)1, &ovl);          // ERROR - not suitable for overload\n+  (void)((void)1, f);           // ok\n+  (void)((void)1, ovl);         // ERROR - not suitable for overload\n+  (void)((void)1, &ovl);        // ERROR - not suitable for overload\n+\n+  return 0;\n+}"}]}