{"sha": "3ee2243c06c6bb8cfb118709b61425ad26329bbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VlMjI0M2MwNmM2YmI4Y2ZiMTE4NzA5YjYxNDI1YWQyNjMyOWJiZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-04-19T23:33:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-04-19T23:33:21Z"}, "message": "opts.c (decode_options): Disable whpr incompatible passes.\n\n\n\t* opts.c (decode_options): Disable whpr incompatible passes.\n\t* lto/lto.c (lto_1_to_1_map): Skip clones.\n\t(read_cgraph_and_symbols): Do not mark everything as needed.\n\t(do_whole_program_analysis): Do map only after optimizing;\n\tset proper cgraph_state; use passmanager.\n\nFrom-SVN: r158533", "tree": {"sha": "1d6021fe1d646d929e1b51598497ba71d3a24003", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d6021fe1d646d929e1b51598497ba71d3a24003"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ee2243c06c6bb8cfb118709b61425ad26329bbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ee2243c06c6bb8cfb118709b61425ad26329bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ee2243c06c6bb8cfb118709b61425ad26329bbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ee2243c06c6bb8cfb118709b61425ad26329bbd/comments", "author": null, "committer": null, "parents": [{"sha": "576319a79ad554e2537b0d97a355f7896c8c3a35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576319a79ad554e2537b0d97a355f7896c8c3a35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/576319a79ad554e2537b0d97a355f7896c8c3a35"}], "stats": {"total": 49, "additions": 26, "deletions": 23}, "files": [{"sha": "bf3c1b115d7686bfd7c571ebbdf9b2aa98b1f9e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ee2243c06c6bb8cfb118709b61425ad26329bbd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ee2243c06c6bb8cfb118709b61425ad26329bbd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ee2243c06c6bb8cfb118709b61425ad26329bbd", "patch": "@@ -1,3 +1,11 @@\n+2010-04-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* opts.c (decode_options): Disable whpr incompatible passes.\n+\t* lto/lto.c (lto_1_to_1_map): Skip clones.\n+\t(read_cgraph_and_symbols): Do not mark everything as needed.\n+\t(do_whole_program_analysis): Do map only after optimizing;\n+\tset proper cgraph_state; use passmanager.\n+\n 2010-04-19  DJ Delorie  <dj@redhat.com>\n \n \t* cfgexpand.c (expand_debug_expr): Check for mismatched modes in"}, {"sha": "dc6ccb50af8048f6c15e50abeba95da3a14c51fe", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ee2243c06c6bb8cfb118709b61425ad26329bbd/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ee2243c06c6bb8cfb118709b61425ad26329bbd/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=3ee2243c06c6bb8cfb118709b61425ad26329bbd", "patch": "@@ -554,6 +554,10 @@ lto_1_to_1_map (void)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n+      /* We will get proper partition based on function they are inlined to or\n+\t cloned from.  */\n+      if (node->global.inlined_to || node->clone_of)\n+\tcontinue;\n       /* We only need to partition the nodes that we read from the\n \t gimple bytecode files.  */\n       file_data = node->local.lto_file_data;\n@@ -1881,19 +1885,9 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   /* Finally merge the cgraph according to the decl merging decisions.  */\n   lto_symtab_merge_cgraph_nodes ();\n \n-  /* Mark cgraph nodes needed in the merged cgraph\n-     This normally happens in whole-program pass, but for\n-     ltrans the pass was already run at WPA phase.\n-     \n-     FIXME:  This is not valid way to do so; nodes can be needed\n-     for non-obvious reasons.  We should stream the flags from WPA\n-     phase. */\n   if (flag_ltrans)\n     for (node = cgraph_nodes; node; node = node->next)\n       {\n-        if (!node->global.inlined_to\n-\t    && cgraph_decide_is_function_needed (node, node->decl))\n-          cgraph_mark_needed_node (node);\n \t/* FIXME: ipa_transforms_to_apply holds list of passes that have optimization\n \t   summaries computed and needs to apply changes.  At the moment WHOPR only\n \t   supports inlining, so we can push it here by hand.  In future we need to stream\n@@ -1986,9 +1980,6 @@ do_whole_program_analysis (void)\n {\n   char **output_files;\n   size_t i;\n-  struct cgraph_node *node; \n-\n-  lto_1_to_1_map ();\n \n   /* Note that since we are in WPA mode, materialize_cgraph will not\n      actually read in all the function bodies.  It only materializes\n@@ -1998,27 +1989,21 @@ do_whole_program_analysis (void)\n   /* Reading in the cgraph uses different timers, start timing WPA now.  */\n   timevar_push (TV_WHOPR_WPA);\n \n-  /* FIXME lto. Hack. We should use the IPA passes.  There are a\n-     number of issues with this now. 1. There is no convenient way to\n-     do this. 2. Some passes may depend on properties that requires\n-     the function bodies to compute.  */\n   cgraph_function_flags_ready = true;\n   bitmap_obstack_initialize (NULL);\n   ipa_register_cgraph_hooks ();\n+  cgraph_state = CGRAPH_STATE_IPA_SSA;\n \n-  /* Reset inlining information before running IPA inliner.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    reset_inline_failed (node);\n-\n-  /* FIXME lto.  We should not call this function directly. */\n-  pass_ipa_inline.pass.execute ();\n+  execute_ipa_pass_list (all_regular_ipa_passes);\n \n   verify_cgraph ();\n   bitmap_obstack_release (NULL);\n \n   /* We are about to launch the final LTRANS phase, stop the WPA timer.  */\n   timevar_pop (TV_WHOPR_WPA);\n \n+  lto_1_to_1_map ();\n+\n   output_files = lto_wpa_write_files ();\n \n   /* Show the LTO report before launching LTRANS.  */"}, {"sha": "0e86ab065d74dfe16c520c37fc370e96073ae71c", "filename": "gcc/opts.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ee2243c06c6bb8cfb118709b61425ad26329bbd/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ee2243c06c6bb8cfb118709b61425ad26329bbd/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=3ee2243c06c6bb8cfb118709b61425ad26329bbd", "patch": "@@ -1120,6 +1120,16 @@ decode_options (unsigned int argc, const char **argv)\n       if (!PARAM_SET_P (PARAM_STACK_FRAME_GROWTH))\n         PARAM_VALUE (PARAM_STACK_FRAME_GROWTH) = 40;\n     }\n+  if (flag_wpa || flag_ltrans)\n+    {\n+      /* These passes are not WHOPR compatible yet.  */\n+      flag_ipa_cp = 0;\n+      flag_ipa_reference = 0;\n+      flag_ipa_pure_const = 0;\n+      flag_ipa_type_escape = 0;\n+      flag_ipa_pta = 0;\n+      flag_ipa_struct_reorg = 0;\n+    }\n \n   if (flag_lto || flag_whopr)\n     {"}]}