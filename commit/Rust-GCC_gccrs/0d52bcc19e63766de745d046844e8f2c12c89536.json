{"sha": "0d52bcc19e63766de745d046844e8f2c12c89536", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ1MmJjYzE5ZTYzNzY2ZGU3NDVkMDQ2ODQ0ZThmMmMxMmM4OTUzNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-06-13T02:27:04Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-06-13T02:27:04Z"}, "message": "auto-inc-dec.c, [...]: Fix comment typos.\n\n\t* auto-inc-dec.c, c-incpath.c, config/c4x/libgcc.S,\n\tconfig/sh/divcost-analysis, dbgcnt.def, df-core.c,\n\tdf-problems.c, df-scan.c, df.h, dominance.c, dse.c, regstat.c,\n\ttree-data-ref.c, tree-ssa-loop-im.c, tree-ssa-loop-prefetch.c,\n\ttree-vect-transform.c: Fix comment typos.  Follow spelling\n\tconventions.\n\nFrom-SVN: r125666", "tree": {"sha": "53bc6532998c58f2c87be78479fff08b511afc9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53bc6532998c58f2c87be78479fff08b511afc9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d52bcc19e63766de745d046844e8f2c12c89536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d52bcc19e63766de745d046844e8f2c12c89536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d52bcc19e63766de745d046844e8f2c12c89536", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d52bcc19e63766de745d046844e8f2c12c89536/comments", "author": null, "committer": null, "parents": [{"sha": "ebca1de4384a5c5c563f0d3337999886b01f0f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebca1de4384a5c5c563f0d3337999886b01f0f7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebca1de4384a5c5c563f0d3337999886b01f0f7e"}], "stats": {"total": 87, "additions": 48, "deletions": 39}, "files": [{"sha": "d0fba3ff3bc365ce89d7bb9c1b6a37c196962d77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -1,4 +1,13 @@\n-2007-06-12 Seongbae Park <seongbae.park@gmail.com>\n+2007-06-13  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* auto-inc-dec.c, c-incpath.c, config/c4x/libgcc.S,\n+\tconfig/sh/divcost-analysis, dbgcnt.def, df-core.c,\n+\tdf-problems.c, df-scan.c, df.h, dominance.c, dse.c, regstat.c,\n+\ttree-data-ref.c, tree-ssa-loop-im.c, tree-ssa-loop-prefetch.c,\n+\ttree-vect-transform.c: Fix comment typos.  Follow spelling\n+\tconventions.\n+\n+2007-06-12  Seongbae Park  <seongbae.park@gmail.com>\n \n        * df-scan.c (df_get_exit-block_use_set): Always add the stack pointer\n        to the exit block use set."}, {"sha": "6718b742c2abb443bbc296a90d1fc4bf7e58d763", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -90,7 +90,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n        HAVE_PRE_INCREMENT, HAVE_POST_INCREMENT, HAVE_PRE_DECREMENT or\n        HAVE_POST_DECREMENT defined.\n \n-    2) c is a contant not equal to the width of the value being accessed\n+    2) c is a constant not equal to the width of the value being accessed\n        by the pointer.  This is useful for machines that have\n        HAVE_PRE_MODIFY_DISP, HAVE_POST_MODIFY_DISP defined.\n \n@@ -445,7 +445,7 @@ static rtx *reg_next_def = NULL;\n /* Move dead note that match PATTERN to TO_INSN from FROM_INSN.  We do\n    not really care about moving any other notes from the inc or add\n    insn.  Moving the REG_EQUAL and REG_EQUIV is clearly wrong and it\n-   does not appear that there are any other kinds of relavant notes.  */\n+   does not appear that there are any other kinds of relevant notes.  */\n \n static void \n move_dead_notes (rtx to_insn, rtx from_insn, rtx pattern)\n@@ -1195,7 +1195,7 @@ find_inc (bool first_try)\n \t\t    return false;\n \t\t}\n \n-\t      /* Need to check that there are no assignemnts to b\n+\t      /* Need to check that there are no assignments to b\n \t\t before the add insn.  */\n \t      other_insn \n \t\t= get_next_ref (REGNO (inc_insn.reg1), bb, reg_next_def);"}, {"sha": "355f8db22245d6e30e00296a1a0e8a34a3350054", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -391,7 +391,7 @@ add_path (char *path, int chain, int cxx_aware, bool user_supplied_p)\n #if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n   /* Remove unnecessary trailing slashes.  On some versions of MS\n      Windows, trailing  _forward_ slashes cause no problems for stat().\n-     On newer versions, stat() does not recognise a directory that ends\n+     On newer versions, stat() does not recognize a directory that ends\n      in a '\\\\' or '/', unless it is a drive root dir, such as \"c:/\",\n      where it is obligatory.  */\n   int pathlen = strlen (path);"}, {"sha": "8f801da6af76e3357f3e87793b8b7ab4b13d4523", "filename": "gcc/config/c4x/libgcc.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fconfig%2Fc4x%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fconfig%2Fc4x%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Flibgcc.S?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -327,7 +327,7 @@ div_32:\ttstb\tar1, ar1\n ; Now divisor and dividend are aligned.  Do first SUBC by hand, save\n ; of the forst quotient digit.  Then, shift divisor right rather\n ; than shifting dividend left.  This leaves a zero in the top bit of\n-; the divident\n+; the dividend\n ;\n \tldi\t1, ar0\t\t; Initizialize MSB of quotient\n \tlsh\trc, ar0\t\t; create a mask for MSBs"}, {"sha": "d93f04355f46ed873990f8c7c57c56d21d1c97c2", "filename": "gcc/config/sh/divcost-analysis", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fconfig%2Fsh%2Fdivcost-analysis", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fconfig%2Fsh%2Fdivcost-analysis", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fdivcost-analysis?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -39,7 +39,7 @@ div_le128_neg -> div_by_1_neg: 4\n div_le128_neg -> rts          18\n \n          sh4-200    absolute divisor range:\n-            1  [2..128]  [129..64K) [64K..|divident|/256] >=64K,>|divident/256|\n+            1  [2..128]  [129..64K) [64K..|dividend|/256] >=64K,>|dividend/256|\n udiv       18     22         38            32                   30\n sdiv pos:  20     24         41            35                   32\n sdiv neg:  15     25         42            36                   33"}, {"sha": "854f3d922c3ac63750bdb801f3a3e78a91dc3696", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -33,7 +33,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n    How does it work ?\n \n-   Everytime dbg_cnt(named-counter) is called,\n+   Every time dbg_cnt(named-counter) is called,\n    the counter is incremented for the named-counter.\n    And the incremented value is compared against the threshold (limit)\n    specified by the option."}, {"sha": "68f6c5076e192288bac8c29aa8ff6f016ea6b403", "filename": "gcc/df-core.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -64,7 +64,7 @@ dataflow solution.  The transfer functions are only rebuilt if the\n some instruction within the block has changed.  \n \n The top layer is the dataflow solution itself.  The dataflow solution\n-is computed by using an efficient iterative solver and the trasfer\n+is computed by using an efficient iterative solver and the transfer\n functions.  The dataflow solution must be recomputed whenever the\n control changes or if one of the transfer function changes.\n \n@@ -115,7 +115,7 @@ DF_ANALYZE causes all of the defined problems to be (re)solved.  When\n DF_ANALYZE is completes, the IN and OUT sets for each basic block\n contain the computer information.  The DF_*_BB_INFO macros can be used\n to access these bitvectors.  All deferred rescannings are down before\n-the transfer functions are recompited.\n+the transfer functions are recomputed.\n \n DF_DUMP can then be called to dump the information produce to some\n file.  This calls DF_DUMP_START, to print the information that is not\n@@ -177,7 +177,7 @@ There are four ways of doing the incremental scanning:\n       rescanned may be impractical.  Cse and regrename fall into this\n       category.\n \n-2) Defered rescanning - Calls to df_insn_rescan, df_notes_rescan, and\n+2) Deferred rescanning - Calls to df_insn_rescan, df_notes_rescan, and\n    df_insn_delete do not immediately change the insn but instead make\n    a note that the insn needs to be rescanned.  The next call to\n    df_analyze, df_finish_pass, or df_process_deferred_rescans will\n@@ -635,7 +635,7 @@ df_remove_problem (struct dataflow *dflow)\n \n \n /* Remove all of the problems that are not permanent.  Scanning, lr,\n-   ur and live are permanent, the rest are removeable.  Also clear all\n+   ur and live are permanent, the rest are removable.  Also clear all\n    of the changeable_flags.  */\n \n void\n@@ -1505,7 +1505,7 @@ df_bb_delete (int bb_index)\n    dataflow infomation is not being updated properly.  You can just\n    sprinkle calls in until you find the place that is changing an\n    underlying structure without calling the proper updating\n-   rountine.  */\n+   routine.  */\n \n void\n df_verify (void)"}, {"sha": "79b2f42fba7a3f4c7e5bcce33bd0d416c8a5f61d", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -4264,7 +4264,7 @@ df_simulate_fixup_sets (basic_block bb, bitmap live)\n }\n \n \n-/* Apply the artifical uses and defs at the top of BB in a forwards\n+/* Apply the artificial uses and defs at the top of BB in a forwards\n    direction.  */\n \n void \n@@ -4304,7 +4304,7 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n }\n \n \n-/* Apply the artifical uses and defs at the end of BB in a backwards\n+/* Apply the artificial uses and defs at the end of BB in a backwards\n    direction.  */\n \n void "}, {"sha": "010488efc0046e7ce6678d53bb15a0b970f98295", "filename": "gcc/df-scan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -1635,7 +1635,7 @@ df_reorganize_refs_by_insn_bb (basic_block bb, unsigned int offset,\n }\n \n \n-/* Organinze the refs by insn into the table in REF_INFO.  If\n+/* Organize the refs by insn into the table in REF_INFO.  If\n    blocks_to_analyze is defined, use that set, otherwise the entire\n    program.  Include the defs if INCLUDE_DEFS. Include the uses if\n    INCLUDE_USES. Include the eq_uses if INCLUDE_EQ_USES.  */\n@@ -3599,7 +3599,7 @@ df_get_entry_block_def_set (bitmap entry_block_defs)\n \n /* Return the (conservative) set of hard registers that are defined on\n    entry to the function.  \n-   It uses df->entry_block_defs to determine which regster \n+   It uses df->entry_block_defs to determine which register \n    reference to include.  */\n \n static void"}, {"sha": "9a3345c7ce0dcb8b9ad9c1ba06abed2f4ee74d7d", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -800,7 +800,7 @@ extern struct df *df;\n #define df_chain (df->problems_by_index[DF_CHAIN])\n #define df_note  (df->problems_by_index[DF_NOTE])\n \n-/* This symbol turns on checking that each modfication of the cfg has\n+/* This symbol turns on checking that each modification of the cfg has\n   been identified to the appropriate df routines.  It is not part of\n   verification per se because the check that the final solution has\n   not changed covers this.  However, if the solution is not being"}, {"sha": "ed64c4f74cfbd0a9fe8374aec4c6d5680f2fc841", "filename": "gcc/dominance.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -1242,9 +1242,9 @@ iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n \n      Then, we need to establish the dominance relation among the basic blocks\n      in BBS.  We split the dominance tree by removing the immediate dominator\n-     edges from BBS, creating a forrest F.  We form a graph G whose vertices\n+     edges from BBS, creating a forest F.  We form a graph G whose vertices\n      are BBS and ENTRY and X -> Y is an edge of G if there exists an edge\n-     X' -> Y in CFG such that X' belongs to the tree of the dominance forrest\n+     X' -> Y in CFG such that X' belongs to the tree of the dominance forest\n      whose root is X.  We then determine dominance tree of G.  Note that\n      for X, Y in BBS, X dominates Y in CFG if and only if X dominates Y in G.\n      In this step, we can use arbitrary algorithm to determine dominators."}, {"sha": "2c27d6e8e8b3a55f8be20b81e37356701484459d", "filename": "gcc/dse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -96,7 +96,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    possible for each address.  This pass is a forwards pass through\n    each basic block.  From the point of view of the global technique,\n    the first pass could examine a block in either direction.  The\n-   forwards ordering is to accomodate cselib.\n+   forwards ordering is to accommodate cselib.\n \n    We a simplifying assumption: addresses fall into four broad\n    categories:\n@@ -183,7 +183,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n      c) For any pass that may prespill, there is currently no\n      mechanism to tell the dse pass that the slot being used has the\n      special properties that reload uses.  It may be that all that is\n-     requirred is to have those passes make the same calls that reload\n+     required is to have those passes make the same calls that reload\n      does, assuming that the alias sets can be manipulated in the same\n      way.  */\n \n@@ -710,7 +710,7 @@ dse_step0 (void)\n    First step.\n \n    Scan all of the insns.  Any random ordering of the blocks is fine.\n-   Each block is scanned in forward order to accomodate cselib which\n+   Each block is scanned in forward order to accommodate cselib which\n    is used to remove stores with non-constant bases.\n ----------------------------------------------------------------------------*/\n \n@@ -780,7 +780,7 @@ replace_inc_dec (rtx *r, void *d)\n     case PRE_MODIFY:\n     case POST_MODIFY:\n       {\n-\t/* We can resuse the add because we are about to delete the\n+\t/* We can reuse the add because we are about to delete the\n \t   insn that contained it.  */\n \trtx add = XEXP (x, 0);\n \trtx r1 = XEXP (add, 0);\n@@ -1536,7 +1536,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n   read_info->next = insn_info->read_rec;\n   insn_info->read_rec = read_info;\n \n-  /* We ignore the clobbers in store_info.  The is mildly agressive,\n+  /* We ignore the clobbers in store_info.  The is mildly aggressive,\n      but there really should not be a clobber followed by a read.  */\n \n   if (spill_alias_set)\n@@ -1756,7 +1756,7 @@ scan_insn (bb_info_t bb_info, rtx insn)\n   bb_info->last_insn = insn_info;\n   \n \n-  /* Cselib clears the table for this case, so we have to essentually\n+  /* Cselib clears the table for this case, so we have to essentially\n      do the same.  */\n   if (NONJUMP_INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n@@ -1947,7 +1947,7 @@ dse_step1 (void)\n \t     algorithm must take a more conservative view of block\n \t     mode reads than the local alg does.  So to get the case\n \t     where you have a store to the frame followed by a non\n-\t     overlaping block more read, we look at the active local\n+\t     overlapping block more read, we look at the active local\n \t     stores at the end of the function and delete all of the\n \t     frame and spill based ones.  */\n \t  if (stores_off_frame_dead_at_return\n@@ -2762,7 +2762,7 @@ dse_step4 (void)\n /*----------------------------------------------------------------------------\n    Fifth step.\n \n-   Delete the stores that can only be deleted using the global informantion.\n+   Delete the stores that can only be deleted using the global information.\n ----------------------------------------------------------------------------*/\n \n "}, {"sha": "0a028ae12b066220d982c809193a213ddec2cedf", "filename": "gcc/regstat.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -406,7 +406,7 @@ regstat_get_setjmp_crosses (void)\n \n \n \n-/* Compute callse crossed for BB. Live is a scratch bitvector.  */\n+/* Compute calls crossed for BB. Live is a scratch bitvector.  */\n \n static void\n regstat_bb_compute_calls_crossed (unsigned int bb_index, bitmap live)"}, {"sha": "53c9c0054fb8d493b442953ee314df6810ab07d9", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -769,7 +769,7 @@ free_data_ref (data_reference_p dr)\n /* Analyzes memory reference MEMREF accessed in STMT.  The reference\n    is read if IS_READ is true, write otherwise.  Returns the\n    data_reference description of MEMREF.  NEST is the outermost loop of the\n-   loop nest in that the reference should be analysed.  */\n+   loop nest in that the reference should be analyzed.  */\n \n struct data_reference *\n create_data_ref (struct loop *nest, tree memref, tree stmt, bool is_read)\n@@ -1225,7 +1225,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n     }\n \n   /* If the base of the object is not invariant in the loop nest, we cannot\n-     analyse it.  TODO -- in fact, it would suffice to record that there may\n+     analyze it.  TODO -- in fact, it would suffice to record that there may\n      be arbitrary dependences in the loops where the base object varies.  */\n   if (!object_address_invariant_in_loop_p (VEC_index (loop_p, loop_nest, 0),\n \t\t\t\t\t   DR_BASE_OBJECT (a)))\n@@ -3942,7 +3942,7 @@ get_references_in_stmt (tree stmt, VEC (data_ref_loc, heap) **references)\n \n /* Stores the data references in STMT to DATAREFS.  If there is an unanalyzable\n    reference, returns false, otherwise returns true.  NEST is the outermost\n-   loop of the loop nest in that the references should be analysed.  */\n+   loop of the loop nest in that the references should be analyzed.  */\n \n static bool\n find_data_references_in_stmt (struct loop *nest, tree stmt,"}, {"sha": "0813474b9893fc4315dd411973357b9f13ae9c53", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -642,7 +642,7 @@ rewrite_bittest (block_stmt_iterator *bsi)\n   if (TREE_CODE (stmt1) != GIMPLE_MODIFY_STMT)\n     return stmt;\n \n-  /* There is a conversion inbetween possibly inserted by fold.  */\n+  /* There is a conversion in between possibly inserted by fold.  */\n   t = GIMPLE_STMT_OPERAND (stmt1, 1);\n   if (TREE_CODE (t) == NOP_EXPR\n       || TREE_CODE (t) == CONVERT_EXPR)"}, {"sha": "a4c2d0897953059963f13d0acd7c874316be5c92", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -1334,7 +1334,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n     }\n \n   /* Prepare the references in the form suitable for data dependence\n-     analysis.  We ignore unanalysable data references (the results\n+     analysis.  We ignore unanalyzable data references (the results\n      are used just as a heuristics to estimate temporality of the\n      references, hence we do not need to worry about correctness).  */\n   for (gr = refs; gr; gr = gr->next)\n@@ -1376,7 +1376,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n       if (DDR_ARE_DEPENDENT (dep) == chrec_dont_know\n \t  || DDR_NUM_DIST_VECTS (dep) == 0)\n \t{\n-\t  /* If the dependence cannot be analysed, assume that there might be\n+\t  /* If the dependence cannot be analyzed, assume that there might be\n \t     a reuse.  */\n \t  dist = 0;\n       \n@@ -1385,7 +1385,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n \t}\n       else\n \t{\n-\t  /* The distance vectors are normalised to be always lexicographically\n+\t  /* The distance vectors are normalized to be always lexicographically\n \t     positive, hence we cannot tell just from them whether DDR_A comes\n \t     before DDR_B or vice versa.  However, it is not important,\n \t     anyway -- if DDR_A is close to DDR_B, then it is either reused in"}, {"sha": "477fc883b7d0285fcbe5b3fe002ad40ba3ce30ec", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d52bcc19e63766de745d046844e8f2c12c89536/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=0d52bcc19e63766de745d046844e8f2c12c89536", "patch": "@@ -188,7 +188,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n                  \"prologue peel iters set conservatively.\");\n \n       /* If peeling for alignment is unknown, loop bound of main loop becomes\n-         unkown.  */\n+         unknown.  */\n       peel_iters_epilogue = vf - 1;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"cost model: \"\n@@ -270,7 +270,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n \n /* TODO: Close dependency between vect_model_*_cost and vectorizable_* \n-   functions. Design better to avoid maintainence issues.  */\n+   functions. Design better to avoid maintenance issues.  */\n     \n /* Function vect_model_reduction_cost.  \n \n@@ -526,7 +526,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies)\n         /* Unaligned software pipeline has a load of an address, an initial\n            load, and possibly a mask operation to \"prime\" the loop. However,\n            if this is an access in a group of loads, which provide strided\n-           acccess, then the above cost should only be considered for one\n+           access, then the above cost should only be considered for one\n            access in the group. Inside the loop, there is a load op\n            and a realignment op.  */\n "}]}