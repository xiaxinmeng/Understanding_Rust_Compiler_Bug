{"sha": "6119e7d5ec67f6133abc2090697b7e3bf7e65ffc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjExOWU3ZDVlYzY3ZjYxMzNhYmMyMDkwNjk3YjdlM2JmN2U2NWZmYw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-11-25T05:27:36Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T05:27:36Z"}, "message": "graphite-interchange.c (lst_perfectly_nested_p): New.\n\n2009-10-30  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-interchange.c (lst_perfectly_nested_p): New.\n\t(lst_perfect_nestify): New.\n\t(lst_try_interchange_loops): Call store_lst_schedule,\n\tlst_perfectly_nested_p, lst_perfect_nestify and restore_lst_schedule.\n\t(scop_do_interchange): Avoid redundant legality test.\n\tCall lst_do_interchange on a copy of SCOP_TRANSFORMED_SCHEDULE.\n\t* graphite-poly.c (apply_poly_transforms): Call lst_update_scattering.\n\t* graphite-poly.h (psct_static_dim): New.\n\t(lst_dewey_number_at_depth): New.\n\t(lst_find_pbb): Restructured.\n\t(lst_find_first_pbb): Restructured.\n\t(lst_find_last_pbb): New.\n\t(lst_contains_p): New.\n\t(lst_contains_pbb): New.\n\t(lst_create_nest): New.\n\t(lst_remove_from_sequence): New.\n\t(pbb_update_scattering): New.\n\t(lst_update_scattering_under): New.\n\t(lst_update_scattering_seq): New.\n\t(lst_update_scattering): New.\n\t(lst_insert_in_sequence): New.\n\t(lst_distribute_lst): New.\n\t(lst_remove_all_before_including_pbb): New.\n\t(lst_remove_all_before_excluding_pbb): New.\n\nFrom-SVN: r154631", "tree": {"sha": "ac9086cdba6ee22f27459ed64e2bb41b9e180415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac9086cdba6ee22f27459ed64e2bb41b9e180415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "431f3f22406a693e088f60678a9afb6d1e35a90a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431f3f22406a693e088f60678a9afb6d1e35a90a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/431f3f22406a693e088f60678a9afb6d1e35a90a"}], "stats": {"total": 450, "additions": 419, "deletions": 31}, "files": [{"sha": "2662b613d3b58d5cf77cc4f839bb27093b846b5f", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=6119e7d5ec67f6133abc2090697b7e3bf7e65ffc", "patch": "@@ -1,3 +1,30 @@\n+2009-10-30  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-interchange.c (lst_perfectly_nested_p): New.\n+\t(lst_perfect_nestify): New.\n+\t(lst_try_interchange_loops): Call store_lst_schedule,\n+\tlst_perfectly_nested_p, lst_perfect_nestify and restore_lst_schedule.\n+\t(scop_do_interchange): Avoid redundant legality test.\n+\tCall lst_do_interchange on a copy of SCOP_TRANSFORMED_SCHEDULE.\n+\t* graphite-poly.c (apply_poly_transforms): Call lst_update_scattering.\n+\t* graphite-poly.h (psct_static_dim): New.\n+\t(lst_dewey_number_at_depth): New.\n+\t(lst_find_pbb): Restructured.\n+\t(lst_find_first_pbb): Restructured.\n+\t(lst_find_last_pbb): New.\n+\t(lst_contains_p): New.\n+\t(lst_contains_pbb): New.\n+\t(lst_create_nest): New.\n+\t(lst_remove_from_sequence): New.\n+\t(pbb_update_scattering): New.\n+\t(lst_update_scattering_under): New.\n+\t(lst_update_scattering_seq): New.\n+\t(lst_update_scattering): New.\n+\t(lst_insert_in_sequence): New.\n+\t(lst_distribute_lst): New.\n+\t(lst_remove_all_before_including_pbb): New.\n+\t(lst_remove_all_before_excluding_pbb): New.\n+\n 2009-10-30  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-ssa-loop-niter.c (finite_loop_p): Do not call twice"}, {"sha": "6bfa9ab63e4e224e0bc600d5d4d8d1ec927c1022", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=6119e7d5ec67f6133abc2090697b7e3bf7e65ffc", "patch": "@@ -475,6 +475,51 @@ lst_interchange_profitable_p (lst_p lst, int depth1, int depth2)\n     return pbb_interchange_profitable_p (depth1, depth2, LST_PBB (lst));\n }\n \n+/* Return true when the nest starting at LOOP1 and ending on LOOP2 is\n+   perfect: i.e. there are no sequence of statements.  */\n+\n+static bool\n+lst_perfectly_nested_p (lst_p loop1, lst_p loop2)\n+{\n+  if (loop1 == loop2)\n+    return true;\n+\n+  if (!LST_LOOP_P (loop1))\n+    return false;\n+\n+  return VEC_length (lst_p, LST_SEQ (loop1)) == 1\n+    && lst_perfectly_nested_p (VEC_index (lst_p, LST_SEQ (loop1), 0), loop2);\n+}\n+\n+/* Transform the loop nest between LOOP1 and LOOP2 into a perfect\n+   nest.  To continue the naming tradition, this function is called\n+   after perfect_nestify.  */\n+\n+static void\n+lst_perfect_nestify (lst_p loop1, lst_p loop2)\n+{\n+  lst_p before, after;\n+  poly_bb_p first, last;\n+\n+  gcc_assert (loop1 && loop2\n+\t      && loop1 != loop2\n+\t      && LST_LOOP_P (loop1) && LST_LOOP_P (loop2));\n+\n+  first = LST_PBB (lst_find_first_pbb (loop2));\n+  last = LST_PBB (lst_find_last_pbb (loop2));\n+\n+  before = copy_lst (loop1);\n+  after = copy_lst (loop1);\n+\n+  lst_remove_all_before_including_pbb (before, first, false);\n+  lst_remove_all_before_including_pbb (after, last, true);\n+\n+  lst_remove_all_before_excluding_pbb (loop1, first, true);\n+  lst_remove_all_before_excluding_pbb (loop1, last, false);\n+\n+  lst_insert_in_sequence (before, loop1, true);\n+  lst_insert_in_sequence (after, loop1, false);\n+}\n \n /* Try to interchange LOOP1 with LOOP2 for all the statements of the\n    body of LOOP2.  LOOP1 contains LOOP2.  Return true if it did the\n@@ -489,6 +534,12 @@ lst_try_interchange_loops (scop_p scop, lst_p loop1, lst_p loop2)\n   if (!lst_interchange_profitable_p (loop2, depth1, depth2))\n     return false;\n \n+  store_lst_schedule (scop);\n+\n+  if (!lst_perfectly_nested_p (loop1, loop2))\n+    lst_perfect_nestify (loop1, loop2);\n+\n+  gcc_assert (lst_perfectly_nested_p (loop1, loop2));\n   lst_apply_interchange (loop2, depth1, depth2);\n \n   if (graphite_legal_transform (scop))\n@@ -503,6 +554,7 @@ lst_try_interchange_loops (scop_p scop, lst_p loop1, lst_p loop2)\n \n   /* Undo the transform.  */\n   lst_apply_interchange (loop2, depth2, depth1);\n+  restore_lst_schedule (scop);\n   return false;\n }\n \n@@ -563,22 +615,11 @@ lst_do_interchange (scop_p scop, lst_p lst)\n bool\n scop_do_interchange (scop_p scop)\n {\n-  bool transform_done = false;\n-\n-  store_scattering (scop);\n+  lst_p lst = copy_lst (SCOP_TRANSFORMED_SCHEDULE (scop));\n+  bool res = lst_do_interchange (scop, lst);\n \n-  transform_done = lst_do_interchange (scop, SCOP_TRANSFORMED_SCHEDULE (scop));\n-\n-  if (!transform_done)\n-    return false;\n-\n-  if (!graphite_legal_transform (scop))\n-    {\n-      restore_scattering (scop);\n-      return false;\n-    }\n-\n-  return transform_done;\n+  free_lst (lst);\n+  return res;\n }\n \n "}, {"sha": "f628052d928c2c04d252be9c2cf20d0f08bfd0ef", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=6119e7d5ec67f6133abc2090697b7e3bf7e65ffc", "patch": "@@ -263,6 +263,7 @@ apply_poly_transforms (scop_p scop)\n \ttransform_done |= scop_do_interchange (scop);\n     }\n \n+  lst_update_scattering (SCOP_TRANSFORMED_SCHEDULE (scop));\n   return transform_done;\n }\n "}, {"sha": "6cd46ae04081619d091b4753ab70d5c465a6b6fe", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 335, "deletions": 16, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6119e7d5ec67f6133abc2090697b7e3bf7e65ffc/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=6119e7d5ec67f6133abc2090697b7e3bf7e65ffc", "patch": "@@ -575,8 +575,19 @@ psct_parameter_dim (poly_bb_p pbb, graphite_dim_t param)\n static inline ppl_dimension_type\n psct_dynamic_dim (poly_bb_p pbb, graphite_dim_t level)\n {\n-  graphite_dim_t result;\n-  result = 1 + 2 * level;\n+  graphite_dim_t result = 1 + 2 * level;\n+\n+  gcc_assert (result < pbb_nb_scattering_transform (pbb));\n+  return result;\n+}\n+\n+/* The scattering dimension of PBB corresponding to the static\n+   sequence of the loop level LEVEL.  */\n+\n+static inline ppl_dimension_type\n+psct_static_dim (poly_bb_p pbb, graphite_dim_t level)\n+{\n+  graphite_dim_t result = 2 * level;\n \n   gcc_assert (result < pbb_nb_scattering_transform (pbb));\n   return result;\n@@ -768,6 +779,19 @@ lst_dewey_number (lst_p lst)\n   return -1;\n }\n \n+/* Returns the Dewey number of LST at depth DEPTH.  */\n+\n+static inline int\n+lst_dewey_number_at_depth (lst_p lst, int depth)\n+{\n+  gcc_assert (lst && depth >= 0 && lst_depth (lst) <= depth);\n+\n+  if (lst_depth (lst) == depth)\n+    return lst_dewey_number (lst);\n+\n+  return lst_dewey_number_at_depth (LST_LOOP_FATHER (lst), depth);\n+}\n+\n /* Return the LST node corresponding to PBB.  */\n \n static inline lst_p\n@@ -779,15 +803,15 @@ lst_find_pbb (lst_p lst, poly_bb_p pbb)\n   if (!lst)\n     return NULL;\n \n-  if (LST_LOOP_P (lst))\n-    for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n-      {\n-\tlst_p res = lst_find_pbb (l, pbb);\n-\tif (res)\n-\t  return res;\n-      }\n-  else if (pbb == LST_PBB (lst))\n-    return lst;\n+  if (!LST_LOOP_P (lst))\n+    return (pbb == LST_PBB (lst)) ? lst : NULL;\n+\n+  for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+    {\n+      lst_p res = lst_find_pbb (l, pbb);\n+      if (res)\n+\treturn res;\n+    }\n \n   return NULL;\n }\n@@ -808,7 +832,7 @@ find_lst_loop (lst_p stmt, int loop_depth)\n   return loop;\n }\n \n-/* Return the LST node corresponding to PBB.  */\n+/* Return the first lst representing a PBB statement in LST.  */\n \n static inline lst_p\n lst_find_first_pbb (lst_p lst)\n@@ -819,15 +843,310 @@ lst_find_first_pbb (lst_p lst)\n   if (!lst)\n     return NULL;\n \n+  if (!LST_LOOP_P (lst))\n+    return lst;\n+\n+  for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+    {\n+      lst_p res = lst_find_first_pbb (l);\n+      if (res)\n+\treturn res;\n+    }\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Return the last lst representing a PBB statement in LST.  */\n+\n+static inline lst_p\n+lst_find_last_pbb (lst_p lst)\n+{\n+  int i;\n+  lst_p l, res = NULL;\n+\n+  if (!lst)\n+    return NULL;\n+\n+  if (!LST_LOOP_P (lst))\n+    return lst;\n+\n+  for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+    {\n+      lst_p last = lst_find_last_pbb (l);\n+\n+      if (last)\n+\tres = last;\n+    }\n+\n+  gcc_assert (res);\n+  return res;\n+}\n+\n+/* Returns true if LOOP contains LST, in other words, if LST is nested\n+   in LOOP.  */\n+\n+static inline bool\n+lst_contains_p (lst_p loop, lst_p lst)\n+{\n+  if (!loop || !lst || !LST_LOOP_P (loop))\n+    return false;\n+\n+  if (loop == lst)\n+    return true;\n+\n+  return lst_contains_p (loop, LST_LOOP_FATHER (lst));\n+}\n+\n+/* Returns true if LOOP contains PBB, in other words, if PBB is nested\n+   in LOOP.  */\n+\n+static inline bool\n+lst_contains_pbb (lst_p loop, poly_bb_p pbb)\n+{\n+  return lst_find_pbb (loop, pbb) ? true : false;\n+}\n+\n+/* Creates a loop nest of depth NB_LOOPS containing LST.  */\n+\n+static inline lst_p\n+lst_create_nest (int nb_loops, lst_p lst)\n+{\n+  lst_p res, loop;\n+  VEC (lst_p, heap) *seq;\n+\n+  if (nb_loops == 0)\n+    return lst;\n+\n+  seq = VEC_alloc (lst_p, heap, 1);\n+  loop = lst_create_nest (nb_loops - 1, lst);\n+  VEC_quick_push (lst_p, seq, loop);\n+  res = new_lst_loop (seq);\n+  LST_LOOP_FATHER (loop) = res;\n+\n+  return res;\n+}\n+\n+/* Removes LST from the sequence of statements of its loop father.  */\n+\n+static inline void\n+lst_remove_from_sequence (lst_p lst)\n+{\n+  lst_p father = LST_LOOP_FATHER (lst);\n+  int dewey = lst_dewey_number (lst);\n+\n+  gcc_assert (lst && father && dewey >= 0);\n+\n+  VEC_ordered_remove (lst_p, LST_SEQ (father), dewey);\n+  LST_LOOP_FATHER (lst) = NULL;\n+}\n+\n+/* Updates the scattering of PBB to be at the DEWEY number in the loop\n+   at depth LEVEL.  */\n+\n+static inline void\n+pbb_update_scattering (poly_bb_p pbb, graphite_dim_t level, int dewey)\n+{\n+  ppl_Polyhedron_t ph = PBB_TRANSFORMED_SCATTERING (pbb);\n+  ppl_dimension_type sched = psct_static_dim (pbb, level);\n+  ppl_dimension_type ds[1];\n+  ppl_Constraint_t new_cstr;\n+  ppl_Linear_Expression_t expr;\n+  ppl_dimension_type dim;\n+\n+  ppl_Polyhedron_space_dimension (ph, &dim);\n+  ds[0] = sched;\n+  ppl_Polyhedron_remove_space_dimensions (ph, ds, 1);\n+  ppl_insert_dimensions (ph, sched, 1);\n+\n+  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n+  ppl_set_coef (expr, sched, -1);\n+  ppl_set_inhomogeneous (expr, dewey);\n+  ppl_new_Constraint (&new_cstr, expr, PPL_CONSTRAINT_TYPE_EQUAL);\n+  ppl_delete_Linear_Expression (expr);\n+  ppl_Polyhedron_add_constraint (ph, new_cstr);\n+  ppl_delete_Constraint (new_cstr);\n+}\n+\n+/* Updates the scattering of all the PBBs under LST to be at the DEWEY\n+   number in the loop at depth LEVEL.  */\n+\n+static inline void\n+lst_update_scattering_under (lst_p lst, int level, int dewey)\n+{\n+  int i;\n+  lst_p l;\n+\n+  gcc_assert (lst && level >= 0 && dewey >= 0);\n+\n   if (LST_LOOP_P (lst))\n     for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+      lst_update_scattering_under (l, level, dewey);\n+  else\n+    pbb_update_scattering (LST_PBB (lst), level, dewey);\n+}\n+\n+/* Updates the scattering of all the PBBs under LST and in sequence\n+   with LST.  */\n+\n+static inline void\n+lst_update_scattering_seq (lst_p lst)\n+{\n+  int i;\n+  lst_p l;\n+  lst_p father = LST_LOOP_FATHER (lst);\n+  int dewey = lst_dewey_number (lst);\n+  int level = lst_depth (lst);\n+\n+  gcc_assert (lst && father && dewey >= 0 && level >= 0);\n+\n+  for (i = dewey; VEC_iterate (lst_p, LST_SEQ (father), i, l); i++)\n+    lst_update_scattering_under (l, level, i);\n+}\n+\n+/* Updates the all the scattering levels of all the PBBs under\n+   LST.  */\n+\n+static inline void\n+lst_update_scattering (lst_p lst)\n+{\n+  int i;\n+  lst_p l;\n+\n+  if (!lst || !LST_LOOP_P (lst))\n+    return;\n+\n+  if (LST_LOOP_FATHER (lst))\n+    lst_update_scattering_seq (lst);\n+\n+  for (i = 0; VEC_iterate (lst_p, LST_SEQ (lst), i, l); i++)\n+    lst_update_scattering (l);\n+}\n+\n+/* Inserts LST1 before LST2 if BEFORE is true; inserts LST1 after LST2\n+   if BEFORE is false.  */\n+\n+static inline void\n+lst_insert_in_sequence (lst_p lst1, lst_p lst2, bool before)\n+{\n+  lst_p father = LST_LOOP_FATHER (lst2);\n+  int dewey = lst_dewey_number (lst2);\n+\n+  gcc_assert (lst1 && lst2 && father && dewey >= 0);\n+\n+  VEC_safe_insert (lst_p, heap, LST_SEQ (father), before ? dewey : dewey + 1,\n+\t\t   lst1);\n+  LST_LOOP_FATHER (lst1) = father;\n+}\n+\n+/* Moves LST before LOOP if BEFORE is true, and after the LOOP if\n+   BEFORE is false.  */\n+\n+static inline void\n+lst_distribute_lst (lst_p loop, lst_p lst, bool before)\n+{\n+  int loop_depth = lst_depth (loop);\n+  int depth = lst_depth (lst);\n+  int nb_loops = depth - loop_depth;\n+\n+  gcc_assert (lst && loop && LST_LOOP_P (loop) && nb_loops > 0);\n+\n+  lst_remove_from_sequence (lst);\n+  lst_insert_in_sequence (lst_create_nest (nb_loops, lst), loop, before);\n+}\n+\n+/* Removes from LOOP all the statements before/after and including PBB\n+   if BEFORE is true/false.  Returns the negation of BEFORE when the\n+   statement PBB has been found.  */\n+\n+static inline bool\n+lst_remove_all_before_including_pbb (lst_p loop, poly_bb_p pbb, bool before)\n+{\n+  int i;\n+  lst_p l;\n+\n+  if (!loop || !LST_LOOP_P (loop))\n+    return before;\n+\n+  for (i = 0; VEC_iterate (lst_p, LST_SEQ (loop), i, l);)\n+    if (LST_LOOP_P (l))\n+      {\n+\tbefore = lst_remove_all_before_including_pbb (l, pbb, before);\n+\n+\tif (VEC_length (lst_p, LST_SEQ (l)) == 0)\n+\t  {\n+\t    VEC_ordered_remove (lst_p, LST_SEQ (loop), i);\n+\t    free_lst (l);\n+\t  }\n+\telse\n+\t  i++;\n+      }\n+    else\n       {\n-\tlst_p res = lst_find_first_pbb (l);\n-\tif (res)\n-\t  return res;\n+\tif (before)\n+\t  {\n+\t    if (LST_PBB (l) == pbb)\n+\t      before = false;\n+\n+\t    VEC_ordered_remove (lst_p, LST_SEQ (loop), i);\n+\t    free_lst (l);\n+\t  }\n+\telse if (LST_PBB (l) == pbb)\n+\t  {\n+\t    before = true;\n+\t    VEC_ordered_remove (lst_p, LST_SEQ (loop), i);\n+\t    free_lst (l);\n+\t  }\n+\telse\n+\t  i++;\n       }\n \n-  return lst;\n+  return before;\n+}\n+\n+/* Removes from LOOP all the statements before/after and excluding PBB\n+   if BEFORE is true/false; Returns the negation of BEFORE when the\n+   statement PBB has been found.  */\n+\n+static inline bool\n+lst_remove_all_before_excluding_pbb (lst_p loop, poly_bb_p pbb, bool before)\n+{\n+  int i;\n+  lst_p l;\n+\n+  if (!loop || !LST_LOOP_P (loop))\n+    return before;\n+\n+  for (i = 0; VEC_iterate (lst_p, LST_SEQ (loop), i, l);)\n+    if (LST_LOOP_P (l))\n+      {\n+\tbefore = lst_remove_all_before_excluding_pbb (l, pbb, before);\n+\n+\tif (VEC_length (lst_p, LST_SEQ (l)) == 0)\n+\t  {\n+\t    VEC_ordered_remove (lst_p, LST_SEQ (loop), i);\n+\t    free_lst (l);\n+\t    continue;\n+\t  }\n+\n+\ti++;\n+      }\n+    else\n+      {\n+\tif (before && LST_PBB (l) != pbb)\n+\t  {\n+\t    VEC_ordered_remove (lst_p, LST_SEQ (loop), i);\n+\t    free_lst (l);\n+\t    continue;\n+\t  }\n+\n+\ti++;\n+\n+\tif (LST_PBB (l) == pbb)\n+\t  before = before ? false : true;\n+      }\n+\n+  return before;\n }\n \n /* A SCOP is a Static Control Part of the program, simple enough to be"}]}