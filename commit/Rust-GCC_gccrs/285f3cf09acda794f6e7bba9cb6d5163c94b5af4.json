{"sha": "285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1ZjNjZjA5YWNkYTc5NGY2ZTdiYmE5Y2I2ZDUxNjNjOTRiNWFmNA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-12-15T14:57:29Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-12-15T14:57:29Z"}, "message": "caller-save.c (insert_one_insn): Returns struct insn_chain *.\n\n\t* caller-save.c (insert_one_insn): Returns struct insn_chain *.\n\tHandle live_throughout / dead_or_set instead of live_before /\n\tlive_after.\n\t(save_call_clobbered_regs): Get register livenessinformation from\n\tchain->live_throughout.\n\t(add_stored_regs): New function.\n\t(insert_restore, insert_save): Add restored / saved registers to\n\tdead_or_set.\n\t* global.c (reg_dies): New parameter chain.\n\t(reg_becomes_live): Third parameter is regs_set now.\n\tChanged all callers.\n\t(reg_dies): New parameter chain.  Changed all callers.\n\t(build_insn_chain): Set live_throughout instead of\n\tlive_before / live_after.\n\t* reload.h (struct insn_chain): Replace members live_before /\n\tlive_after with live_throughout / dead_or_set.\n\t* reload1.c (new_insn_chain): Handle live_throughout / dead_or_set\n\tinstead of live_before / live_after.\n\t(maybe_fix_stack_asms, find_reload_regs, finish_spills): Likewise.\n\t(order_regs_for_reload, find_reg, finish_spills): Likewise.\n\t(choose_reload_regs_init): Likewise.\n\t* stupid.c (current_chain, find_clobbered_regs): Delete.\n\t(stupid_life_analysis): Set chain->live_throughout chain->dead_or_set\n\tinstead of chain->live_before / chain->live_after.\n\t(mark_hard_ref): New function.\n\t(stupid_mark_refs): Call mark_hard_ref. Clear chain->live_throughout.\n\nFrom-SVN: r30957", "tree": {"sha": "004232333d701e94fd104742dbd3de8db91043a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/004232333d701e94fd104742dbd3de8db91043a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/comments", "author": null, "committer": null, "parents": [{"sha": "4940cd6041eaa51d8a9bb245d7be26ac0b68187d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4940cd6041eaa51d8a9bb245d7be26ac0b68187d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4940cd6041eaa51d8a9bb245d7be26ac0b68187d"}], "stats": {"total": 419, "additions": 253, "deletions": 166}, "files": [{"sha": "5bc25d70c7ea7e4b83365d320cad8bfccd026232", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "patch": "@@ -1,3 +1,32 @@\n+Wed Dec 15 14:55:24 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* caller-save.c (insert_one_insn): Returns struct insn_chain *.\n+\tHandle live_throughout / dead_or_set instead of live_before /\n+\tlive_after.\n+\t(save_call_clobbered_regs): Get register livenessinformation from\n+\tchain->live_throughout.\n+\t(add_stored_regs): New function.\n+\t(insert_restore, insert_save): Add restored / saved registers to\n+\tdead_or_set.\n+\t* global.c (reg_dies): New parameter chain.\n+\t(reg_becomes_live): Third parameter is regs_set now.\n+\tChanged all callers.\n+\t(reg_dies): New parameter chain.  Changed all callers.\n+\t(build_insn_chain): Set live_throughout instead of\n+\tlive_before / live_after.\n+\t* reload.h (struct insn_chain): Replace members live_before /\n+\tlive_after with live_throughout / dead_or_set.\n+\t* reload1.c (new_insn_chain): Handle live_throughout / dead_or_set\n+\tinstead of live_before / live_after.\n+\t(maybe_fix_stack_asms, find_reload_regs, finish_spills): Likewise.\n+\t(order_regs_for_reload, find_reg, finish_spills): Likewise.\n+\t(choose_reload_regs_init): Likewise.\n+\t* stupid.c (current_chain, find_clobbered_regs): Delete.\n+\t(stupid_life_analysis): Set chain->live_throughout chain->dead_or_set\n+\tinstead of chain->live_before / chain->live_after.\n+\t(mark_hard_ref): New function.\n+\t(stupid_mark_refs): Call mark_hard_ref. Clear chain->live_throughout.\n+\n 1999-12-15  David S. Miller  <davem@redhat.com>\n \n \t* rtlanal.c (reg_overlap_mentioned_p): Handle CONCAT."}, {"sha": "bbd783131d2bc4992c31bff79e1c418291ceac5e", "filename": "gcc/caller-save.c", "status": "modified", "additions": 113, "deletions": 83, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "patch": "@@ -90,8 +90,8 @@ static int insert_save\t\t\tPROTO((struct insn_chain *, int, int,\n \t\t\t\t\t       HARD_REG_SET *));\n static int insert_restore\t\tPROTO((struct insn_chain *, int, int,\n \t\t\t\t\t       int));\n-static void insert_one_insn\t\tPROTO((struct insn_chain *, int,\n-\t\t\t\t\t       enum insn_code, rtx));\n+static struct insn_chain *insert_one_insn PROTO((struct insn_chain *, int,\n+\t\t\t\t\t\t enum insn_code, rtx));\n \f\n /* Initialize for caller-save.\n \n@@ -373,17 +373,20 @@ save_call_clobbered_regs ()\n \n \t  if (code == CALL_INSN)\n \t    {\n-\t      rtx x;\n-\t      int regno, nregs;\n+\t      int regno;\n \t      HARD_REG_SET hard_regs_to_save;\n \n \t      /* Use the register life information in CHAIN to compute which\n-\t\t regs are live before the call.  */\n-\t      REG_SET_TO_HARD_REG_SET (hard_regs_to_save, chain->live_before);\n-\t      compute_use_by_pseudos (&hard_regs_to_save, chain->live_before);\n+\t\t regs are live during the call.  */\n+\t      REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n+\t\t\t\t       chain->live_throughout);\n+\t      compute_use_by_pseudos (&hard_regs_to_save,\n+\t\t\t\t      chain->live_throughout);\n \n \t      /* Record all registers set in this call insn.  These don't need\n-\t\t to be saved.  */\n+\t\t to be saved.  N.B. the call insn might set a subreg of a\n+\t\t multi-hard-reg pseudo; then the pseudo is considered live\n+\t\t during the call, but the subreg that is set isn't.  */\n \t      CLEAR_HARD_REG_SET (this_insn_sets);\n \t      note_stores (PATTERN (insn), mark_set_regs, NULL);\n \n@@ -393,45 +396,6 @@ save_call_clobbered_regs ()\n \t      AND_COMPL_HARD_REG_SET (hard_regs_to_save, hard_regs_saved);\n \t      AND_HARD_REG_SET (hard_regs_to_save, call_used_reg_set);\n \n-\t      /* Registers used for function parameters need not be saved.  */\n-\t      for (x = CALL_INSN_FUNCTION_USAGE (insn); x != 0;\n-\t\t   x = XEXP (x, 1))\n-\t\t{\n-\t\t  rtx y;\n-\n-\t\t  if (GET_CODE (XEXP (x, 0)) != USE)\n-\t\t    continue;\n-\t\t  y = XEXP (XEXP (x, 0), 0);\n-\t\t  if (GET_CODE (y) != REG)\n-\t\t    abort ();\n-\t\t  regno = REGNO (y);\n-\t\t  if (REGNO (y) >= FIRST_PSEUDO_REGISTER)\n-\t\t    abort ();\n-\t\t  nregs = HARD_REGNO_NREGS (regno, GET_MODE (y));\n-\t\t  while (nregs-- > 0)\n-\t\t    CLEAR_HARD_REG_BIT (hard_regs_to_save, regno + nregs);\n-\t\t}\n-\n-\t      /* Neither do registers for which we find a death note.  */\n-\t      for (x = REG_NOTES (insn); x != 0; x = XEXP (x, 1))\n-\t\t{\n-\t\t  rtx y = XEXP (x, 0);\n-\n-\t\t  if (REG_NOTE_KIND (x) != REG_DEAD)\n-\t\t    continue;\n-\t\t  if (GET_CODE (y) != REG)\n-\t\t    abort ();\n-\t\t  regno = REGNO (y);\n-\n-\t\t  if (regno >= FIRST_PSEUDO_REGISTER)\n-\t\t    regno = reg_renumber[regno];\n-\t\t  if (regno < 0)\n-\t\t    continue;\n-\t\t  nregs = HARD_REGNO_NREGS (regno, GET_MODE (y));\n-\t\t  while (nregs-- > 0)\n-\t\t    CLEAR_HARD_REG_BIT (hard_regs_to_save, regno + nregs);\t\t  \n-\t\t}\n-\t\t\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (TEST_HARD_REG_BIT (hard_regs_to_save, regno))\n \t\t  regno += insert_save (chain, 1, regno, &hard_regs_to_save);\n@@ -490,6 +454,39 @@ mark_set_regs (reg, setter, data)\n     SET_HARD_REG_BIT (this_insn_sets, i);\n }\n \n+/* Here from note_stores when an insn stores a value in a register.\n+   Set the proper bit or bits in the passed regset.  All pseudos that have\n+   been assigned hard regs have had their register number changed already,\n+   so we can ignore pseudos.  */\n+static void\n+add_stored_regs (reg, setter, data)\n+     rtx reg;\n+     rtx setter;\n+     void *data;\n+{\n+  register int regno, endregno, i;\n+  enum machine_mode mode = GET_MODE (reg);\n+  int word = 0;\n+\n+  if (GET_CODE (setter) == CLOBBER)\n+    return;\n+\n+  while (GET_CODE (reg) == SUBREG)\n+    {\n+      word += SUBREG_WORD (reg);\n+      reg = SUBREG_REG (reg);\n+    }\n+\n+  if (GET_CODE (reg) != REG || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  regno = REGNO (reg) + word;\n+  endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+\n+  for (i = regno; i < endregno; i++)\n+    SET_REGNO_REG_SET ((regset) data, i);\n+}\n+\n /* Walk X and record all referenced registers in REFERENCED_REGS.  */\n static void\n mark_referenced_regs (x)\n@@ -568,10 +565,11 @@ insert_restore (chain, before_p, regno, maxrestore)\n      int regno;\n      int maxrestore;\n {\n-  int i;\n+  int i, k;\n   rtx pat = NULL_RTX;\n   enum insn_code code = CODE_FOR_nothing;\n   int numregs = 0;\n+  struct insn_chain *new;\n \n   /* A common failure mode if register status is not correct in the RTL\n      is for this routine to be called with a REGNO we didn't expect to\n@@ -589,7 +587,7 @@ insert_restore (chain, before_p, regno, maxrestore)\n      backwards to the single register case.  */\n   for (i = maxrestore; i > 0; i--)\n     {\n-      int j, k;\n+      int j;\n       int ok = 1;\n \n       if (regno_save_mem[regno][i] == 0)\n@@ -605,24 +603,26 @@ insert_restore (chain, before_p, regno, maxrestore)\n       if (! ok)\n \tcontinue;\n \n-      pat = gen_rtx_SET (VOIDmode,\n-\t\t\t gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]), \n-\t\t\t\t      regno), \n-\t\t\t regno_save_mem[regno][i]);\n-      code = reg_restore_code[regno][i];\n-\n-      /* Clear status for all registers we restored.  */\n-      for (k = 0; k < i; k++)\n-\t{\n-\t  CLEAR_HARD_REG_BIT (hard_regs_saved, regno + k);\n-\t  n_regs_saved--;\n-\t}\n-\n       numregs = i;\n       break;\n     }\n \n-  insert_one_insn (chain, before_p, code, pat);\n+  pat = gen_rtx_SET (VOIDmode,\n+\t\t     gen_rtx_REG (GET_MODE (regno_save_mem[regno][numregs]), \n+\t\t\t\t  regno), \n+\t\t     regno_save_mem[regno][numregs]);\n+  code = reg_restore_code[regno][numregs];\n+  new = insert_one_insn (chain, before_p, code, pat);\n+\n+  /* Clear status for all registers we restored.  */\n+  for (k = 0; k < i; k++)\n+    {\n+      CLEAR_HARD_REG_BIT (hard_regs_saved, regno + k);\n+      SET_REGNO_REG_SET (new->dead_or_set, regno + k);\n+      n_regs_saved--;\n+    }\n+\n+\n \n   /* Tell our callers how many extra registers we saved/restored */\n   return numregs - 1;\n@@ -636,10 +636,11 @@ insert_save (chain, before_p, regno, to_save)\n      int regno;\n      HARD_REG_SET *to_save;\n {\n-  int i;\n+  int i, k;\n   rtx pat = NULL_RTX;\n   enum insn_code code = CODE_FOR_nothing;\n   int numregs = 0;\n+  struct insn_chain *new;\n \n   /* A common failure mode if register status is not correct in the RTL\n      is for this routine to be called with a REGNO we didn't expect to\n@@ -657,7 +658,7 @@ insert_save (chain, before_p, regno, to_save)\n      Work backwards to the single register case.  */\n   for (i = MOVE_MAX_WORDS; i > 0; i--)\n     {\n-      int j, k;\n+      int j;\n       int ok = 1;\n       if (regno_save_mem[regno][i] == 0)\n \tcontinue;\n@@ -672,30 +673,30 @@ insert_save (chain, before_p, regno, to_save)\n       if (! ok)\n \tcontinue;\n \n-      pat = gen_rtx_SET (VOIDmode, regno_save_mem[regno][i],\n-\t\t\t gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]),\n-\t\t\t\t      regno));\n-      code = reg_save_code[regno][i];\n-\n-      /* Set hard_regs_saved for all the registers we saved.  */\n-      for (k = 0; k < i; k++)\n-\t{\n-\t  SET_HARD_REG_BIT (hard_regs_saved, regno + k);\n-\t  n_regs_saved++;\n-\t}\n-\n       numregs = i;\n       break;\n     }\n \n-  insert_one_insn (chain, before_p, code, pat);\n+  pat = gen_rtx_SET (VOIDmode, regno_save_mem[regno][numregs],\n+\t\t     gen_rtx_REG (GET_MODE (regno_save_mem[regno][numregs]),\n+\t\t\t\t  regno));\n+  code = reg_save_code[regno][numregs];\n+  new = insert_one_insn (chain, before_p, code, pat);\n+\n+  /* Set hard_regs_saved and dead_or_set for all the registers we saved.  */\n+  for (k = 0; k < numregs; k++)\n+    {\n+      SET_HARD_REG_BIT (hard_regs_saved, regno + k);\n+      SET_REGNO_REG_SET (new->dead_or_set, regno + k);\n+      n_regs_saved++;\n+    }\n \n   /* Tell our callers how many extra registers we saved/restored */\n   return numregs - 1;\n }\n \n /* Emit a new caller-save insn and set the code.  */\n-static void\n+static struct insn_chain *\n insert_one_insn (chain, before_p, code, pat)\n      struct insn_chain *chain;\n      int before_p;\n@@ -721,6 +722,8 @@ insert_one_insn (chain, before_p, code, pat)\n   new = new_insn_chain ();\n   if (before_p)\n     {\n+      rtx link;\n+\n       new->prev = chain->prev;\n       if (new->prev != 0)\n \tnew->prev->next = new;\n@@ -732,8 +735,29 @@ insert_one_insn (chain, before_p, code, pat)\n       new->insn = emit_insn_before (pat, insn);\n       /* ??? It would be nice if we could exclude the already / still saved\n \t registers from the live sets.  */\n-      COPY_REG_SET (new->live_before, chain->live_before);\n-      COPY_REG_SET (new->live_after, chain->live_before);\n+      COPY_REG_SET (new->live_throughout, chain->live_throughout);\n+      /* Registers that die in CHAIN->INSN still live in the new insn.  */\n+      for (link = REG_NOTES (chain->insn); link; link = XEXP (link, 1))\n+\t{\n+\t  if (REG_NOTE_KIND (link) == REG_DEAD)\n+\t    {\n+\t      rtx reg = XEXP (link, 0);\n+\t      int regno, i;\n+\n+\t      if (GET_CODE (reg) != REG)\n+\t\tabort ();\n+\n+\t      regno = REGNO (reg);\n+\t      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t\tregno = reg_renumber[regno];\n+\t      if (regno < 0)\n+\t\tcontinue;\n+\t      for (i = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n+\t\t   i >= 0; i--)\n+\t\tSET_REGNO_REG_SET (new->live_throughout, regno + i);\n+\t    }\n+\t}\n+      CLEAR_REG_SET (new->dead_or_set);\n       if (chain->insn == BLOCK_HEAD (chain->block))\n \tBLOCK_HEAD (chain->block) = new->insn;\n     }\n@@ -747,13 +771,19 @@ insert_one_insn (chain, before_p, code, pat)\n       new->insn = emit_insn_after (pat, insn);\n       /* ??? It would be nice if we could exclude the already / still saved\n \t registers from the live sets, and observe REG_UNUSED notes.  */\n-      COPY_REG_SET (new->live_before, chain->live_after);\n-      COPY_REG_SET (new->live_after, chain->live_after);\n+      COPY_REG_SET (new->live_throughout, chain->live_throughout);\n+      /* Registers that are set in CHAIN->INSN live in the new insn.\n+         (Unless there is a REG_UNUSED note for them, but we don't\n+\t  look for them here.) */\n+      note_stores (PATTERN (chain->insn), add_stored_regs,\n+\t\t   new->live_throughout);\n+      CLEAR_REG_SET (new->dead_or_set);\n       if (chain->insn == BLOCK_END (chain->block))\n \tBLOCK_END (chain->block) = new->insn;\n     }\n   new->block = chain->block;\n   new->is_caller_save_insn = 1;\n \n   INSN_CODE (new->insn) = code;\n+  return new;\n }"}, {"sha": "04058290cc6022888bdc597abf56cb403620146e", "filename": "gcc/global.c", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "patch": "@@ -303,7 +303,8 @@ static void mark_reg_live_nc\tPROTO((int, enum machine_mode));\n static void set_preference\tPROTO((rtx, rtx));\n static void dump_conflicts\tPROTO((FILE *));\n static void reg_becomes_live\tPROTO((rtx, rtx, void *));\n-static void reg_dies\t\tPROTO((int, enum machine_mode));\n+static void reg_dies\t\tPROTO((int, enum machine_mode,\n+\t\t\t\t       struct insn_chain *));\n static void build_insn_chain\tPROTO((rtx));\n \f\n /* Perform allocation of pseudo-registers not allocated by local_alloc.\n@@ -1693,13 +1694,13 @@ mark_elimination (from, to)\n    current life information.  */\n static regset live_relevant_regs;\n \n-/* Record in live_relevant_regs that register REG became live.  This\n-   is called via note_stores.  */\n+/* Record in live_relevant_regs and REGS_SET that register REG became live.\n+   This is called via note_stores.  */\n static void\n-reg_becomes_live (reg, setter, data)\n+reg_becomes_live (reg, setter, regs_set)\n      rtx reg;\n      rtx setter ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *regs_set;\n {\n   int regno;\n \n@@ -1714,26 +1715,44 @@ reg_becomes_live (reg, setter, data)\n     {\n       int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (nregs-- > 0)\n-\tSET_REGNO_REG_SET (live_relevant_regs, regno++);\n+\t{\n+\t  SET_REGNO_REG_SET (live_relevant_regs, regno);\n+\t  if (! fixed_regs[regno])\n+\t    SET_REGNO_REG_SET ((regset) regs_set, regno);\n+\t  regno++;\n+\t}\n     }\n   else if (reg_renumber[regno] >= 0)\n-    SET_REGNO_REG_SET (live_relevant_regs, regno);\n+    {\n+      SET_REGNO_REG_SET (live_relevant_regs, regno);\n+      SET_REGNO_REG_SET ((regset) regs_set, regno);\n+    }\n }\n \n /* Record in live_relevant_regs that register REGNO died.  */\n static void\n-reg_dies (regno, mode)\n+reg_dies (regno, mode, chain)\n      int regno;\n      enum machine_mode mode;\n+     struct insn_chain *chain;\n {\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n       int nregs = HARD_REGNO_NREGS (regno, mode);\n       while (nregs-- > 0)\n-\tCLEAR_REGNO_REG_SET (live_relevant_regs, regno++);\n+\t{\n+\t  CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n+\t  if (! fixed_regs[regno])\n+\t    SET_REGNO_REG_SET (chain->dead_or_set, regno);\n+\t  regno++;\n+\t}\n     }\n   else\n-    CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n+    {\n+      CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n+      if (reg_renumber[regno] >= 0)\n+\tSET_REGNO_REG_SET (chain->dead_or_set, regno);\n+    }\n }\n \n /* Walk the insns of the current function and build reload_insn_chain,\n@@ -1778,8 +1797,6 @@ build_insn_chain (first)\n \t  c->insn = first;\n \t  c->block = b;\n \n-\t  COPY_REG_SET (c->live_before, live_relevant_regs);\n-\n \t  if (GET_RTX_CLASS (GET_CODE (first)) == 'i')\n \t    {\n \t      rtx link;\n@@ -1789,16 +1806,18 @@ build_insn_chain (first)\n \t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_DEAD\n \t\t    && GET_CODE (XEXP (link, 0)) == REG)\n-\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)));\n+\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)),\n+\t\t\t    c);\n+\n+\t      COPY_REG_SET (c->live_throughout, live_relevant_regs);\n \n \t      /* Mark everything born in this instruction as live.  */\n \n-\t      note_stores (PATTERN (first), reg_becomes_live, NULL);\n+\t      note_stores (PATTERN (first), reg_becomes_live,\n+\t\t\t   c->dead_or_set);\n \t    }\n-\n-\t  /* Remember which registers are live at the end of the insn, before\n-\t     killing those with REG_UNUSED notes.  */\n-\t  COPY_REG_SET (c->live_after, live_relevant_regs);\n+\t  else\n+\t    COPY_REG_SET (c->live_throughout, live_relevant_regs);\n \n \t  if (GET_RTX_CLASS (GET_CODE (first)) == 'i')\n \t    {\n@@ -1809,7 +1828,8 @@ build_insn_chain (first)\n \t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n \t\tif (REG_NOTE_KIND (link) == REG_UNUSED\n \t\t    && GET_CODE (XEXP (link, 0)) == REG)\n-\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)));\n+\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)),\n+\t\t\t    c);\n \t    }\n \t}\n "}, {"sha": "391c047c882c0c6fae4f180063583ba56b1a4a15", "filename": "gcc/reload.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "patch": "@@ -224,12 +224,9 @@ struct insn_chain\n   /* The rtx of the insn.  */\n   rtx insn;\n   /* Register life information: record all live hard registers, and all\n-     live pseudos that have a hard register.\n-     This information is recorded for the point immediately before the insn\n-     (in live_before), and for the point within the insn at which all\n-     outputs have just been written to (in live_after).  */\n-  regset live_before;\n-  regset live_after;\n+     live pseudos that have a hard register.  */\n+  regset live_throughout;\n+  regset dead_or_set;\n \n   /* Copies of the global variables computed by find_reloads.  */\n   struct reload *rld;"}, {"sha": "dc690852a11dc1c84f2d93138c28f3bef6ae99d3", "filename": "gcc/reload1.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "patch": "@@ -514,8 +514,8 @@ new_insn_chain ()\n     {\n       c = (struct insn_chain *)\n \tobstack_alloc (&reload_obstack, sizeof (struct insn_chain));\n-      c->live_before = OBSTACK_ALLOC_REG_SET (&reload_obstack);\n-      c->live_after = OBSTACK_ALLOC_REG_SET (&reload_obstack);\n+      c->live_throughout = OBSTACK_ALLOC_REG_SET (&reload_obstack);\n+      c->dead_or_set = OBSTACK_ALLOC_REG_SET (&reload_obstack);\n     }\n   else\n     {\n@@ -1295,8 +1295,8 @@ maybe_fix_stack_asms ()\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (allowed, i))\n \t  {\n-\t    CLEAR_REGNO_REG_SET (chain->live_before, i);\n-\t    CLEAR_REGNO_REG_SET (chain->live_after, i);\n+\t    CLEAR_REGNO_REG_SET (chain->live_throughout, i);\n+\t    CLEAR_REGNO_REG_SET (chain->dead_or_set, i);\n \t  }\n     }\n \n@@ -1516,21 +1516,21 @@ order_regs_for_reload (chain)\n       /* Test the various reasons why we can't use a register for\n \t spilling in this insn.  */\n       if (fixed_regs[i]\n-\t  || REGNO_REG_SET_P (chain->live_before, i)\n-\t  || REGNO_REG_SET_P (chain->live_after, i))\n+\t  || REGNO_REG_SET_P (chain->live_throughout, i)\n+\t  || REGNO_REG_SET_P (chain->dead_or_set, i))\n \tSET_HARD_REG_BIT (bad_spill_regs, i);\n     }\n   /* Now find out which pseudos are allocated to it, and update\n      hard_reg_n_uses.  */\n   CLEAR_REG_SET (&pseudos_counted);\n \n   EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_before, FIRST_PSEUDO_REGISTER, j,\n+    (chain->live_throughout, FIRST_PSEUDO_REGISTER, j,\n      {\n        count_pseudo (j);\n      });\n   EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_after, FIRST_PSEUDO_REGISTER, j,\n+    (chain->dead_or_set, FIRST_PSEUDO_REGISTER, j,\n      {\n        count_pseudo (j);\n      });\n@@ -1645,12 +1645,12 @@ find_reg (chain, order, dumpfile)\n   rl->regno = best_reg;\n \n   EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_before, FIRST_PSEUDO_REGISTER, j,\n+    (chain->live_throughout, FIRST_PSEUDO_REGISTER, j,\n      {\n        count_spilled_pseudo (best_reg, rl->nregs, j);\n      });\n   EXECUTE_IF_SET_IN_REG_SET\n-    (chain->live_after, FIRST_PSEUDO_REGISTER, j,\n+    (chain->dead_or_set, FIRST_PSEUDO_REGISTER, j,\n      {\n        count_spilled_pseudo (best_reg, rl->nregs, j);\n      });\n@@ -3489,13 +3489,13 @@ finish_spills (global, dumpfile)\n       for (chain = insns_need_reload; chain; chain = chain->next_need_reload)\n \t{\n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (chain->live_before, FIRST_PSEUDO_REGISTER, i,\n+\t    (chain->live_throughout, FIRST_PSEUDO_REGISTER, i,\n \t     {\n \t       ior_hard_reg_set (pseudo_forbidden_regs + i,\n \t\t\t\t &chain->used_spill_regs);\n \t     });\n \t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (chain->live_after, FIRST_PSEUDO_REGISTER, i,\n+\t    (chain->dead_or_set, FIRST_PSEUDO_REGISTER, i,\n \t     {\n \t       ior_hard_reg_set (pseudo_forbidden_regs + i,\n \t\t\t\t &chain->used_spill_regs);\n@@ -3528,22 +3528,22 @@ finish_spills (global, dumpfile)\n       HARD_REG_SET used_by_pseudos;\n       HARD_REG_SET used_by_pseudos2;\n \n-      AND_COMPL_REG_SET (chain->live_before, &spilled_pseudos);\n-      AND_COMPL_REG_SET (chain->live_after, &spilled_pseudos);\n+      AND_COMPL_REG_SET (chain->live_throughout, &spilled_pseudos);\n+      AND_COMPL_REG_SET (chain->dead_or_set, &spilled_pseudos);\n \n       /* Mark any unallocated hard regs as available for spills.  That\n \t makes inheritance work somewhat better.  */\n       if (chain->need_reload)\n \t{\n-\t  REG_SET_TO_HARD_REG_SET (used_by_pseudos, chain->live_before);\n-\t  REG_SET_TO_HARD_REG_SET (used_by_pseudos2, chain->live_after);\n+\t  REG_SET_TO_HARD_REG_SET (used_by_pseudos, chain->live_throughout);\n+\t  REG_SET_TO_HARD_REG_SET (used_by_pseudos2, chain->dead_or_set);\n \t  IOR_HARD_REG_SET (used_by_pseudos, used_by_pseudos2);\n \n \t  /* Save the old value for the sanity test below.  */\n \t  COPY_HARD_REG_SET (used_by_pseudos2, chain->used_spill_regs);\n \n-\t  compute_use_by_pseudos (&used_by_pseudos, chain->live_before);\n-\t  compute_use_by_pseudos (&used_by_pseudos, chain->live_after);\n+\t  compute_use_by_pseudos (&used_by_pseudos, chain->live_throughout);\n+\t  compute_use_by_pseudos (&used_by_pseudos, chain->dead_or_set);\n \t  COMPL_HARD_REG_SET (chain->used_spill_regs, used_by_pseudos);\n \t  AND_HARD_REG_SET (chain->used_spill_regs, used_spill_regs);\n \n@@ -5033,12 +5033,12 @@ choose_reload_regs_init (chain, save_reload_reg_rtx)\n   CLEAR_HARD_REG_SET (reg_used_in_insn);\n   {\n     HARD_REG_SET tmp;\n-    REG_SET_TO_HARD_REG_SET (tmp, chain->live_before);\n+    REG_SET_TO_HARD_REG_SET (tmp, chain->live_throughout);\n     IOR_HARD_REG_SET (reg_used_in_insn, tmp);\n-    REG_SET_TO_HARD_REG_SET (tmp, chain->live_after);\n+    REG_SET_TO_HARD_REG_SET (tmp, chain->dead_or_set);\n     IOR_HARD_REG_SET (reg_used_in_insn, tmp);\n-    compute_use_by_pseudos (&reg_used_in_insn, chain->live_before);\n-    compute_use_by_pseudos (&reg_used_in_insn, chain->live_after);\n+    compute_use_by_pseudos (&reg_used_in_insn, chain->live_throughout);\n+    compute_use_by_pseudos (&reg_used_in_insn, chain->dead_or_set);\n   }\n   for (i = 0; i < reload_n_operands; i++)\n     {"}, {"sha": "a4392e4ab0fe05c92ee730eb144da26be885057d", "filename": "gcc/stupid.c", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285f3cf09acda794f6e7bba9cb6d5163c94b5af4/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=285f3cf09acda794f6e7bba9cb6d5163c94b5af4", "patch": "@@ -129,12 +129,13 @@ static int stupid_find_reg\tPROTO((int, enum reg_class, enum machine_mode,\n \t\t\t\t       int, int, int));\n static void stupid_mark_refs\tPROTO((rtx, struct insn_chain *));\n static void find_clobbered_regs\tPROTO((rtx, rtx, void *));\n+static void mark_hard_ref\tPROTO((rtx, int, struct insn_chain *));\n \f\n /* For communication between stupid_life_analysis and find_clobbered_regs.  */\n static struct insn_chain *current_chain;\n \n /* This function, called via note_stores, marks any hard registers that are\n-   clobbered in an insn as being live in the live_after and live_before fields\n+   clobbered in an insn as being live in the live_throughout field\n    of the appropriate insn_chain structure.  */\n \n static void\n@@ -161,8 +162,7 @@ find_clobbered_regs (reg, setter, data)\n     nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n   while (nregs-- > 0)\n     {\n-      SET_REGNO_REG_SET (current_chain->live_after, regno);\n-      SET_REGNO_REG_SET (current_chain->live_before, regno++);\n+      SET_REGNO_REG_SET (current_chain->live_throughout, regno++);\n     }\n }\n \f\n@@ -285,7 +285,7 @@ stupid_life_analysis (f, nregs, file)\n \t  chain->insn = insn;\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    if (regs_live[i])\n-\t      SET_REGNO_REG_SET (chain->live_before, i);\n+\t      SET_REGNO_REG_SET (chain->live_throughout, i);\n \t}\n \n       /* Update which hard regs are currently live\n@@ -336,10 +336,6 @@ stupid_life_analysis (f, nregs, file)\n \n       if (GET_CODE (insn) != NOTE && GET_CODE (insn) != BARRIER)\n \t{\t  \n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (regs_live[i])\n-\t      SET_REGNO_REG_SET (chain->live_after, i);\n-\n \t  /* The regs_live array doesn't say anything about hard registers\n \t     clobbered by this insn.  So we need an extra pass over the\n \t     pattern.  */\n@@ -407,21 +403,14 @@ stupid_life_analysis (f, nregs, file)\n \tcontinue;\n \n       chain = reg_where_dead_chain[i];\n-      if (reg_where_dead[i] > INSN_SUID (chain->insn))\n-\tSET_REGNO_REG_SET (chain->live_after, i);\n+      SET_REGNO_REG_SET (chain->dead_or_set, i);\n \n-      while (INSN_SUID (chain->insn) > reg_where_born_exact[i])\n-\t{\n-\t  SET_REGNO_REG_SET (chain->live_before, i);\n-\t  chain = chain->prev;\n-\t  if (!chain)\n-\t    break;\n-\t  SET_REGNO_REG_SET (chain->live_after, i);\n-\t}\n+      while ((chain = chain->prev)\n+\t     && INSN_SUID (chain->insn) > reg_where_born_exact[i])\n+\tSET_REGNO_REG_SET (chain->live_throughout, i);\n \n-      if (INSN_SUID (chain->insn) == reg_where_born_exact[i]\n-\t  && reg_where_born_clobber[i])\n-\tSET_REGNO_REG_SET (chain->live_before, i);\n+      if (chain)\n+\tSET_REGNO_REG_SET (chain->dead_or_set, i);\n     }\n \n   if (file)\n@@ -568,6 +557,32 @@ stupid_find_reg (call_preserved, class, mode,\n   return -1;\n }\n \f\n+/* Note that REG is being set or referenced, and add the appropriate\n+   REG_DEAD / REG_UNUSED note(s).  For sets, LIVE_BEFORE_P will be 0,\n+   while for references, LIVE_BEFORE_P will be 1.\n+   INSN is the instruction that the reg notes have to be added to.  */\n+static void\n+mark_hard_ref (reg, live_before_p, chain)\n+     rtx reg;\n+     int live_before_p;\n+     struct insn_chain *chain;\n+{\n+  /* Hard reg: mark it live for continuing scan of previous insns.  */\n+  int regno = REGNO (reg);\n+  char *live = regs_live;\n+  register int j;\n+  int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\n+  for (j = nregs - 1; j >= 0; j--)\n+    {\n+      if (! fixed_regs[regno+j]\n+\t  && (! live_before_p || ! live[regno+j]))\n+\tSET_REGNO_REG_SET (chain->dead_or_set, regno+j);\n+      regs_ever_live[regno+j] = 1;\n+      live[regno+j] = live_before_p;\n+    }\n+}\n+\n /* Walk X, noting all assignments and references to registers\n    and recording what they imply about life spans.\n    INSN is the current insn, supplied so we can find its suid.  */\n@@ -597,27 +612,30 @@ stupid_mark_refs (x, chain)\n \t\t      >= FIRST_PSEUDO_REGISTER))))\n \t{\n \t  /* Register is being assigned.  */\n+\t  rtx reg = SET_DEST (x);\n+\n \t  /* If setting a SUBREG, we treat the entire reg as being set.  */\n \t  if (GET_CODE (SET_DEST (x)) == SUBREG)\n-\t    regno = REGNO (SUBREG_REG (SET_DEST (x)));\n-\t  else\n-\t    regno = REGNO (SET_DEST (x));\n+\t    reg = SUBREG_REG (reg);\n+\n+\t  regno = REGNO (reg);\n \n \t  /* For hard regs, update the where-live info.  */\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    {\n \t      register int j\n \t\t= HARD_REGNO_NREGS (regno, GET_MODE (SET_DEST (x)));\n \n+\t      mark_hard_ref (reg, 0, chain);\n+\n \t      while (--j >= 0)\n \t\t{\n-\t\t  regs_ever_live[regno+j] = 1;\n-\t\t  regs_live[regno+j] = 0;\n-\n \t\t  /* The following line is for unused outputs;\n \t\t     they do get stored even though never used again.  */\n \t\t  MARK_LIVE_AFTER (insn, regno+j);\n \n+\t\t  CLEAR_REGNO_REG_SET (chain->live_throughout, regno + j);\n+\n \t\t  /* When a hard reg is clobbered, mark it in use\n \t\t     just before this insn, so it is live all through.  */\n \t\t  if (code == CLOBBER && INSN_SUID (insn) > 0)\n@@ -706,15 +724,8 @@ stupid_mark_refs (x, chain)\n     {\n       regno = REGNO (x);\n       if (regno < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  /* Hard reg: mark it live for continuing scan of previous insns.  */\n-\t  register int j = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t  while (--j >= 0)\n-\t    {\n-\t      regs_ever_live[regno+j] = 1;\n-\t      regs_live[regno+j] = 1;\n-\t    }\n-\t}\n+\t/* Hard reg: mark it live for continuing scan of previous insns.  */\n+\tmark_hard_ref (x, 1, chain);\n       else\n \t{\n \t  /* Pseudo reg: record first use, last use and number of uses.  */"}]}