{"sha": "478167be6297adb9774abfea589b6b1d0a7f227e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4MTY3YmU2Mjk3YWRiOTc3NGFiZmVhNTg5YjZiMWQwYTdmMjI3ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-08T12:04:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-08T12:04:37Z"}, "message": "gen-pass-instances.awk: Rewritten.\n\n\t* gen-pass-instances.awk: Rewritten.\n\t* Makefile.in (pass-instances.def): Depend on $(PASSES_EXTRA), pass\n\t$(PASSES_EXTRA) after passes.def to the script.\n\t* config/i386/t-i386 (PASSES_EXTRA): Add i386-passes.def.\n\t* config/i386/i386-passes.def: New file.\n\t* config/i386/i386-protos.h (make_pass_insert_vzeroupper,\n\tmake_pass_stv): Declare.\n\t* config/i386/i386.c (pass_stv::pass_stv): Initialize timode_p to\n\tfalse.\n\t(pass_stv::gate): Depending on timode_p member require TARGET_64BIT\n\tor !TARGET_64BIT.\n\t(pass_stv::clone, pass_stv::set_pass_param): New methods.\n\t(pass_stv::timode_p): New non-static data member.\n\t(ix86_option_override): Don't register passes here.\n\nFrom-SVN: r240887", "tree": {"sha": "c64fb4d05bc6d2df0c0fe2e1a7a2146b140e04c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c64fb4d05bc6d2df0c0fe2e1a7a2146b140e04c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/478167be6297adb9774abfea589b6b1d0a7f227e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478167be6297adb9774abfea589b6b1d0a7f227e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478167be6297adb9774abfea589b6b1d0a7f227e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478167be6297adb9774abfea589b6b1d0a7f227e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ee19ef45ba9dc5a783303e353d538e83dabe3377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee19ef45ba9dc5a783303e353d538e83dabe3377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee19ef45ba9dc5a783303e353d538e83dabe3377"}], "stats": {"total": 300, "additions": 219, "deletions": 81}, "files": [{"sha": "1685c7f95aa06e05c0dcc735b82e605a31b35676", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=478167be6297adb9774abfea589b6b1d0a7f227e", "patch": "@@ -1,5 +1,20 @@\n 2016-10-08  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gen-pass-instances.awk: Rewritten.\n+\t* Makefile.in (pass-instances.def): Depend on $(PASSES_EXTRA), pass\n+\t$(PASSES_EXTRA) after passes.def to the script.\n+\t* config/i386/t-i386 (PASSES_EXTRA): Add i386-passes.def.\n+\t* config/i386/i386-passes.def: New file.\n+\t* config/i386/i386-protos.h (make_pass_insert_vzeroupper,\n+\tmake_pass_stv): Declare.\n+\t* config/i386/i386.c (pass_stv::pass_stv): Initialize timode_p to\n+\tfalse.\n+\t(pass_stv::gate): Depending on timode_p member require TARGET_64BIT\n+\tor !TARGET_64BIT.\n+\t(pass_stv::clone, pass_stv::set_pass_param): New methods.\n+\t(pass_stv::timode_p): New non-static data member.\n+\t(ix86_option_override): Don't register passes here.\n+\n \t* doc/invoke.texi: Document accepting Else, fallthrough.\n \n \t* doc/invoke.texi (-Wimplicit-fallthrough): Document FALLTHRU comment"}, {"sha": "705b574bb8e3805623cb59243aca964a083d0d48", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=478167be6297adb9774abfea589b6b1d0a7f227e", "patch": "@@ -2158,9 +2158,10 @@ s-bversion: BASE-VER\n \n CFLAGS-toplev.o += -DTARGET_NAME=\\\"$(target_noncanonical)\\\"\n \n-pass-instances.def: $(srcdir)/passes.def $(srcdir)/gen-pass-instances.awk\n+pass-instances.def: $(srcdir)/passes.def $(PASSES_EXTRA) \\\n+\t\t    $(srcdir)/gen-pass-instances.awk\n \t$(AWK) -f $(srcdir)/gen-pass-instances.awk \\\n-\t  $(srcdir)/passes.def > pass-instances.def\n+\t  $(srcdir)/passes.def $(PASSES_EXTRA) > pass-instances.def\n \n $(out_object_file): $(out_file)\n \t$(COMPILE) $<"}, {"sha": "8eeb0728e96af1710232d9d6aaf19ef7b22132cd", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=478167be6297adb9774abfea589b6b1d0a7f227e", "patch": "@@ -338,3 +338,9 @@ struct ix86_first_cycle_multipass_data_\n \n const addr_space_t ADDR_SPACE_SEG_FS = 1;\n const addr_space_t ADDR_SPACE_SEG_GS = 2;\n+\n+namespace gcc { class context; }\n+class rtl_opt_pass;\n+\n+extern rtl_opt_pass *make_pass_insert_vzeroupper (gcc::context *);\n+extern rtl_opt_pass *make_pass_stv (gcc::context *);"}, {"sha": "f6946112c6b34189fdbec012e00e4df6704b8a48", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=478167be6297adb9774abfea589b6b1d0a7f227e", "patch": "@@ -4105,20 +4105,35 @@ class pass_stv : public rtl_opt_pass\n {\n public:\n   pass_stv (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_stv, ctxt)\n+    : rtl_opt_pass (pass_data_stv, ctxt),\n+      timode_p (false)\n   {}\n \n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-      return TARGET_STV && TARGET_SSE2 && optimize > 1;\n+      return (timode_p == !!TARGET_64BIT\n+\t      && TARGET_STV && TARGET_SSE2 && optimize > 1);\n     }\n \n   virtual unsigned int execute (function *)\n     {\n       return convert_scalars_to_vector ();\n     }\n \n+  opt_pass *clone ()\n+    {\n+      return new pass_stv (m_ctxt);\n+    }\n+\n+  void set_pass_param (unsigned int n, bool param)\n+    {\n+      gcc_assert (n == 0);\n+      timode_p = param;\n+    }\n+\n+private:\n+  bool timode_p;\n }; // class pass_stv\n \n } // anon namespace\n@@ -6150,29 +6165,7 @@ ix86_option_override_internal (bool main_args_p,\n static void\n ix86_option_override (void)\n {\n-  opt_pass *pass_insert_vzeroupper = make_pass_insert_vzeroupper (g);\n-  struct register_pass_info insert_vzeroupper_info\n-    = { pass_insert_vzeroupper, \"reload\",\n-\t1, PASS_POS_INSERT_AFTER\n-      };\n-  opt_pass *pass_stv = make_pass_stv (g);\n-  struct register_pass_info stv_info_dimode\n-    = { pass_stv, \"combine\",\n-\t1, PASS_POS_INSERT_AFTER\n-      };\n-  /* Run the 64-bit STV pass before the CSE pass so that CONST0_RTX and\n-     CONSTM1_RTX generated by the STV pass can be CSEed.  */\n-  struct register_pass_info stv_info_timode\n-    = { pass_stv, \"cse2\",\n-\t1, PASS_POS_INSERT_BEFORE\n-      };\n-\n   ix86_option_override_internal (true, &global_options, &global_options_set);\n-\n-\n-  /* This needs to be done at start up.  It's convenient to do it here.  */\n-  register_pass (&insert_vzeroupper_info);\n-  register_pass (TARGET_64BIT ? &stv_info_timode : &stv_info_dimode);\n }\n \n /* Implement the TARGET_OFFLOAD_OPTIONS hook.  */"}, {"sha": "c435c1f053d06fd43b5729329090b7ef096548b1", "filename": "gcc/config/i386/t-i386", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2Fconfig%2Fi386%2Ft-i386", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2Fconfig%2Fi386%2Ft-i386", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-i386?ref=478167be6297adb9774abfea589b6b1d0a7f227e", "patch": "@@ -18,6 +18,7 @@\n \n OPTIONS_H_EXTRA += $(srcdir)/config/i386/stringop.def\n TM_H += $(srcdir)/config/i386/x86-tune.def\n+PASSES_EXTRA += $(srcdir)/config/i386/i386-passes.def\n \n i386-c.o: $(srcdir)/config/i386/i386-c.c\n \t  $(COMPILE) $<"}, {"sha": "6f7794eb402f55463b159d5a7aa090f799b189bd", "filename": "gcc/gen-pass-instances.awk", "status": "modified", "additions": 177, "deletions": 55, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2Fgen-pass-instances.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478167be6297adb9774abfea589b6b1d0a7f227e/gcc%2Fgen-pass-instances.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-pass-instances.awk?ref=478167be6297adb9774abfea589b6b1d0a7f227e", "patch": "@@ -17,6 +17,8 @@\n # This Awk script takes passes.def and writes pass-instances.def,\n # counting the instances of each kind of pass, adding an instance number\n # to everywhere that NEXT_PASS is used.\n+# Also handle INSERT_PASS_AFTER, INSERT_PASS_BEFORE and REPLACE_PASS\n+# directives.\n #\n # For example, the single-instanced pass:\n #     NEXT_PASS (pass_warn_unused_result);\n@@ -30,81 +32,201 @@\n # through:\n #   NEXT_PASS (pass_copy_prop, 8);\n # (currently there are 8 instances of that pass)\n+#\n+#     INSERT_PASS_AFTER (pass_copy_prop, 1, pass_stv);\n+# will insert\n+#     NEXT_PASS (pass_stv, 1);\n+# immediately after the NEXT_PASS (pass_copy_prop, 1) line,\n+# similarly INSERT_PASS_BEFORE inserts immediately before that line.\n+#     REPLACE_PASS (pass_copy_prop, 1, pass_stv, true);\n+# will replace NEXT_PASS (pass_copy_prop, 1) line with\n+#     NEXT_PASS (pass_stv, 1, true);\n+# line and renumber all higher pass_copy_prop instances if any.\n \n # Usage: awk -f gen-pass-instances.awk passes.def\n \n BEGIN {\n-\tprint \"/* This file is auto-generated by gen-pass-instances.awk\";\n-\tprint \"   from passes.def.  */\";\n+  print \"/* This file is auto-generated by gen-pass-instances.awk\";\n+  print \"   from passes.def.  */\";\n+  lineno = 1;\n }\n \n-function handle_line()\n+function parse_line(line, fnname,\tlen_of_call, len_of_start,\n+\t\t\t\t\tlen_of_open, len_of_close,\n+\t\t\t\t\tlen_of_args, args_start_at,\n+\t\t\t\t\targs_str, len_of_prefix,\n+\t\t\t\t\tcall_starts_at,\n+\t\t\t\t\tpostfix_starts_at)\n {\n-\tline = $0;\n-\n-\t# Find call expression.\n-\tcall_starts_at = match(line, /NEXT_PASS \\(.+\\)/);\n-\tif (call_starts_at == 0)\n-\t{\n-\t\tprint line;\n-\t\treturn;\n-\t}\n+  # Find call expression.\n+  call_starts_at = match(line, fnname \" \\\\(.+\\\\)\");\n+  if (call_starts_at == 0)\n+    return 0;\n+\n+  # Length of the call expression.\n+  len_of_call = RLENGTH;\n+\n+  len_of_start = length(fnname \" (\");\n+  len_of_open = length(\"(\");\n+  len_of_close = length(\")\");\n+\n+  # Find arguments\n+  len_of_args = len_of_call - (len_of_start + len_of_close);\n+  args_start_at = call_starts_at + len_of_start;\n+  args_str = substr(line, args_start_at, len_of_args);\n+  split(args_str, args, \",\");\n+\n+  # Find call expression prefix\n+  len_of_prefix = call_starts_at - 1;\n+  prefix = substr(line, 1, len_of_prefix);\n+\n+  # Find call expression postfix\n+  postfix_starts_at = call_starts_at + len_of_call;\n+  postfix = substr(line, postfix_starts_at);\n+  return 1;\n+}\n \n-\t# Length of the call expression.\n-\tlen_of_call = RLENGTH;\n+function adjust_linenos(above, increment,\tp, i)\n+{\n+  for (p in pass_lines)\n+    if (pass_lines[p] >= above)\n+      pass_lines[p] += pass_lines[p];\n+  if (increment > 0)\n+    for (i = lineno - 1; i >= above; i--)\n+      lines[i + increment] = lines[i];\n+  else\n+    for (i = above; i < lineno; i++)\n+      lines[i + increment] = lines[i];\n+  lineno += increment;\n+}\n \n-\tlen_of_start = length(\"NEXT_PASS (\");\n-\tlen_of_open = length(\"(\");\n-\tlen_of_close = length(\")\");\n+function insert_remove_pass(line, fnname)\n+{\n+  parse_line($0, fnname);\n+  pass_name = args[1];\n+  if (pass_name == \"PASS\")\n+    return 1;\n+  pass_num = args[2] + 0;\n+  new_line = prefix \"NEXT_PASS (\" args[3];\n+  if (args[4])\n+    new_line = new_line \", \" args[4];\n+  new_line = new_line \")\" postfix;\n+  if (!pass_lines[pass_name, pass_num])\n+    {\n+      print \"ERROR: Can't locate instance of the pass mentioned in \" fnname;\n+      return 1;\n+    }\n+  return 0;\n+}\n \n-\t# Find arguments\n-\tlen_of_args = len_of_call - (len_of_start + len_of_close);\n-\targs_start_at = call_starts_at + len_of_start;\n-\targs_str = substr(line, args_start_at, len_of_args);\n-\tsplit(args_str, args, \",\");\n+function insert_pass(line, fnname, after,\t\tnum)\n+{\n+  if (insert_remove_pass(line, fnname))\n+    return;\n+  num = pass_lines[pass_name, pass_num];\n+  adjust_linenos(num + after, 1);\n+  pass_name = args[3];\n+  # Set pass_counts\n+  if (args[3] in pass_counts)\n+    pass_counts[pass_name]++;\n+  else\n+    pass_counts[pass_name] = 1;\n+\n+  pass_lines[pass_name, pass_counts[pass_name]] = num + after;\n+  lines[num + after] = new_line;\n+}\n \n-\t# Set pass_name argument, an optional with_arg argument\n-\tpass_name = args[1];\n-\twith_arg = args[2];\n+function replace_pass(line, fnname,\t\t\tnum, i)\n+{\n+  if (insert_remove_pass(line, \"REPLACE_PASS\"))\n+    return;\n+  num = pass_lines[pass_name, pass_num];\n+  for (i = pass_counts[pass_name]; i > pass_num; i--)\n+    pass_lines[pass_name, i - 1] = pass_lines[pass_name, i];\n+  delete pass_lines[pass_name, pass_counts[pass_name]];\n+  if (pass_counts[pass_name] == 1)\n+    delete pass_counts[pass_name];\n+  else\n+    pass_counts[pass_name]--;\n+\n+  pass_name = args[3];\n+  # Set pass_counts\n+  if (args[3] in pass_counts)\n+    pass_counts[pass_name]++;\n+  else\n+    pass_counts[pass_name] = 1;\n+\n+  pass_lines[pass_name, pass_counts[pass_name]] = num;\n+  lines[num] = new_line;\n+}\n \n-\t# Find call expression prefix\n-\tlen_of_prefix = call_starts_at - 1;\n-\tprefix = substr(line, 1, len_of_prefix);\n+/INSERT_PASS_AFTER \\(.+\\)/ {\n+  insert_pass($0, \"INSERT_PASS_AFTER\", 1);\n+  next;\n+}\n \n-\t# Find call expression postfix\n-\tpostfix_starts_at = call_starts_at + len_of_call;\n-\tpostfix = substr(line, postfix_starts_at);\n+/INSERT_PASS_BEFORE \\(.+\\)/ {\n+  insert_pass($0, \"INSERT_PASS_BEFORE\", 0);\n+  next;\n+}\n \n-\t# Set pass_counts\n-\tif (pass_name in pass_counts)\n-\t\tpass_counts[pass_name]++;\n-\telse\n-\t\tpass_counts[pass_name] = 1;\n+/REPLACE_PASS \\(.+\\)/ {\n+  replace_pass($0, \"REPLACE_PASS\");\n+  next;\n+}\n \n-\tpass_num = pass_counts[pass_name];\n+{\n+  ret = parse_line($0, \"NEXT_PASS\");\n+  if (ret)\n+    {\n+      pass_name = args[1];\n+\n+      # Set pass_counts\n+      if (pass_name in pass_counts)\n+\tpass_counts[pass_name]++;\n+      else\n+\tpass_counts[pass_name] = 1;\n+\n+      pass_lines[pass_name, pass_counts[pass_name]] = lineno;\n+    }\n+  lines[lineno++] = $0;\n+}\n \n-\t# Print call expression with extra pass_num argument\n-\tprintf \"%s\", prefix;\n-\tif (with_arg)\n+END {\n+  delete pass_counts;\n+  for (i = 1; i < lineno; i++)\n+    {\n+      ret = parse_line(lines[i], \"NEXT_PASS\");\n+      if (ret)\n \t{\n-\t\tprintf \"NEXT_PASS_WITH_ARG\";\n+\t  # Set pass_name argument, an optional with_arg argument\n+\t  pass_name = args[1];\n+\t  with_arg = args[2];\n+\n+\t  # Set pass_counts\n+\t  if (pass_name in pass_counts)\n+\t    pass_counts[pass_name]++;\n+\t  else\n+\t    pass_counts[pass_name] = 1;\n+\n+\t  pass_num = pass_counts[pass_name];\n+\n+\t  # Print call expression with extra pass_num argument\n+\t  printf \"%s\", prefix;\n+\t  if (with_arg)\n+\t    printf \"NEXT_PASS_WITH_ARG\";\n+\t  else\n+\t    printf \"NEXT_PASS\";\n+\t  printf \" (%s, %s\", pass_name, pass_num;\n+\t  if (with_arg)\n+\t    printf \", %s\", with_arg;\n+\t  printf \")%s\\n\", postfix;\n \t}\n-\telse\n-\t{\n-\t\tprintf \"NEXT_PASS\";\n-\t}\n-\tprintf \" (\";\n-\tprintf \"%s\", pass_name;\n-\tprintf \", %s\", pass_num;\n-\tif (with_arg)\n-\t{\n-\t\tprintf \", %s\", with_arg;\n-\t}\n-\tprintf \")%s\\n\", postfix;\n+      else\n+\tprint lines[i];\n+    }\n }\n \n-{ handle_line() }\n-\n # Local Variables:\n # mode:awk\n # c-basic-offset:8"}]}