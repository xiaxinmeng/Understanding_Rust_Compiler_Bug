{"sha": "de6c59795844f185e1079034b9fa777fbc12ef5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU2YzU5Nzk1ODQ0ZjE4NWUxMDc5MDM0YjlmYTc3N2ZiYzEyZWY1YQ==", "commit": {"author": {"name": "Brad Lucier", "email": "lucier@math.purdue.edu", "date": "2001-03-07T19:29:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-07T19:29:41Z"}, "message": "Brad's -ffast-math breakup.\n\nFrom-SVN: r40300", "tree": {"sha": "996aa9dfa54be0d228dde6e7394f9adf66f7c76c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/996aa9dfa54be0d228dde6e7394f9adf66f7c76c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de6c59795844f185e1079034b9fa777fbc12ef5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6c59795844f185e1079034b9fa777fbc12ef5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6c59795844f185e1079034b9fa777fbc12ef5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6c59795844f185e1079034b9fa777fbc12ef5a/comments", "author": {"login": "gambiteer", "id": 1544698, "node_id": "MDQ6VXNlcjE1NDQ2OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1544698?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gambiteer", "html_url": "https://github.com/gambiteer", "followers_url": "https://api.github.com/users/gambiteer/followers", "following_url": "https://api.github.com/users/gambiteer/following{/other_user}", "gists_url": "https://api.github.com/users/gambiteer/gists{/gist_id}", "starred_url": "https://api.github.com/users/gambiteer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gambiteer/subscriptions", "organizations_url": "https://api.github.com/users/gambiteer/orgs", "repos_url": "https://api.github.com/users/gambiteer/repos", "events_url": "https://api.github.com/users/gambiteer/events{/privacy}", "received_events_url": "https://api.github.com/users/gambiteer/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6822468a694e59639c0f97975a2f48951501fd37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6822468a694e59639c0f97975a2f48951501fd37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6822468a694e59639c0f97975a2f48951501fd37"}], "stats": {"total": 394, "additions": 280, "deletions": 114}, "files": [{"sha": "c24116eeaf7d2b642715788782d7802300b9fef3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1,3 +1,51 @@\n+2001-03-07  Brad Lucier  <lucier@math.purdue.edu>\n+\n+\t* builtins.c (expand_builtin_mathfn): Check\n+\tflag_unsafe_math_optimizations, not flag_fast_math.\n+\t(expand_builtin): Likewise\n+\t* combine.c (combine_simplify_rtx): Likewise.\n+\t(simplify_if_then_else): Likewise.\n+\t* cse.c (fold_rtx): Likewise.\n+\t* flags.h: Remove flag_fast_math.  Add \n+\tflag_unsafe_math_optimizations and flag_trapping_math.\n+\t* fold-const.c (negate_expr): Check\n+\tflag_unsafe_math_optimizations, not flag_fast_math.\n+\t(invert_truthvalue): Likewise.\n+\t(fold): Likewise.  Before associating operands, check that\n+\tcode == MULT_EXPR, not code != MULT_EXPR.\n+\t* ifcvt.c (noce_try_minmax): Check\n+\tflag_unsafe_math_optimizations, not flag_fast_math.\n+\t(noce_operand_ok): Check flag_trapping_math, not flag_fast_math.\n+\t* invoke.texi: Document -funsafe-math-optimizations and\n+\t-fno-trapping-math.  Change documentation for -ffast-math.\n+\t* jump.c (reversed_comparison_code_parts): Likewise.\n+\t(rtx_equal_for_thread_p): Likewise.\n+\t* optabs.c (emit_conditional_move): Likewise.\n+\t* simplify-rtx.c (simplify_binary_operation): Likewise.\n+\t(simplify_relational_operation): Likewise.\n+\t(simplify_ternary_operation): Likewise.\n+\t* toplev.c: Remove flag_fast_math.  Add flag_trapping_math and\n+\tflag_unsafe_math_optimizations.  Remove fast-math entry from f_options.\n+\tAdd trapping-math and unsafe-math-optimizations entries to f_options.\n+\t(set_fast_math_flags): New, sets flags for -ffast-math.\n+\t(set_no_fast_math_flags): New, sets flags for -fno-fast-math.\n+\t(decode_f_option): Add code to handle -ffast-math and -fno-fast-math.\n+\t* toplev.h: Declare set_fast_math_flags and set_no_fast_math_flags.\n+\n+\t* config/alpha/alpha.c (alpha_emit_conditional_branch): Likewise.\n+\t(alpha_emit_conditional_move): Initialize local_fast_math to\n+\tflag_unsafe_math_optimizations, not flat_fast_math.\n+\t* config/c4x/c4x.c (c4x_override_options): Call set_fast_math_flags\n+\tinstead of setting flag_fast_math to 1.\n+\t* config/convex/convex.md: Check flag_unsafe_math_optimizations,\n+\tnot flag_fast_math.\n+\t* config/i386/i386.c (override_options): Likewise\n+\t* config/i386/i386.md: Likewise.\n+\t* config/m68k/m68k.md: Likewise.\n+\t* config/mips/mips.md: Likewise.\n+\t* config/rs6000/rs6000.c (validate_condition_mode): Likewise.\n+\t(rs6000_generate_compare): Likewise.\n+\n 2001-03-07  Laurynas Biveinis  <lauras@softhome.net>\n \n         * Makefile.in: Set RANLIB to @RANLIB@."}, {"sha": "8ccd0922f62bf0e448eae1b9f746216f0bffb6be", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1430,10 +1430,10 @@ expand_builtin_mathfn (exp, target, subtarget)\n       return 0;\n     }\n \n-  /* Check the results by default.  But if flag_fast_math is turned on,\n-     then assume sqrt will always be called with valid arguments.  */\n+  /* If errno must be maintained and if we are not allowing unsafe\n+     math optimizations, check the result.  */\n \n-  if (flag_errno_math && ! flag_fast_math)\n+  if (flag_errno_math && ! flag_unsafe_math_optimizations)\n     {\n       rtx lab1;\n \n@@ -3329,8 +3329,9 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n     case BUILT_IN_SIN:\n     case BUILT_IN_COS:\n-      /* Treat these like sqrt, but only if the user asks for them.  */\n-      if (! flag_fast_math)\n+      /* Treat these like sqrt only if unsafe math optimizations are allowed,\n+\t because of possible accuracy problems.  */\n+      if (! flag_unsafe_math_optimizations)\n \tbreak;\n     case BUILT_IN_FSQRT:\n       target = expand_builtin_mathfn (exp, target, subtarget);"}, {"sha": "ca698707e77edb723698c7e9c37ea0334d2e0d32", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -4021,7 +4021,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && (! FLOAT_MODE_P (mode)\n \t      /* x-y != -(y-x) with IEEE floating point.  */\n \t      || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t      || flag_fast_math))\n+\t      || flag_unsafe_math_optimizations))\n \treturn gen_binary (MINUS, mode, XEXP (XEXP (x, 0), 1),\n \t\t\t   XEXP (XEXP (x, 0), 0));\n \n@@ -4189,7 +4189,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       /* In IEEE floating point, x-0 is not the same as x.  */\n       if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t   || ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0)))\n-\t   || flag_fast_math)\n+\t   || flag_unsafe_math_optimizations)\n \t  && XEXP (x, 1) == CONST0_RTX (GET_MODE (XEXP (x, 0))))\n \treturn XEXP (x, 0);\n       break;\n@@ -4777,12 +4777,12 @@ simplify_if_then_else (x)\n \n   /* Convert a == b ? b : a to \"a\".  */\n   if (true_code == EQ && ! side_effects_p (cond)\n-      && (! FLOAT_MODE_P (mode) || flag_fast_math)\n+      && (! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n       && rtx_equal_p (XEXP (cond, 0), false_rtx)\n       && rtx_equal_p (XEXP (cond, 1), true_rtx))\n     return false_rtx;\n   else if (true_code == NE && ! side_effects_p (cond)\n-\t   && (! FLOAT_MODE_P (mode) || flag_fast_math)\n+\t   && (! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n \t   && rtx_equal_p (XEXP (cond, 0), true_rtx)\n \t   && rtx_equal_p (XEXP (cond, 1), false_rtx))\n     return true_rtx;\n@@ -4810,7 +4810,7 @@ simplify_if_then_else (x)\n \n   /* Look for MIN or MAX.  */\n \n-  if ((! FLOAT_MODE_P (mode) || flag_fast_math)\n+  if ((! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n       && comparison_p\n       && rtx_equal_p (XEXP (cond, 0), true_rtx)\n       && rtx_equal_p (XEXP (cond, 1), false_rtx)"}, {"sha": "a9c2e85faca6b1369f5d13be1b6f472addbc83b4", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1678,7 +1678,7 @@ alpha_emit_conditional_branch (code)\n   if (alpha_compare.fp_p)\n     {\n       cmp_mode = DFmode;\n-      if (flag_fast_math)\n+      if (flag_unsafe_math_optimizations)\n \t{\n \t  /* When we are not as concerned about non-finite values, and we\n \t     are comparing against zero, we can branch directly.  */\n@@ -1879,7 +1879,7 @@ alpha_emit_conditional_move (cmp, mode)\n     = (GET_MODE (op0) == VOIDmode ? DImode : GET_MODE (op0));\n   enum machine_mode cmp_op_mode = fp_p ? DFmode : DImode;\n   enum machine_mode cmov_mode = VOIDmode;\n-  int local_fast_math = flag_fast_math;\n+  int local_fast_math = flag_unsafe_math_optimizations;\n   rtx tem;\n \n   /* Zero the operands.  */"}, {"sha": "b8f3d2ad1529787c561faa5383f26256de9c8aef", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -278,7 +278,7 @@ c4x_override_options ()\n     target_flags &= ~C3X_FLAG;\n \n   /* Convert foo / 8.0 into foo * 0.125, etc.  */\n-  flag_fast_math = 1;\n+  set_fast_math_flags();\n \n   /* We should phase out the following at some stage.\n      This provides compatibility with the old -mno-aliases option.  */"}, {"sha": "31ee5eec4c055865143752da2c13a65e56461f0d", "filename": "gcc/config/convex/convex.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fconvex%2Fconvex.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fconvex%2Fconvex.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.md?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1309,39 +1309,39 @@\n (define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n \t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n-  \"! TARGET_C1 && flag_fast_math\"\n+  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n   \"sqrt.d %0\"\n   [(set_attr \"type\" \"divd\")])\n \n (define_insn \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"! TARGET_C1 && flag_fast_math\"\n+  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n   \"sqrt.s %0\"\n   [(set_attr \"type\" \"divs\")])\n \n (define_insn \"sindf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 1))]\n-  \"! TARGET_C1 && flag_fast_math\"\n+  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n   \"sin.d %0\")\n \n (define_insn \"sinsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 1))]\n-  \"! TARGET_C1 && flag_fast_math\"\n+  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n   \"sin.s %0\")\n \n (define_insn \"cosdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 2))]\n-  \"! TARGET_C1 && flag_fast_math\"\n+  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n   \"cos.d %0\")\n \n (define_insn \"cossf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n \t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 2))]\n-  \"! TARGET_C1 && flag_fast_math\"\n+  \"! TARGET_C1 && flag_unsafe_math_optimizations\"\n   \"cos.s %0\")\n \n (define_insn \"ftruncdf2\""}, {"sha": "0f531ea3091dd8386cc3bfa346820afea1fc2fd8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -748,7 +748,7 @@ override_options ()\n \n   /* If we're doing fast math, we don't care about comparison order\n      wrt NaNs.  This lets us use a shorter comparison sequence.  */\n-  if (flag_fast_math)\n+  if (flag_unsafe_math_optimizations)\n     target_flags &= ~MASK_IEEE_FP;\n \n   /* It makes no sense to ask for just SSE builtins, so MMX is also turned"}, {"sha": "43b007d27f927f70285be5979f72285dde771785", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -10991,7 +10991,7 @@\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(sqrt:XF (match_operand:XF 1 \"register_operand\" \"0\")))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n-   && (TARGET_IEEE_FP || flag_fast_math) \"\n+   && (TARGET_IEEE_FP || flag_unsafe_math_optimizations) \"\n   \"fsqrt\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")\n@@ -11001,7 +11001,7 @@\n   [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n \t(sqrt:TF (match_operand:TF 1 \"register_operand\" \"0\")))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n-   && (TARGET_IEEE_FP || flag_fast_math) \"\n+   && (TARGET_IEEE_FP || flag_unsafe_math_optimizations) \"\n   \"fsqrt\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")\n@@ -11050,15 +11050,17 @@\n (define_insn \"sindf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 1))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fsin\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")])\n \n (define_insn \"sinsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 1))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fsin\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"SF\")])\n@@ -11067,39 +11069,44 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(float_extend:DF\n \t\t     (match_operand:SF 1 \"register_operand\" \"0\"))] 1))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fsin\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")])\n \n (define_insn \"sinxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 1 \"register_operand\" \"0\")] 1))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fsin\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])\n \n (define_insn \"sintf2\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n \t(unspec:TF [(match_operand:TF 1 \"register_operand\" \"0\")] 1))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fsin\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])\n \n (define_insn \"cosdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] 2))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fcos\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")])\n \n (define_insn \"cossf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] 2))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fcos\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"SF\")])\n@@ -11108,23 +11115,26 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(float_extend:DF\n \t\t     (match_operand:SF 1 \"register_operand\" \"0\"))] 2))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fcos\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")])\n \n (define_insn \"cosxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 1 \"register_operand\" \"0\")] 2))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fcos\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])\n \n (define_insn \"costf2\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n \t(unspec:TF [(match_operand:TF 1 \"register_operand\" \"0\")] 2))]\n-  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 && flag_fast_math\"\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n   \"fcos\"\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])"}, {"sha": "1eff7f437234a88f0f317459610ea65fa3bb4a81", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -7840,7 +7840,7 @@\n (define_insn \"sinsf2\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n \t(unspec:SF [(match_operand:SF 1 \"general_operand\" \"fm\")] 1))]\n-  \"TARGET_68881 && flag_fast_math\"\n+  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n   \"*\n {\n   if (FP_REG_P (operands[1]))\n@@ -7852,7 +7852,7 @@\n (define_insn \"sindf2\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"general_operand\" \"fm\")] 1))]\n-  \"TARGET_68881 && flag_fast_math\"\n+  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n   \"*\n {\n   if (FP_REG_P (operands[1]))\n@@ -7864,13 +7864,13 @@\n (define_insn \"sinxf2\"\n   [(set (match_operand:XF 0 \"general_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 1 \"nonimmediate_operand\" \"fm\")] 1))]\n-  \"TARGET_68881 && flag_fast_math\"\n+  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n   \"fsin%.x %1,%0\")\n \n (define_insn \"cossf2\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n \t(unspec:SF [(match_operand:SF 1 \"general_operand\" \"fm\")] 2))]\n-  \"TARGET_68881 && flag_fast_math\"\n+  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n   \"*\n {\n   if (FP_REG_P (operands[1]))\n@@ -7882,7 +7882,7 @@\n (define_insn \"cosdf2\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"general_operand\" \"fm\")] 2))]\n-  \"TARGET_68881 && flag_fast_math\"\n+  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n   \"*\n {\n   if (FP_REG_P (operands[1]))\n@@ -7894,7 +7894,7 @@\n (define_insn \"cosxf2\"\n   [(set (match_operand:XF 0 \"general_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 1 \"nonimmediate_operand\" \"fm\")] 2))]\n-  \"TARGET_68881 && flag_fast_math\"\n+  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n   \"fcos%.x %1,%0\")\n \n (define_insn \"trap\""}, {"sha": "1f343f54229af20d2902e61d5a83e62df067605b", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -2223,7 +2223,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n \t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_fast_math\"\n+  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n   \"recip.d\\\\t%0,%2\"\n   [(set_attr \"type\"\t\"fdiv\")\n    (set_attr \"mode\"\t\"DF\")])\n@@ -2232,7 +2232,7 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n \t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_fast_math\"\n+  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n   \"recip.s\\\\t%0,%2\"\n   [(set_attr \"type\"\t\"fdiv\")\n    (set_attr \"mode\"\t\"SF\")])\n@@ -2824,7 +2824,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n \t\t(sqrt:DF (match_operand:DF 2 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_fast_math\"\n+  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n   \"rsqrt.d\\\\t%0,%2\"\n   [(set_attr \"type\"\t\"fsqrt\")\n    (set_attr \"mode\"\t\"DF\")])\n@@ -2833,7 +2833,7 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n \t\t(sqrt:SF (match_operand:SF 2 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_fast_math\"\n+  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n   \"rsqrt.s\\\\t%0,%2\"\n   [(set_attr \"type\"\t\"fsqrt\")\n    (set_attr \"mode\"\t\"SF\")])"}, {"sha": "557dc196b389a522299fad2de13dd7868a7a4d83", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -3238,9 +3238,10 @@ validate_condition_mode (code, mode)\n \t  || code == UNGE || code == UNLE))\n     abort();\n   \n-  /* These should never be generated except for fast_math.  */\n+  /* These should never be generated except for \n+     flag_unsafe_math_optimizations.  */\n   if (mode == CCFPmode\n-      && ! flag_fast_math\n+      && ! flag_unsafe_math_optimizations\n       && (code == LE || code == GE\n \t  || code == UNEQ || code == LTGT\n \t  || code == UNGT || code == UNLT))\n@@ -4454,9 +4455,9 @@ rs6000_generate_compare (code)\n \t\t\t\t\t   rs6000_compare_op1)));\n   \n   /* Some kinds of FP comparisons need an OR operation;\n-     except that for fast_math we don't bother.  */\n+     except for flag_unsafe_math_optimizations we don't bother.  */\n   if (rs6000_compare_fp_p\n-      && ! flag_fast_math\n+      && ! flag_unsafe_math_optimizations\n       && (code == LE || code == GE\n \t  || code == UNEQ || code == LTGT\n \t  || code == UNGT || code == UNLT))"}, {"sha": "38ba919f115abe387795afd8099739e5f2752478", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -3977,7 +3977,8 @@ fold_rtx (x, insn)\n \t\t{\n \t\t   /* Sadly two equal NaNs are not equivalent.  */\n \t\t   if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t       || ! FLOAT_MODE_P (mode_arg0) || flag_fast_math)\n+\t\t       || ! FLOAT_MODE_P (mode_arg0) \n+\t\t       || flag_unsafe_math_optimizations)\n \t\t      return ((code == EQ || code == LE || code == GE\n \t\t\t       || code == LEU || code == GEU || code == UNEQ\n \t\t\t       || code == UNLE || code == UNGE || code == ORDERED)"}, {"sha": "5dbe031c8552be011bc88aaf73224e4e67db1714", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1,8 +1,13 @@\n+2001-03-07  Brad Lucier  <lucier@math.purdue.edu>\n+\n+\t* g77.texi: Document new options -funsafe-math-optimizations\n+\tand -fno-trapping-math.  Revise documentation for -ffast-math.\n+\n 2001-03-01  Zack Weinberg  <zackw@stanford.edu>\n \n-\t* f/proj.h: Delete 'bool' type.  Don't include stddef.h here.\n-\t* f/com.c: Rename variables named 'true' and/or 'false'.\n-\t* f/intdoc.c: Delete 'bool' type.\n+\t* proj.h: Delete 'bool' type.  Don't include stddef.h here.\n+\t* com.c: Rename variables named 'true' and/or 'false'.\n+\t* intdoc.c: Delete 'bool' type.\n \n 2001-03-01  Zack Weinberg  <zackw@stanford.edu>\n "}, {"sha": "5709f54877de7626b360303ddf0de2d09cdf4d88", "filename": "gcc/f/g77.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ff%2Fg77.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ff%2Fg77.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77.texi?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1446,6 +1446,7 @@ by type.  Explanations are in the following sections.\n -malign-double\n -ffloat-store  -fforce-mem  -fforce-addr  -fno-inline\n -ffast-math  -fstrength-reduce  -frerun-cse-after-loop\n+-funsafe-math-optimizations -fno-trapping-math\n -fexpensive-optimizations  -fdelayed-branch\n -fschedule-insns  -fschedule-insn2  -fcaller-saves\n -funroll-loops  -funroll-all-loops\n@@ -2779,6 +2780,22 @@ Note that if you are not optimizing, no functions can be expanded inline.\n @cindex conformance, IEEE 754\n Might allow some programs designed to not be too dependent\n on IEEE behavior for floating-point to run faster, or die trying.\n+Sets @samp{-funsafe-math-optimizations}, and\n+@samp{-fno-trapping-math}.\n+\n+@cindex -funsafe-math-optimizations option\n+@cindex options, -funsafe-math-optimizations\n+@item -funsafe-math-optimizations\n+Allow optimizations that may be give incorrect results\n+for certain IEEE inputs.\n+\n+@cindex -fno-trapping-math option\n+@cindex options, -fno-trapping-math\n+@item -fno-trapping-math\n+Allow the compiler to assume that floating-point arithmetic\n+will not generate traps on any inputs.  This is useful, for\n+example, when running a program using IEEE \"non-stop\"\n+floating-point arithmetic.\n \n @cindex -fstrength-reduce option\n @cindex options, -fstrength-reduce"}, {"sha": "d0e2b27bf0e69ca8a80e6271f853038f0ebd5166", "filename": "gcc/flags.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -327,22 +327,28 @@ extern int flag_volatile_global;\n \n extern int flag_volatile_static;\n \n-/* Nonzero allows GCC to violate some IEEE or ANSI rules regarding math\n-   operations in the interest of optimization.  For example it allows\n-   GCC to assume arguments to sqrt are nonnegative numbers, allowing\n-   faster code for sqrt to be generated. */\n-\n-extern int flag_fast_math;\n-\n /* Nonzero allows GCC to optimize sibling and tail recursive calls.  */\n \n extern int flag_optimize_sibling_calls;\n \n /* Nonzero means the front end generally wants `errno' maintained by math\n-   operations, like built-in SQRT, unless overridden by flag_fast_math.  */\n+   operations, like built-in SQRT.  */\n \n extern int flag_errno_math;\n \n+/* Nonzero means that unsafe floating-point math optimizations are allowed\n+   for the sake of speed.  IEEE compliance is not guaranteed, and operations\n+   are allowed to assume that their arguments and results are \"normal\"\n+   (e.g., nonnegative for SQRT).  */\n+\n+extern int flag_unsafe_math_optimizations;\n+\n+/* Zero means that floating-point math operations cannot generate a\n+   (user-visible) trap.  This is the case, for example, in nonstop\n+   IEEE 754 arithmetic.  */\n+\n+extern int flag_trapping_math;\n+\n /* 0 means straightforward implementation of complex divide acceptable.\n    1 means wide ranges of inputs must work for complex divide.\n    2 means C99-like requirements for complex divide (not yet implemented).  */"}, {"sha": "dda3102cfae34d534b1ecd13af8654eb36f4512d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1311,7 +1311,7 @@ negate_expr (t)\n \n     case MINUS_EXPR:\n       /* - (A - B) -> B - A  */\n-      if (! FLOAT_TYPE_P (type) || flag_fast_math)\n+      if (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n \treturn convert (type,\n \t\t\tfold (build (MINUS_EXPR, TREE_TYPE (t),\n \t\t\t\t     TREE_OPERAND (t, 1),\n@@ -2719,7 +2719,9 @@ invert_truthvalue (arg)\n   if (TREE_CODE_CLASS (code) == '<')\n     {\n       if (FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n-\t  && !flag_fast_math && code != NE_EXPR && code != EQ_EXPR)\n+\t  && !flag_unsafe_math_optimizations\n+\t  && code != NE_EXPR \n+\t  && code != EQ_EXPR)\n \treturn build1 (TRUTH_NOT_EXPR, type, arg);\n       else\n \treturn build (invert_tree_comparison (code), type,\n@@ -5262,7 +5264,7 @@ fold (expr)\n \n       /* Convert - (a - b) to (b - a) for non-floating-point.  */\n       else if (TREE_CODE (arg0) == MINUS_EXPR\n-\t       && (! FLOAT_TYPE_P (type) || flag_fast_math))\n+\t       && (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n \treturn build (MINUS_EXPR, type, TREE_OPERAND (arg0, 1),\n \t\t      TREE_OPERAND (arg0, 0));\n \n@@ -5457,7 +5459,7 @@ fold (expr)\n \t}\n       /* In IEEE floating point, x+0 may not equal x.  */\n       else if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t|| flag_fast_math)\n+\t\t|| flag_unsafe_math_optimizations)\n \t       && real_zerop (arg1))\n \treturn non_lvalue (convert (type, arg0));\n       /* x+(-0) equals x, even for IEEE.  */\n@@ -5541,11 +5543,11 @@ fold (expr)\n \t parentheses.  Rather than remember where the parentheses were, we\n \t don't associate floats at all.  It shouldn't matter much.  However,\n \t associating multiplications is only very slightly inaccurate, so do\n-\t that if -ffast-math is specified.  */\n+\t that if -funsafe-math-optimizations is specified.  */\n \n       if (! wins\n \t  && (! FLOAT_TYPE_P (type)\n-\t      || (flag_fast_math && code != MULT_EXPR)))\n+\t      || (flag_unsafe_math_optimizations && code == MULT_EXPR)))\n \t{\n \t  tree var0, con0, lit0, var1, con1, lit1;\n \n@@ -5622,7 +5624,7 @@ fold (expr)\n \t}\n \n       else if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || flag_fast_math)\n+\t       || flag_unsafe_math_optimizations)\n \t{\n \t  /* Except with IEEE floating point, 0-x equals -x.  */\n \t  if (! wins && real_zerop (arg0))\n@@ -5638,7 +5640,7 @@ fold (expr)\n \t Also note that operand_equal_p is always false if an operand\n \t is volatile.  */\n \n-      if ((! FLOAT_TYPE_P (type) || flag_fast_math)\n+      if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n \t  && operand_equal_p (arg0, arg1, 0))\n \treturn convert (type, integer_zero_node);\n \n@@ -5677,7 +5679,7 @@ fold (expr)\n \t{\n \t  /* x*0 is 0, except for IEEE floating point.  */\n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || flag_fast_math)\n+\t       || flag_unsafe_math_optimizations)\n \t      && real_zerop (arg1))\n \t    return omit_one_operand (type, arg1, arg0);\n \t  /* In IEEE floating point, x*1 is not equivalent to x for snans.\n@@ -5834,12 +5836,12 @@ fold (expr)\n \n       /* If ARG1 is a constant, we can convert this to a multiply by the\n \t reciprocal.  This does not have the same rounding properties,\n-\t so only do this if -ffast-math.  We can actually always safely\n-\t do it if ARG1 is a power of two, but it's hard to tell if it is\n-\t or not in a portable manner.  */\n+\t so only do this if -funsafe-math-optimizations.  We can actually\n+\t always safely do it if ARG1 is a power of two, but it's hard to\n+\t tell if it is or not in a portable manner.  */\n       if (TREE_CODE (arg1) == REAL_CST)\n \t{\n-\t  if (flag_fast_math\n+\t  if (flag_unsafe_math_optimizations\n \t      && 0 != (tem = const_binop (code, build_real (type, dconst1),\n \t\t\t\t\t  arg1, 0)))\n \t    return fold (build (MULT_EXPR, type, arg0, tem));\n@@ -6899,7 +6901,7 @@ fold (expr)\n       if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n \t  && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t      || ! FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0)))\n-\t      || flag_fast_math)\n+\t      || flag_unsafe_math_optimizations)\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1)))\n \t{"}, {"sha": "ceb7d49db2dd4dd00ae660a16c747c25c3517a84", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1143,7 +1143,7 @@ noce_try_minmax (if_info)\n      to get the target to tell us...  */\n   if (FLOAT_MODE_P (GET_MODE (if_info->x))\n       && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-      && ! flag_fast_math)\n+      && ! flag_unsafe_math_optimizations)\n     return FALSE;\n \n   cond = noce_get_alt_condition (if_info, if_info->a, &earliest);\n@@ -1397,10 +1397,10 @@ noce_operand_ok (op)\n   if (side_effects_p (op))\n     return FALSE;\n \n-  /* ??? Unfortuantely may_trap_p can't look at flag_fast_math, due to\n+  /* ??? Unfortuantely may_trap_p can't look at flag_trapping_math, due to\n      being linked into the genfoo programs.  This is probably a mistake.\n      With finite operands, most fp operations don't trap.  */\n-  if (flag_fast_math && FLOAT_MODE_P (GET_MODE (op)))\n+  if (!flag_trapping_math && FLOAT_MODE_P (GET_MODE (op)))\n     switch (GET_CODE (op))\n       {\n       case DIV:"}, {"sha": "0f3be5b1db677e02d9d3e6f7d137f483d219a39a", "filename": "gcc/invoke.texi", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -245,8 +245,9 @@ in the following sections.\n -finline-functions  -finline-limit=@var{n}  -fkeep-inline-functions @gol\n -fkeep-static-consts  -fmove-all-movables @gol\n -fno-default-inline  -fno-defer-pop @gol\n--fno-function-cse   -fno-guess-branch-probability\n+-fno-function-cse   -fno-guess-branch-probability @gol\n -fno-inline  -fno-math-errno  -fno-peephole @gol\n+-funsafe-math-optimizations -fno-trapping-math @gol\n -fomit-frame-pointer  -foptimize-register-move @gol\n -foptimize-sibling-calls  -freduce-all-givs @gol\n -fregmove  -frename-registers @gol\n@@ -2934,11 +2935,10 @@ that alter the assembler output may be confused by the optimizations\n performed when this option is not used.\n \n @item -ffast-math\n-This option allows GCC to violate some ISO or IEEE rules and/or\n-specifications in the interest of optimizing code for speed.  For\n-example, it allows the compiler to assume arguments to the @code{sqrt}\n-function are non-negative numbers and that no floating-point values\n-are NaNs.\n+Sets @samp{-fno-math-errno}, @samp{-funsafe-math-optimizations},\n+and @samp{-fno-trapping-math}.\n+\n+This option causes the preprocessor macro __FAST_MATH__ to be defined.\n \n This option causes the preprocessor macro __FAST_MATH__ to be defined.\n \n@@ -2953,8 +2953,39 @@ with a single instruction, e.g., sqrt.  A program that relies on\n IEEE exceptions for math error handling may want to use this flag\n for speed while maintaining IEEE arithmetic compatibility.\n \n+This option should never be turned on by any @samp{-O} option since\n+it can result in incorrect output for programs which depend on\n+an exact implementation of IEEE or ISO rules/specifications for\n+math functions.\n+\n The default is @samp{-fmath-errno}.  The @samp{-ffast-math} option\n sets @samp{-fno-math-errno}.\n+\n+@item -funsafe-math-optimizations\n+Allow optimizations for floating-point arithmetic that (a) assume\n+that arguments and results are valid and (b) may violate IEEE or\n+ANSI standards.  \n+\n+This option should never be turned on by any @samp{-O} option since\n+it can result in incorrect output for programs which depend on\n+an exact implementation of IEEE or ISO rules/specifications for\n+math functions.\n+\n+The default is @samp{-fno-unsafe-math-optimizations}.  The\n+@samp{-ffast-math} option sets @samp{-funsafe-math-optimizations}.\n+\n+@item -fno-trapping-math\n+Compile code assuming that floating-point operations cannot generate\n+user-visible traps.  Setting this option may allow faster code\n+if one relies on ``non-stop'' IEEE arithmetic, for example.\n+\n+This option should never be turned on by any @samp{-O} option since\n+it can result in incorrect output for programs which depend on\n+an exact implementation of IEEE or ISO rules/specifications for\n+math functions.\n+\n+The default is @samp{-ftrapping-math}.  The @samp{-ffast-math}\n+option sets @samp{-fno-trapping-math}.\n @end table\n \n @c following causes underfulls.. they don't look great, but we deal.\n@@ -6594,7 +6625,7 @@ Some 387 emulators do not support the @code{sin}, @code{cos} and\n @code{sqrt} instructions for the 387.  Specify this option to avoid\n generating those instructions. This option is the default on FreeBSD.\n As of revision 2.6.1, these instructions are not generated unless you\n-also use the @samp{-ffast-math} switch.\n+also use the @samp{-funsafe-math-optimizations} switch.\n \n @item -malign-double\n @itemx -mno-align-double"}, {"sha": "f88bdc2a5692bfb4e48c5b076836323174e245eb", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1,3 +1,8 @@\n+2001-03-07  Brad Lucier  <lucier@math.purdue.edu>\n+\n+\t* typeck.c (convert): Check flag_unsafe_math_optimizations,\n+\tnot flag_fast_math.\n+\n 2001-03-05  Per Bothner  <per@bothner.com>\n \n \tFix a problem where rest_of_decl_compilation applied to"}, {"sha": "c6bbd7ae086b694cf4d4002fa68f1719518953f4", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -132,7 +132,7 @@ convert (type, expr)\n     return fold (convert_to_boolean (type, expr));\n   if (code == INTEGER_TYPE)\n     {\n-      if (! flag_fast_math\n+      if (! flag_unsafe_math_optimizations\n \t  && ! flag_emit_class_files\n \t  && TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n \t  && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)"}, {"sha": "f6f524e5e33d3563aa9259a515c0edac931afa91", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -1785,7 +1785,7 @@ reversed_comparison_code_parts (code, arg0, arg1, insn)\n \t/* We don't have safe way to reverse these yet - we would need\n \t   ordered compares that may not trap.  */\n \tif (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t    || flag_fast_math)\n+\t    || flag_unsafe_math_optimizations)\n \t  return reverse_condition_maybe_unordered (code);\n \treturn UNKNOWN;\n       default:\n@@ -1794,7 +1794,7 @@ reversed_comparison_code_parts (code, arg0, arg1, insn)\n \n   /* In case we give up IEEE compatibility, all comparisons are reversible.  */\n   if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-      || flag_fast_math)\n+      || flag_unsafe_math_optimizations)\n     return reverse_condition (code);\n \n   if (GET_MODE_CLASS (mode) == MODE_CC\n@@ -4061,7 +4061,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n      pessimistic, but this pass would only rarely do anything for FP\n      anyway.  */\n   if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-      && FLOAT_MODE_P (GET_MODE (x)) && ! flag_fast_math)\n+      && FLOAT_MODE_P (GET_MODE (x)) && ! flag_unsafe_math_optimizations)\n     return 0;\n \n   /* For commutative operations, the RTX match if the operand match in any"}, {"sha": "bde10d4cde4e8a3ee84d9fcd45e124cf6eaac019", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -3620,7 +3620,8 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n   if (((CONSTANT_P (op2) && ! CONSTANT_P (op3))\n        || (GET_CODE (op2) == CONST_INT && GET_CODE (op3) != CONST_INT))\n       && (GET_MODE_CLASS (GET_MODE (op1)) != MODE_FLOAT\n-\t  || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT || flag_fast_math))\n+\t  || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT \n+\t  || flag_unsafe_math_optimizations))\n     {\n       tem = op2;\n       op2 = op3;"}, {"sha": "dd7d2e1e6b5ef6d156acdee618cc653fda4f7f90", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -903,7 +903,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* In IEEE floating point, x+0 is not the same as x.  Similarly\n \t     for the other optimizations below.  */\n \t  if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\t      && FLOAT_MODE_P (mode) && ! flag_fast_math)\n+\t      && FLOAT_MODE_P (mode) && ! flag_unsafe_math_optimizations)\n \t    break;\n \n \t  if (op1 == CONST0_RTX (mode))\n@@ -1004,7 +1004,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t     In IEEE floating point, x-0 is not the same as x.  */\n \n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || ! FLOAT_MODE_P (mode) || flag_fast_math)\n+\t       || ! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n \t      && op1 == CONST0_RTX (mode))\n \t    return op0;\n #endif\n@@ -1034,15 +1034,15 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* None of these optimizations can be done for IEEE\n \t     floating point.  */\n \t  if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\t      && FLOAT_MODE_P (mode) && ! flag_fast_math)\n+\t      && FLOAT_MODE_P (mode) && ! flag_unsafe_math_optimizations)\n \t    break;\n \n \t  /* We can't assume x-x is 0 even with non-IEEE floating point,\n \t     but since it is zero except in very strange circumstances, we\n-\t     will treat it as zero with -ffast-math.  */\n+\t     will treat it as zero with -funsafe-math-optimizations.  */\n \t  if (rtx_equal_p (op0, op1)\n \t      && ! side_effects_p (op0)\n-\t      && (! FLOAT_MODE_P (mode) || flag_fast_math))\n+\t      && (! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations))\n \t    return CONST0_RTX (mode);\n \n \t  /* Change subtraction from zero into negation.  */\n@@ -1153,7 +1153,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  /* In IEEE floating point, x*0 is not always 0.  */\n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || ! FLOAT_MODE_P (mode) || flag_fast_math)\n+\t       || ! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n \t      && op1 == CONST0_RTX (mode)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n@@ -1260,19 +1260,18 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  /* In IEEE floating point, 0/x is not always 0.  */\n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || ! FLOAT_MODE_P (mode) || flag_fast_math)\n+\t       || ! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n \t      && op0 == CONST0_RTX (mode)\n \t      && ! side_effects_p (op1))\n \t    return op0;\n \n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n \t  /* Change division by a constant into multiplication.  Only do\n-\t     this with -ffast-math until an expert says it is safe in\n-\t     general.  */\n+\t     this with -funsafe-math-optimizations.  */\n \t  else if (GET_CODE (op1) == CONST_DOUBLE\n \t\t   && GET_MODE_CLASS (GET_MODE (op1)) == MODE_FLOAT\n \t\t   && op1 != CONST0_RTX (mode)\n-\t\t   && flag_fast_math)\n+\t\t   && flag_unsafe_math_optimizations)\n \t    {\n \t      REAL_VALUE_TYPE d;\n \t      REAL_VALUE_FROM_CONST_DOUBLE (d, op1);\n@@ -1803,17 +1802,18 @@ simplify_relational_operation (code, mode, op0, op1)\n     return simplify_relational_operation (signed_condition (code),\n \t\t\t\t\t  mode, tem, const0_rtx);\n \n-  if (flag_fast_math && code == ORDERED)\n+  if (flag_unsafe_math_optimizations && code == ORDERED)\n     return const_true_rtx;\n \n-  if (flag_fast_math && code == UNORDERED)\n+  if (flag_unsafe_math_optimizations && code == UNORDERED)\n     return const0_rtx;\n \n   /* For non-IEEE floating-point, if the two operands are equal, we know the\n      result.  */\n   if (rtx_equal_p (op0, op1)\n       && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t  || ! FLOAT_MODE_P (GET_MODE (op0)) || flag_fast_math))\n+\t  || ! FLOAT_MODE_P (GET_MODE (op0)) \n+\t  || flag_unsafe_math_optimizations))\n     equal = 1, op0lt = 0, op0ltu = 0, op1lt = 0, op1ltu = 0;\n \n   /* If the operands are floating-point constants, see if we can fold\n@@ -2082,12 +2082,12 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \n       /* Convert a == b ? b : a to \"a\".  */\n       if (GET_CODE (op0) == NE && ! side_effects_p (op0)\n-\t  && (! FLOAT_MODE_P (mode) || flag_fast_math)\n+\t  && (! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n \t  && rtx_equal_p (XEXP (op0, 0), op1)\n \t  && rtx_equal_p (XEXP (op0, 1), op2))\n \treturn op1;\n       else if (GET_CODE (op0) == EQ && ! side_effects_p (op0)\n-\t  && (! FLOAT_MODE_P (mode) || flag_fast_math)\n+\t  && (! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && rtx_equal_p (XEXP (op0, 0), op2))\n \treturn op2;"}, {"sha": "6bddc9c3690013feda83e2bd774f1bbcdbebe908", "filename": "gcc/toplev.c", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -618,22 +618,28 @@ int flag_data_sections = 0;\n \n int flag_no_peephole = 0;\n \n-/* Nonzero allows GCC to violate some IEEE or ANSI rules regarding math\n-   operations in the interest of optimization.  For example it allows\n-   GCC to assume arguments to sqrt are nonnegative numbers, allowing\n-   faster code for sqrt to be generated.  */\n-\n-int flag_fast_math = 0;\n-\n /* Nonzero allows GCC to optimize sibling and tail recursive calls.  */\n \n int flag_optimize_sibling_calls = 0;\n \n /* Nonzero means the front end generally wants `errno' maintained by math\n-   operations, like built-in SQRT, unless overridden by flag_fast_math.  */\n+   operations, like built-in SQRT.  */\n \n int flag_errno_math = 1;\n \n+/* Nonzero means that unsafe floating-point math optimizations are allowed\n+   for the sake of speed.  IEEE compliance is not guaranteed, and operations\n+   are allowed to assume that their arguments and results are \"normal\"\n+   (e.g., nonnegative for SQRT).  */\n+\n+int flag_unsafe_math_optimizations = 0;\n+\n+/* Zero means that floating-point math operations cannot generate a\n+   (user-visible) trap.  This is the case, for example, in nonstop\n+   IEEE 754 arithmetic.  */\n+\n+int flag_trapping_math = 1;\n+\n /* 0 means straightforward implementation of complex divide acceptable.\n    1 means wide ranges of inputs must work for complex divide.\n    2 means C99-like requirements for complex divide (not yet implemented).  */\n@@ -1094,8 +1100,6 @@ lang_independent_options f_options[] =\n    \"Reorder basic blocks to improve code placement\" },\n   {\"rename-registers\", &flag_rename_registers, 1,\n    \"Do the register renaming optimization pass\"},\n-  {\"fast-math\", &flag_fast_math, 1,\n-   \"Improve FP speed by violating ANSI & IEEE rules\" },\n   {\"common\", &flag_no_common, 0,\n    \"Do not put unitialised globals in the common section\" },\n   {\"inhibit-size-directive\", &flag_inhibit_size_directive, 1,\n@@ -1154,6 +1158,10 @@ lang_independent_options f_options[] =\n     \"Enables guessing of branch probabilities\" },\n   {\"math-errno\", &flag_errno_math, 1,\n    \"Set errno after built-in math functions\"},\n+  {\"trapping-math\", &flag_trapping_math, 1,\n+   \"Floating-point operations can trap\"},\n+  {\"unsafe-math-optimizations\", &flag_unsafe_math_optimizations, 1,\n+   \"Allow math optimizations that may violate IEEE or ANSI standards\"},\n   {\"bounded-pointers\", &flag_bounded_pointers, 1,\n    \"Compile pointers as triples: value, base & end\" },\n   {\"bounds-check\", &flag_bounds_check, 1,\n@@ -1479,6 +1487,26 @@ lang_independent_options W_options[] =\n   {\"missing-noreturn\", &warn_missing_noreturn, 1,\n    \"Warn about functions which might be candidates for attribute noreturn\"}\n };\n+\n+/* The following routines are useful in setting all the flags that\n+   -ffast-math and -fno-fast-math imply.  */\n+\n+void\n+set_fast_math_flags ()\n+{\n+  flag_trapping_math = 0;\n+  flag_unsafe_math_optimizations = 1;\n+  flag_errno_math = 0;\n+}\n+\n+void\n+set_no_fast_math_flags ()\n+{\n+  flag_trapping_math = 1;\n+  flag_unsafe_math_optimizations = 0;\n+  flag_errno_math = 1;\n+}\n+\n \f\n /* Output files for assembler code (real compiler output)\n    and debugging dumps.  */\n@@ -4092,8 +4120,12 @@ decode_f_option (arg)\n \t}\n     }\n \n-  if ((option_value = skip_leading_substring (arg, \"inline-limit-\"))\n-      || (option_value = skip_leading_substring (arg, \"inline-limit=\")))\n+  if (!strcmp (arg, \"fast-math\"))\n+    set_fast_math_flags();\n+  else if (!strcmp (arg, \"no-fast-math\"))\n+    set_no_fast_math_flags();\n+  else if ((option_value = skip_leading_substring (arg, \"inline-limit-\"))\n+\t   || (option_value = skip_leading_substring (arg, \"inline-limit=\")))\n     {\n       int val = \n \tread_integral_parameter (option_value, arg - 2,"}, {"sha": "0e9e10bdad4af61111f1ed929c2f693349c32cc3", "filename": "gcc/toplev.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6c59795844f185e1079034b9fa777fbc12ef5a/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=de6c59795844f185e1079034b9fa777fbc12ef5a", "patch": "@@ -164,4 +164,10 @@ struct lang_hooks\n /* Each front end provides its own.  */\n extern struct lang_hooks lang_hooks;\n \n+/* These functions can be used by targets to set the flags originally\n+   implied by -ffast-math and -fno-fast-math.  */\n+\n+extern void set_fast_math_flags         PARAMS ((void));\n+extern void set_no_fast_math_flags      PARAMS ((void));\n+\n #endif /* __GCC_TOPLEV_H */"}]}