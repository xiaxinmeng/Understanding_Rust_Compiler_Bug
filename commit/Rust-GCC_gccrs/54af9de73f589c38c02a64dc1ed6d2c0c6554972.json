{"sha": "54af9de73f589c38c02a64dc1ed6d2c0c6554972", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRhZjlkZTczZjU4OWMzOGMwMmE2NGRjMWVkNmQyYzBjNjU1NDk3Mg==", "commit": {"author": {"name": "David Edelsohn", "email": "dje.gcc@gmail.com", "date": "2012-06-20T13:02:56Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2012-06-20T13:02:56Z"}, "message": "locks.h (compare_and_swap): Use GCC atomic intrinsics.\n\n2012-06-20  David Edelsohn  <dje.gcc@gmail.com>\n            Alan Modra  <amodra@gmail.com>\n\n        * sysdep/powerpc/locks.h (compare_and_swap): Use GCC atomic\n        intrinsics.\n        (release_set): Same.\n        (compare_and_swap_release): Same.\n        (read_barrier): Same.\n        (write_barrier): Same.\n\nCo-Authored-By: Alan Modra <amodra@gmail.com>\n\nFrom-SVN: r188829", "tree": {"sha": "e879acf299bb2060d99c8b970fb37dc1bdb03b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e879acf299bb2060d99c8b970fb37dc1bdb03b6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54af9de73f589c38c02a64dc1ed6d2c0c6554972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54af9de73f589c38c02a64dc1ed6d2c0c6554972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54af9de73f589c38c02a64dc1ed6d2c0c6554972", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54af9de73f589c38c02a64dc1ed6d2c0c6554972/comments", "author": {"login": "edelsohn", "id": 667700, "node_id": "MDQ6VXNlcjY2NzcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/667700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edelsohn", "html_url": "https://github.com/edelsohn", "followers_url": "https://api.github.com/users/edelsohn/followers", "following_url": "https://api.github.com/users/edelsohn/following{/other_user}", "gists_url": "https://api.github.com/users/edelsohn/gists{/gist_id}", "starred_url": "https://api.github.com/users/edelsohn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edelsohn/subscriptions", "organizations_url": "https://api.github.com/users/edelsohn/orgs", "repos_url": "https://api.github.com/users/edelsohn/repos", "events_url": "https://api.github.com/users/edelsohn/events{/privacy}", "received_events_url": "https://api.github.com/users/edelsohn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a75f501709fc1562a96064688ca925d48562f131", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a75f501709fc1562a96064688ca925d48562f131", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a75f501709fc1562a96064688ca925d48562f131"}], "stats": {"total": 86, "additions": 36, "deletions": 50}, "files": [{"sha": "152e9d7db08128091a859409f6efbff0badb3989", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54af9de73f589c38c02a64dc1ed6d2c0c6554972/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54af9de73f589c38c02a64dc1ed6d2c0c6554972/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=54af9de73f589c38c02a64dc1ed6d2c0c6554972", "patch": "@@ -1,3 +1,13 @@\n+2012-06-20  David Edelsohn  <dje.gcc@gmail.com>\n+\t    Alan Modra  <amodra@gmail.com>\n+\n+\t* sysdep/powerpc/locks.h (compare_and_swap): Use GCC atomic\n+\tintrinsics.\n+\t(release_set): Same.\n+\t(compare_and_swap_release): Same.\n+\t(read_barrier): Same.\n+\t(write_barrier): Same.\n+\n 2012-06-15  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* sysdep/m68k/locks.h (compare_and_swap): Use"}, {"sha": "ecff4e251de1316f49f38eaa30b839746a2f31aa", "filename": "libjava/sysdep/powerpc/locks.h", "status": "modified", "additions": 26, "deletions": 50, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54af9de73f589c38c02a64dc1ed6d2c0c6554972/libjava%2Fsysdep%2Fpowerpc%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54af9de73f589c38c02a64dc1ed6d2c0c6554972/libjava%2Fsysdep%2Fpowerpc%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fpowerpc%2Flocks.h?ref=54af9de73f589c38c02a64dc1ed6d2c0c6554972", "patch": "@@ -11,87 +11,63 @@ details.  */\n #ifndef __SYSDEP_LOCKS_H__\n #define __SYSDEP_LOCKS_H__\n \n-#ifdef __LP64__\n-#define _LARX \"ldarx \"\n-#define _STCX \"stdcx. \"\n-#else\n-#define _LARX \"lwarx \"\n-#ifdef __PPC405__\n-#define _STCX \"sync; stwcx. \"\n-#else\n-#define _STCX \"stwcx. \"\n-#endif\n-#endif\n-\n typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n \t\t\t\t/* address.\t\t\t\t*/\n \n+// Atomically replace *addr by new_val if it was initially equal to old.\n+// Return true if the comparison succeeded.\n+// Assumed to have acquire semantics, i.e. later memory operations\n+// cannot execute before the compare_and_swap finishes.\n+\n inline static bool\n-compare_and_swap (volatile obj_addr_t *addr, obj_addr_t old,\n+compare_and_swap (volatile obj_addr_t *addr,\n+\t\t  obj_addr_t old,\n \t\t  obj_addr_t new_val) \n {\n-  obj_addr_t ret;\n-\n-  __asm__ __volatile__ (\n-\t   \"      \" _LARX \"%0,0,%1 \\n\"\n-\t   \"      xor. %0,%3,%0\\n\"\n-\t   \"      bne $+12\\n\"\n-\t   \"      \" _STCX \"%2,0,%1\\n\"\n-\t   \"      bne- $-16\\n\"\n-\t: \"=&r\" (ret)\n-\t: \"r\" (addr), \"r\" (new_val), \"r\" (old)\n-\t: \"cr0\", \"memory\");\n-\n-  /* This version of __compare_and_swap is to be used when acquiring\n-     a lock, so we don't need to worry about whether other memory\n-     operations have completed, but we do need to be sure that any loads\n-     after this point really occur after we have acquired the lock.  */\n-  __asm__ __volatile__ (\"isync\" : : : \"memory\");\n-  return ret == 0;\n+  return __atomic_compare_exchange_n (addr, &old, new_val, 0,\n+\t\t\t\t      __ATOMIC_ACQUIRE, __ATOMIC_RELAXED);\n }\n \n+\n+// Set *addr to new_val with release semantics, i.e. making sure\n+// that prior loads and stores complete before this\n+// assignment.\n+\n inline static void\n release_set (volatile obj_addr_t *addr, obj_addr_t new_val)\n {\n-  __asm__ __volatile__ (\"sync\" : : : \"memory\");\n-  *addr = new_val;\n+  __atomic_store_n(addr, val, __ATOMIC_RELEASE);\n }\n \n+\n+// Compare_and_swap with release semantics instead of acquire semantics.\n+\n inline static bool\n compare_and_swap_release (volatile obj_addr_t *addr, obj_addr_t old,\n \t\t\t  obj_addr_t new_val)\n {\n-  obj_addr_t ret;\n-\n-  __asm__ __volatile__ (\"sync\" : : : \"memory\");\n-\n-  __asm__ __volatile__ (\n-\t   \"      \" _LARX \"%0,0,%1 \\n\"\n-\t   \"      xor. %0,%3,%0\\n\"\n-\t   \"      bne $+12\\n\"\n-\t   \"      \" _STCX \"%2,0,%1\\n\"\n-\t   \"      bne- $-16\\n\"\n-\t: \"=&r\" (ret)\n-\t: \"r\" (addr), \"r\" (new_val), \"r\" (old)\n-\t: \"cr0\", \"memory\");\n-\n-  return ret == 0;\n+  return __atomic_compare_exchange_n (addr, &old, new_val, 0,\n+\t\t\t\t      __ATOMIC_RELEASE, __ATOMIC_RELAXED);\n }\n \n+\n // Ensure that subsequent instructions do not execute on stale\n // data that was loaded from memory before the barrier.\n+\n inline static void\n read_barrier ()\n {\n-  __asm__ __volatile__ (\"isync\" : : : \"memory\");\n+  __atomic_thread_fence (__ATOMIC_ACQUIRE);\n }\n \n+\n // Ensure that prior stores to memory are completed with respect to other\n // processors.\n+\n inline static void\n write_barrier ()\n {\n-  __asm__ __volatile__ (\"sync\" : : : \"memory\");\n+  __atomic_thread_fence (__ATOMIC_RELEASE);\n }\n \n #endif"}]}