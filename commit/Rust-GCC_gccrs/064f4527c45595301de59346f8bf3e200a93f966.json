{"sha": "064f4527c45595301de59346f8bf3e200a93f966", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY0ZjQ1MjdjNDU1OTUzMDFkZTU5MzQ2ZjhiZjNlMjAwYTkzZjk2Ng==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2013-10-17T13:58:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-17T13:58:39Z"}, "message": "exp_util.adb (Get_Current_Value_Condition, [...]): Handle the case of expressions with actions * exp_util.adb (Insert_Actions):...\n\n2013-10-17  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_util.adb (Get_Current_Value_Condition,\n\tSet_Current_Value_Condition): Handle the case of expressions\n\twith actions * exp_util.adb (Insert_Actions): Handle the case\n\tof an expression with actions whose Actions list is empty.\n\t* exp_util.adb (Remove_Side_Effects.Side_Effect_Free): An\n\texpression with actions that has no Actions and whose Expression\n\tis side effect free is itself side effect free.\n\t* exp_util.adb (Remove_Side_Effects): Do not set an incorrect etype on\n\ttemporary 'R' (Def_Id), which is in general an access to Exp_Type, not\n\tan Exp_Type.\n\t* sem_res.adb (Resolve): For an expression with\n\tactions, resolve the expression early.\t* sem_res.adb\n\t(Resolve_Expression_With_Actions): Rewrite an expression with\n\tactions whose value is compile time known and which has no\n\tactions into just its expression, so that its constant value is\n\tavailable downstream.\n\t* sem_res.adb (Resolve_Short_Circuit):\n\tWrap the left operand in an expression with actions to contain\n\tany required finalization actions.\n\t* exp_ch4.adb (Expand_Expression_With_Actions): For an\n\texpression with actions returning a Boolean expression, ensure\n\tany finalization action is kept within the Actions list.\n\t* sem_warn.adb (Check_References, Check_Unset_Reference): add\n\tmissing circuitry to handle expressions with actions.\n\t* checks.adb (Ensure_Valid): For an expression with actions,\n\tinsert the validity check on the Expression.\n\t* sem_ch13.adb (Build_Static_Predicate.Get_RList): An expression\n\twith actions that has a non-empty Actions list is not static. An\n\texpression with actions that has an empty Actions list has the\n\tstatic ranges of its Expression.\n\t* sem_util.adb (Has_No_Obvious_Side_Effects): An expression with\n\tactions with an empty Actions list has no obvious side effects\n\tif its Expression itsekf has no obvious side effects.\n\nFrom-SVN: r203763", "tree": {"sha": "659d72d41960b0109772adedd106fcef972cd3fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/659d72d41960b0109772adedd106fcef972cd3fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/064f4527c45595301de59346f8bf3e200a93f966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/064f4527c45595301de59346f8bf3e200a93f966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/064f4527c45595301de59346f8bf3e200a93f966", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/064f4527c45595301de59346f8bf3e200a93f966/comments", "author": null, "committer": null, "parents": [{"sha": "51245e2db08facc4d1ce09aa57782b43526c8055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51245e2db08facc4d1ce09aa57782b43526c8055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51245e2db08facc4d1ce09aa57782b43526c8055"}], "stats": {"total": 340, "additions": 270, "deletions": 70}, "files": [{"sha": "a815f366bc63f91d4db2b51471b83dda9c201055", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=064f4527c45595301de59346f8bf3e200a93f966", "patch": "@@ -1,3 +1,39 @@\n+2013-10-17  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_util.adb (Get_Current_Value_Condition,\n+\tSet_Current_Value_Condition): Handle the case of expressions\n+\twith actions * exp_util.adb (Insert_Actions): Handle the case\n+\tof an expression with actions whose Actions list is empty.\n+\t* exp_util.adb (Remove_Side_Effects.Side_Effect_Free): An\n+\texpression with actions that has no Actions and whose Expression\n+\tis side effect free is itself side effect free.\n+\t* exp_util.adb (Remove_Side_Effects): Do not set an incorrect etype on\n+\ttemporary 'R' (Def_Id), which is in general an access to Exp_Type, not\n+\tan Exp_Type.\n+\t* sem_res.adb (Resolve): For an expression with\n+\tactions, resolve the expression early.\t* sem_res.adb\n+\t(Resolve_Expression_With_Actions): Rewrite an expression with\n+\tactions whose value is compile time known and which has no\n+\tactions into just its expression, so that its constant value is\n+\tavailable downstream.\n+\t* sem_res.adb (Resolve_Short_Circuit):\n+\tWrap the left operand in an expression with actions to contain\n+\tany required finalization actions.\n+\t* exp_ch4.adb (Expand_Expression_With_Actions): For an\n+\texpression with actions returning a Boolean expression, ensure\n+\tany finalization action is kept within the Actions list.\n+\t* sem_warn.adb (Check_References, Check_Unset_Reference): add\n+\tmissing circuitry to handle expressions with actions.\n+\t* checks.adb (Ensure_Valid): For an expression with actions,\n+\tinsert the validity check on the Expression.\n+\t* sem_ch13.adb (Build_Static_Predicate.Get_RList): An expression\n+\twith actions that has a non-empty Actions list is not static. An\n+\texpression with actions that has an empty Actions list has the\n+\tstatic ranges of its Expression.\n+\t* sem_util.adb (Has_No_Obvious_Side_Effects): An expression with\n+\tactions with an empty Actions list has no obvious side effects\n+\tif its Expression itsekf has no obvious side effects.\n+\n 2013-10-17  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_aux.ads, sem_aux.adb (Is_Immutably_Limited_Type): Make"}, {"sha": "328e05e5aaf30db70b05525c23b8f706f46fa52c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=064f4527c45595301de59346f8bf3e200a93f966", "patch": "@@ -5092,6 +5092,13 @@ package body Checks is\n       then\n          return;\n \n+      --  For an expression with actions, we want to insert the validity check\n+      --  on the final Expression.\n+\n+      elsif Nkind (Expr) = N_Expression_With_Actions then\n+         Ensure_Valid (Expression (Expr));\n+         return;\n+\n       --  An annoying special case. If this is an out parameter of a scalar\n       --  type, then the value is not going to be accessed, therefore it is\n       --  inappropriate to do any validity check at the call site."}, {"sha": "0356b67e6c69fc85b789db9605aaa63007c802cc", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 104, "deletions": 55, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=064f4527c45595301de59346f8bf3e200a93f966", "patch": "@@ -12135,15 +12135,26 @@ package body Exp_Ch4 is\n      (Decl     : Node_Id;\n       Rel_Node : Node_Id)\n    is\n-      function Find_Enclosing_Context (N : Node_Id) return Node_Id;\n-      --  Find the logical context where N appears. The context is chosen such\n-      --  that it is possible to insert before and after it.\n+      Hook_Context         : Node_Id;\n+      --  Node on which to insert the hook pointer (as an action)\n \n-      ----------------------------\n-      -- Find_Enclosing_Context --\n-      ----------------------------\n+      Finalization_Context : Node_Id;\n+      --  Node after which to insert finalization actions\n+\n+      Finalize_Always : Boolean;\n+      --  If False, call to finalizer includes a test of whether the\n+      --  hook pointer is null.\n \n-      function Find_Enclosing_Context (N : Node_Id) return Node_Id is\n+      procedure Find_Enclosing_Contexts (N : Node_Id);\n+      --  Find the logical context where N appears, and initializae\n+      --  Hook_Context and Finalization_Context accordingly. Also\n+      --  sets Finalize_Always.\n+\n+      -----------------------------\n+      -- Find_Enclosing_Contexts --\n+      -----------------------------\n+\n+      procedure Find_Enclosing_Contexts (N : Node_Id) is\n          Par : Node_Id;\n          Top : Node_Id;\n \n@@ -12153,7 +12164,7 @@ package body Exp_Ch4 is\n          --  other controlled values can reuse it.\n \n          if Scope_Is_Transient then\n-            return Node_To_Be_Wrapped;\n+            Hook_Context := Node_To_Be_Wrapped;\n \n          --  In some cases, such as return statements, no transient scope is\n          --  generated, in which case we have to look up in the tree to find\n@@ -12193,7 +12204,8 @@ package body Exp_Ch4 is\n                                              N_Parameter_Association,\n                                              N_Pragma_Argument_Association)\n                then\n-                  return Par;\n+                  Hook_Context := Par;\n+                  goto Hook_Context_Found;\n \n                --  Prevent the search from going too far\n \n@@ -12204,26 +12216,10 @@ package body Exp_Ch4 is\n                Par := Parent (Par);\n             end loop;\n \n-            return Par;\n-\n-         --  Short circuit operators in complex expressions are converted into\n-         --  expression_with_actions.\n+            Hook_Context := Par;\n+            goto Hook_Context_Found;\n \n          else\n-            --  Handle the case where the node is buried deep inside an if\n-            --  statement. The temporary controlled object must be finalized\n-            --  before the then, elsif or else statements are evaluated.\n-\n-            --    if Something\n-            --      and then Ctrl_Func_Call\n-            --    then\n-            --       <result must be finalized at this point>\n-            --       <statements>\n-            --    end if;\n-\n-            --  To achieve this, find the topmost logical operator. Generated\n-            --  actions are then inserted before/after it.\n-\n             Par := N;\n             while Present (Par) loop\n \n@@ -12267,7 +12263,8 @@ package body Exp_Ch4 is\n                                  N_Procedure_Call_Statement,\n                                  N_Simple_Return_Statement)\n                then\n-                  return Par;\n+                  Hook_Context := Par;\n+                  goto Hook_Context_Found;\n \n                --  Prevent the search from going too far\n \n@@ -12280,25 +12277,66 @@ package body Exp_Ch4 is\n \n             --  Return the topmost short circuit operator\n \n-            return Top;\n+            Hook_Context := Top;\n          end if;\n-      end Find_Enclosing_Context;\n+\n+      <<Hook_Context_Found>>\n+\n+         --  Special case for Boolean EWAs: capture expression in a temporary,\n+         --  whose declaration will serve as the context around which to insert\n+         --  finalization code. The finalization thus remains local to the\n+         --  specific condition being evaluated.\n+\n+         if Is_Boolean_Type (Etype (N)) then\n+\n+            --  In this case, the finalization context is chosen so that\n+            --  we know at finalization point that the hook pointer is\n+            --  never null, so no need for a test, we can call the finalizer\n+            --  unconditionally.\n+\n+            Finalize_Always := True;\n+\n+            declare\n+               Loc  : constant Source_Ptr := Sloc (N);\n+               Temp : constant Entity_Id := Make_Temporary (Loc, 'E', N);\n+            begin\n+               Append_To (Actions (N),\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Constant_Present    => True,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Etype (N), Loc),\n+                   Expression          => Expression (N)));\n+               Finalization_Context := Last (Actions (N));\n+\n+               Analyze (Last (Actions (N)));\n+\n+               Set_Expression (N, New_Occurrence_Of (Temp, Loc));\n+               Analyze (Expression (N));\n+            end;\n+\n+         else\n+            Finalize_Always := False;\n+            Finalization_Context := Hook_Context;\n+         end if;\n+      end Find_Enclosing_Contexts;\n \n       --  Local variables\n \n-      Context   : constant Node_Id    := Find_Enclosing_Context (Rel_Node);\n       Loc       : constant Source_Ptr := Sloc (Decl);\n       Obj_Id    : constant Entity_Id  := Defining_Identifier (Decl);\n       Obj_Typ   : constant Node_Id    := Etype (Obj_Id);\n       Desig_Typ : Entity_Id;\n       Expr      : Node_Id;\n-      Fin_Call  : Node_Id;\n+      Fin_Stmts : List_Id;\n       Ptr_Id    : Entity_Id;\n       Temp_Id   : Entity_Id;\n \n    --  Start of processing for Process_Transient_Object\n \n    begin\n+      Find_Enclosing_Contexts (Rel_Node);\n+\n       --  Step 1: Create the access type which provides a reference to the\n       --  transient controlled object.\n \n@@ -12315,7 +12353,7 @@ package body Exp_Ch4 is\n \n       Ptr_Id := Make_Temporary (Loc, 'A');\n \n-      Insert_Action (Context,\n+      Insert_Action (Hook_Context,\n         Make_Full_Type_Declaration (Loc,\n           Defining_Identifier => Ptr_Id,\n           Type_Definition     =>\n@@ -12330,7 +12368,7 @@ package body Exp_Ch4 is\n \n       Temp_Id := Make_Temporary (Loc, 'T');\n \n-      Insert_Action (Context,\n+      Insert_Action (Hook_Context,\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Temp_Id,\n           Object_Definition   => New_Reference_To (Ptr_Id, Loc)));\n@@ -12363,10 +12401,18 @@ package body Exp_Ch4 is\n       --      <or>\n       --    Temp := Obj_Id'Unrestricted_Access;\n \n-      Insert_After_And_Analyze (Decl,\n-        Make_Assignment_Statement (Loc,\n-          Name       => New_Reference_To (Temp_Id, Loc),\n-          Expression => Expr));\n+      if Finalization_Context /= Hook_Context then\n+         Insert_Action (Finalization_Context,\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Temp_Id, Loc),\n+             Expression => Expr));\n+\n+      else\n+         Insert_After_And_Analyze (Decl,\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Temp_Id, Loc),\n+             Expression => Expr));\n+      end if;\n \n       --  Step 4: Finalize the transient controlled object after the context\n       --  has been evaluated/elaborated. Generate:\n@@ -12383,26 +12429,29 @@ package body Exp_Ch4 is\n       --  insert the finalization code after the return statement as this will\n       --  render it unreachable.\n \n-      if Nkind (Context) /= N_Simple_Return_Statement then\n-         Fin_Call :=\n-           Make_Implicit_If_Statement (Decl,\n-             Condition =>\n-               Make_Op_Ne (Loc,\n-                 Left_Opnd  => New_Reference_To (Temp_Id, Loc),\n-                 Right_Opnd => Make_Null (Loc)),\n+      if Nkind (Finalization_Context) /= N_Simple_Return_Statement then\n+         Fin_Stmts := New_List (\n+           Make_Final_Call\n+             (Obj_Ref =>\n+                Make_Explicit_Dereference (Loc,\n+                  Prefix => New_Reference_To (Temp_Id, Loc)),\n+              Typ     => Desig_Typ),\n \n-             Then_Statements => New_List (\n-               Make_Final_Call\n-                 (Obj_Ref =>\n-                    Make_Explicit_Dereference (Loc,\n-                      Prefix => New_Reference_To (Temp_Id, Loc)),\n-                  Typ     => Desig_Typ),\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Reference_To (Temp_Id, Loc),\n+             Expression => Make_Null (Loc)));\n \n-               Make_Assignment_Statement (Loc,\n-                 Name       => New_Reference_To (Temp_Id, Loc),\n-                 Expression => Make_Null (Loc))));\n+         if not Finalize_Always then\n+            Fin_Stmts := New_List (\n+              Make_Implicit_If_Statement (Decl,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd  => New_Reference_To (Temp_Id, Loc),\n+                    Right_Opnd => Make_Null (Loc)),\n+                Then_Statements => Fin_Stmts));\n+         end if;\n \n-         Insert_Action_After (Context, Fin_Call);\n+         Insert_Actions_After (Finalization_Context, Fin_Stmts);\n       end if;\n    end Process_Transient_Object;\n "}, {"sha": "c260207550de4035f477f7183f16422021f54e60", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=064f4527c45595301de59346f8bf3e200a93f966", "patch": "@@ -2706,18 +2706,36 @@ package body Exp_Util is\n         (N : Node_Id;\n          S : Boolean)\n       is\n-         Cond : Node_Id;\n-         Sens : Boolean;\n+         Cond      : Node_Id;\n+         Prev_Cond : Node_Id;\n+         Sens      : Boolean;\n \n       begin\n          Cond := N;\n          Sens := S;\n \n-         --  Deal with NOT operators, inverting sense\n+         loop\n+            Prev_Cond := Cond;\n \n-         while Nkind (Cond) = N_Op_Not loop\n-            Cond := Right_Opnd (Cond);\n-            Sens := not Sens;\n+            --  Deal with NOT operators, inverting sense\n+\n+            while Nkind (Cond) = N_Op_Not loop\n+               Cond := Right_Opnd (Cond);\n+               Sens := not Sens;\n+            end loop;\n+\n+            --  Deal with conversions, qualifications, and expressions with\n+            --  actions.\n+\n+            while Nkind_In (Cond,\n+                    N_Type_Conversion,\n+                    N_Qualified_Expression,\n+                    N_Expression_With_Actions)\n+            loop\n+               Cond := Expression (Cond);\n+            end loop;\n+\n+            exit when Cond = Prev_Cond;\n          end loop;\n \n          --  Deal with AND THEN and AND cases\n@@ -2798,8 +2816,15 @@ package body Exp_Util is\n \n             return;\n \n-            --  Case of Boolean variable reference, return as though the\n-            --  reference had said var = True.\n+         elsif Nkind_In (Cond,\n+                 N_Type_Conversion,\n+                 N_Qualified_Expression,\n+                 N_Expression_With_Actions)\n+         then\n+            Cond := Expression (Cond);\n+\n+         --  Case of Boolean variable reference, return as though the\n+         --  reference had said var = True.\n \n          else\n             if Is_Entity_Name (Cond) and then Ent = Entity (Cond) then\n@@ -3406,8 +3431,13 @@ package body Exp_Util is\n \n             when N_Expression_With_Actions =>\n                if N = Expression (P) then\n-                  Insert_List_After_And_Analyze\n-                    (Last (Actions (P)), Ins_Actions);\n+                  if Is_Empty_List (Actions (P)) then\n+                     Append_List_To (Actions (P), Ins_Actions);\n+                     Analyze_List (Actions (P));\n+                  else\n+                     Insert_List_After_And_Analyze\n+                       (Last (Actions (P)), Ins_Actions);\n+                  end if;\n                   return;\n                end if;\n \n@@ -6702,6 +6732,14 @@ package body Exp_Util is\n             when N_Explicit_Dereference =>\n                return Safe_Prefixed_Reference (N);\n \n+            --  An expression with action is side effect free if its expression\n+            --  is side effect free and it has no actions.\n+\n+            when N_Expression_With_Actions =>\n+               return Is_Empty_List (Actions (N))\n+                        and then\n+                      Side_Effect_Free (Expression (N));\n+\n             --  A call to _rep_to_pos is side effect free, since we generate\n             --  this pure function call ourselves. Moreover it is critically\n             --  important to make this exception, since otherwise we can have\n@@ -7103,7 +7141,6 @@ package body Exp_Util is\n          end if;\n \n          Def_Id := Make_Temporary (Loc, 'R', Exp);\n-         Set_Etype (Def_Id, Exp_Type);\n \n          --  The regular expansion of functions with side effects involves the\n          --  generation of an access type to capture the return value found on\n@@ -7780,7 +7817,14 @@ package body Exp_Util is\n                Set_Entity_Current_Value (Right_Opnd (Cond));\n             end if;\n \n-            --  Check possible boolean variable reference\n+         elsif Nkind_In (Cond,\n+                 N_Type_Conversion,\n+                 N_Qualified_Expression,\n+                 N_Expression_With_Actions)\n+         then\n+            Set_Expression_Current_Value (Expression (Cond));\n+\n+         --  Check possible boolean variable reference\n \n          else\n             Set_Entity_Current_Value (Cond);"}, {"sha": "0ba9d8fa14a0e37b533555196df7341b15bfa262", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=064f4527c45595301de59346f8bf3e200a93f966", "patch": "@@ -7279,6 +7279,16 @@ package body Sem_Ch13 is\n             when N_Qualified_Expression =>\n                return Get_RList (Expression (Exp));\n \n+            --  Expression with actions: if no actions, dig out expression\n+\n+            when N_Expression_With_Actions =>\n+               if Is_Empty_List (Actions (Exp)) then\n+                  return Get_RList (Expression (Exp));\n+\n+               else\n+                  raise Non_Static;\n+               end if;\n+\n             --  Xor operator\n \n             when N_Op_Xor =>"}, {"sha": "ca7310585b4f388ab30c546ca0b9a1f9a58db9a0", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=064f4527c45595301de59346f8bf3e200a93f966", "patch": "@@ -2095,10 +2095,19 @@ package body Sem_Res is\n \n       Check_Parameterless_Call (N);\n \n+      --  The resolution of an Expression_With_Actions is determined by\n+      --  its Expression.\n+\n+      if Nkind (N) = N_Expression_With_Actions then\n+         Resolve (Expression (N), Typ);\n+\n+         Found := True;\n+         Expr_Type := Etype (Expression (N));\n+\n       --  If not overloaded, then we know the type, and all that needs doing\n       --  is to check that this type is compatible with the context.\n \n-      if not Is_Overloaded (N) then\n+      elsif not Is_Overloaded (N) then\n          Found := Covers (Typ, Etype (N));\n          Expr_Type := Etype (N);\n \n@@ -7274,6 +7283,17 @@ package body Sem_Res is\n    procedure Resolve_Expression_With_Actions (N : Node_Id; Typ : Entity_Id) is\n    begin\n       Set_Etype (N, Typ);\n+\n+      --  If N has no actions, and its expression has been constant folded,\n+      --  then rewrite N as just its expression. Note, we can't do this in\n+      --  the general case of Is_Empty_List (Actions (N)) as this would cause\n+      --  Expression (N) to be expanded again.\n+\n+      if Is_Empty_List (Actions (N))\n+        and then Compile_Time_Known_Value (Expression (N))\n+      then\n+         Rewrite (N, Expression (N));\n+      end if;\n    end Resolve_Expression_With_Actions;\n \n    ---------------------------\n@@ -8996,6 +9016,30 @@ package body Sem_Res is\n       R     : constant Node_Id   := Right_Opnd (N);\n \n    begin\n+      --  Ensure all actions associated with the left operand (e.g.\n+      --  finalization of transient controlled objects) are fully evaluated\n+      --  locally within an expression with actions. This is particularly\n+      --  helpful for coverage analysis. However this should not happen in\n+      --  generics.\n+\n+      if Expander_Active then\n+         declare\n+            Reloc_L : constant Node_Id := Relocate_Node (L);\n+         begin\n+            Save_Interps (Old_N => L, New_N => Reloc_L);\n+\n+            Rewrite (L,\n+              Make_Expression_With_Actions (Sloc (L),\n+                Actions    => New_List,\n+                Expression => Reloc_L));\n+\n+            --  Set Comes_From_Source on L to preserve warnings for unset\n+            --  reference.\n+\n+            Set_Comes_From_Source (L, Comes_From_Source (Reloc_L));\n+         end;\n+      end if;\n+\n       Resolve (L, B_Typ);\n       Resolve (R, B_Typ);\n "}, {"sha": "6e9e7fe464fb410ce9fcc157461bc53d414186c3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=064f4527c45595301de59346f8bf3e200a93f966", "patch": "@@ -6777,6 +6777,12 @@ package body Sem_Util is\n                    and then\n                 Has_No_Obvious_Side_Effects (Right_Opnd (N));\n \n+      elsif Nkind (N) = N_Expression_With_Actions\n+              and then\n+            Is_Empty_List (Actions (N))\n+      then\n+         return Has_No_Obvious_Side_Effects (Expression (N));\n+\n       elsif Nkind (N) in N_Has_Entity then\n          return Present (Entity (N))\n            and then Ekind_In (Entity (N), E_Variable,"}, {"sha": "dd6a904daa6ca3bf8376ac743a9576e5b609efa4", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/064f4527c45595301de59346f8bf3e200a93f966/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=064f4527c45595301de59346f8bf3e200a93f966", "patch": "@@ -1310,6 +1310,7 @@ package body Sem_Warn is\n                   UR := Original_Node (UR);\n                   while Nkind (UR) = N_Type_Conversion\n                     or else Nkind (UR) = N_Qualified_Expression\n+                    or else Nkind (UR) = N_Expression_With_Actions\n                   loop\n                      UR := Expression (UR);\n                   end loop;\n@@ -2034,9 +2035,12 @@ package body Sem_Warn is\n                Check_Unset_Reference (Pref);\n             end;\n \n-         --  For type conversions or qualifications examine the expression\n+         --  For type conversions, qualifications, or expressions with actions,\n+         --  examine the expression.\n \n-         when N_Type_Conversion | N_Qualified_Expression =>\n+         when N_Type_Conversion         |\n+              N_Qualified_Expression    |\n+              N_Expression_With_Actions =>\n             Check_Unset_Reference (Expression (N));\n \n          --  For explicit dereference, always check prefix, which will generate"}]}