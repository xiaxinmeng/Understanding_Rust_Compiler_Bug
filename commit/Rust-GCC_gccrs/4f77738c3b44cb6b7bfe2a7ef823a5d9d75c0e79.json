{"sha": "4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79", "node_id": "C_kwDOANBUbNoAKDRmNzc3MzhjM2I0NGNiNmI3YmZlMmE3ZWY4MjNhNWQ5ZDc1YzBlNzk", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-04-14T12:06:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-04-25T07:25:33Z"}, "message": "rtl-optimization/105231 - distribute_notes and REG_EH_REGION\n\nThe following mitigates a problem in combine distribute_notes which\nplaces an original REG_EH_REGION based on only may_trap_p which is\ngood to test whether a non-call insn can possibly throw but not if\nactually it does or we care.  That's something we decided at RTL\nexpansion time where we possibly still know the insn evaluates\nto a constant.\n\nIn fact, the REG_EH_REGION note with lp > 0 can only come from the\noriginal i3 and an assert is added to that effect.  That means we only\nneed to retain the note on i3 or, if that cannot trap, drop it but we\nshould never move it to i2.\n\nThe following places constraints on the insns to combine with\nnon-call exceptions since we cannot handle the case where we\nhave more than one EH side-effect in the IL.  The patch also\nmakes sure we can accumulate that on i3 and do not split\na possible exception raising part of it to i2.  As a special\ncase we do not place any restriction on all externally\nthrowing insns when there is no REG_EH_REGION present.\n\n2022-04-22  Richard Biener  <rguenther@suse.de>\n\n\tPR rtl-optimization/105231\n\t* combine.cc (distribute_notes): Assert that a REG_EH_REGION\n\twith landing pad > 0 is from i3.  Put any REG_EH_REGION note\n\ton i3 or drop it if the insn can not trap.\n\t(try_combine): Ensure that we can merge REG_EH_REGION notes\n\twith non-call exceptions.  Ensure we are not splitting a\n\ttrapping part of an insn with non-call exceptions when there\n\tis any REG_EH_REGION note to preserve.\n\n\t* gcc.dg/torture/pr105231.c: New testcase.", "tree": {"sha": "ade51b6bef8f3501aa2b7e14fd056f0d205697bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ade51b6bef8f3501aa2b7e14fd056f0d205697bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c940d42701707559fabe49be99296f60fbc43e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c940d42701707559fabe49be99296f60fbc43e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c940d42701707559fabe49be99296f60fbc43e7"}], "stats": {"total": 96, "additions": 78, "deletions": 18}, "files": [{"sha": "9a34ef847aaddfdc4c56fc4cc57616627a47c30f", "filename": "gcc/combine.cc", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79/gcc%2Fcombine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79/gcc%2Fcombine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.cc?ref=4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79", "patch": "@@ -2569,6 +2569,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n   rtx new_other_notes;\n   int i;\n   scalar_int_mode dest_mode, temp_mode;\n+  bool has_non_call_exception = false;\n \n   /* Immediately return if any of I0,I1,I2 are the same insn (I3 can\n      never be).  */\n@@ -2951,6 +2952,32 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       return 0;\n     }\n \n+  /* With non-call exceptions we can end up trying to combine multiple\n+     insns with possible EH side effects.  Make sure we can combine\n+     that to a single insn which means there must be at most one insn\n+     in the combination with an EH side effect.  */\n+  if (cfun->can_throw_non_call_exceptions)\n+    {\n+      if (find_reg_note (i3, REG_EH_REGION, NULL_RTX)\n+\t  || find_reg_note (i2, REG_EH_REGION, NULL_RTX)\n+\t  || (i1 && find_reg_note (i1, REG_EH_REGION, NULL_RTX))\n+\t  || (i0 && find_reg_note (i0, REG_EH_REGION, NULL_RTX)))\n+\t{\n+\t  has_non_call_exception = true;\n+\t  if (insn_could_throw_p (i3)\n+\t      + insn_could_throw_p (i2)\n+\t      + (i1 ? insn_could_throw_p (i1) : 0)\n+\t      + (i0 ? insn_could_throw_p (i0) : 0) > 1)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Can't combine multiple insns with EH \"\n+\t\t\t \"side-effects\\n\");\n+\t      undo_all ();\n+\t      return 0;\n+\t    }\n+\t}\n+    }\n+\n   /* Record whether i2 and i3 are trivial moves.  */\n   i2_was_move = is_just_move (i2);\n   i3_was_move = is_just_move (i3);\n@@ -3685,7 +3712,13 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t      || !modified_between_p (*split, i2, i3))\n \t  /* We can't overwrite I2DEST if its value is still used by\n \t     NEWPAT.  */\n-\t  && ! reg_referenced_p (i2dest, newpat))\n+\t  && ! reg_referenced_p (i2dest, newpat)\n+\t  /* We should not split a possibly trapping part when we\n+\t     care about non-call EH and have REG_EH_REGION notes\n+\t     to distribute.  */\n+\t  && ! (cfun->can_throw_non_call_exceptions\n+\t\t&& has_non_call_exception\n+\t\t&& may_trap_p (*split)))\n \t{\n \t  rtx newdest = i2dest;\n \t  enum rtx_code split_code = GET_CODE (*split);\n@@ -14175,23 +14208,35 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \t  break;\n \n \tcase REG_EH_REGION:\n-\t  /* These notes must remain with the call or trapping instruction.  */\n-\t  if (CALL_P (i3))\n-\t    place = i3;\n-\t  else if (i2 && CALL_P (i2))\n-\t    place = i2;\n-\t  else\n-\t    {\n-\t      gcc_assert (cfun->can_throw_non_call_exceptions);\n-\t      if (may_trap_p (i3))\n-\t\tplace = i3;\n-\t      else if (i2 && may_trap_p (i2))\n-\t\tplace = i2;\n-\t      /* ??? Otherwise assume we've combined things such that we\n-\t\t can now prove that the instructions can't trap.  Drop the\n-\t\t note in this case.  */\n-\t    }\n-\t  break;\n+\t  {\n+\t    /* The landing pad handling needs to be kept in sync with the\n+\t       prerequisite checking in try_combine.  */\n+\t    int lp_nr = INTVAL (XEXP (note, 0));\n+\t    /* A REG_EH_REGION note transfering control can only ever come\n+\t       from i3.  */\n+\t    if (lp_nr > 0)\n+\t      gcc_assert (from_insn == i3);\n+\t    /* We are making sure there is a single effective REG_EH_REGION\n+\t       note and it's valid to put it on i3.  */\n+\t    if (!insn_could_throw_p (from_insn))\n+\t      /* Throw away stra notes on insns that can never throw.  */\n+\t      ;\n+\t    else\n+\t      {\n+\t\tif (CALL_P (i3))\n+\t\t  place = i3;\n+\t\telse\n+\t\t  {\n+\t\t    gcc_assert (cfun->can_throw_non_call_exceptions);\n+\t\t    /* If i3 can still trap preserve the note, otherwise we've\n+\t\t       combined things such that we can now prove that the\n+\t\t       instructions can't trap.  Drop the note in this case.  */\n+\t\t    if (may_trap_p (i3))\n+\t\t      place = i3;\n+\t\t  }\n+\t      }\n+\t    break;\n+\t  }\n \n \tcase REG_ARGS_SIZE:\n \t  /* ??? How to distribute between i3-i1.  Assume i3 contains the"}, {"sha": "00121fd8d1ea51ba644cc38a55c4ccc07ee5dfb7", "filename": "gcc/testsuite/gcc.dg/torture/pr105231.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105231.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105231.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr105231.c?ref=4f77738c3b44cb6b7bfe2a7ef823a5d9d75c0e79", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target dfp } */\n+/* { dg-additional-options \"-fsanitize-coverage=trace-pc -fnon-call-exceptions --param=max-cse-insns=1 -frounding-math\" } */\n+/* { dg-additional-options \"-mstack-arg-probe\" { target x86_64-*-* i?86-*-* } } */\n+\n+void baz (int *);\n+void bar (double, double, _Decimal64);\n+\n+void\n+foo (void)\n+{\n+  int s __attribute__((cleanup (baz)));\n+  bar (0xfffffffffffffffe, 0xebf3fff2fbebaf7f, 0xffffffffffffff);\n+}"}]}