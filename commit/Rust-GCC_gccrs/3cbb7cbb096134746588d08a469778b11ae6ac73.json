{"sha": "3cbb7cbb096134746588d08a469778b11ae6ac73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NiYjdjYmIwOTYxMzQ3NDY1ODhkMDhhNDY5Nzc4YjExYWU2YWM3Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-08T14:21:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-08T14:21:30Z"}, "message": "libgo: update to Go 1.11.1 release\n    \n    Reviewed-on: https://go-review.googlesource.com/c/140277\n\nFrom-SVN: r264932", "tree": {"sha": "eff67e0dc5d748e398ea1a7ffa36f6a3bbda072b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eff67e0dc5d748e398ea1a7ffa36f6a3bbda072b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cbb7cbb096134746588d08a469778b11ae6ac73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cbb7cbb096134746588d08a469778b11ae6ac73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cbb7cbb096134746588d08a469778b11ae6ac73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cbb7cbb096134746588d08a469778b11ae6ac73/comments", "author": null, "committer": null, "parents": [{"sha": "a3368b8ea1bda5edd41900096b10514bcf7c6de7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3368b8ea1bda5edd41900096b10514bcf7c6de7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3368b8ea1bda5edd41900096b10514bcf7c6de7"}], "stats": {"total": 566, "additions": 399, "deletions": 167}, "files": [{"sha": "6e783c96d6d4021199699ac4b18bec4485858ec8", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -1,4 +1,4 @@\n-d0739c13ca3686df1f8d0fae7c6c5caaed058503\n+a9da4d34a2f878a5058f7e7d2beef52aa62471a1\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b2803e871c5f759fe08d8d8991b7ccd18d31df48", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -1,4 +1,4 @@\n-41e62b8c49d21659b48a95216e3062032285250f\n+26957168c4c0cdcc7ca4f0b19d0eb19474d224ac\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "0ff4ff61d198186b956c60c8596a89213baf6621", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -1 +1 @@\n-go1.11\n+go1.11.1"}, {"sha": "1060e779c1b6e7d6978c37b1cfc74e836511de9d", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -1449,6 +1449,12 @@\n // \t\tThe directory where the go command will write\n // \t\ttemporary source files, packages, and binaries.\n //\n+// Each entry in the GOFLAGS list must be a standalone flag.\n+// Because the entries are space-separated, flag values must\n+// not contain spaces. In some cases, you can provide multiple flag\n+// values instead: for example, to set '-ldflags=-s -w'\n+// you can use 'GOFLAGS=-ldflags=-s -ldflags=-w'.\n+//\n // Environment variables for use with cgo:\n //\n // \tCC"}, {"sha": "e2c4e61615bcc7c63539101ba68ec2d2ee44df52", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -507,6 +507,12 @@ General-purpose environment variables:\n \t\tThe directory where the go command will write\n \t\ttemporary source files, packages, and binaries.\n \n+Each entry in the GOFLAGS list must be a standalone flag.\n+Because the entries are space-separated, flag values must\n+not contain spaces. In some cases, you can provide multiple flag\n+values instead: for example, to set '-ldflags=-s -w'\n+you can use 'GOFLAGS=-ldflags=-s -ldflags=-w'.\n+\n Environment variables for use with cgo:\n \n \tCC"}, {"sha": "8aba293dd345ea574f422c5520d6f94cded2f409", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -224,7 +224,9 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \t\tif len(p.SFiles) > 0 {\n \t\t\tfmt.Fprintf(h, \"asm %q %q %q\\n\", b.toolID(\"asm\"), forcedAsmflags, p.Internal.Asmflags)\n \t\t}\n-\t\tfmt.Fprintf(h, \"GO$GOARCH=%s\\n\", os.Getenv(\"GO\"+strings.ToUpper(cfg.BuildContext.GOARCH))) // GO386, GOARM, etc\n+\t\t// GO386, GOARM, GOMIPS, etc.\n+\t\tbaseArch := strings.TrimSuffix(cfg.BuildContext.GOARCH, \"le\")\n+\t\tfmt.Fprintf(h, \"GO$GOARCH=%s\\n\", os.Getenv(\"GO\"+strings.ToUpper(baseArch)))\n \n \t\t// TODO(rsc): Convince compiler team not to add more magic environment variables,\n \t\t// or perhaps restrict the environment variables passed to subprocesses."}, {"sha": "2132c5f3e15f41597a8a1f9656c9ef54e343aa7c", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -170,6 +170,7 @@ var validLinkerFlags = []*regexp.Regexp{\n \tre(`-Wl,-e[=,][a-zA-Z0-9]*`),\n \tre(`-Wl,--enable-new-dtags`),\n \tre(`-Wl,--end-group`),\n+\tre(`-Wl,--(no-)?export-dynamic`),\n \tre(`-Wl,-framework,[^,@\\-][^,]+`),\n \tre(`-Wl,-headerpad_max_install_names`),\n \tre(`-Wl,--no-undefined`),"}, {"sha": "6399faac0f456f93a813fbd4a47fb49d4a27d240", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -635,6 +635,9 @@ func scriptMatch(ts *testScript, neg bool, args []string, text, name string) {\n \t\ttext = string(data)\n \t}\n \n+\t// Matching against workdir would be misleading.\n+\ttext = strings.Replace(text, ts.workdir, \"$WORK\", -1)\n+\n \tif neg {\n \t\tif re.MatchString(text) {\n \t\t\tif isGrep {"}, {"sha": "0b75778a03840da7e75c57c94da8546372d1a605", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -894,8 +894,8 @@ func validHostname(host string) bool {\n \t\t\tif c == '-' && j != 0 {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif c == '_' {\n-\t\t\t\t// _ is not a valid character in hostnames, but it's commonly\n+\t\t\tif c == '_' || c == ':' {\n+\t\t\t\t// Not valid characters in hostnames, but commonly\n \t\t\t\t// found in deployments outside the WebPKI.\n \t\t\t\tcontinue\n \t\t\t}"}, {"sha": "0e24d3b5da3af3218f8d63992811ef674eba1ba8", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -1881,6 +1881,7 @@ func TestValidHostname(t *testing.T) {\n \t\t{\"foo.*.example.com\", false},\n \t\t{\"exa_mple.com\", true},\n \t\t{\"foo,bar\", false},\n+\t\t{\"project-dev:us-central1:main\", true},\n \t}\n \tfor _, tt := range tests {\n \t\tif got := validHostname(tt.host); got != tt.want {"}, {"sha": "7d235087e60f4bb998e4c5e862f27990f1b59034", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -672,6 +672,7 @@ func (d *decodeState) object(v reflect.Value) error {\n \t}\n \n \tvar mapElem reflect.Value\n+\toriginalErrorContext := d.errorContext\n \n \tfor {\n \t\t// Read opening \" of string key or closing }.\n@@ -832,8 +833,7 @@ func (d *decodeState) object(v reflect.Value) error {\n \t\t\treturn errPhase\n \t\t}\n \n-\t\td.errorContext.Struct = \"\"\n-\t\td.errorContext.Field = \"\"\n+\t\td.errorContext = originalErrorContext\n \t}\n \treturn nil\n }\n@@ -991,7 +991,7 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool\n \t\t\tif fromQuoted {\n \t\t\t\treturn fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type())\n \t\t\t}\n-\t\t\treturn &UnmarshalTypeError{Value: \"number\", Type: v.Type(), Offset: int64(d.readIndex())}\n+\t\t\td.saveError(&UnmarshalTypeError{Value: \"number\", Type: v.Type(), Offset: int64(d.readIndex())})\n \t\tcase reflect.Interface:\n \t\t\tn, err := d.convertNumber(s)\n \t\t\tif err != nil {"}, {"sha": "5746ddf9861e7e1f672ad92a5b6479331b868aa9", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -371,6 +371,10 @@ func (b *intWithPtrMarshalText) UnmarshalText(data []byte) error {\n \treturn (*intWithMarshalText)(b).UnmarshalText(data)\n }\n \n+type mapStringToStringData struct {\n+\tData map[string]string `json:\"data\"`\n+}\n+\n type unmarshalTest struct {\n \tin                    string\n \tptr                   interface{}\n@@ -401,6 +405,7 @@ var unmarshalTests = []unmarshalTest{\n \t{in: `\"invalid: \\uD834x\\uDD1E\"`, ptr: new(string), out: \"invalid: \\uFFFDx\\uFFFD\"},\n \t{in: \"null\", ptr: new(interface{}), out: nil},\n \t{in: `{\"X\": [1,2,3], \"Y\": 4}`, ptr: new(T), out: T{Y: 4}, err: &UnmarshalTypeError{\"array\", reflect.TypeOf(\"\"), 7, \"T\", \"X\"}},\n+\t{in: `{\"X\": 23}`, ptr: new(T), out: T{}, err: &UnmarshalTypeError{\"number\", reflect.TypeOf(\"\"), 8, \"T\", \"X\"}}, {in: `{\"x\": 1}`, ptr: new(tx), out: tx{}},\n \t{in: `{\"x\": 1}`, ptr: new(tx), out: tx{}},\n \t{in: `{\"x\": 1}`, ptr: new(tx), err: fmt.Errorf(\"json: unknown field \\\"x\\\"\"), disallowUnknownFields: true},\n \t{in: `{\"F1\":1,\"F2\":2,\"F3\":3}`, ptr: new(V), out: V{F1: float64(1), F2: int32(2), F3: Number(\"3\")}},\n@@ -866,6 +871,18 @@ var unmarshalTests = []unmarshalTest{\n \t\terr:                   fmt.Errorf(\"json: unknown field \\\"extra\\\"\"),\n \t\tdisallowUnknownFields: true,\n \t},\n+\t// issue 26444\n+\t// UnmarshalTypeError without field & struct values\n+\t{\n+\t\tin:  `{\"data\":{\"test1\": \"bob\", \"test2\": 123}}`,\n+\t\tptr: new(mapStringToStringData),\n+\t\terr: &UnmarshalTypeError{Value: \"number\", Type: reflect.TypeOf(\"\"), Offset: 37, Struct: \"mapStringToStringData\", Field: \"data\"},\n+\t},\n+\t{\n+\t\tin:  `{\"data\":{\"test1\": 123, \"test2\": \"bob\"}}`,\n+\t\tptr: new(mapStringToStringData),\n+\t\terr: &UnmarshalTypeError{Value: \"number\", Type: reflect.TypeOf(\"\"), Offset: 21, Struct: \"mapStringToStringData\", Field: \"data\"},\n+\t},\n }\n \n func TestMarshal(t *testing.T) {"}, {"sha": "35050e1b9eb588991af2310fad323272b9b77e39", "filename": "libgo/go/go/types/api_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -262,6 +262,8 @@ func TestTypesInfo(t *testing.T) {\n \t\t{`package x0; func _() { var x struct {f string}; x.f := 0 }`, `x.f`, `string`},\n \t\t{`package x1; func _() { var z string; type x struct {f string}; y := &x{q: z}}`, `z`, `string`},\n \t\t{`package x2; func _() { var a, b string; type x struct {f string}; z := &x{f: a; f: b;}}`, `b`, `string`},\n+\t\t{`package x3; var x = panic(\"\");`, `panic`, `func(interface{})`},\n+\t\t{`package x4; func _() { panic(\"\") }`, `panic`, `func(interface{})`},\n \t}\n \n \tfor _, test := range tests {"}, {"sha": "d3f0c4d40dfb1dead02852227521e0ca54e3ccd8", "filename": "libgo/go/go/types/builtins.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -476,7 +476,7 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \t\t// panic(x)\n \t\t// record panic call if inside a function with result parameters\n \t\t// (for use in Checker.isTerminating)\n-\t\tif check.sig.results.Len() > 0 {\n+\t\tif check.sig != nil && check.sig.results.Len() > 0 {\n \t\t\t// function has result parameters\n \t\t\tp := check.isPanic\n \t\t\tif p == nil {"}, {"sha": "3b0293025d9fdee2256bf8fad169f6487252fa68", "filename": "libgo/go/net/dnsclient_unix.go", "status": "modified", "additions": 70, "deletions": 45, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -27,6 +27,20 @@ import (\n \t\"golang_org/x/net/dns/dnsmessage\"\n )\n \n+var (\n+\terrLameReferral              = errors.New(\"lame referral\")\n+\terrCannotUnmarshalDNSMessage = errors.New(\"cannot unmarshal DNS message\")\n+\terrCannotMarshalDNSMessage   = errors.New(\"cannot marshal DNS message\")\n+\terrServerMisbehaving         = errors.New(\"server misbehaving\")\n+\terrInvalidDNSResponse        = errors.New(\"invalid DNS response\")\n+\terrNoAnswerFromDNSServer     = errors.New(\"no answer from DNS server\")\n+\n+\t// errServerTemporarlyMisbehaving is like errServerMisbehaving, except\n+\t// that when it gets translated to a DNSError, the IsTemporary field\n+\t// gets set to true.\n+\terrServerTemporarlyMisbehaving = errors.New(\"server misbehaving\")\n+)\n+\n func newRequest(q dnsmessage.Question) (id uint16, udpReq, tcpReq []byte, err error) {\n \tid = uint16(rand.Int()) ^ uint16(time.Now().UnixNano())\n \tb := dnsmessage.NewBuilder(make([]byte, 2, 514), dnsmessage.Header{ID: id, RecursionDesired: true})\n@@ -105,14 +119,14 @@ func dnsStreamRoundTrip(c Conn, id uint16, query dnsmessage.Question, b []byte)\n \tvar p dnsmessage.Parser\n \th, err := p.Start(b[:n])\n \tif err != nil {\n-\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errors.New(\"cannot unmarshal DNS message\")\n+\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errCannotUnmarshalDNSMessage\n \t}\n \tq, err := p.Question()\n \tif err != nil {\n-\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errors.New(\"cannot unmarshal DNS message\")\n+\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errCannotUnmarshalDNSMessage\n \t}\n \tif !checkResponse(id, query, h, q) {\n-\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errors.New(\"invalid DNS response\")\n+\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errInvalidDNSResponse\n \t}\n \treturn p, h, nil\n }\n@@ -122,7 +136,7 @@ func (r *Resolver) exchange(ctx context.Context, server string, q dnsmessage.Que\n \tq.Class = dnsmessage.ClassINET\n \tid, udpReq, tcpReq, err := newRequest(q)\n \tif err != nil {\n-\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errors.New(\"cannot marshal DNS message\")\n+\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errCannotMarshalDNSMessage\n \t}\n \tfor _, network := range []string{\"udp\", \"tcp\"} {\n \t\tctx, cancel := context.WithDeadline(ctx, time.Now().Add(timeout))\n@@ -147,31 +161,31 @@ func (r *Resolver) exchange(ctx context.Context, server string, q dnsmessage.Que\n \t\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, mapErr(err)\n \t\t}\n \t\tif err := p.SkipQuestion(); err != dnsmessage.ErrSectionDone {\n-\t\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errors.New(\"invalid DNS response\")\n+\t\t\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errInvalidDNSResponse\n \t\t}\n \t\tif h.Truncated { // see RFC 5966\n \t\t\tcontinue\n \t\t}\n \t\treturn p, h, nil\n \t}\n-\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errors.New(\"no answer from DNS server\")\n+\treturn dnsmessage.Parser{}, dnsmessage.Header{}, errNoAnswerFromDNSServer\n }\n \n // checkHeader performs basic sanity checks on the header.\n func checkHeader(p *dnsmessage.Parser, h dnsmessage.Header, name, server string) error {\n+\tif h.RCode == dnsmessage.RCodeNameError {\n+\t\treturn errNoSuchHost\n+\t}\n+\n \t_, err := p.AnswerHeader()\n \tif err != nil && err != dnsmessage.ErrSectionDone {\n-\t\treturn &DNSError{\n-\t\t\tErr:    \"cannot unmarshal DNS message\",\n-\t\t\tName:   name,\n-\t\t\tServer: server,\n-\t\t}\n+\t\treturn errCannotUnmarshalDNSMessage\n \t}\n \n \t// libresolv continues to the next server when it receives\n \t// an invalid referral response. See golang.org/issue/15434.\n \tif h.RCode == dnsmessage.RCodeSuccess && !h.Authoritative && !h.RecursionAvailable && err == dnsmessage.ErrSectionDone {\n-\t\treturn &DNSError{Err: \"lame referral\", Name: name, Server: server}\n+\t\treturn errLameReferral\n \t}\n \n \tif h.RCode != dnsmessage.RCodeSuccess && h.RCode != dnsmessage.RCodeNameError {\n@@ -180,11 +194,10 @@ func checkHeader(p *dnsmessage.Parser, h dnsmessage.Header, name, server string)\n \t\t// a name error and we didn't get success,\n \t\t// the server is behaving incorrectly or\n \t\t// having temporary trouble.\n-\t\terr := &DNSError{Err: \"server misbehaving\", Name: name, Server: server}\n \t\tif h.RCode == dnsmessage.RCodeServerFailure {\n-\t\t\terr.IsTemporary = true\n+\t\t\treturn errServerTemporarlyMisbehaving\n \t\t}\n-\t\treturn err\n+\t\treturn errServerMisbehaving\n \t}\n \n \treturn nil\n@@ -194,28 +207,16 @@ func skipToAnswer(p *dnsmessage.Parser, qtype dnsmessage.Type, name, server stri\n \tfor {\n \t\th, err := p.AnswerHeader()\n \t\tif err == dnsmessage.ErrSectionDone {\n-\t\t\treturn &DNSError{\n-\t\t\t\tErr:    errNoSuchHost.Error(),\n-\t\t\t\tName:   name,\n-\t\t\t\tServer: server,\n-\t\t\t}\n+\t\t\treturn errNoSuchHost\n \t\t}\n \t\tif err != nil {\n-\t\t\treturn &DNSError{\n-\t\t\t\tErr:    \"cannot unmarshal DNS message\",\n-\t\t\t\tName:   name,\n-\t\t\t\tServer: server,\n-\t\t\t}\n+\t\t\treturn errCannotUnmarshalDNSMessage\n \t\t}\n \t\tif h.Type == qtype {\n \t\t\treturn nil\n \t\t}\n \t\tif err := p.SkipAnswer(); err != nil {\n-\t\t\treturn &DNSError{\n-\t\t\t\tErr:    \"cannot unmarshal DNS message\",\n-\t\t\t\tName:   name,\n-\t\t\t\tServer: server,\n-\t\t\t}\n+\t\t\treturn errCannotUnmarshalDNSMessage\n \t\t}\n \t}\n }\n@@ -229,7 +230,7 @@ func (r *Resolver) tryOneName(ctx context.Context, cfg *dnsConfig, name string,\n \n \tn, err := dnsmessage.NewName(name)\n \tif err != nil {\n-\t\treturn dnsmessage.Parser{}, \"\", errors.New(\"cannot marshal DNS message\")\n+\t\treturn dnsmessage.Parser{}, \"\", errCannotMarshalDNSMessage\n \t}\n \tq := dnsmessage.Question{\n \t\tName:  n,\n@@ -243,38 +244,62 @@ func (r *Resolver) tryOneName(ctx context.Context, cfg *dnsConfig, name string,\n \n \t\t\tp, h, err := r.exchange(ctx, server, q, cfg.timeout)\n \t\t\tif err != nil {\n-\t\t\t\tlastErr = &DNSError{\n+\t\t\t\tdnsErr := &DNSError{\n \t\t\t\t\tErr:    err.Error(),\n \t\t\t\t\tName:   name,\n \t\t\t\t\tServer: server,\n \t\t\t\t}\n \t\t\t\tif nerr, ok := err.(Error); ok && nerr.Timeout() {\n-\t\t\t\t\tlastErr.(*DNSError).IsTimeout = true\n+\t\t\t\t\tdnsErr.IsTimeout = true\n \t\t\t\t}\n \t\t\t\t// Set IsTemporary for socket-level errors. Note that this flag\n \t\t\t\t// may also be used to indicate a SERVFAIL response.\n \t\t\t\tif _, ok := err.(*OpError); ok {\n-\t\t\t\t\tlastErr.(*DNSError).IsTemporary = true\n+\t\t\t\t\tdnsErr.IsTemporary = true\n \t\t\t\t}\n+\t\t\t\tlastErr = dnsErr\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\t// The name does not exist, so trying another server won't help.\n-\t\t\t//\n-\t\t\t// TODO: indicate this in a more obvious way, such as a field on DNSError?\n-\t\t\tif h.RCode == dnsmessage.RCodeNameError {\n-\t\t\t\treturn dnsmessage.Parser{}, \"\", &DNSError{Err: errNoSuchHost.Error(), Name: name, Server: server}\n-\t\t\t}\n-\n-\t\t\tlastErr = checkHeader(&p, h, name, server)\n-\t\t\tif lastErr != nil {\n+\t\t\tif err := checkHeader(&p, h, name, server); err != nil {\n+\t\t\t\tdnsErr := &DNSError{\n+\t\t\t\t\tErr:    err.Error(),\n+\t\t\t\t\tName:   name,\n+\t\t\t\t\tServer: server,\n+\t\t\t\t}\n+\t\t\t\tif err == errServerTemporarlyMisbehaving {\n+\t\t\t\t\tdnsErr.IsTemporary = true\n+\t\t\t\t}\n+\t\t\t\tif err == errNoSuchHost {\n+\t\t\t\t\t// The name does not exist, so trying\n+\t\t\t\t\t// another server won't help.\n+\t\t\t\t\t//\n+\t\t\t\t\t// TODO: indicate this in a more\n+\t\t\t\t\t// obvious way, such as a field on\n+\t\t\t\t\t// DNSError?\n+\t\t\t\t\treturn p, server, dnsErr\n+\t\t\t\t}\n+\t\t\t\tlastErr = dnsErr\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\tlastErr = skipToAnswer(&p, qtype, name, server)\n-\t\t\tif lastErr == nil {\n+\t\t\terr = skipToAnswer(&p, qtype, name, server)\n+\t\t\tif err == nil {\n \t\t\t\treturn p, server, nil\n \t\t\t}\n+\t\t\tlastErr = &DNSError{\n+\t\t\t\tErr:    err.Error(),\n+\t\t\t\tName:   name,\n+\t\t\t\tServer: server,\n+\t\t\t}\n+\t\t\tif err == errNoSuchHost {\n+\t\t\t\t// The name does not exist, so trying another\n+\t\t\t\t// server won't help.\n+\t\t\t\t//\n+\t\t\t\t// TODO: indicate this in a more obvious way,\n+\t\t\t\t// such as a field on DNSError?\n+\t\t\t\treturn p, server, lastErr\n+\t\t\t}\n \t\t}\n \t}\n \treturn dnsmessage.Parser{}, \"\", lastErr"}, {"sha": "8992480b6ac71ed6cbf40f2efd52cd3ba71953a0", "filename": "libgo/go/net/dnsclient_unix_test.go", "status": "modified", "additions": 141, "deletions": 55, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -1427,28 +1427,35 @@ func TestDNSGoroutineRace(t *testing.T) {\n \t}\n }\n \n+func lookupWithFake(fake fakeDNSServer, name string, typ dnsmessage.Type) error {\n+\tr := Resolver{PreferGo: true, Dial: fake.DialContext}\n+\n+\tresolvConf.mu.RLock()\n+\tconf := resolvConf.dnsConfig\n+\tresolvConf.mu.RUnlock()\n+\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tdefer cancel()\n+\n+\t_, _, err := r.tryOneName(ctx, conf, name, typ)\n+\treturn err\n+}\n+\n // Issue 8434: verify that Temporary returns true on an error when rcode\n // is SERVFAIL\n func TestIssue8434(t *testing.T) {\n-\tmsg := dnsmessage.Message{\n-\t\tHeader: dnsmessage.Header{\n-\t\t\tRCode: dnsmessage.RCodeServerFailure,\n+\terr := lookupWithFake(fakeDNSServer{\n+\t\trh: func(n, _ string, q dnsmessage.Message, _ time.Time) (dnsmessage.Message, error) {\n+\t\t\treturn dnsmessage.Message{\n+\t\t\t\tHeader: dnsmessage.Header{\n+\t\t\t\t\tID:       q.ID,\n+\t\t\t\t\tResponse: true,\n+\t\t\t\t\tRCode:    dnsmessage.RCodeServerFailure,\n+\t\t\t\t},\n+\t\t\t\tQuestions: q.Questions,\n+\t\t\t}, nil\n \t\t},\n-\t}\n-\tb, err := msg.Pack()\n-\tif err != nil {\n-\t\tt.Fatal(\"Pack failed:\", err)\n-\t}\n-\tvar p dnsmessage.Parser\n-\th, err := p.Start(b)\n-\tif err != nil {\n-\t\tt.Fatal(\"Start failed:\", err)\n-\t}\n-\tif err := p.SkipAllQuestions(); err != nil {\n-\t\tt.Fatal(\"SkipAllQuestions failed:\", err)\n-\t}\n-\n-\terr = checkHeader(&p, h, \"golang.org\", \"foo:53\")\n+\t}, \"golang.org.\", dnsmessage.TypeALL)\n \tif err == nil {\n \t\tt.Fatal(\"expected an error\")\n \t}\n@@ -1464,50 +1471,76 @@ func TestIssue8434(t *testing.T) {\n \t}\n }\n \n-// Issue 12778: verify that NXDOMAIN without RA bit errors as\n-// \"no such host\" and not \"server misbehaving\"\n+// TestNoSuchHost verifies that tryOneName works correctly when the domain does\n+// not exist.\n+//\n+// Issue 12778: verify that NXDOMAIN without RA bit errors as \"no such host\"\n+// and not \"server misbehaving\"\n //\n // Issue 25336: verify that NXDOMAIN errors fail fast.\n-func TestIssue12778(t *testing.T) {\n-\tlookups := 0\n-\tfake := fakeDNSServer{\n-\t\trh: func(n, _ string, q dnsmessage.Message, _ time.Time) (dnsmessage.Message, error) {\n-\t\t\tlookups++\n-\t\t\treturn dnsmessage.Message{\n-\t\t\t\tHeader: dnsmessage.Header{\n-\t\t\t\t\tID:                 q.ID,\n-\t\t\t\t\tResponse:           true,\n-\t\t\t\t\tRCode:              dnsmessage.RCodeNameError,\n-\t\t\t\t\tRecursionAvailable: false,\n-\t\t\t\t},\n-\t\t\t\tQuestions: q.Questions,\n-\t\t\t}, nil\n+//\n+// Issue 27525: verify that empty answers fail fast.\n+func TestNoSuchHost(t *testing.T) {\n+\ttests := []struct {\n+\t\tname string\n+\t\tf    func(string, string, dnsmessage.Message, time.Time) (dnsmessage.Message, error)\n+\t}{\n+\t\t{\n+\t\t\t\"NXDOMAIN\",\n+\t\t\tfunc(n, _ string, q dnsmessage.Message, _ time.Time) (dnsmessage.Message, error) {\n+\t\t\t\treturn dnsmessage.Message{\n+\t\t\t\t\tHeader: dnsmessage.Header{\n+\t\t\t\t\t\tID:                 q.ID,\n+\t\t\t\t\t\tResponse:           true,\n+\t\t\t\t\t\tRCode:              dnsmessage.RCodeNameError,\n+\t\t\t\t\t\tRecursionAvailable: false,\n+\t\t\t\t\t},\n+\t\t\t\t\tQuestions: q.Questions,\n+\t\t\t\t}, nil\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t\"no answers\",\n+\t\t\tfunc(n, _ string, q dnsmessage.Message, _ time.Time) (dnsmessage.Message, error) {\n+\t\t\t\treturn dnsmessage.Message{\n+\t\t\t\t\tHeader: dnsmessage.Header{\n+\t\t\t\t\t\tID:                 q.ID,\n+\t\t\t\t\t\tResponse:           true,\n+\t\t\t\t\t\tRCode:              dnsmessage.RCodeSuccess,\n+\t\t\t\t\t\tRecursionAvailable: false,\n+\t\t\t\t\t\tAuthoritative:      true,\n+\t\t\t\t\t},\n+\t\t\t\t\tQuestions: q.Questions,\n+\t\t\t\t}, nil\n+\t\t\t},\n \t\t},\n \t}\n-\tr := Resolver{PreferGo: true, Dial: fake.DialContext}\n-\n-\tresolvConf.mu.RLock()\n-\tconf := resolvConf.dnsConfig\n-\tresolvConf.mu.RUnlock()\n-\n-\tctx, cancel := context.WithCancel(context.Background())\n-\tdefer cancel()\n \n-\t_, _, err := r.tryOneName(ctx, conf, \".\", dnsmessage.TypeALL)\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tlookups := 0\n+\t\t\terr := lookupWithFake(fakeDNSServer{\n+\t\t\t\trh: func(n, s string, q dnsmessage.Message, d time.Time) (dnsmessage.Message, error) {\n+\t\t\t\t\tlookups++\n+\t\t\t\t\treturn test.f(n, s, q, d)\n+\t\t\t\t},\n+\t\t\t}, \".\", dnsmessage.TypeALL)\n \n-\tif lookups != 1 {\n-\t\tt.Errorf(\"got %d lookups, wanted 1\", lookups)\n-\t}\n+\t\t\tif lookups != 1 {\n+\t\t\t\tt.Errorf(\"got %d lookups, wanted 1\", lookups)\n+\t\t\t}\n \n-\tif err == nil {\n-\t\tt.Fatal(\"expected an error\")\n-\t}\n-\tde, ok := err.(*DNSError)\n-\tif !ok {\n-\t\tt.Fatalf(\"err = %#v; wanted a *net.DNSError\", err)\n-\t}\n-\tif de.Err != errNoSuchHost.Error() {\n-\t\tt.Fatalf(\"Err = %#v; wanted %q\", de.Err, errNoSuchHost.Error())\n+\t\t\tif err == nil {\n+\t\t\t\tt.Fatal(\"expected an error\")\n+\t\t\t}\n+\t\t\tde, ok := err.(*DNSError)\n+\t\t\tif !ok {\n+\t\t\t\tt.Fatalf(\"err = %#v; wanted a *net.DNSError\", err)\n+\t\t\t}\n+\t\t\tif de.Err != errNoSuchHost.Error() {\n+\t\t\t\tt.Fatalf(\"Err = %#v; wanted %q\", de.Err, errNoSuchHost.Error())\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n@@ -1535,3 +1568,56 @@ func TestDNSDialTCP(t *testing.T) {\n \t\tt.Fatal(\"exhange failed:\", err)\n \t}\n }\n+\n+// Issue 27763: verify that two strings in one TXT record are concatenated.\n+func TestTXTRecordTwoStrings(t *testing.T) {\n+\tfake := fakeDNSServer{\n+\t\trh: func(n, _ string, q dnsmessage.Message, _ time.Time) (dnsmessage.Message, error) {\n+\t\t\tr := dnsmessage.Message{\n+\t\t\t\tHeader: dnsmessage.Header{\n+\t\t\t\t\tID:       q.Header.ID,\n+\t\t\t\t\tResponse: true,\n+\t\t\t\t\tRCode:    dnsmessage.RCodeSuccess,\n+\t\t\t\t},\n+\t\t\t\tQuestions: q.Questions,\n+\t\t\t\tAnswers: []dnsmessage.Resource{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tHeader: dnsmessage.ResourceHeader{\n+\t\t\t\t\t\t\tName:  q.Questions[0].Name,\n+\t\t\t\t\t\t\tType:  dnsmessage.TypeA,\n+\t\t\t\t\t\t\tClass: dnsmessage.ClassINET,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tBody: &dnsmessage.TXTResource{\n+\t\t\t\t\t\t\tTXT: []string{\"string1 \", \"string2\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tHeader: dnsmessage.ResourceHeader{\n+\t\t\t\t\t\t\tName:  q.Questions[0].Name,\n+\t\t\t\t\t\t\tType:  dnsmessage.TypeA,\n+\t\t\t\t\t\t\tClass: dnsmessage.ClassINET,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tBody: &dnsmessage.TXTResource{\n+\t\t\t\t\t\t\tTXT: []string{\"onestring\"},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\treturn r, nil\n+\t\t},\n+\t}\n+\tr := Resolver{PreferGo: true, Dial: fake.DialContext}\n+\ttxt, err := r.lookupTXT(context.Background(), \"golang.org\")\n+\tif err != nil {\n+\t\tt.Fatal(\"LookupTXT failed:\", err)\n+\t}\n+\tif want := 2; len(txt) != want {\n+\t\tt.Fatalf(\"len(txt), got %d, want %d\", len(txt), want)\n+\t}\n+\tif want := \"string1 string2\"; txt[0] != want {\n+\t\tt.Errorf(\"txt[0], got %q, want %q\", txt[0], want)\n+\t}\n+\tif want := \"onestring\"; txt[1] != want {\n+\t\tt.Errorf(\"txt[1], got %q, want %q\", txt[1], want)\n+\t}\n+}"}, {"sha": "38e4f5573e60edcb7afcd9c9ae480e4c0395191a", "filename": "libgo/go/net/http/roundtrip_js.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Fhttp%2Froundtrip_js.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Fhttp%2Froundtrip_js.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Froundtrip_js.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -116,7 +116,9 @@ func (t *Transport) RoundTrip(req *Request) (*Response, error) {\n \n \t\tb := result.Get(\"body\")\n \t\tvar body io.ReadCloser\n-\t\tif b != js.Undefined() {\n+\t\t// The body is undefined when the browser does not support streaming response bodies (Firefox),\n+\t\t// and null in certain error cases, i.e. when the request is blocked because of CORS settings.\n+\t\tif b != js.Undefined() && b != js.Null() {\n \t\t\tbody = &streamReader{stream: b.Call(\"getReader\")}\n \t\t} else {\n \t\t\t// Fall back to using ArrayBuffer"}, {"sha": "39e8b720076b962c01906d9fc5a205b30c8f1f8d", "filename": "libgo/go/net/lookup_unix.go", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_unix.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -299,11 +299,21 @@ func (r *Resolver) lookupTXT(ctx context.Context, name string) ([]string, error)\n \t\t\t\tServer: server,\n \t\t\t}\n \t\t}\n+\t\t// Multiple strings in one TXT record need to be\n+\t\t// concatenated without separator to be consistent\n+\t\t// with previous Go resolver.\n+\t\tn := 0\n+\t\tfor _, s := range txt.TXT {\n+\t\t\tn += len(s)\n+\t\t}\n+\t\ttxtJoin := make([]byte, 0, n)\n+\t\tfor _, s := range txt.TXT {\n+\t\t\ttxtJoin = append(txtJoin, s...)\n+\t\t}\n \t\tif len(txts) == 0 {\n-\t\t\ttxts = txt.TXT\n-\t\t} else {\n-\t\t\ttxts = append(txts, txt.TXT...)\n+\t\t\ttxts = make([]string, 0, 1)\n \t\t}\n+\t\ttxts = append(txts, string(txtJoin))\n \t}\n \treturn txts, nil\n }"}, {"sha": "3be1c7e5de11405df8e8342d30d48f09b620a17e", "filename": "libgo/go/net/splice_test.go", "status": "modified", "additions": 53, "deletions": 10, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Fsplice_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fnet%2Fsplice_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsplice_test.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -124,6 +124,7 @@ func testSpliceBig(t *testing.T) {\n func testSpliceHonorsLimitedReader(t *testing.T) {\n \tt.Run(\"stopsAfterN\", testSpliceStopsAfterN)\n \tt.Run(\"updatesN\", testSpliceUpdatesN)\n+\tt.Run(\"readerAtLimit\", testSpliceReaderAtLimit)\n }\n \n func testSpliceStopsAfterN(t *testing.T) {\n@@ -210,7 +211,7 @@ func testSpliceUpdatesN(t *testing.T) {\n \t}\n }\n \n-func testSpliceReaderAtEOF(t *testing.T) {\n+func testSpliceReaderAtLimit(t *testing.T) {\n \tclientUp, serverUp, err := spliceTestSocketPair(\"tcp\")\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -224,22 +225,64 @@ func testSpliceReaderAtEOF(t *testing.T) {\n \tdefer clientDown.Close()\n \tdefer serverDown.Close()\n \n-\tserverUp.Close()\n-\t_, err, handled := splice(serverDown.(*TCPConn).fd, serverUp)\n+\tlr := &io.LimitedReader{\n+\t\tN: 0,\n+\t\tR: serverUp,\n+\t}\n+\t_, err, handled := splice(serverDown.(*TCPConn).fd, lr)\n \tif !handled {\n \t\tif serr, ok := err.(*os.SyscallError); ok && serr.Syscall == \"pipe2\" && serr.Err == syscall.ENOSYS {\n \t\t\tt.Skip(\"pipe2 not supported\")\n \t\t}\n \n-\t\tt.Errorf(\"closed connection: got err = %v, handled = %t, want handled = true\", err, handled)\n+\t\tt.Errorf(\"exhausted LimitedReader: got err = %v, handled = %t, want handled = true\", err, handled)\n \t}\n-\tlr := &io.LimitedReader{\n-\t\tN: 0,\n-\t\tR: serverUp,\n+}\n+\n+func testSpliceReaderAtEOF(t *testing.T) {\n+\tclientUp, serverUp, err := spliceTestSocketPair(\"tcp\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n \t}\n-\t_, err, handled = splice(serverDown.(*TCPConn).fd, lr)\n-\tif !handled {\n-\t\tt.Errorf(\"exhausted LimitedReader: got err = %v, handled = %t, want handled = true\", err, handled)\n+\tdefer clientUp.Close()\n+\tclientDown, serverDown, err := spliceTestSocketPair(\"tcp\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer clientDown.Close()\n+\n+\tserverUp.Close()\n+\n+\t// We'd like to call net.splice here and check the handled return\n+\t// value, but we disable splice on old Linux kernels.\n+\t//\n+\t// In that case, poll.Splice and net.splice return a non-nil error\n+\t// and handled == false. We'd ideally like to see handled == true\n+\t// because the source reader is at EOF, but if we're running on an old\n+\t// kernel, and splice is disabled, we won't see EOF from net.splice,\n+\t// because we won't touch the reader at all.\n+\t//\n+\t// Trying to untangle the errors from net.splice and match them\n+\t// against the errors created by the poll package would be brittle,\n+\t// so this is a higher level test.\n+\t//\n+\t// The following ReadFrom should return immediately, regardless of\n+\t// whether splice is disabled or not. The other side should then\n+\t// get a goodbye signal. Test for the goodbye signal.\n+\tmsg := \"bye\"\n+\tgo func() {\n+\t\tserverDown.(*TCPConn).ReadFrom(serverUp)\n+\t\tio.WriteString(serverDown, msg)\n+\t\tserverDown.Close()\n+\t}()\n+\n+\tbuf := make([]byte, 3)\n+\t_, err = io.ReadFull(clientDown, buf)\n+\tif err != nil {\n+\t\tt.Errorf(\"clientDown: %v\", err)\n+\t}\n+\tif string(buf) != msg {\n+\t\tt.Errorf(\"clientDown got %q, want %q\", buf, msg)\n \t}\n }\n "}, {"sha": "472988fe85622e9175e2a0535928881b24fbcc10", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -5864,7 +5864,7 @@ func clobber() {\n type funcLayoutTest struct {\n \trcvr, t                  Type\n \tsize, argsize, retOffset uintptr\n-\tstack                    []byte // pointer bitmap: 1 is pointer, 0 is scalar (or uninitialized)\n+\tstack                    []byte // pointer bitmap: 1 is pointer, 0 is scalar\n \tgc                       []byte\n }\n \n@@ -5886,7 +5886,7 @@ func init() {\n \t\t\t6 * PtrSize,\n \t\t\t4 * PtrSize,\n \t\t\t4 * PtrSize,\n-\t\t\t[]byte{1, 0, 1},\n+\t\t\t[]byte{1, 0, 1, 0, 1},\n \t\t\t[]byte{1, 0, 1, 0, 1},\n \t\t})\n "}, {"sha": "9d9cbdec25ddf210d0eefb5d84df7fecfcb28d23", "filename": "libgo/go/reflect/makefunc_ffi.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -33,7 +33,7 @@ func FFICallbackGo(results unsafe.Pointer, params unsafe.Pointer, impl *makeFunc\n \tap := params\n \tfor _, rt := range ftyp.in {\n \t\tp := unsafe_New(rt)\n-\t\tmemmove(p, *(*unsafe.Pointer)(ap), rt.size)\n+\t\ttypedmemmove(rt, p, *(*unsafe.Pointer)(ap))\n \t\tv := Value{rt, p, flag(rt.Kind()) | flagIndir}\n \t\tin = append(in, v)\n \t\tap = (unsafe.Pointer)(uintptr(ap) + ptrSize)\n@@ -59,7 +59,7 @@ func FFICallbackGo(results unsafe.Pointer, params unsafe.Pointer, impl *makeFunc\n \t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n \t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n \t\t} else {\n-\t\t\tmemmove(addr, v.ptr, typ.size)\n+\t\t\ttypedmemmove(typ, addr, v.ptr)\n \t\t}\n \t\toff += typ.size\n \t}"}, {"sha": "9f05744f8d13625c9cd817aea948be928c52dad7", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -323,7 +323,7 @@ var callGC bool // for testing; see TestCallMethodJump\n \n func (v Value) call(op string, in []Value) []Value {\n \t// Get function pointer, type.\n-\tt := v.typ\n+\tt := (*funcType)(unsafe.Pointer(v.typ))\n \tvar (\n \t\tfn   unsafe.Pointer\n \t\trcvr Value\n@@ -472,7 +472,7 @@ func (v Value) call(op string, in []Value) []Value {\n // The return value rcvrtype gives the method's actual receiver type.\n // The return value t gives the method type signature (without the receiver).\n // The return value fn is a pointer to the method code.\n-func methodReceiver(op string, v Value, methodIndex int) (rcvrtype, t *rtype, fn unsafe.Pointer) {\n+func methodReceiver(op string, v Value, methodIndex int) (rcvrtype *rtype, t *funcType, fn unsafe.Pointer) {\n \ti := methodIndex\n \tif v.typ.Kind() == Interface {\n \t\ttt := (*interfaceType)(unsafe.Pointer(v.typ))\n@@ -489,7 +489,7 @@ func methodReceiver(op string, v Value, methodIndex int) (rcvrtype, t *rtype, fn\n \t\t}\n \t\trcvrtype = iface.itab.typ\n \t\tfn = unsafe.Pointer(&iface.itab.fun[i])\n-\t\tt = m.typ\n+\t\tt = (*funcType)(unsafe.Pointer(m.typ))\n \t} else {\n \t\trcvrtype = v.typ\n \t\tms := v.typ.exportedMethods()\n@@ -501,7 +501,7 @@ func methodReceiver(op string, v Value, methodIndex int) (rcvrtype, t *rtype, fn\n \t\t\tpanic(\"reflect: \" + op + \" of unexported method\")\n \t\t}\n \t\tfn = unsafe.Pointer(&m.tfn)\n-\t\tt = m.mtyp\n+\t\tt = (*funcType)(unsafe.Pointer(m.mtyp))\n \t}\n \treturn\n }\n@@ -2399,10 +2399,14 @@ func mapiternext(it unsafe.Pointer)\n \n //go:noescape\n func maplen(m unsafe.Pointer) int\n-func call(typ *rtype, fnaddr unsafe.Pointer, isInterface bool, isMethod bool, params *unsafe.Pointer, results *unsafe.Pointer)\n+func call(typ *funcType, fnaddr unsafe.Pointer, isInterface bool, isMethod bool, params *unsafe.Pointer, results *unsafe.Pointer)\n \n func ifaceE2I(t *rtype, src interface{}, dst unsafe.Pointer)\n \n+// memmove copies size bytes to dst from src. No write barriers are used.\n+//go:noescape\n+func memmove(dst, src unsafe.Pointer, size uintptr)\n+\n // typedmemmove copies a value of type t to dst from src.\n //go:noescape\n func typedmemmove(t *rtype, dst, src unsafe.Pointer)\n@@ -2412,10 +2416,6 @@ func typedmemmove(t *rtype, dst, src unsafe.Pointer)\n //go:noescape\n func typedslicecopy(elemType *rtype, dst, src sliceHeader) int\n \n-//go:noescape\n-//extern memmove\n-func memmove(adst, asrc unsafe.Pointer, n uintptr)\n-\n // Dummy annotation marking that the value x escapes,\n // for use in cases where the reflect code is so clever that\n // the compiler cannot follow."}, {"sha": "cb369effb8cd9f9452b192a61e571e8b21062ac9", "filename": "libgo/go/runtime/chan.go", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -102,7 +102,7 @@ func makechan(t *chantype, size int) *hchan {\n \t\t// Queue or element size is zero.\n \t\tc = (*hchan)(mallocgc(hchanSize, nil, true))\n \t\t// Race detector uses this location for synchronization.\n-\t\tc.buf = unsafe.Pointer(c)\n+\t\tc.buf = c.raceaddr()\n \tcase elem.kind&kindNoPointers != 0:\n \t\t// Elements do not contain pointers.\n \t\t// Allocate hchan and buf in one call.\n@@ -166,7 +166,7 @@ func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n \t}\n \n \tif raceenabled {\n-\t\tracereadpc(unsafe.Pointer(c), callerpc, funcPC(chansend))\n+\t\tracereadpc(c.raceaddr(), callerpc, funcPC(chansend))\n \t}\n \n \t// Fast path: check for failed non-blocking operation without acquiring the lock.\n@@ -352,8 +352,8 @@ func closechan(c *hchan) {\n \n \tif raceenabled {\n \t\tcallerpc := getcallerpc()\n-\t\tracewritepc(unsafe.Pointer(c), callerpc, funcPC(closechan))\n-\t\tracerelease(unsafe.Pointer(c))\n+\t\tracewritepc(c.raceaddr(), callerpc, funcPC(closechan))\n+\t\tracerelease(c.raceaddr())\n \t}\n \n \tc.closed = 1\n@@ -376,7 +376,7 @@ func closechan(c *hchan) {\n \t\tgp := sg.g\n \t\tgp.param = nil\n \t\tif raceenabled {\n-\t\t\traceacquireg(gp, unsafe.Pointer(c))\n+\t\t\traceacquireg(gp, c.raceaddr())\n \t\t}\n \t\tgp.schedlink.set(glist)\n \t\tglist = gp\n@@ -395,7 +395,7 @@ func closechan(c *hchan) {\n \t\tgp := sg.g\n \t\tgp.param = nil\n \t\tif raceenabled {\n-\t\t\traceacquireg(gp, unsafe.Pointer(c))\n+\t\t\traceacquireg(gp, c.raceaddr())\n \t\t}\n \t\tgp.schedlink.set(glist)\n \t\tglist = gp\n@@ -477,7 +477,7 @@ func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)\n \n \tif c.closed != 0 && c.qcount == 0 {\n \t\tif raceenabled {\n-\t\t\traceacquire(unsafe.Pointer(c))\n+\t\t\traceacquire(c.raceaddr())\n \t\t}\n \t\tunlock(&c.lock)\n \t\tif ep != nil {\n@@ -755,6 +755,15 @@ func (q *waitq) dequeue() *sudog {\n \t}\n }\n \n+func (c *hchan) raceaddr() unsafe.Pointer {\n+\t// Treat read-like and write-like operations on the channel to\n+\t// happen at this address. Avoid using the address of qcount\n+\t// or dataqsiz, because the len() and cap() builtins read\n+\t// those addresses, and we don't want them racing with\n+\t// operations like close().\n+\treturn unsafe.Pointer(&c.buf)\n+}\n+\n func racesync(c *hchan, sg *sudog) {\n \tracerelease(chanbuf(c, 0))\n \traceacquireg(sg.g, chanbuf(c, 0))"}, {"sha": "487131576011fbaa76e572dc47f395133c1d9b99", "filename": "libgo/go/runtime/mbarrier.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fmbarrier.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fmbarrier.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmbarrier.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -309,6 +309,19 @@ func typedmemclr(typ *_type, ptr unsafe.Pointer) {\n \tmemclrNoHeapPointers(ptr, typ.size)\n }\n \n+//go:linkname reflect_typedmemclr reflect.typedmemclr\n+func reflect_typedmemclr(typ *_type, ptr unsafe.Pointer) {\n+\ttypedmemclr(typ, ptr)\n+}\n+\n+//go:linkname reflect_typedmemclrpartial reflect.typedmemclrpartial\n+func reflect_typedmemclrpartial(typ *_type, ptr unsafe.Pointer, off, size uintptr) {\n+\tif typ.kind&kindNoPointers == 0 {\n+\t\tbulkBarrierPreWrite(uintptr(ptr), 0, size)\n+\t}\n+\tmemclrNoHeapPointers(ptr, size)\n+}\n+\n // memclrHasPointers clears n bytes of typed memory starting at ptr.\n // The caller must ensure that the type of the object at ptr has\n // pointers, usually by checking typ.kind&kindNoPointers. However, ptr"}, {"sha": "235f7943f8d397512a640143b806e8b0e4afb555", "filename": "libgo/go/runtime/os_darwin.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fos_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fos_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_darwin.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -34,6 +34,10 @@ func semacreate(mp *m) {\n \n //go:nosplit\n func semasleep(ns int64) int32 {\n+\tvar start int64\n+\tif ns >= 0 {\n+\t\tstart = nanotime()\n+\t}\n \tmp := getg().m\n \tpthread_mutex_lock(&mp.mutex)\n \tfor {\n@@ -43,8 +47,13 @@ func semasleep(ns int64) int32 {\n \t\t\treturn 0\n \t\t}\n \t\tif ns >= 0 {\n+\t\t\tspent := nanotime() - start\n+\t\t\tif spent >= ns {\n+\t\t\t\tpthread_mutex_unlock(&mp.mutex)\n+\t\t\t\treturn -1\n+\t\t\t}\n \t\t\tvar t timespec\n-\t\t\tt.set_nsec(ns)\n+\t\t\tt.set_nsec(ns - spent)\n \t\t\terr := pthread_cond_timedwait_relative_np(&mp.cond, &mp.mutex, &t)\n \t\t\tif err == _ETIMEDOUT {\n \t\t\t\tpthread_mutex_unlock(&mp.mutex)"}, {"sha": "16a11926dda4f44f568c9e58ec798131e29c4adc", "filename": "libgo/go/runtime/os_netbsd.go", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fos_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fos_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_netbsd.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -29,15 +29,9 @@ func semacreate(mp *m) {\n //go:nosplit\n func semasleep(ns int64) int32 {\n \t_g_ := getg()\n-\n-\t// Compute sleep deadline.\n-\tvar tsp *timespec\n-\tvar ts timespec\n+\tvar deadline int64\n \tif ns >= 0 {\n-\t\tvar nsec int32\n-\t\tts.set_sec(int64(timediv(ns, 1000000000, &nsec)))\n-\t\tts.set_nsec(nsec)\n-\t\ttsp = &ts\n+\t\tdeadline = nanotime() + ns\n \t}\n \n \tfor {\n@@ -50,18 +44,21 @@ func semasleep(ns int64) int32 {\n \t\t}\n \n \t\t// Sleep until unparked by semawakeup or timeout.\n+\t\tvar tsp *timespec\n+\t\tvar ts timespec\n+\t\tif ns >= 0 {\n+\t\t\twait := deadline - nanotime()\n+\t\t\tif wait <= 0 {\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\tvar nsec int32\n+\t\t\tts.set_sec(timediv(wait, 1000000000, &nsec))\n+\t\t\tts.set_nsec(nsec)\n+\t\t\ttsp = &ts\n+\t\t}\n \t\tret := lwp_park(_CLOCK_MONOTONIC, _TIMER_RELTIME, tsp, 0, unsafe.Pointer(&_g_.m.waitsemacount), nil)\n \t\tif ret == _ETIMEDOUT {\n \t\t\treturn -1\n-\t\t} else if ret == _EINTR && ns >= 0 {\n-\t\t\t// Avoid sleeping forever if we keep getting\n-\t\t\t// interrupted (for example by the profiling\n-\t\t\t// timer). It would be if tsp upon return had the\n-\t\t\t// remaining time to sleep, but this is good enough.\n-\t\t\tvar nsec int32\n-\t\t\tns /= 2\n-\t\t\tts.set_sec(timediv(ns, 1000000000, &nsec))\n-\t\t\tts.set_nsec(nsec)\n \t\t}\n \t}\n }"}, {"sha": "fb8373f53b5801e0ca88d7a806a0599cd6117e1c", "filename": "libgo/go/runtime/select.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fselect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Fselect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fselect.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -426,7 +426,7 @@ rclose:\n \t\ttypedmemclr(c.elemtype, cas.elem)\n \t}\n \tif raceenabled {\n-\t\traceacquire(unsafe.Pointer(c))\n+\t\traceacquire(c.raceaddr())\n \t}\n \tgoto retc\n "}, {"sha": "d5a7d003fe2fc58a26dff8a653c195134c231a8f", "filename": "libgo/go/runtime/trace/annotation.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Ftrace%2Fannotation.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cbb7cbb096134746588d08a469778b11ae6ac73/libgo%2Fgo%2Fruntime%2Ftrace%2Fannotation.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace%2Fannotation.go?ref=3cbb7cbb096134746588d08a469778b11ae6ac73", "patch": "@@ -24,13 +24,13 @@ type traceContextKey struct{}\n // If the end function is called multiple times, only the first\n // call is used in the latency measurement.\n //\n-//   ctx, task := trace.NewTask(ctx, \"awesome task\")\n-//   trace.WithRegion(ctx, prepWork)\n+//   ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n+//   trace.WithRegion(ctx, \"preparation\", prepWork)\n //   // preparation of the task\n //   go func() {  // continue processing the task in a separate goroutine.\n //       defer task.End()\n-//       trace.WithRegion(ctx, remainingWork)\n-//   }\n+//       trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n+//   }()\n func NewTask(pctx context.Context, taskType string) (ctx context.Context, task *Task) {\n \tpid := fromContext(pctx).id\n \tid := newID()"}]}