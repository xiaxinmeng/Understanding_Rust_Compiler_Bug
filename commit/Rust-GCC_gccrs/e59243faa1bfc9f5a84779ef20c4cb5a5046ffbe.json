{"sha": "e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5MjQzZmFhMWJmYzlmNWE4NDc3OWVmMjBjNGNiNWE1MDQ2ZmZiZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T14:00:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T14:00:46Z"}, "message": "[multiple changes]\n\n2014-07-16  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.ads, exp_ch4.adb (Find_Hook_Context): Relocated to Exp_Util.\n\t* exp_ch7.adb (Process_Declarations): There is no need to check\n\tthat a transient object being hooked is controlled as it would\n\tnot have been hooked in the first place.\n\t* exp_ch9.adb Remove with and use clause for Exp_Ch4.\n\t* exp_util.adb (Find_Hook_Context): Relocated from Exp_Ch4.\n\t(Is_Aliased): A renaming of a transient controlled object is\n\tnot considered aliasing when it occurs within an expression\n\twith actions.\n\t(Requires_Cleanup_Actions): There is no need to\n\tcheck that a transient object being hooked is controlled as it\n\twould not have been hooked in the first place.\n\t* exp_util.ads (Find_Hook_Context): Relocated from Exp_Ch4.\n\n2014-07-16  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch13.adb (Insert_After_SPARK_Mode): Moved to\n\tthe outer level of routine Analyze_Aspect_Specifications. Ensure\n\tthat the corresponding pragmas of aspects Initial_Condition and\n\tInitializes are inserted after pragma SPARK_Mode.\n\n2014-07-16  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute, case 'Update): Handle\n\tproperly a choice list with more than one choice, where each\n\tis an aggregate denoting a sequence of array indices for a\n\tmultidimentional array. For SPARK use.\n\nFrom-SVN: r212646", "tree": {"sha": "5dfcf15d019c554b5504a0af6e05baff001bde4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dfcf15d019c554b5504a0af6e05baff001bde4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/comments", "author": null, "committer": null, "parents": [{"sha": "8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8942b30c7c1a6500f56bdf93ba96c54da370ba8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8942b30c7c1a6500f56bdf93ba96c54da370ba8c"}], "stats": {"total": 515, "additions": 282, "deletions": 233}, "files": [{"sha": "ab74e4e4cac907ed0b8cb8121339497b64a3d343", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -1,3 +1,33 @@\n+2014-07-16  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.ads, exp_ch4.adb (Find_Hook_Context): Relocated to Exp_Util.\n+\t* exp_ch7.adb (Process_Declarations): There is no need to check\n+\tthat a transient object being hooked is controlled as it would\n+\tnot have been hooked in the first place.\n+\t* exp_ch9.adb Remove with and use clause for Exp_Ch4.\n+\t* exp_util.adb (Find_Hook_Context): Relocated from Exp_Ch4.\n+\t(Is_Aliased): A renaming of a transient controlled object is\n+\tnot considered aliasing when it occurs within an expression\n+\twith actions.\n+\t(Requires_Cleanup_Actions): There is no need to\n+\tcheck that a transient object being hooked is controlled as it\n+\twould not have been hooked in the first place.\n+\t* exp_util.ads (Find_Hook_Context): Relocated from Exp_Ch4.\n+\n+2014-07-16  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch13.adb (Insert_After_SPARK_Mode): Moved to\n+\tthe outer level of routine Analyze_Aspect_Specifications. Ensure\n+\tthat the corresponding pragmas of aspects Initial_Condition and\n+\tInitializes are inserted after pragma SPARK_Mode.\n+\n+2014-07-16  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute, case 'Update): Handle\n+\tproperly a choice list with more than one choice, where each\n+\tis an aggregate denoting a sequence of array indices for a\n+\tmultidimentional array. For SPARK use.\n+\n 2014-07-16  Vadim Godunko  <godunko@adacore.com>\n \n \t* a-coinho-shared.adb (Adjust): Create"}, {"sha": "1ef60a29b2cf3a8005da126f1fee2a9bdfefd04a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -11390,145 +11390,6 @@ package body Exp_Ch4 is\n       Adjust_Result_Type (N, Typ);\n    end Expand_Short_Circuit_Operator;\n \n-   -----------------------\n-   -- Find_Hook_Context --\n-   -----------------------\n-\n-   function Find_Hook_Context (N : Node_Id) return Node_Id is\n-      Par : Node_Id;\n-      Top : Node_Id;\n-\n-      Wrapped_Node : Node_Id;\n-      --  Note: if we are in a transient scope, we want to reuse it as\n-      --  the context for actions insertion, if possible. But if N is itself\n-      --  part of the stored actions for the current transient scope,\n-      --  then we need to insert at the appropriate (inner) location in\n-      --  the not as an action on Node_To_Be_Wrapped.\n-\n-      In_Cond_Expr : constant Boolean := Within_Case_Or_If_Expression (N);\n-\n-   begin\n-      --  When the node is inside a case/if expression, the lifetime of any\n-      --  temporary controlled object is extended. Find a suitable insertion\n-      --  node by locating the topmost case or if expressions.\n-\n-      if In_Cond_Expr then\n-         Par := N;\n-         Top := N;\n-         while Present (Par) loop\n-            if Nkind_In (Original_Node (Par), N_Case_Expression,\n-                                              N_If_Expression)\n-            then\n-               Top := Par;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Par) then\n-               exit;\n-            end if;\n-\n-            Par := Parent (Par);\n-         end loop;\n-\n-         --  The topmost case or if expression is now recovered, but it may\n-         --  still not be the correct place to add generated code. Climb to\n-         --  find a parent that is part of a declarative or statement list,\n-         --  and is not a list of actuals in a call.\n-\n-         Par := Top;\n-         while Present (Par) loop\n-            if Is_List_Member (Par)\n-              and then not Nkind_In (Par, N_Component_Association,\n-                                          N_Discriminant_Association,\n-                                          N_Parameter_Association,\n-                                          N_Pragma_Argument_Association)\n-              and then not Nkind_In\n-                             (Parent (Par), N_Function_Call,\n-                                            N_Procedure_Call_Statement,\n-                                            N_Entry_Call_Statement)\n-\n-            then\n-               return Par;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Par) then\n-               exit;\n-            end if;\n-\n-            Par := Parent (Par);\n-         end loop;\n-\n-         return Par;\n-\n-      else\n-         Par := N;\n-         while Present (Par) loop\n-\n-            --  Keep climbing past various operators\n-\n-            if Nkind (Parent (Par)) in N_Op\n-              or else Nkind_In (Parent (Par), N_And_Then, N_Or_Else)\n-            then\n-               Par := Parent (Par);\n-            else\n-               exit;\n-            end if;\n-         end loop;\n-\n-         Top := Par;\n-\n-         --  The node may be located in a pragma in which case return the\n-         --  pragma itself:\n-\n-         --    pragma Precondition (... and then Ctrl_Func_Call ...);\n-\n-         --  Similar case occurs when the node is related to an object\n-         --  declaration or assignment:\n-\n-         --    Obj [: Some_Typ] := ... and then Ctrl_Func_Call ...;\n-\n-         --  Another case to consider is when the node is part of a return\n-         --  statement:\n-\n-         --    return ... and then Ctrl_Func_Call ...;\n-\n-         --  Another case is when the node acts as a formal in a procedure\n-         --  call statement:\n-\n-         --    Proc (... and then Ctrl_Func_Call ...);\n-\n-         if Scope_Is_Transient then\n-            Wrapped_Node := Node_To_Be_Wrapped;\n-         else\n-            Wrapped_Node := Empty;\n-         end if;\n-\n-         while Present (Par) loop\n-            if Par = Wrapped_Node\n-              or else Nkind_In (Par, N_Assignment_Statement,\n-                                     N_Object_Declaration,\n-                                     N_Pragma,\n-                                     N_Procedure_Call_Statement,\n-                                     N_Simple_Return_Statement)\n-            then\n-               return Par;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Par) then\n-               exit;\n-            end if;\n-\n-            Par := Parent (Par);\n-         end loop;\n-\n-         --  Return the topmost short circuit operator\n-\n-         return Top;\n-      end if;\n-   end Find_Hook_Context;\n-\n    -------------------------------------\n    -- Fixup_Universal_Fixed_Operation --\n    -------------------------------------"}, {"sha": "abdc470036a3d1bc6dbca9fe4438739440b2dafe", "filename": "gcc/ada/exp_ch4.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.ads?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -103,11 +103,4 @@ package Exp_Ch4 is\n    --  have special circuitry in Expand_N_Type_Conversion to promote both of\n    --  the operands to type Integer.\n \n-   function Find_Hook_Context (N : Node_Id) return Node_Id;\n-   --  Determine a suitable node on which to attach actions related to N\n-   --  that need to be elaborated unconditionally (i.e. in general the topmost\n-   --  expression of which N is a subexpression, which may or may not be\n-   --  evaluated, for example if N is the right operand of a short circuit\n-   --  operator).\n-\n end Exp_Ch4;"}, {"sha": "9a135bdd4875cfed1cce116a008371fda093a1f7", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1825,8 +1825,6 @@ package body Exp_Ch7 is\n                  and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))\n                  and then Nkind (Status_Flag_Or_Transient_Decl (Obj_Id)) =\n                                    N_Object_Declaration\n-                 and then Is_Finalizable_Transient\n-                            (Status_Flag_Or_Transient_Decl (Obj_Id), Decl)\n                then\n                   Processing_Actions (Has_No_Init => True);\n "}, {"sha": "db66a8a4e0e80a5ece2700b89104f17fc4cf1c25", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -29,7 +29,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch3;  use Exp_Ch3;\n-with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Dbug; use Exp_Dbug;"}, {"sha": "fca843255d3695e2a7dfe3fcd6fe159ed832dd22", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 152, "deletions": 4, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -2598,6 +2598,145 @@ package body Exp_Util is\n       raise Program_Error;\n    end Find_Protection_Type;\n \n+   -----------------------\n+   -- Find_Hook_Context --\n+   -----------------------\n+\n+   function Find_Hook_Context (N : Node_Id) return Node_Id is\n+      Par : Node_Id;\n+      Top : Node_Id;\n+\n+      Wrapped_Node : Node_Id;\n+      --  Note: if we are in a transient scope, we want to reuse it as\n+      --  the context for actions insertion, if possible. But if N is itself\n+      --  part of the stored actions for the current transient scope,\n+      --  then we need to insert at the appropriate (inner) location in\n+      --  the not as an action on Node_To_Be_Wrapped.\n+\n+      In_Cond_Expr : constant Boolean := Within_Case_Or_If_Expression (N);\n+\n+   begin\n+      --  When the node is inside a case/if expression, the lifetime of any\n+      --  temporary controlled object is extended. Find a suitable insertion\n+      --  node by locating the topmost case or if expressions.\n+\n+      if In_Cond_Expr then\n+         Par := N;\n+         Top := N;\n+         while Present (Par) loop\n+            if Nkind_In (Original_Node (Par), N_Case_Expression,\n+                                              N_If_Expression)\n+            then\n+               Top := Par;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         --  The topmost case or if expression is now recovered, but it may\n+         --  still not be the correct place to add generated code. Climb to\n+         --  find a parent that is part of a declarative or statement list,\n+         --  and is not a list of actuals in a call.\n+\n+         Par := Top;\n+         while Present (Par) loop\n+            if Is_List_Member (Par)\n+              and then not Nkind_In (Par, N_Component_Association,\n+                                          N_Discriminant_Association,\n+                                          N_Parameter_Association,\n+                                          N_Pragma_Argument_Association)\n+              and then not Nkind_In\n+                             (Parent (Par), N_Function_Call,\n+                                            N_Procedure_Call_Statement,\n+                                            N_Entry_Call_Statement)\n+\n+            then\n+               return Par;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return Par;\n+\n+      else\n+         Par := N;\n+         while Present (Par) loop\n+\n+            --  Keep climbing past various operators\n+\n+            if Nkind (Parent (Par)) in N_Op\n+              or else Nkind_In (Parent (Par), N_And_Then, N_Or_Else)\n+            then\n+               Par := Parent (Par);\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n+         Top := Par;\n+\n+         --  The node may be located in a pragma in which case return the\n+         --  pragma itself:\n+\n+         --    pragma Precondition (... and then Ctrl_Func_Call ...);\n+\n+         --  Similar case occurs when the node is related to an object\n+         --  declaration or assignment:\n+\n+         --    Obj [: Some_Typ] := ... and then Ctrl_Func_Call ...;\n+\n+         --  Another case to consider is when the node is part of a return\n+         --  statement:\n+\n+         --    return ... and then Ctrl_Func_Call ...;\n+\n+         --  Another case is when the node acts as a formal in a procedure\n+         --  call statement:\n+\n+         --    Proc (... and then Ctrl_Func_Call ...);\n+\n+         if Scope_Is_Transient then\n+            Wrapped_Node := Node_To_Be_Wrapped;\n+         else\n+            Wrapped_Node := Empty;\n+         end if;\n+\n+         while Present (Par) loop\n+            if Par = Wrapped_Node\n+              or else Nkind_In (Par, N_Assignment_Statement,\n+                                     N_Object_Declaration,\n+                                     N_Pragma,\n+                                     N_Procedure_Call_Statement,\n+                                     N_Simple_Return_Statement)\n+            then\n+               return Par;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         --  Return the topmost short circuit operator\n+\n+         return Top;\n+      end if;\n+   end Find_Hook_Context;\n+\n    ----------------------\n    -- Force_Evaluation --\n    ----------------------\n@@ -4423,7 +4562,18 @@ package body Exp_Util is\n             elsif Nkind (Stmt) = N_Object_Renaming_Declaration then\n                Ren_Obj := Find_Renamed_Object (Stmt);\n \n-               if Present (Ren_Obj) and then Ren_Obj = Trans_Id then\n+               if Present (Ren_Obj)\n+                 and then Ren_Obj = Trans_Id\n+\n+                 --  When the related context is an expression with actions,\n+                 --  both the transient controlled object and its renaming are\n+                 --  bound by the \"scope\" of the expression with actions. In\n+                 --  other words, the two cannot be visible outside the scope,\n+                 --  therefore the lifetime of the transient object is not\n+                 --  really extended by the renaming.\n+\n+                 and then Nkind (Rel_Node) /= N_Expression_With_Actions\n+               then\n                   return True;\n                end if;\n             end if;\n@@ -7193,9 +7343,7 @@ package body Exp_Util is\n             elsif Is_Access_Type (Obj_Typ)\n               and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))\n               and then Nkind (Status_Flag_Or_Transient_Decl (Obj_Id)) =\n-                                                      N_Object_Declaration\n-              and then Is_Finalizable_Transient\n-                         (Status_Flag_Or_Transient_Decl (Obj_Id), Decl)\n+                                N_Object_Declaration\n             then\n                return True;\n "}, {"sha": "54e051b447b85aa60d7700e9d020362be2a93652", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -445,6 +445,13 @@ package Exp_Util is\n    --  Given a protected type or its corresponding record, find the type of\n    --  field _object.\n \n+   function Find_Hook_Context (N : Node_Id) return Node_Id;\n+   --  Determine a suitable node on which to attach actions related to N that\n+   --  need to be elaborated unconditionally. In general this is the topmost\n+   --  expression of which N is a subexpression, which in turn may or may not\n+   --  be evaluated, for example if N is the right operand of a short circuit\n+   --  operator.\n+\n    procedure Force_Evaluation\n      (Exp      : Node_Id;\n       Name_Req : Boolean := False);"}, {"sha": "5e5d0d7b82159502b21b34b8d25d3b5b4f5fe51e", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -6127,6 +6127,7 @@ package body Sem_Attr is\n \n       when Attribute_Update => Update : declare\n          Comps : Elist_Id := No_Elist;\n+         Expr  : Node_Id;\n \n          procedure Check_Component_Reference\n            (Comp : Entity_Id;\n@@ -6310,20 +6311,25 @@ package body Sem_Attr is\n                      --  Choice is a sequence of indexes for each dimension\n \n                      else\n-                        Index_Type := First_Index (P_Type);\n-                        Index := First (Expressions (First (Choices (Assoc))));\n-                        while Present (Index_Type)\n-                          and then Present (Index)\n-                        loop\n-                           Analyze_And_Resolve (Index, Etype (Index_Type));\n-                           Next_Index (Index_Type);\n-                           Next (Index);\n-                        end loop;\n+                        Expr := First (Choices (Assoc));\n+                        while Present (Expr) loop\n+                           Index_Type := First_Index (P_Type);\n+                           Index := First (Expressions (Expr));\n+                           while Present (Index_Type)\n+                             and then Present (Index)\n+                           loop\n+                              Analyze_And_Resolve (Index, Etype (Index_Type));\n+                              Next_Index (Index_Type);\n+                              Next (Index);\n+                           end loop;\n \n-                        if Present (Index) or else Present (Index_Type) then\n-                           Error_Msg_N\n-                             (\"dimension mismatch in index list\", Assoc);\n-                        end if;\n+                           if Present (Index) or else Present (Index_Type) then\n+                              Error_Msg_N\n+                                (\"dimension mismatch in index list\", Assoc);\n+                           end if;\n+\n+                           Next (Expr);\n+                        end loop;\n                      end if;\n                   end;\n "}, {"sha": "f3dd0585ef2539f81d43a2cbe5608ff337dfc233", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 72, "deletions": 65, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e59243faa1bfc9f5a84779ef20c4cb5a5046ffbe", "patch": "@@ -1158,6 +1158,15 @@ package body Sem_Ch13 is\n       --  Establish the linkages between an aspect and its corresponding\n       --  pragma. Flag Delayed should be set when both constructs are delayed.\n \n+      procedure Insert_After_SPARK_Mode\n+        (Prag    : Node_Id;\n+         Ins_Nod : Node_Id;\n+         Decls   : List_Id);\n+      --  Subsidiary to the analysis of aspects Abstract_State, Initializes and\n+      --  Initial_Condition. Insert node Prag before node Ins_Nod. If Ins_Nod\n+      --  denotes pragma SPARK_Mode, then SPARK_Mode is skipped. Decls is the\n+      --  associated declarative list where Prag is to reside.\n+\n       procedure Insert_Delayed_Pragma (Prag : Node_Id);\n       --  Insert a postcondition-like pragma into the tree depending on the\n       --  context. Prag must denote one of the following: Pre, Post, Depends,\n@@ -1182,6 +1191,37 @@ package body Sem_Ch13 is\n          Set_Parent                    (Prag, Asp);\n       end Decorate_Aspect_And_Pragma;\n \n+      -----------------------------\n+      -- Insert_After_SPARK_Mode --\n+      -----------------------------\n+\n+      procedure Insert_After_SPARK_Mode\n+        (Prag    : Node_Id;\n+         Ins_Nod : Node_Id;\n+         Decls   : List_Id)\n+      is\n+         Decl : Node_Id := Ins_Nod;\n+\n+      begin\n+         --  Skip SPARK_Mode\n+\n+         if Present (Decl)\n+           and then Nkind (Decl) = N_Pragma\n+           and then Pragma_Name (Decl) = Name_SPARK_Mode\n+         then\n+            Decl := Next (Decl);\n+         end if;\n+\n+         if Present (Decl) then\n+            Insert_Before (Decl, Prag);\n+\n+         --  Aitem acts as the last declaration\n+\n+         else\n+            Append_To (Decls, Prag);\n+         end if;\n+      end Insert_After_SPARK_Mode;\n+\n       ---------------------------\n       -- Insert_Delayed_Pragma --\n       ---------------------------\n@@ -2007,51 +2047,10 @@ package body Sem_Ch13 is\n                --  immediately.\n \n                when Aspect_Abstract_State => Abstract_State : declare\n-                  procedure Insert_After_SPARK_Mode\n-                    (Ins_Nod : Node_Id;\n-                     Decls   : List_Id);\n-                  --  Insert Aitem before node Ins_Nod. If Ins_Nod denotes\n-                  --  pragma SPARK_Mode, then SPARK_Mode is skipped. Decls is\n-                  --  the associated declarative list where Aitem is to reside.\n-\n-                  -----------------------------\n-                  -- Insert_After_SPARK_Mode --\n-                  -----------------------------\n-\n-                  procedure Insert_After_SPARK_Mode\n-                    (Ins_Nod : Node_Id;\n-                     Decls   : List_Id)\n-                  is\n-                     Decl : Node_Id := Ins_Nod;\n-\n-                  begin\n-                     --  Skip SPARK_Mode\n-\n-                     if Present (Decl)\n-                       and then Nkind (Decl) = N_Pragma\n-                       and then Pragma_Name (Decl) = Name_SPARK_Mode\n-                     then\n-                        Decl := Next (Decl);\n-                     end if;\n-\n-                     if Present (Decl) then\n-                        Insert_Before (Decl, Aitem);\n-\n-                     --  Aitem acts as the last declaration\n-\n-                     else\n-                        Append_To (Decls, Aitem);\n-                     end if;\n-                  end Insert_After_SPARK_Mode;\n-\n-                  --  Local variables\n-\n                   Context : Node_Id := N;\n                   Decl    : Node_Id;\n                   Decls   : List_Id;\n \n-               --  Start of processing for Abstract_State\n-\n                begin\n                   --  When aspect Abstract_State appears on a generic package,\n                   --  it is propageted to the package instance. The context in\n@@ -2080,6 +2079,7 @@ package body Sem_Ch13 is\n                      --  inserted after the association renamings.\n \n                      if Present (Decls) then\n+                        Decl := First (Decls);\n \n                         --  The visible declarations of a generic instance have\n                         --  the following structure:\n@@ -2089,34 +2089,25 @@ package body Sem_Ch13 is\n                         --    <first source declaration>\n \n                         --  The pragma must be inserted before the first source\n-                        --  declaration.\n+                        --  declaration, skip the instance \"header\".\n \n                         if Is_Generic_Instance (Defining_Entity (Context)) then\n-\n-                           --  Skip the instance \"header\"\n-\n-                           Decl := First (Decls);\n                            while Present (Decl)\n                              and then not Comes_From_Source (Decl)\n                            loop\n                               Decl := Next (Decl);\n                            end loop;\n+                        end if;\n \n-                           --  Pragma Abstract_State must be inserted after\n-                           --  pragma SPARK_Mode in the tree. This ensures that\n-                           --  any error messages dependent on SPARK_Mode will\n-                           --  be properly enabled/suppressed.\n-\n-                           Insert_After_SPARK_Mode (Decl, Decls);\n-\n-                        --  The related package is not a generic instance, the\n-                        --  corresponding pragma must be the first declaration\n-                        --  except when SPARK_Mode is already in the list. In\n-                        --  that case pragma Abstract_State is placed second.\n+                        --  Pragma Abstract_State must be inserted after pragma\n+                        --  SPARK_Mode in the tree. This ensures that any error\n+                        --  messages dependent on SPARK_Mode will be properly\n+                        --  enabled/suppressed.\n \n-                        else\n-                           Insert_After_SPARK_Mode (First (Decls), Decls);\n-                        end if;\n+                        Insert_After_SPARK_Mode\n+                          (Prag    => Aitem,\n+                           Ins_Nod => Decl,\n+                           Decls   => Decls);\n \n                      --  Otherwise the pragma forms a new declarative list\n \n@@ -2211,7 +2202,15 @@ package body Sem_Ch13 is\n                         Set_Visible_Declarations (Context, Decls);\n                      end if;\n \n-                     Prepend_To (Decls, Aitem);\n+                     --  When aspects Abstract_State, Initial_Condition and\n+                     --  Initializes are out of order, ensure that pragma\n+                     --  SPARK_Mode is always at the top of the declarative\n+                     --  list to properly enable/suppress errors.\n+\n+                     Insert_After_SPARK_Mode\n+                       (Prag    => Aitem,\n+                        Ins_Nod => First (Decls),\n+                        Decls   => Decls);\n \n                   else\n                      Error_Msg_NE\n@@ -2233,9 +2232,9 @@ package body Sem_Ch13 is\n                   Decls   : List_Id;\n \n                begin\n-                  --  When aspect Abstract_State appears on a generic package,\n-                  --  it is propageted to the package instance. The context in\n-                  --  this case is the instance spec.\n+                  --  When aspect Initializes appears on a generic package,\n+                  --  it is propageted to the package instance. The context\n+                  --  in this case is the instance spec.\n \n                   if Nkind (Context) = N_Package_Instantiation then\n                      Context := Instance_Spec (Context);\n@@ -2260,7 +2259,15 @@ package body Sem_Ch13 is\n                         Set_Visible_Declarations (Context, Decls);\n                      end if;\n \n-                     Prepend_To (Decls, Aitem);\n+                     --  When aspects Abstract_State, Initial_Condition and\n+                     --  Initializes are out of order, ensure that pragma\n+                     --  SPARK_Mode is always at the top of the declarative\n+                     --  list to properly enable/suppress errors.\n+\n+                     Insert_After_SPARK_Mode\n+                       (Prag    => Aitem,\n+                        Ins_Nod => First (Decls),\n+                        Decls   => Decls);\n \n                   else\n                      Error_Msg_NE"}]}