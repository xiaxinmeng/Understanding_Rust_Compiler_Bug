{"sha": "95048daaffa5e16df4d663702fe80294eac7b85e", "node_id": "C_kwDOANBUbNoAKDk1MDQ4ZGFhZmZhNWUxNmRmNGQ2NjM3MDJmZTgwMjk0ZWFjN2I4NWU", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-15T17:49:38Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-16T21:12:53Z"}, "message": "Replace Bfunction with GCC tree", "tree": {"sha": "b56f8e72ac7161b460b8e8455d1c957330680790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b56f8e72ac7161b460b8e8455d1c957330680790"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95048daaffa5e16df4d663702fe80294eac7b85e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95048daaffa5e16df4d663702fe80294eac7b85e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95048daaffa5e16df4d663702fe80294eac7b85e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95048daaffa5e16df4d663702fe80294eac7b85e/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "553e88f1dd4b4794334ee6d1861c185b92361a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/553e88f1dd4b4794334ee6d1861c185b92361a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/553e88f1dd4b4794334ee6d1861c185b92361a0b"}], "stats": {"total": 350, "additions": 156, "deletions": 194}, "files": [{"sha": "af0ea408ccdf0cd69ceb059405d6f06ac8449222", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -193,11 +193,11 @@ class HIRCompileBase : public HIR::HIRVisitor\n \n   Context *get_context () { return ctx; }\n \n-  void compile_function_body (Bfunction *fndecl,\n+  void compile_function_body (tree fndecl,\n \t\t\t      std::unique_ptr<HIR::BlockExpr> &function_body,\n \t\t\t      bool has_return_type);\n \n-  bool compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n+  bool compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n \t\t\t\t std::vector<Bvariable *> &locals);\n \n   tree coercion_site (tree compiled_ref, TyTy::BaseType *actual,"}, {"sha": "4c8f7223bc929325aa9fdb562a2596c56caeae2f", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -35,7 +35,7 @@ namespace Compile {\n \n struct fncontext\n {\n-  ::Bfunction *fndecl;\n+  ::tree fndecl;\n   ::Bvariable *ret_addr;\n };\n \n@@ -161,7 +161,7 @@ class Context\n     return true;\n   }\n \n-  void insert_function_decl (const TyTy::FnType *ref, ::Bfunction *fn)\n+  void insert_function_decl (const TyTy::FnType *ref, tree fn)\n   {\n     auto id = ref->get_ty_ref ();\n     auto dId = ref->get_id ();\n@@ -176,8 +176,7 @@ class Context\n     mono_fns[dId].push_back ({ref, fn});\n   }\n \n-  bool lookup_function_decl (HirId id, ::Bfunction **fn,\n-\t\t\t     DefId dId = UNKNOWN_DEFID,\n+  bool lookup_function_decl (HirId id, tree *fn, DefId dId = UNKNOWN_DEFID,\n \t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n     // for for any monomorphized fns\n@@ -192,7 +191,7 @@ class Context\n \tfor (auto &e : mono_fns[dId])\n \t  {\n \t    const TyTy::BaseType *r = e.first;\n-\t    ::Bfunction *f = e.second;\n+\t    tree f = e.second;\n \t    if (ref->is_equal (*r))\n \t      {\n \t\t*fn = f;\n@@ -237,7 +236,7 @@ class Context\n     return true;\n   }\n \n-  void push_fn (::Bfunction *fn, ::Bvariable *ret_addr)\n+  void push_fn (tree fn, ::Bvariable *ret_addr)\n   {\n     fn_stack.push_back (fncontext{fn, ret_addr});\n   }\n@@ -247,19 +246,19 @@ class Context\n   void push_type (::tree t) { type_decls.push_back (t); }\n   void push_var (::Bvariable *v) { var_decls.push_back (v); }\n   void push_const (::tree c) { const_decls.push_back (c); }\n-  void push_function (::Bfunction *f) { func_decls.push_back (f); }\n+  void push_function (tree f) { func_decls.push_back (f); }\n \n   void write_to_backend ()\n   {\n     backend->write_global_definitions (type_decls, const_decls, func_decls,\n \t\t\t\t       var_decls);\n   }\n \n-  bool function_completed (Bfunction *fn)\n+  bool function_completed (tree fn)\n   {\n     for (auto it = func_decls.begin (); it != func_decls.end (); it++)\n       {\n-\tBfunction *i = (*it);\n+\ttree i = (*it);\n \tif (i == fn)\n \t  {\n \t    return true;\n@@ -320,22 +319,22 @@ class Context\n   std::vector<fncontext> fn_stack;\n   std::map<HirId, ::Bvariable *> compiled_var_decls;\n   std::map<HirId, tree> compiled_type_map;\n-  std::map<HirId, ::Bfunction *> compiled_fn_map;\n+  std::map<HirId, tree> compiled_fn_map;\n   std::map<HirId, tree> compiled_consts;\n   std::map<HirId, ::Blabel *> compiled_labels;\n   std::vector<::std::vector<tree>> statements;\n   std::vector<::Bblock *> scope_stack;\n   std::vector<::Bvariable *> loop_value_stack;\n   std::vector<::Blabel *> loop_begin_labels;\n   std::map<const TyTy::BaseType *, std::pair<HirId, ::tree >> mono;\n-  std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, ::Bfunction *>>>\n+  std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n \n   // To GCC middle-end\n   std::vector<tree> type_decls;\n   std::vector<::Bvariable *> var_decls;\n   std::vector<tree> const_decls;\n-  std::vector<::Bfunction *> func_decls;\n+  std::vector<tree> func_decls;\n };\n \n class TyTyResolveCompile : public TyTy::TyConstVisitor"}, {"sha": "8b1da22efcf87a73174edeabcd7a91ef7ab58789", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -209,7 +209,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \t\t\t\t     Location expr_locus)\n {\n   // lookup compiled functions since it may have already been compiled\n-  Bfunction *fn = nullptr;\n+  tree fn = NULL_TREE;\n   if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n     {\n       return ctx->get_backend ()->function_code_expression (fn, expr_locus);"}, {"sha": "f7392739e553406b7b472337982a9032a8685fc0", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -204,7 +204,7 @@ class CompileExpr : public HIRCompileBase\n \tgcc_unreachable ();\n       }\n \n-    Bfunction *fn = nullptr;\n+    tree fn = NULL_TREE;\n     Bvariable *var = nullptr;\n     if (ctx->lookup_const_decl (ref, &translated))\n       {"}, {"sha": "aa73509f634a02ada963ade4267eeeb91c8b4711", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -99,14 +99,14 @@ class CompileExternItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      ctx->insert_function_decl (fntype, lookup);\n \n@@ -123,7 +123,7 @@ class CompileExternItem : public HIRCompileBase\n     if (fntype->get_abi () == ABI::INTRINSIC)\n       {\n \tIntrinsics compile (ctx);\n-\tBfunction *fndecl = compile.compile (fntype);\n+\ttree fndecl = compile.compile (fntype);\n \tctx->insert_function_decl (fntype, fndecl);\n \treturn;\n       }\n@@ -139,7 +139,7 @@ class CompileExternItem : public HIRCompileBase\n     std::string ir_symbol_name = function.get_item_name ();\n     std::string asm_name = function.get_item_name ();\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);"}, {"sha": "629f0f5a873db43244949c83254a8ed4796af0aa", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -29,7 +29,7 @@ class CompileFnParam : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n+  static Bvariable *compile (Context *ctx, tree fndecl,\n \t\t\t     HIR::FunctionParam *param, tree decl_type,\n \t\t\t     Location locus)\n   {\n@@ -51,13 +51,12 @@ class CompileFnParam : public HIRCompileBase\n   }\n \n private:\n-  CompileFnParam (Context *ctx, ::Bfunction *fndecl, tree decl_type,\n-\t\t  Location locus)\n+  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus)\n     : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type),\n       locus (locus), translated (nullptr)\n   {}\n \n-  ::Bfunction *fndecl;\n+  tree fndecl;\n   tree decl_type;\n   Location locus;\n   ::Bvariable *translated;\n@@ -66,9 +65,8 @@ class CompileFnParam : public HIRCompileBase\n class CompileSelfParam : public HIRCompileBase\n {\n public:\n-  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n-\t\t\t     HIR::SelfParam &self, tree decl_type,\n-\t\t\t     Location locus)\n+  static Bvariable *compile (Context *ctx, tree fndecl, HIR::SelfParam &self,\n+\t\t\t     tree decl_type, Location locus)\n   {\n     bool is_immutable\n       = self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM"}, {"sha": "23b10d61de58c074754532556a6610a7bf6816df", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -110,14 +110,14 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -156,7 +156,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     std::string asm_name\n       = ctx->mangle_impl_item (self, fntype, function.get_function_name ());\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);\n@@ -377,14 +377,14 @@ class CompileTraitItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -417,7 +417,7 @@ class CompileTraitItem : public HIRCompileBase\n     std::string fn_identifier = canonical_path->get ();\n     std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, func.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);"}, {"sha": "69626a930e955753529624771b865b1681a76755", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -21,7 +21,7 @@ namespace Compile {\n \n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n \n-Bfunction *\n+tree\n Intrinsics::compile (TyTy::FnType *fntype)\n {\n   rust_assert (fntype->get_abi () == ABI::INTRINSIC);\n@@ -77,7 +77,7 @@ Intrinsics::compile (TyTy::FnType *fntype)\n   // };\n   // Some(cx.get_intrinsic(&llvm_name))\n \n-  Bfunction *builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n+  tree builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n     fntype->get_identifier ());\n   if (builtin != nullptr)\n     return builtin;"}, {"sha": "2d44baa037cf78b3eae22b12b5ec9c46b69d393e", "filename": "gcc/rust/backend/rust-compile-intrinsic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -27,7 +27,7 @@ class Intrinsics\n public:\n   Intrinsics (Context *ctx);\n \n-  Bfunction *compile (TyTy::FnType *fntype);\n+  tree compile (TyTy::FnType *fntype);\n \n private:\n   Context *ctx;"}, {"sha": "94a313e1aa811701d0f747ebe1cc4e7530a2bc99", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -147,14 +147,14 @@ class CompileItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -201,7 +201,7 @@ class CompileItem : public HIRCompileBase\n \tasm_name = ctx->mangle_item (fntype, *canonical_path);\n       }\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);"}, {"sha": "cb3f0df8db03d2e89e19d77ec64dc39ea0c51c11", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -92,7 +92,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n   if (lookup->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-      Bfunction *fn = nullptr;\n+      tree fn = NULL_TREE;\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n \t  return ctx->get_backend ()->function_code_expression (fn, expr_locus);"}, {"sha": "a964fa2206bfa015b3b74983a94530aa9ea4d1a6", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -29,8 +29,7 @@ class CompileVarDecl : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static ::Bvariable *compile (::Bfunction *fndecl, HIR::Stmt *stmt,\n-\t\t\t       Context *ctx)\n+  static ::Bvariable *compile (tree fndecl, HIR::Stmt *stmt, Context *ctx)\n   {\n     CompileVarDecl compiler (ctx, fndecl);\n     stmt->accept_vis (compiler);\n@@ -64,12 +63,12 @@ class CompileVarDecl : public HIRCompileBase\n   }\n \n private:\n-  CompileVarDecl (Context *ctx, ::Bfunction *fndecl)\n+  CompileVarDecl (Context *ctx, tree fndecl)\n     : HIRCompileBase (ctx), fndecl (fndecl), translated_type (nullptr),\n       translated (nullptr)\n   {}\n \n-  ::Bfunction *fndecl;\n+  tree fndecl;\n   tree translated_type;\n   Location locus;\n   ::Bvariable *translated;"}, {"sha": "71435f37e889ef0f5f47a0de3466a80267d44b91", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -322,7 +322,7 @@ void\n CompileBlock::visit (HIR::BlockExpr &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n+  tree fndecl = fnctx.fndecl;\n   Location start_location = expr.get_locus ();\n   Location end_location = expr.get_closing_locus ();\n   auto body_mappings = expr.get_mappings ();\n@@ -393,7 +393,7 @@ void\n CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n+  tree fndecl = fnctx.fndecl;\n   tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n   Bblock *then_block\n     = CompileBlock::compile (expr.get_if_block (), ctx, result);\n@@ -407,7 +407,7 @@ void\n CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n+  tree fndecl = fnctx.fndecl;\n   tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n   Bblock *then_block\n     = CompileBlock::compile (expr.get_if_block (), ctx, result);\n@@ -423,7 +423,7 @@ void\n CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n+  tree fndecl = fnctx.fndecl;\n   tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n   Bblock *then_block\n     = CompileBlock::compile (expr.get_if_block (), ctx, result);\n@@ -478,7 +478,7 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n \n void\n HIRCompileBase::compile_function_body (\n-  Bfunction *fndecl, std::unique_ptr<HIR::BlockExpr> &function_body,\n+  tree fndecl, std::unique_ptr<HIR::BlockExpr> &function_body,\n   bool has_return_type)\n {\n   for (auto &s : function_body->get_statements ())\n@@ -523,7 +523,7 @@ HIRCompileBase::compile_function_body (\n }\n \n bool\n-HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n+HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n \t\t\t\t\t  std::vector<Bvariable *> &locals)\n {\n   rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {"}, {"sha": "836f5190e8b6f2c5926b9f692d0e207f4f1af4fe", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -41,9 +41,6 @@ saw_errors (void);\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n \n-// The backend representation of a function definition or declaration.\n-class Bfunction;\n-\n // The backend representation of a block.\n class Bblock;\n \n@@ -81,7 +78,6 @@ class Backend\n \n   // debug\n   virtual void debug (tree) = 0;\n-  virtual void debug (Bfunction *) = 0;\n   virtual void debug (Bblock *) = 0;\n   virtual void debug (Bvariable *) = 0;\n   virtual void debug (Blabel *) = 0;\n@@ -314,7 +310,7 @@ class Backend\n \n   // Create an expression for the address of a function.  This is used to\n   // get the address of the code for a function.\n-  virtual tree function_code_expression (Bfunction *, Location) = 0;\n+  virtual tree function_code_expression (tree, Location) = 0;\n \n   // Create an expression that takes the address of an expression.\n   virtual tree address_expression (tree, Location) = 0;\n@@ -329,7 +325,7 @@ class Backend\n   // Return an expression that executes THEN_EXPR if CONDITION is true, or\n   // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n   // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.\n-  virtual tree conditional_expression (Bfunction *function, tree btype,\n+  virtual tree conditional_expression (tree function, tree btype,\n \t\t\t\t       tree condition, tree then_expr,\n \t\t\t\t       tree else_expr, Location)\n     = 0;\n@@ -385,7 +381,7 @@ class Backend\n \n   // Create an expression for a call to FN with ARGS, taking place within\n   // caller CALLER.\n-  virtual tree call_expression (Bfunction *caller, tree fn,\n+  virtual tree call_expression (tree caller, tree fn,\n \t\t\t\tconst std::vector<tree> &args,\n \t\t\t\ttree static_chain, Location)\n     = 0;\n@@ -398,25 +394,22 @@ class Backend\n   virtual tree error_statement () = 0;\n \n   // Create an expression statement within the specified function.\n-  virtual tree expression_statement (Bfunction *, tree) = 0;\n+  virtual tree expression_statement (tree, tree) = 0;\n \n   // Create a variable initialization statement in the specified\n   // function.  This initializes a local variable at the point in the\n   // program flow where it is declared.\n-  virtual tree init_statement (Bfunction *, Bvariable *var, tree init) = 0;\n+  virtual tree init_statement (tree, Bvariable *var, tree init) = 0;\n \n   // Create an assignment statement within the specified function.\n-  virtual tree assignment_statement (Bfunction *, tree lhs, tree rhs, Location)\n-    = 0;\n+  virtual tree assignment_statement (tree, tree lhs, tree rhs, Location) = 0;\n \n   // Create a return statement, passing the representation of the\n   // function and the list of values to return.\n-  virtual tree return_statement (Bfunction *, const std::vector<tree> &,\n-\t\t\t\t Location)\n-    = 0;\n+  virtual tree return_statement (tree, const std::vector<tree> &, Location) = 0;\n \n   // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n-  virtual tree if_statement (Bfunction *, tree condition, Bblock *then_block,\n+  virtual tree if_statement (tree, tree condition, Bblock *then_block,\n \t\t\t     Bblock *else_block, Location)\n     = 0;\n \n@@ -433,7 +426,7 @@ class Backend\n   // either end with a goto statement or will fall through into\n   // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n   // which need not be last.  FUNCTION is the current function.\n-  virtual tree switch_statement (Bfunction *function, tree value,\n+  virtual tree switch_statement (tree function, tree value,\n \t\t\t\t const std::vector<std::vector<tree> > &cases,\n \t\t\t\t const std::vector<tree> &statements, Location)\n     = 0;\n@@ -465,7 +458,7 @@ class Backend\n   // the initial curly brace.  END_LOCATION is the location of the end\n   // of the block, more or less the location of the final curly brace.\n   // The statements will be added after the block is created.\n-  virtual Bblock *block (Bfunction *function, Bblock *enclosing,\n+  virtual Bblock *block (tree function, Bblock *enclosing,\n \t\t\t const std::vector<Bvariable *> &vars,\n \t\t\t Location start_location, Location end_location)\n     = 0;\n@@ -523,21 +516,21 @@ class Backend\n   // the function, as otherwise the variable would be on the heap).\n   // LOCATION is where the variable is defined.  For each local variable\n   // the frontend will call init_statement to set the initial value.\n-  virtual Bvariable *\n-  local_variable (Bfunction *function, const std::string &name, tree type,\n-\t\t  Bvariable *decl_var, bool is_address_taken, Location location)\n+  virtual Bvariable *local_variable (tree function, const std::string &name,\n+\t\t\t\t     tree type, Bvariable *decl_var,\n+\t\t\t\t     bool is_address_taken, Location location)\n     = 0;\n \n   // Create a function parameter.  This is an incoming parameter, not\n   // a result parameter (result parameters are treated as local\n   // variables).  The arguments are as for local_variable.\n-  virtual Bvariable *\n-  parameter_variable (Bfunction *function, const std::string &name, tree type,\n-\t\t      bool is_address_taken, Location location)\n+  virtual Bvariable *parameter_variable (tree function, const std::string &name,\n+\t\t\t\t\t tree type, bool is_address_taken,\n+\t\t\t\t\t Location location)\n     = 0;\n \n   // Create a static chain parameter.  This is the closure parameter.\n-  virtual Bvariable *static_chain_variable (Bfunction *function,\n+  virtual Bvariable *static_chain_variable (tree function,\n \t\t\t\t\t    const std::string &name, tree type,\n \t\t\t\t\t    Location location)\n     = 0;\n@@ -553,7 +546,7 @@ class Backend\n   // variable, and may not be very useful.  This function should\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n-  virtual Bvariable *temporary_variable (Bfunction *, Bblock *, tree, tree init,\n+  virtual Bvariable *temporary_variable (tree, Bblock *, tree, tree init,\n \t\t\t\t\t bool address_is_taken,\n \t\t\t\t\t Location location, tree *pstatement)\n     = 0;\n@@ -676,7 +669,7 @@ class Backend\n   // Create a new label.  NAME will be empty if this is a label\n   // created by the frontend for a loop construct.  The location is\n   // where the label is defined.\n-  virtual Blabel *label (Bfunction *, const std::string &name, Location) = 0;\n+  virtual Blabel *label (tree, const std::string &name, Location) = 0;\n \n   // Create a statement which defines a label.  This statement will be\n   // put into the codestream at the point where the label should be\n@@ -696,7 +689,7 @@ class Backend\n   // Create an error function.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bfunction *error_function () = 0;\n+  virtual tree error_function () = 0;\n \n   // Bit flags to pass to the function method.\n \n@@ -735,9 +728,9 @@ class Backend\n   // string, is the name that should be used in the symbol table; this\n   // will be non-empty if a magic extern comment is used.  FLAGS is\n   // bit flags described above.\n-  virtual Bfunction *function (tree fntype, const std::string &name,\n-\t\t\t       const std::string &asm_name, unsigned int flags,\n-\t\t\t       Location)\n+  virtual tree function (tree fntype, const std::string &name,\n+\t\t\t const std::string &asm_name, unsigned int flags,\n+\t\t\t Location)\n     = 0;\n \n   virtual tree specify_abi_attribute (tree type, Rust::ABI abi) = 0;\n@@ -746,27 +739,27 @@ class Backend\n   // be a statement that looks like this in C++:\n   //   finish:\n   //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n-  virtual tree function_defer_statement (Bfunction *function, tree undefer,\n+  virtual tree function_defer_statement (tree function, tree undefer,\n \t\t\t\t\t tree check_defer, Location)\n     = 0;\n \n   // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n   // This will only be called for a function definition.  Returns true on\n   // success, false on failure.\n   virtual bool\n-  function_set_parameters (Bfunction *function,\n+  function_set_parameters (tree function,\n \t\t\t   const std::vector<Bvariable *> &param_vars)\n     = 0;\n \n   // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n   // true on success, false on failure.\n-  virtual bool function_set_body (Bfunction *function, tree code_stmt) = 0;\n+  virtual bool function_set_body (tree function, tree code_stmt) = 0;\n \n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists.\n-  virtual Bfunction *lookup_gcc_builtin (const std::string &) = 0;\n+  virtual tree lookup_gcc_builtin (const std::string &) = 0;\n \n-  virtual Bfunction *lookup_builtin_by_rust_name (const std::string &) = 0;\n+  virtual tree lookup_builtin_by_rust_name (const std::string &) = 0;\n \n   // Utility.\n \n@@ -775,7 +768,7 @@ class Backend\n   virtual void\n   write_global_definitions (const std::vector<tree> &type_decls,\n \t\t\t    const std::vector<tree> &constant_decls,\n-\t\t\t    const std::vector<Bfunction *> &function_decls,\n+\t\t\t    const std::vector<tree> &function_decls,\n \t\t\t    const std::vector<Bvariable *> &variable_decls)\n     = 0;\n "}, {"sha": "730835325db943dda067748c8fd6658a351b4c19", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 81, "deletions": 108, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95048daaffa5e16df4d663702fe80294eac7b85e/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=95048daaffa5e16df4d663702fe80294eac7b85e", "patch": "@@ -70,12 +70,6 @@ class Gcc_tree\n \n // In gcc, types, expressions, and statements are all trees.\n \n-class Bfunction : public Gcc_tree\n-{\n-public:\n-  Bfunction (tree t) : Gcc_tree (t) {}\n-};\n-\n class Bblock : public Gcc_tree\n {\n public:\n@@ -143,7 +137,6 @@ class Gcc_backend : public Backend\n   Gcc_backend ();\n \n   void debug (tree t) { debug_tree (t); };\n-  void debug (Bfunction *t) { debug_tree (t->get_tree ()); };\n   void debug (Bblock *t) { debug_tree (t->get_tree ()); };\n   void debug (Bvariable *t) { debug_tree (t->get_decl ()); };\n   void debug (Blabel *t) { debug_tree (t->get_tree ()); };\n@@ -305,15 +298,15 @@ class Gcc_backend : public Backend\n \n   tree convert_expression (tree type, tree expr, Location);\n \n-  tree function_code_expression (Bfunction *, Location);\n+  tree function_code_expression (tree, Location);\n \n   tree address_expression (tree, Location);\n \n   tree struct_field_expression (tree, size_t, Location);\n \n   tree compound_expression (tree, tree, Location);\n \n-  tree conditional_expression (Bfunction *, tree, tree, tree, tree, Location);\n+  tree conditional_expression (tree, tree, tree, tree, tree, Location);\n \n   tree negation_expression (NegationOperator op, tree expr, Location);\n \n@@ -335,26 +328,25 @@ class Gcc_backend : public Backend\n \n   tree array_index_expression (tree array, tree index, Location);\n \n-  tree call_expression (Bfunction *caller, tree fn,\n-\t\t\tconst std::vector<tree> &args, tree static_chain,\n-\t\t\tLocation);\n+  tree call_expression (tree caller, tree fn, const std::vector<tree> &args,\n+\t\t\ttree static_chain, Location);\n \n   // Statements.\n \n   tree error_statement () { return error_mark_node; }\n \n-  tree expression_statement (Bfunction *, tree);\n+  tree expression_statement (tree, tree);\n \n-  tree init_statement (Bfunction *, Bvariable *var, tree init);\n+  tree init_statement (tree, Bvariable *var, tree init);\n \n-  tree assignment_statement (Bfunction *, tree lhs, tree rhs, Location);\n+  tree assignment_statement (tree, tree lhs, tree rhs, Location);\n \n-  tree return_statement (Bfunction *, const std::vector<tree> &, Location);\n+  tree return_statement (tree, const std::vector<tree> &, Location);\n \n-  tree if_statement (Bfunction *, tree condition, Bblock *then_block,\n+  tree if_statement (tree, tree condition, Bblock *then_block,\n \t\t     Bblock *else_block, Location);\n \n-  tree switch_statement (Bfunction *function, tree value,\n+  tree switch_statement (tree function, tree value,\n \t\t\t const std::vector<std::vector<tree>> &cases,\n \t\t\t const std::vector<tree> &statements, Location);\n \n@@ -371,8 +363,8 @@ class Gcc_backend : public Backend\n \n   // Blocks.\n \n-  Bblock *block (Bfunction *, Bblock *, const std::vector<Bvariable *> &,\n-\t\t Location, Location);\n+  Bblock *block (tree, Bblock *, const std::vector<Bvariable *> &, Location,\n+\t\t Location);\n \n   void block_add_statements (Bblock *, const std::vector<tree> &);\n \n@@ -389,17 +381,16 @@ class Gcc_backend : public Backend\n \n   void global_variable_set_init (Bvariable *, tree);\n \n-  Bvariable *local_variable (Bfunction *, const std::string &, tree,\n-\t\t\t     Bvariable *, bool, Location);\n+  Bvariable *local_variable (tree, const std::string &, tree, Bvariable *, bool,\n+\t\t\t     Location);\n \n-  Bvariable *parameter_variable (Bfunction *, const std::string &, tree,\n-\t\t\t\t bool, Location);\n+  Bvariable *parameter_variable (tree, const std::string &, tree, bool,\n+\t\t\t\t Location);\n \n-  Bvariable *static_chain_variable (Bfunction *, const std::string &, tree,\n-\t\t\t\t    Location);\n+  Bvariable *static_chain_variable (tree, const std::string &, tree, Location);\n \n-  Bvariable *temporary_variable (Bfunction *, Bblock *, tree, tree, bool,\n-\t\t\t\t Location, tree *);\n+  Bvariable *temporary_variable (tree, Bblock *, tree, tree, bool, Location,\n+\t\t\t\t tree *);\n \n   Bvariable *implicit_variable (const std::string &, const std::string &,\n \t\t\t\ttree, bool, bool, bool, int64_t);\n@@ -422,7 +413,7 @@ class Gcc_backend : public Backend\n \n   // Labels.\n \n-  Blabel *label (Bfunction *, const std::string &name, Location);\n+  Blabel *label (tree, const std::string &name, Location);\n \n   tree label_definition_statement (Blabel *);\n \n@@ -432,35 +423,32 @@ class Gcc_backend : public Backend\n \n   // Functions.\n \n-  Bfunction *error_function () { return this->make_function (error_mark_node); }\n+  tree error_function () { return error_mark_node; }\n \n-  Bfunction *function (tree fntype, const std::string &name,\n-\t\t       const std::string &asm_name, unsigned int flags,\n-\t\t       Location);\n+  tree function (tree fntype, const std::string &name,\n+\t\t const std::string &asm_name, unsigned int flags, Location);\n \n-  tree function_defer_statement (Bfunction *function, tree undefer, tree defer,\n+  tree function_defer_statement (tree function, tree undefer, tree defer,\n \t\t\t\t Location);\n \n-  bool function_set_parameters (Bfunction *function,\n+  bool function_set_parameters (tree function,\n \t\t\t\tconst std::vector<Bvariable *> &);\n \n-  bool function_set_body (Bfunction *function, tree code_stmt);\n+  bool function_set_body (tree function, tree code_stmt);\n \n-  Bfunction *lookup_gcc_builtin (const std::string &);\n+  tree lookup_gcc_builtin (const std::string &);\n \n-  Bfunction *lookup_builtin_by_rust_name (const std::string &);\n+  tree lookup_builtin_by_rust_name (const std::string &);\n \n   void write_global_definitions (const std::vector<tree> &,\n \t\t\t\t const std::vector<tree> &,\n-\t\t\t\t const std::vector<Bfunction *> &,\n+\t\t\t\t const std::vector<tree> &,\n \t\t\t\t const std::vector<Bvariable *> &);\n \n   void write_export_data (const char *bytes, unsigned int size);\n \n private:\n \n-  Bfunction *make_function (tree t) { return new Bfunction (t); }\n-\n   tree fill_in_fields (tree, const std::vector<typed_identifier> &);\n \n   tree fill_in_array (tree, tree, tree);\n@@ -479,7 +467,7 @@ class Gcc_backend : public Backend\n \t\t       int flags);\n \n   // A mapping of the GCC built-ins exposed to GCCRust.\n-  std::map<std::string, Bfunction *> builtin_functions_;\n+  std::map<std::string, tree> builtin_functions_;\n   std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n };\n \n@@ -1458,9 +1446,8 @@ Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n // Get the address of a function.\n \n tree\n-Gcc_backend::function_code_expression (Bfunction *bfunc, Location location)\n+Gcc_backend::function_code_expression (tree func, Location location)\n {\n-  tree func = bfunc->get_tree ();\n   if (func == error_mark_node)\n     return this->error_expression ();\n \n@@ -1527,9 +1514,9 @@ Gcc_backend::compound_expression (tree stat, tree expr, Location location)\n // ELSE_EXPR otherwise.\n \n tree\n-Gcc_backend::conditional_expression (Bfunction *, tree type_tree,\n-\t\t\t\t     tree cond_expr, tree then_expr,\n-\t\t\t\t     tree else_expr, Location location)\n+Gcc_backend::conditional_expression (tree, tree type_tree, tree cond_expr,\n+\t\t\t\t     tree then_expr, tree else_expr,\n+\t\t\t\t     Location location)\n {\n   if (type_tree == error_mark_node || cond_expr == error_mark_node\n       || then_expr == error_mark_node || else_expr == error_mark_node)\n@@ -1949,7 +1936,7 @@ Gcc_backend::array_index_expression (tree array_tree, tree index_tree,\n \n // Create an expression for a call to FN_EXPR with FN_ARGS.\n tree\n-Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n+Gcc_backend::call_expression (tree, // containing fcn for call\n \t\t\t      tree fn, const std::vector<tree> &fn_args,\n \t\t\t      tree chain_expr, Location location)\n {\n@@ -2025,15 +2012,15 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n // An expression as a statement.\n \n tree\n-Gcc_backend::expression_statement (Bfunction *, tree expr)\n+Gcc_backend::expression_statement (tree, tree expr)\n {\n   return expr;\n }\n \n // Variable initialization.\n \n tree\n-Gcc_backend::init_statement (Bfunction *, Bvariable *var, tree init_tree)\n+Gcc_backend::init_statement (tree, Bvariable *var, tree init_tree)\n {\n   tree var_tree = var->get_decl ();\n   if (var_tree == error_mark_node || init_tree == error_mark_node)\n@@ -2065,7 +2052,7 @@ Gcc_backend::init_statement (Bfunction *, Bvariable *var, tree init_tree)\n // Assignment.\n \n tree\n-Gcc_backend::assignment_statement (Bfunction *bfn, tree lhs, tree rhs,\n+Gcc_backend::assignment_statement (tree bfn, tree lhs, tree rhs,\n \t\t\t\t   Location location)\n {\n   if (lhs == error_mark_node || rhs == error_mark_node)\n@@ -2093,10 +2080,9 @@ Gcc_backend::assignment_statement (Bfunction *bfn, tree lhs, tree rhs,\n // Return.\n \n tree\n-Gcc_backend::return_statement (Bfunction *bfunction,\n-\t\t\t       const std::vector<tree> &vals, Location location)\n+Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n+\t\t\t       Location location)\n {\n-  tree fntree = bfunction->get_tree ();\n   if (fntree == error_mark_node)\n     return this->error_statement ();\n   tree result = DECL_RESULT (fntree);\n@@ -2208,7 +2194,7 @@ Gcc_backend::exception_handler_statement (tree try_stmt, tree except_stmt,\n // If.\n \n tree\n-Gcc_backend::if_statement (Bfunction *, tree cond_tree, Bblock *then_block,\n+Gcc_backend::if_statement (tree, tree cond_tree, Bblock *then_block,\n \t\t\t   Bblock *else_block, Location location)\n {\n   tree then_tree = then_block->get_tree ();\n@@ -2240,14 +2226,13 @@ Gcc_backend::exit_expression (tree cond_tree, Location locus)\n // Switch.\n \n tree\n-Gcc_backend::switch_statement (Bfunction *function, tree value,\n+Gcc_backend::switch_statement (tree decl, tree value,\n \t\t\t       const std::vector<std::vector<tree>> &cases,\n \t\t\t       const std::vector<tree> &statements,\n \t\t\t       Location switch_location)\n {\n   gcc_assert (cases.size () == statements.size ());\n \n-  tree decl = function->get_tree ();\n   if (DECL_STRUCT_FUNCTION (decl) == NULL)\n     push_struct_function (decl);\n   else\n@@ -2345,14 +2330,13 @@ Gcc_backend::statement_list (const std::vector<tree> &statements)\n // the Bblock.\n \n Bblock *\n-Gcc_backend::block (Bfunction *function, Bblock *enclosing,\n+Gcc_backend::block (tree fndecl, Bblock *enclosing,\n \t\t    const std::vector<Bvariable *> &vars,\n \t\t    Location start_location, Location)\n {\n   tree block_tree = make_node (BLOCK);\n   if (enclosing == NULL)\n     {\n-      tree fndecl = function->get_tree ();\n       gcc_assert (fndecl != NULL_TREE);\n \n       // We may have already created a block for local variables when\n@@ -2599,15 +2583,15 @@ Gcc_backend::global_variable_set_init (Bvariable *var, tree expr_tree)\n // Make a local variable.\n \n Bvariable *\n-Gcc_backend::local_variable (Bfunction *function, const std::string &name,\n+Gcc_backend::local_variable (tree function, const std::string &name,\n \t\t\t     tree type_tree, Bvariable *decl_var,\n \t\t\t     bool is_address_taken, Location location)\n {\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), VAR_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_CONTEXT (decl) = function->get_tree ();\n+  DECL_CONTEXT (decl) = function;\n   TREE_USED (decl) = 1;\n   if (is_address_taken)\n     TREE_ADDRESSABLE (decl) = 1;\n@@ -2623,15 +2607,15 @@ Gcc_backend::local_variable (Bfunction *function, const std::string &name,\n // Make a function parameter variable.\n \n Bvariable *\n-Gcc_backend::parameter_variable (Bfunction *function, const std::string &name,\n+Gcc_backend::parameter_variable (tree function, const std::string &name,\n \t\t\t\t tree type_tree, bool is_address_taken,\n \t\t\t\t Location location)\n {\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), PARM_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_CONTEXT (decl) = function->get_tree ();\n+  DECL_CONTEXT (decl) = function;\n   DECL_ARG_TYPE (decl) = type_tree;\n   TREE_USED (decl) = 1;\n   if (is_address_taken)\n@@ -2643,15 +2627,13 @@ Gcc_backend::parameter_variable (Bfunction *function, const std::string &name,\n // Make a static chain variable.\n \n Bvariable *\n-Gcc_backend::static_chain_variable (Bfunction *function,\n-\t\t\t\t    const std::string &name, tree type_tree,\n-\t\t\t\t    Location location)\n+Gcc_backend::static_chain_variable (tree fndecl, const std::string &name,\n+\t\t\t\t    tree type_tree, Location location)\n {\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), PARM_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  tree fndecl = function->get_tree ();\n   DECL_CONTEXT (decl) = fndecl;\n   DECL_ARG_TYPE (decl) = type_tree;\n   TREE_USED (decl) = 1;\n@@ -2677,15 +2659,13 @@ Gcc_backend::static_chain_variable (Bfunction *function,\n // Make a temporary variable.\n \n Bvariable *\n-Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n-\t\t\t\t tree type_tree, tree init_tree,\n-\t\t\t\t bool is_address_taken, Location location,\n-\t\t\t\t tree *pstatement)\n+Gcc_backend::temporary_variable (tree fndecl, Bblock *bblock, tree type_tree,\n+\t\t\t\t tree init_tree, bool is_address_taken,\n+\t\t\t\t Location location, tree *pstatement)\n {\n-  gcc_assert (function != NULL);\n-  tree decl = function->get_tree ();\n+  gcc_assert (fndecl != NULL_TREE);\n   if (type_tree == error_mark_node || init_tree == error_mark_node\n-      || decl == error_mark_node)\n+      || fndecl == error_mark_node)\n     {\n       *pstatement = this->error_statement ();\n       return this->error_variable ();\n@@ -2695,10 +2675,10 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n   // We can only use create_tmp_var if the type is not addressable.\n   if (!TREE_ADDRESSABLE (type_tree))\n     {\n-      if (DECL_STRUCT_FUNCTION (decl) == NULL)\n-\tpush_struct_function (decl);\n+      if (DECL_STRUCT_FUNCTION (fndecl) == NULL)\n+\tpush_struct_function (fndecl);\n       else\n-\tpush_cfun (DECL_STRUCT_FUNCTION (decl));\n+\tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \n       var = create_tmp_var (type_tree, \"RUSTTMP\");\n       pop_cfun ();\n@@ -2711,7 +2691,7 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n       DECL_ARTIFICIAL (var) = 1;\n       DECL_IGNORED_P (var) = 1;\n       TREE_USED (var) = 1;\n-      DECL_CONTEXT (var) = decl;\n+      DECL_CONTEXT (var) = fndecl;\n \n       // We have to add this variable to the BLOCK and the BIND_EXPR.\n       tree bind_tree = bblock->get_tree ();\n@@ -2739,7 +2719,7 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n       && (this->type_size (type_tree) == 0\n \t  || TREE_TYPE (init_tree) == void_type_node))\n     *pstatement = this->compound_statement (\n-      this->expression_statement (function, init_tree), *pstatement);\n+      this->expression_statement (fndecl, init_tree), *pstatement);\n \n   return new Bvariable (var);\n }\n@@ -2950,13 +2930,11 @@ Gcc_backend::immutable_struct_reference (const std::string &name,\n // Make a label.\n \n Blabel *\n-Gcc_backend::label (Bfunction *function, const std::string &name,\n-\t\t    Location location)\n+Gcc_backend::label (tree func_tree, const std::string &name, Location location)\n {\n   tree decl;\n   if (name.empty ())\n     {\n-      tree func_tree = function->get_tree ();\n       if (DECL_STRUCT_FUNCTION (func_tree) == NULL)\n \tpush_struct_function (func_tree);\n       else\n@@ -2971,7 +2949,7 @@ Gcc_backend::label (Bfunction *function, const std::string &name,\n       tree id = get_identifier_from_string (name);\n       decl\n \t= build_decl (location.gcc_location (), LABEL_DECL, id, void_type_node);\n-      DECL_CONTEXT (decl) = function->get_tree ();\n+      DECL_CONTEXT (decl) = func_tree;\n     }\n   return new Blabel (decl);\n }\n@@ -3013,7 +2991,7 @@ Gcc_backend::label_address (Blabel *label, Location location)\n \n // Declare or define a new function.\n \n-Bfunction *\n+tree\n Gcc_backend::function (tree functype, const std::string &name,\n \t\t       const std::string &asm_name, unsigned int flags,\n \t\t       Location location)\n@@ -3061,7 +3039,7 @@ Gcc_backend::function (tree functype, const std::string &name,\n     TREE_READONLY (decl) = 1;\n \n   rust_preserve_from_gc (decl);\n-  return new Bfunction (decl);\n+  return decl;\n }\n \n // Create a statement that runs all deferred calls for FUNCTION.  This should\n@@ -3070,19 +3048,17 @@ Gcc_backend::function (tree functype, const std::string &name,\n //     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n \n tree\n-Gcc_backend::function_defer_statement (Bfunction *function, tree undefer_tree,\n+Gcc_backend::function_defer_statement (tree function, tree undefer_tree,\n \t\t\t\t       tree defer_tree, Location location)\n {\n-  tree fntree = function->get_tree ();\n-\n   if (undefer_tree == error_mark_node || defer_tree == error_mark_node\n-      || fntree == error_mark_node)\n+      || function == error_mark_node)\n     return this->error_statement ();\n \n-  if (DECL_STRUCT_FUNCTION (fntree) == NULL)\n-    push_struct_function (fntree);\n+  if (DECL_STRUCT_FUNCTION (function) == NULL)\n+    push_struct_function (function);\n   else\n-    push_cfun (DECL_STRUCT_FUNCTION (fntree));\n+    push_cfun (DECL_STRUCT_FUNCTION (function));\n \n   tree stmt_list = NULL;\n   Blabel *blabel = this->label (function, \"\", location);\n@@ -3106,10 +3082,9 @@ Gcc_backend::function_defer_statement (Bfunction *function, tree undefer_tree,\n \n bool\n Gcc_backend::function_set_parameters (\n-  Bfunction *function, const std::vector<Bvariable *> &param_vars)\n+  tree function, const std::vector<Bvariable *> &param_vars)\n {\n-  tree func_tree = function->get_tree ();\n-  if (func_tree == error_mark_node)\n+  if (function == error_mark_node)\n     return false;\n \n   tree params = NULL_TREE;\n@@ -3122,35 +3097,33 @@ Gcc_backend::function_set_parameters (\n       pp = &DECL_CHAIN (*pp);\n     }\n   *pp = NULL_TREE;\n-  DECL_ARGUMENTS (func_tree) = params;\n+  DECL_ARGUMENTS (function) = params;\n   return true;\n }\n \n // Set the function body for FUNCTION using the code in CODE_BLOCK.\n \n bool\n-Gcc_backend::function_set_body (Bfunction *function, tree code_stmt)\n+Gcc_backend::function_set_body (tree function, tree code_stmt)\n {\n-  tree func_tree = function->get_tree ();\n-\n-  if (func_tree == error_mark_node || code_stmt == error_mark_node)\n+  if (function == error_mark_node || code_stmt == error_mark_node)\n     return false;\n-  DECL_SAVED_TREE (func_tree) = code_stmt;\n+  DECL_SAVED_TREE (function) = code_stmt;\n   return true;\n }\n \n // Look up a named built-in function in the current backend implementation.\n // Returns NULL if no built-in function by that name exists.\n \n-Bfunction *\n+tree\n Gcc_backend::lookup_gcc_builtin (const std::string &name)\n {\n   if (this->builtin_functions_.count (name) != 0)\n     return this->builtin_functions_[name];\n   return NULL;\n }\n \n-Bfunction *\n+tree\n Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n {\n   auto it = rust_intrinsic_to_gcc_builtin.find (name);\n@@ -3167,7 +3140,7 @@ Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n void\n Gcc_backend::write_global_definitions (\n   const std::vector<tree> &type_decls, const std::vector<tree> &constant_decls,\n-  const std::vector<Bfunction *> &function_decls,\n+  const std::vector<tree> &function_decls,\n   const std::vector<Bvariable *> &variable_decls)\n {\n   size_t count_definitions = type_decls.size () + constant_decls.size ()\n@@ -3211,10 +3184,10 @@ Gcc_backend::write_global_definitions (\n \t  ++i;\n \t}\n     }\n-  for (std::vector<Bfunction *>::const_iterator p = function_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = function_decls.begin ();\n        p != function_decls.end (); ++p)\n     {\n-      tree decl = (*p)->get_tree ();\n+      tree decl = (*p);\n       if (decl != error_mark_node)\n \t{\n \t  rust_preserve_from_gc (decl);\n@@ -3262,7 +3235,7 @@ Gcc_backend::define_builtin (const std::string rust_name,\n   if ((flags & builtin_novops) != 0)\n     DECL_IS_NOVOPS (decl) = 1;\n   set_builtin_decl (bcode, decl, true);\n-  this->builtin_functions_[name] = this->make_function (decl);\n+  this->builtin_functions_[name] = decl;\n   if (libname != NULL)\n     {\n       decl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n@@ -3273,7 +3246,7 @@ Gcc_backend::define_builtin (const std::string rust_name,\n \tTREE_THIS_VOLATILE (decl) = 1;\n       if ((flags & builtin_novops) != 0)\n \tDECL_IS_NOVOPS (decl) = 1;\n-      this->builtin_functions_[libname] = this->make_function (decl);\n+      this->builtin_functions_[libname] = decl;\n     }\n \n   rust_intrinsic_to_gcc_builtin[rust_name] = name;"}]}