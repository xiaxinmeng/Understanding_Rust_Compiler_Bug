{"sha": "04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d", "node_id": "C_kwDOANBUbNoAKDA0ZjE5NTgwZThkYmRiYzczNjZkMGY1ZmQwNjhhYTBjZWNhZmRjOWQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-26T14:20:16Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-26T14:20:16Z"}, "message": "c++: ICE when building builtin operator->* set [PR103455]\n\nHere when constructing the builtin operator->* candidate set according\nto the available conversion functions for the operand types, we end up\nconsidering a candidate with C1=T (through B's dependent conversion\nfunction) and C2=F, during which we crash from DERIVED_FROM_P because\ndependent_type_p sees a TEMPLATE_TYPE_PARM outside of a template\ncontext.\n\nSidestepping the question of whether we should be considering such a\ndependent conversion function here in the first place, it seems futile\nto test DERIVED_FROM_P for anything other than an actual class type, so\nthis patch fixes this ICE by simply guarding the DERIVED_FROM_P test\nwith CLASS_TYPE_P instead of MAYBE_CLASS_TYPE_P.\n\n\tPR c++/103455\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (add_builtin_candidate) <case MEMBER_REF>: Test\n\tCLASS_TYPE_P instead of MAYBE_CLASS_TYPE_P.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/overload/builtin6.C: New test.", "tree": {"sha": "39273eb9e1a7b1a695fbf64096396ad866ce1fdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39273eb9e1a7b1a695fbf64096396ad866ce1fdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d/comments", "author": null, "committer": null, "parents": [{"sha": "ede5f5224d55b84b9f186b288164df9c06fd85e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede5f5224d55b84b9f186b288164df9c06fd85e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ede5f5224d55b84b9f186b288164df9c06fd85e7"}], "stats": {"total": 16, "additions": 15, "deletions": 1}, "files": [{"sha": "dfe370d685dfd3b30e19244f223a1924967e5cfd", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d", "patch": "@@ -2821,7 +2821,7 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t  tree c1 = TREE_TYPE (type1);\n \t  tree c2 = TYPE_PTRMEM_CLASS_TYPE (type2);\n \n-\t  if (MAYBE_CLASS_TYPE_P (c1) && DERIVED_FROM_P (c2, c1)\n+\t  if (CLASS_TYPE_P (c1) && DERIVED_FROM_P (c2, c1)\n \t      && (TYPE_PTRMEMFUNC_P (type2)\n \t\t  || is_complete (TYPE_PTRMEM_POINTED_TO_TYPE (type2))))\n \t    break;"}, {"sha": "de192be67ecc5f14c7236a7d902d7e7f886d9428", "filename": "gcc/testsuite/g++.dg/overload/builtin6.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fbuiltin6.C?ref=04f19580e8dbdbc7366d0f5fd068aa0cecafdc9d", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/103455\n+\n+struct A { };\n+\n+struct B {\n+  operator A*() const;\n+  template<class T> operator T*() const;\n+};\n+\n+typedef void (A::*F)();\n+\n+void f(B b, F pmf) {\n+  (b->*pmf)();\n+}"}]}