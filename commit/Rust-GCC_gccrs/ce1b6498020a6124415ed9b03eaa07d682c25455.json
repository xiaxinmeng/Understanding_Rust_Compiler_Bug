{"sha": "ce1b6498020a6124415ed9b03eaa07d682c25455", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxYjY0OTgwMjBhNjEyNDQxNWVkOWIwM2VhYTA3ZDY4MmMyNTQ1NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-12-04T15:55:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-12-04T15:55:25Z"}, "message": "re PR middle-end/36509 (gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c)\n\n2008-12-04  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/36509\n\tPR c++/38334\n\t* Makefile.in (tree-ssa-alias-warnings.o): Remove.\n\t(tree-ssa-structalias.o): Remove errors.h dependency.\n\t(tree-ssa-reassoc.o): Likewise.\n\t* tree-ssa-reassoc.c: Do not include errors.h.\n\t* tree-ssa-alias-warnings.c: Remove.\n\t* tree-ssa-alias.c (compute_may_aliases): Remove call to\n\tstrict_aliasing_warning_backend.\n\t* tree-ssa-structalias.c (emit_pointer_definition): New function.\n\t(emit_alias_warning): Likewise.\n\t(set_uids_in_ptset): Warn for clear cases of type-punning.\n\t* tree-inline.c (remap_gimple_op_r): Preserve TREE_NO_WARNING\n\ton INDIRECT_REFs.\n\n\tcp/\n\t* typeck.c (get_member_function_from_ptrfunc): Mark the vtbl\n\tpointer access with TREE_NO_WARNING.\n\n\t* gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c: Adjust, remove XFAIL.\n\t* gcc.dg/Wstrict-aliasing-converted-assigned.c: Adjust.\n\t* g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C: Likewise.\n\nFrom-SVN: r142437", "tree": {"sha": "266c7ec6506d5c152c0f89ceef62763632c6a3ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/266c7ec6506d5c152c0f89ceef62763632c6a3ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce1b6498020a6124415ed9b03eaa07d682c25455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1b6498020a6124415ed9b03eaa07d682c25455", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce1b6498020a6124415ed9b03eaa07d682c25455", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1b6498020a6124415ed9b03eaa07d682c25455/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a4781348e23ac96865470f4b11c170e9f40a44d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4781348e23ac96865470f4b11c170e9f40a44d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4781348e23ac96865470f4b11c170e9f40a44d5"}], "stats": {"total": 1213, "additions": 154, "deletions": 1059}, "files": [{"sha": "d9b81fede57c4fbd91bd541eeacc1a350cb76f67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -1,3 +1,19 @@\n+2008-12-04  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/36509\n+\t* Makefile.in (tree-ssa-alias-warnings.o): Remove.\n+\t(tree-ssa-structalias.o): Remove errors.h dependency.\n+\t(tree-ssa-reassoc.o): Likewise.\n+\t* tree-ssa-reassoc.c: Do not include errors.h.\n+\t* tree-ssa-alias-warnings.c: Remove.\n+\t* tree-ssa-alias.c (compute_may_aliases): Remove call to\n+\tstrict_aliasing_warning_backend.\n+\t* tree-ssa-structalias.c (emit_pointer_definition): New function.\n+\t(emit_alias_warning): Likewise.\n+\t(set_uids_in_ptset): Warn for clear cases of type-punning.\n+\t* tree-inline.c (remap_gimple_op_r): Preserve TREE_NO_WARNING\n+\ton INDIRECT_REFs.\n+\n 2008-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* cse.c (equiv_constant): Fix pasto."}, {"sha": "b50d1f4e3dc8cf9a93a771d90968df5285bc3dec", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -1243,7 +1243,6 @@ OBJS-common = \\\n \ttree-switch-conversion.o \\\n \ttree-ssa-address.o \\\n \ttree-ssa-alias.o \\\n-\ttree-ssa-alias-warnings.o \\\n \ttree-ssa-ccp.o \\\n \ttree-ssa-coalesce.o \\\n \ttree-ssa-copy.o \\\n@@ -2089,7 +2088,7 @@ stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TOPLEV_H)\n tree-ssa-structalias.o: tree-ssa-structalias.c tree-ssa-structalias.h \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \\\n-   $(FLAGS_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) output.h errors.h \\\n+   $(FLAGS_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n    $(DIAGNOSTIC_H) $(TREE_H) $(C_COMMON_H) $(TREE_FLOW_H) $(TREE_INLINE_H) varray.h \\\n    $(C_TREE_H) $(GIMPLE_H) $(HASHTAB_H) $(FUNCTION_H) $(CGRAPH_H) tree-pass.h \\\n    $(TIMEVAR_H) alloc-pool.h $(SPLAY_TREE_H) $(PARAMS_H) gt-tree-ssa-structalias.h \\\n@@ -2309,19 +2308,14 @@ tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-math-opts.o : tree-ssa-math-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(FLAGS_H) $(TREE_H) $(TREE_FLOW_H) $(REAL_H) $(TIMEVAR_H) tree-pass.h \\\n    alloc-pool.h $(BASIC_BLOCK_H) $(TARGET_H)\n-tree-ssa-alias-warnings.o : tree-ssa-alias-warnings.c \\\n-   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(TREE_DUMP_H) \\\n-   $(TREE_FLOW_H) $(PARAMS_H) $(FUNCTION_H) $(EXPR_H) $(TOPLEV_H) \\\n-   tree-ssa-structalias.h tree-ssa-propagate.h langhooks.h alloc-pool.h \\\n-   $(DIAGNOSTIC_H)\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(TREE_INLINE_H) $(FLAGS_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \\\n    $(TREE_DUMP_H) tree-pass.h $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    hard-reg-set.h $(GIMPLE_H) vec.h tree-ssa-structalias.h \\\n    $(IPA_TYPE_ESCAPE_H) vecprim.h pointer-set.h alloc-pool.h\n tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \\\n+   $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\\\n    $(BASIC_BLOCK_H) $(GIMPLE_H) $(TREE_INLINE_H) vec.h langhooks.h \\\n    alloc-pool.h pointer-set.h $(CFGLOOP_H)"}, {"sha": "029d2adbb86e43072ae163469eb7d4bee9658d98", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -1,3 +1,9 @@\n+2008-12-04  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR c++/38334\n+\t* typeck.c (get_member_function_from_ptrfunc): Mark the vtbl\n+\tpointer access with TREE_NO_WARNING.\n+\n 2008-12-03  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/38232"}, {"sha": "ed01c511f3c2354f08160edcf9f8a95263a0e01e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -2790,6 +2790,10 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       vtbl = build1 (NOP_EXPR, build_pointer_type (vtbl_ptr_type_node),\n \t\t     instance_ptr);\n       vtbl = cp_build_indirect_ref (vtbl, NULL, tf_warning_or_error);\n+      /* If the object is not dynamic the access invokes undefined\n+\t behavior.  As it is not executed in this case silence the\n+\t spurious warnings it may provoke.  */\n+      TREE_NO_WARNING (vtbl) = 1;\n \n       /* Finally, extract the function pointer from the vtable.  */\n       e2 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtbl), vtbl,"}, {"sha": "e58bdbb01b87a0b099a1002ccb0afe81ace2da2e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -1,3 +1,10 @@\n+2008-12-04  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/36509\n+\t* gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c: Adjust, remove XFAIL.\n+\t* gcc.dg/Wstrict-aliasing-converted-assigned.c: Adjust.\n+\t* g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C: Likewise.\n+\n 2008-12-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.dg/union-4.c: New test."}, {"sha": "d88ed4314b33dba13a5c831fd14c77b5bbb77657", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -4,7 +4,9 @@\n \n int foo() {\n   int x;\n-  float& q = reinterpret_cast<float&> (x);  /* { dg-warning \"type-punn\" } */\n-  q = 1.0;\n+  float& q = reinterpret_cast<float&> (x);  /* { dg-message \"initialized\" } */\n+  q = 1.0; /* { dg-warning \"does break strict-aliasing\" } */\n   return x;\n }\n+\n+/* { dg-message \"dereferencing type-punned\" \"\" { target *-*-* } 7 } */"}, {"sha": "eb404a190135f27f12185f625030bfd5574adb39", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-converted-assigned.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -8,3 +8,6 @@ int foo()\n   *(long*)&i = 0;  /* { dg-warning \"type-punn\" } */\n   return i;\n }\n+\n+/* { dg-message \"does break strict-aliasing\" \"\" { target *-*-* } 8 } */\n+/* { dg-message \"initialized\" \"\" { target *-*-* } 8 } */"}, {"sha": "fccc178d22428cee92aae2ac05cb1e7f37c1fe2b", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -11,12 +11,12 @@ int foo() {\n   float* r;\n \n   if (flag) {\n-    q = (float*) &x;  /* { dg-warning \"type-punn\" \"\" { xfail *-*-* } } */\n+    q = (float*) &x;  /* { dg-message \"initialized\" } */\n   } else {\n-    q = (float*) &y;  /* { dg-warning \"type-punn\" \"\" { xfail *-*-* } } */\n+    q = (float*) &y;  /* { dg-message \"initialized\" } */\n   }\n \n-  *q = 1.0;\n+  *q = 1.0;  /* { dg-warning \"does break strict-aliasing\" } */\n \n   return x;\n "}, {"sha": "075e575d11b1bf72ac04097ecd4a35464d5ce0f0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -710,6 +710,7 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t\t    {\n \t              *tp = build1 (INDIRECT_REF, type, new_tree);\n \t\t      TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n+\t\t      TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n \t\t    }\n \t\t}\n \t      *walk_subtrees = 0;"}, {"sha": "5bae978187a66c1f4debeb54eab5cc598904c8ac", "filename": "gcc/tree-ssa-alias-warnings.c", "status": "removed", "additions": 0, "deletions": 1033, "changes": 1033, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4781348e23ac96865470f4b11c170e9f40a44d5/gcc%2Ftree-ssa-alias-warnings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4781348e23ac96865470f4b11c170e9f40a44d5/gcc%2Ftree-ssa-alias-warnings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias-warnings.c?ref=a4781348e23ac96865470f4b11c170e9f40a44d5", "patch": "@@ -1,1033 +0,0 @@\n-/* Strict aliasing checks.\n-   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n-   Contributed by Silvius Rus <rus@google.com>.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"alloc-pool.h\"\n-#include \"tree.h\"\n-#include \"tree-dump.h\"\n-#include \"tree-flow.h\"\n-#include \"params.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"toplev.h\"\n-#include \"diagnostic.h\"\n-#include \"tree-ssa-structalias.h\"\n-#include \"tree-ssa-propagate.h\"\n-#include \"langhooks.h\"\n-\n-/* Module to issue a warning when a program uses data through a type\n-   different from the type through which the data were defined.\n-   Implements -Wstrict-aliasing and -Wstrict-aliasing=n.\n-   These checks only happen when -fstrict-aliasing is present.\n-\n-   The idea is to use the compiler to identify occurrences of nonstandard\n-   aliasing, and report them to programmers.  Programs free of such aliasing\n-   are more portable, maintainable, and can usually be optimized better.\n-\n-   The current, as of April 2007, C and C++ language standards forbid\n-   accessing data of type A through an lvalue of another type B,\n-   with certain exceptions. See the C Standard ISO/IEC 9899:1999,\n-   section 6.5, paragraph 7, and the C++ Standard ISO/IEC 14882:1998,\n-   section 3.10, paragraph 15.\n-\n-   Example 1:*a is used as int but was defined as a float, *b.\n-        int* a = ...;\n-        float* b = reinterpret_cast<float*> (a);\n-        *b = 2.0;\n-        return *a\n-\n-   Unfortunately, the problem is in general undecidable if we take into\n-   account arithmetic expressions such as array indices or pointer arithmetic.\n-   (It is at least as hard as Peano arithmetic decidability.)\n-   Even ignoring arithmetic, the problem is still NP-hard, because it is\n-   at least as hard as flow-insensitive may-alias analysis, which was proved\n-   NP-hard by Horwitz et al, TOPLAS 1997.\n-\n-   It is clear that we need to choose some heuristics.\n-   Unfortunately, various users have different goals which correspond to\n-   different time budgets so a common approach will not suit all.\n-   We present the user with three effort/accuracy levels.  By accuracy, we mean\n-   a common-sense mix of low count of false positives with a\n-   reasonably low number of false negatives.  We are heavily biased\n-   towards a low count of false positives.\n-   The effort (compilation time) is likely to increase with the level.\n-\n-   -Wstrict-aliasing=1\n-   ===================\n-   Most aggressive, least accurate.  Possibly useful when higher levels\n-   do not warn but -fstrict-aliasing still breaks the code, as\n-   it has very few false negatives.\n-   Warn for all bad pointer conversions, even if never dereferenced.\n-   Implemented in the front end (c-common.c).\n-   Uses alias_sets_might_conflict to compare types.\n-\n-   -Wstrict-aliasing=2\n-   ===================\n-   Aggressive, not too precise.\n-   May still have many false positives (not as many as level 1 though),\n-   and few false negatives (but possibly more than level 1).\n-   Runs only in the front end. Uses alias_sets_might_conflict to\n-   compare types. Does not check for pointer dereferences.\n-   Only warns when an address is taken. Warns about incomplete type punning.\n-\n-   -Wstrict-aliasing=3 (default)\n-   ===================\n-   Should have very few false positives and few false negatives.\n-   Takes care of the common pun+dereference pattern in the front end:\n-   *(int*)&some_float.\n-   Takes care of multiple statement cases in the back end,\n-   using flow-sensitive points-to information (-O required).\n-   Uses alias_sets_conflict_p to compare types and only warns\n-   when the converted pointer is dereferenced.\n-   Does not warn about incomplete type punning.\n-\n-   Future improvements can be included by adding higher levels.\n-\n-   In summary, expression level analysis is performed in the front-end,\n-   and multiple-statement analysis is performed in the backend.\n-   The remainder of this discussion is only about the backend analysis.\n-\n-   This implementation uses flow-sensitive points-to information.\n-   Flow-sensitivity refers to accesses to the pointer, and not the object\n-   pointed.  For instance, we do not warn about the following case.\n-\n-   Example 2.\n-        int* a = (int*)malloc (...);\n-        float* b = reinterpret_cast<float*> (a);\n-        *b = 2.0;\n-        a = (int*)malloc (...);\n-        return *a;\n-\n-   In SSA, it becomes clear that the INT value *A_2 referenced in the\n-   return statement is not aliased to the FLOAT defined through *B_1.\n-        int* a_1 = (int*)malloc (...);\n-        float* b_1 = reinterpret_cast<float*> (a_1);\n-        *b_1 = 2.0;\n-        a_2 = (int*)malloc (...);\n-        return *a_2;\n-\n-\n-   Algorithm Outline\n-   =================\n-\n-   ForEach (ptr, object) in the points-to table\n-     If (incompatible_types (*ptr, object))\n-       If (referenced (ptr, current function)\n-           and referenced (object, current function))\n-         Issue warning (ptr, object, reference locations)\n-\n-   The complexity is:\n-   O (sizeof (points-to table)\n-      + sizeof (function body) * lookup_time (points-to table))\n-\n-   Pointer dereference locations are looked up on demand.  The search is\n-   a single scan of the function body, in which all references to pointers\n-   and objects in the points-to table are recorded.  However, this dominant\n-   time factor occurs rarely, only when cross-type aliasing was detected.\n-\n-\n-   Limitations of the Proposed Implementation\n-   ==========================================\n-\n-   1. We do not catch the following case, because -fstrict-aliasing will\n-      associate different tags with MEM while building points-to information,\n-      thus before we get to analyze it.\n-      XXX: this could be solved by either running with -fno-strict-aliasing\n-      or by recording the points-to information before splitting the original\n-      tag based on type.\n-\n-   Example 3.\n-        void* mem = malloc (...);\n-\tint* pi = reinterpret_cast<int*> (mem);\n-\tfloat* b = reinterpret_cast<float*> (mem);\n-\t*b = 2.0;\n-\treturn *pi+1;\n-\n-   2. We do not check whether the two conflicting (de)references can\n-      reach each other in the control flow sense.  If we fixed limitation\n-      1, we would wrongly issue a warning in the following case.\n-\n-   Example 4.\n-        void* raw = malloc (...);\n-        if (...) {\n-         float* b = reinterpret_cast<float*> (raw);\n-         *b = 2.0;\n-         return (int)*b;\n-        } else {\n-         int* a = reinterpret_cast<int*> (raw);\n-         *a = 1;\n-         return *a;\n-\n-   3. Only simple types are compared, thus no structures, unions or classes\n-      are analyzed.  A first attempt to deal with structures introduced much\n-      complication and has not showed much improvement in preliminary tests,\n-      so it was left out.\n-\n-   4. All analysis is intraprocedural.  */\n-\n-\n-/* Local declarations.  */\n-static void find_references_in_function (void);\n-\f\n-\n-\n-/* Get main type of tree TYPE, stripping array dimensions and qualifiers.  */\n-\n-static tree\n-get_main_type (tree type)\n-{\n-  while (TREE_CODE (type) == ARRAY_TYPE)\n-    type = TREE_TYPE (type);\n-  return TYPE_MAIN_VARIANT (type);\n-}\n-\n-\n-/* Get the type of the given object.  If IS_PTR is true, get the type of the\n-   object pointed to or referenced by OBJECT instead.\n-   For arrays, return the element type.  Ignore all qualifiers.  */\n-\n-static tree\n-get_otype (tree object, bool is_ptr)\n-{\n-  tree otype = TREE_TYPE (object);\n-\n-  if (is_ptr)\n-    {\n-      gcc_assert (POINTER_TYPE_P (otype));\n-      otype = TREE_TYPE (otype);\n-    }\n-  return get_main_type (otype);\n-}\n-\n-\n-/* Return true if tree TYPE is struct, class or union.  */\n-\n-static bool\n-struct_class_union_p (tree type)\n-{\n-  return (TREE_CODE (type) == RECORD_TYPE\n-\t  || TREE_CODE (type) == UNION_TYPE\n-\t  || TREE_CODE (type) == QUAL_UNION_TYPE);\n-}\n-\f\n-\n-\n-/* Keep data during a search for an aliasing site.\n-   RHS = object or pointer aliased.  No LHS is specified because we are only\n-   looking in the UseDef paths of a given variable, so LHS will always be\n-   an SSA name of the same variable.\n-   When IS_RHS_POINTER = true, we are looking for ... = RHS.  Otherwise,\n-   we are looking for ... = &RHS.\n-   SITE is the output of a search, non-NULL if the search succeeded.  */\n-\n-struct alias_match\n-{\n-  tree rhs;\n-  bool is_rhs_pointer;\n-  gimple site;\n-};\n-\n-\n-/* Callback for find_alias_site.  Return true if the right hand site\n-   of STMT matches DATA.  */\n-\n-static bool\n-find_alias_site_helper (tree var ATTRIBUTE_UNUSED, gimple stmt, void *data)\n-{\n-  struct alias_match *match = (struct alias_match *) data;\n-  tree rhs_pointer = NULL_TREE;\n-  tree to_match = NULL_TREE;\n-\n-  if (gimple_assign_cast_p (stmt))\n-    rhs_pointer = gimple_assign_rhs1 (stmt);\n-\n-  if (!rhs_pointer)\n-    /* Not a type conversion.  */\n-    return false;\n-\n-  if (TREE_CODE (rhs_pointer) == ADDR_EXPR && !match->is_rhs_pointer)\n-    to_match = TREE_OPERAND (rhs_pointer, 0);\n-  else if (POINTER_TYPE_P (rhs_pointer) && match->is_rhs_pointer)\n-    to_match = rhs_pointer;\n-\n-  if (to_match != match->rhs)\n-    /* Type conversion, but not a name match.  */\n-    return false;\n-\n-  /* Found it.  */\n-  match->site = stmt;\n-  return true;\n-}\n-\n-\n-/* Find the statement where OBJECT1 gets aliased to OBJECT2.\n-   If IS_PTR2 is true, consider OBJECT2 to be the name of a pointer or\n-   reference rather than the actual aliased object.\n-   For now, just implement the case where OBJECT1 is an SSA name defined\n-   by a PHI statement.  */\n-\n-static gimple\n-find_alias_site (tree object1, bool is_ptr1 ATTRIBUTE_UNUSED,\n-                 tree object2, bool is_ptr2)\n-{\n-  struct alias_match match;\n-\n-  match.rhs = object2;\n-  match.is_rhs_pointer = is_ptr2;\n-  match.site = NULL;\n-\n-  if (TREE_CODE (object1) != SSA_NAME)\n-    return NULL;\n-\n-  walk_use_def_chains (object1, find_alias_site_helper, &match, false);\n-  return match.site;\n-}\n-\n-\n-/* Structure to store temporary results when trying to figure out whether\n-   an object is referenced.  Just its presence in the text is not enough,\n-   as we may just be taking its address.  */\n-\n-struct match_info\n-{\n-  tree object;\n-  bool is_ptr;\n-  /* The difference between the number of references to OBJECT\n-     and the number of occurrences of &OBJECT.  */\n-  int found;\n-};\n-\n-\n-/* Return the base if EXPR is an SSA name.  Return EXPR otherwise.  */\n-\n-static tree\n-get_ssa_base (tree expr)\n-{\n-  if (TREE_CODE (expr) == SSA_NAME)\n-    return SSA_NAME_VAR (expr);\n-  else\n-    return expr;\n-}\n-\n-\n-/* Record references to objects and pointer dereferences across some piece of\n-   code.  The number of references is recorded for each item.\n-   References to an object just to take its address are not counted.\n-   For instance, if PTR is a pointer and OBJ is an object:\n-   1. Expression &obj + *ptr will have the following reference match structure:\n-   ptrs: <ptr, 1>\n-   objs: <ptr, 1>\n-   OBJ does not appear as referenced because we just take its address.\n-   2. Expression ptr + *ptr will have the following reference match structure:\n-   ptrs: <ptr, 1>\n-   objs: <ptr, 2>\n-   PTR shows up twice as an object, but is dereferenced only once.\n-\n-   The elements of the hash tables are gimple_map objects.  */\n-struct reference_matches\n-{\n-  htab_t ptrs;\n-  htab_t objs;\n-};\n-\n-struct gimple_tree_map\n-{\n-  tree from;\n-  gimple to;\n-};\n-\n-/* Return true if the from tree in both gimple-tree maps are equal.\n-   VA and VB are really instances of struct gimple_tree_map.  */\n-\n-static int\n-gimple_tree_map_eq (const void *va, const void *vb)\n-{\n-  const struct gimple_tree_map *const a = (const struct gimple_tree_map *) va;\n-  const struct gimple_tree_map *const b = (const struct gimple_tree_map *) vb;\n-  return (a->from == b->from);\n-}\n-\n-/* Hash a from tree in a gimple_tree_map.  ITEM is really an instance\n-   of struct gimple_tree_map.  */\n-\n-static unsigned int\n-gimple_tree_map_hash (const void *item)\n-{\n-  return htab_hash_pointer (((const struct gimple_tree_map *)item)->from);\n-}\n-\n-/* Return the match, if any.  Otherwise, return NULL.  It will return\n-   NULL even when a match was found, if the value associated to KEY is\n-   NULL.  */\n-\n-static inline gimple\n-match (htab_t ref_map, tree key)\n-{\n-  struct gimple_tree_map *found;\n-  void **slot = NULL;\n-  slot = htab_find_slot (ref_map, &key, NO_INSERT);\n-\n-  if (!slot)\n-    return NULL;\n-\n-  found = (struct gimple_tree_map *) *slot;\n-\n-  return found->to;\n-}\n-\n-\n-/* Set the entry corresponding to KEY, but only if the entry\n-   already exists and its value is NULL_TREE.  Otherwise, do nothing.  */\n-\n-static inline void\n-maybe_add_match (htab_t ref_map, struct gimple_tree_map *key)\n-{\n-  struct gimple_tree_map *found;\n-  \n-  found = (struct gimple_tree_map *) htab_find (ref_map, key);\n-\n-  if (found && !found->to)\n-    found->to = key->to;\n-}\n-\n-\n-/* Add an entry to HT, with key T and value NULL_TREE.  */\n-\n-static void\n-add_key (htab_t ht, tree t, alloc_pool references_pool)\n-{\n-  void **slot;\n-  struct gimple_tree_map *tp;\n-  \n-  tp = (struct gimple_tree_map *) pool_alloc (references_pool);\n-\n-  tp->from = t;\n-  tp->to = NULL;\n-  slot = htab_find_slot (ht, &t, INSERT);\n-  *slot = (void *) tp;\n-}\n-\n-\n-/* Some memory to keep the objects in the reference table.  */\n-\n-static alloc_pool ref_table_alloc_pool = NULL;\n-\n-\n-/* Get some memory to keep the objects in the reference table.  */\n-\n-static inline alloc_pool\n-reference_table_alloc_pool (bool build)\n-{\n-  if (ref_table_alloc_pool || !build)\n-    return ref_table_alloc_pool;\n-\n-  ref_table_alloc_pool = create_alloc_pool (\"ref_table_alloc_pool\",\n-\t\t\t\t\t    sizeof (struct gimple_tree_map),\n-\t\t\t\t\t    20);\n-\n-  return ref_table_alloc_pool;\n-}\n-\n-\n-/* Initialize the reference table by adding all pointers in the points-to\n-   table as keys, and NULL_TREE as associated values.  */\n-\n-static struct reference_matches *\n-build_reference_table (void)\n-{\n-  unsigned int i;\n-  struct reference_matches *ref_table = NULL;\n-  alloc_pool references_pool = reference_table_alloc_pool (true);\n-\n-  ref_table = XNEW (struct reference_matches);\n-  ref_table->objs = htab_create (10, gimple_tree_map_hash, gimple_tree_map_eq,\n-\t\t\t\t NULL);\n-  ref_table->ptrs = htab_create (10, gimple_tree_map_hash, gimple_tree_map_eq,\n-\t\t\t\t NULL);\n-\n-  for (i = 1; i < num_ssa_names; i++)\n-    {\n-      tree ptr = ssa_name (i);\n-      struct ptr_info_def *pi;\n-\n-      if (ptr == NULL_TREE)\n-\tcontinue;\n-\n-      pi = SSA_NAME_PTR_INFO (ptr);\n-\n-      if (!SSA_NAME_IN_FREE_LIST (ptr) && pi && pi->name_mem_tag)\n-\t{\n-\t  /* Add pointer to the interesting dereference list.  */\n-\t  add_key (ref_table->ptrs, ptr, references_pool);\n-\n-\t  /* Add all aliased names to the interesting reference list.  */\n-\t  if (pi->pt_vars)\n-\t    {\n-\t      unsigned ix;\n-\t      bitmap_iterator bi;\n-\n-\t      EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix, bi)\n-\t\t{\n-\t\t  tree alias = referenced_var (ix);\n-\t\t  add_key (ref_table->objs, alias, references_pool);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  return ref_table;\n-}\n-\n-\n-/*  Reference table.  */\n-\n-static struct reference_matches *ref_table = NULL;\n-\n-\n-/* Clean up the reference table if allocated.  */\n-\n-static void\n-maybe_free_reference_table (void)\n-{\n-  if (ref_table)\n-    {\n-      htab_delete (ref_table->ptrs);\n-      htab_delete (ref_table->objs);\n-      free (ref_table);\n-      ref_table = NULL;\n-    }\n-\n-  if (ref_table_alloc_pool)\n-    {\n-      free_alloc_pool (ref_table_alloc_pool);\n-      ref_table_alloc_pool = NULL;\n-    }\n-}\n-\n-\n-/* Get the reference table.  Initialize it if needed.  */\n-\n-static inline struct reference_matches *\n-reference_table (bool build)\n-{\n-  if (ref_table || !build)\n-    return ref_table;\n-\n-  ref_table = build_reference_table ();\n-  find_references_in_function ();\n-  return ref_table;\n-}\n-\n-\n-/* Callback for find_references_in_function.\n-   Check whether *TP is an object reference or pointer dereference for the\n-   variables given in ((struct match_info*)DATA)->OBJS or\n-   ((struct match_info*)DATA)->PTRS.  The total number of references\n-   is stored in the same structures.  */\n-\n-static tree\n-find_references_in_tree_helper (tree *tp,\n-\t\t\t\tint *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t\t\tvoid *data)\n-{\n-  struct gimple_tree_map match;\n-  static int parent_tree_code = ERROR_MARK;\n-  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-\n-  /* Do not report references just for the purpose of taking an address.\n-     XXX: we rely on the fact that the tree walk is in preorder\n-     and that ADDR_EXPR is not a leaf, thus cannot be carried over across\n-     walks.  */\n-  if (parent_tree_code == ADDR_EXPR)\n-    goto finish;\n-\n-  match.to = (gimple) wi->info;\n-\n-  if (TREE_CODE (*tp) == INDIRECT_REF)\n-    {\n-      match.from = TREE_OPERAND (*tp, 0);\n-      maybe_add_match (reference_table (true)->ptrs, &match);\n-    }\n-  else\n-    {\n-      match.from = *tp;\n-      maybe_add_match (reference_table (true)->objs, &match);\n-    }\n-\n-finish:\n-  parent_tree_code = TREE_CODE (*tp);\n-  return NULL_TREE;\n-}\n-\n-\n-/* Find all the references to aliased variables in the current function.  */\n-\n-static void\n-find_references_in_function (void)\n-{\n-  basic_block bb;\n-  gimple_stmt_iterator i;\n-\n-  FOR_EACH_BB (bb)\n-    for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n-      {\n-\tstruct walk_stmt_info wi;\n-\tmemset (&wi, 0, sizeof (wi));\n-\twi.info = (void *) gsi_stmt (i);\n-\twalk_gimple_op (gsi_stmt (i), find_references_in_tree_helper, &wi);\n-      }\n-}\n-\n-\n-/* Find the reference site for OBJECT.\n-   If IS_PTR is true, look for dereferences of OBJECT instead.\n-   XXX: only the first site is returned in the current\n-   implementation.  If there are no matching sites, return NULL_TREE.  */\n-\n-static gimple\n-reference_site (tree object, bool is_ptr)\n-{\n-  if (is_ptr)\n-    return match (reference_table (true)->ptrs, object);\n-  else\n-    return match (reference_table (true)->objs, object);\n-}\n-\n-\n-/* Try to get more location info when something is missing.\n-   OBJECT1 and OBJECT2 are aliased names.  If IS_PTR1 or IS_PTR2, the alias\n-   is on the memory referenced or pointed to by OBJECT1 and OBJECT2.\n-   ALIAS_SITE, DEREF_SITE1 and DEREF_SITE2 are the statements where the\n-   alias takes place (some pointer assignment usually) and where the\n-   alias is referenced through OBJECT1 and OBJECT2 respectively.\n-   REF_TYPE1 and REF_TYPE2 will return the type of the reference at the\n-   respective sites.  Only the first matching reference is returned for\n-   each name.  If no statement is found, the function header is returned.  */\n-\n-static void\n-maybe_find_missing_stmts (tree object1, bool is_ptr1,\n-                          tree object2, bool is_ptr2,\n-                          gimple *alias_site,\n-                          gimple *deref_site1,\n-                          gimple *deref_site2)\n-{\n-  if (object1 && object2)\n-    {\n-      if (!*alias_site || !gimple_has_location (*alias_site))\n-\t*alias_site = find_alias_site (object1, is_ptr1, object2, is_ptr2);\n-\n-      if (!*deref_site1 || !gimple_has_location (*deref_site1))\n-\t*deref_site1 = reference_site (object1, is_ptr1);\n-\n-      if (!*deref_site2 || !gimple_has_location (*deref_site2))\n-\t*deref_site2 = reference_site (object2, is_ptr2);\n-    }\n-\n-  /* If we could not find the alias site, set it to one of the dereference\n-     sites, if available.  */\n-  if (!*alias_site)\n-    {\n-      if (*deref_site1)\n-\t*alias_site = *deref_site1;\n-      else if (*deref_site2)\n-\t*alias_site = *deref_site2;\n-    }\n-\n-  /* If we could not find the dereference sites, set them to the alias site,\n-     if known.  */\n-  if (!*deref_site1 && *alias_site)\n-    *deref_site1 = *alias_site;\n-  if (!*deref_site2 && *alias_site)\n-    *deref_site2 = *alias_site;\n-}\n-\n-\n-/* Callback for find_first_artificial_name.\n-   Find out if there are no artificial names at tree node *T.  */\n-\n-static tree\n-ffan_walker (tree *t,\n-             int *go_below ATTRIBUTE_UNUSED,\n-             void *data ATTRIBUTE_UNUSED)\n-{\n-  if (DECL_P (*t) && !MTAG_P (*t) && DECL_ARTIFICIAL (*t))\n-    return *t;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Return the first artificial name within EXPR, or NULL_TREE if\n-   none exists.  */\n-\n-static tree\n-find_first_artificial_name (tree expr)\n-{\n-  return walk_tree_without_duplicates (&expr, ffan_walker, NULL);\n-}\n-\n-\n-/* Get a name from the original program for VAR.  */\n-\n-static const char *\n-get_var_name (tree var)\n-{\n-  if (TREE_CODE (var) == SSA_NAME)\n-    return get_var_name (get_ssa_base (var));\n-\n-  if (find_first_artificial_name (var))\n-    return \"{unknown}\";\n-\n-  if (TREE_CODE (var) == VAR_DECL || TREE_CODE (var) == PARM_DECL)\n-    if (DECL_NAME (var))\n-      return IDENTIFIER_POINTER (DECL_NAME (var));\n-\n-  return \"{unknown}\";\n-}\n-\n-\n-/* Return \"*\" if OBJECT is not the actual alias but a pointer to it, or\n-   \"\" otherwise.\n-   IS_PTR is true when OBJECT is not the actual alias.\n-   In addition to checking IS_PTR, we also make sure that OBJECT is a pointer\n-   since IS_PTR would also be true for C++ references, but we should only\n-   print a * before a pointer and not before a reference.  */\n-\n-static const char *\n-get_maybe_star_prefix (tree object, bool is_ptr)\n-{\n-  gcc_assert (object);\n-  return (is_ptr\n-          && TREE_CODE (TREE_TYPE (object)) == POINTER_TYPE) ? \"*\" : \"\";\n-}\n-\n-/* Callback for contains_node_type_p.\n-   Returns true if *T has tree code *(int*)DATA.  */\n-\n-static tree\n-contains_node_type_p_callback (tree *t,\n-\t\t\t       int *go_below ATTRIBUTE_UNUSED,\n-\t\t\t       void *data)\n-{\n-  return ((int) TREE_CODE (*t) == *((int *) data)) ? *t : NULL_TREE;\n-}\n-\n-\n-/* Return true if T contains a node with tree code TYPE.  */\n-\n-static bool\n-contains_node_type_p (tree t, int type)\n-{\n-  return (walk_tree_without_duplicates (&t, contains_node_type_p_callback,\n-\t\t\t\t\t(void *) &type)\n-\t  != NULL_TREE);\n-}\n-\n-\n-/* Return true if a warning was issued in the front end at STMT.  */\n-\n-static bool\n-already_warned_in_frontend_p (gimple stmt)\n-{\n-  if (stmt == NULL)\n-    return false;\n-\n-  if (gimple_assign_cast_p (stmt)\n-      && TREE_NO_WARNING (gimple_assign_rhs1 (stmt)))\n-    return true;\n-  else\n-    return false;\n-}\n-\n-\n-/* Return true if and only if TYPE is a function or method pointer type,\n-   or pointer to a pointer to ... to a function or method.  */\n-\n-static bool\n-is_method_pointer (tree type)\n-{\n-  while (TREE_CODE (type) == POINTER_TYPE)\n-    type = TREE_TYPE (type);\n-  return TREE_CODE (type) == METHOD_TYPE || TREE_CODE (type) == FUNCTION_TYPE;\n-}\n-\n-\n-/* Issue a -Wstrict-aliasing warning.\n-   OBJECT1 and OBJECT2 are aliased names.\n-   If IS_PTR1 and/or IS_PTR2 is true, then the corresponding name\n-   OBJECT1/OBJECT2 is a pointer or reference to the aliased memory,\n-   rather than actual storage.\n-   ALIAS_SITE is a statement where the alias took place.  In the most common\n-   case, that is where a pointer was assigned to the address of an object.  */\n-\n-static bool\n-strict_aliasing_warn (gimple alias_site,\n-                      tree object1, bool is_ptr1,\n-                      tree object2, bool is_ptr2,\n-\t\t      bool filter_artificials)\n-{\n-  gimple ref_site1 = NULL;\n-  gimple ref_site2 = NULL;\n-  const char *name1;\n-  const char *name2;\n-  location_t alias_loc;\n-  location_t ref1_loc;\n-  location_t ref2_loc;\n-  gcc_assert (object1);\n-  gcc_assert (object2);\n-  name1 = get_var_name (object1);\n-  name2 = get_var_name (object2);\n-\n-\n-  if (is_method_pointer (get_main_type (TREE_TYPE (object2))))\n-    return false;\n-\n-  maybe_find_missing_stmts (object1, is_ptr1, object2, is_ptr2, &alias_site,\n-                            &ref_site1, &ref_site2);\n-\n-  if (gimple_has_location (alias_site))\n-    alias_loc = gimple_location (alias_site);\n-  else\n-    return false;\n-\n-  if (gimple_has_location (ref_site1))\n-    ref1_loc = gimple_location (ref_site1);\n-  else\n-    ref1_loc = alias_loc;\n-\n-  if (gimple_has_location (ref_site2))\n-    ref2_loc = gimple_location (ref_site2);\n-  else\n-    ref2_loc = alias_loc;\n-\n-  if (already_warned_in_frontend_p (alias_site))\n-    return false;\n-\n-  /* If they are not SSA names, but contain SSA names, drop the warning\n-     because it cannot be displayed well.\n-     Also drop it if they both contain artificials.\n-     XXX: this is a hack, must figure out a better way to display them.  */\n-  if (filter_artificials)\n-    if ((find_first_artificial_name (get_ssa_base (object1))\n-\t && find_first_artificial_name (get_ssa_base (object2)))\n-\t|| (TREE_CODE (object1) != SSA_NAME\n-\t    && contains_node_type_p (object1, SSA_NAME))\n-\t|| (TREE_CODE (object2) != SSA_NAME\n-\t    && contains_node_type_p (object2, SSA_NAME)))\n-      return false;\n-\n-\n-  /* XXX: In the following format string, %s:%d should be replaced by %H.\n-     However, in my tests only the first %H printed ok, while the\n-     second and third were printed as blanks.  */\n-  warning (OPT_Wstrict_aliasing,\n-\t   \"%Hlikely type-punning may break strict-aliasing rules: \"\n-\t   \"object %<%s%s%> of main type %qT is referenced at or around \"\n-\t   \"%s:%d and may be \"\n-\t   \"aliased to object %<%s%s%> of main type %qT which is referenced \"\n-\t   \"at or around %s:%d.\",\n-\t   &alias_loc,\n-\t   get_maybe_star_prefix (object1, is_ptr1),\n-\t   name1, get_otype (object1, is_ptr1),\n-\t   LOCATION_FILE (ref1_loc), LOCATION_LINE (ref1_loc),\n-\t   get_maybe_star_prefix (object2, is_ptr2),\n-\t   name2, get_otype (object2, is_ptr2),\n-\t   LOCATION_FILE (ref2_loc), LOCATION_LINE (ref2_loc));\n-\n-  return true;\n-}\n-\f\n-\n-\n-/* Return true when any objects of TYPE1 and TYPE2 respectively\n-   may not be aliased according to the language standard.  */\n-\n-static bool\n-nonstandard_alias_types_p (tree type1, tree type2)\n-{\n-  alias_set_type set1;\n-  alias_set_type set2;\n-\n-  if (VOID_TYPE_P (type1) || VOID_TYPE_P (type2))\n-    return false;\n-\n-  set1 = get_alias_set (type1);\n-  set2 = get_alias_set (type2);\n-  return !alias_sets_conflict_p (set1, set2);\n-}\n-\f\n-\n-\n-/* Returns true when *PTR may not be aliased to ALIAS.\n-   See C standard 6.5p7 and C++ standard 3.10p15.\n-   If PTR_PTR is true, ALIAS represents a pointer or reference to the\n-   aliased storage rather than its actual name.  */\n-\n-static bool\n-nonstandard_alias_p (tree ptr, tree alias, bool ptr_ptr)\n-{\n-  /* Find the types to compare.  */\n-  tree ptr_type = get_otype (ptr, true);\n-  tree alias_type = get_otype (alias, ptr_ptr);\n-\n-  /* If this is a ref-all pointer the access is ok.  */\n-  if (TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (ptr)))\n-    return false;\n-\n-  /* XXX: for now, say it's OK if the alias escapes.\n-     Not sure this is needed in general, but otherwise GCC will not\n-     bootstrap.  */\n-  if (var_ann (get_ssa_base (alias))->escape_mask != NO_ESCAPE)\n-    return false;\n-\n-  /* XXX: don't get into structures for now.  It brings much complication\n-     and little benefit.  */\n-  if (struct_class_union_p (ptr_type) || struct_class_union_p (alias_type))\n-    return false;\n-\n-  /* If they are both SSA names of artificials, let it go, the warning\n-     is too confusing.  */\n-  if (find_first_artificial_name (ptr) && find_first_artificial_name (alias))\n-    return false;\n-\n-  /* Compare the types.  */\n-  return nonstandard_alias_types_p (ptr_type, alias_type);\n-}\n-\n-\n-/* Return true when we should skip analysis for pointer PTR based on the\n-   fact that their alias information *PI is not considered relevant.  */\n-\n-static bool\n-skip_this_pointer (tree ptr ATTRIBUTE_UNUSED, struct ptr_info_def *pi)\n-{\n-  /* If it is not dereferenced, it is not a problem (locally).  */\n-  if (!pi->is_dereferenced)\n-    return true;\n-\n-  /* This would probably cause too many false positives.  */\n-  if (pi->value_escapes_p || pi->pt_anything)\n-    return true;\n-\n-  return false;\n-}\n-\n-\n-/* Find aliasing to named objects for pointer PTR.  */\n-\n-static void\n-dsa_named_for (tree ptr ATTRIBUTE_UNUSED)\n-{\n-  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n-\n-  if (pi)\n-    {\n-      if (skip_this_pointer (ptr, pi))\n-\treturn;\n-\n-      /* For all the variables it could be aliased to.  */\n-      if (pi->pt_vars)\n-\t{\n-\t  unsigned ix;\n-\t  bitmap_iterator bi;\n-\t  bool any = false;\n-\n-\t  EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix, bi)\n-\t    {\n-\t      tree alias = referenced_var (ix);\n-\n-\t      if (nonstandard_alias_p (ptr, alias, false))\n-\t\tstrict_aliasing_warn (SSA_NAME_DEF_STMT (ptr),\n-\t\t\t\t      ptr, true, alias, false, true);\n-\t      else\n-\t\tany = true;\n-\t    }\n-\n-\t  /* If there was no object in the points-to set that the pointer\n-\t     may alias, unconditionally warn.  */\n-\t  if (!any)\n-\t    warning (OPT_Wstrict_aliasing,\n-\t\t     \"dereferencing type-punned pointer %D will \"\n-\t\t     \"break strict-aliasing rules\", SSA_NAME_VAR (ptr));\n-\t}\n-    }\n-}\n-\n-\n-/* Detect and report strict aliasing violation of named objects.  */\n-\n-static void\n-detect_strict_aliasing_named (void)\n-{\n-  unsigned int i;\n-\n-  for (i = 1; i < num_ssa_names; i++)\n-    {\n-      tree ptr = ssa_name (i);\n-      struct ptr_info_def *pi;\n-\n-      if (ptr == NULL_TREE)\n-\tcontinue;\n-\n-      pi = SSA_NAME_PTR_INFO (ptr);\n-\n-      if (!SSA_NAME_IN_FREE_LIST (ptr) && pi && pi->name_mem_tag)\n-\tdsa_named_for (ptr);\n-    }\n-}\n-\n-\n-/* Return false only the first time I see each instance of FUNC.  */\n-\n-static bool\n-processed_func_p (tree func)\n-{\n-  static htab_t seen = NULL;\n-  void **slot = NULL;\n-\n-  if (!seen)\n-    seen = htab_create (10, gimple_tree_map_hash, gimple_tree_map_eq, NULL);\n-\n-  slot = htab_find_slot (seen, &func, INSERT);\n-  gcc_assert (slot);\n-\n-  if (*slot)\n-    return true;\n-\n-  gcc_assert (slot);\n-  *slot = &func;\n-  return false;\n-}\n-\n-\n-/* Detect and warn about type-punning using points-to information.  */\n-\n-void\n-strict_aliasing_warning_backend (void)\n-{\n-  if (flag_strict_aliasing && warn_strict_aliasing == 3\n-      && !processed_func_p (current_function_decl))\n-    {\n-      detect_strict_aliasing_named ();\n-      maybe_free_reference_table ();\n-    }\n-}"}, {"sha": "4e9d28bf9ebad2a99796aa6fd95f609e6ff2d57e", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -1825,9 +1825,6 @@ compute_may_aliases (void)\n \tdump_referenced_vars (dump_file);\n     }\n \n-  /* Report strict aliasing violations.  */\n-  strict_aliasing_warning_backend ();\n-\n   /* Deallocate memory used by aliasing data structures.  */\n   delete_alias_info (ai);\n "}, {"sha": "c71680aae24815010707d933f94fa000c0312674", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"errors.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n #include \"basic-block.h\""}, {"sha": "46781b82129d15d84ca998d6a174a1223c8e117a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 108, "deletions": 9, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1b6498020a6124415ed9b03eaa07d682c25455/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=ce1b6498020a6124415ed9b03eaa07d682c25455", "patch": "@@ -31,14 +31,14 @@\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"output.h\"\n-#include \"errors.h\"\n-#include \"diagnostic.h\"\n #include \"tree.h\"\n #include \"c-common.h\"\n #include \"tree-flow.h\"\n #include \"tree-inline.h\"\n #include \"varray.h\"\n #include \"c-tree.h\"\n+#include \"diagnostic.h\"\n+#include \"toplev.h\"\n #include \"gimple.h\"\n #include \"hashtab.h\"\n #include \"function.h\"\n@@ -4648,14 +4648,15 @@ shared_bitmap_add (bitmap pt_vars)\n    IS_DEREFED is true if PTR was directly dereferenced, which we use to\n    help determine whether we are we are allowed to prune using TBAA.\n    If NO_TBAA_PRUNING is true, we do not perform any TBAA pruning of\n-   the from set.  */\n+   the from set.  Returns the number of pruned variables.  */\n \n-static void\n+static unsigned\n set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n \t\t   bool no_tbaa_pruning)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n+  unsigned pruned = 0;\n \n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (ptr)));\n \n@@ -4688,14 +4689,97 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n \t      if (may_alias_p (SSA_NAME_VAR (ptr), mem_alias_set,\n \t\t\t       vi->decl, var_alias_set, true))\n \t        bitmap_set_bit (into, DECL_UID (vi->decl));\n+\t      else\n+\t\t++pruned;\n \t    }\n \t}\n     }\n+\n+  return pruned;\n }\n \n \n static bool have_alias_info = false;\n \n+/* Emit a note for the pointer initialization point DEF.  */\n+\n+static void\n+emit_pointer_definition (gimple def)\n+{\n+  if (gimple_code (def) == GIMPLE_PHI)\n+    {\n+      use_operand_p argp;\n+      ssa_op_iter oi;\n+\n+      FOR_EACH_PHI_ARG (argp, def, oi, SSA_OP_USE)\n+\t{\n+\t  tree arg = USE_FROM_PTR (argp);\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    emit_pointer_definition (SSA_NAME_DEF_STMT (arg));\n+\t  else\n+\t    inform (0, \"initialized from %qE\", arg);\n+\t}\n+    }\n+  else if (!gimple_nop_p (def))\n+    inform (gimple_location (def), \"initialized from here\");\n+}\n+\n+/* Emit a strict aliasing warning for dereferencing the pointer PTR.  */\n+\n+static void\n+emit_alias_warning (tree ptr)\n+{\n+  gimple def = SSA_NAME_DEF_STMT (ptr);\n+  gimple use;\n+  imm_use_iterator ui;\n+  unsigned warned = 0;\n+\n+  FOR_EACH_IMM_USE_STMT (use, ui, ptr)\n+    {\n+      tree deref = NULL_TREE;\n+\n+      if (gimple_has_lhs (use))\n+\t{\n+\t  tree lhs = get_base_address (gimple_get_lhs (use));\n+\t  if (lhs\n+\t      && INDIRECT_REF_P (lhs)\n+\t      && TREE_OPERAND (lhs, 0) == ptr)\n+\t    deref = lhs;\n+\t}\n+      if (gimple_assign_single_p (use))\n+\t{\n+\t  tree rhs = get_base_address (gimple_assign_rhs1 (use));\n+\t  if (rhs\n+\t      && INDIRECT_REF_P (rhs)\n+\t      && TREE_OPERAND (rhs, 0) == ptr)\n+\t    deref = rhs;\n+\t}\n+      else if (is_gimple_call (use))\n+\t{\n+\t  unsigned i;\n+\t  for (i = 0; i < gimple_call_num_args (use); ++i)\n+\t    {\n+\t      tree op = get_base_address (gimple_call_arg (use, i));\n+\t      if (op\n+\t\t  && INDIRECT_REF_P (op)\n+\t\t  && TREE_OPERAND (op, 0) == ptr)\n+\t\tderef = op;\n+\t    }\n+\t}\n+      if (deref\n+\t  && !TREE_NO_WARNING (deref))\n+\t{\n+\t  TREE_NO_WARNING (deref) = 1;\n+\t  warning_at (gimple_location (use), OPT_Wstrict_aliasing,\n+\t\t      \"dereferencing pointer %qD does break strict-aliasing \"\n+\t\t      \"rules\", SSA_NAME_VAR (ptr));\n+\t  ++warned;\n+\t}\n+    }\n+  if (warned > 0)\n+    emit_pointer_definition (def);\n+}\n+\n /* Given a pointer variable P, fill in its points-to set, or return\n    false if we can't.\n    Rather than return false for variables that point-to anything, we\n@@ -4740,7 +4824,7 @@ find_what_p_points_to (tree p)\n       else\n \t{\n \t  struct ptr_info_def *pi = get_ptr_info (p);\n-\t  unsigned int i;\n+\t  unsigned int i, pruned;\n \t  bitmap_iterator bi;\n \t  bool was_pt_anything = false;\n \t  bitmap finished_solution;\n@@ -4792,9 +4876,9 @@ find_what_p_points_to (tree p)\n \t  finished_solution = BITMAP_GGC_ALLOC ();\n \t  stats.points_to_sets_created++;\n \n-\t  set_uids_in_ptset (p, finished_solution, vi->solution,\n-\t\t\t     pi->is_dereferenced,\n-\t\t\t     vi->no_tbaa_pruning);\n+\t  pruned = set_uids_in_ptset (p, finished_solution, vi->solution,\n+\t\t\t\t      pi->is_dereferenced,\n+\t\t\t\t      vi->no_tbaa_pruning);\n \t  result = shared_bitmap_lookup (finished_solution);\n \n \t  if (!result)\n@@ -4809,7 +4893,22 @@ find_what_p_points_to (tree p)\n \t    }\n \n \t  if (bitmap_empty_p (pi->pt_vars))\n-\t    pi->pt_vars = NULL;\n+\t    {\n+\t      pi->pt_vars = NULL;\n+\t      if (pruned > 0\n+\t\t  && pi->is_dereferenced\n+\t\t  && warn_strict_aliasing > 0\n+\t\t  && !SSA_NAME_IS_DEFAULT_DEF (p))\n+\t\t{\n+\t\t  if (dump_file && dump_flags & TDF_DETAILS)\n+\t\t    {\n+\t\t      fprintf (dump_file, \"alias warning for \");\n+\t\t      print_generic_expr (dump_file, p, 0);\n+\t\t      fprintf (dump_file, \"\\n\");\n+\t\t    }\n+\t\t  emit_alias_warning (p);\n+\t\t}\n+\t    }\n \n \t  return true;\n \t}"}]}