{"sha": "5d4d64faa71a6389bfb76bfb3334b63360cf62c0", "node_id": "C_kwDOANBUbNoAKDVkNGQ2NGZhYTcxYTYzODliZmI3NmJmYjMzMzRiNjMzNjBjZjYyYzA", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-15T12:46:32Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-17T16:51:39Z"}, "message": "Allow fully resolving backward jump threading passes.\n\nThis refactors the backward threader pass so that it can be called in\neither fully resolving mode, or in classic mode where any unknowns\ndefault to VARYING.  Doing so opens the door for\n\"pass_thread_jumps_full\" which has the resolving bits set.\n\nThis pass has not been added to the pipeline, but with it in place, we\ncan now experiment with it to see how to reduce the number of\njump threaders.  The first suspect will probably be enabling fully\nresolving in the backward threader pass immediately preceeding VRP2,\nand removing the VRP2 threader pass.  Now that VRP and the backward\nthreader are sharing a solver, and most of the threads get handcuffed\nby cancel_threads(), we should have a variety of scenarios to try.\n\nIn the process, I have cleaned up things to make it trivial to see\nwhat the difference between the 3 variants are (early jump\nthreading, quick jump threading without resolving SSAs, and fully\nresolving jump threading).  Since I moved stuff around, it's probably\neasier to just look at the last section in tree-ssa-threadbackward to\nsee how it's all laid out.\n\nNo functional changes as the new pass hasn't been added to the\npipeline.\n\ngcc/ChangeLog:\n\n\t* tree-pass.h (make_pass_thread_jumps_full): New.\n\t* tree-ssa-threadbackward.c (pass_thread_jumps::gate): Inline.\n\t(try_thread_blocks): Add resolve and speed arguments.\n\t(pass_thread_jumps::execute): Inline.\n\t(do_early_thread_jumps): New.\n\t(do_thread_jumps): New.\n\t(make_pass_thread_jumps): Move.\n\t(pass_early_thread_jumps::gate): Inline.\n\t(pass_early_thread_jumps::execute): Inline.\n\t(class pass_thread_jumps_full): New.", "tree": {"sha": "c3eeb954ccd2460268b3fbdd4747bfc977c035b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3eeb954ccd2460268b3fbdd4747bfc977c035b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d4d64faa71a6389bfb76bfb3334b63360cf62c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d4d64faa71a6389bfb76bfb3334b63360cf62c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d4d64faa71a6389bfb76bfb3334b63360cf62c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d4d64faa71a6389bfb76bfb3334b63360cf62c0/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7319539d32b9c930f040350fc4d9c327cdf2dc0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7319539d32b9c930f040350fc4d9c327cdf2dc0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7319539d32b9c930f040350fc4d9c327cdf2dc0f"}], "stats": {"total": 179, "additions": 108, "deletions": 71}, "files": [{"sha": "d379769a9436408fbd2b3bd8903a11153e128c5d", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d4d64faa71a6389bfb76bfb3334b63360cf62c0/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d4d64faa71a6389bfb76bfb3334b63360cf62c0/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=5d4d64faa71a6389bfb76bfb3334b63360cf62c0", "patch": "@@ -407,6 +407,7 @@ extern gimple_opt_pass *make_pass_cd_dce (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_call_cdce (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_merge_phi (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_thread_jumps (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_thread_jumps_full (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_early_thread_jumps (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_split_crit_edges (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_laddress (gcc::context *ctxt);"}, {"sha": "62f936a9651c8736928cd3aebe4b85376216f1fa", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 107, "deletions": 71, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d4d64faa71a6389bfb76bfb3334b63360cf62c0/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d4d64faa71a6389bfb76bfb3334b63360cf62c0/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=5d4d64faa71a6389bfb76bfb3334b63360cf62c0", "patch": "@@ -114,7 +114,7 @@ class back_threader\n   static const edge UNREACHABLE_EDGE;\n   // Set to TRUE if unknown SSA names along a path should be resolved\n   // with the ranger.  Otherwise, unknown SSA names are assumed to be\n-  // VARYING.  Setting to true more precise but slower.\n+  // VARYING.  Setting to true is more precise but slower.\n   bool m_resolve;\n };\n \n@@ -925,47 +925,15 @@ back_threader_registry::register_path (const vec<basic_block> &m_path,\n   return true;\n }\n \n-namespace {\n-\n-const pass_data pass_data_thread_jumps =\n-{\n-  GIMPLE_PASS,\n-  \"thread\",\n-  OPTGROUP_NONE,\n-  TV_TREE_SSA_THREAD_JUMPS,\n-  ( PROP_cfg | PROP_ssa ),\n-  0,\n-  0,\n-  0,\n-  TODO_update_ssa,\n-};\n-\n-class pass_thread_jumps : public gimple_opt_pass\n-{\n-public:\n-  pass_thread_jumps (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_thread_jumps, ctxt)\n-  {}\n-\n-  opt_pass * clone (void) { return new pass_thread_jumps (m_ctxt); }\n-  virtual bool gate (function *);\n-  virtual unsigned int execute (function *);\n-};\n-\n-bool\n-pass_thread_jumps::gate (function *fun ATTRIBUTE_UNUSED)\n-{\n-  return flag_thread_jumps && flag_expensive_optimizations;\n-}\n-\n-// Try to thread blocks in FUN.  Return TRUE if any jump thread paths were\n-// registered.\n+// Try to thread blocks in FUN.  RESOLVE is TRUE when fully resolving\n+// unknown SSAs.  SPEED is TRUE when optimizing for speed.\n+//\n+// Return TRUE if any jump thread paths were registered.\n \n static bool\n-try_thread_blocks (function *fun)\n+try_thread_blocks (function *fun, bool resolve, bool speed)\n {\n-  /* Try to thread each block with more than one successor.  */\n-  back_threader threader (/*speed=*/true, /*resolve=*/false);\n+  back_threader threader (speed, resolve);\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n@@ -975,24 +943,27 @@ try_thread_blocks (function *fun)\n   return threader.thread_through_all_blocks (/*peel_loop_headers=*/true);\n }\n \n-unsigned int\n-pass_thread_jumps::execute (function *fun)\n+static unsigned int\n+do_early_thread_jumps (function *fun, bool resolve)\n {\n-  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);\n+  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n \n-  bool changed = try_thread_blocks (fun);\n+  try_thread_blocks (fun, resolve, /*speed=*/false);\n \n   loop_optimizer_finalize ();\n-\n-  return changed ? TODO_cleanup_cfg : 0;\n-}\n-\n+  return 0;\n }\n \n-gimple_opt_pass *\n-make_pass_thread_jumps (gcc::context *ctxt)\n+static unsigned int\n+do_thread_jumps (function *fun, bool resolve)\n {\n-  return new pass_thread_jumps (ctxt);\n+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);\n+\n+  bool changed = try_thread_blocks (fun, resolve, /*speed=*/true);\n+\n+  loop_optimizer_finalize ();\n+\n+  return changed ? TODO_cleanup_cfg : 0;\n }\n \n namespace {\n@@ -1010,43 +981,108 @@ const pass_data pass_data_early_thread_jumps =\n   ( TODO_cleanup_cfg | TODO_update_ssa ),\n };\n \n+const pass_data pass_data_thread_jumps =\n+{\n+  GIMPLE_PASS,\n+  \"thread\",\n+  OPTGROUP_NONE,\n+  TV_TREE_SSA_THREAD_JUMPS,\n+  ( PROP_cfg | PROP_ssa ),\n+  0,\n+  0,\n+  0,\n+  TODO_update_ssa,\n+};\n+\n+const pass_data pass_data_thread_jumps_full =\n+{\n+  GIMPLE_PASS,\n+  \"thread-full\",\n+  OPTGROUP_NONE,\n+  TV_TREE_SSA_THREAD_JUMPS,\n+  ( PROP_cfg | PROP_ssa ),\n+  0,\n+  0,\n+  0,\n+  TODO_update_ssa,\n+};\n+\n+// Early jump threading pass optimizing for size.\n class pass_early_thread_jumps : public gimple_opt_pass\n {\n public:\n   pass_early_thread_jumps (gcc::context *ctxt)\n     : gimple_opt_pass (pass_data_early_thread_jumps, ctxt)\n   {}\n \n-  opt_pass * clone (void) { return new pass_early_thread_jumps (m_ctxt); }\n-  virtual bool gate (function *);\n-  virtual unsigned int execute (function *);\n+  opt_pass * clone () override\n+  {\n+    return new pass_early_thread_jumps (m_ctxt);\n+  }\n+  bool gate (function *) override\n+  {\n+    return flag_thread_jumps;\n+  }\n+  unsigned int execute (function *fun) override\n+  {\n+    return do_early_thread_jumps (fun, /*resolve=*/false);\n+  }\n };\n \n-bool\n-pass_early_thread_jumps::gate (function *fun ATTRIBUTE_UNUSED)\n+// Jump threading pass without resolving of unknown SSAs.\n+class pass_thread_jumps : public gimple_opt_pass\n {\n-  return flag_thread_jumps;\n-}\n+public:\n+  pass_thread_jumps (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_thread_jumps, ctxt)\n+  {}\n+  opt_pass * clone (void) override\n+  {\n+    return new pass_thread_jumps (m_ctxt);\n+  }\n+  bool gate (function *) override\n+  {\n+    return flag_thread_jumps && flag_expensive_optimizations;\n+  }\n+  unsigned int execute (function *fun) override\n+  {\n+    return do_thread_jumps (fun, /*resolve=*/false);\n+  }\n+};\n \n-unsigned int\n-pass_early_thread_jumps::execute (function *fun)\n+// Jump threading pass that fully resolves unknown SSAs.\n+class pass_thread_jumps_full : public gimple_opt_pass\n {\n-  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+public:\n+  pass_thread_jumps_full (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_thread_jumps_full, ctxt)\n+  {}\n+  opt_pass * clone (void) override\n+  {\n+    return new pass_thread_jumps (m_ctxt);\n+  }\n+  bool gate (function *) override\n+  {\n+    return flag_thread_jumps && flag_expensive_optimizations;\n+  }\n+  unsigned int execute (function *fun) override\n+  {\n+    return do_thread_jumps (fun, /*resolve=*/true);\n+  }\n+};\n \n-  /* Try to thread each block with more than one successor.  */\n-  back_threader threader (/*speed_p=*/false, /*resolve=*/false);\n-  basic_block bb;\n-  FOR_EACH_BB_FN (bb, fun)\n-    {\n-      if (EDGE_COUNT (bb->succs) > 1)\n-\tthreader.maybe_thread_block (bb);\n-    }\n-  threader.thread_through_all_blocks (/*peel_loop_headers=*/true);\n+} // namespace {\n \n-  loop_optimizer_finalize ();\n-  return 0;\n+gimple_opt_pass *\n+make_pass_thread_jumps (gcc::context *ctxt)\n+{\n+  return new pass_thread_jumps (ctxt);\n }\n \n+gimple_opt_pass *\n+make_pass_thread_jumps_full (gcc::context *ctxt)\n+{\n+  return new pass_thread_jumps_full (ctxt);\n }\n \n gimple_opt_pass *"}]}