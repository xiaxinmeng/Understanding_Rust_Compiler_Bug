{"sha": "7861b6489dd7777b1b8829fd8726079f133eb34c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg2MWI2NDg5ZGQ3Nzc3YjFiODgyOWZkODcyNjA3OWYxMzNlYjM0Yw==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2014-09-24T03:29:24Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2014-09-24T03:29:24Z"}, "message": "Add an no_reorder attribute for LTO\n\nSome projects need to prevent reordering of specific top level\ndeclarations with LTO, in particular declarations defining init calls.\n\nThe only way to do that with LTO was to use -fno-toplevel-reorder,\nwhich stops reordering for all declarations and makes LTO partitioning\nless efficient.\n\nThis patch adds a new no_reorder attribute that stops reordering only\nfor the marked declaration. The program can then only mark e.g. the\ninitcalls and leave all the other declarations alone.\n\nThe patch does:\n\n- Adds the new no_reorder attribute for the C family.\n- Initializes a new no_reorder flag in the symtab_nodes in the\nfunction visibility flag.\n- Maintains the no_reorder flag when creating new nodes.\n- Changes the partition code to always keep a separate\nsorted queue of ordered nodes and flush them in order with the other\nnodes. This is used by all nodes with -fno-toplevel-reorder,\nand only the marked ones without it.\nParts of the old -fno-toplevel-reorder code paths are reused.\n- Adds various checks throughout the tree to make no_reorder\nmarked functions behave the same as with -fno-toplevel-reorder\n- Changes the LTO streamer to serialize the no_reorder attribute.\n\ngcc/c-family/:\n\n2014-09-23  Andi Kleen  <ak@linux.intel.com>\n\n\t* c-common.c (handle_no_reorder_attribute): New function.\n\t(c_common_attribute_table): Add no_reorder attribute.\n\ngcc/:\n\n2014-09-23  Andi Kleen  <ak@linux.intel.com>\n\n\t* cgraph.h (symtab_node): Add no_reorder attribute.\n\t(symbol_table::output_asm_statements): Remove.\n\t* cgraphclones.c (cgraph_node::create_clone): Copy no_reorder.\n\t(cgraph_node::create_version_clone): Dito.\n\t(symbol_table::output_asm_statements): Remove.\n\t* trans-mem.c (ipa_tm_create_version_alias): Dito.\n\t* cgraphunit.c (varpool_node::finalize_decl): Check no_reorder.\n\t(output_in_order): Add no_reorder flag. Only handle no_reorder\n\tnodes when set.\n\t(symbol_table::compile): Add separate pass for no_reorder nodes.\n\t(process_common_attributes): Set no_reorder flag in symtab node.\n\tAdd node argument.\n\t(process_function_and_variable_attributes): Pass symtab nodes to\n\tprocess_common_attributes.\n\t* doc/extend.texi (no_reorder): Document no_reorder attribute.\n\t* lto-cgraph.c (lto_output_node): Serialize no_reorder.\n\t(lto_output_varpool_node): Dito.\n\t(input_overwrite_node): Dito.\n\t(input_varpool_node): Dito.\n\t* varpool.c (varpool_node::add): Set no_reorder attribute.\n\t(symbol_table::remove_unreferenced_decls): Handle no_reorder.\n\t(symbol_table::output_variables): Dito.\n\t* symtab.c (symtab_node::dump_base): Print no_reorder.\n\ngcc/lto/:\n\n2014-09-23  Andi Kleen  <ak@linux.intel.com>\n\n\t* lto-partition.c (node_cmp): Update comment.\n\t(varpool_node_cmp): Use symtab_node for comparison.\n\t(add_sorted_nodes): New function.\n\t(lto_balanced_map): Change to keep ordered queue\n\tof ordered node. Handle no_reorder attribute.\n\nFrom-SVN: r215537", "tree": {"sha": "73e70259b9d2f956939310c8f0e194397eda7e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73e70259b9d2f956939310c8f0e194397eda7e4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7861b6489dd7777b1b8829fd8726079f133eb34c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7861b6489dd7777b1b8829fd8726079f133eb34c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7861b6489dd7777b1b8829fd8726079f133eb34c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7861b6489dd7777b1b8829fd8726079f133eb34c/comments", "author": null, "committer": null, "parents": [{"sha": "2f4a54f2d91538336797b9a5401c83e6f9831f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4a54f2d91538336797b9a5401c83e6f9831f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f4a54f2d91538336797b9a5401c83e6f9831f0b"}], "stats": {"total": 276, "additions": 201, "deletions": 75}, "files": [{"sha": "a0de60bbc534fd0ee44e722070a59320361970a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -1,3 +1,29 @@\n+2014-09-23  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* cgraph.h (symtab_node): Add no_reorder attribute.\n+\t(symbol_table::output_asm_statements): Remove.\n+\t* cgraphclones.c (cgraph_node::create_clone): Copy no_reorder.\n+\t(cgraph_node::create_version_clone): Dito.\n+\t(symbol_table::output_asm_statements): Remove.\n+\t* trans-mem.c (ipa_tm_create_version_alias): Dito.\n+\t* cgraphunit.c (varpool_node::finalize_decl): Check no_reorder.\n+\t(output_in_order): Add no_reorder flag. Only handle no_reorder\n+\tnodes when set.\n+\t(symbol_table::compile): Add separate pass for no_reorder nodes.\n+\t(process_common_attributes): Set no_reorder flag in symtab node.\n+\tAdd node argument.\n+\t(process_function_and_variable_attributes): Pass symtab nodes to\n+\tprocess_common_attributes.\n+\t* doc/extend.texi (no_reorder): Document no_reorder attribute.\n+\t* lto-cgraph.c (lto_output_node): Serialize no_reorder.\n+\t(lto_output_varpool_node): Dito.\n+\t(input_overwrite_node): Dito.\n+\t(input_varpool_node): Dito.\n+\t* varpool.c (varpool_node::add): Set no_reorder attribute.\n+\t(symbol_table::remove_unreferenced_decls): Handle no_reorder.\n+\t(symbol_table::output_variables): Dito.\n+\t* symtab.c (symtab_node::dump_base): Print no_reorder.\n+\n 2014-09-23  Jiong Wang  <jiong.wang@arm.com>\n \n \t* shrink-wrap.c (try_shrink_wrapping): Check PIC_OFFSET_TABLE_REGNUM not"}, {"sha": "f8b4a14e4eac1265c6482ec911c888eb459fb9f7", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -1,3 +1,8 @@\n+2014-09-23  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* c-common.c (handle_no_reorder_attribute): New function.\n+\t(c_common_attribute_table): Add no_reorder attribute.\n+\n 2014-09-22  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-cppbuiltin.c (c_cpp_builtins): Define"}, {"sha": "a9e019199cdccbfd10687682fb14dc1ecde9f034", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -328,6 +328,8 @@ static tree handle_used_attribute (tree *, tree, tree, int, bool *);\n static tree handle_unused_attribute (tree *, tree, tree, int, bool *);\n static tree handle_externally_visible_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n+static tree handle_no_reorder_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *);\n static tree handle_const_attribute (tree *, tree, tree, int, bool *);\n static tree handle_transparent_union_attribute (tree *, tree, tree,\n \t\t\t\t\t\tint, bool *);\n@@ -652,6 +654,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_unused_attribute, false },\n   { \"externally_visible\",     0, 0, true,  false, false,\n \t\t\t      handle_externally_visible_attribute, false },\n+  { \"no_reorder\",\t      0, 0, true, false, false,\n+                              handle_no_reorder_attribute, false },\n   /* The same comments as for noreturn attributes apply to const ones.  */\n   { \"const\",                  0, 0, true,  false, false,\n \t\t\t      handle_const_attribute, false },\n@@ -6953,6 +6957,30 @@ handle_externally_visible_attribute (tree *pnode, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle the \"no_reorder\" attribute. Arguments as in\n+   struct attribute_spec.handler. */\n+\n+static tree\n+handle_no_reorder_attribute (tree *pnode,\n+\t\t\t     tree name,\n+\t\t\t     tree,\n+\t\t\t     int,\n+\t\t\t     bool *no_add_attrs)\n+{\n+  tree node = *pnode;\n+\n+  if ((TREE_CODE (node) != FUNCTION_DECL && TREE_CODE (node) != VAR_DECL)\n+\t&& !(TREE_STATIC (node) || DECL_EXTERNAL (node)))\n+    {\n+      warning (OPT_Wattributes,\n+\t\t\"%qE attribute only affects top level objects\",\n+\t\tname);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"const\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "6c046c739940a2399c6b2206f5527e12a3cffbcf", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -406,6 +406,8 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n   /* Set when function is visible by other units.  */\n   unsigned externally_visible : 1;\n+  /* Don't reorder to other symbols having this set.  */\n+  unsigned no_reorder : 1;\n   /* The symbol will be assumed to be used in an invisible way (like\n      by an toplevel asm statement).  */\n   unsigned force_output : 1;\n@@ -1707,9 +1709,6 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Output all variables enqueued to be assembled.  */\n   bool output_variables (void);\n \n-  /* Output all asm statements we have stored up to be output.  */\n-  void output_asm_statements (void);\n-\n   /* Weakrefs may be associated to external decls and thus not output\n      at expansion time.  Emit all necessary aliases.  */\n   void output_weakrefs (void);"}, {"sha": "38d92f53e836d8993b03acbbb40f1d831673c6d6", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -437,6 +437,7 @@ cgraph_node::create_clone (tree decl, gcov_type gcov_count, int freq,\n   new_node->definition = definition;\n   new_node->local = local;\n   new_node->externally_visible = false;\n+  new_node->no_reorder = no_reorder;\n   new_node->local.local = true;\n   new_node->global = global;\n   new_node->global.inlined_to = new_inlined_to;\n@@ -876,6 +877,7 @@ cgraph_node::create_version_clone (tree new_decl,\n    new_version->definition = definition;\n    new_version->local = local;\n    new_version->externally_visible = false;\n+   new_version->no_reorder = no_reorder;\n    new_version->local.local = new_version->definition;\n    new_version->global = global;\n    new_version->rtl = rtl;"}, {"sha": "b854e4b2a37d6c644f12004dd89ba3a6a61b0d0d", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -545,22 +545,6 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n     DECL_FUNCTION_PERSONALITY (fndecl) = lang_hooks.eh_personality ();\n }\n \n-/* Output all asm statements we have stored up to be output.  */\n-\n-void\n-symbol_table::output_asm_statements (void)\n-{\n-  asm_node *can;\n-\n-  if (seen_error ())\n-    return;\n-\n-  for (can = first_asm_symbol (); can; can = can->next)\n-    assemble_asm (can->asm_str);\n-\n-  clear_asm_symbols ();\n-}\n-\n /* Analyze the function scheduled to be output.  */\n void\n cgraph_node::analyze (void)\n@@ -657,7 +641,7 @@ symbol_table::process_same_body_aliases (void)\n /* Process attributes common for vars and functions.  */\n \n static void\n-process_common_attributes (tree decl)\n+process_common_attributes (symtab_node *node, tree decl)\n {\n   tree weakref = lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl));\n \n@@ -670,6 +654,9 @@ process_common_attributes (tree decl)\n       DECL_ATTRIBUTES (decl) = remove_attribute (\"weakref\",\n \t\t\t\t\t\t DECL_ATTRIBUTES (decl));\n     }\n+\n+  if (lookup_attribute (\"no_reorder\", DECL_ATTRIBUTES (decl)))\n+    node->no_reorder = 1;\n }\n \n /* Look for externally_visible and used attributes and mark cgraph nodes\n@@ -734,7 +721,7 @@ process_function_and_variable_attributes (cgraph_node *first,\n \twarning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,\n \t\t    \"always_inline function might not be inlinable\");\n      \n-      process_common_attributes (decl);\n+      process_common_attributes (node, decl);\n     }\n   for (vnode = symtab->first_variable (); vnode != first_var;\n        vnode = symtab->next_variable (vnode))\n@@ -763,7 +750,7 @@ process_function_and_variable_attributes (cgraph_node *first,\n \t  DECL_ATTRIBUTES (decl) = remove_attribute (\"weakref\",\n \t\t\t\t\t\t      DECL_ATTRIBUTES (decl));\n \t}\n-      process_common_attributes (decl);\n+      process_common_attributes (vnode, decl);\n     }\n }\n \n@@ -785,8 +772,10 @@ varpool_node::finalize_decl (tree decl)\n   if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl)\n       /* Traditionally we do not eliminate static variables when not\n \t optimizing and when not doing toplevel reoder.  */\n-      || (!flag_toplevel_reorder && !DECL_COMDAT (node->decl)\n-\t  && !DECL_ARTIFICIAL (node->decl)))\n+      || node->no_reorder\n+      || ((!flag_toplevel_reorder\n+          && !DECL_COMDAT (node->decl)\n+\t   && !DECL_ARTIFICIAL (node->decl))))\n     node->force_output = true;\n \n   if (symtab->state == CONSTRUCTION\n@@ -1922,10 +1911,11 @@ struct cgraph_order_sort\n    according to their order fields, which is the order in which they\n    appeared in the file.  This implements -fno-toplevel-reorder.  In\n    this mode we may output functions and variables which don't really\n-   need to be output.  */\n+   need to be output.\n+   When NO_REORDER is true only do this for symbols marked no reorder. */\n \n static void\n-output_in_order (void)\n+output_in_order (bool no_reorder)\n {\n   int max;\n   cgraph_order_sort *nodes;\n@@ -1940,6 +1930,8 @@ output_in_order (void)\n     {\n       if (pf->process && !pf->thunk.thunk_p && !pf->alias)\n \t{\n+\t  if (no_reorder && !pf->no_reorder)\n+\t    continue;\n \t  i = pf->order;\n \t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n \t  nodes[i].kind = ORDER_FUNCTION;\n@@ -1950,6 +1942,8 @@ output_in_order (void)\n   FOR_EACH_DEFINED_VARIABLE (pv)\n     if (!DECL_EXTERNAL (pv->decl))\n       {\n+\tif (no_reorder && !pv->no_reorder)\n+\t    continue;\n \ti = pv->order;\n \tgcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n \tnodes[i].kind = ORDER_VAR;\n@@ -2203,11 +2197,12 @@ symbol_table::compile (void)\n   state = EXPANSION;\n \n   if (!flag_toplevel_reorder)\n-    output_in_order ();\n+    output_in_order (false);\n   else\n     {\n-      output_asm_statements ();\n-\n+      /* Output first asm statements and anything ordered. The process\n+         flag is cleared for these nodes, so we skip them later.  */\n+      output_in_order (true);\n       expand_all_functions ();\n       output_variables ();\n     }"}, {"sha": "c78ffb2dabc184e7fa320f8b66bc3dce68832007", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -2180,7 +2180,7 @@ attributes are currently defined for functions on all targets:\n @code{returns_nonnull}, @code{gnu_inline},\n @code{externally_visible}, @code{hot}, @code{cold}, @code{artificial},\n @code{no_sanitize_address}, @code{no_address_safety_analysis},\n-@code{no_sanitize_undefined},\n+@code{no_sanitize_undefined}, @code{no_reorder},\n @code{error} and @code{warning}.\n Several other attributes are defined for functions on particular\n target systems.  Other attributes, including @code{section} are\n@@ -3472,6 +3472,16 @@ my_memcpy (void *dest, const void *src, size_t len)\n         __attribute__((nonnull));\n @end smallexample\n \n+@item no_reorder\n+@cindex @code{no_reorder} function or variable attribute\n+Do not reorder functions or variables marked @code{no_reorder}\n+against each other or top level assembler statements the executable.\n+The actual order in the program will depend on the linker command\n+line. Static variables marked like this are also not removed.\n+This has a similar effect\n+as the @option{-fno-toplevel-reorder} option, but only applies to the\n+marked symbols.\n+\n @item returns_nonnull\n @cindex @code{returns_nonnull} function attribute\n The @code{returns_nonnull} attribute specifies that the function"}, {"sha": "42d528c6634c9ddf7a3270ed50fc429ce584c167", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -640,6 +640,9 @@ function_and_variable_visibility (bool whole_program)\n           vnode->externally_visible = false;\n \t  vnode->forced_by_abi = false;\n \t}\n+      if (lookup_attribute (\"no_reorder\",\n+\t\t\t    DECL_ATTRIBUTES (vnode->decl)))\n+\tvnode->no_reorder = 1;\n       if (!vnode->externally_visible\n \t  && !vnode->weakref)\n \t{"}, {"sha": "0584946d5b0edf4f70c1639b8a61c0422b46557a", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -508,6 +508,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->local.local, 1);\n   bp_pack_value (&bp, node->externally_visible, 1);\n+  bp_pack_value (&bp, node->no_reorder, 1);\n   bp_pack_value (&bp, node->definition, 1);\n   bp_pack_value (&bp, node->local.versionable, 1);\n   bp_pack_value (&bp, node->local.can_change_signature, 1);\n@@ -581,6 +582,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->decl);\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->externally_visible, 1);\n+  bp_pack_value (&bp, node->no_reorder, 1);\n   bp_pack_value (&bp, node->force_output, 1);\n   bp_pack_value (&bp, node->forced_by_abi, 1);\n   bp_pack_value (&bp, node->unique_name, 1);\n@@ -1041,6 +1043,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \n   node->local.local = bp_unpack_value (bp, 1);\n   node->externally_visible = bp_unpack_value (bp, 1);\n+  node->no_reorder = bp_unpack_value (bp, 1);\n   node->definition = bp_unpack_value (bp, 1);\n   node->local.versionable = bp_unpack_value (bp, 1);\n   node->local.can_change_signature = bp_unpack_value (bp, 1);\n@@ -1246,6 +1249,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n \n   bp = streamer_read_bitpack (ib);\n   node->externally_visible = bp_unpack_value (&bp, 1);\n+  node->no_reorder = bp_unpack_value (&bp, 1);\n   node->force_output = bp_unpack_value (&bp, 1);\n   node->forced_by_abi = bp_unpack_value (&bp, 1);\n   node->unique_name = bp_unpack_value (&bp, 1);"}, {"sha": "762296cc6b7cdccd174caaf2f8cc08611ab58974", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -1,3 +1,11 @@\n+2014-09-23  Andi Kleen  <ak@linux.intel.com>\n+\n+\t* lto-partition.c (node_cmp): Update comment.\n+\t(varpool_node_cmp): Use symtab_node for comparison.\n+\t(add_sorted_nodes): New function.\n+\t(lto_balanced_map): Change to keep ordered queue\n+\tof ordered node. Handle no_reorder attribute.\n+\n 2014-09-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (lto_read_decls): Register ODR types."}, {"sha": "0451a66be3457b7515b019d077c516304f417d03", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -333,7 +333,8 @@ lto_max_map (void)\n     new_partition (\"empty\");\n }\n \n-/* Helper function for qsort; sort nodes by order.  */\n+/* Helper function for qsort; sort nodes by order. noreorder functions must have\n+   been removed earlier.  */\n static int\n node_cmp (const void *pa, const void *pb)\n {\n@@ -365,11 +366,26 @@ node_cmp (const void *pa, const void *pb)\n static int\n varpool_node_cmp (const void *pa, const void *pb)\n {\n-  const varpool_node *a = *(const varpool_node * const *) pa;\n-  const varpool_node *b = *(const varpool_node * const *) pb;\n+  const symtab_node *a = *static_cast<const symtab_node * const *> (pa);\n+  const symtab_node *b = *static_cast<const symtab_node * const *> (pb);\n   return b->order - a->order;\n }\n \n+/* Add all symtab nodes from NEXT_NODE to PARTITION in order.  */\n+\n+static void\n+add_sorted_nodes (vec<symtab_node *> &next_nodes, ltrans_partition partition)\n+{\n+  unsigned i;\n+  symtab_node *node;\n+\n+  next_nodes.qsort (varpool_node_cmp);\n+  FOR_EACH_VEC_ELT (next_nodes, i, node)\n+    if (!symbol_partitioned_p (node))\n+      add_symbol_to_partition (partition, node);\n+}\n+\n+\n /* Group cgraph nodes into equally-sized partitions.\n \n    The partitioning algorithm is simple: nodes are taken in predefined order.\n@@ -414,7 +430,8 @@ lto_balanced_map (int n_lto_partitions)\n   int n_nodes = 0;\n   int n_varpool_nodes = 0, varpool_pos = 0, best_varpool_pos = 0;\n   struct cgraph_node **order = XNEWVEC (cgraph_node *, symtab->cgraph_max_uid);\n-  varpool_node **varpool_order = NULL;\n+  auto_vec<cgraph_node *> noreorder;\n+  auto_vec<varpool_node *> varpool_order;\n   int i;\n   struct cgraph_node *node;\n   int total_size = 0, best_total_size = 0;\n@@ -427,14 +444,18 @@ lto_balanced_map (int n_lto_partitions)\n     INT_MAX, best_internal = 0;\n   int npartitions;\n   int current_order = -1;\n+  int noreorder_pos = 0;\n \n   FOR_EACH_VARIABLE (vnode)\n     gcc_assert (!vnode->aux);\n     \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (node->get_partitioning_class () == SYMBOL_PARTITION)\n       {\n-\torder[n_nodes++] = node;\n+\tif (node->no_reorder)\n+\t  noreorder.safe_push (node);\n+\telse\n+\t  order[n_nodes++] = node;\n \tif (!node->alias)\n \t  total_size += inline_summary (node)->size;\n       }\n@@ -445,27 +466,26 @@ lto_balanced_map (int n_lto_partitions)\n      get better about minimizing the function bounday, but until that\n      things works smoother if we order in source order.  */\n   qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n+  noreorder.qsort (node_cmp);\n \n   if (symtab->dump_file)\n-    for(i = 0; i < n_nodes; i++)\n-      fprintf (symtab->dump_file, \"Balanced map symbol order:%s:%u\\n\",\n-\t       order[i]->name (), order[i]->tp_first_run);\n-\n-  if (!flag_toplevel_reorder)\n     {\n-      FOR_EACH_VARIABLE (vnode)\n-\tif (vnode->get_partitioning_class () == SYMBOL_PARTITION)\n-\t  n_varpool_nodes++;\n-      varpool_order = XNEWVEC (varpool_node *, n_varpool_nodes);\n-\n-      n_varpool_nodes = 0;\n-      FOR_EACH_VARIABLE (vnode)\n-\tif (vnode->get_partitioning_class () == SYMBOL_PARTITION)\n-\t  varpool_order[n_varpool_nodes++] = vnode;\n-      qsort (varpool_order, n_varpool_nodes, sizeof (varpool_node *),\n-\t     varpool_node_cmp);\n+      for(i = 0; i < n_nodes; i++)\n+\tfprintf (symtab->dump_file, \"Balanced map symbol order:%s:%u\\n\",\n+\t\t order[i]->name (), order[i]->tp_first_run);\n+      for(i = 0; i < (int)noreorder.length(); i++)\n+\tfprintf (symtab->dump_file, \"Balanced map symbol no_reorder:%s:%u\\n\",\n+\t\t noreorder[i]->name (), noreorder[i]->tp_first_run);\n     }\n \n+  /* Collect all variables that should not be reordered.  */\n+  FOR_EACH_VARIABLE (vnode)\n+    if (vnode->get_partitioning_class () == SYMBOL_PARTITION\n+\t&& (!flag_toplevel_reorder || vnode->no_reorder))\n+      varpool_order.safe_push (vnode);\n+  n_varpool_nodes = varpool_order.length ();\n+  varpool_order.qsort (varpool_node_cmp);\n+\n   /* Compute partition size and create the first partition.  */\n   partition_size = total_size / n_lto_partitions;\n   if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n@@ -476,21 +496,28 @@ lto_balanced_map (int n_lto_partitions)\n     fprintf (symtab->dump_file, \"Total unit size: %i, partition size: %i\\n\",\n \t     total_size, partition_size);\n \n+  auto_vec<symtab_node *> next_nodes;\n+\n   for (i = 0; i < n_nodes; i++)\n     {\n       if (symbol_partitioned_p (order[i]))\n \tcontinue;\n \n       current_order = order[i]->order;\n \n-      if (!flag_toplevel_reorder)\n-\twhile (varpool_pos < n_varpool_nodes\n-\t       && varpool_order[varpool_pos]->order < current_order)\n-\t  {\n-\t    if (!symbol_partitioned_p (varpool_order[varpool_pos]))\n-\t      add_symbol_to_partition (partition, varpool_order[varpool_pos]);\n-\t    varpool_pos++;\n-\t  }\n+      /* Output noreorder and varpool in program order first.  */\n+      next_nodes.truncate (0);\n+      while (varpool_pos < n_varpool_nodes\n+\t     && varpool_order[varpool_pos]->order < current_order)\n+\tnext_nodes.safe_push (varpool_order[varpool_pos++]);\n+      while (noreorder_pos < (int)noreorder.length ()\n+\t     && noreorder[noreorder_pos]->order < current_order)\n+\t{\n+\t  if (!noreorder[noreorder_pos]->alias)\n+\t    total_size -= inline_summary (noreorder[noreorder_pos])->size;\n+\t  next_nodes.safe_push (noreorder[noreorder_pos++]);\n+\t}\n+      add_sorted_nodes (next_nodes, partition);\n \n       add_symbol_to_partition (partition, order[i]);\n       if (!order[i]->alias)\n@@ -580,6 +607,7 @@ lto_balanced_map (int n_lto_partitions)\n \t\tif (!vnode->definition)\n \t\t  continue;\n \t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n+\t\t    && !vnode->no_reorder\n \t\t    && vnode->get_partitioning_class () == SYMBOL_PARTITION)\n \t\t  add_symbol_to_partition (partition, vnode);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n@@ -616,6 +644,7 @@ lto_balanced_map (int n_lto_partitions)\n \t\t   to be removed.  Coupling with objects they refer to only helps to reduce\n \t\t   number of symbols promoted to hidden.  */\n \t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n+\t\t    && !vnode->no_reorder\n \t\t    && !vnode->can_remove_if_no_refs_p ()\n \t\t    && vnode->get_partitioning_class () == SYMBOL_PARTITION)\n \t\t  add_symbol_to_partition (partition, vnode);\n@@ -705,24 +734,25 @@ lto_balanced_map (int n_lto_partitions)\n \t}\n     }\n \n+  next_nodes.truncate (0);\n+\n   /* Varables that are not reachable from the code go into last partition.  */\n   if (flag_toplevel_reorder)\n     {\n       FOR_EACH_VARIABLE (vnode)\n \tif (vnode->get_partitioning_class () == SYMBOL_PARTITION\n-\t    && !symbol_partitioned_p (vnode))\n-\t  add_symbol_to_partition (partition, vnode);\n-    }\n-  else\n-    {\n-      while (varpool_pos < n_varpool_nodes)\n-\t{\n-\t  if (!symbol_partitioned_p (varpool_order[varpool_pos]))\n-\t    add_symbol_to_partition (partition, varpool_order[varpool_pos]);\n-\t  varpool_pos++;\n-\t}\n-      free (varpool_order);\n+\t    && !symbol_partitioned_p (vnode)\n+\t    && !vnode->no_reorder)\n+\t  next_nodes.safe_push (vnode);\n     }\n+\n+  /* Output remaining ordered symbols.  */\n+  while (varpool_pos < n_varpool_nodes)\n+    next_nodes.safe_push (varpool_order[varpool_pos++]);\n+  while (noreorder_pos < (int)noreorder.length ())\n+    next_nodes.safe_push (noreorder[noreorder_pos++]);\n+  add_sorted_nodes (next_nodes, partition);\n+\n   free (order);\n }\n "}, {"sha": "76223b2f20ee58f39111d7c93f469f6a8eb60b48", "filename": "gcc/symtab.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -831,6 +831,8 @@ symtab_node::dump_base (FILE *f)\n     fprintf (f, \" forced_by_abi\");\n   if (externally_visible)\n     fprintf (f, \" externally_visible\");\n+  if (no_reorder)\n+    fprintf (f, \" no_reorder\");\n   if (resolution != LDPR_UNKNOWN)\n     fprintf (f, \" %s\",\n  \t     ld_plugin_symbol_resolution_names[(int)resolution]);"}, {"sha": "94d896d6f9db57f11badd94ae629bd8a0eeea61c", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -4849,6 +4849,7 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n   new_node = cgraph_node::create_same_body_alias (new_decl, info->new_decl);\n   new_node->tm_clone = true;\n   new_node->externally_visible = info->old_node->externally_visible;\n+  new_node->no_reorder = info->old_node->no_reorder;\n   /* ?? Do not traverse aliases here.  */\n   get_cg_data (&node, false)->clone = new_node;\n "}, {"sha": "8001c93b012f4b1ee9c0f183b893ec021757b9af", "filename": "gcc/varpool.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7861b6489dd7777b1b8829fd8726079f133eb34c/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=7861b6489dd7777b1b8829fd8726079f133eb34c", "patch": "@@ -449,6 +449,8 @@ varpool_node::add (tree decl)\n   symtab->call_varpool_insertion_hooks (node);\n   if (node->externally_visible_p ())\n     node->externally_visible = true;\n+  if (lookup_attribute (\"no_reorder\", decl))\n+    node->no_reorder = 1;\n }\n \n /* Return variable availability.  See cgraph.h for description of individual\n@@ -640,7 +642,7 @@ symbol_table::remove_unreferenced_decls (void)\n   for (node = first_defined_variable (); node; node = next)\n     {\n       next = next_defined_variable (node);\n-      if (!node->aux)\n+      if (!node->aux && !node->no_reorder)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \" %s\", node->asm_name ());\n@@ -687,11 +689,22 @@ symbol_table::output_variables (void)\n   timevar_push (TV_VAROUT);\n \n   FOR_EACH_DEFINED_VARIABLE (node)\n-    node->finalize_named_section_flags ();\n+    {\n+      /* Handled in output_in_order.  */\n+      if (node->no_reorder)\n+\tcontinue;\n+\n+      node->finalize_named_section_flags ();\n+    }\n \n   FOR_EACH_DEFINED_VARIABLE (node)\n-    if (node->assemble_decl ())\n-      changed = true;\n+    {\n+      /* Handled in output_in_order.  */\n+      if (node->no_reorder)\n+\tcontinue;\n+      if (node->assemble_decl ())\n+        changed = true;\n+    }\n   timevar_pop (TV_VAROUT);\n   return changed;\n }"}]}