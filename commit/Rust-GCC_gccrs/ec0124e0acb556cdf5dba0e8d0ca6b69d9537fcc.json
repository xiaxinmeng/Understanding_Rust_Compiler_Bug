{"sha": "ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc", "node_id": "C_kwDOANBUbNoAKGVjMDEyNGUwYWNiNTU2Y2RmNWRiYTBlOGQwY2E2YjY5ZDk1MzdmY2M", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-05T13:03:34Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-05T16:24:30Z"}, "message": "Loosen loop crossing restriction in threader.\n\nCrossing loops is generally discouraged from the threader, but we can\nmake an exception when we don't cross the latch or enter another loop,\nsince this is just an early exit out of the loop.\n\nIn fact, the whole threaded path is logically outside the loop.  This\nhas nice secondary effects.  For example, objects on the threaded path\nwill no longer necessarily be live throughout the loop, so we can get\nregister allocation improvements.  The threaded path can physically\nmove outside the loop resulting in better icache efficiency, etc.\n\nTested on x86-64 Linux, and on a visium-elf cross making sure that the\nfollowing tests do not have an abort in the final assembly:\n\ngcc.c-torture/execute/960218-1.c\ngcc.c-torture/execute/visium-pending-4.c\ngcc.c-torture/execute/pr58209.c\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadupdate.c (jt_path_registry::cancel_invalid_paths):\n\tLoosen restrictions\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/ssa-thread-valid.c: New test.", "tree": {"sha": "644adb390be49233e736f3aa2639fe2da2b23bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/644adb390be49233e736f3aa2639fe2da2b23bcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f51e9af7b615838424214e6aaea0de793cb10fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f51e9af7b615838424214e6aaea0de793cb10fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f51e9af7b615838424214e6aaea0de793cb10fe"}], "stats": {"total": 79, "additions": 68, "deletions": 11}, "files": [{"sha": "7adca97cc2b1ce445cbd0ea3aa6e6fc58a189aa1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-valid.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-valid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-valid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-valid.c?ref=ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fgimple -fdump-statistics\" }\n+\n+// This is a collection of threadable paths.  To simplify maintenance,\n+// there should only be one threadable path per function.\n+\n+int global;\n+\n+// The thread from 3->4->5 crosses loops but is allowed because it\n+// never crosses the latch (BB3) and is just an early exit out of the\n+// loop.\n+int __GIMPLE (ssa)\n+foo1 (int x)\n+{\n+  int D_1420;\n+  int a;\n+\n+  __BB(2):\n+  a_4 = ~x_3(D);\n+  goto __BB4;\n+\n+  // Latch.\n+  __BB(3):\n+  global = a_1;\n+  goto __BB4;\n+\n+  __BB(4,loop_header(1)):\n+  a_1 = __PHI (__BB2: a_4, __BB3: 0);\n+  if (a_1 != 0)\n+    goto __BB3;\n+  else\n+    goto __BB5;\n+\n+  __BB(5):\n+  return;\n+\n+}\n+\n+// { dg-final { scan-tree-dump \"Jumps threaded\\\" \\\"foo1\\\" 1\" \"statistics\" } }"}, {"sha": "32ce1e3af409f2a30811e9ef996530459519902c", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=ec0124e0acb556cdf5dba0e8d0ca6b69d9537fcc", "patch": "@@ -2766,10 +2766,17 @@ bool\n jt_path_registry::cancel_invalid_paths (vec<jump_thread_edge *> &path)\n {\n   gcc_checking_assert (!path.is_empty ());\n-  edge taken_edge = path[path.length () - 1]->e;\n-  loop_p loop = taken_edge->src->loop_father;\n+  edge entry = path[0]->e;\n+  edge exit = path[path.length () - 1]->e;\n   bool seen_latch = false;\n-  bool path_crosses_loops = false;\n+  int loops_crossed = 0;\n+  bool crossed_latch = false;\n+  // Use ->dest here instead of ->src to ignore the first block.  The\n+  // first block is allowed to be in a different loop, since it'll be\n+  // redirected.  See similar comment in profitable_path_p: \"we don't\n+  // care about that block...\".\n+  loop_p loop = entry->dest->loop_father;\n+  loop_p curr_loop = loop;\n \n   for (unsigned int i = 0; i < path.length (); i++)\n     {\n@@ -2784,19 +2791,30 @@ jt_path_registry::cancel_invalid_paths (vec<jump_thread_edge *> &path)\n \t}\n \n       if (loop->latch == e->src || loop->latch == e->dest)\n-\tseen_latch = true;\n+\t{\n+\t  seen_latch = true;\n+\t  // Like seen_latch, but excludes the first block.\n+\t  if (e->src != entry->src)\n+\t    crossed_latch = true;\n+\t}\n \n-      // The first entry represents the block with an outgoing edge\n-      // that we will redirect to the jump threading path.  Thus we\n-      // don't care about that block's loop father.\n-      if ((i > 0 && e->src->loop_father != loop)\n-\t  || e->dest->loop_father != loop)\n-\tpath_crosses_loops = true;\n+      if (e->dest->loop_father != curr_loop)\n+\t{\n+\t  curr_loop = e->dest->loop_father;\n+\t  ++loops_crossed;\n+\t}\n \n       if (flag_checking && !m_backedge_threads)\n \tgcc_assert ((path[i]->e->flags & EDGE_DFS_BACK) == 0);\n     }\n \n+  // If we crossed a loop into an outer loop without crossing the\n+  // latch, this is just an early exit from the loop.\n+  if (loops_crossed == 1\n+      && !crossed_latch\n+      && flow_loop_nested_p (exit->dest->loop_father, exit->src->loop_father))\n+    return false;\n+\n   if (cfun->curr_properties & PROP_loop_opts_done)\n     return false;\n \n@@ -2806,7 +2824,7 @@ jt_path_registry::cancel_invalid_paths (vec<jump_thread_edge *> &path)\n \t\t     \"would create non-empty latch\");\n       return true;\n     }\n-  if (path_crosses_loops)\n+  if (loops_crossed)\n     {\n       cancel_thread (&path, \"Path crosses loops\");\n       return true;"}]}