{"sha": "2bdfeefa887fd39b27a2c456d09fbd721fd5278d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJkZmVlZmE4ODdmZDM5YjI3YTJjNDU2ZDA5ZmJkNzIxZmQ1Mjc4ZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-09-05T12:24:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-05T12:24:04Z"}, "message": "Makefile.in (pexecute.o): Use pexecute.c from libiberty.\n\n        * Makefile.in (pexecute.o): Use pexecute.c from libiberty.  Provide\n        explicit rules for building.  Similarly for alloca, vfprintf,\n        choose-temp and mkstemp, getopt, getopt1, and obstack.\n        (INCLUDES): Add $(srcdir)/../include.\n        * pexecute.c, alloca.c, vfprintf.c, choose-temp.c, mkstemp.c: Delete.\n        * getopt.h, getopt.c getopt1.c, obstack.c, obstack.h: Likewise.\n\nFrom-SVN: r22258", "tree": {"sha": "d1aa596ba583fe8dd033388c83c78e6fd48d383f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1aa596ba583fe8dd033388c83c78e6fd48d383f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bdfeefa887fd39b27a2c456d09fbd721fd5278d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bdfeefa887fd39b27a2c456d09fbd721fd5278d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bdfeefa887fd39b27a2c456d09fbd721fd5278d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bdfeefa887fd39b27a2c456d09fbd721fd5278d/comments", "author": null, "committer": null, "parents": [{"sha": "7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e"}], "stats": {"total": 1216, "additions": 17, "deletions": 1199}, "files": [{"sha": "ff6834cb881eda54ddfd07f6676ae378435c2ee1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bdfeefa887fd39b27a2c456d09fbd721fd5278d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bdfeefa887fd39b27a2c456d09fbd721fd5278d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bdfeefa887fd39b27a2c456d09fbd721fd5278d", "patch": "@@ -2,10 +2,10 @@ Sat Sep  5 03:23:05 1998  Jeffrey A Law  (law@cygnus.com)\n \n         * Makefile.in (pexecute.o): Use pexecute.c from libiberty.  Provide\n \texplicit rules for building.  Similarly for alloca, vfprintf,\n-\tchoose-temp and mkstemp, getopt, getopt1.\n+\tchoose-temp and mkstemp, getopt, getopt1, and obstack.\n \t(INCLUDES): Add $(srcdir)/../include.\n         * pexecute.c, alloca.c, vfprintf.c, choose-temp.c, mkstemp.c: Delete.\n-\t* getopt.h, getopt.c getopt1.c: Likewise.\n+\t* getopt.h, getopt.c getopt1.c, obstack.c, obstack.h: Likewise.\n \n Fri Sep  4 11:57:50 1998  Tom Tromey  <tromey@cygnus.com>\n "}, {"sha": "5ee23204c85be4b8219a40bf24732c218de83468", "filename": "gcc/Makefile.in", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bdfeefa887fd39b27a2c456d09fbd721fd5278d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bdfeefa887fd39b27a2c456d09fbd721fd5278d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2bdfeefa887fd39b27a2c456d09fbd721fd5278d", "patch": "@@ -521,8 +521,7 @@ all: all.indirect\n \n all.indirect: $(ALL)\n \n-# IN_GCC tells obstack.h that we are using gcc's <stddef.h> file.\n-# ??? IN_GCC should be obsolete now.\n+# IN_GCC tells various files that system.h, toplev.c, etc are available.\n INTERNAL_CFLAGS = $(CROSS) -DIN_GCC @extra_c_flags@\n \n # This is the variable actually used when we compile.\n@@ -1295,8 +1294,8 @@ collect2$(exeext): collect2.o tlink.o hash.o cplus-dem.o underscore.o \\\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ collect2.o tlink.o hash.o \\\n \t  cplus-dem.o underscore.o version.o choose-temp.o mkstemp.o $(LIBS)\n \n-collect2.o : collect2.c $(CONFIG_H) system.h gansidecl.h gstab.h obstack.h \\\n-\t$(DEMANGLE_H)\n+collect2.o : collect2.c $(CONFIG_H) system.h gansidecl.h gstab.h \\\n+\t$(srcdir)/../include/obstack.h $(DEMANGLE_H)\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES)  \\\n \t-DTARGET_MACHINE=\\\"$(target_alias)\\\" $(MAYBE_USE_COLLECT2) \\\n \t-c `echo $(srcdir)/collect2.c | sed 's,^\\./,,'`\n@@ -1369,7 +1368,11 @@ gencheck.o : gencheck.c hconfig.h system.h\n dumpvers: dumpvers.c\n \n version.o: version.c\n-obstack.o: obstack.c $(CONFIG_H)\n+obstack.o: $(srcdir)/../libiberty/obstack.c $(CONFIG_H)\n+\trm -f obstack.c\n+\t$(LN_S) $(srcdir)/../libiberty/obstack.c obstack.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) obstack.c\n+\n choose-temp.o: $(srcdir)/../libiberty/choose-temp.c $(CONFIG_H) gansidecl.h \\\n \tsystem.h\n \trm -f choose-temp.c\n@@ -1436,7 +1439,8 @@ dbxout.o : dbxout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h $(REGS_H) \\\n    toplev.h\n sdbout.o : sdbout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h except.h \\\n    function.h $(EXPR_H) output.h hard-reg-set.h $(REGS_H) defaults.h real.h \\\n-   insn-config.h obstack.h xcoffout.h c-pragma.h sdbout.h toplev.h\n+   insn-config.h $(srcdir)/../include/obstack.h xcoffout.h c-pragma.h \\\n+   sdbout.h toplev.h\n dwarfout.o : dwarfout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf.h \\\n    flags.h insn-config.h reload.h output.h defaults.h toplev.h dwarfout.h\n dwarf2out.o : dwarf2out.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf2.h \\\n@@ -1446,7 +1450,7 @@ xcoffout.o : xcoffout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h toplev.h output.h dbxout.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    except.h function.h $(REGS_H) insn-config.h $(RECOG_H) real.h \\\n-   $(EXPR_H) obstack.h hard-reg-set.h bitmap.h\n+   $(EXPR_H) $(srcdir)/../include/obstack.h hard-reg-set.h bitmap.h\n real.o : real.c $(CONFIG_H) system.h $(TREE_H) toplev.h\n getpwd.o : getpwd.c $(CONFIG_H) system.h\n \n@@ -1815,9 +1819,9 @@ $(HOST_PREFIX_1)alloca.o: $(srcdir)/../libiberty/alloca.c\n \t$(LN_S) $(srcdir)/../libiberty/alloca.c $(HOST_PREFIX)alloca.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)alloca.c\n \n-$(HOST_PREFIX_1)obstack.o: obstack.c\n+$(HOST_PREFIX_1)obstack.o: $(srcdir)/../libiberty/obstack.c\n \trm -f $(HOST_PREFIX)obstack.c\n-\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/obstack.c > $(HOST_PREFIX)obstack.c\n+\tsed -e 's/config[.]h/hconfig.h/' $(srcdir)/../libiberty/obstack.c > $(HOST_PREFIX)obstack.c\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(HOST_PREFIX)obstack.c\n \n $(HOST_PREFIX_1)vfprintf.o: $(srcdir)/../libiberty/vfprintf.c\n@@ -2092,8 +2096,8 @@ fix-header: fix-header.o scan-decls.o scan.o xsys-protos.h $(HOST_LIBDEPS) \\\n \t   scan-decls.o scan.o cpplib.o cpphash.o cppalloc.o prefix.o \\\n \t   version.o cppexp.o $(HOST_LIBS)\n \n-fix-header.o: fix-header.c obstack.h scan.h xsys-protos.h $(build_xm_file) \\\n-\tsystem.h cpplib.h cpphash.h\n+fix-header.o: fix-header.c $(srcdir)/../include/obstack.h scan.h \\\n+\txsys-protos.h $(build_xm_file) system.h cpplib.h cpphash.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/fix-header.c\n \n scan-decls.o: scan-decls.c scan.h cpplib.h $(build_xm_file) system.h gansidecl.h"}, {"sha": "bc318b37790eeb1cde7bdcde56fe383c60a9a310", "filename": "gcc/obstack.c", "status": "removed", "additions": 0, "deletions": 593, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e/gcc%2Fobstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e/gcc%2Fobstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobstack.c?ref=7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e", "patch": "@@ -1,593 +0,0 @@\n-/* obstack.c - subroutines used implicitly by object stack macros\n-   Copyright (C) 1988,89,90,91,92,93,94,96,97 Free Software Foundation, Inc.\n-\n-\n-   NOTE: The canonical source of this file is maintained with the GNU C Library.\n-   Bugs can be reported to bug-glibc@gnu.org.\n-\n-   This program is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 2, or (at your option) any\n-   later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-   USA.  */\n-\n-#ifdef HAVE_CONFIG_H\n-#include <config.h>\n-#endif\n-\n-#include \"obstack.h\"\n-\n-/* NOTE BEFORE MODIFYING THIS FILE: This version number must be\n-   incremented whenever callers compiled using an old obstack.h can no\n-   longer properly call the functions in this obstack.c.  */\n-#define OBSTACK_INTERFACE_VERSION 1\n-\n-/* Comment out all this code if we are using the GNU C Library, and are not\n-   actually compiling the library itself, and the installed library\n-   supports the same library interface we do.  This code is part of the GNU\n-   C Library, but also included in many other GNU distributions.  Compiling\n-   and linking in this code is a waste when using the GNU C library\n-   (especially if it is a shared library).  Rather than having every GNU\n-   program understand `configure --with-gnu-libc' and omit the object\n-   files, it is simpler to just do this in the source for each such file.  */\n-\n-#include <stdio.h>\t\t/* Random thing to get __GNU_LIBRARY__.  */\n-#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1\n-#include <gnu-versions.h>\n-#if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION\n-#define ELIDE_CODE\n-#endif\n-#endif\n-\n-\n-#ifndef ELIDE_CODE\n-\n-\n-#if defined (__STDC__) && __STDC__\n-#define POINTER void *\n-#else\n-#define POINTER char *\n-#endif\n-\n-/* Determine default alignment.  */\n-struct fooalign {char x; double d;};\n-#define DEFAULT_ALIGNMENT  \\\n-  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))\n-/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.\n-   But in fact it might be less smart and round addresses to as much as\n-   DEFAULT_ROUNDING.  So we prepare for it to do that.  */\n-union fooround {long x; double d;};\n-#define DEFAULT_ROUNDING (sizeof (union fooround))\n-\n-/* When we copy a long block of data, this is the unit to do it with.\n-   On some machines, copying successive ints does not work;\n-   in such a case, redefine COPYING_UNIT to `long' (if that works)\n-   or `char' as a last resort.  */\n-#ifndef COPYING_UNIT\n-#define COPYING_UNIT int\n-#endif\n-\n-\n-/* The functions allocating more room by calling `obstack_chunk_alloc'\n-   jump to the handler pointed to by `obstack_alloc_failed_handler'.\n-   This variable by default points to the internal function\n-   `print_and_abort'.  */\n-#if defined (__STDC__) && __STDC__\n-static void print_and_abort (void);\n-void (*obstack_alloc_failed_handler) (void) = print_and_abort;\n-#else\n-static void print_and_abort ();\n-void (*obstack_alloc_failed_handler) () = print_and_abort;\n-#endif\n-\n-/* Exit value used when `print_and_abort' is used.  */\n-#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H\n-#include <stdlib.h>\n-#endif\n-#ifndef EXIT_FAILURE\n-#define EXIT_FAILURE 1\n-#endif\n-int obstack_exit_failure = EXIT_FAILURE;\n-\n-/* The non-GNU-C macros copy the obstack into this global variable\n-   to avoid multiple evaluation.  */\n-\n-struct obstack *_obstack;\n-\n-/* Define a macro that either calls functions with the traditional malloc/free\n-   calling interface, or calls functions with the mmalloc/mfree interface\n-   (that adds an extra first argument), based on the state of use_extra_arg.\n-   For free, do not use ?:, since some compilers, like the MIPS compilers,\n-   do not allow (expr) ? void : void.  */\n-\n-#if defined (__STDC__) && __STDC__\n-#define CALL_CHUNKFUN(h, size) \\\n-  (((h) -> use_extra_arg) \\\n-   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n-   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))\n-\n-#define CALL_FREEFUN(h, old_chunk) \\\n-  do { \\\n-    if ((h) -> use_extra_arg) \\\n-      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \\\n-    else \\\n-      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \\\n-  } while (0)\n-#else\n-#define CALL_CHUNKFUN(h, size) \\\n-  (((h) -> use_extra_arg) \\\n-   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \\\n-   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))\n-\n-#define CALL_FREEFUN(h, old_chunk) \\\n-  do { \\\n-    if ((h) -> use_extra_arg) \\\n-      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \\\n-    else \\\n-      (*(void (*) ()) (h)->freefun) ((old_chunk)); \\\n-  } while (0)\n-#endif\n-\n-\f\n-/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).\n-   Objects start on multiples of ALIGNMENT (0 means use default).\n-   CHUNKFUN is the function to use to allocate chunks,\n-   and FREEFUN the function to free them.\n-\n-   Return nonzero if successful, zero if out of memory.\n-   To recover from an out of memory error,\n-   free up some memory, then call this again.  */\n-\n-int\n-_obstack_begin (h, size, alignment, chunkfun, freefun)\n-     struct obstack *h;\n-     int size;\n-     int alignment;\n-#if defined (__STDC__) && __STDC__\n-     POINTER (*chunkfun) (long);\n-     void (*freefun) (void *);\n-#else\n-     POINTER (*chunkfun) ();\n-     void (*freefun) ();\n-#endif\n-{\n-  register struct _obstack_chunk *chunk; /* points to new chunk */\n-\n-  if (alignment == 0)\n-    alignment = (int) DEFAULT_ALIGNMENT;\n-  if (size == 0)\n-    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n-    {\n-      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n-\t Use the values for range checking, because if range checking is off,\n-\t the extra bytes won't be missed terribly, but if range checking is on\n-\t and we used a larger request, a whole extra 4096 bytes would be\n-\t allocated.\n-\n-\t These number are irrelevant to the new GNU malloc.  I suspect it is\n-\t less sensitive to the size of the request.  */\n-      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n-\t\t    + 4 + DEFAULT_ROUNDING - 1)\n-\t\t   & ~(DEFAULT_ROUNDING - 1));\n-      size = 4096 - extra;\n-    }\n-\n-#if defined (__STDC__) && __STDC__\n-  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;\n-  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n-#else\n-  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n-  h->freefun = freefun;\n-#endif\n-  h->chunk_size = size;\n-  h->alignment_mask = alignment - 1;\n-  h->use_extra_arg = 0;\n-\n-  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n-  if (!chunk)\n-    (*obstack_alloc_failed_handler) ();\n-  h->next_free = h->object_base = chunk->contents;\n-  h->chunk_limit = chunk->limit\n-    = (char *) chunk + h->chunk_size;\n-  chunk->prev = 0;\n-  /* The initial chunk now contains no empty object.  */\n-  h->maybe_empty_object = 0;\n-  h->alloc_failed = 0;\n-  return 1;\n-}\n-\n-int\n-_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)\n-     struct obstack *h;\n-     int size;\n-     int alignment;\n-#if defined (__STDC__) && __STDC__\n-     POINTER (*chunkfun) (POINTER, long);\n-     void (*freefun) (POINTER, POINTER);\n-#else\n-     POINTER (*chunkfun) ();\n-     void (*freefun) ();\n-#endif\n-     POINTER arg;\n-{\n-  register struct _obstack_chunk *chunk; /* points to new chunk */\n-\n-  if (alignment == 0)\n-    alignment = (int) DEFAULT_ALIGNMENT;\n-  if (size == 0)\n-    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n-    {\n-      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n-\t Use the values for range checking, because if range checking is off,\n-\t the extra bytes won't be missed terribly, but if range checking is on\n-\t and we used a larger request, a whole extra 4096 bytes would be\n-\t allocated.\n-\n-\t These number are irrelevant to the new GNU malloc.  I suspect it is\n-\t less sensitive to the size of the request.  */\n-      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n-\t\t    + 4 + DEFAULT_ROUNDING - 1)\n-\t\t   & ~(DEFAULT_ROUNDING - 1));\n-      size = 4096 - extra;\n-    }\n-\n-#if defined(__STDC__) && __STDC__\n-  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n-  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n-#else\n-  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;\n-  h->freefun = freefun;\n-#endif\n-  h->chunk_size = size;\n-  h->alignment_mask = alignment - 1;\n-  h->extra_arg = arg;\n-  h->use_extra_arg = 1;\n-\n-  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n-  if (!chunk)\n-    (*obstack_alloc_failed_handler) ();\n-  h->next_free = h->object_base = chunk->contents;\n-  h->chunk_limit = chunk->limit\n-    = (char *) chunk + h->chunk_size;\n-  chunk->prev = 0;\n-  /* The initial chunk now contains no empty object.  */\n-  h->maybe_empty_object = 0;\n-  h->alloc_failed = 0;\n-  return 1;\n-}\n-\n-/* Allocate a new current chunk for the obstack *H\n-   on the assumption that LENGTH bytes need to be added\n-   to the current object, or a new object of length LENGTH allocated.\n-   Copies any partial object from the end of the old chunk\n-   to the beginning of the new one.  */\n-\n-void\n-_obstack_newchunk (h, length)\n-     struct obstack *h;\n-     int length;\n-{\n-  register struct _obstack_chunk *old_chunk = h->chunk;\n-  register struct _obstack_chunk *new_chunk;\n-  register long\tnew_size;\n-  register long obj_size = h->next_free - h->object_base;\n-  register long i;\n-  long already;\n-\n-  /* Compute size for new chunk.  */\n-  new_size = (obj_size + length) + (obj_size >> 3) + 100;\n-  if (new_size < h->chunk_size)\n-    new_size = h->chunk_size;\n-\n-  /* Allocate and initialize the new chunk.  */\n-  new_chunk = CALL_CHUNKFUN (h, new_size);\n-  if (!new_chunk)\n-    (*obstack_alloc_failed_handler) ();\n-  h->chunk = new_chunk;\n-  new_chunk->prev = old_chunk;\n-  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n-\n-  /* Move the existing object to the new chunk.\n-     Word at a time is fast and is safe if the object\n-     is sufficiently aligned.  */\n-  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)\n-    {\n-      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\n-\t   i >= 0; i--)\n-\t((COPYING_UNIT *)new_chunk->contents)[i]\n-\t  = ((COPYING_UNIT *)h->object_base)[i];\n-      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\n-\t but that can cross a page boundary on a machine\n-\t which does not do strict alignment for COPYING_UNITS.  */\n-      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);\n-    }\n-  else\n-    already = 0;\n-  /* Copy remaining bytes one by one.  */\n-  for (i = already; i < obj_size; i++)\n-    new_chunk->contents[i] = h->object_base[i];\n-\n-  /* If the object just copied was the only data in OLD_CHUNK,\n-     free that chunk and remove it from the chain.\n-     But not if that chunk might contain an empty object.  */\n-  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)\n-    {\n-      new_chunk->prev = old_chunk->prev;\n-      CALL_FREEFUN (h, old_chunk);\n-    }\n-\n-  h->object_base = new_chunk->contents;\n-  h->next_free = h->object_base + obj_size;\n-  /* The new chunk certainly contains no empty object yet.  */\n-  h->maybe_empty_object = 0;\n-}\n-\n-/* Return nonzero if object OBJ has been allocated from obstack H.\n-   This is here for debugging.\n-   If you use it in a program, you are probably losing.  */\n-\n-#if defined (__STDC__) && __STDC__\n-/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in\n-   obstack.h because it is just for debugging.  */\n-int _obstack_allocated_p (struct obstack *h, POINTER obj);\n-#endif\n-\n-int\n-_obstack_allocated_p (h, obj)\n-     struct obstack *h;\n-     POINTER obj;\n-{\n-  register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n-  register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n-\n-  lp = (h)->chunk;\n-  /* We use >= rather than > since the object cannot be exactly at\n-     the beginning of the chunk but might be an empty object exactly\n-     at the end of an adjacent chunk.  */\n-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))\n-    {\n-      plp = lp->prev;\n-      lp = plp;\n-    }\n-  return lp != 0;\n-}\n-\f\n-/* Free objects in obstack H, including OBJ and everything allocate\n-   more recently than OBJ.  If OBJ is zero, free everything in H.  */\n-\n-#undef obstack_free\n-\n-/* This function has two names with identical definitions.\n-   This is the first one, called from non-ANSI code.  */\n-\n-void\n-_obstack_free (h, obj)\n-     struct obstack *h;\n-     POINTER obj;\n-{\n-  register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n-  register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n-\n-  lp = h->chunk;\n-  /* We use >= because there cannot be an object at the beginning of a chunk.\n-     But there can be an empty object at that address\n-     at the end of another chunk.  */\n-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))\n-    {\n-      plp = lp->prev;\n-      CALL_FREEFUN (h, lp);\n-      lp = plp;\n-      /* If we switch chunks, we can't tell whether the new current\n-\t chunk contains an empty object, so assume that it may.  */\n-      h->maybe_empty_object = 1;\n-    }\n-  if (lp)\n-    {\n-      h->object_base = h->next_free = (char *) (obj);\n-      h->chunk_limit = lp->limit;\n-      h->chunk = lp;\n-    }\n-  else if (obj != 0)\n-    /* obj is not in any of the chunks! */\n-    abort ();\n-}\n-\n-/* This function is used from ANSI code.  */\n-\n-void\n-obstack_free (h, obj)\n-     struct obstack *h;\n-     POINTER obj;\n-{\n-  register struct _obstack_chunk *lp;\t/* below addr of any objects in this chunk */\n-  register struct _obstack_chunk *plp;\t/* point to previous chunk if any */\n-\n-  lp = h->chunk;\n-  /* We use >= because there cannot be an object at the beginning of a chunk.\n-     But there can be an empty object at that address\n-     at the end of another chunk.  */\n-  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))\n-    {\n-      plp = lp->prev;\n-      CALL_FREEFUN (h, lp);\n-      lp = plp;\n-      /* If we switch chunks, we can't tell whether the new current\n-\t chunk contains an empty object, so assume that it may.  */\n-      h->maybe_empty_object = 1;\n-    }\n-  if (lp)\n-    {\n-      h->object_base = h->next_free = (char *) (obj);\n-      h->chunk_limit = lp->limit;\n-      h->chunk = lp;\n-    }\n-  else if (obj != 0)\n-    /* obj is not in any of the chunks! */\n-    abort ();\n-}\n-\f\n-int\n-_obstack_memory_used (h)\n-     struct obstack *h;\n-{\n-  register struct _obstack_chunk* lp;\n-  register int nbytes = 0;\n-\n-  for (lp = h->chunk; lp != 0; lp = lp->prev)\n-    {\n-      nbytes += lp->limit - (char *) lp;\n-    }\n-  return nbytes;\n-}\n-\f\n-/* Define the error handler.  */\n-#ifndef _\n-# ifdef HAVE_LIBINTL_H\n-#  include <libintl.h>\n-#  ifndef _\n-#   define _(Str) gettext (Str)\n-#  endif\n-# else\n-#  define _(Str) (Str)\n-# endif\n-#endif\n-\n-static void\n-print_and_abort ()\n-{\n-  fputs (_(\"memory exhausted\\n\"), stderr);\n-  exit (obstack_exit_failure);\n-}\n-\f\n-#if 0\n-/* These are now turned off because the applications do not use it\n-   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */\n-\n-/* Now define the functional versions of the obstack macros.\n-   Define them to simply use the corresponding macros to do the job.  */\n-\n-#if defined (__STDC__) && __STDC__\n-/* These function definitions do not work with non-ANSI preprocessors;\n-   they won't pass through the macro names in parentheses.  */\n-\n-/* The function names appear in parentheses in order to prevent\n-   the macro-definitions of the names from being expanded there.  */\n-\n-POINTER (obstack_base) (obstack)\n-     struct obstack *obstack;\n-{\n-  return obstack_base (obstack);\n-}\n-\n-POINTER (obstack_next_free) (obstack)\n-     struct obstack *obstack;\n-{\n-  return obstack_next_free (obstack);\n-}\n-\n-int (obstack_object_size) (obstack)\n-     struct obstack *obstack;\n-{\n-  return obstack_object_size (obstack);\n-}\n-\n-int (obstack_room) (obstack)\n-     struct obstack *obstack;\n-{\n-  return obstack_room (obstack);\n-}\n-\n-int (obstack_make_room) (obstack, length)\n-     struct obstack *obstack;\n-     int length;\n-{\n-  return obstack_make_room (obstack, length);\n-}\n-\n-void (obstack_grow) (obstack, pointer, length)\n-     struct obstack *obstack;\n-     POINTER pointer;\n-     int length;\n-{\n-  obstack_grow (obstack, pointer, length);\n-}\n-\n-void (obstack_grow0) (obstack, pointer, length)\n-     struct obstack *obstack;\n-     POINTER pointer;\n-     int length;\n-{\n-  obstack_grow0 (obstack, pointer, length);\n-}\n-\n-void (obstack_1grow) (obstack, character)\n-     struct obstack *obstack;\n-     int character;\n-{\n-  obstack_1grow (obstack, character);\n-}\n-\n-void (obstack_blank) (obstack, length)\n-     struct obstack *obstack;\n-     int length;\n-{\n-  obstack_blank (obstack, length);\n-}\n-\n-void (obstack_1grow_fast) (obstack, character)\n-     struct obstack *obstack;\n-     int character;\n-{\n-  obstack_1grow_fast (obstack, character);\n-}\n-\n-void (obstack_blank_fast) (obstack, length)\n-     struct obstack *obstack;\n-     int length;\n-{\n-  obstack_blank_fast (obstack, length);\n-}\n-\n-POINTER (obstack_finish) (obstack)\n-     struct obstack *obstack;\n-{\n-  return obstack_finish (obstack);\n-}\n-\n-POINTER (obstack_alloc) (obstack, length)\n-     struct obstack *obstack;\n-     int length;\n-{\n-  return obstack_alloc (obstack, length);\n-}\n-\n-POINTER (obstack_copy) (obstack, pointer, length)\n-     struct obstack *obstack;\n-     POINTER pointer;\n-     int length;\n-{\n-  return obstack_copy (obstack, pointer, length);\n-}\n-\n-POINTER (obstack_copy0) (obstack, pointer, length)\n-     struct obstack *obstack;\n-     POINTER pointer;\n-     int length;\n-{\n-  return obstack_copy0 (obstack, pointer, length);\n-}\n-\n-#endif /* __STDC__ */\n-\n-#endif /* 0 */\n-\n-#endif\t/* !ELIDE_CODE */"}, {"sha": "38e96777660d5bbdafa108ae60def43e5221b750", "filename": "gcc/obstack.h", "status": "removed", "additions": 0, "deletions": 593, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e/gcc%2Fobstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e/gcc%2Fobstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobstack.h?ref=7520c31b2d4c43e9ae93a9f9fbd6aaed5f4ce96e", "patch": "@@ -1,593 +0,0 @@\n-/* obstack.h - object stack macros\n-   Copyright (C) 1988,89,90,91,92,93,94,96,97,98 Free Software Foundation, Inc.\n-\n-\n-   NOTE: The canonical source of this file is maintained with the GNU C Library.\n-   Bugs can be reported to bug-glibc@gnu.org.\n-\n-   This program is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by the\n-   Free Software Foundation; either version 2, or (at your option) any\n-   later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-   USA.  */\n-\n-/* Summary:\n-\n-All the apparent functions defined here are macros. The idea\n-is that you would use these pre-tested macros to solve a\n-very specific set of problems, and they would run fast.\n-Caution: no side-effects in arguments please!! They may be\n-evaluated MANY times!!\n-\n-These macros operate a stack of objects.  Each object starts life\n-small, and may grow to maturity.  (Consider building a word syllable\n-by syllable.)  An object can move while it is growing.  Once it has\n-been \"finished\" it never changes address again.  So the \"top of the\n-stack\" is typically an immature growing object, while the rest of the\n-stack is of mature, fixed size and fixed address objects.\n-\n-These routines grab large chunks of memory, using a function you\n-supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,\n-by calling `obstack_chunk_free'.  You must define them and declare\n-them before using any obstack macros.\n-\n-Each independent stack is represented by a `struct obstack'.\n-Each of the obstack macros expects a pointer to such a structure\n-as the first argument.\n-\n-One motivation for this package is the problem of growing char strings\n-in symbol tables.  Unless you are \"fascist pig with a read-only mind\"\n---Gosper's immortal quote from HAKMEM item 154, out of context--you\n-would not like to put any arbitrary upper limit on the length of your\n-symbols.\n-\n-In practice this often means you will build many short symbols and a\n-few long symbols.  At the time you are reading a symbol you don't know\n-how long it is.  One traditional method is to read a symbol into a\n-buffer, realloc()ating the buffer every time you try to read a symbol\n-that is longer than the buffer.  This is beaut, but you still will\n-want to copy the symbol from the buffer to a more permanent\n-symbol-table entry say about half the time.\n-\n-With obstacks, you can work differently.  Use one obstack for all symbol\n-names.  As you read a symbol, grow the name in the obstack gradually.\n-When the name is complete, finalize it.  Then, if the symbol exists already,\n-free the newly read name.\n-\n-The way we do this is to take a large chunk, allocating memory from\n-low addresses.  When you want to build a symbol in the chunk you just\n-add chars above the current \"high water mark\" in the chunk.  When you\n-have finished adding chars, because you got to the end of the symbol,\n-you know how long the chars are, and you can create a new object.\n-Mostly the chars will not burst over the highest address of the chunk,\n-because you would typically expect a chunk to be (say) 100 times as\n-long as an average object.\n-\n-In case that isn't clear, when we have enough chars to make up\n-the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)\n-so we just point to it where it lies.  No moving of chars is\n-needed and this is the second win: potentially long strings need\n-never be explicitly shuffled. Once an object is formed, it does not\n-change its address during its lifetime.\n-\n-When the chars burst over a chunk boundary, we allocate a larger\n-chunk, and then copy the partly formed object from the end of the old\n-chunk to the beginning of the new larger chunk.  We then carry on\n-accreting characters to the end of the object as we normally would.\n-\n-A special macro is provided to add a single char at a time to a\n-growing object.  This allows the use of register variables, which\n-break the ordinary 'growth' macro.\n-\n-Summary:\n-\tWe allocate large chunks.\n-\tWe carve out one object at a time from the current chunk.\n-\tOnce carved, an object never moves.\n-\tWe are free to append data of any size to the currently\n-\t  growing object.\n-\tExactly one object is growing in an obstack at any one time.\n-\tYou can run one obstack per control block.\n-\tYou may have as many control blocks as you dare.\n-\tBecause of the way we do it, you can `unwind' an obstack\n-\t  back to a previous state. (You may remove objects much\n-\t  as you would with a stack.)\n-*/\n-\n-\n-/* Don't do the contents of this file more than once.  */\n-\n-#ifndef _OBSTACK_H\n-#define _OBSTACK_H 1\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\f\n-/* We use subtraction of (char *) 0 instead of casting to int\n-   because on word-addressable machines a simple cast to int\n-   may ignore the byte-within-word field of the pointer.  */\n-\n-#ifndef __PTR_TO_INT\n-# define __PTR_TO_INT(P) ((P) - (char *) 0)\n-#endif\n-\n-#ifndef __INT_TO_PTR\n-# define __INT_TO_PTR(P) ((P) + (char *) 0)\n-#endif\n-\n-/* We need the type of the resulting object.  If __PTRDIFF_TYPE__ is\n-   defined, as with GNU C, use that; that way we don't pollute the\n-   namespace with <stddef.h>'s symbols.  Otherwise, if <stddef.h> is\n-   available, include it and use ptrdiff_t.  In traditional C, long is\n-   the best that we can do.  */\n-\n-#ifdef __PTRDIFF_TYPE__\n-# define PTR_INT_TYPE __PTRDIFF_TYPE__\n-#else\n-# ifdef HAVE_STDDEF_H\n-#  include <stddef.h>\n-#  define PTR_INT_TYPE ptrdiff_t\n-# else\n-#  define PTR_INT_TYPE long\n-# endif\n-#endif\n-\n-#if defined _LIBC || defined HAVE_STRING_H\n-# include <string.h>\n-# define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n-#else\n-# ifdef memcpy\n-#  define _obstack_memcpy(To, From, N) memcpy ((To), (From), (N))\n-# else\n-#  define _obstack_memcpy(To, From, N) bcopy ((From), (To), (N))\n-# endif\n-#endif\n-\n-struct _obstack_chunk\t\t/* Lives at front of each chunk. */\n-{\n-  char  *limit;\t\t\t/* 1 past end of this chunk */\n-  struct _obstack_chunk *prev;\t/* address of prior chunk or NULL */\n-  char\tcontents[4];\t\t/* objects begin here */\n-};\n-\n-struct obstack\t\t/* control current object in current chunk */\n-{\n-  long\tchunk_size;\t\t/* preferred size to allocate chunks in */\n-  struct _obstack_chunk *chunk;\t/* address of current struct obstack_chunk */\n-  char\t*object_base;\t\t/* address of object we are building */\n-  char\t*next_free;\t\t/* where to add next char to current object */\n-  char\t*chunk_limit;\t\t/* address of char after current chunk */\n-  PTR_INT_TYPE temp;\t\t/* Temporary for some macros.  */\n-  int   alignment_mask;\t\t/* Mask of alignment for each object. */\n-#if defined __STDC__ && __STDC__\n-  /* These prototypes vary based on `use_extra_arg', and we use\n-     casts to the prototypeless function type in all assignments,\n-     but having prototypes here quiets -Wstrict-prototypes.  */\n-  struct _obstack_chunk *(*chunkfun) (void *, long);\n-  void (*freefun) (void *, struct _obstack_chunk *);\n-  void *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n-#else\n-  struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */\n-  void (*freefun) ();\t\t/* User's function to free a chunk.  */\n-  char *extra_arg;\t\t/* first arg for chunk alloc/dealloc funcs */\n-#endif\n-  unsigned use_extra_arg:1;\t/* chunk alloc/dealloc funcs take extra arg */\n-  unsigned maybe_empty_object:1;/* There is a possibility that the current\n-\t\t\t\t   chunk contains a zero-length object.  This\n-\t\t\t\t   prevents freeing the chunk if we allocate\n-\t\t\t\t   a bigger chunk to replace it. */\n-  unsigned alloc_failed:1;\t/* No longer used, as we now call the failed\n-\t\t\t\t   handler on error, but retained for binary\n-\t\t\t\t   compatibility.  */\n-};\n-\n-/* Declare the external functions we use; they are in obstack.c.  */\n-\n-#if defined __STDC__ && __STDC__\n-extern void _obstack_newchunk (struct obstack *, int);\n-extern void _obstack_free (struct obstack *, void *);\n-extern int _obstack_begin (struct obstack *, int, int,\n-\t\t\t    void *(*) (long), void (*) (void *));\n-extern int _obstack_begin_1 (struct obstack *, int, int,\n-\t\t\t     void *(*) (void *, long),\n-\t\t\t     void (*) (void *, void *), void *);\n-extern int _obstack_memory_used (struct obstack *);\n-#else\n-extern void _obstack_newchunk ();\n-extern void _obstack_free ();\n-extern int _obstack_begin ();\n-extern int _obstack_begin_1 ();\n-extern int _obstack_memory_used ();\n-#endif\n-\f\n-#if defined __STDC__ && __STDC__\n-\n-/* Do the function-declarations after the structs\n-   but before defining the macros.  */\n-\n-void obstack_init (struct obstack *obstack);\n-\n-void * obstack_alloc (struct obstack *obstack, int size);\n-\n-void * obstack_copy (struct obstack *obstack, void *address, int size);\n-void * obstack_copy0 (struct obstack *obstack, void *address, int size);\n-\n-void obstack_free (struct obstack *obstack, void *block);\n-\n-void obstack_blank (struct obstack *obstack, int size);\n-\n-void obstack_grow (struct obstack *obstack, void *data, int size);\n-void obstack_grow0 (struct obstack *obstack, void *data, int size);\n-\n-void obstack_1grow (struct obstack *obstack, int data_char);\n-void obstack_ptr_grow (struct obstack *obstack, void *data);\n-void obstack_int_grow (struct obstack *obstack, int data);\n-\n-void * obstack_finish (struct obstack *obstack);\n-\n-int obstack_object_size (struct obstack *obstack);\n-\n-int obstack_room (struct obstack *obstack);\n-void obstack_make_room (struct obstack *obstack, int size);\n-void obstack_1grow_fast (struct obstack *obstack, int data_char);\n-void obstack_ptr_grow_fast (struct obstack *obstack, void *data);\n-void obstack_int_grow_fast (struct obstack *obstack, int data);\n-void obstack_blank_fast (struct obstack *obstack, int size);\n-\n-void * obstack_base (struct obstack *obstack);\n-void * obstack_next_free (struct obstack *obstack);\n-int obstack_alignment_mask (struct obstack *obstack);\n-int obstack_chunk_size (struct obstack *obstack);\n-int obstack_memory_used (struct obstack *obstack);\n-\n-#endif /* __STDC__ */\n-\n-/* Non-ANSI C cannot really support alternative functions for these macros,\n-   so we do not declare them.  */\n-\n-/* Error handler called when `obstack_chunk_alloc' failed to allocate\n-   more memory.  This can be set to a user defined function.  The\n-   default action is to print a message and abort.  */\n-#if defined __STDC__ && __STDC__\n-extern void (*obstack_alloc_failed_handler) (void);\n-#else\n-extern void (*obstack_alloc_failed_handler) ();\n-#endif\n-\n-/* Exit value used when `print_and_abort' is used.  */\n-extern int obstack_exit_failure;\n-\f\n-/* Pointer to beginning of object being allocated or to be allocated next.\n-   Note that this might not be the final address of the object\n-   because a new chunk might be needed to hold the final size.  */\n-\n-#define obstack_base(h) ((h)->object_base)\n-\n-/* Size for allocating ordinary chunks.  */\n-\n-#define obstack_chunk_size(h) ((h)->chunk_size)\n-\n-/* Pointer to next byte not yet allocated in current chunk.  */\n-\n-#define obstack_next_free(h)\t((h)->next_free)\n-\n-/* Mask specifying low bits that should be clear in address of an object.  */\n-\n-#define obstack_alignment_mask(h) ((h)->alignment_mask)\n-\n-/* To prevent prototype warnings provide complete argument list in\n-   standard C version.  */\n-#if defined __STDC__ && __STDC__\n-\n-# define obstack_init(h) \\\n-  _obstack_begin ((h), 0, 0, \\\n-\t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n-\n-# define obstack_begin(h, size) \\\n-  _obstack_begin ((h), (size), 0, \\\n-\t\t  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)\n-\n-# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n-  _obstack_begin ((h), (size), (alignment), \\\n-\t\t    (void *(*) (long)) (chunkfun), (void (*) (void *)) (freefun))\n-\n-# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n-  _obstack_begin_1 ((h), (size), (alignment), \\\n-\t\t    (void *(*) (void *, long)) (chunkfun), \\\n-\t\t    (void (*) (void *, void *)) (freefun), (arg))\n-\n-# define obstack_chunkfun(h, newchunkfun) \\\n-  ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))\n-\n-# define obstack_freefun(h, newfreefun) \\\n-  ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))\n-\n-#else\n-\n-# define obstack_init(h) \\\n-  _obstack_begin ((h), 0, 0, \\\n-\t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n-\n-# define obstack_begin(h, size) \\\n-  _obstack_begin ((h), (size), 0, \\\n-\t\t  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)\n-\n-# define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \\\n-  _obstack_begin ((h), (size), (alignment), \\\n-\t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))\n-\n-# define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \\\n-  _obstack_begin_1 ((h), (size), (alignment), \\\n-\t\t    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))\n-\n-# define obstack_chunkfun(h, newchunkfun) \\\n-  ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))\n-\n-# define obstack_freefun(h, newfreefun) \\\n-  ((h) -> freefun = (void (*)()) (newfreefun))\n-\n-#endif\n-\n-#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = achar)\n-\n-#define obstack_blank_fast(h,n) ((h)->next_free += (n))\n-\n-#define obstack_memory_used(h) _obstack_memory_used (h)\n-\f\n-#if defined __GNUC__ && defined __STDC__ && __STDC__\n-/* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and\n-   does not implement __extension__.  But that compiler doesn't define\n-   __GNUC_MINOR__.  */\n-# if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)\n-#  define __extension__\n-# endif\n-\n-/* For GNU C, if not -traditional,\n-   we can define these macros to compute all args only once\n-   without using a global variable.\n-   Also, we can avoid using the `temp' slot, to make faster code.  */\n-\n-# define obstack_object_size(OBSTACK)\t\t\t\t\t\\\n-  __extension__\t\t\t\t\t\t\t\t\\\n-  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-     (unsigned) (__o->next_free - __o->object_base); })\n-\n-# define obstack_room(OBSTACK)\t\t\t\t\t\t\\\n-  __extension__\t\t\t\t\t\t\t\t\\\n-  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-     (unsigned) (__o->chunk_limit - __o->next_free); })\n-\n-# define obstack_make_room(OBSTACK,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   int __len = (length);\t\t\t\t\t\t\\\n-   if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n-     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_empty_p(OBSTACK)\t\t\t\t\t\\\n-  __extension__\t\t\t\t\t\t\t\t\\\n-  ({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-     (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })\n-\n-# define obstack_grow(OBSTACK,where,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   int __len = (length);\t\t\t\t\t\t\\\n-   if (__o->next_free + __len > __o->chunk_limit)\t\t\t\\\n-     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n-   _obstack_memcpy (__o->next_free, (char *) (where), __len);\t\t\\\n-   __o->next_free += __len;\t\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_grow0(OBSTACK,where,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   int __len = (length);\t\t\t\t\t\t\\\n-   if (__o->next_free + __len + 1 > __o->chunk_limit)\t\t\t\\\n-     _obstack_newchunk (__o, __len + 1);\t\t\t\t\\\n-   _obstack_memcpy (__o->next_free, (char *) (where), __len);\t\t\\\n-   __o->next_free += __len;\t\t\t\t\t\t\\\n-   *(__o->next_free)++ = 0;\t\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_1grow(OBSTACK,datum)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   if (__o->next_free + 1 > __o->chunk_limit)\t\t\t\t\\\n-     _obstack_newchunk (__o, 1);\t\t\t\t\t\\\n-   *(__o->next_free)++ = (datum);\t\t\t\t\t\\\n-   (void) 0; })\n-\n-/* These assume that the obstack alignment is good enough for pointers or ints,\n-   and that the data added so far to the current object\n-   shares that much alignment.  */\n-\n-# define obstack_ptr_grow(OBSTACK,datum)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   if (__o->next_free + sizeof (void *) > __o->chunk_limit)\t\t\\\n-     _obstack_newchunk (__o, sizeof (void *));\t\t\t\t\\\n-   *((void **)__o->next_free)++ = ((void *)datum);\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_int_grow(OBSTACK,datum)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   if (__o->next_free + sizeof (int) > __o->chunk_limit)\t\t\\\n-     _obstack_newchunk (__o, sizeof (int));\t\t\t\t\\\n-   *((int *)__o->next_free)++ = ((int)datum);\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_ptr_grow_fast(h,aptr) (*((void **) (h)->next_free)++ = (void *)aptr)\n-# define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)\n-\n-# define obstack_blank(OBSTACK,length)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   int __len = (length);\t\t\t\t\t\t\\\n-   if (__o->chunk_limit - __o->next_free < __len)\t\t\t\\\n-     _obstack_newchunk (__o, __len);\t\t\t\t\t\\\n-   __o->next_free += __len;\t\t\t\t\t\t\\\n-   (void) 0; })\n-\n-# define obstack_alloc(OBSTACK,length)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n-   obstack_blank (__h, (length));\t\t\t\t\t\\\n-   obstack_finish (__h); })\n-\n-# define obstack_copy(OBSTACK,where,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n-   obstack_grow (__h, (where), (length));\t\t\t\t\\\n-   obstack_finish (__h); })\n-\n-# define obstack_copy0(OBSTACK,where,length)\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__h = (OBSTACK);\t\t\t\t\t\\\n-   obstack_grow0 (__h, (where), (length));\t\t\t\t\\\n-   obstack_finish (__h); })\n-\n-/* The local variable is named __o1 to avoid a name conflict\n-   when obstack_blank is called.  */\n-# define obstack_finish(OBSTACK)  \t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o1 = (OBSTACK);\t\t\t\t\t\\\n-   void *value;\t\t\t\t\t\t\t\t\\\n-   value = (void *) __o1->object_base;\t\t\t\t\t\\\n-   if (__o1->next_free == value)\t\t\t\t\t\\\n-     __o1->maybe_empty_object = 1;\t\t\t\t\t\\\n-   __o1->next_free\t\t\t\t\t\t\t\\\n-     = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\\\n-\t\t     & ~ (__o1->alignment_mask));\t\t\t\\\n-   if (__o1->next_free - (char *)__o1->chunk\t\t\t\t\\\n-       > __o1->chunk_limit - (char *)__o1->chunk)\t\t\t\\\n-     __o1->next_free = __o1->chunk_limit;\t\t\t\t\\\n-   __o1->object_base = __o1->next_free;\t\t\t\t\t\\\n-   value; })\n-\n-# define obstack_free(OBSTACK, OBJ)\t\t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-({ struct obstack *__o = (OBSTACK);\t\t\t\t\t\\\n-   void *__obj = (OBJ);\t\t\t\t\t\t\t\\\n-   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \\\n-     __o->next_free = __o->object_base = __obj;\t\t\t\t\\\n-   else (obstack_free) (__o, __obj); })\n-\f\n-#else /* not __GNUC__ or not __STDC__ */\n-\n-# define obstack_object_size(h) \\\n- (unsigned) ((h)->next_free - (h)->object_base)\n-\n-# define obstack_room(h)\t\t\\\n- (unsigned) ((h)->chunk_limit - (h)->next_free)\n-\n-# define obstack_empty_p(h) \\\n- ((h)->chunk->prev == 0 && (h)->next_free - (h)->chunk->contents == 0)\n-\n-/* Note that the call to _obstack_newchunk is enclosed in (..., 0)\n-   so that we can avoid having void expressions\n-   in the arms of the conditional expression.\n-   Casting the third operand to void was tried before,\n-   but some compilers won't accept it.  */\n-\n-# define obstack_make_room(h,length)\t\t\t\t\t\\\n-( (h)->temp = (length),\t\t\t\t\t\t\t\\\n-  (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0))\n-\n-# define obstack_grow(h,where,length)\t\t\t\t\t\\\n-( (h)->temp = (length),\t\t\t\t\t\t\t\\\n-  (((h)->next_free + (h)->temp > (h)->chunk_limit)\t\t\t\\\n-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n-  _obstack_memcpy ((h)->next_free, (char *) (where), (h)->temp),\t\\\n-  (h)->next_free += (h)->temp)\n-\n-# define obstack_grow0(h,where,length)\t\t\t\t\t\\\n-( (h)->temp = (length),\t\t\t\t\t\t\t\\\n-  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)\t\t\t\\\n-   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),\t\t\t\\\n-  _obstack_memcpy ((h)->next_free, (char *) (where), (h)->temp),\t\\\n-  (h)->next_free += (h)->temp,\t\t\t\t\t\t\\\n-  *((h)->next_free)++ = 0)\n-\n-# define obstack_1grow(h,datum)\t\t\t\t\t\t\\\n-( (((h)->next_free + 1 > (h)->chunk_limit)\t\t\t\t\\\n-   ? (_obstack_newchunk ((h), 1), 0) : 0),\t\t\t\t\\\n-  (*((h)->next_free)++ = (datum)))\n-\n-# define obstack_ptr_grow(h,datum)\t\t\t\t\t\\\n-( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)\t\t\\\n-   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),\t\t\\\n-  (*((char **) (((h)->next_free+=sizeof(char *))-sizeof(char *))) = ((char *) datum)))\n-\n-# define obstack_int_grow(h,datum)\t\t\t\t\t\\\n-( (((h)->next_free + sizeof (int) > (h)->chunk_limit)\t\t\t\\\n-   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),\t\t\t\\\n-  (*((int *) (((h)->next_free+=sizeof(int))-sizeof(int))) = ((int) datum)))\n-\n-# define obstack_ptr_grow_fast(h,aptr) (*((char **) (h)->next_free)++ = (char *) aptr)\n-# define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)\n-\n-# define obstack_blank(h,length)\t\t\t\t\t\\\n-( (h)->temp = (length),\t\t\t\t\t\t\t\\\n-  (((h)->chunk_limit - (h)->next_free < (h)->temp)\t\t\t\\\n-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),\t\t\t\\\n-  ((h)->next_free += (h)->temp))\n-\n-# define obstack_alloc(h,length)\t\t\t\t\t\\\n- (obstack_blank ((h), (length)), obstack_finish ((h)))\n-\n-# define obstack_copy(h,where,length)\t\t\t\t\t\\\n- (obstack_grow ((h), (where), (length)), obstack_finish ((h)))\n-\n-# define obstack_copy0(h,where,length)\t\t\t\t\t\\\n- (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))\n-\n-# define obstack_finish(h)  \t\t\t\t\t\t\\\n-( ((h)->next_free == (h)->object_base\t\t\t\t\t\\\n-   ? (((h)->maybe_empty_object = 1), 0)\t\t\t\t\t\\\n-   : 0),\t\t\t\t\t\t\t\t\\\n-  (h)->temp = __PTR_TO_INT ((h)->object_base),\t\t\t\t\\\n-  (h)->next_free\t\t\t\t\t\t\t\\\n-    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)\t\\\n-\t\t    & ~ ((h)->alignment_mask)),\t\t\t\t\\\n-  (((h)->next_free - (char *) (h)->chunk\t\t\t\t\\\n-    > (h)->chunk_limit - (char *) (h)->chunk)\t\t\t\t\\\n-   ? ((h)->next_free = (h)->chunk_limit) : 0),\t\t\t\t\\\n-  (h)->object_base = (h)->next_free,\t\t\t\t\t\\\n-  __INT_TO_PTR ((h)->temp))\n-\n-# if defined __STDC__ && __STDC__\n-#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n-( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n-  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n-   ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n-\t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n-   : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))\n-# else\n-#  define obstack_free(h,obj)\t\t\t\t\t\t\\\n-( (h)->temp = (char *) (obj) - (char *) (h)->chunk,\t\t\t\\\n-  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\\\n-   ? (int) ((h)->next_free = (h)->object_base\t\t\t\t\\\n-\t    = (h)->temp + (char *) (h)->chunk)\t\t\t\t\\\n-   : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))\n-# endif\n-\n-#endif /* not __GNUC__ or not __STDC__ */\n-\n-#ifdef __cplusplus\n-}\t/* C++ */\n-#endif\n-\n-#endif /* obstack.h */"}]}