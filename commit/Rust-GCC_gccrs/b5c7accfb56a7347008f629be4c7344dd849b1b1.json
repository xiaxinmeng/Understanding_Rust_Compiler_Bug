{"sha": "b5c7accfb56a7347008f629be4c7344dd849b1b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjN2FjY2ZiNTZhNzM0NzAwOGY2MjliZTRjNzM0NGRkODQ5YjFiMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-03-31T18:34:01Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-03-31T18:34:01Z"}, "message": "data-ref: Tighten index-based alias checks [PR99726]\n\ncreate_intersect_range_checks_index tries to create a runtime\nalias check based on index comparisons.  It looks through the\naccess functions for the two DRs to find a SCEV for the loop\nthat is being versioned and converts a DR_STEP-based check\ninto an index-based check.\n\nHowever, there isn't any reliable sign information in the types,\nso the code expects the value of the IV step (when interpreted as\nsigned) to be negative iff the DR_STEP (when interpreted as signed)\nis negative.\n\nr10-4762 added another assert related to this assumption and the\nassert fired for the testcase in the PR.  The sign of the IV step\ndidn't match the sign of the DR_STEP.\n\nI think this is actually showing what was previously a wrong-code bug.\nThe signs didn't match because the DRs contained *two* access function\nSCEVs for the loop being versioned.  It doesn't look like the code\nis set up to deal with this, since it checks each access function\nindependently and treats it as the sole source of DR_STEP.\n\nThe patch therefore moves the main condition out of the loop.\nThis also has the advantage of not building a tree for one access\nfunction only to throw it away if we find an inner function that\nmakes the comparison invalid.\n\ngcc/\n\tPR tree-optimization/99726\n\t* tree-data-ref.c (create_intersect_range_checks_index): Bail\n\tout if there is more than one access function SCEV for the loop\n\tbeing versioned.\n\ngcc/testsuite/\n\tPR tree-optimization/99726\n\t* gcc.target/i386/pr99726.c: New test.", "tree": {"sha": "42b4abf64ffc6a6b91ca569794bfdd1f7b0b83dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42b4abf64ffc6a6b91ca569794bfdd1f7b0b83dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5c7accfb56a7347008f629be4c7344dd849b1b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c7accfb56a7347008f629be4c7344dd849b1b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c7accfb56a7347008f629be4c7344dd849b1b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c7accfb56a7347008f629be4c7344dd849b1b1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b5f74e8be4dd7abe5624ff60adceff19ca71bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5f74e8be4dd7abe5624ff60adceff19ca71bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b5f74e8be4dd7abe5624ff60adceff19ca71bda"}], "stats": {"total": 260, "additions": 143, "deletions": 117}, "files": [{"sha": "ff19bcabe4fe7f71c944be6eaa4dff247a3df48e", "filename": "gcc/testsuite/gcc.target/i386/pr99726.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c7accfb56a7347008f629be4c7344dd849b1b1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr99726.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c7accfb56a7347008f629be4c7344dd849b1b1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr99726.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr99726.c?ref=b5c7accfb56a7347008f629be4c7344dd849b1b1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-flive-patching=inline-clone -mavx512f -O2 -floop-nest-optimize -ftree-loop-vectorize -ftrapv -m32\" } */\n+\n+extern int a[256][1024];\n+int b;\n+long c, d;\n+unsigned int e;\n+\n+int\n+main ()\n+{\n+  for (; e < d; e++)\n+    for (unsigned j = 1; j < c; j++)\n+      a[e][j] = b * a[e - 1][j + 1];\n+  return 0;\n+}"}, {"sha": "e6dd5f15bedebf7d53954e8e8925a94b26102bea", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 128, "deletions": 117, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c7accfb56a7347008f629be4c7344dd849b1b1/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c7accfb56a7347008f629be4c7344dd849b1b1/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=b5c7accfb56a7347008f629be4c7344dd849b1b1", "patch": "@@ -2147,8 +2147,8 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n \n   bool waw_or_war_p = (alias_pair.flags & ~(DR_ALIAS_WAR | DR_ALIAS_WAW)) == 0;\n \n-  unsigned int i;\n-  for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n+  int found = -1;\n+  for (unsigned int i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n     {\n       tree access1 = DR_ACCESS_FN (dr_a.dr, i);\n       tree access2 = DR_ACCESS_FN (dr_b.dr, i);\n@@ -2164,155 +2164,166 @@ create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n \n \t  return false;\n \t}\n-      /* The two indices must have the same step.  */\n-      if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))\n+      if (found >= 0)\n \treturn false;\n+      found = i;\n+    }\n \n-      tree idx_step = CHREC_RIGHT (access1);\n-      /* Index must have const step, otherwise DR_STEP won't be constant.  */\n-      gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);\n-      /* Index must evaluate in the same direction as DR.  */\n-      gcc_assert (!neg_step || tree_int_cst_sign_bit (idx_step) == 1);\n+  /* Ought not to happen in practice, since if all accesses are equal then the\n+     alias should be decidable at compile time.  */\n+  if (found < 0)\n+    return false;\n \n-      tree min1 = CHREC_LEFT (access1);\n-      tree min2 = CHREC_LEFT (access2);\n-      if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))\n-\treturn false;\n+  /* The two indices must have the same step.  */\n+  tree access1 = DR_ACCESS_FN (dr_a.dr, found);\n+  tree access2 = DR_ACCESS_FN (dr_b.dr, found);\n+  if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))\n+    return false;\n \n-      /* Ideally, alias can be checked against loop's control IV, but we\n-\t need to prove linear mapping between control IV and reference\n-\t index.  Although that should be true, we check against (array)\n-\t index of data reference.  Like segment length, index length is\n-\t linear function of the number of iterations with index_step as\n-\t the coefficient, i.e, niter_len * idx_step.  */\n-      offset_int abs_idx_step = offset_int::from (wi::to_wide (idx_step),\n-\t\t\t\t\t\t  SIGNED);\n-      if (neg_step)\n-\tabs_idx_step = -abs_idx_step;\n-      poly_offset_int idx_len1 = abs_idx_step * niter_len1;\n-      poly_offset_int idx_len2 = abs_idx_step * niter_len2;\n-      poly_offset_int idx_access1 = abs_idx_step * niter_access1;\n-      poly_offset_int idx_access2 = abs_idx_step * niter_access2;\n+  tree idx_step = CHREC_RIGHT (access1);\n+  /* Index must have const step, otherwise DR_STEP won't be constant.  */\n+  gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);\n+  /* Index must evaluate in the same direction as DR.  */\n+  gcc_assert (!neg_step || tree_int_cst_sign_bit (idx_step) == 1);\n \n-      gcc_assert (known_ge (idx_len1, 0)\n-\t\t  && known_ge (idx_len2, 0)\n-\t\t  && known_ge (idx_access1, 0)\n-\t\t  && known_ge (idx_access2, 0));\n+  tree min1 = CHREC_LEFT (access1);\n+  tree min2 = CHREC_LEFT (access2);\n+  if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))\n+    return false;\n \n-      /* Each access has the following pattern, with lengths measured\n-\t in units of INDEX:\n+  /* Ideally, alias can be checked against loop's control IV, but we\n+     need to prove linear mapping between control IV and reference\n+     index.  Although that should be true, we check against (array)\n+     index of data reference.  Like segment length, index length is\n+     linear function of the number of iterations with index_step as\n+     the coefficient, i.e, niter_len * idx_step.  */\n+  offset_int abs_idx_step = offset_int::from (wi::to_wide (idx_step),\n+\t\t\t\t\t      SIGNED);\n+  if (neg_step)\n+    abs_idx_step = -abs_idx_step;\n+  poly_offset_int idx_len1 = abs_idx_step * niter_len1;\n+  poly_offset_int idx_len2 = abs_idx_step * niter_len2;\n+  poly_offset_int idx_access1 = abs_idx_step * niter_access1;\n+  poly_offset_int idx_access2 = abs_idx_step * niter_access2;\n \n-\t      <-- idx_len -->\n-\t      <--- A: -ve step --->\n-\t      +-----+-------+-----+-------+-----+\n-\t      | n-1 | ..... |  0  | ..... | n-1 |\n-\t      +-----+-------+-----+-------+-----+\n-\t\t\t    <--- B: +ve step --->\n-\t\t\t    <-- idx_len -->\n-\t\t\t    |\n-\t\t\t   min\n+  gcc_assert (known_ge (idx_len1, 0)\n+\t      && known_ge (idx_len2, 0)\n+\t      && known_ge (idx_access1, 0)\n+\t      && known_ge (idx_access2, 0));\n \n-\t where \"n\" is the number of scalar iterations covered by the segment\n-\t and where each access spans idx_access units.\n+  /* Each access has the following pattern, with lengths measured\n+     in units of INDEX:\n \n-\t A is the range of bytes accessed when the step is negative,\n-\t B is the range when the step is positive.\n+\t  <-- idx_len -->\n+\t  <--- A: -ve step --->\n+\t  +-----+-------+-----+-------+-----+\n+\t  | n-1 | ..... |  0  | ..... | n-1 |\n+\t  +-----+-------+-----+-------+-----+\n+\t\t\t<--- B: +ve step --->\n+\t\t\t<-- idx_len -->\n+\t\t\t|\n+\t\t       min\n \n-\t When checking for general overlap, we need to test whether\n-\t the range:\n+     where \"n\" is the number of scalar iterations covered by the segment\n+     and where each access spans idx_access units.\n \n-\t   [min1 + low_offset1, min2 + high_offset1 + idx_access1 - 1]\n+     A is the range of bytes accessed when the step is negative,\n+     B is the range when the step is positive.\n \n-\t overlaps:\n+     When checking for general overlap, we need to test whether\n+     the range:\n \n-\t   [min2 + low_offset2, min2 + high_offset2 + idx_access2 - 1]\n+       [min1 + low_offset1, min1 + high_offset1 + idx_access1 - 1]\n \n-\t where:\n+     overlaps:\n+\n+       [min2 + low_offset2, min2 + high_offset2 + idx_access2 - 1]\n \n-\t    low_offsetN = +ve step ? 0 : -idx_lenN;\n-\t   high_offsetN = +ve step ? idx_lenN : 0;\n+     where:\n \n-\t This is equivalent to testing whether:\n+\tlow_offsetN = +ve step ? 0 : -idx_lenN;\n+       high_offsetN = +ve step ? idx_lenN : 0;\n+\n+     This is equivalent to testing whether:\n \n-\t   min1 + low_offset1 <= min2 + high_offset2 + idx_access2 - 1\n-\t   && min2 + low_offset2 <= min1 + high_offset1 + idx_access1 - 1\n+       min1 + low_offset1 <= min2 + high_offset2 + idx_access2 - 1\n+       && min2 + low_offset2 <= min1 + high_offset1 + idx_access1 - 1\n \n-\t Converting this into a single test, there is an overlap if:\n+     Converting this into a single test, there is an overlap if:\n \n-\t   0 <= min2 - min1 + bias <= limit\n+       0 <= min2 - min1 + bias <= limit\n \n-\t where  bias = high_offset2 + idx_access2 - 1 - low_offset1\n-\t       limit = (high_offset1 - low_offset1 + idx_access1 - 1)\n-\t\t     + (high_offset2 - low_offset2 + idx_access2 - 1)\n-\t  i.e. limit = idx_len1 + idx_access1 - 1 + idx_len2 + idx_access2 - 1\n+     where  bias = high_offset2 + idx_access2 - 1 - low_offset1\n+\t   limit = (high_offset1 - low_offset1 + idx_access1 - 1)\n+\t\t + (high_offset2 - low_offset2 + idx_access2 - 1)\n+      i.e. limit = idx_len1 + idx_access1 - 1 + idx_len2 + idx_access2 - 1\n \n-\t Combining the tests requires limit to be computable in an unsigned\n-\t form of the index type; if it isn't, we fall back to the usual\n-\t pointer-based checks.\n+     Combining the tests requires limit to be computable in an unsigned\n+     form of the index type; if it isn't, we fall back to the usual\n+     pointer-based checks.\n \n-\t We can do better if DR_B is a write and if DR_A and DR_B are\n-\t well-ordered in both the original and the new code (see the\n-\t comment above the DR_ALIAS_* flags for details).  In this case\n-\t we know that for each i in [0, n-1], the write performed by\n-\t access i of DR_B occurs after access numbers j<=i of DR_A in\n-\t both the original and the new code.  Any write or anti\n-\t dependencies wrt those DR_A accesses are therefore maintained.\n+     We can do better if DR_B is a write and if DR_A and DR_B are\n+     well-ordered in both the original and the new code (see the\n+     comment above the DR_ALIAS_* flags for details).  In this case\n+     we know that for each i in [0, n-1], the write performed by\n+     access i of DR_B occurs after access numbers j<=i of DR_A in\n+     both the original and the new code.  Any write or anti\n+     dependencies wrt those DR_A accesses are therefore maintained.\n \n-\t We just need to make sure that each individual write in DR_B does not\n-\t overlap any higher-indexed access in DR_A; such DR_A accesses happen\n-\t after the DR_B access in the original code but happen before it in\n-\t the new code.\n+     We just need to make sure that each individual write in DR_B does not\n+     overlap any higher-indexed access in DR_A; such DR_A accesses happen\n+     after the DR_B access in the original code but happen before it in\n+     the new code.\n \n-\t We know the steps for both accesses are equal, so by induction, we\n-\t just need to test whether the first write of DR_B overlaps a later\n-\t access of DR_A.  In other words, we need to move min1 along by\n-\t one iteration:\n+     We know the steps for both accesses are equal, so by induction, we\n+     just need to test whether the first write of DR_B overlaps a later\n+     access of DR_A.  In other words, we need to move min1 along by\n+     one iteration:\n \n-\t   min1' = min1 + idx_step\n+       min1' = min1 + idx_step\n \n-\t and use the ranges:\n+     and use the ranges:\n \n-\t   [min1' + low_offset1', min1' + high_offset1' + idx_access1 - 1]\n+       [min1' + low_offset1', min1' + high_offset1' + idx_access1 - 1]\n \n-\t and:\n+     and:\n \n-\t   [min2, min2 + idx_access2 - 1]\n+       [min2, min2 + idx_access2 - 1]\n \n-\t where:\n+     where:\n \n-\t    low_offset1' = +ve step ? 0 : -(idx_len1 - |idx_step|)\n-\t   high_offset1' = +ve_step ? idx_len1 - |idx_step| : 0.  */\n-      if (waw_or_war_p)\n-\tidx_len1 -= abs_idx_step;\n+\tlow_offset1' = +ve step ? 0 : -(idx_len1 - |idx_step|)\n+       high_offset1' = +ve_step ? idx_len1 - |idx_step| : 0.  */\n+  if (waw_or_war_p)\n+    idx_len1 -= abs_idx_step;\n \n-      poly_offset_int limit = idx_len1 + idx_access1 - 1 + idx_access2 - 1;\n-      if (!waw_or_war_p)\n-\tlimit += idx_len2;\n+  poly_offset_int limit = idx_len1 + idx_access1 - 1 + idx_access2 - 1;\n+  if (!waw_or_war_p)\n+    limit += idx_len2;\n \n-      tree utype = unsigned_type_for (TREE_TYPE (min1));\n-      if (!wi::fits_to_tree_p (limit, utype))\n-\treturn false;\n+  tree utype = unsigned_type_for (TREE_TYPE (min1));\n+  if (!wi::fits_to_tree_p (limit, utype))\n+    return false;\n \n-      poly_offset_int low_offset1 = neg_step ? -idx_len1 : 0;\n-      poly_offset_int high_offset2 = neg_step || waw_or_war_p ? 0 : idx_len2;\n-      poly_offset_int bias = high_offset2 + idx_access2 - 1 - low_offset1;\n-      /* Equivalent to adding IDX_STEP to MIN1.  */\n-      if (waw_or_war_p)\n-\tbias -= wi::to_offset (idx_step);\n-\n-      tree subject = fold_build2 (MINUS_EXPR, utype,\n-\t\t\t\t  fold_convert (utype, min2),\n-\t\t\t\t  fold_convert (utype, min1));\n-      subject = fold_build2 (PLUS_EXPR, utype, subject,\n-\t\t\t     wide_int_to_tree (utype, bias));\n-      tree part_cond_expr = fold_build2 (GT_EXPR, boolean_type_node, subject,\n-\t\t\t\t\t wide_int_to_tree (utype, limit));\n-      if (*cond_expr)\n-\t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t  *cond_expr, part_cond_expr);\n-      else\n-\t*cond_expr = part_cond_expr;\n-    }\n+  poly_offset_int low_offset1 = neg_step ? -idx_len1 : 0;\n+  poly_offset_int high_offset2 = neg_step || waw_or_war_p ? 0 : idx_len2;\n+  poly_offset_int bias = high_offset2 + idx_access2 - 1 - low_offset1;\n+  /* Equivalent to adding IDX_STEP to MIN1.  */\n+  if (waw_or_war_p)\n+    bias -= wi::to_offset (idx_step);\n+\n+  tree subject = fold_build2 (MINUS_EXPR, utype,\n+\t\t\t      fold_convert (utype, min2),\n+\t\t\t      fold_convert (utype, min1));\n+  subject = fold_build2 (PLUS_EXPR, utype, subject,\n+\t\t\t wide_int_to_tree (utype, bias));\n+  tree part_cond_expr = fold_build2 (GT_EXPR, boolean_type_node, subject,\n+\t\t\t\t     wide_int_to_tree (utype, limit));\n+  if (*cond_expr)\n+    *cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t      *cond_expr, part_cond_expr);\n+  else\n+    *cond_expr = part_cond_expr;\n   if (dump_enabled_p ())\n     {\n       if (waw_or_war_p)"}]}