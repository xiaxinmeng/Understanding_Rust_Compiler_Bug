{"sha": "06469efd1a409d723093cfaa75ab9d39653e6463", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY0NjllZmQxYTQwOWQ3MjMwOTNjZmFhNzVhYjlkMzk2NTNlNjQ2Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-03T07:18:22Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-03T07:18:22Z"}, "message": "re PR fortran/29642 (Fortran 2003: VALUE Attribute (call by value not call by reference for actual arguments))\n\n2006-12-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29642\n\t* trans-expr.c (gfc_conv_variable): A character expression with\n\tthe VALUE attribute needs an address expression; otherwise all\n\tother expressions with this attribute must not be dereferenced.\n\t(gfc_conv_function_call): Pass expressions with the VALUE\n\tattribute by value, using gfc_conv_expr.\n\t* symbol.c (check_conflict): Add strings for INTENT OUT, INOUT\n\tand VALUE.  Apply all the constraints associated with the VALUE\n\tattribute.\n\t(gfc_add_value): New function.\n\t(gfc_copy_attr): Call it for VALUE attribute.\n\t* decl.c (match_attr_spec): Include the VALUE attribute.\n\t(gfc_match_value): New function.\n\t* dump-parse-tree.c (gfc_show_attr): Include VALUE.\n\t* gfortran.h : Add value to the symbol_attribute structure and\n\tadd a prototype for gfc_add_value\n\t* module.c (mio_internal_string): Include AB_VALUE in enum.\n\t(attr_bits): Provide the VALUE string for it.\n\t(mio_symbol_attribute): Read or apply the VLUE attribute.\n\t* trans-types.c (gfc_sym_type): Variables with the VLAUE\n\tattribute are not passed by reference!\n\t* resolve.c (was_declared): Add value to those that return 1.\n\t(resolve_symbol): Value attribute requires dummy attribute.\n\t* match.h : Add prototype for gfc_match_public.\n\t* parse.c (decode_statement): Try to match a VALUE statement.\n\n\n2006-12-03  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29642\n\t* gfortran.dg/value_1.f90 : New test.\n\t* gfortran.dg/value_2.f90 : New test.\n\t* gfortran.dg/value_3.f90 : New test.\n\t* gfortran.dg/value_4.f90 : New test.\n\t* gfortran.dg/value_4.c : Called from value_4.f90.\n\nFrom-SVN: r119461", "tree": {"sha": "2cc0f500bf05264d75beb5ac0011e36ce0619792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cc0f500bf05264d75beb5ac0011e36ce0619792"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06469efd1a409d723093cfaa75ab9d39653e6463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06469efd1a409d723093cfaa75ab9d39653e6463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06469efd1a409d723093cfaa75ab9d39653e6463", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06469efd1a409d723093cfaa75ab9d39653e6463/comments", "author": null, "committer": null, "parents": [{"sha": "3c5e8e4492a4f360800bfc4d3965a5a85c230a08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c5e8e4492a4f360800bfc4d3965a5a85c230a08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c5e8e4492a4f360800bfc4d3965a5a85c230a08"}], "stats": {"total": 511, "additions": 487, "deletions": 24}, "files": [{"sha": "d17b047aa82f0603b4c34710c7560c838967a66e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -1,3 +1,31 @@\n+2006-12-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29642\n+\t* trans-expr.c (gfc_conv_variable): A character expression with\n+\tthe VALUE attribute needs an address expression; otherwise all\n+\tother expressions with this attribute must not be dereferenced.\n+\t(gfc_conv_function_call): Pass expressions with the VALUE\n+\tattribute by value, using gfc_conv_expr.\n+\t* symbol.c (check_conflict): Add strings for INTENT OUT, INOUT\n+\tand VALUE.  Apply all the constraints associated with the VALUE\n+\tattribute.\n+\t(gfc_add_value): New function.\n+\t(gfc_copy_attr): Call it for VALUE attribute.\n+\t* decl.c (match_attr_spec): Include the VALUE attribute.\n+\t(gfc_match_value): New function.\n+\t* dump-parse-tree.c (gfc_show_attr): Include VALUE.\n+\t* gfortran.h : Add value to the symbol_attribute structure and\n+\tadd a prototype for gfc_add_value\n+\t* module.c (mio_internal_string): Include AB_VALUE in enum.\n+\t(attr_bits): Provide the VALUE string for it.\n+\t(mio_symbol_attribute): Read or apply the VLUE attribute.\n+\t* trans-types.c (gfc_sym_type): Variables with the VLAUE\n+\tattribute are not passed by reference!\n+\t* resolve.c (was_declared): Add value to those that return 1.\n+\t(resolve_symbol): Value attribute requires dummy attribute.\n+\t* match.h : Add prototype for gfc_match_public.\n+\t* parse.c (decode_statement): Try to match a VALUE statement.\n+\n 2006-12-01  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/29568"}, {"sha": "46c49ba9e8c29c6105e8639dd45c089ac69065b7", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -2117,7 +2117,7 @@ match_attr_spec (void)\n     DECL_ALLOCATABLE = GFC_DECL_BEGIN, DECL_DIMENSION, DECL_EXTERNAL,\n     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,\n     DECL_PARAMETER, DECL_POINTER, DECL_PRIVATE, DECL_PUBLIC, DECL_SAVE,\n-    DECL_TARGET, DECL_VOLATILE, DECL_COLON, DECL_NONE,\n+    DECL_TARGET, DECL_VALUE, DECL_VOLATILE, DECL_COLON, DECL_NONE,\n     GFC_DECL_END /* Sentinel */\n   }\n   decl_types;\n@@ -2140,6 +2140,7 @@ match_attr_spec (void)\n     minit (\", public\", DECL_PUBLIC),\n     minit (\", save\", DECL_SAVE),\n     minit (\", target\", DECL_TARGET),\n+    minit (\", value\", DECL_VALUE),\n     minit (\", volatile\", DECL_VOLATILE),\n     minit (\"::\", DECL_COLON),\n     minit (NULL, DECL_NONE)\n@@ -2261,6 +2262,9 @@ match_attr_spec (void)\n \t  case DECL_TARGET:\n \t    attr = \"TARGET\";\n \t    break;\n+\t  case DECL_VALUE:\n+\t    attr = \"VALUE\";\n+\t    break;\n \t  case DECL_VOLATILE:\n \t    attr = \"VOLATILE\";\n \t    break;\n@@ -2378,6 +2382,15 @@ match_attr_spec (void)\n \t  t = gfc_add_target (&current_attr, &seen_at[d]);\n \t  break;\n \n+\tcase DECL_VALUE:\n+\t  if (gfc_notify_std (GFC_STD_F2003,\n+                              \"Fortran 2003: VALUE attribute at %C\")\n+\t      == FAILURE)\n+\t    t = FAILURE;\n+\t  else\n+\t    t = gfc_add_value (&current_attr, NULL, &seen_at[d]);\n+\t  break;\n+\n \tcase DECL_VOLATILE:\n \t  if (gfc_notify_std (GFC_STD_F2003,\n                               \"Fortran 2003: VOLATILE attribute at %C\")\n@@ -4050,6 +4063,57 @@ gfc_match_save (void)\n }\n \n \n+match\n+gfc_match_value (void)\n+{\n+  gfc_symbol *sym;\n+  match m;\n+\n+  if (gfc_notify_std (GFC_STD_F2003, \n+\t\t      \"Fortran 2003: VALUE statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match (\" ::\") == MATCH_NO && gfc_match_space () == MATCH_NO)\n+    {\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_eos () == MATCH_YES)\n+    goto syntax;\n+\n+  for(;;)\n+    {\n+      m = gfc_match_symbol (&sym, 0);\n+      switch (m)\n+\t{\n+\tcase MATCH_YES:\n+\t  if (gfc_add_value (&sym->attr, sym->name,\n+  \t\t\t        &gfc_current_locus) == FAILURE)\n+\t    return MATCH_ERROR;\n+\t  goto next_item;\n+\n+\tcase MATCH_NO:\n+\t  break;\n+\n+\tcase MATCH_ERROR:\n+\t  return MATCH_ERROR;\n+\t}\n+\n+    next_item:\n+      if (gfc_match_eos () == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in VALUE statement at %C\");\n+  return MATCH_ERROR;\n+}\n+\n match\n gfc_match_volatile (void)\n {"}, {"sha": "f53ee2e859823879b55fb3acc6d81a2f66b43548", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -552,6 +552,8 @@ gfc_show_attr (symbol_attribute * attr)\n     gfc_status (\" POINTER\");\n   if (attr->save)\n     gfc_status (\" SAVE\");\n+  if (attr->value)\n+    gfc_status (\" VALUE\");\n   if (attr->volatile_)\n     gfc_status (\" VOLATILE\");\n   if (attr->threadprivate)"}, {"sha": "3a3b680f88f99b98032e4c34bd20eab3e4e20d31", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -479,7 +479,7 @@ typedef struct\n {\n   /* Variable attributes.  */\n   unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n-    optional:1, pointer:1, save:1, target:1, volatile_:1,\n+    optional:1, pointer:1, save:1, target:1, value:1, volatile_:1,\n     dummy:1, result:1, assign:1, threadprivate:1;\n \n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n@@ -1871,6 +1871,7 @@ try gfc_add_pure (symbol_attribute *, locus *);\n try gfc_add_recursive (symbol_attribute *, locus *);\n try gfc_add_function (symbol_attribute *, const char *, locus *);\n try gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n+try gfc_add_value (symbol_attribute *, const char *, locus *);\n try gfc_add_volatile (symbol_attribute *, const char *, locus *);\n \n try gfc_add_access (symbol_attribute *, gfc_access, const char *, locus *);"}, {"sha": "cc0207b9916cb1edf1064d7bca743b7d23e60c98", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -147,6 +147,7 @@ match gfc_match_public (gfc_statement *);\n match gfc_match_save (void);\n match gfc_match_modproc (void);\n match gfc_match_target (void);\n+match gfc_match_value (void);\n match gfc_match_volatile (void);\n \n /* primary.c */"}, {"sha": "6956fc980c5595b1fd9c2d9ad4b1810a00dcd1da", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -1487,11 +1487,11 @@ mio_internal_string (char *string)\n \n typedef enum\n { AB_ALLOCATABLE, AB_DIMENSION, AB_EXTERNAL, AB_INTRINSIC, AB_OPTIONAL,\n-  AB_POINTER, AB_SAVE, AB_TARGET, AB_DUMMY, AB_RESULT,\n-  AB_DATA, AB_IN_NAMELIST, AB_IN_COMMON, \n-  AB_FUNCTION, AB_SUBROUTINE, AB_SEQUENCE, AB_ELEMENTAL, AB_PURE,\n-  AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT, AB_CRAY_POINTER,\n-  AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP, AB_VOLATILE\n+  AB_POINTER, AB_SAVE, AB_TARGET, AB_DUMMY, AB_RESULT, AB_DATA,\n+  AB_IN_NAMELIST, AB_IN_COMMON, AB_FUNCTION, AB_SUBROUTINE, AB_SEQUENCE,\n+  AB_ELEMENTAL, AB_PURE, AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT,\n+  AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP,\n+  AB_VALUE, AB_VOLATILE\n }\n ab_attribute;\n \n@@ -1504,6 +1504,7 @@ static const mstring attr_bits[] =\n     minit (\"OPTIONAL\", AB_OPTIONAL),\n     minit (\"POINTER\", AB_POINTER),\n     minit (\"SAVE\", AB_SAVE),\n+    minit (\"VALUE\", AB_VALUE),\n     minit (\"VOLATILE\", AB_VOLATILE),\n     minit (\"TARGET\", AB_TARGET),\n     minit (\"THREADPRIVATE\", AB_THREADPRIVATE),\n@@ -1575,6 +1576,8 @@ mio_symbol_attribute (symbol_attribute * attr)\n \tMIO_NAME(ab_attribute) (AB_POINTER, attr_bits);\n       if (attr->save)\n \tMIO_NAME(ab_attribute) (AB_SAVE, attr_bits);\n+      if (attr->value)\n+\tMIO_NAME(ab_attribute) (AB_VALUE, attr_bits);\n       if (attr->volatile_)\n \tMIO_NAME(ab_attribute) (AB_VOLATILE, attr_bits);\n       if (attr->target)\n@@ -1655,6 +1658,9 @@ mio_symbol_attribute (symbol_attribute * attr)\n \t    case AB_SAVE:\n \t      attr->save = 1;\n \t      break;\n+\t    case AB_VALUE:\n+\t      attr->value = 1;\n+\t      break;\n \t    case AB_VOLATILE:\n \t      attr->volatile_ = 1;\n \t      break;"}, {"sha": "d23737356abcb0d5e82675eec38c1561267e69c4", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -284,6 +284,7 @@ decode_statement (void)\n       break;\n \n     case 'v':\n+      match (\"value\", gfc_match_value, ST_ATTR_DECL);\n       match (\"volatile\", gfc_match_volatile, ST_ATTR_DECL);\n       break;\n "}, {"sha": "d682b223b453f58a48d233379e60b3a30707793d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -675,7 +675,7 @@ was_declared (gfc_symbol * sym)\n     return 1;\n \n   if (a.allocatable || a.dimension || a.dummy || a.external || a.intrinsic\n-      || a.optional || a.pointer || a.save || a.target || a.volatile_\n+      || a.optional || a.pointer || a.save || a.target || a.volatile_ || a.value\n       || a.access != ACCESS_UNKNOWN || a.intent != INTENT_UNKNOWN)\n     return 1;\n \n@@ -5961,6 +5961,14 @@ resolve_symbol (gfc_symbol * sym)\n       return;\n     }\n \n+  if (sym->attr.value && !sym->attr.dummy)\n+    {\n+      gfc_error (\"'%s' at %L cannot have the VALUE attribute because \"\n+\t\t \"it is not a dummy\", sym->name, &sym->declared_at);\n+      return;\n+    }\n+\n+\n   /* If a derived type symbol has reached this point, without its\n      type being declared, we have an error.  Notice that most\n      conditions that produce undefined derived types have already"}, {"sha": "228567bd5e8ec29692dacafe300a35032595d4a6", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -266,14 +266,16 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   static const char *dummy = \"DUMMY\", *save = \"SAVE\", *pointer = \"POINTER\",\n     *target = \"TARGET\", *external = \"EXTERNAL\", *intent = \"INTENT\",\n     *intent_in = \"INTENT(IN)\", *intrinsic = \"INTRINSIC\",\n+    *intent_out = \"INTENT(OUT)\", *intent_inout = \"INTENT(INOUT)\",\n     *allocatable = \"ALLOCATABLE\", *elemental = \"ELEMENTAL\",\n     *private = \"PRIVATE\", *recursive = \"RECURSIVE\",\n     *in_common = \"COMMON\", *result = \"RESULT\", *in_namelist = \"NAMELIST\",\n     *public = \"PUBLIC\", *optional = \"OPTIONAL\", *entry = \"ENTRY\",\n     *function = \"FUNCTION\", *subroutine = \"SUBROUTINE\",\n     *dimension = \"DIMENSION\", *in_equivalence = \"EQUIVALENCE\",\n     *use_assoc = \"USE ASSOCIATED\", *cray_pointer = \"CRAY POINTER\",\n-    *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\", *volatile_ = \"VOLATILE\";\n+    *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\", *value = \"VALUE\",\n+    *volatile_ = \"VOLATILE\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n@@ -402,6 +404,21 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   conf (data, allocatable);\n   conf (data, use_assoc);\n \n+  conf (value, pointer)\n+  conf (value, allocatable)\n+  conf (value, subroutine)\n+  conf (value, function)\n+  conf (value, volatile_)\n+  conf (value, dimension)\n+  conf (value, external)\n+\n+  if (attr->value && (attr->intent == INTENT_OUT || attr->intent == INTENT_INOUT))\n+    {\n+      a1 = value;\n+      a2 = attr->intent == INTENT_OUT ? intent_out : intent_inout;\n+      goto conflict;\n+    }\n+\n   conf (volatile_, intrinsic)\n   conf (volatile_, external)\n \n@@ -524,6 +541,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n       conf2 (dummy);\n       conf2 (in_common);\n       conf2 (save);\n+      conf2 (value);\n       conf2 (volatile_);\n       conf2 (threadprivate);\n       break;\n@@ -804,6 +822,26 @@ gfc_add_save (symbol_attribute * attr, const char *name, locus * where)\n   return check_conflict (attr, name, where);\n }\n \n+try\n+gfc_add_value (symbol_attribute * attr, const char *name, locus * where)\n+{\n+\n+  if (check_used (attr, name, where))\n+    return FAILURE;\n+\n+  if (attr->value)\n+    {\n+\tif (gfc_notify_std (GFC_STD_LEGACY, \n+\t\t\t    \"Duplicate VALUE attribute specified at %L\",\n+\t\t\t    where) \n+\t    == FAILURE)\n+\t  return FAILURE;\n+    }\n+\n+  attr->value = 1;\n+  return check_conflict (attr, name, where);\n+}\n+\n try\n gfc_add_volatile (symbol_attribute * attr, const char *name, locus * where)\n {\n@@ -1257,6 +1295,8 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n     goto fail;\n   if (src->save && gfc_add_save (dest, NULL, where) == FAILURE)\n     goto fail;\n+  if (src->value && gfc_add_value (dest, NULL, where) == FAILURE)\n+    goto fail;\n   if (src->volatile_ && gfc_add_volatile (dest, NULL, where) == FAILURE)\n     goto fail;\n   if (src->threadprivate && gfc_add_threadprivate (dest, NULL, where) == FAILURE)"}, {"sha": "3505236ab47703590e2d6f5254757634e929b1d7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -447,15 +447,21 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t separately.  */\n       if (sym->ts.type == BT_CHARACTER)\n \t{\n-          /* Dereference character pointer dummy arguments\n+\t  /* Dereference character pointer dummy arguments\n \t     or results.  */\n \t  if ((sym->attr.pointer || sym->attr.allocatable)\n \t      && (sym->attr.dummy\n \t\t  || sym->attr.function\n \t\t  || sym->attr.result))\n \t    se->expr = build_fold_indirect_ref (se->expr);\n+\n+\t  /* A character with VALUE attribute needs an address\n+\t     expression.  */\n+\t  if (sym->attr.value)\n+\t    se->expr = build_fold_addr_expr (se->expr);\n+\n \t}\n-      else\n+      else if (!sym->attr.value)\n \t{\n           /* Dereference non-character scalar dummy arguments.  */\n \t  if (sym->attr.dummy && !sym->attr.dimension)\n@@ -2005,19 +2011,26 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  argss = gfc_walk_expr (e);\n \n \t  if (argss == gfc_ss_terminator)\n-            {\n-\t      gfc_conv_expr_reference (&parmse, e);\n+\t    {\n \t      parm_kind = SCALAR;\n-              if (fsym && fsym->attr.pointer\n-\t\t  && e->expr_type != EXPR_NULL)\n-                {\n-                  /* Scalar pointer dummy args require an extra level of\n-\t\t  indirection. The null pointer already contains\n-\t\t  this level of indirection.  */\n-\t\t  parm_kind = SCALAR_POINTER;\n-                  parmse.expr = build_fold_addr_expr (parmse.expr);\n-                }\n-            }\n+\t      if (fsym && fsym->attr.value)\n+\t\t{\n+\t\t  gfc_conv_expr (&parmse, e);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gfc_conv_expr_reference (&parmse, e);\n+\t\t  if (fsym && fsym->attr.pointer\n+\t\t\t&& e->expr_type != EXPR_NULL)\n+\t\t    {\n+\t\t      /* Scalar pointer dummy args require an extra level of\n+\t\t\t indirection. The null pointer already contains\n+\t\t\t this level of indirection.  */\n+\t\t      parm_kind = SCALAR_POINTER;\n+\t\t      parmse.expr = build_fold_addr_expr (parmse.expr);\n+\t\t    }\n+\t\t}\n+\t    }\n \t  else\n \t    {\n               /* If the procedure requires an explicit interface, the actual"}, {"sha": "381e007ab3c8248f30715c270fef130c6fde963a", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -1343,7 +1343,7 @@ gfc_sym_type (gfc_symbol * sym)\n       sym->ts.kind = gfc_default_real_kind;\n     }\n \n-  if (sym->attr.dummy && !sym->attr.function)\n+  if (sym->attr.dummy && !sym->attr.function && !sym->attr.value)\n     byref = 1;\n   else\n     byref = 0;"}, {"sha": "d39d5bcc76714a3301f87f5a1929f1215738f37b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -1,3 +1,12 @@\n+2006-12-03  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29642\n+\t* gfortran.dg/value_1.f90 : New test.\n+\t* gfortran.dg/value_2.f90 : New test.\n+\t* gfortran.dg/value_3.f90 : New test.\n+\t* gfortran.dg/value_4.f90 : New test.\n+\t* gfortran.dg/value_4.c : Called from value_4.f90.\n+\n 2006-12-02  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR C++/30033"}, {"sha": "526a028ec3a5d0b31538806ffbac30f13ed292be", "filename": "gcc/testsuite/gfortran.dg/value_1.f90", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_1.f90?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -0,0 +1,84 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! Tests the functionality of the patch for PR29642, which requested the\n+! implementation of the F2003 VALUE attribute for gfortran.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org> \n+!\n+module global\n+  type :: mytype\n+    real(4) :: x\n+    character(4) :: c\n+  end type mytype\n+contains\n+  subroutine typhoo (dt)\n+    type(mytype), value :: dt\n+    if (dtne (dt, mytype (42.0, \"lmno\"))) call abort ()\n+    dt = mytype (21.0, \"wxyz\")\n+    if (dtne (dt, mytype (21.0, \"wxyz\"))) call abort ()\n+  end subroutine typhoo\n+\n+  logical function dtne (a, b)\n+    type(mytype) :: a, b\n+    dtne = .FALSE.\n+    if ((a%x /= b%x) .or. (a%c /= b%c)) dtne = .TRUE.\n+  end function dtne\n+end module global\n+\n+program test_value\n+  use global\n+  integer(8) :: i = 42\n+  real(8) :: r = 42.0\n+  character(2) ::   c = \"ab\"\n+  complex(8) :: z = (-99.0, 199.0)\n+  type(mytype) :: dt = mytype (42.0, \"lmno\")\n+\n+  call foo (c)\n+  if (c /= \"ab\") call abort ()\n+\n+  call bar (i)\n+  if (i /= 42) call abort ()\n+\n+  call foobar (r)\n+  if (r /= 42.0) call abort ()\n+\n+  call complex_foo (z)\n+  if (z /= (-99.0, 199.0)) call abort ()\n+\n+  call typhoo (dt)\n+  if (dtne (dt, mytype (42.0, \"lmno\"))) call abort ()\n+\n+  r = 20.0\n+  call foobar (r*2.0 + 2.0)\n+\n+contains\n+  subroutine foo (c)\n+    character(2), value :: c\n+    if (c /= \"ab\") call abort ()\n+    c = \"cd\"\n+    if (c /= \"cd\") call abort ()\n+  end subroutine foo\n+\n+  subroutine bar (i)\n+    integer(8), value :: i\n+    if (i /= 42) call abort ()\n+    i = 99\n+    if (i /= 99) call abort ()\n+  end subroutine bar\n+\n+  subroutine foobar (r)\n+    real(8), value :: r\n+    if (r /= 42.0) call abort ()\n+    r = 99.0\n+    if (r /= 99.0) call abort ()\n+  end subroutine foobar\n+\n+  subroutine complex_foo (z)\n+    COMPLEX(8), value :: z\n+    if (z /= (-99.0, 199.0)) call abort ()\n+    z = (77.0, -42.0)\n+    if (z /= (77.0, -42.0)) call abort ()\n+  end subroutine complex_foo\n+\n+end program test_value\n+! { dg-final { cleanup-modules \"global\" } }"}, {"sha": "d25683c2e50d1fb21f4aeb34350eb52eb7e9891c", "filename": "gcc/testsuite/gfortran.dg/value_2.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_2.f90?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+! Tests the standard check in the patch for PR29642, which requested the\n+! implementation of the F2003 VALUE attribute for gfortran.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org> \n+!\n+program test_value\n+  integer(8) :: i = 42\n+\n+  call bar (i)\n+  if (i /= 42) call abort ()\n+contains\n+  subroutine bar (i)\n+    integer(8) :: i\n+    value :: i      ! { dg-error \"Fortran 2003: VALUE\" }\n+    if (i /= 42) call abort ()\n+    i = 99\n+    if (i /= 99) call abort ()\n+  end subroutine bar\n+end program test_value"}, {"sha": "c5d2d1f27df6944d579b92e7d645a43f8f21e20b", "filename": "gcc/testsuite/gfortran.dg/value_3.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_3.f90?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do compile }\n+! Tests the constraints in the patch for PR29642, which requested the\n+! implementation of the F2003 VALUE attribute for gfortran.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org> \n+!\n+program test_value\n+  integer(8) :: i = 42, j   ! { dg-error \"not a dummy\" }\n+  integer(8), value :: k    ! { dg-error \"not a dummy\" }\n+  value :: j\n+\n+contains\n+  subroutine bar_1 (i)\n+    integer(8) :: i\n+    dimension i(8)\n+    value :: i  ! { dg-error \"conflicts with DIMENSION\" }\n+    i = 0\n+  end subroutine bar_1\n+\n+  subroutine bar_2 (i)\n+    integer(8) :: i\n+    pointer :: i\n+    value :: i  ! { dg-error \"conflicts with POINTER\" }\n+    i = 0\n+  end subroutine bar_2\n+\n+  integer function bar_3 (i)\n+    integer(8) :: i\n+    dimension i(8)\n+    value :: bar_3  ! { dg-error \"conflicts with FUNCTION\" }\n+    i = 0\n+    bar_3 = 0\n+  end function bar_3\n+\n+  subroutine bar_4 (i, j)\n+    integer(8), intent(inout) :: i\n+    integer(8), intent(out) :: j\n+    value :: i  ! { dg-error \"conflicts with INTENT\" }\n+    value :: j  ! { dg-error \"conflicts with INTENT\" }\n+    i = 0\n+    j = 0\n+  end subroutine bar_4\n+\n+  integer function bar_5 ()\n+    integer(8) :: i\n+    external :: i\n+    integer, parameter :: j = 99\n+    value :: i  ! { dg-error \"conflicts with EXTERNAL\" }\n+    value :: j  ! { dg-error \"PARAMETER attribute conflicts with\" }\n+    bar_5 = 0\n+  end function bar_5\n+\n+end program test_value"}, {"sha": "1eff965a02903e8fcdff884e177b3050e7a26fa2", "filename": "gcc/testsuite/gfortran.dg/value_4.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_4.c?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -0,0 +1,48 @@\n+/*  Passing from fortran to C by value, using VALUE.  This is identical\n+    to c_by_val_1.c, which performs the same function for %VAL.\n+\n+    Contributed by Paul Thomas <pault@gcc.gnu.org>  */\n+\n+typedef struct { float r, i; } complex;\n+extern float *f_to_f__ (float, float*);\n+extern int *i_to_i__ (int, int*);\n+extern void c_to_c__ (complex*, complex, complex*);\n+extern void abort (void);\n+\n+/* In f_to_f and i_to_i we return the second argument, so that we do\n+   not have to worry about keeping track of memory allocation between\n+   fortran and C.  All three functions check that the argument passed\n+   by value is the same as that passed by reference.  Then the passed\n+   by value argument is modified so that the caller can check that\n+   its version has not changed.*/\n+\n+float *\n+f_to_f__(float a1, float *a2)\n+{\n+  if ( a1 != *a2 ) abort();\n+  *a2 = a1 * 2.0;\n+  a1 = 0.0;\n+  return a2;\n+}\n+\n+int *\n+i_to_i__(int i1, int *i2)\n+{\n+  if ( i1 != *i2 ) abort();\n+  *i2 = i1 * 3;\n+  i1 = 0;\n+  return i2;\n+}\n+\n+void\n+c_to_c__(complex *retval, complex c1, complex *c2)\n+{\n+  if ( c1.r != c2->r ) abort();\n+  if ( c1.i != c2->i ) abort();\n+  c1.r = 0.0;\n+  c1.i = 0.0;\n+  retval->r = c2->r * 4.0;\n+  retval->i = c2->i * 4.0;\n+  return;\n+}\n+"}, {"sha": "969e4acc9e99ea11384dc8d88713efac96bb63f7", "filename": "gcc/testsuite/gfortran.dg/value_4.f90", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06469efd1a409d723093cfaa75ab9d39653e6463/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvalue_4.f90?ref=06469efd1a409d723093cfaa75ab9d39653e6463", "patch": "@@ -0,0 +1,84 @@\n+! { dg-do run }\n+! { dg-additional-sources value_4.c }\n+! { dg-options \"-ff2c -w -O0\" }\n+!\n+! Tests the functionality of the patch for PR29642, which requested the\n+! implementation of the F2003 VALUE attribute for gfortran, by calling\n+! external C functions by value and by reference.  This is effectively\n+! identical to c_by_val_1.f, which does the same for %VAL.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org> \n+!\n+module global\n+  interface delta\n+    module procedure deltai, deltar, deltac\n+  end interface delta\n+  real(4) :: epsi = epsilon (1.0_4)\n+contains\n+  function deltai (a, b) result (c)\n+    integer(4) :: a, b\n+    logical :: c\n+    c = (a /= b)\n+  end function deltai\n+\n+  function deltar (a, b) result (c)\n+    real(4) :: a, b\n+    logical :: c\n+    c = (abs (a-b) > epsi)\n+  end function deltar\n+\n+  function deltac (a, b) result (c)\n+    complex(4) :: a, b\n+    logical :: c\n+    c = ((abs (real (a-b)) > epsi).or.(abs (aimag (a-b)) > epsi))\n+  end function deltac\n+end module global  \n+\n+program value_4\n+  use global\n+  interface\n+    function f_to_f (x, y)\n+      real(4), pointer :: f_to_f\n+      real(4) :: x, y\n+      value :: x\n+    end function f_to_f\n+  end interface\n+\n+  interface\n+    function i_to_i (x, y)\n+      integer(4), pointer :: i_to_i\n+      integer(4) :: x, y\n+      value :: x\n+    end function i_to_i\n+  end interface\n+\n+  interface\n+    complex(4) function c_to_c (x, y)\n+      complex(4) :: x, y\n+      value :: x\n+    end function c_to_c\n+  end interface\n+\n+  real(4)       a, b, c\n+  integer(4)    i, j, k\n+  complex(4)    u, v, w\n+\n+  a = 42.0\n+  b = 0.0\n+  c = a\n+  b = f_to_f (a, c)\n+  if (delta ((2.0 * a), b)) call abort ()\n+\n+  i = 99\n+  j = 0\n+  k = i\n+  j = i_to_i (i, k)\n+  if (delta ((3 * i), j)) call abort ()\n+\n+  u = (-1.0, 2.0)\n+  v = (1.0, -2.0)\n+  w = u\n+  v = c_to_c (u, w)\n+  if (delta ((4.0 * u), v)) call abort ()\n+end program value_4\n+! { dg-final { cleanup-modules \"global\" } }"}]}