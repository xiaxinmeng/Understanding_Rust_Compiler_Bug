{"sha": "6df6055d5c666e669890ff8572df2353e341a534", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmNjA1NWQ1YzY2NmU2Njk4OTBmZjg1NzJkZjIzNTNlMzQxYTUzNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-29T13:26:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-29T14:20:14Z"}, "message": "Add forward propagation to SLP \"any\" permutes\n\nThis adds a forward propagation phase to the permute optimization\nmachinery which allows us to handle \"any\" permute for all kinds of\nnodes.  To match previous behavior cost-wise we still do not allow\nnon-external/constant nodes to be duplicated for multiple permutes\nand this is ensured during propagation itself.\n\n2021-06-29  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_optimize_slp): Forward propagate\n\tto \"any\" permute nodes and relax \"any\" permute proapgation\n\tduring iterative backward propagation.", "tree": {"sha": "2707b5ac9b0b0c040279bf1f278337e75476e9fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2707b5ac9b0b0c040279bf1f278337e75476e9fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6df6055d5c666e669890ff8572df2353e341a534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df6055d5c666e669890ff8572df2353e341a534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df6055d5c666e669890ff8572df2353e341a534", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df6055d5c666e669890ff8572df2353e341a534/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33c4e466243f2d0459d9a4d0cadc1b38a3741f3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c4e466243f2d0459d9a4d0cadc1b38a3741f3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33c4e466243f2d0459d9a4d0cadc1b38a3741f3e"}], "stats": {"total": 81, "additions": 63, "deletions": 18}, "files": [{"sha": "9155af499b397fc4105e6e297311942a210d243d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df6055d5c666e669890ff8572df2353e341a534/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df6055d5c666e669890ff8572df2353e341a534/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6df6055d5c666e669890ff8572df2353e341a534", "patch": "@@ -3729,16 +3729,11 @@ vect_optimize_slp (vec_info *vinfo)\n \t    perm = vertices[idx].perm_out;\n \t  else\n \t    {\n-\t      perm = -1;\n-\t      bool all_constant = true;\n+\t      perm = vertices[idx].get_perm_in ();\n \t      for (graph_edge *succ = slpg->vertices[idx].succ;\n \t\t   succ; succ = succ->succ_next)\n \t\t{\n \t\t  int succ_idx = succ->dest;\n-\t\t  slp_tree succ_node = vertices[succ_idx].node;\n-\t\t  if (SLP_TREE_DEF_TYPE (succ_node) != vect_external_def\n-\t\t      && SLP_TREE_DEF_TYPE (succ_node) != vect_constant_def)\n-\t\t    all_constant = false;\n \t\t  int succ_perm = vertices[succ_idx].perm_out;\n \t\t  /* Handle unvisited (and constant) nodes optimistically.  */\n \t\t  /* ???  But for constants once we want to handle\n@@ -3750,25 +3745,34 @@ vect_optimize_slp (vec_info *vinfo)\n \t\t    continue;\n \t\t  if (perm == -1)\n \t\t    perm = succ_perm;\n-\t\t  else if (succ_perm == 0)\n+\t\t  else if (succ_perm == 0\n+\t\t\t   || !vect_slp_perms_eq (perms, perm, succ_perm))\n \t\t    {\n \t\t      perm = 0;\n \t\t      break;\n \t\t    }\n-\t\t  else if (!vect_slp_perms_eq (perms, perm, succ_perm))\n+\t\t}\n+\n+\t      /* If this is a node we do not want to eventually unshare\n+\t\t but it can be permuted at will, verify all users have\n+\t\t the same permutations registered and otherwise drop to\n+\t\t zero.  */\n+\t      if (perm == -1\n+\t\t  && SLP_TREE_DEF_TYPE (node) != vect_external_def\n+\t\t  && SLP_TREE_DEF_TYPE (node) != vect_constant_def)\n+\t\t{\n+\t\t  int preds_perm = -1;\n+\t\t  for (graph_edge *pred = slpg->vertices[idx].pred;\n+\t\t       pred; pred = pred->pred_next)\n \t\t    {\n-\t\t      perm = 0;\n-\t\t      break;\n+\t\t      int pred_perm = vertices[pred->src].get_perm_in ();\n+\t\t      if (preds_perm == -1)\n+\t\t\tpreds_perm = pred_perm;\n+\t\t      else if (!vect_slp_perms_eq (perms,\n+\t\t\t\t\t\t   pred_perm, preds_perm))\n+\t\t\tperm = 0;\n \t\t    }\n \t\t}\n-\t      /* We still lack a forward propagation of materializations\n-\t\t and thus only allow \"any\" permutes on constant or external\n-\t\t nodes which we handle during materialization by looking\n-\t\t at SLP children.  So avoid having internal \"any\" permutes\n-\t\t for now, see gcc.dg/vect/bb-slp-71.c for a testcase that\n-\t\t breaks when removing this restriction.  */\n-\t      if (perm == -1 && all_constant)\n-\t\tperm = 0;\n \n \t      if (!vect_slp_perms_eq (perms, perm,\n \t\t\t\t      vertices[idx].get_perm_in ()))\n@@ -3836,6 +3840,47 @@ vect_optimize_slp (vec_info *vinfo)\n \t}\n     }\n   while (changed);\n+  statistics_counter_event (cfun, \"SLP optimize perm iterations\", iteration);\n+\n+  /* Compute pre-order.  */\n+  auto_vec<int> heads;\n+  heads.reserve (vinfo->slp_instances.length ());\n+  for (slp_instance inst : vinfo->slp_instances)\n+    heads.quick_push (SLP_INSTANCE_TREE (inst)->vertex);\n+  auto_vec<int> po;\n+  graphds_dfs (slpg, &heads[0], heads.length (), &po, true, NULL, NULL);\n+\n+  /* Propagate materialized permutes to \"any\" permute nodes.  For heads\n+     ending up as \"any\" (reductions with just invariants), set them to\n+     no permute.  */\n+  for (int idx : heads)\n+    if (vertices[idx].perm_out == -1)\n+      vertices[idx].perm_out = 0;\n+  for (i = po.length (); i > 0; --i)\n+    {\n+      int idx = po[i-1];\n+      int perm_in = vertices[idx].get_perm_in ();\n+      slp_tree node = vertices[idx].node;\n+      if (SLP_TREE_DEF_TYPE (node) == vect_external_def\n+\t  || SLP_TREE_DEF_TYPE (node) == vect_constant_def)\n+\tcontinue;\n+      gcc_assert (perm_in != -1);\n+      for (graph_edge *succ = slpg->vertices[idx].succ;\n+\t   succ; succ = succ->succ_next)\n+\t{\n+\t  slp_tree succ_node = vertices[succ->dest].node;\n+\t  if (SLP_TREE_DEF_TYPE (succ_node) == vect_external_def\n+\t      || SLP_TREE_DEF_TYPE (succ_node) == vect_constant_def)\n+\t    continue;\n+\t  if (vertices[succ->dest].perm_out == -1)\n+\t    vertices[succ->dest].perm_out = perm_in;\n+\t  else\n+\t    /* Propagation should have ensured that all preds have the same\n+\t       permutation.  */\n+\t    gcc_assert (vect_slp_perms_eq (perms, perm_in,\n+\t\t\t\t\t   vertices[succ->dest].perm_out));\n+\t}\n+    }\n \n   /* Materialize.  */\n   for (i = 0; i < vertices.length (); ++i)"}]}