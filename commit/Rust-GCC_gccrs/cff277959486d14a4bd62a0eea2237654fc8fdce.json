{"sha": "cff277959486d14a4bd62a0eea2237654fc8fdce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmMjc3OTU5NDg2ZDE0YTRiZDYyYTBlZWEyMjM3NjU0ZmM4ZmRjZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@multimania.com", "date": "2002-04-23T23:31:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-23T23:31:07Z"}, "message": "fold-const.c (split_tree): Add MINUS_LITP parameter; separate added literals from substracted literals.\n\n        * fold-const.c (split_tree): Add MINUS_LITP parameter; separate\n        added literals from substracted literals.\n        (associate_trees): Don't convert MINUS_EXPR into PLUS_EXPR.\n        (fold) [associate]: Preserve MINUS_EXPR if needed.\n\n\t* gcc.c-torture/execute/20020423-1.c: New.\n\nFrom-SVN: r52695", "tree": {"sha": "8365dbb25fbafd138473dd142712439b4166052b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8365dbb25fbafd138473dd142712439b4166052b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cff277959486d14a4bd62a0eea2237654fc8fdce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff277959486d14a4bd62a0eea2237654fc8fdce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cff277959486d14a4bd62a0eea2237654fc8fdce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff277959486d14a4bd62a0eea2237654fc8fdce/comments", "author": null, "committer": null, "parents": [{"sha": "952bca8474a9978db54cc15a47966e3df864ebce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/952bca8474a9978db54cc15a47966e3df864ebce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/952bca8474a9978db54cc15a47966e3df864ebce"}], "stats": {"total": 154, "additions": 122, "deletions": 32}, "files": [{"sha": "e62f85879792ff32ebe1274181ab3aa846855c2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff277959486d14a4bd62a0eea2237654fc8fdce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff277959486d14a4bd62a0eea2237654fc8fdce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cff277959486d14a4bd62a0eea2237654fc8fdce", "patch": "@@ -1,3 +1,11 @@\n+2002-04-23  Eric Botcazou  <ebotcazou@multimania.com>\n+\n+\tPR c/5430\n+\t* fold-const.c (split_tree): Add MINUS_LITP parameter; separate\n+\tadded literals from substracted literals.\n+\t(associate_trees): Don't convert MINUS_EXPR into PLUS_EXPR.\n+\t(fold) [associate]: Preserve MINUS_EXPR if needed.\n+\n 2002-04-23  Zack Weinberg  <zack@codesourcery.com>\n \n \t* doc/install.texi: Clarify which versions of alpha*-dec-osf*\n@@ -35,9 +43,9 @@ Tue Apr 23 14:24:25 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-04-23  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/altivec.h (vec_step): Remove extraneous\n-        parentheses.\n-        (vec_ctu): Cast return.\n+\t* config/rs6000/altivec.h (vec_step): Remove extraneous\n+\tparentheses.\n+\t(vec_ctu): Cast return.\n \n 2002-04-23  Alan Modra  <amodra@bigpond.net.au>\n \n@@ -69,11 +77,11 @@ Tue Apr 23 14:24:25 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n 2002-04-22  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000.md (\"*movv4si_internal\"): Change 'm'\n-        constraint to 'o' for m=r and r=m alternatives.\n-        (\"*movv8hi_internal1\"): Same.\n-        (\"*movv16qi_internal1\"): Same.\n-        (\"*movv4sf_internal1\"): Same.\n+\t* config/rs6000/rs6000.md (\"*movv4si_internal\"): Change 'm'\n+\tconstraint to 'o' for m=r and r=m alternatives.\n+\t(\"*movv8hi_internal1\"): Same.\n+\t(\"*movv16qi_internal1\"): Same.\n+\t(\"*movv4sf_internal1\"): Same.\n \n 2002-04-22  Janis Johnson  <janis187@us.ibm.com>\n "}, {"sha": "084308ec9fa502077144884eca117c86480fc3ea", "filename": "gcc/fold-const.c", "status": "modified", "additions": 73, "deletions": 24, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff277959486d14a4bd62a0eea2237654fc8fdce/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff277959486d14a4bd62a0eea2237654fc8fdce/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=cff277959486d14a4bd62a0eea2237654fc8fdce", "patch": "@@ -62,7 +62,7 @@ static void decode\t\tPARAMS ((HOST_WIDE_INT *,\n \t\t\t\t\t HOST_WIDE_INT *));\n static tree negate_expr\t\tPARAMS ((tree));\n static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n-\t\t\t\t\t int));\n+\t\t\t\t\t tree *, int));\n static tree associate_trees\tPARAMS ((tree, tree, enum tree_code, tree));\n static tree int_const_binop\tPARAMS ((enum tree_code, tree, tree, int));\n static tree const_binop\t\tPARAMS ((enum tree_code, tree, tree, int));\n@@ -876,30 +876,34 @@ negate_expr (t)\n    combined with CODE to make IN.  \"constant\" means an expression with\n    TREE_CONSTANT but that isn't an actual constant.  CODE must be a\n    commutative arithmetic operation.  Store the constant part into *CONP,\n-   the literal in &LITP and return the variable part.  If a part isn't\n+   the literal in *LITP and return the variable part.  If a part isn't\n    present, set it to null.  If the tree does not decompose in this way,\n    return the entire tree as the variable part and the other parts as null.\n \n    If CODE is PLUS_EXPR we also split trees that use MINUS_EXPR.  In that\n-   case, we negate an operand that was subtracted.  If NEGATE_P is true, we\n-   are negating all of IN.\n+   case, we negate an operand that was subtracted.  Except if it is a\n+   literal for which we use *MINUS_LITP instead.\n+\n+   If NEGATE_P is true, we are negating all of IN, again except a literal\n+   for which we use *MINUS_LITP instead.\n \n    If IN is itself a literal or constant, return it as appropriate.\n \n    Note that we do not guarantee that any of the three values will be the\n    same type as IN, but they will have the same signedness and mode.  */\n \n static tree\n-split_tree (in, code, conp, litp, negate_p)\n+split_tree (in, code, conp, litp, minus_litp, negate_p)\n      tree in;\n      enum tree_code code;\n-     tree *conp, *litp;\n+     tree *conp, *litp, *minus_litp;\n      int negate_p;\n {\n   tree var = 0;\n \n   *conp = 0;\n   *litp = 0;\n+  *minus_litp = 0;\n \n   /* Strip any conversions that don't change the machine mode or signedness.  */\n   STRIP_SIGN_NOPS (in);\n@@ -941,9 +945,12 @@ split_tree (in, code, conp, litp, negate_p)\n \tvar = op1, neg_var_p = neg1_p;\n \n       /* Now do any needed negations.  */\n-      if (neg_litp_p) *litp = negate_expr (*litp);\n-      if (neg_conp_p) *conp = negate_expr (*conp);\n-      if (neg_var_p) var = negate_expr (var);\n+      if (neg_litp_p)\n+\t*minus_litp = *litp, *litp = 0;\n+      if (neg_conp_p)\n+\t*conp = negate_expr (*conp);\n+      if (neg_var_p)\n+\tvar = negate_expr (var);\n     }\n   else if (TREE_CONSTANT (in))\n     *conp = in;\n@@ -952,19 +959,20 @@ split_tree (in, code, conp, litp, negate_p)\n \n   if (negate_p)\n     {\n-      var = negate_expr (var);\n+      if (*litp)\n+\t*minus_litp = *litp, *litp = 0;\n+      else if (*minus_litp)\n+\t*litp = *minus_litp, *minus_litp = 0;\n       *conp = negate_expr (*conp);\n-      *litp = negate_expr (*litp);\n+      var = negate_expr (var);\n     }\n \n   return var;\n }\n \n /* Re-associate trees split by the above function.  T1 and T2 are either\n    expressions to associate or null.  Return the new expression, if any.  If\n-   we build an operation, do it in TYPE and with CODE, except if CODE is a\n-   MINUS_EXPR, in which case we use PLUS_EXPR since split_tree will already\n-   have taken care of the negations.  */\n+   we build an operation, do it in TYPE and with CODE.  */\n \n static tree\n associate_trees (t1, t2, code, type)\n@@ -977,9 +985,6 @@ associate_trees (t1, t2, code, type)\n   else if (t2 == 0)\n     return t1;\n \n-  if (code == MINUS_EXPR)\n-    code = PLUS_EXPR;\n-\n   /* If either input is CODE, a PLUS_EXPR, or a MINUS_EXPR, don't\n      try to fold this since we will have infinite recursion.  But do\n      deal with any NEGATE_EXPRs.  */\n@@ -3805,8 +3810,8 @@ optimize_minmax_comparison (t)\n    other operations already in T.  WIDE_TYPE, if non-null, is a type that\n    should be used for the computation if wider than our type.\n \n-   For example, if we are dividing (X * 8) + (Y + 16) by 4, we can return\n-   (X * 2) + (Y + 4).  We must, however, be assured that either the original\n+   For example, if we are dividing (X * 8) + (Y * 16) by 4, we can return\n+   (X * 2) + (Y * 4).  We must, however, be assured that either the original\n    expression would not overflow or that overflow is undefined for the type\n    in the language in question.\n \n@@ -5078,24 +5083,68 @@ fold (expr)\n \t  && (! FLOAT_TYPE_P (type)\n \t      || (flag_unsafe_math_optimizations && code == MULT_EXPR)))\n \t{\n-\t  tree var0, con0, lit0, var1, con1, lit1;\n+\t  tree var0, con0, lit0, minus_lit0;\n+\t  tree var1, con1, lit1, minus_lit1;\n \n \t  /* Split both trees into variables, constants, and literals.  Then\n \t     associate each group together, the constants with literals,\n \t     then the result with variables.  This increases the chances of\n \t     literals being recombined later and of generating relocatable\n \t     expressions for the sum of a constant and literal.  */\n-\t  var0 = split_tree (arg0, code, &con0, &lit0, 0);\n-\t  var1 = split_tree (arg1, code, &con1, &lit1, code == MINUS_EXPR);\n+\t  var0 = split_tree (arg0, code, &con0, &lit0, &minus_lit0, 0);\n+\t  var1 = split_tree (arg1, code, &con1, &lit1, &minus_lit1,\n+\t\t\t     code == MINUS_EXPR);\n \n \t  /* Only do something if we found more than two objects.  Otherwise,\n \t     nothing has changed and we risk infinite recursion.  */\n-\t  if (2 < ((var0 != 0) + (var1 != 0) + (con0 != 0) + (con1 != 0)\n-\t\t   + (lit0 != 0) + (lit1 != 0)))\n+\t  if (2 < ((var0 != 0) + (var1 != 0)\n+\t\t   + (con0 != 0) + (con1 != 0)\n+\t\t   + (lit0 != 0) + (lit1 != 0)\n+\t\t   + (minus_lit0 != 0) + (minus_lit1 != 0)))\n \t    {\n+\t      /* Recombine MINUS_EXPR operands by using PLUS_EXPR.  */\n+\t      if (code == MINUS_EXPR)\n+\t\tcode = PLUS_EXPR;\n+\n \t      var0 = associate_trees (var0, var1, code, type);\n \t      con0 = associate_trees (con0, con1, code, type);\n \t      lit0 = associate_trees (lit0, lit1, code, type);\n+\t      minus_lit0 = associate_trees (minus_lit0, minus_lit1, code, type);\n+\n+\t      /* Preserve the MINUS_EXPR if the negative part of the literal is\n+\t\t greater than the positive part.  Otherwise, the multiplicative\n+\t\t folding code (i.e extract_muldiv) may be fooled in case\n+\t\t unsigned constants are substracted, like in the following\n+\t\t example: ((X*2 + 4) - 8U)/2.  */\n+\t      if (minus_lit0 && lit0)\n+\t\t{\n+\t\t  if (tree_int_cst_lt (lit0, minus_lit0))\n+\t\t    {\n+\t\t      minus_lit0 = associate_trees (minus_lit0, lit0,\n+\t\t\t\t\t\t    MINUS_EXPR, type);\n+\t\t      lit0 = 0;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      lit0 = associate_trees (lit0, minus_lit0,\n+\t\t\t\t\t      MINUS_EXPR, type);\n+\t\t      minus_lit0 = 0;\n+\t\t    }\n+\t\t}\n+\t      if (minus_lit0)\n+\t\t{\n+\t\t  if (con0 == 0)\n+\t\t    return convert (type, associate_trees (var0, minus_lit0,\n+\t\t\t\t\t\t\t   MINUS_EXPR, type));\n+\t\t  else\n+\t\t    {\n+\t\t      con0 = associate_trees (con0, minus_lit0,\n+\t\t\t\t\t      MINUS_EXPR, type);\n+\t\t      return convert (type, associate_trees (var0, con0,\n+\t\t\t\t\t\t\t     PLUS_EXPR, type));\n+\t\t    }\n+\t\t}\n+\n \t      con0 = associate_trees (con0, lit0, code, type);\n \t      return convert (type, associate_trees (var0, con0, code, type));\n \t    }"}, {"sha": "5f744b6f94ab415a626cc0d4ff9008fc80b695a7", "filename": "gcc/testsuite/gcc.c-torture/execute/20020423-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff277959486d14a4bd62a0eea2237654fc8fdce/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020423-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff277959486d14a4bd62a0eea2237654fc8fdce/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020423-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20020423-1.c?ref=cff277959486d14a4bd62a0eea2237654fc8fdce", "patch": "@@ -0,0 +1,33 @@\n+/* PR c/5430 */\n+/* Verify that the multiplicative folding code is not fooled\n+   by the mix between signed variables and unsigned constants. */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+int main (void)\n+{\n+  int my_int = 924;\n+  unsigned int result;\n+\n+  result = ((my_int*2 + 4) - 8U) / 2;\n+  if (result != 922U)\n+    abort();\n+         \n+  result = ((my_int*2 - 4U) + 2) / 2;\n+  if (result != 923U)\n+    abort();\n+\n+  result = (((my_int + 2) * 2) - 8U - 4) / 2;\n+  if (result != 920U)\n+    abort();\n+  result = (((my_int + 2) * 2) - (8U + 4)) / 2;\n+  if (result != 920U)\n+    abort();\n+\n+  result = ((my_int*4 + 2U) - 4U) / 2;\n+  if (result != 1847U)\n+    abort();\n+\n+  exit(0);\n+}"}]}