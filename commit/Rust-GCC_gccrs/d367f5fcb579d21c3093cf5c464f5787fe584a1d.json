{"sha": "d367f5fcb579d21c3093cf5c464f5787fe584a1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM2N2Y1ZmNiNTc5ZDIxYzMwOTNjZjVjNDY0ZjU3ODdmZTU4NGExZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-08-18T18:57:18Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-08-18T18:59:09Z"}, "message": "PR middle-end/96665 - memcmp of a constant string not folded\n\nRelated:\nPR middle-end/78257 - missing memcmp optimization with constant arrays\n\ngcc/ChangeLog:\n\n\tPR middle-end/96665\n\tPR middle-end/78257\n\t* expr.c (convert_to_bytes): Replace statically allocated buffer with\n\ta dynamically allocated one of sufficient size.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/96665\n\tPR middle-end/78257\n\t* gcc.dg/memcmp-5.c: New test.", "tree": {"sha": "0d1778f66517b2fb0db3927b124acca6097b5282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d1778f66517b2fb0db3927b124acca6097b5282"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d367f5fcb579d21c3093cf5c464f5787fe584a1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d367f5fcb579d21c3093cf5c464f5787fe584a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d367f5fcb579d21c3093cf5c464f5787fe584a1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d367f5fcb579d21c3093cf5c464f5787fe584a1d/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb04901d14f7749eb949092fd3dfcb6ca1958701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb04901d14f7749eb949092fd3dfcb6ca1958701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb04901d14f7749eb949092fd3dfcb6ca1958701"}], "stats": {"total": 99, "additions": 91, "deletions": 8}, "files": [{"sha": "437faeaba08030f54b26325e0747049f0be164d5", "filename": "gcc/expr.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d367f5fcb579d21c3093cf5c464f5787fe584a1d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d367f5fcb579d21c3093cf5c464f5787fe584a1d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d367f5fcb579d21c3093cf5c464f5787fe584a1d", "patch": "@@ -11683,16 +11683,27 @@ convert_to_bytes (tree type, tree expr, vec<unsigned char> *bytes)\n       return true;\n     }\n \n-  unsigned char charbuf[MAX_BITSIZE_MODE_ANY_MODE / BITS_PER_UNIT];\n-  int len = native_encode_expr (expr, charbuf, sizeof charbuf, 0);\n-  if (len <= 0)\n+  /* Except for RECORD_TYPE which may have an initialized flexible array\n+     member, the size of a type is the same as the size of the initializer\n+     (including any implicitly zeroed out members and padding).  Allocate\n+     just enough for that many bytes.  */\n+  tree expr_size = TYPE_SIZE_UNIT (TREE_TYPE (expr));\n+  if (!expr_size || !tree_fits_uhwi_p (expr_size))\n+    return false;\n+  const unsigned HOST_WIDE_INT expr_bytes = tree_to_uhwi (expr_size);\n+  const unsigned bytes_sofar = bytes->length ();\n+  /* native_encode_expr can convert at most INT_MAX bytes.  vec is limited\n+     to at most UINT_MAX.  */\n+  if (bytes_sofar + expr_bytes > INT_MAX)\n     return false;\n \n-  unsigned n = bytes->length ();\n-  bytes->safe_grow (n + len);\n-  unsigned char *p = bytes->address ();\n-  memcpy (p + n, charbuf, len);\n-  return true;\n+  /* Unlike for RECORD_TYPE, there is no need to clear the memory since\n+     it's completely overwritten by native_encode_expr.  */\n+  bytes->safe_grow (bytes_sofar + expr_bytes);\n+  unsigned char *pnext = bytes->begin () + bytes_sofar;\n+  int nbytes = native_encode_expr (expr, pnext, expr_bytes, 0);\n+  /* NBYTES is zero on failure.  Otherwise it should equal EXPR_BYTES.  */\n+  return (unsigned HOST_WIDE_INT) nbytes == expr_bytes;\n }\n \n /* Return a STRING_CST corresponding to ARG's constant initializer either"}, {"sha": "34bae92f6b0fbb4b882fa282b5b3b0cf7a20dd9b", "filename": "gcc/testsuite/gcc.dg/memcmp-5.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d367f5fcb579d21c3093cf5c464f5787fe584a1d/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d367f5fcb579d21c3093cf5c464f5787fe584a1d/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-5.c?ref=d367f5fcb579d21c3093cf5c464f5787fe584a1d", "patch": "@@ -0,0 +1,72 @@\n+/* PR middle-end/78257 - missing memcmp optimization with constant arrays\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -fdump-tree-optimized\" } */\n+\n+#define A \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" \\\n+          \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" \\\n+          \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" \\\n+          \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" \\\n+          \"0\"\n+\n+const char a257[sizeof A - 1] = A;\n+const char a258[sizeof A] = A;\n+\n+_Static_assert (sizeof A == 258);\n+_Static_assert (sizeof a257 == 257);\n+\n+/* Verify that initializers longer than 256 characters (an internal limit\n+   on the size of a buffer used to store representations in) are handled.  */\n+\n+void eq_256plus (void)\n+{\n+  int n = 0;\n+\n+  n += __builtin_memcmp (a257,       A,       sizeof a257);\n+  n += __builtin_memcmp (a257 +   1, A +   1, sizeof a257 - 1);\n+  n += __builtin_memcmp (a257 +   2, A +   2, sizeof a257 - 2);\n+  n += __builtin_memcmp (a257 + 127, A + 127, sizeof a257 - 127);\n+  n += __builtin_memcmp (a257 + 128, A + 128, sizeof a257 - 128);\n+  n += __builtin_memcmp (a257 + 255, A + 255, 2);\n+  n += __builtin_memcmp (a257 + 256, A + 256, 1);\n+\n+  n += __builtin_memcmp (a258,       A,       sizeof a257);\n+  n += __builtin_memcmp (a258 +   1, A +   1, sizeof a257 - 1);\n+  n += __builtin_memcmp (a258 +   2, A +   2, sizeof a257 - 2);\n+  n += __builtin_memcmp (a258 + 127, A + 127, sizeof a257 - 127);\n+  n += __builtin_memcmp (a258 + 128, A + 128, sizeof a257 - 128);\n+  n += __builtin_memcmp (a258 + 256, A + 256, 2);\n+  n += __builtin_memcmp (a258 + 257, A + 257, 1);\n+\n+  if (n)\n+    __builtin_abort ();\n+}\n+\n+#define X \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" \\\n+          \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" \\\n+          \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" \\\n+          \"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\" \\\n+          \"1\"\n+\n+void lt_256plus (void)\n+{\n+  int n = 0;\n+\n+  n += 0 >  __builtin_memcmp (a257,       X,       sizeof a257);\n+  n += 0 >  __builtin_memcmp (a257 +   1, X +   1, sizeof a257 - 1);\n+  n += 0 >  __builtin_memcmp (a257 +   2, X +   2, sizeof a257 - 2);\n+  n += 0 >  __builtin_memcmp (a257 + 127, X + 127, sizeof a257 - 127);\n+  n += 0 >  __builtin_memcmp (a257 + 128, X + 128, sizeof a257 - 128);\n+  n += 0 >  __builtin_memcmp (a257 + 255, X + 255, 2);\n+  n += 0 >  __builtin_memcmp (a257 + 256, X + 256, 1);\n+\n+  n += 0 >  __builtin_memcmp (a258,       X,       sizeof a258);\n+  n += 0 >  __builtin_memcmp (a258 +   1, X +   1, sizeof a258 - 1);\n+  n += 0 >  __builtin_memcmp (a258 +   2, X +   2, sizeof a258 - 2);\n+  n += 0 >  __builtin_memcmp (a258 + 127, X + 127, sizeof a257 - 127);\n+  n += 0 >  __builtin_memcmp (a258 + 128, X + 128, sizeof a257 - 128);\n+  n += 0 >  __builtin_memcmp (a258 + 256, X + 256, 2);\n+  n += 0 == __builtin_memcmp (a258 + 257, X + 257, 1);\n+\n+  if (n != 14)\n+    __builtin_abort ();\n+}"}]}