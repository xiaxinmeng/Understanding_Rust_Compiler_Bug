{"sha": "75da2103e4fcad4e66ce23240b884ed679993642", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkYTIxMDNlNGZjYWQ0ZTY2Y2UyMzI0MGI4ODRlZDY3OTk5MzY0Mg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-18T08:09:48Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-18T08:09:48Z"}, "message": "InetAddress.java: Reformatted to better match classpath's version.\n\n2003-06-18  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/InetAddress.java:\n\tReformatted to better match classpath's version.\n\t* java/net/URL.java\n\t(equals): Simplified.\n\t* java/net/URLConnection.java\n\t(setDoInput): Revised documentation.\n\t(getDefaultUseCaches): Likewise.\n\t(setRequestProperty): Added @since tag.\n\nFrom-SVN: r68143", "tree": {"sha": "e529fe1e2d5d41a2df816d422b60340be69459ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e529fe1e2d5d41a2df816d422b60340be69459ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75da2103e4fcad4e66ce23240b884ed679993642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75da2103e4fcad4e66ce23240b884ed679993642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75da2103e4fcad4e66ce23240b884ed679993642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75da2103e4fcad4e66ce23240b884ed679993642/comments", "author": null, "committer": null, "parents": [{"sha": "a26574f5bc076a72b29fa9e9b861d9acd7549add", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a26574f5bc076a72b29fa9e9b861d9acd7549add", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a26574f5bc076a72b29fa9e9b861d9acd7549add"}], "stats": {"total": 83, "additions": 64, "deletions": 19}, "files": [{"sha": "03cf46dc43cc561fbc0c918bf19cabff87f67976", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75da2103e4fcad4e66ce23240b884ed679993642/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75da2103e4fcad4e66ce23240b884ed679993642/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=75da2103e4fcad4e66ce23240b884ed679993642", "patch": "@@ -1,3 +1,14 @@\n+2003-06-18  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/InetAddress.java:\n+\tReformatted to better match classpath's version.\n+\t* java/net/URL.java\n+\t(equals): Simplified.\n+\t* java/net/URLConnection.java\n+\t(setDoInput): Revised documentation.\n+\t(getDefaultUseCaches): Likewise.\n+\t(setRequestProperty): Added @since tag.\n+\n 2003-06-17  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/InetSocketAddress.java"}, {"sha": "aafa5622746631b3036d5a1376817433410060cc", "filename": "libjava/java/net/InetAddress.java", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75da2103e4fcad4e66ce23240b884ed679993642/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75da2103e4fcad4e66ce23240b884ed679993642/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=75da2103e4fcad4e66ce23240b884ed679993642", "patch": "@@ -68,19 +68,21 @@\n  */\n public class InetAddress implements Serializable\n {\n+  private static final long serialVersionUID = 3286316764910316507L;\n+  \n   // The Serialized Form specifies that an int 'address' is saved/restored.\n   // This class uses a byte array internally so we'll just do the conversion\n   // at serialization time and leave the rest of the algorithm as is.\n   private int address;\n   transient byte[] addr;\n   String hostName;\n+  \n   // The field 'family' seems to be the AF_ value.\n   // FIXME: Much of the code in the other java.net classes does not make\n   // use of this family field.  A better implementation would be to make\n   // use of getaddrinfo() and have other methods just check the family\n   // field rather than examining the length of the address each time.\n   int family;\n-  private static final long serialVersionUID = 3286316764910316507L;\n \n   /**\n    * Needed for serialization\n@@ -96,8 +98,10 @@ private void readObject(ObjectInputStream ois)\n     ois.defaultReadObject();\n     addr = new byte[4];\n     addr[3] = (byte) address;\n+    \n     for (int i = 2; i >= 0; --i)\n       addr[i] = (byte) (address >>= 8);\n+    \n     // Ignore family from serialized data.  Since the saved address is 32 bits\n     // the deserialized object will have an IPv4 address i.e. AF_INET family.\n     // FIXME: An alternative is to call the aton method on the deserialized\n@@ -112,8 +116,10 @@ private void writeObject(ObjectOutputStream oos) throws IOException\n     // or a 16 byte IPv6 address.\n     int len = addr.length;\n     int i = len - 4;\n+    \n     for (; i < len; i++)\n       address = address << 8 | (((int) addr[i]) & 0xFF);\n+    \n     oos.defaultWriteObject();\n   }\n \n@@ -123,6 +129,7 @@ private void writeObject(ObjectOutputStream oos) throws IOException\n   {\n     addr = address;\n     hostName = hostname;\n+    \n     if (address != null)\n       family = getFamily (address);\n   }\n@@ -135,10 +142,13 @@ private void writeObject(ObjectOutputStream oos) throws IOException\n   public boolean isMulticastAddress ()\n   {\n     int len = addr.length;\n+    \n     if (len == 4)\n       return (addr[0] & 0xF0) == 0xE0;\n+    \n     if (len == 16)\n       return addr[0] == (byte) 0xFF;\n+    \n     return false;\n   }\n \n@@ -199,11 +209,13 @@ public boolean isSiteLocalAddress ()\n     // it says 172.16.0.0 - 172.255.255.255 are site local addresses\n \n     // 172.16.0.0/12\n-    if (addr[0] == 0xAC && (addr[1] & 0xF0) == 0x01)\n+    if (addr [0] == 0xAC\n+        && (addr [1] & 0xF0) == 0x01)\n       return true;\n \n     // 192.168.0.0/16\n-    if (addr[0] == 0xC0 && addr[1] == 0xA8)\n+    if (addr [0] == 0xC0\n+        && addr [1] == 0xA8)\n       return true;\n \n     // XXX: Do we need to check more addresses here ?\n@@ -257,7 +269,7 @@ public boolean isMCLinkLocal ()\n   }\n \n   /**\n-   * Utility reoutine to check if InetAddress is a site local multicast address\n+   * Utility routine to check if InetAddress is a site local multicast address\n    *\n    * @since 1.4\n    */\n@@ -341,8 +353,10 @@ private static InetAddress[] allocArray (int count)\n   private static SecurityException checkConnect (String hostname)\n   {\n     SecurityManager s = System.getSecurityManager();\n+    \n     if (s == null)\n       return null;\n+    \n     try\n       {\n \ts.checkConnect(hostname, -1);\n@@ -415,8 +429,10 @@ public int hashCode()\n     int hash = 0;\n     int len = addr.length;\n     int i = len > 4 ? len - 4 : 0;\n+    \n     for ( ; i < len;  i++)\n       hash = (hash << 8) | (addr[i] & 0xFF);\n+    \n     return hash;\n   }\n \n@@ -425,7 +441,8 @@ public int hashCode()\n    */\n   public boolean equals (Object obj)\n   {\n-    if (obj == null || ! (obj instanceof InetAddress))\n+    if (obj == null\n+        || ! (obj instanceof InetAddress))\n       return false;\n     \n     // \"The Java Class Libraries\" 2nd edition says \"If a machine has\n@@ -436,11 +453,14 @@ public boolean equals (Object obj)\n     // shows that the latter is correct.\n     byte[] addr1 = addr;\n     byte[] addr2 = ((InetAddress) obj).addr;\n+    \n     if (addr1.length != addr2.length)\n       return false;\n+    \n     for (int i = addr1.length;  --i >= 0;  )\n       if (addr1[i] != addr2[i])\n \treturn false;\n+    \n     return true;\n   }\n \n@@ -451,10 +471,12 @@ public String toString()\n   {\n     String result;\n     String address = getHostAddress();\n+    \n     if (hostName != null)\n       result = hostName + \"/\" + address;\n     else\n       result = address;\n+    \n     return result;\n   }\n \n@@ -505,8 +527,10 @@ public static InetAddress getByAddress (String host, byte[] addr)\n     throw new UnknownHostException (\"IP address has illegal length\");\n   }\n   \n-  /** If host is a valid numeric IP address, return the numeric address.\n-   * Otherwise, return null. */\n+  /**\n+   * If host is a valid numeric IP address, return the numeric address.\n+   * Otherwise, return null.\n+   */\n   private static native byte[] aton (String host);\n \n   private static native InetAddress[] lookup (String hostname,\n@@ -523,9 +547,9 @@ private static native InetAddress[] lookup (String hostname,\n   public static InetAddress getByName (String hostname)\n     throws UnknownHostException\n   {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkConnect (hostname, -1);\n+    SecurityManager s = System.getSecurityManager ();\n+    if (s != null)\n+      s.checkConnect (hostname, -1);\n    \n     // Default to current host if necessary\n     if (hostname == null)\n@@ -571,9 +595,9 @@ else if (address.length == 16)\n   public static InetAddress[] getAllByName (String hostname)\n     throws UnknownHostException\n   {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      sm.checkConnect(hostname, -1);\n+    SecurityManager s = System.getSecurityManager ();\n+    if (s != null)\n+      s.checkConnect (hostname, -1);\n \n     // Check if hostname is an IP address\n     byte[] address = aton (hostname);\n@@ -608,12 +632,14 @@ public static InetAddress[] getAllByName (String hostname)\n   public static InetAddress getLocalHost() throws UnknownHostException\n   {\n     SecurityManager s = System.getSecurityManager();\n+    \n     // Experimentation shows that JDK1.2 does cache the result.\n     // However, if there is a security manager, and the cached result\n     // is other than \"localhost\", we need to check again.\n     if (localhost == null\n \t|| (s != null && localhost.addr != localhostAddress))\n       getLocalHost(s);\n+    \n     return localhost;\n   }\n \n@@ -623,7 +649,9 @@ private static synchronized void getLocalHost(SecurityManager s)\n     // Check the localhost cache again, now that we've synchronized.\n     if (s == null && localhost != null)\n       return;\n+    \n     String hostname = getLocalHostname();\n+    \n     if (s != null)\n       {\n \t// \"The Java Class Libraries\" suggests that if the security\n@@ -643,6 +671,7 @@ private static synchronized void getLocalHost(SecurityManager s)\n \t    hostname = null;\n \t  }\n       }\n+    \n     if (hostname != null)\n       {\n \ttry\n@@ -654,6 +683,7 @@ private static synchronized void getLocalHost(SecurityManager s)\n \t  {\n \t  }\n       }\n+    \n     if (localhost == null)\n       localhost = new InetAddress (localhostAddress, \"localhost\");\n   }"}, {"sha": "0a71d7d359d4e381db011bf9846ae2ea953e7753", "filename": "libjava/java/net/URL.java", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75da2103e4fcad4e66ce23240b884ed679993642/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75da2103e4fcad4e66ce23240b884ed679993642/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=75da2103e4fcad4e66ce23240b884ed679993642", "patch": "@@ -418,14 +418,12 @@ else if (context != null)\n    *\n    * @return true if the URL is equal, false otherwise\n    */\n-  public boolean equals(Object obj)\n+  public boolean equals (Object obj)\n   {\n     if (obj == null || ! (obj instanceof URL))\n       return false;\n \n-    URL uObj = (URL) obj;\n-\n-    return handler.equals (this, uObj);\n+    return handler.equals (this, (URL) obj);\n   }\n \n   /**"}, {"sha": "7d2ab44f6c517e8707bc60342acf6589e09eb7c8", "filename": "libjava/java/net/URLConnection.java", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75da2103e4fcad4e66ce23240b884ed679993642/libjava%2Fjava%2Fnet%2FURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75da2103e4fcad4e66ce23240b884ed679993642/libjava%2Fjava%2Fnet%2FURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLConnection.java?ref=75da2103e4fcad4e66ce23240b884ed679993642", "patch": "@@ -509,7 +509,8 @@ public String toString()\n    * to be done for this connection.  This default to true unless the\n    * doOutput flag is set to false, in which case this defaults to false.\n    * \n-   * @param doinput The new value of the doInput field\n+   * @param input <code>true</code> if input is to be done,\n+   * <code>false</code> otherwise\n    *\n    * @exception IllegalStateException If already connected\n    */\n@@ -671,7 +672,10 @@ public long getIfModifiedSince()\n   }\n \n   /**\n-   * Returns the default value of the useCaches field\n+   * Returns the default value used to determine whether or not caching\n+   * of documents will be done when possible.\n+   *\n+   * @return true if caches will be used, false otherwise\n    */\n   public boolean getDefaultUseCaches()\n   {\n@@ -701,6 +705,8 @@ public void setDefaultUseCaches(boolean defaultusecaches)\n    *\n    * @see URLConnection#getRequestProperty(String key)\n    * @see URLConnection#addRequestProperty(String key, String value)\n+   * \n+   * @since 1.4\n    */\n   public void setRequestProperty(String key, String value)\n   {"}]}