{"sha": "a3935ffcb75885f82b3034c8b45bc54b14b49cff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM5MzVmZmNiNzU4ODVmODJiMzAzNGM4YjQ1YmM1NGIxNGI0OWNmZg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-04-04T18:35:13Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-04-04T18:35:13Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-04-04  Tobias Burnus  <burnus@net-b.de>\n            Mikael Morin  <mikael.morin@sfr.fr>\n\n        PR fortran/18918\n        * check.c (is_coarray): Update - because of DIMEN_THIS_IMAGE.\n        * expr.c (gfc_is_coindexed): Ditto.\n        * gfortran.h (gfc_array_ref_dimen_type): Add DIMEN_THIS_IMAGE.\n        * interface.c (compare_parameter): Use gfc_expr_attr and\n        gfc_is_coindexed.\n        * resolve.c (check_dimension, compare_spec_to_ref,\n        resolve_allocate_expr, check_data_variable): Update for\n        DIMEN_THIS_IMAGE.\n        * simplify.c (gfc_simplify_lcobound, gfc_simplify_this_image,\n        gfc_simplify_ucobound): Allow non-constant bounds.\n        * trans-array.c (gfc_set_loop_bounds_from_array_spec,\n        gfc_trans_create_temp_array, gfc_trans_constant_array_constructor,\n        gfc_set_vector_loop_bounds, gfc_conv_array_index_offset,\n        gfc_start_scalarized_body, gfc_trans_scalarizing_loops,\n        gfc_trans_scalarized_loop_boundary, gfc_conv_section_startstride,\n        gfc_conv_ss_startstride, gfc_conv_loop_setup,\n        gfc_trans_array_bounds, gfc_conv_expr_descriptor,\n        gfc_walk_variable_expr): Handle codimen.\n        * trans-decl.c (gfc_build_qualified_array): Save cobounds.\n        * trans-intrinsic.c (gfc_conv_intrinsic_bound): Use arg2.\n        (conv_intrinsic_cobound): New function.\n        (gfc_conv_intrinsic_function): Call it.\n        (gfc_walk_intrinsic_function, gfc_add_intrinsic_ss_code): Handle\n        ucobound, lcobound, this_image.\n        * fortran/trans-types.c (gfc_build_array_type): Save cobounds.\n        (gfc_get_dtype): Honour corank.\n        (gfc_get_nodesc_array_type): Save corank and codimensions.\n        (gfc_get_array_type_bounds): Save cobound.\n        * fortran/trans.h (gfc_ss_info,gfc_loopinfo): Add codimen item.\n        (gfc_array_kind): Add corank item.\n        (GFC_TYPE_ARRAY_CORANK): New macro.\n\n2011-04-04  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_10.f90: Add coarray descriptor diagnostic\n        check.\n        * gfortran.dg/coarray_13.f90: Add checks for run-time cobounds.\n        * gfortran.dg/coarray_15.f90: New.\n\n\nCo-Authored-By: Mikael Morin <mikael.morin@sfr.fr>\n\nFrom-SVN: r171949", "tree": {"sha": "9abcba3bcc381b60bb846f373262fa21db1ff878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9abcba3bcc381b60bb846f373262fa21db1ff878"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3935ffcb75885f82b3034c8b45bc54b14b49cff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3935ffcb75885f82b3034c8b45bc54b14b49cff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3935ffcb75885f82b3034c8b45bc54b14b49cff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3935ffcb75885f82b3034c8b45bc54b14b49cff/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b77f9eab26590857d67853ab3edd5e7171315e72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77f9eab26590857d67853ab3edd5e7171315e72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b77f9eab26590857d67853ab3edd5e7171315e72"}], "stats": {"total": 841, "additions": 705, "deletions": 136}, "files": [{"sha": "f9513dbf650f4997e922fafef5679cde8b66b169", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -1,3 +1,39 @@\n+2011-04-04  Tobias Burnus  <burnus@net-b.de>\n+\t    Mikael Morin  <mikael.morin@sfr.fr>\n+\n+\tPR fortran/18918\n+\t* check.c (is_coarray): Update - because of DIMEN_THIS_IMAGE.\n+\t* expr.c (gfc_is_coindexed): Ditto.\n+\t* gfortran.h (gfc_array_ref_dimen_type): Add DIMEN_THIS_IMAGE.\n+\t* interface.c (compare_parameter): Use gfc_expr_attr and\n+\tgfc_is_coindexed.\n+\t* resolve.c (check_dimension, compare_spec_to_ref,\n+\tresolve_allocate_expr, check_data_variable): Update for\n+\tDIMEN_THIS_IMAGE.\n+\t* simplify.c (gfc_simplify_lcobound, gfc_simplify_this_image,\n+\tgfc_simplify_ucobound): Allow non-constant bounds.\n+\t* trans-array.c (gfc_set_loop_bounds_from_array_spec,\n+\tgfc_trans_create_temp_array, gfc_trans_constant_array_constructor,\n+\tgfc_set_vector_loop_bounds, gfc_conv_array_index_offset,\n+\tgfc_start_scalarized_body, gfc_trans_scalarizing_loops,\n+\tgfc_trans_scalarized_loop_boundary, gfc_conv_section_startstride,\n+\tgfc_conv_ss_startstride, gfc_conv_loop_setup,\n+\tgfc_trans_array_bounds, gfc_conv_expr_descriptor,\n+\tgfc_walk_variable_expr): Handle codimen.\n+\t* trans-decl.c (gfc_build_qualified_array): Save cobounds.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_bound): Use arg2.\n+\t(conv_intrinsic_cobound): New function.\n+\t(gfc_conv_intrinsic_function): Call it.\n+\t(gfc_walk_intrinsic_function, gfc_add_intrinsic_ss_code): Handle\n+\tucobound, lcobound, this_image.\n+\t* fortran/trans-types.c (gfc_build_array_type): Save cobounds.\n+\t(gfc_get_dtype): Honour corank.\n+\t(gfc_get_nodesc_array_type): Save corank and codimensions.\n+\t(gfc_get_array_type_bounds): Save cobound.\n+\t* fortran/trans.h (gfc_ss_info,gfc_loopinfo): Add codimen item.\n+\t(gfc_array_kind): Add corank item.\n+\t(GFC_TYPE_ARRAY_CORANK): New macro.\n+\n 2011-04-03  Kai Tietz  <ktietz@redhat.com>\n \n \tPR middle-end/48422"}, {"sha": "bb56122137e44f0f042def053be36cb16b601606", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -219,9 +219,15 @@ is_coarray (gfc_expr *e)\n     {\n       if (ref->type == REF_COMPONENT)\n \tcoarray = ref->u.c.component->attr.codimension;\n-      else if (ref->type != REF_ARRAY || ref->u.ar.dimen != 0\n-\t       || ref->u.ar.codimen != 0) \n+      else if (ref->type != REF_ARRAY || ref->u.ar.dimen != 0)\n \tcoarray = false;\n+      else if (ref->type == REF_ARRAY && ref->u.ar.codimen != 0) \n+\t{\n+\t  int n;\n+\t  for (n = 0; n < ref->u.ar.codimen; n++)\n+\t    if (ref->u.ar.dimen_type[n] != DIMEN_THIS_IMAGE)\n+\t      coarray = false;\n+\t}\n     }\n \n   return coarray;"}, {"sha": "287a2a24e3c4cbee6681ae4b772daff1bc401b18", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -4129,7 +4129,12 @@ gfc_is_coindexed (gfc_expr *e)\n \n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n-      return true;\n+      {\n+\tint n;\n+\tfor (n = ref->u.ar.dimen; n < ref->u.ar.dimen + ref->u.ar.codimen; n++)\n+\t  if (ref->u.ar.dimen_type[n] != DIMEN_THIS_IMAGE)\n+\t    return true;\n+      }\n \n   return false;\n }"}, {"sha": "495923a2466aa804e3dffcf6ccddcc93e55f5bf5", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -1486,7 +1486,7 @@ extern gfc_interface_info current_interface;\n \n enum gfc_array_ref_dimen_type\n {\n-  DIMEN_ELEMENT = 1, DIMEN_RANGE, DIMEN_VECTOR, DIMEN_STAR, DIMEN_UNKNOWN\n+  DIMEN_ELEMENT = 1, DIMEN_RANGE, DIMEN_VECTOR, DIMEN_STAR, DIMEN_THIS_IMAGE, DIMEN_UNKNOWN\n };\n \n typedef struct gfc_array_ref"}, {"sha": "00fd24ac247bf4d0868d52a7fb7ae0da1b9b5772", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -1564,24 +1564,24 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       gfc_ref *last = NULL;\n \n       if (actual->expr_type != EXPR_VARIABLE\n-\t  || (actual->ref == NULL\n-\t      && !actual->symtree->n.sym->attr.codimension))\n+\t  || !gfc_expr_attr (actual).codimension)\n \t{\n \t  if (where)\n \t    gfc_error (\"Actual argument to '%s' at %L must be a coarray\",\n \t\t       formal->name, &actual->where);\n \t  return 0;\n \t}\n \n+      if (gfc_is_coindexed (actual))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument to '%s' at %L must be a coarray \"\n+\t\t       \"and not coindexed\", formal->name, &actual->where);\n+\t  return 0;\n+\t}\n+\n       for (ref = actual->ref; ref; ref = ref->next)\n \t{\n-\t  if (ref->type == REF_ARRAY && ref->u.ar.codimen != 0)\n-\t    {\n-\t      if (where)\n-\t\tgfc_error (\"Actual argument to '%s' at %L must be a coarray \"\n-\t\t\t   \"and not coindexed\", formal->name, &ref->u.ar.where);\n-\t      return 0;\n-\t    }\n \t  if (ref->type == REF_ARRAY && ref->u.ar.as->corank\n \t      && ref->u.ar.type != AR_FULL && ref->u.ar.dimen != 0)\n \t    {\n@@ -1595,14 +1595,6 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t    last = ref;\n \t}\n \n-      if (last && !last->u.c.component->attr.codimension)\n-      \t{\n-\t  if (where)\n-\t    gfc_error (\"Actual argument to '%s' at %L must be a coarray\",\n-\t\t       formal->name, &actual->where);\n-\t  return 0;\n-\t}\n-\n       /* F2008, 12.5.2.6.  */\n       if (formal->attr.allocatable &&\n \t  ((last && last->u.c.component->as->corank != formal->as->corank)"}, {"sha": "01999e5f250846573d460c1d2a573346c895083e", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -4157,6 +4157,7 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n   switch (ar->dimen_type[i])\n     {\n     case DIMEN_VECTOR:\n+    case DIMEN_THIS_IMAGE:\n       break;\n \n     case DIMEN_STAR:\n@@ -4324,7 +4325,8 @@ compare_spec_to_ref (gfc_array_ref *ar)\n   if (ar->codimen != 0)\n     for (i = as->rank; i < as->rank + as->corank; i++)\n       {\n-\tif (ar->dimen_type[i] != DIMEN_ELEMENT && !ar->in_allocate)\n+\tif (ar->dimen_type[i] != DIMEN_ELEMENT && !ar->in_allocate\n+\t    && ar->dimen_type[i] != DIMEN_THIS_IMAGE)\n \t  {\n \t    gfc_error (\"Coindex of codimension %d must be a scalar at %L\",\n \t\t       i + 1 - as->rank, &ar->where);\n@@ -4334,6 +4336,14 @@ compare_spec_to_ref (gfc_array_ref *ar)\n \t  return FAILURE;\n       }\n \n+  if (as->corank && ar->codimen == 0)\n+    {\n+      int n;\n+      ar->codimen = as->corank;\n+      for (n = ar->dimen; n < ar->dimen + ar->codimen; n++)\n+\tar->dimen_type[n] = DIMEN_THIS_IMAGE;\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -6848,12 +6858,14 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \n   ar = &ref2->u.ar;\n \n-  if (codimension && ar->codimen == 0)\n-    {\n-      gfc_error (\"Coarray specification required in ALLOCATE statement \"\n-\t\t \"at %L\", &e->where);\n-      goto failure;\n-    }\n+  if (codimension)\n+    for (i = ar->dimen; i < ar->dimen + ar->codimen; i++)\n+      if (ar->dimen_type[i] == DIMEN_THIS_IMAGE)\n+\t{\n+\t  gfc_error (\"Coarray specification required in ALLOCATE statement \"\n+\t\t     \"at %L\", &e->where);\n+\t  goto failure;\n+\t}\n \n   for (i = 0; i < ar->dimen; i++)\n     {\n@@ -6876,6 +6888,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \tcase DIMEN_UNKNOWN:\n \tcase DIMEN_VECTOR:\n \tcase DIMEN_STAR:\n+\tcase DIMEN_THIS_IMAGE:\n \t  gfc_error (\"Bad array specification in ALLOCATE statement at %L\",\n \t\t     &e->where);\n \t  goto failure;\n@@ -12501,18 +12514,18 @@ check_data_variable (gfc_data_variable *var, locus *where)\n \n   has_pointer = sym->attr.pointer;\n \n+  if (gfc_is_coindexed (e))\n+    {\n+      gfc_error (\"DATA element '%s' at %L cannot have a coindex\", sym->name,\n+\t\t where);\n+      return FAILURE;\n+    }\n+\n   for (ref = e->ref; ref; ref = ref->next)\n     {\n       if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)\n \thas_pointer = 1;\n \n-      if (ref->type == REF_ARRAY && ref->u.ar.codimen)\n-\t{\n-\t  gfc_error (\"DATA element '%s' at %L cannot have a coindex\",\n-\t\t     sym->name, where);\n-\t  return FAILURE;\n-\t}\n-\n       if (has_pointer\n \t    && ref->type == REF_ARRAY\n \t    && ref->u.ar.type != AR_FULL)"}, {"sha": "2a994454b059a64970cde058d68fc52de7ed83b5", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -3632,16 +3632,7 @@ gfc_simplify_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n gfc_expr *\n gfc_simplify_lcobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n-  gfc_expr *e;\n-  /* return simplify_cobound (array, dim, kind, 0);*/\n-\n-  e = simplify_cobound (array, dim, kind, 0);\n-  if (e != NULL)\n-    return e;\n-\n-  gfc_error (\"Not yet implemented: LCOBOUND for coarray with non-constant \"\n-\t     \"cobounds at %L\", &array->where);\n-  return &gfc_bad_expr;\n+  return simplify_cobound (array, dim, kind, 0);\n }\n \n gfc_expr *\n@@ -6338,7 +6329,7 @@ gfc_simplify_this_image (gfc_expr *coarray, gfc_expr *dim)\n       as = ref->u.ar.as;\n \n   if (as->type == AS_DEFERRED)\n-    goto not_implemented; /* return NULL;*/\n+    return NULL;\n \n   if (dim == NULL)\n     {\n@@ -6357,8 +6348,7 @@ gfc_simplify_this_image (gfc_expr *coarray, gfc_expr *dim)\n \n \t      for (j = 0; j < d; j++)\n \t\tgfc_free_expr (bounds[j]);\n-\t      if (bounds[d] == NULL)\n-\t\tgoto not_implemented;\n+\n \t      return bounds[d];\n \t    }\n \t}\n@@ -6383,10 +6373,9 @@ gfc_simplify_this_image (gfc_expr *coarray, gfc_expr *dim)\n     }\n   else\n     {\n-      gfc_expr *e;\n       /* A DIM argument is specified.  */\n       if (dim->expr_type != EXPR_CONSTANT)\n-\tgoto not_implemented; /*return NULL;*/\n+\treturn NULL;\n \n       d = mpz_get_si (dim->value.integer);\n \n@@ -6396,18 +6385,9 @@ gfc_simplify_this_image (gfc_expr *coarray, gfc_expr *dim)\n \t  return &gfc_bad_expr;\n \t}\n \n-      /*return simplify_bound_dim (coarray, NULL, d + as->rank, 0, as, NULL, true);*/\n-      e = simplify_bound_dim (coarray, NULL, d + as->rank, 0, as, NULL, true);\n-      if (e != NULL)\n-\treturn e;\n-      else\n-\tgoto not_implemented;\n+      return simplify_bound_dim (coarray, NULL, d + as->rank, 0, as, NULL,\n+\t\t\t\t true);\n    }\n-\n-not_implemented:\n-  gfc_error (\"Not yet implemented: THIS_IMAGE for coarray with non-constant \"\n-\t     \"cobounds at %L\", &coarray->where);\n-  return &gfc_bad_expr;\n }\n \n \n@@ -6420,16 +6400,7 @@ gfc_simplify_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n gfc_expr *\n gfc_simplify_ucobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n-  gfc_expr *e;\n-  /* return simplify_cobound (array, dim, kind, 1);*/\n-\n-  e = simplify_cobound (array, dim, kind, 1);\n-  if (e != NULL)\n-    return e;\n-\n-  gfc_error (\"Not yet implemented: UCOBOUND for coarray with non-constant \"\n-\t     \"cobounds at %L\", &array->where);\n-  return &gfc_bad_expr;\n+  return simplify_cobound (array, dim, kind, 1);\n }\n \n "}, {"sha": "0046d0ac10334f5db25cd35f5469f7e47debbdb0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 154, "deletions": 52, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -562,7 +562,7 @@ gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping * mapping,\n   tree tmp;\n \n   if (as && as->type == AS_EXPLICIT)\n-    for (n = 0; n < se->loop->dimen; n++)\n+    for (n = 0; n < se->loop->dimen + se->loop->codimen; n++)\n       {\n \tdim = se->ss->data.info.dim[n];\n \tgcc_assert (dim < as->rank);\n@@ -576,18 +576,22 @@ gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping * mapping,\n \t    gfc_add_block_to_block (&se->post, &tmpse.post);\n \t    lower = fold_convert (gfc_array_index_type, tmpse.expr);\n \n-\t    /* ...and the upper bound.  */\n-\t    gfc_init_se (&tmpse, NULL);\n-\t    gfc_apply_interface_mapping (mapping, &tmpse, as->upper[dim]);\n-\t    gfc_add_block_to_block (&se->pre, &tmpse.pre);\n-\t    gfc_add_block_to_block (&se->post, &tmpse.post);\n-\t    upper = fold_convert (gfc_array_index_type, tmpse.expr);\n-\n-\t    /* Set the upper bound of the loop to UPPER - LOWER.  */\n-\t    tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t   gfc_array_index_type, upper, lower);\n-\t    tmp = gfc_evaluate_now (tmp, &se->pre);\n-\t    se->loop->to[n] = tmp;\n+\t    if (se->loop->codimen == 0\n+\t\t|| n < se->loop->dimen + se->loop->codimen - 1)\n+\t      {\n+\t\t/* ...and the upper bound.  */\n+\t\tgfc_init_se (&tmpse, NULL);\n+\t\tgfc_apply_interface_mapping (mapping, &tmpse, as->upper[dim]);\n+\t\tgfc_add_block_to_block (&se->pre, &tmpse.pre);\n+\t\tgfc_add_block_to_block (&se->post, &tmpse.post);\n+\t\tupper = fold_convert (gfc_array_index_type, tmpse.expr);\n+\n+\t\t/* Set the upper bound of the loop to UPPER - LOWER.  */\n+\t\ttmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t       gfc_array_index_type, upper, lower);\n+\t\ttmp = gfc_evaluate_now (tmp, &se->pre);\n+\t\tse->loop->to[n] = tmp;\n+\t      }\n \t  }\n       }\n }\n@@ -885,6 +889,13 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \t\t\t      size, tmp);\n       size = gfc_evaluate_now (size, pre);\n     }\n+  for (n = info->dimen; n < info->dimen + info->codimen; n++)\n+    {\n+      gfc_conv_descriptor_lbound_set (pre, desc, gfc_rank_cst[n],\n+                                      gfc_index_zero_node);\n+      if (n < info->dimen + info->codimen - 1)\n+\tgfc_conv_descriptor_ubound_set (pre, desc, gfc_rank_cst[n], loop->to[n]);\n+    }\n \n   /* Get the size of the array.  */\n \n@@ -1777,7 +1788,7 @@ gfc_trans_constant_array_constructor (gfc_loopinfo * loop,\n   info->data = gfc_build_addr_expr (NULL_TREE, tmp);\n   info->offset = gfc_index_zero_node;\n \n-  for (i = 0; i < info->dimen; i++)\n+  for (i = 0; i < info->dimen + info->codimen; i++)\n     {\n       info->delta[i] = gfc_index_zero_node;\n       info->start[i] = gfc_index_zero_node;\n@@ -2018,7 +2029,7 @@ gfc_set_vector_loop_bounds (gfc_loopinfo * loop, gfc_ss_info * info)\n   int n;\n   int dim;\n \n-  for (n = 0; n < loop->dimen; n++)\n+  for (n = 0; n < loop->dimen + loop->codimen; n++)\n     {\n       dim = info->dim[n];\n       if (info->ref->u.ar.dimen_type[dim] == DIMEN_VECTOR\n@@ -2452,6 +2463,9 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n       gcc_assert (ar->type != AR_ELEMENT);\n       switch (ar->dimen_type[dim])\n \t{\n+\tcase DIMEN_THIS_IMAGE:\n+\t  gcc_unreachable ();\n+\t  break;\n \tcase DIMEN_ELEMENT:\n \t  /* Elemental dimension.  */\n \t  gcc_assert (info->subscript[dim]\n@@ -2813,7 +2827,7 @@ gfc_start_scalarized_body (gfc_loopinfo * loop, stmtblock_t * pbody)\n \n   gcc_assert (!loop->array_parameter);\n \n-  for (dim = loop->dimen - 1; dim >= 0; dim--)\n+  for (dim = loop->dimen + loop->codimen - 1; dim >= 0; dim--)\n     {\n       n = loop->order[dim];\n \n@@ -2967,7 +2981,7 @@ gfc_trans_scalarizing_loops (gfc_loopinfo * loop, stmtblock_t * body)\n \n   pblock = body;\n   /* Generate the loops.  */\n-  for (dim = 0; dim < loop->dimen; dim++)\n+  for (dim = 0; dim < loop->dimen + loop->codimen; dim++)\n     {\n       n = loop->order[dim];\n       gfc_trans_scalarized_loop_end (loop, n, pblock);\n@@ -3043,11 +3057,12 @@ gfc_trans_scalarized_loop_boundary (gfc_loopinfo * loop, stmtblock_t * body)\n /* Calculate the lower bound of an array section.  */\n \n static void\n-gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n+gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim,\n+\t\t\t      bool coarray, bool coarray_last)\n {\n   gfc_expr *start;\n   gfc_expr *end;\n-  gfc_expr *stride;\n+  gfc_expr *stride = NULL;\n   tree desc;\n   gfc_se se;\n   gfc_ss_info *info;\n@@ -3060,16 +3075,18 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n     {\n       /* We use a zero-based index to access the vector.  */\n       info->start[dim] = gfc_index_zero_node;\n-      info->stride[dim] = gfc_index_one_node;\n       info->end[dim] = NULL;\n+      if (!coarray)\n+\tinfo->stride[dim] = gfc_index_one_node;\n       return;\n     }\n \n   gcc_assert (info->ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n   desc = info->descriptor;\n   start = info->ref->u.ar.start[dim];\n   end = info->ref->u.ar.end[dim];\n-  stride = info->ref->u.ar.stride[dim];\n+  if (!coarray)\n+    stride = info->ref->u.ar.stride[dim];\n \n   /* Calculate the start of the range.  For vector subscripts this will\n      be the range of the vector.  */\n@@ -3091,25 +3108,28 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int dim)\n   /* Similarly calculate the end.  Although this is not used in the\n      scalarizer, it is needed when checking bounds and where the end\n      is an expression with side-effects.  */\n-  if (end)\n+  if (!coarray_last)\n     {\n-      /* Specified section start.  */\n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_type (&se, end, gfc_array_index_type);\n-      gfc_add_block_to_block (&loop->pre, &se.pre);\n-      info->end[dim] = se.expr;\n-    }\n-  else\n-    {\n-      /* No upper bound specified so use the bound of the array.  */\n-      info->end[dim] = gfc_conv_array_ubound (desc, dim);\n+      if (end)\n+\t{\n+\t  /* Specified section start.  */\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_type (&se, end, gfc_array_index_type);\n+\t  gfc_add_block_to_block (&loop->pre, &se.pre);\n+\t  info->end[dim] = se.expr;\n+\t}\n+      else\n+\t{\n+\t  /* No upper bound specified so use the bound of the array.  */\n+\t  info->end[dim] = gfc_conv_array_ubound (desc, dim);\n+\t}\n+      info->end[dim] = gfc_evaluate_now (info->end[dim], &loop->pre);\n     }\n-  info->end[dim] = gfc_evaluate_now (info->end[dim], &loop->pre);\n \n   /* Calculate the stride.  */\n-  if (stride == NULL)\n+  if (!coarray && stride == NULL)\n     info->stride[dim] = gfc_index_one_node;\n-  else\n+  else if (!coarray)\n     {\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_type (&se, stride, gfc_array_index_type);\n@@ -3143,6 +3163,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \tcase GFC_SS_FUNCTION:\n \tcase GFC_SS_COMPONENT:\n \t  loop->dimen = ss->data.info.dimen;\n+\t  loop->codimen = ss->data.info.codimen;\n \t  break;\n \n \t/* As usual, lbound and ubound are exceptions!.  */\n@@ -3152,6 +3173,15 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    case GFC_ISYM_LBOUND:\n \t    case GFC_ISYM_UBOUND:\n \t      loop->dimen = ss->data.info.dimen;\n+\t      loop->codimen = 0;\n+\t      break;\n+\n+\t    case GFC_ISYM_LCOBOUND:\n+\t    case GFC_ISYM_UCOBOUND:\n+\t    case GFC_ISYM_THIS_IMAGE:\n+\t      loop->dimen = ss->data.info.dimen;\n+\t      loop->codimen = ss->data.info.codimen;\n+\t      break;\n \n \t    default:\n \t      break;\n@@ -3164,7 +3194,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \n   /* We should have determined the rank of the expression by now.  If\n      not, that's bad news.  */\n-  gcc_assert (loop->dimen != 0);\n+  gcc_assert (loop->dimen + loop->codimen != 0);\n \n   /* Loop over all the SS in the chain.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n@@ -3179,7 +3209,14 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  gfc_conv_ss_descriptor (&loop->pre, ss, !loop->array_parameter);\n \n \t  for (n = 0; n < ss->data.info.dimen; n++)\n-\t    gfc_conv_section_startstride (loop, ss, ss->data.info.dim[n]);\n+\t    gfc_conv_section_startstride (loop, ss, ss->data.info.dim[n],\n+\t\t\t\t\t  false, false);\n+\t  for (n = ss->data.info.dimen;\n+\t       n < ss->data.info.dimen + ss->data.info.codimen; n++)\n+\t    gfc_conv_section_startstride (loop, ss, ss->data.info.dim[n], true,\n+\t\t\t\t\t  n == ss->data.info.dimen\n+\t\t\t\t\t       + ss->data.info.codimen -1);\n+\n \t  break;\n \n \tcase GFC_SS_INTRINSIC:\n@@ -3188,7 +3225,11 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t    /* Fall through to supply start and stride.  */\n \t    case GFC_ISYM_LBOUND:\n \t    case GFC_ISYM_UBOUND:\n+\t    case GFC_ISYM_LCOBOUND:\n+\t    case GFC_ISYM_UCOBOUND:\n+\t    case GFC_ISYM_THIS_IMAGE:\n \t      break;\n+\n \t    default:\n \t      continue;\n \t    }\n@@ -3697,6 +3738,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n       loop->temp_ss->data.temp.type = base_type;\n       loop->temp_ss->string_length = dest->string_length;\n       loop->temp_ss->data.temp.dimen = loop->dimen;\n+      loop->temp_ss->data.temp.codimen = loop->codimen;\n       loop->temp_ss->next = gfc_ss_terminator;\n       gfc_add_ss_to_loop (loop, loop->temp_ss);\n     }\n@@ -3725,7 +3767,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n   mpz_t i;\n \n   mpz_init (i);\n-  for (n = 0; n < loop->dimen; n++)\n+  for (n = 0; n < loop->dimen + loop->codimen; n++)\n     {\n       loopspec[n] = NULL;\n       dynamic[n] = false;\n@@ -3807,7 +3849,8 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t     known lower bound\n \t     known upper bound\n \t   */\n-\t  else if (loopspec[n]->type == GFC_SS_CONSTRUCTOR && dynamic[n])\n+\t  else if ((loopspec[n]->type == GFC_SS_CONSTRUCTOR && dynamic[n])\n+\t\t   || n >= loop->dimen)\n \t    loopspec[n] = ss;\n \t  else if (integer_onep (info->stride[dim])\n \t\t   && !integer_onep (specinfo->stride[spec_dim]))\n@@ -3833,7 +3876,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \n       /* Set the extents of this range.  */\n       cshape = loopspec[n]->shape;\n-      if (cshape && INTEGER_CST_P (info->start[dim])\n+      if (n < loop->dimen && cshape && INTEGER_CST_P (info->start[dim])\n \t  && INTEGER_CST_P (info->stride[dim]))\n \t{\n \t  loop->from[n] = info->start[dim];\n@@ -3877,9 +3920,9 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t}\n \n       /* Transform everything so we have a simple incrementing variable.  */\n-      if (integer_onep (info->stride[dim]))\n+      if (n < loop->dimen && integer_onep (info->stride[dim]))\n \tinfo->delta[dim] = gfc_index_zero_node;\n-      else\n+      else if (n < loop->dimen)\n \t{\n \t  /* Set the delta for this section.  */\n \t  info->delta[dim] = gfc_evaluate_now (loop->from[n], &loop->pre);\n@@ -4663,7 +4706,26 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \n       size = stride;\n     }\n-\n+  for (dim = as->rank; dim < as->rank + as->corank; dim++)\n+    {\n+      /* Evaluate non-constant array bound expressions.  */\n+      lbound = GFC_TYPE_ARRAY_LBOUND (type, dim);\n+      if (as->lower[dim] && !INTEGER_CST_P (lbound))\n+        {\n+          gfc_init_se (&se, NULL);\n+          gfc_conv_expr_type (&se, as->lower[dim], gfc_array_index_type);\n+          gfc_add_block_to_block (pblock, &se.pre);\n+          gfc_add_modify (pblock, lbound, se.expr);\n+        }\n+      ubound = GFC_TYPE_ARRAY_UBOUND (type, dim);\n+      if (as->upper[dim] && !INTEGER_CST_P (ubound))\n+        {\n+          gfc_init_se (&se, NULL);\n+          gfc_conv_expr_type (&se, as->upper[dim], gfc_array_index_type);\n+          gfc_add_block_to_block (pblock, &se.pre);\n+          gfc_add_modify (pblock, ubound, se.expr);\n+        }\n+    }\n   gfc_trans_vla_type_sizes (sym, pblock);\n \n   *poffset = offset;\n@@ -5626,6 +5688,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       se->string_length = loop.temp_ss->string_length;\n       loop.temp_ss->data.temp.dimen = loop.dimen;\n+      loop.temp_ss->data.temp.codimen = loop.codimen;\n       gfc_add_ss_to_loop (&loop, loop.temp_ss);\n     }\n \n@@ -5689,7 +5752,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t limits will be the limits of the section.\n \t A function may decide to repack the array to speed up access, but\n \t we're not bothered about that here.  */\n-      int dim, ndim;\n+      int dim, ndim, codim;\n       tree parm;\n       tree parmtype;\n       tree stride;\n@@ -5712,8 +5775,9 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t{\n \t  /* Otherwise make a new one.  */\n \t  parmtype = gfc_get_element_type (TREE_TYPE (desc));\n-\t  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen, 0,\n-\t\t\t\t\t\tloop.from, loop.to, 0,\n+\t  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen,\n+\t\t\t\t\t\tloop.codimen, loop.from,\n+\t\t\t\t\t\tloop.to, 0,\n \t\t\t\t\t\tGFC_ARRAY_UNKNOWN, false);\n \t  parm = gfc_create_var (parmtype, \"parm\");\n \t}\n@@ -5744,6 +5808,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \tbase = NULL_TREE;\n \n       ndim = info->ref ? info->ref->u.ar.dimen : info->dimen;\n+      codim = info->codimen;\n       for (n = 0; n < ndim; n++)\n \t{\n \t  stride = gfc_conv_array_stride (desc, n);\n@@ -5845,6 +5910,26 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t\t\t\t\t  gfc_rank_cst[dim], stride);\n \t}\n \n+      for (n = ndim; n < ndim + codim; n++)\n+\t{\n+\t  /* look for the corresponding scalarizer dimension: dim.  */\n+\t  for (dim = 0; dim < ndim + codim; dim++)\n+\t    if (info->dim[dim] == n)\n+\t      break;\n+\n+\t  /* loop exited early: the DIM being looked for has been found.  */\n+\t  gcc_assert (dim < ndim + codim);\n+\n+\t  from = loop.from[dim];\n+\t  to = loop.to[dim];\n+\t  gfc_conv_descriptor_lbound_set (&loop.pre, parm,\n+\t\t\t\t\t  gfc_rank_cst[dim], from);\n+\t  if (n < ndim + codim - 1)\n+\t    gfc_conv_descriptor_ubound_set (&loop.pre, parm,\n+\t\t\t\t\t    gfc_rank_cst[dim], to);\n+\t  dim++;\n+\t}\n+\n       if (se->data_not_needed)\n \tgfc_conv_descriptor_data_set (&loop.pre, parm,\n \t\t\t\t      gfc_index_zero_node);\n@@ -7311,7 +7396,7 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n       switch (ar->type)\n \t{\n \tcase AR_ELEMENT:\n-\t  for (n = 0; n < ar->dimen; n++)\n+\t  for (n = 0; n < ar->dimen + ar->codimen; n++)\n \t    {\n \t      newss = gfc_get_ss ();\n \t      newss->type = GFC_SS_SCALAR;\n@@ -7327,11 +7412,13 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t  newss->expr = expr;\n \t  newss->next = ss;\n \t  newss->data.info.dimen = ar->as->rank;\n+\t  newss->data.info.codimen = 0;\n \t  newss->data.info.ref = ref;\n \n \t  /* Make sure array is the same as array(:,:), this way\n \t     we don't need to special case all the time.  */\n \t  ar->dimen = ar->as->rank;\n+\t  ar->codimen = 0;\n \t  for (n = 0; n < ar->dimen; n++)\n \t    {\n \t      newss->data.info.dim[n] = n;\n@@ -7341,6 +7428,14 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t      gcc_assert (ar->end[n] == NULL);\n \t      gcc_assert (ar->stride[n] == NULL);\n \t    }\n+\t  for (n = ar->dimen; n < ar->dimen + ar->as->corank; n++)\n+\t    {\n+\t      newss->data.info.dim[n] = n;\n+\t      ar->dimen_type[n] = DIMEN_RANGE;\n+\n+\t      gcc_assert (ar->start[n] == NULL);\n+\t      gcc_assert (ar->end[n] == NULL);\n+\t    }\n \t  ss = newss;\n \t  break;\n \n@@ -7350,15 +7445,18 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t  newss->expr = expr;\n \t  newss->next = ss;\n \t  newss->data.info.dimen = 0;\n+\t  newss->data.info.codimen = 0;\n \t  newss->data.info.ref = ref;\n \n           /* We add SS chains for all the subscripts in the section.  */\n-\t  for (n = 0; n < ar->dimen; n++)\n+\t  for (n = 0; n < ar->dimen + ar->codimen; n++)\n \t    {\n \t      gfc_ss *indexss;\n \n \t      switch (ar->dimen_type[n])\n \t\t{\n+\t        case DIMEN_THIS_IMAGE:\n+\t\t  continue;\n \t\tcase DIMEN_ELEMENT:\n \t\t  /* Add SS for elemental (scalar) subscripts.  */\n \t\t  gcc_assert (ar->start[n]);\n@@ -7373,8 +7471,10 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t\tcase DIMEN_RANGE:\n                   /* We don't add anything for sections, just remember this\n                      dimension for later.  */\n-\t\t  newss->data.info.dim[newss->data.info.dimen] = n;\n-\t\t  newss->data.info.dimen++;\n+\t\t  newss->data.info.dim[newss->data.info.dimen\n+\t\t\t\t       + newss->data.info.codimen] = n;\n+\t\t  if (n < ar->dimen)\n+\t\t    newss->data.info.dimen++;\n \t\t  break;\n \n \t\tcase DIMEN_VECTOR:\n@@ -7386,8 +7486,10 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t\t  indexss->next = gfc_ss_terminator;\n \t\t  indexss->loop_chain = gfc_ss_terminator;\n \t\t  newss->data.info.subscript[n] = indexss;\n-\t\t  newss->data.info.dim[newss->data.info.dimen] = n;\n-\t\t  newss->data.info.dimen++;\n+\t\t  newss->data.info.dim[newss->data.info.dimen\n+\t\t\t\t       + newss->data.info.codimen] = n;\n+\t\t  if (n < ar->dimen)\n+\t\t    newss->data.info.dimen++;\n \t\t  break;\n \n \t\tdefault:"}, {"sha": "cc6fced4c0cd8187df83a31a0414895c62008514", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -767,6 +767,22 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n \t  TREE_NO_WARNING (GFC_TYPE_ARRAY_STRIDE (type, dim)) = 1;\n \t}\n     }\n+  for (dim = GFC_TYPE_ARRAY_RANK (type);\n+       dim < GFC_TYPE_ARRAY_RANK (type) + GFC_TYPE_ARRAY_CORANK (type); dim++)\n+    {\n+      if (GFC_TYPE_ARRAY_LBOUND (type, dim) == NULL_TREE)\n+\t{\n+\t  GFC_TYPE_ARRAY_LBOUND (type, dim) = create_index_var (\"lbound\", nest);\n+\t  TREE_NO_WARNING (GFC_TYPE_ARRAY_LBOUND (type, dim)) = 1;\n+\t}\n+      /* Don't try to use the unknown ubound for the last coarray dimension.  */\n+      if (GFC_TYPE_ARRAY_UBOUND (type, dim) == NULL_TREE\n+          && dim < GFC_TYPE_ARRAY_RANK (type) + GFC_TYPE_ARRAY_CORANK (type) - 1)\n+\t{\n+\t  GFC_TYPE_ARRAY_UBOUND (type, dim) = create_index_var (\"ubound\", nest);\n+\t  TREE_NO_WARNING (GFC_TYPE_ARRAY_UBOUND (type, dim)) = 1;\n+\t}\n+    }\n   if (GFC_TYPE_ARRAY_OFFSET (type) == NULL_TREE)\n     {\n       GFC_TYPE_ARRAY_OFFSET (type) = gfc_create_var_np (gfc_array_index_type,"}, {"sha": "a3c2ecda0c6d3c2a2af63078c4ffe8d750536afd", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 145, "deletions": 5, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -932,6 +932,7 @@ trans_num_images (gfc_se * se)\n   se->expr = gfort_gvar_caf_num_images;\n }\n \n+\n /* Evaluate a single upper or lower bound.  */\n /* TODO: bound intrinsic generates way too much unnecessary code.  */\n \n@@ -969,9 +970,9 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   else\n     {\n       /* use the passed argument.  */\n-      gcc_assert (arg->next->expr);\n+      gcc_assert (arg2->expr);\n       gfc_init_se (&argse, NULL);\n-      gfc_conv_expr_type (&argse, arg->next->expr, gfc_array_index_type);\n+      gfc_conv_expr_type (&argse, arg2->expr, gfc_array_index_type);\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       bound = argse.expr;\n       /* Convert from one based to zero based.  */\n@@ -1116,6 +1117,128 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n }\n \n \n+static void\n+conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n+{\n+  gfc_actual_arglist *arg;\n+  gfc_actual_arglist *arg2;\n+  gfc_se argse;\n+  gfc_ss *ss;\n+  tree bound, resbound, resbound2, desc, cond, tmp;\n+  tree type;\n+  gfc_array_spec * as;\n+  int corank;\n+\n+  gcc_assert (expr->value.function.isym->id == GFC_ISYM_LCOBOUND\n+\t      || expr->value.function.isym->id == GFC_ISYM_UCOBOUND\n+\t      || expr->value.function.isym->id == GFC_ISYM_THIS_IMAGE);\n+\n+  arg = expr->value.function.actual;\n+  arg2 = arg->next;\n+\n+  gcc_assert (arg->expr->expr_type == EXPR_VARIABLE);\n+  corank = gfc_get_corank (arg->expr);\n+\n+  as = gfc_get_full_arrayspec_from_expr (arg->expr);\n+  gcc_assert (as);\n+\n+  ss = gfc_walk_expr (arg->expr);\n+  gcc_assert (ss != gfc_ss_terminator);\n+  ss->data.info.codimen = corank;\n+  gfc_init_se (&argse, NULL);\n+\n+  gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n+  gfc_add_block_to_block (&se->pre, &argse.pre);\n+  gfc_add_block_to_block (&se->post, &argse.post);\n+  desc = argse.expr;\n+\n+  if (se->ss)\n+    {\n+      mpz_t mpz_rank;\n+      tree tree_rank;\n+\n+      /* Create an implicit second parameter from the loop variable.  */\n+      gcc_assert (!arg2->expr);\n+      gcc_assert (corank > 0);\n+      gcc_assert (se->loop->dimen == 1);\n+      gcc_assert (se->ss->expr == expr);\n+\n+      mpz_init_set_ui (mpz_rank, arg->expr->rank);\n+      tree_rank = gfc_conv_mpz_to_tree (mpz_rank, gfc_index_integer_kind);\n+\n+      bound = se->loop->loopvar[0];\n+      bound = fold_build2 (PLUS_EXPR, gfc_array_index_type, bound,\n+\t\t\t   se->ss->data.info.delta[0]);\n+      bound = fold_build2 (PLUS_EXPR, gfc_array_index_type, bound,\n+\t\t\t   tree_rank);\n+      gfc_advance_se_ss_chain (se);\n+    }\n+  else\n+    {\n+      /* use the passed argument.  */\n+      gcc_assert (arg2->expr);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_type (&argse, arg2->expr, gfc_array_index_type);\n+      gfc_add_block_to_block (&se->pre, &argse.pre);\n+      bound = argse.expr;\n+\n+      if (INTEGER_CST_P (bound))\n+\t{\n+\t  int hi, low;\n+\n+\t  hi = TREE_INT_CST_HIGH (bound);\n+\t  low = TREE_INT_CST_LOW (bound);\n+\t  if (hi || low < 1 || low > GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc)))\n+\t    gfc_error (\"'dim' argument of %s intrinsic at %L is not a valid \"\n+\t\t       \"dimension index\", expr->value.function.isym->name,\n+\t\t       &expr->where);\n+\t}\n+      else if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n+        {\n+\t  bound = gfc_evaluate_now (bound, &se->pre);\n+\t  cond = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t      bound, build_int_cst (TREE_TYPE (bound), 1));\n+\t  tmp = gfc_rank_cst[GFC_TYPE_ARRAY_CORANK (TREE_TYPE (desc))];\n+\t  tmp = fold_build2 (GT_EXPR, boolean_type_node, bound, tmp);\n+\t  cond = fold_build2 (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp);\n+\t  gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n+\t\t\t\t   gfc_msg_fault);\n+\t}\n+\n+\n+      /* Substract 1 to get to zero based and add dimensions.  */\n+      switch (arg->expr->rank)\n+\t{\n+\tcase 0:\n+\t  bound = fold_build2 (MINUS_EXPR, gfc_array_index_type, bound,\n+\t\t\t       gfc_index_one_node);\n+\tcase 1:\n+\t  break;\n+\tdefault:\n+\t  bound = fold_build2 (PLUS_EXPR, gfc_array_index_type, bound,\n+\t\t\t       gfc_rank_cst[arg->expr->rank - 1]);\n+\t}\n+    }\n+\n+  resbound = gfc_conv_descriptor_lbound_get (desc, bound);\n+\n+  if (expr->value.function.isym->id == GFC_ISYM_UCOBOUND)\n+    {\n+      cond = fold_build2 (EQ_EXPR, boolean_type_node, bound,\n+\t\t\t  build_int_cst (TREE_TYPE (bound),\n+\t\t\t  arg->expr->rank + corank - 1));\n+      resbound2 = gfc_conv_descriptor_ubound_get (desc, bound);\n+      se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n+\t\t\t      resbound, resbound2);\n+    }\n+  else\n+    se->expr = resbound;\n+\n+  type = gfc_typenode_for_spec (&expr->ts);\n+  se->expr = convert (type, se->expr);\n+}\n+\n+\n static void\n gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n {\n@@ -5960,6 +6083,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_bound (se, expr, 0);\n       break;\n \n+    case GFC_ISYM_LCOBOUND:\n+      conv_intrinsic_cobound (se, expr);\n+      break;\n+\n     case GFC_ISYM_TRANSPOSE:\n       /* The scalarizer has already been set up for reversed dimension access\n \t order ; now we just get the argument value normally.  */\n@@ -6117,6 +6244,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_bound (se, expr, 1);\n       break;\n \n+    case GFC_ISYM_UCOBOUND:\n+      conv_intrinsic_cobound (se, expr);\n+      break;\n+\n     case GFC_ISYM_XOR:\n       gfc_conv_intrinsic_bitop (se, expr, BIT_XOR_EXPR);\n       break;\n@@ -6126,7 +6257,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_THIS_IMAGE:\n-      trans_this_image (se, expr);\n+      if (expr->value.function.actual)\n+\tconv_intrinsic_cobound (se, expr);\n+      else\n+\ttrans_this_image (se, expr);\n       break;\n \n     case GFC_ISYM_NUM_IMAGES:\n@@ -6261,6 +6395,9 @@ gfc_add_intrinsic_ss_code (gfc_loopinfo * loop ATTRIBUTE_UNUSED, gfc_ss * ss)\n     {\n     case GFC_ISYM_UBOUND:\n     case GFC_ISYM_LBOUND:\n+    case GFC_ISYM_UCOBOUND:\n+    case GFC_ISYM_LCOBOUND:\n+    case GFC_ISYM_THIS_IMAGE:\n       break;\n \n     default:\n@@ -6269,8 +6406,8 @@ gfc_add_intrinsic_ss_code (gfc_loopinfo * loop ATTRIBUTE_UNUSED, gfc_ss * ss)\n }\n \n \n-/* UBOUND and LBOUND intrinsics with one parameter are expanded into code\n-   inside the scalarization loop.  */\n+/* The LBOUND, LCOBOUND, UBOUND and UCOBOUND intrinsics with one parameter\n+   are expanded into code inside the scalarization loop.  */\n \n static gfc_ss *\n gfc_walk_intrinsic_bound (gfc_ss * ss, gfc_expr * expr)\n@@ -6407,7 +6544,10 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n   switch (isym->id)\n     {\n     case GFC_ISYM_LBOUND:\n+    case GFC_ISYM_LCOBOUND:\n     case GFC_ISYM_UBOUND:\n+    case GFC_ISYM_UCOBOUND:\n+    case GFC_ISYM_THIS_IMAGE:\n       return gfc_walk_intrinsic_bound (ss, expr);\n \n     case GFC_ISYM_TRANSFER:"}, {"sha": "7e12f08beaf46d3d471395fbd5ac6baef3ae4a78", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -1249,6 +1249,17 @@ gfc_build_array_type (tree type, gfc_array_spec * as,\n       ubound[n] = gfc_conv_array_bound (as->upper[n]);\n     }\n \n+  for (n = as->rank; n < as->rank + as->corank; n++)\n+    {\n+      if (as->lower[n] == NULL)\n+        lbound[n] = gfc_index_one_node;\n+      else\n+        lbound[n] = gfc_conv_array_bound (as->lower[n]);\n+\n+      if (n < as->rank + as->corank - 1)\n+\tubound[n] = gfc_conv_array_bound (as->upper[n]);\n+    }\n+\n   if (as->type == AS_ASSUMED_SHAPE)\n     akind = contiguous ? GFC_ARRAY_ASSUMED_SHAPE_CONT\n \t\t       : GFC_ARRAY_ASSUMED_SHAPE;\n@@ -1477,6 +1488,25 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n       if (packed == PACKED_NO || packed == PACKED_PARTIAL)\n         known_stride = 0;\n     }\n+  for (n = as->rank; n < as->rank + as->corank; n++)\n+    {\n+      expr = as->lower[n];\n+      if (expr->expr_type == EXPR_CONSTANT)\n+\ttmp = gfc_conv_mpz_to_tree (expr->value.integer,\n+\t\t\t\t    gfc_index_integer_kind);\n+      else\n+      \ttmp = NULL_TREE;\n+      GFC_TYPE_ARRAY_LBOUND (type, n) = tmp;\n+\n+      expr = as->upper[n];\n+      if (expr && expr->expr_type == EXPR_CONSTANT)\n+\ttmp = gfc_conv_mpz_to_tree (expr->value.integer,\n+\t\t\t\t    gfc_index_integer_kind);\n+      else\n+ \ttmp = NULL_TREE;\n+      if (n < as->rank + as->corank - 1)\n+      GFC_TYPE_ARRAY_UBOUND (type, n) = tmp;\n+    }\n \n   if (known_offset)\n     {\n@@ -1495,6 +1525,7 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed,\n     GFC_TYPE_ARRAY_SIZE (type) = NULL_TREE;\n \n   GFC_TYPE_ARRAY_RANK (type) = as->rank;\n+  GFC_TYPE_ARRAY_CORANK (type) = as->corank;\n   GFC_TYPE_ARRAY_DTYPE (type) = NULL_TREE;\n   range = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n \t\t\t    NULL_TREE);\n@@ -1654,6 +1685,7 @@ gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n     = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));\n \n   GFC_TYPE_ARRAY_RANK (fat_type) = dimen;\n+  GFC_TYPE_ARRAY_CORANK (fat_type) = codimen;\n   GFC_TYPE_ARRAY_DTYPE (fat_type) = NULL_TREE;\n   GFC_TYPE_ARRAY_AKIND (fat_type) = akind;\n "}, {"sha": "543ad525b1aad7d0eb0cda945552e64f6e95085f", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -104,7 +104,7 @@ gfc_se;\n \n typedef struct gfc_ss_info\n {\n-  int dimen;\n+  int dimen, codimen;\n   /* The ref that holds information on this section.  */\n   gfc_ref *ref;\n   /* The descriptor of this array.  */\n@@ -198,7 +198,7 @@ typedef struct gfc_ss\n     {\n       /* The rank of the temporary.  May be less than the rank of the\n          assigned expression.  */\n-      int dimen;\n+      int dimen, codimen;\n       tree type;\n     }\n     temp;\n@@ -231,7 +231,7 @@ typedef struct gfc_loopinfo\n   stmtblock_t pre;\n   stmtblock_t post;\n \n-  int dimen;\n+  int dimen, codimen;\n \n   /* All the SS involved with this loop.  */\n   gfc_ss *ss;\n@@ -713,7 +713,7 @@ enum gfc_array_kind\n    variable-sized in some other frontends.  Due to gengtype deficiency the GTY\n    options of such types have to agree across all frontends. */\n struct GTY((variable_size))\tlang_type\t {\n-  int rank;\n+  int rank, corank;\n   enum gfc_array_kind akind;\n   tree lbound[GFC_MAX_DIMENSIONS];\n   tree ubound[GFC_MAX_DIMENSIONS];\n@@ -768,6 +768,7 @@ struct GTY((variable_size)) lang_decl {\n #define GFC_TYPE_ARRAY_STRIDE(node, dim) \\\n   (TYPE_LANG_SPECIFIC(node)->stride[dim])\n #define GFC_TYPE_ARRAY_RANK(node) (TYPE_LANG_SPECIFIC(node)->rank)\n+#define GFC_TYPE_ARRAY_CORANK(node) (TYPE_LANG_SPECIFIC(node)->corank)\n #define GFC_TYPE_ARRAY_SIZE(node) (TYPE_LANG_SPECIFIC(node)->size)\n #define GFC_TYPE_ARRAY_OFFSET(node) (TYPE_LANG_SPECIFIC(node)->offset)\n #define GFC_TYPE_ARRAY_AKIND(node) (TYPE_LANG_SPECIFIC(node)->akind)"}, {"sha": "3204df3a820c257a63b01e176ced803bae7f3d90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -1,3 +1,10 @@\n+2011-04-04  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_10.f90: Add coarray descriptor diagnostic check.\n+\t* gfortran.dg/coarray_13.f90: Add checks for run-time cobounds.\n+\t* gfortran.dg/coarray_15.f90: New.\n+\n 2011-04-04  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gfortran.dg/bessel_6.f90: Use dg-add-options ieee."}, {"sha": "d32e25478c774c98f4237b7568a449ce0b769dd8", "filename": "gcc/testsuite/gfortran.dg/coarray_10.f90", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_10.f90?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -44,3 +44,9 @@ subroutine rank_mismatch()\n   A(1)[1,1] = 1         ! { dg-error \"Too few codimensions\" }\n   A(1)[1,1:1] = 1       ! { dg-error \"Too few codimensions\" }\n end subroutine rank_mismatch\n+\n+subroutine rank_mismatch2()\n+  implicit none\n+  integer, allocatable:: A(:)[:,:,:]\n+  allocate(A(1)[7:8,4:*]) ! { dg-error \"Unexpected .*. for codimension 2 of 3\" }\n+end subroutine rank_mismatch2"}, {"sha": "1c79a079130ad65e3edd9de9ddf6abc8f5d73acd", "filename": "gcc/testsuite/gfortran.dg/coarray_13.f90", "status": "modified", "additions": 134, "deletions": 4, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_13.f90?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -1,19 +1,149 @@\n ! { dg-do run }\n-! { dg-options \"-fcoarray=single\" }\n+! { dg-options \"-fcoarray=single -fcheck=bounds\" }\n !\n ! Coarray support -- allocatable array coarrays\n+!                 -- intrinsic procedures\n ! PR fortran/18918\n ! PR fortran/43931\n !\n program test\n   implicit none\n+  integer,allocatable :: B(:)[:]\n+\n   call one()\n+  call two()\n+  allocate(B(3)[-4:*])\n+  call three(3,B,1)\n+  call three_a(3,B)\n+  call three_b(3,B)\n+  call four(B)\n+  call five()\n contains\n   subroutine one()\n     integer, allocatable :: a(:)[:,:,:]\n     allocate(a(1)[-4:9,8,4:*])\n+ \n+    if (this_image(a,dim=1) /= -4_8) call abort()\n+    if (lcobound  (a,dim=1) /= -4_8) call abort()\n+    if (ucobound  (a,dim=1) /=  9_8) call abort()\n+ \n+    if (this_image(a,dim=2) /=  1_8) call abort()\n+    if (lcobound  (a,dim=2) /=  1_8) call abort()\n+    if (ucobound  (a,dim=2) /=  8_8) call abort()\n+ \n+    if (this_image(a,dim=3) /= 4_8) call abort()\n+    if (lcobound  (a,dim=3) /= 4_8) call abort()\n+    if (ucobound  (a,dim=3) /= 4_8) call abort()\n+ \n+    if (any(this_image(a) /= [-4_8, 1_8, 4_8])) call abort()\n+    if (any(lcobound  (a) /= [-4_8, 1_8, 4_8])) call abort()\n+    if (any(ucobound  (a) /= [9_8, 8_8, 4_8])) call abort()\n   end subroutine one\n-  subroutine four(C)\n-    integer, allocatable :: C(:)[:]\n- end subroutine four\n+\n+  subroutine two()\n+    integer, allocatable :: a(:)[:,:,:]\n+    allocate(a(1)[-4:9,8,4:*])\n+\n+    if (this_image(a,dim=1) /= -4) call abort()\n+    if (lcobound  (a,dim=1) /= -4) call abort()\n+    if (ucobound  (a,dim=1) /=  9) call abort()\n+\n+    if (this_image(a,dim=2) /=  1) call abort()\n+    if (lcobound  (a,dim=2) /=  1) call abort()\n+    if (ucobound  (a,dim=2) /=  8) call abort()\n+\n+    if (this_image(a,dim=3) /= 4) call abort()\n+    if (lcobound  (a,dim=3) /= 4) call abort()\n+    if (ucobound  (a,dim=3) /= 4) call abort()\n+\n+    if (any(this_image(a) /= [-4, 1, 4])) call abort()\n+    if (any(lcobound  (a) /= [-4, 1, 4])) call abort()\n+    if (any(ucobound  (a) /= [9, 8, 4])) call abort()\n+  end subroutine two\n+\n+  subroutine three(n,A, n2)\n+    integer :: n, n2\n+    integer :: A(3)[n:*]\n+\n+    A(1) = 42\n+    if (A(1) /= 42) call abort()\n+    A(1)[n2] = -42\n+    if (A(1)[n2] /= -42) call abort()\n+\n+    if (this_image(A,dim=1) /= n) call abort()\n+    if (lcobound  (A,dim=1) /= n) call abort()\n+    if (ucobound  (A,dim=1) /= n) call abort()\n+\n+    if (any(this_image(A) /= n)) call abort()\n+    if (any(lcobound  (A) /= n)) call abort()\n+    if (any(ucobound  (A) /= n)) call abort()\n+  end subroutine three\n+\n+  subroutine three_a(n,A)\n+    integer :: n\n+    integer :: A(3)[n+2:n+5,n-1:*]\n+\n+    A(1) = 42\n+    if (A(1) /= 42) call abort()\n+    A(1)[4,n] = -42\n+    if (A(1)[4,n] /= -42) call abort()\n+\n+    if (this_image(A,dim=1) /= n+2) call abort()\n+    if (lcobound  (A,dim=1) /= n+2) call abort()\n+    if (ucobound  (A,dim=1) /= n+5) call abort()\n+\n+    if (this_image(A,dim=2) /= n-1) call abort()\n+    if (lcobound  (A,dim=2) /= n-1) call abort()\n+    if (ucobound  (A,dim=2) /= n-1) call abort()\n+\n+    if (any(this_image(A) /= [n+2,n-1])) call abort()\n+    if (any(lcobound  (A) /= [n+2,n-1])) call abort()\n+    if (any(ucobound  (A) /= [n+5,n-1])) call abort()\n+  end subroutine three_a\n+\n+  subroutine three_b(n,A)\n+    integer :: n\n+    integer :: A(-1:3,0:4,-2:5,-4:7)[n+2:n+5,n-1:*]\n+\n+    A(1,1,1,1) = 42\n+    if (A(1,1,1,1) /= 42) call abort()\n+    A(1,1,1,1)[4,n] = -42\n+    if (A(1,1,1,1)[4,n] /= -42) call abort()\n+\n+    if (this_image(A,dim=1) /= n+2) call abort()\n+    if (lcobound  (A,dim=1) /= n+2) call abort()\n+    if (ucobound  (A,dim=1) /= n+5) call abort()\n+\n+    if (this_image(A,dim=2) /= n-1) call abort()\n+    if (lcobound  (A,dim=2) /= n-1) call abort()\n+    if (ucobound  (A,dim=2) /= n-1) call abort()\n+\n+    if (any(this_image(A) /= [n+2,n-1])) call abort()\n+    if (any(lcobound  (A) /= [n+2,n-1])) call abort()\n+    if (any(ucobound  (A) /= [n+5,n-1])) call abort()\n+  end subroutine three_b\n+\n+  subroutine four(A)\n+    integer, allocatable :: A(:)[:]\n+    if (this_image(A,dim=1) /= -4_8) call abort()\n+    if (lcobound  (A,dim=1) /= -4_8) call abort()\n+    if (ucobound  (A,dim=1) /= -4_8) call abort()\n+  end subroutine four\n+\n+  subroutine five()\n+    integer, save :: foo(2)[5:7,4:*]\n+    integer :: i\n+\n+    i = 1\n+    foo(1)[5,4] = 42\n+    if (foo(1)[5,4] /= 42) call abort()\n+    if (this_image(foo,dim=i) /= 5) call abort()\n+    if (lcobound(foo,dim=i) /= 5) call abort()\n+    if (ucobound(foo,dim=i) /= 7) call abort()\n+\n+    i = 2\n+    if (this_image(foo,dim=i) /= 4) call abort()\n+    if (lcobound(foo,dim=i) /= 4) call abort()\n+    if (ucobound(foo,dim=i) /= 4) call abort()\n+  end subroutine five\n end program test"}, {"sha": "91584e26df85d19ed7d635b87d5eff1dea26d3d6", "filename": "gcc/testsuite/gfortran.dg/coarray_15.f90", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3935ffcb75885f82b3034c8b45bc54b14b49cff/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_15.f90?ref=a3935ffcb75885f82b3034c8b45bc54b14b49cff", "patch": "@@ -0,0 +1,112 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/18918\n+!\n+! Contributed by John Reid.\n+!\n+program ex2\n+      implicit none\n+      real, allocatable :: z(:)[:]\n+      integer :: image\n+      character(len=80) :: str\n+\n+      allocate(z(3)[*])\n+      write(*,*) 'z allocated on image',this_image()\n+      sync all\n+      if (this_image()==1) then\n+          z = 1.2\n+          do image = 2, num_images() ! { dg-warning \"will be executed zero times\" }\n+            write(*,*) 'Assigning z(:) on image',image\n+            z(:)[image] = z\n+         end do\n+      end if\n+      sync all\n+\n+      str = repeat('X', len(str))\n+      write(str,*) 'z=',z(:),' on image',this_image()\n+      if (str /= \" z=   1.2000000       1.2000000       1.2000000      on image           1\") &\n+        call abort ()\n+\n+      str = repeat('X', len(str))\n+      write(str,*) 'z=',z,' on image',this_image()\n+      if (str /= \" z=   1.2000000       1.2000000       1.2000000      on image           1\") &\n+        call abort ()\n+\n+      str = repeat('X', len(str))\n+      write(str,*) 'z=',z(1:3)[this_image()],' on image',this_image()\n+      if (str /= \" z=   1.2000000       1.2000000       1.2000000      on image           1\") &\n+        call abort ()\n+\n+      call ex2a()\n+      call ex5()\n+end\n+\n+subroutine ex2a()\n+      implicit none\n+      real, allocatable :: z(:,:)[:,:]\n+      integer :: image\n+      character(len=100) :: str\n+\n+      allocate(z(2,2)[1,*])\n+      write(*,*) 'z allocated on image',this_image()\n+      sync all\n+      if (this_image()==1) then\n+          z = 1.2\n+          do image = 2, num_images() ! { dg-warning \"will be executed zero times\" }\n+            write(*,*) 'Assigning z(:) on image',image\n+            z(:,:)[1,image] = z\n+         end do\n+      end if\n+      sync all\n+\n+      str = repeat('X', len(str))\n+      write(str,*) 'z=',z(:,:),' on image',this_image()\n+      if (str /= \" z=   1.2000000       1.2000000       1.2000000       1.2000000      on image           1\") &\n+        call abort ()\n+\n+      str = repeat('X', len(str))\n+      write(str,*) 'z=',z,' on image',this_image()\n+      if (str /= \" z=   1.2000000       1.2000000       1.2000000       1.2000000      on image           1\") &\n+        call abort ()\n+end subroutine ex2a\n+\n+subroutine ex5\n+   implicit none\n+   integer :: me\n+   real, save :: w(4)[*]\n+   character(len=100) :: str\n+\n+   me = this_image()\n+   w = me\n+\n+   str = repeat('X', len(str))\n+   write(str,*) 'In main on image',this_image(), 'w= ',w \n+   if (str /= \" In main on image           1 w=    1.0000000       1.0000000       1.0000000       1.0000000\") &\n+     call abort ()\n+\n+   str = repeat('X', len(str))\n+   write(str,*) 'In main on image',this_image(), 'w= ',w(1:4) \n+   if (str /= \" In main on image           1 w=    1.0000000       1.0000000       1.0000000       1.0000000\") &\n+     call abort ()\n+\n+   str = repeat('X', len(str))\n+   write(str,*) 'In main on image',this_image(), 'w= ',w(:)[1]\n+   if (str /= \" In main on image           1 w=    1.0000000       1.0000000       1.0000000       1.0000000\") &\n+     call abort ()\n+\n+   sync all\n+   call ex5_sub(me,w)\n+end subroutine ex5\n+      \n+subroutine ex5_sub(n,w)\n+   implicit none\n+   integer :: n\n+   real :: w(n)\n+   character(len=50) :: str\n+\n+   str = repeat('X', len(str))\n+   write(str,*) 'In sub on image',this_image(), 'w= ',w \n+   if (str /= \" In sub on image           1 w=    1.0000000\") &\n+     call abort ()\n+end subroutine ex5_sub"}]}