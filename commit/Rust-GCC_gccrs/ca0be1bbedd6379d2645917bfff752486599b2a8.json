{"sha": "ca0be1bbedd6379d2645917bfff752486599b2a8", "node_id": "C_kwDOANBUbNoAKGNhMGJlMWJiZWRkNjM3OWQyNjQ1OTE3YmZmZjc1MjQ4NjU5OWIyYTg", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-19T10:11:25Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-24T06:38:27Z"}, "message": "Remove unused legacy VRP code.\n\nRemoves unused legacy VRP code.  The legacy mode in value_range's is\nstill around, as it can't be trivially deleted.\n\nWith this patch vr-values.cc melts away to simplify_using_ranges, but\nI have avoided any renaming of actual files, since we have plans for\nconsolidation of other folding with ranges for the next release.\n\ngcc/ChangeLog:\n\n\t* doc/invoke.texi: Remove docs for max-vrp-switch-assertions,\n\tvrp1-mode, and vrp2-mode.\n\t* params.opt: Same.\n\t* range-op.cc (masked_increment): Move from tree-vrp.cc.\n\t* tree-vrp.cc (class live_names): Remove.\n\t(live_names::init_bitmap_if_needed): Remove.\n\t(live_names::block_has_live_names_p): Remove.\n\t(live_names::clear_block): Remove.\n\t(live_names::merge): Remove.\n\t(live_names::set): Remove.\n\t(live_names::clear): Remove.\n\t(live_names::live_names): Remove.\n\t(live_names::~live_names): Remove.\n\t(live_names::live_on_block_p): Remove.\n\t(live_names::live_on_edge_p): Remove.\n\t(get_single_symbol): Make static.\n\t(build_symbolic_expr): Remove.\n\t(adjust_symbolic_bound): Remove.\n\t(combine_bound): Remove.\n\t(set_value_range_with_overflow): Remove.\n\t(extract_range_from_pointer_plus_expr): Remove.\n\t(extract_range_from_plus_minus_expr): Remove.\n\t(drop_undefines_to_varying): Remove.\n\t(range_fold_binary_symbolics_p): Remove.\n\t(range_fold_unary_symbolics_p): Remove.\n\t(range_fold_binary_expr): Remove.\n\t(infer_value_range): Remove.\n\t(dump_assert_info): Remove.\n\t(dump_asserts_info): Remove.\n\t(add_assert_info): Remove.\n\t(extract_code_and_val_from_cond_with_ops): Remove.\n\t(masked_increment): Move to range-op.cc.\n\t(register_edge_assert_for_2): Remove.\n\t(find_case_label_index): Remove.\n\t(find_case_label_range): Remove.\n\t(register_edge_assert_for_1): Remove.\n\t(is_masked_range_test): Remove.\n\t(register_edge_assert_for): Remove.\n\t(stmt_interesting_for_vrp): Remove.\n\t(struct case_info): Remove.\n\t(struct assert_locus): Remove.\n\t(class vrp_asserts): Remove.\n\t(vrp_asserts::build_assert_expr_for): Remove.\n\t(vrp_asserts::dump): Remove.\n\t(vrp_asserts::register_new_assert_for): Remove.\n\t(vrp_asserts::finish_register_edge_assert_for): Remove.\n\t(vrp_asserts::find_conditional_asserts): Remove.\n\t(vrp_asserts::compare_case_labels): Remove.\n\t(vrp_asserts::find_switch_asserts): Remove.\n\t(vrp_asserts::find_assert_locations_in_bb): Remove.\n\t(vrp_asserts::find_assert_locations): Remove.\n\t(vrp_asserts::process_assert_insertions_for): Remove.\n\t(vrp_asserts::compare_assert_loc): Remove.\n\t(vrp_asserts::process_assert_insertions): Remove.\n\t(vrp_asserts::insert_range_assertions): Remove.\n\t(vrp_asserts::all_imm_uses_in_stmt_or_feed_cond): Remove.\n\t(vrp_asserts::remove_range_assertions): Remove.\n\t(class vrp_prop): Remove.\n\t(vrp_prop::initialize): Remove.\n\t(enum ssa_prop_result): Remove.\n\t(vrp_prop::visit_stmt): Remove.\n\t(vrp_prop::visit_phi): Remove.\n\t(vrp_prop::finalize): Remove.\n\t(class vrp_folder): Remove.\n\t(vrp_folder::fold_predicate_in): Remove.\n\t(vrp_folder::fold_stmt): Remove.\n\t(vrp_folder::simplify_casted_conds): Remove.\n\t(execute_vrp): Remove.\n\t* tree-vrp.h (struct assert_info): Remove.\n\t(register_edge_assert_for): Remove.\n\t(stmt_interesting_for_vrp): Remove.\n\t(infer_value_range): Remove.\n\t(get_single_symbol): Remove.\n\t(masked_increment): Remove.\n\t(execute_ranger_vrp): Remove.\n\t* vr-values.cc (set_value_range_to_nonnegative): Remove.\n\t(set_value_range_to_truthvalue): Remove.\n\t(vr_values::get_lattice_entry): Remove.\n\t(vr_values::get_value_range): Remove.\n\t(vr_values::range_of_expr): Remove.\n\t(vr_values::value_of_expr): Remove.\n\t(vr_values::value_on_edge): Remove.\n\t(vr_values::value_of_stmt): Remove.\n\t(vr_values::set_def_to_varying): Remove.\n\t(vr_values::set_defs_to_varying): Remove.\n\t(vr_values::update_value_range): Remove.\n\t(symbolic_range_based_on_p): Remove.\n\t(gimple_assign_nonzero_p): Remove.\n\t(gimple_stmt_nonzero_p): Remove.\n\t(vr_values::vrp_stmt_computes_nonzero): Remove.\n\t(vr_values::op_with_constant_singleton_value_range): Remove.\n\t(vr_values::extract_range_for_var_from_comparison_expr): Remove.\n\t(vr_values::extract_range_from_assert): Remove.\n\t(vr_values::extract_range_from_ssa_name): Remove.\n\t(vr_values::extract_range_from_binary_expr): Remove.\n\t(vr_values::extract_range_from_unary_expr): Remove.\n\t(vr_values::extract_range_from_cond_expr): Remove.\n\t(vr_values::extract_range_from_comparison): Remove.\n\t(vr_values::extract_range_from_ubsan_builtin): Remove.\n\t(vr_values::extract_range_basic): Remove.\n\t(vr_values::extract_range_from_assignment): Remove.\n\t(vr_values::adjust_range_with_scev): Remove.\n\t(vr_values::dump): Remove.\n\t(vr_values::vr_values): Remove.\n\t(vr_values::~vr_values): Remove.\n\t(vrp_valueize): Remove.\n\t(vrp_valueize_1): Remove.\n\t(get_output_for_vrp): Remove.\n\t(vr_values::vrp_visit_assignment_or_call): Remove.\n\t(simplify_using_ranges::vrp_evaluate_conditional): Remove.\n\t(vr_values::vrp_visit_switch_stmt): Remove.\n\t(vr_values::extract_range_from_stmt): Remove.\n\t(vr_values::extract_range_from_phi_node): Remove.\n\t(simplify_using_ranges::fold_cond): Add FIXME note.\n\t(vr_values::set_vr_value): Remove.\n\t(vr_values::swap_vr_value): Remove.\n\t* vr-values.h (class vr_values): Remove.\n\t(get_output_for_vrp): Remove.", "tree": {"sha": "5a8d91c97354f0f2df88741e5476782c09515dec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a8d91c97354f0f2df88741e5476782c09515dec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca0be1bbedd6379d2645917bfff752486599b2a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0be1bbedd6379d2645917bfff752486599b2a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca0be1bbedd6379d2645917bfff752486599b2a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0be1bbedd6379d2645917bfff752486599b2a8/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce917b0422c145779b83e005afd8433c0c86fb06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce917b0422c145779b83e005afd8433c0c86fb06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce917b0422c145779b83e005afd8433c0c86fb06"}], "stats": {"total": 5889, "additions": 252, "deletions": 5637}, "files": [{"sha": "202388b3fb813af381983e1752fe448b8699706a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ca0be1bbedd6379d2645917bfff752486599b2a8", "patch": "@@ -15784,19 +15784,9 @@ The maximum number of may-defs we analyze when looking for a must-def\n specifying the dynamic type of an object that invokes a virtual call\n we may be able to devirtualize speculatively.\n \n-@item max-vrp-switch-assertions\n-The maximum number of assertions to add along the default edge of a switch\n-statement during VRP.\n-\n @item evrp-sparse-threshold\n Maximum number of basic blocks before EVRP uses a sparse cache.\n \n-@item vrp1-mode\n-Specifies the mode VRP pass 1 should operate in.\n-\n-@item vrp2-mode\n-Specifies the mode VRP pass 2 should operate in.\n-\n @item ranger-debug\n Specifies the type of debug output to be issued for ranges.\n "}, {"sha": "c1dcb7ea4878b536a4a6a76d254f2398b63119ef", "filename": "gcc/params.opt", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=ca0be1bbedd6379d2645917bfff752486599b2a8", "patch": "@@ -746,10 +746,6 @@ Max. size of var tracking hash tables.\n Common Joined UInteger Var(param_max_find_base_term_values) Init(200) Param Optimization\n Maximum number of VALUEs handled during a single find_base_term call.\n \n--param=max-vrp-switch-assertions=\n-Common Joined UInteger Var(param_max_vrp_switch_assertions) Init(10) Param Optimization\n-Maximum number of assertions to add along the default edge of a switch statement during VRP.\n-\n -param=min-crossjump-insns=\n Common Joined UInteger Var(param_min_crossjump_insns) Init(5) IntegerRange(1, 65536) Param Optimization\n The minimum number of matching instructions to consider for crossjumping.\n@@ -1165,21 +1161,4 @@ The maximum factor which the loop vectorizer applies to the cost of statements i\n Common Joined UInteger Var(param_vect_induction_float) Init(1) IntegerRage(0, 1) Param Optimization\n Enable loop vectorization of floating point inductions.\n \n--param=vrp1-mode=\n-Common Joined Var(param_vrp1_mode) Enum(vrp_mode) Init(VRP_MODE_RANGER) Param Optimization\n---param=vrp1-mode=[vrp|ranger] Specifies the mode VRP1 should operate in.\n-\n--param=vrp2-mode=\n-Common Joined Var(param_vrp2_mode) Enum(vrp_mode) Init(VRP_MODE_RANGER) Param Optimization\n---param=vrp2-mode=[vrp|ranger] Specifies the mode VRP2 should operate in.\n-\n-Enum\n-Name(vrp_mode) Type(enum vrp_mode) UnknownError(unknown vrp mode %qs)\n-\n-EnumValue\n-Enum(vrp_mode) String(vrp) Value(VRP_MODE_VRP)\n-\n-EnumValue\n-Enum(vrp_mode) String(ranger) Value(VRP_MODE_RANGER)\n-\n ; This comment is to ensure we retain the blank line above."}, {"sha": "ca1c38c9307991c2864379c2756d4535690480a8", "filename": "gcc/range-op.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=ca0be1bbedd6379d2645917bfff752486599b2a8", "patch": "@@ -3082,6 +3082,34 @@ set_nonzero_range_from_mask (irange &r, tree type, const irange &lhs)\n     r.set_varying (type);\n }\n \n+/* Find out smallest RES where RES > VAL && (RES & MASK) == RES, if any\n+   (otherwise return VAL).  VAL and MASK must be zero-extended for\n+   precision PREC.  If SGNBIT is non-zero, first xor VAL with SGNBIT\n+   (to transform signed values into unsigned) and at the end xor\n+   SGNBIT back.  */\n+\n+wide_int\n+masked_increment (const wide_int &val_in, const wide_int &mask,\n+\t\t  const wide_int &sgnbit, unsigned int prec)\n+{\n+  wide_int bit = wi::one (prec), res;\n+  unsigned int i;\n+\n+  wide_int val = val_in ^ sgnbit;\n+  for (i = 0; i < prec; i++, bit += bit)\n+    {\n+      res = mask;\n+      if ((res & bit) == 0)\n+\tcontinue;\n+      res = bit - 1;\n+      res = wi::bit_and_not (val + bit, res);\n+      res &= mask;\n+      if (wi::gtu_p (res, val))\n+\treturn res ^ sgnbit;\n+    }\n+  return val ^ sgnbit;\n+}\n+\n // This was shamelessly stolen from register_edge_assert_for_2 and\n // adjusted to work with iranges.\n "}, {"sha": "86978086cfb11da27baad69003ee8aaccab9df4c", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 206, "deletions": 3632, "changes": 3838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=ca0be1bbedd6379d2645917bfff752486599b2a8"}, {"sha": "07630b5b1ca8ebe5a3f9308646aab340f0b0185c", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=ca0be1bbedd6379d2645917bfff752486599b2a8", "patch": "@@ -22,26 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"value-range.h\"\n \n-struct assert_info\n-{\n-  /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */\n-  enum tree_code comp_code;\n-\n-  /* Name to register the assert for.  */\n-  tree name;\n-\n-  /* Value being compared against.  */\n-  tree val;\n-\n-  /* Expression to compare.  */\n-  tree expr;\n-};\n-\n-extern void register_edge_assert_for (tree, edge, enum tree_code,\n-\t\t\t\t      tree, tree, vec<assert_info> &);\n-extern bool stmt_interesting_for_vrp (gimple *);\n-extern bool infer_value_range (gimple *, tree, tree_code *, tree *);\n-\n extern bool range_int_cst_p (const value_range *);\n \n extern int compare_values (tree, tree);\n@@ -60,11 +40,6 @@ extern bool find_case_label_range (gswitch *, tree, tree, size_t *, size_t *);\n extern tree find_case_label_range (gswitch *, const irange *vr);\n extern bool find_case_label_index (gswitch *, size_t, tree, size_t *);\n extern bool overflow_comparison_p (tree_code, tree, tree, bool, tree *);\n-extern tree get_single_symbol (tree, bool *, tree *);\n extern void maybe_set_nonzero_bits (edge, tree);\n-extern wide_int masked_increment (const wide_int &val_in, const wide_int &mask,\n-\t\t\t\t  const wide_int &sgnbit, unsigned int prec);\n \n-extern unsigned int execute_ranger_vrp (struct function *fun,\n-\t\t\t\t\tbool warn_array_bounds_p = false);\n #endif /* GCC_TREE_VRP_H */"}, {"sha": "2515d9883f4f2e26885968fc454fe37524c8bc9d", "filename": "gcc/vr-values.cc", "status": "modified", "additions": 16, "deletions": 1851, "changes": 1867, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fvr-values.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fvr-values.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.cc?ref=ca0be1bbedd6379d2645917bfff752486599b2a8", "patch": "@@ -52,415 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"range-op.h\"\n #include \"gimple-range.h\"\n \n-/* Set value range VR to a non-negative range of type TYPE.  */\n-\n-static inline void\n-set_value_range_to_nonnegative (value_range_equiv *vr, tree type)\n-{\n-  tree zero = build_int_cst (type, 0);\n-  vr->update (zero, vrp_val_max (type));\n-}\n-\n-/* Set value range VR to a range of a truthvalue of type TYPE.  */\n-\n-static inline void\n-set_value_range_to_truthvalue (value_range_equiv *vr, tree type)\n-{\n-  if (TYPE_PRECISION (type) == 1)\n-    vr->set_varying (type);\n-  else\n-    vr->update (build_int_cst (type, 0), build_int_cst (type, 1));\n-}\n-\n-/* Return the lattice entry for VAR or NULL if it doesn't exist or cannot\n-   be initialized.  */\n-\n-value_range_equiv *\n-vr_values::get_lattice_entry (const_tree var)\n-{\n-  value_range_equiv *vr;\n-  tree sym;\n-  unsigned ver = SSA_NAME_VERSION (var);\n-\n-  /* If we query the entry for a new SSA name avoid reallocating the lattice\n-     since we should get here at most from the substitute-and-fold stage which\n-     will never try to change values.  */\n-  if (ver >= num_vr_values)\n-    return NULL;\n-\n-  vr = vr_value[ver];\n-  if (vr)\n-    return vr;\n-\n-  /* Create a default value range.  */\n-  vr = allocate_value_range_equiv ();\n-  vr_value[ver] = vr;\n-\n-  /* After propagation finished return varying.  */\n-  if (values_propagated)\n-    {\n-      vr->set_varying (TREE_TYPE (var));\n-      return vr;\n-    }\n-\n-  vr->set_undefined ();\n-\n-  /* If VAR is a default definition of a parameter, the variable can\n-     take any value in VAR's type.  */\n-  if (SSA_NAME_IS_DEFAULT_DEF (var))\n-    {\n-      sym = SSA_NAME_VAR (var);\n-      if (TREE_CODE (sym) == PARM_DECL)\n-\t{\n-\t  /* Try to use the \"nonnull\" attribute to create ~[0, 0]\n-\t     anti-ranges for pointers.  Note that this is only valid with\n-\t     default definitions of PARM_DECLs.  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (sym))\n-\t      && (nonnull_arg_p (sym)\n-\t\t  || (get_global_range_query ()->range_of_expr (*vr,\n-\t\t\t\t\t\tconst_cast <tree> (var))\n-\t\t      && vr->nonzero_p ())))\n-\t    {\n-\t      vr->set_nonzero (TREE_TYPE (sym));\n-\t      vr->equiv_clear ();\n-\t    }\n-\t  else if (INTEGRAL_TYPE_P (TREE_TYPE (sym)))\n-\t    {\n-\t      get_global_range_query ()->range_of_expr (*vr, const_cast <tree> (var));\n-\t      if (vr->undefined_p ())\n-\t\tvr->set_varying (TREE_TYPE (sym));\n-\t    }\n-\t  else\n-\t    vr->set_varying (TREE_TYPE (sym));\n-\t}\n-      else if (TREE_CODE (sym) == RESULT_DECL\n-\t       && DECL_BY_REFERENCE (sym))\n-\t{\n-\t  vr->set_nonzero (TREE_TYPE (sym));\n-\t  vr->equiv_clear ();\n-\t}\n-    }\n-\n-  return vr;\n-}\n-\n-/* Return value range information for VAR.\n-\n-   If we have no values ranges recorded (ie, VRP is not running), then\n-   return NULL.  Otherwise create an empty range if none existed for VAR.  */\n-\n-const value_range_equiv *\n-vr_values::get_value_range (const_tree var,\n-\t\t\t    gimple *stmt ATTRIBUTE_UNUSED)\n-{\n-  /* If we have no recorded ranges, then return NULL.  */\n-  if (!vr_value)\n-    return NULL;\n-\n-  value_range_equiv *vr = get_lattice_entry (var);\n-\n-  /* Reallocate the lattice if needed.  */\n-  if (!vr)\n-    {\n-      unsigned int old_sz = num_vr_values;\n-      num_vr_values = num_ssa_names + num_ssa_names / 10;\n-      vr_value = XRESIZEVEC (value_range_equiv *, vr_value, num_vr_values);\n-      for ( ; old_sz < num_vr_values; old_sz++)\n-        vr_value [old_sz] = NULL;\n-\n-      /* Now that the lattice has been resized, we should never fail.  */\n-      vr = get_lattice_entry (var);\n-      gcc_assert (vr);\n-    }\n-\n-  return vr;\n-}\n-\n-bool\n-vr_values::range_of_expr (vrange &r, tree expr, gimple *stmt)\n-{\n-  if (!gimple_range_ssa_p (expr))\n-    return get_tree_range (r, expr, stmt);\n-\n-  if (const value_range *vr = get_value_range (expr, stmt))\n-    {\n-      if (!vr->supports_type_p (TREE_TYPE (expr)))\n-\t{\n-\t  // vr_values::extract_range_basic() use of ranger's\n-\t  // fold_range() can create a situation where we are asked\n-\t  // for the range of an unsupported legacy type.  Since\n-\t  // get_value_range() above will return varying or undefined\n-\t  // for such types, avoid copying incompatible range types.\n-\t  if (vr->undefined_p ())\n-\t    r.set_undefined ();\n-\t  else\n-\t    r.set_varying (TREE_TYPE (expr));\n-\t  return true;\n-\t}\n-      if (vr->undefined_p () || vr->constant_p ())\n-\tr = *vr;\n-      else\n-\t{\n-\t  value_range tmp = *vr;\n-\t  tmp.normalize_symbolics ();\n-\t  r = tmp;\n-\t}\n-      return true;\n-    }\n-  return false;\n-}\n-\n-tree\n-vr_values::value_of_expr (tree op, gimple *)\n-{\n-  return op_with_constant_singleton_value_range (op);\n-}\n-\n-tree\n-vr_values::value_on_edge (edge, tree op)\n-{\n-  return op_with_constant_singleton_value_range (op);\n-}\n-\n-tree\n-vr_values::value_of_stmt (gimple *stmt, tree op)\n-{\n-  if (!op)\n-    op = gimple_get_lhs (stmt);\n-\n-  gcc_checking_assert (!op|| op == gimple_get_lhs (stmt));\n-\n-  if (op)\n-    return op_with_constant_singleton_value_range (op);\n-  return NULL_TREE;\n-}\n-\n-/* Set the lattice entry for DEF to VARYING.  */\n-\n-void\n-vr_values::set_def_to_varying (const_tree def)\n-{\n-  value_range_equiv *vr = get_lattice_entry (def);\n-  if (vr)\n-    vr->set_varying (TREE_TYPE (def));\n-}\n-\n-/* Set value-ranges of all SSA names defined by STMT to varying.  */\n-\n-void\n-vr_values::set_defs_to_varying (gimple *stmt)\n-{\n-  ssa_op_iter i;\n-  tree def;\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, i, SSA_OP_DEF)\n-    set_def_to_varying (def);\n-}\n-\n-/* Update the value range and equivalence set for variable VAR to\n-   NEW_VR.  Return true if NEW_VR is different from VAR's previous\n-   value.\n-\n-   NOTE: This function assumes that NEW_VR is a temporary value range\n-   object created for the sole purpose of updating VAR's range.  The\n-   storage used by the equivalence set from NEW_VR will be freed by\n-   this function.  Do not call update_value_range when NEW_VR\n-   is the range object associated with another SSA name.  */\n-\n-bool\n-vr_values::update_value_range (const_tree var, value_range_equiv *new_vr)\n-{\n-  value_range_equiv *old_vr;\n-  bool is_new;\n-\n-  /* If there is a value-range on the SSA name from earlier analysis\n-     factor that in.  */\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (var)))\n-    {\n-      value_range_equiv nr;\n-      get_global_range_query ()->range_of_expr (nr, const_cast <tree> (var));\n-      if (!nr.undefined_p ())\n-\tnew_vr->legacy_verbose_intersect (&nr);\n-    }\n-\n-  /* Update the value range, if necessary.  If we cannot allocate a lattice\n-     entry for VAR keep it at VARYING.  This happens when DOM feeds us stmts\n-     with SSA names allocated after setting up the lattice.  */\n-  old_vr = get_lattice_entry (var);\n-  if (!old_vr)\n-    return false;\n-  is_new = !old_vr->equal_p (*new_vr, /*ignore_equivs=*/false);\n-\n-  if (is_new)\n-    {\n-      /* Do not allow transitions up the lattice.  The following\n-\t is slightly more awkward than just new_vr->type < old_vr->type\n-\t because VR_RANGE and VR_ANTI_RANGE need to be considered\n-\t the same.  We may not have is_new when transitioning to\n-\t UNDEFINED.  If old_vr->type is VARYING, we shouldn't be\n-\t called, if we are anyway, keep it VARYING.  */\n-      if (old_vr->varying_p ())\n-\t{\n-\t  new_vr->set_varying (TREE_TYPE (var));\n-\t  is_new = false;\n-\t}\n-      else if (new_vr->undefined_p ())\n-\t{\n-\t  old_vr->set_varying (TREE_TYPE (var));\n-\t  new_vr->set_varying (TREE_TYPE (var));\n-\t  return true;\n-\t}\n-      else\n-\told_vr->set (new_vr->min (), new_vr->max (), new_vr->equiv (),\n-\t\t     new_vr->kind ());\n-    }\n-\n-  new_vr->equiv_clear ();\n-\n-  return is_new;\n-}\n-\n-/* Return true if value range VR involves exactly one symbol SYM.  */\n-\n-static bool\n-symbolic_range_based_on_p (value_range *vr, const_tree sym)\n-{\n-  bool neg, min_has_symbol, max_has_symbol;\n-  tree inv;\n-\n-  if (is_gimple_min_invariant (vr->min ()))\n-    min_has_symbol = false;\n-  else if (get_single_symbol (vr->min (), &neg, &inv) == sym)\n-    min_has_symbol = true;\n-  else\n-    return false;\n-\n-  if (is_gimple_min_invariant (vr->max ()))\n-    max_has_symbol = false;\n-  else if (get_single_symbol (vr->max (), &neg, &inv) == sym)\n-    max_has_symbol = true;\n-  else\n-    return false;\n-\n-  return (min_has_symbol || max_has_symbol);\n-}\n-\n-/* Return true if the result of assignment STMT is know to be non-zero.  */\n-\n-static bool\n-gimple_assign_nonzero_p (gimple *stmt)\n-{\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-  bool strict_overflow_p;\n-  tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n-  switch (get_gimple_rhs_class (code))\n-    {\n-    case GIMPLE_UNARY_RHS:\n-      return tree_unary_nonzero_warnv_p (gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t type,\n-\t\t\t\t\t gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t &strict_overflow_p);\n-    case GIMPLE_BINARY_RHS:\n-      return tree_binary_nonzero_warnv_p (gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t  type,\n-\t\t\t\t\t  gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t  gimple_assign_rhs2 (stmt),\n-\t\t\t\t\t  &strict_overflow_p);\n-    case GIMPLE_TERNARY_RHS:\n-      return false;\n-    case GIMPLE_SINGLE_RHS:\n-      return tree_single_nonzero_warnv_p (gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t  &strict_overflow_p);\n-    case GIMPLE_INVALID_RHS:\n-      gcc_unreachable ();\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Return true if STMT is known to compute a non-zero value.  */\n-\n-static bool\n-gimple_stmt_nonzero_p (gimple *stmt)\n-{\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_ASSIGN:\n-      return gimple_assign_nonzero_p (stmt);\n-    case GIMPLE_CALL:\n-      {\n-        gcall *call_stmt = as_a<gcall *> (stmt);\n-\treturn (gimple_call_nonnull_result_p (call_stmt)\n-\t\t|| gimple_call_nonnull_arg (call_stmt));\n-      }\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-/* Like tree_expr_nonzero_p, but this function uses value ranges\n-   obtained so far.  */\n-\n-bool\n-vr_values::vrp_stmt_computes_nonzero (gimple *stmt)\n-{\n-  if (gimple_stmt_nonzero_p (stmt))\n-    return true;\n-\n-  /* If we have an expression of the form &X->a, then the expression\n-     is nonnull if X is nonnull.  */\n-  if (is_gimple_assign (stmt)\n-      && gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n-    {\n-      tree expr = gimple_assign_rhs1 (stmt);\n-      poly_int64 bitsize, bitpos;\n-      tree offset;\n-      machine_mode mode;\n-      int unsignedp, reversep, volatilep;\n-      tree base = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize,\n-\t\t\t\t       &bitpos, &offset, &mode, &unsignedp,\n-\t\t\t\t       &reversep, &volatilep);\n-\n-      if (base != NULL_TREE\n-\t  && TREE_CODE (base) == MEM_REF\n-\t  && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n-\t{\n-\t  poly_offset_int off = 0;\n-\t  bool off_cst = false;\n-\t  if (offset == NULL_TREE || TREE_CODE (offset) == INTEGER_CST)\n-\t    {\n-\t      off = mem_ref_offset (base);\n-\t      if (offset)\n-\t\toff += poly_offset_int::from (wi::to_poly_wide (offset),\n-\t\t\t\t\t      SIGNED);\n-\t      off <<= LOG2_BITS_PER_UNIT;\n-\t      off += bitpos;\n-\t      off_cst = true;\n-\t    }\n-\t  /* If &X->a is equal to X and X is ~[0, 0], the result is too.\n-\t     For -fdelete-null-pointer-checks -fno-wrapv-pointer we don't\n-\t     allow going from non-NULL pointer to NULL.  */\n-\t  if ((off_cst && known_eq (off, 0))\n-\t      || (flag_delete_null_pointer_checks\n-\t\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))))\n-\t    {\n-\t      const value_range_equiv *vr\n-\t\t= get_value_range (TREE_OPERAND (base, 0), stmt);\n-\t      if (!range_includes_zero_p (vr))\n-\t\treturn true;\n-\t    }\n-\t  /* If MEM_REF has a \"positive\" offset, consider it non-NULL\n-\t     always, for -fdelete-null-pointer-checks also \"negative\"\n-\t     ones.  Punt for unknown offsets (e.g. variable ones).  */\n-\t  if (!TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))\n-\t      && off_cst\n-\t      && known_ne (off, 0)\n-\t      && (flag_delete_null_pointer_checks || known_gt (off, 0)))\n-\t    return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n /* Returns true if EXPR is a valid value (as expected by compare_values) --\n    a gimple invariant, or SSA_NAME +- CST.  */\n \n@@ -478,25 +69,6 @@ valid_value_p (tree expr)\n   return is_gimple_min_invariant (expr);\n }\n \n-/* If OP has a value range with a single constant value return that,\n-   otherwise return NULL_TREE.  This returns OP itself if OP is a\n-   constant.  */\n-\n-tree\n-vr_values::op_with_constant_singleton_value_range (tree op)\n-{\n-  if (is_gimple_min_invariant (op))\n-    return op;\n-\n-  if (TREE_CODE (op) != SSA_NAME)\n-    return NULL_TREE;\n-\n-  tree t;\n-  if (get_value_range (op)->singleton_p (&t))\n-    return t;\n-  return NULL;\n-}\n-\n /* Return true if op is in a boolean [0, 1] value-range.  */\n \n bool\n@@ -519,549 +91,6 @@ simplify_using_ranges::op_with_boolean_value_range_p (tree op, gimple *s)\n \t\t\t     build_one_cst (TREE_TYPE (op)));\n }\n \n-/* Extract value range information for VAR when (OP COND_CODE LIMIT) is\n-   true and store it in *VR_P.  */\n-\n-void\n-vr_values::extract_range_for_var_from_comparison_expr (tree var,\n-\t\t\t\t\t\t       enum tree_code cond_code,\n-\t\t\t\t\t\t       tree op, tree limit,\n-\t\t\t\t\t\t       value_range_equiv *vr_p)\n-{\n-  tree  min, max, type;\n-  const value_range_equiv *limit_vr;\n-  type = TREE_TYPE (var);\n-\n-  /* For pointer arithmetic, we only keep track of pointer equality\n-     and inequality.  If we arrive here with unfolded conditions like\n-     _1 > _1 do not derive anything.  */\n-  if ((POINTER_TYPE_P (type) && cond_code != NE_EXPR && cond_code != EQ_EXPR)\n-      || limit == var)\n-    {\n-      vr_p->set_varying (type);\n-      return;\n-    }\n-\n-  /* If LIMIT is another SSA name and LIMIT has a range of its own,\n-     try to use LIMIT's range to avoid creating symbolic ranges\n-     unnecessarily. */\n-  limit_vr = (TREE_CODE (limit) == SSA_NAME) ? get_value_range (limit) : NULL;\n-\n-  /* LIMIT's range is only interesting if it has any useful information.  */\n-  if (! limit_vr\n-      || limit_vr->undefined_p ()\n-      || limit_vr->varying_p ()\n-      || (limit_vr->symbolic_p ()\n-\t  && ! (limit_vr->kind () == VR_RANGE\n-\t\t&& (limit_vr->min () == limit_vr->max ()\n-\t\t    || operand_equal_p (limit_vr->min (),\n-\t\t\t\t\tlimit_vr->max (), 0)))))\n-    limit_vr = NULL;\n-\n-  /* Initially, the new range has the same set of equivalences of\n-     VAR's range.  This will be revised before returning the final\n-     value.  Since assertions may be chained via mutually exclusive\n-     predicates, we will need to trim the set of equivalences before\n-     we are done.  */\n-  gcc_assert (vr_p->equiv () == NULL);\n-  vr_p->equiv_add (var, get_value_range (var), &vrp_equiv_obstack);\n-\n-  /* Extract a new range based on the asserted comparison for VAR and\n-     LIMIT's value range.  Notice that if LIMIT has an anti-range, we\n-     will only use it for equality comparisons (EQ_EXPR).  For any\n-     other kind of assertion, we cannot derive a range from LIMIT's\n-     anti-range that can be used to describe the new range.  For\n-     instance, ASSERT_EXPR <x_2, x_2 <= b_4>.  If b_4 is ~[2, 10],\n-     then b_4 takes on the ranges [-INF, 1] and [11, +INF].  There is\n-     no single range for x_2 that could describe LE_EXPR, so we might\n-     as well build the range [b_4, +INF] for it.\n-     One special case we handle is extracting a range from a\n-     range test encoded as (unsigned)var + CST <= limit.  */\n-  if (TREE_CODE (op) == NOP_EXPR\n-      || TREE_CODE (op) == PLUS_EXPR)\n-    {\n-      if (TREE_CODE (op) == PLUS_EXPR)\n-        {\n-\t  min = fold_build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (op, 1)),\n-\t\t\t     TREE_OPERAND (op, 1));\n-          max = int_const_binop (PLUS_EXPR, limit, min);\n-\t  op = TREE_OPERAND (op, 0);\n-\t}\n-      else\n-\t{\n-\t  min = build_int_cst (TREE_TYPE (var), 0);\n-\t  max = limit;\n-\t}\n-\n-      /* Make sure to not set TREE_OVERFLOW on the final type\n-\t conversion.  We are willingly interpreting large positive\n-\t unsigned values as negative signed values here.  */\n-      min = force_fit_type (TREE_TYPE (var), wi::to_widest (min), 0, false);\n-      max = force_fit_type (TREE_TYPE (var), wi::to_widest (max), 0, false);\n-\n-      /* We can transform a max, min range to an anti-range or\n-         vice-versa.  Use set_and_canonicalize which does this for\n-         us.  */\n-      if (cond_code == LE_EXPR)\n-\tvr_p->set (min, max, vr_p->equiv ());\n-      else if (cond_code == GT_EXPR)\n-\tvr_p->set (min, max, vr_p->equiv (), VR_ANTI_RANGE);\n-      else\n-\tgcc_unreachable ();\n-    }\n-  else if (cond_code == EQ_EXPR)\n-    {\n-      enum value_range_kind range_kind;\n-\n-      if (limit_vr)\n-\t{\n-\t  range_kind = limit_vr->kind ();\n-\t  min = limit_vr->min ();\n-\t  max = limit_vr->max ();\n-\t}\n-      else\n-\t{\n-\t  range_kind = VR_RANGE;\n-\t  min = limit;\n-\t  max = limit;\n-\t}\n-\n-      vr_p->update (min, max, range_kind);\n-\n-      /* When asserting the equality VAR == LIMIT and LIMIT is another\n-\t SSA name, the new range will also inherit the equivalence set\n-\t from LIMIT.  */\n-      if (TREE_CODE (limit) == SSA_NAME)\n-\tvr_p->equiv_add (limit, get_value_range (limit), &vrp_equiv_obstack);\n-    }\n-  else if (cond_code == NE_EXPR)\n-    {\n-      /* As described above, when LIMIT's range is an anti-range and\n-\t this assertion is an inequality (NE_EXPR), then we cannot\n-\t derive anything from the anti-range.  For instance, if\n-\t LIMIT's range was ~[0, 0], the assertion 'VAR != LIMIT' does\n-\t not imply that VAR's range is [0, 0].  So, in the case of\n-\t anti-ranges, we just assert the inequality using LIMIT and\n-\t not its anti-range.\n-\n-\t If LIMIT_VR is a range, we can only use it to build a new\n-\t anti-range if LIMIT_VR is a single-valued range.  For\n-\t instance, if LIMIT_VR is [0, 1], the predicate\n-\t VAR != [0, 1] does not mean that VAR's range is ~[0, 1].\n-\t Rather, it means that for value 0 VAR should be ~[0, 0]\n-\t and for value 1, VAR should be ~[1, 1].  We cannot\n-\t represent these ranges.\n-\n-\t The only situation in which we can build a valid\n-\t anti-range is when LIMIT_VR is a single-valued range\n-\t (i.e., LIMIT_VR->MIN == LIMIT_VR->MAX).  In that case,\n-\t build the anti-range ~[LIMIT_VR->MIN, LIMIT_VR->MAX].  */\n-      if (limit_vr\n-\t  && limit_vr->kind () == VR_RANGE\n-\t  && compare_values (limit_vr->min (), limit_vr->max ()) == 0)\n-\t{\n-\t  min = limit_vr->min ();\n-\t  max = limit_vr->max ();\n-\t}\n-      else\n-\t{\n-\t  /* In any other case, we cannot use LIMIT's range to build a\n-\t     valid anti-range.  */\n-\t  min = max = limit;\n-\t}\n-\n-      /* If MIN and MAX cover the whole range for their type, then\n-\t just use the original LIMIT.  */\n-      if (INTEGRAL_TYPE_P (type)\n-\t  && vrp_val_is_min (min)\n-\t  && vrp_val_is_max (max))\n-\tmin = max = limit;\n-\n-      vr_p->set (min, max, vr_p->equiv (), VR_ANTI_RANGE);\n-    }\n-  else if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n-    {\n-      min = TYPE_MIN_VALUE (type);\n-\n-      if (limit_vr == NULL || limit_vr->kind () == VR_ANTI_RANGE)\n-\tmax = limit;\n-      else\n-\t{\n-\t  /* If LIMIT_VR is of the form [N1, N2], we need to build the\n-\t     range [MIN, N2] for LE_EXPR and [MIN, N2 - 1] for\n-\t     LT_EXPR.  */\n-\t  max = limit_vr->max ();\n-\t}\n-\n-      /* If the maximum value forces us to be out of bounds, simply punt.\n-\t It would be pointless to try and do anything more since this\n-\t all should be optimized away above us.  */\n-      if (cond_code == LT_EXPR\n-\t  && compare_values (max, min) == 0)\n-\tvr_p->set_varying (TREE_TYPE (min));\n-      else\n-\t{\n-\t  /* For LT_EXPR, we create the range [MIN, MAX - 1].  */\n-\t  if (cond_code == LT_EXPR)\n-\t    {\n-\t      if (TYPE_PRECISION (TREE_TYPE (max)) == 1\n-\t\t  && !TYPE_UNSIGNED (TREE_TYPE (max)))\n-\t\tmax = fold_build2 (PLUS_EXPR, TREE_TYPE (max), max,\n-\t\t\t\t   build_int_cst (TREE_TYPE (max), -1));\n-\t      else\n-\t\tmax = fold_build2 (MINUS_EXPR, TREE_TYPE (max), max,\n-\t\t\t\t   build_int_cst (TREE_TYPE (max), 1));\n-\t      /* Signal to compare_values_warnv this expr doesn't overflow.  */\n-\t      if (EXPR_P (max))\n-\t\tsuppress_warning (max, OPT_Woverflow);\n-\t    }\n-\n-\t  vr_p->update (min, max);\n-\t}\n-    }\n-  else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n-    {\n-      max = TYPE_MAX_VALUE (type);\n-\n-      if (limit_vr == NULL || limit_vr->kind () == VR_ANTI_RANGE)\n-\tmin = limit;\n-      else\n-\t{\n-\t  /* If LIMIT_VR is of the form [N1, N2], we need to build the\n-\t     range [N1, MAX] for GE_EXPR and [N1 + 1, MAX] for\n-\t     GT_EXPR.  */\n-\t  min = limit_vr->min ();\n-\t}\n-\n-      /* If the minimum value forces us to be out of bounds, simply punt.\n-\t It would be pointless to try and do anything more since this\n-\t all should be optimized away above us.  */\n-      if (cond_code == GT_EXPR\n-\t  && compare_values (min, max) == 0)\n-\tvr_p->set_varying (TREE_TYPE (min));\n-      else\n-\t{\n-\t  /* For GT_EXPR, we create the range [MIN + 1, MAX].  */\n-\t  if (cond_code == GT_EXPR)\n-\t    {\n-\t      if (TYPE_PRECISION (TREE_TYPE (min)) == 1\n-\t\t  && !TYPE_UNSIGNED (TREE_TYPE (min)))\n-\t\tmin = fold_build2 (MINUS_EXPR, TREE_TYPE (min), min,\n-\t\t\t\t   build_int_cst (TREE_TYPE (min), -1));\n-\t      else\n-\t\tmin = fold_build2 (PLUS_EXPR, TREE_TYPE (min), min,\n-\t\t\t\t   build_int_cst (TREE_TYPE (min), 1));\n-\t      /* Signal to compare_values_warnv this expr doesn't overflow.  */\n-\t      if (EXPR_P (min))\n-\t\tsuppress_warning (min, OPT_Woverflow);\n-\t    }\n-\n-\t  vr_p->update (min, max);\n-\t}\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  /* Finally intersect the new range with what we already know about var.  */\n-  vr_p->legacy_verbose_intersect (get_value_range (var));\n-}\n-\n-/* Extract value range information from an ASSERT_EXPR EXPR and store\n-   it in *VR_P.  */\n-\n-void\n-vr_values::extract_range_from_assert (value_range_equiv *vr_p, tree expr)\n-{\n-  tree var = ASSERT_EXPR_VAR (expr);\n-  tree cond = ASSERT_EXPR_COND (expr);\n-  tree limit, op;\n-  enum tree_code cond_code;\n-  gcc_assert (COMPARISON_CLASS_P (cond));\n-\n-  /* Find VAR in the ASSERT_EXPR conditional.  */\n-  if (var == TREE_OPERAND (cond, 0)\n-      || TREE_CODE (TREE_OPERAND (cond, 0)) == PLUS_EXPR\n-      || TREE_CODE (TREE_OPERAND (cond, 0)) == NOP_EXPR)\n-    {\n-      /* If the predicate is of the form VAR COMP LIMIT, then we just\n-\t take LIMIT from the RHS and use the same comparison code.  */\n-      cond_code = TREE_CODE (cond);\n-      limit = TREE_OPERAND (cond, 1);\n-      op = TREE_OPERAND (cond, 0);\n-    }\n-  else\n-    {\n-      /* If the predicate is of the form LIMIT COMP VAR, then we need\n-\t to flip around the comparison code to create the proper range\n-\t for VAR.  */\n-      cond_code = swap_tree_comparison (TREE_CODE (cond));\n-      limit = TREE_OPERAND (cond, 0);\n-      op = TREE_OPERAND (cond, 1);\n-    }\n-  extract_range_for_var_from_comparison_expr (var, cond_code, op,\n-\t\t\t\t\t      limit, vr_p);\n-}\n-\n-/* Extract range information from SSA name VAR and store it in VR.  If\n-   VAR has an interesting range, use it.  Otherwise, create the\n-   range [VAR, VAR] and return it.  This is useful in situations where\n-   we may have conditionals testing values of VARYING names.  For\n-   instance,\n-\n-   \tx_3 = y_5;\n-\tif (x_3 > y_5)\n-\t  ...\n-\n-    Even if y_5 is deemed VARYING, we can determine that x_3 > y_5 is\n-    always false.  */\n-\n-void\n-vr_values::extract_range_from_ssa_name (value_range_equiv *vr, tree var)\n-{\n-  const value_range_equiv *var_vr = get_value_range (var);\n-\n-  if (!var_vr->varying_p ())\n-    vr->deep_copy (var_vr);\n-  else\n-    vr->set (var);\n-\n-  if (!vr->undefined_p ())\n-    vr->equiv_add (var, get_value_range (var), &vrp_equiv_obstack);\n-}\n-\n-/* Extract range information from a binary expression OP0 CODE OP1 based on\n-   the ranges of each of its operands with resulting type EXPR_TYPE.\n-   The resulting range is stored in *VR.  */\n-\n-void\n-vr_values::extract_range_from_binary_expr (value_range_equiv *vr,\n-\t\t\t\t\t   enum tree_code code,\n-\t\t\t\t\t   tree expr_type, tree op0, tree op1)\n-{\n-  /* Get value ranges for each operand.  For constant operands, create\n-     a new value range with the operand to simplify processing.  */\n-  value_range vr0, vr1;\n-  if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *(get_value_range (op0));\n-  else if (is_gimple_min_invariant (op0))\n-    vr0.set (op0, op0);\n-  else\n-    vr0.set_varying (TREE_TYPE (op0));\n-\n-  if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = *(get_value_range (op1));\n-  else if (is_gimple_min_invariant (op1))\n-    vr1.set (op1, op1);\n-  else\n-    vr1.set_varying (TREE_TYPE (op1));\n-\n-  /* If one argument is varying, we can sometimes still deduce a\n-     range for the output: any + [3, +INF] is in [MIN+3, +INF].  */\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (op0))\n-      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0)))\n-    {\n-      if (vr0.varying_p () && !vr1.varying_p ())\n-\tvr0 = value_range (vrp_val_min (expr_type), vrp_val_max (expr_type));\n-      else if (vr1.varying_p () && !vr0.varying_p ())\n-\tvr1 = value_range (vrp_val_min (expr_type), vrp_val_max (expr_type));\n-    }\n-\n-  range_fold_binary_expr (vr, code, expr_type, &vr0, &vr1);\n-\n-  /* Set value_range for n in following sequence:\n-     def = __builtin_memchr (arg, 0, sz)\n-     n = def - arg\n-     Here the range for n can be set to [0, PTRDIFF_MAX - 1]. */\n-\n-  if (vr->varying_p ()\n-      && code == POINTER_DIFF_EXPR\n-      && TREE_CODE (op0) == SSA_NAME\n-      && TREE_CODE (op1) == SSA_NAME)\n-    {\n-      tree op0_ptype = TREE_TYPE (TREE_TYPE (op0));\n-      tree op1_ptype = TREE_TYPE (TREE_TYPE (op1));\n-      gcall *call_stmt = NULL;\n-\n-      if (TYPE_MODE (op0_ptype) == TYPE_MODE (char_type_node)\n-\t  && TYPE_PRECISION (op0_ptype) == TYPE_PRECISION (char_type_node)\n-\t  && TYPE_MODE (op1_ptype) == TYPE_MODE (char_type_node)\n-\t  && TYPE_PRECISION (op1_ptype) == TYPE_PRECISION (char_type_node)\n-\t  && (call_stmt = dyn_cast<gcall *>(SSA_NAME_DEF_STMT (op0)))\n-\t  && gimple_call_builtin_p (call_stmt, BUILT_IN_MEMCHR)\n-\t  && operand_equal_p (op0, gimple_call_lhs (call_stmt), 0)\n-\t  && operand_equal_p (op1, gimple_call_arg (call_stmt, 0), 0)\n-\t  && integer_zerop (gimple_call_arg (call_stmt, 1)))\n-\t    {\n-\t      tree max = vrp_val_max (ptrdiff_type_node);\n-\t      wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n-\t      tree range_min = build_zero_cst (expr_type);\n-\t      tree range_max = wide_int_to_tree (expr_type, wmax - 1);\n-\t      vr->set (range_min, range_max, NULL);\n-\t      return;\n-\t    }\n-     }\n-\n-  /* Try harder for PLUS and MINUS if the range of one operand is symbolic\n-     and based on the other operand, for example if it was deduced from a\n-     symbolic comparison.  When a bound of the range of the first operand\n-     is invariant, we set the corresponding bound of the new range to INF\n-     in order to avoid recursing on the range of the second operand.  */\n-  if (vr->varying_p ()\n-      && (code == PLUS_EXPR || code == MINUS_EXPR)\n-      && TREE_CODE (op1) == SSA_NAME\n-      && vr0.kind () == VR_RANGE\n-      && symbolic_range_based_on_p (&vr0, op1))\n-    {\n-      const bool minus_p = (code == MINUS_EXPR);\n-      value_range n_vr1;\n-\n-      /* Try with VR0 and [-INF, OP1].  */\n-      if (is_gimple_min_invariant (minus_p ? vr0.max () : vr0.min ()))\n-\tn_vr1.set (vrp_val_min (expr_type), op1);\n-\n-      /* Try with VR0 and [OP1, +INF].  */\n-      else if (is_gimple_min_invariant (minus_p ? vr0.min () : vr0.max ()))\n-\tn_vr1.set (op1, vrp_val_max (expr_type));\n-\n-      /* Try with VR0 and [OP1, OP1].  */\n-      else\n-\tn_vr1.set (op1, op1);\n-\n-      range_fold_binary_expr (vr, code, expr_type, &vr0, &n_vr1);\n-    }\n-\n-  if (vr->varying_p ()\n-      && (code == PLUS_EXPR || code == MINUS_EXPR)\n-      && TREE_CODE (op0) == SSA_NAME\n-      && vr1.kind () == VR_RANGE\n-      && symbolic_range_based_on_p (&vr1, op0))\n-    {\n-      const bool minus_p = (code == MINUS_EXPR);\n-      value_range n_vr0;\n-\n-      /* Try with [-INF, OP0] and VR1.  */\n-      if (is_gimple_min_invariant (minus_p ? vr1.max () : vr1.min ()))\n-\tn_vr0.set (vrp_val_min (expr_type), op0);\n-\n-      /* Try with [OP0, +INF] and VR1.  */\n-      else if (is_gimple_min_invariant (minus_p ? vr1.min (): vr1.max ()))\n-\tn_vr0.set (op0, vrp_val_max (expr_type));\n-\n-      /* Try with [OP0, OP0] and VR1.  */\n-      else\n-\tn_vr0.set (op0, op0);\n-\n-      range_fold_binary_expr (vr, code, expr_type, &n_vr0, &vr1);\n-    }\n-\n-  /* If we didn't derive a range for MINUS_EXPR, and\n-     op1's range is ~[op0,op0] or vice-versa, then we\n-     can derive a non-null range.  This happens often for\n-     pointer subtraction.  */\n-  if (vr->varying_p ()\n-      && (code == MINUS_EXPR || code == POINTER_DIFF_EXPR)\n-      && TREE_CODE (op0) == SSA_NAME\n-      && ((vr0.kind () == VR_ANTI_RANGE\n-\t   && vr0.min () == op1\n-\t   && vr0.min () == vr0.max ())\n-\t  || (vr1.kind () == VR_ANTI_RANGE\n-\t      && vr1.min () == op0\n-\t      && vr1.min () == vr1.max ())))\n-    {\n-      vr->set_nonzero (expr_type);\n-      vr->equiv_clear ();\n-    }\n-}\n-\n-/* Extract range information from a unary expression CODE OP0 based on\n-   the range of its operand with resulting type TYPE.\n-   The resulting range is stored in *VR.  */\n-\n-void\n-vr_values::extract_range_from_unary_expr (value_range_equiv *vr,\n-\t\t\t\t\t  enum tree_code code,\n-\t\t\t\t\t  tree type, tree op0)\n-{\n-  value_range vr0;\n-\n-  /* Get value ranges for the operand.  For constant operands, create\n-     a new value range with the operand to simplify processing.  */\n-  if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *(get_value_range (op0));\n-  else if (is_gimple_min_invariant (op0))\n-    vr0.set (op0, op0);\n-  else\n-    vr0.set_varying (type);\n-\n-  range_fold_unary_expr (vr, code, type, &vr0, TREE_TYPE (op0));\n-}\n-\n-\n-/* Extract range information from a conditional expression STMT based on\n-   the ranges of each of its operands and the expression code.  */\n-\n-void\n-vr_values::extract_range_from_cond_expr (value_range_equiv *vr, gassign *stmt)\n-{\n-  /* Get value ranges for each operand.  For constant operands, create\n-     a new value range with the operand to simplify processing.  */\n-  tree op0 = gimple_assign_rhs2 (stmt);\n-  value_range_equiv tem0;\n-  const value_range_equiv *vr0 = &tem0;\n-  if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = get_value_range (op0);\n-  else if (is_gimple_min_invariant (op0))\n-    tem0.set (op0);\n-  else\n-    tem0.set_varying (TREE_TYPE (op0));\n-\n-  tree op1 = gimple_assign_rhs3 (stmt);\n-  value_range_equiv tem1;\n-  const value_range_equiv *vr1 = &tem1;\n-  if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = get_value_range (op1);\n-  else if (is_gimple_min_invariant (op1))\n-    tem1.set (op1);\n-  else\n-    tem1.set_varying (TREE_TYPE (op1));\n-\n-  /* The resulting value range is the union of the operand ranges */\n-  vr->deep_copy (vr0);\n-  vr->legacy_verbose_union_ (vr1);\n-}\n-\n-\n-/* Extract range information from a comparison expression EXPR based\n-   on the range of its operand and the expression code.  */\n-\n-void\n-vr_values::extract_range_from_comparison (value_range_equiv *vr,\n-\t\t\t\t\t  gimple *stmt)\n-{\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-  tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n-  tree op0 = gimple_assign_rhs1 (stmt);\n-  tree op1 = gimple_assign_rhs2 (stmt);\n-  bool sop;\n-  tree val\n-    = simplifier.vrp_evaluate_conditional_warnv_with_ops (stmt, code, op0, op1,\n-\t\t\t\t\t\t\t  false, &sop, NULL);\n-  if (val)\n-    {\n-      /* Since this expression was found on the RHS of an assignment,\n-\t its type may be different from _Bool.  Convert VAL to EXPR's\n-\t type.  */\n-      val = fold_convert (type, val);\n-      if (is_gimple_min_invariant (val))\n-\tvr->set (val);\n-      else\n-\tvr->update (val, val);\n-    }\n-  else\n-    /* The result of a comparison is always true or false.  */\n-    set_value_range_to_truthvalue (vr, type);\n-}\n-\n /* Helper function for simplify_internal_call_using_ranges and\n    extract_range_basic.  Return true if OP0 SUBCODE OP1 for\n    SUBCODE {PLUS,MINUS,MULT}_EXPR is known to never overflow or\n@@ -1150,247 +179,25 @@ check_for_binary_op_overflow (range_query *query,\n \t    {\n \t      wmin = wt;\n \t      wmax = wt;\n-\t    }\n-\t  else\n-\t    {\n-\t      wmin = wi::smin (wmin, wt);\n-\t      wmax = wi::smax (wmax, wt);\n-\t    }\n-\t}\n-      /* The result of op0 CODE op1 is known to be in range\n-\t [wmin, wmax].  */\n-      widest_int wtmin = wi::to_widest (vrp_val_min (type));\n-      widest_int wtmax = wi::to_widest (vrp_val_max (type));\n-      /* If all values in [wmin, wmax] are smaller than\n-\t [wtmin, wtmax] or all are larger than [wtmin, wtmax],\n-\t the arithmetic operation will always overflow.  */\n-      if (wmax < wtmin || wmin > wtmax)\n-\treturn true;\n-      return false;\n-    }\n-  return true;\n-}\n-\n-/* Derive a range from a builtin.  Set range in VR and return TRUE if\n-   successful.  */\n-\n-bool\n-vr_values::extract_range_from_ubsan_builtin (value_range_equiv *vr, gimple *stmt)\n-{\n-  gcc_assert (is_gimple_call (stmt));\n-  enum tree_code subcode = ERROR_MARK;\n-  combined_fn cfn = gimple_call_combined_fn (stmt);\n-  scalar_int_mode mode;\n-\n-  switch (cfn)\n-    {\n-    case CFN_UBSAN_CHECK_ADD:\n-      subcode = PLUS_EXPR;\n-      break;\n-    case CFN_UBSAN_CHECK_SUB:\n-      subcode = MINUS_EXPR;\n-      break;\n-    case CFN_UBSAN_CHECK_MUL:\n-      subcode = MULT_EXPR;\n-      break;\n-    default:\n-      break;\n-    }\n-  if (subcode != ERROR_MARK)\n-    {\n-      bool saved_flag_wrapv = flag_wrapv;\n-      /* Pretend the arithmetics is wrapping.  If there is\n-\t any overflow, we'll complain, but will actually do\n-\t wrapping operation.  */\n-      flag_wrapv = 1;\n-      extract_range_from_binary_expr (vr, subcode,\n-\t\t\t\t      TREE_TYPE (gimple_call_arg (stmt, 0)),\n-\t\t\t\t      gimple_call_arg (stmt, 0),\n-\t\t\t\t      gimple_call_arg (stmt, 1));\n-      flag_wrapv = saved_flag_wrapv;\n-\n-      /* If for both arguments vrp_valueize returned non-NULL,\n-\t this should have been already folded and if not, it\n-\t wasn't folded because of overflow.  Avoid removing the\n-\t UBSAN_CHECK_* calls in that case.  */\n-      if (vr->kind () == VR_RANGE\n-\t  && (vr->min () == vr->max ()\n-\t      || operand_equal_p (vr->min (), vr->max (), 0)))\n-\tvr->set_varying (vr->type ());\n-\n-      return !vr->varying_p ();\n-    }\n-  return false;\n-}\n-\n-/* Try to derive a nonnegative or nonzero range out of STMT relying\n-   primarily on generic routines in fold in conjunction with range data.\n-   Store the result in *VR */\n-\n-void\n-vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n-{\n-  bool sop;\n-\n-  if (is_gimple_call (stmt))\n-    {\n-      combined_fn cfn = gimple_call_combined_fn (stmt);\n-      switch (cfn)\n-\t{\n-\tcase CFN_UBSAN_CHECK_ADD:\n-\tcase CFN_UBSAN_CHECK_SUB:\n-\tcase CFN_UBSAN_CHECK_MUL:\n-\t  if (extract_range_from_ubsan_builtin (vr, stmt))\n-\t    return;\n-\t  break;\n-\tdefault:\n-\t  if (fold_range (*vr, stmt, this))\n-\t    {\n-\t      /* The original code nuked equivalences every time a\n-\t\t range was found, so do the same here.  */\n-\t      vr->equiv_clear ();\n-\t      return;\n-\t    }\n-\t  break;\n-\t}\n-    }\n-  /* Handle extraction of the two results (result of arithmetics and\n-     a flag whether arithmetics overflowed) from {ADD,SUB,MUL}_OVERFLOW\n-     internal function.  Similarly from ATOMIC_COMPARE_EXCHANGE.  */\n-  if (is_gimple_assign (stmt)\n-      && (gimple_assign_rhs_code (stmt) == REALPART_EXPR\n-\t  || gimple_assign_rhs_code (stmt) == IMAGPART_EXPR)\n-      && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (stmt))))\n-    {\n-      enum tree_code code = gimple_assign_rhs_code (stmt);\n-      tree op = gimple_assign_rhs1 (stmt);\n-      tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n-      if (TREE_CODE (op) == code && TREE_CODE (TREE_OPERAND (op, 0)) == SSA_NAME)\n-\t{\n-\t  gimple *g = SSA_NAME_DEF_STMT (TREE_OPERAND (op, 0));\n-\t  if (is_gimple_call (g) && gimple_call_internal_p (g))\n+\t    }\n+\t  else\n \t    {\n-\t      enum tree_code subcode = ERROR_MARK;\n-\t      switch (gimple_call_internal_fn (g))\n-\t\t{\n-\t\tcase IFN_ADD_OVERFLOW:\n-\t\t  subcode = PLUS_EXPR;\n-\t\t  break;\n-\t\tcase IFN_SUB_OVERFLOW:\n-\t\t  subcode = MINUS_EXPR;\n-\t\t  break;\n-\t\tcase IFN_MUL_OVERFLOW:\n-\t\t  subcode = MULT_EXPR;\n-\t\t  break;\n-\t\tcase IFN_ATOMIC_COMPARE_EXCHANGE:\n-\t\t  if (code == IMAGPART_EXPR)\n-\t\t    {\n-\t\t      /* This is the boolean return value whether compare and\n-\t\t\t exchange changed anything or not.  */\n-\t\t      vr->set (build_int_cst (type, 0),\n-\t\t\t       build_int_cst (type, 1), NULL);\n-\t\t      return;\n-\t\t    }\n-\t\t  break;\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t      if (subcode != ERROR_MARK)\n-\t\t{\n-\t\t  tree op0 = gimple_call_arg (g, 0);\n-\t\t  tree op1 = gimple_call_arg (g, 1);\n-\t\t  if (code == IMAGPART_EXPR)\n-\t\t    {\n-\t\t      bool ovf = false;\n-\t\t      if (check_for_binary_op_overflow (this, subcode, type,\n-\t\t\t\t\t\t\top0, op1, &ovf))\n-\t\t\tvr->set (build_int_cst (type, ovf));\n-\t\t      else if (TYPE_PRECISION (type) == 1\n-\t\t\t       && !TYPE_UNSIGNED (type))\n-\t\t\tvr->set_varying (type);\n-\t\t      else\n-\t\t\tvr->set (build_int_cst (type, 0),\n-\t\t\t\t build_int_cst (type, 1), NULL);\n-\t\t    }\n-\t\t  else if (types_compatible_p (type, TREE_TYPE (op0))\n-\t\t\t   && types_compatible_p (type, TREE_TYPE (op1)))\n-\t\t    {\n-\t\t      bool saved_flag_wrapv = flag_wrapv;\n-\t\t      /* Pretend the arithmetics is wrapping.  If there is\n-\t\t\t any overflow, IMAGPART_EXPR will be set.  */\n-\t\t      flag_wrapv = 1;\n-\t\t      extract_range_from_binary_expr (vr, subcode, type,\n-\t\t\t\t\t\t      op0, op1);\n-\t\t      flag_wrapv = saved_flag_wrapv;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      value_range_equiv vr0, vr1;\n-\t\t      bool saved_flag_wrapv = flag_wrapv;\n-\t\t      /* Pretend the arithmetics is wrapping.  If there is\n-\t\t\t any overflow, IMAGPART_EXPR will be set.  */\n-\t\t      flag_wrapv = 1;\n-\t\t      extract_range_from_unary_expr (&vr0, NOP_EXPR,\n-\t\t\t\t\t\t     type, op0);\n-\t\t      extract_range_from_unary_expr (&vr1, NOP_EXPR,\n-\t\t\t\t\t\t     type, op1);\n-\t\t      range_fold_binary_expr (vr, subcode, type, &vr0, &vr1);\n-\t\t      flag_wrapv = saved_flag_wrapv;\n-\t\t    }\n-\t\t  return;\n-\t\t}\n+\t      wmin = wi::smin (wmin, wt);\n+\t      wmax = wi::smax (wmax, wt);\n \t    }\n \t}\n+      /* The result of op0 CODE op1 is known to be in range\n+\t [wmin, wmax].  */\n+      widest_int wtmin = wi::to_widest (vrp_val_min (type));\n+      widest_int wtmax = wi::to_widest (vrp_val_max (type));\n+      /* If all values in [wmin, wmax] are smaller than\n+\t [wtmin, wtmax] or all are larger than [wtmin, wtmax],\n+\t the arithmetic operation will always overflow.  */\n+      if (wmax < wtmin || wmin > wtmax)\n+\treturn true;\n+      return false;\n     }\n-  /* None of the below should need a 'type', but we are only called\n-     for assignments and calls with a LHS.  */\n-  tree type = TREE_TYPE (gimple_get_lhs (stmt));\n-  if (INTEGRAL_TYPE_P (type)\n-      && gimple_stmt_nonnegative_warnv_p (stmt, &sop))\n-    set_value_range_to_nonnegative (vr, type);\n-  else if (vrp_stmt_computes_nonzero (stmt))\n-    {\n-      vr->set_nonzero (type);\n-      vr->equiv_clear ();\n-    }\n-  else\n-    vr->set_varying (type);\n-}\n-\n-\n-/* Try to compute a useful range out of assignment STMT and store it\n-   in *VR.  */\n-\n-void\n-vr_values::extract_range_from_assignment (value_range_equiv *vr, gassign *stmt)\n-{\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-\n-  if (code == ASSERT_EXPR)\n-    extract_range_from_assert (vr, gimple_assign_rhs1 (stmt));\n-  else if (code == SSA_NAME)\n-    extract_range_from_ssa_name (vr, gimple_assign_rhs1 (stmt));\n-  else if (TREE_CODE_CLASS (code) == tcc_binary)\n-    extract_range_from_binary_expr (vr, gimple_assign_rhs_code (stmt),\n-\t\t\t\t    TREE_TYPE (gimple_assign_lhs (stmt)),\n-\t\t\t\t    gimple_assign_rhs1 (stmt),\n-\t\t\t\t    gimple_assign_rhs2 (stmt));\n-  else if (TREE_CODE_CLASS (code) == tcc_unary)\n-    extract_range_from_unary_expr (vr, gimple_assign_rhs_code (stmt),\n-\t\t\t\t   TREE_TYPE (gimple_assign_lhs (stmt)),\n-\t\t\t\t   gimple_assign_rhs1 (stmt));\n-  else if (code == COND_EXPR)\n-    extract_range_from_cond_expr (vr, stmt);\n-  else if (TREE_CODE_CLASS (code) == tcc_comparison)\n-    extract_range_from_comparison (vr, stmt);\n-  else if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS\n-\t   && is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n-    vr->set (gimple_assign_rhs1 (stmt));\n-  else\n-    vr->set_varying (TREE_TYPE (gimple_assign_lhs (stmt)));\n-\n-  if (vr->varying_p ())\n-    extract_range_basic (vr, stmt);\n+  return true;\n }\n \n /* Given two numeric value ranges VR0, VR1 and a comparison code COMP:\n@@ -1808,202 +615,6 @@ bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n   return true;\n }\n \n-/* Given a range VR, a LOOP and a variable VAR, determine whether it\n-   would be profitable to adjust VR using scalar evolution information\n-   for VAR.  If so, update VR with the new limits.  */\n-\n-void\n-vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n-\t\t\t\t   gimple *stmt, tree var)\n-{\n-  tree min, max;\n-  if (bounds_of_var_in_loop (&min, &max, this, loop, stmt, var))\n-    {\n-      if (vr->undefined_p () || vr->varying_p ())\n-\t{\n-\t  /* For VARYING or UNDEFINED ranges, just about anything we get\n-\t     from scalar evolutions should be better.  */\n-\t  vr->update (min, max);\n-\t}\n-      else if (vr->kind () == VR_RANGE)\n-\t{\n-\t  /* Start with the input range... */\n-\t  tree vrmin = vr->min ();\n-\t  tree vrmax = vr->max ();\n-\n-\t  /* ...and narrow it down with what we got from SCEV.  */\n-\t  if (compare_values (min, vrmin) == 1)\n-\t    vrmin = min;\n-\t  if (compare_values (max, vrmax) == -1)\n-\t    vrmax = max;\n-\n-\t  vr->update (vrmin, vrmax);\n-\t}\n-      else if (vr->kind () == VR_ANTI_RANGE)\n-\t{\n-\t  /* ?? As an enhancement, if VR, MIN, and MAX are constants, one\n-\t     could just intersect VR with a range of [MIN,MAX].  */\n-\t}\n-    }\n-}\n-\n-/* Dump value ranges of all SSA_NAMEs to FILE.  */\n-\n-void\n-vr_values::dump (FILE *file)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < num_vr_values; i++)\n-    {\n-      if (vr_value[i] && ssa_name (i))\n-\t{\n-\t  print_generic_expr (file, ssa_name (i));\n-\t  fprintf (file, \": \");\n-\t  dump_value_range (file, vr_value[i]);\n-\t  fprintf (file, \"\\n\");\n-\t}\n-    }\n-\n-  fprintf (file, \"\\n\");\n-}\n-\n-/* Initialize VRP lattice.  */\n-\n-vr_values::vr_values () : simplifier (this)\n-{\n-  values_propagated = false;\n-  num_vr_values = num_ssa_names * 2;\n-  vr_value = XCNEWVEC (value_range_equiv *, num_vr_values);\n-  vr_phi_edge_counts = XCNEWVEC (int, num_ssa_names);\n-  bitmap_obstack_initialize (&vrp_equiv_obstack);\n-}\n-\n-/* Free VRP lattice.  */\n-\n-vr_values::~vr_values ()\n-{\n-  /* Free allocated memory.  */\n-  free (vr_value);\n-  free (vr_phi_edge_counts);\n-  bitmap_obstack_release (&vrp_equiv_obstack);\n-\n-  /* So that we can distinguish between VRP data being available\n-     and not available.  */\n-  vr_value = NULL;\n-  vr_phi_edge_counts = NULL;\n-}\n-\n-\n-/* A hack.  */\n-static class vr_values *x_vr_values;\n-\n-/* Return the singleton value-range for NAME or NAME.  */\n-\n-static inline tree\n-vrp_valueize (tree name)\n-{\n-  if (TREE_CODE (name) == SSA_NAME)\n-    {\n-      const value_range_equiv *vr = x_vr_values->get_value_range (name);\n-      if (vr->kind () == VR_RANGE\n-\t  && (TREE_CODE (vr->min ()) == SSA_NAME\n-\t      || is_gimple_min_invariant (vr->min ()))\n-\t  && vrp_operand_equal_p (vr->min (), vr->max ()))\n-\treturn vr->min ();\n-    }\n-  return name;\n-}\n-\n-/* Return the singleton value-range for NAME if that is a constant\n-   but signal to not follow SSA edges.  */\n-\n-static inline tree\n-vrp_valueize_1 (tree name)\n-{\n-  if (TREE_CODE (name) == SSA_NAME)\n-    {\n-      /* If the definition may be simulated again we cannot follow\n-         this SSA edge as the SSA propagator does not necessarily\n-\t re-visit the use.  */\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n-      if (!gimple_nop_p (def_stmt)\n-\t  && prop_simulate_again_p (def_stmt))\n-\treturn NULL_TREE;\n-      const value_range_equiv *vr = x_vr_values->get_value_range (name);\n-      tree singleton;\n-      if (vr->singleton_p (&singleton))\n-\treturn singleton;\n-    }\n-  return name;\n-}\n-\n-/* Given STMT, an assignment or call, return its LHS if the type\n-   of the LHS is suitable for VRP analysis, else return NULL_TREE.  */\n-\n-tree\n-get_output_for_vrp (gimple *stmt)\n-{\n-  if (!is_gimple_assign (stmt) && !is_gimple_call (stmt))\n-    return NULL_TREE;\n-\n-  /* We only keep track of ranges in integral and pointer types.  */\n-  tree lhs = gimple_get_lhs (stmt);\n-  if (TREE_CODE (lhs) == SSA_NAME\n-      && ((INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t   /* It is valid to have NULL MIN/MAX values on a type.  See\n-\t      build_range_type.  */\n-\t   && TYPE_MIN_VALUE (TREE_TYPE (lhs))\n-\t   && TYPE_MAX_VALUE (TREE_TYPE (lhs)))\n-\t  || POINTER_TYPE_P (TREE_TYPE (lhs))))\n-    return lhs;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Visit assignment STMT.  If it produces an interesting range, record\n-   the range in VR and set LHS to OUTPUT_P.  */\n-\n-void\n-vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n-\t\t\t\t\t value_range_equiv *vr)\n-{\n-  tree lhs = get_output_for_vrp (stmt);\n-  *output_p = lhs;\n-\n-  /* We only keep track of ranges in integral and pointer types.  */\n-  if (lhs)\n-    {\n-      enum gimple_code code = gimple_code (stmt);\n-\n-      /* Try folding the statement to a constant first.  */\n-      x_vr_values = this;\n-      tree tem = gimple_fold_stmt_to_constant_1 (stmt, vrp_valueize,\n-\t\t\t\t\t\t vrp_valueize_1);\n-      x_vr_values = NULL;\n-      if (tem)\n-\t{\n-\t  if (TREE_CODE (tem) == SSA_NAME\n-\t      && (SSA_NAME_IS_DEFAULT_DEF (tem)\n-\t\t  || ! prop_simulate_again_p (SSA_NAME_DEF_STMT (tem))))\n-\t    {\n-\t      extract_range_from_ssa_name (vr, tem);\n-\t      return;\n-\t    }\n-\t  else if (is_gimple_min_invariant (tem))\n-\t    {\n-\t      vr->set (tem);\n-\t      return;\n-\t    }\n-\t}\n-      /* Then dispatch to value-range extracting functions.  */\n-      if (code == GIMPLE_CALL)\n-\textract_range_basic (vr, stmt);\n-      else\n-\textract_range_from_assignment (vr, as_a <gassign *> (stmt));\n-    }\n-}\n-\n /* Helper that gets the value range of the SSA_NAME with version I\n    or a symbolic range containing the SSA_NAME only if the value range\n    is varying or undefined.  Uses TEM as storage for the alternate range.  */\n@@ -2352,100 +963,6 @@ simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops\n   return NULL_TREE;\n }\n \n-/* Given (CODE OP0 OP1) within STMT, try to simplify it based on value range\n-   information.  Return NULL if the conditional cannot be evaluated.\n-   The ranges of all the names equivalent with the operands in COND\n-   will be used when trying to compute the value.  If the result is\n-   based on undefined signed overflow, issue a warning if\n-   appropriate.  */\n-\n-tree\n-simplify_using_ranges::vrp_evaluate_conditional (tree_code code, tree op0,\n-\t\t\t\t\t\t tree op1, gimple *stmt)\n-{\n-  bool sop;\n-  tree ret;\n-  bool only_ranges;\n-\n-  /* Some passes and foldings leak constants with overflow flag set\n-     into the IL.  Avoid doing wrong things with these and bail out.  */\n-  if ((TREE_CODE (op0) == INTEGER_CST\n-       && TREE_OVERFLOW (op0))\n-      || (TREE_CODE (op1) == INTEGER_CST\n-\t  && TREE_OVERFLOW (op1)))\n-    return NULL_TREE;\n-\n-  sop = false;\n-  ret = vrp_evaluate_conditional_warnv_with_ops (stmt, code, op0, op1, true,\n-\t\t\t\t\t\t &sop, &only_ranges);\n-\n-  if (ret && sop)\n-    {\n-      enum warn_strict_overflow_code wc;\n-      const char* warnmsg;\n-\n-      if (is_gimple_min_invariant (ret))\n-\t{\n-\t  wc = WARN_STRICT_OVERFLOW_CONDITIONAL;\n-\t  warnmsg = G_(\"assuming signed overflow does not occur when \"\n-\t\t       \"simplifying conditional to constant\");\n-\t}\n-      else\n-\t{\n-\t  wc = WARN_STRICT_OVERFLOW_COMPARISON;\n-\t  warnmsg = G_(\"assuming signed overflow does not occur when \"\n-\t\t       \"simplifying conditional\");\n-\t}\n-\n-      if (issue_strict_overflow_warning (wc))\n-\t{\n-\t  location_t location;\n-\n-\t  if (!gimple_has_location (stmt))\n-\t    location = input_location;\n-\t  else\n-\t    location = gimple_location (stmt);\n-\t  warning_at (location, OPT_Wstrict_overflow, \"%s\", warnmsg);\n-\t}\n-    }\n-\n-  if (warn_type_limits\n-      && ret && only_ranges\n-      && TREE_CODE_CLASS (code) == tcc_comparison\n-      && TREE_CODE (op0) == SSA_NAME)\n-    {\n-      /* If the comparison is being folded and the operand on the LHS\n-\t is being compared against a constant value that is outside of\n-\t the natural range of OP0's type, then the predicate will\n-\t always fold regardless of the value of OP0.  If -Wtype-limits\n-\t was specified, emit a warning.  */\n-      tree type = TREE_TYPE (op0);\n-      const value_range_equiv *vr0 = query->get_value_range (op0, stmt);\n-\n-      if (vr0->varying_p ()\n-\t  && INTEGRAL_TYPE_P (type)\n-\t  && is_gimple_min_invariant (op1))\n-\t{\n-\t  location_t location;\n-\n-\t  if (!gimple_has_location (stmt))\n-\t    location = input_location;\n-\t  else\n-\t    location = gimple_location (stmt);\n-\n-\t  warning_at (location, OPT_Wtype_limits,\n-\t\t      integer_zerop (ret)\n-\t\t      ? G_(\"comparison always false \"\n-                           \"due to limited range of data type\")\n-\t\t      : G_(\"comparison always true \"\n-                           \"due to limited range of data type\"));\n-\t}\n-    }\n-\n-  return ret;\n-}\n-\n-\n /* Visit conditional statement STMT.  If we can determine which edge\n    will be taken out of STMT's basic block, record it in\n    *TAKEN_EDGE_P.  Otherwise, set *TAKEN_EDGE_P to NULL.  */\n@@ -2619,336 +1136,6 @@ find_case_label_ranges (gswitch *stmt, const value_range *vr,\n   return false;\n }\n \n-/* Visit switch statement STMT.  If we can determine which edge\n-   will be taken out of STMT's basic block, record it in\n-   *TAKEN_EDGE_P.  Otherwise, *TAKEN_EDGE_P set to NULL.  */\n-\n-void\n-vr_values::vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n-{\n-  tree op, val;\n-  const value_range_equiv *vr;\n-  size_t i = 0, j = 0, k, l;\n-  bool take_default;\n-\n-  *taken_edge_p = NULL;\n-  op = gimple_switch_index (stmt);\n-  if (TREE_CODE (op) != SSA_NAME)\n-    return;\n-\n-  vr = get_value_range (op);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"\\nVisiting switch expression with operand \");\n-      print_generic_expr (dump_file, op);\n-      fprintf (dump_file, \" with known range \");\n-      dump_value_range (dump_file, vr);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  if (vr->undefined_p ()\n-      || vr->varying_p ()\n-      || vr->symbolic_p ())\n-    return;\n-\n-  /* Find the single edge that is taken from the switch expression.  */\n-  take_default = !find_case_label_ranges (stmt, vr, &i, &j, &k, &l);\n-\n-  /* Check if the range spans no CASE_LABEL. If so, we only reach the default\n-     label */\n-  if (j < i)\n-    {\n-      gcc_assert (take_default);\n-      val = gimple_switch_default_label (stmt);\n-    }\n-  else\n-    {\n-      /* Check if labels with index i to j and maybe the default label\n-\t are all reaching the same label.  */\n-\n-      val = gimple_switch_label (stmt, i);\n-      if (take_default\n-\t  && CASE_LABEL (gimple_switch_default_label (stmt))\n-\t  != CASE_LABEL (val))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"  not a single destination for this \"\n-\t\t     \"range\\n\");\n-\t  return;\n-\t}\n-      for (++i; i <= j; ++i)\n-        {\n-          if (CASE_LABEL (gimple_switch_label (stmt, i)) != CASE_LABEL (val))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"  not a single destination for this \"\n-\t\t\t \"range\\n\");\n-\t      return;\n-\t    }\n-        }\n-      for (; k <= l; ++k)\n-        {\n-          if (CASE_LABEL (gimple_switch_label (stmt, k)) != CASE_LABEL (val))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"  not a single destination for this \"\n-\t\t\t \"range\\n\");\n-\t      return;\n-\t    }\n-        }\n-    }\n-\n-  *taken_edge_p = find_edge (gimple_bb (stmt),\n-\t\t\t     label_to_block (cfun, CASE_LABEL (val)));\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"  will take edge to \");\n-      print_generic_stmt (dump_file, CASE_LABEL (val));\n-    }\n-}\n-\n-\n-/* Evaluate statement STMT.  If the statement produces a useful range,\n-   set VR and corepsponding OUTPUT_P.\n-\n-   If STMT is a conditional branch and we can determine its truth\n-   value, the taken edge is recorded in *TAKEN_EDGE_P.  */\n-\n-void\n-vr_values::extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-\t\t\t\t    tree *output_p, value_range_equiv *vr)\n-{\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"\\nextract_range_from_stmt visiting:\\n\");\n-      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n-    }\n-\n-  if (!stmt_interesting_for_vrp (stmt))\n-    gcc_assert (stmt_ends_bb_p (stmt));\n-  else if (is_gimple_assign (stmt) || is_gimple_call (stmt))\n-    vrp_visit_assignment_or_call (stmt, output_p, vr);\n-  else if (gimple_code (stmt) == GIMPLE_COND)\n-    simplifier.vrp_visit_cond_stmt (as_a <gcond *> (stmt), taken_edge_p);\n-  else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    vrp_visit_switch_stmt (as_a <gswitch *> (stmt), taken_edge_p);\n-}\n-\n-/* Visit all arguments for PHI node PHI that flow through executable\n-   edges.  If a valid value range can be derived from all the incoming\n-   value ranges, set a new range in VR_RESULT.  */\n-\n-void\n-vr_values::extract_range_from_phi_node (gphi *phi,\n-\t\t\t\t\tvalue_range_equiv *vr_result)\n-{\n-  tree lhs = PHI_RESULT (phi);\n-  const value_range_equiv *lhs_vr = get_value_range (lhs);\n-  bool first = true;\n-  int old_edges;\n-  class loop *l;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"\\nVisiting PHI node: \");\n-      print_gimple_stmt (dump_file, phi, 0, dump_flags);\n-    }\n-\n-  bool may_simulate_backedge_again = false;\n-  int edges = 0;\n-  for (size_t i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      edge e = gimple_phi_arg_edge (phi, i);\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file,\n-\t      \"    Argument #%d (%d -> %d %sexecutable)\\n\",\n-\t      (int) i, e->src->index, e->dest->index,\n-\t      (e->flags & EDGE_EXECUTABLE) ? \"\" : \"not \");\n-\t}\n-\n-      if (e->flags & EDGE_EXECUTABLE)\n-\t{\n-\t  value_range_equiv vr_arg_tem;\n-\t  const value_range_equiv *vr_arg = &vr_arg_tem;\n-\n-\t  ++edges;\n-\n-\t  tree arg = PHI_ARG_DEF (phi, i);\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    {\n-\t      /* See if we are eventually going to change one of the args.  */\n-\t      gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n-\t      if (! gimple_nop_p (def_stmt)\n-\t\t  && prop_simulate_again_p (def_stmt)\n-\t\t  && e->flags & EDGE_DFS_BACK)\n-\t\tmay_simulate_backedge_again = true;\n-\n-\t      const value_range_equiv *vr_arg_ = get_value_range (arg);\n-\t      /* Do not allow equivalences or symbolic ranges to leak in from\n-\t\t backedges.  That creates invalid equivalencies.\n-\t\t See PR53465 and PR54767.  */\n-\t      if (e->flags & EDGE_DFS_BACK)\n-\t\t{\n-\t\t  if (!vr_arg_->varying_p () && !vr_arg_->undefined_p ())\n-\t\t    {\n-\t\t      vr_arg_tem.set (vr_arg_->min (), vr_arg_->max (), NULL,\n-\t\t\t\t      vr_arg_->kind ());\n-\t\t      if (vr_arg_tem.symbolic_p ())\n-\t\t\tvr_arg_tem.set_varying (TREE_TYPE (arg));\n-\t\t    }\n-\t\t  else\n-\t\t    vr_arg = vr_arg_;\n-\t\t}\n-\t      /* If the non-backedge arguments range is VR_VARYING then\n-\t\t we can still try recording a simple equivalence.  */\n-\t      else if (vr_arg_->varying_p ())\n-\t\tvr_arg_tem.set (arg);\n-\t      else\n-\t\tvr_arg = vr_arg_;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TREE_OVERFLOW_P (arg))\n-\t\targ = drop_tree_overflow (arg);\n-\n-\t      vr_arg_tem.set (arg);\n-\t    }\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"\\t\");\n-\t      print_generic_expr (dump_file, arg, dump_flags);\n-\t      fprintf (dump_file, \": \");\n-\t      dump_value_range (dump_file, vr_arg);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\n-\t  if (first)\n-\t    vr_result->deep_copy (vr_arg);\n-\t  else\n-\t    vr_result->legacy_verbose_union_ (vr_arg);\n-\t  first = false;\n-\n-\t  if (vr_result->varying_p ())\n-\t    break;\n-\t}\n-    }\n-\n-  if (vr_result->varying_p ())\n-    goto varying;\n-  else if (vr_result->undefined_p ())\n-    goto update_range;\n-\n-  old_edges = vr_phi_edge_counts[SSA_NAME_VERSION (lhs)];\n-  vr_phi_edge_counts[SSA_NAME_VERSION (lhs)] = edges;\n-\n-  /* To prevent infinite iterations in the algorithm, derive ranges\n-     when the new value is slightly bigger or smaller than the\n-     previous one.  We don't do this if we have seen a new executable\n-     edge; this helps us avoid an infinity for conditionals\n-     which are not in a loop.  If the old value-range was VR_UNDEFINED\n-     use the updated range and iterate one more time.  If we will not\n-     simulate this PHI again via the backedge allow us to iterate.  */\n-  if (edges > 0\n-      && gimple_phi_num_args (phi) > 1\n-      && edges == old_edges\n-      && !lhs_vr->undefined_p ()\n-      && may_simulate_backedge_again)\n-    {\n-      /* Compare old and new ranges, fall back to varying if the\n-         values are not comparable.  */\n-      int cmp_min = compare_values (lhs_vr->min (), vr_result->min ());\n-      if (cmp_min == -2)\n-\tgoto varying;\n-      int cmp_max = compare_values (lhs_vr->max (), vr_result->max ());\n-      if (cmp_max == -2)\n-\tgoto varying;\n-\n-      /* For non VR_RANGE or for pointers fall back to varying if\n-\t the range changed.  */\n-      if ((lhs_vr->kind () != VR_RANGE || vr_result->kind () != VR_RANGE\n-\t   || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && (cmp_min != 0 || cmp_max != 0))\n-\tgoto varying;\n-\n-      /* If the new minimum is larger than the previous one\n-\t retain the old value.  If the new minimum value is smaller\n-\t than the previous one and not -INF go all the way to -INF + 1.\n-\t In the first case, to avoid infinite bouncing between different\n-\t minimums, and in the other case to avoid iterating millions of\n-\t times to reach -INF.  Going to -INF + 1 also lets the following\n-\t iteration compute whether there will be any overflow, at the\n-\t expense of one additional iteration.  */\n-      tree new_min = vr_result->min ();\n-      tree new_max = vr_result->max ();\n-      if (cmp_min < 0)\n-\tnew_min = lhs_vr->min ();\n-      else if (cmp_min > 0\n-\t       && (TREE_CODE (vr_result->min ()) != INTEGER_CST\n-\t\t   || tree_int_cst_lt (vrp_val_min (vr_result->type ()),\n-\t\t\t\t       vr_result->min ())))\n-\tnew_min = int_const_binop (PLUS_EXPR,\n-\t\t\t\t   vrp_val_min (vr_result->type ()),\n-\t\t\t\t   build_int_cst (vr_result->type (), 1));\n-\n-      /* Similarly for the maximum value.  */\n-      if (cmp_max > 0)\n-\tnew_max = lhs_vr->max ();\n-      else if (cmp_max < 0\n-\t       && (TREE_CODE (vr_result->max ()) != INTEGER_CST\n-\t\t   || tree_int_cst_lt (vr_result->max (),\n-\t\t\t\t       vrp_val_max (vr_result->type ()))))\n-\tnew_max = int_const_binop (MINUS_EXPR,\n-\t\t\t\t   vrp_val_max (vr_result->type ()),\n-\t\t\t\t   build_int_cst (vr_result->type (), 1));\n-\n-      vr_result->update (new_min, new_max, vr_result->kind ());\n-\n-      /* If we dropped either bound to +-INF then if this is a loop\n-\t PHI node SCEV may known more about its value-range.  */\n-      if (cmp_min > 0 || cmp_min < 0\n-\t   || cmp_max < 0 || cmp_max > 0)\n-\tgoto scev_check;\n-\n-      goto infinite_check;\n-    }\n-\n-  goto update_range;\n-\n-varying:\n-  vr_result->set_varying (TREE_TYPE (lhs));\n-\n-scev_check:\n-  /* If this is a loop PHI node SCEV may known more about its value-range.\n-     scev_check can be reached from two paths, one is a fall through from above\n-     \"varying\" label, the other is direct goto from code block which tries to\n-     avoid infinite simulation.  */\n-  if (scev_initialized_p ()\n-      && (l = loop_containing_stmt (phi))\n-      && l->header == gimple_bb (phi))\n-    adjust_range_with_scev (vr_result, l, phi, lhs);\n-\n-infinite_check:\n-  /* If we will end up with a (-INF, +INF) range, set it to\n-     VARYING.  Same if the previous max value was invalid for\n-     the type and we end up with vr_result.min > vr_result.max.  */\n-  if ((!vr_result->varying_p () && !vr_result->undefined_p ())\n-      && !((vrp_val_is_max (vr_result->max ()) && vrp_val_is_min (vr_result->min ()))\n-\t   || compare_values (vr_result->min (), vr_result->max ()) > 0))\n-    ;\n-  else\n-    vr_result->set_varying (TREE_TYPE (lhs));\n-\n-  /* If the new range is different than the previous value, keep\n-     iterating.  */\n-update_range:\n-  return;\n-}\n-\n /* Simplify boolean operations if the source is known\n    to be already a boolean.  */\n bool\n@@ -3557,8 +1744,7 @@ simplify_using_ranges::fold_cond (gcond *cond)\n       return true;\n     }\n \n-  /* ?? vrp_folder::fold_predicate_in() is a superset of this.  At\n-     some point we should merge all variants of this code.  */\n+  // FIXME: Audit the code below and make sure it never finds anything.\n   edge taken_edge;\n   vrp_visit_cond_stmt (cond, &taken_edge);\n \n@@ -4428,24 +2614,3 @@ simplify_using_ranges::simplify (gimple_stmt_iterator *gsi)\n \n   return false;\n }\n-\n-/* Set the lattice entry for VAR to VR.  */\n-\n-void\n-vr_values::set_vr_value (tree var, value_range_equiv *vr)\n-{\n-  if (SSA_NAME_VERSION (var) >= num_vr_values)\n-    return;\n-  vr_value[SSA_NAME_VERSION (var)] = vr;\n-}\n-\n-/* Swap the lattice entry for VAR with VR and return the old entry.  */\n-\n-value_range_equiv *\n-vr_values::swap_vr_value (tree var, value_range_equiv *vr)\n-{\n-  if (SSA_NAME_VERSION (var) >= num_vr_values)\n-    return NULL;\n-  std::swap (vr_value[SSA_NAME_VERSION (var)], vr);\n-  return vr;\n-}"}, {"sha": "8ee8cc12f8bf12e661acd84b14bb7cfa0555d253", "filename": "gcc/vr-values.h", "status": "modified", "additions": 2, "deletions": 98, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0be1bbedd6379d2645917bfff752486599b2a8/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=ca0be1bbedd6379d2645917bfff752486599b2a8", "patch": "@@ -33,21 +33,14 @@ class simplify_using_ranges\n   simplify_using_ranges (range_query *query = NULL,\n \t\t\t int not_executable_flag = 0);\n   ~simplify_using_ranges ();\n-  void set_range_query (class range_query *q, int not_executable_flag = 0)\n-      { query = q; m_not_executable_flag = not_executable_flag; }\n-\n   bool simplify (gimple_stmt_iterator *);\n-\n-  // ?? These should be cleaned, merged, and made private.\n-  tree vrp_evaluate_conditional (tree_code, tree, tree, gimple *);\n-  void vrp_visit_cond_stmt (gcond *, edge *);\n   bool fold_cond (gcond *);\n+private:\n+  void vrp_visit_cond_stmt (gcond *, edge *);\n   tree vrp_evaluate_conditional_warnv_with_ops (gimple *stmt, enum tree_code,\n \t\t\t\t\t\ttree, tree, bool,\n \t\t\t\t\t\tbool *, bool *);\n   bool simplify_casted_cond (gcond *);\n-\n-private:\n   bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_div_or_mod_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_abs_using_ranges (gimple_stmt_iterator *, gimple *);\n@@ -89,95 +82,6 @@ class simplify_using_ranges\n   vec<edge> m_flag_set_edges;  // List of edges with flag to be cleared.\n };\n \n-/* The VR_VALUES class holds the current view of range information\n-   for all the SSA_NAMEs in the IL.\n-\n-   It can be used to hold context sensitive range information during\n-   a dominator walk or it may be used to hold range information in the\n-   standard VRP pass as ranges are propagated through the lattice to a\n-   steady state.\n-\n-   This information is independent of the range information that gets\n-   attached to SSA_NAMEs.  A pass such as VRP may choose to transfer\n-   the global information it produces into global range information that\n-   gets attached to an SSA_NAME.  It's unclear how useful that global\n-   information will be in a world where we can compute context sensitive\n-   range information fast or perform on-demand queries.  */\n-class vr_values : public range_query\n-{\n- public:\n-  vr_values (void);\n-  ~vr_values (void);\n-\n-  virtual bool range_of_expr (vrange &r, tree expr, gimple *stmt) override;\n-  virtual tree value_of_expr (tree, gimple * = NULL) override;\n-  virtual tree value_on_edge (edge, tree) override;\n-  virtual tree value_of_stmt (gimple *, tree = NULL_TREE) override;\n-  virtual const value_range_equiv *get_value_range (const_tree,\n-\t\t\t\t\t\t    gimple * = NULL) override;\n-  void set_vr_value (tree, value_range_equiv *);\n-  value_range_equiv *swap_vr_value (tree, value_range_equiv *);\n-\n-  void set_def_to_varying (const_tree);\n-  void set_defs_to_varying (gimple *);\n-  bool update_value_range (const_tree, value_range_equiv *);\n-  tree op_with_constant_singleton_value_range (tree);\n-  void adjust_range_with_scev (value_range_equiv *, class loop *,\n-\t\t\t       gimple *, tree);\n-  virtual void dump (FILE *) override;\n-\n-  void extract_range_for_var_from_comparison_expr (tree, enum tree_code,\n-\t\t\t\t\t\t   tree, tree,\n-\t\t\t\t\t\t   value_range_equiv *);\n-  void extract_range_from_phi_node (gphi *, value_range_equiv *);\n-  void extract_range_basic (value_range_equiv *, gimple *);\n-  void extract_range_from_stmt (gimple *, edge *, tree *, value_range_equiv *);\n-\n-  /* Indicate that propagation through the lattice is complete.  */\n-  void set_lattice_propagation_complete (void) { values_propagated = true; }\n-\n-  /* Allocate a new value_range object.  */\n-  value_range_equiv *allocate_value_range_equiv (void)\n-    { return range_query::allocate_value_range_equiv (); }\n-  void free_value_range (value_range_equiv *vr)\n-    { free_value_range_equiv (vr); }\n-\n- private:\n-  value_range_equiv *get_lattice_entry (const_tree);\n-  bool vrp_stmt_computes_nonzero (gimple *);\n-  void extract_range_from_assignment (value_range_equiv *, gassign *);\n-  void extract_range_from_assert (value_range_equiv *, tree);\n-  void extract_range_from_ssa_name (value_range_equiv *, tree);\n-  void extract_range_from_binary_expr (value_range_equiv *, enum tree_code,\n-\t\t\t\t       tree, tree, tree);\n-  void extract_range_from_unary_expr (value_range_equiv *, enum tree_code,\n-\t\t\t\t      tree, tree);\n-  void extract_range_from_cond_expr (value_range_equiv *, gassign *);\n-  void extract_range_from_comparison (value_range_equiv *, gimple *);\n-  void vrp_visit_assignment_or_call (gimple*, tree *, value_range_equiv *);\n-  void vrp_visit_switch_stmt (gswitch *, edge *);\n-  bool extract_range_from_ubsan_builtin (value_range_equiv *, gimple *);\n-\n-  /* This probably belongs in the lattice rather than in here.  */\n-  bool values_propagated;\n-\n-  /* Allocations for equivalences all come from this obstack.  */\n-  bitmap_obstack vrp_equiv_obstack;\n-\n-  /* Value range array.  After propagation, VR_VALUE[I] holds the range\n-     of values that SSA name N_I may take.  */\n-  unsigned int num_vr_values;\n-  value_range_equiv **vr_value;\n-\n-  /* For a PHI node which sets SSA name N_I, VR_COUNTS[I] holds the\n-     number of executable edges we saw the last time we visited the\n-     node.  */\n-  int *vr_phi_edge_counts;\n-  simplify_using_ranges simplifier;\n-};\n-\n-extern tree get_output_for_vrp (gimple *);\n-\n extern bool range_fits_type_p (const value_range *vr,\n \t\t\t       unsigned dest_precision, signop dest_sgn);\n extern bool bounds_of_var_in_loop (tree *min, tree *max, range_query *,"}]}