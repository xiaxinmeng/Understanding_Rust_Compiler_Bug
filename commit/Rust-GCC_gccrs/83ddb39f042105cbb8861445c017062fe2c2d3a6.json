{"sha": "83ddb39f042105cbb8861445c017062fe2c2d3a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNkZGIzOWYwNDIxMDVjYmI4ODYxNDQ1YzAxNzA2MmZlMmMyZDNhNg==", "commit": {"author": {"name": "Daniel Krugler", "email": "daniel.kruegler@googlemail.com", "date": "2012-10-01T16:02:57Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-10-01T16:02:57Z"}, "message": "type_traits (result_of): Provide \"SFINAE-friendly\" (see N3436) implementation.\n\n2012-10-01  Daniel Krugler  <daniel.kruegler@googlemail.com>\n\n\t* include/std/type_traits (result_of): Provide \"SFINAE-friendly\"\n\t(see N3436) implementation.\n\t* testsuite/20_util/result_of/sfinae_friendly_1.cc: New.\n\t* testsuite/20_util/result_of/sfinae_friendly_2.cc: Likewise.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Tweak\n\tdg-error line numbers.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n\nFrom-SVN: r191930", "tree": {"sha": "216d82c40141b19a2abccec486ee06d9d47053a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/216d82c40141b19a2abccec486ee06d9d47053a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83ddb39f042105cbb8861445c017062fe2c2d3a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ddb39f042105cbb8861445c017062fe2c2d3a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83ddb39f042105cbb8861445c017062fe2c2d3a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ddb39f042105cbb8861445c017062fe2c2d3a6/comments", "author": {"login": "Dani-Hub", "id": 431432, "node_id": "MDQ6VXNlcjQzMTQzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/431432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dani-Hub", "html_url": "https://github.com/Dani-Hub", "followers_url": "https://api.github.com/users/Dani-Hub/followers", "following_url": "https://api.github.com/users/Dani-Hub/following{/other_user}", "gists_url": "https://api.github.com/users/Dani-Hub/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dani-Hub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dani-Hub/subscriptions", "organizations_url": "https://api.github.com/users/Dani-Hub/orgs", "repos_url": "https://api.github.com/users/Dani-Hub/repos", "events_url": "https://api.github.com/users/Dani-Hub/events{/privacy}", "received_events_url": "https://api.github.com/users/Dani-Hub/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd8b6dc554e8ca488ec5d3f975250e29b316397c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8b6dc554e8ca488ec5d3f975250e29b316397c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8b6dc554e8ca488ec5d3f975250e29b316397c"}], "stats": {"total": 1065, "additions": 984, "deletions": 81}, "files": [{"sha": "8fd82e7ab6666cbe6a92126f6c62a3417a080c48", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=83ddb39f042105cbb8861445c017062fe2c2d3a6", "patch": "@@ -1,3 +1,15 @@\n+2012-10-01  Daniel Krugler  <daniel.kruegler@googlemail.com>\n+\n+\t* include/std/type_traits (result_of): Provide \"SFINAE-friendly\"\n+\t(see N3436) implementation.\n+\t* testsuite/20_util/result_of/sfinae_friendly_1.cc: New.\n+\t* testsuite/20_util/result_of/sfinae_friendly_2.cc: Likewise.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Tweak\n+\tdg-error line numbers.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tLikewise.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n+\n 2012-09-30  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* doc/doxygen/user.cfg.in: Update to doxygen 1.8.2."}, {"sha": "e8d432c45e9d2083d5153523ee78da8aaf97a854", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 142, "deletions": 61, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=83ddb39f042105cbb8861445c017062fe2c2d3a6", "patch": "@@ -1,7 +1,6 @@\n // C++11 type_traits -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2007-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -1819,89 +1818,171 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Signature>\n     class result_of;\n \n+  // sfinae-friendly result_of implementation. We use enable_if to transport\n+  // both the result information (as the member type) and the failure\n+  // information (no member type).\n+\n+  template<typename _Tp>\n+    using __success_type = enable_if<true, _Tp>;\n+\n+  using __failure_type = enable_if<false>;\n+\n+  // [func.require] paragraph 1 bullet 1:\n+  struct __result_of_memfun_ref_impl\n+  {\n+    template<typename _Fp, typename _Tp1, typename... _Args>\n+      static __success_type<decltype(\n+      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)\n+      )> _S_test(int);\n+\n+    template<typename...>\n+      static __failure_type _S_test(...);\n+  };\n+\n+  template<typename _MemPtr, typename _Arg, typename... _Args>\n+    struct __result_of_memfun_ref\n+    : private __result_of_memfun_ref_impl\n+    {\n+      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;\n+    };\n+\n+  // [func.require] paragraph 1 bullet 2:\n+  struct __result_of_memfun_deref_impl\n+  {\n+    template<typename _Fp, typename _Tp1, typename... _Args>\n+      static __success_type<decltype(\n+      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)\n+      )> _S_test(int);\n+\n+    template<typename...>\n+      static __failure_type _S_test(...);\n+  };\n+\n+  template<typename _MemPtr, typename _Arg, typename... _Args>\n+    struct __result_of_memfun_deref\n+    : private __result_of_memfun_deref_impl\n+    {\n+      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;\n+    };\n+\n+  // [func.require] paragraph 1 bullet 3:\n+  struct __result_of_memobj_ref_impl\n+  {\n+    template<typename _Fp, typename _Tp1>\n+      static __success_type<decltype(\n+      std::declval<_Tp1>().*std::declval<_Fp>()\n+      )> _S_test(int);\n+\n+    template<typename, typename>\n+      static __failure_type _S_test(...);\n+  };\n+\n+  template<typename _MemPtr, typename _Arg>\n+    struct __result_of_memobj_ref\n+    : private __result_of_memobj_ref_impl\n+    {\n+      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;\n+    };\n+\n+  // [func.require] paragraph 1 bullet 4:\n+  struct __result_of_memobj_deref_impl\n+  {\n+    template<typename _Fp, typename _Tp1>\n+      static __success_type<decltype(\n+      (*std::declval<_Tp1>()).*std::declval<_Fp>()\n+      )> _S_test(int);\n+\n+    template<typename, typename>\n+      static __failure_type _S_test(...);\n+  };\n+\n   template<typename _MemPtr, typename _Arg>\n-    struct _Result_of_memobj;\n+    struct __result_of_memobj_deref\n+    : private __result_of_memobj_deref_impl\n+    {\n+      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;\n+    };\n+\n+  template<typename _MemPtr, typename _Arg>\n+    struct __result_of_memobj;\n \n   template<typename _Res, typename _Class, typename _Arg>\n-    struct _Result_of_memobj<_Res _Class::*, _Arg>\n+    struct __result_of_memobj<_Res _Class::*, _Arg>\n     {\n-    private:\n-      typedef _Res _Class::* _Func;\n-\n-      template<typename _Tp>\n-\tstatic _Tp _S_get(const _Class&);\n-      template<typename _Tp>\n-\tstatic _Tp _S_get(const volatile _Class&);\n-      template<typename _Tp>\n-\tstatic decltype(*std::declval<_Tp>()) _S_get(...);\n-        \n-    public:\n-      typedef\n-        decltype(_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())\n-        __type;\n+      typedef typename remove_cv<typename remove_reference<\n+        _Arg>::type>::type _Argval;\n+      typedef _Res _Class::* _MemPtr;\n+      typedef typename conditional<__or_<is_same<_Argval, _Class>,\n+        is_base_of<_Class, _Argval>>::value,\n+        __result_of_memobj_ref<_MemPtr, _Arg>,\n+        __result_of_memobj_deref<_MemPtr, _Arg>\n+      >::type::type type;\n     };\n \n-  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>\n-    struct _Result_of_memfun;\n+  template<typename _MemPtr, typename _Arg, typename... _Args>\n+    struct __result_of_memfun;\n \n   template<typename _Res, typename _Class, typename _Arg, typename... _Args>\n-    struct _Result_of_memfun<_Res _Class::*, _Arg, _Args...>\n+    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>\n     {\n-    private:\n-      typedef _Res _Class::* _Func;\n-\n-      template<typename _Tp>\n-\tstatic _Tp _S_get(const _Class&);\n-      template<typename _Tp>\n-\tstatic _Tp _S_get(const volatile _Class&);\n-      template<typename _Tp>\n-\tstatic decltype(*std::declval<_Tp>()) _S_get(...);\n-        \n-    public:\n-      typedef\n-        decltype((_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())\n-            (std::declval<_Args>()...) )\n-        __type;\n+      typedef typename remove_cv<typename remove_reference<\n+        _Arg>::type>::type _Argval;\n+      typedef _Res _Class::* _MemPtr;\n+      typedef typename conditional<__or_<is_same<_Argval, _Class>,\n+        is_base_of<_Class, _Argval>>::value,\n+        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,\n+        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>\n+      >::type::type type;\n     };\n \n   template<bool, bool, typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl;\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct _Result_of_impl<false, false, _Functor, _ArgTypes...>\n+    struct __result_of_impl\n     {\n-      typedef\n-        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )\n-        __type;\n+      typedef __failure_type type;\n     };\n \n   template<typename _MemPtr, typename _Arg>\n-    struct _Result_of_impl<true, false, _MemPtr, _Arg>\n-    : _Result_of_memobj<typename decay<_MemPtr>::type, _Arg>\n+    struct __result_of_impl<true, false, _MemPtr, _Arg>\n+    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>\n     { };\n \n-  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>\n-    struct _Result_of_impl<false, true, _MemPtr, _Arg, _ArgTypes...>\n-    : _Result_of_memfun<typename decay<_MemPtr>::type, _Arg, _ArgTypes...>\n+  template<typename _MemPtr, typename _Arg, typename... _Args>\n+    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>\n+    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>\n     { };\n \n+  // [func.require] paragraph 1 bullet 5:\n+  struct __result_of_other_impl\n+  {\n+    template<typename _Fn, typename... _Args>\n+      static __success_type<decltype(\n+      std::declval<_Fn>()(std::declval<_Args>()...)\n+      )> _S_test(int);\n+\n+    template<typename...>\n+      static __failure_type _S_test(...);\n+  };\n+\n   template<typename _Functor, typename... _ArgTypes>\n-    struct result_of<_Functor(_ArgTypes...)>\n-    : _Result_of_impl<is_member_object_pointer<\n-                        typename remove_reference<_Functor>::type >::value,\n-                      is_member_function_pointer<\n-\t\t\ttypename remove_reference<_Functor>::type >::value,\n-\t\t      _Functor, _ArgTypes...>\n+    struct __result_of_impl<false, false, _Functor, _ArgTypes...>\n+    : private __result_of_other_impl\n     {\n-      typedef typename _Result_of_impl<\n-\tis_member_object_pointer<\n-\t  typename remove_reference<_Functor>::type >::value,\n-        is_member_function_pointer<\n-\t  typename remove_reference<_Functor>::type >::value,\n-       \t_Functor, _ArgTypes...>::__type\n-\ttype;\n+      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;\n     };\n \n+  template<typename _Functor, typename... _ArgTypes>\n+    struct result_of<_Functor(_ArgTypes...)>\n+    : public __result_of_impl<\n+        is_member_object_pointer<\n+          typename remove_reference<_Functor>::type\n+        >::value,\n+        is_member_function_pointer<\n+          typename remove_reference<_Functor>::type\n+        >::value,\n+\t    _Functor, _ArgTypes...\n+      >::type\n+    { };\n+\t\n   /**\n    *  Use SFINAE to determine if the type _Tp has a publicly-accessible\n    *  member type _NTYPE."}, {"sha": "6b9a4cb950e1f5e678548dc71e7c4d407f307562", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=83ddb39f042105cbb8861445c017062fe2c2d3a6", "patch": "@@ -2,7 +2,7 @@\n // { dg-do compile }\n // 2009-11-12  Paolo Carlini  <paolo.carlini@oracle.com>\n //\n-// Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+// Copyright (C) 2009-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1813 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1812 }\n \n #include <utility>\n "}, {"sha": "3f1d33ba9bd3a0e8862853fbf520f13785d00533", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=83ddb39f042105cbb8861445c017062fe2c2d3a6", "patch": "@@ -3,8 +3,7 @@\n \n // 2007-05-03  Benjamin Kosnik  <bkoz@redhat.com>\n //\n-// Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2007-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -43,11 +42,11 @@ void test01()\n   typedef make_signed<float>::type  \ttest5_type;\n }\n \n-// { dg-error \"does not name a type\" \"\" { target *-*-* } 34 }\n-// { dg-error \"required from here\" \"\" { target *-*-* } 36 }\n-// { dg-error \"required from here\" \"\" { target *-*-* } 38 }\n-// { dg-error \"required from here\" \"\" { target *-*-* } 41 }\n-// { dg-error \"required from here\" \"\" { target *-*-* } 43 }\n+// { dg-error \"does not name a type\" \"\" { target *-*-* } 33 }\n+// { dg-error \"required from here\" \"\" { target *-*-* } 35 }\n+// { dg-error \"required from here\" \"\" { target *-*-* } 37 }\n+// { dg-error \"required from here\" \"\" { target *-*-* } 40 }\n+// { dg-error \"required from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1602 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1566 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1601 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1565 }"}, {"sha": "b13200e067a40f43824978865008cdac865b38e5", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=83ddb39f042105cbb8861445c017062fe2c2d3a6", "patch": "@@ -3,8 +3,7 @@\n \n // 2007-05-03  Benjamin Kosnik  <bkoz@redhat.com>\n //\n-// Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2007-2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -43,11 +42,11 @@ void test01()\n   typedef make_unsigned<float>::type  \t\ttest5_type;\n }\n \n-// { dg-error \"does not name a type\" \"\" { target *-*-* } 34 }\n-// { dg-error \"required from here\" \"\" { target *-*-* } 36 }\n-// { dg-error \"required from here\" \"\" { target *-*-* } 38 }\n-// { dg-error \"required from here\" \"\" { target *-*-* } 41 }\n-// { dg-error \"required from here\" \"\" { target *-*-* } 43 }\n+// { dg-error \"does not name a type\" \"\" { target *-*-* } 33 }\n+// { dg-error \"required from here\" \"\" { target *-*-* } 35 }\n+// { dg-error \"required from here\" \"\" { target *-*-* } 37 }\n+// { dg-error \"required from here\" \"\" { target *-*-* } 40 }\n+// { dg-error \"required from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1520 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1484 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1519 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1483 }"}, {"sha": "3ea9e60078c29e7225b417f22816c7a492039b89", "filename": "libstdc++-v3/testsuite/20_util/result_of/sfinae_friendly_1.cc", "status": "added", "additions": 736, "deletions": 0, "changes": 736, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc?ref=83ddb39f042105cbb8861445c017062fe2c2d3a6", "patch": "@@ -0,0 +1,736 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <cstddef>\n+#include <type_traits>\n+\n+// TODO: Uncomment the following define once gcc has fixed bug 52748\n+// (incomplete types in function call expressions):\n+//#define HAS_52748_FIXED\n+\n+// Helper types:\n+struct has_type_impl\n+{\n+  template<class T, class = typename T::type>\n+  static std::true_type test(int);\n+\n+  template<class>\n+  static std::false_type test(...);\n+};\n+\n+template<class T>\n+struct has_type : decltype(has_type_impl::test<T>(0))\n+{};\n+\n+template<class T, class Res>\n+struct is_expected_type : std::is_same<typename T::type, Res>\n+{};\n+\n+template<class T, class Res>\n+struct is_type : std::__and_<has_type<T>, is_expected_type<T, Res>>\n+{};\n+\n+// Types under inspection:\n+\n+typedef bool (&PF1)();\n+typedef short (*PF2)(long);\n+\n+struct S {\n+  operator PF2() const;\n+  double operator()(char, int&);\n+  void calc(long) const;\n+};\n+\n+typedef void (S::*PMS)(long) const;\n+typedef void (S::*PMSnonconst)(long);\n+\n+typedef int S::* PMI;\n+\n+struct B {\n+  int i;\n+  void f1() const;\n+  bool f2(int) const volatile;\n+};\n+\n+struct D : B {};\n+\n+typedef void (B::*base_func_void)() const;\n+typedef bool (B::*base_func_bool_int)(int) const volatile;\n+\n+struct ident_functor {\n+  template<class T>\n+  T operator()(T&& x);\n+};\n+\n+template<class Ret = void>\n+struct variable_functor {\n+  template<class... T>\n+  Ret operator()(T&&...);\n+};\n+\n+struct ident_functor_noref {\n+  template<class T>\n+  typename std::remove_reference<T>::type operator()(T&& x);\n+};\n+\n+enum class ScEn;\n+\n+enum UnScEn : int;\n+\n+union U {\n+  int i;\n+  double d;\n+};\n+\n+union U2 {\n+  int i;\n+  bool b;\n+  void operator()() const;\n+  int operator()(double) const;\n+  bool operator()(double);\n+  U operator()(int, int);\n+};\n+\n+struct Ukn;\n+\n+typedef Ukn (S::*PMSIncomplete)(long) const;\n+typedef Ukn (S::*PMSIncompletenonconst)(long);\n+typedef Ukn (*FuncIncomplete)(long);\n+\n+struct Abstract {\n+  virtual ~Abstract() = 0;\n+};\n+\n+struct Private {\n+private:\n+  void operator()();\n+  int operator()(int);\n+public:\n+  bool operator()(std::nullptr_t);\n+};\n+\n+union PrivateUnion {\n+  double d;\n+private:\n+  void operator()();\n+  int operator()(int);\n+public:\n+  bool operator()(std::nullptr_t);\n+};\n+\n+template<class T>\n+struct ImplicitTo {\n+  operator T();\n+};\n+\n+template<class>\n+struct never { static const bool value = false; };\n+\n+template<class T>\n+struct BrokenTrait {\n+  static_assert(never<T>::value, \"Error!\");\n+  typedef T type;\n+};\n+\n+template<class T>\n+struct BadSmartPtr : T {\n+  T& operator*() const noexcept(typename BrokenTrait<T>::type());\n+};\n+\n+template<class Ret>\n+using FuncEllipses = Ret(...);\n+\n+static_assert(is_type<std::result_of<S(int)>, short>::value, \"Error!\");\n+static_assert(is_type<std::result_of<S&(unsigned char, int&)>,\n+\t      double>::value, \"Error!\");\n+static_assert(is_type<std::result_of<PF1()>, bool>::value, \"Error!\");\n+static_assert(is_type<std::result_of<PF1&()>, bool>::value, \"Error!\");\n+static_assert(is_type<std::result_of<PMS(std::unique_ptr<S>, int)>,\n+\t      void>::value, \"Error!\");\n+static_assert(is_type<std::result_of<PMS(std::unique_ptr<S>&, unsigned&)>,\n+\t      void>::value, \"Error!\");\n+static_assert(is_type<std::result_of<PMS&(std::unique_ptr<S>, int)>,\n+\t      void>::value, \"Error!\");\n+static_assert(is_type<std::result_of<PMS&(std::unique_ptr<S>&, unsigned&)>,\n+\t      void>::value, \"Error!\");\n+\n+static_assert(is_type<std::result_of<ident_functor(int)>,\n+\t      int>::value, \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(const int)>,\n+\t      int>::value, \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(const int&&)>,\n+\t      int>::value, \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(int&&)>,\n+\t      int>::value, \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(int&)>,\n+\t      int&>::value, \"Error!\");\n+\n+static_assert(is_type<std::result_of<ident_functor(const B)>,\n+\t      B>::value, \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(const B&&)>,\n+\t      const B>::value, \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(B&&)>, B>::value, \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(B&)>, B&>::value, \"Error!\");\n+\n+static_assert(is_type<std::result_of<int B::*(B&)>, int&>::value, \"Error!\");\n+\n+// This is expected as of CWG 616 P/R:\n+static_assert(is_type<std::result_of<int B::*(B)>, int&&>::value, \"Error!\");\n+\n+static_assert(is_type<std::result_of<volatile int B::*(const B&&)>,\n+\t      const volatile int&&>::value, \"Error!\");\n+static_assert(is_type<std::result_of<const int B::*(volatile B&&)>,\n+\t      const volatile int&&>::value, \"Error!\");\n+\n+static_assert(is_type<std::result_of<int B::*(const B&)>,\n+\t      const int&>::value, \"Error!\");\n+static_assert(is_type<std::result_of<volatile int B::*(const B&)>,\n+\t      const volatile int&>::value, \"Error!\");\n+static_assert(is_type<std::result_of<const int B::*(volatile B&)>,\n+\t      const volatile int&>::value, \"Error!\");\n+\n+static_assert(is_type<std::result_of<int B::*(B*)>, int&>::value, \"Error!\");\n+static_assert(is_type<std::result_of<int B::*(B*&)>, int&>(), \"Error!\");\n+static_assert(is_type<std::result_of<int B::*(const B*)>,\n+\t      const int&>::value, \"Error!\");\n+static_assert(is_type<std::result_of<int B::*(const B*&)>,\n+\t      const int&>::value, \"Error!\");\n+static_assert(is_type<std::result_of<volatile int B::*(const B*)>,\n+\t      const volatile int&>::value, \"Error!\");\n+static_assert(is_type<std::result_of<const int B::*(volatile B*)>,\n+\t      const volatile int&>::value, \"Error!\");\n+\n+static_assert(is_type<std::result_of<base_func_void(const B&)>,\n+\t      void>::value, \"Error!\");\n+static_assert(is_type<std::result_of<base_func_void(const B*)>,\n+\t      void>::value, \"Error!\");\n+static_assert(is_type<std::result_of<base_func_void(B&)>,\n+\t      void>::value, \"Error!\");\n+static_assert(is_type<std::result_of<base_func_void(B*)>,\n+\t      void>::value, \"Error!\");\n+\n+static_assert(!has_type<std::result_of<base_func_void(volatile B&)>>::value,\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<base_func_void(volatile B*)>>::value,\n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<base_func_bool_int(B&, long)>,\n+\t      bool>::value, \"Error!\");\n+static_assert(is_type<std::result_of<base_func_bool_int(B*, long)>,\n+\t      bool>::value, \"Error!\");\n+static_assert(is_type<std::result_of<base_func_bool_int(volatile B&, long)>,\n+\t      bool>::value, \"Error!\");\n+static_assert(is_type<std::result_of<base_func_bool_int(volatile B*, long)>,\n+\t      bool>::value, \"Error!\");\n+\n+static_assert(!has_type<std::result_of<int()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<void()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<int(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<void(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PF1(int)>>(), \"Error!\");\n+static_assert(is_type<std::result_of<PF2(long)>, short>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PF2()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PF2(B)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PF2(ScEn)>>(), \"Error!\");\n+static_assert(is_type<std::result_of<PF2(UnScEn)>, short>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PF2(long, int)>>(), \"Error!\");\n+static_assert(is_type<std::result_of<PMS(std::unique_ptr<S>, int)>, void>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(int, std::unique_ptr<S>)>>(), \"Error!\");\n+\n+// Argument number mismatch:\n+static_assert(!has_type<std::result_of<PMS(std::unique_ptr<S>)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(std::unique_ptr<S>&)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(std::unique_ptr<S>, int, bool)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(std::unique_ptr<S>&, int, bool)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(S)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(S&)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(S, int, bool)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(S&, int, bool)>>(), \"Error!\");\n+\n+// Non-convertible arguments:\n+static_assert(!has_type<std::result_of<PMS(std::unique_ptr<S>, S)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(std::unique_ptr<S>&, S)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(S, S)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMS(S&, S)>>(), \"Error!\");\n+\n+// cv-violations:\n+static_assert(!has_type<std::result_of<PMSnonconst(const S&, long)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PMSnonconst(const S&&, long)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PMSnonconst(const S*, long)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PMSnonconst(const S*&, long)>>(),\n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<PMI(S*)>, int&>(), \"Error!\");\n+static_assert(is_type<std::result_of<PMI(S&)>, int&>(), \"Error!\");\n+static_assert(is_type<std::result_of<PMI(S&&)>, int&&>(), \"Error!\");\n+static_assert(is_type<std::result_of<PMI(S)>, int&&>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<PMI()>>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<PMI(S*, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMI(S&, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMI(S*, int, S, bool)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMI(S&, int, S, bool)>>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<PMI(B*)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PMI(B&)>>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<int U::*(U)>, int&&>(), \"Error!\");\n+static_assert(is_type<std::result_of<int U::*(U&)>, int&>(), \"Error!\");\n+static_assert(is_type<std::result_of<int U::*(const U&)>, const int&>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <volatile int U::*(const U&)>, const volatile int&>(), \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <const int U::*(volatile U&)>, const volatile int&>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<int Ukn::*(Ukn*)>, int&>(), \"Error!\");\n+static_assert(is_type<std::result_of<int Ukn::*(Ukn&)>, int&>(), \"Error!\");\n+static_assert(is_type<std::result_of<int Ukn::*(Ukn&&)>, int&&>(), \"Error!\");\n+static_assert(is_type<std::result_of<int Ukn::*(const Ukn*)>, const int&>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<int Ukn::*(const Ukn&)>, const int&>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<int Ukn::*(const Ukn&&)>, const int&&>(),\n+\t      \"Error!\");\n+\n+typedef void (Ukn::* PUfnMF)();\n+typedef void (Ukn::* PUfnConstMF)() const;\n+\n+static_assert(is_type<std::result_of<PUfnMF(Ukn*)>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<PUfnMF(Ukn&)>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<PUfnMF(Ukn&&)>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<PUfnConstMF(Ukn*)>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<PUfnConstMF(Ukn&)>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<PUfnConstMF(Ukn&&)>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<PUfnConstMF(const Ukn*)>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<PUfnConstMF(const Ukn&)>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<PUfnConstMF(const Ukn&&)>, void>(),\n+\t      \"Error!\");\n+\n+static_assert(!has_type<std::result_of<S()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<S(int, S)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<S(S)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <S(double, bool, std::nullptr_t, Ukn&)>>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<U2()>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<const U2&()>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<U2&()>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<U2(double)>, bool>(), \"Error!\");\n+static_assert(is_type<std::result_of<const U2&(double)>, int>(), \"Error!\");\n+static_assert(is_type<std::result_of<U2&(double)>, bool>(), \"Error!\");\n+static_assert(is_type<std::result_of<U2(int)>, bool>(), \"Error!\");\n+static_assert(is_type<std::result_of<U2&(int)>, bool>(), \"Error!\");\n+static_assert(is_type<std::result_of<const U2&(int)>, int>(), \"Error!\");\n+static_assert(is_type<std::result_of<U2(int, int)>, U>(), \"Error!\");\n+static_assert(is_type<std::result_of<U2&(int, int)>, U>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<const U2&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<U2(int, int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<U2&(int, int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const U2&(int, int, int)>>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<ident_functor(int)>, int>(), \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(const volatile int)>,\n+\t      int>(), \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(int&)>, int&>(), \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(const volatile int&)>,\n+\t      const volatile int&>(), \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(int&&)>, int>(), \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(const volatile int&&)>,\n+\t      int>(), \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(Abstract&)>, Abstract&>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(const volatile Abstract&)>,\n+\t      const volatile Abstract&>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<ident_functor(int(&&)[1])>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor(Abstract&&)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor(const int(&&)[1])>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor(const Abstract&&)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor_noref(int(&)[1])>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor_noref\n+\t      (const int(&)[1])>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor_noref(Abstract&)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <ident_functor_noref(const Abstract&)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor_noref(void(&)())>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor_noref(void(&&)())>>(),\n+\t      \"Error!\");\n+\n+static_assert(!has_type<std::result_of<ident_functor()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<ident_functor(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const ident_functor&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const ident_functor&&(int)>>(),\n+\t      \"Error!\");\n+\n+// Border-line case:\n+static_assert(!has_type<std::result_of<int S::*(Ukn*)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<void (S::*(Ukn*))()>>(), \"Error!\");\n+\n+// We want to allow this, it seems to be required by the order described \n+// in [func.require] p1:\n+static_assert(is_type<std::result_of<int S::*(BadSmartPtr<S>&)>, int&>(),\n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<Private(std::nullptr_t)>, bool>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<Private&(std::nullptr_t)>, bool>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<Private&&(std::nullptr_t)>, bool>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<Private(ImplicitTo<std::nullptr_t>)>,\n+\t      bool>(), \"Error!\");\n+static_assert(is_type<std::result_of<Private&(ImplicitTo<std::nullptr_t>)>,\n+\t      bool>(), \"Error!\");\n+static_assert(is_type<std::result_of<Private&&(ImplicitTo<std::nullptr_t>)>,\n+\t      bool>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<const Private&(std::nullptr_t)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&&(std::nullptr_t)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<Private()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private&&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private&&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private&&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&&(int, int)>>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<Private(ScEn)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private(UnScEn)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&(ScEn)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&(UnScEn)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private(ImplicitTo<ScEn>)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<Private(ImplicitTo<UnScEn>)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&(ImplicitTo<ScEn>)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const Private&(ImplicitTo<UnScEn>)>>(),\n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<PrivateUnion(std::nullptr_t)>, bool>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<PrivateUnion&(std::nullptr_t)>, bool>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<PrivateUnion&&(std::nullptr_t)>, bool>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<PrivateUnion(ImplicitTo<std::nullptr_t>)>,\n+\t      bool>(), \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <PrivateUnion&(ImplicitTo<std::nullptr_t>)>, bool>(), \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <PrivateUnion&&(ImplicitTo<std::nullptr_t>)>, bool>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<const PrivateUnion&(std::nullptr_t)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const PrivateUnion&&(std::nullptr_t)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const PrivateUnion&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const PrivateUnion&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const PrivateUnion&(int, int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion&&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion&&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion&&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const PrivateUnion&&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const PrivateUnion&&(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const PrivateUnion&&(int, int)>>(),\n+\t      \"Error!\");\n+\n+static_assert(!has_type<std::result_of<PrivateUnion(ScEn)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion(UnScEn)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const PrivateUnion&(ScEn)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<const PrivateUnion&(UnScEn)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion(ImplicitTo<ScEn>)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<PrivateUnion(ImplicitTo<UnScEn>)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const PrivateUnion&(ImplicitTo<ScEn>)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const PrivateUnion&(ImplicitTo<UnScEn>)>>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<void(*(bool))(int)>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<void(*(UnScEn))(int)>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<void(*(ImplicitTo<int>))(int)>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<void(*(ImplicitTo<int>&))(int)>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<void(*(ImplicitTo<int>&&))(int)>, void>(),\n+\t      \"Error!\");\n+\n+static_assert(!has_type<std::result_of<void(*(ScEn))(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <void(*(const ImplicitTo<int>&))(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <void(*(const ImplicitTo<int>&&))(int)>>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<ImplicitTo<void(*)()>()>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<ImplicitTo<void(&)()>()>, void>(),\n+\t      \"Error!\");\n+\n+static_assert(!has_type<std::result_of<ImplicitTo<void(*)()>(int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<ImplicitTo<void(*)(int)>()>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<ImplicitTo<void(&)()>(int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<ImplicitTo<void(&)(int)>()>>(),\n+\t      \"Error!\");\n+\n+// Conversion operators of types are not considered in call expressions\n+// (except for conversion to function pointer/reference):\n+static_assert(!has_type<std::result_of<ImplicitTo<S>(char, int&)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<ImplicitTo<ident_functor>(int)>>(),\n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<variable_functor<>()>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<>(int)>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<>(int, int)>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<>(int, int, int)>,\n+\t      void>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<variable_functor<>&()>, void>(), \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<>&(int)>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<>&(int, int)>, void>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<>&(int, int, int)>,\n+\t      void>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<const variable_functor<>()>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const variable_functor<>(int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const variable_functor<>(int, int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<>(int, int, int)>>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<const variable_functor<>&()>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const variable_functor<>&(int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<>&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<>&(int, int, int)>>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<variable_functor<S>()>, S>(), \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<S>(int)>, S>(), \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<S>(int, int)>, S>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<S>(int, int, int)>, S>(),\n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<variable_functor<S>&()>, S>(), \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<S>&(int)>, S>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<S>&(int, int)>, S>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <variable_functor<S>&(int, int, int)>, S>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<S>()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<S>(int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<S>(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<S>(int, int, int)>>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<const variable_functor<S>&()>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const variable_functor<S>&(int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<S>&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<S>&(int, int, int)>>(), \"Error!\");\n+\n+#if defined(HAS_52748_FIXED)\n+static_assert(has_type<std::result_of<variable_functor<Ukn>()>>(), \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<Ukn>()>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<Ukn>(int)>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<Ukn>(int, int)>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <variable_functor<Ukn>(int, int, int)>, Ukn>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<variable_functor<Ukn>&()>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<variable_functor<Ukn>&(int)>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <variable_functor<Ukn>&(int, int)>, Ukn>(), \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <variable_functor<Ukn>&(int, int, int)>, Ukn>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<PMSIncomplete(int)>, Ukn>(), \"Error!\");\n+static_assert(is_type<std::result_of<PMSIncomplete&(int)>, Ukn>(), \"Error!\");\n+static_assert(is_type<std::result_of<PMSIncomplete&&(int)>, Ukn>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<FuncIncomplete(int)>, Ukn>(), \"Error!\");\n+static_assert(is_type<std::result_of<FuncIncomplete&(int)>, Ukn>(), \"Error!\");\n+static_assert(is_type<std::result_of<FuncIncomplete&&(int)>, Ukn>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<FuncEllipses<Ukn>*()>, Ukn>(), \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<Ukn>&()>, Ukn>(), \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<Ukn>&&()>, Ukn>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<FuncEllipses<Ukn>*(bool)>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<Ukn>&(bool)>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<Ukn>&&(bool)>, Ukn>(),\n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<FuncEllipses<Ukn>*(bool, int, S)>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<Ukn>&(bool, int, S)>, Ukn>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <FuncEllipses<Ukn>&&(bool, int, S)>, Ukn>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<PMSIncompletenonconst(const S*)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S*, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S*, int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S*, int, int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S*&)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S*&, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S*&, int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S*&, int, int, int)>>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S&)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S&, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S&, int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S&, int, int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S&&)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S&&, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S&&, int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <PMSIncompletenonconst(const S&&, int, int, int)>>(), \"Error!\");\n+#endif\n+\n+static_assert(!has_type<std::result_of<const variable_functor<Ukn>()>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const variable_functor<Ukn>(int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<Ukn>(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<Ukn>(int, int, int)>>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<const variable_functor<Ukn>&()>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<const variable_functor<Ukn>&(int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<Ukn>&(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of\n+\t      <const variable_functor<Ukn>&(int, int, int)>>(), \"Error!\");\n+\n+static_assert(!has_type<std::result_of<FuncIncomplete()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<FuncIncomplete(S)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<FuncIncomplete(int, int)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<FuncIncomplete(int, int, int)>>(),\n+\t      \"Error!\");\n+\n+static_assert(!has_type<std::result_of<FuncIncomplete&&()>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<FuncIncomplete&&(S)>>(), \"Error!\");\n+static_assert(!has_type<std::result_of<FuncIncomplete&&(int, int)>>(),\n+\t      \"Error!\");\n+static_assert(!has_type<std::result_of<FuncIncomplete&&(int, int, int)>>(),\n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<FuncEllipses<int>*()>, int>(), \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<int>&()>, int>(), \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<int>&&()>, int>(), \"Error!\");\n+\n+static_assert(is_type<std::result_of<FuncEllipses<int>*(bool)>, int>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<int>&(bool)>, int>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<int>&&(bool)>, int>(), \n+\t      \"Error!\");\n+\n+static_assert(is_type<std::result_of<FuncEllipses<int>*(bool, int, S)>, int>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of<FuncEllipses<int>&(bool, int, S)>, int>(),\n+\t      \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <FuncEllipses<int>&&(bool, int, S)>, int>(), \"Error!\");\n+"}, {"sha": "57dcc5f66d13984d16b6563df042576ca22b23cb", "filename": "libstdc++-v3/testsuite/20_util/result_of/sfinae_friendly_2.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ddb39f042105cbb8861445c017062fe2c2d3a6/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_2.cc?ref=83ddb39f042105cbb8861445c017062fe2c2d3a6", "patch": "@@ -0,0 +1,76 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Taken from N3436:\n+\n+#include <type_traits>\n+#include <string>\n+\n+struct eat { template<class T> eat(T const &) {} };\n+struct not_incrementable {};\n+\n+struct inc {\n+ template<class T>\n+ auto operator()(T t) const -> decltype(t++)\n+ { return t++; }\n+};\n+\n+template<class A>\n+typename std::result_of<inc(A)>::type // sfinae here\n+try_inc(A a) {\n+  return inc()(a);\n+}\n+\n+not_incrementable\n+try_inc(eat) {\n+  return not_incrementable();\n+}\n+\n+template<class>\n+struct never { static const bool value = false; };\n+\n+template<class T>\n+struct Fail\n+{\n+  static_assert(never<T>::value, \"duh\");\n+  typedef int type;\n+};\n+\n+struct Fun\n+{\n+  template<class T>\n+  typename Fail<T>::type operator()(T)\n+  { return 0; }\n+};\n+\n+template<class T>\n+typename std::result_of<Fun(T)>::type foo(T)\n+{ return 0; }\n+\n+template<class>\n+int foo(...)\n+{ return 0; }\n+\n+void result_of_sfinae() {\n+  int x = try_inc(1); // OK\n+  not_incrementable y = try_inc(std::string(\"foo\")); // OK, not_incrementable\n+  (void) x;\n+  (void) y;\n+}"}]}