{"sha": "6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJkYjgxNDFlY2I3ZTIzYTI2OWUxZGFjMWRkOThmY2Y3YjVlNmI4Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-05-19T10:44:22Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-05-19T10:44:22Z"}, "message": "Implement anonymous structs.\n\n\t* cp-tree.h (ANON_AGGR_TYPE_P): Rename from ANON_UNION_TYPE_P.\n\t* class.c, decl.c, decl2.c, init.c, pt.c, search.c, typeck.c: Adjust.\n\t* class.c (finish_struct_1): Remove redundant check for anon struct.\n\t* decl.c (fixup_anonymous_aggr): Renamed from fixup_anonymous_union.\n\t(check_tag_decl): Check for anonymous struct here.\n\t* decl2.c (build_anon_union_vars): Catch anon struct at file scope.\n\t* init.c (sort_member_init, emit_base_init): Handle getting fields\n\tas well as names in current_member_init_list.\n\t(perform_member_init): Handle getting an anon aggr.\n\t* method.c (do_build_assign_ref): Don't descend into anon aggrs.\n\t(do_build_copy_constructor): Likewise.\n\nFrom-SVN: r27027", "tree": {"sha": "f4a2d76ef728e21180a863ba3b68bc67af34dcce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4a2d76ef728e21180a863ba3b68bc67af34dcce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/comments", "author": null, "committer": null, "parents": [{"sha": "cb6c8ebb73aee0931d64fd532d11c9830339f348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb6c8ebb73aee0931d64fd532d11c9830339f348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb6c8ebb73aee0931d64fd532d11c9830339f348"}], "stats": {"total": 182, "additions": 91, "deletions": 91}, "files": [{"sha": "63f41580b7c42812e6fe67742eb6c215bc271abb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -1,3 +1,18 @@\n+1999-05-19  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tImplement anonymous structs.\n+\t* cp-tree.h (ANON_AGGR_TYPE_P): Rename from ANON_UNION_TYPE_P.\n+\t* class.c, decl.c, decl2.c, init.c, pt.c, search.c, typeck.c: Adjust.\n+\t* class.c (finish_struct_1): Remove redundant check for anon struct.\n+\t* decl.c (fixup_anonymous_aggr): Renamed from fixup_anonymous_union.\n+\t(check_tag_decl): Check for anonymous struct here.\n+\t* decl2.c (build_anon_union_vars): Catch anon struct at file scope.\n+\t* init.c (sort_member_init, emit_base_init): Handle getting fields\n+\tas well as names in current_member_init_list.\n+\t(perform_member_init): Handle getting an anon aggr.\n+\t* method.c (do_build_assign_ref): Don't descend into anon aggrs.\n+\t(do_build_copy_constructor): Likewise.\n+\n 1999-05-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* tree.c (cp_build_qualified_type): Don't allow qualified function"}, {"sha": "94c891ead81ad3e9e4c15d3feb44ee3c180aaa0c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -1337,7 +1337,7 @@ delete_duplicate_fields_1 (field, fields)\n   tree prev = 0;\n   if (DECL_NAME (field) == 0)\n     {\n-      if (TREE_CODE (TREE_TYPE (field)) != UNION_TYPE)\n+      if (! ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \treturn fields;\n \n       for (x = TYPE_FIELDS (TREE_TYPE (field)); x; x = TREE_CHAIN (x))\n@@ -1350,7 +1350,7 @@ delete_duplicate_fields_1 (field, fields)\n \t{\n \t  if (DECL_NAME (x) == 0)\n \t    {\n-\t      if (TREE_CODE (TREE_TYPE (x)) != UNION_TYPE)\n+\t      if (! ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n \t\tcontinue;\n \t      TYPE_FIELDS (TREE_TYPE (x))\n \t\t= delete_duplicate_fields_1 (field, TYPE_FIELDS (TREE_TYPE (x)));\n@@ -2953,7 +2953,7 @@ finish_struct_anon (t)\n \tcontinue;\n \n       if (DECL_NAME (field) == NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t{\n \t  tree* uelt = &TYPE_FIELDS (TREE_TYPE (field));\n \t  for (; *uelt; uelt = &TREE_CHAIN (*uelt))\n@@ -3135,9 +3135,6 @@ finish_struct_1 (t, warn_anon)\n   int has_pointers = 0;\n   tree inline_friends;\n \n-  if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n-    pedwarn (\"anonymous class type not used to declare any objects\");\n-\n   if (TYPE_SIZE (t))\n     {\n       if (IS_AGGR_TYPE (t))"}, {"sha": "85247889327ca17d4e8316a6421fe9eeecc2d200", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -696,7 +696,7 @@ struct lang_type\n       unsigned const_needs_init : 1;\n       unsigned ref_needs_init : 1;\n       unsigned has_const_assign_ref : 1;\n-      unsigned anon_union : 1;\n+      unsigned anon_aggr : 1;\n \n       unsigned has_nonpublic_ctor : 2;\n       unsigned has_nonpublic_assign_ref : 2;\n@@ -1764,16 +1764,14 @@ extern int flag_new_for_scope;\n    Just used to communicate formatting information to dbxout.c.  */\n #define DECL_OPERATOR(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.operator_attr)\n \n-#define ANON_UNION_P(NODE) (DECL_NAME (NODE) == 0)\n-\n-/* Nonzero if TYPE is an anonymous union type.  We have to use a flag for\n-   this because \"A union for which objects or pointers are declared is not\n-   an anonymous union\" [class.union].  */\n-#define ANON_UNION_TYPE_P(NODE)\t\t\t\t\\\n+/* Nonzero if TYPE is an anonymous union or struct type.  We have to use a\n+   flag for this because \"A union for which objects or pointers are\n+   declared is not an anonymous union\" [class.union].  */\n+#define ANON_AGGR_TYPE_P(NODE)\t\t\t\t\\\n   (TYPE_LANG_SPECIFIC (NODE)\t\t\t\t\\\n-   && TYPE_LANG_SPECIFIC (NODE)->type_flags.anon_union)\n-#define SET_ANON_UNION_TYPE_P(NODE)\t\t\t\t\\\n-  (TYPE_LANG_SPECIFIC (NODE)->type_flags.anon_union = 1)\n+   && TYPE_LANG_SPECIFIC (NODE)->type_flags.anon_aggr)\n+#define SET_ANON_AGGR_TYPE_P(NODE)\t\t\t\\\n+  (TYPE_LANG_SPECIFIC (NODE)->type_flags.anon_aggr = 1)\n \n #define UNKNOWN_TYPE LANG_TYPE\n \n@@ -2879,7 +2877,7 @@ extern int in_function_p\t\t\tPROTO((void));\n extern void replace_defarg\t\t\tPROTO((tree, tree));\n extern void print_other_binding_stack\t\tPROTO((struct binding_level *));\n extern void revert_static_member_fn             PROTO((tree*, tree*, tree*));\n-extern void fixup_anonymous_union               PROTO((tree));\n+extern void fixup_anonymous_aggr               PROTO((tree));\n extern int check_static_variable_definition     PROTO((tree, tree));\n extern void push_local_binding                  PROTO((tree, tree, int));\n extern int push_class_binding                   PROTO((tree, tree));"}, {"sha": "ebb15d18172036a514371d58da1ac45e52ef86d6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -4338,7 +4338,7 @@ pushdecl_class_level (x)\n       if (TREE_CODE (x) == TYPE_DECL)\n \tset_identifier_type_value (name, TREE_TYPE (x));\n     }\n-  else if (ANON_UNION_TYPE_P (TREE_TYPE (x)))\n+  else if (ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n     {\n       tree f;\n \n@@ -7011,7 +7011,7 @@ define_function (name, type, function_code, pfn, library_name)\n    union type.)  */\n \n void\n-fixup_anonymous_union (t)\n+fixup_anonymous_aggr (t)\n      tree t;\n {\n   tree *q;\n@@ -7098,12 +7098,15 @@ check_tag_decl (declspecs)\n   /* Check for an anonymous union.  We're careful\n      accessing TYPE_IDENTIFIER because some built-in types, like\n      pointer-to-member types, do not have TYPE_NAME.  */\n-  else if (t && TREE_CODE (t) == UNION_TYPE\n+  else if (t && IS_AGGR_TYPE_CODE (TREE_CODE (t))\n \t   && TYPE_NAME (t)\n \t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n     {\n       /* Anonymous unions are objects, so they can have specifiers.  */;\n-      SET_ANON_UNION_TYPE_P (t);\n+      SET_ANON_AGGR_TYPE_P (t);\n+\n+      if (TREE_CODE (t) != UNION_TYPE && pedantic && ! in_system_header)\n+\tpedwarn (\"ISO C++ prohibits anonymous structs\");\n     }\n \n   else if (ob_modifier)\n@@ -7149,9 +7152,9 @@ shadow_tag (declspecs)\n      union { ... } ;\n      because there is no declarator after the union, the parser\n      sends that declaration here.  */\n-  if (t && ANON_UNION_TYPE_P (t))\n+  if (t && ANON_AGGR_TYPE_P (t))\n     {\n-      fixup_anonymous_union (t);\n+      fixup_anonymous_aggr (t);\n \n       if (TYPE_FIELDS (t))\n \t{\n@@ -10053,7 +10056,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   /* Static anonymous unions are dealt with here.  */\n   if (staticp && decl_context == TYPENAME\n       && TREE_CODE (declspecs) == TREE_LIST\n-      && ANON_UNION_TYPE_P (TREE_VALUE (declspecs)))\n+      && ANON_AGGR_TYPE_P (TREE_VALUE (declspecs)))\n     decl_context = FIELD;\n \n   /* Give error if `const,' `volatile,' `inline,' `friend,' or `virtual'"}, {"sha": "9b9f4d68a4d53358fed2d7d7dad53a12720f4ee6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -887,10 +887,10 @@ grok_x_components (specs)\n \n   /* The only case where we need to do anything additional here is an\n      anonymous union field, e.g.: `struct S { union { int i; }; };'.  */\n-  if (t == NULL_TREE || !ANON_UNION_TYPE_P (t))\n+  if (t == NULL_TREE || !ANON_AGGR_TYPE_P (t))\n     return;\n \n-  fixup_anonymous_union (t);\n+  fixup_anonymous_aggr (t);\n   finish_member_declaration (build_lang_field_decl (FIELD_DECL,\n \t\t\t\t\t\t    NULL_TREE,\n \t\t\t\t\t\t    t)); \n@@ -2152,6 +2152,11 @@ build_anon_union_vars (anon_decl, elems, static_p, external_p)\n   tree main_decl = NULL_TREE;\n   tree field;\n \n+  /* Rather than write the code to handle the non-union case,\n+     just give an error.  */\n+  if (TREE_CODE (type) != UNION_TYPE)\n+    error (\"anonymous struct not inside named type\");\n+\n   for (field = TYPE_FIELDS (type); \n        field != NULL_TREE; \n        field = TREE_CHAIN (field))\n@@ -2173,7 +2178,7 @@ build_anon_union_vars (anon_decl, elems, static_p, external_p)\n \tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n \n       if (DECL_NAME (field) == NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t{\n \t  decl = build_anon_union_vars (field, elems, static_p, external_p);\n \t  if (!decl)\n@@ -2205,7 +2210,7 @@ build_anon_union_vars (anon_decl, elems, static_p, external_p)\n \tTREE_ASM_WRITTEN (decl) = 1;\n       \n       if (DECL_NAME (field) == NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t/* The remainder of the processing was already done in the\n \t   recursive call.  */\n \tcontinue;"}, {"sha": "1bbc51e04e216d11128c73d596f1fc88a73e7ca2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -154,16 +154,25 @@ perform_member_init (member, name, init, explicit)\n \n   expand_start_target_temps ();\n \n-  if (TYPE_NEEDS_CONSTRUCTING (type)\n-      || (init && TYPE_HAS_CONSTRUCTOR (type)))\n+  decl = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n+\n+  /* Deal with this here, as we will get confused if we try to call the\n+     assignment op for an anonymous union.  This can happen in a\n+     synthesized copy constructor.  */\n+  if (ANON_AGGR_TYPE_P (type))\n+    {\n+      init = build (INIT_EXPR, type, decl, TREE_VALUE (init));\n+      TREE_SIDE_EFFECTS (init) = 1;\n+      expand_expr_stmt (init);\n+    }\n+  else if (TYPE_NEEDS_CONSTRUCTING (type)\n+\t   || (init && TYPE_HAS_CONSTRUCTOR (type)))\n     {\n       /* Since `init' is already a TREE_LIST on the current_member_init_list,\n \t only build it into one if we aren't already a list.  */\n       if (init != NULL_TREE && TREE_CODE (init) != TREE_LIST)\n \tinit = build_expr_list (NULL_TREE, init);\n \n-      decl = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n-\n       if (explicit\n \t  && TREE_CODE (type) == ARRAY_TYPE\n \t  && init != NULL_TREE\n@@ -186,7 +195,7 @@ perform_member_init (member, name, init, explicit)\n \t      /* default-initialization.  */\n \t      if (AGGREGATE_TYPE_P (type))\n \t\tinit = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n-\t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n+ \t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n \t\t{\n \t\t  cp_error (\"default-initialization of `%#D', which has reference type\",\n \t\t\t    member);\n@@ -216,8 +225,6 @@ perform_member_init (member, name, init, explicit)\n \t current_member_init_list.  */\n       if (init || explicit)\n \t{\n-\t  decl = build_component_ref (current_class_ref, name, NULL_TREE,\n-\t\t\t\t      explicit);\n \t  expand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \t}\n     }\n@@ -275,16 +282,13 @@ sort_member_init (t)\n \t    continue;\n \t  name = TREE_PURPOSE (x);\n \n-#if 0\n-\t  /* This happens in templates, since the IDENTIFIER is replaced\n-             with the COMPONENT_REF in tsubst_expr.  */\n-\t  field = (TREE_CODE (name) == COMPONENT_REF\n-\t\t   ? TREE_OPERAND (name, 1) : IDENTIFIER_CLASS_VALUE (name));\n-#else\n-\t  /* Let's find out when this happens.  */\n-\t  my_friendly_assert (TREE_CODE (name) != COMPONENT_REF, 348);\n-\t  field = IDENTIFIER_CLASS_VALUE (name);\n-#endif\n+\t  if (TREE_CODE (name) == IDENTIFIER_NODE)\n+\t    field = IDENTIFIER_CLASS_VALUE (name);\n+\t  else\n+\t    {\n+\t      my_friendly_assert (TREE_CODE (name) == FIELD_DECL, 348); \n+\t      field = name;\n+\t    }\n \n \t  /* If one member shadows another, get the outermost one.  */\n \t  if (TREE_CODE (field) == TREE_LIST)\n@@ -635,15 +639,8 @@ emit_base_init (t, immediately)\n \t  init = TREE_VALUE (mem_init_list);\n \t  from_init_list = 1;\n \n-#if 0\n-\t  if (TREE_CODE (name) == COMPONENT_REF)\n-\t    name = DECL_NAME (TREE_OPERAND (name, 1));\n-#else\n-\t  /* Also see if it's ever a COMPONENT_REF here.  If it is, we\n-\t     need to do `expand_assignment (name, init, 0, 0);' and\n-\t     a continue.  */\n-\t  my_friendly_assert (TREE_CODE (name) != COMPONENT_REF, 349);\n-#endif\n+\t  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE\n+\t\t\t      || TREE_CODE (name) == FIELD_DECL, 349);\n \t}\n       else\n \t{\n@@ -672,9 +669,11 @@ emit_base_init (t, immediately)\n \t{\n \t  name = TREE_PURPOSE (mem_init_list);\n \t  init = TREE_VALUE (mem_init_list);\n-\t  /* XXX: this may need the COMPONENT_REF operand 0 check if\n-\t     it turns out we actually get them.  */\n-\t  field = IDENTIFIER_CLASS_VALUE (name);\n+\n+\t  if (TREE_CODE (name) == IDENTIFIER_NODE)\n+\t    field = IDENTIFIER_CLASS_VALUE (name);\n+\t  else\n+\t    field = name;\n \n \t  /* If one member shadows another, get the outermost one.  */\n \t  if (TREE_CODE (field) == TREE_LIST)\n@@ -831,7 +830,7 @@ initializing_context (field)\n \n   /* Anonymous union members can be initialized in the first enclosing\n      non-anonymous union context.  */\n-  while (t && ANON_UNION_TYPE_P (t))\n+  while (t && ANON_AGGR_TYPE_P (t))\n     t = TYPE_CONTEXT (t);\n   return t;\n }"}, {"sha": "48701696bbd4bd27e6e253e6506b20c0c3084d38", "filename": "gcc/cp/method.c", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -2282,26 +2282,18 @@ do_build_copy_constructor (fndecl)\n \t\tcontinue;\n \t    }\n \t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t   && ANON_UNION_TYPE_P (t)\n+\t\t   && ANON_AGGR_TYPE_P (t)\n \t\t   && TYPE_FIELDS (t) != NULL_TREE)\n-\t    {\n-\t      do\n-\t\t{\n-\t\t  init = build (COMPONENT_REF, t, init, field);\n-\t\t  field = largest_union_member (t);\n-\t\t}\n-\t      while ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t     && ANON_UNION_TYPE_P (t)\n-\t\t     && TYPE_FIELDS (t) != NULL_TREE);\n-\t    }\n+\t    /* Just use the field; anonymous types can't have\n+\t       nontrivial copy ctors or assignment ops.  */;\n \t  else\n \t    continue;\n \n \t  init = build (COMPONENT_REF, TREE_TYPE (field), init, field);\n \t  init = build_tree_list (NULL_TREE, init);\n \n \t  current_member_init_list\n-\t    = tree_cons (DECL_NAME (field), init, current_member_init_list);\n+\t    = tree_cons (field, init, current_member_init_list);\n \t}\n       current_member_init_list = nreverse (current_member_init_list);\n       current_base_init_list = nreverse (current_base_init_list);\n@@ -2390,19 +2382,10 @@ do_build_assign_ref (fndecl)\n \t\tcontinue;\n \t    }\n \t  else if ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t   && ANON_UNION_TYPE_P (t)\n+\t\t   && ANON_AGGR_TYPE_P (t)\n \t\t   && TYPE_FIELDS (t) != NULL_TREE)\n-\t    {\n-\t      do\n-\t\t{\n-\t\t  comp = build (COMPONENT_REF, t, comp, field);\n-\t\t  init = build (COMPONENT_REF, t, init, field);\n-\t\t  field = largest_union_member (t);\n-\t\t}\n-\t      while ((t = TREE_TYPE (field)) != NULL_TREE\n-\t\t     && ANON_UNION_TYPE_P (t)\n-\t\t     && TYPE_FIELDS (t) != NULL_TREE);\n-\t    }\n+\t    /* Just use the field; anonymous types can't have\n+\t       nontrivial copy ctors or assignment ops.  */;\n \t  else\n \t    continue;\n "}, {"sha": "6c316518732a5c36999f18b03323dde5791e51fc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -4884,8 +4884,8 @@ instantiate_class_template (type)\n   TYPE_PACKED (type) = TYPE_PACKED (pattern);\n   TYPE_ALIGN (type) = TYPE_ALIGN (pattern);\n   TYPE_FOR_JAVA (type) = TYPE_FOR_JAVA (pattern); /* For libjava's JArray<T> */\n-  if (ANON_UNION_TYPE_P (pattern))\n-    SET_ANON_UNION_TYPE_P (type);\n+  if (ANON_AGGR_TYPE_P (pattern))\n+    SET_ANON_AGGR_TYPE_P (type);\n \n   /* We must copy the arguments to the permanent obstack since\n      during the tsubst'ing below they may wind up in the"}, {"sha": "906aa131b3d4cef63fb02fcf779a367df1b25bde", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -534,7 +534,7 @@ lookup_field_1 (type, name)\n #endif /* GATHER_STATISTICS */\n       my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (field)) == 'd', 0);\n       if (DECL_NAME (field) == NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t{\n \t  tree temp = lookup_field_1 (TREE_TYPE (field), name);\n \t  if (temp)\n@@ -610,7 +610,7 @@ context_for_name_lookup (decl)\n      declared.  */ \n   tree context = DECL_REAL_CONTEXT (decl);\n \n-  while (TYPE_P (context) && ANON_UNION_TYPE_P (context))\n+  while (TYPE_P (context) && ANON_AGGR_TYPE_P (context))\n     context = TYPE_CONTEXT (context);\n   if (!context)\n     context = global_namespace;\n@@ -2927,7 +2927,7 @@ dfs_push_decls (binfo, data)\n \t    && TREE_CODE (fields) != USING_DECL)\n \t  setup_class_bindings (DECL_NAME (fields), /*type_binding_p=*/0);\n \telse if (TREE_CODE (fields) == FIELD_DECL\n-\t\t && ANON_UNION_TYPE_P (TREE_TYPE (fields)))\n+\t\t && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n \t  dfs_push_decls (TYPE_BINFO (TREE_TYPE (fields)), data);\n \t  \n       method_vec = (CLASS_TYPE_P (type) \n@@ -3001,7 +3001,7 @@ dfs_unuse_fields (binfo, data)\n \n       TREE_USED (fields) = 0;\n       if (DECL_NAME (fields) == NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (fields)) == UNION_TYPE)\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n \tunuse_fields (TREE_TYPE (fields));\n     }\n "}, {"sha": "6ca5adcb73de31b657ecc1b693714f0b7817e374", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6bdb8141ecb7e23a269e1dac1dd98fcf7b5e6b8b", "patch": "@@ -2006,7 +2006,7 @@ lookup_anon_field (t, type)\n \n       /* Otherwise, it could be nested, search harder.  */\n       if (DECL_NAME (field) == NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t{\n \t  tree subfield = lookup_anon_field (TREE_TYPE (field), type);\n \t  if (subfield)\n@@ -2216,7 +2216,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       tree context = DECL_FIELD_CONTEXT (field);\n       tree base = context;\n       while (!same_type_p (base, basetype) && TYPE_NAME (base)\n-\t     && ANON_UNION_TYPE_P (base))\n+\t     && ANON_AGGR_TYPE_P (base))\n \t{\n \t  base = TYPE_CONTEXT (base);\n \t}\n@@ -2246,7 +2246,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       basetype = base;\n  \n       /* Handle things from anon unions here...  */\n-      if (TYPE_NAME (context) && ANON_UNION_TYPE_P (context))\n+      if (TYPE_NAME (context) && ANON_AGGR_TYPE_P (context))\n \t{\n \t  tree subfield = lookup_anon_field (basetype, context);\n \t  tree subdatum = build_component_ref (datum, subfield,"}]}