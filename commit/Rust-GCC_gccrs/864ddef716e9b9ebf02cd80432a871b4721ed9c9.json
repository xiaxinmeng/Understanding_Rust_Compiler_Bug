{"sha": "864ddef716e9b9ebf02cd80432a871b4721ed9c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY0ZGRlZjcxNmU5YjllYmYwMmNkODA0MzJhODcxYjQ3MjFlZDljOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-03-07T15:44:11Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-03-07T15:44:11Z"}, "message": "re PR debug/43176 (var-tracking fails to notice a value change)\n\n\tPR debug/43176\n\t* Makefile.in (var-tracking.o): Depend on pointer-set.h.\n\t* cselib.c (struct expand_value_data): Add dummy field.\n\t(cselib_expand_value_rtx, cselib_expand_value_rtx_cb): Initialize\n\tdummy to false.\n\t(cselib_dummy_expand_value_rtx_cb): New function.\n\t(cselib_expand_value_rtx_1): If evd->dummy is true, don't allocate\n\tany rtl.\n\t* cselib.h (cselib_dummy_expand_value_rtx_cb): New prototype.\n\t* var-tracking.c: Include pointer-set.h.\n\t(variable): Change n_var_parts to char from int.  Add\n\tcur_loc_changed and in_changed_variables fields.\n\t(variable_canonicalize): Remove.\n\t(shared_var_p): New inline function.\n\t(unshare_variable): Maintain cur_loc_changed and\n\tin_changed_variables fields.  If var was in changed_variables,\n\treplace it there with new_var.  Just copy cur_loc instead of\n\tresetting it to something else.\n\t(variable_union): Don't recompute cur_loc.  Use shared_var_p.\n\t(dataflow_set_union): Don't call variable_canonicalize.\n\t(loc_cmp): If both x and y are DEBUG_EXPRs, compare uids\n\tof their DEBUG_EXPR_TREE_DECLs.\n\t(canonicalize_loc_order_check): Verify that cur_loc is NULL\n\tand in_changed_variables and cur_loc_changed is false.\n\t(variable_merge_over_cur): Clear cur_loc, in_changed_variables\n\tand cur_loc_changed.  Don't update cur_loc here.\n\t(variable_merge_over_src): Don't call variable_canonicalize.\n\t(dataflow_set_preserve_mem_locs): Use shared_var_p.  When\n\tremoving loc that is equal to cur_loc, clear cur_loc,\n\tset cur_loc_changed and ensure variable_was_changed is called.\n\t(dataflow_set_remove_mem_locs): Use shared_var_p.  Only\n\tcompare pointers in cur_loc check, if it is equal to loc,\n\tclear cur_loc and set cur_loc_changed.  Don't recompute cur_loc here.\n\t(variable_different_p): Remove compare_current_location argument,\n\tdon't compare cur_loc.\n\t(dataflow_set_different_1): Adjust variable_different_p caller.\n\t(variable_was_changed): If dv had some var in changed_variables\n\talready, reset in_changed_variables flag for it and propagate\n\tcur_loc_changed over to the new variable.  On empty var\n\talways set cur_loc_changed.  Set in_changed_variables on whatever\n\tvar is added to changed_variables.\n\t(set_slot_part): Clear cur_loc_changed and in_changed_variables.\n\tUse shared_var_p.  When removing loc that is equal to cur_loc,\n\tclear cur_loc and set cur_loc_changed.  If cur_loc is NULL at the\n\tend, don't set it to something else, just call variable_was_changed.\n\t(delete_slot_part): Use shared_var_p.  When cur_loc equals to\n\tloc being removed, clear cur_loc and set cur_loc_changed.\n\tSet cur_loc_changed if all locations have been removed.\n\t(struct expand_loc_callback_data): New type.\n\t(vt_expand_loc_callback): Add dummy mode in which no rtxes are\n\tallocated.  Always create SUBREGs if simplify_subreg failed.\n\tPrefer to use cur_loc, when that fails and still in\n\tchanged_variables (and seen first time) recompute it.  Set\n\tcur_loc_changed of variables which had to change cur_loc and\n\tcompute elcd->cur_loc_changed if any of the subexpressions used\n\thad to change cur_loc.\n\t(vt_expand_loc): Adjust to pass arguments in\n\texpand_loc_callback_data structure.\n\t(vt_expand_loc_dummy): New function.\n\t(emitted_notes): New variable.\n\t(emit_note_insn_var_location): For VALUEs and DEBUG_EXPR_DECLs\n\tthat weren't used for any other decl in current\n\temit_notes_for_changes call call vt_expand_loc_dummy to update\n\tcur_loc.  For -fno-var-tracking-assignments, set cur_loc to\n\tfirst loc_chain location if NULL before.  Always use just\n\tcur_loc instead of first loc_chain location.  When cur_loc_changed\n\tis false, when not --enable-checking=rtl just don't emit any note.\n\tWhen rtl checking, compute the note and assert it is the same\n\tas previous note.  Clear cur_loc_changed and in_changed_variables\n\tat the end before removing from changed_variables.\n\t(check_changed_vars_3): New function.\n\t(emit_notes_for_changes): Traverse changed_vars to call\n\tcheck_changed_vars_3 on each changed var.\n\t(emit_notes_for_differences_1): Clear cur_loc_changed and\n\tin_changed_variables.  Recompute cur_loc of new_var.\n\t(emit_notes_for_differences_2): Clear cur_loc if new variable\n\tappears.\n\t(vt_emit_notes): Initialize and destroy emitted_notes.\n\nFrom-SVN: r157264", "tree": {"sha": "025d8a7128b27b9e7c0a077d3565137986a733d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/025d8a7128b27b9e7c0a077d3565137986a733d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/864ddef716e9b9ebf02cd80432a871b4721ed9c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/864ddef716e9b9ebf02cd80432a871b4721ed9c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/864ddef716e9b9ebf02cd80432a871b4721ed9c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/864ddef716e9b9ebf02cd80432a871b4721ed9c9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c41379182bcafb29fe64ccf8e2fe78d362ccc388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c41379182bcafb29fe64ccf8e2fe78d362ccc388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c41379182bcafb29fe64ccf8e2fe78d362ccc388"}], "stats": {"total": 753, "additions": 560, "deletions": 193}, "files": [{"sha": "c495c34377a145d64236e873198c0ba97895838f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=864ddef716e9b9ebf02cd80432a871b4721ed9c9", "patch": "@@ -1,3 +1,84 @@\n+2010-03-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/43176\n+\t* Makefile.in (var-tracking.o): Depend on pointer-set.h.\n+\t* cselib.c (struct expand_value_data): Add dummy field.\n+\t(cselib_expand_value_rtx, cselib_expand_value_rtx_cb): Initialize\n+\tdummy to false.\n+\t(cselib_dummy_expand_value_rtx_cb): New function.\n+\t(cselib_expand_value_rtx_1): If evd->dummy is true, don't allocate\n+\tany rtl.\n+\t* cselib.h (cselib_dummy_expand_value_rtx_cb): New prototype.\n+\t* var-tracking.c: Include pointer-set.h.\n+\t(variable): Change n_var_parts to char from int.  Add\n+\tcur_loc_changed and in_changed_variables fields.\n+\t(variable_canonicalize): Remove.\n+\t(shared_var_p): New inline function.\n+\t(unshare_variable): Maintain cur_loc_changed and\n+\tin_changed_variables fields.  If var was in changed_variables,\n+\treplace it there with new_var.  Just copy cur_loc instead of\n+\tresetting it to something else.\n+\t(variable_union): Don't recompute cur_loc.  Use shared_var_p.\n+\t(dataflow_set_union): Don't call variable_canonicalize.\n+\t(loc_cmp): If both x and y are DEBUG_EXPRs, compare uids\n+\tof their DEBUG_EXPR_TREE_DECLs.\n+\t(canonicalize_loc_order_check): Verify that cur_loc is NULL\n+\tand in_changed_variables and cur_loc_changed is false.\n+\t(variable_merge_over_cur): Clear cur_loc, in_changed_variables\n+\tand cur_loc_changed.  Don't update cur_loc here.\n+\t(variable_merge_over_src): Don't call variable_canonicalize.\n+\t(dataflow_set_preserve_mem_locs): Use shared_var_p.  When\n+\tremoving loc that is equal to cur_loc, clear cur_loc,\n+\tset cur_loc_changed and ensure variable_was_changed is called.\n+\t(dataflow_set_remove_mem_locs): Use shared_var_p.  Only\n+\tcompare pointers in cur_loc check, if it is equal to loc,\n+\tclear cur_loc and set cur_loc_changed.  Don't recompute cur_loc here.\n+\t(variable_different_p): Remove compare_current_location argument,\n+\tdon't compare cur_loc.\n+\t(dataflow_set_different_1): Adjust variable_different_p caller.\n+\t(variable_was_changed): If dv had some var in changed_variables\n+\talready, reset in_changed_variables flag for it and propagate\n+\tcur_loc_changed over to the new variable.  On empty var\n+\talways set cur_loc_changed.  Set in_changed_variables on whatever\n+\tvar is added to changed_variables.\n+\t(set_slot_part): Clear cur_loc_changed and in_changed_variables.\n+\tUse shared_var_p.  When removing loc that is equal to cur_loc,\n+\tclear cur_loc and set cur_loc_changed.  If cur_loc is NULL at the\n+\tend, don't set it to something else, just call variable_was_changed.\n+\t(delete_slot_part): Use shared_var_p.  When cur_loc equals to\n+\tloc being removed, clear cur_loc and set cur_loc_changed.\n+\tSet cur_loc_changed if all locations have been removed.\n+\t(struct expand_loc_callback_data): New type.\n+\t(vt_expand_loc_callback): Add dummy mode in which no rtxes are\n+\tallocated.  Always create SUBREGs if simplify_subreg failed.\n+\tPrefer to use cur_loc, when that fails and still in\n+\tchanged_variables (and seen first time) recompute it.  Set\n+\tcur_loc_changed of variables which had to change cur_loc and\n+\tcompute elcd->cur_loc_changed if any of the subexpressions used\n+\thad to change cur_loc.\n+\t(vt_expand_loc): Adjust to pass arguments in\n+\texpand_loc_callback_data structure.\n+\t(vt_expand_loc_dummy): New function.\n+\t(emitted_notes): New variable.\n+\t(emit_note_insn_var_location): For VALUEs and DEBUG_EXPR_DECLs\n+\tthat weren't used for any other decl in current\n+\temit_notes_for_changes call call vt_expand_loc_dummy to update\n+\tcur_loc.  For -fno-var-tracking-assignments, set cur_loc to\n+\tfirst loc_chain location if NULL before.  Always use just\n+\tcur_loc instead of first loc_chain location.  When cur_loc_changed\n+\tis false, when not --enable-checking=rtl just don't emit any note.\n+\tWhen rtl checking, compute the note and assert it is the same\n+\tas previous note.  Clear cur_loc_changed and in_changed_variables\n+\tat the end before removing from changed_variables.\n+\t(check_changed_vars_3): New function.\n+\t(emit_notes_for_changes): Traverse changed_vars to call\n+\tcheck_changed_vars_3 on each changed var.\n+\t(emit_notes_for_differences_1): Clear cur_loc_changed and\n+\tin_changed_variables.  Recompute cur_loc of new_var.\n+\t(emit_notes_for_differences_2): Clear cur_loc if new variable\n+\tappears.\n+\t(vt_emit_notes): Initialize and destroy emitted_notes.\n+\n 2010-03-07  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \tPR rtl-optimization/42220"}, {"sha": "20ab71ff786cebab26d33ff5c0cb777573d44fd2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=864ddef716e9b9ebf02cd80432a871b4721ed9c9", "patch": "@@ -3031,7 +3031,7 @@ var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n    $(REGS_H) $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(TREE_FLOW_H) \\\n-   cselib.h $(TARGET_H) $(TOPLEV_H) $(PARAMS_H) $(DIAGNOSTIC_H)\n+   cselib.h $(TARGET_H) $(TOPLEV_H) $(PARAMS_H) $(DIAGNOSTIC_H) pointer-set.h\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) $(FUNCTION_H) \\\n    $(TOPLEV_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\"}, {"sha": "515fc328463d204895a261955ced0570b97f2706", "filename": "gcc/cselib.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=864ddef716e9b9ebf02cd80432a871b4721ed9c9", "patch": "@@ -69,6 +69,7 @@ struct expand_value_data\n   bitmap regs_active;\n   cselib_expand_callback callback;\n   void *callback_arg;\n+  bool dummy;\n };\n \n static rtx cselib_expand_value_rtx_1 (rtx, struct expand_value_data *, int);\n@@ -1069,6 +1070,7 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n   evd.regs_active = regs_active;\n   evd.callback = NULL;\n   evd.callback_arg = NULL;\n+  evd.dummy = false;\n \n   return cselib_expand_value_rtx_1 (orig, &evd, max_depth);\n }\n@@ -1088,10 +1090,29 @@ cselib_expand_value_rtx_cb (rtx orig, bitmap regs_active, int max_depth,\n   evd.regs_active = regs_active;\n   evd.callback = cb;\n   evd.callback_arg = data;\n+  evd.dummy = false;\n \n   return cselib_expand_value_rtx_1 (orig, &evd, max_depth);\n }\n \n+/* Similar to cselib_expand_value_rtx_cb, but no rtxs are actually copied\n+   or simplified.  Useful to find out whether cselib_expand_value_rtx_cb\n+   would return NULL or non-NULL, without allocating new rtx.  */\n+\n+bool\n+cselib_dummy_expand_value_rtx_cb (rtx orig, bitmap regs_active, int max_depth,\n+\t\t\t\t  cselib_expand_callback cb, void *data)\n+{\n+  struct expand_value_data evd;\n+\n+  evd.regs_active = regs_active;\n+  evd.callback = cb;\n+  evd.callback_arg = data;\n+  evd.dummy = true;\n+\n+  return cselib_expand_value_rtx_1 (orig, &evd, max_depth) != NULL;\n+}\n+\n /* Internal implementation of cselib_expand_value_rtx and\n    cselib_expand_value_rtx_cb.  */\n \n@@ -1249,7 +1270,10 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n      that all fields need copying, and then clear the fields that should\n      not be copied.  That is the sensible default behavior, and forces\n      us to explicitly document why we are *not* copying a flag.  */\n-  copy = shallow_copy_rtx (orig);\n+  if (evd->dummy)\n+    copy = NULL;\n+  else\n+    copy = shallow_copy_rtx (orig);\n \n   format_ptr = GET_RTX_FORMAT (code);\n \n@@ -1263,22 +1287,25 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n \t\t\t\t\t\t    max_depth - 1);\n \t    if (!result)\n \t      return NULL;\n-\t    XEXP (copy, i) = result;\n+\t    if (copy)\n+\t      XEXP (copy, i) = result;\n \t  }\n \tbreak;\n \n       case 'E':\n       case 'V':\n \tif (XVEC (orig, i) != NULL)\n \t  {\n-\t    XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n-\t    for (j = 0; j < XVECLEN (copy, i); j++)\n+\t    if (copy)\n+\t      XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n+\t    for (j = 0; j < XVECLEN (orig, i); j++)\n \t      {\n \t\trtx result = cselib_expand_value_rtx_1 (XVECEXP (orig, i, j),\n \t\t\t\t\t\t\tevd, max_depth - 1);\n \t\tif (!result)\n \t\t  return NULL;\n-\t\tXVECEXP (copy, i, j) = result;\n+\t\tif (copy)\n+\t\t  XVECEXP (copy, i, j) = result;\n \t      }\n \t  }\n \tbreak;\n@@ -1299,6 +1326,9 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n \tgcc_unreachable ();\n       }\n \n+  if (evd->dummy)\n+    return orig;\n+\n   mode = GET_MODE (copy);\n   /* If an operand has been simplified into CONST_INT, which doesn't\n      have a mode and the mode isn't derivable from whole rtx's mode,"}, {"sha": "2cdf6ade10b2000066461f4340631715f9504c7a", "filename": "gcc/cselib.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=864ddef716e9b9ebf02cd80432a871b4721ed9c9", "patch": "@@ -81,7 +81,9 @@ extern int references_value_p (const_rtx, int);\n extern rtx cselib_expand_value_rtx (rtx, bitmap, int);\n typedef rtx (*cselib_expand_callback)(rtx, bitmap, int, void *);\n extern rtx cselib_expand_value_rtx_cb (rtx, bitmap, int,\n-\t\t\t\t       cselib_expand_callback, void*);\n+\t\t\t\t       cselib_expand_callback, void *);\n+extern bool cselib_dummy_expand_value_rtx_cb (rtx, bitmap, int,\n+\t\t\t\t\t      cselib_expand_callback, void *);\n extern rtx cselib_subst_to_values (rtx);\n extern void cselib_invalidate_rtx (rtx);\n "}, {"sha": "1878e90c1ef84184354f6fa3e5ffc33664b22205", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 440, "deletions": 186, "changes": 626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/864ddef716e9b9ebf02cd80432a871b4721ed9c9/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=864ddef716e9b9ebf02cd80432a871b4721ed9c9", "patch": "@@ -112,6 +112,7 @@\n #include \"toplev.h\"\n #include \"params.h\"\n #include \"diagnostic.h\"\n+#include \"pointer-set.h\"\n \n /* var-tracking.c assumes that tree code with the same value as VALUE rtx code\n    has no chance to appear in REG_EXPR/MEM_EXPRs and isn't a decl.\n@@ -324,7 +325,16 @@ typedef struct variable_def\n   int refcount;\n \n   /* Number of variable parts.  */\n-  int n_var_parts;\n+  char n_var_parts;\n+\n+  /* True if this variable changed (any of its) cur_loc fields\n+     during the current emit_notes_for_changes resp.\n+     emit_notes_for_differences call.  */\n+  bool cur_loc_changed;\n+\n+  /* True if this variable_def struct is currently in the\n+     changed_variables hash table.  */\n+  bool in_changed_variables;\n \n   /* The variable parts.  */\n   variable_part var_part[1];\n@@ -429,14 +439,13 @@ static void dataflow_set_clear (dataflow_set *);\n static void dataflow_set_copy (dataflow_set *, dataflow_set *);\n static int variable_union_info_cmp_pos (const void *, const void *);\n static int variable_union (void **, void *);\n-static int variable_canonicalize (void **, void *);\n static void dataflow_set_union (dataflow_set *, dataflow_set *);\n static location_chain find_loc_in_1pdv (rtx, variable, htab_t);\n static bool canon_value_cmp (rtx, rtx);\n static int loc_cmp (rtx, rtx);\n static bool variable_part_different_p (variable_part *, variable_part *);\n static bool onepart_variable_different_p (variable, variable);\n-static bool variable_different_p (variable, variable, bool);\n+static bool variable_different_p (variable, variable);\n static int dataflow_set_different_1 (void **, void *);\n static bool dataflow_set_different (dataflow_set *, dataflow_set *);\n static void dataflow_set_destroy (dataflow_set *);\n@@ -1056,6 +1065,16 @@ shared_hash_htab (shared_hash vars)\n   return vars->htab;\n }\n \n+/* Return true if VAR is shared, or maybe because VARS is shared.  */\n+\n+static inline bool\n+shared_var_p (variable var, shared_hash vars)\n+{\n+  /* Don't count an entry in the changed_variables table as a duplicate.  */\n+  return ((var->refcount > 1 + (int) var->in_changed_variables)\n+\t  || shared_hash_shared (vars));\n+}\n+\n /* Copy variables into a new hash table.  */\n \n static shared_hash\n@@ -1195,6 +1214,9 @@ unshare_variable (dataflow_set *set, void **slot, variable var,\n   new_var->refcount = 1;\n   var->refcount--;\n   new_var->n_var_parts = var->n_var_parts;\n+  new_var->cur_loc_changed = var->cur_loc_changed;\n+  var->cur_loc_changed = false;\n+  new_var->in_changed_variables = false;\n \n   if (! flag_var_tracking_uninit)\n     initialized = VAR_INIT_STATUS_INITIALIZED;\n@@ -1226,12 +1248,7 @@ unshare_variable (dataflow_set *set, void **slot, variable var,\n \t  nextp = &new_lc->next;\n \t}\n \n-      /* We are at the basic block boundary when copying variable description\n-\t so set the CUR_LOC to be the first element of the chain.  */\n-      if (new_var->var_part[i].loc_chain)\n-\tnew_var->var_part[i].cur_loc = new_var->var_part[i].loc_chain->loc;\n-      else\n-\tnew_var->var_part[i].cur_loc = NULL;\n+      new_var->var_part[i].cur_loc = var->var_part[i].cur_loc;\n     }\n \n   dst_can_be_shared = false;\n@@ -1240,6 +1257,17 @@ unshare_variable (dataflow_set *set, void **slot, variable var,\n   else if (set->traversed_vars && set->vars != set->traversed_vars)\n     slot = shared_hash_find_slot_noinsert (set->vars, var->dv);\n   *slot = new_var;\n+  if (var->in_changed_variables)\n+    {\n+      void **cslot\n+\t= htab_find_slot_with_hash (changed_variables, var->dv,\n+\t\t\t\t    dv_htab_hash (var->dv), NO_INSERT);\n+      gcc_assert (*cslot == (void *) var);\n+      var->in_changed_variables = false;\n+      variable_htab_free (var);\n+      *cslot = new_var;\n+      new_var->in_changed_variables = true;\n+    }\n   return slot;\n }\n \n@@ -1791,23 +1819,6 @@ variable_union (void **slot, void *data)\n \n       *dstp = src;\n \n-      /* If CUR_LOC of some variable part is not the first element of\n-\t the location chain we are going to change it so we have to make\n-\t a copy of the variable.  */\n-      for (k = 0; k < src->n_var_parts; k++)\n-\t{\n-\t  gcc_assert (!src->var_part[k].loc_chain\n-\t\t      == !src->var_part[k].cur_loc);\n-\t  if (src->var_part[k].loc_chain)\n-\t    {\n-\t      gcc_assert (src->var_part[k].cur_loc);\n-\t      if (src->var_part[k].cur_loc != src->var_part[k].loc_chain->loc)\n-\t\tbreak;\n-\t    }\n-\t}\n-      if (k < src->n_var_parts)\n-\tdstp = unshare_variable (set, dstp, src, VAR_INIT_STATUS_UNKNOWN);\n-\n       /* Continue traversing the hash table.  */\n       return 1;\n     }\n@@ -1841,7 +1852,7 @@ variable_union (void **slot, void *data)\n \t    {\n \t      location_chain nnode;\n \n-\t      if (dst->refcount != 1 || shared_hash_shared (set->vars))\n+\t      if (shared_var_p (dst, set->vars))\n \t\t{\n \t\t  dstp = unshare_variable (set, dstp, dst,\n \t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n@@ -1871,8 +1882,6 @@ variable_union (void **slot, void *data)\n \t  dnode = *nodep;\n \t}\n \n-      dst->var_part[0].cur_loc = dst->var_part[0].loc_chain->loc;\n-\n       return 1;\n     }\n \n@@ -1897,8 +1906,7 @@ variable_union (void **slot, void *data)\n      thus there are at most MAX_VAR_PARTS different offsets.  */\n   gcc_assert (dv_onepart_p (dst->dv) ? k == 1 : k <= MAX_VAR_PARTS);\n \n-  if ((dst->refcount > 1 || shared_hash_shared (set->vars))\n-      && dst->n_var_parts != k)\n+  if (dst->n_var_parts != k && shared_var_p (dst, set->vars))\n     {\n       dstp = unshare_variable (set, dstp, dst, VAR_INIT_STATUS_UNKNOWN);\n       dst = (variable)*dstp;\n@@ -1925,7 +1933,7 @@ variable_union (void **slot, void *data)\n \t  /* If DST is shared compare the location chains.\n \t     If they are different we will modify the chain in DST with\n \t     high probability so make a copy of DST.  */\n-\t  if (dst->refcount > 1 || shared_hash_shared (set->vars))\n+\t  if (shared_var_p (dst, set->vars))\n \t    {\n \t      for (node = src->var_part[i].loc_chain,\n \t\t   node2 = dst->var_part[j].loc_chain; node && node2;\n@@ -2139,13 +2147,7 @@ variable_union (void **slot, void *data)\n \t  dst->var_part[k].offset = src->var_part[i].offset;\n \t  i--;\n \t}\n-\n-      /* We are at the basic block boundary when computing union\n-\t so set the CUR_LOC to be the first element of the chain.  */\n-      if (dst->var_part[k].loc_chain)\n-\tdst->var_part[k].cur_loc = dst->var_part[k].loc_chain->loc;\n-      else\n-\tdst->var_part[k].cur_loc = NULL;\n+      dst->var_part[k].cur_loc = NULL;\n     }\n \n   if (flag_var_tracking_uninit)\n@@ -2165,39 +2167,6 @@ variable_union (void **slot, void *data)\n   return 1;\n }\n \n-/* Like variable_union, but only used when doing dataflow_set_union\n-   into an empty hashtab.  To allow sharing, dst is initially shared\n-   with src (so all variables are \"copied\" from src to dst hashtab),\n-   so only unshare_variable for variables that need canonicalization\n-   are needed.  */\n-\n-static int\n-variable_canonicalize (void **slot, void *data)\n-{\n-  variable src;\n-  dataflow_set *set = (dataflow_set *) data;\n-  int k;\n-\n-  src = *(variable *) slot;\n-\n-  /* If CUR_LOC of some variable part is not the first element of\n-     the location chain we are going to change it so we have to make\n-     a copy of the variable.  */\n-  for (k = 0; k < src->n_var_parts; k++)\n-    {\n-      gcc_assert (!src->var_part[k].loc_chain == !src->var_part[k].cur_loc);\n-      if (src->var_part[k].loc_chain)\n-\t{\n-\t  gcc_assert (src->var_part[k].cur_loc);\n-\t  if (src->var_part[k].cur_loc != src->var_part[k].loc_chain->loc)\n-\t    break;\n-\t}\n-    }\n-  if (k < src->n_var_parts)\n-    slot = unshare_variable (set, slot, src, VAR_INIT_STATUS_UNKNOWN);\n-  return 1;\n-}\n-\n /* Compute union of dataflow sets SRC and DST and store it to DST.  */\n \n static void\n@@ -2212,9 +2181,6 @@ dataflow_set_union (dataflow_set *dst, dataflow_set *src)\n     {\n       shared_hash_destroy (dst->vars);\n       dst->vars = shared_hash_copy (src->vars);\n-      dst->traversed_vars = dst->vars;\n-      htab_traverse (shared_hash_htab (dst->vars), variable_canonicalize, dst);\n-      dst->traversed_vars = NULL;\n     }\n   else\n     htab_traverse (shared_hash_htab (src->vars), variable_union, dst);\n@@ -2479,6 +2445,18 @@ loc_cmp (rtx x, rtx y)\n \n   gcc_assert (GET_MODE (x) == GET_MODE (y));\n \n+  if (GET_CODE (x) == DEBUG_EXPR)\n+    {\n+      if (DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x))\n+\t  < DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (y)))\n+\treturn -1;\n+#ifdef ENABLE_CHECKING\n+      gcc_assert (DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x))\n+\t\t  > DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (y)));\n+#endif\n+      return 1;\n+    }\n+\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++)\n     switch (fmt[i])\n@@ -2718,6 +2696,13 @@ canonicalize_loc_order_check (void **slot, void *data ATTRIBUTE_UNUSED)\n   decl_or_value dv = var->dv;\n   location_chain node, next;\n \n+#ifdef ENABLE_RTL_CHECKING\n+  int i;\n+  for (i = 0; i < var->n_var_parts; i++)\n+    gcc_assert (var->var_part[0].cur_loc == NULL);\n+  gcc_assert (!var->cur_loc_changed && !var->in_changed_variables);\n+#endif\n+\n   if (!dv_onepart_p (dv))\n     return 1;\n \n@@ -3080,9 +3065,11 @@ variable_merge_over_cur (void **s1slot, void *data)\n \t      dvar->dv = dv;\n \t      dvar->refcount = 1;\n \t      dvar->n_var_parts = 1;\n+\t      dvar->cur_loc_changed = false;\n+\t      dvar->in_changed_variables = false;\n \t      dvar->var_part[0].offset = 0;\n \t      dvar->var_part[0].loc_chain = node;\n-\t      dvar->var_part[0].cur_loc = node->loc;\n+\t      dvar->var_part[0].cur_loc = NULL;\n \n \t      dstslot\n \t\t= shared_hash_find_slot_unshare_1 (&dst->vars, dv, dvhash,\n@@ -3212,6 +3199,8 @@ variable_merge_over_cur (void **s1slot, void *data)\n \t\t      var->dv = dv;\n \t\t      var->refcount = 1;\n \t\t      var->n_var_parts = 1;\n+\t\t      var->cur_loc_changed = false;\n+\t\t      var->in_changed_variables = false;\n \t\t      var->var_part[0].offset = 0;\n \t\t      var->var_part[0].loc_chain = NULL;\n \t\t      var->var_part[0].cur_loc = NULL;\n@@ -3248,11 +3237,7 @@ variable_merge_over_cur (void **s1slot, void *data)\n       dst_can_be_shared = false;\n     }\n   else\n-    {\n-      if (dvar->refcount == 1)\n-        dvar->var_part[0].cur_loc = dvar->var_part[0].loc_chain->loc;\n-      dst_can_be_shared = false;\n-    }\n+    dst_can_be_shared = false;\n \n   return 1;\n }\n@@ -3276,7 +3261,7 @@ variable_merge_over_src (void **s2slot, void *data)\n       void **dstp = shared_hash_find_slot (dst->vars, dv);\n       *dstp = s2var;\n       s2var->refcount++;\n-      return variable_canonicalize (dstp, dst);\n+      return 1;\n     }\n \n   dsm->src_onepart_cnt++;\n@@ -3746,13 +3731,14 @@ dataflow_set_preserve_mem_locs (void **slot, void *data)\n     {\n       tree decl = dv_as_decl (var->dv);\n       location_chain loc, *locp;\n+      bool changed = false;\n \n       if (!var->n_var_parts)\n \treturn 1;\n \n       gcc_assert (var->n_var_parts == 1);\n \n-      if (var->refcount > 1 || shared_hash_shared (set->vars))\n+      if (shared_var_p (var, set->vars))\n \t{\n \t  for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)\n \t    {\n@@ -3809,6 +3795,12 @@ dataflow_set_preserve_mem_locs (void **slot, void *data)\n \t    {\n \t      if (old_loc != loc->loc && emit_notes)\n \t\t{\n+\t\t  if (old_loc == var->var_part[0].cur_loc)\n+\t\t    {\n+\t\t      changed = true;\n+\t\t      var->var_part[0].cur_loc = NULL;\n+\t\t      var->cur_loc_changed = true;\n+\t\t    }\n \t\t  add_value_chains (var->dv, loc->loc);\n \t\t  remove_value_chains (var->dv, old_loc);\n \t\t}\n@@ -3817,7 +3809,15 @@ dataflow_set_preserve_mem_locs (void **slot, void *data)\n \t    }\n \n \t  if (emit_notes)\n-\t    remove_value_chains (var->dv, old_loc);\n+\t    {\n+\t      remove_value_chains (var->dv, old_loc);\n+\t      if (old_loc == var->var_part[0].cur_loc)\n+\t\t{\n+\t\t  changed = true;\n+\t\t  var->var_part[0].cur_loc = NULL;\n+\t\t  var->cur_loc_changed = true;\n+\t\t}\n+\t    }\n \t  *locp = loc->next;\n \t  pool_free (loc_chain_pool, loc);\n \t}\n@@ -3827,8 +3827,10 @@ dataflow_set_preserve_mem_locs (void **slot, void *data)\n \t  var->n_var_parts--;\n \t  if (emit_notes && dv_is_value_p (var->dv))\n \t    remove_cselib_value_chains (var->dv);\n-\t  variable_was_changed (var, set);\n+\t  changed = true;\n \t}\n+      if (changed)\n+\tvariable_was_changed (var, set);\n     }\n \n   return 1;\n@@ -3850,7 +3852,7 @@ dataflow_set_remove_mem_locs (void **slot, void *data)\n \n       gcc_assert (var->n_var_parts == 1);\n \n-      if (var->refcount > 1 || shared_hash_shared (set->vars))\n+      if (shared_var_p (var, set->vars))\n \t{\n \t  for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)\n \t    if (GET_CODE (loc->loc) == MEM\n@@ -3881,9 +3883,12 @@ dataflow_set_remove_mem_locs (void **slot, void *data)\n \t  /* If we have deleted the location which was last emitted\n \t     we have to emit new location so add the variable to set\n \t     of changed variables.  */\n-\t  if (var->var_part[0].cur_loc\n-\t      && rtx_equal_p (loc->loc, var->var_part[0].cur_loc))\n-\t    changed = true;\n+\t  if (var->var_part[0].cur_loc == loc->loc)\n+\t    {\n+\t      changed = true;\n+\t      var->var_part[0].cur_loc = NULL;\n+\t      var->cur_loc_changed = true;\n+\t    }\n \t  pool_free (loc_chain_pool, loc);\n \t}\n \n@@ -3892,14 +3897,10 @@ dataflow_set_remove_mem_locs (void **slot, void *data)\n \t  var->n_var_parts--;\n \t  if (emit_notes && dv_is_value_p (var->dv))\n \t    remove_cselib_value_chains (var->dv);\n-\t  gcc_assert (changed);\n+\t  changed = true;\n \t}\n       if (changed)\n-\t{\n-\t  if (var->n_var_parts && var->var_part[0].loc_chain)\n-\t    var->var_part[0].cur_loc = var->var_part[0].loc_chain->loc;\n-\t  variable_was_changed (var, set);\n-\t}\n+\tvariable_was_changed (var, set);\n     }\n \n   return 1;\n@@ -3987,13 +3988,10 @@ onepart_variable_different_p (variable var1, variable var2)\n   return lc1 != lc2;\n }\n \n-/* Return true if variables VAR1 and VAR2 are different.\n-   If COMPARE_CURRENT_LOCATION is true compare also the cur_loc of each\n-   variable part.  */\n+/* Return true if variables VAR1 and VAR2 are different.  */\n \n static bool\n-variable_different_p (variable var1, variable var2,\n-\t\t      bool compare_current_location)\n+variable_different_p (variable var1, variable var2)\n {\n   int i;\n \n@@ -4007,16 +4005,6 @@ variable_different_p (variable var1, variable var2,\n     {\n       if (var1->var_part[i].offset != var2->var_part[i].offset)\n \treturn true;\n-      if (compare_current_location)\n-\t{\n-\t  if (!((REG_P (var1->var_part[i].cur_loc)\n-\t\t && REG_P (var2->var_part[i].cur_loc)\n-\t\t && (REGNO (var1->var_part[i].cur_loc)\n-\t\t     == REGNO (var2->var_part[i].cur_loc)))\n-\t\t|| rtx_equal_p (var1->var_part[i].cur_loc,\n-\t\t\t\tvar2->var_part[i].cur_loc)))\n-\t    return true;\n-\t}\n       /* One-part values have locations in a canonical order.  */\n       if (i == 0 && var1->var_part[i].offset == 0 && dv_onepart_p (var1->dv))\n \t{\n@@ -4058,7 +4046,7 @@ dataflow_set_different_1 (void **slot, void *data)\n       return 0;\n     }\n \n-  if (variable_different_p (var1, var2, false))\n+  if (variable_different_p (var1, var2))\n     {\n       dataflow_set_different_value = true;\n \n@@ -5978,6 +5966,7 @@ variable_was_changed (variable var, dataflow_set *set)\n   if (emit_notes)\n     {\n       void **slot;\n+      bool old_cur_loc_changed = false;\n \n       /* Remember this decl or VALUE has been added to changed_variables.  */\n       set_dv_changed (var->dv, true);\n@@ -5986,6 +5975,14 @@ variable_was_changed (variable var, dataflow_set *set)\n \t\t\t\t       var->dv,\n \t\t\t\t       hash, INSERT);\n \n+      if (*slot)\n+\t{\n+\t  variable old_var = (variable) *slot;\n+\t  gcc_assert (old_var->in_changed_variables);\n+\t  old_var->in_changed_variables = false;\n+\t  old_cur_loc_changed = old_var->cur_loc_changed;\n+\t  variable_htab_free (*slot);\n+\t}\n       if (set && var->n_var_parts == 0)\n \t{\n \t  variable empty_var;\n@@ -5994,12 +5991,19 @@ variable_was_changed (variable var, dataflow_set *set)\n \t  empty_var->dv = var->dv;\n \t  empty_var->refcount = 1;\n \t  empty_var->n_var_parts = 0;\n+\t  empty_var->cur_loc_changed = true;\n+\t  empty_var->in_changed_variables = true;\n \t  *slot = empty_var;\n \t  goto drop_var;\n \t}\n       else\n \t{\n \t  var->refcount++;\n+\t  var->in_changed_variables = true;\n+\t  /* If within processing one uop a variable is deleted\n+\t     and then readded, we need to assume it has changed.  */\n+\t  if (old_cur_loc_changed)\n+\t    var->cur_loc_changed = true;\n \t  *slot = var;\n \t}\n     }\n@@ -6082,6 +6086,8 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n       var->dv = dv;\n       var->refcount = 1;\n       var->n_var_parts = 1;\n+      var->cur_loc_changed = false;\n+      var->in_changed_variables = false;\n       var->var_part[0].offset = offset;\n       var->var_part[0].loc_chain = NULL;\n       var->var_part[0].cur_loc = NULL;\n@@ -6179,7 +6185,7 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n       if (r == 0)\n \treturn slot;\n \n-      if (var->refcount > 1 || shared_hash_shared (set->vars))\n+      if (shared_var_p (var, set->vars))\n \t{\n \t  slot = unshare_variable (set, slot, var, initialized);\n \t  var = (variable)*slot;\n@@ -6218,7 +6224,7 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t  else\n \t    {\n \t      /* We have to make a copy of a shared variable.  */\n-\t      if (var->refcount > 1 || shared_hash_shared (set->vars))\n+\t      if (shared_var_p (var, set->vars))\n \t\t{\n \t\t  slot = unshare_variable (set, slot, var, initialized);\n \t\t  var = (variable)*slot;\n@@ -6230,7 +6236,7 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t  /* We have not found the location part, new one will be created.  */\n \n \t  /* We have to make a copy of the shared variable.  */\n-\t  if (var->refcount > 1 || shared_hash_shared (set->vars))\n+\t  if (shared_var_p (var, set->vars))\n \t    {\n \t      slot = unshare_variable (set, slot, var, initialized);\n \t      var = (variable)*slot;\n@@ -6267,6 +6273,11 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t\tinitialized = node->init;\n \t      if (node->set_src != NULL && set_src == NULL)\n \t\tset_src = node->set_src;\n+\t      if (var->var_part[pos].cur_loc == node->loc)\n+\t\t{\n+\t\t  var->var_part[pos].cur_loc = NULL;\n+\t\t  var->cur_loc_changed = true;\n+\t\t}\n \t      pool_free (loc_chain_pool, node);\n \t      *nextp = next;\n \t      break;\n@@ -6291,10 +6302,7 @@ set_slot_part (dataflow_set *set, rtx loc, void **slot,\n \n   /* If no location was emitted do so.  */\n   if (var->var_part[pos].cur_loc == NULL)\n-    {\n-      var->var_part[pos].cur_loc = loc;\n-      variable_was_changed (var, set);\n-    }\n+    variable_was_changed (var, set);\n \n   return slot;\n }\n@@ -6422,7 +6430,7 @@ delete_slot_part (dataflow_set *set, rtx loc, void **slot,\n       location_chain *nextp;\n       bool changed;\n \n-      if (var->refcount > 1 || shared_hash_shared (set->vars))\n+      if (shared_var_p (var, set->vars))\n \t{\n \t  /* If the variable contains the location part we have to\n \t     make a copy of the variable.  */\n@@ -6442,6 +6450,7 @@ delete_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t}\n \n       /* Delete the location part.  */\n+      changed = false;\n       nextp = &var->var_part[pos].loc_chain;\n       for (node = *nextp; node; node = next)\n \t{\n@@ -6452,6 +6461,15 @@ delete_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t    {\n \t      if (emit_notes && pos == 0 && dv_onepart_p (var->dv))\n \t\tremove_value_chains (var->dv, node->loc);\n+\t      /* If we have deleted the location which was last emitted\n+\t\t we have to emit new location so add the variable to set\n+\t\t of changed variables.  */\n+\t      if (var->var_part[pos].cur_loc == node->loc)\n+\t\t{\n+\t\t  changed = true;\n+\t\t  var->var_part[pos].cur_loc = NULL;\n+\t\t  var->cur_loc_changed = true;\n+\t\t}\n \t      pool_free (loc_chain_pool, node);\n \t      *nextp = next;\n \t      break;\n@@ -6460,28 +6478,16 @@ delete_slot_part (dataflow_set *set, rtx loc, void **slot,\n \t    nextp = &node->next;\n \t}\n \n-      /* If we have deleted the location which was last emitted\n-\t we have to emit new location so add the variable to set\n-\t of changed variables.  */\n-      if (var->var_part[pos].cur_loc\n-\t  && ((REG_P (loc)\n-\t       && REG_P (var->var_part[pos].cur_loc)\n-\t       && REGNO (loc) == REGNO (var->var_part[pos].cur_loc))\n-\t      || rtx_equal_p (loc, var->var_part[pos].cur_loc)))\n-\t{\n-\t  changed = true;\n-\t  if (var->var_part[pos].loc_chain)\n-\t    var->var_part[pos].cur_loc = var->var_part[pos].loc_chain->loc;\n-\t}\n-      else\n-\tchanged = false;\n-\n       if (var->var_part[pos].loc_chain == NULL)\n \t{\n-\t  gcc_assert (changed);\n+\t  changed = true;\n \t  var->n_var_parts--;\n-\t  if (emit_notes && var->n_var_parts == 0 && dv_is_value_p (var->dv))\n-\t    remove_cselib_value_chains (var->dv);\n+\t  if (emit_notes)\n+\t    {\n+\t      var->cur_loc_changed = true;\n+\t      if (var->n_var_parts == 0 && dv_is_value_p (var->dv))\n+\t\tremove_cselib_value_chains (var->dv);\n+\t    }\n \t  while (pos < var->n_var_parts)\n \t    {\n \t      var->var_part[pos] = var->var_part[pos + 1];\n@@ -6510,14 +6516,38 @@ delete_variable_part (dataflow_set *set, rtx loc, decl_or_value dv,\n   slot = delete_slot_part (set, loc, slot, offset);\n }\n \n+/* Structure for passing some other parameters to function\n+   vt_expand_loc_callback.  */\n+struct expand_loc_callback_data\n+{\n+  /* The variables and values active at this point.  */\n+  htab_t vars;\n+\n+  /* True in vt_expand_loc_dummy calls, no rtl should be allocated.\n+     Non-NULL should be returned if vt_expand_loc would return\n+     non-NULL in that case, NULL otherwise.  cur_loc_changed should be\n+     computed and cur_loc recomputed when possible (but just once\n+     per emit_notes_for_changes call).  */\n+  bool dummy;\n+\n+  /* True if expansion of subexpressions had to recompute some\n+     VALUE/DEBUG_EXPR_DECL's cur_loc or used a VALUE/DEBUG_EXPR_DECL\n+     whose cur_loc has been already recomputed during current\n+     emit_notes_for_changes call.  */\n+  bool cur_loc_changed;\n+};\n+\n /* Callback for cselib_expand_value, that looks for expressions\n    holding the value in the var-tracking hash tables.  Return X for\n    standard processing, anything else is to be used as-is.  */\n \n static rtx\n vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n {\n-  htab_t vars = (htab_t)data;\n+  struct expand_loc_callback_data *elcd\n+    = (struct expand_loc_callback_data *) data;\n+  bool dummy = elcd->dummy;\n+  bool cur_loc_changed = elcd->cur_loc_changed;\n   decl_or_value dv;\n   variable var;\n   location_chain loc;\n@@ -6526,25 +6556,23 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n   switch (GET_CODE (x))\n     {\n     case SUBREG:\n-      subreg = SUBREG_REG (x);\n-\n-      if (GET_CODE (SUBREG_REG (x)) != VALUE)\n-\treturn x;\n-\n       subreg = cselib_expand_value_rtx_cb (SUBREG_REG (x), regs,\n \t\t\t\t\t   max_depth - 1,\n \t\t\t\t\t   vt_expand_loc_callback, data);\n \n       if (!subreg)\n \treturn NULL;\n \n+      if (dummy)\n+\treturn pc_rtx;\n+\n       result = simplify_gen_subreg (GET_MODE (x), subreg,\n \t\t\t\t    GET_MODE (SUBREG_REG (x)),\n \t\t\t\t    SUBREG_BYTE (x));\n \n       /* Invalid SUBREGs are ok in debug info.  ??? We could try\n \t alternate expansions for the VALUE as well.  */\n-      if (!result && (REG_P (subreg) || MEM_P (subreg)))\n+      if (!result)\n \tresult = gen_rtx_raw_SUBREG (GET_MODE (x), subreg, SUBREG_BYTE (x));\n \n       return result;\n@@ -6566,25 +6594,78 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n   if (VALUE_RECURSED_INTO (x))\n     return NULL;\n \n-  var = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n+  var = (variable) htab_find_with_hash (elcd->vars, dv, dv_htab_hash (dv));\n \n   if (!var)\n-    return xret;\n+    {\n+      if (dummy && dv_changed_p (dv))\n+\telcd->cur_loc_changed = true;\n+      return xret;\n+    }\n \n   if (var->n_var_parts == 0)\n-    return xret;\n+    {\n+      if (dummy)\n+\telcd->cur_loc_changed = true;\n+      return xret;\n+    }\n \n   gcc_assert (var->n_var_parts == 1);\n \n   VALUE_RECURSED_INTO (x) = true;\n   result = NULL;\n \n-  for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)\n+  if (var->var_part[0].cur_loc)\n     {\n-      result = cselib_expand_value_rtx_cb (loc->loc, regs, max_depth,\n-\t\t\t\t\t   vt_expand_loc_callback, vars);\n+      if (dummy)\n+\t{\n+\t  if (cselib_dummy_expand_value_rtx_cb (var->var_part[0].cur_loc, regs,\n+\t\t\t\t\t\tmax_depth,\n+\t\t\t\t\t\tvt_expand_loc_callback, data))\n+\t    result = pc_rtx;\n+\t}\n+      else\n+\tresult = cselib_expand_value_rtx_cb (var->var_part[0].cur_loc, regs,\n+\t\t\t\t\t     max_depth,\n+\t\t\t\t\t     vt_expand_loc_callback, data);\n       if (result)\n-\tbreak;\n+\tset_dv_changed (dv, false);\n+    }\n+  if (!result && dv_changed_p (dv))\n+    {\n+      set_dv_changed (dv, false);\n+      for (loc = var->var_part[0].loc_chain; loc; loc = loc->next)\n+\tif (loc->loc == var->var_part[0].cur_loc)\n+\t  continue;\n+\telse if (dummy)\n+\t  {\n+\t    elcd->cur_loc_changed = cur_loc_changed;\n+\t    if (cselib_dummy_expand_value_rtx_cb (loc->loc, regs, max_depth,\n+\t\t\t\t\t\t  vt_expand_loc_callback,\n+\t\t\t\t\t\t  data))\n+\t      {\n+\t\tresult = pc_rtx;\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      {\n+\t\tresult = cselib_expand_value_rtx_cb (loc->loc, regs, max_depth,\n+\t\t\t\t\t\t     vt_expand_loc_callback,\n+\t\t\t\t\t\t     data);\n+\t\tif (result)\n+\t\t  break;\n+\t      }\n+\t  }\n+      if (dummy && (result || var->var_part[0].cur_loc))\n+\tvar->cur_loc_changed = true;\n+      var->var_part[0].cur_loc = loc ? loc->loc : NULL_RTX;\n+    }\n+  if (dummy)\n+    {\n+      if (var->cur_loc_changed)\n+\telcd->cur_loc_changed = true;\n+      else if (!result && var->var_part[0].cur_loc == NULL_RTX)\n+\telcd->cur_loc_changed = cur_loc_changed;\n     }\n \n   VALUE_RECURSED_INTO (x) = false;\n@@ -6600,18 +6681,46 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n static rtx\n vt_expand_loc (rtx loc, htab_t vars)\n {\n+  struct expand_loc_callback_data data;\n+\n   if (!MAY_HAVE_DEBUG_INSNS)\n     return loc;\n \n+  data.vars = vars;\n+  data.dummy = false;\n+  data.cur_loc_changed = false;\n   loc = cselib_expand_value_rtx_cb (loc, scratch_regs, 5,\n-\t\t\t\t    vt_expand_loc_callback, vars);\n+\t\t\t\t    vt_expand_loc_callback, &data);\n \n   if (loc && MEM_P (loc))\n     loc = targetm.delegitimize_address (loc);\n-\n   return loc;\n }\n \n+/* Like vt_expand_loc, but only return true/false (whether vt_expand_loc\n+   would succeed or not, without actually allocating new rtxes.  */\n+\n+static bool\n+vt_expand_loc_dummy (rtx loc, htab_t vars, bool *pcur_loc_changed)\n+{\n+  struct expand_loc_callback_data data;\n+  bool ret;\n+\n+  gcc_assert (MAY_HAVE_DEBUG_INSNS);\n+  data.vars = vars;\n+  data.dummy = true;\n+  data.cur_loc_changed = false;\n+  ret = cselib_dummy_expand_value_rtx_cb (loc, scratch_regs, 5,\n+\t\t\t\t\t  vt_expand_loc_callback, &data);\n+  *pcur_loc_changed = data.cur_loc_changed;\n+  return ret;\n+}\n+\n+#ifdef ENABLE_RTL_CHECKING\n+/* Used to verify that cur_loc_changed updating is safe.  */\n+static struct pointer_map_t *emitted_notes;\n+#endif\n+\n /* Emit the NOTE_INSN_VAR_LOCATION for variable *VARP.  DATA contains\n    additional parameters: WHERE specifies whether the note shall be emitted\n    before or after instruction INSN.  */\n@@ -6623,7 +6732,7 @@ emit_note_insn_var_location (void **varp, void *data)\n   rtx insn = ((emit_note_data *)data)->insn;\n   enum emit_note_where where = ((emit_note_data *)data)->where;\n   htab_t vars = ((emit_note_data *)data)->vars;\n-  rtx note;\n+  rtx note, note_vl;\n   int i, j, n_var_parts;\n   bool complete;\n   enum var_init_status initialized = VAR_INIT_STATUS_UNINITIALIZED;\n@@ -6632,20 +6741,34 @@ emit_note_insn_var_location (void **varp, void *data)\n   HOST_WIDE_INT offsets[MAX_VAR_PARTS];\n   rtx loc[MAX_VAR_PARTS];\n   tree decl;\n+  location_chain lc;\n \n   if (dv_is_value_p (var->dv))\n-    goto clear;\n+    goto value_or_debug_decl;\n \n   decl = dv_as_decl (var->dv);\n \n   if (TREE_CODE (decl) == DEBUG_EXPR_DECL)\n-    goto clear;\n-\n-  gcc_assert (decl);\n+    goto value_or_debug_decl;\n \n   complete = true;\n   last_limit = 0;\n   n_var_parts = 0;\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    {\n+      for (i = 0; i < var->n_var_parts; i++)\n+\tif (var->var_part[i].cur_loc == NULL && var->var_part[i].loc_chain)\n+\t  {\n+\t    var->var_part[i].cur_loc = var->var_part[i].loc_chain->loc;\n+\t    var->cur_loc_changed = true;\n+\t  }\n+      if (var->n_var_parts == 0)\n+\tvar->cur_loc_changed = true;\n+    }\n+#ifndef ENABLE_RTL_CHECKING\n+  if (!var->cur_loc_changed)\n+    goto clear;\n+#endif\n   for (i = 0; i < var->n_var_parts; i++)\n     {\n       enum machine_mode mode, wider_mode;\n@@ -6659,15 +6782,26 @@ emit_note_insn_var_location (void **varp, void *data)\n       else if (last_limit > var->var_part[i].offset)\n \tcontinue;\n       offsets[n_var_parts] = var->var_part[i].offset;\n-      loc2 = vt_expand_loc (var->var_part[i].loc_chain->loc, vars);\n+      if (!var->var_part[i].cur_loc)\n+\t{\n+\t  complete = false;\n+\t  continue;\n+\t}\n+      loc2 = vt_expand_loc (var->var_part[i].cur_loc, vars);\n       if (!loc2)\n \t{\n \t  complete = false;\n \t  continue;\n \t}\n       loc[n_var_parts] = loc2;\n-      mode = GET_MODE (var->var_part[i].loc_chain->loc);\n-      initialized = var->var_part[i].loc_chain->init;\n+      mode = GET_MODE (var->var_part[i].cur_loc);\n+      for (lc = var->var_part[i].loc_chain; lc; lc = lc->next)\n+\tif (var->var_part[i].cur_loc == lc->loc)\n+\t  {\n+\t    initialized = lc->init;\n+\t    break;\n+\t  }\n+      gcc_assert (lc);\n       last_limit = offsets[n_var_parts] + GET_MODE_SIZE (mode);\n \n       /* Attempt to merge adjacent registers or memory.  */\n@@ -6677,11 +6811,12 @@ emit_note_insn_var_location (void **varp, void *data)\n \t  break;\n       if (j < var->n_var_parts\n \t  && wider_mode != VOIDmode\n-\t  && mode == GET_MODE (var->var_part[j].loc_chain->loc)\n+\t  && var->var_part[j].cur_loc\n+\t  && mode == GET_MODE (var->var_part[j].cur_loc)\n \t  && (REG_P (loc[n_var_parts]) || MEM_P (loc[n_var_parts]))\n-\t  && (loc2 = vt_expand_loc (var->var_part[j].loc_chain->loc, vars))\n-\t  && GET_CODE (loc[n_var_parts]) == GET_CODE (loc2)\n-\t  && last_limit == var->var_part[j].offset)\n+\t  && last_limit == var->var_part[j].offset\n+\t  && (loc2 = vt_expand_loc (var->var_part[j].cur_loc, vars))\n+\t  && GET_CODE (loc[n_var_parts]) == GET_CODE (loc2))\n \t{\n \t  rtx new_loc = NULL;\n \n@@ -6740,31 +6875,20 @@ emit_note_insn_var_location (void **varp, void *data)\n   if ((unsigned HOST_WIDE_INT) last_limit < TREE_INT_CST_LOW (type_size_unit))\n     complete = false;\n \n-  if (where != EMIT_NOTE_BEFORE_INSN)\n-    {\n-      note = emit_note_after (NOTE_INSN_VAR_LOCATION, insn);\n-      if (where == EMIT_NOTE_AFTER_CALL_INSN)\n-\tNOTE_DURING_CALL_P (note) = true;\n-    }\n-  else\n-    note = emit_note_before (NOTE_INSN_VAR_LOCATION, insn);\n-\n   if (! flag_var_tracking_uninit)\n     initialized = VAR_INIT_STATUS_INITIALIZED;\n \n+  note_vl = NULL_RTX;\n   if (!complete)\n-    {\n-      NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, decl,\n-\t\t\t\t\t\t       NULL_RTX, (int) initialized);\n-    }\n+    note_vl = gen_rtx_VAR_LOCATION (VOIDmode, decl, NULL_RTX,\n+\t\t\t\t    (int) initialized);\n   else if (n_var_parts == 1)\n     {\n       rtx expr_list\n \t= gen_rtx_EXPR_LIST (VOIDmode, loc[0], GEN_INT (offsets[0]));\n \n-      NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, decl,\n-\t\t\t\t\t\t       expr_list,\n-\t\t\t\t\t\t       (int) initialized);\n+      note_vl = gen_rtx_VAR_LOCATION (VOIDmode, decl, expr_list,\n+\t\t\t\t      (int) initialized);\n     }\n   else if (n_var_parts)\n     {\n@@ -6776,17 +6900,64 @@ emit_note_insn_var_location (void **varp, void *data)\n \n       parallel = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t\t   gen_rtvec_v (n_var_parts, loc));\n-      NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, decl,\n-\t\t\t\t\t\t       parallel,\n-\t\t\t\t\t\t       (int) initialized);\n+      note_vl = gen_rtx_VAR_LOCATION (VOIDmode, decl,\n+\t\t\t\t      parallel, (int) initialized);\n     }\n \n+#ifdef ENABLE_RTL_CHECKING\n+  if (note_vl)\n+    {\n+      void **note_slot = pointer_map_insert (emitted_notes, decl);\n+      rtx pnote = (rtx) *note_slot;\n+      if (!var->cur_loc_changed && (pnote || PAT_VAR_LOCATION_LOC (note_vl)))\n+\t{\n+\t  gcc_assert (pnote);\n+\t  gcc_assert (rtx_equal_p (PAT_VAR_LOCATION_LOC (pnote),\n+\t\t\t\t   PAT_VAR_LOCATION_LOC (note_vl)));\n+\t}\n+      *note_slot = (void *) note_vl;\n+    }\n+  if (!var->cur_loc_changed)\n+    goto clear;\n+#endif\n+\n+  if (where != EMIT_NOTE_BEFORE_INSN)\n+    {\n+      note = emit_note_after (NOTE_INSN_VAR_LOCATION, insn);\n+      if (where == EMIT_NOTE_AFTER_CALL_INSN)\n+\tNOTE_DURING_CALL_P (note) = true;\n+    }\n+  else\n+    note = emit_note_before (NOTE_INSN_VAR_LOCATION, insn);\n+  NOTE_VAR_LOCATION (note) = note_vl;\n+\n  clear:\n   set_dv_changed (var->dv, false);\n+  var->cur_loc_changed = false;\n+  gcc_assert (var->in_changed_variables);\n+  var->in_changed_variables = false;\n   htab_clear_slot (changed_variables, varp);\n \n   /* Continue traversing the hash table.  */\n   return 1;\n+\n+ value_or_debug_decl:\n+  if (dv_changed_p (var->dv) && var->n_var_parts)\n+    {\n+      location_chain lc;\n+      bool cur_loc_changed;\n+\n+      if (var->var_part[0].cur_loc\n+\t  && vt_expand_loc_dummy (var->var_part[0].cur_loc, vars,\n+\t\t\t\t  &cur_loc_changed))\n+\tgoto clear;\n+      for (lc = var->var_part[0].loc_chain; lc; lc = lc->next)\n+\tif (lc->loc != var->var_part[0].cur_loc\n+\t    && vt_expand_loc_dummy (lc->loc, vars, &cur_loc_changed))\n+\t  break;\n+      var->var_part[0].cur_loc = lc ? lc->loc : NULL_RTX;\n+    }\n+  goto clear;\n }\n \n DEF_VEC_P (variable);\n@@ -6858,6 +7029,48 @@ check_changed_vars_2 (variable var, htab_t htab)\n     }\n }\n \n+/* For each changed decl (except DEBUG_EXPR_DECLs) recompute\n+   cur_loc if needed (and cur_loc of all VALUEs and DEBUG_EXPR_DECLs\n+   it needs and are also in changed variables) and track whether\n+   cur_loc (or anything it uses to compute location) had to change\n+   during the current emit_notes_for_changes call.  */\n+\n+static int\n+check_changed_vars_3 (void **slot, void *data)\n+{\n+  variable var = (variable) *slot;\n+  htab_t vars = (htab_t) data;\n+  int i;\n+  location_chain lc;\n+  bool cur_loc_changed;\n+\n+  if (dv_is_value_p (var->dv)\n+      || TREE_CODE (dv_as_decl (var->dv)) == DEBUG_EXPR_DECL)\n+    return 1;\n+\n+  for (i = 0; i < var->n_var_parts; i++)\n+    {\n+      if (var->var_part[i].cur_loc\n+\t  && vt_expand_loc_dummy (var->var_part[i].cur_loc, vars,\n+\t\t\t\t  &cur_loc_changed))\n+\t{\n+\t  if (cur_loc_changed)\n+\t    var->cur_loc_changed = true;\n+\t  continue;\n+\t}\n+      for (lc = var->var_part[i].loc_chain; lc; lc = lc->next)\n+\tif (lc->loc != var->var_part[i].cur_loc\n+\t    && vt_expand_loc_dummy (lc->loc, vars, &cur_loc_changed))\n+\t  break;\n+      if (lc || var->var_part[i].cur_loc)\n+\tvar->cur_loc_changed = true;\n+      var->var_part[i].cur_loc = lc ? lc->loc : NULL_RTX;\n+    }\n+  if (var->n_var_parts == 0)\n+    var->cur_loc_changed = true;\n+  return 1;\n+}\n+\n /* Emit NOTE_INSN_VAR_LOCATION note for each variable from a chain\n    CHANGED_VARIABLES and delete this chain.  WHERE specifies whether the notes\n    shall be emitted before of after instruction INSN.  */\n@@ -6881,6 +7094,7 @@ emit_notes_for_changes (rtx insn, enum emit_note_where where,\n       while (VEC_length (variable, changed_variables_stack) > 0)\n \tcheck_changed_vars_2 (VEC_pop (variable, changed_variables_stack),\n \t\t\t      htab);\n+      htab_traverse (changed_variables, check_changed_vars_3, htab);\n     }\n \n   data.insn = insn;\n@@ -6912,6 +7126,8 @@ emit_notes_for_differences_1 (void **slot, void *data)\n       empty_var->dv = old_var->dv;\n       empty_var->refcount = 0;\n       empty_var->n_var_parts = 0;\n+      empty_var->cur_loc_changed = false;\n+      empty_var->in_changed_variables = false;\n       if (dv_onepart_p (old_var->dv))\n \t{\n \t  location_chain lc;\n@@ -6923,8 +7139,10 @@ emit_notes_for_differences_1 (void **slot, void *data)\n \t    remove_cselib_value_chains (old_var->dv);\n \t}\n       variable_was_changed (empty_var, NULL);\n+      /* Continue traversing the hash table.  */\n+      return 1;\n     }\n-  else if (variable_different_p (old_var, new_var, true))\n+  if (variable_different_p (old_var, new_var))\n     {\n       if (dv_onepart_p (old_var->dv))\n \t{\n@@ -6949,6 +7167,33 @@ emit_notes_for_differences_1 (void **slot, void *data)\n \t}\n       variable_was_changed (new_var, NULL);\n     }\n+  /* Update cur_loc.  */\n+  if (old_var != new_var)\n+    {\n+      int i;\n+      for (i = 0; i < new_var->n_var_parts; i++)\n+\t{\n+\t  new_var->var_part[i].cur_loc = NULL;\n+\t  if (old_var->n_var_parts != new_var->n_var_parts\n+\t      || old_var->var_part[i].offset != new_var->var_part[i].offset)\n+\t    new_var->cur_loc_changed = true;\n+\t  else if (old_var->var_part[i].cur_loc != NULL)\n+\t    {\n+\t      location_chain lc;\n+\t      rtx cur_loc = old_var->var_part[i].cur_loc;\n+\n+\t      for (lc = new_var->var_part[i].loc_chain; lc; lc = lc->next)\n+\t\tif (lc->loc == cur_loc\n+\t\t    || rtx_equal_p (cur_loc, lc->loc))\n+\t\t  {\n+\t\t    new_var->var_part[i].cur_loc = lc->loc;\n+\t\t    break;\n+\t\t  }\n+\t      if (lc == NULL)\n+\t\tnew_var->cur_loc_changed = true;\n+\t    }\n+\t}\n+    }\n \n   /* Continue traversing the hash table.  */\n   return 1;\n@@ -6968,6 +7213,7 @@ emit_notes_for_differences_2 (void **slot, void *data)\n \t\t\t\t\t    dv_htab_hash (new_var->dv));\n   if (!old_var)\n     {\n+      int i;\n       /* Variable has appeared.  */\n       if (dv_onepart_p (new_var->dv))\n \t{\n@@ -6979,6 +7225,8 @@ emit_notes_for_differences_2 (void **slot, void *data)\n \t  if (dv_is_value_p (new_var->dv))\n \t    add_cselib_value_chains (new_var->dv);\n \t}\n+      for (i = 0; i < new_var->n_var_parts; i++)\n+\tnew_var->var_part[i].cur_loc = NULL;\n       variable_was_changed (new_var, NULL);\n     }\n \n@@ -7283,6 +7531,9 @@ vt_emit_notes (void)\n   basic_block bb;\n   dataflow_set cur;\n \n+#ifdef ENABLE_RTL_CHECKING\n+  emitted_notes = pointer_map_create ();\n+#endif\n   gcc_assert (!htab_elements (changed_variables));\n \n   /* Free memory occupied by the out hash tables, as they aren't used\n@@ -7324,6 +7575,9 @@ vt_emit_notes (void)\n   if (MAY_HAVE_DEBUG_INSNS)\n     VEC_free (variable, heap, changed_variables_stack);\n \n+#ifdef ENABLE_RTL_CHECKING\n+  pointer_map_destroy (emitted_notes);\n+#endif\n   emit_notes = false;\n }\n "}]}