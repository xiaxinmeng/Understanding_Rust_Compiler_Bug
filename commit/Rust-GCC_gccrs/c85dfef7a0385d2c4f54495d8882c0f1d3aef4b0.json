{"sha": "c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg1ZGZlZjdhMDM4NWQyYzRmNTQ0OTVkODg4MmMwZjFkM2FlZjRiMA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-11-15T14:26:47Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-11-15T14:26:47Z"}, "message": "std_cmath.h: Don't import C99's float transcendentals into the __gnu_cxx::__c99_binding...\n\n\n\t* include/c_std/std_cmath.h: Don't import C99's float transcendentals\n\tinto the __gnu_cxx::__c99_binding namespace.\n\t(acos, asin, atan, atan2, ceil, cosh, exp, floor, fmod, frexp,\n\tldexp, log, log10, modf, pow, sinh, tan, tanh): Implement using\n\tGCC's math builtins, i.e. __builtin_foo.\n\t* libmath/stubs.c (acosf, acosl, asinf, asinl, atanf, atanl,\n\tceilf, ceill, floorf, floorl, fmodf, fmodl, frexpf, frexpl,\n\tldexpf, ldexpl, modff, modfl): Provide stub implementations.\n\nFrom-SVN: r73629", "tree": {"sha": "0b957def5b15a525410bba871e11102a1c097b00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b957def5b15a525410bba871e11102a1c097b00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0/comments", "author": null, "committer": null, "parents": [{"sha": "1f7290e64d03a849a1d983b9faaaab975f8cb5a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f7290e64d03a849a1d983b9faaaab975f8cb5a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f7290e64d03a849a1d983b9faaaab975f8cb5a7"}], "stats": {"total": 595, "additions": 259, "deletions": 336}, "files": [{"sha": "2cb7a3c41bf74a89b01353e856fd5dfdb1e931c5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0", "patch": "@@ -1,3 +1,14 @@\n+2003-11-15  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* include/c_std/std_cmath.h: Don't import C99's float transcendentals\n+\tinto the __gnu_cxx::__c99_binding namespace.\n+\t(acos, asin, atan, atan2, ceil, cosh, exp, floor, fmod, frexp,\n+\tldexp, log, log10, modf, pow, sinh, tan, tanh): Implement using\n+\tGCC's math builtins, i.e. __builtin_foo.\n+\t* libmath/stubs.c (acosf, acosl, asinf, asinl, atanf, atanl,\n+\tceilf, ceill, floorf, floorl, fmodf, fmodl, frexpf, frexpl,\n+\tldexpf, ldexpl, modff, modfl): Provide stub implementations.\n+\n 2003-11-14  Paolo Carlini  <pcarlini@suse.de>\n \n \t* testsuite/22_locale/locale/cons/12352.cc: Use"}, {"sha": "8be2882bb7a93b14b114f4b10f6bb7f199c65540", "filename": "libstdc++-v3/include/c_std/std_cmath.h", "status": "modified", "additions": 87, "deletions": 336, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h?ref=c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0", "patch": "@@ -77,90 +77,6 @@\n #undef tan\n #undef tanh\n \n-// ...and in the darkness bind them...\n-namespace __gnu_cxx\n-{\n-  namespace  __c99_binding\n-  {\n-#if _GLIBCXX_USE_C99_FLOAT_TRANSCENDENTALS_CHECK || \\\n-    _GLIBCXX_USE_C99_FLOAT_TRANSCENDENTALS_DYNAMIC\n-    extern \"C\" float (acosf)(float);\n-    extern \"C\" float (asinf)(float);\n-    extern \"C\" float (atanf)(float);\n-    extern \"C\" float (atan2f)(float, float);\n-    extern \"C\" float (ceilf)(float);\n-    extern \"C\" float (coshf)(float);\n-    extern \"C\" float (expf)(float);\n-    extern \"C\" float (floorf)(float);\n-    extern \"C\" float (fmodf)(float, float);\n-    extern \"C\" float (frexpf)(float, int*);\n-    extern \"C\" float (ldexpf)(float, int);\n-    extern \"C\" float (logf)(float);\n-    extern \"C\" float (log10f)(float);\n-    extern \"C\" float (modff)(float, float*);\n-    extern \"C\" float (powf)(float, float);\n-    extern \"C\" float (sinhf)(float);\n-    extern \"C\" float (tanf)(float);\n-    extern \"C\" float (tanhf)(float);\n-#endif\n-#if !_GLIBCXX_USE_C99_FLOAT_TRANSCENDENTALS_DYNAMIC\n-#if _GLIBCXX_HAVE_ACOSF\n-    using ::acosf;\n-#endif\n-#if _GLIBCXX_HAVE_ASINF\n-    using ::asinf;\n-#endif\n-#if _GLIBCXX_HAVE_ATANF\n-    using ::atanf;\n-#endif\n-#if _GLIBCXX_HAVE_ATAN2F\n-    using ::atan2f;\n-#endif\n-#if _GLIBCXX_HAVE_CEILF\n-    using ::ceilf;\n-#endif\n-#if _GLIBCXX_HAVE_COSHF\n-    using ::coshf;\n-#endif\n-#if _GLIBCXX_HAVE_EXPF\n-    using ::expf;\n-#endif\n-#if _GLIBCXX_HAVE_FLOORF\n-    using ::floorf;\n-#endif\n-#if _GLIBCXX_HAVE_FMODF\n-    using ::fmodf;\n-#endif\n-#if _GLIBCXX_HAVE_FREXPF\n-    using ::frexpf;\n-#endif\n-#if _GLIBCXX_HAVE_LDEXPF\n-    using ::ldexpf;\n-#endif\n-#if _GLIBCXX_HAVE_LOGF\n-    using ::logf;\n-#endif\n-#if _GLIBCXX_HAVE_LOG10F\n-    using ::log10f;\n-#endif\n-#if _GLIBCXX_HAVE_MODFF\n-    using ::modff;\n-#endif\n-#if _GLIBCXX_HAVE_POWF\n-    using ::powf;\n-#endif\n-#if _GLIBCXX_HAVE_SINHF\n-    using ::sinhf;\n-#endif\n-#if _GLIBCXX_HAVE_TANF\n-    using ::tanf;\n-#endif\n-#if _GLIBCXX_HAVE_TANHF\n-    using ::tanhf;\n-#endif\n-#endif /* _GLIBCXX_USE_C99_FLOAT_TRANSCENDENTALS_DYNAMIC */\n-  }\n-}\n \n namespace std \n {\n@@ -180,125 +96,83 @@ namespace std\n   abs(long double __x)\n   { return __builtin_fabsl(__x); }\n \n-#if _GLIBCXX_HAVE_ACOSF\n-  inline float \n-  acos(float __x) { return __gnu_cxx::__c99_binding::acosf(__x); }\n-#else\n-  inline float \n-  acos(float __x) { return ::acos(static_cast<double>(__x)); }\n-#endif\n-\n   using ::acos;\n-  \n-#if _GLIBCXX_HAVE_ACOSL\n-  inline long double \n-  acos(long double __x) { return ::acosl(__x); }\n-#else\n-  inline long double \n-  acos(long double __x) { return ::acos(static_cast<double>(__x)); }\n-#endif\n+\n+  inline float\n+  acos(float __x)\n+  { return __builtin_acosf(__x); }\n+\n+  inline long double\n+  acos(long double __x)\n+  { return __builtin_acosl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     acos(_Tp __x)\n     {\n-      return ::acos(static_cast<double>(__x));\n+      return __builtin_acos(__x);\n     }\n   \n   using ::asin;\n \n-#if _GLIBCXX_HAVE_ASINF\n-  inline float \n-  asin(float __x) { return __gnu_cxx::__c99_binding::asinf(__x); }\n-#else\n   inline float \n-  asin(float __x) { return ::asin(static_cast<double>(__x)); }\n-#endif\n+  asin(float __x)\n+  { return __builtin_asinf(__x); }\n \n-#if _GLIBCXX_HAVE_ASINL\n   inline long double \n-  asin(long double __x) { return ::asinl(__x); }\n-#else\n-  inline long double \n-  asin(long double __x) { return ::asin(static_cast<double>(__x)); }\n-#endif\n+  asin(long double __x)\n+  { return __builtin_asinl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     asin(_Tp __x)\n-    { return ::asin(static_cast<double>(__x)); }\n+    { return __builtin_asin(__x); }\n \n   using ::atan;\n \n-#if _GLIBCXX_HAVE_ATANF\n-  inline float \n-  atan(float __x) { return __gnu_cxx::__c99_binding::atanf(__x); }\n-#else\n   inline float \n-  atan(float __x) { return ::atan(static_cast<double>(__x)); }\n-#endif\n+  atan(float __x)\n+  { return __builtin_atanf(__x); }\n \n-#if _GLIBCXX_HAVE_ATANL\n-  inline long double \n-  atan(long double __x) { return ::atanl(__x); }\n-#else\n   inline long double \n-  atan(long double __x) { return ::atan(static_cast<double>(__x)); }\n-#endif\n+  atan(long double __x)\n+  { return __builtin_atanl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     atan(_Tp __x)\n-    { return ::atan(static_cast<double>(__x)); }\n+    { return __builtin_atan(__x); }\n   \n   using ::atan2;\n \n-#if _GLIBCXX_HAVE_ATAN2F\n-  inline float \n-  atan2(float __y, float __x) { return __gnu_cxx::__c99_binding::atan2f(__y, __x); }\n-#else\n   inline float \n   atan2(float __y, float __x)\n-  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n-#endif\n+  { return __builtin_atan2f(__y, __x); }\n \n-#if _GLIBCXX_HAVE_ATAN2L\n-  inline long double \n-  atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }\n-#else\n   inline long double \n-  atan2(long double __y, long double __x) \n-  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n-#endif\n+  atan2(long double __y, long double __x)\n+  { return __builtin_atan2l(__y, __x); }\n \n   template<typename _Tp, typename _Up>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type\n                                         && __is_integer<_Up>::_M_type>::_M_type\n-    atan2(_Tp __x, _Up __y)\n-    { return ::atan2(static_cast<double>(__x), static_cast<double>(__y)); }\n+    atan2(_Tp __y, _Up __x)\n+    { return __builtin_atan2(__y, __x); }\n \n   using ::ceil;\n \n-#if _GLIBCXX_HAVE_CEILF\n-  inline float \n-  ceil(float __x) { return __gnu_cxx::__c99_binding::ceilf(__x); }\n-#else\n   inline float \n-  ceil(float __x) { return ::ceil(static_cast<double>(__x)); }\n-#endif\n+  ceil(float __x)\n+  { return __builtin_ceilf(__x); }\n \n-#if _GLIBCXX_HAVE_CEILL\n   inline long double \n-  ceil(long double __x) { return ::ceill(__x); }\n-#else\n-  inline long double \n-  ceil(long double __x) { return ::ceil(static_cast<double>(__x)); }\n-#endif\n+  ceil(long double __x)\n+  { return __builtin_ceill(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     ceil(_Tp __x)\n-    { return ::ceil(static_cast<double>(__x)); }\n+    { return __builtin_ceil(__x); }\n   \n   using ::cos;\n \n@@ -317,49 +191,33 @@ namespace std\n \n   using ::cosh;\n \n-#if _GLIBCXX_HAVE_COSHF\n-  inline float \n-  cosh(float __x) { return __gnu_cxx::__c99_binding::coshf(__x); }\n-#else\n   inline float \n-  cosh(float __x) { return ::cosh(static_cast<double>(__x)); }\n-#endif\n+  cosh(float __x)\n+  { return __builtin_coshf(__x); }\n \n-#if _GLIBCXX_HAVE_COSHL\n-  inline long double \n-  cosh(long double __x) { return ::coshl(__x); }\n-#else\n   inline long double \n-  cosh(long double __x) { return ::cosh(static_cast<double>(__x)); }\n-#endif\n+  cosh(long double __x)\n+  { return __builtin_coshl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     cosh(_Tp __x)\n-    { return ::cosh(static_cast<double>(__x)); }\n+    { return __builtin_cosh(__x); }\n \n   using ::exp;\n \n-#if _GLIBCXX_HAVE_EXPF\n-  inline float \n-  exp(float __x) { return __gnu_cxx::__c99_binding::expf(__x); }\n-#else\n   inline float \n-  exp(float __x) { return ::exp(static_cast<double>(__x)); }\n-#endif\n+  exp(float __x)\n+  { return __builtin_expf(__x); }\n \n-#if _GLIBCXX_HAVE_EXPL\n-  inline long double \n-  exp(long double __x) { return ::expl(__x); }\n-#else\n   inline long double \n-  exp(long double __x) { return ::exp(static_cast<double>(__x)); }\n-#endif\n+  exp(long double __x)\n+  { return __builtin_expl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     exp(_Tp __x)\n-    { return ::exp(static_cast<double>(__x)); }\n+    { return __builtin_exp(__x); }\n   \n   using ::fabs;\n \n@@ -378,171 +236,98 @@ namespace std\n \n   using ::floor;\n \n-#if _GLIBCXX_HAVE_FLOORF\n   inline float \n-  floor(float __x) { return __gnu_cxx::__c99_binding::floorf(__x); }\n-#else\n-  inline float \n-  floor(float __x) { return ::floor(static_cast<double>(__x)); }\n-#endif\n+  floor(float __x)\n+  { return __builtin_floorf(__x); }\n \n-#if _GLIBCXX_HAVE_FLOORL\n-  inline long double \n-  floor(long double __x) { return ::floorl(__x); }\n-#else\n   inline long double \n-  floor(long double __x) { return ::floor(static_cast<double>(__x)); }\n-#endif\n+  floor(long double __x)\n+  { return __builtin_floorl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     floor(_Tp __x)\n-    { return ::floor(static_cast<double>(__x)); }\n+    { return __builtin_floor(__x); }\n   \n   using ::fmod;\n \n-#if _GLIBCXX_HAVE_FMODF\n-  inline float \n-  fmod(float __x, float __y) { return __gnu_cxx::__c99_binding::fmodf(__x, __y); }\n-#else\n   inline float \n   fmod(float __x, float __y)\n-  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n-#endif\n+  { return __builtin_fmodf(__x, __y); }\n \n-#if _GLIBCXX_HAVE_FMODL\n   inline long double \n-  fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }\n-#else\n-  inline long double \n-  fmod(long double __x, long double __y) \n-  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n-#endif\n+  fmod(long double __x, long double __y)\n+  { return __builtin_fmodl(__x, __y); }\n \n   using ::frexp;\n \n-#if _GLIBCXX_HAVE_FREXPF\n-  inline float \n-  frexp(float __x, int* __exp) { return __gnu_cxx::__c99_binding::frexpf(__x, __exp); }\n-#else\n   inline float \n-  frexp(float __x, int* __exp) { return ::frexp(__x, __exp); }\n-#endif\n+  frexp(float __x, int* __exp)\n+  { return __builtin_frexpf(__x, __exp); }\n \n-#if _GLIBCXX_HAVE_FREXPL\n-  inline long double \n-  frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }\n-#else\n   inline long double \n-  frexp(long double __x, int* __exp) \n-  { return ::frexp(static_cast<double>(__x), __exp); }\n-#endif\n+  frexp(long double __x, int* __exp)\n+  { return __builtin_frexpl(__x, __exp); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     frexp(_Tp __x, int* __exp)\n-    { return ::frexp(static_cast<double>(__x), __exp); }\n+    { return __builtin_frexp(__x, __exp); }\n   \n   using ::ldexp;\n \n-#if _GLIBCXX_HAVE_LDEXPF\n-  inline float \n-  ldexp(float __x, int __exp) { return __gnu_cxx::__c99_binding::ldexpf(__x, __exp); }\n-#else\n   inline float \n   ldexp(float __x, int __exp)\n-  { return ::ldexp(static_cast<double>(__x), __exp); }\n-#endif\n+  { return __builtin_ldexpf(__x, __exp); }\n \n-#if _GLIBCXX_HAVE_LDEXPL\n-  inline long double \n-  ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }\n-#else\n   inline long double \n-  ldexp(long double __x, int __exp) \n-  { return ::ldexp(static_cast<double>(__x), __exp); }\n-#endif\n+  ldexp(long double __x, int __exp)\n+  { return __builtin_ldexpl(__x, __exp); }\n \n   template<typename _Tp>\n   inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n   ldexp(_Tp __x, int __exp)\n-  { return ::ldexp(static_cast<double>(__x), __exp); }\n+  { return __builtin_ldexp(__x, __exp); }\n \n   using ::log;\n \n-#if _GLIBCXX_HAVE_LOGF\n   inline float \n-  log(float __x) { return __gnu_cxx::__c99_binding::logf(__x); }\n-#else\n-  inline float log(float __x)\n-  { return ::log(static_cast<double>(__x)); }\n-#endif\n+  log(float __x)\n+  { return __builtin_logf(__x); }\n \n-#if _GLIBCXX_HAVE_LOGL\n-  inline long double \n-  log(long double __x) { return ::logl(__x); }\n-#else\n   inline long double \n-  log(long double __x) { return ::log(static_cast<double>(__x)); }\n-#endif\n+  log(long double __x)\n+  { return __builtin_logl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     log(_Tp __x)\n-    { return ::log(static_cast<double>(__x)); }\n+    { return __builtin_log(__x); }\n   \n   using ::log10;\n \n-#if _GLIBCXX_HAVE_LOG10F\n-  inline float \n-  log10(float __x) { return __gnu_cxx::__c99_binding::log10f(__x); }\n-#else\n   inline float \n-  log10(float __x) { return ::log10(static_cast<double>(__x)); }\n-#endif\n+  log10(float __x)\n+  { return __builtin_log10f(__x); }\n \n-#if _GLIBCXX_HAVE_LOG10L\n-  inline long double \n-  log10(long double __x) { return ::log10l(__x); }\n-#else\n   inline long double \n-  log10(long double __x) { return ::log10(static_cast<double>(__x)); }\n-#endif\n+  log10(long double __x)\n+  { return __builtin_log10l(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     log10(_Tp __x)\n-    { return ::log10(static_cast<double>(__x)); }\n+    { return __builtin_log10(__x); }\n   \n   using ::modf;\n \n-#if _GLIBCXX_HAVE_MODFF\n-  inline float \n-  modf(float __x, float* __iptr) { return __gnu_cxx::__c99_binding::modff(__x, __iptr); }\n-#else\n   inline float \n   modf(float __x, float* __iptr)\n-  {\n-    double __tmp;\n-    double __res = ::modf(static_cast<double>(__x), &__tmp);\n-    *__iptr = static_cast<float>(__tmp);\n-    return __res;\n-  }\n-#endif\n+  { return __builtin_modff(__x, __iptr); }\n \n-#if _GLIBCXX_HAVE_MODFL\n   inline long double \n-  modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }\n-#else\n-  inline long double \n-  modf(long double __x, long double* __iptr) \n-  { \n-    double __tmp;\n-    double __res = ::modf(static_cast<double>(__x), &__tmp);\n-    * __iptr = static_cast<long double>(__tmp);\n-    return __res;\n-  }\n-#endif\n+  modf(long double __x, long double* __iptr)\n+  { return __builtin_modfl(__x, __iptr); }\n \n   template<typename _Tp>\n     inline _Tp\n@@ -555,23 +340,13 @@ namespace std\n \n   using ::pow;\n \n-#if _GLIBCXX_HAVE_POWF\n-  inline float \n-  pow(float __x, float __y) { return __gnu_cxx::__c99_binding::powf(__x, __y); }\n-#else\n   inline float \n   pow(float __x, float __y)\n-  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n-#endif\n+  { return __builtin_powf(__x, __y); }\n \n-#if _GLIBCXX_HAVE_POWL\n-  inline long double \n-  pow(long double __x, long double __y) { return ::powl(__x, __y); }\n-#else\n   inline long double \n-  pow(long double __x, long double __y) \n-  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n-#endif\n+  pow(long double __x, long double __y)\n+  { return __builtin_powl(__x, __y); }\n \n   inline double \n   pow(double __x, int __i)\n@@ -602,26 +377,18 @@ namespace std\n \n   using ::sinh;\n \n-#if _GLIBCXX_HAVE_SINHF\n   inline float \n-  sinh(float __x) { return __gnu_cxx::__c99_binding::sinhf(__x); }\n-#else\n-  inline float \n-  sinh(float __x) { return ::sinh(static_cast<double>(__x)); }\n-#endif\n+  sinh(float __x)\n+  { return __builtin_sinhf(__x); }\n \n-#if _GLIBCXX_HAVE_SINHL\n-  inline long double \n-  sinh(long double __x) { return ::sinhl(__x); }\n-#else\n   inline long double \n-  sinh(long double __x) { return ::sinh(static_cast<double>(__x)); }\n-#endif\n+  sinh(long double __x)\n+  { return __builtin_sinhl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     sinh(_Tp __x)\n-    { return ::sinh(static_cast<_Tp>(__x)); }\n+    { return __builtin_sinh(__x); }\n   \n   using ::sqrt;\n \n@@ -640,49 +407,33 @@ namespace std\n   \n   using ::tan;\n \n-#if _GLIBCXX_HAVE_TANF\n-  inline float \n-  tan(float __x) { return __gnu_cxx::__c99_binding::tanf(__x); }\n-#else\n   inline float \n-  tan(float __x) { return ::tan(static_cast<double>(__x)); }\n-#endif\n+  tan(float __x)\n+  { return __builtin_tanf(__x); }\n \n-#if _GLIBCXX_HAVE_TANL\n   inline long double \n-  tan(long double __x) { return ::tanl(__x); }\n-#else\n-  inline long double \n-  tan(long double __x) { return ::tan(static_cast<double>(__x)); }\n-#endif\n+  tan(long double __x)\n+  { return __builtin_tanl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     tan(_Tp __x)\n-    { return ::tan(static_cast<double>(__x)); }\n+    { return __builtin_tan(__x); }\n   \n   using ::tanh;\n \n-#if _GLIBCXX_HAVE_TANHF\n-  inline float \n-  tanh(float __x) { return __gnu_cxx::__c99_binding::tanhf(__x); }\n-#else\n   inline float \n-  tanh(float __x) { return ::tanh(static_cast<double>(__x)); }\n-#endif\n+  tanh(float __x)\n+  { return __builtin_tanhf(__x); }\n \n-#if _GLIBCXX_HAVE_TANHL\n-  inline long double \n-  tanh(long double __x) { return ::tanhl(__x); }\n-#else\n   inline long double \n-  tanh(long double __x) { return ::tanh(static_cast<double>(__x)); }\n-#endif\n+  tanh(long double __x)\n+  { return __builtin_tanhl(__x); }\n \n   template<typename _Tp>\n     inline typename __enable_if<double, __is_integer<_Tp>::_M_type>::_M_type\n     tanh(_Tp __x)\n-    { return ::tanh(static_cast<double>(__x)); }\n+    { return __builtin_tanh(__x); }\n } \n \n "}, {"sha": "797b2017fb0627608ce8c4395d56b43c07d2a787", "filename": "libstdc++-v3/libmath/stubs.c", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0/libstdc%2B%2B-v3%2Flibmath%2Fstubs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0/libstdc%2B%2B-v3%2Flibmath%2Fstubs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibmath%2Fstubs.c?ref=c85dfef7a0385d2c4f54495d8882c0f1d3aef4b0", "patch": "@@ -34,6 +34,57 @@\n    we use the crude approximation.  We'll do better later.  */\n \n \n+#ifndef HAVE_ACOSF\n+float\n+acosf(float x)\n+{\n+  return (float) acos(x);\n+}\n+#endif\n+\n+#ifndef HAVE_ACOSL\n+long double\n+acosl(long double x)\n+{\n+  return acos((double) x);\n+}\n+#endif\n+\n+\n+#ifndef HAVE_ASINF\n+float\n+asinf(float x)\n+{\n+  return (float) asin(x);\n+}\n+#endif\n+\n+#ifndef HAVE_ASINL\n+long double\n+asinl(long double x)\n+{\n+  return asin((double) x);\n+}\n+#endif\n+\n+\n+#ifndef HAVE_ATANF\n+float\n+atanf(float x)\n+{\n+  return (float) atan(x);\n+}\n+#endif\n+\n+#ifndef HAVE_ATANL\n+long double\n+atanl(long double x)\n+{\n+  return atan ((double) x);\n+}\n+#endif\n+\n+\n #ifndef HAVE_ATAN2F\n float\n atan2f(float x, float y)\n@@ -51,6 +102,23 @@ atan2l(long double x, long double y)\n #endif\n \n \n+#ifndef HAVE_CEILF\n+float\n+ceilf(float x)\n+{\n+  return (float) ceil(x);\n+}\n+#endif\n+\n+#ifndef HAVE_CEILL\n+long double\n+ceill(long double x)\n+{\n+  return ceil((double) x);\n+}\n+#endif\n+\n+\n #ifndef HAVE_COSF\n float\n cosf(float x)\n@@ -102,6 +170,57 @@ expl(long double x)\n #endif\n \n \n+#ifndef HAVE_FLOORF\n+float\n+floorf(float x)\n+{\n+  return (float) floor(x);\n+}\n+#endif\n+\n+#ifndef HAVE_FLOORL\n+long double\n+floorl(long double x)\n+{\n+  return floor((double) x);\n+}\n+#endif\n+\n+\n+#ifndef HAVE_FMODF\n+float\n+fmodf(float x, float y)\n+{\n+  return (float) fmod(x, y);\n+}\n+#endif\n+\n+#ifndef HAVE_FMODL\n+long double\n+fmodl(long double x, long double y)\n+{\n+  return fmod((double) x, (double) y);\n+}\n+#endif\n+\n+\n+#ifndef HAVE_FREXPF\n+float\n+frexpf(float x, int *exp)\n+{\n+  return (float) frexp(x, exp);\n+}\n+#endif\n+\n+#ifndef HAVE_FREXPL\n+long double\n+frexpl(long double x, int *exp)\n+{\n+  return frexp((double) x, exp);\n+}\n+#endif\n+\n+\n #ifndef HAVE_SQRTF\n float\n sqrtf(float x)\n@@ -158,6 +277,23 @@ hypotl(long double x, long double y)\n \n \n \n+#ifndef HAVE_LDEXPF\n+float\n+ldexpf(float x, int exp)\n+{\n+  return (float) ldexp(x, exp);\n+}\n+#endif\n+\n+#ifndef HAVE_LDEXPL\n+long double\n+ldexpl(long double x, int exp)\n+{\n+  return ldexp((double) x, exp);\n+}\n+#endif\n+\n+\n #ifndef HAVE_LOGF\n float\n logf(float x)\n@@ -192,6 +328,31 @@ log10l(long double x)\n #endif\n \n \n+#ifndef HAVE_MODFF\n+float\n+modff(float x, float *iptr)\n+{\n+  double result, temp;\n+\n+  result = modf(x, &temp);\n+  *iptr = (float) temp;\n+  return (float) result;\n+}\n+#endif\n+\n+#ifndef HAVE_MODFL\n+long double\n+modfl(long double x, long double *iptr)\n+{\n+  double result, temp;\n+\n+  result = modf((double) x, &temp);\n+  *iptr = temp;\n+  return result;\n+}\n+#endif\n+\n+\n #ifndef HAVE_POWF\n float\n powf(float x, float y)"}]}