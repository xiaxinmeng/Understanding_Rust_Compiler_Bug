{"sha": "4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmZWI2NWMzMjQ4ZTRlY2UyNzIwZWE2MTZkOTMzM2JkZWRhZjVmZg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-12-31T11:32:16Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-12-31T11:32:16Z"}, "message": "re PR fortran/47065 (Replace trim(a) by a(1:len_trim(a)))\n\n2010-12-31  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/47065\n\t* frontend-passes.c (count_arglist):  Static variable to\n\tcount the nesting of argument lists.\n\t(optimize_code):  Set count_arglist to 1 if within a call\n\tstatement, to 0 otherwise.\n\t(optimize_trim):  New function.\n\t(optimize_expr):  Adjust count_arglist.  Call optimize_trim.\n\n2010-12-31  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/47065\n\t* gfortran.dg/trim_optimize_3.f90:  New test.\n\t* gfortran.dg/trim_optimize_4.f90:  New test.\n\nFrom-SVN: r168367", "tree": {"sha": "dce0054aa68fea712fe3f1b5b0444415fe2541ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dce0054aa68fea712fe3f1b5b0444415fe2541ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/comments", "author": null, "committer": null, "parents": [{"sha": "7c1a49fa1b2535dcce600d03887e2c72a463cc2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c1a49fa1b2535dcce600d03887e2c72a463cc2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c1a49fa1b2535dcce600d03887e2c72a463cc2c"}], "stats": {"total": 162, "additions": 161, "deletions": 1}, "files": [{"sha": "e25d4e38124e8d20ffabe0c9b1756545c2bdc4f1", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "patch": "@@ -1,3 +1,13 @@\n+2010-12-31  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/47065\n+\t* frontend-passes.c (count_arglist):  Static variable to\n+\tcount the nesting of argument lists.\n+\t(optimize_code):  Set count_arglist to 1 if within a call\n+\tstatement, to 0 otherwise.\n+\t(optimize_trim):  New function.\n+\t(optimize_expr):  Adjust count_arglist.  Call optimize_trim.\n+\n 2010-12-31  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/45338"}, {"sha": "0777dba6869c16448e52b6a1fb3280bf9f6e89db", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "patch": "@@ -34,6 +34,11 @@ static void optimize_namespace (gfc_namespace *);\n static void optimize_assignment (gfc_code *);\n static bool optimize_op (gfc_expr *);\n static bool optimize_comparison (gfc_expr *, gfc_intrinsic_op);\n+static bool optimize_trim (gfc_expr *);\n+\n+/* How deep we are inside an argument list.  */\n+\n+static int count_arglist;\n \n /* Entry point - run all passes for a namespace.  So far, only an\n    optimization pass is run.  */\n@@ -56,7 +61,18 @@ static int\n optimize_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t       void *data ATTRIBUTE_UNUSED)\n {\n-  if ((*c)->op == EXEC_ASSIGN)\n+\n+  gfc_exec_op op;\n+\n+  op = (*c)->op;\n+\n+  if (op == EXEC_CALL || op == EXEC_COMPCALL || op == EXEC_ASSIGN_CALL\n+      || op == EXEC_CALL_PPC)\n+    count_arglist = 1;\n+  else\n+    count_arglist = 0;\n+\n+  if (op == EXEC_ASSIGN)\n     optimize_assignment (*c);\n   return 0;\n }\n@@ -68,8 +84,25 @@ static int\n optimize_expr (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t       void *data ATTRIBUTE_UNUSED)\n {\n+  bool function_expr;\n+\n+  if ((*e)->expr_type == EXPR_FUNCTION)\n+    {\n+      count_arglist ++;\n+      function_expr = true;\n+    }\n+  else\n+    function_expr = false;\n+\n+  if (optimize_trim (*e))\n+    gfc_simplify_expr (*e, 0);\n+\n   if ((*e)->expr_type == EXPR_OP && optimize_op (*e))\n     gfc_simplify_expr (*e, 0);\n+\n+  if (function_expr)\n+    count_arglist --;\n+\n   return 0;\n }\n \n@@ -395,6 +428,76 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n   return false;\n }\n \n+/* Optimize a trim function by replacing it with an equivalent substring\n+   involving a call to len_trim.  This only works for expressions where\n+   variables are trimmed.  Return true if anything was modified.  */\n+\n+static bool\n+optimize_trim (gfc_expr *e)\n+{\n+  gfc_expr *a;\n+  gfc_ref *ref;\n+  gfc_expr *fcn;\n+  gfc_actual_arglist *actual_arglist, *next;\n+\n+  /* Don't do this optimization within an argument list, because\n+     otherwise aliasing issues may occur.  */\n+\n+  if (count_arglist != 1)\n+    return false;\n+\n+  if (e->ts.type != BT_CHARACTER || e->expr_type != EXPR_FUNCTION\n+      || e->value.function.isym == NULL\n+      || e->value.function.isym->id != GFC_ISYM_TRIM)\n+    return false;\n+\n+  a = e->value.function.actual->expr;\n+\n+  if (a->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  if (a->ref)\n+    {\n+      /* FIXME - also handle substring references, by modifying the\n+\t reference itself.  Make sure not to evaluate functions in\n+\t the references twice.  */\n+      return false;\n+    }\n+  else\n+    {\n+      strip_function_call (e);\n+\n+      /* Create the reference.  */\n+\n+      ref = gfc_get_ref ();\n+      ref->type = REF_SUBSTRING;\n+\n+      /* Set the start of the reference.  */\n+\n+      ref->u.ss.start = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n+\n+      /* Build the function call to len_trim(x, gfc_defaul_integer_kind).  */\n+\n+      fcn = gfc_get_expr ();\n+      fcn->expr_type = EXPR_FUNCTION;\n+      fcn->value.function.isym =\n+\tgfc_intrinsic_function_by_id (GFC_ISYM_LEN_TRIM);\n+      actual_arglist = gfc_get_actual_arglist ();\n+      actual_arglist->expr = gfc_copy_expr (e);\n+      next = gfc_get_actual_arglist ();\n+      next->expr = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t     gfc_default_integer_kind);\n+      actual_arglist->next = next;\n+      fcn->value.function.actual = actual_arglist;\n+\n+      /* Set the end of the reference to the call to len_trim.  */\n+\n+      ref->u.ss.end = fcn;\n+      e->ref = ref;\n+      return true;\n+    }\n+}\n+\n #define WALK_SUBEXPR(NODE) \\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\"}, {"sha": "82959637820a056795e9b03d9f77b1d08e49ab0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "patch": "@@ -1,3 +1,9 @@\n+2010-12-31  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/47065\n+\t* gfortran.dg/trim_optimize_3.f90:  New test.\n+\t* gfortran.dg/trim_optimize_4.f90:  New test.\n+\n 2010-12-31  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/45338"}, {"sha": "33cf8b2b9408f2ff95598d36732e99c3b0438b94", "filename": "gcc/testsuite/gfortran.dg/trim_optimize_3.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_3.f90?ref=4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+! PR 47065 - replace trim with substring expressions.\n+program main\n+  character(len=10) :: a, b\n+  character(kind=4,len=10) :: a4, b4\n+  character(len=100) :: line\n+  a = 'bcd'\n+  b = trim(a) // 'x'\n+  if (b /= 'bcdx') call abort\n+  a4 = 4_\"bcd\"\n+  b4 = trim(a4) // 4_'x'\n+  if (b4 /= 4_'bcdx') call abort\n+end\n+! { dg-final { scan-tree-dump-times \"string_len_trim\" 2 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "41c65b10bcde46a5de53ed39b6c22fc2576d1335", "filename": "gcc/testsuite/gfortran.dg/trim_optimize_4.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4afeb65c3248e4ece2720ea616d9333bdedaf5ff/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_4.f90?ref=4afeb65c3248e4ece2720ea616d9333bdedaf5ff", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+! PR 47065 - make sure that trim optimization does not lead to\n+! wrong-code with aliasing.\n+! Test case provided by Tobias Burnus.\n+program main\n+  character(len=12) :: str\n+  str = '1234567890'\n+  call sub(trim(str), str)\n+  ! Should print '12345       '\n+  if (str /= '12345       ') call abort\n+  call two(trim(str))\n+  if (str /= '123         ') call abort\n+contains\n+  subroutine sub(a,b)\n+    character(len=*), intent(in) :: a\n+    character(len=*), intent(out) :: b\n+    b = ''\n+    b = a(1:5)\n+  end subroutine sub\n+  subroutine two(a)\n+    character(len=*), intent(in) :: a\n+    str = ''\n+    str(1:3) = a(1:3)\n+  end subroutine two\n+end program main"}]}