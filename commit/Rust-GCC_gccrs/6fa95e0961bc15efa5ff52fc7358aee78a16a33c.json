{"sha": "6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZhOTVlMDk2MWJjMTVlZmE1ZmY1MmZjNzM1OGFlZTc4YTE2YTMzYw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2017-05-14T00:39:23Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2017-05-14T00:39:23Z"}, "message": "make inverted_post_order_compute() operate on a vec\n\ngcc/ChangeLog:\n\n2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* cfganal.c (inverted_post_order_compute): Change argument type\n\tto vec *.\n\t* cfganal.h (inverted_post_order_compute): Adjust prototype.\n\t* df-core.c (rest_of_handle_df_initialize): Adjust.\n\t(rest_of_handle_df_finish): Likewise.\n\t(df_analyze_1): Likewise.\n\t(df_analyze): Likewise.\n\t(loop_inverted_post_order_compute): Change argument to be a vec *.\n\t(df_analyze_loop): Adjust.\n\t(df_get_n_blocks): Likewise.\n\t(df_get_postorder): Likewise.\n\t* df.h (struct df_d): Change field to be a vec.\n\t* lcm.c (compute_laterin): Adjust.\n\t(compute_available): Likewise.\n\t* lra-lives.c (lra_create_live_ranges_1): Likewise.\n\t* tree-ssa-dce.c (remove_dead_stmt): Likewise.\n\t* tree-ssa-pre.c (compute_antic): Likewise.\n\nFrom-SVN: r248027", "tree": {"sha": "cb4fb40255dee04a4d085d4a1614b8d8b295cd27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb4fb40255dee04a4d085d4a1614b8d8b295cd27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/comments", "author": null, "committer": null, "parents": [{"sha": "35bfaf4d537dbf181575c9568a54da33d45a30ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35bfaf4d537dbf181575c9568a54da33d45a30ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35bfaf4d537dbf181575c9568a54da33d45a30ad"}], "stats": {"total": 138, "additions": 72, "deletions": 66}, "files": [{"sha": "b8bff6a17c51ac153705c666d58adba604894bb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -1,3 +1,23 @@\n+2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* cfganal.c (inverted_post_order_compute): Change argument type\n+\tto vec *.\n+\t* cfganal.h (inverted_post_order_compute): Adjust prototype.\n+\t* df-core.c (rest_of_handle_df_initialize): Adjust.\n+\t(rest_of_handle_df_finish): Likewise.\n+\t(df_analyze_1): Likewise.\n+\t(df_analyze): Likewise.\n+\t(loop_inverted_post_order_compute): Change argument to be a vec *.\n+\t(df_analyze_loop): Adjust.\n+\t(df_get_n_blocks): Likewise.\n+\t(df_get_postorder): Likewise.\n+\t* df.h (struct df_d): Change field to be a vec.\n+\t* lcm.c (compute_laterin): Adjust.\n+\t(compute_available): Likewise.\n+\t* lra-lives.c (lra_create_live_ranges_1): Likewise.\n+\t* tree-ssa-dce.c (remove_dead_stmt): Likewise.\n+\t* tree-ssa-pre.c (compute_antic): Likewise.\n+\n 2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* cfganal.c (connect_infinite_loops_to_exit): Adjust."}, {"sha": "a3a6ea869941f9204f383ecc3e2d6b5e984c1f6e", "filename": "gcc/cfganal.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -790,12 +790,12 @@ dfs_find_deadend (basic_block bb)\n    and start looking for a \"dead end\" from that block\n    and do another inverted traversal from that block.  */\n \n-int\n-inverted_post_order_compute (int *post_order,\n+void\n+inverted_post_order_compute (vec<int> *post_order,\n \t\t\t     sbitmap *start_points)\n {\n   basic_block bb;\n-  int post_order_num = 0;\n+  post_order->reserve_exact (n_basic_blocks_for_fn (cfun));\n \n   if (flag_checking)\n     verify_no_unreachable_blocks ();\n@@ -863,13 +863,13 @@ inverted_post_order_compute (int *post_order,\n                    time, check its predecessors.  */\n \t\tstack.quick_push (ei_start (pred->preds));\n               else\n-                post_order[post_order_num++] = pred->index;\n+\t\tpost_order->quick_push (pred->index);\n             }\n           else\n             {\n \t      if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun)\n \t\t  && ei_one_before_end_p (ei))\n-                post_order[post_order_num++] = bb->index;\n+\t\tpost_order->quick_push (bb->index);\n \n               if (!ei_one_before_end_p (ei))\n \t\tei_next (&stack.last ());\n@@ -927,9 +927,7 @@ inverted_post_order_compute (int *post_order,\n   while (!stack.is_empty ());\n \n   /* EXIT_BLOCK is always included.  */\n-  post_order[post_order_num++] = EXIT_BLOCK;\n-\n-  return post_order_num;\n+  post_order->quick_push (EXIT_BLOCK);\n }\n \n /* Compute the depth first search order of FN and store in the array"}, {"sha": "39bb5e547a53fca66a8b7718d87e789973600db4", "filename": "gcc/cfganal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Fcfganal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Fcfganal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.h?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -63,7 +63,7 @@ extern void add_noreturn_fake_exit_edges (void);\n extern void connect_infinite_loops_to_exit (void);\n extern int post_order_compute (int *, bool, bool);\n extern basic_block dfs_find_deadend (basic_block);\n-extern int inverted_post_order_compute (int *, sbitmap *start_points = 0);\n+extern void inverted_post_order_compute (vec<int> *postorder, sbitmap *start_points = 0);\n extern int pre_and_rev_post_order_compute_fn (struct function *,\n \t\t\t\t\t      int *, int *, bool);\n extern int pre_and_rev_post_order_compute (int *, int *, bool);"}, {"sha": "1e84d4d948f4404df36bdb6ff9557a19cfae1b7c", "filename": "gcc/df-core.c", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -702,10 +702,9 @@ rest_of_handle_df_initialize (void)\n     df_live_add_problem ();\n \n   df->postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  df->postorder_inverted = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   df->n_blocks = post_order_compute (df->postorder, true, true);\n-  df->n_blocks_inverted = inverted_post_order_compute (df->postorder_inverted);\n-  gcc_assert (df->n_blocks == df->n_blocks_inverted);\n+  inverted_post_order_compute (&df->postorder_inverted);\n+  gcc_assert ((unsigned) df->n_blocks == df->postorder_inverted.length ());\n \n   df->hard_regs_live_count = XCNEWVEC (unsigned int, FIRST_PSEUDO_REGISTER);\n \n@@ -816,7 +815,7 @@ rest_of_handle_df_finish (void)\n     }\n \n   free (df->postorder);\n-  free (df->postorder_inverted);\n+  df->postorder_inverted.release ();\n   free (df->hard_regs_live_count);\n   free (df);\n   df = NULL;\n@@ -1198,7 +1197,7 @@ df_analyze_1 (void)\n   int i;\n \n   /* These should be the same.  */\n-  gcc_assert (df->n_blocks == df->n_blocks_inverted);\n+  gcc_assert ((unsigned) df->n_blocks == df->postorder_inverted.length ());\n \n   /* We need to do this before the df_verify_all because this is\n      not kept incrementally up to date.  */\n@@ -1222,8 +1221,8 @@ df_analyze_1 (void)\n           if (dflow->problem->dir == DF_FORWARD)\n             df_analyze_problem (dflow,\n                                 df->blocks_to_analyze,\n-                                df->postorder_inverted,\n-                                df->n_blocks_inverted);\n+\t\t\t\tdf->postorder_inverted.address (),\n+\t\t\t\tdf->postorder_inverted.length ());\n           else\n             df_analyze_problem (dflow,\n                                 df->blocks_to_analyze,\n@@ -1249,23 +1248,21 @@ void\n df_analyze (void)\n {\n   bitmap current_all_blocks = BITMAP_ALLOC (&df_bitmap_obstack);\n-  int i;\n \n   free (df->postorder);\n-  free (df->postorder_inverted);\n   df->postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  df->postorder_inverted = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   df->n_blocks = post_order_compute (df->postorder, true, true);\n-  df->n_blocks_inverted = inverted_post_order_compute (df->postorder_inverted);\n+  df->postorder_inverted.truncate (0);\n+  inverted_post_order_compute (&df->postorder_inverted);\n \n-  for (i = 0; i < df->n_blocks; i++)\n+  for (int i = 0; i < df->n_blocks; i++)\n     bitmap_set_bit (current_all_blocks, df->postorder[i]);\n \n   if (flag_checking)\n     {\n       /* Verify that POSTORDER_INVERTED only contains blocks reachable from\n \t the ENTRY block.  */\n-      for (i = 0; i < df->n_blocks_inverted; i++)\n+      for (unsigned int i = 0; i < df->postorder_inverted.length (); i++)\n \tgcc_assert (bitmap_bit_p (current_all_blocks,\n \t\t\t\t  df->postorder_inverted[i]));\n     }\n@@ -1277,9 +1274,10 @@ df_analyze (void)\n       bitmap_and_into (df->blocks_to_analyze, current_all_blocks);\n       df->n_blocks = df_prune_to_subcfg (df->postorder,\n \t\t\t\t\t df->n_blocks, df->blocks_to_analyze);\n-      df->n_blocks_inverted = df_prune_to_subcfg (df->postorder_inverted,\n-\t\t\t\t\t\t  df->n_blocks_inverted,\n+      unsigned int newlen = df_prune_to_subcfg (df->postorder_inverted.address (),\n+\t\t\t\t\t\tdf->postorder_inverted.length (),\n \t\t\t\t\t\t  df->blocks_to_analyze);\n+      df->postorder_inverted.truncate (newlen);\n       BITMAP_FREE (current_all_blocks);\n     }\n   else\n@@ -1355,13 +1353,14 @@ loop_post_order_compute (int *post_order, struct loop *loop)\n /* Compute the reverse top sort order of the inverted sub-CFG specified\n    by LOOP.  Returns the number of blocks which is always loop->num_nodes.  */\n \n-static int\n-loop_inverted_post_order_compute (int *post_order, struct loop *loop)\n+static void\n+loop_inverted_post_order_compute (vec<int> *post_order, struct loop *loop)\n {\n   basic_block bb;\n   edge_iterator *stack;\n   int sp;\n-  int post_order_num = 0;\n+\n+  post_order->reserve_exact (loop->num_nodes);\n \n   /* Allocate stack for back-tracking up CFG.  */\n   stack = XNEWVEC (edge_iterator, loop->num_nodes + 1);\n@@ -1398,13 +1397,13 @@ loop_inverted_post_order_compute (int *post_order, struct loop *loop)\n \t       time, check its predecessors.  */\n \t    stack[sp++] = ei_start (pred->preds);\n \t  else\n-\t    post_order[post_order_num++] = pred->index;\n+\t    post_order->quick_push (pred->index);\n \t}\n       else\n \t{\n \t  if (flow_bb_inside_loop_p (loop, bb)\n \t      && ei_one_before_end_p (ei))\n-\t    post_order[post_order_num++] = bb->index;\n+\t    post_order->quick_push (bb->index);\n \n \t  if (!ei_one_before_end_p (ei))\n \t    ei_next (&stack[sp - 1]);\n@@ -1414,7 +1413,6 @@ loop_inverted_post_order_compute (int *post_order, struct loop *loop)\n     }\n \n   free (stack);\n-  return post_order_num;\n }\n \n \n@@ -1424,15 +1422,13 @@ void\n df_analyze_loop (struct loop *loop)\n {\n   free (df->postorder);\n-  free (df->postorder_inverted);\n \n   df->postorder = XNEWVEC (int, loop->num_nodes);\n-  df->postorder_inverted = XNEWVEC (int, loop->num_nodes);\n+  df->postorder_inverted.truncate (0);\n   df->n_blocks = loop_post_order_compute (df->postorder, loop);\n-  df->n_blocks_inverted\n-    = loop_inverted_post_order_compute (df->postorder_inverted, loop);\n+    loop_inverted_post_order_compute (&df->postorder_inverted, loop);\n   gcc_assert ((unsigned) df->n_blocks == loop->num_nodes);\n-  gcc_assert ((unsigned) df->n_blocks_inverted == loop->num_nodes);\n+  gcc_assert (df->postorder_inverted.length () == loop->num_nodes);\n \n   bitmap blocks = BITMAP_ALLOC (&df_bitmap_obstack);\n   for (int i = 0; i < df->n_blocks; ++i)\n@@ -1453,8 +1449,8 @@ df_get_n_blocks (enum df_flow_dir dir)\n \n   if (dir == DF_FORWARD)\n     {\n-      gcc_assert (df->postorder_inverted);\n-      return df->n_blocks_inverted;\n+      gcc_assert (df->postorder_inverted.length ());\n+      return df->postorder_inverted.length ();\n     }\n \n   gcc_assert (df->postorder);\n@@ -1473,8 +1469,8 @@ df_get_postorder (enum df_flow_dir dir)\n \n   if (dir == DF_FORWARD)\n     {\n-      gcc_assert (df->postorder_inverted);\n-      return df->postorder_inverted;\n+      gcc_assert (df->postorder_inverted.length ());\n+      return df->postorder_inverted.address ();\n     }\n   gcc_assert (df->postorder);\n   return df->postorder;"}, {"sha": "07fd3345d9d002d6e9bf73c2157e980225625660", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -582,11 +582,9 @@ struct df_d\n   bitmap_head insns_to_notes_rescan;\n   int *postorder;                /* The current set of basic blocks\n                                     in reverse postorder.  */\n-  int *postorder_inverted;       /* The current set of basic blocks\n+  vec<int> postorder_inverted;       /* The current set of basic blocks\n                                     in reverse postorder of inverted CFG.  */\n   int n_blocks;                  /* The number of blocks in reverse postorder.  */\n-  int n_blocks_inverted;         /* The number of blocks\n-                                    in reverse postorder of inverted CFG.  */\n \n   /* An array [FIRST_PSEUDO_REGISTER], indexed by regno, of the number\n      of refs that qualify as being real hard regs uses.  Artificial"}, {"sha": "e86662742111907c2bc4e34bcc66979a1e4ff499", "filename": "gcc/lcm.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -270,9 +270,9 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n \n   /* Add all the blocks to the worklist.  This prevents an early exit from\n      the loop given our optimistic initialization of LATER above.  */\n-  int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n-  int postorder_num = inverted_post_order_compute (postorder);\n-  for (int i = 0; i < postorder_num; ++i)\n+  auto_vec<int, 20> postorder;\n+  inverted_post_order_compute (&postorder);\n+  for (unsigned int i = 0; i < postorder.length (); ++i)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, postorder[i]);\n       if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n@@ -281,7 +281,6 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n       *qin++ = bb;\n       bb->aux = bb;\n     }\n-  free (postorder);\n \n   /* Note that we do not use the last allocated element for our queue,\n      as EXIT_BLOCK is never inserted into it. */\n@@ -512,9 +511,9 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n   /* Put every block on the worklist; this is necessary because of the\n      optimistic initialization of AVOUT above.  Use inverted postorder\n      to make the dataflow problem require less iterations.  */\n-  int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n-  int postorder_num = inverted_post_order_compute (postorder);\n-  for (int i = 0; i < postorder_num; ++i)\n+  auto_vec<int, 20> postorder;\n+  inverted_post_order_compute (&postorder);\n+  for (unsigned int i = 0; i < postorder.length (); ++i)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, postorder[i]);\n       if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n@@ -523,7 +522,6 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n       *qin++ = bb;\n       bb->aux = bb;\n     }\n-  free (postorder);\n \n   qin = worklist;\n   qend = &worklist[n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS];"}, {"sha": "e728e348215fc9f58736ac34762a37428f200ebd", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -1287,11 +1287,11 @@ lra_create_live_ranges_1 (bool all_p, bool dead_insn_p)\n   point_freq_vec.truncate (0);\n   point_freq_vec.reserve_exact (new_length);\n   lra_point_freq = point_freq_vec.address ();\n-  int *post_order_rev_cfg = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  int n_blocks_inverted = inverted_post_order_compute (post_order_rev_cfg);\n-  lra_assert (n_blocks_inverted == n_basic_blocks_for_fn (cfun));\n+  auto_vec<int, 20> post_order_rev_cfg;\n+  inverted_post_order_compute (&post_order_rev_cfg);\n+  lra_assert (post_order_rev_cfg.length () == (unsigned) n_basic_blocks_for_fn (cfun));\n   bb_live_change_p = false;\n-  for (i = n_blocks_inverted - 1; i >= 0; --i)\n+  for (i = post_order_rev_cfg.length () - 1; i >= 0; --i)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, post_order_rev_cfg[i]);\n       if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || bb\n@@ -1338,7 +1338,6 @@ lra_create_live_ranges_1 (bool all_p, bool dead_insn_p)\n \t    }\n \t}\n     }\n-  free (post_order_rev_cfg);\n   lra_live_max_point = curr_point;\n   if (lra_dump_file != NULL)\n     print_live_ranges (lra_dump_file);"}, {"sha": "428dc814d933adc4f284568b7f6a505bb582a95f", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -1040,14 +1040,12 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n \t{\n \t  if (!bb_postorder)\n \t    {\n-\t      int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n-\t      int postorder_num\n-\t\t = inverted_post_order_compute (postorder,\n-\t\t\t\t\t\t&bb_contains_live_stmts);\n+\t      auto_vec<int, 20> postorder;\n+\t\t inverted_post_order_compute (&postorder,\n+\t\t\t\t\t      &bb_contains_live_stmts);\n \t      bb_postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-\t      for (int i = 0; i < postorder_num; ++i)\n+\t      for (unsigned int i = 0; i < postorder.length (); ++i)\n \t\t bb_postorder[postorder[i]] = i;\n-\t      free (postorder);\n \t    }\n           FOR_EACH_EDGE (e2, ei, bb->succs)\n \t    if (!e || e2->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)"}, {"sha": "f3e5eff9a76d03a3e4a5aa37e92e94a516074c84", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fa95e0961bc15efa5ff52fc7358aee78a16a33c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=6fa95e0961bc15efa5ff52fc7358aee78a16a33c", "patch": "@@ -2375,8 +2375,8 @@ compute_antic (void)\n   /* For ANTIC computation we need a postorder that also guarantees that\n      a block with a single successor is visited after its successor.\n      RPO on the inverted CFG has this property.  */\n-  int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n-  int postorder_num = inverted_post_order_compute (postorder);\n+  auto_vec<int, 20> postorder;\n+  inverted_post_order_compute (&postorder);\n \n   auto_sbitmap worklist (last_basic_block_for_fn (cfun) + 1);\n   bitmap_ones (worklist);\n@@ -2390,7 +2390,7 @@ compute_antic (void)\n \t for PA ANTIC computation.  */\n       num_iterations++;\n       changed = false;\n-      for (i = postorder_num - 1; i >= 0; i--)\n+      for (i = postorder.length () - 1; i >= 0; i--)\n \t{\n \t  if (bitmap_bit_p (worklist, postorder[i]))\n \t    {\n@@ -2417,7 +2417,7 @@ compute_antic (void)\n     {\n       /* For partial antic we ignore backedges and thus we do not need\n          to perform any iteration when we process blocks in postorder.  */\n-      postorder_num = pre_and_rev_post_order_compute (NULL, postorder, false);\n+      int postorder_num = pre_and_rev_post_order_compute (NULL, postorder.address (), false);\n       for (i = postorder_num - 1 ; i >= 0; i--)\n \t{\n \t  basic_block block = BASIC_BLOCK_FOR_FN (cfun, postorder[i]);\n@@ -2428,7 +2428,6 @@ compute_antic (void)\n     }\n \n   sbitmap_free (has_abnormal_preds);\n-  free (postorder);\n }\n \n "}]}