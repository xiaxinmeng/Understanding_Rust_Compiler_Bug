{"sha": "35e4f3b4af4c4e9a883b40603199eea09f9cd9f0", "node_id": "C_kwDOANBUbNoAKDM1ZTRmM2I0YWY0YzRlOWE4ODNiNDA2MDMxOTllZWEwOWY5Y2Q5ZjA", "commit": {"author": {"name": "Joel Phillips", "email": "simplytheother@gmail.com", "date": "2022-10-21T11:39:04Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:04Z"}, "message": "gccrs: Add Parser for Rust front-end pt.1\n\nThis is a Pratt-style parser for Rust that implements all of the AST. The\nrust-parser-impl.h is the implementation of the parser as a template,\nallowing it to be given ManagedTokenSource and avoid virtual calls. The\ndownside is it takes time to compile when used.\n\nsee: https://en.wikipedia.org/wiki/Operator-precedence_parser#Pratt_parsing\n\nThis patch contains the first half of the templated parser, so as to not\nlose patches in the mailing list archives.\n\n\tgcc/rust/\n\t* parse/rust-cfg-parser.cc: New.\n\t* parse/rust-cfg-parser.h: New.\n\t* parse/rust-parse-impl.h: New.\n\t* parse/rust-parse.cc: New.\n\t* parse/rust-parse.h: New.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n\nSigned-off-by: Joel Phillips <simplytheother@gmail.com>", "tree": {"sha": "b2de99d8f36f78cab0a30ba4fc12ae1b558ea2cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2de99d8f36f78cab0a30ba4fc12ae1b558ea2cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f6990f842d0bdcb2cf9541ca98d67b414d5802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18f6990f842d0bdcb2cf9541ca98d67b414d5802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18f6990f842d0bdcb2cf9541ca98d67b414d5802"}], "stats": {"total": 8143, "additions": 8143, "deletions": 0}, "files": [{"sha": "0a62dd11ede9412d4f91730c54b87dbfd811097e", "filename": "gcc/rust/parse/rust-cfg-parser.cc", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-cfg-parser.cc?ref=35e4f3b4af4c4e9a883b40603199eea09f9cd9f0", "patch": "@@ -0,0 +1,127 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n+#include \"rust-cfg-parser.h\"\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n+#include \"rust-session-manager.h\"\n+#include \"selftest.h\"\n+\n+namespace Rust {\n+bool\n+parse_cfg_option (std::string &input, std::string &key, std::string &value)\n+{\n+  key.clear ();\n+  value.clear ();\n+\n+  auto lexer = Lexer (input);\n+  auto parser = Parser<Lexer> (lexer);\n+\n+  auto token = parser.peek_current_token ();\n+  if (token->get_id () != IDENTIFIER)\n+    {\n+      return false;\n+    }\n+\n+  key = token->get_str ();\n+\n+  rust_assert (parser.skip_token (IDENTIFIER));\n+  token = parser.peek_current_token ();\n+\n+  switch (token->get_id ())\n+    {\n+    case END_OF_FILE:\n+      // we're done parsing, we had a valid key, return happily\n+      return true;\n+    case EQUAL:\n+      // We have an equal sign: Skip the token and parse an identifier\n+      {\n+\trust_assert (parser.skip_token (EQUAL));\n+\n+\tauto value_expr = parser.parse_literal_expr ();\n+\t// We had an equal sign but no value, error out\n+\tif (!value_expr)\n+\t  return false;\n+\n+\tif (value_expr->get_lit_type () != AST::Literal::LitType::STRING)\n+\t  return false;\n+\n+\tvalue = value_expr->get_literal ().as_string ();\n+\treturn true;\n+      }\n+    default:\n+      return false;\n+    }\n+}\n+} // namespace Rust\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+void\n+rust_cfg_parser_test (void)\n+{\n+  std::string key;\n+  std::string value;\n+\n+  auto input = std::string (\"key_no_value\");\n+\n+  ASSERT_TRUE (Rust::parse_cfg_option (input, key, value));\n+  ASSERT_EQ (key, \"key_no_value\");\n+  ASSERT_TRUE (value.empty ());\n+\n+  input = std::string (\"k=\\\"v\\\"\");\n+\n+  ASSERT_TRUE (Rust::parse_cfg_option (input, key, value));\n+  ASSERT_EQ (key, \"k\");\n+  ASSERT_EQ (value, \"v\");\n+\n+  // values should be between double quotes\n+  input = std::string (\"k=v\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  // No value is an error if there is an equal sign\n+  input = std::string (\"k=\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  // No key is an error\n+  input = std::string (\"=\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  input = std::string (\"=value\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  // values that are not string literals are an error\n+  input = std::string (\"key=b\\\"a\\\"\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  input = std::string (\"key='v'\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  input = std::string (\"key=155\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  input = std::string (\"key=3.14\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+\n+  // kebab case is not valid for an identifier\n+  input = std::string (\"key-no-value\");\n+  ASSERT_FALSE (Rust::parse_cfg_option (input, key, value));\n+}\n+} // namespace selftest\n+\n+#endif // CHECKING_P"}, {"sha": "0d64016f86dca820ed3145cf35a8637b0a2a8446", "filename": "gcc/rust/parse/rust-cfg-parser.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-cfg-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-cfg-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-cfg-parser.h?ref=35e4f3b4af4c4e9a883b40603199eea09f9cd9f0", "patch": "@@ -0,0 +1,52 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n+#ifndef RUST_CFG_PARSER_H\n+#define RUST_CFG_PARSER_H\n+\n+#include \"rust-system.h\"\n+\n+namespace Rust {\n+/**\n+ * Parse a `key` or `key=\"value\"` pair given to the `-frust-cfg` compiler\n+ * option.\n+ *\n+ * The format is as follows:\n+ *\n+ * -frust-cfg=<input>\n+ *\n+ * cfg_input: identifier | identifier '=' '\"' identifier '\"'\n+ *\n+ * @param input User input given to the -frust-cfg option\n+ * @param key String in which to store the parsed `key`.\n+ * @param value String in which to store the parsed `value` if it exists\n+ *\n+ * @return false if the given input was invalid, true otherwise\n+ */\n+bool\n+parse_cfg_option (std::string &input, std::string &key, std::string &value);\n+} // namespace Rust\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+extern void\n+rust_cfg_parser_test (void);\n+} // namespace selftest\n+\n+#endif // CHECKING_P\n+\n+#endif // RUST_CFG_PARSER_H"}, {"sha": "45e0f6972c6a1228689f6277b396173e4d9707c1", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "added", "additions": 6904, "deletions": 0, "changes": 6904, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=35e4f3b4af4c4e9a883b40603199eea09f9cd9f0"}, {"sha": "f1e2caa258b0ca6869255aecc385a9e905dd6663", "filename": "gcc/rust/parse/rust-parse.cc", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=35e4f3b4af4c4e9a883b40603199eea09f9cd9f0", "patch": "@@ -0,0 +1,328 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n+#include \"rust-parse.h\"\n+#include \"rust-linemap.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+\n+std::string\n+extract_module_path (const AST::AttrVec &inner_attrs,\n+\t\t     const AST::AttrVec &outer_attrs, const std::string &name)\n+{\n+  AST::Attribute path_attr = AST::Attribute::create_empty ();\n+  for (const auto &attr : inner_attrs)\n+    {\n+      if (attr.get_path ().as_string () == \"path\")\n+\t{\n+\t  path_attr = attr;\n+\t  break;\n+\t}\n+    }\n+\n+  // Here, we found a path attribute, but it has no associated string. This is\n+  // invalid\n+  if (!path_attr.is_empty () && !path_attr.has_attr_input ())\n+    {\n+      rust_error_at (\n+\tpath_attr.get_locus (),\n+\t// Split the format string so that -Wformat-diag does not complain...\n+\t\"path attributes must contain a filename: '%s'\", \"#![path = \\\"file\\\"]\");\n+      return name;\n+    }\n+\n+  for (const auto &attr : outer_attrs)\n+    {\n+      if (attr.get_path ().as_string () == \"path\")\n+\t{\n+\t  path_attr = attr;\n+\t  break;\n+\t}\n+    }\n+\n+  // We didn't find a path attribute. This is not an error, there simply isn't\n+  // one present\n+  if (path_attr.is_empty ())\n+    return name;\n+\n+  // Here, we found a path attribute, but it has no associated string. This is\n+  // invalid\n+  if (!path_attr.has_attr_input ())\n+    {\n+      rust_error_at (\n+\tpath_attr.get_locus (),\n+\t// Split the format string so that -Wformat-diag does not complain...\n+\t\"path attributes must contain a filename: '%s'\", \"#[path = \\\"file\\\"]\");\n+      return name;\n+    }\n+\n+  auto path_value = path_attr.get_attr_input ().as_string ();\n+\n+  // At this point, the 'path' is of the following format: '= \"<file.rs>\"'\n+  // We need to remove the equal sign and only keep the actual filename.\n+  // In order to do this, we can simply go through the string until we find\n+  // a character that is not an equal sign or whitespace\n+  auto filename_begin = path_value.find_first_not_of (\"=\\t \");\n+\n+  auto path = path_value.substr (filename_begin);\n+\n+  // On windows, the path might mix '/' and '\\' separators. Replace the\n+  // UNIX-like separators by MSDOS separators to make sure the path will resolve\n+  // properly.\n+  //\n+  // Source: rustc compiler\n+  // (https://github.com/rust-lang/rust/blob/9863bf51a52b8e61bcad312f81b5193d53099f9f/compiler/rustc_expand/src/module.rs#L174)\n+#if defined(HAVE_DOS_BASED_FILE_SYSTEM)\n+  path.replace ('/', '\\\\');\n+#endif /* HAVE_DOS_BASED_FILE_SYSTEM */\n+\n+  return path;\n+}\n+\n+template <typename T>\n+static bool\n+contains (std::vector<T> &vec, T elm)\n+{\n+  return std::find (vec.begin (), vec.end (), elm) != vec.end ();\n+}\n+\n+/**\n+ * Avoid UB by calling .front() and .back() on empty containers...\n+ */\n+\n+template <typename T>\n+static const T *\n+get_back_ptr (const std::vector<std::unique_ptr<T>> &values)\n+{\n+  if (values.empty ())\n+    return nullptr;\n+\n+  return values.back ().get ();\n+}\n+\n+template <typename T>\n+static const T *\n+get_front_ptr (const std::vector<std::unique_ptr<T>> &values)\n+{\n+  if (values.empty ())\n+    return nullptr;\n+\n+  return values.front ().get ();\n+}\n+\n+static bool\n+peculiar_fragment_match_compatible_fragment (\n+  const AST::MacroFragSpec &last_spec, const AST::MacroFragSpec &spec,\n+  Location match_locus)\n+{\n+  static std::unordered_map<AST::MacroFragSpec::Kind,\n+\t\t\t    std::vector<AST::MacroFragSpec::Kind>>\n+    fragment_follow_set\n+    = {{AST::MacroFragSpec::PATH, {AST::MacroFragSpec::BLOCK}},\n+       {AST::MacroFragSpec::TY, {AST::MacroFragSpec::BLOCK}},\n+       {AST::MacroFragSpec::VIS,\n+\t{AST::MacroFragSpec::IDENT, AST::MacroFragSpec::TY,\n+\t AST::MacroFragSpec::PATH}}};\n+\n+  auto is_valid\n+    = contains (fragment_follow_set[last_spec.get_kind ()], spec.get_kind ());\n+\n+  if (!is_valid)\n+    rust_error_at (\n+      match_locus,\n+      \"fragment specifier %<%s%> is not allowed after %<%s%> fragments\",\n+      spec.as_string ().c_str (), last_spec.as_string ().c_str ());\n+\n+  return is_valid;\n+}\n+\n+static bool\n+peculiar_fragment_match_compatible (const AST::MacroMatchFragment &last_match,\n+\t\t\t\t    const AST::MacroMatch &match)\n+{\n+  static std::unordered_map<AST::MacroFragSpec::Kind, std::vector<TokenId>>\n+    follow_set\n+    = {{AST::MacroFragSpec::EXPR, {MATCH_ARROW, COMMA, SEMICOLON}},\n+       {AST::MacroFragSpec::STMT, {MATCH_ARROW, COMMA, SEMICOLON}},\n+       {AST::MacroFragSpec::PAT, {MATCH_ARROW, COMMA, EQUAL, PIPE, IF, IN}},\n+       {AST::MacroFragSpec::PATH,\n+\t{MATCH_ARROW, COMMA, EQUAL, PIPE, SEMICOLON, COLON, RIGHT_ANGLE,\n+\t RIGHT_SHIFT, LEFT_SQUARE, LEFT_CURLY, AS, WHERE}},\n+       {AST::MacroFragSpec::TY,\n+\t{MATCH_ARROW, COMMA, EQUAL, PIPE, SEMICOLON, COLON, RIGHT_ANGLE,\n+\t RIGHT_SHIFT, LEFT_SQUARE, LEFT_CURLY, AS, WHERE}},\n+       {AST::MacroFragSpec::VIS,\n+\t{\n+\t  COMMA,\n+\t  IDENTIFIER /* FIXME: Other than `priv` */,\n+\t  LEFT_PAREN,\n+\t  LEFT_SQUARE,\n+\t  EXCLAM,\n+\t  ASTERISK,\n+\t  AMP,\n+\t  LOGICAL_AND,\n+\t  QUESTION_MARK,\n+\t  LIFETIME,\n+\t  LEFT_ANGLE,\n+\t  LEFT_SHIFT,\n+\t  SUPER,\n+\t  SELF,\n+\t  SELF_ALIAS,\n+\t  EXTERN_TOK,\n+\t  CRATE,\n+\t  UNDERSCORE,\n+\t  FOR,\n+\t  IMPL,\n+\t  FN_TOK,\n+\t  UNSAFE,\n+\t  TYPEOF,\n+\t  DYN\n+\t  // FIXME: Add Non kw identifiers\n+\t  // FIXME: Add $crate as valid\n+\t}}};\n+\n+  Location error_locus = match.get_match_locus ();\n+  std::string kind_str = \"fragment\";\n+  auto &allowed_toks = follow_set[last_match.get_frag_spec ().get_kind ()];\n+\n+  // There are two behaviors to handle here: If the follow-up match is a token,\n+  // we want to check if it is allowed.\n+  // If it is a fragment, repetition or matcher then we know that it will be\n+  // an error.\n+  // For repetitions and matchers we want to extract a proper location to report\n+  // the error.\n+  switch (match.get_macro_match_type ())\n+    {\n+      case AST::MacroMatch::Tok: {\n+\tauto tok = static_cast<const AST::Token *> (&match);\n+\tif (contains (allowed_toks, tok->get_id ()))\n+\t  return true;\n+\tkind_str = \"token `\"\n+\t\t   + std::string (get_token_description (tok->get_id ())) + \"`\";\n+\terror_locus = tok->get_match_locus ();\n+\tbreak;\n+      }\n+      break;\n+      case AST::MacroMatch::Repetition: {\n+\tauto repetition\n+\t  = static_cast<const AST::MacroMatchRepetition *> (&match);\n+\tauto &matches = repetition->get_matches ();\n+\tauto first_frag = get_front_ptr (matches);\n+\tif (first_frag)\n+\t  return peculiar_fragment_match_compatible (last_match, *first_frag);\n+\tbreak;\n+      }\n+      case AST::MacroMatch::Matcher: {\n+\tauto matcher = static_cast<const AST::MacroMatcher *> (&match);\n+\tauto first_token = matcher->get_delim_type ();\n+\tTokenId delim_id;\n+\tswitch (first_token)\n+\t  {\n+\t  case AST::PARENS:\n+\t    delim_id = LEFT_PAREN;\n+\t    break;\n+\t  case AST::SQUARE:\n+\t    delim_id = LEFT_SQUARE;\n+\t    break;\n+\t  case AST::CURLY:\n+\t    delim_id = LEFT_CURLY;\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t    break;\n+\t  }\n+\tif (contains (allowed_toks, delim_id))\n+\t  return true;\n+\tkind_str = \"token `\" + std::string (get_token_description (delim_id))\n+\t\t   + \"` at start of matcher\";\n+\terror_locus = matcher->get_match_locus ();\n+\tbreak;\n+      }\n+      case AST::MacroMatch::Fragment: {\n+\tauto last_spec = last_match.get_frag_spec ();\n+\tauto fragment = static_cast<const AST::MacroMatchFragment *> (&match);\n+\tif (last_spec.has_follow_set_fragment_restrictions ())\n+\t  return peculiar_fragment_match_compatible_fragment (\n+\t    last_spec, fragment->get_frag_spec (), match.get_match_locus ());\n+      }\n+      break;\n+    }\n+\n+  rust_error_at (error_locus, \"%s is not allowed after %<%s%> fragment\",\n+\t\t kind_str.c_str (),\n+\t\t last_match.get_frag_spec ().as_string ().c_str ());\n+  auto allowed_toks_str\n+    = \"`\" + std::string (get_token_description (allowed_toks[0])) + \"`\";\n+  for (size_t i = 1; i < allowed_toks.size (); i++)\n+    allowed_toks_str\n+      += \", `\" + std::string (get_token_description (allowed_toks[i])) + \"`\";\n+\n+  rust_inform (error_locus, \"allowed tokens are %s\", allowed_toks_str.c_str ());\n+\n+  return false;\n+}\n+\n+bool\n+is_match_compatible (const AST::MacroMatch &last_match,\n+\t\t     const AST::MacroMatch &match)\n+{\n+  const AST::MacroMatch *new_last = nullptr;\n+\n+  // We want to \"extract\" the concerning matches. In cases such as matchers and\n+  // repetitions, we actually store multiple matchers, but are only concerned\n+  // about the follow-set ambiguities of certain elements.\n+  // There are some cases where we can short-circuit the algorithm: There will\n+  // never be restrictions on token literals, or on certain fragments which do\n+  // not have a set of follow-restrictions.\n+\n+  switch (last_match.get_macro_match_type ())\n+    {\n+      // This is our main stop condition: When we are finally looking at the\n+      // last match (or its actual last component), and it is a fragment, it\n+      // may contain some follow up restrictions.\n+      case AST::MacroMatch::Fragment: {\n+\tauto fragment\n+\t  = static_cast<const AST::MacroMatchFragment *> (&last_match);\n+\tif (fragment->get_frag_spec ().has_follow_set_restrictions ())\n+\t  return peculiar_fragment_match_compatible (*fragment, match);\n+\telse\n+\t  return true;\n+      }\n+      case AST::MacroMatch::Repetition: {\n+\t// A repetition on the left hand side means we want to make sure the\n+\t// last match of the repetition is compatible with the new match\n+\tauto repetition\n+\t  = static_cast<const AST::MacroMatchRepetition *> (&last_match);\n+\tnew_last = get_back_ptr (repetition->get_matches ());\n+\t// If there are no matches in the matcher, then it can be followed by\n+\t// anything\n+\tif (!new_last)\n+\t  return true;\n+\tbreak;\n+      }\n+    case AST::MacroMatch::Matcher:\n+    case AST::MacroMatch::Tok:\n+      return true;\n+    }\n+\n+  rust_assert (new_last);\n+\n+  // We check recursively until we find a terminating condition\n+  // FIXME: Does expansion depth/limit matter here?\n+  return is_match_compatible (*new_last, match);\n+}\n+} // namespace Rust"}, {"sha": "e4c5a2c5c9f6b1d44f11953a9f5c97d4a479bce0", "filename": "gcc/rust/parse/rust-parse.h", "status": "added", "additions": 732, "deletions": 0, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e4f3b4af4c4e9a883b40603199eea09f9cd9f0/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=35e4f3b4af4c4e9a883b40603199eea09f9cd9f0", "patch": "@@ -0,0 +1,732 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n+#ifndef RUST_PARSE_H\n+#define RUST_PARSE_H\n+\n+#include \"rust-lex.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+/* HACK: used to resolve the expression-or-statement problem at the end of a\n+ * block by allowing either to be returned (technically). Tagged union would\n+ * probably take up the same amount of space. */\n+struct ExprOrStmt\n+{\n+  std::unique_ptr<AST::Expr> expr;\n+  std::unique_ptr<AST::Stmt> stmt;\n+\n+  /* I was going to resist the urge to make this a real class and make it POD,\n+   * but construction in steps is too difficult. So it'll just also have a\n+   * constructor. */\n+\n+  // expression constructor\n+  ExprOrStmt (std::unique_ptr<AST::Expr> expr) : expr (std::move (expr)) {}\n+\n+  // statement constructor\n+  ExprOrStmt (std::unique_ptr<AST::Stmt> stmt) : stmt (std::move (stmt)) {}\n+\n+  // macro constructor\n+  ExprOrStmt (std::unique_ptr<AST::MacroInvocation> macro)\n+    : expr (std::move (macro))\n+  {}\n+\n+  // Returns whether this object is in an error state.\n+  bool is_error () const\n+  {\n+    return (expr == nullptr && stmt == nullptr)\n+\t   || (expr != nullptr && stmt != nullptr);\n+  }\n+\n+  // Returns an error state object.\n+  static ExprOrStmt create_error () { return ExprOrStmt (nullptr, nullptr); }\n+\n+  ~ExprOrStmt () = default;\n+\n+  /* no copy constructors/assignment as simple object like this shouldn't\n+   * require it */\n+\n+  // move constructors\n+  ExprOrStmt (ExprOrStmt &&other) = default;\n+  ExprOrStmt &operator= (ExprOrStmt &&other) = default;\n+\n+private:\n+  // private constructor only used for creating error state expr or stmt objects\n+  ExprOrStmt (AST::Expr *expr, AST::Stmt *stmt) : expr (expr), stmt (stmt) {}\n+\n+  // make this work: have a disambiguation specifically for known statements\n+  // (i.e. ';' and 'let'). then, have a special \"parse expr or stmt\" function\n+  // that returns this type. inside it, it parses an expression, and then\n+  // determines whether to return expr or stmt via whether the next token is a\n+  // semicolon. should be able to disambiguate inside that function between\n+  // stmts with blocks and without blocks.\n+};\n+\n+/* Restrictions on parsing used to signal that certain ambiguous grammar\n+ * features should be parsed in a certain way. */\n+struct ParseRestrictions\n+{\n+  bool can_be_struct_expr = true;\n+  /* Whether the expression was entered from a unary expression - prevents stuff\n+   * like struct exprs being parsed from a dereference. */\n+  bool entered_from_unary = false;\n+  bool expr_can_be_null = false;\n+  bool expr_can_be_stmt = false;\n+  bool consume_semi = true;\n+};\n+\n+// Parser implementation for gccrs.\n+// TODO: if updated to C++20, ManagedTokenSource would be useful as a concept\n+template <typename ManagedTokenSource> class Parser\n+{\n+public:\n+  /**\n+   * Consume a token, reporting an error if it isn't the next token\n+   *\n+   * @param t ID of the token to consume\n+   *\n+   * @return true if the token was next, false if it wasn't found\n+   */\n+  bool skip_token (TokenId t);\n+\n+  /**\n+   * Same as `skip_token` but allows for failure without necessarily reporting\n+   * an error\n+   *\n+   * @param t ID of the token to consume\n+   *\n+   * @return true if the token was next, false if it wasn't found\n+   */\n+  bool maybe_skip_token (TokenId t);\n+\n+  std::unique_ptr<AST::Expr>\n+  parse_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t      ParseRestrictions restrictions = ParseRestrictions ());\n+\n+  std::unique_ptr<AST::LiteralExpr> parse_literal_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t\t= AST::AttrVec ());\n+\n+  std::unique_ptr<AST::BlockExpr>\n+  parse_block_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n+\n+  std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n+  std::unique_ptr<AST::Pattern> parse_pattern ();\n+\n+  /**\n+   * Parse a statement\n+   *\n+   * Statement : ';'\n+   *    | Item\n+   *    | LetStatement\n+   *    | ExpressionStatement\n+   *    | MacroInvocationSemi\n+   */\n+  std::unique_ptr<AST::Stmt> parse_stmt (ParseRestrictions restrictions\n+\t\t\t\t\t = ParseRestrictions ());\n+  std::unique_ptr<AST::Type> parse_type (bool save_errors = true);\n+  std::unique_ptr<AST::ExternalItem> parse_external_item ();\n+  std::unique_ptr<AST::TraitItem> parse_trait_item ();\n+  std::unique_ptr<AST::InherentImplItem> parse_inherent_impl_item ();\n+  std::unique_ptr<AST::TraitImplItem> parse_trait_impl_item ();\n+  AST::PathInExpression parse_path_in_expression ();\n+  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n+  AST::Visibility parse_visibility ();\n+  std::unique_ptr<AST::IdentifierPattern> parse_identifier_pattern ();\n+  std::unique_ptr<AST::TokenTree> parse_token_tree ();\n+  AST::Attribute parse_attribute_body ();\n+  AST::AttrVec parse_inner_attributes ();\n+\n+private:\n+  void skip_after_semicolon ();\n+  void skip_after_end ();\n+  void skip_after_end_block ();\n+  void skip_after_next_block ();\n+  void skip_after_end_attribute ();\n+\n+  const_TokenPtr expect_token (TokenId t);\n+  void unexpected_token (const_TokenPtr t);\n+  bool skip_generics_right_angle ();\n+\n+  void parse_statement_seq (bool (Parser::*done) ());\n+\n+  // AST-related stuff - maybe move or something?\n+  AST::Attribute parse_inner_attribute ();\n+  AST::AttrVec parse_outer_attributes ();\n+  AST::Attribute parse_outer_attribute ();\n+  std::unique_ptr<AST::AttrInput> parse_attr_input ();\n+  AST::Attribute parse_doc_comment ();\n+\n+  // Path-related\n+  AST::SimplePath parse_simple_path ();\n+  AST::SimplePathSegment parse_simple_path_segment ();\n+  AST::TypePath parse_type_path ();\n+  std::unique_ptr<AST::TypePathSegment> parse_type_path_segment ();\n+  AST::PathIdentSegment parse_path_ident_segment ();\n+  AST::GenericArg parse_generic_arg ();\n+  AST::GenericArgs parse_path_generic_args ();\n+  AST::GenericArgsBinding parse_generic_args_binding ();\n+  AST::TypePathFunction parse_type_path_function (Location locus);\n+  AST::PathExprSegment parse_path_expr_segment ();\n+  AST::QualifiedPathInExpression\n+  // When given a pratt_parsed_loc, use it as the location of the\n+  // first token parsed in the expression (the parsing of that first\n+  // token should be skipped).\n+  parse_qualified_path_in_expression (Location pratt_parsed_loc\n+\t\t\t\t      = Linemap::unknown_location ());\n+  AST::QualifiedPathType\n+  parse_qualified_path_type (Location pratt_parsed_loc\n+\t\t\t     = Linemap::unknown_location ());\n+  AST::QualifiedPathInType parse_qualified_path_in_type ();\n+\n+  // Token tree or macro related\n+  AST::DelimTokenTree parse_delim_token_tree ();\n+  std::unique_ptr<AST::MacroRulesDefinition>\n+  parse_macro_rules_def (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::MacroInvocation>\n+  parse_macro_invocation_semi (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::MacroInvocation>\n+  parse_macro_invocation (AST::AttrVec outer_attrs);\n+  AST::MacroRule parse_macro_rule ();\n+  AST::MacroMatcher parse_macro_matcher ();\n+  std::unique_ptr<AST::MacroMatch> parse_macro_match ();\n+  std::unique_ptr<AST::MacroMatchFragment> parse_macro_match_fragment ();\n+  std::unique_ptr<AST::MacroMatchRepetition> parse_macro_match_repetition ();\n+\n+  // Top-level item-related\n+  std::unique_ptr<AST::VisItem> parse_vis_item (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::MacroItem> parse_macro_item (AST::AttrVec outer_attrs);\n+\n+  // VisItem subclass-related\n+  std::unique_ptr<AST::Module> parse_module (AST::Visibility vis,\n+\t\t\t\t\t     AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::ExternCrate>\n+  parse_extern_crate (AST::Visibility vis, AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::UseDeclaration>\n+  parse_use_decl (AST::Visibility vis, AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::UseTree> parse_use_tree ();\n+  std::unique_ptr<AST::Function> parse_function (AST::Visibility vis,\n+\t\t\t\t\t\t AST::AttrVec outer_attrs);\n+  AST::FunctionQualifiers parse_function_qualifiers ();\n+  std::vector<std::unique_ptr<AST::GenericParam> >\n+  parse_generic_params_in_angles ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::GenericParam> >\n+  parse_generic_params (EndTokenPred is_end_token);\n+  template <typename EndTokenPred>\n+  std::unique_ptr<AST::GenericParam>\n+  parse_generic_param (EndTokenPred is_end_token);\n+\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::LifetimeParam> >\n+  parse_lifetime_params (EndTokenPred is_end_token);\n+  std::vector<AST::LifetimeParam> parse_lifetime_params_objs ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::LifetimeParam>\n+  parse_lifetime_params_objs (EndTokenPred is_end_token);\n+  template <typename ParseFunction, typename EndTokenPred>\n+  auto parse_non_ptr_sequence (\n+    ParseFunction parsing_function, EndTokenPred is_end_token,\n+    std::string error_msg = \"failed to parse generic param in generic params\")\n+    -> std::vector<decltype (parsing_function ())>;\n+  AST::LifetimeParam parse_lifetime_param ();\n+  std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::TypeParam> >\n+  parse_type_params (EndTokenPred is_end_token);\n+  std::unique_ptr<AST::TypeParam> parse_type_param ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::FunctionParam>\n+  parse_function_params (EndTokenPred is_end_token);\n+  AST::FunctionParam parse_function_param ();\n+  std::unique_ptr<AST::Type> parse_function_return_type ();\n+  AST::WhereClause parse_where_clause ();\n+  std::unique_ptr<AST::WhereClauseItem> parse_where_clause_item ();\n+  std::unique_ptr<AST::LifetimeWhereClauseItem>\n+  parse_lifetime_where_clause_item ();\n+  std::unique_ptr<AST::TypeBoundWhereClauseItem>\n+  parse_type_bound_where_clause_item ();\n+  std::vector<AST::LifetimeParam> parse_for_lifetimes ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::TypeParamBound> >\n+  parse_type_param_bounds (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds ();\n+  std::unique_ptr<AST::TypeParamBound> parse_type_param_bound ();\n+  std::unique_ptr<AST::TraitBound> parse_trait_bound ();\n+  std::vector<AST::Lifetime> parse_lifetime_bounds ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::Lifetime> parse_lifetime_bounds (EndTokenPred is_end_token);\n+  AST::Lifetime parse_lifetime ();\n+  std::unique_ptr<AST::TypeAlias> parse_type_alias (AST::Visibility vis,\n+\t\t\t\t\t\t    AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::Struct> parse_struct (AST::Visibility vis,\n+\t\t\t\t\t     AST::AttrVec outer_attrs);\n+  std::vector<AST::StructField> parse_struct_fields ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::StructField> parse_struct_fields (EndTokenPred is_end_token);\n+  AST::StructField parse_struct_field ();\n+  std::vector<AST::TupleField> parse_tuple_fields ();\n+  AST::TupleField parse_tuple_field ();\n+  std::unique_ptr<AST::Enum> parse_enum (AST::Visibility vis,\n+\t\t\t\t\t AST::AttrVec outer_attrs);\n+  std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::EnumItem> >\n+  parse_enum_items (EndTokenPred is_end_token);\n+  std::unique_ptr<AST::EnumItem> parse_enum_item ();\n+  std::unique_ptr<AST::Union> parse_union (AST::Visibility vis,\n+\t\t\t\t\t   AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::ConstantItem>\n+  parse_const_item (AST::Visibility vis, AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::StaticItem> parse_static_item (AST::Visibility vis,\n+\t\t\t\t\t\t      AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::Trait> parse_trait (AST::Visibility vis,\n+\t\t\t\t\t   AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::TraitItemType>\n+  parse_trait_type (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::TraitItemConst>\n+  parse_trait_const (AST::AttrVec outer_attrs);\n+  AST::SelfParam parse_self_param ();\n+  std::unique_ptr<AST::Impl> parse_impl (AST::Visibility vis,\n+\t\t\t\t\t AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::InherentImplItem>\n+  parse_inherent_impl_function_or_method (AST::Visibility vis,\n+\t\t\t\t\t  AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::TraitImplItem>\n+  parse_trait_impl_function_or_method (AST::Visibility vis,\n+\t\t\t\t       AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::ExternBlock>\n+  parse_extern_block (AST::Visibility vis, AST::AttrVec outer_attrs);\n+  AST::NamedFunctionParam parse_named_function_param (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t      = AST::AttrVec ());\n+  AST::Method parse_method ();\n+\n+  // Expression-related (Pratt parsed)\n+  std::unique_ptr<AST::Expr>\n+  parse_expr (int right_binding_power,\n+\t      AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t      ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::Expr>\n+  null_denotation (const_TokenPtr t, AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t   ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::Expr>\n+  left_denotation (const_TokenPtr t, std::unique_ptr<AST::Expr> left,\n+\t\t   AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t   ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_arithmetic_or_logical_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs, AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_plus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  AST::AttrVec outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_minus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t   AST::AttrVec outer_attrs,\n+\t\t\t   ParseRestrictions restrictions\n+\t\t\t   = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_mult_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  AST::AttrVec outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_div_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t AST::AttrVec outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_binary_mod_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t AST::AttrVec outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_and_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  AST::AttrVec outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_or_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t AST::AttrVec outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_bitwise_xor_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  AST::AttrVec outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_left_shift_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t AST::AttrVec outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n+  parse_right_shift_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  AST::AttrVec outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr>\n+  parse_comparison_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t AST::AttrVec outer_attrs,\n+\t\t\t AST::ComparisonExpr::ExprType expr_type,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr>\n+  parse_binary_equal_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t   AST::AttrVec outer_attrs,\n+\t\t\t   ParseRestrictions restrictions\n+\t\t\t   = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_not_equal_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_than_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_less_than_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_greater_equal_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ComparisonExpr> parse_binary_less_equal_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::LazyBooleanExpr>\n+  parse_lazy_or_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t      AST::AttrVec outer_attrs,\n+\t\t      ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::LazyBooleanExpr>\n+  parse_lazy_and_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t       AST::AttrVec outer_attrs,\n+\t\t       ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::TypeCastExpr>\n+  parse_type_cast_expr (const_TokenPtr tok,\n+\t\t\tstd::unique_ptr<AST::Expr> expr_to_cast,\n+\t\t\tAST::AttrVec outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::AssignmentExpr>\n+  parse_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t    AST::AttrVec outer_attrs,\n+\t\t    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr> parse_compound_assignment_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs, AST::CompoundAssignmentExpr::ExprType expr_type,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_plus_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t AST::AttrVec outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_minus_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t  AST::AttrVec outer_attrs,\n+\t\t\t  ParseRestrictions restrictions\n+\t\t\t  = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_mult_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\t AST::AttrVec outer_attrs,\n+\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_div_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\tAST::AttrVec outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_mod_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\tAST::AttrVec outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_and_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\tAST::AttrVec outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_or_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t       AST::AttrVec outer_attrs,\n+\t\t       ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr>\n+  parse_xor_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+\t\t\tAST::AttrVec outer_attrs,\n+\t\t\tParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr> parse_left_shift_assig_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr> parse_right_shift_assig_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::AwaitExpr>\n+  parse_await_expr (const_TokenPtr tok,\n+\t\t    std::unique_ptr<AST::Expr> expr_to_await,\n+\t\t    AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::MethodCallExpr> parse_method_call_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> receiver_expr,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CallExpr> parse_function_call_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> function_expr,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::RangeExpr> parse_led_range_exclusive_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::RangeExpr>\n+  parse_nud_range_exclusive_expr (const_TokenPtr tok, AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::RangeFromToInclExpr> parse_range_inclusive_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::RangeToInclExpr>\n+  parse_range_to_inclusive_expr (const_TokenPtr tok, AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> tuple_expr,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::FieldAccessExpr> parse_field_access_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> struct_expr,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::ArrayIndexExpr>\n+  parse_index_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> array_expr,\n+\t\t    AST::AttrVec outer_attrs,\n+\t\t    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::MacroInvocation> parse_macro_invocation_partial (\n+    AST::PathInExpression path, AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::StructExprStruct>\n+  parse_struct_expr_struct_partial (AST::PathInExpression path,\n+\t\t\t\t    AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::CallExpr>\n+  parse_struct_expr_tuple_partial (AST::PathInExpression path,\n+\t\t\t\t   AST::AttrVec outer_attrs);\n+  AST::PathInExpression parse_path_in_expression_pratt (const_TokenPtr tok);\n+  std::unique_ptr<AST::ClosureExpr>\n+  parse_closure_expr_pratt (const_TokenPtr tok,\n+\t\t\t    AST::AttrVec outer_attrs = AST::AttrVec ());\n+  std::unique_ptr<AST::TupleIndexExpr> parse_tuple_index_expr_float (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> tuple_expr,\n+    AST::AttrVec outer_attrs,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n+\n+  // Expression-related (non-Pratt parsed)\n+  std::unique_ptr<AST::ExprWithBlock>\n+  parse_expr_with_block (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::ExprWithoutBlock>\n+  parse_expr_without_block (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t\t    ParseRestrictions restrictions\n+\t\t\t    = ParseRestrictions ());\n+  // When given a pratt_parsed_loc, use it as the location of the\n+  // first token parsed in the expression (the parsing of that first\n+  // token should be skipped).\n+  std::unique_ptr<AST::IfExpr>\n+  parse_if_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::IfLetExpr>\n+  parse_if_let_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t     Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::LoopExpr>\n+  parse_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t   AST::LoopLabel label = AST::LoopLabel::error (),\n+\t\t   Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::WhileLoopExpr>\n+  parse_while_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t\t AST::LoopLabel label = AST::LoopLabel::error (),\n+\t\t\t Location pratt_parsed_loc\n+\t\t\t = Linemap::unknown_location ());\n+  std::unique_ptr<AST::WhileLetLoopExpr>\n+  parse_while_let_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t\t     AST::LoopLabel label = AST::LoopLabel::error ());\n+  std::unique_ptr<AST::ForLoopExpr>\n+  parse_for_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t       AST::LoopLabel label = AST::LoopLabel::error ());\n+  std::unique_ptr<AST::MatchExpr>\n+  parse_match_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n+  AST::MatchArm parse_match_arm ();\n+  std::vector<std::unique_ptr<AST::Pattern> >\n+  parse_match_arm_patterns (TokenId end_token_id);\n+  std::unique_ptr<AST::BaseLoopExpr>\n+  parse_labelled_loop_expr (AST::AttrVec outer_attrs = AST::AttrVec ());\n+  AST::LoopLabel parse_loop_label ();\n+  std::unique_ptr<AST::AsyncBlockExpr>\n+  parse_async_block_expr (AST::AttrVec outer_attrs = AST::AttrVec ());\n+  std::unique_ptr<AST::GroupedExpr> parse_grouped_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t\t= AST::AttrVec ());\n+  std::unique_ptr<AST::ClosureExpr> parse_closure_expr (AST::AttrVec outer_attrs\n+\t\t\t\t\t\t\t= AST::AttrVec ());\n+  AST::ClosureParam parse_closure_param ();\n+\n+  // When given a pratt_parsed_loc, use it as the location of the\n+  // first token parsed in the expression (the parsing of that first\n+  // token should be skipped).\n+  std::unique_ptr<AST::ReturnExpr>\n+  parse_return_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t     Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::BreakExpr>\n+  parse_break_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::ContinueExpr>\n+  parse_continue_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t       Location pratt_parsed_loc\n+\t\t       = Linemap::unknown_location ());\n+  std::unique_ptr<AST::UnsafeBlockExpr>\n+  parse_unsafe_block_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t\t   Location pratt_parsed_loc\n+\t\t\t   = Linemap::unknown_location ());\n+  std::unique_ptr<AST::ArrayExpr>\n+  parse_array_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t    Location pratt_parsed_loc = Linemap::unknown_location ());\n+  std::unique_ptr<AST::ExprWithoutBlock>\n+  parse_grouped_or_tuple_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n+\t\t\t       Location pratt_parsed_loc\n+\t\t\t       = Linemap::unknown_location ());\n+  std::unique_ptr<AST::StructExprField> parse_struct_expr_field ();\n+  bool will_be_expr_with_block ();\n+\n+  // Type-related\n+  std::unique_ptr<AST::TypeNoBounds> parse_type_no_bounds ();\n+  std::unique_ptr<AST::TypeNoBounds> parse_slice_or_array_type ();\n+  std::unique_ptr<AST::RawPointerType> parse_raw_pointer_type ();\n+  std::unique_ptr<AST::ReferenceType> parse_reference_type ();\n+  std::unique_ptr<AST::BareFunctionType>\n+  parse_bare_function_type (std::vector<AST::LifetimeParam> for_lifetimes);\n+  std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n+  std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n+  std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n+  AST::MaybeNamedParam parse_maybe_named_param (AST::AttrVec outer_attrs);\n+\n+  // Statement-related\n+\n+  /**\n+   *Parse a let-statement\n+   * LetStatement :\n+   * \tOuterAttribute*\n+   * \t\t'let' PatternNoTopAlt ( ':' Type )? ('=' Expression )? ';'\n+   *\n+   * @param allow_no_semi Allow parsing a let-statement without expecting a\n+   * \t\tsemicolon to follow it\n+   */\n+  std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\tParseRestrictions restrictions\n+\t\t\t\t\t\t= ParseRestrictions ());\n+  std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\t  ParseRestrictions restrictions\n+\t\t\t\t\t\t  = ParseRestrictions ());\n+  std::unique_ptr<AST::ExprStmtWithBlock>\n+  parse_expr_stmt_with_block (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::ExprStmtWithoutBlock>\n+  parse_expr_stmt_without_block (AST::AttrVec outer_attrs,\n+\t\t\t\t ParseRestrictions restrictions\n+\t\t\t\t = ParseRestrictions ());\n+  ExprOrStmt parse_stmt_or_expr_without_block ();\n+  ExprOrStmt parse_stmt_or_expr_with_block (AST::AttrVec outer_attrs);\n+  ExprOrStmt parse_macro_invocation_maybe_semi (AST::AttrVec outer_attrs);\n+  ExprOrStmt parse_path_based_stmt_or_expr (AST::AttrVec outer_attrs);\n+\n+  // Pattern-related\n+  std::unique_ptr<AST::Pattern> parse_literal_or_range_pattern ();\n+  std::unique_ptr<AST::RangePatternBound> parse_range_pattern_bound ();\n+  std::unique_ptr<AST::ReferencePattern> parse_reference_pattern ();\n+  std::unique_ptr<AST::Pattern> parse_grouped_or_tuple_pattern ();\n+  std::unique_ptr<AST::SlicePattern> parse_slice_pattern ();\n+  std::unique_ptr<AST::Pattern> parse_ident_leading_pattern ();\n+  std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n+  AST::StructPatternElements parse_struct_pattern_elems ();\n+  std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n+  std::unique_ptr<AST::StructPatternField>\n+  parse_struct_pattern_field_partial (AST::AttrVec outer_attrs);\n+\n+  int left_binding_power (const_TokenPtr token);\n+\n+  bool done_end ();\n+  bool done_end_or_else ();\n+  bool done_end_of_file ();\n+\n+  void add_error (Error error) { error_table.push_back (std::move (error)); }\n+\n+public:\n+  // Construct parser with specified \"managed\" token source.\n+  Parser (ManagedTokenSource &tokenSource) : lexer (tokenSource) {}\n+\n+  // Parse items without parsing an entire crate. This function is the main\n+  // parsing loop of AST::Crate::parse_crate().\n+  std::vector<std::unique_ptr<AST::Item> > parse_items ();\n+\n+  // Main entry point for parser.\n+  std::unique_ptr<AST::Crate> parse_crate ();\n+\n+  // Dumps all lexer output.\n+  void debug_dump_lex_output (std::ostream &out);\n+  void debug_dump_ast_output (AST::Crate &crate, std::ostream &out);\n+\n+  // Returns whether any parsing errors have occurred.\n+  bool has_errors () const { return !error_table.empty (); }\n+  // Remove all parsing errors from the table\n+  void clear_errors () { error_table.clear (); }\n+\n+  // Get a reference to the list of errors encountered\n+  std::vector<Error> &get_errors () { return error_table; }\n+\n+  const ManagedTokenSource &get_token_source () const { return lexer; }\n+\n+  const_TokenPtr peek_current_token () { return lexer.peek_token (0); }\n+\n+private:\n+  // The token source (usually lexer) associated with the parser.\n+  ManagedTokenSource &lexer;\n+  // The error list.\n+  std::vector<Error> error_table;\n+  // The names of inline modules while parsing.\n+  std::vector<std::string> inline_module_stack;\n+\n+  class InlineModuleStackScope\n+  {\n+  private:\n+    Parser &parser;\n+\n+  public:\n+    InlineModuleStackScope (Parser &parser, std::string name) : parser (parser)\n+    {\n+      parser.inline_module_stack.emplace_back (std::move (name));\n+    }\n+    ~InlineModuleStackScope () { parser.inline_module_stack.pop_back (); }\n+  };\n+};\n+\n+std::string\n+extract_module_path (const AST::AttrVec &inner_attrs,\n+\t\t     const AST::AttrVec &outer_attrs, const std::string &name);\n+\n+/**\n+ * Check if a MacroMatch is allowed to follow the last parsed MacroMatch.\n+ *\n+ * @param last_match Last matcher parsed before the current match\n+ * @param match Current matcher to check\n+ *\n+ * @return true if the follow-up is valid, false otherwise\n+ */\n+bool\n+is_match_compatible (const AST::MacroMatch &last_match,\n+\t\t     const AST::MacroMatch &current_match);\n+} // namespace Rust\n+\n+// as now template, include implementations of all methods\n+#include \"rust-parse-impl.h\"\n+\n+#endif // RUST_PARSE_H"}]}