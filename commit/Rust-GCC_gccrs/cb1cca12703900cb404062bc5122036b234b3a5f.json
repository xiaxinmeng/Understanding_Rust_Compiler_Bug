{"sha": "cb1cca12703900cb404062bc5122036b234b3a5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IxY2NhMTI3MDM5MDBjYjQwNDA2MmJjNTEyMjAzNmIyMzRiM2E1Zg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-08-08T20:56:52Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-08-08T20:56:52Z"}, "message": "lra-constraints.c (emit_spill_move): Remove assert.\n\n2013-08-08  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* lra-constraints.c (emit_spill_move): Remove assert.\n\t(process_alt_operands): Add more debugging\n\toutput.  Increase reject for spilling into memory.  Decrease\n\treject for reloading scratch.\n\t(split_reg): Use HARD_REGNO_CALLER_SAVE_MODE.\n\nFrom-SVN: r201611", "tree": {"sha": "5a8e58f80ddaac858ff987ebf8c735d19ff23a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a8e58f80ddaac858ff987ebf8c735d19ff23a97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb1cca12703900cb404062bc5122036b234b3a5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1cca12703900cb404062bc5122036b234b3a5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb1cca12703900cb404062bc5122036b234b3a5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1cca12703900cb404062bc5122036b234b3a5f/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a3719e31a1508b1d101d574fc20ff55817e287f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3719e31a1508b1d101d574fc20ff55817e287f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3719e31a1508b1d101d574fc20ff55817e287f3"}], "stats": {"total": 160, "additions": 130, "deletions": 30}, "files": [{"sha": "33e54ef54c4235924eb11bab72ad9d3443c7e133", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1cca12703900cb404062bc5122036b234b3a5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1cca12703900cb404062bc5122036b234b3a5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb1cca12703900cb404062bc5122036b234b3a5f", "patch": "@@ -1,3 +1,11 @@\n+2013-08-08  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* lra-constraints.c (emit_spill_move): Remove assert.\n+\t(process_alt_operands): Add more debugging\n+\toutput.  Increase reject for spilling into memory.  Decrease\n+\treject for reloading scratch.\n+\t(split_reg): Use HARD_REGNO_CALLER_SAVE_MODE.\n+\n 2013-08-08  Steve Ellcey  <sellcey@mips.com>\n \n \t* config/mips/mti-linux.h (SYSROOT_SUFFIX_SPEC): Add nan2008."}, {"sha": "ee72f7f0985624e79b2f3f1fe094720946a29224", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 122, "deletions": 30, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb1cca12703900cb404062bc5122036b234b3a5f/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb1cca12703900cb404062bc5122036b234b3a5f/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=cb1cca12703900cb404062bc5122036b234b3a5f", "patch": "@@ -859,8 +859,9 @@ emit_spill_move (bool to_p, rtx mem_pseudo, rtx val)\n {\n   if (GET_MODE (mem_pseudo) != GET_MODE (val))\n     {\n-      lra_assert (GET_MODE_SIZE (GET_MODE (mem_pseudo))\n-\t\t  >= GET_MODE_SIZE (GET_MODE (val)));\n+      /* Usually size of mem_pseudo is greater than val size but in\n+\t rare cases it can be less as it can be defined by target\n+\t dependent macro HARD_REGNO_CALLER_SAVE_MODE.  */\n       if (! MEM_P (val))\n \t{\n \t  val = gen_rtx_SUBREG (GET_MODE (mem_pseudo),\n@@ -1423,8 +1424,14 @@ process_alt_operands (int only_alternative)\n             \n       overall = losers = reject = reload_nregs = reload_sum = 0;\n       for (nop = 0; nop < n_operands; nop++)\n-\treject += (curr_static_id\n-\t\t   ->operand_alternative[nalt * n_operands + nop].reject);\n+\t{\n+\t  int inc = (curr_static_id\n+\t\t     ->operand_alternative[nalt * n_operands + nop].reject);\n+\t  if (lra_dump_file != NULL && inc != 0)\n+\t    fprintf (lra_dump_file,\n+\t\t     \"            Staticly defined alt reject+=%d\\n\", inc);\n+\t  reject += inc;\n+\t}\n       early_clobbered_regs_num = 0;\n \n       for (nop = 0; nop < n_operands; nop++)\n@@ -1598,7 +1605,14 @@ process_alt_operands (int only_alternative)\n \t\t\t    || (find_regno_note (curr_insn, REG_DEAD,\n \t\t\t\t\t\t REGNO (operand_reg[nop]))\n \t\t\t\t == NULL_RTX))\n-\t\t\t  reject += 2;\n+\t\t\t  {\n+\t\t\t    if (lra_dump_file != NULL)\n+\t\t\t      fprintf\n+\t\t\t\t(lra_dump_file,\n+\t\t\t\t \"            %d Matching alt: reject+=2\\n\",\n+\t\t\t\t nop);\n+\t\t\t    reject += 2;\n+\t\t\t  }\n \t\t      }\n \t\t    /* If we have to reload this operand and some\n \t\t       previous operand also had to match the same\n@@ -1854,16 +1868,35 @@ process_alt_operands (int only_alternative)\n \t\t    {\n \t\t      if (in_hard_reg_set_p (this_costly_alternative_set,\n \t\t\t\t\t     mode, hard_regno[nop]))\n-\t\t\treject++;\n+\t\t\t{\n+\t\t\t  if (lra_dump_file != NULL)\n+\t\t\t    fprintf (lra_dump_file,\n+\t\t\t\t     \"            %d Costly set: reject++\\n\",\n+\t\t\t\t     nop);\n+\t\t\t  reject++;\n+\t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* Prefer won reg to spilled pseudo under other equal\n \t\t\t conditions.  */\n+\t\t      if (lra_dump_file != NULL)\n+\t\t\tfprintf\n+\t\t\t  (lra_dump_file,\n+\t\t\t   \"            %d Non pseudo reload: reject++\\n\",\n+\t\t\t   nop);\n \t\t      reject++;\n \t\t      if (in_class_p (operand_reg[nop],\n \t\t\t\t      this_costly_alternative, NULL))\n-\t\t\treject++;\n+\t\t\t{\n+\t\t\t  if (lra_dump_file != NULL)\n+\t\t\t    fprintf\n+\t\t\t      (lra_dump_file,\n+\t\t\t       \"            %d Non pseudo costly reload:\"\n+\t\t\t       \" reject++\\n\",\n+\t\t\t       nop);\n+\t\t\t  reject++;\n+\t\t\t}\n \t\t    }\n \t\t  /* We simulate the behaviour of old reload here.\n \t\t     Although scratches need hard registers and it\n@@ -1872,7 +1905,13 @@ process_alt_operands (int only_alternative)\n \t\t     might cost something but probably less than old\n \t\t     reload pass believes.  */\n \t\t  if (lra_former_scratch_p (REGNO (operand_reg[nop])))\n-\t\t    reject += LRA_LOSER_COST_FACTOR;\n+\t\t    {\n+\t\t      if (lra_dump_file != NULL)\n+\t\t\tfprintf (lra_dump_file,\n+\t\t\t\t \"            %d Scratch win: reject+=3\\n\",\n+\t\t\t\t nop);\n+\t\t      reject += 3;\n+\t\t    }\n \t\t}\n \t    }\n \t  else if (did_match)\n@@ -1914,7 +1953,12 @@ process_alt_operands (int only_alternative)\n \n \t      this_alternative_offmemok = offmemok;\n \t      if (this_costly_alternative != NO_REGS)\n-\t\treject++;\n+\t\t{\n+\t\t  if (lra_dump_file != NULL)\n+\t\t    fprintf (lra_dump_file,\n+\t\t\t     \"            %d Costly loser: reject++\\n\", nop);\n+\t\t  reject++;\n+\t\t}\n \t      /* If the operand is dying, has a matching constraint,\n \t\t and satisfies constraints of the matched operand\n \t\t which failed to satisfy the own constraints, we do\n@@ -1996,7 +2040,13 @@ process_alt_operands (int only_alternative)\n \t\t      || (curr_static_id->operand[nop].type == OP_OUT\n \t\t\t  && (targetm.preferred_output_reload_class\n \t\t\t      (op, this_alternative) == NO_REGS))))\n-\t\treject += LRA_MAX_REJECT;\n+\t\t{\n+\t\t  if (lra_dump_file != NULL)\n+\t\t    fprintf (lra_dump_file,\n+\t\t\t     \"            %d Non-prefered reload: reject+=%d\\n\",\n+\t\t\t     nop, LRA_MAX_REJECT);\n+\t\t  reject += LRA_MAX_REJECT;\n+\t\t}\n \n \t      if (! (MEM_P (op) && offmemok)\n \t\t  && ! (const_to_mem && constmemok))\n@@ -2009,22 +2059,43 @@ process_alt_operands (int only_alternative)\n \t\t     we don't want to have a different alternative\n \t\t     match then.  */\n \t\t  if (! (REG_P (op) && REGNO (op) >= FIRST_PSEUDO_REGISTER))\n-\t\t    reject += 2;\n+\t\t    {\n+\t\t      if (lra_dump_file != NULL)\n+\t\t\tfprintf\n+\t\t\t  (lra_dump_file,\n+\t\t\t   \"            %d Non-pseudo reload: reject+=2\\n\",\n+\t\t\t   nop);\n+\t\t      reject += 2;\n+\t\t    }\n \n \t\t  if (! no_regs_p)\n \t\t    reload_nregs\n \t\t      += ira_reg_class_max_nregs[this_alternative][mode];\n \n \t\t  if (SMALL_REGISTER_CLASS_P (this_alternative))\n-\t\t    reject += LRA_LOSER_COST_FACTOR / 2;\n+\t\t    {\n+\t\t      if (lra_dump_file != NULL)\n+\t\t\tfprintf\n+\t\t\t  (lra_dump_file,\n+\t\t\t   \"            %d Small class reload: reject+=%d\\n\",\n+\t\t\t   nop, LRA_LOSER_COST_FACTOR / 2);\n+\t\t      reject += LRA_LOSER_COST_FACTOR / 2;\n+\t\t    }\n \t\t}\n \n \t      /* We are trying to spill pseudo into memory.  It is\n \t\t usually more costly than moving to a hard register\n \t\t although it might takes the same number of\n \t\t reloads.  */\n-\t      if (no_regs_p && REG_P (op))\n-\t\treject += 2;\n+\t      if (no_regs_p && REG_P (op) && hard_regno[nop] >= 0)\n+\t\t{\n+\t\t  if (lra_dump_file != NULL)\n+\t\t    fprintf\n+\t\t      (lra_dump_file,\n+\t\t       \"            %d Spill pseudo in memory: reject+=3\\n\",\n+\t\t       nop);\n+\t\t  reject += 3;\n+\t\t}\n \n #ifdef SECONDARY_MEMORY_NEEDED\n \t      /* If reload requires moving value through secondary\n@@ -2043,12 +2114,23 @@ process_alt_operands (int only_alternative)\n \t\t reloads can be removed, so penalize output\n \t\t reloads.  */\n \t      if (!REG_P (op) || curr_static_id->operand[nop].type != OP_IN)\n-\t\treject++;\n-\n+\t\t{\n+\t\t  if (lra_dump_file != NULL)\n+\t\t    fprintf\n+\t\t      (lra_dump_file,\n+\t\t       \"            %d Non input pseudo reload: reject++\\n\",\n+\t\t       nop);\n+\t\t  reject++;\n+\t\t}\n \t    }\n \n \t  if (early_clobber_p)\n-\t    reject++;\n+\t    {\n+\t      if (lra_dump_file != NULL)\n+\t\tfprintf (lra_dump_file,\n+\t\t\t \"            %d Early clobber: reject++\\n\", nop);\n+\t      reject++;\n+\t    }\n \t  /* ??? We check early clobbers after processing all operands\n \t     (see loop below) and there we update the costs more.\n \t     Should we update the cost (may be approximately) here\n@@ -2059,7 +2141,7 @@ process_alt_operands (int only_alternative)\n             {\n               if (lra_dump_file != NULL)\n \t\tfprintf (lra_dump_file,\n-\t\t\t \"          alt=%d,overall=%d,losers=%d -- reject\\n\",\n+\t\t\t \"            alt=%d,overall=%d,losers=%d -- refuse\\n\",\n \t\t\t nalt, overall, losers);\n               goto fail;\n             }\n@@ -2102,10 +2184,12 @@ process_alt_operands (int only_alternative)\n \t\t     insn we can transform it into an add still by\n \t\t     using this alternative.  */\n \t\t  && GET_CODE (no_subreg_reg_operand[1]) != PLUS)))\n-\t/* We have a move insn and a new reload insn will be similar\n-\t   to the current insn.  We should avoid such situation as it\n-\t   results in LRA cycling.  */\n-\toverall += LRA_MAX_REJECT;\n+\t{\n+\t  /* We have a move insn and a new reload insn will be similar\n+\t     to the current insn.  We should avoid such situation as it\n+\t     results in LRA cycling.  */\n+\t  overall += LRA_MAX_REJECT;\n+\t}\n       ok_p = true;\n       curr_alt_dont_inherit_ops_num = 0;\n       for (nop = 0; nop < early_clobbered_regs_num; nop++)\n@@ -2159,6 +2243,11 @@ process_alt_operands (int only_alternative)\n \t      losers++;\n \t      /* Early clobber was already reflected in REJECT. */\n \t      lra_assert (reject > 0);\n+\t      if (lra_dump_file != NULL)\n+\t\tfprintf\n+\t\t  (lra_dump_file,\n+\t\t   \"            %d Conflict early clobber reload: reject--\\n\",\n+\t\t   i);\n \t      reject--;\n \t      overall += LRA_LOSER_COST_FACTOR - 1;\n \t    }\n@@ -2186,6 +2275,12 @@ process_alt_operands (int only_alternative)\n \t      losers++;\n \t      /* Early clobber was already reflected in REJECT. */\n \t      lra_assert (reject > 0);\n+\t      if (lra_dump_file != NULL)\n+\t\tfprintf\n+\t\t  (lra_dump_file,\n+\t\t   \"            %d Matched conflict early clobber reloads:\"\n+\t\t   \"reject--\\n\",\n+\t\t   i);\n \t      reject--;\n \t      overall += LRA_LOSER_COST_FACTOR - 1;\n \t    }\n@@ -4386,15 +4481,12 @@ split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n \t     \"\t  ((((((((((((((((((((((((((((((((((((((((((((((((\\n\");\n   if (call_save_p)\n     {\n-      enum machine_mode sec_mode;\n+      enum machine_mode mode = GET_MODE (original_reg);\n \n-#ifdef SECONDARY_MEMORY_NEEDED_MODE\n-      sec_mode = SECONDARY_MEMORY_NEEDED_MODE (GET_MODE (original_reg));\n-#else\n-      sec_mode = GET_MODE (original_reg);\n-#endif\n-      new_reg = lra_create_new_reg (sec_mode, NULL_RTX,\n-\t\t\t\t    NO_REGS, \"save\");\n+      mode = HARD_REGNO_CALLER_SAVE_MODE (hard_regno,\n+\t\t\t\t\t  hard_regno_nregs[hard_regno][mode],\n+\t\t\t\t\t  mode);\n+      new_reg = lra_create_new_reg (mode, NULL_RTX, NO_REGS, \"save\");\n     }\n   else\n     {"}]}