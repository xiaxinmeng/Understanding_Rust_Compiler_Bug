{"sha": "80c7a9eb12eeb8ccd16823996fee736c8e01e59d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBjN2E5ZWIxMmVlYjhjY2QxNjgyMzk5NmZlZTczNmM4ZTAxZTU5ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-21T02:03:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-21T02:03:28Z"}, "message": "cfgexpand.c (expand_gimple_cond_expr, [...]): Split,\n\n        * cfgexpand.c (expand_gimple_cond_expr, expand_gimple_tailcall): Split,\n        (expand_gimple_basic_block): out from here.  Renamed from expand_block.\n\nFrom-SVN: r84993", "tree": {"sha": "4b027cd57200aed38249015e930418b1c0c433c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b027cd57200aed38249015e930418b1c0c433c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80c7a9eb12eeb8ccd16823996fee736c8e01e59d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c7a9eb12eeb8ccd16823996fee736c8e01e59d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80c7a9eb12eeb8ccd16823996fee736c8e01e59d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c7a9eb12eeb8ccd16823996fee736c8e01e59d/comments", "author": null, "committer": null, "parents": [{"sha": "e08eb33cbcf2cb4cc402fc4def027bd9deb65928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08eb33cbcf2cb4cc402fc4def027bd9deb65928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e08eb33cbcf2cb4cc402fc4def027bd9deb65928"}], "stats": {"total": 318, "additions": 171, "deletions": 147}, "files": [{"sha": "ecb93aab60d00f92e2afcfaaaf3611b9b8ebd755", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c7a9eb12eeb8ccd16823996fee736c8e01e59d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c7a9eb12eeb8ccd16823996fee736c8e01e59d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80c7a9eb12eeb8ccd16823996fee736c8e01e59d", "patch": "@@ -1,3 +1,8 @@\n+2004-07-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* cfgexpand.c (expand_gimple_cond_expr, expand_gimple_tailcall): Split,\n+\t(expand_gimple_basic_block): out from here.  Renamed from expand_block.\n+\n 2004-07-20  David S. Miller  <davem@nuts.davemloft.net>\n \n \t* config/sparc/sparc.c (sparc_rtx_costs case MULT): Emit"}, {"sha": "ff9578808c824b56b5b29f8a2225e4237a28ee62", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 166, "deletions": 147, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c7a9eb12eeb8ccd16823996fee736c8e01e59d/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c7a9eb12eeb8ccd16823996fee736c8e01e59d/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=80c7a9eb12eeb8ccd16823996fee736c8e01e59d", "patch": "@@ -35,10 +35,159 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-pass.h\"\n #include \"except.h\"\n #include \"flags.h\"\n+\n+\n+/* A subroutine of expand_gimple_basic_block.  Expand one COND_EXPR.\n+   Returns a new basic block if we've terminated the current basic\n+   block and created a new one.  */\n+\n+static basic_block\n+expand_gimple_cond_expr (basic_block bb, tree stmt)\n+{\n+  basic_block new_bb, dest;\n+  edge new_edge;\n+  edge true_edge;\n+  edge false_edge;\n+  tree pred = COND_EXPR_COND (stmt);\n+  tree then_exp = COND_EXPR_THEN (stmt);\n+  tree else_exp = COND_EXPR_ELSE (stmt);\n+  rtx last;\n+\n+  extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+  if (EXPR_LOCUS (stmt))\n+    {\n+      emit_line_note (*(EXPR_LOCUS (stmt)));\n+      record_block_change (TREE_BLOCK (stmt));\n+    }\n+\n+  /* These flags have no purpose in RTL land.  */\n+  true_edge->flags &= ~EDGE_TRUE_VALUE;\n+  false_edge->flags &= ~EDGE_FALSE_VALUE;\n+\n+  /* We can either have a pure conditional jump with one fallthru edge or\n+     two-way jump that needs to be decomposed into two basic blocks.  */\n+  if (TREE_CODE (then_exp) == GOTO_EXPR && IS_EMPTY_STMT (else_exp))\n+    {\n+      jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n+      return NULL;\n+    }\n+  if (TREE_CODE (else_exp) == GOTO_EXPR && IS_EMPTY_STMT (then_exp))\n+    {\n+      jumpifnot (pred, label_rtx (GOTO_DESTINATION (else_exp)));\n+      return NULL;\n+    }\n+  if (TREE_CODE (then_exp) != GOTO_EXPR || TREE_CODE (else_exp) != GOTO_EXPR)\n+    abort ();\n+\n+  jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n+  last = get_last_insn ();\n+  expand_expr (else_exp, const0_rtx, VOIDmode, 0);\n+\n+  BB_END (bb) = last;\n+  if (BARRIER_P (BB_END (bb)))\n+    BB_END (bb) = PREV_INSN (BB_END (bb));\n+  update_bb_for_insn (bb);\n+\n+  new_bb = create_basic_block (NEXT_INSN (last), get_last_insn (), bb);\n+  dest = false_edge->dest;\n+  redirect_edge_succ (false_edge, new_bb);\n+  false_edge->flags |= EDGE_FALLTHRU;\n+  new_bb->count = false_edge->count;\n+  new_bb->frequency = EDGE_FREQUENCY (false_edge);\n+  new_edge = make_edge (new_bb, dest, 0);\n+  new_edge->probability = REG_BR_PROB_BASE;\n+  new_edge->count = new_bb->count;\n+  if (BARRIER_P (BB_END (new_bb)))\n+    BB_END (new_bb) = PREV_INSN (BB_END (new_bb));\n+  update_bb_for_insn (new_bb);\n+\n+  if (dump_file)\n+    {\n+      dump_bb (bb, dump_file, 0);\n+      dump_bb (new_bb, dump_file, 0);\n+    }\n+\n+  return new_bb;\n+}\n+\n+/* A subroutine of expand_gimple_basic_block.  Expand one CALL_EXPR\n+   that has CALL_EXPR_TAILCALL set.  Returns a new basic block if we've\n+   terminated the current basic block and created a new one.  */\n+\n+static basic_block\n+expand_gimple_tailcall (basic_block bb, tree stmt)\n+{\n+  rtx last = get_last_insn ();\n+\n+  expand_expr_stmt (stmt);\n+\n+  for (last = NEXT_INSN (last); last; last = NEXT_INSN (last))\n+    {\n+      if (CALL_P (last) && SIBLING_CALL_P (last))\n+\t{\n+\t  edge e;\n+\t  int probability = 0;\n+\t  gcov_type count = 0;\n+\n+\t  do_pending_stack_adjust ();\n+\t  e = bb->succ;\n+\t  while (e)\n+\t    {\n+\t      edge next = e->succ_next;\n+\n+\t      if (!(e->flags & (EDGE_ABNORMAL | EDGE_EH)))\n+\t\t{\n+\t\t  if (e->dest != EXIT_BLOCK_PTR)\n+\t\t    {\n+\t\t      e->dest->count -= e->count;\n+\t\t      e->dest->frequency -= EDGE_FREQUENCY (e);\n+\t\t      if (e->dest->count < 0)\n+\t\t        e->dest->count = 0;\n+\t\t      if (e->dest->frequency < 0)\n+\t\t        e->dest->frequency = 0;\n+\t\t    }\n+\t\t  count += e->count;\n+\t\t  probability += e->probability;\n+\t\t  remove_edge (e);\n+\t\t}\n+\n+\t      e = next;\n+\t    }\n+\n+\t  /* This is somewhat ugly: the call_expr expander often emits\n+\t     instructions after the sibcall (to perform the function\n+\t     return).  These confuse the find_sub_basic_blocks code,\n+\t     so we need to get rid of these.  */\n+\t  last = NEXT_INSN (last);\n+\t  if (!BARRIER_P (last))\n+\t    abort ();\n+\t  while (NEXT_INSN (last))\n+\t    {\n+\t      /* For instance an sqrt builtin expander expands if with\n+\t\t sibcall in the then and label for `else`.  */\n+\t      if (LABEL_P (NEXT_INSN (last)))\n+\t\tbreak;\n+\t      delete_insn (NEXT_INSN (last));\n+\t    }\n+\t  e = make_edge (bb, EXIT_BLOCK_PTR, EDGE_ABNORMAL | EDGE_SIBCALL);\n+\t  e->probability += probability;\n+\t  e->count += count;\n+\t  BB_END (bb) = last;\n+\t  update_bb_for_insn (bb);\n+\t  if (NEXT_INSN (last))\n+\t    bb = create_basic_block (NEXT_INSN (last), get_last_insn (), bb);\n+\t  else\n+\t    return bb;\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n /* Expand basic block BB from GIMPLE trees to RTL.  */\n \n static basic_block\n-expand_block (basic_block bb, FILE * dump_file)\n+expand_gimple_basic_block (basic_block bb, FILE * dump_file)\n {\n   block_stmt_iterator bsi = bsi_start (bb);\n   tree stmt = NULL;\n@@ -94,157 +243,26 @@ expand_block (basic_block bb, FILE * dump_file)\n   for (; !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       tree stmt = bsi_stmt (bsi);\n-\n-      last = get_last_insn ();\n+      basic_block new_bb = NULL;\n \n       if (!stmt)\n \tcontinue;\n \n       /* Expand this statement, then evaluate the resulting RTL and\n \t fixup the CFG accordingly.  */\n-      switch (TREE_CODE (stmt))\n+      if (TREE_CODE (stmt) == COND_EXPR)\n+\tnew_bb = expand_gimple_cond_expr (bb, stmt);\n+      else\n \t{\n-\tcase COND_EXPR:\n-\t  {\n-\t    basic_block new_bb, dest;\n-\t    edge new_edge;\n-\t    edge true_edge;\n-\t    edge false_edge;\n-\t    tree pred = COND_EXPR_COND (stmt);\n-\t    tree then_exp = COND_EXPR_THEN (stmt);\n-\t    tree else_exp = COND_EXPR_ELSE (stmt);\n-\t    rtx last = get_last_insn ();\n-\n-\t    extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n-\t    if (EXPR_LOCUS (stmt))\n-\t      {\n-\t\temit_line_note (*(EXPR_LOCUS (stmt)));\n-\t\trecord_block_change (TREE_BLOCK (stmt));\n-\t      }\n-\n-\t    /* These flags have no purpose in RTL land.  */\n-\t    true_edge->flags &= ~EDGE_TRUE_VALUE;\n-\t    false_edge->flags &= ~EDGE_FALSE_VALUE;\n-\n-\t    /* We can either have a pure conditional jump with one fallthru\n-\t       edge or two-way jump that needs to be decomposed into two\n-\t       basic blocks.  */\n-\t    if (TREE_CODE (then_exp) == GOTO_EXPR\n-\t\t&& TREE_CODE (else_exp) == NOP_EXPR)\n-\t      {\n-\t\tjumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n-\t\tbreak;\n-\t      }\n-\t    if (TREE_CODE (else_exp) == GOTO_EXPR\n-\t\t&& TREE_CODE (then_exp) == NOP_EXPR)\n-\t      {\n-\t\tjumpifnot (pred, label_rtx (GOTO_DESTINATION (else_exp)));\n-\t\tbreak;\n-\t      }\n-\t    if (TREE_CODE (then_exp) != GOTO_EXPR\n-\t\t|| TREE_CODE (else_exp) != GOTO_EXPR)\n-\t      abort ();\n-\n-\t    jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n-\t    last = get_last_insn ();\n-\t    expand_expr (else_exp, const0_rtx, VOIDmode, 0);\n-\n-\t    BB_END (bb) = last;\n-\t    if (BARRIER_P (BB_END (bb)))\n-\t      BB_END (bb) = PREV_INSN (BB_END (bb));\n-\t    update_bb_for_insn (bb);\n-\n-\t    new_bb = create_basic_block (NEXT_INSN (last), get_last_insn (), bb);\n-\t    dest = false_edge->dest;\n-\t    redirect_edge_succ (false_edge, new_bb);\n-\t    false_edge->flags |= EDGE_FALLTHRU;\n-\t    new_bb->count = false_edge->count;\n-\t    new_bb->frequency = EDGE_FREQUENCY (false_edge);\n-\t    new_edge = make_edge (new_bb, dest, 0);\n-\t    new_edge->probability = REG_BR_PROB_BASE;\n-\t    new_edge->count = new_bb->count;\n-\t    if (BARRIER_P (BB_END (new_bb)))\n-\t      BB_END (new_bb) = PREV_INSN (BB_END (new_bb));\n-\t    update_bb_for_insn (new_bb);\n-\n-\t    if (dump_file)\n-\t      {\n-\t\tdump_bb (bb, dump_file, 0);\n-\t\tdump_bb (new_bb, dump_file, 0);\n-\t      }\n-\t    return new_bb;\n-\t  }\n-\n-\t/* Update after expansion of sibling call.  */\n-\tcase CALL_EXPR:\n-\tcase MODIFY_EXPR:\n-\tcase RETURN_EXPR:\n-          expand_expr_stmt (stmt);\n-\t  for (last = NEXT_INSN (last); last; last = NEXT_INSN (last))\n-\t    {\n-\t      if (CALL_P (last) && SIBLING_CALL_P (last))\n-\t\t{\n-\t\t  edge e;\n-\t\t  int probability = 0;\n-\t\t  gcov_type count = 0;\n-\n-\t\t  do_pending_stack_adjust ();\n-\t\t  e = bb->succ;\n-\t\t  while (e)\n-\t\t    {\n-\t\t      edge next = e->succ_next;\n-\n-\t\t      if (!(e->flags & (EDGE_ABNORMAL | EDGE_EH)))\n-\t\t\t{\n-\t\t\t  if (e->dest != EXIT_BLOCK_PTR)\n-\t\t\t    {\n-\t\t\t      e->dest->count -= e->count;\n-\t\t\t      e->dest->frequency -= EDGE_FREQUENCY (e);\n-\t\t\t      if (e->dest->count < 0)\n-\t\t\t        e->dest->count = 0;\n-\t\t\t      if (e->dest->frequency < 0)\n-\t\t\t        e->dest->frequency = 0;\n-\t\t\t    }\n-\t\t\t  count += e->count;\n-\t\t\t  probability += e->probability;\n-\t\t\t  remove_edge (e);\n-\t\t\t}\n-\n-\t\t      e = next;\n-\t\t    }\n-\n-\t\t  /* This is somewhat ugly:  the call_expr expander often emits instructions\n-\t\t     after the sibcall (to perform the function return).  These confuse the \n-\t\t     find_sub_basic_blocks code, so we need to get rid of these.  */\n-\t\t  last = NEXT_INSN (last);\n-\t\t  if (!BARRIER_P (last))\n-\t\t    abort ();\n-\t\t  while (NEXT_INSN (last))\n-\t\t    {\n-\t\t      /* For instance an sqrt builtin expander expands if with\n-\t\t\t sibcall in the then and label for `else`.  */\n-\t\t      if (LABEL_P (NEXT_INSN (last)))\n-\t\t\tbreak;\n-\t\t      delete_insn (NEXT_INSN (last));\n-\t\t    }\n-\t\t  e = make_edge (bb, EXIT_BLOCK_PTR,\n-\t\t\t\t     EDGE_ABNORMAL | EDGE_SIBCALL);\n-\t\t  e->probability += probability;\n-\t\t  e->count += count;\n-\t\t  BB_END (bb) = last;\n-\t\t  update_bb_for_insn (bb);\n-\t\t  if (NEXT_INSN (last))\n-\t\t    bb = create_basic_block (NEXT_INSN (last), get_last_insn (), bb);\n-\t\t  else\n-\t\t    return bb;\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-          expand_expr_stmt (stmt);\n-\t  break;\n+\t  tree call = get_call_expr_in (stmt);\n+\t  if (call && CALL_EXPR_TAILCALL (call))\n+\t    new_bb = expand_gimple_tailcall (bb, stmt);\n+\t  else\n+\t    expand_expr_stmt (stmt);\n \t}\n+\n+      if (new_bb)\n+\treturn new_bb;\n     }\n \n   do_pending_stack_adjust ();\n@@ -261,6 +279,7 @@ expand_block (basic_block bb, FILE * dump_file)\n   if (dump_file)\n     dump_bb (bb, dump_file, 0);\n   update_bb_for_insn (bb);\n+\n   return bb;\n }\n \n@@ -332,7 +351,8 @@ construct_exit_block (void)\n     return;\n   while (NEXT_INSN (head) && NOTE_P (NEXT_INSN (head)))\n     head = NEXT_INSN (head);\n-  exit_block = create_basic_block (NEXT_INSN (head), end, EXIT_BLOCK_PTR->prev_bb);\n+  exit_block = create_basic_block (NEXT_INSN (head), end,\n+\t\t\t\t   EXIT_BLOCK_PTR->prev_bb);\n   exit_block->frequency = EXIT_BLOCK_PTR->frequency;\n   exit_block->count = EXIT_BLOCK_PTR->count;\n   for (e = EXIT_BLOCK_PTR->pred; e; e = next)\n@@ -408,7 +428,7 @@ tree_expand_cfg (void)\n   init_block = construct_init_block ();\n \n   FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR, next_bb)\n-    bb = expand_block (bb, dump_file);\n+    bb = expand_gimple_basic_block (bb, dump_file);\n \n   construct_exit_block ();\n \n@@ -448,4 +468,3 @@ struct tree_opt_pass pass_expand =\n   0,                                    /* todo_flags_start */\n   0                                     /* todo_flags_finish */\n };\n-"}]}