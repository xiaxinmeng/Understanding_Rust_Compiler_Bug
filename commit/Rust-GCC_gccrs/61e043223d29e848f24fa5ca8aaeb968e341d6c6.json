{"sha": "61e043223d29e848f24fa5ca8aaeb968e341d6c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFlMDQzMjIzZDI5ZTg0OGYyNGZhNWNhOGFhZWI5NjhlMzQxZDZjNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-02-23T13:10:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-02-23T13:10:53Z"}, "message": "re PR tree-optimization/37709 (inlining causes explosion in debug info)\n\n\tPR tree-optimization/37709                                              \n\t* tree.c (block_ultimate_origin): Move here from dwarf2out.             \n\t* tree.h (block_ultimate_origin): Declare.                              \n\t* dwarf2out.c (block_ultimate_origin): Move to tree.c                   \n\t* tree-ssa-live.c (remove_unused_scope_block_p):\n\tEliminate blocks containig no instructions nor live variables nor\n\tnested blocks.\n\t(dump_scope_block): New function.\n\t(remove_unused_locals): Enable removal of dead blocks by default;\n\tenable dumping at TDF_DETAILS.\n\nFrom-SVN: r144381", "tree": {"sha": "d5fc8eef4ee0352c6b6283866a64b8d5d9ec3bde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5fc8eef4ee0352c6b6283866a64b8d5d9ec3bde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61e043223d29e848f24fa5ca8aaeb968e341d6c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61e043223d29e848f24fa5ca8aaeb968e341d6c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61e043223d29e848f24fa5ca8aaeb968e341d6c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61e043223d29e848f24fa5ca8aaeb968e341d6c6/comments", "author": null, "committer": null, "parents": [{"sha": "791c5e482115ebb266ca3c97881b7ea10f267521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/791c5e482115ebb266ca3c97881b7ea10f267521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/791c5e482115ebb266ca3c97881b7ea10f267521"}], "stats": {"total": 177, "additions": 117, "deletions": 60}, "files": [{"sha": "01968baaf2aabe4328ba3075adb0a452940509fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61e043223d29e848f24fa5ca8aaeb968e341d6c6", "patch": "@@ -1,3 +1,16 @@\n+2009-02-23  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/37709                                              \n+\t* tree.c (block_ultimate_origin): Move here from dwarf2out.             \n+\t* tree.h (block_ultimate_origin): Declare.                              \n+\t* dwarf2out.c (block_ultimate_origin): Move to tree.c                   \n+\t* tree-ssa-live.c (remove_unused_scope_block_p):\n+\tEliminate blocks containig no instructions nor live variables nor\n+\tnested blocks.\n+\t(dump_scope_block): New function.\n+\t(remove_unused_locals): Enable removal of dead blocks by default;\n+\tenable dumping at TDF_DETAILS.                                          \n+\n 2008-02-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (classify_argument): Don't allow COImode"}, {"sha": "6cfa55f932808d1ab2aa71682cafda026e3605c9", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=61e043223d29e848f24fa5ca8aaeb968e341d6c6", "patch": "@@ -3593,7 +3593,7 @@ dbxout_block (tree block, int depth, tree args)\n   while (block)\n     {\n       /* Ignore blocks never expanded or otherwise marked as real.  */\n-      if (TREE_USED (block) && TREE_ASM_WRITTEN (block))\n+      if (TREE_ASM_WRITTEN (block))\n \t{\n \t  int did_output;\n \t  int blocknum = BLOCK_NUMBER (block);"}, {"sha": "2e5f032c2a260acfb4b7cfa0ed992ba2151d671a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=61e043223d29e848f24fa5ca8aaeb968e341d6c6", "patch": "@@ -4947,7 +4947,6 @@ static const char *dwarf_tag_name (unsigned);\n static const char *dwarf_attr_name (unsigned);\n static const char *dwarf_form_name (unsigned);\n static tree decl_ultimate_origin (const_tree);\n-static tree block_ultimate_origin (const_tree);\n static tree decl_class_context (tree);\n static void add_dwarf_attr (dw_die_ref, dw_attr_ref);\n static inline enum dw_val_class AT_class (dw_attr_ref);\n@@ -5772,51 +5771,6 @@ decl_ultimate_origin (const_tree decl)\n   return DECL_ABSTRACT_ORIGIN (decl);\n }\n \n-/* Determine the \"ultimate origin\" of a block.  The block may be an inlined\n-   instance of an inlined instance of a block which is local to an inline\n-   function, so we have to trace all of the way back through the origin chain\n-   to find out what sort of node actually served as the original seed for the\n-   given block.  */\n-\n-static tree\n-block_ultimate_origin (const_tree block)\n-{\n-  tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n-\n-  /* output_inline_function sets BLOCK_ABSTRACT_ORIGIN for all the\n-     nodes in the function to point to themselves; ignore that if\n-     we're trying to output the abstract instance of this function.  */\n-  if (BLOCK_ABSTRACT (block) && immediate_origin == block)\n-    return NULL_TREE;\n-\n-  if (immediate_origin == NULL_TREE)\n-    return NULL_TREE;\n-  else\n-    {\n-      tree ret_val;\n-      tree lookahead = immediate_origin;\n-\n-      do\n-\t{\n-\t  ret_val = lookahead;\n-\t  lookahead = (TREE_CODE (ret_val) == BLOCK\n-\t\t       ? BLOCK_ABSTRACT_ORIGIN (ret_val) : NULL);\n-\t}\n-      while (lookahead != NULL && lookahead != ret_val);\n-\n-      /* The block's abstract origin chain may not be the *ultimate* origin of\n-\t the block. It could lead to a DECL that has an abstract origin set.\n-\t If so, we want that DECL's abstract origin (which is what DECL_ORIGIN\n-\t will give us if it has one).  Note that DECL's abstract origins are\n-\t supposed to be the most distant ancestor (or so decl_ultimate_origin\n-\t claims), so we don't need to loop following the DECL origins.  */\n-      if (DECL_P (ret_val))\n-\treturn DECL_ORIGIN (ret_val);\n-\n-      return ret_val;\n-    }\n-}\n-\n /* Get the class to which DECL belongs, if any.  In g++, the DECL_CONTEXT\n    of a virtual function may refer to a base class, so we check the 'this'\n    parameter.  */"}, {"sha": "81e65f732e1c5cba80317a01cd45d9a91e93b57e", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=61e043223d29e848f24fa5ca8aaeb968e341d6c6", "patch": "@@ -485,10 +485,13 @@ remove_unused_scope_block_p (tree scope)\n       next = &TREE_CHAIN (*t);\n \n       /* Debug info of nested function refers to the block of the\n-\t function.  */\n+\t function.  We might stil call it even if all statements\n+\t of function it was nested into was elliminated.\n+\t \n+\t TODO: We can actually look into cgraph to see if function\n+\t will be output to file.  */\n       if (TREE_CODE (*t) == FUNCTION_DECL)\n \tunused = false;\n-\n       /* Remove everything we don't generate debug info for.  */\n       else if (DECL_IGNORED_P (*t))\n \t{\n@@ -506,15 +509,24 @@ remove_unused_scope_block_p (tree scope)\n \n       /* When we are not doing full debug info, we however can keep around\n \t only the used variables for cfgexpand's memory packing saving quite\n-\t a lot of memory.  */\n+\t a lot of memory.  \n+\n+\t For sake of -g3, we keep around those vars but we don't count this as\n+\t use of block, so innermost block with no used vars and no instructions\n+\t can be considered dead.  We only want to keep around blocks user can\n+\t breakpoint into and ask about value of optimized out variables. \n+\n+\t Similarly we need to keep around types at least until all variables of\n+\t all nested blocks are gone.  We track no information on whether given\n+\t type is used or not.  */\n+\n       else if (debug_info_level == DINFO_LEVEL_NORMAL\n \t       || debug_info_level == DINFO_LEVEL_VERBOSE\n \t       /* Removing declarations before inlining is going to affect\n \t\t  DECL_UID that in turn is going to affect hashtables and\n \t\t  code generation.  */\n \t       || !cfun->after_inlining)\n-\tunused = false;\n-\n+\t;\n       else\n \t{\n \t  *t = TREE_CHAIN (*t);\n@@ -537,10 +549,7 @@ remove_unused_scope_block_p (tree scope)\n \t    nsubblocks ++;\n \t  }\n \telse\n-\t  {\n-\t    gcc_assert (!BLOCK_VARS (*t));\n-\t    *t = BLOCK_CHAIN (*t);\n-\t  }\n+\t  *t = BLOCK_CHAIN (*t);\n       }\n     else\n       {\n@@ -576,6 +585,38 @@ mark_all_vars_used (tree *expr_p, void *data)\n   walk_tree (expr_p, mark_all_vars_used_1, data, NULL);\n }\n \n+/* Dump scope blocks.  */\n+\n+static void\n+dump_scope_block (FILE *file, int indent, tree scope, int flags)\n+{\n+  tree var, t;\n+\n+  fprintf (file, \"\\n%*sScope block #%i %s\\n\",indent, \"\" , BLOCK_NUMBER (scope),\n+  \t   TREE_USED (scope) ? \"\" : \"(unused)\");\n+  if (BLOCK_ABSTRACT_ORIGIN (scope) && DECL_P (block_ultimate_origin (scope)))\n+    {\n+      fprintf (file, \"\\n%*sOriginating from \",indent + 1, \"\");\n+      print_generic_decl (file, block_ultimate_origin (scope), flags);\n+      fprintf (file, \"\\n\");\n+    }\n+  for (var = BLOCK_VARS (scope); var; var = TREE_CHAIN (var))\n+    {\n+      bool used = false;\n+      var_ann_t ann;\n+\n+      if ((ann = var_ann (var))\n+\t  && ann->used)\n+\tused = true;\n+\n+      fprintf (file, \"%*s\",indent, \"\");\n+      print_generic_decl (file, var, flags);\n+      fprintf (file, \"%s\\n\", used ? \"\" : \" (unused)\");\n+    }\n+  for (t = BLOCK_SUBBLOCKS (scope); t ; t = BLOCK_CHAIN (t))\n+    dump_scope_block (file, indent + 2, t, flags);\n+}\n+\n \n /* Remove local variables that are not referenced in the IL.  */\n \n@@ -588,8 +629,7 @@ remove_unused_locals (void)\n   var_ann_t ann;\n   bitmap global_unused_vars = NULL;\n \n-  if (optimize)\n-    mark_scope_block_unused (DECL_INITIAL (current_function_decl));\n+  mark_scope_block_unused (DECL_INITIAL (current_function_decl));\n \n   /* Assume all locals are unused.  */\n   FOR_EACH_REFERENCED_VAR (t, rvi)\n@@ -716,8 +756,12 @@ remove_unused_locals (void)\n \t&& !TREE_ADDRESSABLE (t)\n \t&& (optimize || DECL_ARTIFICIAL (t)))\n       remove_referenced_var (t);\n-  if (optimize)\n-    remove_unused_scope_block_p (DECL_INITIAL (current_function_decl));\n+  remove_unused_scope_block_p (DECL_INITIAL (current_function_decl));\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Scope blocks after cleanups:\\n\");\n+      dump_scope_block (dump_file, 0, DECL_INITIAL (current_function_decl), false);\n+    }\n }\n \n "}, {"sha": "423c8681cf2fb20d31fdee9ae88eca4af2e56059", "filename": "gcc/tree.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=61e043223d29e848f24fa5ca8aaeb968e341d6c6", "patch": "@@ -9199,4 +9199,49 @@ build_target_option_node (void)\n   return t;\n }\n \n+/* Determine the \"ultimate origin\" of a block.  The block may be an inlined\n+   instance of an inlined instance of a block which is local to an inline\n+   function, so we have to trace all of the way back through the origin chain\n+   to find out what sort of node actually served as the original seed for the\n+   given block.  */\n+\n+tree\n+block_ultimate_origin (const_tree block)\n+{\n+  tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n+\n+  /* output_inline_function sets BLOCK_ABSTRACT_ORIGIN for all the\n+     nodes in the function to point to themselves; ignore that if\n+     we're trying to output the abstract instance of this function.  */\n+  if (BLOCK_ABSTRACT (block) && immediate_origin == block)\n+    return NULL_TREE;\n+\n+  if (immediate_origin == NULL_TREE)\n+    return NULL_TREE;\n+  else\n+    {\n+      tree ret_val;\n+      tree lookahead = immediate_origin;\n+\n+      do\n+\t{\n+\t  ret_val = lookahead;\n+\t  lookahead = (TREE_CODE (ret_val) == BLOCK\n+\t\t       ? BLOCK_ABSTRACT_ORIGIN (ret_val) : NULL);\n+\t}\n+      while (lookahead != NULL && lookahead != ret_val);\n+\n+      /* The block's abstract origin chain may not be the *ultimate* origin of\n+\t the block. It could lead to a DECL that has an abstract origin set.\n+\t If so, we want that DECL's abstract origin (which is what DECL_ORIGIN\n+\t will give us if it has one).  Note that DECL's abstract origins are\n+\t supposed to be the most distant ancestor (or so decl_ultimate_origin\n+\t claims), so we don't need to loop following the DECL origins.  */\n+      if (DECL_P (ret_val))\n+\treturn DECL_ORIGIN (ret_val);\n+\n+      return ret_val;\n+    }\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "ae4291326d995dabd2e4c739ca9b2a074b804d30", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e043223d29e848f24fa5ca8aaeb968e341d6c6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=61e043223d29e848f24fa5ca8aaeb968e341d6c6", "patch": "@@ -5022,6 +5022,7 @@ extern bool gimple_alloca_call_p (const_gimple);\n extern bool alloca_call_p (const_tree);\n extern bool must_pass_in_stack_var_size (enum machine_mode, const_tree);\n extern bool must_pass_in_stack_var_size_or_pad (enum machine_mode, const_tree);\n+extern tree block_ultimate_origin (const_tree);\n \n /* In attribs.c.  */\n "}]}