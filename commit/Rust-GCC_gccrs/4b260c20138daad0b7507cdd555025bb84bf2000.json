{"sha": "4b260c20138daad0b7507cdd555025bb84bf2000", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIyNjBjMjAxMzhkYWFkMGI3NTA3Y2RkNTU1MDI1YmI4NGJmMjAwMA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-05-13T12:50:53Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-05-13T12:50:53Z"}, "message": "abi.html: New.\n\n\n2004-05-13  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* docs/html/abi.html: New.\n\t* docs/html/abi.txt: Remove.\n\t* docs/html/documentation.html: Add link.\n\t* testsuite/Makefile.am: Add files.\n\t* testsuite/Makefile.in: Regenerated.\n\t* testsuite/abi_check.cc: Move and modify code into...\n\t* testsuite/testsuite_abi.cc: Add.\n\t* testsuite/testsuite_abi.h: Add.\n\n\t* docs/html/17_intro/TODO: Update.\n\t* include/bits/stl_pair.h: Format.\n\nFrom-SVN: r81781", "tree": {"sha": "63b5caca1dfe3a1f87e96af76329f6f1565e7266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63b5caca1dfe3a1f87e96af76329f6f1565e7266"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b260c20138daad0b7507cdd555025bb84bf2000", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b260c20138daad0b7507cdd555025bb84bf2000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b260c20138daad0b7507cdd555025bb84bf2000", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b260c20138daad0b7507cdd555025bb84bf2000/comments", "author": null, "committer": null, "parents": [{"sha": "f8f456c68aea1927308c9ee9b47246e62dc945c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8f456c68aea1927308c9ee9b47246e62dc945c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8f456c68aea1927308c9ee9b47246e62dc945c2"}], "stats": {"total": 2432, "additions": 1568, "deletions": 864}, "files": [{"sha": "428c55940a8df9f85511dbc737a41abaa861a585", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -1,3 +1,17 @@\n+2004-05-13  Benjamin Kosnik  <bkoz@redhat.com>\n+\t\n+\t* docs/html/abi.html: New.\n+\t* docs/html/abi.txt: Remove.\n+\t* docs/html/documentation.html: Add link.\n+\t* testsuite/Makefile.am: Add files.\n+\t* testsuite/Makefile.in: Regenerated.\n+\t* testsuite/abi_check.cc: Move and modify code into...\n+\t* testsuite/testsuite_abi.cc: Add.\n+\t* testsuite/testsuite_abi.h: Add.\n+\n+\t* docs/html/17_intro/TODO: Update.\n+\t* include/bits/stl_pair.h: Format.\n+\t\n 2004-05-06  Matthias Klose  <doko@debian.org>\n \n \t* include/backward/iterator.h: \tAdd GPL copyright info,"}, {"sha": "93685fa3c9e97017b2a6feea429b17517cb9c4ac", "filename": "libstdc++-v3/docs/html/17_intro/TODO", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2FTODO?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -2,16 +2,13 @@ std::allocator\n \n   - switch to mt_allocator with --enable-threads=posix. \n \n-  - Try to figure out a way to switch allocators in a more elegant\n-    manner, and make the default allocator configurable.\n-\n   - persistent allocator\n \n   - global/extern allocator\n \n std::string \n \n-  - re-design for multi-paradigm, meta string class solution incorporating COW\n+  - Policy-based design incorporating COW\n     vs. deep copy issues, MT scalability\n     See Andrei Alexandrescu, June 2001, C/C++ Users Journal\n     \"Generic<Programming>: A Policy-Based basic_string Implementation\"\n@@ -53,8 +50,6 @@ std::locale\n \n   - minimize ctype convertion in data facets, see numpunct/num_put/num_get\n \n-  - finish caching data facets and using the caches\n-\n std::basic_filebuf, 27_io\n \n   - wfilebuf, get variable-encoding working and tested, including\n@@ -86,11 +81,11 @@ testsuite\n \n   - diffing generated output files\n \n+  - provide testsuites for numerics.\n+\n   - make check-abi needs to have full symbol checking. Scope the LSB\n     testsuite, see what's going on with the typeinfo etc. bits.\n \n-  - provide testsuites for numerics.\n-\n   - try to do a better job of ABI testing, with instantiations of all\n     standard-specified types checked, not just exported symbols.\n \n@@ -140,9 +135,6 @@ Nathan's commentary on cantrip, http://www.cantrip.org/cheaders.html\n - auto_ptr: seems to be some disagreement on what is\n standards-conformant behavior, specially on conversion operators.\n \n-- looks like deque::get_allocator not standards conformant or deque\n-allocator non-standard.\n-\n - list::assignment operator needs const_cast\n \n - a cleaner division between pointers-to-value_type and true iterators"}, {"sha": "fcb84e91793b2e38dd0cd22573fa58aa1c0f120f", "filename": "libstdc++-v3/docs/html/abi.html", "status": "added", "additions": 857, "deletions": 0, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fabi.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fabi.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fabi.html?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -0,0 +1,857 @@\n+<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n+<!DOCTYPE html\n+          PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n+          \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n+\n+<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n+<head>\n+   <meta name=\"AUTHOR\" content=\"bkoz@gcc.gnu.org (Benjamin Kosnik)\" />\n+   <meta name=\"KEYWORDS\" content=\"C++, libstdc++, dynamic, shared, library, ABI, version\" />\n+   <meta name=\"DESCRIPTION\" content=\"C++ Standard Library ABI\" />\n+   <meta name=\"GENERATOR\" content=\"emacs and ten fingers\" />\n+   <title>Standard C++ Library ABI</title>\n+<link rel=\"StyleSheet\" href=\"lib3styles.css\" type=\"text/css\" />\n+<link rel=\"Start\" href=\"documentation.html\" type=\"text/html\"\n+  title=\"GNU C++ Standard Library\" />\n+<link rel=\"Copyright\" href=\"17_intro/license.html\" type=\"text/html\" />\n+</head>\n+<body>\n+\n+<h1 class=\"centered\"><a name=\"top\">C++ Standard Library ABI</a></h1>\n+\n+<p class=\"fineprint\"><em>\n+   The latest version of this document is always available at\n+   <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/abi.html\">\n+   http://gcc.gnu.org/onlinedocs/libstdc++/abi.html</a>.\n+</em></p>\n+\n+<p><em>\n+   To the <a href=\"http://gcc.gnu.org/libstdc++/\">libstdc++-v3 homepage</a>.\n+</em></p>\n+\n+<!-- ####################################################### -->\n+<hr />\n+<h3 class=\"left\">\n+  <a name=\"C++interface\">The C++ interface</a>\n+</h3>\n+\n+<p> C++ applications often dependent on specific language support\n+routines, say for throwing exceptions, or catching exceptions, and\n+perhaps also dependent on features in the C++ Standard Library.\n+</p>\n+\n+<p> The C++ Standard Library has many include files, types defined in\n+those include files, specific named functions, and other behavior. The\n+text of these behaviors, as written in source include files, is called\n+the Application Programing Interface, or API.\n+</p>\n+\n+<p> Furthermore, C++ source that is compiled into object files is\n+ transformed by the compiler: it arranges objects with specific\n+ alignment and in a particular layout, mangling names according to a\n+ well-defined algorithm, has specific arrangements for the support of\n+ virtual functions, etc. These details are defined as the compiler\n+ Application Binary Interface, or ABI. The GNU C++ compiler uses an\n+ industry-standard C++ ABI starting with version 3. Details can be\n+ found in the <a href=\"http://www.codesourcery.com/cxx-abi/abi.html\">\n+ ABI specification</a>.\n+</p>\n+\n+<p>\n+ The GNU C++ compiler, g++, has a compiler command line option to\n+  switch between various different C++ ABIs. This explicit version\n+  switch is the flag <code> -fabi-version</code>. In addition, some\n+  g++ command line options may change the ABI as a side-effect of\n+  use. Such flags include <code>-fpack-struct</code> and\n+  <code>-fno-exceptions</code>, but include others: see the complete\n+  list in the GCC manual under the heading <a\n+  href=\"http://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#Code%20Gen%20Options\">Options\n+  for Code Generation Conventions</a>.\n+</p>\n+\n+<p> The configure options used when building a specific libstdc++\n+version may also impact the resulting library ABI. The available\n+configure options, and their impact on the library ABI, are documented\n+<a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/configopts.html\">\n+here</a>.\n+</p>\n+\n+<p> Putting all of these ideas together results in the C++ Standard\n+library ABI, which is the compilation of a given library API by a\n+given compiler ABI. In a nutshell:\n+</p>\n+\n+<code> library API + compiler ABI = library ABI</code>\n+\n+<p>\n+ The library ABI is mostly of interest for end-users who have\n+ unresolved symbols and are linking dynamically to the C++ Standard\n+ library, and who thus must be careful to compile their application\n+ with a compiler that is compatible with the available C++ Standard\n+ library binary. In this case, compatible is defined with the equation\n+ above: given an application compiled with a given compiler ABI and\n+ library API, it will work correctly with a Standard C++ Library\n+ created with the same constraints.\n+</p>\n+\n+<p>\n+  To use a specific version of the C++ ABI, one must use a\n+  corresponding GNU C++ toolchain (Ie, g++ and libstdc++) that\n+  implements the C++ ABI in question.\n+</p>\n+\n+<h3 class=\"left\">\n+  <a name=\"ABI versioning\">Versioning</a>\n+</h3>\n+\n+<p> The C++ interface has evolved throughout the history of the GNU\n+C++ toolchain. With each release, various details have been changed so\n+as to give distinct versions to the C++ interface.\n+</p>\n+\n+<h5 class=\"left\">\n+  <a name=\"goals\">Goals of versioning</a>\n+</h5>\n+\n+<p>Extending existing, stable ABIs. Versioning gives subsequent stable\n+releases series libraries the ability to add new symbols and add\n+functionality, all the while retaining backwards compatibility with\n+the previous releases in the series. Note: the reverse is not true. It\n+is not possible to take binaries linked with the latest version of a\n+release series (if symbols have been added) and expect the initial\n+release of the series to remain link compatible.\n+</p>\n+\n+<p>Allows multiple, incompatible ABIs to coexist at the same time.\n+</p>\n+\n+<p>\n+</p>\n+\n+<h5 class=\"left\">\n+  <a name=\"details\"> Version History </a>\n+</h5>\n+<p>\n+ How can this complexity be managed? What does C++ versioning mean?\n+  Because library and compiler changes often make binaries compiled\n+  with one version of the GNU tools incompatible with binaries\n+  compiled with other (either newer or older) versions of the same GNU\n+  tools, specific techniques are used to make managing this complexity\n+  easier.\n+</p>\n+\n+<p>\n+  The following techniques are used:\n+</p>\n+\n+  <ul>\n+\n+    <li> <p>Release versioning on the libgcc_s.so binary. This is\n+implemented via file names and the ELF DT_SONAME mechanism (at least\n+on ELF systems).</p>\n+\n+    <p>It is versioned as follows: \n+    </p>\n+    <ul>\n+    <li>gcc-3.0.0: libgcc_s.so.1</li>\n+    <li>gcc-3.0.1: libgcc_s.so.1</li>\n+    <li>gcc-3.0.2: libgcc_s.so.1</li>\n+    <li>gcc-3.0.3: libgcc_s.so.1</li>\n+    <li>gcc-3.0.4: libgcc_s.so.1</li>\n+    <li>gcc-3.1.0: libgcc_s.so.1</li>\n+    <li>gcc-3.1.1: libgcc_s.so.1</li>\n+    <li>gcc-3.2.0: libgcc_s.so.1</li>\n+    <li>gcc-3.2.1: libgcc_s.so.1</li>\n+    <li>gcc-3.2.2: libgcc_s.so.1</li>\n+    <li>gcc-3.2.3: libgcc_s.so.1</li>\n+    <li>gcc-3.3.0: libgcc_s.so.1</li>\n+    <li>gcc-3.3.1: libgcc_s.so.1</li>\n+    <li>gcc-3.3.2: libgcc_s.so.1</li>\n+    <li>gcc-3.3.3: libgcc_s.so.1</li>\n+    <li>gcc-3.4.0: libgcc_s.so.1</li>\n+    </ul>\n+    </li>\n+    <p></p>\n+\n+    <li>Release versioning on the libstdc++.so binary, implemented in the same was as the libgcc_s.so binary, above.\n+\n+    <p>It is versioned as follows:\n+    </p>\n+    <ul>\n+    <li>gcc-3.0.0: libstdc++.so.3.0.0</li>\n+    <li>gcc-3.0.1: libstdc++.so.3.0.1</li>\n+    <li>gcc-3.0.2: libstdc++.so.3.0.2</li>\n+    <li>gcc-3.0.3: libstdc++.so.3.0.2 (Error should be libstdc++.so.3.0.3)</li>\n+    <li>gcc-3.0.4: libstdc++.so.3.0.4</li>\n+    <li>gcc-3.1.0: libstdc++.so.4.0.0</li>\n+    <li>gcc-3.1.1: libstdc++.so.4.0.1</li>\n+    <li>gcc-3.2.0: libstdc++.so.5.0.0</li>\n+    <li>gcc-3.2.1: libstdc++.so.5.0.1</li>\n+    <li>gcc-3.2.2: libstdc++.so.5.0.2</li>\n+    <li>gcc-3.2.3: libstdc++.so.5.0.3 (Not strictly required)</li>\n+    <li>gcc-3.3.0: libstdc++.so.5.0.4</li>\n+    <li>gcc-3.3.1: libstdc++.so.5.0.5</li>\n+    <li>gcc-3.3.2: libstdc++.so.5.0.5</li>\n+    <li>gcc-3.3.3: libstdc++.so.5.0.5</li>\n+    <li>gcc-3.4.0: libstdc++.so.6.0.0</li>\n+    </ul>\n+    </li>\n+    <p></p>\n+\n+    <li>Symbol versioning on the libgcc_s.so binary.\n+    <p>mapfile: gcc/libgcc-std.ver</p>\n+\n+    <p>It is versioned with the following labels and version definitions:</p>\n+    <ul>\n+    <li>gcc-3.0.0: GCC_3.0</li>\n+    <li>gcc-3.0.1: GCC_3.0</li>\n+    <li>gcc-3.0.2: GCC_3.0</li>\n+    <li>gcc-3.0.3: GCC_3.0</li>\n+    <li>gcc-3.0.4: GCC_3.0</li>\n+    <li>gcc-3.1.0: GCC_3.0</li>\n+    <li>gcc-3.1.1: GCC_3.0</li>\n+    <li>gcc-3.2.0: GCC_3.0</li>\n+    <li>gcc-3.2.1: GCC_3.0</li>\n+    <li>gcc-3.2.2: GCC_3.0</li>\n+    <li>gcc-3.2.3: GCC_3.0</li>\n+    <li>gcc-3.3.0: GCC_3.0</li>\n+    <li>gcc-3.3.1: GCC_3.0</li>\n+    <li>gcc-3.3.2: GCC_3.0</li>\n+    <li>gcc-3.3.3: GCC_3.0</li>\n+    <li>gcc-3.4.0: GCC_3.0</li>\n+    </ul>\n+    </li>\n+    <p></p>\n+\n+    <li>Symbol versioning on the libstdc++.so binary.\n+\n+    <p>mapfile: libstdc++-v3/config/linker-map.gnu</p>\n+    <p>It is versioned with the following labels and version\n+   definitions, where the version definition is the maximum for a\n+   particular release. Note, only symbol which are newly introduced\n+   will use the maximum version definition. Thus, for release series\n+   with the same label, but incremented version definitions, the later\n+   release has both versions. (An example of this would be the\n+   gcc-3.2.1 release, which has GLIBCPP_3.2.1 for new symbols and\n+   GLIBCPP_3.2 for symbols that were introduced in the gcc-3.2.0\n+   release.)\n+   </p>\n+    <ul>\n+    <li>gcc-3.0.0: (Error, not versioned)</li>\n+    <li>gcc-3.0.1: (Error, not versioned)</li>\n+    <li>gcc-3.0.2: (Error, not versioned)</li>\n+    <li>gcc-3.0.3: (Error, not versioned)</li>\n+    <li>gcc-3.0.4: (Error, not versioned)</li>\n+    <li>gcc-3.1.0: GLIBCPP_3.1, CXXABI_1</li>\n+    <li>gcc-3.1.1: GLIBCPP_3.1, CXXABI_1</li>\n+    <li>gcc-3.2.0: GLIBCPP_3.2, CXXABI_1.2</li>\n+    <li>gcc-3.2.1: GLIBCPP_3.2.1, CXXABI_1.2</li>\n+    <li>gcc-3.2.2: GLIBCPP_3.2.2, CXXABI_1.2</li>\n+    <li>gcc-3.2.3: GLIBCPP_3.2.2, CXXABI_1.2</li>\n+    <li>gcc-3.3.0: GLIBCPP_3.2.2, CXXABI_1.2.1</li>\n+    <li>gcc-3.3.1: GLIBCPP_3.2.3, CXXABI_1.2.1</li>\n+    <li>gcc-3.3.2: GLIBCPP_3.2.3, CXXABI_1.2.1</li>\n+    <li>gcc-3.3.3: GLIBCPP_3.2.3, CXXABI_1.2.1</li>\n+    <li>gcc-3.4.0: GLIBCXX_3.4, CXXABI_1.3</li>\n+    </ul>\n+    </li>\n+    <p></p>\n+  \n+    <li>\n+    <p>Incremental bumping of a compiler pre-defined macro,\n+    __GXX_ABI_VERSION. This macro is defined as the version of the\n+    compiler v3 ABI, with g++ 3.0.x being version 100. This macro will\n+    be automatically defined whenever g++ is used (the curious can\n+    test this by invoking g++ with the '-v' flag.)\n+    </p>\n+    \n+    <p>\n+    This macro is defined in the file \"lang-specs.h\" in the gcc/cp directory.\n+    Later versions define it in \"c-common.c\" in the gcc directory.\n+    </p>\n+\n+    <p>\n+    It is versioned as follows:\n+    </p>\n+    <ul>\n+    <li>gcc-3.0.x: 100</li>\n+    <li>gcc-3.1.x: 100 (Error, should be 101)</li>\n+    <li>gcc-3.2.x: 102</li>\n+    <li>gcc-3.3.x: 102</li>\n+    <li>gcc-3.4.x: 1002</li>\n+    </ul>\n+    </li>\n+    <p></p>\n+\n+    <li>\n+    <p>Changes to the default compiler option for\n+    <code>-fabi-version</code>.\n+    </p>\n+   <p>\n+    It is versioned as follows:\n+    </p>\n+    <ul>\n+    <li>gcc-3.0.x: (Error, not versioned) </li>\n+    <li>gcc-3.1.x: (Error, not versioned) </li>\n+    <li>gcc-3.2.x: <code>-fabi-version=1</code></li>\n+    <li>gcc-3.3.x: <code>-fabi-version=1</code></li>\n+    <li>gcc-3.4.x: <code>-fabi-version=2</code></li>\n+    </ul>\n+    </li>\n+    <p></p>\n+\n+   <li>\n+    <p>Incremental bumping of a library pre-defined macro. For releases\n+    before 3.4.0, the macro is __GLIBCPP__. For later releases, it's\n+    __GLIBCXX__. (The libstdc++ project generously changed from CPP to\n+    CXX throughout its source to allow the \"C\" pre-processor the CPP\n+    macro namespace.) These macros are defined as the date the library\n+    was released, in compressed ISO date format, as an unsigned long.\n+    </p>\n+\n+    <p>\n+    In addition, the pre-defined macro is defined in the file\n+    \"c++config\" in the \"libstdc++-v3/include/bits\" directory and is\n+    changed every night by an automated script.\n+    </p>\n+    <p>\n+    It is versioned as follows:\n+    </p>\n+    <ul>\n+    <li>gcc-3.0.0: 20010615</li>\n+    <li>gcc-3.0.1: 20010819</li>\n+    <li>gcc-3.0.2: 20011023</li>\n+    <li>gcc-3.0.3: 20011220</li>\n+    <li>gcc-3.0.4: 20020220</li>\n+    <li>gcc-3.1.0: 20020514</li>\n+    <li>gcc-3.1.1: 20020725</li>\n+    <li>gcc-3.2.0: 20020814</li>\n+    <li>gcc-3.2.1: 20021119</li>\n+    <li>gcc-3.2.2: 20030205</li>\n+    <li>gcc-3.2.3: 20030422</li>\n+    <li>gcc-3.3.0: 20030513</li>\n+    <li>gcc-3.3.1: 20030804</li>\n+    <li>gcc-3.3.2: 20031016</li>\n+    <li>gcc-3.3.3: 20040214</li>\n+    <li>gcc-3.4.0: 20040419</li>\n+    </ul>\n+    </li>\n+    <p></p>\n+\n+\n+    <li>\n+    <p>\n+    Incremental bumping of a library pre-defined macro,\n+    _GLIBCPP_VERSION. This macro is defined as the released version of\n+    the library, as a string literal. This is only implemented in\n+    gcc-3.1.0 releases and higher, and is deprecated in 3.4.\n+    </p>\n+\n+    <p>\n+    This macro is defined in the file \"c++config\" in the\n+    \"libstdc++-v3/include/bits\" directory and is generated\n+    automatically by autoconf as part of the configure-time generation\n+    of config.h.\n+    </p>\n+\n+    <p>\n+    It is versioned as follows:\n+    </p>\n+    <ul>\n+    <li>gcc-3.0.0: \"3.0.0\"</li>\n+    <li>gcc-3.0.1: \"3.0.0\" (Error, should be \"3.0.1\")</li>\n+    <li>gcc-3.0.2: \"3.0.0\" (Error, should be \"3.0.2\")</li>\n+    <li>gcc-3.0.3: \"3.0.0\" (Error, should be \"3.0.3\")</li>\n+    <li>gcc-3.0.4: \"3.0.0\" (Error, should be \"3.0.4\")</li>\n+    <li>gcc-3.1.0: \"3.1.0\"</li>\n+    <li>gcc-3.1.1: \"3.1.1\"</li>\n+    <li>gcc-3.2.0: \"3.2\"</li>\n+    <li>gcc-3.2.1: \"3.2.1\"</li>\n+    <li>gcc-3.2.2: \"3.2.2\"</li>\n+    <li>gcc-3.2.3: \"3.2.3\"</li>\n+    <li>gcc-3.3.0: \"3.3\"</li>\n+    <li>gcc-3.3.1: \"3.3.1\"</li>\n+    <li>gcc-3.3.2: \"3.3.2\"</li>\n+    <li>gcc-3.3.3: \"3.3.3\"</li>\n+    <li>gcc-3.4.0: \"version-unused\"</li>\n+    </ul>\n+    </li>\n+    <p></p>\n+\n+    <li>\n+    <p>\n+    Matching each specific C++ compiler release to a specific set of\n+    C++ include files. This is only implemented in gcc-3.1.1 releases\n+    and higher.\n+    </p>\n+    <p>\n+    All C++ includes are installed in include/c++, then nest in a\n+    directory hierarchy corresponding to the C++ compiler's released\n+    version. This version corresponds to the variable \"gcc_version\" in\n+    \"libstdc++-v3/acinclude.m4,\" and more details can be found in that\n+    file's macro GLIBCPP_CONFIGURE.\n+    </p>\n+    <p>\n+    C++ includes are versioned as follows:\n+    </p>\n+    <ul>\n+    <li>gcc-3.0.0: include/g++-v3</li>\n+    <li>gcc-3.0.1: include/g++-v3</li>\n+    <li>gcc-3.0.2: include/g++-v3</li>\n+    <li>gcc-3.0.3: include/g++-v3</li>\n+    <li>gcc-3.0.4: include/g++-v3</li>\n+    <li>gcc-3.1.0: include/g++-v3</li>\n+    <li>gcc-3.1.1: include/c++/3.1.1</li>\n+    <li>gcc-3.2.0: include/c++/3.2</li>\n+    <li>gcc-3.2.1: include/c++/3.2.1</li>\n+    <li>gcc-3.2.2: include/c++/3.2.2</li>\n+    <li>gcc-3.2.3: include/c++/3.2.3</li>\n+    <li>gcc-3.3.0: include/c++/3.3</li>\n+    <li>gcc-3.3.1: include/c++/3.3.1</li>\n+    <li>gcc-3.3.2: include/c++/3.3.2</li>\n+    <li>gcc-3.3.3: include/c++/3.3.3</li>\n+    <li>gcc-3.4.0: include/c++/3.4.0</li>\n+    </ul>\n+    </li>\n+    <p></p>\n+  </ul>\n+<p>\n+  Taken together, these techniques can accurately specify interface\n+  and implementation changes in the GNU C++ tools themselves. Used\n+  properly, they allow both the GNU C++ tools implementation, and\n+  programs using them, an evolving yet controlled development that\n+  maintains backward compatibility.\n+</p>\n+\n+\n+\n+<h5 class=\"left\">\n+  <a name=\"requirements\"> Minimum requirements for a versioned ABI </a>\n+</h5>\n+<p>\n+  Minimum environment that supports a versioned ABI: A supported\n+  dynamic linker, a GNU linker of sufficient vintage to understand\n+  demangled C++ name globbing (ld), a shared executable compiled with\n+  g++, and shared libraries (libgcc_s, libstdc++-v3) compiled by a\n+  compiler (g++) with a compatible ABI. Phew.\n+</p>\n+\n+<p>\n+  On top of all that, an additional constraint: libstdc++ did not\n+  attempt to version symbols (or age gracefully, really) until version\n+  3.1.0. \n+</p>\n+\n+<p>\n+  Most modern Linux and BSD versions, particularly ones using\n+  gcc-3.1.x tools and more recent vintages, will meet the requirements above.\n+</p>\n+\n+\n+<h5 class=\"left\">\n+  <a name=\"config\"> What configure options impact symbol versioning? </a>\n+</h5>\n+<p>\n+  It turns out that most of the configure options that change default\n+  behavior will impact the mangled names of exported symbols, and thus\n+  impact versioning and compatibility.\n+</p>\n+\n+</p>\n+  For more information on configure options, including ABI impacts, see:\n+  http://gcc.gnu.org/onlinedocs/libstdc++/configopts.html\n+</p>\n+\n+<p>\n+  There is one flag that explicitly deals with symbol versioning:\n+  --enable-symvers. \n+</p>\n+\n+<p>\n+  In particular, libstdc++-v3/acinclude.m4 has a macro called\n+  GLIBCXX_ENABLE_SYMVERS that defaults to yes (or the argument passed\n+  in via --enable-symvers=foo). At that point, the macro attempts to\n+  make sure that all the requirement for symbol versioning are in\n+  place. For more information, please consult acinclude.m4. \n+</p>\n+\n+\n+<h5 class=\"left\">\n+  <a name=\"active\"> How to tell if symbol versioning is, indeed, active? </a>\n+</h5>\n+<p>\n+  When the GNU C++ library is being built with symbol versioning on,\n+  you should see the following at configure time for libstdc++-v3:\n+</p>\n+\n+\n+<code>  checking versioning on shared library symbols... gnu</code>\n+\n+<p>\n+  If you don't see this line in the configure output, or if this line\n+  appears but the last word is 'no', then you are out of luck.\n+</p>\n+\n+<p>\n+  If the compiler is pre-installed, a quick way to test is to compile\n+  the following (or any) simple C++ file and link it to the shared\n+  libstdc++ library:\n+</p>\n+\n+<pre>\n+#include &lt;iostream&gt;\n+\n+int main()\n+{ std::cout &lt;&lt; \"hello\" &lt;&lt; std::endl; return 0; }\n+\n+%g++ hello.cc -o hello.out\n+\n+%ldd hello.out\n+        libstdc++.so.5 => /usr/lib/libstdc++.so.5 (0x00764000)\n+        libm.so.6 => /lib/tls/libm.so.6 (0x004a8000)\n+        libgcc_s.so.1 => /mnt/hd/bld/gcc/gcc/libgcc_s.so.1 (0x40016000)\n+        libc.so.6 => /lib/tls/libc.so.6 (0x0036d000)\n+        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x00355000)\n+\n+%nm hello.out\n+</pre>\n+\n+<p>\n+If you see symbols in the resulting output with \"GLIBCXX_3\" as part\n+of the name, then the executable is versioned. Here's an example:\n+</p>\n+\n+   <code>      U _ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4 </code>\n+\n+<h3 class=\"left\">\n+  <a name=\"ABI allowed\">Library allowed ABI changes</a>\n+</h3>\n+<p>\n+The following will cause the library minor version number to\n+increase, say from \"libstdc++.so.3.0.4\" to \"libstdc++.so.3.0.5\".\n+</p>\n+<ul>\n+ <li>adding an exported global or static data member</li>\n+ <li>adding an exported function, static or non-virtual member function</li>\n+ <li>adding an exported symbol or symbols by additional instantiations</li>\n+</ul>\n+<p>\n+</p>\n+<p>\n+Other allowed changes are possible.\n+</p>\n+\n+\n+<h3 class=\"left\">\n+  <a name=\"ABI disallowed\">Library disallowed ABI changes</a>\n+</h3>\n+\n+<p>\n+The following non-exhaustive list will cause the library major version\n+number to increase, say from \"libstdc++.so.3.0.4\" to\n+\"libstdc++.so.4.0.0\".\n+</p>\n+<ul>\n+ <li>changes in the gcc/g++ compiler ABI</li>\n+<li>changing size of an exported symbol</li>\n+<li>changing alignment of an exported symbol</li>\n+<li>changing the layout of an exported symbol</li>\n+<li>changing mangling on an exported symbol</li>\n+<li>deleting an exported symbol</li>\n+<li>changing the inheritance properties of a type by adding or removing\n+    base classes</li>\n+<li>\n+  changing the size, alignment, or layout of types\n+  specified in the C++ standard. These may not necessarily be\n+  instantiated or otherwise exported in the library binary, and\n+  include all the required locale facets, as well as things like\n+  std::basic_streambuf, et al.\n+</li>\n+</ul>\n+\n+<h3 class=\"left\">\n+  <a name=\"implementation\">Library implementation strategy</a>\n+</h3>\n+\n+<ul>\n+ <li>Separation of interface and implementation</li>\n+<p>This is accomplished by two techniques that separate the API from\n+the ABI: forcing undefined references to link against a library binary\n+for definitions.\n+</p>\n+\n+ <ul>\n+ <li>Include files have declarations, source files have defines</li>\n+\n+<p> For non-templatized types, such as much of <code>class\n+locale</code>, the appropriate standard C++ include, say\n+<code>locale</code>, can contain full declarations, while various\n+source files (say <code> locale.cc, locale_init.cc,\n+localename.cc</code>) contain definitions.</p>\n+\n+  <li>Extern template on required types</li>\n+\n+   <p>For parts of the standard that have an explicit list of required\n+   instantiations, the GNU extension syntax <code> extern template\n+   </code> can be used to control where template definitions\n+   reside. By marking required instantiations as <code> extern\n+   template </code> in include files, and providing explicit\n+   instantiations in the appropriate instantiation files, non-inlined\n+   template functions can be versioned. This technique is mostly used\n+   on parts of the standard that require <code> char</code> and <code>\n+   wchar_t</code> instantiations, and includes <code>\n+   basic_string</code>, the locale facets, and the types in <code>\n+   iostreams</code>.</p>\n+\n+ </ul>\n+ <p> In addition, these techniques have the additional benefit that\n+ they reduce binary size, which can increase runtime performance.\n+ </p>\n+\n+ <li>Namespaces linking symbol definitions to export mapfiles</li>\n+\n+<p>All symbols in the shared library binary are processed by a linker\n+script at build time that either allows or disallows external\n+linkage. Because of this, some symbols, regardless of normal C/C++\n+linkage, are not visible. Symbols that are internal have several\n+appealing characteristics: by not exporting the symbols, there are no\n+relocations when the shared library is started and thus this makes for\n+faster runtime loading performance by the underlying dynamic loading\n+mechanism. In addition, they have the possibility of changing without\n+impacting ABI compatibility.\n+</p>\n+\n+<p>The following namespaces are transformed by the mapfile:</p>\n+\n+<ul>\n+<li><code>namespace std</code></li>\n+<p> Defaults to exporting all symbols in label\n+<code>GLIBCXX</code> that do not begin with an underscore, ie\n+<code>__test_func</code> would not be exported by default. Select\n+exceptional symbols are allowed to be visible.</p>\n+\n+<li><code>namespace __gnu_cxx</code></li>\n+<p> Defaults to not exporting any symbols in label\n+<code>GLIBCXX</code>, select items are allowed to be visible.</p>\n+\n+<li><code>namespace __gnu_internal</code></li>\n+<p> Defaults to not exported, no items are allowed to be visible.</p>\n+\n+<li><code>namespace __cxxabiv1</code>, aliased to <code> namespace abi</code></li>\n+<p> Defaults to not exporting any symbols in label\n+<code>CXXABI</code>, select items are allowed to be visible.</p>\n+</ul>\n+<p>\n+</p>\n+\n+ <li>Freezing the API</li>\n+ <p>Disallowed changes, as above, are not made on a stable release\n+branch. Enforcement tends to be less strict with GNU extensions that\n+standard includes.</p> </ul>\n+\n+<h3 class=\"left\">\n+  <a name=\"ABI testing\">Testing ABI changes</a>\n+</h3>\n+\n+<p>\n+Testing for GNU C++ ABI changes is composed of two distinct areas:\n+testing the C++ compiler (g++) for compiler changes, and testing the\n+C++ library (libstdc++) for library changes.\n+</p>\n+\n+<p>\n+Testing the C++ compiler ABI can be done various ways.\n+</p>\n+\n+<p>\n+One. \n+Intel ABI checker. More information can be obtained\n+<a href=\"http://developer.intel.com/software/products/opensource/\">here.</a>\n+</p>\n+\n+<p>\n+Two.\n+The second is yet unreleased, but has been announced on the gcc\n+mailing list. It is yet unspecified if these tools will be freely\n+available, and able to be included in a GNU project. Please contact\n+Mark Mitchell (mark@codesourcery.com) for more details, and current\n+status.\n+</p>\n+\n+<p>\n+Three.\n+Involves using the vlad.consistency test framework. This has also been\n+discussed on the gcc mailing lists.\n+</p>\n+\n+<p>\n+Testing the C++ library ABI can also be done various ways.\n+</p>\n+\n+<p>\n+One. \n+(Brendan Kehoe, Jeff Law suggestion to run 'make check-c++' two ways, \n+one with a new compiler and an old library, and the other with an old\n+compiler and a new library, and look for testsuite regressions)\n+</p>\n+\n+<p>\n+Details on how to set this kind of test up can be found here:\n+http://gcc.gnu.org/ml/gcc/2002-08/msg00142.html\n+</p>\n+\n+<p>\n+Two.  \n+Use the 'make check-abi' rule in the libstdc++-v3 Makefile. \n+</p>\n+\n+<p>\n+This is a proactive check the library ABI. Currently, exported symbol\n+names that are either weak or defined are checked against a last known\n+good baseline. Currently, this baseline is keyed off of 3.2.0\n+binaries, as this was the last time the .so number was incremented. In\n+addition, all exported names are demangled, and the exported objects\n+are checked to make sure they are the same size as the same object in\n+the baseline.\n+</p>\n+\n+<p>\n+This dataset is insufficient, yet a start. Also needed is a\n+comprehensive check for all user-visible types part of the standard\n+library for sizeof() and alignof() changes. \n+</p>\n+\n+<p>\n+Verifying compatible layouts of objects is not even attempted.  It\n+should be possible to use sizeof, alignof, and offsetof to compute\n+offsets for each structure and type in the standard library, saving to\n+another datafile. Then, compute this in a similar way for new\n+binaries, and look for differences.\n+</p>\n+\n+<p>\n+Another approach might be to use the -fdump-class-hierarchy flag to\n+get information. However, currently this approach gives insufficient\n+data for use in library testing, as class data members, their offsets,\n+and other detailed data is not displayed with this flag.\n+(See g++/7470 on how this was used to find bugs.)\n+</p>\n+\n+<p>\n+Perhaps there are other C++ ABI checkers. If so, please notify\n+us. We'd like to know about them!\n+</p>\n+\n+<h3 class=\"left\">\n+  <a name=\"ABI multi testing\">Testing Multi-ABI binaries</a>\n+</h3>\n+\n+<p>\n+A \"C\" application, dynamically linked to two shared libraries, liba,\n+libb. The dependent library liba is C++ shared library compiled with\n+gcc-3.3.x, and uses io, exceptions, locale, etc. The dependent library\n+libb is a C++ shared library compiled with gcc-3.4.x, and also uses io,\n+exceptions, locale, etc.\n+</p>\n+\n+<p> As above, libone is constructed as follows: </p>\n+<pre>\n+%$bld/H-x86-gcc-3.4.0/bin/g++ -fPIC -DPIC -c a.cc\n+\n+%$bld/H-x86-gcc-3.4.0/bin/g++ -shared -Wl,-soname -Wl,libone.so.1 -Wl,-O1 -Wl,-z,defs a.o -o libone.so.1.0.0\n+\n+%ln -s libone.so.1.0.0 libone.so\n+\n+%$bld/H-x86-gcc-3.4.0/bin/g++ -c a.cc\n+\n+%ar cru libone.a a.o \n+</pre>\n+\n+<p> And, libtwo is constructed as follows: </p>\n+\n+<pre>\n+%$bld/H-x86-gcc-3.3.3/bin/g++ -fPIC -DPIC -c b.cc\n+\n+%$bld/H-x86-gcc-3.3.3/bin/g++ -shared -Wl,-soname -Wl,libtwo.so.1 -Wl,-O1 -Wl,-z,defs b.o -o libtwo.so.1.0.0\n+\n+%ln -s libtwo.so.1.0.0 libtwo.so\n+\n+%$bld/H-x86-gcc-3.3.3/bin/g++ -c b.cc\n+\n+%ar cru libtwo.a b.o \n+</pre>\n+\n+<p> ...with the resulting libraries looking like </p>\n+<pre>\n+%ldd libone.so.1.0.0\n+        libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x40016000)\n+        libm.so.6 => /lib/tls/libm.so.6 (0x400fa000)\n+        libgcc_s.so.1 => /mnt/hd/bld/gcc/gcc/libgcc_s.so.1 (0x4011c000)\n+        libc.so.6 => /lib/tls/libc.so.6 (0x40125000)\n+        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x00355000)\n+\n+%ldd libtwo.so.1.0.0\n+        libstdc++.so.5 => /usr/lib/libstdc++.so.5 (0x40027000)\n+        libm.so.6 => /lib/tls/libm.so.6 (0x400e1000)\n+        libgcc_s.so.1 => /mnt/hd/bld/gcc/gcc/libgcc_s.so.1 (0x40103000)\n+        libc.so.6 => /lib/tls/libc.so.6 (0x4010c000)\n+        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x00355000)\n+\n+</pre>\n+\n+<p> Then, the \"C\" compiler is used to compile a source file that uses\n+functions from each library.</p>\n+<pre>\n+gcc test.c -g -O2 -L. -lone -ltwo /usr/lib/libstdc++.so.5 /usr/lib/libstdc++.so.6\n+</pre>\n+\n+<p>\n+Which gives the expected:\n+</p>\n+<pre>\n+%ldd a.out\n+        libstdc++.so.5 => /usr/lib/libstdc++.so.5 (0x00764000)\n+        libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x40015000)\n+        libc.so.6 => /lib/tls/libc.so.6 (0x0036d000)\n+        libm.so.6 => /lib/tls/libm.so.6 (0x004a8000)\n+        libgcc_s.so.1 => /mnt/hd/bld/gcc/gcc/libgcc_s.so.1 (0x400e5000)\n+        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x00355000)\n+</pre>\n+\n+<p>\n+This resulting binary, when executed, will be able to safely use code\n+from both liba, and the dependent libstdc++.so.6, and libb, with the\n+dependent libstdc++.so.5.\n+</p>\n+\n+<h3 class=\"left\">\n+  <a name=\"references\">Bibliography / Further Reading</a>\n+</h3>\n+\n+<p>\n+ABIcheck, a vague idea of checking ABI compatibility\n+http://abicheck.sourceforge.net/\n+\n+<p>\n+C++ ABI reference\n+http://www.codesourcery.com/cxx-abi/\n+</p>\n+\n+<p>\n+Intel ABI documentation\n+\"Intel\ufffd Compilers for Linux* -Compatibility with the GNU Compilers\"\n+(included in icc 6.0)\n+</p>\n+\n+<p>\n+Sun Solaris 2.9 docs\n+Linker and Libraries Guide (document 816-1386)\n+C++ Migration Guide (document 816-2459)\n+http://docs.sun.com/db/prod/solaris.9\n+http://docs.sun.com/?p=/doc/816-1386&a=load\n+</p>\n+\n+<p>\n+Ulrich Drepper, \"ELF Symbol Versioning\"\n+http://people.redhat.com/drepper/symbol-versioning\n+</p>"}, {"sha": "430108885f9dd988018f2707c25b7507fa7dfada", "filename": "libstdc++-v3/docs/html/abi.txt", "status": "removed", "additions": 0, "deletions": 389, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f456c68aea1927308c9ee9b47246e62dc945c2/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fabi.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f456c68aea1927308c9ee9b47246e62dc945c2/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fabi.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fabi.txt?ref=f8f456c68aea1927308c9ee9b47246e62dc945c2", "patch": "@@ -1,389 +0,0 @@\n-\n-2002-10-14 Benjamin Kosnik\n-\n-Description of the libstdc++ ABI.\n-\n-I. What is an ABI? What's covered? What's not?\n-\n-- scope of document, of use to system integrators.\n-\n-- What's the deal with C++? Why can't different compiler's object\n-  files link with each other? Bug? Feature?\n-\n-- compilation includes and linked library binary must match up..\n-\n-- shared library only, static is immutable.\n-\n-- What's an ABI?\n-\n-- library ABI, compiler ABI different issues, (but related)\n-\n-- GNU C++ does not have a compiler command line option to switch\n-  between various different C++ ABIs. For instance, there is no way to\n-  switch between the gcc-3.0.x ABI, gcc-3.1.x ABI, and the gcc-3.2.x\n-  ABI during compilation. Other C++ compilers do allow this, and some\n-  g++ command line options may change the ABI (-fno-exceptions, see\n-  the complete list), but there is no version switch. Sorry. \n-\n-  To use a specific C++ABI, one must use the corresponding GNU C++\n-  toolchain. \n-\n-- How can this complexity be managed? What does C++ versioning mean?\n-  Because library and compiler changes often make binaries compiled\n-  with one version of the GNU tools incompatible with binaries\n-  compiled with other (either newer or older) versions of the same GNU\n-  tools, specific techniques are used to make managing this complexity\n-  easier.\n-\n-  The following techniques are used:\n-\n-  - Release versioning on the libgcc_s.so binary.\n-\n-    It is versioned as follows:\n-    gcc-3.0.0: libgcc_s.so.1\n-    gcc-3.0.1: libgcc_s.so.1\n-    gcc-3.0.2: libgcc_s.so.1\n-    gcc-3.0.3: libgcc_s.so.1\n-    gcc-3.0.4: libgcc_s.so.1\n-    gcc-3.1.0: libgcc_s.so.1\n-    gcc-3.1.1: libgcc_s.so.1\n-    gcc-3.2.0: libgcc_s.so.1\n-\n-\n-  - Release versioning on the libstdc++.so binary.\n-\n-    It is versioned as follows:\n-    gcc-3.0.0: libstdc++.so.3.0.0\n-    gcc-3.0.1: libstdc++.so.3.0.1\n-    gcc-3.0.2: libstdc++.so.3.0.2\n-    gcc-3.0.3: libstdc++.so.3.0.2 (Error, should be libstdc++.so.3.0.3)\n-    gcc-3.0.4: libstdc++.so.3.0.4\n-    gcc-3.1.0: libstdc++.so.4.0.0\n-    gcc-3.1.1: libstdc++.so.4.0.1\n-    gcc-3.2.0: libstdc++.so.5.0.0\n-\n-\n-  - Symbol versioning on the libgcc_s.so binary.\n-  \n-    file: gcc/libgcc-std.ver\n-\n-    It is versioned as follows:\n-    gcc-3.0.0: GCC_3.0\n-    gcc-3.0.1: GCC_3.0\n-    gcc-3.0.2: GCC_3.0\n-    gcc-3.0.3: GCC_3.0\n-    gcc-3.0.4: GCC_3.0\n-    gcc-3.1.0: GCC_3.0\n-    gcc-3.1.1: GCC_3.0\n-    gcc-3.2.0: GCC_3.0\n-\n-\n-  - Symbol versioning on the libstdc++.so binary.\n-  \n-    It is versioned as follows:\n-    gcc-3.0.0: (Error, unversioned)\n-    gcc-3.0.1: (Error, unversioned)\n-    gcc-3.0.2: (Error, unversioned)\n-    gcc-3.0.3: (Error, unversioned)\n-    gcc-3.0.4: (Error, unversioned)\n-    gcc-3.1.0: GLIBCPP_3.1, CXXABI_1\n-    gcc-3.1.1: GLIBCPP_3.1, CXXABI_1\n-    gcc-3.2.0: GLIBCPP_3.2, CXXABI_1.2\n-    \n-    file: libstdc++-v3/config/linker-map.gnu\n-  \n-\n-  - Incremental bumping of a compiler pre-defined macro,\n-    __GXX_ABI_VERSION. This macro is defined as the version of the\n-    compiler v3 ABI, with g++ 3.0.x being version 100. This macro will\n-    be automatically defined whenever g++ is used (the curious can\n-    test this by invoking g++ with the '-v' flag.)\n-    \n-    This macro is defined in the file \"lang-specs.h\" in the gcc/cp directory.\n-    Later versions define it in \"c-common.c\" in the gcc directory.\n-\n-    It is versioned as follows:\n-    gcc-3.0.x: 100\n-    gcc-3.1.x: 100 (Error, should be 101)\n-    gcc-3.2.x: 102\n-\n-\n-  - Incremental bumping of a library pre-defined macro, __GLIBCPP__ or\n-    __GLIBCXX__.  This macro is defined as the date the library was\n-    released, in compressed ISO date format, as an unsigned long.\n-\n-    This macro is defined in the file \"c++config\" in the\n-    \"libstdc++-v3/include/bits\" directory and is changed every night\n-    by an automated script.\n-\n-    It is versioned as follows:\n-    gcc-3.0.0: 20010615\n-    gcc-3.0.1: 20010819\n-    gcc-3.0.2: 20011023\n-    gcc-3.0.3: 20011220\n-    gcc-3.0.4: 20020220\n-    gcc-3.1.0: 20020514\n-    gcc-3.1.1: 20020725\n-    gcc-3.2.0: 20020814\n-\n-\n-  - Incremental bumping of a library pre-defined macro,\n-    _GLIBCPP_VERSION. This macro is defined as the released version of\n-    the library, as a string literal. This is only implemented in\n-    gcc-3.1.0 releases and higher, and changed to _GLIBCXX_VERSION in 3.4.\n-\n-    This macro is defined in the file \"c++config\" in the\n-    \"libstdc++-v3/include/bits\" directory and is generated\n-    automatically by autoconf as part of the configure-time generation\n-    of config.h.\n-\n-    It is versioned as follows:\n-    gcc-3.0.0: \"3.0.0\"\n-    gcc-3.0.1: \"3.0.0\" (Error, should be \"3.0.1\")\n-    gcc-3.0.2: \"3.0.0\" (Error, should be \"3.0.2\")\n-    gcc-3.0.3: \"3.0.0\" (Error, should be \"3.0.3\")\n-    gcc-3.0.4: \"3.0.0\" (Error, should be \"3.0.4\")\n-    gcc-3.1.0: \"3.1.0\"\n-    gcc-3.1.1: \"3.1.1\"\n-    gcc-3.2.0: \"3.2\"\n-\n-\n-  - Matching each specific C++ compiler release to a specific set of\n-    C++ include files. This is only implemented in gcc-3.1.1 releases\n-    and higher.\n-\n-    All C++ includes are installed in include/c++, then nest in a\n-    directory hierarchy corresponding to the C++ compiler's released\n-    version. This version corresponds to the variable \"gcc_version\" in\n-    \"libstdc++-v3/acinclude.m4,\" and more details can be found in that\n-    file's macro GLIBCPP_CONFIGURE.\n-\n-    C++ includes are versioned as follows:\n-    gcc-3.0.0: include/g++-v3\n-    gcc-3.0.1: include/g++-v3\n-    gcc-3.0.2: include/g++-v3\n-    gcc-3.0.3: include/g++-v3\n-    gcc-3.0.4: include/g++-v3\n-    gcc-3.1.0: include/g++-v3\n-    gcc-3.1.1: include/c++/3.1.1\n-    gcc-3.2.0: include/c++/3.2\n-\n-  Taken together, these techniques can accurately specify interface\n-  and implementation changes in the GNU C++ tools themselves. Used\n-  properly, they allow both the GNU C++ tools implementation, and\n-  programs using them, an evolving yet controlled development that\n-  maintains backward compatibility.\n-\n-- Minimum environment that supports a versioned ABI: what's needed?  A\n-  supported dynamic linker, a GNU linker of sufficient vintage to\n-  understand demangled C++ name globbing (ld), a shared executable\n-  compiled with g++, and shared libraries (libgcc_s, libstdc++-v3)\n-  compiled by a compiler (g++) with a compatible ABI. Phew.\n-\n-  On top of all that, an additional constraint: libstdc++ did not\n-  attempt to version symbols (or age gracefully, really) until version\n-  3.1.0. \n-\n-  Most modern Linux and BSD versions, particularly ones using\n-  gcc-3.1.x tools, will meet the requirements above.\n-\n-- What configure options impact symbol versioning?\n-\n-  It turns out that most of the configure options that change default\n-  behavior will impact the mangled names of exported symbols, and thus\n-  impact versioning and compatibility.\n-\n-  For more information on configure options, including ABI impacts, see:\n-  http://gcc.gnu.org/onlinedocs/libstdc++/configopts.html\n-\n-  There is one flag that explicitly deals with symbol versioning:\n-  --enable-symvers. \n-\n-  In particular, libstdc++-v3/acinclude.m4 has a macro called\n-  GLIBCXX_ENABLE_SYMVERS that defaults to yes (or the argument passed\n-  in via --enable-symvers=foo). At that point, the macro attempts to\n-  make sure that all the requirement for symbol versioning are in\n-  place. For more information, please consult acinclude.m4. \n-\n-- How can I tell if symbol versioning is, indeed, active? \n-\n-  When the GNU C++ library is being built with symbol versioning on,\n-  you should see the following at configure time for libstdc++-v3:\n-\n-  checking versioning on shared library symbols... gnu\n-\n-  If you don't see this line in the configure output, or if this line\n-  appears but the last word is 'no', then you are out of luck.\n-\n-  If the compiler is pre-installed, a quick way to test is to compile\n-  the following (or any) simple C++ file:\n-\n-#include <iostream>\n-\n-int main()\n-{ std::cout << \"hello\" << std::endl; return 0; }\n-\n-%g++ hello.cc -o hello.out\n-%nm hello.out\n-\n-If you see symbols in the resulting output with \"GLIBCPP_3.x\" as part\n-of the name, then the executable is versioned. Here's an example:\n-\n-         U _ZNSt8ios_base4InitC1Ev@@GLIBCPP_3.1\n-\n-\n-II. Library ABI changes\n-\n-The following will cause the library major version number to\n-increase, say from \"libstdc++.so.3.0.4\" to \"libstdc++.so.4.0.0\".\n-\n-- (anything) changing in the gcc/g++ compiler ABI\n-\n-- (anything) changing size of an exported symbol\n-\n-- (anything) changing alignment of an exported symbol\n-\n-- (anything) changing the layout of an exported symbol\n-\n-- (anything) changing mangling on an exported symbol\n-\n-- (anything) deleting an exported symbol\n-\n-- (anything) changing the size, alignment, or layout of types\n-  specified in the C++ standard. These may not necessarily be\n-  instantiated or otherwise exported in the library binary, and\n-  include all the required locale facets, as well as things like\n-  std::basic_streambuf, et al.\n-\n-Note: adding an exported symbol, if it's in a new and dependent\n-interface name, is ok.\n-\n-The following will cause the library revision version number to\n-increase, say from \"libstdc++.so.5.0.0\" to \"libstdc++.so.5.0.1\".\n-\n-- any release of the gcc toolchain.\n-\n-\n-III. Versioning\n-\n-- include files\n-\n-  - versioning headers with version, why necessary\n-    (need to control member/non-member functions, add delete files)\n-\n-- shared library binaries\n-\n-  - release versions\n-\n-  - libtool versions\n-\n-  - when does so version get a bump? what are the options?\n-\n-  - how is the link map used?  \n-\n-  - in an non-abi breaking minor release, how are symbols added?\n-    removed?\n-\n-  - in an abi-breaking major release, what happens? symbol fall back\n-\n-\n-IV. Testing ABI changes\n-\n-Testing for GNU C++ ABI changes is composed of two distinct areas:\n-testing the C++ compiler (g++) for compiler changes, and testing the\n-C++ library (libstdc++) for library changes.\n-\n-Testing the C++ compiler ABI can be done various ways.\n-\n-One. \n-Intel ABI checker. More information can be obtained\n-<a href=\"http://developer.intel.com/software/products/opensource/\">here.</a>\n-\n-Two.\n-The second is yet unreleased, but has been announced on the gcc\n-mailing list. It is yet unspecified if these tools will be freely\n-available, and able to be included in a GNU project. Please contact\n-Mark Mitchell (mark@codesourcery.com) for more details, and current\n-status.\n-\n-Three.\n-Involves using the vlad.consistency test framework. This has also been\n-discussed on the gcc mailing lists.\n-\n-Testing the C++ library ABI can also be done various ways.\n-\n-One. \n-(Brendan Kehoe, Jeff Law suggestion to run 'make check-c++' two ways, \n-one with a new compiler and an old library, and the other with an old\n-compiler and a new library, and look for testsuite regressions)\n-\n-Details on how to set this kind of test up can be found here:\n-http://gcc.gnu.org/ml/gcc/2002-08/msg00142.html\n-\n-Two.  \n-Use the 'make check-abi' rule in the libstdc++-v3 Makefile. \n-\n-This is a proactive check the library ABI. Currently, exported symbol\n-names that are either weak or defined are checked against a last known\n-good baseline. Currently, this baseline is keyed off of 3.2.0\n-binaries, as this was the last time the .so number was incremented. In\n-addition, all exported names are demangled, and the exported objects\n-are checked to make sure they are the same size as the same object in\n-the baseline.\n-\n-This dataset is insufficient, yet a start. Also needed is a\n-comprehensive check for all user-visible types part of the standard\n-library for sizeof() and alignof() changes. \n-\n-Verifying compatible layouts of objects is not even attempted.  It\n-should be possible to use sizeof, alignof, and offsetof to compute\n-offsets for each structure and type in the standard library, saving to\n-another datafile. Then, compute this in a similar way for new\n-binaries, and look for differences.\n-\n-Another approach might be to use the -fdump-class-hierarchy flag to\n-get information. However, currently this approach gives insufficient\n-data for use in library testing, as class data members, their offsets,\n-and other detailed data is not displayed with this flag.\n-(See g++/7470 on how this was used to find bugs.)\n-\n-Perhaps there are other C++ ABI checkers. If so, please notify\n-us. We'd like to know about them!\n-\n-\n-V. Issues not directly addressed, and possible suggestions\n-\n-- what to do about multi-ABI systems (nathan scenario)?\n-\n-  - compatibility libs\n-\n-  --enable-version-specific-runtime-libs\n-\n-  - Alexandre Oliva proposal to have extended name attributes, modify ld\n- \n-  - directory-level versioning\n-\n-- wrapping C++ API's in \"C\" to use the C ABI.\n-\n-\n-V. References\n-\n-ABIcheck, a vague idea of checking ABI compatibility\n-http://abicheck.sourceforge.net/\n-\n-C++ ABI reference\n-http://www.codesourcery.com/cxx-abi/\n-\n-Intel ABI documentation\n-\"Intel\ufffd Compilers for Linux* -Compatibility with the GNU Compilers\"\n-(included in icc 6.0)\n-\n-Sun Solaris 2.9 docs\n-Linker and Libraries Guide (document 816-1386)\n-C++ Migration Guide (document 816-2459)\n-http://docs.sun.com/db/prod/solaris.9\n-http://docs.sun.com/?p=/doc/816-1386&a=load\n-\n-Ulrich Drepper, \"ELF Symbol Versioning\"\n-http://people.redhat.com/drepper/symbol-versioning\n-"}, {"sha": "d1aea5a926ef82976da5666f68459e0d2be652e2", "filename": "libstdc++-v3/docs/html/documentation.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -30,7 +30,7 @@ <h2><a name=\"1\">Introduction</a></h2>\n       <ul>\n          <li><a href=\"17_intro/COPYING\">License</a>\n          - GPL v2 license terms</li>\n-         <li><a href=\"abi.txt\">ABI Policy and Guidelines</a></li>\n+         <li><a href=\"abi.html\">ABI Policy and Guidelines</a></li>\n          <li><a href=\"17_intro/BUGS\">BUGS</a></li>\n          <li><a href=\"17_intro/PROBLEMS\">PROBLEMS</a>\n          - target-specific known issues</li>"}, {"sha": "d5146bb5943fc5f6aa32bd421908c2beda333efa", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -63,9 +63,8 @@\n \n namespace std\n {\n-\n   /// pair holds two objects of arbitrary type.\n-  template <class _T1, class _T2>\n+  template<class _T1, class _T2>\n     struct pair\n     {\n       typedef _T1 first_type;    ///<  @c first_type is the first bound type\n@@ -79,51 +78,51 @@ namespace std\n       /** The default constructor creates @c first and @c second using their\n        *  respective default constructors.  */\n       pair()\n-      : first(), second() {}\n+      : first(), second() { }\n \n       /** Two objects may be passed to a @c pair constructor to be copied.  */\n       pair(const _T1& __a, const _T2& __b)\n-      : first(__a), second(__b) {}\n+      : first(__a), second(__b) { }\n \n       /** There is also a templated copy ctor for the @c pair class itself.  */\n-      template <class _U1, class _U2>\n+      template<class _U1, class _U2>\n         pair(const pair<_U1, _U2>& __p)\n-\t: first(__p.first), second(__p.second) {}\n+\t: first(__p.first), second(__p.second) { }\n     };\n \n   /// Two pairs of the same type are equal iff their members are equal.\n-  template <class _T1, class _T2>\n+  template<class _T1, class _T2>\n     inline bool\n     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n     { return __x.first == __y.first && __x.second == __y.second; }\n \n   /// <http://gcc.gnu.org/onlinedocs/libstdc++/20_util/howto.html#pairlt>\n-  template <class _T1, class _T2>\n+  template<class _T1, class _T2>\n     inline bool\n     operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n     { return __x.first < __y.first\n \t     || (!(__y.first < __x.first) && __x.second < __y.second); }\n \n   /// Uses @c operator== to find the result.\n-  template <class _T1, class _T2>\n+  template<class _T1, class _T2>\n     inline bool\n     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n     { return !(__x == __y); }\n \n   /// Uses @c operator< to find the result.\n-  template <class _T1, class _T2>\n+  template<class _T1, class _T2>\n     inline bool\n     operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n     { return __y < __x; }\n \n   /// Uses @c operator< to find the result.\n-  template <class _T1, class _T2>\n+  template<class _T1, class _T2>\n     inline bool\n     operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n     { return !(__y < __x); }\n \n   /// Uses @c operator< to find the result.\n-  template <class _T1, class _T2>\n+  template<class _T1, class _T2>\n     inline bool\n     operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n     { return !(__x < __y); }\n@@ -138,18 +137,11 @@ namespace std\n    *  but LWG issue #181 says they should be passed by const value.  We follow\n    *  the LWG by default.\n    */\n-  template <class _T1, class _T2>\n-\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // 181.  make_pair() unintended behavior\n-  inline pair<_T1, _T2>\n-  make_pair(_T1 __x, _T2 __y)\n-  { return pair<_T1, _T2>(__x, __y); }\n-\n+  template<class _T1, class _T2>\n+    inline pair<_T1, _T2>\n+    make_pair(_T1 __x, _T2 __y) { return pair<_T1, _T2>(__x, __y); }\n } // namespace std\n \n #endif /* _PAIR_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "9e11ac30ae97bb4588ae6b49a6ed4423a638daac", "filename": "libstdc++-v3/testsuite/Makefile.am", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -39,18 +39,14 @@ GLIBCXX_DIR=${glibcxx_builddir}/src/.libs\n CXXLINK = \\\n \t$(LIBTOOL) --tag=CXX --mode=link $(CXX) \\\n \t-R $(GLIBGCC_DIR) -R $(GLIBCXX_DIR) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@\n-\n-# Generated lists of files to run.  All of these names are valid make\n-# targets, if you wish to generate a list manually.\n-lists_of_files = \\\n-   testsuite_files \\\n-   testsuite_files_interactive \\\n-   testsuite_files_performance\n+\t$(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) -lv3test -L. -o $@\n \n ## Build support library.\n noinst_LIBRARIES = libv3test.a\n-libv3test_a_SOURCES = testsuite_hooks.cc testsuite_allocator.cc\n+libv3test_a_SOURCES = \\\n+\ttestsuite_abi.cc \\\n+\ttestsuite_allocator.cc \\\n+\ttestsuite_hooks.cc \n \n ## Build support utilities.\n if GLIBCXX_TEST_ABI\n@@ -59,6 +55,7 @@ else\n noinst_PROGRAMS =\n endif\n abi_check_SOURCES = abi_check.cc\n+abi_check_DEPENDENCIES = libv3test.a\n \n all-local: stamp_wchar testsuite_files\n \n@@ -70,6 +67,14 @@ else\n stamp_wchar:\n endif\n \n+# Generated lists of files to run.  All of these names are valid make\n+# targets, if you wish to generate a list manually.\n+lists_of_files = \\\n+   testsuite_files \\\n+   testsuite_files_interactive \\\n+   testsuite_files_performance\n+\n+\n # We need more things in site.exp, but automake completely controls the\n # creation of that file; there's no way to append to it without messing up\n # the dependancy chains.  So we overrule automake.  This rule is exactly"}, {"sha": "b74f2b36cdbc9f4f01f0b68b49f508c43da622a5", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -58,8 +58,8 @@ ARFLAGS = cru\n LIBRARIES = $(noinst_LIBRARIES)\n libv3test_a_AR = $(AR) $(ARFLAGS)\n libv3test_a_LIBADD =\n-am_libv3test_a_OBJECTS = testsuite_hooks.$(OBJEXT) \\\n-\ttestsuite_allocator.$(OBJEXT)\n+am_libv3test_a_OBJECTS = testsuite_abi.$(OBJEXT) \\\n+\ttestsuite_allocator.$(OBJEXT) testsuite_hooks.$(OBJEXT)\n libv3test_a_OBJECTS = $(am_libv3test_a_OBJECTS)\n PROGRAMS = $(noinst_PROGRAMS)\n am_abi_check_OBJECTS = abi_check.$(OBJEXT)\n@@ -272,8 +272,16 @@ GLIBCXX_DIR = ${glibcxx_builddir}/src/.libs\n CXXLINK = \\\n \t$(LIBTOOL) --tag=CXX --mode=link $(CXX) \\\n \t-R $(GLIBGCC_DIR) -R $(GLIBCXX_DIR) \\\n-\t$(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@\n+\t$(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) -lv3test -L. -o $@\n \n+noinst_LIBRARIES = libv3test.a\n+libv3test_a_SOURCES = \\\n+\ttestsuite_abi.cc \\\n+\ttestsuite_allocator.cc \\\n+\ttestsuite_hooks.cc \n+\n+abi_check_SOURCES = abi_check.cc\n+abi_check_DEPENDENCIES = libv3test.a\n \n # Generated lists of files to run.  All of these names are valid make\n # targets, if you wish to generate a list manually.\n@@ -282,9 +290,6 @@ lists_of_files = \\\n    testsuite_files_interactive \\\n    testsuite_files_performance\n \n-noinst_LIBRARIES = libv3test.a\n-libv3test_a_SOURCES = testsuite_hooks.cc testsuite_allocator.cc\n-abi_check_SOURCES = abi_check.cc\n baseline_file = ${baseline_dir}/baseline_symbols.txt\n extract_symvers = $(glibcxx_srcdir)/scripts/extract_symvers\n "}, {"sha": "18c8b7be9b6e51c075c0a44b90ff1feb5fec09b2", "filename": "libstdc++-v3/testsuite/abi_check.cc", "status": "modified", "additions": 63, "deletions": 426, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2Fabi_check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2Fabi_check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fabi_check.cc?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -1,456 +1,93 @@\n-// Utility for libstdc++ ABI analysis -*- C++ -*-\n-\n-// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n+// -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n \n // Benjamin Kosnik  <bkoz@redhat.com>\n // Blame subsequent hacks on Loren J. Rittle <ljrittle@acm.org>, Phil\n // Edwards <pme@gcc.gnu.org>, and a cast of dozens at libstdc++@gcc.gnu.org.\n-\n-#include <string>\n-#include <ext/hash_map>\n-#include <deque>\n-#include <sstream>\n-#include <fstream>\n+ \n+#include \"testsuite_abi.h\"\n #include <iostream>\n-#include <cxxabi.h>\n-#include <stdlib.h>    // for system(3)\n-#include <unistd.h>    // for access(2)\n-\n-struct symbol_info\n-{\n-  enum category { none, function, object, error };\n-  category \ttype;  \n-  std::string \tname;\n-  std::string \tdemangled_name;\n-  int \t\tsize;\n-  std::string \tversion_name;\n-\n-  symbol_info() : type(none), size(0) { }\n-\n-  symbol_info(const symbol_info& other) \n-  : type(other.type), name(other.name), demangled_name(other.demangled_name), \n-   size(other.size), version_name(other.version_name) { }\n-};\n-\n-namespace __gnu_cxx\n-{\n-  using namespace std;\n-\n-  template<> \n-    struct hash<string>\n-    {\n-      size_t operator()(const string& s) const \n-      { \n-\tconst collate<char>& c = use_facet<collate<char> >(locale::classic());\n-\treturn c.hash(s.c_str(), s.c_str() + s.size());\n-      }\n-    }; \n-}\n-\n-typedef std::deque<std::string>\t\t\t\tsymbol_names;\n-typedef __gnu_cxx::hash_map<std::string, symbol_info> \tsymbol_infos;\n-\n-\n-bool\n-check_version(const symbol_info& test, bool added = false)\n-{\n-  typedef std::vector<std::string> compat_list;\n-  static compat_list known_versions;\n-  if (known_versions.empty())\n-    {\n-      known_versions.push_back(\"GLIBCPP_3.2\"); // base version\n-      known_versions.push_back(\"GLIBCPP_3.2.1\");\n-      known_versions.push_back(\"GLIBCPP_3.2.2\");\n-      known_versions.push_back(\"GLIBCPP_3.2.3\"); // gcc-3.3.0\n-      known_versions.push_back(\"GLIBCXX_3.4\");\n-      known_versions.push_back(\"CXXABI_1.2\");\n-      known_versions.push_back(\"CXXABI_1.2.1\");\n-      known_versions.push_back(\"CXXABI_1.3\");\n-    }\n-  compat_list::iterator begin = known_versions.begin();\n-  compat_list::iterator end = known_versions.end();\n-\n-  // Check version names for compatibility...\n-  compat_list::iterator it1 = find(begin, end, test.version_name);\n-  \n-  // Check for weak label.\n-  compat_list::iterator it2 = find(begin, end, test.name);\n-\n-  // Check that added symbols aren't added in the base version.\n-  bool compat = true;\n-  if (added && test.version_name == known_versions[0])\n-    compat = false;\n-\n-  if (it1 == end && it2 == end)\n-    compat = false;\n-\n-  return compat;\n-}\n-\n-bool \n-check_compatible(const symbol_info& lhs, const symbol_info& rhs, \n-\t\t bool verbose = false)\n-{\n-  using namespace std;\n-  bool ret = true;\n-  const char tab = '\\t';\n-\n-  // Check to see if symbol_infos are compatible.\n-  if (lhs.type != rhs.type)\n-    {\n-      ret = false;\n-      if (verbose)\n-\t{\n-\t  cout << tab << \"incompatible types\" << endl;\n-\t}\n-    }\n-  \n-  if (lhs.name != rhs.name)\n-    {\n-      ret = false;\n-      if (verbose)\n-\t{\n-\t  cout << tab << \"incompatible names\" << endl;\n-\t}\n-    }\n-\n-  if (lhs.size != rhs.size)\n-    {\n-      ret = false;\n-      if (verbose)\n-\t{\n-\t  cout << tab << \"incompatible sizes\" << endl;\n-\t  cout << tab << lhs.size << endl;\n-\t  cout << tab << rhs.size << endl;\n-\t}\n-    }\n-\n-  if (lhs.version_name != rhs.version_name \n-      && !check_version(lhs) && !check_version(rhs))\n-    {\n-      ret = false;\n-      if (verbose)\n-\t{\n-\t  cout << tab << \"incompatible versions\" << endl;\n-\t  cout << tab << lhs.version_name << endl;\n-\t  cout << tab << rhs.version_name << endl;\n-\t}\n-    }\n-\n-  if (verbose)\n-    cout << endl;\n-\n-  return ret;\n-}\n-\n-const char*\n-demangle(const std::string& mangled)\n-{\n-  const char* name;\n-  if (mangled[0] != '_' || mangled[1] != 'Z')\n-    {\n-      // This is not a mangled symbol, thus has \"C\" linkage.\n-      name = mangled.c_str();\n-    }\n-  else\n-    {\n-      // Use __cxa_demangle to demangle.\n-      int status = 0;\n-      name = abi::__cxa_demangle(mangled.c_str(), 0, 0, &status);\n-      if (!name)\n-\t{\n-\t  switch (status)\n-\t    {\n-\t    case 0:\n-\t      name = \"error code = 0: success\";\n-\t      break;\n-\t    case -1:\n-\t      name = \"error code = -1: memory allocation failure\";\n-\t      break;\n-\t    case -2:\n-\t      name = \"error code = -2: invalid mangled name\";\n-\t      break;\n-\t    case -3:\n-\t      name = \"error code = -3: invalid arguments\";\n-\t      break;\n-\t    default:\n-\t      name = \"error code unknown - who knows what happened\";\n-\t    }\n-\t}\n-    }\n-  return name;\n-}\n-\n-void \n-line_to_symbol_info(std::string& input, symbol_info& output)\n-{\n-  using namespace std;\n-  const char delim = ':';\n-  const char version_delim = '@';\n-  const string::size_type npos = string::npos;\n-  string::size_type n = 0;\n-\n-  // Set the type.\n-  if (input.find(\"FUNC\") == 0)\n-    output.type = symbol_info::function;\n-  else if (input.find(\"OBJECT\") == 0)\n-    output.type = symbol_info::object;\n-  else\n-    output.type = symbol_info::error;\n-  n = input.find_first_of(delim);\n-  if (n != npos)\n-    input.erase(input.begin(), input.begin() + n + 1);\n-\n-  // Iff object, get size info.\n-  if (output.type == symbol_info::object)\n-    {\n-      n = input.find_first_of(delim);\n-      if (n != npos)\n-\t{\n-\t  string size(input.begin(), input.begin() + n);\n-\t  istringstream iss(size);\n-\t  int x;\n-\t  iss >> x;\n-\t  if (!iss.fail())\n-\t    output.size = x;\n-\t  input.erase(input.begin(), input.begin() + n + 1);\n-\t}\n-    }\n-\n-  // Set the name.\n-  n = input.find_first_of(version_delim);\n-  if (n != npos)\n-    {\n-      // Found version string.\n-      output.name = string(input.begin(), input.begin() + n);\n-      n = input.find_last_of(version_delim);\n-      input.erase(input.begin(), input.begin() + n + 1);\n-\n-      // Set version name.\n-      output.version_name = input;\n-    }\n-  else\n-    {\n-      // No versioning info.\n-      output.name = string(input.begin(), input.end());\n-      input.erase(input.begin(), input.end());\n-    }\n-\n-  // Set the demangled name.\n-  output.demangled_name = demangle(output.name);\n-}\n-\n-void\n-create_symbol_data(const char* file, symbol_infos& symbols, \n-\t\t   symbol_names& names)\n-{\n-  // Parse list of symbols in file into vectors of symbol_info.\n-  // For 3.2.0 on x86/linux, this usually is\n-  // 947 non-weak symbols\n-  // 2084 weak symbols\n-  using namespace std;\n-  ifstream ifs(file); \n-  if (ifs.is_open())\n-    {\n-      // Organize input into container of symbol_info objects.\n-      const string empty;\n-      string line = empty;\n-      while (getline(ifs, line).good())\n-\t{\n-\t  symbol_info symbol;\n-\t  line_to_symbol_info(line, symbol);\n-\t  symbols[symbol.name] = symbol;\n-\t  names.push_back(symbol.name);\n-\t  line = empty;\n-\t}\n-    }\n-}\n-\n-void\n-report_symbol_info(const symbol_info& symbol, std::size_t n, bool ret = true)\n-{\n-  using namespace std;\n-  const char tab = '\\t';\n-\n-  // Add any other information to display here.\n-  cout << tab << symbol.demangled_name << endl;\n-  cout << tab << symbol.name << endl;\n-  cout << tab << symbol.version_name << endl;\n-\n-  if (ret)\n-    cout << endl;\n-}\n-\n \n int\n main(int argc, char** argv)\n {\n   using namespace std;\n \n   // Get arguments.  (Heading towards getopt_long, I can feel it.)\n-  bool verbose = false;\n   string argv1 = argc > 1 ? argv[1] : \"\";\n   if (argv1 == \"--help\" || argc < 4)\n     {\n       cerr << \"usage: abi_check --check         current baseline\\n\"\n               \"                 --check-verbose current baseline\\n\"\n-              \"                 --help\\n\\n\"\n-              \"Where CURRENT is a file containing the current results from\\n\"\n-              \"extract_symvers, and BASELINE is one from config/abi.\\n\"\n+              \"                 --examine       symbol current\\n\"\n+              \"                 --help\\n\"\n+\t      \"\\n\"\n+              \"All arguments are string literals.\\n\"\n+\t      \"CURRENT is a file generated byextract_symvers.\\n\"\n+              \"BASELINE is a file from config/abi.\\n\"\n+              \"SYMBOL is a mangled name.\\n\"\n \t   << endl;\n       exit(1);\n     }\n-  else if (argv1 == \"--check-verbose\")\n-    verbose = true;\n-\n-  // Quick sanity/setup check for arguments.\n-  const char* test_file = argv[2];\n-  const char* baseline_file = argv[3];\n-  if (access(test_file, R_OK) != 0)\n-    {\n-      cerr << \"Cannot read symbols file \" << test_file\n-           << \", did you forget to build first?\" << endl;\n-      exit(1);\n-    }\n-  if (access(baseline_file, R_OK) != 0)\n-    {\n-      cerr << \"Cannot read baseline file \" << baseline_file << endl;\n-      exit(1);\n-    }\n-\n-  // Input both lists of symbols into container.\n-  symbol_infos  baseline_symbols;\n-  symbol_names  baseline_names;\n-  symbol_infos  test_symbols;\n-  symbol_names  test_names;\n-  create_symbol_data(baseline_file, baseline_symbols, baseline_names);\n-  create_symbol_data(test_file, test_symbols, test_names);\n-\n-  //  Sanity check results.\n-  const symbol_names::size_type baseline_size = baseline_names.size();\n-  const symbol_names::size_type test_size = test_names.size();\n-  if (!baseline_size || !test_size)\n-    {\n-      cerr << \"Problems parsing the list of exported symbols.\" << endl;\n-      exit(2);\n-    }\n-\n-  // Sort out names.\n-  // Assuming baseline_names, test_names are both unique w/ no duplicates.\n-  //\n-  // The names added to missing_names are baseline_names not found in\n-  // test_names \n-  // -> symbols that have been deleted.\n-  //\n-  // The names added to added_names are test_names are names not in\n-  // baseline_names\n-  // -> symbols that have been added.\n-  symbol_names shared_names;\n-  symbol_names missing_names;\n-  symbol_names added_names = test_names;\n-  for (size_t i = 0; i < baseline_size; ++i)\n-    {\n-      string what(baseline_names[i]);\n-      symbol_names::iterator end = added_names.end();\n-      symbol_names::iterator it = find(added_names.begin(), end, what);\n-      if (it != end)\n+  \n+  if (argv1.find(\"--check\") != string::npos)\n+    {\n+      bool verbose = false;\n+      if (argv1 == \"--check-verbose\")\n+\tverbose = true;\n+      \n+      // Quick sanity/setup check for arguments.\n+      const char* test_file = argv[2];\n+      const char* baseline_file = argv[3];\n+      if (access(test_file, R_OK) != 0)\n \t{\n-\t  // Found.\n-\t  shared_names.push_back(what);\n-\t  added_names.erase(it);\n+\t  cerr << \"Cannot read symbols file \" << test_file\n+\t       << \", did you forget to build first?\" << endl;\n+\t  exit(1);\n \t}\n-      else\n-\t  missing_names.push_back(what);\n-    }\n-\n-  // Check missing names for compatibility.\n-  typedef pair<symbol_info, symbol_info> symbol_pair;\n-  vector<symbol_pair> incompatible;\n-  for (size_t i = 0; i < missing_names.size(); ++i)\n-    {\n-      symbol_info base = baseline_symbols[missing_names[i]];\n-      incompatible.push_back(symbol_pair(base, base));\n-    }\n-\n-  // Check shared names for compatibility.\n-  for (size_t i = 0; i < shared_names.size(); ++i)\n-    {\n-      symbol_info base = baseline_symbols[shared_names[i]];\n-      symbol_info test = test_symbols[shared_names[i]];\n-      if (!check_compatible(base, test))\n-\tincompatible.push_back(symbol_pair(base, test));\n-    }\n-\n-  // Check added names for compatibility.\n-  for (size_t i = 0; i < added_names.size(); ++i)\n-    {\n-      symbol_info test = test_symbols[added_names[i]];\n-      if (!check_version(test, true))\n-\tincompatible.push_back(symbol_pair(test, test));\n-    }\n-\n-  // Report results.\n-  if (verbose && added_names.size())\n-    {\n-      cout << added_names.size() << \" added symbols \" << endl;\n-      for (size_t j = 0; j < added_names.size() ; ++j)\n-\treport_symbol_info(test_symbols[added_names[j]], j + 1);\n-    }\n-  \n-  if (verbose && missing_names.size())\n-    {\n-      cout << missing_names.size() << \" missing symbols \" << endl;\n-      for (size_t j = 0; j < missing_names.size() ; ++j)\n-\treport_symbol_info(baseline_symbols[missing_names[j]], j + 1);\n+      if (access(baseline_file, R_OK) != 0)\n+\t{\n+\t  cerr << \"Cannot read baseline file \" << baseline_file << endl;\n+\texit(1);\n+\t}\n+      compare_symbols(baseline_file, test_file, verbose);\n     }\n   \n-  if (verbose && incompatible.size())\n+  if (argv1 == \"--examine\")\n     {\n-      cout << incompatible.size() << \" incompatible symbols \" << endl;\n-      for (size_t j = 0; j < incompatible.size() ; ++j)\n+      const char* file = argv[3];\n+      if (access(file, R_OK) != 0)\n \t{\n-\t  // First, report name.\n-\t  const symbol_info& base = incompatible[j].first;\n-\t  const symbol_info& test = incompatible[j].second;\n-\t  report_symbol_info(test, j + 1, false);\n-\t  \n-\t  // Second, report reason or reasons incompatible.\n-\t  check_compatible(base, test, true);\n+\t  cerr << \"Cannot read symbol file \" << file << endl;\n+\t  exit(1);\n \t}\n+      examine_symbol(argv[2], file);\n     }\n-  \n-  cout << \"\\n\\t\\t=== libstdc++-v3 check-abi Summary ===\" << endl;\n-  cout << endl;\n-  cout << \"# of added symbols:\\t\\t \" << added_names.size() << endl;\n-  cout << \"# of missing symbols:\\t\\t \" << missing_names.size() << endl;\n-  cout << \"# of incompatible symbols:\\t \" << incompatible.size() << endl;\n-  cout << endl;\n-  cout << \"using: \" << baseline_file << endl;\n-\n   return 0;\n }"}, {"sha": "552da1bca0eca650e79a2275cb1a141726868db0", "filename": "libstdc++-v3/testsuite/testsuite_abi.cc", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_abi.cc?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -0,0 +1,462 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+// Benjamin Kosnik  <bkoz@redhat.com>\n+\n+#include \"testsuite_abi.h\"\n+#include <sstream>\n+#include <fstream>\n+#include <iostream>\n+\n+using namespace std;\n+\n+void \n+symbol::init(string& data)\n+{\n+  const char delim = ':';\n+  const char version_delim = '@';\n+  const string::size_type npos = string::npos;\n+  string::size_type n = 0;\n+\n+  // Set the type.\n+  if (data.find(\"FUNC\") == 0)\n+    type = symbol::function;\n+  else if (data.find(\"OBJECT\") == 0)\n+    type = symbol::object;\n+  else\n+    type = symbol::error;\n+  n = data.find_first_of(delim);\n+  if (n != npos)\n+    data.erase(data.begin(), data.begin() + n + 1);\n+\n+  // Iff object, get size info.\n+  if (type == symbol::object)\n+    {\n+      n = data.find_first_of(delim);\n+      if (n != npos)\n+\t{\n+\t  string size(data.begin(), data.begin() + n);\n+\t  istringstream iss(size);\n+\t  int x;\n+\t  iss >> x;\n+\t  if (!iss.fail())\n+\t    size = x;\n+\t  data.erase(data.begin(), data.begin() + n + 1);\n+\t}\n+    }\n+\n+  // Set the name.\n+  n = data.find_first_of(version_delim);\n+  if (n != npos)\n+    {\n+      // Found version string.\n+      name = string(data.begin(), data.begin() + n);\n+      n = data.find_last_of(version_delim);\n+      data.erase(data.begin(), data.begin() + n + 1);\n+\n+      // Set version name.\n+      version_name = data;\n+    }\n+  else\n+    {\n+      // No versioning info.\n+      name = string(data.begin(), data.end());\n+      data.erase(data.begin(), data.end());\n+    }\n+\n+  // Set the demangled name.\n+  demangled_name = demangle(name);\n+}\n+\n+void\n+symbol::print() const\n+{\n+  const char tab = '\\t';\n+  cout << tab << name << endl;\n+  cout << tab << demangled_name << endl;\n+  cout << tab << version_name << endl;\n+\n+  string type_string;\n+  switch (type)\n+    {\n+    case none:\n+      type_string = \"none\";\n+      break;\n+    case function:\n+      type_string = \"function\";\n+      break;\n+    case object:\n+      type_string = \"object\";\n+      break;\n+    case error:\n+      type_string = \"error\";\n+      break;\n+    default:\n+      type_string = \"<default>\";\n+    }\n+  cout << tab << type_string << endl;\n+  \n+  if (type == object)\n+    cout << tab << size << endl;\n+\n+  string status_string;\n+  switch (status)\n+    {\n+    case unknown:\n+      status_string = \"unknown\";\n+      break;\n+    case added:\n+      status_string = \"added\";\n+      break;\n+    case subtracted:\n+      status_string = \"subtracted\";\n+      break;\n+    case compatible:\n+      status_string = \"compatible\";\n+      break;\n+    case incompatible:\n+      status_string = \"incompatible\";\n+      break;\n+    default:\n+      status_string = \"<default>\";\n+    }\n+  cout << tab << status_string << endl;\n+}\n+\n+\n+bool\n+check_version(const symbol& test, bool added)\n+{\n+  typedef std::vector<std::string> compat_list;\n+  static compat_list known_versions;\n+  if (known_versions.empty())\n+    {\n+      known_versions.push_back(\"GLIBCPP_3.2\"); // base version\n+      known_versions.push_back(\"GLIBCPP_3.2.1\");\n+      known_versions.push_back(\"GLIBCPP_3.2.2\");\n+      known_versions.push_back(\"GLIBCPP_3.2.3\"); // gcc-3.3.0\n+      known_versions.push_back(\"GLIBCXX_3.4\");\n+      known_versions.push_back(\"CXXABI_1.2\");\n+      known_versions.push_back(\"CXXABI_1.2.1\");\n+      known_versions.push_back(\"CXXABI_1.3\");\n+    }\n+  compat_list::iterator begin = known_versions.begin();\n+  compat_list::iterator end = known_versions.end();\n+\n+  // Check version names for compatibility...\n+  compat_list::iterator it1 = find(begin, end, test.version_name);\n+  \n+  // Check for weak label.\n+  compat_list::iterator it2 = find(begin, end, test.name);\n+\n+  // Check that added symbols aren't added in the base version.\n+  bool compat = true;\n+  if (added && test.version_name == known_versions[0])\n+    compat = false;\n+\n+  if (it1 == end && it2 == end)\n+    compat = false;\n+\n+  return compat;\n+}\n+\n+bool \n+check_compatible(const symbol& lhs, const symbol& rhs, bool verbose)\n+{\n+  bool ret = true;\n+  const char tab = '\\t';\n+\n+  // Check to see if symbol_objects are compatible.\n+  if (lhs.type != rhs.type)\n+    {\n+      ret = false;\n+      if (verbose)\n+\tcout << tab << \"incompatible types\" << endl;\n+    }\n+  \n+  if (lhs.name != rhs.name)\n+    {\n+      ret = false;\n+      if (verbose)\n+\tcout << tab << \"incompatible names\" << endl;\n+    }\n+\n+  if (lhs.size != rhs.size)\n+    {\n+      ret = false;\n+      if (verbose)\n+\t{\n+\t  cout << tab << \"incompatible sizes\" << endl;\n+\t  cout << tab << lhs.size << endl;\n+\t  cout << tab << rhs.size << endl;\n+\t}\n+    }\n+\n+  if (lhs.version_name != rhs.version_name \n+      && !check_version(lhs) && !check_version(rhs))\n+    {\n+      ret = false;\n+      if (verbose)\n+\t{\n+\t  cout << tab << \"incompatible versions\" << endl;\n+\t  cout << tab << lhs.version_name << endl;\n+\t  cout << tab << rhs.version_name << endl;\n+\t}\n+    }\n+\n+  if (verbose)\n+    cout << endl;\n+\n+  return ret;\n+}\n+\n+\n+bool\n+has_symbol(const string& mangled, const symbols& s) throw()\n+{\n+  const symbol_names& names = s.first;\n+  symbol_names::const_iterator i = find(names.begin(), names.end(), mangled);\n+  return i != names.end();\n+}\n+\n+symbol&\n+get_symbol(const string& mangled, const symbols& s)\n+{\n+  const symbol_names& names = s.first;\n+  symbol_names::const_iterator i = find(names.begin(), names.end(), mangled);\n+  if (i != names.end())\n+    {\n+      symbol_objects objects = s.second;\n+      return objects[mangled];\n+    }\n+  else\n+    {\n+      ostringstream os;\n+      os << \"get_symbol failed for symbol \" << mangled;\n+      throw symbol_error(os.str());\n+    }\n+}\n+\n+void \n+examine_symbol(const char* name, const char* file)\n+{\n+  try\n+    {\n+      symbols s = create_symbols(file);\n+      symbol& sym = get_symbol(name, s);\n+      sym.print();\n+    }\n+  catch(...)\n+    { throw; }\n+}\n+\n+void \n+compare_symbols(const char* baseline_file, const char* test_file, \n+\t\tbool verbose)\n+{\n+  // Input both lists of symbols into container.\n+  symbols baseline = create_symbols(baseline_file);\n+  symbols test = create_symbols(test_file);\n+  symbol_names& baseline_names = baseline.first;\n+  symbol_objects& baseline_objects = baseline.second;\n+  symbol_names& test_names = test.first;\n+  symbol_objects& test_objects = test.second;\n+\n+  //  Sanity check results.\n+  const symbol_names::size_type baseline_size = baseline_names.size();\n+  const symbol_names::size_type test_size = test_names.size();\n+  if (!baseline_size || !test_size)\n+    {\n+      cerr << \"Problems parsing the list of exported symbols.\" << endl;\n+      exit(2);\n+    }\n+\n+  // Sort out names.\n+  // Assuming baseline_names, test_names are both unique w/ no duplicates.\n+  //\n+  // The names added to missing_names are baseline_names not found in\n+  // test_names \n+  // -> symbols that have been deleted.\n+  //\n+  // The names added to added_names are test_names are names not in\n+  // baseline_names\n+  // -> symbols that have been added.\n+  symbol_names shared_names;\n+  symbol_names missing_names;\n+  symbol_names added_names = test_names;\n+  for (size_t i = 0; i < baseline_size; ++i)\n+    {\n+      string what(baseline_names[i]);\n+      symbol_names::iterator end = added_names.end();\n+      symbol_names::iterator it = find(added_names.begin(), end, what);\n+      if (it != end)\n+\t{\n+\t  // Found.\n+\t  shared_names.push_back(what);\n+\t  added_names.erase(it);\n+\t}\n+      else\n+\t  missing_names.push_back(what);\n+    }\n+\n+  // Check missing names for compatibility.\n+  typedef pair<symbol, symbol> symbol_pair;\n+  vector<symbol_pair> incompatible;\n+  for (size_t i = 0; i < missing_names.size(); ++i)\n+    {\n+      symbol base = baseline_objects[missing_names[i]];\n+      incompatible.push_back(symbol_pair(base, base));\n+    }\n+\n+  // Check shared names for compatibility.\n+  for (size_t i = 0; i < shared_names.size(); ++i)\n+    {\n+      symbol base = baseline_objects[shared_names[i]];\n+      symbol test = test_objects[shared_names[i]];\n+      if (!check_compatible(base, test))\n+\tincompatible.push_back(symbol_pair(base, test));\n+    }\n+\n+  // Check added names for compatibility.\n+  for (size_t i = 0; i < added_names.size(); ++i)\n+    {\n+      symbol test = test_objects[added_names[i]];\n+      if (!check_version(test, true))\n+\tincompatible.push_back(symbol_pair(test, test));\n+    }\n+\n+  // Report results.\n+  if (verbose && added_names.size())\n+    {\n+      cout << added_names.size() << \" added symbols \" << endl;\n+      for (size_t j = 0; j < added_names.size() ; ++j)\n+\ttest_objects[added_names[j]].print();\n+    }\n+  \n+  if (verbose && missing_names.size())\n+    {\n+      cout << missing_names.size() << \" missing symbols \" << endl;\n+      for (size_t j = 0; j < missing_names.size() ; ++j)\n+\tbaseline_objects[missing_names[j]].print();\n+    }\n+  \n+  if (verbose && incompatible.size())\n+    {\n+      cout << incompatible.size() << \" incompatible symbols \" << endl;\n+      for (size_t j = 0; j < incompatible.size() ; ++j)\n+\t{\n+\t  // First, report name.\n+\t  const symbol& base = incompatible[j].first;\n+\t  const symbol& test = incompatible[j].second;\n+\t  test.print();\n+\t  \n+\t  // Second, report reason or reasons incompatible.\n+\t  check_compatible(base, test, true);\n+\t}\n+    }\n+  \n+  cout << \"\\n\\t\\t=== libstdc++-v3 check-abi Summary ===\" << endl;\n+  cout << endl;\n+  cout << \"# of added symbols:\\t\\t \" << added_names.size() << endl;\n+  cout << \"# of missing symbols:\\t\\t \" << missing_names.size() << endl;\n+  cout << \"# of incompatible symbols:\\t \" << incompatible.size() << endl;\n+  cout << endl;\n+  cout << \"using: \" << baseline_file << endl;\n+}\n+\n+\n+symbols\n+create_symbols(const char* file)\n+{\n+  symbols s;\n+  ifstream ifs(file);\n+  if (ifs.is_open())\n+    {\n+      // Organize file data into container of symbol objects.\n+      symbol_names& names = s.first;\n+      symbol_objects& objects = s.second;\n+      const string empty;\n+      string line = empty;\n+      while (getline(ifs, line).good())\n+\t{\n+\t  symbol tmp;\n+\t  tmp.init(line);\n+\t  objects[tmp.name] = tmp;\n+\t  names.push_back(tmp.name);\n+\t  line = empty;\n+\t}\n+    }\n+  else\n+    {\n+      ostringstream os;\n+      os << \"create_symbols failed for file \" << file;\n+      throw runtime_error(os.str());\n+    }\n+  return s;\n+}\n+\n+\n+const char*\n+demangle(const std::string& mangled)\n+{\n+  const char* name;\n+  if (mangled[0] != '_' || mangled[1] != 'Z')\n+    {\n+      // This is not a mangled symbol, thus has \"C\" linkage.\n+      name = mangled.c_str();\n+    }\n+  else\n+    {\n+      // Use __cxa_demangle to demangle.\n+      int status = 0;\n+      name = abi::__cxa_demangle(mangled.c_str(), 0, 0, &status);\n+      if (!name)\n+\t{\n+\t  switch (status)\n+\t    {\n+\t    case 0:\n+\t      name = \"error code = 0: success\";\n+\t      break;\n+\t    case -1:\n+\t      name = \"error code = -1: memory allocation failure\";\n+\t      break;\n+\t    case -2:\n+\t      name = \"error code = -2: invalid mangled name\";\n+\t      break;\n+\t    case -3:\n+\t      name = \"error code = -3: invalid arguments\";\n+\t      break;\n+\t    default:\n+\t      name = \"error code unknown - who knows what happened\";\n+\t    }\n+\t}\n+    }\n+  return name;\n+}\n+"}, {"sha": "ebacb6a46e8fc3ce6eeb67f529ad133865a22637", "filename": "libstdc++-v3/testsuite/testsuite_abi.h", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_abi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b260c20138daad0b7507cdd555025bb84bf2000/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_abi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_abi.h?ref=4b260c20138daad0b7507cdd555025bb84bf2000", "patch": "@@ -0,0 +1,129 @@\n+// -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+// Benjamin Kosnik  <bkoz@redhat.com>\n+\n+#include <string>\n+#include <stdexcept>\n+#include <deque>\n+#include <ext/hash_map>\n+#include <cxxabi.h>\n+\n+// Encapsulates symbol characteristics.\n+struct symbol\n+{\n+  enum category { none, function, object, error };\n+  enum designation { unknown, added, subtracted, compatible, incompatible };\n+  enum compatibility \n+    { \n+      compat_type = 1, \n+      compat_name = 2, \n+      compat_size = 4, \n+      compat_version = 8 \n+    };\n+\n+  category \ttype;\n+  std::string \tname;\n+  std::string \tdemangled_name;\n+  int \t\tsize;\n+  std::string \tversion_name;\n+  designation\tstatus;\n+\n+  symbol() : type(none), size(0), status(unknown) { }\n+\n+  symbol(const symbol& other) \n+  : type(other.type), name(other.name), demangled_name(other.demangled_name), \n+   size(other.size), version_name(other.version_name),\n+   status(other.status) { }\n+\n+  void\n+  print() const;\n+\n+  void\n+  init(std::string& data);\n+};\n+\n+struct symbol_error : public std::logic_error\n+{\n+  explicit symbol_error(const std::string& s) : std::logic_error(s) { }\n+};\n+\n+\n+typedef __gnu_cxx::hash_map<std::string, symbol> \tsymbol_objects;\n+\n+typedef std::deque<std::string>\t\t\t\tsymbol_names;\n+\n+typedef std::pair<symbol_names, symbol_objects>\t\tsymbols;\n+\n+\n+// Check.\n+bool\n+check_version(const symbol& test, bool added = false);\n+\n+bool \n+check_compatible(const symbol& lhs, const symbol& rhs, bool verbose = false);\n+\n+\n+// Examine.\n+bool\n+has_symbol(const std::string& mangled, const symbols& list) throw();\n+\n+symbol&\n+get_symbol(const std::string& mangled, const symbols& list);\n+\n+extern \"C\" void\n+examine_symbol(const char* name, const char* file);\n+\n+extern \"C\" void\n+compare_symbols(const char* baseline_file, const char* test_file, bool verb);\n+\n+\n+// Util.\n+symbols\n+create_symbols(const char* file);\n+\n+const char*\n+demangle(const std::string& mangled);\n+\n+\n+// Specialization.\n+namespace __gnu_cxx\n+{\n+  using namespace std;\n+\n+  template<> \n+    struct hash<string>\n+    {\n+      size_t operator()(const string& s) const \n+      { \n+\tconst collate<char>& c = use_facet<collate<char> >(locale::classic());\n+\treturn c.hash(s.c_str(), s.c_str() + s.size());\n+      }\n+    }; \n+}"}]}