{"sha": "656412552b7c8d29090dfec239f51aa33f760c77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU2NDEyNTUyYjdjOGQyOTA5MGRmZWMyMzlmNTFhYTMzZjc2MGM3Nw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2018-05-29T09:42:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-29T09:42:34Z"}, "message": "[Ada] Wrong equality on untagged private type\n\nWhen a private type declaration T1 is completed with a derivation of an\nuntagged private type that overrides the predefined equality primitive, and the\nfull view of T2 is a derivation of another private type T2 whose full view is a\ntagged type, the compiler may generate code that references the wrong equality\nprimitive when processing comparisons of objects of type T1.\n\n2018-05-29  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Op_Eq, Expand_Composite_Equality): Use the new\n\tsubprogram Inherits_From_Tagged_Full_View to identify more reliably\n\tuntagged private types completed with a derivation of an untagged\n\tprivate whose full view is a tagged type.\n\t* sem_util.ads, sem_util.adb (Inherits_From_Tagged_Full_View): New\n\tsubprogram.\n\t(Collect_Primitive_Operations): Handle untagged private types completed\n\twith a derivation of an untagged private type whose full view is a\n\ttagged type. In such case, collecting the list of primitives we may\n\tfind two equality primitives: one associated with the untagged private\n\tand another associated with the ultimate tagged type (and we must\n\tremove from the returned list this latter one).\n\ngcc/testsuite/\n\n\t* gnat.dg/equal2.adb: New testcase.\n\nFrom-SVN: r260886", "tree": {"sha": "54a8540e8eba293025f539857abb35e53efb4271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54a8540e8eba293025f539857abb35e53efb4271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/656412552b7c8d29090dfec239f51aa33f760c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/656412552b7c8d29090dfec239f51aa33f760c77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/656412552b7c8d29090dfec239f51aa33f760c77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/656412552b7c8d29090dfec239f51aa33f760c77/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "999acab61b42c6641f7be13aa6a6452587106d43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/999acab61b42c6641f7be13aa6a6452587106d43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/999acab61b42c6641f7be13aa6a6452587106d43"}], "stats": {"total": 189, "additions": 160, "deletions": 29}, "files": [{"sha": "1ad345e3e0dcaaa44a4acb15bca9fdf133826096", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=656412552b7c8d29090dfec239f51aa33f760c77", "patch": "@@ -1,3 +1,18 @@\n+2018-05-29  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Eq, Expand_Composite_Equality): Use the new\n+\tsubprogram Inherits_From_Tagged_Full_View to identify more reliably\n+\tuntagged private types completed with a derivation of an untagged\n+\tprivate whose full view is a tagged type.\n+\t* sem_util.ads, sem_util.adb (Inherits_From_Tagged_Full_View): New\n+\tsubprogram.\n+\t(Collect_Primitive_Operations): Handle untagged private types completed\n+\twith a derivation of an untagged private type whose full view is a\n+\ttagged type. In such case, collecting the list of primitives we may\n+\tfind two equality primitives: one associated with the untagged private\n+\tand another associated with the ultimate tagged type (and we must\n+\tremove from the returned list this latter one).\n+\n 2018-05-29  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_unst.adb (Visit_Node): Handle statement sequences that include an"}, {"sha": "bc504225a0caedfc869e3c9341d13746f4a318c8", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=656412552b7c8d29090dfec239f51aa33f760c77", "patch": "@@ -2488,17 +2488,13 @@ package body Exp_Ch4 is\n             Full_Type := Root_Type (Full_Type);\n          end if;\n \n-         --  If this is derived from an untagged private type completed with a\n-         --  tagged type, it does not have a full view, so we use the primitive\n-         --  operations of the private type. This check should no longer be\n-         --  necessary when these types receive their full views ???\n-\n-         if Is_Private_Type (Typ)\n-           and then not Is_Tagged_Type (Typ)\n-           and then not Is_Controlled (Typ)\n-           and then Is_Derived_Type (Typ)\n-           and then No (Full_View (Typ))\n-         then\n+         --  If this is an untagged private type completed with a derivation of\n+         --  an untagged private type whose full view is a tagged type, we use\n+         --  the primitive operations of the private parent type (since it does\n+         --  not have a full view, and also because its equality primitive may\n+         --  have been overridden in its untagged full view).\n+\n+         if Inherits_From_Tagged_Full_View (Typ) then\n             Prim := First_Elmt (Collect_Primitive_Operations (Typ));\n          else\n             Prim := First_Elmt (Primitive_Operations (Full_Type));\n@@ -7857,16 +7853,14 @@ package body Exp_Ch4 is\n                return;\n             end if;\n \n-            --  If this is derived from an untagged private type completed with\n-            --  a tagged type, it does not have a full view, so we use the\n-            --  primitive operations of the private type. This check should no\n-            --  longer be necessary when these types get their full views???\n+            --  If this is an untagged private type completed with a derivation\n+            --  of an untagged private type whose full view is a tagged type,\n+            --  we use the primitive operations of the private type (since it\n+            --  does not have a full view, and also because its equality\n+            --  primitive may have been overridden in its untagged full view).\n+\n+            if Inherits_From_Tagged_Full_View (A_Typ) then\n \n-            if Is_Private_Type (A_Typ)\n-              and then not Is_Tagged_Type (A_Typ)\n-              and then Is_Derived_Type (A_Typ)\n-              and then No (Full_View (A_Typ))\n-            then\n                --  Search for equality operation, checking that the operands\n                --  have the same type. Note that we must find a matching entry,\n                --  or something is very wrong."}, {"sha": "ed66422cc00f06699e3dd44099a2bd316c88531a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 80, "deletions": 9, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=656412552b7c8d29090dfec239f51aa33f760c77", "patch": "@@ -5084,15 +5084,7 @@ package body Sem_Util is\n    ----------------------------------\n \n    function Collect_Primitive_Operations (T : Entity_Id) return Elist_Id is\n-      B_Type         : constant Entity_Id := Base_Type (T);\n-      B_Decl         : constant Node_Id   := Original_Node (Parent (B_Type));\n-      B_Scope        : Entity_Id          := Scope (B_Type);\n-      Op_List        : Elist_Id;\n-      Formal         : Entity_Id;\n-      Is_Prim        : Boolean;\n-      Is_Type_In_Pkg : Boolean;\n-      Formal_Derived : Boolean := False;\n-      Id             : Entity_Id;\n+      B_Type : constant Entity_Id := Base_Type (T);\n \n       function Match (E : Entity_Id) return Boolean;\n       --  True if E's base type is B_Type, or E is of an anonymous access type\n@@ -5120,6 +5112,18 @@ package body Sem_Util is\n                and then Full_View (Etyp) = B_Type);\n       end Match;\n \n+      --  Local variables\n+\n+      B_Decl         : constant Node_Id := Original_Node (Parent (B_Type));\n+      B_Scope        : Entity_Id        := Scope (B_Type);\n+      Op_List        : Elist_Id;\n+      Eq_Prims_List  : Elist_Id := No_Elist;\n+      Formal         : Entity_Id;\n+      Is_Prim        : Boolean;\n+      Is_Type_In_Pkg : Boolean;\n+      Formal_Derived : Boolean := False;\n+      Id             : Entity_Id;\n+\n    --  Start of processing for Collect_Primitive_Operations\n \n    begin\n@@ -5268,6 +5272,22 @@ package body Sem_Util is\n \n                   else\n                      Append_Elmt (Id, Op_List);\n+\n+                     --  Save collected equality primitives for later filtering\n+                     --  (if we are processing a private type for which we can\n+                     --  collect several candidates).\n+\n+                     if Inherits_From_Tagged_Full_View (T)\n+                       and then Chars (Id) = Name_Op_Eq\n+                       and then Etype (First_Formal (Id)) =\n+                                Etype (Next_Formal (First_Formal (Id)))\n+                     then\n+                        if No (Eq_Prims_List) then\n+                           Eq_Prims_List := New_Elmt_List;\n+                        end if;\n+\n+                        Append_Elmt (Id, Eq_Prims_List);\n+                     end if;\n                   end if;\n                end if;\n             end if;\n@@ -5285,6 +5305,43 @@ package body Sem_Util is\n                Id := First_Entity (System_Aux_Id);\n             end if;\n          end loop;\n+\n+         --  Filter collected equality primitives\n+\n+         if Inherits_From_Tagged_Full_View (T)\n+           and then Present (Eq_Prims_List)\n+         then\n+            declare\n+               First  : constant Elmt_Id := First_Elmt (Eq_Prims_List);\n+               Second : Elmt_Id;\n+\n+            begin\n+               pragma Assert (No (Next_Elmt (First))\n+                 or else No (Next_Elmt (Next_Elmt (First))));\n+\n+               --  No action needed if we have collected a single equality\n+               --  primitive\n+\n+               if Present (Next_Elmt (First)) then\n+                  Second := Next_Elmt (First);\n+\n+                  if Is_Dispatching_Operation\n+                       (Ultimate_Alias (Node (First)))\n+                  then\n+                     Remove (Op_List, Node (First));\n+\n+                  elsif Is_Dispatching_Operation\n+                          (Ultimate_Alias (Node (Second)))\n+                  then\n+                     Remove (Op_List, Node (Second));\n+\n+                  else\n+                     pragma Assert (False);\n+                     raise Program_Error;\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n       end if;\n \n       return Op_List;\n@@ -12615,6 +12672,20 @@ package body Sem_Util is\n       end if;\n    end Inherit_Rep_Item_Chain;\n \n+   ------------------------------------\n+   -- Inherits_From_Tagged_Full_View --\n+   ------------------------------------\n+\n+   function Inherits_From_Tagged_Full_View (Typ : Entity_Id) return Boolean is\n+   begin\n+      return Is_Private_Type (Typ)\n+        and then Present (Full_View (Typ))\n+        and then Is_Private_Type (Full_View (Typ))\n+        and then not Is_Tagged_Type (Full_View (Typ))\n+        and then Present (Underlying_Type (Full_View (Typ)))\n+        and then Is_Tagged_Type (Underlying_Type (Full_View (Typ)));\n+   end Inherits_From_Tagged_Full_View;\n+\n    ---------------------------------\n    -- Insert_Explicit_Dereference --\n    ---------------------------------"}, {"sha": "6cb7db878398894dc8a90ebb4e45e34c37140ccc", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=656412552b7c8d29090dfec239f51aa33f760c77", "patch": "@@ -1452,6 +1452,12 @@ package Sem_Util is\n    --  Inherit the rep item chain of type From_Typ without clobbering any\n    --  existing rep items on Typ's chain. Typ is the destination type.\n \n+   function Inherits_From_Tagged_Full_View (Typ : Entity_Id) return Boolean;\n+   pragma Inline (Inherits_From_Tagged_Full_View);\n+   --  Return True if Typ is an untagged private type completed with a\n+   --  derivation of an untagged private type declaration whose full view\n+   --  is a tagged type.\n+\n    procedure Insert_Explicit_Dereference (N : Node_Id);\n    --  In a context that requires a composite or subprogram type and where a\n    --  prefix is an access type, rewrite the access type node N (which is the"}, {"sha": "030573496ebc3b4619bb890a7b55cbac7555db07", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=656412552b7c8d29090dfec239f51aa33f760c77", "patch": "@@ -1,3 +1,7 @@\n+2018-05-29  Javier Miranda  <miranda@adacore.com>\n+\n+\t* gnat.dg/equal2.adb: New testcase.\n+\n 2018-05-29  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat.dg/float_attributes_overflows.adb: New testcase."}, {"sha": "ca3717729208e62e620c3366a8510cf4789f1c28", "filename": "gcc/testsuite/gnat.dg/equal2.adb", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Ftestsuite%2Fgnat.dg%2Fequal2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/656412552b7c8d29090dfec239f51aa33f760c77/gcc%2Ftestsuite%2Fgnat.dg%2Fequal2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fequal2.adb?ref=656412552b7c8d29090dfec239f51aa33f760c77", "patch": "@@ -0,0 +1,41 @@\n+--  { dg-do run }\n+\n+procedure Equal2 is\n+\n+   package L1 is\n+      type T is private;\n+      overriding function \"=\" (Left, Right : T) return Boolean;\n+   private\n+      type T is tagged record\n+        I : Integer := 0;\n+      end record;\n+   end L1;\n+\n+   package L2 is\n+      type T is private;\n+   private\n+      type T is new L1.T;\n+      overriding function \"=\" (Left, Right : T) return Boolean;\n+   end L2;\n+\n+   package body L1 is\n+      overriding function \"=\" (Left, Right : T) return Boolean is\n+      begin\n+        return False;\n+      end \"=\";\n+   end L1;\n+\n+   package body L2 is\n+      overriding function \"=\" (Left, Right : T) return Boolean is\n+      begin\n+        return True;\n+      end \"=\";\n+   end L2;\n+\n+   use type L2.T;\n+   Left, Right : L2.T;\n+begin\n+   if Left /= Right then\n+      raise Program_Error;\n+   end if;\n+end;"}]}