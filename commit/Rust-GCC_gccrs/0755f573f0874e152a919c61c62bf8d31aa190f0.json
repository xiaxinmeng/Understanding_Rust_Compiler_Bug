{"sha": "0755f573f0874e152a919c61c62bf8d31aa190f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc1NWY1NzNmMDg3NGUxNTJhOTE5YzYxYzYyYmY4ZDMxYWExOTBmMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-09-09T01:18:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-09-09T01:22:35Z"}, "message": "libbacktrace: avoid ambiguous binary search\n\nSearching for a range match can cause the search order to not match\nthe sort order, which can cause libbacktrace to miss matching entries.\nAllocate an extra entry at the end of function_addrs and unit_addrs vectors,\nso that we can safely compare to the next entry when searching.\nAdjust the matching code accordingly.\n\nFixes https://github.com/ianlancetaylor/libbacktrace/issues/44.\n\n\t* dwarf.c (function_addrs_search): Compare against the next entry\n\tlow address, not the high address.\n\t(unit_addrs_search): Likewise.\n\t(build_address_map): Add a trailing unit_addrs.\n\t(read_function_entry): Add a trailing function_addrs.\n\t(read_function_info): Likewise.\n\t(report_inlined_functions): Search backward for function_addrs\n\tmatch.\n\t(dwarf_lookup_pc): Search backward for unit_addrs and\n\tfunction_addrs matches.", "tree": {"sha": "21161daf3e6f780e00778a45e319ec6e9aae3f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21161daf3e6f780e00778a45e319ec6e9aae3f7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0755f573f0874e152a919c61c62bf8d31aa190f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0755f573f0874e152a919c61c62bf8d31aa190f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0755f573f0874e152a919c61c62bf8d31aa190f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0755f573f0874e152a919c61c62bf8d31aa190f0/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31a050462476f4f15dc5e1f9d6ac9a1dd0a70e74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31a050462476f4f15dc5e1f9d6ac9a1dd0a70e74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31a050462476f4f15dc5e1f9d6ac9a1dd0a70e74"}], "stats": {"total": 180, "additions": 135, "deletions": 45}, "files": [{"sha": "386701bffea6b3da6ea0ab8ba93e0365d63e5bc5", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 135, "deletions": 45, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0755f573f0874e152a919c61c62bf8d31aa190f0/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0755f573f0874e152a919c61c62bf8d31aa190f0/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=0755f573f0874e152a919c61c62bf8d31aa190f0", "patch": "@@ -1164,9 +1164,11 @@ function_addrs_compare (const void *v1, const void *v2)\n   return strcmp (a1->function->name, a2->function->name);\n }\n \n-/* Compare a PC against a function_addrs for bsearch.  Note that if\n-   there are multiple ranges containing PC, which one will be returned\n-   is unpredictable.  We compensate for that in dwarf_fileline.  */\n+/* Compare a PC against a function_addrs for bsearch.  We always\n+   allocate an entra entry at the end of the vector, so that this\n+   routine can safely look at the next entry.  Note that if there are\n+   multiple ranges containing PC, which one will be returned is\n+   unpredictable.  We compensate for that in dwarf_fileline.  */\n \n static int\n function_addrs_search (const void *vkey, const void *ventry)\n@@ -1178,7 +1180,7 @@ function_addrs_search (const void *vkey, const void *ventry)\n   pc = *key;\n   if (pc < entry->low)\n     return -1;\n-  else if (pc >= entry->high)\n+  else if (pc > (entry + 1)->low)\n     return 1;\n   else\n     return 0;\n@@ -1249,9 +1251,11 @@ unit_addrs_compare (const void *v1, const void *v2)\n   return 0;\n }\n \n-/* Compare a PC against a unit_addrs for bsearch.  Note that if there\n-   are multiple ranges containing PC, which one will be returned is\n-   unpredictable.  We compensate for that in dwarf_fileline.  */\n+/* Compare a PC against a unit_addrs for bsearch.  We always allocate\n+   an entry entry at the end of the vector, so that this routine can\n+   safely look at the next entry.  Note that if there are multiple\n+   ranges containing PC, which one will be returned is unpredictable.\n+   We compensate for that in dwarf_fileline.  */\n \n static int\n unit_addrs_search (const void *vkey, const void *ventry)\n@@ -1263,7 +1267,7 @@ unit_addrs_search (const void *vkey, const void *ventry)\n   pc = *key;\n   if (pc < entry->low)\n     return -1;\n-  else if (pc >= entry->high)\n+  else if (pc > (entry + 1)->low)\n     return 1;\n   else\n     return 0;\n@@ -2091,6 +2095,7 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n   size_t i;\n   struct unit **pu;\n   size_t unit_offset = 0;\n+  struct unit_addrs *pa;\n \n   memset (&addrs->vec, 0, sizeof addrs->vec);\n   memset (&unit_vec->vec, 0, sizeof unit_vec->vec);\n@@ -2231,6 +2236,17 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n   if (info.reported_underflow)\n     goto fail;\n \n+  /* Add a trailing addrs entry, but don't include it in addrs->count.  */\n+  pa = ((struct unit_addrs *)\n+\tbacktrace_vector_grow (state, sizeof (struct unit_addrs),\n+\t\t\t       error_callback, data, &addrs->vec));\n+  if (pa == NULL)\n+    goto fail;\n+  pa->low = 0;\n+  --pa->low;\n+  pa->high = pa->low;\n+  pa->u = NULL;\n+\n   unit_vec->vec = units;\n   unit_vec->count = units_count;\n   return 1;\n@@ -3404,8 +3420,23 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \n \t      if (fvec.count > 0)\n \t\t{\n+\t\t  struct function_addrs *p;\n \t\t  struct function_addrs *faddrs;\n \n+\t\t  /* Allocate a trailing entry, but don't include it\n+\t\t     in fvec.count.  */\n+\t\t  p = ((struct function_addrs *)\n+\t\t       backtrace_vector_grow (state,\n+\t\t\t\t\t      sizeof (struct function_addrs),\n+\t\t\t\t\t      error_callback, data,\n+\t\t\t\t\t      &fvec.vec));\n+\t\t  if (p == NULL)\n+\t\t    return 0;\n+\t\t  p->low = 0;\n+\t\t  --p->low;\n+\t\t  p->high = p->low;\n+\t\t  p->function = NULL;\n+\n \t\t  if (!backtrace_vector_release (state, &fvec.vec,\n \t\t\t\t\t\t error_callback, data))\n \t\t    return 0;\n@@ -3439,6 +3470,7 @@ read_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n   struct function_vector lvec;\n   struct function_vector *pfvec;\n   struct dwarf_buf unit_buf;\n+  struct function_addrs *p;\n   struct function_addrs *addrs;\n   size_t addrs_count;\n \n@@ -3470,6 +3502,18 @@ read_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n   if (pfvec->count == 0)\n     return;\n \n+  /* Allocate a trailing entry, but don't include it in\n+     pfvec->count.  */\n+  p = ((struct function_addrs *)\n+       backtrace_vector_grow (state, sizeof (struct function_addrs),\n+\t\t\t      error_callback, data, &pfvec->vec));\n+  if (p == NULL)\n+    return;\n+  p->low = 0;\n+  --p->low;\n+  p->high = p->low;\n+  p->function = NULL;\n+\n   addrs_count = pfvec->count;\n \n   if (fvec == NULL)\n@@ -3506,30 +3550,46 @@ report_inlined_functions (uintptr_t pc, struct function *function,\n \t\t\t  backtrace_full_callback callback, void *data,\n \t\t\t  const char **filename, int *lineno)\n {\n-  struct function_addrs *function_addrs;\n+  struct function_addrs *p;\n+  struct function_addrs *match;\n   struct function *inlined;\n   int ret;\n \n   if (function->function_addrs_count == 0)\n     return 0;\n \n-  function_addrs = ((struct function_addrs *)\n-\t\t    bsearch (&pc, function->function_addrs,\n-\t\t\t     function->function_addrs_count,\n-\t\t\t     sizeof (struct function_addrs),\n-\t\t\t     function_addrs_search));\n-  if (function_addrs == NULL)\n+  p = ((struct function_addrs *)\n+       bsearch (&pc, function->function_addrs,\n+\t\tfunction->function_addrs_count,\n+\t\tsizeof (struct function_addrs),\n+\t\tfunction_addrs_search));\n+  if (p == NULL)\n     return 0;\n \n-  while (((size_t) (function_addrs - function->function_addrs) + 1\n-\t  < function->function_addrs_count)\n-\t && pc >= (function_addrs + 1)->low\n-\t && pc < (function_addrs + 1)->high)\n-    ++function_addrs;\n+  /* Here pc >= p->low && pc < (p + 1)->low.  The function_addrs are\n+     sorted by low, so we are at the end of a range of function_addrs\n+     with the same low alue.  Walk backward and use the first range\n+     that includes pc.  */\n+  match = NULL;\n+  while (1)\n+    {\n+      if (pc < p->high)\n+\t{\n+\t  match = p;\n+\t  break;\n+\t}\n+      if (p == function->function_addrs)\n+\tbreak;\n+      if ((p - 1)->low < p->low)\n+\tbreak;\n+      --p;\n+    }\n+  if (match == NULL)\n+    return 0;\n \n   /* We found an inlined call.  */\n \n-  inlined = function_addrs->function;\n+  inlined = match->function;\n \n   /* Report any calls inlined into this one.  */\n   ret = report_inlined_functions (pc, inlined, callback, data,\n@@ -3562,11 +3622,13 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n \t\t int *found)\n {\n   struct unit_addrs *entry;\n+  int found_entry;\n   struct unit *u;\n   int new_data;\n   struct line *lines;\n   struct line *ln;\n-  struct function_addrs *function_addrs;\n+  struct function_addrs *p;\n+  struct function_addrs *fmatch;\n   struct function *function;\n   const char *filename;\n   int lineno;\n@@ -3586,14 +3648,29 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n       return 0;\n     }\n \n-  /* If there are multiple ranges that contain PC, use the last one,\n-     in order to produce predictable results.  If we assume that all\n-     ranges are properly nested, then the last range will be the\n-     smallest one.  */\n-  while ((size_t) (entry - ddata->addrs) + 1 < ddata->addrs_count\n-\t && pc >= (entry + 1)->low\n-\t && pc < (entry + 1)->high)\n-    ++entry;\n+  /* Here pc >= entry->low && pc < (entry + 1)->low.  The unit_addrs\n+     are sorted by low, so we are at the end of a range of unit_addrs\n+     with the same low value.  Walk backward and use the first range\n+     that includes pc.  */\n+  found_entry = 0;\n+  while (1)\n+    {\n+      if (pc < entry->high)\n+\t{\n+\t  found_entry = 1;\n+\t  break;\n+\t}\n+      if (entry == ddata->addrs)\n+\tbreak;\n+      if ((entry - 1)->low < entry->low)\n+\tbreak;\n+      --entry;\n+    }\n+  if (!found_entry)\n+    {\n+      *found = 0;\n+      return 0;\n+    }\n \n   /* We need the lines, lines_count, function_addrs,\n      function_addrs_count fields of u.  If they are not set, we need\n@@ -3629,6 +3706,7 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n   new_data = 0;\n   if (lines == NULL)\n     {\n+      struct function_addrs *function_addrs;\n       size_t function_addrs_count;\n       struct line_header lhdr;\n       size_t count;\n@@ -3745,24 +3823,36 @@ dwarf_lookup_pc (struct backtrace_state *state, struct dwarf_data *ddata,\n   if (entry->u->function_addrs_count == 0)\n     return callback (data, pc, ln->filename, ln->lineno, NULL);\n \n-  function_addrs = ((struct function_addrs *)\n-\t\t    bsearch (&pc, entry->u->function_addrs,\n-\t\t\t     entry->u->function_addrs_count,\n-\t\t\t     sizeof (struct function_addrs),\n-\t\t\t     function_addrs_search));\n-  if (function_addrs == NULL)\n+  p = ((struct function_addrs *)\n+       bsearch (&pc, entry->u->function_addrs,\n+\t\tentry->u->function_addrs_count,\n+\t\tsizeof (struct function_addrs),\n+\t\tfunction_addrs_search));\n+  if (p == NULL)\n     return callback (data, pc, ln->filename, ln->lineno, NULL);\n \n-  /* If there are multiple function ranges that contain PC, use the\n-     last one, in order to produce predictable results.  */\n-\n-  while (((size_t) (function_addrs - entry->u->function_addrs + 1)\n-\t  < entry->u->function_addrs_count)\n-\t && pc >= (function_addrs + 1)->low\n-\t && pc < (function_addrs + 1)->high)\n-    ++function_addrs;\n+  /* Here pc >= p->low && pc < (p + 1)->low.  The function_addrs are\n+     sorted by low, so we are at the end of a range of function_addrs\n+     with the same low alue.  Walk backward and use the first range\n+     that includes pc.  */\n+  fmatch = NULL;\n+  while (1)\n+    {\n+      if (pc < p->high)\n+\t{\n+\t  fmatch = p;\n+\t  break;\n+\t}\n+      if (p == entry->u->function_addrs)\n+\tbreak;\n+      if ((p - 1)->low < p->low)\n+\tbreak;\n+      --p;\n+    }\n+  if (fmatch == NULL)\n+    return callback (data, pc, ln->filename, ln->lineno, NULL);\n \n-  function = function_addrs->function;\n+  function = fmatch->function;\n \n   filename = ln->filename;\n   lineno = ln->lineno;"}]}