{"sha": "a94c1199226699ca26717aff8c71c2ee19212f6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk0YzExOTkyMjY2OTljYTI2NzE3YWZmOGM3MWMyZWUxOTIxMmY2ZA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-09-25T23:35:10Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-09-25T23:35:10Z"}, "message": "cpplex.c (parse_args): Don't set VOID_REST flag.\n\n        * cpplex.c (parse_args): Don't set VOID_REST flag.\n\t(Fix diagnostic merge problem).\n        (CONTEXT_VARARGS): New flag.\n        (maybe_paste_with_next): Set context earlier in loop.  Use\n        it.  Do varargs test with CONTEXT_VARARGS flag.\n        (push_arg_context): Set CONTEXT_VARARGS flag if we're\n        pushing an argument context for a varargs argument.\n        * cpplib.h (VOID_REST): Delete.\n        * gcc.dg/cpp/vararg1.c: Add test case.\n\nFrom-SVN: r36638", "tree": {"sha": "531c9ea973f7c28cdfde77bf7e98c0094da5b45e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/531c9ea973f7c28cdfde77bf7e98c0094da5b45e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a94c1199226699ca26717aff8c71c2ee19212f6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94c1199226699ca26717aff8c71c2ee19212f6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a94c1199226699ca26717aff8c71c2ee19212f6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a94c1199226699ca26717aff8c71c2ee19212f6d/comments", "author": null, "committer": null, "parents": [{"sha": "15e2ab712e9d77d0ddadf39b9b9f32697daa25c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e2ab712e9d77d0ddadf39b9b9f32697daa25c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e2ab712e9d77d0ddadf39b9b9f32697daa25c8"}], "stats": {"total": 64, "additions": 34, "deletions": 30}, "files": [{"sha": "3b3a6f2de3794a5094bec05c8b16f5d00c3fc576", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94c1199226699ca26717aff8c71c2ee19212f6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94c1199226699ca26717aff8c71c2ee19212f6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a94c1199226699ca26717aff8c71c2ee19212f6d", "patch": "@@ -1,3 +1,14 @@\n+Tue 26-Sep-2000 00:16:22 BST  Neil Booth  <neilb@earthling.net>\n+\n+        * cpplex.c (parse_args): Don't set VOID_REST flag.\n+\t(CONTEXT_VARARGS): New flag.\n+\t(maybe_paste_with_next): Set context earlier in loop.  Use\n+\tit.  Do varargs test with CONTEXT_VARARGS flag.\n+\t(push_arg_context): Set CONTEXT_VARARGS flag if we're\n+\tpushing an argument context for a varargs argument.\n+\t* cpplib.h (VOID_REST): Delete.\n+\t* gcc.dg/cpp/vararg1.c: Add test case.   \n+\n 2000-09-25  Branko Cibej  <branko.cibej@hermes.si>\n \n         * flags.h:  Declare warning flag warn_system_headers."}, {"sha": "4b2f84b03f85156e88dc1d337efed589316cc004", "filename": "gcc/cpplex.c", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94c1199226699ca26717aff8c71c2ee19212f6d/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94c1199226699ca26717aff8c71c2ee19212f6d/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=a94c1199226699ca26717aff8c71c2ee19212f6d", "patch": "@@ -52,6 +52,7 @@ static const cpp_token eof_token = {0, 0, CPP_EOF, 0 UNION_INIT_ZERO};\n #define CONTEXT_PASTER\t(1 << 1) /* An argument context on RHS of ##.  */\n #define CONTEXT_RAW\t(1 << 2) /* If argument tokens already expanded.  */\n #define CONTEXT_ARG\t(1 << 3) /* If an argument context.  */\n+#define CONTEXT_VARARGS\t(1 << 4) /* If a varargs argument context.  */\n \n typedef struct cpp_context cpp_context;\n struct cpp_context\n@@ -1209,31 +1210,17 @@ lex_token (pfile, result)\n \t     irrespective of conformance mode, because lots of\n \t     broken systems do that and trying to clean it up in\n \t     fixincludes is a nightmare.  */\n-\t  if (CPP_OPTION (pfile, cplusplus_comments)\n-\t      || CPP_IN_SYSTEM_HEADER (pfile))\n+\t  if (CPP_OPTION (pfile, c89) && CPP_PEDANTIC (pfile)\n+\t      && ! buffer->warned_cplusplus_comments)\n \t    {\n-\t      if (CPP_OPTION (pfile, c89) && CPP_PEDANTIC (pfile)\n-\t\t  && ! buffer->warned_cplusplus_comments)\n-\t\t{\n-\t\t  cpp_pedwarn (pfile,\n-\t\t       \"C++ style comments are not allowed in ISO C89\");\n-\t\t  cpp_pedwarn (pfile,\n-\t\t       \"(this will be reported only once per input file)\");\n-\t\t  buffer->warned_cplusplus_comments = 1;\n-\t\t}\n-\t      comment_start = buffer->cur;\n-\n-\t      /* Skip_line_comment updates buffer->read_ahead.  */\n-\t      if (skip_line_comment (pfile))\n-\t\tcpp_warning_with_line (pfile, result->line, result->col,\n-\t\t\t\t       \"multi-line comment\");\n \t      cpp_pedwarn (pfile,\n \t\t\t   \"C++ style comments are not allowed in ISO C89\");\n \t      cpp_pedwarn (pfile,\n \t\t\t   \"(this will be reported only once per input file)\");\n \t      buffer->warned_cplusplus_comments = 1;\n \t    }\n \n+\t  /* Skip_line_comment updates buffer->read_ahead.  */\n \t  if (skip_line_comment (pfile))\n \t    cpp_warning_with_line (pfile, result->line, result->col,\n \t\t\t\t   \"multi-line comment\");\n@@ -2004,9 +1991,7 @@ parse_args (pfile, hp, args)\n \t{\n \t  /* Duplicate the placemarker.  Then we can set its flags and\n              position and safely be using more than one.  */\n-\t  cpp_token *pm = duplicate_token (pfile, &placemarker_token);\n-\t  pm->flags = VOID_REST;\n-\t  save_token (args, pm);\n+\t  save_token (args, duplicate_token (pfile, &placemarker_token));\n \t  args->ends[argc] = total + 1;\n \n \t  if (CPP_OPTION (pfile, c99) && CPP_PEDANTIC (pfile))\n@@ -2316,6 +2301,7 @@ maybe_paste_with_next (pfile, token)\n       pfile->paste_level = pfile->cur_context;\n       second = _cpp_get_token (pfile);\n       pfile->paste_level = 0;\n+      context = CURRENT_CONTEXT (pfile);\n \n       /* Ignore placemarker argument tokens (cannot be from an empty\n \t macro since macros are not expanded).  */\n@@ -2327,7 +2313,7 @@ maybe_paste_with_next (pfile, token)\n \t     a varargs parameter: the comma disappears if b was given\n \t     no actual arguments (not merely if b is an empty\n \t     argument).  */\n-\t  if (token->type == CPP_COMMA && second->flags & VOID_REST)\n+\t  if (token->type == CPP_COMMA && (context->flags & CONTEXT_VARARGS))\n \t    pasted = duplicate_token (pfile, second);\n \t  else\n \t    pasted = duplicate_token (pfile, token);\n@@ -2345,9 +2331,8 @@ maybe_paste_with_next (pfile, token)\n \t\t     <whatever> came from a variable argument, because\n \t\t     the author probably intended the ## to trigger\n \t\t     the special extended semantics (see above).  */\n-\t\t  if (token->type == CPP_COMMA\n-\t\t      && IS_ARG_CONTEXT (CURRENT_CONTEXT (pfile))\n-\t\t      && ON_REST_ARG (CURRENT_CONTEXT (pfile) - 1))\n+\t\t  if (token->type == CPP_COMMA && IS_ARG_CONTEXT (context)\n+\t\t      && ON_REST_ARG (context - 1))\n \t\t    /* no warning */;\n \t\t  else\n \t\t    cpp_warning (pfile,\n@@ -2411,7 +2396,6 @@ maybe_paste_with_next (pfile, token)\n       /* See if there is another token to be pasted onto the one we just\n \t constructed.  */\n       token = pasted;\n-      context = CURRENT_CONTEXT (pfile);\n       /* and loop */\n     }\n   return token;\n@@ -2592,6 +2576,9 @@ push_arg_context (pfile, token)\n   context->posn = 0;\n   context->level = args->level;\n   context->flags = CONTEXT_ARG | CONTEXT_RAW;\n+  if ((context[-1].u.list->flags & VAR_ARGS)\n+      && token->val.aux + 1 == (unsigned) context[-1].u.list->paramc)\n+    context->flags |= CONTEXT_VARARGS;\n   context->pushed_token = 0;\n \n   /* Set the flags of the first token.  There is one.  */"}, {"sha": "0f5235209f0cd3ef6cafb1047c7cf1bde9f23938", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94c1199226699ca26717aff8c71c2ee19212f6d/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94c1199226699ca26717aff8c71c2ee19212f6d/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=a94c1199226699ca26717aff8c71c2ee19212f6d", "patch": "@@ -160,7 +160,6 @@ struct cpp_string\n #define PASTE_LEFT\t(1 << 4) /* If on LHS of a ## operator.  */\n #define PASTED\t\t(1 << 5) /* The result of a ## operator.  */\n #define NAMED_OP\t(1 << 6) /* C++ named operators, also \"defined\".  */\n-#define VOID_REST\t(1 << 7) /* When a rest arg gets zero actual args.  */\n \n /* A preprocessing token.  This has been carefully packed and should\n    occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */"}, {"sha": "38bf56bd047ce45e50f76041347f10f96b71b2db", "filename": "gcc/testsuite/gcc.dg/cpp/vararg1.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a94c1199226699ca26717aff8c71c2ee19212f6d/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a94c1199226699ca26717aff8c71c2ee19212f6d/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg1.c?ref=a94c1199226699ca26717aff8c71c2ee19212f6d", "patch": "@@ -1,11 +1,19 @@\n+/* { dg-do run } */\n+/* { dg-options -w } */\n+\n+/* count() used to give 1 owing to a buggy test for varargs.  */\n+#define count(y...)  count1 ( , ##y)\n+#define count1(y...) count2 (y,1,0)\n+#define count2(_,x0,n,y...) n\n+#if count() != 0 || count(A) != 1\n+#error Incorrect vararg argument counts\n+#endif\n+\n /* Test for changed behavior of the GNU varargs extension.\n    ##args, where args is a rest argument which received zero tokens,\n    used to delete the previous sequence of nonwhitespace characters.\n    Now it deletes the previous token.  */\n \n-/* { dg-do run } */\n-/* { dg-options -w } */\n-\n #include <string.h>\n \n #define S(str, args...) \"  \" str \"\\n\", ##args\n@@ -16,4 +24,3 @@ main()\n   const char *s = S(\"foo\");\n   return strchr (s, '\\n') == NULL;\n }\n-"}]}