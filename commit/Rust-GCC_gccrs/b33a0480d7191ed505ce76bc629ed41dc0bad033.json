{"sha": "b33a0480d7191ed505ce76bc629ed41dc0bad033", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMzYTA0ODBkNzE5MWVkNTA1Y2U3NmJjNjI5ZWQ0MWRjMGJhZDAzMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-05-15T02:22:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-05-15T02:22:37Z"}, "message": "C++ DR 475\n\n\tC++ DR 475\n\t* except.c (build_throw): Simplify, adjust for DR 475.\n\nFrom-SVN: r159428", "tree": {"sha": "2b4e31855a9addf79a8760afef77264ca037c6f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b4e31855a9addf79a8760afef77264ca037c6f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b33a0480d7191ed505ce76bc629ed41dc0bad033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b33a0480d7191ed505ce76bc629ed41dc0bad033", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b33a0480d7191ed505ce76bc629ed41dc0bad033", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b33a0480d7191ed505ce76bc629ed41dc0bad033/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8efab4c82c0bba73d69cde401c344209b37727bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8efab4c82c0bba73d69cde401c344209b37727bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8efab4c82c0bba73d69cde401c344209b37727bf"}], "stats": {"total": 129, "additions": 64, "deletions": 65}, "files": [{"sha": "ce56b0d1fc6d69144a001106a7a1814713092e1d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b33a0480d7191ed505ce76bc629ed41dc0bad033", "patch": "@@ -1,5 +1,8 @@\n 2010-05-14  Jason Merrill  <jason@redhat.com>\n \n+\tC++ DR 475\n+\t* except.c (build_throw): Simplify, adjust for DR 475.\n+\n \tPR c++/44127\n \t* except.c (dtor_nothrow): Return nonzero for type with\n \ttrivial destructor."}, {"sha": "48ace536c54f53d4022079a7b5b1a3c7580b5ebe", "filename": "gcc/cp/except.c", "status": "modified", "additions": 11, "deletions": 49, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=b33a0480d7191ed505ce76bc629ed41dc0bad033", "patch": "@@ -665,8 +665,7 @@ build_throw (tree exp)\n       tree cleanup;\n       tree object, ptr;\n       tree tmp;\n-      tree temp_expr, allocate_expr;\n-      bool elided;\n+      tree allocate_expr;\n \n       /* The CLEANUP_TYPE is the internal type of a destructor.  */\n       if (!cleanup_type)\n@@ -719,11 +718,12 @@ build_throw (tree exp)\n       allocate_expr = do_allocate_exception (temp_type);\n       allocate_expr = get_target_expr (allocate_expr);\n       ptr = TARGET_EXPR_SLOT (allocate_expr);\n+      TARGET_EXPR_CLEANUP (allocate_expr) = do_free_exception (ptr);\n+      CLEANUP_EH_ONLY (allocate_expr) = 1;\n+\n       object = build_nop (build_pointer_type (temp_type), ptr);\n       object = cp_build_indirect_ref (object, RO_NULL, tf_warning_or_error);\n \n-      elided = (TREE_CODE (exp) == TARGET_EXPR);\n-\n       /* And initialize the exception object.  */\n       if (CLASS_TYPE_P (temp_type))\n \t{\n@@ -761,54 +761,16 @@ build_throw (tree exp)\n \t  exp = build2 (INIT_EXPR, temp_type, object, tmp);\n \t}\n \n-      /* Pre-evaluate the thrown expression first, since if we allocated\n-\t the space first we would have to deal with cleaning it up if\n-\t evaluating this expression throws.\n-\n-\t The case where EXP the initializer is a cast or a function\n-\t returning a class is a bit of a grey area in the standard; it's\n-\t unclear whether or not it should be allowed to throw.  We used to\n-\t say no, as that allowed us to optimize this case without worrying\n-\t about deallocating the exception object if it does.  But that\n-\t conflicted with expectations (PR 13944) and the EDG compiler; now\n-\t we wrap the initialization in a TRY_CATCH_EXPR to call\n-\t do_free_exception rather than in a MUST_NOT_THROW_EXPR, for this\n-\t case only.\n-\n-\t BUT: Issue 475 may do away with this inconsistency by removing the\n-\t terminate() in this situation.\n-\n-\t Note that we don't check the return value from stabilize_init\n-\t because it will only return false in cases where elided is true,\n-\t and therefore we don't need to work around the failure to\n-\t preevaluate.  */\n-      temp_expr = NULL_TREE;\n-      stabilize_init (exp, &temp_expr);\n-\n-      /* Wrap the initialization in a CLEANUP_POINT_EXPR so that cleanups\n-\t for temporaries within the initialization are run before the one\n-\t for the exception object, preserving LIFO order.  */\n-      exp = build1 (CLEANUP_POINT_EXPR, void_type_node, exp);\n-\n-      if (elided)\n-\texp = build2 (TRY_CATCH_EXPR, void_type_node, exp,\n-\t\t      do_free_exception (ptr));\n-      else\n-\texp = build1 (MUST_NOT_THROW_EXPR, void_type_node, exp);\n+      /* Mark any cleanups from the initialization as MUST_NOT_THROW, since\n+\t they are run after the exception object is initialized.  */\n+      cp_walk_tree_without_duplicates (&exp, wrap_cleanups_r, 0);\n \n       /* Prepend the allocation.  */\n       exp = build2 (COMPOUND_EXPR, TREE_TYPE (exp), allocate_expr, exp);\n-      if (temp_expr)\n-\t{\n-\t  /* Prepend the calculation of the throw expression.  Also, force\n-\t     any cleanups from the expression to be evaluated here so that\n-\t     we don't have to do them during unwinding.  But first wrap\n-\t     them in MUST_NOT_THROW_EXPR, since they are run after the\n-\t     exception object is initialized.  */\n-\t  cp_walk_tree_without_duplicates (&temp_expr, wrap_cleanups_r, 0);\n-\t  exp = build2 (COMPOUND_EXPR, TREE_TYPE (exp), temp_expr, exp);\n-\t  exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n-\t}\n+\n+      /* Force all the cleanups to be evaluated here so that we don't have\n+\t to do them during unwinding.  */\n+      exp = build1 (CLEANUP_POINT_EXPR, void_type_node, exp);\n \n       throw_type = build_eh_type_type (prepare_eh_type (TREE_TYPE (object)));\n "}, {"sha": "7c14d8cf5fdd671280381144208a616e5e1504ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b33a0480d7191ed505ce76bc629ed41dc0bad033", "patch": "@@ -1,3 +1,9 @@\n+2010-05-14  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/eh/cond4.C: New.\n+\t* g++.dg/eh/elide2.C: Adjust.\n+\t* g++.old-deja/g++.eh/terminate1.C: Adjust.\n+\n 2010-05-14  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/44135"}, {"sha": "a8d1cfbf3e2acb8a3c2c0fbc9695b93134bc5540", "filename": "gcc/testsuite/g++.dg/eh/cond4.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fcond4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fcond4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fcond4.C?ref=b33a0480d7191ed505ce76bc629ed41dc0bad033", "patch": "@@ -0,0 +1,32 @@\n+// Runtime version of cond3.C.  We call terminate when the A cleanup throws\n+// because we've already initialized the exception object.\n+// { dg-do run }\n+\n+#include <exception>\n+#include <cstdlib>\n+\n+void my_terminate ()\n+{\n+  std::exit (0);\n+}\n+\n+struct A {\n+  A(int) { }\n+  ~A() { throw 1; };\n+};\n+struct B {\n+  B(A) { }\n+  ~B() { }\n+};\n+bool b;\n+\n+int main()\n+{\n+  std::set_terminate (my_terminate);\n+  try\n+    {\n+      throw b ? B(1) : B(1);\n+    }\n+  catch (...) { }\n+  return 1;\n+}"}, {"sha": "7d65d9ee6abc664faa4de4144383533138bb03c1", "filename": "gcc/testsuite/g++.dg/eh/elide2.C", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Felide2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Felide2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Felide2.C?ref=b33a0480d7191ed505ce76bc629ed41dc0bad033", "patch": "@@ -1,13 +1,10 @@\n // PR c++/13944\n \n-// Verify that we still call terminate() if we do run the copy constructor,\n-// and it throws.\n+// Verify that we don't call terminate() if initializing the exception\n+// object throws.\n \n // { dg-do run }\n \n-#include <cstdlib>\n-#include <exception>\n-\n struct A\n {\n   A() { }\n@@ -16,17 +13,17 @@ struct A\n \n A a;\n \n-void\n-good_terminate() { std::exit (0); }\n-\n int main()\n {\n-  std::set_terminate (good_terminate);\n   try\n     {\n       throw a;\n     }\n-  catch (...)\n+  catch (int)\n+    {\n+      return 0;\n+    }\n+  catch (A&)\n     {\n       return 2;\n     }"}, {"sha": "623fb84009c9872675c33eb0e4c413164f29909f", "filename": "gcc/testsuite/g++.old-deja/g++.eh/terminate1.C", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fterminate1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b33a0480d7191ed505ce76bc629ed41dc0bad033/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fterminate1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fterminate1.C?ref=b33a0480d7191ed505ce76bc629ed41dc0bad033", "patch": "@@ -1,6 +1,6 @@\n-// { dg-do run  }\n-// Test that an exception thrown out of the constructor for the exception\n-// object (i.e. \"after completing evaluation of the expression to be thrown\n+// { dg-do run }\n+// Test that an exception thrown out of the constructor for the catch\n+// parameter (i.e. \"after completing evaluation of the expression to be thrown\n // but before the exception is caught\") causes us to call terminate.\n \n #include <exception>\n@@ -21,8 +21,7 @@ int main (void)\n {\n   std::set_terminate (my_terminate);\n \n-  A a;\n-  try { throw a; }\n-  catch (...) {}\n+  try { throw A(); }\n+  catch (A) {}\n   return 1;\n }"}]}