{"sha": "ccf5c864c9bae45e3c1a9858529f346005e5ca25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NmNWM4NjRjOWJhZTQ1ZTNjMWE5ODU4NTI5ZjM0NjAwNWU1Y2EyNQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-06-27T14:45:51Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-06-27T14:45:51Z"}, "message": "domwalk.h (struct dom_walk_data): Remove all callbacks except before_dom_children_before_stmts and...\n\n2009-06-27  Paolo Bonzini  <bonzini@gnu.org>\n\n        * domwalk.h (struct dom_walk_data): Remove all callbacks except\n        before_dom_children_before_stmts and after_dom_children_after_stmts.\n        Rename the two remaining callbacks to just before_dom_children and \n        after_dom_children. Remove other GIMPLE statement walking bits.\n        * domwalk.c (walk_dominator_tree): Remove now unsupported features.\n        * graphite.c: Do not include domwalk.h.\n        * tree-into-ssa.c (interesting_blocks): New global.\n        (struct mark_def_sites_global_data): Remove it and names_to_rename.\n        (mark_def_sites, rewrite_stmt, rewrite_add_phi_arguments,\n        rewrite_update_stmt, rewrite_update_phi_arguments): Simplify\n        now that they're not domwalk callbacks.\n        (rewrite_initialize_block): Rename to...\n        (rewrite_enter_block): ... this, place after called functions.  Test\n        interesting_blocks, call rewrite_stmt and rewrite_add_phi_arguments.\n        (rewrite_finalize_block): Rename to...\n        (rewrite_leave_block): ... this, place after called functions.\n        (rewrite_update_init_block): Rename to...\n        (rewrite_update_enter_block): ... this, place after called functions.\n        Test interesting_blocks, call rewrite_update_stmt and \n        rewrite_update_phi_arguments.\n        (rewrite_update_fini_block): Rename to...\n        (rewrite_leave_block): ... this, place after called functions.\n        (rewrite_blocks): Remove last argument, simplify initialization of\n        walk_data.\n        (mark_def_sites_initialize_block): Rename to...\n        (mark_def_sites_block): ... this, call mark_def_sites.\n        (mark_def_sites_blocks): Remove argument, simplify initialization of\n        walk_data.\n        (rewrite_into_ssa): Adjust for interesting_blocks_being a global.\n        (update_ssa): Likewise.\n        * tree-ssa-dom.c (optimize_stmt): Simplify now that it's not a domwalk\n        callback.\n        (tree_ssa_dominator_optimize): Simplify initialization of walk_data.\n        (dom_opt_initialize_block): Rename to...\n        (dom_opt_enter_block): ... this, place after called functions.  Walk\n        statements here, inline propagate_to_outgoing_edges.\n        (dom_opt_finalize_block): Rename to...\n        (dom_opt_leave_block): ... this, place after called functions.\n        * tree-ssa-dse.c (dse_optimize_stmt): Simplify now that it's not a\n        domwalk callback.\n        (dse_enter_block, dse_record_phi): New.\n        (dse_record_phis): Delete.\n        (dse_finalize_block): Rename to...\n        (dse_leave_block): ... this.\n        (tree_ssa_dse): Simplify initialization of walk_data.\n        * tree-ssa-loop-im.c (determine_invariantness, move_computations):\n        Adjust initialization of walk_data.\n        * tree-ssa-loop-unswitch.c: Do not include domwalk.h.\n        * tree-ssa-loop-phiopt.c (get_non_trapping):\n        Adjust initialization of walk_data.\n        * tree-ssa-loop-threadedge.c: Do not include domwalk.h.\n        * tree-ssa-uncprop.c (uncprop_into_successor_phis): Simplify now that\n        it's not a domwalk callback.\n        (uncprop_initialize_block): Rename to...\n        (dse_enter_block): ... this, call uncprop_into_successor_phis.\n        (dse_finalize_block): Rename to...\n        (dse_leave_block): ... this.\n        (tree_ssa_uncprop): Simplify initialization of walk_data.\n        * Makefile.in: Adjust dependencies.\n\nFrom-SVN: r149008", "tree": {"sha": "4d282ef2e7bba7ac8b8f57bfadf3057c91cb6a6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d282ef2e7bba7ac8b8f57bfadf3057c91cb6a6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccf5c864c9bae45e3c1a9858529f346005e5ca25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf5c864c9bae45e3c1a9858529f346005e5ca25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccf5c864c9bae45e3c1a9858529f346005e5ca25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf5c864c9bae45e3c1a9858529f346005e5ca25/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c6bd4220c947db8bccef32768766ea2f030f70d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bd4220c947db8bccef32768766ea2f030f70d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6bd4220c947db8bccef32768766ea2f030f70d5"}], "stats": {"total": 1034, "additions": 463, "deletions": 571}, "files": [{"sha": "5517f3706ce3ef533612b55cadb4304251ad116b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -1,3 +1,65 @@\n+2009-06-27  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * domwalk.h (struct dom_walk_data): Remove all callbacks except\n+        before_dom_children_before_stmts and after_dom_children_after_stmts.\n+        Rename the two remaining callbacks to just before_dom_children and \n+        after_dom_children. Remove other GIMPLE statement walking bits.\n+        * domwalk.c (walk_dominator_tree): Remove now unsupported features.\n+        * graphite.c: Do not include domwalk.h.\n+        * tree-into-ssa.c (interesting_blocks): New global.\n+        (struct mark_def_sites_global_data): Remove it and names_to_rename.\n+        (mark_def_sites, rewrite_stmt, rewrite_add_phi_arguments,\n+        rewrite_update_stmt, rewrite_update_phi_arguments): Simplify\n+        now that they're not domwalk callbacks.\n+        (rewrite_initialize_block): Rename to...\n+        (rewrite_enter_block): ... this, place after called functions.  Test\n+        interesting_blocks, call rewrite_stmt and rewrite_add_phi_arguments.\n+        (rewrite_finalize_block): Rename to...\n+        (rewrite_leave_block): ... this, place after called functions.\n+        (rewrite_update_init_block): Rename to...\n+        (rewrite_update_enter_block): ... this, place after called functions.\n+        Test interesting_blocks, call rewrite_update_stmt and \n+        rewrite_update_phi_arguments.\n+        (rewrite_update_fini_block): Rename to...\n+        (rewrite_leave_block): ... this, place after called functions.\n+        (rewrite_blocks): Remove last argument, simplify initialization of\n+        walk_data.\n+        (mark_def_sites_initialize_block): Rename to...\n+        (mark_def_sites_block): ... this, call mark_def_sites.\n+        (mark_def_sites_blocks): Remove argument, simplify initialization of\n+        walk_data.\n+        (rewrite_into_ssa): Adjust for interesting_blocks_being a global.\n+        (update_ssa): Likewise.\n+        * tree-ssa-dom.c (optimize_stmt): Simplify now that it's not a domwalk\n+        callback.\n+        (tree_ssa_dominator_optimize): Simplify initialization of walk_data.\n+        (dom_opt_initialize_block): Rename to...\n+        (dom_opt_enter_block): ... this, place after called functions.  Walk\n+        statements here, inline propagate_to_outgoing_edges.\n+        (dom_opt_finalize_block): Rename to...\n+        (dom_opt_leave_block): ... this, place after called functions.\n+        * tree-ssa-dse.c (dse_optimize_stmt): Simplify now that it's not a\n+        domwalk callback.\n+        (dse_enter_block, dse_record_phi): New.\n+        (dse_record_phis): Delete.\n+        (dse_finalize_block): Rename to...\n+        (dse_leave_block): ... this.\n+        (tree_ssa_dse): Simplify initialization of walk_data.\n+        * tree-ssa-loop-im.c (determine_invariantness, move_computations):\n+        Adjust initialization of walk_data.\n+        * tree-ssa-loop-unswitch.c: Do not include domwalk.h.\n+        * tree-ssa-loop-phiopt.c (get_non_trapping):\n+        Adjust initialization of walk_data.\n+        * tree-ssa-loop-threadedge.c: Do not include domwalk.h.\n+        * tree-ssa-uncprop.c (uncprop_into_successor_phis): Simplify now that\n+        it's not a domwalk callback.\n+        (uncprop_initialize_block): Rename to...\n+        (dse_enter_block): ... this, call uncprop_into_successor_phis.\n+        (dse_finalize_block): Rename to...\n+        (dse_leave_block): ... this.\n+        (tree_ssa_uncprop): Simplify initialization of walk_data.\n+        * Makefile.in: Adjust dependencies.\n+\n 2009-06-27  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (casesi): Fix test for Thumb1."}, {"sha": "d621d7fb52ff303e7660b535189df6e8d97ada16", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -2221,7 +2221,7 @@ tree-ssa-threadedge.o : tree-ssa-threadedge.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(FLAGS_H) $(RTL_H) $(TM_P_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) $(CFGLOOP_H) output.h $(EXPR_H) \\\n    $(FUNCTION_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TREE_DUMP_H) $(TREE_FLOW_H) \\\n-   domwalk.h $(REAL_H) $(TREE_PASS_H) tree-ssa-propagate.h langhooks.h \\\n+   $(REAL_H) $(TREE_PASS_H) tree-ssa-propagate.h langhooks.h \\\n    $(PARAMS_H)\n tree-ssa-threadupdate.o : tree-ssa-threadupdate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n@@ -2233,7 +2233,7 @@ tree-phinodes.o : tree-phinodes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(VARRAY_H) $(GGC_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n    gt-tree-phinodes.h $(RTL_H) $(TOPLEV.H)  $(GIMPLE_H)\n domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) domwalk.h $(GGC_H)\n+   $(BASIC_BLOCK_H) domwalk.h $(GGC_H)\n tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(TREE_SSA_LIVE_H) $(BITMAP_H) $(TOPLEV_H) debug.h $(FLAGS_H)\n@@ -2310,7 +2310,7 @@ tree-ssa-loop.o : tree-ssa-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(CFGLOOP_H) $(FLAGS_H) $(TREE_INLINE_H) tree-scalar-evolution.h\n tree-ssa-loop-unswitch.o : tree-ssa-loop-unswitch.c $(TREE_FLOW_H) \\\n    $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n-   domwalk.h $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \\\n+   $(PARAMS_H) output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(BASIC_BLOCK_H) hard-reg-set.h \\\n     $(TREE_INLINE_H)\n tree-ssa-address.o : tree-ssa-address.c $(TREE_FLOW_H) $(CONFIG_H) \\\n@@ -2425,7 +2425,7 @@ tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_DATA_REF_H) $(SCEV_H) $(TREE_PASS_H) tree-chrec.h langhooks.h\n graphite.o: graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n-   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) domwalk.h \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n    $(TREE_DATA_REF_H) $(SCEV_H) $(TREE_PASS_H) tree-chrec.h graphite.h \\\n    pointer-set.h value-prof.h\n tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\"}, {"sha": "b70a807e7a454a99f9538d7ad451edd4fd9a1484", "filename": "gcc/domwalk.c", "status": "modified", "additions": 6, "deletions": 57, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -23,9 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"tree.h\"\n #include \"basic-block.h\"\n-#include \"tree-flow.h\"\n #include \"domwalk.h\"\n #include \"ggc.h\"\n \n@@ -144,8 +142,6 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n {\n   void *bd = NULL;\n   basic_block dest;\n-  gimple_stmt_iterator gsi;\n-  bool is_interesting;\n   basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks * 2);\n   int sp = 0;\n \n@@ -156,13 +152,6 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t  || bb == ENTRY_BLOCK_PTR\n \t  || bb == EXIT_BLOCK_PTR)\n \t{\n-\t  /* If block BB is not interesting to the caller, then none of the\n-\t     callbacks that walk the statements in BB are going to be\n-\t     executed.  */\n-\t  is_interesting = walk_data->interesting_blocks == NULL\n-\t                   || TEST_BIT (walk_data->interesting_blocks,\n-\t\t\t\t\tbb->index);\n-\n \t  /* Callback to initialize the local data structure.  */\n \t  if (walk_data->initialize_block_local_data)\n \t    {\n@@ -192,27 +181,8 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \n \t  /* Callback for operations to execute before we have walked the\n \t     dominator children, but before we walk statements.  */\n-\t  if (walk_data->before_dom_children_before_stmts)\n-\t    (*walk_data->before_dom_children_before_stmts) (walk_data, bb);\n-\n-\t  /* Statement walk before walking dominator children.  */\n-\t  if (is_interesting && walk_data->before_dom_children_walk_stmts)\n-\t    {\n-\t      if (walk_data->walk_stmts_backward)\n-\t\tfor (gsi = gsi_last (bb_seq (bb)); !gsi_end_p (gsi);\n-\t\t     gsi_prev (&gsi))\n-\t\t  (*walk_data->before_dom_children_walk_stmts) (walk_data, bb,\n-\t\t\t\t\t\t\t\tgsi);\n-\t      else\n-\t\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\t  (*walk_data->before_dom_children_walk_stmts) (walk_data, bb,\n-\t\t\t\t\t\t\t\tgsi);\n-\t    }\n-\n-\t  /* Callback for operations to execute before we have walked the\n-\t     dominator children, and after we walk statements.  */\n-\t  if (walk_data->before_dom_children_after_stmts)\n-\t    (*walk_data->before_dom_children_after_stmts) (walk_data, bb);\n+\t  if (walk_data->before_dom_children)\n+\t    (*walk_data->before_dom_children) (walk_data, bb);\n \n \t  /* Mark the current BB to be popped out of the recursion stack\n \t     once children are processed.  */\n@@ -223,37 +193,16 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t       dest; dest = next_dom_son (walk_data->dom_direction, dest))\n \t    worklist[sp++] = dest;\n \t}\n-      /* NULL is used to signalize pop operation in recursion stack.  */\n+      /* NULL is used to mark pop operations in the recursion stack.  */\n       while (sp > 0 && !worklist[sp - 1])\n \t{\n \t  --sp;\n \t  bb = worklist[--sp];\n-\t  is_interesting = walk_data->interesting_blocks == NULL\n-\t                   || TEST_BIT (walk_data->interesting_blocks,\n-\t\t\t\t        bb->index);\n-\t  /* Callback for operations to execute after we have walked the\n-\t     dominator children, but before we walk statements.  */\n-\t  if (walk_data->after_dom_children_before_stmts)\n-\t    (*walk_data->after_dom_children_before_stmts) (walk_data, bb);\n-\n-\t  /* Statement walk after walking dominator children.  */\n-\t  if (is_interesting && walk_data->after_dom_children_walk_stmts)\n-\t    {\n-\t      if (walk_data->walk_stmts_backward)\n-\t\tfor (gsi = gsi_last (bb_seq (bb)); !gsi_end_p (gsi);\n-\t\t     gsi_prev (&gsi))\n-\t\t  (*walk_data->after_dom_children_walk_stmts) (walk_data, bb,\n-\t\t\t\t\t\t\t       gsi);\n-\t      else\n-\t\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\t  (*walk_data->after_dom_children_walk_stmts) (walk_data, bb,\n-\t\t\t\t\t\t\t       gsi);\n-\t    }\n \n \t  /* Callback for operations to execute after we have walked the\n-\t     dominator children and after we have walked statements.  */\n-\t  if (walk_data->after_dom_children_after_stmts)\n-\t    (*walk_data->after_dom_children_after_stmts) (walk_data, bb);\n+\t     dominator children, but before we walk statements.  */\n+\t  if (walk_data->after_dom_children)\n+\t    (*walk_data->after_dom_children) (walk_data, bb);\n \n \t  if (walk_data->initialize_block_local_data)\n \t    {"}, {"sha": "63aeec233a363478283e4dac3acb1b9bfb68f379", "filename": "gcc/domwalk.h", "status": "modified", "additions": 4, "deletions": 51, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -34,15 +34,6 @@ struct dom_walk_data\n      dominator tree.  */\n   ENUM_BITFIELD (cdi_direction) dom_direction : 2;\n \n-  /* Nonzero if the statement walker should walk the statements from\n-     last to first within a basic block instead of first to last.\n-\n-     Note this affects both statement walkers.  We haven't yet needed\n-     to use the second statement walker for anything, so it's hard to\n-     predict if we really need the ability to select their direction\n-     independently.  */\n-  BOOL_BITFIELD walk_stmts_backward : 1;\n-\n   /* Function to initialize block local data.\n \n      Note that the dominator walker infrastructure may provide a new\n@@ -55,41 +46,11 @@ struct dom_walk_data\n   void (*initialize_block_local_data) (struct dom_walk_data *,\n \t\t\t\t       basic_block, bool);\n \n-  /* Function to call before the statement walk occurring before the\n-     recursive walk of the dominator children. \n-\n-     This typically initializes a block local data and pushes that\n-     data onto BLOCK_DATA_STACK.  */\n-  void (*before_dom_children_before_stmts) (struct dom_walk_data *,\n-\t\t\t\t\t    basic_block);\n-\n-  /* Function to call to walk statements before the recursive walk\n-     of the dominator children.  */\n-  void (*before_dom_children_walk_stmts) (struct dom_walk_data *,\n-\t\t\t\t\t  basic_block, gimple_stmt_iterator);\n-\n-  /* Function to call after the statement walk occurring before the\n-     recursive walk of the dominator children.  */\n-  void (*before_dom_children_after_stmts) (struct dom_walk_data *,\n-\t\t\t\t\t   basic_block);\n+  /* Function to call before the recursive walk of the dominator children.  */\n+  void (*before_dom_children) (struct dom_walk_data *, basic_block);\n \n-  /* Function to call before the statement walk occurring after the\n-     recursive walk of the dominator children.  */\n-  void (*after_dom_children_before_stmts) (struct dom_walk_data *,\n-\t\t\t\t\t   basic_block);\n-\n-  /* Function to call to walk statements after the recursive walk\n-     of the dominator children.  */\n-  void (*after_dom_children_walk_stmts) (struct dom_walk_data *,\n-\t\t\t\t\t basic_block, gimple_stmt_iterator);\n-\n-  /* Function to call after the statement walk occurring after the\n-     recursive walk of the dominator children. \n-\n-     This typically finalizes any block local data and pops\n-     that data from BLOCK_DATA_STACK.  */\n-  void (*after_dom_children_after_stmts) (struct dom_walk_data *,\n-\t\t\t\t\t  basic_block);\n+  /* Function to call after the recursive walk of the dominator children.  */\n+  void (*after_dom_children) (struct dom_walk_data *, basic_block);\n \n   /* Global data for a walk through the dominator tree.  */\n   void *global_data;\n@@ -108,14 +69,6 @@ struct dom_walk_data\n \n   /* Stack of available block local structures.  */\n   VEC(void_p,heap) *free_block_data;\n-\n-  /* Interesting blocks to process.  If this field is not NULL, this\n-     set is used to determine which blocks to walk.  If we encounter\n-     block I in the dominator traversal, but block I is not present in\n-     INTERESTING_BLOCKS, then none of the callback functions are\n-     invoked on it.  This is useful when a particular traversal wants\n-     to filter out non-interesting blocks from the dominator tree.  */\n-  sbitmap interesting_blocks;\n };\n \n void walk_dominator_tree (struct dom_walk_data *, basic_block);"}, {"sha": "a87bca867c98c99a30c9485f1dbd00f3de168ba6", "filename": "gcc/graphite.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -50,7 +50,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n-#include \"domwalk.h\"\n #include \"value-prof.h\"\n #include \"pointer-set.h\"\n #include \"gimple.h\""}, {"sha": "5ae2a7ef343d214b9360c5404fc3ee5623033185", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -1259,7 +1259,7 @@ execute_one_pass (struct opt_pass *pass)\n   if (pass->gate && !pass->gate ())\n     return false;\n \n-  if (!quiet_flag && !cfun)\n+  if (!quiet_flag)\n     fprintf (stderr, \" <%s>\", pass->name ? pass->name : \"\");\n \n   if (pass->todo_flags_start & TODO_set_props)"}, {"sha": "ab827eadc578a8bd52aaaa945f20fe80d8a388a0", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 197, "deletions": 221, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -112,6 +112,7 @@ static sbitmap old_ssa_names;\n    the operations done on them are presence tests.  */\n static sbitmap new_ssa_names;\n \n+sbitmap interesting_blocks;\n \n /* Set of SSA names that have been marked to be released after they\n    were registered in the replacement table.  They will be finally\n@@ -168,13 +169,6 @@ struct mark_def_sites_global_data\n   /* This bitmap contains the variables which are set before they\n      are used in a basic block.  */\n   bitmap kills;\n-\n-  /* Bitmap of names to rename.  */\n-  sbitmap names_to_rename;\n-\n-  /* Set of blocks that mark_def_sites deems interesting for the\n-     renamer to process.  */\n-  sbitmap interesting_blocks;\n };\n \n \n@@ -731,7 +725,7 @@ add_new_name_mapping (tree new_tree, tree old)\n    BB:\n \n    1- Variables defined by S in the DEFS of S are marked in the bitmap\n-      WALK_DATA->GLOBAL_DATA->KILLS.\n+      KILLS.\n \n    2- If S uses a variable VAR and there is no preceding kill of VAR,\n       then it is marked in the LIVEIN_BLOCKS bitmap associated with VAR.\n@@ -741,24 +735,16 @@ add_new_name_mapping (tree new_tree, tree old)\n    we create.  */\n \n static void\n-mark_def_sites (struct dom_walk_data *walk_data, basic_block bb,\n-\t\tgimple_stmt_iterator gsi)\n+mark_def_sites (basic_block bb, gimple stmt, bitmap kills)\n {\n-  struct mark_def_sites_global_data *gd;\n-  bitmap kills;\n   tree def;\n-  gimple stmt;\n   use_operand_p use_p;\n   ssa_op_iter iter;\n \n   /* Since this is the first time that we rewrite the program into SSA\n      form, force an operand scan on every statement.  */\n-  stmt = gsi_stmt (gsi);\n   update_stmt (stmt);\n \n-  gd = (struct mark_def_sites_global_data *) walk_data->global_data;\n-  kills = gd->kills;\n-\n   gcc_assert (blocks_to_update == NULL);\n   set_register_defs (stmt, false);\n   set_rewrite_uses (stmt, false);\n@@ -787,7 +773,7 @@ mark_def_sites (struct dom_walk_data *walk_data, basic_block bb,\n   /* If we found the statement interesting then also mark the block BB\n      as interesting.  */\n   if (rewrite_uses_p (stmt) || register_defs_p (stmt))\n-    SET_BIT (gd->interesting_blocks, bb->index);\n+    SET_BIT (interesting_blocks, bb->index);\n }\n \n /* Structure used by prune_unused_phi_nodes to record bounds of the intervals\n@@ -1243,39 +1229,6 @@ register_new_def (tree def, tree sym)\n       definitions are restored to the names that were valid in the\n       dominator parent of BB.  */\n \n-/* SSA Rewriting Step 1.  Initialization, create a block local stack\n-   of reaching definitions for new SSA names produced in this block\n-   (BLOCK_DEFS).  Register new definitions for every PHI node in the\n-   block.  */\n-\n-static void\n-rewrite_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t  basic_block bb)\n-{\n-  gimple phi;\n-  gimple_stmt_iterator gsi;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n-\n-  /* Mark the unwind point for this block.  */\n-  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n-\n-  /* Step 1.  Register new definitions for every PHI node in the block.\n-     Conceptually, all the PHI nodes are executed in parallel and each PHI\n-     node introduces a new version for the associated variable.  */\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      tree result;\n-\n-      phi = gsi_stmt (gsi);\n-      result = gimple_phi_result (phi);\n-      gcc_assert (is_gimple_reg (result));\n-      register_new_def (result, SSA_NAME_VAR (result));\n-    }\n-}\n-\n-\n /* Return the current definition for variable VAR.  If none is found,\n    create a new SSA name to act as the zeroth definition for VAR.  */\n \n@@ -1307,16 +1260,12 @@ get_reaching_def (tree var)\n    definition of a variable when a new real or virtual definition is found.  */\n \n static void\n-rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t      basic_block bb ATTRIBUTE_UNUSED, gimple_stmt_iterator si)\n+rewrite_stmt (gimple stmt)\n {\n-  gimple stmt;\n   use_operand_p use_p;\n   def_operand_p def_p;\n   ssa_op_iter iter;\n \n-  stmt = gsi_stmt (si);\n-\n   /* If mark_def_sites decided that we don't need to rewrite this\n      statement, ignore it.  */\n   gcc_assert (blocks_to_update == NULL);\n@@ -1357,8 +1306,7 @@ rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n    that definition is reaching the PHI node.  */\n \n static void\n-rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t   basic_block bb)\n+rewrite_add_phi_arguments (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1379,13 +1327,59 @@ rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     }\n }\n \n+/* SSA Rewriting Step 1.  Initialization, create a block local stack\n+   of reaching definitions for new SSA names produced in this block\n+   (BLOCK_DEFS).  Register new definitions for every PHI node in the\n+   block.  */\n+\n+static void\n+rewrite_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t     basic_block bb)\n+{\n+  gimple phi;\n+  gimple_stmt_iterator gsi;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n+\n+  /* Mark the unwind point for this block.  */\n+  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n+\n+  /* Step 1.  Register new definitions for every PHI node in the block.\n+     Conceptually, all the PHI nodes are executed in parallel and each PHI\n+     node introduces a new version for the associated variable.  */\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      tree result;\n+\n+      phi = gsi_stmt (gsi);\n+      result = gimple_phi_result (phi);\n+      gcc_assert (is_gimple_reg (result));\n+      register_new_def (result, SSA_NAME_VAR (result));\n+    }\n+\n+  /* Step 2.  Rewrite every variable used in each statement in the block\n+     with its immediate reaching definitions.  Update the current definition\n+     of a variable when a new real or virtual definition is found.  */\n+  if (TEST_BIT (interesting_blocks, bb->index))\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      rewrite_stmt (gsi_stmt (gsi));\n+\n+  /* Step 3.  Visit all the successor blocks of BB looking for PHI nodes.\n+     For every PHI node found, add a new argument containing the current\n+     reaching definition for the variable and the edge through which that\n+     definition is reaching the PHI node.  */\n+  rewrite_add_phi_arguments (bb);\n+}\n+\n+\n \n /* Called after visiting all the statements in basic block BB and all\n    of its dominator children.  Restore CURRDEFS to its original value.  */\n \n static void\n-rewrite_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\tbasic_block bb ATTRIBUTE_UNUSED)\n+rewrite_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t     basic_block bb ATTRIBUTE_UNUSED)\n {\n   /* Restore CURRDEFS to its original state.  */\n   while (VEC_length (tree, block_defs_stack) > 0)\n@@ -1740,103 +1734,6 @@ register_new_update_set (tree new_name, bitmap old_names)\n }\n \n \n-/* Initialization of block data structures for the incremental SSA\n-   update pass.  Create a block local stack of reaching definitions\n-   for new SSA names produced in this block (BLOCK_DEFS).  Register\n-   new definitions for every PHI node in the block.  */\n-\n-static void\n-rewrite_update_init_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t           basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  bool is_abnormal_phi;\n-  gimple_stmt_iterator gsi;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n\\nRegistering new PHI nodes in block #%d\\n\\n\",\n-\t     bb->index);\n-\n-  /* Mark the unwind point for this block.  */\n-  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n-\n-  if (!bitmap_bit_p (blocks_to_update, bb->index))\n-    return;\n-\n-  /* Mark the LHS if any of the arguments flows through an abnormal\n-     edge.  */\n-  is_abnormal_phi = false;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_ABNORMAL)\n-      {\n-\tis_abnormal_phi = true;\n-\tbreak;\n-      }\n-\n-  /* If any of the PHI nodes is a replacement for a name in\n-     OLD_SSA_NAMES or it's one of the names in NEW_SSA_NAMES, then\n-     register it as a new definition for its corresponding name.  Also\n-     register definitions for names whose underlying symbols are\n-     marked for renaming.  */\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      tree lhs, lhs_sym;\n-      gimple phi = gsi_stmt (gsi);\n-\n-      if (!register_defs_p (phi))\n-\tcontinue;\n-      \n-      lhs = gimple_phi_result (phi);\n-      lhs_sym = SSA_NAME_VAR (lhs);\n-\n-      if (symbol_marked_for_renaming (lhs_sym))\n-\tregister_new_update_single (lhs, lhs_sym);\n-      else\n-\t{\n-\n-\t  /* If LHS is a new name, register a new definition for all\n-\t     the names replaced by LHS.  */\n-\t  if (is_new_name (lhs))\n-\t    register_new_update_set (lhs, names_replaced_by (lhs));\n-\t  \n-\t  /* If LHS is an OLD name, register it as a new definition\n-\t     for itself.  */\n-\t  if (is_old_name (lhs))\n-\t    register_new_update_single (lhs, lhs);\n-\t}\n-\n-      if (is_abnormal_phi)\n-\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs) = 1;\n-    }\n-}\n-\n-\n-/* Called after visiting block BB.  Unwind BLOCK_DEFS_STACK to restore\n-   the current reaching definition of every name re-written in BB to\n-   the original reaching definition before visiting BB.  This\n-   unwinding must be done in the opposite order to what is done in\n-   register_new_update_set.  */\n-\n-static void\n-rewrite_update_fini_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t   basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  while (VEC_length (tree, block_defs_stack) > 0)\n-    {\n-      tree var = VEC_pop (tree, block_defs_stack);\n-      tree saved_def;\n-      \n-      /* NULL indicates the unwind stop point for this block (see\n-\t rewrite_update_init_block).  */\n-      if (var == NULL)\n-\treturn;\n-\n-      saved_def = VEC_pop (tree, block_defs_stack);\n-      set_current_def (var, saved_def);\n-    }\n-}\n-\n \n /* If the operand pointed to by USE_P is a name in OLD_SSA_NAMES or\n    it is a symbol marked for renaming, replace it with USE_P's current\n@@ -1905,19 +1802,12 @@ maybe_register_def (def_operand_p def_p, gimple stmt)\n    in OLD_SSA_NAMES.  */\n \n static void\n-rewrite_update_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t     basic_block bb ATTRIBUTE_UNUSED,\n-\t\t     gimple_stmt_iterator si)\n+rewrite_update_stmt (gimple stmt)\n {\n-  gimple stmt;\n   use_operand_p use_p;\n   def_operand_p def_p;\n   ssa_op_iter iter;\n \n-  stmt = gsi_stmt (si);\n-\n-  gcc_assert (bitmap_bit_p (blocks_to_update, bb->index));\n-\n   /* Only update marked statements.  */\n   if (!rewrite_uses_p (stmt) && !register_defs_p (stmt))\n     return;\n@@ -1950,8 +1840,7 @@ rewrite_update_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n    definition, replace it.  */\n \n static void\n-rewrite_update_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t      basic_block bb)\n+rewrite_update_phi_arguments (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -2005,6 +1894,114 @@ rewrite_update_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n }\n \n \n+/* Initialization of block data structures for the incremental SSA\n+   update pass.  Create a block local stack of reaching definitions\n+   for new SSA names produced in this block (BLOCK_DEFS).  Register\n+   new definitions for every PHI node in the block.  */\n+\n+static void\n+rewrite_update_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t            basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  bool is_abnormal_phi;\n+  gimple_stmt_iterator gsi;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\\nRegistering new PHI nodes in block #%d\\n\\n\",\n+\t     bb->index);\n+\n+  /* Mark the unwind point for this block.  */\n+  VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n+\n+  if (!bitmap_bit_p (blocks_to_update, bb->index))\n+    return;\n+\n+  /* Mark the LHS if any of the arguments flows through an abnormal\n+     edge.  */\n+  is_abnormal_phi = false;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_ABNORMAL)\n+      {\n+\tis_abnormal_phi = true;\n+\tbreak;\n+      }\n+\n+  /* If any of the PHI nodes is a replacement for a name in\n+     OLD_SSA_NAMES or it's one of the names in NEW_SSA_NAMES, then\n+     register it as a new definition for its corresponding name.  Also\n+     register definitions for names whose underlying symbols are\n+     marked for renaming.  */\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      tree lhs, lhs_sym;\n+      gimple phi = gsi_stmt (gsi);\n+\n+      if (!register_defs_p (phi))\n+\tcontinue;\n+      \n+      lhs = gimple_phi_result (phi);\n+      lhs_sym = SSA_NAME_VAR (lhs);\n+\n+      if (symbol_marked_for_renaming (lhs_sym))\n+\tregister_new_update_single (lhs, lhs_sym);\n+      else\n+\t{\n+\n+\t  /* If LHS is a new name, register a new definition for all\n+\t     the names replaced by LHS.  */\n+\t  if (is_new_name (lhs))\n+\t    register_new_update_set (lhs, names_replaced_by (lhs));\n+\t  \n+\t  /* If LHS is an OLD name, register it as a new definition\n+\t     for itself.  */\n+\t  if (is_old_name (lhs))\n+\t    register_new_update_single (lhs, lhs);\n+\t}\n+\n+      if (is_abnormal_phi)\n+\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs) = 1;\n+    }\n+\n+  /* Step 2.  Rewrite every variable used in each statement in the block.  */\n+  if (TEST_BIT (interesting_blocks, bb->index))\n+   {\n+     gcc_assert (bitmap_bit_p (blocks_to_update, bb->index));\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+        rewrite_update_stmt (gsi_stmt (gsi));\n+   }\n+\n+  /* Step 3.  Update PHI nodes.  */\n+  rewrite_update_phi_arguments (bb);\n+}\n+\n+/* Called after visiting block BB.  Unwind BLOCK_DEFS_STACK to restore\n+   the current reaching definition of every name re-written in BB to\n+   the original reaching definition before visiting BB.  This\n+   unwinding must be done in the opposite order to what is done in\n+   register_new_update_set.  */\n+\n+static void\n+rewrite_update_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  while (VEC_length (tree, block_defs_stack) > 0)\n+    {\n+      tree var = VEC_pop (tree, block_defs_stack);\n+      tree saved_def;\n+      \n+      /* NULL indicates the unwind stop point for this block (see\n+\t rewrite_update_enter_block).  */\n+      if (var == NULL)\n+\treturn;\n+\n+      saved_def = VEC_pop (tree, block_defs_stack);\n+      set_current_def (var, saved_def);\n+    }\n+}\n+\n+\n /* Rewrite the actual blocks, statements, and PHI arguments, to be in SSA\n    form.  \n \n@@ -2020,7 +2017,7 @@ rewrite_update_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n       are not present in BLOCKS are ignored.  */\n \n static void\n-rewrite_blocks (basic_block entry, enum rewrite_mode what, sbitmap blocks)\n+rewrite_blocks (basic_block entry, enum rewrite_mode what)\n {\n   struct dom_walk_data walk_data;\n   \n@@ -2031,31 +2028,17 @@ rewrite_blocks (basic_block entry, enum rewrite_mode what, sbitmap blocks)\n   memset (&walk_data, 0, sizeof (walk_data));\n \n   walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.interesting_blocks = blocks;\n-\n-  if (what == REWRITE_ALL)\n-    walk_data.before_dom_children_before_stmts = rewrite_initialize_block;\n-  else\n-    walk_data.before_dom_children_before_stmts = rewrite_update_init_block;\n \n   if (what == REWRITE_ALL)\n-    walk_data.before_dom_children_walk_stmts = rewrite_stmt;\n-  else if (what == REWRITE_UPDATE)\n-    walk_data.before_dom_children_walk_stmts = rewrite_update_stmt;\n-  else\n-    gcc_unreachable ();\n-\n-  if (what == REWRITE_ALL)\n-    walk_data.before_dom_children_after_stmts = rewrite_add_phi_arguments;\n-  else if (what == REWRITE_UPDATE)\n-    walk_data.before_dom_children_after_stmts = rewrite_update_phi_arguments;\n-  else\n-    gcc_unreachable ();\n-  \n-  if (what == REWRITE_ALL)\n-    walk_data.after_dom_children_after_stmts =  rewrite_finalize_block;\n+    {\n+      walk_data.before_dom_children = rewrite_enter_block;\n+      walk_data.after_dom_children = rewrite_leave_block;\n+    }\n   else if (what == REWRITE_UPDATE)\n-    walk_data.after_dom_children_after_stmts = rewrite_update_fini_block;\n+    {\n+      walk_data.before_dom_children = rewrite_update_enter_block;\n+      walk_data.after_dom_children = rewrite_update_leave_block;\n+    }\n   else\n     gcc_unreachable ();\n \n@@ -2085,53 +2068,49 @@ rewrite_blocks (basic_block entry, enum rewrite_mode what, sbitmap blocks)\n }\n \n \n-/* Block initialization routine for mark_def_sites.  Clear the \n-   KILLS bitmap at the start of each block.  */\n+/* Block processing routine for mark_def_sites.  Clear the KILLS bitmap\n+   at the start of each block, and call mark_def_sites for each statement.  */\n \n static void\n-mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n-\t\t\t\t basic_block bb ATTRIBUTE_UNUSED)\n+mark_def_sites_block (struct dom_walk_data *walk_data, basic_block bb)\n {\n   struct mark_def_sites_global_data *gd;\n+  bitmap kills;\n+  gimple_stmt_iterator gsi;\n+\n   gd = (struct mark_def_sites_global_data *) walk_data->global_data;\n-  bitmap_clear (gd->kills);\n+  kills = gd->kills;\n+\n+  bitmap_clear (kills);\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    mark_def_sites (bb, gsi_stmt (gsi), kills);\n }\n \n \n /* Mark the definition site blocks for each variable, so that we know\n    where the variable is actually live.\n \n-   INTERESTING_BLOCKS will be filled in with all the blocks that\n-      should be processed by the renamer.  It is assumed to be\n-      initialized and zeroed by the caller.  */\n+   The INTERESTING_BLOCKS global will be filled in with all the blocks\n+   that should be processed by the renamer.  It is assumed that the\n+   caller has already initialized and zeroed it.  */\n \n static void\n-mark_def_site_blocks (sbitmap interesting_blocks)\n+mark_def_site_blocks (void)\n {\n   struct dom_walk_data walk_data;\n   struct mark_def_sites_global_data mark_def_sites_global_data;\n \n   /* Setup callbacks for the generic dominator tree walker to find and\n      mark definition sites.  */\n-  walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = mark_def_sites_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = mark_def_sites;\n-  walk_data.before_dom_children_after_stmts = NULL; \n-  walk_data.after_dom_children_before_stmts =  NULL;\n-  walk_data.after_dom_children_walk_stmts =  NULL;\n-  walk_data.after_dom_children_after_stmts =  NULL;\n-  walk_data.interesting_blocks = NULL;\n+  walk_data.before_dom_children = mark_def_sites_block;\n+  walk_data.after_dom_children = NULL;\n \n   /* Notice that this bitmap is indexed using variable UIDs, so it must be\n      large enough to accommodate all the variables referenced in the\n      function, not just the ones we are renaming.  */\n   mark_def_sites_global_data.kills = BITMAP_ALLOC (NULL);\n-\n-  /* Create the set of interesting blocks that will be filled by\n-     mark_def_sites.  */\n-  mark_def_sites_global_data.interesting_blocks = interesting_blocks;\n   walk_data.global_data = &mark_def_sites_global_data;\n \n   /* We do not have any local data.  */\n@@ -2207,7 +2186,6 @@ rewrite_into_ssa (void)\n {\n   bitmap *dfs;\n   basic_block bb;\n-  sbitmap interesting_blocks;\n   \n   timevar_push (TV_TREE_SSA_OTHER);\n \n@@ -2233,19 +2211,18 @@ rewrite_into_ssa (void)\n   compute_dominance_frontiers (dfs);\n \n   /* 2- Find and mark definition sites.  */\n-  mark_def_site_blocks (interesting_blocks);\n+  mark_def_site_blocks ();\n \n   /* 3- Insert PHI nodes at dominance frontiers of definition blocks.  */\n   insert_phi_nodes (dfs);\n \n   /* 4- Rename all the blocks.  */\n-  rewrite_blocks (ENTRY_BLOCK_PTR, REWRITE_ALL, interesting_blocks);\n+  rewrite_blocks (ENTRY_BLOCK_PTR, REWRITE_ALL);\n \n   /* Free allocated memory.  */\n   FOR_EACH_BB (bb)\n     BITMAP_FREE (dfs[bb->index]);\n   free (dfs);\n-  sbitmap_free (interesting_blocks);\n \n   fini_ssa_renamer ();\n \n@@ -3079,7 +3056,6 @@ update_ssa (unsigned update_flags)\n   basic_block bb, start_bb;\n   bitmap_iterator bi;\n   unsigned i = 0;\n-  sbitmap tmp;\n   bool insert_phi_p;\n   sbitmap_iterator sbi;\n \n@@ -3235,14 +3211,14 @@ update_ssa (unsigned update_flags)\n     set_current_def (referenced_var (i), NULL_TREE);\n \n   /* Now start the renaming process at START_BB.  */\n-  tmp = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (tmp);\n+  interesting_blocks = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (interesting_blocks);\n   EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)\n-    SET_BIT (tmp, i);\n+    SET_BIT (interesting_blocks, i);\n \n-  rewrite_blocks (start_bb, REWRITE_UPDATE, tmp);\n+  rewrite_blocks (start_bb, REWRITE_UPDATE);\n \n-  sbitmap_free (tmp);\n+  sbitmap_free (interesting_blocks);\n \n   /* Debugging dumps.  */\n   if (dump_file)"}, {"sha": "f14fa09026843af37565df00823b56be257dd530", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -1358,13 +1358,10 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n   bitmap visited = NULL;\n   void *res;\n \n-  timevar_push (TV_ALIAS_STMT_WALK);\n-\n   do\n     {\n       gimple def_stmt;\n \n-      /* ???  Do we want to account this to TV_ALIAS_STMT_WALK?  */\n       res = (*walker) (ref, vuse, data);\n       if (res)\n \tbreak;\n@@ -1400,8 +1397,6 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n   if (visited)\n     BITMAP_FREE (visited);\n \n-  timevar_pop (TV_ALIAS_STMT_WALK);\n-\n   return res;\n }\n \n@@ -1445,7 +1440,6 @@ walk_aliased_vdefs_1 (tree ref, tree vdef,\n \t  return cnt;\n \t}\n \n-      /* ???  Do we want to account this to TV_ALIAS_STMT_WALK?  */\n       cnt++;\n       if ((!ref\n \t   || stmt_may_clobber_ref_p (def_stmt, ref))\n@@ -1465,15 +1459,11 @@ walk_aliased_vdefs (tree ref, tree vdef,\n   bitmap local_visited = NULL;\n   unsigned int ret;\n \n-  timevar_push (TV_ALIAS_STMT_WALK);\n-\n   ret = walk_aliased_vdefs_1 (ref, vdef, walker, data,\n \t\t\t      visited ? visited : &local_visited, 0);\n   if (local_visited)\n     BITMAP_FREE (local_visited);\n \n-  timevar_pop (TV_ALIAS_STMT_WALK);\n-\n   return ret;\n }\n "}, {"sha": "0a2c4900e8e8b957e407c81f2c366cc0fdc5af0e", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 152, "deletions": 167, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -183,9 +183,7 @@ struct opt_stats_d\n static struct opt_stats_d opt_stats;\n \n /* Local functions.  */\n-static void optimize_stmt (struct dom_walk_data *, \n-\t\t\t   basic_block,\n-\t\t\t   gimple_stmt_iterator);\n+static void optimize_stmt (basic_block, gimple_stmt_iterator);\n static tree lookup_avail_expr (gimple, bool);\n static hashval_t avail_expr_hash (const void *);\n static hashval_t real_avail_expr_hash (const void *);\n@@ -199,9 +197,8 @@ static void record_equivalences_from_incoming_edge (basic_block);\n static bool eliminate_redundant_computations (gimple_stmt_iterator *);\n static void record_equivalences_from_stmt (gimple, int);\n static void dom_thread_across_edge (struct dom_walk_data *, edge);\n-static void dom_opt_finalize_block (struct dom_walk_data *, basic_block);\n-static void dom_opt_initialize_block (struct dom_walk_data *, basic_block);\n-static void propagate_to_outgoing_edges (struct dom_walk_data *, basic_block);\n+static void dom_opt_leave_block (struct dom_walk_data *, basic_block);\n+static void dom_opt_enter_block (struct dom_walk_data *, basic_block);\n static void remove_local_expressions_from_table (void);\n static void restore_vars_to_original_value (void);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n@@ -630,21 +627,15 @@ tree_ssa_dominator_optimize (void)\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n   /* Setup callbacks for the generic dominator tree walker.  */\n-  walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = dom_opt_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = optimize_stmt;\n-  walk_data.before_dom_children_after_stmts = propagate_to_outgoing_edges;\n-  walk_data.after_dom_children_before_stmts = NULL;\n-  walk_data.after_dom_children_walk_stmts = NULL;\n-  walk_data.after_dom_children_after_stmts = dom_opt_finalize_block;\n+  walk_data.before_dom_children = dom_opt_enter_block;\n+  walk_data.after_dom_children = dom_opt_leave_block;\n   /* Right now we only attach a dummy COND_EXPR to the global data pointer.\n      When we attach more stuff we'll need to fill this out with a real\n      structure.  */\n   walk_data.global_data = NULL;\n   walk_data.block_local_data_size = 0;\n-  walk_data.interesting_blocks = NULL;\n \n   /* Now initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);\n@@ -827,24 +818,6 @@ canonicalize_comparison (gimple condstmt)\n    upon entry to BB.  Equivalences can come from the edge traversed to\n    reach BB or they may come from PHI nodes at the start of BB.  */\n \n-static void\n-dom_opt_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t  basic_block bb)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n\\nOptimizing block #%d\\n\\n\", bb->index);\n-\n-  /* Push a marker on the stacks of local information so that we know how\n-     far to unwind when we finalize this block.  */\n-  VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack, NULL);\n-  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n-\n-  record_equivalences_from_incoming_edge (bb);\n-\n-  /* PHI nodes can create equivalences too.  */\n-  record_equivalences_from_phis (bb);\n-}\n-\n /* Remove all the expressions in LOCALS from TABLE, stopping when there are\n    LIMIT entries left in LOCALs.  */\n \n@@ -935,131 +908,6 @@ dom_thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t\t      simplify_stmt_for_jump_threading);\n }\n \n-/* We have finished processing the dominator children of BB, perform\n-   any finalization actions in preparation for leaving this node in\n-   the dominator tree.  */\n-\n-static void\n-dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n-{\n-  gimple last;\n-\n-  /* If we have an outgoing edge to a block with multiple incoming and\n-     outgoing edges, then we may be able to thread the edge, i.e., we\n-     may be able to statically determine which of the outgoing edges\n-     will be traversed when the incoming edge from BB is traversed.  */\n-  if (single_succ_p (bb)\n-      && (single_succ_edge (bb)->flags & EDGE_ABNORMAL) == 0\n-      && potentially_threadable_block (single_succ (bb)))\n-    {\n-      dom_thread_across_edge (walk_data, single_succ_edge (bb));\n-    }\n-  else if ((last = last_stmt (bb))\n-\t   && gimple_code (last) == GIMPLE_COND\n-\t   && EDGE_COUNT (bb->succs) == 2\n-\t   && (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL) == 0\n-\t   && (EDGE_SUCC (bb, 1)->flags & EDGE_ABNORMAL) == 0)\n-    {\n-      edge true_edge, false_edge;\n-\n-      extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n-\n-      /* Only try to thread the edge if it reaches a target block with\n-\t more than one predecessor and more than one successor.  */\n-      if (potentially_threadable_block (true_edge->dest))\n-\t{\n-\t  struct edge_info *edge_info;\n-\t  unsigned int i;\n-\n-\t  /* Push a marker onto the available expression stack so that we\n-\t     unwind any expressions related to the TRUE arm before processing\n-\t     the false arm below.  */\n-          VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack, NULL);\n-\t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n-\n-\t  edge_info = (struct edge_info *) true_edge->aux;\n-\n-\t  /* If we have info associated with this edge, record it into\n-\t     our equivalence tables.  */\n-\t  if (edge_info)\n-\t    {\n-\t      struct cond_equivalence *cond_equivalences = edge_info->cond_equivalences;\n-\t      tree lhs = edge_info->lhs;\n-\t      tree rhs = edge_info->rhs;\n-\n-\t      /* If we have a simple NAME = VALUE equivalence, record it.  */\n-\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t\trecord_const_or_copy (lhs, rhs);\n-\n-\t      /* If we have 0 = COND or 1 = COND equivalences, record them\n-\t\t into our expression hash tables.  */\n-\t      if (cond_equivalences)\n-\t\tfor (i = 0; i < edge_info->max_cond_equivalences; i++)\n-                  record_cond (&cond_equivalences[i]);\n-\t    }\n-\n-\t  dom_thread_across_edge (walk_data, true_edge);\n-\n-\t  /* And restore the various tables to their state before\n-\t     we threaded this edge.  */\n-\t  remove_local_expressions_from_table ();\n-\t}\n-\n-      /* Similarly for the ELSE arm.  */\n-      if (potentially_threadable_block (false_edge->dest))\n-\t{\n-\t  struct edge_info *edge_info;\n-\t  unsigned int i;\n-\n-\t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n-\t  edge_info = (struct edge_info *) false_edge->aux;\n-\n-\t  /* If we have info associated with this edge, record it into\n-\t     our equivalence tables.  */\n-\t  if (edge_info)\n-\t    {\n-\t      struct cond_equivalence *cond_equivalences = edge_info->cond_equivalences;\n-\t      tree lhs = edge_info->lhs;\n-\t      tree rhs = edge_info->rhs;\n-\n-\t      /* If we have a simple NAME = VALUE equivalence, record it.  */\n-\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t\trecord_const_or_copy (lhs, rhs);\n-\n-\t      /* If we have 0 = COND or 1 = COND equivalences, record them\n-\t\t into our expression hash tables.  */\n-\t      if (cond_equivalences)\n-\t\tfor (i = 0; i < edge_info->max_cond_equivalences; i++)\n-                  record_cond (&cond_equivalences[i]);\n-\t    }\n-\n-\t  /* Now thread the edge.  */\n-\t  dom_thread_across_edge (walk_data, false_edge);\n-\n-\t  /* No need to remove local expressions from our tables\n-\t     or restore vars to their original value as that will\n-\t     be done immediately below.  */\n-\t}\n-    }\n-\n-  remove_local_expressions_from_table ();\n-  restore_vars_to_original_value ();\n-\n-  /* If we queued any statements to rescan in this block, then\n-     go ahead and rescan them now.  */\n-  while (VEC_length (gimple, stmts_to_rescan) > 0)\n-    {\n-      gimple stmt = VEC_last (gimple, stmts_to_rescan);\n-      basic_block stmt_bb = gimple_bb (stmt);\n-\n-      if (stmt_bb != bb)\n-\tbreak;\n-\n-      VEC_pop (gimple, stmts_to_rescan);\n-      update_stmt (stmt);\n-    }\n-}\n-\n /* PHI nodes can create equivalences too.\n \n    Ignoring any alternatives which are the same as the result, if\n@@ -1787,20 +1635,158 @@ record_edge_info (basic_block bb)\n     }\n }\n \n-/* Propagate information from BB to its outgoing edges.\n-\n-   This can include equivalence information implied by control statements\n-   at the end of BB and const/copy propagation into PHIs in BB's\n-   successor blocks.  */\n-\n static void\n-propagate_to_outgoing_edges (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t     basic_block bb)\n+dom_opt_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t     basic_block bb)\n {\n+  gimple_stmt_iterator gsi;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\\nOptimizing block #%d\\n\\n\", bb->index);\n+\n+  /* Push a marker on the stacks of local information so that we know how\n+     far to unwind when we finalize this block.  */\n+  VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack, NULL);\n+  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n+\n+  record_equivalences_from_incoming_edge (bb);\n+\n+  /* PHI nodes can create equivalences too.  */\n+  record_equivalences_from_phis (bb);\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    optimize_stmt (bb, gsi);\n+\n+  /* Now prepare to process dominated blocks.  */\n   record_edge_info (bb);\n   cprop_into_successor_phis (bb);\n }\n \n+/* We have finished processing the dominator children of BB, perform\n+   any finalization actions in preparation for leaving this node in\n+   the dominator tree.  */\n+\n+static void\n+dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n+{\n+  gimple last;\n+\n+  /* If we have an outgoing edge to a block with multiple incoming and\n+     outgoing edges, then we may be able to thread the edge, i.e., we\n+     may be able to statically determine which of the outgoing edges\n+     will be traversed when the incoming edge from BB is traversed.  */\n+  if (single_succ_p (bb)\n+      && (single_succ_edge (bb)->flags & EDGE_ABNORMAL) == 0\n+      && potentially_threadable_block (single_succ (bb)))\n+    {\n+      dom_thread_across_edge (walk_data, single_succ_edge (bb));\n+    }\n+  else if ((last = last_stmt (bb))\n+\t   && gimple_code (last) == GIMPLE_COND\n+\t   && EDGE_COUNT (bb->succs) == 2\n+\t   && (EDGE_SUCC (bb, 0)->flags & EDGE_ABNORMAL) == 0\n+\t   && (EDGE_SUCC (bb, 1)->flags & EDGE_ABNORMAL) == 0)\n+    {\n+      edge true_edge, false_edge;\n+\n+      extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+\n+      /* Only try to thread the edge if it reaches a target block with\n+\t more than one predecessor and more than one successor.  */\n+      if (potentially_threadable_block (true_edge->dest))\n+\t{\n+\t  struct edge_info *edge_info;\n+\t  unsigned int i;\n+\n+\t  /* Push a marker onto the available expression stack so that we\n+\t     unwind any expressions related to the TRUE arm before processing\n+\t     the false arm below.  */\n+          VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack, NULL);\n+\t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n+\n+\t  edge_info = (struct edge_info *) true_edge->aux;\n+\n+\t  /* If we have info associated with this edge, record it into\n+\t     our equivalence tables.  */\n+\t  if (edge_info)\n+\t    {\n+\t      struct cond_equivalence *cond_equivalences = edge_info->cond_equivalences;\n+\t      tree lhs = edge_info->lhs;\n+\t      tree rhs = edge_info->rhs;\n+\n+\t      /* If we have a simple NAME = VALUE equivalence, record it.  */\n+\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\t\trecord_const_or_copy (lhs, rhs);\n+\n+\t      /* If we have 0 = COND or 1 = COND equivalences, record them\n+\t\t into our expression hash tables.  */\n+\t      if (cond_equivalences)\n+\t\tfor (i = 0; i < edge_info->max_cond_equivalences; i++)\n+                  record_cond (&cond_equivalences[i]);\n+\t    }\n+\n+\t  dom_thread_across_edge (walk_data, true_edge);\n+\n+\t  /* And restore the various tables to their state before\n+\t     we threaded this edge.  */\n+\t  remove_local_expressions_from_table ();\n+\t}\n+\n+      /* Similarly for the ELSE arm.  */\n+      if (potentially_threadable_block (false_edge->dest))\n+\t{\n+\t  struct edge_info *edge_info;\n+\t  unsigned int i;\n+\n+\t  VEC_safe_push (tree, heap, const_and_copies_stack, NULL_TREE);\n+\t  edge_info = (struct edge_info *) false_edge->aux;\n+\n+\t  /* If we have info associated with this edge, record it into\n+\t     our equivalence tables.  */\n+\t  if (edge_info)\n+\t    {\n+\t      struct cond_equivalence *cond_equivalences = edge_info->cond_equivalences;\n+\t      tree lhs = edge_info->lhs;\n+\t      tree rhs = edge_info->rhs;\n+\n+\t      /* If we have a simple NAME = VALUE equivalence, record it.  */\n+\t      if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\t\trecord_const_or_copy (lhs, rhs);\n+\n+\t      /* If we have 0 = COND or 1 = COND equivalences, record them\n+\t\t into our expression hash tables.  */\n+\t      if (cond_equivalences)\n+\t\tfor (i = 0; i < edge_info->max_cond_equivalences; i++)\n+                  record_cond (&cond_equivalences[i]);\n+\t    }\n+\n+\t  /* Now thread the edge.  */\n+\t  dom_thread_across_edge (walk_data, false_edge);\n+\n+\t  /* No need to remove local expressions from our tables\n+\t     or restore vars to their original value as that will\n+\t     be done immediately below.  */\n+\t}\n+    }\n+\n+  remove_local_expressions_from_table ();\n+  restore_vars_to_original_value ();\n+\n+  /* If we queued any statements to rescan in this block, then\n+     go ahead and rescan them now.  */\n+  while (VEC_length (gimple, stmts_to_rescan) > 0)\n+    {\n+      gimple stmt = VEC_last (gimple, stmts_to_rescan);\n+      basic_block stmt_bb = gimple_bb (stmt);\n+\n+      if (stmt_bb != bb)\n+\tbreak;\n+\n+      VEC_pop (gimple, stmts_to_rescan);\n+      update_stmt (stmt);\n+    }\n+}\n+\n /* Search for redundant computations in STMT.  If any are found, then\n    replace them with the variable holding the result of the computation.\n \n@@ -2114,8 +2100,7 @@ cprop_into_stmt (gimple stmt)\n       the variable in the LHS in the CONST_AND_COPIES table.  */\n \n static void\n-optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t       basic_block bb, gimple_stmt_iterator si)\n+optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n {\n   gimple stmt, old_stmt;\n   bool may_optimize_p;"}, {"sha": "9559b4cb2f580d3cc0b47d1d9f70bce652173b9d", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -89,11 +89,8 @@ static unsigned int tree_ssa_dse (void);\n static void dse_initialize_block_local_data (struct dom_walk_data *,\n \t\t\t\t\t     basic_block,\n \t\t\t\t\t     bool);\n-static void dse_optimize_stmt (struct dom_walk_data *,\n-\t\t\t       basic_block,\n-\t\t\t       gimple_stmt_iterator);\n-static void dse_record_phis (struct dom_walk_data *, basic_block);\n-static void dse_finalize_block (struct dom_walk_data *, basic_block);\n+static void dse_enter_block (struct dom_walk_data *, basic_block);\n+static void dse_leave_block (struct dom_walk_data *, basic_block);\n static void record_voperand_set (bitmap, bitmap *, unsigned int);\n \n /* Returns uid of statement STMT.  */\n@@ -267,15 +264,10 @@ dse_possible_dead_store_p (gimple stmt, gimple *use_stmt)\n    post dominates the first store, then the first store is dead.  */\n \n static void\n-dse_optimize_stmt (struct dom_walk_data *walk_data,\n-\t\t   basic_block bb ATTRIBUTE_UNUSED,\n+dse_optimize_stmt (struct dse_global_data *dse_gd,\n+\t\t   struct dse_block_local_data *bd,\n \t\t   gimple_stmt_iterator gsi)\n {\n-  struct dse_block_local_data *bd\n-    = (struct dse_block_local_data *)\n-\tVEC_last (void_p, walk_data->block_data_stack);\n-  struct dse_global_data *dse_gd\n-    = (struct dse_global_data *) walk_data->global_data;\n   gimple stmt = gsi_stmt (gsi);\n \n   /* If this statement has no virtual defs, then there is nothing\n@@ -351,27 +343,33 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n /* Record that we have seen the PHIs at the start of BB which correspond\n    to virtual operands.  */\n static void\n-dse_record_phis (struct dom_walk_data *walk_data, basic_block bb)\n+dse_record_phi (struct dse_global_data *dse_gd,\n+\t\tstruct dse_block_local_data *bd,\n+\t\tgimple phi)\n+{\n+  if (!is_gimple_reg (gimple_phi_result (phi)))\n+    record_voperand_set (dse_gd->stores, &bd->stores, get_stmt_uid (phi));\n+}\n+\n+static void\n+dse_enter_block (struct dom_walk_data *walk_data, basic_block bb)\n {\n   struct dse_block_local_data *bd\n     = (struct dse_block_local_data *)\n \tVEC_last (void_p, walk_data->block_data_stack);\n   struct dse_global_data *dse_gd\n     = (struct dse_global_data *) walk_data->global_data;\n-  gimple phi;\n   gimple_stmt_iterator gsi;\n \n+  for (gsi = gsi_last (bb_seq (bb)); !gsi_end_p (gsi); gsi_prev (&gsi))\n+    dse_optimize_stmt (dse_gd, bd, gsi);\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      phi = gsi_stmt (gsi);\n-      if (!is_gimple_reg (gimple_phi_result (phi)))\n-\trecord_voperand_set (dse_gd->stores, &bd->stores, get_stmt_uid (phi));\n-    }\n+    dse_record_phi (dse_gd, bd, gsi_stmt (gsi));\n }\n \n static void\n-dse_finalize_block (struct dom_walk_data *walk_data,\n-\t\t    basic_block bb ATTRIBUTE_UNUSED)\n+dse_leave_block (struct dom_walk_data *walk_data,\n+\t\t basic_block bb ATTRIBUTE_UNUSED)\n {\n   struct dse_block_local_data *bd\n     = (struct dse_block_local_data *)\n@@ -409,16 +407,10 @@ tree_ssa_dse (void)\n \n   /* Dead store elimination is fundamentally a walk of the post-dominator\n      tree and a backwards walk of statements within each block.  */\n-  walk_data.walk_stmts_backward = true;\n   walk_data.dom_direction = CDI_POST_DOMINATORS;\n   walk_data.initialize_block_local_data = dse_initialize_block_local_data;\n-  walk_data.before_dom_children_before_stmts = NULL;\n-  walk_data.before_dom_children_walk_stmts = dse_optimize_stmt;\n-  walk_data.before_dom_children_after_stmts = dse_record_phis;\n-  walk_data.after_dom_children_before_stmts = NULL;\n-  walk_data.after_dom_children_walk_stmts = NULL;\n-  walk_data.after_dom_children_after_stmts = dse_finalize_block;\n-  walk_data.interesting_blocks = NULL;\n+  walk_data.before_dom_children = dse_enter_block;\n+  walk_data.after_dom_children = dse_leave_block;\n \n   walk_data.block_local_data_size = sizeof (struct dse_block_local_data);\n "}, {"sha": "d8ee787cc470bdbfa272fd529802c5d46eecc97c", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -999,7 +999,7 @@ determine_invariantness (void)\n \n   memset (&walk_data, 0, sizeof (struct dom_walk_data));\n   walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.before_dom_children_before_stmts = determine_invariantness_stmt;\n+  walk_data.before_dom_children = determine_invariantness_stmt;\n \n   init_walk_dominator_tree (&walk_data);\n   walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n@@ -1073,7 +1073,7 @@ move_computations (void)\n \n   memset (&walk_data, 0, sizeof (struct dom_walk_data));\n   walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.before_dom_children_before_stmts = move_computations_stmt;\n+  walk_data.before_dom_children = move_computations_stmt;\n \n   init_walk_dominator_tree (&walk_data);\n   walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);"}, {"sha": "8f200be81c11062f835a452b262d90c5bfe3265e", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -32,7 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dump.h\"\n #include \"timevar.h\"\n #include \"cfgloop.h\"\n-#include \"domwalk.h\"\n #include \"params.h\"\n #include \"tree-pass.h\"\n #include \"tree-inline.h\""}, {"sha": "8c3f71d32b6a73e3faeb85adad3349054b00ccad", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -1139,18 +1139,12 @@ get_non_trapping (void)\n \n   /* Setup callbacks for the generic dominator tree walker.  */\n   nontrap_set = nontrap;\n-  walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = nt_init_block;\n-  walk_data.before_dom_children_walk_stmts = NULL;\n-  walk_data.before_dom_children_after_stmts = NULL;\n-  walk_data.after_dom_children_before_stmts = NULL;\n-  walk_data.after_dom_children_walk_stmts = NULL;\n-  walk_data.after_dom_children_after_stmts = nt_fini_block;\n+  walk_data.before_dom_children = nt_init_block;\n+  walk_data.after_dom_children = nt_fini_block;\n   walk_data.global_data = NULL;\n   walk_data.block_local_data_size = 0;\n-  walk_data.interesting_blocks = NULL;\n \n   init_walk_dominator_tree (&walk_data);\n   walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);"}, {"sha": "f503ffc9271bd516c2355e01367eb8db84f512c5", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -36,7 +36,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"tree-dump.h\"\n #include \"tree-flow.h\"\n-#include \"domwalk.h\"\n #include \"real.h\"\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\""}, {"sha": "1efea61bae0e06b4616a4ca4bcf12a2ed6fd740f", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf5c864c9bae45e3c1a9858529f346005e5ca25/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=ccf5c864c9bae45e3c1a9858529f346005e5ca25", "patch": "@@ -289,9 +289,9 @@ struct equiv_hash_elt\n   VEC(tree,heap) *equivalences;\n };\n \n-static void uncprop_initialize_block (struct dom_walk_data *, basic_block);\n-static void uncprop_finalize_block (struct dom_walk_data *, basic_block);\n-static void uncprop_into_successor_phis (struct dom_walk_data *, basic_block);\n+static void uncprop_enter_block (struct dom_walk_data *, basic_block);\n+static void uncprop_leave_block (struct dom_walk_data *, basic_block);\n+static void uncprop_into_successor_phis (basic_block);\n \n /* Hashing and equality routines for the hash table.  */\n \n@@ -381,18 +381,12 @@ tree_ssa_uncprop (void)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   /* Setup callbacks for the generic dominator tree walker.  */\n-  walk_data.walk_stmts_backward = false;\n   walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children_before_stmts = uncprop_initialize_block;\n-  walk_data.before_dom_children_walk_stmts = NULL;\n-  walk_data.before_dom_children_after_stmts = uncprop_into_successor_phis;\n-  walk_data.after_dom_children_before_stmts = NULL;\n-  walk_data.after_dom_children_walk_stmts = NULL;\n-  walk_data.after_dom_children_after_stmts = uncprop_finalize_block;\n+  walk_data.before_dom_children = uncprop_enter_block;\n+  walk_data.after_dom_children = uncprop_leave_block;\n   walk_data.global_data = NULL;\n   walk_data.block_local_data_size = 0;\n-  walk_data.interesting_blocks = NULL;\n \n   /* Now initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);\n@@ -432,8 +426,8 @@ tree_ssa_uncprop (void)\n    the dominator tree.  */\n \n static void\n-uncprop_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\tbasic_block bb ATTRIBUTE_UNUSED)\n+uncprop_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t     basic_block bb ATTRIBUTE_UNUSED)\n {\n   /* Pop the topmost value off the equiv stack.  */\n   tree value = VEC_pop (tree, equiv_stack);\n@@ -447,8 +441,7 @@ uncprop_finalize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n /* Unpropagate values from PHI nodes in successor blocks of BB.  */\n \n static void\n-uncprop_into_successor_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t     basic_block bb)\n+uncprop_into_successor_phis (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -476,7 +469,6 @@ uncprop_into_successor_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n       /* Walk over the PHI nodes, unpropagating values.  */\n       for (gsi = gsi_start (phis) ; !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  /* Sigh.  We'll have more efficient access to this one day.  */\n \t  gimple phi = gsi_stmt (gsi);\n \t  tree arg = PHI_ARG_DEF (phi, e->dest_idx);\n \t  struct equiv_hash_elt equiv_hash_elt;\n@@ -556,8 +548,8 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n }\n \n static void\n-uncprop_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t  basic_block bb)\n+uncprop_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t     basic_block bb)\n {\n   basic_block parent;\n   edge e;\n@@ -583,6 +575,8 @@ uncprop_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n   if (!recorded)\n     VEC_safe_push (tree, heap, equiv_stack, NULL_TREE);\n+\n+  uncprop_into_successor_phis (bb);\n }\n \n static bool"}]}