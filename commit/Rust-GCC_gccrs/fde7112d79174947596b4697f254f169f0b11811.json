{"sha": "fde7112d79174947596b4697f254f169f0b11811", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRlNzExMmQ3OTE3NDk0NzU5NmI0Njk3ZjI1NGYxNjlmMGIxMTgxMQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2019-11-12T19:33:10Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2019-11-12T19:33:10Z"}, "message": "PR fortran/92470 Fixes for CFI_address\n\n        libgfortran/\n        PR fortran/92470\n        * runtime/ISO_Fortran_binding.c (CFI_address): Handle non-zero\n        lower_bound; update error message.\n        (CFI_allocate): Fix comment typo.\n        (CFI_establish): Fix identation, fix typos, don't check values of 'dv'\n        argument.\n\n        gcc/testsuite/\n        PR fortran/92470\n        * gfortran.dg/ISO_Fortran_binding_17.c: New.\n        * gfortran.dg/ISO_Fortran_binding_17.f90: New.\n        * gfortran.dg/ISO_Fortran_binding_1.c (elemental_mult_c, allocate_c,\n        section_c, select_part_c): Update for CFI_{address} changes;\n        add asserts.\n\nFrom-SVN: r278101", "tree": {"sha": "0cd1794f67116522ffea80ef46db50c6bb33fc63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cd1794f67116522ffea80ef46db50c6bb33fc63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fde7112d79174947596b4697f254f169f0b11811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde7112d79174947596b4697f254f169f0b11811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fde7112d79174947596b4697f254f169f0b11811", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fde7112d79174947596b4697f254f169f0b11811/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d200a49f5c83fa0f2e7332aecf69b6ab4a51b052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d200a49f5c83fa0f2e7332aecf69b6ab4a51b052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d200a49f5c83fa0f2e7332aecf69b6ab4a51b052"}], "stats": {"total": 216, "additions": 178, "deletions": 38}, "files": [{"sha": "3ee50a6eaec05fa32e157f214e18eaca392f339d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde7112d79174947596b4697f254f169f0b11811/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde7112d79174947596b4697f254f169f0b11811/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fde7112d79174947596b4697f254f169f0b11811", "patch": "@@ -1,3 +1,12 @@\n+2019-11-12  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR fortran/92470\n+\t* gfortran.dg/ISO_Fortran_binding_17.c: New.\n+\t* gfortran.dg/ISO_Fortran_binding_17.f90: New.\n+\t* gfortran.dg/ISO_Fortran_binding_1.c (elemental_mult_c, allocate_c,\n+\tsection_c, select_part_c): Update for CFI_{address} changes;\n+\tadd asserts.\n+\n 2019-11-12  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/92412"}, {"sha": "091e754d8f96afce5b3c468a3f0ed8f3b0f74b2d", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.c", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde7112d79174947596b4697f254f169f0b11811/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde7112d79174947596b4697f254f169f0b11811/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.c?ref=fde7112d79174947596b4697f254f169f0b11811", "patch": "@@ -1,6 +1,7 @@\n /* Test F2008 18.5: ISO_Fortran_binding.h functions.  */\n \n #include \"../../../libgfortran/ISO_Fortran_binding.h\"\n+#include <assert.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <complex.h>\n@@ -33,13 +34,34 @@ int elemental_mult_c(CFI_cdesc_t * a_desc, CFI_cdesc_t * b_desc,\n       || c_desc->rank != 2)\n     return err;\n \n-  for (idx[0] = 0; idx[0] < a_desc->dim[0].extent; idx[0]++)\n-    for (idx[1] = 0; idx[1] < a_desc->dim[1].extent; idx[1]++)\n-      {\n-\tres_addr = CFI_address (a_desc, idx);\n-\t*res_addr = *(int*)CFI_address (b_desc, idx)\n-\t\t    * *(int*)CFI_address (c_desc, idx);\n-      }\n+  if (a_desc->attribute == CFI_attribute_other)\n+    {\n+      assert (a_desc->dim[0].lower_bound == 0);\n+      assert (a_desc->dim[1].lower_bound == 0);\n+      for (idx[0] = 0; idx[0] < a_desc->dim[0].extent; idx[0]++)\n+\tfor (idx[1] = 0; idx[1] < a_desc->dim[1].extent; idx[1]++)\n+\t  {\n+\t    res_addr = CFI_address (a_desc, idx);\n+\t    *res_addr = *(int*)CFI_address (b_desc, idx)\n+\t\t\t* *(int*)CFI_address (c_desc, idx);\n+\t  }\n+    }\n+  else\n+    {\n+      assert (a_desc->attribute == CFI_attribute_allocatable\n+\t      || a_desc->attribute == CFI_attribute_pointer);\n+      for (idx[0] = a_desc->dim[0].lower_bound;\n+\t   idx[0] < a_desc->dim[0].extent + a_desc->dim[0].lower_bound;\n+\t   idx[0]++)\n+\tfor (idx[1] = a_desc->dim[1].lower_bound;\n+\t     idx[1] < a_desc->dim[1].extent + a_desc->dim[1].lower_bound;\n+\t     idx[1]++)\n+\t  {\n+\t    res_addr = CFI_address (a_desc, idx);\n+\t    *res_addr = *(int*)CFI_address (b_desc, idx)\n+\t\t\t* *(int*)CFI_address (c_desc, idx);\n+\t  }\n+    }\n \n   return 0;\n }\n@@ -57,15 +79,16 @@ int allocate_c(CFI_cdesc_t * da, CFI_index_t lower[], CFI_index_t upper[])\n   CFI_index_t idx[2];\n   int *res_addr;\n \n+  if (da->attribute == CFI_attribute_other) return err;\n   if (CFI_allocate(da, lower, upper, 0)) return err;\n+  assert (da->dim[0].lower_bound == lower[0]);\n+  assert (da->dim[1].lower_bound == lower[1]);\n \n-\n-  for (idx[0] = 0; idx[0] < da->dim[0].extent; idx[0]++)\n-    for (idx[1] = 0; idx[1] < da->dim[1].extent; idx[1]++)\n+  for (idx[0] = lower[0]; idx[0] < da->dim[0].extent + lower[0]; idx[0]++)\n+    for (idx[1] = lower[1]; idx[1] < da->dim[1].extent + lower[1]; idx[1]++)\n       {\n \tres_addr = CFI_address (da, idx);\n-\t*res_addr = (int)((idx[0] + da->dim[0].lower_bound)\n-\t\t\t  * (idx[1] + da->dim[1].lower_bound));\n+\t*res_addr = (int)(idx[0] * idx[1]);\n       }\n \n   return 0;\n@@ -118,10 +141,11 @@ float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)\n \t\t\t  CFI_type_float, 0, 1, NULL);\n       if (ind) return -1.0;\n       ind = CFI_section((CFI_cdesc_t *)&section, source, lower, NULL, strides);\n+      assert (section.dim[0].lower_bound == lower[0]);\n       if (ind) return -2.0;\n \n       /* Sum over the section  */\n-      for (idx[0] = 0; idx[0] < section.dim[0].extent; idx[0]++)\n+      for (idx[0] = lower[0]; idx[0] < section.dim[0].extent + lower[0]; idx[0]++)\n         ans += *(float*)CFI_address ((CFI_cdesc_t*)&section, idx);\n       return ans;\n     }\n@@ -138,10 +162,12 @@ float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)\n       if (ind) return -1.0;\n       ind = CFI_section((CFI_cdesc_t *)&section, source,\n \t\t\tlower, upper, strides);\n+      assert (section.rank == 1);\n+      assert (section.dim[0].lower_bound == lower[0]);\n       if (ind) return -2.0;\n \n       /* Sum over the section  */\n-      for (idx[0] = 0; idx[0] < section.dim[0].extent; idx[0]++)\n+      for (idx[0] = lower[0]; idx[0] < section.dim[0].extent + lower[0]; idx[0]++)\n         ans += *(float*)CFI_address ((CFI_cdesc_t*)&section, idx);\n       return ans;\n     }\n@@ -166,6 +192,8 @@ double select_part_c (CFI_cdesc_t * source)\n \t\t      CFI_type_double_Complex, sizeof(double _Complex),\n \t\t      2, extent);\n   (void)CFI_select_part(comp_cdesc, source, offsetof(t,y), 0);\n+  assert (comp_cdesc->dim[0].lower_bound == 0);\n+  assert (comp_cdesc->dim[1].lower_bound == 0);\n \n   /* Sum over comp_cdesc[4,:]  */\n   size = comp_cdesc->dim[1].extent;"}, {"sha": "b0893cc15e8490ddbc70ea1912d08ac4b0fee2d3", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde7112d79174947596b4697f254f169f0b11811/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde7112d79174947596b4697f254f169f0b11811/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.c?ref=fde7112d79174947596b4697f254f169f0b11811", "patch": "@@ -0,0 +1,25 @@\n+/* PR fortran/92470  - to be used with ISO_Fortran_binding_17.f90 */\n+\n+#include <stdio.h>\n+#include <assert.h>\n+#include \"ISO_Fortran_binding.h\"\n+\n+void Csub(const CFI_cdesc_t *, size_t, CFI_index_t invalid);\n+\n+void Csub(const CFI_cdesc_t * dv, size_t locd, CFI_index_t invalid) {\n+\n+   CFI_index_t lb[1];\n+   lb[0] = dv->dim[0].lower_bound;\n+   size_t ld = (size_t)CFI_address(dv, lb);\n+\n+   if (ld != locd)\n+     printf (\"In C function: CFI_address of dv = %I64x\\n\", ld);\n+   assert( ld == locd );\n+\n+   lb[0] = invalid;\n+   /* Shall return NULL and produce stderr diagnostic with -fcheck=array.  */\n+   ld = (size_t)CFI_address(dv, lb);\n+   assert (ld == 0);\n+\n+   return;\n+}"}, {"sha": "bb3093152610581bda168be755414fd825753cc7", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_17.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde7112d79174947596b4697f254f169f0b11811/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde7112d79174947596b4697f254f169f0b11811/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_17.f90?ref=fde7112d79174947596b4697f254f169f0b11811", "patch": "@@ -0,0 +1,77 @@\n+! { dg-do run }\n+! { dg-additional-sources ISO_Fortran_binding_17.c }\n+! { dg-options \"-fcheck=all\" }\n+! { dg-warning \"command-line option '-fcheck=all' is valid for Fortran but not for C\" \"\" { target *-*-* } 0 }\n+!\n+! PR fortran/92470\n+!\n+! https://github.com/j3-fortran/fortran_proposals/issues/57#issuecomment-552680503\n+!\n+! Unit Test #: Test-1.F2018-2.7.5\n+! Author     : FortranFan\n+! Reference  : The New Features of Fortran 2018, John Reid, August 2, 2018\n+!              ISO/IEC JTC1/SC22/WG5 N2161\n+! Description:\n+! Test item 2.7.5 Fortran subscripting\n+! void *CFI_address(const CFI_cdesc_t *dv, const CFI_index_t subscripts[]);\n+! that returns the C address of a scalar or of an element of an array using\n+! Fortran sub-scripting.\n+!\n+   use, intrinsic :: iso_c_binding, only: c_int, c_size_t, c_loc\n+   implicit none\n+\n+   integer, parameter :: LB_A = -2\n+   integer, parameter :: UB_A = 1\n+   character(len=*), parameter :: fmtg = \"(*(g0,1x))\"\n+   character(len=*), parameter :: fmth = \"(g0,1x,z0)\"\n+\n+   blk1: block\n+      interface\n+         subroutine Csub(a, loc_a_1, invalid_idx) bind(C, name=\"Csub\")\n+            import :: c_size_t\n+            type(*), intent(in) :: a(:)\n+            integer(c_size_t), intent(in), value :: loc_a_1, invalid_idx\n+         end subroutine\n+      end interface\n+\n+      integer(c_int), target :: a( LB_A:UB_A )\n+      integer(c_size_t) :: loc_a\n+\n+      print fmtg, \"Block 1\"\n+\n+      loc_a = transfer( c_loc(a(lbound(a,dim=1))), mold=loc_a)\n+      print fmth, \"Address of a: \", loc_a\n+\n+      call Csub(a, loc_a, -1_c_size_t) ! LB starts at 0\n+      call Csub(a, loc_a, 5_c_size_t)  ! 4 elements + 1\n+      print *\n+   end block blk1\n+\n+   blk2: block\n+      interface\n+         subroutine Csub(a, loc_a_1, invalid_idx) bind(C, name=\"Csub\")\n+            import :: c_int, c_size_t\n+            integer(kind=c_int), allocatable, intent(in) :: a(:)\n+            integer(c_size_t), intent(in), value :: loc_a_1, invalid_idx\n+         end subroutine\n+      end interface\n+\n+      integer(c_int), allocatable, target :: a(:)\n+      integer(c_size_t) :: loc_a\n+\n+      print fmtg, \"Block 2\"\n+\n+      allocate( a( LB_A:UB_A ) )\n+      loc_a = transfer( c_loc(a(lbound(a,dim=1))), mold=loc_a )\n+      print fmth, \"Address of a: \", loc_a\n+\n+      call Csub(a, loc_a, LB_A-1_c_size_t)\n+      call Csub(a, loc_a, UB_A+1_c_size_t)\n+      print *\n+   end block blk2\n+end\n+\n+! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = -1, lower_bound = 0, upper bound = 4, extend = 4(\\n|\\r\\n|\\r)\" }\n+! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = 5, lower_bound = 0, upper bound = 4, extend = 4(\\n|\\r\\n|\\r).*\" }\n+! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = -3, lower_bound = -2, upper bound = 6, extend = 4(\\n|\\r\\n|\\r)\" }\n+! { dg-output \"CFI_address: subscripts\\\\\\[0\\\\\\] is out of bounds. For dimension = 0, subscripts = 2, lower_bound = -2, upper bound = 6, extend = 4(\\n|\\r\\n|\\r)\" }"}, {"sha": "1abdd6a4f24e02863e70d0f205cff24dc9f5f374", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde7112d79174947596b4697f254f169f0b11811/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde7112d79174947596b4697f254f169f0b11811/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=fde7112d79174947596b4697f254f169f0b11811", "patch": "@@ -1,3 +1,12 @@\n+2019-11-12  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\tPR fortran/92470\n+\t* runtime/ISO_Fortran_binding.c (CFI_address): Handle non-zero\n+\tlower_bound; update error message.\n+\t(CFI_allocate): Fix comment typo.\n+\t(CFI_establish): Fix identation, fix typos, don't check values of 'dv'\n+\targument.\n+\n 2019-11-11  Jos\u00e9 Rui Faustino de Sousa  <jrfsousa@gmail.com>\n \n \tPR fortran/92142"}, {"sha": "7ae2a9351da4a0529b4c9315b757c98d3117790a", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fde7112d79174947596b4697f254f169f0b11811/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fde7112d79174947596b4697f254f169f0b11811/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=fde7112d79174947596b4697f254f169f0b11811", "patch": "@@ -177,19 +177,21 @@ void *CFI_address (const CFI_cdesc_t *dv, const CFI_index_t subscripts[])\n \t specified by subscripts. */\n       for (i = 0; i < dv->rank; i++)\n \t{\n+\t  CFI_index_t idx = subscripts[i] - dv->dim[i].lower_bound;\n \t  if (unlikely (compile_options.bounds_check)\n-\t      && ((dv->dim[i].extent != -1\n-\t\t   && subscripts[i] >= dv->dim[i].extent)\n-\t\t  || subscripts[i] < 0))\n+\t      && ((dv->dim[i].extent != -1 && idx >= dv->dim[i].extent)\n+\t\t  || idx < 0))\n \t    {\n-\t      fprintf (stderr, \"CFI_address: subscripts[%d], is out of \"\n-\t\t       \"bounds. dv->dim[%d].extent = %d subscripts[%d] \"\n-\t\t       \"= %d.\\n\", i, i, (int)dv->dim[i].extent, i,\n-\t\t       (int)subscripts[i]);\n+\t      fprintf (stderr, \"CFI_address: subscripts[%d] is out of \"\n+\t\t       \"bounds. For dimension = %d, subscripts = %d, \"\n+\t\t       \"lower_bound = %d, upper bound = %d, extend = %d\\n\",\n+\t\t       i, i, (int)subscripts[i], (int)dv->dim[i].lower_bound,\n+\t\t       (int)(dv->dim[i].extent - dv->dim[i].lower_bound),\n+\t\t       (int)dv->dim[i].extent);\n               return NULL;\n             }\n \n-\t  base_addr = base_addr + (CFI_index_t)(subscripts[i] * dv->dim[i].sm);\n+\t  base_addr = base_addr + (CFI_index_t)(idx * dv->dim[i].sm);\n \t}\n     }\n \n@@ -228,7 +230,7 @@ CFI_allocate (CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],\n     }\n \n   /* If the type is a character, the descriptor's element length is replaced\n-   * by the elem_len argument. */\n+     by the elem_len argument. */\n   if (dv->type == CFI_type_char || dv->type == CFI_type_ucs4_char ||\n       dv->type == CFI_type_signed_char)\n     dv->elem_len = elem_len;\n@@ -237,7 +239,7 @@ CFI_allocate (CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],\n   size_t arr_len = 1;\n \n   /* If rank is greater than 0, lower_bounds and upper_bounds are used. They're\n-   * ignored otherwhise. */\n+     ignored otherwise. */\n   if (dv->rank > 0)\n     {\n       if (unlikely (compile_options.bounds_check)\n@@ -325,20 +327,10 @@ int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,\n \t{\n \t  fprintf (stderr, \"CFI_establish: Rank must be between 0 and %d, \"\n \t\t   \"0 < rank (0 !< %d).\\n\", CFI_MAX_RANK, (int)rank);\n-      return CFI_INVALID_RANK;\n-    }\n-\n-      /* C Descriptor must not be an allocated allocatable. */\n-      if (dv->attribute == CFI_attribute_allocatable && dv->base_addr != NULL)\n-\t{\n-\t  fprintf (stderr, \"CFI_establish: If the C Descriptor represents an \"\n-\t\t   \"allocatable variable (dv->attribute = %d), its base \"\n-\t\t   \"address must be NULL (dv->base_addr = NULL).\\n\",\n-\t\t   CFI_attribute_allocatable);\n-\t  return CFI_INVALID_DESCRIPTOR;\n+\t  return CFI_INVALID_RANK;\n \t}\n \n-       /* If base address is not NULL, the established C Descriptor is for a\n+      /* If base address is not NULL, the established C Descriptor is for a\n \t  nonallocatable entity. */\n       if (attribute == CFI_attribute_allocatable && base_addr != NULL)\n \t{\n@@ -382,13 +374,13 @@ int CFI_establish (CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,\n   dv->type = type;\n \n   /* Extents must not be NULL if rank is greater than zero and base_addr is not\n-   * NULL */\n+     NULL */\n   if (rank > 0 && base_addr != NULL)\n     {\n       if (unlikely (compile_options.bounds_check) && extents == NULL)\n         {\n \t  fprintf (stderr, \"CFI_establish: Extents must not be NULL \"\n-\t\t   \"(extents != NULL) if rank (= %d) > 0 nd base address\"\n+\t\t   \"(extents != NULL) if rank (= %d) > 0 and base address \"\n \t\t   \"is not NULL (base_addr != NULL).\\n\", (int)rank);\n \t  return CFI_INVALID_EXTENT;\n \t}"}]}