{"sha": "45b44fbed7110d8388a4eb4c0c16b39e35c4c16c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDViNDRmYmVkNzExMGQ4Mzg4YTRlYjRjMGMxNmIzOWUzNWM0YzE2Yw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-23T10:46:39Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-23T10:46:39Z"}, "message": "expr.c (process_jvm_instruction): Do load_type_state after JSR.\n\na\n\t* expr.c (process_jvm_instruction):  Do load_type_state after JSR.\n\t* verify.c (verify_jvm_instructions):  Fix off-by-one error.\n\t* jcf-write.c (CHECK_PUT):  Add (void) cast to avoid -Wall warnings.\n\t(localvar_alloc):  Change return type to void,\n\t(emit_unop):  Remove unused variable size.\n\t* jcf-write.c (struct jcf_block):  Add new union.\n\t(PENDING_CLEANUP_PC, PENDING_EXIT_PC, UNDEFINED_PC):  New macros.\n\t(call_cleanups):  New functions.\n\t(struct jcf_partial):  New fields num_finalizers and return_value_decl.\n\t(generate_bytecode_insns):  Support CLEANUP_POINT_EXPR and\n\tWITH_CLEANUP_EXPR.  Handle cleanups in RETURN_EXPR and EXIT_BLOCK_EXPR.\n\t* lang.c (lang_init):  Call using_eh_for_cleanups.\n\t* parse.y (java_complete_lhs):  For SYNCHRONIZED_EXPR, defer\n\tcompleting operands to patch_synchronized_statement.\n\tSupport CLEANUP_POINT_EXPR, WITH_CLEANUP_EXPR.\n\t(patch_synchronized_statement): Re-write suing CLEANUP_POINT_EXPR and\n\tWITH_CLEANUP_EXPR instead of TRY_EXPR.\n\nFrom-SVN: r24404", "tree": {"sha": "83bb261f70c82cce1bc6aa57cf487cf178f4c1e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83bb261f70c82cce1bc6aa57cf487cf178f4c1e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45b44fbed7110d8388a4eb4c0c16b39e35c4c16c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b44fbed7110d8388a4eb4c0c16b39e35c4c16c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b44fbed7110d8388a4eb4c0c16b39e35c4c16c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b44fbed7110d8388a4eb4c0c16b39e35c4c16c/comments", "author": null, "committer": null, "parents": [{"sha": "973838fdb39b9e8b41431189af47dcb422b7878b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973838fdb39b9e8b41431189af47dcb422b7878b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973838fdb39b9e8b41431189af47dcb422b7878b"}], "stats": {"total": 190, "additions": 166, "deletions": 24}, "files": [{"sha": "e082dd16a5aae1d440070c9f5de2162110b3d7fe", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 166, "deletions": 24, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b44fbed7110d8388a4eb4c0c16b39e35c4c16c/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b44fbed7110d8388a4eb4c0c16b39e35c4c16c/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=45b44fbed7110d8388a4eb4c0c16b39e35c4c16c", "patch": "@@ -96,19 +96,35 @@ struct chunk\n   int size;\n };\n \n+#define PENDING_CLEANUP_PC (-3)\n+#define PENDING_EXIT_PC (-2)\n+#define UNDEFINED_PC (-1)\n+\n /* Each \"block\" represents a label plus the bytecode instructions following.\n    There may be branches out of the block, but no incoming jumps, except\n-   to the beginning of the block. */\n+   to the beginning of the block.\n+\n+   If (pc < 0), the jcf_block is not an actual block (i.e. it has no\n+   assocated code yet), but it is an undefined label.\n+*/\n \n struct jcf_block\n {\n   /* For blocks that that are defined, the next block (in pc order).\n-     For blocks that are the not-yet-defined end label of a LABELED_BLOCK_EXPR,\n-     this is the next (outer) such end label, in a stack heaed by\n+     For blocks that are the not-yet-defined end label of a LABELED_BLOCK_EXPR\n+     or a cleanup expression (from a WITH_CLEANUP_EXPR),\n+     this is the next (outer) such end label, in a stack headed by\n      labeled_blocks in jcf_partial. */\n   struct jcf_block *next;\n \n-  /* Until perform_relocations is finished, this is the maximum possible\n+  /* In the not-yet-defined end label for an unfinished EXIT_BLOCK_EXPR.\n+     pc is PENDING_EXIT_PC.\n+     In the not-yet-defined end label for pending cleanup subroutine,\n+     pc is PENDING_CLEANUP_PC.\n+     For other not-yet-defined labels, pc is UNDEFINED_PC.\n+\n+     If the label has been defined:\n+     Until perform_relocations is finished, this is the maximum possible\n      value of the bytecode offset at the begnning of this block.\n      After perform_relocations, it is the actual offset (pc). */\n   int pc;\n@@ -117,14 +133,21 @@ struct jcf_block\n \n   /* After finish_jcf_block is called, The actual instructions contained in this block.\n      Before than NULL, and the instructions are in state->bytecode. */\n-  struct chunk *chunk;\n+  union {\n+    struct chunk *chunk;\n+\n+    /* If pc==PENDING_CLEANUP_PC, start_label is the start of the region\n+       coveed by the cleanup. */\n+    struct jcf_block *start_label;\n+  } v;\n \n   union {\n     /* Set of relocations (in reverse offset order) for this block. */\n     struct jcf_relocation *relocations;\n \n     /* If this block is that of the not-yet-defined end label of\n-       a LABELED_BLOCK_EXPR, where LABELED_BLOCK is that LABELED_BLOCK_EXPR. */\n+       a LABELED_BLOCK_EXPR, where LABELED_BLOCK is that LABELED_BLOCK_EXPR.\n+       If pc==PENDING_CLEANUP_PC, the cleanup that needs to be run. */\n     tree labeled_block;\n   } u;\n };\n@@ -240,6 +263,12 @@ struct jcf_partial\n   /* Number of exception handlers for the current method. */\n   int num_handlers;\n \n+  /* Number of finalizers we are currently nested within. */\n+  int num_finalizers;\n+\n+  /* If non-NULL, use this for the return value. */\n+  tree return_value_decl;\n+\n   /* Information about the current switch statemenet. */\n   struct jcf_switch_state *sw_state;\n };\n@@ -263,7 +292,7 @@ CHECK_PUT(ptr, state, i)\n   return 0;\n }\n #else\n-#define CHECK_PUT(PTR, STATE, I) 0\n+#define CHECK_PUT(PTR, STATE, I) ((void)0)\n #endif\n \n #define PUT1(X)  (CHECK_PUT(ptr, state, 1), *ptr++ = (X))\n@@ -308,7 +337,7 @@ CHECK_OP(struct jcf_partial *state)\n   return 0;\n }\n #else\n-#define CHECK_OP(STATE) 0\n+#define CHECK_OP(STATE) ((void)0)\n #endif\n \n unsigned char *\n@@ -341,7 +370,7 @@ gen_jcf_label (state)\n     obstack_alloc (state->chunk_obstack, sizeof (struct jcf_block));\n   block->next =\tNULL;\n   block->linenumber = -1;\n-  block->pc = -1;\n+  block->pc = UNDEFINED_PC;\n   return block;\n }\n \n@@ -355,10 +384,10 @@ finish_jcf_block (state)\n   int pc = state->code_length;\n   append_chunk_copy (state->bytecode.data, code_length, state);\n   BUFFER_RESET (&state->bytecode);\n-  block->chunk = state->chunk;\n+  block->v.chunk = state->chunk;\n \n   /* Calculate code_length to the maximum value it can have. */\n-  pc += block->chunk->size;\n+  pc += block->v.chunk->size;\n   for (reloc = block->u.relocations;  reloc != NULL;  reloc = reloc->next)\n     {\n       int kind = reloc->kind;\n@@ -465,7 +494,7 @@ struct localvar_info\n #define localvar_max \\\n   ((struct localvar_info**) state->localvars.ptr - localvar_buffer)\n \n-int\n+void\n localvar_alloc (decl, state)\n      tree decl;\n      struct jcf_partial *state;\n@@ -915,7 +944,6 @@ emit_unop (opcode, type, state)\n      tree type;\n      struct jcf_partial *state;\n {\n-  int size = TYPE_IS_WIDE (type) ? 2 : 1;\n   RESERVE(1);\n   OP1 (opcode);\n }\n@@ -932,7 +960,7 @@ emit_binop (opcode, type, state)\n   NOTE_POP (size);\n }\n \n-static struct jcf_relocation *\n+static void\n emit_reloc (value, kind, target, state)\n      HOST_WIDE_INT value;\n      int kind;\n@@ -1225,6 +1253,23 @@ generate_bytecode_conditional (exp, true_label, false_label,\n     fatal (\"internal error - SP mismatch\");\n }\n \n+/* Call pending cleanups i.e. those for surrounding CLEANUP_POINT_EXPRs\n+   but only as far out as LIMIT (since we are about to jump to the\n+   emit label that is LIMIT). */\n+\n+static void\n+call_cleanups (limit, state)\n+     struct jcf_block *limit;\n+     struct jcf_partial *state;\n+{\n+  struct jcf_block *block = state->labeled_blocks;\n+  for (;  block != limit;  block = block->next)\n+    {\n+      if (block->pc == PENDING_CLEANUP_PC)\n+\temit_jsr (block, state);\n+    }\n+}\n+\n /* Generate bytecode for sub-expression EXP of METHOD.\n    TARGET is one of STACK_TARGET or IGNORE_TARGET. */\n \n@@ -1593,12 +1638,12 @@ generate_bytecode_insns (exp, target, state)\n \tswitch_length = state->code_length - switch_instruction->pc;\n \tswitch_instruction->pc = body_block->pc;\n \tinstruction_last->next = body_block;\n-\tinstruction_last->chunk->next = body_block->chunk;\n+\tinstruction_last->v.chunk->next = body_block->v.chunk;\n \texpression_last->next = switch_instruction;\n-\texpression_last->chunk->next = switch_instruction->chunk;\n+\texpression_last->v.chunk->next = switch_instruction->v.chunk;\n \tbody_last->next = sw_state.default_label;\n-\tbody_last->chunk->next = NULL;\n-\tstate->chunk = body_last->chunk;\n+\tbody_last->v.chunk->next = NULL;\n+\tstate->chunk = body_last->v.chunk;\n \tfor (;  body_block != sw_state.default_label;  body_block = body_block->next)\n \t  body_block->pc += switch_length;\n \n@@ -1608,7 +1653,10 @@ generate_bytecode_insns (exp, target, state)\n \n     case RETURN_EXPR:\n       if (!TREE_OPERAND (exp, 0))\n-\top = OPCODE_return;\n+\t{\n+\t  op = OPCODE_return;\n+\t  call_cleanups (NULL_TREE, state);\n+\t}\n       else\n \t{\n \t  exp = TREE_OPERAND (exp, 0);\n@@ -1617,6 +1665,23 @@ generate_bytecode_insns (exp, target, state)\n \t  exp = TREE_OPERAND (exp, 1);\n \t  op = OPCODE_ireturn + adjust_typed_op (TREE_TYPE (exp), 4);\n \t  generate_bytecode_insns (exp, STACK_TARGET, state);\n+\t  if (state->num_finalizers > 0)\n+\t    {\n+\t      if (state->return_value_decl == NULL_TREE)\n+\t\t{\n+\t\t  state->return_value_decl\n+\t\t    = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (exp));\n+\t\t  localvar_alloc (state->return_value_decl, state);\n+\t\t}\n+\t      emit_store (state->return_value_decl, state);\n+\t      call_cleanups (NULL_TREE, state);\n+\t      emit_load (state->return_value_decl, state);\n+\t      /* If we call localvar_free (state->return_value_decl, state),\n+\t\t then we risk the save decl erroneously re-used in the\n+\t\t finalizer.  Instead, we keep the state->return_value_decl\n+\t\t allocated through the rest of the method.  This is not\n+\t\t the greatest solution, but it is at least simple and safe. */\n+\t    }\n \t}\n       RESERVE (1);\n       OP1 (op);\n@@ -1626,6 +1691,7 @@ generate_bytecode_insns (exp, target, state)\n \tstruct jcf_block *end_label = gen_jcf_label (state);\n \tend_label->next = state->labeled_blocks;\n \tstate->labeled_blocks = end_label;\n+\tend_label->pc = PENDING_EXIT_PC;\n \tend_label->u.labeled_block = exp;\n \tif (LABELED_BLOCK_BODY (exp))\n \t  generate_bytecode_insns (LABELED_BLOCK_BODY (exp), target, state);\n@@ -1681,6 +1747,7 @@ generate_bytecode_insns (exp, target, state)\n \tif (TREE_OPERAND (exp, 1) != NULL) goto notimpl;\n \twhile (label->u.labeled_block != TREE_OPERAND (exp, 0))\n \t  label = label->next;\n+\tcall_cleanups (label, state);\n \temit_goto (label, state);\n       }\n       break;\n@@ -1990,6 +2057,79 @@ generate_bytecode_insns (exp, target, state)\n \t  }\n       }\n       break;\n+\n+    case CLEANUP_POINT_EXPR:\n+      {\n+\tstruct jcf_block *save_labeled_blocks = state->labeled_blocks;\n+\tint can_complete = CAN_COMPLETE_NORMALLY (TREE_OPERAND (exp, 0));\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), IGNORE_TARGET, state);\n+\tif (target != IGNORE_TARGET)\n+\t  abort ();\n+\twhile (state->labeled_blocks != save_labeled_blocks)\n+\t  {\n+\t    struct jcf_block *finished_label = NULL;\n+\t    tree return_link;\n+\t    tree exception_type = build_pointer_type (throwable_type_node);\n+\t    tree exception_decl = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t\t      exception_type);\n+\t    struct jcf_block *end_label = get_jcf_label_here (state);\n+\t    struct jcf_block *label = state->labeled_blocks;\n+\t    struct jcf_handler *handler;\n+\t    tree cleanup = label->u.labeled_block;\n+\t    state->labeled_blocks = label->next;\n+\t    state->num_finalizers--;\n+\t    if (can_complete)\n+\t      {\n+\t\tfinished_label = gen_jcf_label (state);\n+\t\temit_jsr (label, state);\n+\t\temit_goto (finished_label, state);\n+\t\tif (! CAN_COMPLETE_NORMALLY (cleanup))\n+\t\t  can_complete = 0;\n+\t      }\n+\t    handler = alloc_handler (label->v.start_label, end_label, state);\n+\t    handler->type = NULL_TREE;\n+\t    localvar_alloc (exception_decl, state);\n+\t    NOTE_PUSH (1);\n+            emit_store (exception_decl, state);\n+\t    emit_jsr (label, state);\n+\t    emit_load (exception_decl, state);\n+\t    RESERVE (1);\n+\t    OP1 (OPCODE_athrow);\n+\t    NOTE_POP (1);\n+\n+\t    /* The finally block. */\n+\t    return_link = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t      return_address_type_node);\n+\t    define_jcf_label (label, state);\n+\t    NOTE_PUSH (1);\n+\t    localvar_alloc (return_link, state);\n+\t    emit_store (return_link, state);\n+\t    generate_bytecode_insns (cleanup, IGNORE_TARGET, state);\n+\t    maybe_wide (OPCODE_ret, DECL_LOCAL_INDEX (return_link), state);\n+\t    localvar_free (return_link, state);\n+\t    localvar_free (exception_decl, state);\n+\t    if (finished_label != NULL)\n+\t      define_jcf_label (finished_label, state);\n+\t  }\n+      }\n+      break;\n+\n+    case WITH_CLEANUP_EXPR:\n+      {\n+\tstruct jcf_block *label;\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), IGNORE_TARGET, state);\n+\tlabel = gen_jcf_label (state);\n+\tlabel->pc = PENDING_CLEANUP_PC;\n+\tlabel->next = state->labeled_blocks;\n+\tstate->labeled_blocks = label;\n+\tstate->num_finalizers++;\n+\tlabel->u.labeled_block = TREE_OPERAND (exp, 2);\n+\tlabel->v.start_label = get_jcf_label_here (state);\n+\tif (target != IGNORE_TARGET)\n+\t  abort ();\n+      }\n+      break;\n+\n     case TRY_EXPR:\n       {\n \ttree try_clause = TREE_OPERAND (exp, 0);\n@@ -2259,7 +2399,7 @@ perform_relocations (state)\n   shrink = 0;\n   for (block = state->blocks;  block != NULL;  block = block->next)\n     {\n-      int block_size = block->chunk->size;\n+      int block_size = block->v.chunk->size;\n \n       block->pc = pc;\n \n@@ -2273,7 +2413,7 @@ perform_relocations (state)\n \t{\n \t  reloc = reloc->next;\n \t  block->u.relocations = reloc;\n-\t  block->chunk->size -= 3;\n+\t  block->v.chunk->size -= 3;\n \t  block_size -= 3;\n \t  shrink += 3;\n \t}\n@@ -2309,15 +2449,13 @@ perform_relocations (state)\n \n   for (block = state->blocks;  block != NULL;  block = block->next)\n     {\n-      struct chunk *chunk = block->chunk;\n+      struct chunk *chunk = block->v.chunk;\n       int old_size = chunk->size;\n       int next_pc = block->next == NULL ? pc : block->next->pc;\n       int new_size = next_pc - block->pc;\n-      int offset = 0;\n       unsigned char *new_ptr;\n       unsigned char *old_buffer = chunk->data;\n       unsigned char *old_ptr = old_buffer + old_size;\n-      int new_end = new_size;\n       if (new_size != old_size)\n \t{\n \t  chunk->data = (unsigned char *)\n@@ -2440,6 +2578,8 @@ init_jcf_method (state, method)\n   state->handlers = NULL;\n   state->last_handler = NULL;\n   state->num_handlers = 0;\n+  state->num_finalizers = 0;\n+  state->return_value_decl = NULL_TREE;\n }\n \n void\n@@ -2585,6 +2725,8 @@ generate_classfile (clas, state)\n \t    }\n \t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n \t    localvar_free (t, state);\n+\t  if (state->return_value_decl != NULL_TREE)\n+\t    localvar_free (state->return_value_decl, state);\n \t  finish_jcf_block (state);\n \t  perform_relocations (state);\n "}]}