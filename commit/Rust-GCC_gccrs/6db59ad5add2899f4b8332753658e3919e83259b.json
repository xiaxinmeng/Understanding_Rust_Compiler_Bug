{"sha": "6db59ad5add2899f4b8332753658e3919e83259b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRiNTlhZDVhZGQyODk5ZjRiODMzMjc1MzY1OGUzOTE5ZTgzMjU5Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-06T21:53:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-06T21:53:49Z"}, "message": "(movsi_const0, movhi): Favor clr with TARGET_5200.\n\n(add[qhs]3): Don't use two addqw/subqw insns to add small integers to\nan address register with TARGET_68060.\n(stack push peephole): Use moveq.l with TARGET_5200 (when appropriate).\n\nFrom-SVN: r12184", "tree": {"sha": "9dc2bcbe67a6b709768579f8d685f361bb4ab7e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dc2bcbe67a6b709768579f8d685f361bb4ab7e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6db59ad5add2899f4b8332753658e3919e83259b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6db59ad5add2899f4b8332753658e3919e83259b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6db59ad5add2899f4b8332753658e3919e83259b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6db59ad5add2899f4b8332753658e3919e83259b/comments", "author": null, "committer": null, "parents": [{"sha": "0d0dd44d1ecc658017cd564048cddd9e72e2a99f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d0dd44d1ecc658017cd564048cddd9e72e2a99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d0dd44d1ecc658017cd564048cddd9e72e2a99f"}], "stats": {"total": 176, "additions": 90, "deletions": 86}, "files": [{"sha": "09d152c7b1974eb56a5430d0a2879bb56be30d17", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 90, "deletions": 86, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6db59ad5add2899f4b8332753658e3919e83259b/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6db59ad5add2899f4b8332753658e3919e83259b/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=6db59ad5add2899f4b8332753658e3919e83259b", "patch": "@@ -784,14 +784,14 @@\n \t(const_int 0))]\n   ;; clr insns on 68000 read before writing.\n   ;; This isn't so on the 68010, but we have no TARGET_68010.\n-  \"(TARGET_68020\n+  \"((TARGET_68020 || TARGET_5200)\n     || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\"\n   \"*\n {\n   if (ADDRESS_REG_P (operands[0]))\n     return \\\"sub%.l %0,%0\\\";\n   /* moveq is faster on the 68000.  */\n-  if (DATA_REG_P (operands[0]) && !TARGET_68020)\n+  if (DATA_REG_P (operands[0]) && (!TARGET_68020 && !TARGET_5200))\n #if defined(MOTOROLA) && !defined(CRDS)\n     return \\\"moveq%.l %#0,%0\\\";\n #else\n@@ -869,7 +869,7 @@\n \t      || GET_CODE (operands[0]) == MEM)\n \t  /* clr insns on 68000 read before writing.\n \t     This isn't so on the 68010, but we have no TARGET_68010.  */\n-\t  && (TARGET_68020\n+\t  && ((TARGET_68020 || TARGET_5200)\n \t      || !(GET_CODE (operands[0]) == MEM\n \t\t   && MEM_VOLATILE_P (operands[0]))))\n \treturn \\\"clr%.w %0\\\";\n@@ -937,7 +937,7 @@\n \t      || GET_CODE (operands[0]) == MEM)\n \t  /* clr insns on 68000 read before writing.\n \t     This isn't so on the 68010, but we have no TARGET_68010.  */\n-\t  && (TARGET_68020\n+\t  && ((TARGET_68020 || TARGET_5200)\n \t      || !(GET_CODE (operands[0]) == MEM\n \t\t   && MEM_VOLATILE_P (operands[0]))))\n \treturn \\\"clr%.w %0\\\";\n@@ -1112,7 +1112,7 @@\n   if (operands[1] == const0_rtx\n       /* clr insns on 68000 read before writing.\n          This isn't so on the 68010, but we have no TARGET_68010.  */\n-      && (TARGET_68020\n+      && ((TARGET_68020 || TARGET_5200)\n           || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n     return \\\"clr%.b %0\\\";\n   return \\\"move%.b %1,%0\\\";\n@@ -2249,25 +2249,25 @@\n \t\t  ? \\\"subq%.w %2,%0\\\"\n \t\t  : \\\"subq%.l %2,%0\\\");\n \t}\n-      /* On everything except the 68000 it is faster to use two\n-\t addqw instructions to add a small integer (8 < N <= 16)\n+      /* On everything except the 68000 and 68060 it is faster to use \n+\t two addqw instructions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw.*/\n-      if (INTVAL (operands[2]) > 8\n-\t  && INTVAL (operands[2]) <= 16\n-\t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020)\n-\t{\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 8);\n-\t  return \\\"addq%.w %#8,%0\\;addq%.w %2,%0\\\";\n-\t}\n-      if (INTVAL (operands[2]) < -8\n-\t  && INTVAL (operands[2]) >= -16\n-\t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020)\n+      if (TARGET_68020 && !TARGET_68060 && ADDRESS_REG_P (operands[0]))\n \t{\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t  - INTVAL (operands[2]) - 8);\n-\t  return \\\"subq%.w %#8,%0\\;subq%.w %2,%0\\\";\n+\t  if (INTVAL (operands[2]) > 8\n+\t      && INTVAL (operands[2]) <= 16)\n+\t    {\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t\t      INTVAL (operands[2]) - 8);\n+\t      return \\\"addq%.w %#8,%0\\;addq%.w %2,%0\\\";\n+\t    }\n+\t  if (INTVAL (operands[2]) < -8\n+\t      && INTVAL (operands[2]) >= -16)\n+\t    {\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t      - INTVAL (operands[2]) - 8);\n+\t      return \\\"subq%.w %#8,%0\\;subq%.w %2,%0\\\";\n+\t    }\n \t}\n #endif\n       if (ADDRESS_REG_P (operands[0])\n@@ -2316,25 +2316,25 @@\n \t\t\t         - INTVAL (operands[2]));\n \t  return \\\"subq%.w %2,%0\\\";\n \t}\n-      /* On everything except the 68000 it is faster to use two\n-\t addqw instructions to add a small integer (8 < N <= 16)\n+      /* On everything except the 68000 and 68060 it is faster to use \n+\t two addqw instructions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw. */\n-      if (INTVAL (operands[2]) > 8\n-\t  && INTVAL (operands[2]) <= 16\n-\t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020)\n-\t{\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) - 8);\n-\t  return \\\"addq%.w %#8,%0\\;addq%.w %2,%0\\\";\n-\t}\n-      if (INTVAL (operands[2]) < -8\n-\t  && INTVAL (operands[2]) >= -16\n-\t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020)\n+      if (TARGET_68020 && !TARGET_68060 && ADDRESS_REG_P (operands[0]))\n \t{\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t - INTVAL (operands[2]) - 8);\n-\t  return \\\"subq%.w %#8,%0\\;subq%.w %2,%0\\\";\n+\t  if (INTVAL (operands[2]) > 8\n+\t      && INTVAL (operands[2]) <= 16)\n+\t    {\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t\t     INTVAL (operands[2]) - 8);\n+\t      return \\\"addq%.w %#8,%0\\;addq%.w %2,%0\\\";\n+\t    }\n+\t  if (INTVAL (operands[2]) < -8\n+\t      && INTVAL (operands[2]) >= -16)\n+\t    {\n+\t      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     - INTVAL (operands[2]) - 8);\n+\t      return \\\"subq%.w %#8,%0\\;subq%.w %2,%0\\\";\n+\t    }\n \t}\n     }\n #endif\n@@ -2376,25 +2376,25 @@\n \t\t\t         - INTVAL (operands[1]));\n \t  return \\\"subq%.w %1,%0\\\";\n \t}\n-      /* On everything except the 68000 it is faster to use two\n-\t addqw instructions to add a small integer (8 < N <= 16)\n+      /* On everything except the 68000 and 68060 it is faster to use \n+\t two addqw instructions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw. */\n-      if (INTVAL (operands[1]) > 8\n-\t  && INTVAL (operands[1]) <= 16\n-\t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020)\n+      if (TARGET_68020 && !TARGET_68060 && ADDRESS_REG_P (operands[0]))\n \t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) - 8);\n-\t  return \\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\";\n-\t}\n-      if (INTVAL (operands[1]) < -8\n-\t  && INTVAL (operands[1]) >= -16\n-\t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020)\n-\t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t - INTVAL (operands[1]) - 8);\n-\t  return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n+\t  if (INTVAL (operands[1]) > 8\n+\t      && INTVAL (operands[1]) <= 16)\n+\t    {\n+\t      operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t\t     INTVAL (operands[1]) - 8);\n+\t      return \\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\";\n+\t    }\n+\t  if (INTVAL (operands[1]) < -8\n+\t      && INTVAL (operands[1]) >= -16)\n+\t    {\n+\t      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     - INTVAL (operands[1]) - 8);\n+\t      return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n+\t    }\n \t}\n     }\n #endif\n@@ -2430,25 +2430,25 @@\n \t\t\t         - INTVAL (operands[1]));\n \t  return \\\"subq%.w %1,%0\\\";\n \t}\n-      /* On everything except the 68000 it is faster to use two\n-\t addqw instructions to add a small integer (8 < N <= 16)\n+      /* On everything except the 68000 and 68060 it is faster to use \n+\t two addqw instructions to add a small integer (8 < N <= 16)\n \t to an address register.  Likewise for subqw. */\n-      if (INTVAL (operands[1]) > 8\n-\t  && INTVAL (operands[1]) <= 16\n-\t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020)\n+      if (TARGET_68020 && !TARGET_68060 && ADDRESS_REG_P (operands[0])) \n \t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[1]) - 8);\n-\t  return \\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\";\n-\t}\n-      if (INTVAL (operands[1]) < -8\n-\t  && INTVAL (operands[1]) >= -16\n-\t  && ADDRESS_REG_P (operands[0])\n-\t  && TARGET_68020)\n-\t{\n-\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t - INTVAL (operands[1]) - 8);\n-\t  return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n+\t  if (INTVAL (operands[1]) > 8\n+\t      && INTVAL (operands[1]) <= 16)\n+\t    {\n+\t      operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t\t     INTVAL (operands[1]) - 8);\n+\t      return \\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\";\n+\t    }\n+\t  if (INTVAL (operands[1]) < -8\n+\t      && INTVAL (operands[1]) >= -16)\n+\t    {\n+\t      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t     - INTVAL (operands[1]) - 8);\n+\t      return \\\"subq%.w %#8,%0\\;subq%.w %1,%0\\\";\n+\t    }\n \t}\n     }\n #endif\n@@ -6331,21 +6331,23 @@\n       rtx xoperands[2];\n       xoperands[0] = stack_pointer_rtx;\n       xoperands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[0]) - 4);\n-      if (TARGET_5200)\n-        output_asm_insn (\\\"add%.l %1,%0\\\", xoperands);\n-      else\n #ifndef NO_ADDSUB_Q\n       if (INTVAL (xoperands[1]) <= 8)\n-        output_asm_insn (\\\"addq%.w %1,%0\\\", xoperands);\n-      else if (INTVAL (xoperands[1]) <= 16 && TARGET_68020)\n+\t{\n+\t  if (!TARGET_5200)\n+\t    output_asm_insn (\\\"addq%.w %1,%0\\\", xoperands);\n+\t  else\n+\t    output_asm_insn (\\\"addq%.l %1,%0\\\", xoperands);\n+\t}\n+      else if (INTVAL (xoperands[1]) <= 16 && TARGET_68020 && !TARGET_68060)\n \t{\n \t  xoperands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t  INTVAL (xoperands[1]) - 8);\n \t  output_asm_insn (\\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\", xoperands);\n \t}\n       else\n #endif\n-        if (INTVAL (xoperands[1]) <= 0x7FFF)\n+        if (INTVAL (xoperands[1]) <= 0x7FFF && !TARGET_5200)\n           output_asm_insn (\\\"add%.w %1,%0\\\", xoperands);\n       else\n         output_asm_insn (\\\"add%.l %1,%0\\\", xoperands);\n@@ -6371,21 +6373,23 @@\n       rtx xoperands[2];\n       xoperands[0] = stack_pointer_rtx;\n       xoperands[1] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[0]) - 4);\n-      if (TARGET_5200)\n-        output_asm_insn (\\\"add%.l %1,%0\\\", xoperands);\n-      else\n #ifndef NO_ADDSUB_Q\n       if (INTVAL (xoperands[1]) <= 8)\n-\t  output_asm_insn (\\\"addq%.w %1,%0\\\", xoperands);\n-      else if (INTVAL (xoperands[1]) <= 16 && TARGET_68020)\n+\t{\n+\t  if (!TARGET_5200)\n+\t    output_asm_insn (\\\"addq%.w %1,%0\\\", xoperands);\n+\t  else\n+\t    output_asm_insn (\\\"addq%.l %1,%0\\\", xoperands);\n+\t}\n+      else if (INTVAL (xoperands[1]) <= 16 && TARGET_68020 && !TARGET_68060)\n \t{\n \t  xoperands[1] = gen_rtx (CONST_INT, VOIDmode,\n \t\t\t\t  INTVAL (xoperands[1]) - 8);\n \t  output_asm_insn (\\\"addq%.w %#8,%0\\;addq%.w %1,%0\\\", xoperands);\n \t}\n       else\n #endif\n-        if (INTVAL (xoperands[1]) <= 0x7FFF)\n+        if (INTVAL (xoperands[1]) <= 0x7FFF && !TARGET_5200)\n           output_asm_insn (\\\"add%.w %1,%0\\\", xoperands);\n       else\n         output_asm_insn (\\\"add%.l %1,%0\\\", xoperands);\n@@ -6437,7 +6441,7 @@\n \t      || GET_CODE (operands[0]) == MEM)\n \t  /* clr insns on 68000 read before writing.\n \t     This isn't so on the 68010, but we have no TARGET_68010.  */\n-\t  && (TARGET_68020\n+\t  && ((TARGET_68020 || TARGET_5200)\n \t      || !(GET_CODE (operands[0]) == MEM\n \t\t   && MEM_VOLATILE_P (operands[0]))))\n \treturn \\\"clr%.w %0\\\";"}]}