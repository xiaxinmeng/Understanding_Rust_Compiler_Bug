{"sha": "4bcaafd97b71b43e4892dd4dd783c03dd5e1319e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJjYWFmZDk3YjcxYjQzZTQ4OTJkZDRkZDc4M2MwM2RkNWUxMzE5ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1995-12-13T20:01:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1995-12-13T20:01:49Z"}, "message": "Output N_BINCL and N_EINCL stabs if DBX_USE_BINCL is defined.\n\nFrom-SVN: r10706", "tree": {"sha": "9be3e4a632e62268e99d9fa7ba14e66803ecfe92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9be3e4a632e62268e99d9fa7ba14e66803ecfe92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bcaafd97b71b43e4892dd4dd783c03dd5e1319e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bcaafd97b71b43e4892dd4dd783c03dd5e1319e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bcaafd97b71b43e4892dd4dd783c03dd5e1319e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bcaafd97b71b43e4892dd4dd783c03dd5e1319e/comments", "author": null, "committer": null, "parents": [{"sha": "1a6281cb9c573a533f6d5203b16faa0b670915a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6281cb9c573a533f6d5203b16faa0b670915a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6281cb9c573a533f6d5203b16faa0b670915a8"}], "stats": {"total": 192, "additions": 152, "deletions": 40}, "files": [{"sha": "f6a00bd208154a925f3f57453effc2b39e2f0ab3", "filename": "gcc/dbxout.c", "status": "modified", "additions": 152, "deletions": 40, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcaafd97b71b43e4892dd4dd783c03dd5e1319e/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcaafd97b71b43e4892dd4dd783c03dd5e1319e/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=4bcaafd97b71b43e4892dd4dd783c03dd5e1319e", "patch": "@@ -205,15 +205,28 @@ static char *cwd;\n \n enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};\n \n-/* Vector recording the status of describing C data types.\n+/* Structure recording information about a C data type.\n+   The status element says whether we have yet output\n+   the definition of the type.  TYPE_XREF says we have\n+   output it as a cross-reference only.\n+   The file_number and type_number elements are used if DBX_USE_BINCL\n+   is defined.  */\n+\n+struct typeinfo\n+{\n+  enum typestatus status;\n+#ifdef DBX_USE_BINCL\n+  int file_number;\n+  int type_number;\n+#endif\n+};\n+\n+/* Vector recording information about C data types.\n    When we first notice a data type (a tree node),\n    we assign it a number using next_type_number.\n-   That is its index in this vector.\n-   The vector element says whether we have yet output\n-   the definition of the type.  TYPE_XREF says we have\n-   output it as a cross-reference only.  */\n+   That is its index in this vector.  */\n \n-enum typestatus *typevec;\n+struct typeinfo *typevec;\n \n /* Number of elements of space allocated in `typevec'.  */\n \n@@ -225,6 +238,29 @@ static int typevec_len;\n \n static int next_type_number;\n \n+#ifdef DBX_USE_BINCL\n+\n+/* When using N_BINCL in dbx output, each type number is actually a\n+   pair of the file number and the type number within the file.\n+   This is a stack of input files.  */\n+\n+struct dbx_file\n+{\n+  struct dbx_file *next;\n+  int file_number;\n+  int next_type_number;\n+};\n+\n+/* This is the top of the stack.  */\n+\n+static struct dbx_file *current_file;\n+\n+/* This is the next file number to use.  */\n+\n+static int next_file_number;\n+\n+#endif /* DBX_USE_BINCL */\n+\n /* In dbx output, we must assign symbol-blocks id numbers\n    in the order in which their beginnings are encountered.\n    We output debugging info that refers to the beginning and\n@@ -282,6 +318,7 @@ static void dbxout_symbol_name ();\n static void dbxout_symbol_location ();\n static void dbxout_prepare_symbol ();\n static void dbxout_finish_symbol ();\n+static void dbxout_type_index ();\n static void dbxout_continue ();\n static void print_int_cst_octal ();\n static void print_octal ();\n@@ -404,7 +441,7 @@ dbxout_init (asm_file, input_file_name, syms)\n   asmfile = asm_file;\n \n   typevec_len = 100;\n-  typevec = (enum typestatus *) xmalloc (typevec_len * sizeof typevec[0]);\n+  typevec = (struct typeinfo *) xmalloc (typevec_len * sizeof typevec[0]);\n   bzero ((char *) typevec, typevec_len * sizeof typevec[0]);\n \n   /* Convert Ltext into the appropriate format for local labels in case\n@@ -464,6 +501,14 @@ dbxout_init (asm_file, input_file_name, syms)\n   next_type_number = 1;\n   next_block_number = 2;\n \n+#ifdef DBX_USE_BINCL\n+  current_file = (struct dbx_file *) xmalloc (sizeof *current_file);\n+  current_file->next = NULL;\n+  current_file->file_number = 0;\n+  current_file->next_type_number = 1;\n+  next_file_number = 1;\n+#endif\n+\n   /* Make sure that types `int' and `char' have numbers 1 and 2.\n      Definitions of other integer types will refer to those numbers.\n      (Actually it should no longer matter what their numbers are.\n@@ -505,6 +550,38 @@ dbxout_typedefs (syms)\n     }\n }\n \n+/* Change to reading from a new source file.  Generate a N_BINCL stab.  */\n+\n+void\n+dbxout_start_new_source_file (filename)\n+     char *filename;\n+{\n+#ifdef DBX_USE_BINCL\n+  struct dbx_file *n = (struct dbx_file *) xmalloc (sizeof *n);\n+\n+  n->next = current_file;\n+  n->file_number = next_file_number++;\n+  n->next_type_number = 1;\n+  current_file = n;\n+  fprintf (asmfile, \"%s \\\"%s\\\",%d,0,0,0\\n\", ASM_STABS_OP, filename, N_BINCL);\n+#endif\n+}\n+\n+/* Revert to reading a previous source file.  Generate a N_EINCL stab.  */\n+\n+void\n+dbxout_resume_previous_source_file ()\n+{\n+#ifdef DBX_USE_BINCL\n+  struct dbx_file *next;\n+\n+  fprintf (asmfile, \"%s %d,0,0,0\\n\", ASM_STABN_OP, N_EINCL);\n+  next = current_file->next;\n+  free (current_file);\n+  current_file = next;\n+#endif\n+}\n+\n /* Output debugging info to FILE to switch to sourcefile FILENAME.  */\n \n void\n@@ -568,6 +645,22 @@ dbxout_finish (file, filename)\n #endif /* DBX_OUTPUT_MAIN_SOURCE_FILE_END */\n }\n \n+/* Output the index of a type.  */\n+\n+static void\n+dbxout_type_index (type)\n+     tree type;\n+{\n+#ifndef DBX_USE_BINCL\n+  fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n+  CHARS (3);\n+#else\n+  struct typeinfo *t = &typevec[TYPE_SYMTAB_ADDRESS (type)];\n+  fprintf (asmfile, \"(%d,%d)\", t->file_number, t->type_number);\n+  CHARS (7);\n+#endif\n+}\n+\n /* Continue a symbol-description that gets too big.\n    End one symbol table entry with a double-backslash\n    and start a new one, eventually producing something like\n@@ -896,7 +989,7 @@ dbxout_range_type (type)\n     {\n       /* This used to say `r1' and we used to take care\n \t to make sure that `int' was type number 1.  */\n-      fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (integer_type_node));\n+      dbxout_type_index (integer_type_node);\n     }\n   if (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST)\n     fprintf (asmfile, \";%d\", \n@@ -956,17 +1049,23 @@ dbxout_type (type, full, show_arg_types)\n       if (next_type_number == typevec_len)\n \t{\n \t  typevec =\n-\t    (enum typestatus *) xrealloc (typevec,\n+\t    (struct typeinfo *) xrealloc (typevec,\n \t\t\t\t\t  typevec_len * 2 * sizeof typevec[0]);\n \t  bzero ((char *) (typevec + typevec_len),\n \t\t typevec_len * sizeof typevec[0]);\n \t  typevec_len *= 2;\n \t}\n+\n+#ifdef DBX_USE_BINCL\n+      typevec[TYPE_SYMTAB_ADDRESS (type)].file_number =\n+\tcurrent_file->file_number;\n+      typevec[TYPE_SYMTAB_ADDRESS (type)].type_number =\n+\tcurrent_file->next_type_number++;\n+#endif\n     }\n \n   /* Output the number of this type, to refer to it.  */\n-  fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n-  CHARS (3);\n+  dbxout_type_index (type);\n \n #ifdef DBX_TYPE_DEFINED\n   if (DBX_TYPE_DEFINED (type))\n@@ -976,7 +1075,7 @@ dbxout_type (type, full, show_arg_types)\n   /* If this type's definition has been output or is now being output,\n      that is all.  */\n \n-  switch (typevec[TYPE_SYMTAB_ADDRESS (type)])\n+  switch (typevec[TYPE_SYMTAB_ADDRESS (type)].status)\n     {\n     case TYPE_UNSEEN:\n       break;\n@@ -1014,7 +1113,7 @@ dbxout_type (type, full, show_arg_types)\n \t/* No way in DBX fmt to describe a variable size.  */\n \t|| TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n       {\n-\ttypevec[TYPE_SYMTAB_ADDRESS (type)] = TYPE_XREF;\n+\ttypevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n \treturn;\n       }\n #endif\n@@ -1027,7 +1126,7 @@ dbxout_type (type, full, show_arg_types)\n   /* Mark it as defined, so that if it is self-referent\n      we will not get into an infinite recursion of definitions.  */\n \n-  typevec[TYPE_SYMTAB_ADDRESS (type)] = TYPE_DEFINED;\n+  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_DEFINED;\n \n   switch (TREE_CODE (type))\n     {\n@@ -1038,52 +1137,61 @@ dbxout_type (type, full, show_arg_types)\n \t without saying what it is.  The debugger will make it\n \t a void type when the reference is seen, and nothing will\n \t ever override that default.  */\n-      fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n-      CHARS (3);\n+      dbxout_type_index (type);\n       break;\n \n     case INTEGER_TYPE:\n       if (type == char_type_node && ! TREE_UNSIGNED (type))\n-\t/* Output the type `char' as a subrange of itself!\n-\t   I don't understand this definition, just copied it\n-\t   from the output of pcc.\n-\t   This used to use `r2' explicitly and we used to\n-\t   take care to make sure that `char' was type number 2.  */\n-\tfprintf (asmfile, \"r%d;0;127;\", TYPE_SYMTAB_ADDRESS (type));\n+\t{\n+\t  /* Output the type `char' as a subrange of itself!\n+\t     I don't understand this definition, just copied it\n+\t     from the output of pcc.\n+\t     This used to use `r2' explicitly and we used to\n+\t     take care to make sure that `char' was type number 2.  */\n+\t  fprintf (asmfile, \"r\");\n+\t  dbxout_type_index (type);\n+\t  fprintf (asmfile, \";0;127;\");\n+\t}\n       else if (use_gnu_debug_info_extensions\n \t       && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)\n \t\t   || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT))\n \t{\n \t  /* This used to say `r1' and we used to take care\n \t     to make sure that `int' was type number 1.  */\n-\t  fprintf (asmfile, \"r%d;\", TYPE_SYMTAB_ADDRESS (integer_type_node));\n+\t  fprintf (asmfile, \"r\");\n+\t  dbxout_type_index (integer_type_node);\n+\t  fprintf (asmfile, \";\");\n \t  print_int_cst_octal (TYPE_MIN_VALUE (type));\n \t  fprintf (asmfile, \";\");\n \t  print_int_cst_octal (TYPE_MAX_VALUE (type));\n \t  fprintf (asmfile, \";\");\n \t}\n       else /* Output other integer types as subranges of `int'.  */\n \tdbxout_range_type (type);\n-      CHARS (25);\n+      CHARS (22);\n       break;\n \n     case REAL_TYPE:\n       /* This used to say `r1' and we used to take care\n \t to make sure that `int' was type number 1.  */\n-      fprintf (asmfile, \"r%d;%d;0;\", TYPE_SYMTAB_ADDRESS (integer_type_node),\n-\t       int_size_in_bytes (type));\n-      CHARS (16);\n+      fprintf (asmfile, \"r\");\n+      dbxout_type_index (integer_type_node);\n+      fprintf (asmfile, \";%d;0;\", int_size_in_bytes (type));\n+      CHARS (13);\n       break;\n \n     case CHAR_TYPE:\n       if (use_gnu_debug_info_extensions)\n \tfprintf (asmfile, \"@s%d;-20;\",\n \t\t BITS_PER_UNIT * int_size_in_bytes (type));\n       else\n-\t/* Output the type `char' as a subrange of itself.\n-\t   That is what pcc seems to do.  */\n-      fprintf (asmfile, \"r%d;0;%d;\", TYPE_SYMTAB_ADDRESS (char_type_node),\n-\t       TREE_UNSIGNED (type) ? 255 : 127);\n+\t{\n+\t  /* Output the type `char' as a subrange of itself.\n+\t     That is what pcc seems to do.  */\n+\t  fprintf (asmfile, \"r\");\n+\t  dbxout_type_index (char_type_node);\n+\t  fprintf (asmfile, \";0;%d;\", TREE_UNSIGNED (type) ? 255 : 127);\n+\t}\n       CHARS (9);\n       break;\n \n@@ -1107,10 +1215,11 @@ dbxout_type (type, full, show_arg_types)\n \n       if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n \t{\n-\t  fprintf (asmfile, \"r%d;%d;0;\",\n-\t\t   TYPE_SYMTAB_ADDRESS (type),\n+\t  fprintf (asmfile, \"r\");\n+\t  dbxout_type_index (type);\n+\t  fprintf (asmfile, \";%d;0;\",\n \t\t   int_size_in_bytes (TREE_TYPE (type)));\n-\t  CHARS (15);\t\t/* The number is probably incorrect here.  */\n+\t  CHARS (12);\t\t/* The number is probably incorrect here.  */\n \t}\n       else\n \t{\n@@ -1164,14 +1273,17 @@ dbxout_type (type, full, show_arg_types)\n \t}\n       tem = TYPE_DOMAIN (type);\n       if (tem == NULL)\n-\tfprintf (asmfile, \"ar%d;0;-1;\",\n-\t\t TYPE_SYMTAB_ADDRESS (integer_type_node));\n+\t{\n+\t  fprintf (asmfile, \"ar\");\n+\t  dbxout_type_index (integer_type_node);\n+\t  fprintf (asmfile, \";0;-1;\");\n+\t}\n       else\n \t{\n \t  fprintf (asmfile, \"a\");\n \t  dbxout_range_type (tem);\n \t}\n-      CHARS (17);\n+      CHARS (14);\n       dbxout_type (TREE_TYPE (type), 0, 0);\n       break;\n \n@@ -1215,7 +1327,7 @@ dbxout_type (type, full, show_arg_types)\n \t    else\n \t      fprintf (asmfile, \"$$%d\", anonymous_type_number++);\n \t    fprintf (asmfile, \":\");\n-\t    typevec[TYPE_SYMTAB_ADDRESS (type)] = TYPE_XREF;\n+\t    typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n \t    break;\n \t  }\n \n@@ -1312,7 +1424,7 @@ dbxout_type (type, full, show_arg_types)\n \t  fprintf (asmfile, \"xe\");\n \t  CHARS (3);\n \t  dbxout_type_name (type);\n-\t  typevec[TYPE_SYMTAB_ADDRESS (type)] = TYPE_XREF;\n+\t  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n \t  fprintf (asmfile, \":\");\n \t  return;\n \t}\n@@ -1593,7 +1705,7 @@ dbxout_symbol (decl, local)\n \n       /* If this typedef name was defined by outputting the type,\n \t don't duplicate it.  */\n-      if (typevec[TYPE_SYMTAB_ADDRESS (type)] == TYPE_DEFINED\n+      if (typevec[TYPE_SYMTAB_ADDRESS (type)].status == TYPE_DEFINED\n \t  && TYPE_NAME (TREE_TYPE (decl)) == decl)\n \treturn;\n #endif"}]}