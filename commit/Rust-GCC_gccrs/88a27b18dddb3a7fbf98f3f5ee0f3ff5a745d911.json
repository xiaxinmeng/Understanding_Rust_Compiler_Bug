{"sha": "88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhhMjdiMThkZGRiM2E3ZmJmOThmM2Y1ZWUwZjNmZjVhNzQ1ZDkxMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-23T09:39:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-01-23T09:39:27Z"}, "message": "[multiple changes]\n\n2012-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Associations): Alphabetize local variables and\n\tconstants. Rename Actual_Types to Actuals_To_Freeze. Rename Next_Formal\n\tto Saved_Formal.\n\tFreeze all eligible subprograms which appear as actuals in\n\tthe instantiation.\n\t(Has_Fully_Defined_Profile): New routine.\n\t(Renames_Standard_Subprogram): New routine.\n\t(Earlier): Add local variable N. Comment update. Do not use source\n\tlocations when trying to determine whether one node precedes another.\n\n2012-01-23  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): In the case\n\twhere the result of a concatentation can be null, set the to\n\tresult have both the low and high bounds of the right operand (not\n\tjust the high bound, as was the case prior to this fix). Also,\n\tfix the saved high bound setting (Last_Opnd_High_Bound) in the\n\tempty string literal case (should have been low bound minus one,\n\trather than plus one).\n\n2012-01-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* scos.ads, put_scos.adb, get_scos.adb (Get_SCOs, Put_SCOs): Do not\n\tomit statement SCOs for disabled pragmas.\n\nFrom-SVN: r183419", "tree": {"sha": "1eeb3948fb02ea5d492dcba3de5efd26fcd5412b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eeb3948fb02ea5d492dcba3de5efd26fcd5412b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/comments", "author": null, "committer": null, "parents": [{"sha": "3c24c853da7ea2106fe07213fdf1efd43b86bddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c24c853da7ea2106fe07213fdf1efd43b86bddf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c24c853da7ea2106fe07213fdf1efd43b86bddf"}], "stats": {"total": 383, "additions": 318, "deletions": 65}, "files": [{"sha": "79c5b98c92b1c6f7f6aaca2e7b9329b44e6edf2b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "patch": "@@ -1,3 +1,30 @@\n+2012-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Associations): Alphabetize local variables and\n+\tconstants. Rename Actual_Types to Actuals_To_Freeze. Rename Next_Formal\n+\tto Saved_Formal.\n+\tFreeze all eligible subprograms which appear as actuals in\n+\tthe instantiation.\n+\t(Has_Fully_Defined_Profile): New routine.\n+\t(Renames_Standard_Subprogram): New routine.\n+\t(Earlier): Add local variable N. Comment update. Do not use source\n+\tlocations when trying to determine whether one node precedes another.\n+\n+2012-01-23  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): In the case\n+\twhere the result of a concatentation can be null, set the to\n+\tresult have both the low and high bounds of the right operand (not\n+\tjust the high bound, as was the case prior to this fix). Also,\n+\tfix the saved high bound setting (Last_Opnd_High_Bound) in the\n+\tempty string literal case (should have been low bound minus one,\n+\trather than plus one).\n+\n+2012-01-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* scos.ads, put_scos.adb, get_scos.adb (Get_SCOs, Put_SCOs): Do not\n+\tomit statement SCOs for disabled pragmas.\n+\n 2012-01-23  Matthew Heaney  <heaney@adacore.com>\n \n \t* a-cohase.ads, a-cihase.ads, a-cbhase.ads, a-coorse.ads,"}, {"sha": "b0a65cf92da864d9acc2575136fd2d95903e89fb", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2601,6 +2601,12 @@ package body Exp_Ch4 is\n       --  This is either an integer literal node, or an identifier reference to\n       --  a constant entity initialized to the appropriate value.\n \n+      Last_Opnd_Low_Bound : Node_Id;\n+      --  A tree node representing the low bound of the last operand. This\n+      --  need only be set if the result could be null. It is used for the\n+      --  special case of setting the right low bound for a null result.\n+      --  This is of type Ityp.\n+\n       Last_Opnd_High_Bound : Node_Id;\n       --  A tree node representing the high bound of the last operand. This\n       --  need only be set if the result could be null. It is used for the\n@@ -2811,11 +2817,14 @@ package body Exp_Ch4 is\n                Result_May_Be_Null := False;\n             end if;\n \n-            --  Capture last operand high bound if result could be null\n+            --  Capture last operand low and high bound if result could be null\n \n             if J = N and then Result_May_Be_Null then\n+               Last_Opnd_Low_Bound :=\n+                 New_Copy_Tree (String_Literal_Low_Bound (Opnd_Typ));\n+\n                Last_Opnd_High_Bound :=\n-                 Make_Op_Add (Loc,\n+                 Make_Op_Subtract (Loc,\n                    Left_Opnd  =>\n                      New_Copy_Tree (String_Literal_Low_Bound (Opnd_Typ)),\n                    Right_Opnd => Make_Integer_Literal (Loc, 1));\n@@ -2871,9 +2880,13 @@ package body Exp_Ch4 is\n                            Result_May_Be_Null := False;\n                         end if;\n \n-                        --  Capture last operand bound if result could be null\n+                        --  Capture last operand bounds if result could be null\n \n                         if J = N and then Result_May_Be_Null then\n+                           Last_Opnd_Low_Bound :=\n+                             Convert_To (Ityp,\n+                               Make_Integer_Literal (Loc, Expr_Value (Lo)));\n+\n                            Last_Opnd_High_Bound :=\n                              Convert_To (Ityp,\n                                Make_Integer_Literal (Loc, Expr_Value (Hi)));\n@@ -2914,7 +2927,16 @@ package body Exp_Ch4 is\n                      Duplicate_Subexpr (Opnd, Name_Req => True),\n                    Attribute_Name => Name_First);\n \n+               --  Capture last operand bounds if result could be null\n+\n                if J = N and Result_May_Be_Null then\n+                  Last_Opnd_Low_Bound :=\n+                    Convert_To (Ityp,\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix         =>\n+                          Duplicate_Subexpr (Opnd, Name_Req => True),\n+                        Attribute_Name => Name_First));\n+\n                   Last_Opnd_High_Bound :=\n                     Convert_To (Ityp,\n                       Make_Attribute_Reference (Loc,\n@@ -3124,6 +3146,15 @@ package body Exp_Ch4 is\n       --  bounds if the last operand is super-flat).\n \n       if Result_May_Be_Null then\n+         Low_Bound :=\n+           Make_Conditional_Expression (Loc,\n+             Expressions => New_List (\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd  => New_Copy (Aggr_Length (NN)),\n+                 Right_Opnd => Make_Artyp_Literal (0)),\n+               Last_Opnd_Low_Bound,\n+               Low_Bound));\n+\n          High_Bound :=\n            Make_Conditional_Expression (Loc,\n              Expressions => New_List ("}, {"sha": "ce662ce7e64c6b1d002737079e3785e23f59f223", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -301,7 +301,7 @@ begin\n \n                      when others =>\n                         Skipc;\n-                        if Typ = 'P' then\n+                        if Typ = 'P' or else Typ = 'p' then\n                            if Nextc not in '1' .. '9' then\n                               N := 1;\n                               loop"}, {"sha": "39fd04fcc7a5ad167abdb76abae74cb0083792c7", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -139,12 +139,6 @@ begin\n                      Ctr := 0;\n                      Continuation := False;\n                      loop\n-                        if SCO_Pragma_Disabled\n-                             (SCO_Table.Table (Start).Pragma_Sloc)\n-                        then\n-                           goto Next_Statement;\n-                        end if;\n-\n                         if Ctr = 0 then\n                            Write_SCO_Initiate (U);\n                            if not Continuation then\n@@ -169,7 +163,7 @@ begin\n                               Write_Info_Char (Sent.C2);\n \n                               if Sent.C1 = 'S'\n-                                and then Sent.C2 = 'P'\n+                                and then (Sent.C2 = 'P' or else Sent.C2 = 'p')\n                                 and then Sent.Pragma_Name /= Unknown_Pragma\n                               then\n                                  --  Strip leading \"PRAGMA_\"\n@@ -205,7 +199,6 @@ begin\n                            Ctr := 0;\n                         end if;\n \n-                     <<Next_Statement>>\n                         exit when SCO_Table.Table (Start).Last;\n                         Start := Start + 1;\n                      end loop;"}, {"sha": "e0e31b66673de950c348179891ff5f8549df82cb", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -157,6 +157,7 @@ package SCOs is\n    --      F        FOR loop (from FOR through end of iteration scheme)\n    --      I        IF statement (from IF through end of condition)\n    --      P[name:] PRAGMA with the indicated name\n+   --      p[name:] disabled PRAGMA with the indicated name\n    --      R        extended RETURN statement\n    --      W        WHILE loop statement (from WHILE through end of condition)\n "}, {"sha": "3624385e8642393b15b8f06dff40d264243dba68", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 250, "deletions": 49, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=88a27b18dddb3a7fbf98f3f5ee0f3ff5a745d911", "patch": "@@ -917,20 +917,20 @@ package body Sem_Ch12 is\n       Formals : List_Id;\n       F_Copy  : List_Id) return List_Id\n    is\n-      Actual_Types    : constant Elist_Id  := New_Elmt_List;\n-      Assoc           : constant List_Id   := New_List;\n-      Default_Actuals : constant Elist_Id  := New_Elmt_List;\n-      Gen_Unit        : constant Entity_Id :=\n-                          Defining_Entity (Parent (F_Copy));\n+      Actuals_To_Freeze : constant Elist_Id  := New_Elmt_List;\n+      Assoc             : constant List_Id   := New_List;\n+      Default_Actuals   : constant Elist_Id  := New_Elmt_List;\n+      Gen_Unit          : constant Entity_Id :=\n+                            Defining_Entity (Parent (F_Copy));\n \n       Actuals         : List_Id;\n       Actual          : Node_Id;\n-      Formal          : Node_Id;\n-      Next_Formal     : Node_Id;\n       Analyzed_Formal : Node_Id;\n+      First_Named     : Node_Id := Empty;\n+      Formal          : Node_Id;\n       Match           : Node_Id;\n       Named           : Node_Id;\n-      First_Named     : Node_Id := Empty;\n+      Saved_Formal    : Node_Id;\n \n       Default_Formals : constant List_Id := New_List;\n       --  If an Others_Choice is present, some of the formals may be defaulted.\n@@ -958,6 +958,10 @@ package body Sem_Ch12 is\n       --  to formals of formal packages by AI05-0025, and it also applies to\n       --  box-initialized formals.\n \n+      function Has_Fully_Defined_Profile (Subp : Entity_Id) return Boolean;\n+      --  Determine whether the parameter types and the return type of Subp\n+      --  are fully defined at the point of instantiation.\n+\n       function Matching_Actual\n         (F   : Entity_Id;\n          A_F : Entity_Id) return Node_Id;\n@@ -966,7 +970,7 @@ package body Sem_Ch12 is\n       --  are named, scan the parameter associations to find the right one.\n       --  A_F is the corresponding entity in the analyzed generic,which is\n       --  placed on the selector name for ASIS use.\n-\n+      --\n       --  In Ada 2005, a named association may be given with a box, in which\n       --  case Matching_Actual sets Found_Assoc to the generic association,\n       --  but return Empty for the actual itself. In this case the code below\n@@ -982,6 +986,10 @@ package body Sem_Ch12 is\n       --  associations, and add an explicit box association for F  if there\n       --  is none yet, and the default comes from an Others_Choice.\n \n+      function Renames_Standard_Subprogram (Subp : Entity_Id) return Boolean;\n+      --  Determine whether Subp renames one of the subprograms defined in the\n+      --  generated package Standard.\n+\n       procedure Set_Analyzed_Formal;\n       --  Find the node in the generic copy that corresponds to a given formal.\n       --  The semantic information on this node is used to perform legality\n@@ -1025,6 +1033,62 @@ package body Sem_Ch12 is\n          end loop;\n       end Check_Overloaded_Formal_Subprogram;\n \n+      -------------------------------\n+      -- Has_Fully_Defined_Profile --\n+      -------------------------------\n+\n+      function Has_Fully_Defined_Profile (Subp : Entity_Id) return Boolean is\n+         function Is_Fully_Defined_Type (Typ : Entity_Id) return Boolean;\n+         --  Determine whethet type Typ is fully defined\n+\n+         ---------------------------\n+         -- Is_Fully_Defined_Type --\n+         ---------------------------\n+\n+         function Is_Fully_Defined_Type (Typ : Entity_Id) return Boolean is\n+         begin\n+            --  A private type without a full view is not fully defined\n+\n+            if Is_Private_Type (Typ)\n+              and then No (Full_View (Typ))\n+            then\n+               return False;\n+\n+            --  An incomplete type is never fully defined\n+\n+            elsif Is_Incomplete_Type (Typ) then\n+               return False;\n+\n+            --  All other types are fully defined\n+\n+            else\n+               return True;\n+            end if;\n+         end Is_Fully_Defined_Type;\n+\n+         --  Local declarations\n+\n+         Param : Entity_Id;\n+\n+      --  Start of processing for Has_Fully_Defined_Profile\n+\n+      begin\n+         --  Check the parameters\n+\n+         Param := First_Formal (Subp);\n+         while Present (Param) loop\n+            if not Is_Fully_Defined_Type (Etype (Param)) then\n+               return False;\n+            end if;\n+\n+            Next_Formal (Param);\n+         end loop;\n+\n+         --  Check the return type\n+\n+         return Is_Fully_Defined_Type (Etype (Subp));\n+      end Has_Fully_Defined_Profile;\n+\n       ---------------------\n       -- Matching_Actual --\n       ---------------------\n@@ -1149,6 +1213,26 @@ package body Sem_Ch12 is\n          end if;\n       end Process_Default;\n \n+      ---------------------------------\n+      -- Renames_Standard_Subprogram --\n+      ---------------------------------\n+\n+      function Renames_Standard_Subprogram (Subp : Entity_Id) return Boolean is\n+         Id : Entity_Id;\n+\n+      begin\n+         Id := Alias (Subp);\n+         while Present (Id) loop\n+            if Scope (Id) = Standard_Standard then\n+               return True;\n+            end if;\n+\n+            Id := Alias (Id);\n+         end loop;\n+\n+         return False;\n+      end Renames_Standard_Subprogram;\n+\n       -------------------------\n       -- Set_Analyzed_Formal --\n       -------------------------\n@@ -1259,7 +1343,7 @@ package body Sem_Ch12 is\n       Named := First_Named;\n       while Present (Named) loop\n          if Nkind (Named) /= N_Others_Choice\n-           and then  No (Selector_Name (Named))\n+           and then No (Selector_Name (Named))\n          then\n             Error_Msg_N (\"invalid positional actual after named one\", Named);\n             Abandon_Instantiation (Named);\n@@ -1293,7 +1377,7 @@ package body Sem_Ch12 is\n \n          while Present (Formal) loop\n             Set_Analyzed_Formal;\n-            Next_Formal := Next_Non_Pragma (Formal);\n+            Saved_Formal := Next_Non_Pragma (Formal);\n \n             case Nkind (Formal) is\n                when N_Formal_Object_Declaration =>\n@@ -1335,19 +1419,24 @@ package body Sem_Ch12 is\n                      Analyze (Match);\n                      Append_List\n                        (Instantiate_Type\n-                         (Formal, Match, Analyzed_Formal, Assoc),\n-                       Assoc);\n+                          (Formal, Match, Analyzed_Formal, Assoc),\n+                        Assoc);\n \n                      --  An instantiation is a freeze point for the actuals,\n                      --  unless this is a rewritten formal package, or the\n                      --  formal is an Ada 2012 formal incomplete type.\n \n-                     if Nkind (I_Node) /= N_Formal_Package_Declaration\n-                       and then\n-                         Ekind (Defining_Identifier (Analyzed_Formal)) /=\n-                           E_Incomplete_Type\n+                     if Nkind (I_Node) = N_Formal_Package_Declaration\n+                       or else\n+                         (Ada_Version >= Ada_2012\n+                           and then\n+                             Ekind (Defining_Identifier (Analyzed_Formal)) =\n+                                                            E_Incomplete_Type)\n                      then\n-                        Append_Elmt (Entity (Match), Actual_Types);\n+                        null;\n+\n+                     else\n+                        Append_Elmt (Entity (Match), Actuals_To_Freeze);\n                      end if;\n                   end if;\n \n@@ -1364,9 +1453,9 @@ package body Sem_Ch12 is\n \n                when N_Formal_Subprogram_Declaration =>\n                   Match :=\n-                    Matching_Actual (\n-                      Defining_Unit_Name (Specification (Formal)),\n-                      Defining_Unit_Name (Specification (Analyzed_Formal)));\n+                    Matching_Actual\n+                      (Defining_Unit_Name (Specification (Formal)),\n+                       Defining_Unit_Name (Specification (Analyzed_Formal)));\n \n                   --  If the formal subprogram has the same name as another\n                   --  formal subprogram of the generic, then a named\n@@ -1384,10 +1473,9 @@ package body Sem_Ch12 is\n                   --  partial parametrization, or else the formal has a default\n                   --  or a box.\n \n-                  if No (Match)\n-                    and then  Partial_Parametrization\n-                  then\n+                  if No (Match) and then Partial_Parametrization then\n                      Process_Default (Formal);\n+\n                      if Nkind (I_Node) = N_Formal_Package_Declaration then\n                         Check_Overloaded_Formal_Subprogram (Formal);\n                      end if;\n@@ -1396,6 +1484,37 @@ package body Sem_Ch12 is\n                      Append_To (Assoc,\n                        Instantiate_Formal_Subprogram\n                          (Formal, Match, Analyzed_Formal));\n+\n+                     --  An instantiation is a freeze point for the actuals,\n+                     --  unless this is a rewritten formal package.\n+\n+                     if Nkind (I_Node) /= N_Formal_Package_Declaration\n+                       and then Nkind (Match) = N_Identifier\n+                       and then Is_Subprogram (Entity (Match))\n+\n+                       --  The actual subprogram may rename a routine defined\n+                       --  in Standard. Avoid freezing such renamings because\n+                       --  subprograms coming from Standard cannot be frozen.\n+\n+                       and then\n+                         not Renames_Standard_Subprogram (Entity (Match))\n+\n+                       --  If the actual subprogram comes from a different\n+                       --  unit, it is already frozen, either by a body in\n+                       --  that unit or by the end of the declarative part\n+                       --  of the unit. This check avoids the freezing of\n+                       --  subprograms defined in Standard which are used\n+                       --  as generic actuals.\n+\n+                       and then In_Same_Code_Unit (Entity (Match), I_Node)\n+                       and then Has_Fully_Defined_Profile (Entity (Match))\n+                     then\n+                        --  Mark the subprogram as having a delayed freeze\n+                        --  since this may be an out-of-order action.\n+\n+                        Set_Has_Delayed_Freeze (Entity (Match));\n+                        Append_Elmt (Entity (Match), Actuals_To_Freeze);\n+                     end if;\n                   end if;\n \n                   --  If this is a nested generic, preserve default for later\n@@ -1459,7 +1578,7 @@ package body Sem_Ch12 is\n \n             end case;\n \n-            Formal := Next_Formal;\n+            Formal := Saved_Formal;\n             Next_Non_Pragma (Analyzed_Formal);\n          end loop;\n \n@@ -1484,8 +1603,12 @@ package body Sem_Ch12 is\n            (\"too many actuals in generic instantiation\", Instantiation_Node);\n       end if;\n \n+      --  An instantiation freezes all generic actuals. The only exceptions\n+      --  to this are incomplete types and subprograms which are not fully\n+      --  defined at the point of instantiation.\n+\n       declare\n-         Elmt : Elmt_Id := First_Elmt (Actual_Types);\n+         Elmt : Elmt_Id := First_Elmt (Actuals_To_Freeze);\n       begin\n          while Present (Elmt) loop\n             Freeze_Before (I_Node, Node (Elmt));\n@@ -6818,11 +6941,6 @@ package body Sem_Ch12 is\n    -------------\n \n    function Earlier (N1, N2 : Node_Id) return Boolean is\n-      D1 : Integer := 0;\n-      D2 : Integer := 0;\n-      P1 : Node_Id := N1;\n-      P2 : Node_Id := N2;\n-\n       procedure Find_Depth (P : in out Node_Id; D : in out Integer);\n       --  Find distance from given node to enclosing compilation unit\n \n@@ -6840,6 +6958,13 @@ package body Sem_Ch12 is\n          end loop;\n       end Find_Depth;\n \n+      --  Local declarations\n+\n+      D1 : Integer := 0;\n+      D2 : Integer := 0;\n+      P1 : Node_Id := N1;\n+      P2 : Node_Id := N2;\n+\n    --  Start of processing for Earlier\n \n    begin\n@@ -6864,12 +6989,11 @@ package body Sem_Ch12 is\n       end loop;\n \n       --  At this point P1 and P2 are at the same distance from the root.\n-      --  We examine their parents until we find a common declarative list,\n-      --  at which point we can establish their relative placement by\n-      --  comparing their ultimate slocs. If we reach the root, N1 and N2\n-      --  do not descend from the same declarative list (e.g. one is nested\n-      --  in the declarative part and the other is in a block in the\n-      --  statement part) and the earlier one is already frozen.\n+      --  We examine their parents until we find a common declarative list.\n+      --  If we reach the root, N1 and N2 do not descend from the same\n+      --  declarative list (e.g. one is nested in the declarative part and\n+      --  the other is in a block in the statement part) and the earlier\n+      --  one is already frozen.\n \n       while not Is_List_Member (P1)\n         or else not Is_List_Member (P2)\n@@ -6891,22 +7015,99 @@ package body Sem_Ch12 is\n          end if;\n       end loop;\n \n-      --  If the sloc positions are different the result is unambiguous. If\n-      --  the slocs are identical, one of them must not come from source, which\n-      --  is the case for freeze nodes, whose sloc is unrelated to the point\n-      --  point at which they are inserted in the tree. The source node is the\n-      --  earlier one in the tree.\n+      --  Expanded code usually shares the source location of the original\n+      --  construct it was generated for. This however may not necessarely\n+      --  reflect the true location of the code within the tree.\n \n-      if Top_Level_Location (Sloc (P1)) < Top_Level_Location (Sloc (P2)) then\n-         return True;\n+      --  Before comparing the slocs of the two nodes, make sure that we are\n+      --  working with correct source locations. Assume that P1 is to the left\n+      --  of P2. If either one does not come from source, traverse the common\n+      --  list heading towards the other node and locate the first source\n+      --  statement.\n \n-      elsif\n-        Top_Level_Location (Sloc (P1)) > Top_Level_Location (Sloc (P2))\n-      then\n-         return False;\n+      --             P1                     P2\n+      --     ----+===+===+--------------+===+===+----\n+      --          expanded code          expanded code\n+\n+      if not Comes_From_Source (P1) then\n+         while Present (P1) loop\n+\n+            --  Neither P2 nor a source statement were located during the\n+            --  search. If we reach the end of the list, then P1 does not\n+            --  occur earlier than P2.\n+\n+            --                     ---->\n+            --   start --- P2 ----- P1 --- end\n+\n+            if No (Next (P1)) then\n+               return False;\n+\n+            --  We encounter P2 while going to the right of the list. This\n+            --  means that P1 does indeed appear earlier.\n \n+            --             ---->\n+            --    start --- P1 ===== P2 --- end\n+            --                 expanded code in between\n+\n+            elsif P1 = P2 then\n+               return True;\n+\n+            --  No need to look any further since we have located a source\n+            --  statement.\n+\n+            elsif Comes_From_Source (P1) then\n+               exit;\n+            end if;\n+\n+            --  Keep going right\n+\n+            Next (P1);\n+         end loop;\n+      end if;\n+\n+      if not Comes_From_Source (P2) then\n+         while Present (P2) loop\n+\n+            --  Neither P1 nor a source statement were located during the\n+            --  search. If we reach the start of the list, then P1 does not\n+            --  occur earlier than P2.\n+\n+            --            <----\n+            --    start --- P2 --- P1 --- end\n+\n+            if No (Prev (P2)) then\n+               return False;\n+\n+            --  We encounter P1 while going to the left of the list. This\n+            --  means that P1 does indeed appear earlier.\n+\n+            --                     <----\n+            --    start --- P1 ===== P2 --- end\n+            --                 expanded code in between\n+\n+            elsif P2 = P1 then\n+               return True;\n+\n+            --  No need to look any further since we have located a source\n+            --  statement.\n+\n+            elsif Comes_From_Source (P2) then\n+               exit;\n+            end if;\n+\n+            --  Keep going left\n+\n+            Prev (P2);\n+         end loop;\n+      end if;\n+\n+      --  At this point either both nodes came from source or we approximated\n+      --  their source locations through neighbouring source statements.\n+\n+      if Top_Level_Location (Sloc (P1)) < Top_Level_Location (Sloc (P2)) then\n+         return True;\n       else\n-         return Comes_From_Source (P1);\n+         return False;\n       end if;\n    end Earlier;\n "}]}