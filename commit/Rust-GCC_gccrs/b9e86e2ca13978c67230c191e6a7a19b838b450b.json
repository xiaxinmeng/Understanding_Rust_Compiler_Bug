{"sha": "b9e86e2ca13978c67230c191e6a7a19b838b450b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjllODZlMmNhMTM5NzhjNjcyMzBjMTkxZTZhN2ExOWI4MzhiNDUwYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-11-26T13:46:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-11-26T13:46:59Z"}, "message": "re PR tree-optimization/66721 (gcc.target/i386/pr61403.c FAILs)\n\n2015-11-26  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/66721\n\t* tree-vect-loop.c (vect_analyze_loop_2): Compute scalar\n\titeration cost earlier.  Re-do analysis without SLP when\n\tvectorization using SLP fails and without has a chance to succeed.\n\nFrom-SVN: r230956", "tree": {"sha": "f056ba2282c0604f2f95257846f0c9ea1bb2a9b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f056ba2282c0604f2f95257846f0c9ea1bb2a9b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9e86e2ca13978c67230c191e6a7a19b838b450b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e86e2ca13978c67230c191e6a7a19b838b450b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9e86e2ca13978c67230c191e6a7a19b838b450b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e86e2ca13978c67230c191e6a7a19b838b450b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6be52f624ea94a0a799abd57ca761949ac05123d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be52f624ea94a0a799abd57ca761949ac05123d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be52f624ea94a0a799abd57ca761949ac05123d"}], "stats": {"total": 121, "additions": 105, "deletions": 16}, "files": [{"sha": "c626a6ce6c46b384a6bab72a6c59f62584e1b9ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e86e2ca13978c67230c191e6a7a19b838b450b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e86e2ca13978c67230c191e6a7a19b838b450b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9e86e2ca13978c67230c191e6a7a19b838b450b", "patch": "@@ -1,3 +1,10 @@\n+2015-11-26  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66721\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Compute scalar\n+\titeration cost earlier.  Re-do analysis without SLP when\n+\tvectorization using SLP fails and without has a chance to succeed.\n+\n 2015-11-26  Richard Biener  <rguenther@suse.de>\n \n \t* genmatch.c (dt_simplify::gen_1): For generic wrap all"}, {"sha": "7fb16f592605301d6d074b3ae17f83b3b9c15923", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 98, "deletions": 16, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9e86e2ca13978c67230c191e6a7a19b838b450b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9e86e2ca13978c67230c191e6a7a19b838b450b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b9e86e2ca13978c67230c191e6a7a19b838b450b", "patch": "@@ -1891,6 +1891,14 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       return false;\n     }\n \n+  /* Compute the scalar iteration cost.  */\n+  vect_compute_single_scalar_iteration_cost (loop_vinfo);\n+\n+  int saved_vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  HOST_WIDE_INT estimated_niter;\n+  unsigned th;\n+  int min_scalar_loop_bound;\n+\n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n   ok = vect_analyze_slp (loop_vinfo, n_stmts);\n   if (!ok)\n@@ -1907,6 +1915,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       vect_update_vf_for_slp (loop_vinfo);\n     }\n \n+  /* This is the point where we can re-start analysis with SLP forced off.  */\n+start_over:\n+\n   /* Now the vectorization factor is final.  */\n   unsigned vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   gcc_assert (vectorization_factor != 0);\n@@ -1924,9 +1935,6 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       || (max_niter != -1\n \t  && (unsigned HOST_WIDE_INT) max_niter < vectorization_factor))\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: iteration count too small.\\n\");\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: iteration count smaller than \"\n@@ -1961,12 +1969,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       return false;\n     }\n \n-  /* Compute the scalar iteration cost.  */\n-  vect_compute_single_scalar_iteration_cost (loop_vinfo);\n-\n   /* This pass will decide on using loop versioning and/or loop peeling in\n      order to enhance the alignment of data references in the loop.  */\n-\n   ok = vect_enhance_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n@@ -1985,7 +1989,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       vect_slp_analyze_operations (LOOP_VINFO_SLP_INSTANCES (loop_vinfo),\n \t\t\t\t   LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n       if (LOOP_VINFO_SLP_INSTANCES (loop_vinfo).length () != old_size)\n-\treturn false;\n+\tgoto again;\n     }\n \n   /* Scan all the remaining operations in the loop that are not subject\n@@ -2013,15 +2017,15 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: vector version will never be \"\n \t\t\t \"profitable.\\n\");\n-      return false;\n+      goto again;\n     }\n \n-  int min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n-\t\t\t\t* vectorization_factor) - 1);\n+  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+\t\t\t    * vectorization_factor) - 1);\n \n   /* Use the cost model only if it is more conservative than user specified\n      threshold.  */\n-  unsigned th = (unsigned) min_scalar_loop_bound;\n+  th = (unsigned) min_scalar_loop_bound;\n   if (min_profitable_iters\n       && (!min_scalar_loop_bound\n           || min_profitable_iters > min_scalar_loop_bound))\n@@ -2040,10 +2044,10 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t\t\t \"not vectorized: iteration count smaller than user \"\n \t\t\t \"specified loop bound parameter or minimum profitable \"\n \t\t\t \"iterations (whichever is more conservative).\\n\");\n-      return false;\n+      goto again;\n     }\n \n-  HOST_WIDE_INT estimated_niter\n+  estimated_niter\n     = estimated_stmt_executions_int (LOOP_VINFO_LOOP (loop_vinfo));\n   if (estimated_niter != -1\n       && ((unsigned HOST_WIDE_INT) estimated_niter\n@@ -2059,7 +2063,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n                          \"than specified loop bound parameter or minimum \"\n                          \"profitable iterations (whichever is more \"\n                          \"conservative).\\n\");\n-      return false;\n+      goto again;\n     }\n \n   /* Decide whether we need to create an epilogue loop to handle\n@@ -2102,14 +2106,92 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: can't create required \"\n \t\t\t     \"epilog loop\\n\");\n-          return false;\n+          goto again;\n         }\n     }\n \n   gcc_assert (vectorization_factor\n \t      == (unsigned)LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n \n+  /* Ok to vectorize!  */\n   return true;\n+\n+again:\n+  /* Try again with SLP forced off but if we didn't do any SLP there is\n+     no point in re-trying.  */\n+  if (!slp)\n+    return false;\n+\n+  /* Likewise if the grouped loads or stores in the SLP cannot be handled\n+     via interleaving or lane instructions or if there were any SLP\n+     reductions.  */\n+  slp_instance instance;\n+  slp_tree node;\n+  unsigned i, j;\n+  FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (loop_vinfo), i, instance)\n+    {\n+      stmt_vec_info vinfo;\n+      vinfo = vinfo_for_stmt\n+\t  (SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance))[0]);\n+      if (! STMT_VINFO_GROUPED_ACCESS (vinfo))\n+\treturn false;\n+      vinfo = vinfo_for_stmt (STMT_VINFO_GROUP_FIRST_ELEMENT (vinfo));\n+      unsigned int size = STMT_VINFO_GROUP_SIZE (vinfo);\n+      tree vectype = STMT_VINFO_VECTYPE (vinfo);\n+      if (! vect_store_lanes_supported (vectype, size)\n+\t  && ! vect_grouped_store_supported (vectype, size))\n+\treturn false;\n+      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, node)\n+\t{\n+\t  vinfo = vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]);\n+\t  vinfo = vinfo_for_stmt (STMT_VINFO_GROUP_FIRST_ELEMENT (vinfo));\n+\t  size = STMT_VINFO_GROUP_SIZE (vinfo);\n+\t  vectype = STMT_VINFO_VECTYPE (vinfo);\n+\t  if (! vect_load_lanes_supported (vectype, size)\n+\t      && ! vect_grouped_load_supported (vectype, size))\n+\t    return false;\n+\t}\n+    }\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"re-trying with SLP disabled\\n\");\n+\n+  /* Roll back state appropriately.  No SLP this time.  */\n+  slp = false;\n+  /* Restore vectorization factor as it were without SLP.  */\n+  LOOP_VINFO_VECT_FACTOR (loop_vinfo) = saved_vectorization_factor;\n+  /* Free the SLP instances.  */\n+  FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (loop_vinfo), j, instance)\n+    vect_free_slp_instance (instance);\n+  LOOP_VINFO_SLP_INSTANCES (loop_vinfo).release ();\n+  /* Reset SLP type to loop_vect on all stmts.  */\n+  for (i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)\n+    {\n+      basic_block bb = LOOP_VINFO_BBS (loop_vinfo)[i];\n+      for (gimple_stmt_iterator si = gsi_start_bb (bb);\n+\t   !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  stmt_vec_info stmt_info = vinfo_for_stmt (gsi_stmt (si));\n+\t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n+\t    {\n+\t      gcc_assert (STMT_SLP_TYPE (stmt_info) == loop_vect);\n+\t      stmt_info = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+\t    }\n+\t  STMT_SLP_TYPE (stmt_info) = loop_vect;\n+\t}\n+    }\n+  /* Free optimized alias test DDRS.  */\n+  LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).release ();\n+  /* Reset target cost data.  */\n+  destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n+  LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n+    = init_cost (LOOP_VINFO_LOOP (loop_vinfo));\n+  /* Reset assorted flags.  */\n+  LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n+  LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = 0;\n+\n+  goto start_over;\n }\n \n /* Function vect_analyze_loop."}]}