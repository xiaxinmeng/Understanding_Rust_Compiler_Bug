{"sha": "4fc4e47839a0dcb61bd3ba937e831a0212f468d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZjNGU0NzgzOWEwZGNiNjFiZDNiYTkzN2U4MzFhMDIxMmY0NjhkOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-04-10T00:14:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-10T00:14:53Z"}, "message": "hashtab.c (higher_prime_number): Use 7 as minimum.\n\n        * hashtab.c (higher_prime_number): Use 7 as minimum.\n        (find_empty_slot_for_expand): Don't compute hash2 unless needed.\n        (htab_find_slot_with_hash): Likewise.\n\nFrom-SVN: r52099", "tree": {"sha": "cdbe123c0aa102ef5a672b9f01871e43d97f60b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdbe123c0aa102ef5a672b9f01871e43d97f60b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fc4e47839a0dcb61bd3ba937e831a0212f468d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc4e47839a0dcb61bd3ba937e831a0212f468d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc4e47839a0dcb61bd3ba937e831a0212f468d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc4e47839a0dcb61bd3ba937e831a0212f468d9/comments", "author": null, "committer": null, "parents": [{"sha": "b911c031b3281db6d8b705b0e63c37da3e2193d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b911c031b3281db6d8b705b0e63c37da3e2193d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b911c031b3281db6d8b705b0e63c37da3e2193d2"}], "stats": {"total": 84, "additions": 52, "deletions": 32}, "files": [{"sha": "b7e03afce42c15e81c38b3cfbb3dee0a8d891c0a", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc4e47839a0dcb61bd3ba937e831a0212f468d9/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc4e47839a0dcb61bd3ba937e831a0212f468d9/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=4fc4e47839a0dcb61bd3ba937e831a0212f468d9", "patch": "@@ -1,3 +1,9 @@\n+2002-04-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* hashtab.c (higher_prime_number): Use 7 as minimum.\n+\t(find_empty_slot_for_expand): Don't compute hash2 unless needed.\n+\t(htab_find_slot_with_hash): Likewise.\n+\n 2002-04-01  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* cp-demangle.c (__cxa_demangle):  Also protect with IN_GLIBCPP_V3."}, {"sha": "7477c35c3bc0b93eb65f2dca76bbd73a681d2e3d", "filename": "libiberty/hashtab.c", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fc4e47839a0dcb61bd3ba937e831a0212f468d9/libiberty%2Fhashtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fc4e47839a0dcb61bd3ba937e831a0212f468d9/libiberty%2Fhashtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fhashtab.c?ref=4fc4e47839a0dcb61bd3ba937e831a0212f468d9", "patch": "@@ -1,5 +1,5 @@\n /* An expandable hash tables datatype.  \n-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n \n This file is part of the libiberty library.\n@@ -81,7 +81,6 @@ higher_prime_number (n)\n   /* These are primes that are near, but slightly smaller than, a\n      power of two.  */\n   static const unsigned long primes[] = {\n-    (unsigned long) 2,\n     (unsigned long) 7,\n     (unsigned long) 13,\n     (unsigned long) 31,\n@@ -264,21 +263,27 @@ find_empty_slot_for_expand (htab, hash)\n      hashval_t hash;\n {\n   size_t size = htab->size;\n-  hashval_t hash2 = 1 + hash % (size - 2);\n   unsigned int index = hash % size;\n+  PTR *slot = htab->entries + index;\n+  hashval_t hash2;\n+\n+  if (*slot == EMPTY_ENTRY)\n+    return slot;\n+  else if (*slot == DELETED_ENTRY)\n+    abort ();\n \n+  hash2 = 1 + hash % (size - 2);\n   for (;;)\n     {\n-      PTR *slot = htab->entries + index;\n+      index += hash2;\n+      if (index >= size)\n+\tindex -= size;\n \n+      slot = htab->entries + index;\n       if (*slot == EMPTY_ENTRY)\n \treturn slot;\n       else if (*slot == DELETED_ENTRY)\n \tabort ();\n-\n-      index += hash2;\n-      if (index >= size)\n-\tindex -= size;\n     }\n }\n \n@@ -405,50 +410,59 @@ htab_find_slot_with_hash (htab, element, hash, insert)\n   unsigned int index;\n   hashval_t hash2;\n   size_t size;\n+  PTR entry;\n \n   if (insert == INSERT && htab->size * 3 <= htab->n_elements * 4\n       && htab_expand (htab) == 0)\n     return NULL;\n \n   size = htab->size;\n-  hash2 = 1 + hash % (size - 2);\n   index = hash % size;\n \n   htab->searches++;\n   first_deleted_slot = NULL;\n \n+  entry = htab->entries[index];\n+  if (entry == EMPTY_ENTRY)\n+    goto empty_entry;\n+  else if (entry == DELETED_ENTRY)\n+    first_deleted_slot = &htab->entries[index];\n+  else if ((*htab->eq_f) (entry, element))\n+    return &htab->entries[index];\n+      \n+  hash2 = 1 + hash % (size - 2);\n   for (;;)\n     {\n-      PTR entry = htab->entries[index];\n+      htab->collisions++;\n+      index += hash2;\n+      if (index >= size)\n+\tindex -= size;\n+      \n+      entry = htab->entries[index];\n       if (entry == EMPTY_ENTRY)\n-\t{\n-\t  if (insert == NO_INSERT)\n-\t    return NULL;\n-\n-\t  htab->n_elements++;\n-\n-\t  if (first_deleted_slot)\n-\t    {\n-\t      *first_deleted_slot = EMPTY_ENTRY;\n-\t      return first_deleted_slot;\n-\t    }\n-\n-\t  return &htab->entries[index];\n-\t}\n-\n-      if (entry == DELETED_ENTRY)\n+\tgoto empty_entry;\n+      else if (entry == DELETED_ENTRY)\n \t{\n \t  if (!first_deleted_slot)\n \t    first_deleted_slot = &htab->entries[index];\n \t}\n-      else  if ((*htab->eq_f) (entry, element))\n+      else if ((*htab->eq_f) (entry, element))\n \treturn &htab->entries[index];\n-      \n-      htab->collisions++;\n-      index += hash2;\n-      if (index >= size)\n-\tindex -= size;\n     }\n+\n+ empty_entry:\n+  if (insert == NO_INSERT)\n+    return NULL;\n+\n+  htab->n_elements++;\n+\n+  if (first_deleted_slot)\n+    {\n+      *first_deleted_slot = EMPTY_ENTRY;\n+      return first_deleted_slot;\n+    }\n+\n+  return &htab->entries[index];\n }\n \n /* Like htab_find_slot_with_hash, but compute the hash value from the"}]}