{"sha": "6c5b2a63268212f63ab04f17b71c2abcc6aecefc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM1YjJhNjMyNjgyMTJmNjNhYjA0ZjE3YjcxYzJhYmNjNmFlY2VmYw==", "commit": {"author": {"name": "Yizhe", "email": "yizhe@pku.edu.cn", "date": "2021-02-25T18:41:43Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-03-01T10:42:27Z"}, "message": "Rewrite backend to accept the new enum\n\nGcc_backend::unary_expression and Gcc_backend::binary_expression has\nbeen split into 4 smaller functions corresponding to the 4 enums.\n\nIt turns out that keeping the 4 enums distinct helps simplify the logic\na lot. A lot of if-else branches were eliminated just by inlining the\ntype infomation.\n\nThere were also some minor cleanup. `operator_to_tree_code` function has\nbeen modified to omit the `tree` parameter and offload floating-point\ncheck to the caller.", "tree": {"sha": "e2e2dccfa2d6b9fd1960b6d0fafbc356d8eda34c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2e2dccfa2d6b9fd1960b6d0fafbc356d8eda34c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c5b2a63268212f63ab04f17b71c2abcc6aecefc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5b2a63268212f63ab04f17b71c2abcc6aecefc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c5b2a63268212f63ab04f17b71c2abcc6aecefc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5b2a63268212f63ab04f17b71c2abcc6aecefc/comments", "author": {"login": "YizhePKU", "id": 42838469, "node_id": "MDQ6VXNlcjQyODM4NDY5", "avatar_url": "https://avatars.githubusercontent.com/u/42838469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YizhePKU", "html_url": "https://github.com/YizhePKU", "followers_url": "https://api.github.com/users/YizhePKU/followers", "following_url": "https://api.github.com/users/YizhePKU/following{/other_user}", "gists_url": "https://api.github.com/users/YizhePKU/gists{/gist_id}", "starred_url": "https://api.github.com/users/YizhePKU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YizhePKU/subscriptions", "organizations_url": "https://api.github.com/users/YizhePKU/orgs", "repos_url": "https://api.github.com/users/YizhePKU/repos", "events_url": "https://api.github.com/users/YizhePKU/events{/privacy}", "received_events_url": "https://api.github.com/users/YizhePKU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63dabd8161f5d5c22a796286fb0c366742444c6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63dabd8161f5d5c22a796286fb0c366742444c6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63dabd8161f5d5c22a796286fb0c366742444c6e"}], "stats": {"total": 369, "additions": 227, "deletions": 142}, "files": [{"sha": "394851aae985b59f532e1df282be8d4b43128559", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5b2a63268212f63ab04f17b71c2abcc6aecefc/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5b2a63268212f63ab04f17b71c2abcc6aecefc/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=6c5b2a63268212f63ab04f17b71c2abcc6aecefc", "patch": "@@ -362,19 +362,32 @@ class Backend\n \t\t\t  Bexpression *else_expr, Location)\n     = 0;\n \n-  // Return an expression for the unary operation OP EXPR.\n-  // Supported values of OP are (from operators.h):\n-  //    MINUS, NOT, XOR.\n-  virtual Bexpression *unary_expression (Operator op, Bexpression *expr,\n-\t\t\t\t\t Location)\n-    = 0;\n-\n-  // Return an expression for the binary operation LEFT OP RIGHT.\n-  // Supported values of OP are (from operators.h):\n-  //    EQEQ, NOTEQ, LT, LE, GT, GE, PLUS, MINUS, OR, XOR, MULT, DIV, MOD,\n-  //    LSHIFT, RSHIFT, AND, NOT.\n-  virtual Bexpression *binary_expression (Operator op, Bexpression *left,\n-\t\t\t\t\t  Bexpression *right, Location)\n+  // Return an expression for the negation operation OP EXPR.\n+  // Supported values of OP are enumerated in NegationOperator.\n+  virtual Bexpression *negation_expression (NegationOperator op,\n+\t\t\t\t\t    Bexpression *expr, Location)\n+    = 0;\n+\n+  // Return an expression for the operation LEFT OP RIGHT.\n+  // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n+  virtual Bexpression *\n+  arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t    Bexpression *left, Bexpression *right,\n+\t\t\t\t    Location)\n+    = 0;\n+\n+  // Return an expression for the operation LEFT OP RIGHT.\n+  // Supported values of OP are enumerated in ComparisionOperator.\n+  virtual Bexpression *comparision_expression (ComparisionOperator op,\n+\t\t\t\t\t       Bexpression *left,\n+\t\t\t\t\t       Bexpression *right, Location)\n+    = 0;\n+\n+  // Return an expression for the operation LEFT OP RIGHT.\n+  // Supported values of OP are enumerated in LazyBooleanOperator.\n+  virtual Bexpression *lazy_boolean_expression (LazyBooleanOperator op,\n+\t\t\t\t\t\tBexpression *left,\n+\t\t\t\t\t\tBexpression *right, Location)\n     = 0;\n \n   // Return an expression that constructs BTYPE with VALS.  BTYPE must be the"}, {"sha": "8bdd1b369b9b98b9bd2bbcb272d7c1e48d80ccfd", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 201, "deletions": 129, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5b2a63268212f63ab04f17b71c2abcc6aecefc/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5b2a63268212f63ab04f17b71c2abcc6aecefc/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=6c5b2a63268212f63ab04f17b71c2abcc6aecefc", "patch": "@@ -293,10 +293,20 @@ class Gcc_backend : public Backend\n   Bexpression *conditional_expression (Bfunction *, Btype *, Bexpression *,\n \t\t\t\t       Bexpression *, Bexpression *, Location);\n \n-  Bexpression *unary_expression (Operator, Bexpression *, Location);\n+  Bexpression *negation_expression (NegationOperator op, Bexpression *expr,\n+\t\t\t\t    Location);\n+\n+  Bexpression *arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t\t Bexpression *left,\n+\t\t\t\t\t\t Bexpression *right, Location);\n \n-  Bexpression *binary_expression (Operator, Bexpression *, Bexpression *,\n-\t\t\t\t  Location);\n+  Bexpression *comparision_expression (ComparisionOperator op,\n+\t\t\t\t       Bexpression *left, Bexpression *right,\n+\t\t\t\t       Location);\n+\n+  Bexpression *lazy_boolean_expression (LazyBooleanOperator op,\n+\t\t\t\t\tBexpression *left, Bexpression *right,\n+\t\t\t\t\tLocation);\n \n   Bexpression *constructor_expression (Btype *,\n \t\t\t\t       const std::vector<Bexpression *> &,\n@@ -1624,162 +1634,224 @@ Gcc_backend::conditional_expression (Bfunction *, Btype *btype,\n   return this->make_expression (ret);\n }\n \n-// Return an expression for the unary operation OP EXPR.\n-\n-Bexpression *\n-Gcc_backend::unary_expression (Operator op, Bexpression *expr,\n-\t\t\t       Location location)\n+/* Helper function that converts rust operators to equivalent GCC tree_code.\n+   Note that CompoundAssignmentOperator don't get their corresponding tree_code,\n+   because they get compiled away when we lower AST to HIR. */\n+static enum tree_code\n+operator_to_tree_code (NegationOperator op)\n {\n-  tree expr_tree = expr->get_tree ();\n-  if (expr_tree == error_mark_node || TREE_TYPE (expr_tree) == error_mark_node)\n-    return this->error_expression ();\n-\n-  tree type_tree = TREE_TYPE (expr_tree);\n-  enum tree_code code;\n   switch (op)\n     {\n-      case OPERATOR_MINUS: {\n-\ttree computed_type = excess_precision_type (type_tree);\n-\tif (computed_type != NULL_TREE)\n-\t  {\n-\t    expr_tree = convert (computed_type, expr_tree);\n-\t    type_tree = computed_type;\n-\t  }\n-\tcode = NEGATE_EXPR;\n-\tbreak;\n-      }\n-    case OPERATOR_NOT:\n-      code = TRUTH_NOT_EXPR;\n-      break;\n-    case OPERATOR_XOR:\n-      code = BIT_NOT_EXPR;\n-      break;\n+    case NegationOperator::NEGATE:\n+      return NEGATE_EXPR;\n+    case NegationOperator::NOT:\n+      return TRUTH_NOT_EXPR;\n     default:\n       gcc_unreachable ();\n-      break;\n     }\n-\n-  tree ret\n-    = fold_build1_loc (location.gcc_location (), code, type_tree, expr_tree);\n-  return this->make_expression (ret);\n }\n \n-// Convert a rustfrontend operator to an equivalent tree_code.\n-\n+/* Note that GCC tree code distinguishes floating point division and integer\n+   division. These two types of division are represented as the same rust\n+   operator, and can only be distinguished via context(i.e. the TREE_TYPE of the\n+   operands). */\n static enum tree_code\n-operator_to_tree_code (Operator op, tree type)\n+operator_to_tree_code (ArithmeticOrLogicalOperator op, bool floating_point)\n {\n-  enum tree_code code;\n   switch (op)\n     {\n-    case OPERATOR_EQEQ:\n-      code = EQ_EXPR;\n-      break;\n-    case OPERATOR_NOTEQ:\n-      code = NE_EXPR;\n-      break;\n-    case OPERATOR_LT:\n-      code = LT_EXPR;\n-      break;\n-    case OPERATOR_LE:\n-      code = LE_EXPR;\n-      break;\n-    case OPERATOR_GT:\n-      code = GT_EXPR;\n-      break;\n-    case OPERATOR_GE:\n-      code = GE_EXPR;\n-      break;\n-    case OPERATOR_OROR:\n-      code = TRUTH_ORIF_EXPR;\n-      break;\n-    case OPERATOR_ANDAND:\n-      code = TRUTH_ANDIF_EXPR;\n-      break;\n-    case OPERATOR_PLUS:\n-      code = PLUS_EXPR;\n-      break;\n-    case OPERATOR_MINUS:\n-      code = MINUS_EXPR;\n-      break;\n-    case OPERATOR_OR:\n-      code = BIT_IOR_EXPR;\n-      break;\n-    case OPERATOR_XOR:\n-      code = BIT_XOR_EXPR;\n-      break;\n-    case OPERATOR_MULT:\n-      code = MULT_EXPR;\n-      break;\n-    case OPERATOR_DIV:\n-      if (TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == COMPLEX_TYPE)\n-\tcode = RDIV_EXPR;\n+    case ArithmeticOrLogicalOperator::ADD:\n+      return PLUS_EXPR;\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+      return MINUS_EXPR;\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      return MULT_EXPR;\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n+      if (floating_point)\n+\treturn RDIV_EXPR;\n       else\n-\tcode = TRUNC_DIV_EXPR;\n-      break;\n-    case OPERATOR_MOD:\n-      code = TRUNC_MOD_EXPR;\n-      break;\n-    case OPERATOR_LSHIFT:\n-      code = LSHIFT_EXPR;\n-      break;\n-    case OPERATOR_RSHIFT:\n-      code = RSHIFT_EXPR;\n-      break;\n-    case OPERATOR_AND:\n-      code = BIT_AND_EXPR;\n-      break;\n-    case OPERATOR_BITCLEAR:\n-      code = BIT_AND_EXPR;\n-      break;\n+\treturn TRUNC_DIV_EXPR;\n+    case ArithmeticOrLogicalOperator::MODULUS:\n+      return TRUNC_MOD_EXPR;\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n+      return BIT_AND_EXPR;\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n+      return BIT_IOR_EXPR;\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      return BIT_XOR_EXPR;\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      return LSHIFT_EXPR;\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      return RSHIFT_EXPR;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static enum tree_code\n+operator_to_tree_code (ComparisionOperator op)\n+{\n+  switch (op)\n+    {\n+    case ComparisionOperator::EQUAL:\n+      return EQ_EXPR;\n+    case ComparisionOperator::NOT_EQUAL:\n+      return NE_EXPR;\n+    case ComparisionOperator::GREATER_THAN:\n+      return GT_EXPR;\n+    case ComparisionOperator::LESS_THAN:\n+      return LT_EXPR;\n+    case ComparisionOperator::GREATER_OR_EQUAL:\n+      return GE_EXPR;\n+    case ComparisionOperator::LESS_OR_EQUAL:\n+      return LE_EXPR;\n     default:\n       gcc_unreachable ();\n     }\n+}\n \n-  return code;\n+static enum tree_code\n+operator_to_tree_code (LazyBooleanOperator op)\n+{\n+  switch (op)\n+    {\n+    case LazyBooleanOperator::LOGICAL_OR:\n+      return TRUTH_ORIF_EXPR;\n+    case LazyBooleanOperator::LOGICAL_AND:\n+      return TRUTH_ANDIF_EXPR;\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n-// Return an expression for the binary operation LEFT OP RIGHT.\n+/* Helper function for deciding if a tree is a floating point node. */\n+bool\n+is_floating_point (tree t)\n+{\n+  auto tree_type = TREE_CODE (TREE_TYPE (t));\n+  return tree_type == REAL_TYPE || tree_type == COMPLEX_TYPE;\n+}\n \n+// Return an expression for the negation operation OP EXPR.\n Bexpression *\n-Gcc_backend::binary_expression (Operator op, Bexpression *left,\n-\t\t\t\tBexpression *right, Location location)\n+Gcc_backend::negation_expression (NegationOperator op, Bexpression *expr,\n+\t\t\t\t  Location location)\n {\n-  tree left_tree = left->get_tree ();\n-  tree right_tree = right->get_tree ();\n-  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+  /* Check if the expression is an error, in which case we return an error\n+     expression. */\n+  auto expr_tree = expr->get_tree ();\n+  if (expr_tree == error_mark_node || TREE_TYPE (expr_tree) == error_mark_node)\n     return this->error_expression ();\n-  enum tree_code code = operator_to_tree_code (op, TREE_TYPE (left_tree));\n \n-  bool use_left_type = op != OPERATOR_OROR && op != OPERATOR_ANDAND;\n-  tree type_tree\n-    = use_left_type ? TREE_TYPE (left_tree) : TREE_TYPE (right_tree);\n-  tree computed_type = excess_precision_type (type_tree);\n-  if (computed_type != NULL_TREE)\n+  /* For negation operators, the resulting type should be the same as its\n+     operand. */\n+  auto tree_type = TREE_TYPE (expr_tree);\n+  auto tree_code = operator_to_tree_code (op);\n+\n+  /* For floating point operations we may need to extend the precision of type.\n+     For example, a 64-bit machine may not support operations on float32. */\n+  bool floating_point = is_floating_point (expr_tree);\n+  if (floating_point)\n     {\n-      left_tree = convert (computed_type, left_tree);\n-      right_tree = convert (computed_type, right_tree);\n-      type_tree = computed_type;\n+      auto extended_type = excess_precision_type (tree_type);\n+      if (extended_type != NULL_TREE)\n+\t{\n+\t  expr_tree = convert (extended_type, expr_tree);\n+\t  tree_type = extended_type;\n+\t}\n     }\n \n-  // For comparison operators, the resulting type should be boolean.\n-  switch (op)\n+  /* Construct a new tree and build an expression from it. */\n+  auto new_tree = fold_build1_loc (location.gcc_location (), tree_code,\n+\t\t\t\t   tree_type, expr_tree);\n+  return this->make_expression (new_tree);\n+}\n+\n+// Return an expression for the arithmetic or logical operation LEFT OP RIGHT.\n+Bexpression *\n+Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t       Bexpression *left,\n+\t\t\t\t\t       Bexpression *right,\n+\t\t\t\t\t       Location location)\n+{\n+  /* Check if either expression is an error, in which case we return an error\n+     expression. */\n+  auto left_tree = left->get_tree ();\n+  auto right_tree = right->get_tree ();\n+  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+    return this->error_expression ();\n+\n+  /* We need to determine if we're doing floating point arithmetics of integer\n+     arithmetics. */\n+  bool floating_point = is_floating_point (left_tree);\n+\n+  /* For arithmetic or logical operators, the resulting type should be the same\n+     as the lhs operand. */\n+  auto tree_type = TREE_TYPE (left_tree);\n+  auto tree_code = operator_to_tree_code (op, floating_point);\n+\n+  /* For floating point operations we may need to extend the precision of type.\n+     For example, a 64-bit machine may not support operations on float32. */\n+  if (floating_point)\n     {\n-    case OPERATOR_EQEQ:\n-    case OPERATOR_NOTEQ:\n-    case OPERATOR_LT:\n-    case OPERATOR_LE:\n-    case OPERATOR_GT:\n-    case OPERATOR_GE:\n-      type_tree = boolean_type_node;\n-      break;\n-    default:\n-      break;\n+      auto extended_type = excess_precision_type (tree_type);\n+      if (extended_type != NULL_TREE)\n+\t{\n+\t  left_tree = convert (extended_type, left_tree);\n+\t  right_tree = convert (extended_type, right_tree);\n+\t  tree_type = extended_type;\n+\t}\n     }\n \n-  tree ret = fold_build2_loc (location.gcc_location (), code, type_tree,\n-\t\t\t      left_tree, right_tree);\n-  return this->make_expression (ret);\n+  /* Construct a new tree and build an expression from it. */\n+  auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n+\t\t\t\t   tree_type, left_tree, right_tree);\n+  return this->make_expression (new_tree);\n+}\n+\n+// Return an expression for the comparision operation LEFT OP RIGHT.\n+Bexpression *\n+Gcc_backend::comparision_expression (ComparisionOperator op, Bexpression *left,\n+\t\t\t\t     Bexpression *right, Location location)\n+{\n+  /* Check if either expression is an error, in which case we return an error\n+     expression. */\n+  auto left_tree = left->get_tree ();\n+  auto right_tree = right->get_tree ();\n+  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+    return this->error_expression ();\n+\n+  /* For comparision operators, the resulting type should be boolean. */\n+  auto tree_type = boolean_type_node;\n+  auto tree_code = operator_to_tree_code (op);\n+\n+  /* Construct a new tree and build an expression from it. */\n+  auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n+\t\t\t\t   tree_type, left_tree, right_tree);\n+  return this->make_expression (new_tree);\n+}\n+\n+// Return an expression for the lazy boolean operation LEFT OP RIGHT.\n+Bexpression *\n+Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n+\t\t\t\t      Bexpression *right, Location location)\n+{\n+  /* Check if either expression is an error, in which case we return an error\n+     expression. */\n+  auto left_tree = left->get_tree ();\n+  auto right_tree = right->get_tree ();\n+  if (left_tree == error_mark_node || right_tree == error_mark_node)\n+    return this->error_expression ();\n+\n+  /* For lazy boolean operators, the resulting type should be the same as the\n+     rhs operand. */\n+  auto tree_type = TREE_TYPE (right_tree);\n+  auto tree_code = operator_to_tree_code (op);\n+\n+  /* Construct a new tree and build an expression from it. */\n+  auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n+\t\t\t\t   tree_type, left_tree, right_tree);\n+  return this->make_expression (new_tree);\n }\n \n // Return an expression that constructs BTYPE with VALS."}]}