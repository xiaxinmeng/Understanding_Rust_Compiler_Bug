{"sha": "3c46c513c2008d845cf09642aef08b78b1d2f226", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M0NmM1MTNjMjAwOGQ4NDVjZjA5NjQyYWVmMDhiNzhiMWQyZjIyNg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-01-20T20:09:22Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-01-20T20:09:22Z"}, "message": "re PR debug/19124 (gcc generates incorrect dwarf2 debug info)\n\n2005-01-20  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR debug/19124\n\t* dwarf2out.c (concat_loc_descriptor): We don't know we can use\n\tfbreg, so we have to assume we can't.\n\t(loc_descriptor_from_tree_1): Ditto.\n\t(containing_function_has_frame_base): New function.\n\t(add_location_or_const_value_attribute): Use it.\n\tAlso try to generate a frame_base from a single element location\n\tlist.\n\nFrom-SVN: r93979", "tree": {"sha": "302dada6aafe211b1bea0e17a54e27a3d262111d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/302dada6aafe211b1bea0e17a54e27a3d262111d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c46c513c2008d845cf09642aef08b78b1d2f226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c46c513c2008d845cf09642aef08b78b1d2f226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c46c513c2008d845cf09642aef08b78b1d2f226", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c46c513c2008d845cf09642aef08b78b1d2f226/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23ab2e4e18a866eee66c4576b4a7f98c1124cbf4"}], "stats": {"total": 81, "additions": 69, "deletions": 12}, "files": [{"sha": "cf511fa1dd8e4e23f46cea07baea3796b950065b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c46c513c2008d845cf09642aef08b78b1d2f226/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c46c513c2008d845cf09642aef08b78b1d2f226/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c46c513c2008d845cf09642aef08b78b1d2f226", "patch": "@@ -1,3 +1,14 @@\n+2005-01-20  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR debug/19124\n+\t* dwarf2out.c (concat_loc_descriptor): We don't know we can use\n+\tfbreg, so we have to assume we can't.\n+\t(loc_descriptor_from_tree_1): Ditto.\n+\t(containing_function_has_frame_base): New function.\n+\t(add_location_or_const_value_attribute): Use it.\n+\tAlso try to generate a frame_base from a single element location\n+\tlist.\n+\t\n 2005-01-20  Kazu Hirata  <kazu@cs.umass.edu>\n \n \tPR tree-optimization/15349"}, {"sha": "6336cf69dba8b283d842e8f333af738ea4912f34", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c46c513c2008d845cf09642aef08b78b1d2f226/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c46c513c2008d845cf09642aef08b78b1d2f226/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3c46c513c2008d845cf09642aef08b78b1d2f226", "patch": "@@ -8714,8 +8714,8 @@ static dw_loc_descr_ref\n concat_loc_descriptor (rtx x0, rtx x1)\n {\n   dw_loc_descr_ref cc_loc_result = NULL;\n-  dw_loc_descr_ref x0_ref = loc_descriptor (x0, true);\n-  dw_loc_descr_ref x1_ref = loc_descriptor (x1, true);\n+  dw_loc_descr_ref x0_ref = loc_descriptor (x0, false);\n+  dw_loc_descr_ref x1_ref = loc_descriptor (x1, false);\n \n   if (x0_ref == 0 || x1_ref == 0)\n     return 0;\n@@ -8934,15 +8934,15 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \n \t    /* Certain constructs can only be represented at top-level.  */\n \t    if (want_address == 2)\n-\t      return loc_descriptor (rtl, true);\n+\t      return loc_descriptor (rtl, false);\n \n \t    mode = GET_MODE (rtl);\n \t    if (MEM_P (rtl))\n \t      {\n \t\trtl = XEXP (rtl, 0);\n \t\thave_address = 1;\n \t      }\n-\t    ret = mem_loc_descriptor (rtl, mode, true);\n+\t    ret = mem_loc_descriptor (rtl, mode, false);\n \t  }\n       }\n       break;\n@@ -9021,7 +9021,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t  return 0;\n \tmode = GET_MODE (rtl);\n \trtl = XEXP (rtl, 0);\n-\tret = mem_loc_descriptor (rtl, mode, true);\n+\tret = mem_loc_descriptor (rtl, mode, false);\n \thave_address = 1;\n \tbreak;\n       }\n@@ -9971,6 +9971,29 @@ rtl_for_decl_location (tree decl)\n   return rtl;\n }\n \n+/* Return true if DECL's containing function has a frame base attribute.\n+   Return false otherwise.  */\n+\n+static bool\n+containing_function_has_frame_base (tree decl)\n+{\n+  tree declcontext = decl_function_context (decl);\n+  dw_die_ref context;\n+  dw_attr_ref attr;\n+  \n+  if (!declcontext)\n+    return false;\n+\n+  context = lookup_decl_die (declcontext);\n+  if (!context)\n+    return false;\n+\n+  for (attr = context->die_attr; attr; attr = attr->dw_attr_next)\n+    if (attr->dw_attr == DW_AT_frame_base)\n+      return true;\n+  return false;\n+}\n+  \n /* Generate *either* a DW_AT_location attribute or else a DW_AT_const_value\n    data attribute for a variable or a parameter.  We generate the\n    DW_AT_const_value attribute only in those cases where the given variable\n@@ -9989,12 +10012,15 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n   rtx rtl;\n   dw_loc_descr_ref descr;\n   var_loc_list *loc_list;\n-\n+  bool can_use_fb;\n+  struct var_loc_node *node;\n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL);\n+\t     \n+  can_use_fb = containing_function_has_frame_base (decl);\n \n   /* See if we possibly have multiple locations for this variable.  */\n   loc_list = lookup_decl_loc (decl);\n@@ -10007,7 +10033,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       const char *endname;\n       dw_loc_list_ref list;\n       rtx varloc;\n-      struct var_loc_node *node;\n+\n \n       /* We need to figure out what section we should use as the base\n \t for the address ranges where a given location is valid.\n@@ -10046,7 +10072,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \n       node = loc_list->first;\n       varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-      list = new_loc_list (loc_descriptor (varloc, attr != DW_AT_frame_base),\n+      list = new_loc_list (loc_descriptor (varloc, can_use_fb),\n \t\t\t   node->label, node->next->label, secname, 1);\n       node = node->next;\n \n@@ -10058,7 +10084,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t    varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n \t    add_loc_descr_to_loc_list (&list,\n \t\t\t\t       loc_descriptor (varloc,\n-\t\t\t\t\t\t       attr != DW_AT_frame_base),\n+\t\t\t\t\t\t       can_use_fb),\n \t\t\t\t       node->label, node->next->label, secname);\n \t  }\n \n@@ -10079,7 +10105,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t    }\n \t  add_loc_descr_to_loc_list (&list,\n \t\t\t\t     loc_descriptor (varloc,\n-\t\t\t\t\t\t     attr != DW_AT_frame_base),\n+\t\t\t\t\t\t     can_use_fb),\n \t\t\t\t     node->label, endname, secname);\n \t}\n \n@@ -10088,16 +10114,36 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       return;\n     }\n \n+  /* Try to get some constant RTL for this decl, and use that as the value of\n+     the location.  */\n+  \n   rtl = rtl_for_decl_location (decl);\n   if (rtl && (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING))\n     {\n       add_const_value_attribute (die, rtl);\n       return;\n     }\n-\n+  \n+  /* We couldn't get any rtl, and we had no >1 element location list, so try\n+     directly generating the location description from the tree.  */\n   descr = loc_descriptor_from_tree (decl);\n   if (descr)\n-    add_AT_location_description (die, attr, descr);\n+    {\n+      add_AT_location_description (die, attr, descr);\n+      return;\n+    }\n+  \n+  /* Lastly, if we have tried to generate the location otherwise, and it\n+     didn't work out (we wouldn't be here if we did), and we have a one entry\n+     location list, try generating a location from that.  */\n+  if (loc_list && loc_list->first)\n+    {\n+      node = loc_list->first;\n+      descr = loc_descriptor (NOTE_VAR_LOCATION (node->var_loc_note), \n+\t\t\t      can_use_fb);\n+      if (descr)\n+\tadd_AT_location_description (die, attr, descr);\n+    }\n }\n \n /* If we don't have a copy of this variable in memory for some reason (such"}]}