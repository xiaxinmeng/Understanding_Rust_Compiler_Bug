{"sha": "f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjczMmZhN2I2Y2Q4ZjEyNWYxOWFhMTUwZDg4ZDQ3YTE1ZTAwOTljYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-06-29T14:34:58Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-06-29T14:34:58Z"}, "message": "re PR c++/45923 (constexpr diagnostics, more more)\n\n\tPR c++/45923\n\t* class.c (explain_non_literal_class): New.\n\t(finalize_literal_type_property): Call it.\n\t* cp-tree.h: Declare it.\n\t* semantics.c (ensure_literal_type_for_constexpr_object): Call it.\n\t(is_valid_constexpr_fn): Likewise.\n\t(massage_constexpr_body): Split out from...\n\t(register_constexpr_fundef): ...here.\n\t(is_instantiation_of_constexpr): New.\n\t(expand_or_defer_fn_1): Leave DECL_SAVED_TREE alone in that case.\n\t(explain_invalid_constexpr_fn): New.\n\t(cxx_eval_call_expression): Call it.\n\t(potential_constant_expression_1): Likewise.  Avoid redundant errors.\n\t* method.c (process_subob_fn): Diagnose non-constexpr.\n\t(walk_field_subobs): Likewise.\n\t(synthesized_method_walk): Don't shortcut if we want diagnostics.\n\t(explain_implicit_non_constexpr): New.\n\t(defaulted_late_check): Use it.\n\t* call.c (build_cxx_call): Remember location.\n\nFrom-SVN: r175646", "tree": {"sha": "c78bb4975e01ac82dfc07cfc5592be17dedd13d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c78bb4975e01ac82dfc07cfc5592be17dedd13d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "874d29e5bebbebee89836e041a0de18d183d7303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874d29e5bebbebee89836e041a0de18d183d7303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874d29e5bebbebee89836e041a0de18d183d7303"}], "stats": {"total": 376, "additions": 315, "deletions": 61}, "files": [{"sha": "db0478a6285f5b9d511a6a267950dea4a2447bc5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -1,5 +1,25 @@\n 2011-06-29  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/45923\n+\t* class.c (explain_non_literal_class): New.\n+\t(finalize_literal_type_property): Call it.\n+\t* cp-tree.h: Declare it.\n+\t* semantics.c (ensure_literal_type_for_constexpr_object): Call it.\n+\t(is_valid_constexpr_fn): Likewise.\n+\t(massage_constexpr_body): Split out from...\n+\t(register_constexpr_fundef): ...here.\n+\t(is_instantiation_of_constexpr): New.\n+\t(expand_or_defer_fn_1): Leave DECL_SAVED_TREE alone in that case.\n+\t(explain_invalid_constexpr_fn): New.\n+\t(cxx_eval_call_expression): Call it.\n+\t(potential_constant_expression_1): Likewise.  Avoid redundant errors.\n+\t* method.c (process_subob_fn): Diagnose non-constexpr.\n+\t(walk_field_subobs): Likewise.\n+\t(synthesized_method_walk): Don't shortcut if we want diagnostics.\n+\t(explain_implicit_non_constexpr): New.\n+\t(defaulted_late_check): Use it.\n+\t* call.c (build_cxx_call): Remember location.\n+\n \t* method.c (maybe_explain_implicit_delete): Use pointer_set\n \tinstead of htab.\n "}, {"sha": "56f3408adc6b5c86e4005bd2f6bf6a2e3f4a8df1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -6721,7 +6721,10 @@ build_cxx_call (tree fn, int nargs, tree *argarray)\n {\n   tree fndecl;\n \n+  /* Remember roughly where this call is.  */\n+  location_t loc = EXPR_LOC_OR_HERE (fn);\n   fn = build_call_a (fn, nargs, argarray);\n+  SET_EXPR_LOCATION (fn, loc);\n \n   /* If this call might throw an exception, note that fact.  */\n   fndecl = get_callee_fndecl (fn);"}, {"sha": "6aefd6840756c5a7faf28e46f2e063b0f3b73fd4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"tree-dump.h\"\n #include \"splay-tree.h\"\n+#include \"pointer-set.h\"\n \n /* The number of nested classes being processed.  If we are not in the\n    scope of any class, this is zero.  */\n@@ -4582,10 +4583,73 @@ finalize_literal_type_property (tree t)\n \t{\n \t  DECL_DECLARED_CONSTEXPR_P (fn) = false;\n \t  if (!DECL_TEMPLATE_INFO (fn))\n-\t    error (\"enclosing class of %q+#D is not a literal type\", fn);\n+\t    {\n+\t      error (\"enclosing class of constexpr non-static member \"\n+\t\t     \"function %q+#D is not a literal type\", fn);\n+\t      explain_non_literal_class (t);\n+\t    }\n \t}\n }\n \n+/* T is a non-literal type used in a context which requires a constant\n+   expression.  Explain why it isn't literal.  */\n+\n+void\n+explain_non_literal_class (tree t)\n+{\n+  static struct pointer_set_t *diagnosed;\n+\n+  if (!CLASS_TYPE_P (t))\n+    return;\n+  t = TYPE_MAIN_VARIANT (t);\n+\n+  if (diagnosed == NULL)\n+    diagnosed = pointer_set_create ();\n+  if (pointer_set_insert (diagnosed, t) != 0)\n+    /* Already explained.  */\n+    return;\n+\n+  inform (0, \"%q+T is not literal because:\", t);\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n+    inform (0, \"  %q+T has a non-trivial destructor\", t);\n+  else if (CLASSTYPE_NON_AGGREGATE (t)\n+\t   && !TYPE_HAS_TRIVIAL_DFLT (t)\n+\t   && !TYPE_HAS_CONSTEXPR_CTOR (t))\n+    inform (0, \"  %q+T is not an aggregate, does not have a trivial \"\n+\t    \"default constructor, and has no constexpr constructor that \"\n+\t    \"is not a copy or move constructor\", t);\n+  else\n+    {\n+      tree binfo, base_binfo, field; int i;\n+      for (binfo = TYPE_BINFO (t), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\t{\n+\t  tree basetype = TREE_TYPE (base_binfo);\n+\t  if (!CLASSTYPE_LITERAL_P (basetype))\n+\t    {\n+\t      inform (0, \"  base class %qT of %q+T is non-literal\",\n+\t\t      basetype, t);\n+\t      explain_non_literal_class (basetype);\n+\t      return;\n+\t    }\n+\t}\n+      for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+\t{\n+\t  tree ftype;\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\t  ftype = TREE_TYPE (field);\n+\t  if (!literal_type_p (ftype))\n+\t    {\n+\t      inform (0, \"  non-static data member %q+D has \"\n+\t\t      \"non-literal type\", field);\n+\t      if (CLASS_TYPE_P (ftype))\n+\t\texplain_non_literal_class (ftype);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Check the validity of the bases and members declared in T.  Add any\n    implicitly-generated functions (like copy-constructors and\n    assignment operators).  Compute various flag bits (like"}, {"sha": "7244cc88d4a1480a200dc231608472d0be8036e5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -4816,6 +4816,7 @@ extern bool type_has_virtual_destructor\t\t(tree);\n extern bool type_has_move_constructor\t\t(tree);\n extern bool type_has_move_assign\t\t(tree);\n extern bool type_build_ctor_call\t\t(tree);\n+extern void explain_non_literal_class\t\t(tree);\n extern void defaulted_late_check\t\t(tree);\n extern bool defaultable_fn_check\t\t(tree);\n extern void fixup_type_variants\t\t\t(tree);\n@@ -5094,6 +5095,7 @@ extern void finish_thunk\t\t\t(tree);\n extern void use_thunk\t\t\t\t(tree, bool);\n extern bool trivial_fn_p\t\t\t(tree);\n extern bool maybe_explain_implicit_delete\t(tree);\n+extern void explain_implicit_non_constexpr\t(tree);\n extern void synthesize_method\t\t\t(tree);\n extern tree lazily_declare_fn\t\t\t(special_function_kind,\n \t\t\t\t\t\t tree);\n@@ -5364,6 +5366,7 @@ extern tree maybe_constant_value (tree);\n extern tree maybe_constant_init (tree);\n extern bool is_sub_constant_expr (tree);\n extern bool reduced_constant_expression_p (tree);\n+extern void explain_invalid_constexpr_fn (tree);\n extern VEC(tree,heap)* cx_error_context (void);\n \n enum {"}, {"sha": "f10e846d0ea312df1b7a9d33e0df394487b9f53f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -958,7 +958,15 @@ process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n \t  && !DECL_TEMPLATE_INSTANTIATED (fn))\n \tinstantiate_decl (fn, /*defer_ok*/false, /*expl_class*/false);\n       if (!DECL_DECLARED_CONSTEXPR_P (fn))\n-\t*constexpr_p = false;\n+\t{\n+\t  *constexpr_p = false;\n+\t  if (msg)\n+\t    {\n+\t      inform (0, \"defaulted constructor calls non-constexpr \"\n+\t\t      \"%q+D\", fn);\n+\t      explain_invalid_constexpr_fn (fn);\n+\t    }\n+\t}\n     }\n \n   return;\n@@ -1037,7 +1045,12 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t  /* FIXME will need adjustment for non-static data member\n \t     initializers.  */\n \t  if (constexpr_p && !CLASS_TYPE_P (mem_type))\n-\t    *constexpr_p = false;\n+\t    {\n+\t      *constexpr_p = false;\n+\t      if (msg)\n+\t\tinform (0, \"defaulted default constructor does not \"\n+\t\t\t\"initialize %q+#D\", field);\n+\t    }\n \t}\n \n       if (!CLASS_TYPE_P (mem_type))\n@@ -1071,8 +1084,9 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n /* The caller wants to generate an implicit declaration of SFK for CTYPE\n    which is const if relevant and CONST_P is set.  If spec_p, trivial_p and\n    deleted_p are non-null, set their referent appropriately.  If diag is\n-   true, we're being called from maybe_explain_implicit_delete to give\n-   errors.  */\n+   true, we're either being called from maybe_explain_implicit_delete to\n+   give errors, or if constexpr_p is non-null, from\n+   explain_invalid_constexpr_fn.  */\n \n static void\n synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n@@ -1175,6 +1189,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n      resolution, so a constructor can be trivial even if it would otherwise\n      call a non-trivial constructor.  */\n   if (expected_trivial\n+      && !diag\n       && (!copy_arg_p || cxx_dialect < cxx0x))\n     {\n       if (constexpr_p && sfk == sfk_constructor)\n@@ -1366,6 +1381,20 @@ maybe_explain_implicit_delete (tree decl)\n   return false;\n }\n \n+/* DECL is a defaulted function which was declared constexpr.  Explain why\n+   it can't be constexpr.  */\n+\n+void\n+explain_implicit_non_constexpr (tree decl)\n+{\n+  tree parm_type = TREE_VALUE (FUNCTION_FIRST_USER_PARMTYPE (decl));\n+  bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));\n+  bool dummy;\n+  synthesized_method_walk (DECL_CLASS_CONTEXT (decl),\n+\t\t\t   special_function_p (decl), const_p,\n+\t\t\t   NULL, NULL, NULL, &dummy, true);\n+}\n+\n /* Implicitly declare the special function indicated by KIND, as a\n    member of TYPE.  For copy constructors and assignment operators,\n    CONST_P indicates whether these functions should take a const\n@@ -1581,7 +1610,12 @@ defaulted_late_check (tree fn)\n       && DECL_DECLARED_CONSTEXPR_P (fn))\n     {\n       if (!CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n-\terror (\"%qD cannot be declared as constexpr\", fn);\n+\t{\n+\t  error (\"explicitly defaulted function %q+D cannot be declared \"\n+\t\t \"as constexpr because the implicit declaration is not \"\n+\t\t \"constexpr:\", fn);\n+\t  explain_implicit_non_constexpr (fn);\n+\t}\n       DECL_DECLARED_CONSTEXPR_P (fn) = false;\n     }\n "}, {"sha": "458172980b421bd13a8ce65ea72ff488fba6ac59", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 117, "deletions": 50, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -3538,6 +3538,17 @@ emit_associated_thunks (tree fn)\n     }\n }\n \n+/* Returns true iff FUN is an instantiation of a constexpr function\n+   template.  */\n+\n+static inline bool\n+is_instantiation_of_constexpr (tree fun)\n+{\n+  return (DECL_TEMPLATE_INFO (fun)\n+\t  && DECL_DECLARED_CONSTEXPR_P (DECL_TEMPLATE_RESULT\n+\t\t\t\t\t(DECL_TI_TEMPLATE (fun))));\n+}\n+\n /* Generate RTL for FN.  */\n \n bool\n@@ -3567,7 +3578,10 @@ expand_or_defer_fn_1 (tree fn)\n       /* We don't want to process FN again, so pretend we've written\n \t it out, even though we haven't.  */\n       TREE_ASM_WRITTEN (fn) = 1;\n-      DECL_SAVED_TREE (fn) = NULL_TREE;\n+      /* If this is an instantiation of a constexpr function, keep\n+\t DECL_SAVED_TREE for explain_invalid_constexpr_fn.  */\n+      if (!is_instantiation_of_constexpr (fn))\n+\tDECL_SAVED_TREE (fn) = NULL_TREE;\n       return false;\n     }\n \n@@ -5299,6 +5313,7 @@ ensure_literal_type_for_constexpr_object (tree decl)\n \t{\n \t  error (\"the type %qT of constexpr variable %qD is not literal\",\n \t\t type, decl);\n+\t  explain_non_literal_class (type);\n \t  return NULL;\n \t}\n     }\n@@ -5365,8 +5380,11 @@ is_valid_constexpr_fn (tree fun, bool complain)\n       {\n \tret = false;\n \tif (complain)\n-\t  error (\"invalid type for parameter %d of constexpr \"\n-\t\t \"function %q+#D\", DECL_PARM_INDEX (parm), fun);\n+\t  {\n+\t    error (\"invalid type for parameter %d of constexpr \"\n+\t\t   \"function %q+#D\", DECL_PARM_INDEX (parm), fun);\n+\t    explain_non_literal_class (TREE_TYPE (parm));\n+\t  }\n       }\n \n   if (!DECL_CONSTRUCTOR_P (fun))\n@@ -5376,8 +5394,11 @@ is_valid_constexpr_fn (tree fun, bool complain)\n \t{\n \t  ret = false;\n \t  if (complain)\n-\t    error (\"invalid return type %qT of constexpr function %q+D\",\n-\t\t   rettype, fun);\n+\t    {\n+\t      error (\"invalid return type %qT of constexpr function %q+D\",\n+\t\t     rettype, fun);\n+\t      explain_non_literal_class (rettype);\n+\t    }\n \t}\n \n       /* Check this again here for cxx_eval_call_expression.  */\n@@ -5386,7 +5407,11 @@ is_valid_constexpr_fn (tree fun, bool complain)\n \t{\n \t  ret = false;\n \t  if (complain)\n-\t    error (\"enclosing class of %q+#D is not a literal type\", fun);\n+\t    {\n+\t      error (\"enclosing class of constexpr non-static member \"\n+\t\t     \"function %q+#D is not a literal type\", fun);\n+\t      explain_non_literal_class (DECL_CONTEXT (fun));\n+\t    }\n \t}\n     }\n \n@@ -5640,18 +5665,13 @@ constexpr_fn_retval (tree body)\n     }\n }\n \n-/* We are processing the definition of the constexpr function FUN.\n-   Check that its BODY fulfills the propriate requirements and\n-   enter it in the constexpr function definition table.\n-   For constructor BODY is actually the TREE_LIST of the\n-   member-initializer list.  */\n+/* Subroutine of register_constexpr_fundef.  BODY is the DECL_SAVED_TREE of\n+   FUN; do the necessary transformations to turn it into a single expression\n+   that we can store in the hash table.  */\n \n-tree\n-register_constexpr_fundef (tree fun, tree body)\n+static tree\n+massage_constexpr_body (tree fun, tree body)\n {\n-  constexpr_fundef entry;\n-  constexpr_fundef **slot;\n-\n   if (DECL_CONSTRUCTOR_P (fun))\n     body = build_constexpr_constructor_member_initializers\n       (DECL_CONTEXT (fun), body);\n@@ -5666,12 +5686,28 @@ register_constexpr_fundef (tree fun, tree body)\n       if (TREE_CODE (body) == CLEANUP_POINT_EXPR)\n         body = TREE_OPERAND (body, 0);\n       body = constexpr_fn_retval (body);\n-      if (body == NULL_TREE || body == error_mark_node)\n-        {\n-          error (\"body of constexpr function %qD not a return-statement\", fun);\n-          DECL_DECLARED_CONSTEXPR_P (fun) = false;\n-          return NULL;\n-        }\n+    }\n+  return body;\n+}\n+\n+/* We are processing the definition of the constexpr function FUN.\n+   Check that its BODY fulfills the propriate requirements and\n+   enter it in the constexpr function definition table.\n+   For constructor BODY is actually the TREE_LIST of the\n+   member-initializer list.  */\n+\n+tree\n+register_constexpr_fundef (tree fun, tree body)\n+{\n+  constexpr_fundef entry;\n+  constexpr_fundef **slot;\n+\n+  body = massage_constexpr_body (fun, body);\n+  if (body == NULL_TREE || body == error_mark_node)\n+    {\n+      error (\"body of constexpr function %qD not a return-statement\", fun);\n+      DECL_DECLARED_CONSTEXPR_P (fun) = false;\n+      return NULL;\n     }\n \n   if (!potential_rvalue_constant_expression (body))\n@@ -5700,6 +5736,44 @@ register_constexpr_fundef (tree fun, tree body)\n   return fun;\n }\n \n+/* FUN is a non-constexpr function called in a context that requires a\n+   constant expression.  If it comes from a constexpr template, explain why\n+   the instantiation isn't constexpr.  */\n+\n+void\n+explain_invalid_constexpr_fn (tree fun)\n+{\n+  static struct pointer_set_t *diagnosed;\n+  tree body;\n+  location_t save_loc;\n+  /* Only diagnose instantiations of constexpr templates.  */\n+  if (!is_instantiation_of_constexpr (fun))\n+    return;\n+  if (diagnosed == NULL)\n+    diagnosed = pointer_set_create ();\n+  if (pointer_set_insert (diagnosed, fun) != 0)\n+    /* Already explained.  */\n+    return;\n+\n+  save_loc = input_location;\n+  input_location = DECL_SOURCE_LOCATION (fun);\n+  inform (0, \"%q+D is not constexpr because it does not satisfy the \"\n+\t  \"requirements:\", fun);\n+  /* First check the declaration.  */\n+  if (is_valid_constexpr_fn (fun, true))\n+    {\n+      /* Then if it's OK, the body.  */\n+      if (DECL_DEFAULTED_FN (fun))\n+\texplain_implicit_non_constexpr (fun);\n+      else\n+\t{\n+\t  body = massage_constexpr_body (fun, DECL_SAVED_TREE (fun));\n+\t  require_potential_rvalue_constant_expression (body);\n+\t}\n+    }\n+  input_location = save_loc;\n+}\n+\n /* Objects of this type represent calls to constexpr functions\n    along with the bindings of parameters to their arguments, for\n    the purpose of compile time evaluation.  */\n@@ -6005,7 +6079,7 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n     }\n   if (TREE_CODE (fun) != FUNCTION_DECL)\n     {\n-      if (!allow_non_constant)\n+      if (!allow_non_constant && !*non_constant_p)\n \terror_at (loc, \"expression %qE does not designate a constexpr \"\n \t\t  \"function\", fun);\n       *non_constant_p = true;\n@@ -6020,11 +6094,8 @@ cxx_eval_call_expression (const constexpr_call *old_call, tree t,\n     {\n       if (!allow_non_constant)\n \t{\n-\t  error_at (loc, \"%qD is not a constexpr function\", fun);\n-\t  if (DECL_TEMPLATE_INFO (fun)\n-\t      && DECL_DECLARED_CONSTEXPR_P (DECL_TEMPLATE_RESULT\n-\t\t\t\t\t    (DECL_TI_TEMPLATE (fun))))\n-\t    is_valid_constexpr_fn (fun, true);\n+\t  error_at (loc, \"call to non-constexpr function %qD\", fun);\n+\t  explain_invalid_constexpr_fn (fun);\n \t}\n       *non_constant_p = true;\n       return t;\n@@ -7023,8 +7094,11 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n       if (!literal_type_p (TREE_TYPE (t)))\n \t{\n \t  if (!allow_non_constant)\n-\t    error (\"temporary of non-literal type %qT in a \"\n-\t\t   \"constant expression\", TREE_TYPE (t));\n+\t    {\n+\t      error (\"temporary of non-literal type %qT in a \"\n+\t\t     \"constant expression\", TREE_TYPE (t));\n+\t      explain_non_literal_class (TREE_TYPE (t));\n+\t    }\n \t  *non_constant_p = true;\n \t  break;\n \t}\n@@ -7574,7 +7648,11 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t\t    && !morally_constexpr_builtin_function_p (fun))\n \t\t  {\n \t\t    if (flags & tf_error)\n-\t\t      error (\"%qD is not %<constexpr%>\", fun);\n+\t\t      {\n+\t\t\terror_at (EXPR_LOC_OR_HERE (t),\n+\t\t\t\t  \"call to non-constexpr function %qD\", fun);\n+\t\t\texplain_invalid_constexpr_fn (fun);\n+\t\t      }\n \t\t    return false;\n \t\t  }\n \t\t/* A call to a non-static member function takes the address\n@@ -7588,12 +7666,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t\t    if (is_this_parameter (x))\n \t\t      /* OK.  */;\n \t\t    else if (!potential_constant_expression_1 (x, rval, flags))\n-\t\t      {\n-\t\t\tif (flags & tf_error)\n-\t\t\t  error (\"object argument is not a potential \"\n-\t\t\t\t \"constant expression\");\n-\t\t\treturn false;\n-\t\t      }\n+\t\t      return false;\n \t\t    i = 1;\n \t\t  }\n \t      }\n@@ -7609,22 +7682,13 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t    if (potential_constant_expression_1 (fun, rval, flags))\n \t      /* Might end up being a constant function pointer.  */;\n \t    else\n-\t      {\n-\t\tif (flags & tf_error)\n-\t\t  error (\"%qE is not a function name\", fun);\n-\t\treturn false;\n-\t      }\n+\t      return false;\n           }\n         for (; i < nargs; ++i)\n           {\n             tree x = get_nth_callarg (t, i);\n \t    if (!potential_constant_expression_1 (x, rval, flags))\n-\t      {\n-\t\tif (flags & tf_error)\n-\t\t  error (\"argument in position %qP is not a \"\n-\t\t\t \"potential constant expression\", i);\n-\t\treturn false;\n-              }\n+\t      return false;\n           }\n         return true;\n       }\n@@ -7853,8 +7917,11 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n       if (!literal_type_p (TREE_TYPE (t)))\n \t{\n \t  if (flags & tf_error)\n-\t    error (\"temporary of non-literal type %qT in a \"\n-\t\t   \"constant expression\", TREE_TYPE (t));\n+\t    {\n+\t      error (\"temporary of non-literal type %qT in a \"\n+\t\t     \"constant expression\", TREE_TYPE (t));\n+\t      explain_non_literal_class (TREE_TYPE (t));\n+\t    }\n \t  return false;\n \t}\n     case INIT_EXPR:"}, {"sha": "d30d8b053c2fa243c33a677d9debcbd2a3d4dd82", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -1,3 +1,12 @@\n+2011-06-29  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/45923\n+\t* g++.dg/cpp0x/constexpr-diag3.C: New.\n+\t* g++.dg/cpp0x/constexpr-diag1.C: Adjust error message.\n+\t* g++.dg/cpp0x/constexpr-ex1.C: Adjust error message.\n+\t* g++.dg/cpp0x/constexpr-friend.C: Adjust error message.\n+\t* g++.dg/cpp0x/constexpr-incomplete2.C: Adjust error message.\n+\n 2011-06-29  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/constexpr-is_literal.C: Adjust."}, {"sha": "44e6bc7e089da660922fc105633add0dd2ec813e", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-diag1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag1.C?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -13,7 +13,7 @@ struct B { B(); operator int(); };\n constexpr A<int> ai = { 42 };\n constexpr int i = ai.f();\n \n-constexpr int b = A<B>().f();\t// { dg-error \"not a constexpr function\" }\n+constexpr int b = A<B>().f();\t// { dg-error \"non-constexpr function\" }\n \n template <class T>\n constexpr int f (T t) { return 42; } // { dg-error \"parameter\" }"}, {"sha": "100c17edb45ce82a22490905cc9e23c8b88a1130", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-diag3.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag3.C?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -0,0 +1,54 @@\n+// PR c++/45923\n+// { dg-options -std=c++0x }\n+\n+int f(int);\n+\n+template <class T>\n+constexpr T g(T t) { return f(t); } // { dg-error \"f.int\" }\n+\n+int main()\n+{\n+  constexpr int i = g(1);\t// { dg-error \"g.T\" }\n+}\n+\n+// --------------------\n+\n+struct complex \t\t\t// { dg-message \"no constexpr constructor\" }\n+{\n+  complex(double r, double i) : re(r), im(i) { }\n+  constexpr double real() { return re; } // { dg-error \"not a literal type\" }\n+  double imag() const { return im; }\n+\n+private:\n+  double re;\n+  double im;\n+};\n+\n+constexpr complex co1(0, 1);\t   // { dg-error \"not literal\" }\n+constexpr double dd2 = co1.real(); // { dg-error \"non-constexpr function\" }\n+\n+// --------------------\n+\n+struct base\t\t       // { dg-message \"no constexpr constructor\" }\n+{\n+  int _M_i;\n+  base() : _M_i(5) { }\n+};\n+\n+struct derived : public base\t// { dg-message \"base class\" }\n+{\n+  constexpr derived(): base() { } // { dg-error \"non-constexpr function\" }\n+};\n+\n+constexpr derived obj;\t\t// { dg-error \"not literal\" }\n+\n+// --------------------\n+\n+struct Def\n+{\n+  int _M_i;\t\t\t// { dg-message \"does not initialize\" }\n+\n+  constexpr Def() = default;\t// { dg-error \"implicit declaration is not constexpr\" }\n+};\n+\n+constexpr Def defobj;\t\t// { dg-error \"uninitialized\" }"}, {"sha": "584a5a09b69244cd037b830dfbaf502c16692753", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ex1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -88,7 +88,7 @@ struct resource {\n   }\n };\n constexpr resource f(resource d)\n-{ return d; }                  // { dg-error \"not .constexpr\" }\n+{ return d; }                  // { dg-error \"non-constexpr\" }\n constexpr resource d = f(9);   // { dg-error \"resource\" }\n \n // 4.4 floating-point constant expressions"}, {"sha": "1831a2b003c6f609b3d57eadf4189e30b3f4bc2d", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-friend.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -19,5 +19,5 @@ struct C\n \n constexpr int i = f(C<int>());\n constexpr int j = C<int>().m(C<int>());\n-constexpr int k = C<double>().m(A()); // { dg-error \"not a constexpr function\" }\n-constexpr int l = g(C<double>(),A()); // { dg-error \"not a constexpr function\" }\n+constexpr int k = C<double>().m(A()); // { dg-error \"non-constexpr function\" }\n+constexpr int l = g(C<double>(),A()); // { dg-error \"non-constexpr function\" }"}, {"sha": "f61535f06be517a23ff22d259db25d2c74186d74", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-incomplete2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-incomplete2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f732fa7b6cd8f125f19aa150d88d47a15e0099cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-incomplete2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-incomplete2.C?ref=f732fa7b6cd8f125f19aa150d88d47a15e0099cc", "patch": "@@ -28,4 +28,4 @@ struct D\n   C<D> c;\n };\n \n-constexpr D d {};\t\t// { dg-error \"not a constexpr function\" }\n+constexpr D d {};\t\t// { dg-error \"non-constexpr function\" }"}]}