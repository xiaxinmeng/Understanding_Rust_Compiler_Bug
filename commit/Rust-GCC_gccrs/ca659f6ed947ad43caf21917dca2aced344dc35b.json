{"sha": "ca659f6ed947ad43caf21917dca2aced344dc35b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E2NTlmNmVkOTQ3YWQ0M2NhZjIxOTE3ZGNhMmFjZWQzNDRkYzM1Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-11-30T17:36:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-11-30T17:36:07Z"}, "message": "i386.c (avx_vperm2f128_parallel): New.\n\n        * config/i386/i386.c (avx_vperm2f128_parallel): New.\n        * config/i386/i386-protos.h: Declare it.\n        * config/i386/predicates.md (avx_vperm2f128_v8sf_operand,\n        avx_vperm2f128_v8si_operand, avx_vperm2f128_v4df_operand): New.\n        * config/i386/sse.md (avx_vperm2f128<mode>3): Change to expander.\n        (*avx_vperm2f128<mode>_full): Renamed from avx_vperm2f128<mode>3.\n        (*avx_vperm2f128<mode>_nozero): New.\n\nFrom-SVN: r154832", "tree": {"sha": "81089e4741573f313e575a9c01940ccb37b00977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81089e4741573f313e575a9c01940ccb37b00977"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca659f6ed947ad43caf21917dca2aced344dc35b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca659f6ed947ad43caf21917dca2aced344dc35b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca659f6ed947ad43caf21917dca2aced344dc35b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca659f6ed947ad43caf21917dca2aced344dc35b/comments", "author": null, "committer": null, "parents": [{"sha": "784e5ae13ae4f05fbd5aaebdc98e176b513b3c62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/784e5ae13ae4f05fbd5aaebdc98e176b513b3c62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/784e5ae13ae4f05fbd5aaebdc98e176b513b3c62"}], "stats": {"total": 136, "additions": 135, "deletions": 1}, "files": [{"sha": "96cacc0e0f788c966222153a5e1ffaf075c0e70a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca659f6ed947ad43caf21917dca2aced344dc35b", "patch": "@@ -1,3 +1,13 @@\n+2009-11-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (avx_vperm2f128_parallel): New.\n+\t* config/i386/i386-protos.h: Declare it.\n+\t* config/i386/predicates.md (avx_vperm2f128_v8sf_operand,\n+\tavx_vperm2f128_v8si_operand, avx_vperm2f128_v4df_operand): New.\n+\t* config/i386/sse.md (avx_vperm2f128<mode>3): Change to expander.\n+\t(*avx_vperm2f128<mode>_full): Renamed from avx_vperm2f128<mode>3.\n+\t(*avx_vperm2f128<mode>_nozero): New.\n+\n 2009-11-30  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386-builtin-types.def (V4DF_FTYPE_V4DF_V4DF_V4DI): New."}, {"sha": "1e94cde200d5867bc377d1d1241ceacc31962283", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ca659f6ed947ad43caf21917dca2aced344dc35b", "patch": "@@ -48,6 +48,7 @@ extern bool x86_extended_reg_mentioned_p (rtx);\n extern enum machine_mode ix86_cc_mode (enum rtx_code, rtx, rtx);\n \n extern int avx_vpermilp_parallel (rtx par, enum machine_mode mode);\n+extern int avx_vperm2f128_parallel (rtx par, enum machine_mode mode);\n \n extern int ix86_expand_movmem (rtx, rtx, rtx, rtx, rtx, rtx);\n extern int ix86_expand_setmem (rtx, rtx, rtx, rtx, rtx, rtx);"}, {"sha": "fa84e32a997cbe30a9c46407b389df26cb389d5a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ca659f6ed947ad43caf21917dca2aced344dc35b", "patch": "@@ -24646,6 +24646,58 @@ avx_vpermilp_parallel (rtx par, enum machine_mode mode)\n   /* Make sure success has a non-zero value by adding one.  */\n   return mask + 1;\n }\n+\n+/* Helper for avx_vperm2f128_v4df_operand et al.  This is also used by\n+   the expansion functions to turn the parallel back into a mask.\n+   The return value is 0 for no match and the imm8+1 for a match.  */\n+\n+int\n+avx_vperm2f128_parallel (rtx par, enum machine_mode mode)\n+{\n+  unsigned i, nelt = GET_MODE_NUNITS (mode), nelt2 = nelt / 2;\n+  unsigned mask = 0;\n+  unsigned char ipar[8];\n+\n+  if (XVECLEN (par, 0) != (int) nelt)\n+    return 0;\n+\n+  /* Validate that all of the elements are constants, and not totally\n+     out of range.  Copy the data into an integral array to make the\n+     subsequent checks easier.  */\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      rtx er = XVECEXP (par, 0, i);\n+      unsigned HOST_WIDE_INT ei;\n+\n+      if (!CONST_INT_P (er))\n+\treturn 0;\n+      ei = INTVAL (er);\n+      if (ei >= 2 * nelt)\n+\treturn 0;\n+      ipar[i] = ei;\n+    }\n+\n+  /* Validate that the halves of the permute are halves.  */\n+  for (i = 0; i < nelt2 - 1; ++i)\n+    if (ipar[i] + 1 != ipar[i + 1])\n+      return 0;\n+  for (i = nelt2; i < nelt - 1; ++i)\n+    if (ipar[i] + 1 != ipar[i + 1])\n+      return 0;\n+\n+  /* Reconstruct the mask.  */\n+  for (i = 0; i < 2; ++i)\n+    {\n+      unsigned e = ipar[i * nelt2];\n+      if (e % nelt2)\n+\treturn 0;\n+      e /= nelt2;\n+      mask |= e << (i * 4);\n+    }\n+\n+  /* Make sure success has a non-zero value by adding one.  */\n+  return mask + 1;\n+}\n \f\n \n /* Store OPERAND to the memory after reload is completed.  This means"}, {"sha": "50a68d97ff8b57281d40d34b354f7b0a8d81a777", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=ca659f6ed947ad43caf21917dca2aced344dc35b", "patch": "@@ -1227,3 +1227,17 @@\n (define_predicate \"avx_vpermilp_v2df_operand\"\n   (and (match_code \"parallel\")\n        (match_test \"avx_vpermilp_parallel (op, V2DFmode)\")))\n+\n+;; Return 1 if OP is a parallel for a vperm2f128 permute.\n+\n+(define_predicate \"avx_vperm2f128_v8sf_operand\"\n+  (and (match_code \"parallel\")\n+       (match_test \"avx_vperm2f128_parallel (op, V8SFmode)\")))\n+\n+(define_predicate \"avx_vperm2f128_v8si_operand\"\n+  (and (match_code \"parallel\")\n+       (match_test \"avx_vperm2f128_parallel (op, V8SImode)\")))\n+\n+(define_predicate \"avx_vperm2f128_v4df_operand\"\n+  (and (match_code \"parallel\")\n+       (match_test \"avx_vperm2f128_parallel (op, V4DFmode)\")))"}, {"sha": "b73820bc1d0e93f5cb8587cb2dfc37740c268d0a", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca659f6ed947ad43caf21917dca2aced344dc35b/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ca659f6ed947ad43caf21917dca2aced344dc35b", "patch": "@@ -11917,7 +11917,44 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"avx_vperm2f128<mode>3\"\n+(define_expand \"avx_vperm2f128<mode>3\"\n+  [(set (match_operand:AVX256MODE2P 0 \"register_operand\" \"\")\n+\t(unspec:AVX256MODE2P\n+\t  [(match_operand:AVX256MODE2P 1 \"register_operand\" \"\")\n+\t   (match_operand:AVX256MODE2P 2 \"nonimmediate_operand\" \"\")\n+\t   (match_operand:SI 3 \"const_0_to_255_operand\" \"\")]\n+\t  UNSPEC_VPERMIL2F128))]\n+  \"TARGET_AVX\"\n+{\n+  int mask = INTVAL (operands[2]);\n+  if ((mask & 0x88) == 0)\n+    {\n+      rtx perm[<ssescalarnum>], t1, t2;\n+      int i, base, nelt = <ssescalarnum>, nelt2 = nelt / 2;\n+\n+      base = (mask & 3) * nelt2;\n+      for (i = 0; i < nelt2; ++i)\n+\tperm[i] = GEN_INT (base + i);\n+\n+      base = ((mask >> 4) & 3) * nelt2;\n+      for (i = 0; i < nelt2; ++i)\n+\tperm[i + nelt2] = GEN_INT (base + i);\n+\n+      t2 = gen_rtx_VEC_CONCAT (<ssedoublesizemode>mode,\n+\t\t\t       operands[1], operands[2]);\n+      t1 = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nelt, perm));\n+      t2 = gen_rtx_VEC_SELECT (<MODE>mode, t2, t1);\n+      t2 = gen_rtx_SET (VOIDmode, operands[0], t2);\n+      emit_insn (t2);\n+      DONE;\n+    }\n+})\n+\n+;; Note that bits 7 and 3 of the imm8 allow lanes to be zeroed, which\n+;; means that in order to represent this properly in rtl we'd have to\n+;; nest *another* vec_concat with a zero operand and do the select from\n+;; a 4x wide vector.  That doesn't seem very nice.\n+(define_insn \"*avx_vperm2f128<mode>_full\"\n   [(set (match_operand:AVX256MODE2P 0 \"register_operand\" \"=x\")\n \t(unspec:AVX256MODE2P\n \t  [(match_operand:AVX256MODE2P 1 \"register_operand\" \"x\")\n@@ -11932,6 +11969,26 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"V8SF\")])\n \n+(define_insn \"*avx_vperm2f128<mode>_nozero\"\n+  [(set (match_operand:AVX256MODE2P 0 \"register_operand\" \"=x\")\n+\t(vec_select:AVX256MODE2P\n+\t  (vec_concat:<ssedoublesizemode>\n+\t    (match_operand:AVX256MODE2P 1 \"register_operand\" \"x\")\n+\t    (match_operand:AVX256MODE2P 2 \"nonimmediate_operand\" \"xm\"))\n+\t  (match_parallel 3 \"avx_vperm2f128_<mode>_operand\"\n+\t    [(match_operand 4 \"const_int_operand\" \"\")])))]\n+  \"TARGET_AVX\"\n+{\n+  int mask = avx_vperm2f128_parallel (operands[3], <MODE>mode) - 1;\n+  operands[3] = GEN_INT (mask);\n+  return \"vperm2f128\\t{%3, %2, %1, %0|%0, %1, %2, %3}\";\n+}\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set_attr \"mode\" \"V8SF\")])\n+\n (define_insn \"avx_vbroadcasts<avxmodesuffixf2c><avxmodesuffix>\"\n   [(set (match_operand:AVXMODEF4P 0 \"register_operand\" \"=x\")\n \t(vec_concat:AVXMODEF4P"}]}