{"sha": "b35926b9c57680220b7986dde558af26e6bd5832", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1OTI2YjljNTc2ODAyMjBiNzk4NmRkZTU1OGFmMjZlNmJkNTgzMg==", "commit": {"author": {"name": "Bruce Korb", "email": "autogen@linuxbox.com", "date": "1999-11-11T14:57:55Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-11-11T14:57:55Z"}, "message": "Added verbose levels for status messages\n\nFrom-SVN: r30490", "tree": {"sha": "d2f931675bb80dac81952658f30a9f7651da91fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f931675bb80dac81952658f30a9f7651da91fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b35926b9c57680220b7986dde558af26e6bd5832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35926b9c57680220b7986dde558af26e6bd5832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b35926b9c57680220b7986dde558af26e6bd5832", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35926b9c57680220b7986dde558af26e6bd5832/comments", "author": null, "committer": null, "parents": [{"sha": "f185457abf8902bc01032208a56c13cd2c79d40b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f185457abf8902bc01032208a56c13cd2c79d40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f185457abf8902bc01032208a56c13cd2c79d40b"}], "stats": {"total": 146, "additions": 125, "deletions": 21}, "files": [{"sha": "acf4ae3e980939d1f0b4be43a9bb7ab07e27930d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35926b9c57680220b7986dde558af26e6bd5832/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35926b9c57680220b7986dde558af26e6bd5832/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b35926b9c57680220b7986dde558af26e6bd5832", "patch": "@@ -1,3 +1,7 @@\n+1999-11-11  Bruce Korb  <autogen@linuxbox.com>\n+\n+\t* fixinc/fixincl.c: Added verbose levels for status messages\n+\n Thu Nov 11 13:23:04 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* jump.c (jump_optimize_1): Avoid passing an rtx that is not an"}, {"sha": "2d3159b6be3a786244e3eab26061188747455840", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 121, "deletions": 21, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35926b9c57680220b7986dde558af26e6bd5832/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35926b9c57680220b7986dde558af26e6bd5832/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=b35926b9c57680220b7986dde558af26e6bd5832", "patch": "@@ -107,6 +107,20 @@ char *pz_src_dir = NULL;\n char *pz_machine = NULL;\n int find_base_len = 0;\n \n+typedef enum {\n+  VERB_SILENT = 0,\n+  VERB_FIXES,\n+  VERB_APPLIES,\n+  VERB_PROGRESS,\n+  VERB_TESTS,\n+  VERB_EVERYTHING\n+} te_verbose;\n+\n+te_verbose  verbose_level = VERB_PROGRESS;\n+\n+#define VLEVEL(l)  (verbose_level >= l)\n+#define NOT_SILENT VLEVEL(VERB_FIXES)\n+\n pid_t process_chain_head = (pid_t) -1;\n \n char*  pz_curr_file;  /*  name of the current file under test/fix  */\n@@ -258,7 +272,7 @@ main (argc, argv)\n     } /*  for (;;) */\n \n #ifdef DO_STATS\n-  {\n+  if (VLEVEL( VERB_PROGRESS )) {\n     tSCC zFmt[] =\n       \"\\\n Processed %5d files containing %d bytes    \\n\\\n@@ -329,6 +343,42 @@ initialize ()\n       }\n   }\n \n+  {\n+    static const char var[] = \"VERBOSE\";\n+    char* pz = getenv (var);\n+    if (pz != (char *) NULL)\n+      {\n+        if (isdigit( *pz ))\n+          verbose_level = (te_verbose)atoi( pz );\n+        else\n+          switch (*pz) {\n+          case 's':\n+          case 'S':\n+            verbose_level = VERB_SILENT;     break;\n+\n+          case 'f':\n+          case 'F':\n+            verbose_level = VERB_FIXES;      break;\n+\n+          case 'a':\n+          case 'A':\n+            verbose_level = VERB_APPLIES;    break;\n+\n+          case 'p':\n+          case 'P':\n+            verbose_level = VERB_PROGRESS;   break;\n+\n+          case 't':\n+          case 'T':\n+            verbose_level = VERB_TESTS;      break;\n+\n+          case 'e':\n+          case 'E':\n+            verbose_level = VERB_EVERYTHING; break;\n+          }\n+      }\n+  }\n+\n   {\n     static const char var[] = \"FIND_BASE\";\n     char *pz = getenv (var);\n@@ -383,14 +433,16 @@ wait_for_pid(child)\n       {\n         if (! WIFEXITED( status ))\n           {\n-            fprintf (stderr, \"child process %d is hung on signal %d\\n\",\n-                     child, WSTOPSIG( status ));\n+            if (NOT_SILENT)\n+              fprintf (stderr, \"child process %d is hung on signal %d\\n\",\n+                       child, WSTOPSIG( status ));\n             exit (EXIT_FAILURE);\n           }\n         if (WEXITSTATUS( status ) != 0)\n           {\n-            fprintf (stderr, \"child process %d exited with status %d\\n\",\n-                     child, WEXITSTATUS( status ));\n+            if (NOT_SILENT)\n+              fprintf (stderr, \"child process %d exited with status %d\\n\",\n+                       child, WEXITSTATUS( status ));\n             exit (EXIT_FAILURE);\n           }\n         break; /* normal child completion */\n@@ -407,8 +459,9 @@ wait_for_pid(child)\n           break;\n \n         default:\n-          fprintf (stderr, \"Error %d (%s) waiting for %d to finish\\n\",\n-                   errno, strerror( errno ), child );\n+          if (NOT_SILENT)\n+            fprintf (stderr, \"Error %d (%s) waiting for %d to finish\\n\",\n+                     errno, strerror( errno ), child );\n           /* FALLTHROUGH */\n \n         case ECHILD: /* no children to wait for?? */\n@@ -434,8 +487,9 @@ load_file ( fname )\n \n   if (stat (fname, &stbf) != 0)\n     {\n-      fprintf (stderr, \"error %d (%s) stat-ing %s\\n\",\n-               errno, strerror (errno), fname );\n+      if (NOT_SILENT)\n+        fprintf (stderr, \"error %d (%s) stat-ing %s\\n\",\n+                 errno, strerror (errno), fname );\n       return (char *) NULL;\n     }\n   if (stbf.st_size == 0)\n@@ -447,8 +501,9 @@ load_file ( fname )\n \n   if (data_map_fd < 0)\n     {\n-      fprintf (stderr, \"error %d (%s) opening %s for read\\n\",\n-               errno, strerror (errno), fname);\n+      if (NOT_SILENT)\n+        fprintf (stderr, \"error %d (%s) opening %s for read\\n\",\n+                 errno, strerror (errno), fname);\n       return (char*)NULL;\n     }\n \n@@ -691,7 +746,8 @@ create_file ()\n                errno, strerror (errno), fname);\n       exit (EXIT_FAILURE);\n     }\n-  fprintf (stderr, \"Fixed:  %s\\n\", pz_curr_file);\n+  if (NOT_SILENT)\n+    fprintf (stderr, \"Fixed:  %s\\n\", pz_curr_file);\n   pf = fdopen (fd, \"w\");\n \n #ifdef LATER\n@@ -837,7 +893,8 @@ extract_quoted_files (pz_data, pz_fixed_file, p_re_match)\n   char *pz_dir_end = strrchr (pz_fixed_file, '/');\n   char *pz_incl_quot = pz_data;\n \n-  fprintf (stderr, \"Quoted includes in %s\\n\", pz_fixed_file);\n+  if (VLEVEL( VERB_APPLIES ))\n+    fprintf (stderr, \"Quoted includes in %s\\n\", pz_fixed_file);\n \n   /*  Set \"pz_fixed_file\" to point to the containing subdirectory of the source\n       If there is none, then it is in our current directory, \".\".   */\n@@ -1000,6 +1057,12 @@ start_fixer (read_fd, p_fixd, pz_fix_file)\n       p_fixd->patch_args[2] = pz_cmd;\n     }\n \n+  /*  Start a fix process, handing off the  previous read fd for its\n+      stdin and getting a new fd that reads from the fix process' stdout.\n+      We normally will not loop, but we will up to 10 times if we keep\n+      getting \"EAGAIN\" errors.\n+\n+      */\n   for (;;)\n     {\n       static int failCt = 0;\n@@ -1024,6 +1087,8 @@ start_fixer (read_fd, p_fixd, pz_fix_file)\n       sleep (1);\n     }\n \n+  /*  IF we allocated a shell script command,\n+      THEN free it and restore the command format to the fix description */\n   if (pz_cmd != (char*)NULL)\n     {\n       free ((void*)pz_cmd);\n@@ -1044,6 +1109,9 @@ t_bool\n fix_applies (p_fixd)\n   tFixDesc *p_fixd;\n {\n+#ifdef DEBUG\n+  static const char z_failed[] = \"not applying %s to %s - test %d failed\\n\";\n+#endif\n   int test_ct;\n   tTestDesc *p_test;\n \n@@ -1068,8 +1136,14 @@ fix_applies (p_fixd)\n           pz_scan = strstr (pz_scan + 1, pz_fname);\n           /*  IF we can't match the string at all,\n               THEN bail  */\n-          if (pz_scan == (char *) NULL)\n+          if (pz_scan == (char *) NULL) {\n+#ifdef DEBUG\n+            if (VLEVEL( VERB_EVERYTHING ))\n+              fprintf (stderr, \"file %s not in list for %s\\n\",\n+                       pz_fname, p_fixd->fix_name );\n+#endif\n             return BOOL_FALSE;\n+          }\n \n           /*  IF the match is surrounded by the '|' markers,\n               THEN we found a full match -- time to run the tests  */\n@@ -1089,25 +1163,49 @@ fix_applies (p_fixd)\n       switch (p_test->type)\n         {\n         case TT_TEST:\n-          if (test_test (p_test, pz_curr_file) != APPLY_FIX)\n+          if (test_test (p_test, pz_curr_file) != APPLY_FIX) {\n+#ifdef DEBUG\n+            if (VLEVEL( VERB_EVERYTHING ))\n+              fprintf (stderr, z_failed, p_fixd->fix_name, pz_fname,\n+                       p_fixd->test_ct - test_ct);\n+#endif\n             return BOOL_FALSE;\n+          }\n           break;\n \n         case TT_EGREP:\n-          if (egrep_test (pz_curr_data, p_test) != APPLY_FIX)\n+          if (egrep_test (pz_curr_data, p_test) != APPLY_FIX) {\n+#ifdef DEBUG\n+            if (VLEVEL( VERB_EVERYTHING ))\n+              fprintf (stderr, z_failed, p_fixd->fix_name, pz_fname,\n+                       p_fixd->test_ct - test_ct);\n+#endif\n             return BOOL_FALSE;\n+          }\n           break;\n \n         case TT_NEGREP:\n-          if (egrep_test (pz_curr_data, p_test) == APPLY_FIX)\n+          if (egrep_test (pz_curr_data, p_test) == APPLY_FIX) {\n+#ifdef DEBUG\n+            if (VLEVEL( VERB_EVERYTHING ))\n+              fprintf (stderr, z_failed, p_fixd->fix_name, pz_fname,\n+                       p_fixd->test_ct - test_ct);\n+#endif\n             /*  Negated sense  */\n             return BOOL_FALSE;\n+          }\n           break;\n \n         case TT_FUNCTION:\n           if (run_test (p_test->pz_test_text, pz_curr_file, pz_curr_data)\n-              != APPLY_FIX)\n+              != APPLY_FIX) {\n+#ifdef DEBUG\n+            if (VLEVEL( VERB_EVERYTHING ))\n+              fprintf (stderr, z_failed, p_fixd->fix_name, pz_fname,\n+                       p_fixd->test_ct - test_ct);\n+#endif\n             return BOOL_FALSE;\n+          }\n           break;\n         }\n     }\n@@ -1241,7 +1339,8 @@ process ()\n #ifdef DO_STATS\n   process_ct++;\n #endif\n-  fprintf (stderr, \"%6d %-50s   \\r\", data_map_size, pz_curr_file );\n+  if (VLEVEL( VERB_PROGRESS ))\n+    fprintf (stderr, \"%6d %-50s   \\r\", data_map_size, pz_curr_file );\n   if (strstr (pz_curr_data, gnu_lib_mark) != (char *) NULL)\n     {\n       UNLOAD_DATA();\n@@ -1256,8 +1355,9 @@ process ()\n       if (! fix_applies (p_fixd))\n         continue;\n \n-      fprintf (stderr, \"Applying %-24s to %s\\n\",\n-               p_fixd->fix_name, pz_curr_file);\n+      if (VLEVEL( VERB_APPLIES ))\n+        fprintf (stderr, \"Applying %-24s to %s\\n\",\n+                 p_fixd->fix_name, pz_curr_file);\n \n       if (p_fixd->fd_flags & FD_REPLACEMENT)\n         {"}]}