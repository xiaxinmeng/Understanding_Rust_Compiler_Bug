{"sha": "792bb49bb0732500fe4e87fbeae4aee3cb187112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyYmI0OWJiMDczMjUwMGZlNGU4N2ZiZWFlNGFlZTNjYjE4NzExMg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2017-05-14T00:38:40Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2017-05-14T00:38:40Z"}, "message": "replace some manual stacks with auto_vec\n\ngcc/ChangeLog:\n\n2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* cfganal.c (mark_dfs_back_edges): Replace manual stack with\n\tauto_vec.\n\t(post_order_compute): Likewise.\n\t(inverted_post_order_compute): Likewise.\n\t(pre_and_rev_post_order_compute_fn): Likewise.\n\nFrom-SVN: r248020", "tree": {"sha": "cda6811c5478a68d16361bb7597121477265a8ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cda6811c5478a68d16361bb7597121477265a8ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/792bb49bb0732500fe4e87fbeae4aee3cb187112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792bb49bb0732500fe4e87fbeae4aee3cb187112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792bb49bb0732500fe4e87fbeae4aee3cb187112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792bb49bb0732500fe4e87fbeae4aee3cb187112/comments", "author": null, "committer": null, "parents": [{"sha": "a5c9f2b736f0d152289628e2ff14d1888b512244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c9f2b736f0d152289628e2ff14d1888b512244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c9f2b736f0d152289628e2ff14d1888b512244"}], "stats": {"total": 100, "additions": 44, "deletions": 56}, "files": [{"sha": "c0d3cf8b601af4f72b77c2e990b3e349d00e4962", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792bb49bb0732500fe4e87fbeae4aee3cb187112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792bb49bb0732500fe4e87fbeae4aee3cb187112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=792bb49bb0732500fe4e87fbeae4aee3cb187112", "patch": "@@ -1,3 +1,11 @@\n+2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* cfganal.c (mark_dfs_back_edges): Replace manual stack with\n+\tauto_vec.\n+\t(post_order_compute): Likewise.\n+\t(inverted_post_order_compute): Likewise.\n+\t(pre_and_rev_post_order_compute_fn): Likewise.\n+\n 2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* genrecog.c (int_set::int_set): Explicitly construct our"}, {"sha": "1b01564e8c7e401152afbb590de4f1ed90c7c235", "filename": "gcc/cfganal.c", "status": "modified", "additions": 36, "deletions": 56, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792bb49bb0732500fe4e87fbeae4aee3cb187112/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792bb49bb0732500fe4e87fbeae4aee3cb187112/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=792bb49bb0732500fe4e87fbeae4aee3cb187112", "patch": "@@ -61,10 +61,8 @@ static void flow_dfs_compute_reverse_finish (depth_first_search_ds *);\n bool\n mark_dfs_back_edges (void)\n {\n-  edge_iterator *stack;\n   int *pre;\n   int *post;\n-  int sp;\n   int prenum = 1;\n   int postnum = 1;\n   bool found = false;\n@@ -74,8 +72,7 @@ mark_dfs_back_edges (void)\n   post = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n-  sp = 0;\n+  auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (cfun) + 1);\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n   auto_sbitmap visited (last_basic_block_for_fn (cfun));\n@@ -84,16 +81,15 @@ mark_dfs_back_edges (void)\n   bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n+  stack.quick_push (ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs));\n \n-  while (sp)\n+  while (!stack.is_empty ())\n     {\n-      edge_iterator ei;\n       basic_block src;\n       basic_block dest;\n \n       /* Look at the edge on the top of the stack.  */\n-      ei = stack[sp - 1];\n+      edge_iterator ei = stack.last ();\n       src = ei_edge (ei)->src;\n       dest = ei_edge (ei)->dest;\n       ei_edge (ei)->flags &= ~EDGE_DFS_BACK;\n@@ -110,7 +106,7 @@ mark_dfs_back_edges (void)\n \t    {\n \t      /* Since the DEST node has been visited for the first\n \t\t time, check its successors.  */\n-\t      stack[sp++] = ei_start (dest->succs);\n+\t      stack.quick_push (ei_start (dest->succs));\n \t    }\n \t  else\n \t    post[dest->index] = postnum++;\n@@ -128,15 +124,14 @@ mark_dfs_back_edges (void)\n \t    post[src->index] = postnum++;\n \n \t  if (!ei_one_before_end_p (ei))\n-\t    ei_next (&stack[sp - 1]);\n+\t    ei_next (&stack.last ());\n \t  else\n-\t    sp--;\n+\t    stack.pop ();\n \t}\n     }\n \n   free (pre);\n   free (post);\n-  free (stack);\n \n   return found;\n }\n@@ -637,17 +632,14 @@ int\n post_order_compute (int *post_order, bool include_entry_exit,\n \t\t    bool delete_unreachable)\n {\n-  edge_iterator *stack;\n-  int sp;\n   int post_order_num = 0;\n   int count;\n \n   if (include_entry_exit)\n     post_order[post_order_num++] = EXIT_BLOCK;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n-  sp = 0;\n+  auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (cfun) + 1);\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n   auto_sbitmap visited (last_basic_block_for_fn (cfun));\n@@ -656,16 +648,15 @@ post_order_compute (int *post_order, bool include_entry_exit,\n   bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs);\n+  stack.quick_push (ei_start (ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs));\n \n-  while (sp)\n+  while (!stack.is_empty ())\n     {\n-      edge_iterator ei;\n       basic_block src;\n       basic_block dest;\n \n       /* Look at the edge on the top of the stack.  */\n-      ei = stack[sp - 1];\n+      edge_iterator ei = stack.last ();\n       src = ei_edge (ei)->src;\n       dest = ei_edge (ei)->dest;\n \n@@ -679,7 +670,7 @@ post_order_compute (int *post_order, bool include_entry_exit,\n \t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n \t       time, check its successors.  */\n-\t    stack[sp++] = ei_start (dest->succs);\n+\t    stack.quick_push (ei_start (dest->succs));\n \t  else\n \t    post_order[post_order_num++] = dest->index;\n \t}\n@@ -690,9 +681,9 @@ post_order_compute (int *post_order, bool include_entry_exit,\n \t    post_order[post_order_num++] = src->index;\n \n \t  if (!ei_one_before_end_p (ei))\n-\t    ei_next (&stack[sp - 1]);\n+\t    ei_next (&stack.last ());\n \t  else\n-\t    sp--;\n+\t    stack.pop ();\n \t}\n     }\n \n@@ -722,7 +713,6 @@ post_order_compute (int *post_order, bool include_entry_exit,\n       tidy_fallthru_edges ();\n     }\n \n-  free (stack);\n   return post_order_num;\n }\n \n@@ -813,16 +803,13 @@ inverted_post_order_compute (int *post_order,\n \t\t\t     sbitmap *start_points)\n {\n   basic_block bb;\n-  edge_iterator *stack;\n-  int sp;\n   int post_order_num = 0;\n \n   if (flag_checking)\n     verify_no_unreachable_blocks ();\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n-  sp = 0;\n+  auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (cfun) + 1);\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n   auto_sbitmap visited (last_basic_block_for_fn (cfun));\n@@ -836,12 +823,12 @@ inverted_post_order_compute (int *post_order,\n         if (bitmap_bit_p (*start_points, bb->index)\n \t    && EDGE_COUNT (bb->preds) > 0)\n \t  {\n-            stack[sp++] = ei_start (bb->preds);\n+\t    stack.quick_push (ei_start (bb->preds));\n             bitmap_set_bit (visited, bb->index);\n \t  }\n       if (EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds))\n \t{\n-          stack[sp++] = ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n+\t  stack.quick_push (ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds));\n           bitmap_set_bit (visited, EXIT_BLOCK_PTR_FOR_FN (cfun)->index);\n \t}\n     }\n@@ -853,7 +840,7 @@ inverted_post_order_compute (int *post_order,\n         /* Push the initial edge on to the stack.  */\n         if (EDGE_COUNT (bb->preds) > 0)\n           {\n-            stack[sp++] = ei_start (bb->preds);\n+\t    stack.quick_push (ei_start (bb->preds));\n             bitmap_set_bit (visited, bb->index);\n           }\n       }\n@@ -863,13 +850,13 @@ inverted_post_order_compute (int *post_order,\n       bool has_unvisited_bb = false;\n \n       /* The inverted traversal loop. */\n-      while (sp)\n+      while (!stack.is_empty ())\n         {\n           edge_iterator ei;\n           basic_block pred;\n \n           /* Look at the edge on the top of the stack.  */\n-          ei = stack[sp - 1];\n+\t  ei = stack.last ();\n           bb = ei_edge (ei)->dest;\n           pred = ei_edge (ei)->src;\n \n@@ -882,7 +869,7 @@ inverted_post_order_compute (int *post_order,\n               if (EDGE_COUNT (pred->preds) > 0)\n                 /* Since the predecessor node has been visited for the first\n                    time, check its predecessors.  */\n-                stack[sp++] = ei_start (pred->preds);\n+\t\tstack.quick_push (ei_start (pred->preds));\n               else\n                 post_order[post_order_num++] = pred->index;\n             }\n@@ -893,15 +880,15 @@ inverted_post_order_compute (int *post_order,\n                 post_order[post_order_num++] = bb->index;\n \n               if (!ei_one_before_end_p (ei))\n-                ei_next (&stack[sp - 1]);\n+\t\tei_next (&stack.last ());\n               else\n-                sp--;\n+\t\tstack.pop ();\n             }\n         }\n \n       /* Detect any infinite loop and activate the kludge.\n          Note that this doesn't check EXIT_BLOCK itself\n-         since EXIT_BLOCK is always added after the outer do-while loop.  */\n+\t since EXIT_BLOCK is always added after the outer do-while loop.  */\n       FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),\n \t\t      EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)\n         if (!bitmap_bit_p (visited, bb->index))\n@@ -926,31 +913,30 @@ inverted_post_order_compute (int *post_order,\n                     basic_block be = dfs_find_deadend (bb);\n                     gcc_assert (be != NULL);\n                     bitmap_set_bit (visited, be->index);\n-                    stack[sp++] = ei_start (be->preds);\n+\t\t    stack.quick_push (ei_start (be->preds));\n                     break;\n                   }\n               }\n           }\n \n-      if (has_unvisited_bb && sp == 0)\n+      if (has_unvisited_bb && stack.is_empty ())\n         {\n-          /* No blocks are reachable from EXIT at all.\n+\t  /* No blocks are reachable from EXIT at all.\n              Find a dead-end from the ENTRY, and restart the iteration. */\n \t  basic_block be = dfs_find_deadend (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n           gcc_assert (be != NULL);\n           bitmap_set_bit (visited, be->index);\n-          stack[sp++] = ei_start (be->preds);\n+\t  stack.quick_push (ei_start (be->preds));\n         }\n \n       /* The only case the below while fires is\n          when there's an infinite loop.  */\n     }\n-  while (sp);\n+  while (!stack.is_empty ());\n \n   /* EXIT_BLOCK is always included.  */\n   post_order[post_order_num++] = EXIT_BLOCK;\n \n-  free (stack);\n   return post_order_num;\n }\n \n@@ -971,14 +957,11 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n \t\t\t\t   int *pre_order, int *rev_post_order,\n \t\t\t\t   bool include_entry_exit)\n {\n-  edge_iterator *stack;\n-  int sp;\n   int pre_order_num = 0;\n   int rev_post_order_num = n_basic_blocks_for_fn (cfun) - 1;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = XNEWVEC (edge_iterator, n_basic_blocks_for_fn (cfun) + 1);\n-  sp = 0;\n+  auto_vec<edge_iterator, 20> stack (n_basic_blocks_for_fn (cfun) + 1);\n \n   if (include_entry_exit)\n     {\n@@ -998,16 +981,15 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n   bitmap_clear (visited);\n \n   /* Push the first edge on to the stack.  */\n-  stack[sp++] = ei_start (ENTRY_BLOCK_PTR_FOR_FN (fn)->succs);\n+  stack.quick_push (ei_start (ENTRY_BLOCK_PTR_FOR_FN (fn)->succs));\n \n-  while (sp)\n+  while (!stack.is_empty ())\n     {\n-      edge_iterator ei;\n       basic_block src;\n       basic_block dest;\n \n       /* Look at the edge on the top of the stack.  */\n-      ei = stack[sp - 1];\n+      edge_iterator ei = stack.last ();\n       src = ei_edge (ei)->src;\n       dest = ei_edge (ei)->dest;\n \n@@ -1026,7 +1008,7 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n \t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n \t       time, check its successors.  */\n-\t    stack[sp++] = ei_start (dest->succs);\n+\t    stack.quick_push (ei_start (dest->succs));\n \t  else if (rev_post_order)\n \t    /* There are no successors for the DEST node so assign\n \t       its reverse completion number.  */\n@@ -1042,14 +1024,12 @@ pre_and_rev_post_order_compute_fn (struct function *fn,\n \t    rev_post_order[rev_post_order_num--] = src->index;\n \n \t  if (!ei_one_before_end_p (ei))\n-\t    ei_next (&stack[sp - 1]);\n+\t    ei_next (&stack.last ());\n \t  else\n-\t    sp--;\n+\t    stack.pop ();\n \t}\n     }\n \n-  free (stack);\n-\n   if (include_entry_exit)\n     {\n       if (pre_order)"}]}