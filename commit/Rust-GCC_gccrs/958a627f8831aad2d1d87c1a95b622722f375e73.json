{"sha": "958a627f8831aad2d1d87c1a95b622722f375e73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU4YTYyN2Y4ODMxYWFkMmQxZDg3YzFhOTViNjIyNzIyZjM3NWU3Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-10T23:57:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-10T23:57:15Z"}, "message": "re PR lto/61886 (LTO breaks fread with _FORTIFY_SOURCE=2)\n\n\tPR ipa/61886\n\t* lto-symtab.c (lto_symtab_merge_p): Avoid merging across different\n\tvalues of error and warning attributes.\n\t* gcc.dg/lto/pr61886_0.c: New testcase\n\nFrom-SVN: r231548", "tree": {"sha": "81333eac2542fe1d73ebec68b922ed18cd399b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81333eac2542fe1d73ebec68b922ed18cd399b73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/958a627f8831aad2d1d87c1a95b622722f375e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/958a627f8831aad2d1d87c1a95b622722f375e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/958a627f8831aad2d1d87c1a95b622722f375e73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/958a627f8831aad2d1d87c1a95b622722f375e73/comments", "author": null, "committer": null, "parents": [{"sha": "0c91a1fb3c6bf27bd513d6a160bdce14a7070a60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c91a1fb3c6bf27bd513d6a160bdce14a7070a60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c91a1fb3c6bf27bd513d6a160bdce14a7070a60"}], "stats": {"total": 96, "additions": 90, "deletions": 6}, "files": [{"sha": "f0d90fc328b4f299aad5aa00219676a413f6e568", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958a627f8831aad2d1d87c1a95b622722f375e73/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958a627f8831aad2d1d87c1a95b622722f375e73/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=958a627f8831aad2d1d87c1a95b622722f375e73", "patch": "@@ -1,3 +1,9 @@\n+2015-12-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\t* lto-symtab.c (lto_symtab_merge_p): Avoid merging across different\n+\tvalues of error and warning attributes.\n+\n 2015-12-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/68811"}, {"sha": "35c690ae41a117ecb83b5f786b3a3ad01e63eca9", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958a627f8831aad2d1d87c1a95b622722f375e73/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958a627f8831aad2d1d87c1a95b622722f375e73/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=958a627f8831aad2d1d87c1a95b622722f375e73", "patch": "@@ -511,19 +511,59 @@ static bool\n lto_symtab_merge_p (tree prevailing, tree decl)\n {\n   if (TREE_CODE (prevailing) != TREE_CODE (decl))\n-    return false;\n+    {\n+      if (symtab->dump_file)\n+\tfprintf (symtab->dump_file, \"Not merging decls; \"\n+\t\t \"TREE_CODE mismatch\\n\");\n+      return false;\n+    }\n   if (TREE_CODE (prevailing) == FUNCTION_DECL)\n     {\n       if (DECL_BUILT_IN (prevailing) != DECL_BUILT_IN (decl))\n-\treturn false;\n+\t{\n+          if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t\t     \"DECL_BUILT_IN mismatch\\n\");\n+\t  return false;\n+\t}\n       if (DECL_BUILT_IN (prevailing)\n \t  && (DECL_BUILT_IN_CLASS (prevailing) != DECL_BUILT_IN_CLASS (decl)\n \t      || DECL_FUNCTION_CODE (prevailing) != DECL_FUNCTION_CODE (decl)))\n-\treturn false;\n+\t{\n+          if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t\t     \"DECL_BUILT_IN_CLASS or CODE mismatch\\n\");\n+\t  return false;\n+\t}\n+    }\n+  if (DECL_ATTRIBUTES (prevailing) != DECL_ATTRIBUTES (decl))\n+    {\n+      tree prev_attr = lookup_attribute (\"error\", DECL_ATTRIBUTES (prevailing));\n+      tree attr = lookup_attribute (\"error\", DECL_ATTRIBUTES (decl));\n+      if ((prev_attr == NULL) != (attr == NULL)\n+\t  || (prev_attr\n+\t      && TREE_VALUE (TREE_VALUE (prev_attr))\n+\t\t != TREE_VALUE (TREE_VALUE (attr))))\n+\t{\n+          if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t\t     \"error attribute mismatch\\n\");\n+\t  return false;\n+\t}\n+\n+      prev_attr = lookup_attribute (\"warning\", DECL_ATTRIBUTES (prevailing));\n+      attr = lookup_attribute (\"warning\", DECL_ATTRIBUTES (decl));\n+      if ((prev_attr == NULL) != (attr == NULL)\n+\t  || (prev_attr\n+\t      && TREE_VALUE (TREE_VALUE (prev_attr))\n+\t\t != TREE_VALUE (TREE_VALUE (attr))))\n+\t{\n+          if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t\t     \"warning attribute mismatch\\n\");\n+\t  return false;\n+\t}\n     }\n-  /* There are several other cases where merging can not be done, but until\n-     aliasing code is fixed to support aliases it we can not really return\n-     false on non-readonly var, yet.  */\n   return true;\n }\n "}, {"sha": "725704614923f1e489f5d6fdad85ae169a00b2b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958a627f8831aad2d1d87c1a95b622722f375e73/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958a627f8831aad2d1d87c1a95b622722f375e73/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=958a627f8831aad2d1d87c1a95b622722f375e73", "patch": "@@ -1,3 +1,8 @@\n+2015-12-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\t* gcc.dg/lto/pr61886_0.c: New testcase\n+\n 2015-12-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.c-torture/execute/20010122-1.c: Disable cloning."}, {"sha": "c583774acac85e2ca2b108543281ef0ef2ed2951", "filename": "gcc/testsuite/gcc.dg/lto/pr61886_0.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/958a627f8831aad2d1d87c1a95b622722f375e73/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr61886_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/958a627f8831aad2d1d87c1a95b622722f375e73/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr61886_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr61886_0.c?ref=958a627f8831aad2d1d87c1a95b622722f375e73", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-lto-do link } */\n+/* { dg-lto-options { { -flto -O2 -Werror } } } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef struct _IO_FILE FILE;\n+\n+extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ (\"\" \"__fread_chk\")      __attribute__ ((__warn_unused_result__));\n+extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ (\"\" \"__fread_chk\")      __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ (\"fread called with bigger size * nmemb than length \" \"of destination buffer\")));\n+\n+extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__))\n+size_t\n+fread (void *__restrict __ptr, size_t __size, size_t __n,\n+       FILE *__restrict __stream)\n+{\n+  if (__builtin_object_size (__ptr, 0) != (size_t) -1)\n+    {\n+      if (!__builtin_constant_p (__size)\n+          || !__builtin_constant_p (__n)\n+          || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))\n+        return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);\n+      if (__size * __n > __builtin_object_size (__ptr, 0))\n+        return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);\n+    }\n+}\n+\n+volatile size_t nmemb;\n+FILE *fp;\n+int main ()\n+{\n+  char file_contents[4096];\n+  /* We shouldn't get this resolved to a call to __fread_chk_warn.  */\n+  return fread (file_contents, 1, nmemb, fp);\n+}"}]}