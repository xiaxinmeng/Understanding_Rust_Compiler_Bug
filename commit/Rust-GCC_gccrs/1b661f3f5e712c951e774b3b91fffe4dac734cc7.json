{"sha": "1b661f3f5e712c951e774b3b91fffe4dac734cc7", "node_id": "C_kwDOANBUbNoAKDFiNjYxZjNmNWU3MTJjOTUxZTc3NGIzYjkxZmZmZTRkYWM3MzRjYzc", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-04-26T19:52:00Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-05-25T15:00:10Z"}, "message": "c++: ICE with temporary of class type in DMI [PR100252]\n\nConsider\n\n  struct A {\n    int x;\n    int y = x;\n  };\n\n  struct B {\n    int x = 0;\n    int y = A{x}.y; // #1\n  };\n\nwhere for #1 we end up with\n\n  {.x=(&<PLACEHOLDER_EXPR struct B>)->x, .y=(&<PLACEHOLDER_EXPR struct A>)->x}\n\nthat is, two PLACEHOLDER_EXPRs for different types on the same level in\na {}.  This crashes because our CONSTRUCTOR_PLACEHOLDER_BOUNDARY mechanism to\navoid replacing unrelated PLACEHOLDER_EXPRs cannot deal with it.\n\nHere's why we wound up with those PLACEHOLDER_EXPRs: When we're performing\ncp_parser_late_parsing_nsdmi for \"int y = A{x}.y;\" we use finish_compound_literal\non type=A, compound_literal={((struct B *) this)->x}.  When digesting this\ninitializer, we call get_nsdmi which creates a PLACEHOLDER_EXPR for A -- we don't\nhave any object to refer to yet.  After digesting, we have\n\n  {.x=((struct B *) this)->x, .y=(&<PLACEHOLDER_EXPR struct A>)->x}\n\nand since we've created a PLACEHOLDER_EXPR inside it, we marked the whole ctor\nCONSTRUCTOR_PLACEHOLDER_BOUNDARY.  f_c_l creates a TARGET_EXPR and returns\n\n  TARGET_EXPR <D.2384, {.x=((struct B *) this)->x, .y=(&<PLACEHOLDER_EXPR struct A>)->x}>\n\nThen we get to\n\n  B b = {};\n\nand call store_init_value, which digests the {}, which produces\n\n  {.x=NON_LVALUE_EXPR <0>, .y=(TARGET_EXPR <D.2395, {.x=(&<PLACEHOLDER_EXPR struct B>)->x, .y=(&<PLACEHOLDER_EXPR struct A>)->x}>).y}\n\nlookup_placeholder in constexpr won't find an object to replace the\nPLACEHOLDER_EXPR for B, because ctx->object will be D.2395 of type A, and we\ncannot search outward from D.2395 to find 'b'.\n\nThe call to replace_placeholders in store_init_value will not do anything:\nwe've marked the inner { } CONSTRUCTOR_PLACEHOLDER_BOUNDARY, and it's only\na sub-expression, so replace_placeholders does nothing, so the <P_E struct B>\nstays even though now is the perfect time to replace it because we have an\nobject for it: 'b'.\n\nLater, in cp_gimplify_init_expr the *expr_p is\n\n  D.2395 = {.x=(&<PLACEHOLDER_EXPR struct B>)->x, .y=(&<PLACEHOLDER_EXPR struct A>)->x}\n\nwhere D.2395 is of type A, but we crash because we hit <P_E struct B>, which\nhas a different type.\n\nMy idea was to replace <P_E struct A> with D.2384 after creating the\nTARGET_EXPR because that means we have an object we can refer to.\nThen clear CONSTRUCTOR_PLACEHOLDER_BOUNDARY because we no longer have\na PLACEHOLDER_EXPR in the {}.  Then store_init_value will be able to\nreplace <P_E struct B> with 'b', and we should be good to go.  We must\nbe careful not to break guaranteed copy elision, so this replacement\nhappens in digest_nsdmi_init where we can see the whole initializer,\nand avoid replacing any placeholders in TARGET_EXPRs used in the context\nof initialization/copy elision.  This is achieved via the new function\ncalled potential_prvalue_result_of.\n\nWhile fixing this problem, I found PR105550, thus the FIXMEs in the\ntests.\n\n\tPR c++/100252\n\ngcc/cp/ChangeLog:\n\n\t* typeck2.cc (potential_prvalue_result_of): New.\n\t(replace_placeholders_for_class_temp_r): New.\n\t(digest_nsdmi_init): Call it.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1y/nsdmi-aggr14.C: New test.\n\t* g++.dg/cpp1y/nsdmi-aggr15.C: New test.\n\t* g++.dg/cpp1y/nsdmi-aggr16.C: New test.\n\t* g++.dg/cpp1y/nsdmi-aggr17.C: New test.\n\t* g++.dg/cpp1y/nsdmi-aggr18.C: New test.\n\t* g++.dg/cpp1y/nsdmi-aggr19.C: New test.", "tree": {"sha": "f16ce49da86f56df90e8b80135becc8bb1d88f14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f16ce49da86f56df90e8b80135becc8bb1d88f14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b661f3f5e712c951e774b3b91fffe4dac734cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b661f3f5e712c951e774b3b91fffe4dac734cc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b661f3f5e712c951e774b3b91fffe4dac734cc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b661f3f5e712c951e774b3b91fffe4dac734cc7/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75c4e4909ae2667f56487434f99c2915b4570794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c4e4909ae2667f56487434f99c2915b4570794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75c4e4909ae2667f56487434f99c2915b4570794"}], "stats": {"total": 582, "additions": 582, "deletions": 0}, "files": [{"sha": "1a96be3d412b9b52a1941e82e14ff8190e84cfd6", "filename": "gcc/cp/typeck2.cc", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Fcp%2Ftypeck2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Fcp%2Ftypeck2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.cc?ref=1b661f3f5e712c951e774b3b91fffe4dac734cc7", "patch": "@@ -1371,6 +1371,71 @@ digest_init_flags (tree type, tree init, int flags, tsubst_flags_t complain)\n   return digest_init_r (type, init, 0, flags, complain);\n }\n \n+/* Return true if SUBOB initializes the same object as FULL_EXPR.\n+   For instance:\n+\n+     A a = A{};\t\t      // initializer\n+     A a = (A{});\t      // initializer\n+     A a = (1, A{});\t      // initializer\n+     A a = true ? A{} : A{};  // initializer\n+     auto x = A{}.x;\t      // temporary materialization\n+     auto x = foo(A{});\t      // temporary materialization\n+\n+   FULL_EXPR is the whole expression, SUBOB is its TARGET_EXPR subobject.  */\n+\n+static bool\n+potential_prvalue_result_of (tree subob, tree full_expr)\n+{\n+  if (subob == full_expr)\n+    return true;\n+  else if (TREE_CODE (full_expr) == TARGET_EXPR)\n+    {\n+      tree init = TARGET_EXPR_INITIAL (full_expr);\n+      if (TREE_CODE (init) == COND_EXPR)\n+\treturn (potential_prvalue_result_of (subob, TREE_OPERAND (init, 1))\n+\t\t|| potential_prvalue_result_of (subob, TREE_OPERAND (init, 2)));\n+      else if (TREE_CODE (init) == COMPOUND_EXPR)\n+\treturn potential_prvalue_result_of (subob, TREE_OPERAND (init, 1));\n+      /* ??? I don't know if this can be hit.  */\n+      else if (TREE_CODE (init) == PAREN_EXPR)\n+\t{\n+\t  gcc_checking_assert (false);\n+\t  return potential_prvalue_result_of (subob, TREE_OPERAND (init, 0));\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Callback to replace PLACEHOLDER_EXPRs in a TARGET_EXPR (which isn't used\n+   in the context of guaranteed copy elision).  */\n+\n+static tree\n+replace_placeholders_for_class_temp_r (tree *tp, int *, void *data)\n+{\n+  tree t = *tp;\n+  tree full_expr = *static_cast<tree *>(data);\n+\n+  /* We're looking for a TARGET_EXPR nested in the whole expression.  */\n+  if (TREE_CODE (t) == TARGET_EXPR\n+      && !potential_prvalue_result_of (t, full_expr))\n+    {\n+      tree init = TARGET_EXPR_INITIAL (t);\n+      while (TREE_CODE (init) == COMPOUND_EXPR)\n+\tinit = TREE_OPERAND (init, 1);\n+      if (TREE_CODE (init) == CONSTRUCTOR\n+\t  && CONSTRUCTOR_PLACEHOLDER_BOUNDARY (init))\n+\t{\n+\t  tree obj = TARGET_EXPR_SLOT (t);\n+\t  replace_placeholders (init, obj);\n+\t  /* We should have dealt with all PLACEHOLDER_EXPRs.  */\n+\t  CONSTRUCTOR_PLACEHOLDER_BOUNDARY (init) = false;\n+\t  gcc_checking_assert (!find_placeholders (init));\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Process the initializer INIT for an NSDMI DECL (a FIELD_DECL).  */\n tree\n digest_nsdmi_init (tree decl, tree init, tsubst_flags_t complain)\n@@ -1390,6 +1455,32 @@ digest_nsdmi_init (tree decl, tree init, tsubst_flags_t complain)\n       && CP_AGGREGATE_TYPE_P (type))\n     init = reshape_init (type, init, complain);\n   init = digest_init_flags (type, init, flags, complain);\n+\n+  /* We may have temporary materialization in a NSDMI, if the initializer\n+     has something like A{} in it.  Digesting the {} could have introduced\n+     a PLACEHOLDER_EXPR referring to A.  Now that we've got a TARGET_EXPR,\n+     we have an object we can refer to.  The reason we bother doing this\n+     here is for code like\n+\n+       struct A {\n+\t int x;\n+\t int y = x;\n+       };\n+\n+       struct B {\n+\t int x = 0;\n+\t int y = A{x}.y; // #1\n+       };\n+\n+     where in #1 we don't want to end up with two PLACEHOLDER_EXPRs for\n+     different types on the same level in a {} when lookup_placeholder\n+     wouldn't find a named object for the PLACEHOLDER_EXPR for A.  Note,\n+     temporary materialization does not occur when initializing an object\n+     from a prvalue of the same type, therefore we must not replace the\n+     placeholder with a temporary object so that it can be elided.  */\n+  cp_walk_tree (&init, replace_placeholders_for_class_temp_r, &init,\n+\t\tnullptr);\n+\n   return init;\n }\n \f"}, {"sha": "28b908a0a1a92bfb3822475bc46cea7174acd9e8", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr14.C", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr14.C?ref=1b661f3f5e712c951e774b3b91fffe4dac734cc7", "patch": "@@ -0,0 +1,131 @@\n+// PR c++/100252\n+// { dg-do run { target c++14 } }\n+\n+#define SA(X) static_assert ((X),#X)\n+\n+struct A {\n+  int x;\n+  int y = x;\n+};\n+\n+struct B {\n+  int x = 0;\n+  int y = A{x}.y;\n+};\n+\n+constexpr B csb1 = { };\n+SA(csb1.x == 0 && csb1.y == csb1.x);\n+constexpr B csb2 = { 1 };\n+SA(csb2.x == 1 && csb2.y == csb2.x);\n+constexpr B csb3 = { 1, 2 };\n+SA(csb3.x == 1 && csb3.y == 2);\n+\n+B sb1 = { };\n+B sb2 = { 1 };\n+B sb3 = { 1, 2};\n+\n+struct C {\n+  int x = 0;\n+  int y = (true, A{x}.y) + (A{x}.y, 0);\n+};\n+\n+constexpr C csc1 = { };\n+SA(csc1.x == 0 && csc1.y == csc1.x);\n+constexpr C csc2 = { 1 };\n+SA(csc2.x == 1 && csc2.y == csc2.x);\n+constexpr C csc3 = { 1, 2 };\n+SA(csc3.x == 1 && csc3.y == 2);\n+\n+C sc1 = { };\n+C sc2 = { 1 };\n+C sc3 = { 1, 2};\n+\n+struct D {\n+  int x = 0;\n+  int y = (A{x}.y);\n+};\n+\n+constexpr D csd1 = { };\n+SA(csd1.x == 0 && csd1.y == csd1.x);\n+constexpr D csd2 = { 1 };\n+SA(csd2.x == 1 && csd2.y == csd2.x);\n+constexpr D csd3 = { 1, 2 };\n+SA(csd3.x == 1 && csd3.y == 2);\n+\n+D sd1 = { };\n+D sd2 = { 1 };\n+D sd3 = { 1, 2};\n+\n+struct E {\n+  int x = 0;\n+  int y = x ? A{x}.y : A{x}.y;\n+};\n+\n+constexpr E cse1 = { };\n+SA(cse1.x == 0 && cse1.y == cse1.x);\n+constexpr E cse2 = { 1 };\n+SA(cse2.x == 1 && cse2.y == cse2.x);\n+constexpr E cse3 = { 1, 2 };\n+SA(cse3.x == 1 && cse3.y == 2);\n+\n+E se1 = { };\n+E se2 = { 1 };\n+E se3 = { 1, 2};\n+\n+int\n+main ()\n+{\n+  if (sb1.x != 0 || sb1.x != sb1.y)\n+    __builtin_abort();\n+  if (sb2.x != 1 || sb2.x != sb2.y)\n+    __builtin_abort();\n+  if (sb3.x != 1 || sb3.y != 2)\n+    __builtin_abort();\n+\n+  if (sc1.x != 0 || sc1.x != sc1.y)\n+    __builtin_abort();\n+  if (sc2.x != 1 || sc2.x != sc2.y)\n+    __builtin_abort();\n+  if (sc3.x != 1 || sc3.y != 2)\n+    __builtin_abort();\n+\n+  B b1 = { };\n+  B b2 = { 1 };\n+  B b3 = { 1, 2};\n+  if (b1.x != 0 || b1.x != b1.y)\n+    __builtin_abort();\n+  if (b2.x != 1 || b2.x != b2.y)\n+    __builtin_abort();\n+  if (b3.x != 1 || b3.y != 2)\n+    __builtin_abort();\n+\n+  C c1 = { };\n+  C c2 = { 1 };\n+  C c3 = { 1, 2};\n+  if (c1.x != 0 || c1.x != c1.y)\n+    __builtin_abort();\n+  if (c2.x != 1 || c2.x != c2.y)\n+    __builtin_abort();\n+  if (c3.x != 1 || c3.y != 2)\n+    __builtin_abort();\n+\n+  D d1 = { };\n+  D d2 = { 1 };\n+  D d3 = { 1, 2};\n+  if (d1.x != 0 || d1.x != d1.y)\n+    __builtin_abort();\n+  if (d2.x != 1 || d2.x != d2.y)\n+    __builtin_abort();\n+  if (d3.x != 1 || d3.y != 2)\n+    __builtin_abort();\n+\n+  E e1 = { };\n+  E e2 = { 1 };\n+  E e3 = { 1, 2};\n+  if (e1.x != 0 || e1.x != e1.y)\n+    __builtin_abort();\n+  if (e2.x != 1 || e2.x != e2.y)\n+    __builtin_abort();\n+  if (e3.x != 1 || e3.y != 2)\n+    __builtin_abort();\n+}"}, {"sha": "d091d693042b5aafc67a38002f84c170cd0303c1", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr15.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr15.C?ref=1b661f3f5e712c951e774b3b91fffe4dac734cc7", "patch": "@@ -0,0 +1,80 @@\n+// PR c++/100252\n+// { dg-do run { target c++14 } }\n+\n+struct A {\n+  int x;\n+  int y = x;\n+};\n+\n+struct B {\n+  int x = 0;\n+  int y = A{x}.y;\n+};\n+\n+static void\n+test_b (B b1 = B{}, B b2 = B{1}, B b3 = B{1, 2})\n+{\n+  if (b1.x != 0 || b1.y != b1.x)\n+    __builtin_abort();\n+  if (b2.x != 1 || b2.y != b2.x)\n+    __builtin_abort();\n+  if (b3.x != 1 || b3.y != 2)\n+    __builtin_abort();\n+}\n+\n+struct C {\n+  int x = 0;\n+  int y = (true, A{x}.y) + (A{x}.y, 0);\n+};\n+\n+static void\n+test_c (C c1 = C{}, C c2 = C{1}, C c3 = C{1, 2})\n+{\n+  if (c1.x != 0 || c1.y != c1.x)\n+    __builtin_abort();\n+  if (c2.x != 1 || c2.y != c2.x)\n+    __builtin_abort();\n+  if (c3.x != 1 || c3.y != 2)\n+    __builtin_abort();\n+}\n+\n+struct D {\n+  int x = 0;\n+  int y = (A{x}.y);\n+};\n+\n+static void\n+test_d (D d1 = D{}, D d2 = D{1}, D d3 = D{1, 2})\n+{\n+  if (d1.x != 0 || d1.y != d1.x)\n+    __builtin_abort();\n+  if (d2.x != 1 || d2.y != d2.x)\n+    __builtin_abort();\n+  if (d3.x != 1 || d3.y != 2)\n+    __builtin_abort();\n+}\n+\n+struct E {\n+  int x = 0;\n+  int y = x ? A{x}.y : A{x}.y;\n+};\n+\n+static void\n+test_e (E e1 = E{}, E e2 = E{1}, E e3 = E{1, 2})\n+{\n+  if (e1.x != 0 || e1.y != e1.x)\n+    __builtin_abort();\n+  if (e2.x != 1 || e2.y != e2.x)\n+    __builtin_abort();\n+  if (e3.x != 1 || e3.y != 2)\n+    __builtin_abort();\n+}\n+\n+int\n+main ()\n+{\n+  test_b ();\n+  test_c ();\n+  test_d ();\n+  test_e ();\n+}"}, {"sha": "dc6492c1b0b2fb37322ba66188829d1188331811", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr16.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr16.C?ref=1b661f3f5e712c951e774b3b91fffe4dac734cc7", "patch": "@@ -0,0 +1,58 @@\n+// PR c++/100252\n+// { dg-do compile { target c++14 } }\n+\n+#define SA(X) static_assert ((X),#X)\n+\n+struct A {\n+  const A* p = this;\n+};\n+\n+struct B {\n+  A a = A{};\n+};\n+\n+constexpr B b;\n+SA(b.a.p == &b.a);\n+B b1 = { };\n+\n+struct C {\n+  A a = (true, A{});\n+};\n+\n+constexpr C c;\n+SA(c.a.p == &c.a);\n+C c1 = { };\n+\n+struct D {\n+  A a = (A{});\n+};\n+\n+constexpr D d;\n+SA(d.a.p == &d.a);\n+D d1 = { };\n+\n+static constexpr A global_a;\n+\n+struct E {\n+  A a = true ? A{} : A{};\n+  A b = true ? global_a : (false ? A{} : A{});\n+  A c = true ? (false ? A{} : A{}) : global_a;\n+  A d = true ? (false ? A{} : A{}) : (false ? A{} : A{});\n+};\n+\n+// FIXME: When fixing this, also fix nsdmi-aggr17.C.\n+constexpr E e;\t    // { dg-bogus \"\" \"PR105550\" { xfail *-*-* } }\n+SA (e.a.p == &e.a); // { dg-bogus \"\" \"PR105550\" { xfail *-*-* } }\n+\n+E e1 = { };\n+\n+struct F {\n+  bool b = (A{}, true);\n+};\n+\n+constexpr F f;\n+\n+void\n+g (B b2 = B{}, C c2 = C{}, D d2 = D{}, E e2 = E{})\n+{\n+}"}, {"sha": "fc27a2cdac7bbaa53ed83ea9754510879c1016cf", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr17.C", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr17.C?ref=1b661f3f5e712c951e774b3b91fffe4dac734cc7", "patch": "@@ -0,0 +1,138 @@\n+// PR c++/100252\n+// { dg-do run { target c++14 } }\n+\n+#define SA(X) static_assert ((X),#X)\n+\n+struct A {\n+  int x;\n+  int y = x;\n+  const A* p = this;\n+};\n+\n+struct B {\n+  int x = 42;\n+  A a = A{x};\n+};\n+\n+constexpr B b;\n+SA(b.a.p == &b.a);\n+SA(b.x == 42);\n+B b2 = { };\n+B b3 = { 42 };\n+\n+struct C {\n+  int x = 42;\n+  B b = B{x};\n+};\n+\n+constexpr C c;\n+C c2;\n+C c3;\n+\n+struct D {\n+  int x = 42;\n+  A a = (true, A{x});\n+};\n+\n+constexpr D d;\n+SA(d.a.p == &d.a);\n+SA(d.x == 42);\n+D d2 = { };\n+D d3 = { 42 };\n+\n+struct E {\n+  int x = 42;\n+  A a = (A{x});\n+};\n+\n+constexpr E e;\n+SA(e.a.p == &e.a);\n+SA(e.x == 42);\n+E e2 = { };\n+E e3 = { 42 };\n+\n+struct F {\n+  int x = 42;\n+  A a = true ? A{x} : A{x};\n+};\n+\n+// FIXME: Doesn't work due to PR105550.\n+//constexpr F f;\n+//SA (f.a.p == &f.a);\n+SA (e.x == 42);\n+F f2 = { };\n+F f3 = { 42 };\n+\n+static void\n+test_b (B b4 = B{}, B b5 = B{ 42 })\n+{\n+  if (b2.x != 42 || b2.a.x != 42 || b2.a.y != b2.a.x)\n+    __builtin_abort ();\n+  if (b3.x != 42 || b3.a.x != 42 || b3.a.y != b3.a.x)\n+    __builtin_abort ();\n+  if (b4.x != 42 || b4.a.x != 42 || b4.a.y != b4.a.x)\n+    __builtin_abort ();\n+  if (b5.x != 42 || b5.a.x != 42 || b5.a.y != b5.a.x)\n+    __builtin_abort ();\n+}\n+\n+static void\n+test_c (C c4 = C{}, C c5 = C{ 42 })\n+{\n+  if (c2.b.x != 42 || c2.b.a.x != 42 || c2.b.a.y != c2.b.a.x)\n+    __builtin_abort ();\n+  if (c3.b.x != 42 || c3.b.a.x != 42 || c3.b.a.y != c3.b.a.x)\n+    __builtin_abort ();\n+  if (c4.b.x != 42 || c4.b.a.x != 42 || c4.b.a.y != c4.b.a.x)\n+    __builtin_abort ();\n+  if (c5.b.x != 42 || c5.b.a.x != 42 || c5.b.a.y != c5.b.a.x)\n+    __builtin_abort ();\n+}\n+\n+static void\n+test_d (D d4 = D{}, D d5 = D{ 42 })\n+{\n+  if (d2.x != 42 || d2.a.x != 42 || d2.a.y != d2.a.x)\n+    __builtin_abort ();\n+  if (d3.x != 42 || d3.a.x != 42 || d3.a.y != d3.a.x)\n+    __builtin_abort ();\n+  if (d4.x != 42 || d4.a.x != 42 || d4.a.y != d4.a.x)\n+    __builtin_abort ();\n+  if (d5.x != 42 || d5.a.x != 42 || d5.a.y != d5.a.x)\n+    __builtin_abort ();\n+}\n+\n+static void\n+test_e (E e4 = E{}, E e5 = E{ 42 })\n+{\n+  if (e2.x != 42 || e2.a.x != 42 || e2.a.y != e2.a.x)\n+    __builtin_abort ();\n+  if (e3.x != 42 || e3.a.x != 42 || e3.a.y != e3.a.x)\n+    __builtin_abort ();\n+  if (e4.x != 42 || e4.a.x != 42 || e4.a.y != e4.a.x)\n+    __builtin_abort ();\n+  if (e5.x != 42 || e5.a.x != 42 || e5.a.y != e5.a.x)\n+    __builtin_abort ();\n+}\n+\n+static void\n+test_f (F f4 = F{}, F f5 = F{ 42 })\n+{\n+  if (f2.x != 42 || f2.a.x != 42 || f2.a.y != f2.a.x)\n+    __builtin_abort ();\n+  if (f3.x != 42 || f3.a.x != 42 || f3.a.y != f3.a.x)\n+    __builtin_abort ();\n+  if (f4.x != 42 || f4.a.x != 42 || f4.a.y != f4.a.x)\n+    __builtin_abort ();\n+  if (f5.x != 42 || f5.a.x != 42 || f5.a.y != f5.a.x)\n+    __builtin_abort ();\n+}\n+int\n+main ()\n+{\n+  test_b ();\n+  test_c ();\n+  test_d ();\n+  test_e ();\n+  test_f ();\n+}"}, {"sha": "567b8ee96d9d46a6133ffb598c253dc3b4c69ea4", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr18.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr18.C?ref=1b661f3f5e712c951e774b3b91fffe4dac734cc7", "patch": "@@ -0,0 +1,56 @@\n+// PR c++/100252\n+// { dg-do compile { target c++14 } }\n+\n+struct B { };\n+\n+struct A {\n+  int x;\n+  int y = x;\n+  constexpr operator B() { return B{}; }\n+};\n+\n+struct C {\n+  int x = 42;\n+  B b = A{x};\n+};\n+\n+C c1 = {};\n+C c2 = { 42 };\n+constexpr C c3 = {};\n+constexpr C c4 = { 42 };\n+\n+struct D {\n+  int x = 42;\n+  B b = (true, A{x});\n+};\n+\n+D d1 = {};\n+D d2 = { 42 };\n+constexpr D d3 = {};\n+constexpr D d4 = { 42 };\n+\n+struct E {\n+  int x = 42;\n+  B b = (A{x});\n+};\n+\n+E e1 = {};\n+E e2 = { 42 };\n+constexpr E e3 = {};\n+constexpr E e4 = { 42 };\n+\n+struct F {\n+  int x = 42;\n+  B b = (A{x});\n+};\n+\n+F f1 = {};\n+F f2 = { 42 };\n+constexpr F f3 = {};\n+constexpr F f4 = { 42 };\n+\n+void\n+g (C c5 = C{}, C c6 = C{ 42 }, D d5 = D{}, D d6 = D{ 42 },\n+   E e5 = E{}, E e6 = E{ 42 }, F f5 = F{}, F f6 = F{ 42 })\n+{\n+}"}, {"sha": "f4892e3379bc2054fec9389a444f296b9b560f6c", "filename": "gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr19.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b661f3f5e712c951e774b3b91fffe4dac734cc7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fnsdmi-aggr19.C?ref=1b661f3f5e712c951e774b3b91fffe4dac734cc7", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/100252\n+// { dg-do compile { target c++14 } }\n+\n+#define SA(X) static_assert ((X),#X)\n+\n+struct A {\n+  const A* p = this;\n+};\n+\n+struct B {\n+  A a = (A{}, A{});\n+};\n+\n+constexpr B b;\n+SA(b.a.p == &b.a);\n+\n+struct C { \n+  int x;\n+  int y = x;\n+};\n+\n+struct D { \n+  int x = 0;\n+  int y = (C{x}.y, C{x}.y);\n+};\n+\n+constexpr D d = { };\n+D d2 = {};"}]}