{"sha": "82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJkM2IwM2EzYmFmNDY4MWYzZDQxMzlmYmMzN2M3ZTZjYzkyODQ3Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-11-09T09:50:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-11-09T09:50:02Z"}, "message": "ada-tree.def (PLUS_NOMOD_EXPR): New tree code.\n\n\t* gcc-interface/ada-tree.def (PLUS_NOMOD_EXPR): New tree code.\n\t(MINUS_NOMOD_EXPR): Likewise.\n\t* gcc-interface/utils2.c (build_binary_op) <PREINCREMENT_EXPR>: Make\n\tunreachable.\n\t<PLUS_NOMOD_EXPR>: New case.\n\t<MINUS_NOMOD_EXPR>: Likewise.\n\t* gcc-interface/trans.c (Loop_Statement_to_gnu): Build increment-and-\n\tassignment statement instead of using an increment operator.\n\nFrom-SVN: r141714", "tree": {"sha": "702b82345e4f0709fa08788c1592629bc7f831e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/702b82345e4f0709fa08788c1592629bc7f831e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/comments", "author": null, "committer": null, "parents": [{"sha": "52013b9baae8e58e75461d3ded8f806a4734c82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52013b9baae8e58e75461d3ded8f806a4734c82f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52013b9baae8e58e75461d3ded8f806a4734c82f"}], "stats": {"total": 111, "additions": 84, "deletions": 27}, "files": [{"sha": "5c604ee1d8a6bfdcc6431626042594984f8f9cde", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "patch": "@@ -1,3 +1,14 @@\n+2008-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.def (PLUS_NOMOD_EXPR): New tree code.\n+\t(MINUS_NOMOD_EXPR): Likewise.\n+\t* gcc-interface/utils2.c (build_binary_op) <PREINCREMENT_EXPR>: Make\n+\tunreachable.\n+\t<PLUS_NOMOD_EXPR>: New case.\n+\t<MINUS_NOMOD_EXPR>: Likewise.\n+\t* gcc-interface/trans.c (Loop_Statement_to_gnu): Build increment-and-\n+\tassignment statement instead of using an increment operator.\n+\n 2008-11-07  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* system-irix-n64.ads: New file."}, {"sha": "c046229090f088baefaae63b59432528d065bb91", "filename": "gcc/ada/gcc-interface/ada-tree.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.def?ref=82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "patch": "@@ -41,6 +41,14 @@ DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\",\n    is an expression to be evaluated for side effects only.  */\n DEFTREECODE (NULL_EXPR, \"null_expr\", tcc_expression, 1)\n \n+/* Same as PLUS_EXPR, except that no modulo reduction is applied.\n+   This is used for loops and never shows up in the tree.  */\n+DEFTREECODE (PLUS_NOMOD_EXPR, \"plus_nomod_expr\", tcc_binary, 2)\n+\n+/* Same as MINUS_EXPR, except that no modulo reduction is applied.\n+   This is used for loops and never shows up in the tree.  */\n+DEFTREECODE (MINUS_NOMOD_EXPR, \"minus_nomod_expr\", tcc_binary, 2)\n+\n /* Same as ADDR_EXPR, except that if the operand represents a bit field,\n    return the address of the byte containing the bit.  This is used\n    for the 'Address attribute and never shows up in the tree.  */"}, {"sha": "8ededaa49b2cbecbcfc781f54d57e7eb7c2496e9", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "patch": "@@ -1714,13 +1714,28 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       tree gnu_type = get_unpadded_type (gnat_type);\n       tree gnu_low = TYPE_MIN_VALUE (gnu_type);\n       tree gnu_high = TYPE_MAX_VALUE (gnu_type);\n-      bool reversep = Reverse_Present (gnat_loop_spec);\n-      tree gnu_first = reversep ? gnu_high : gnu_low;\n-      tree gnu_last = reversep ? gnu_low : gnu_high;\n-      enum tree_code end_code = reversep ? GE_EXPR : LE_EXPR;\n+      tree gnu_first, gnu_last, gnu_limit;\n+      enum tree_code update_code, end_code;\n       tree gnu_base_type = get_base_type (gnu_type);\n-      tree gnu_limit = (reversep ? TYPE_MIN_VALUE (gnu_base_type)\n-\t\t\t: TYPE_MAX_VALUE (gnu_base_type));\n+\n+      /* We must disable modulo reduction for the loop variable, if any,\n+\t in order for the loop comparison to be effective.  */\n+      if (Reverse_Present (gnat_loop_spec))\n+\t{\n+\t  gnu_first = gnu_high;\n+\t  gnu_last = gnu_low;\n+\t  update_code = MINUS_NOMOD_EXPR;\n+\t  end_code = GE_EXPR;\n+\t  gnu_limit = TYPE_MIN_VALUE (gnu_base_type);\n+\t}\n+      else\n+\t{\n+\t  gnu_first = gnu_low;\n+\t  gnu_last = gnu_high;\n+\t  update_code = PLUS_NOMOD_EXPR;\n+\t  end_code = LE_EXPR;\n+\t  gnu_limit = TYPE_MAX_VALUE (gnu_base_type);\n+\t}\n \n       /* We know the loop variable will not overflow if GNU_LAST is a constant\n \t and is not equal to GNU_LIMIT.  If it might overflow, we have to move\n@@ -1764,12 +1779,13 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t\t\t     gnu_loop_var, gnu_last);\n \n       LOOP_STMT_UPDATE (gnu_loop_stmt)\n-\t= build_binary_op (reversep ? PREDECREMENT_EXPR\n-\t\t\t   : PREINCREMENT_EXPR,\n-\t\t\t   TREE_TYPE (gnu_loop_var),\n+\t= build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t   gnu_loop_var,\n-\t\t\t   convert (TREE_TYPE (gnu_loop_var),\n-\t\t\t\t    integer_one_node));\n+\t\t\t   build_binary_op (update_code,\n+\t\t\t\t\t    TREE_TYPE (gnu_loop_var),\n+\t\t\t\t\t    gnu_loop_var,\n+\t\t\t\t\t    convert (TREE_TYPE (gnu_loop_var),\n+\t\t\t\t\t\t     integer_one_node)));\n       set_expr_location_from_node (LOOP_STMT_UPDATE (gnu_loop_stmt),\n \t\t\t\t   gnat_iter_scheme);\n     }"}, {"sha": "77a0389674d4789066f452b39f1388ac72aa0d66", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "patch": "@@ -943,21 +943,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n     case PREDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      /* In these, the result type and the left operand type should be the\n-\t same.  Do the operation in the base type of those and convert the\n-\t right operand (which is an integer) to that type.\n-\n-\t Note that these operations are only used in loop control where\n-\t we guarantee that no overflow can occur.  So nothing special need\n-\t be done for modular types.  */\n-\n-      gcc_assert (left_type == result_type);\n-      operation_type = get_base_type (result_type);\n-      left_operand = convert (operation_type, left_operand);\n-      right_operand = convert (operation_type, right_operand);\n-      has_side_effects = true;\n-      modulus = NULL_TREE;\n-      break;\n+      /* These operations are not used anymore.  */\n+      gcc_unreachable ();\n \n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n@@ -1011,14 +998,25 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       right_operand = convert (sizetype, right_operand);\n       break;\n \n+    case PLUS_NOMOD_EXPR:\n+    case MINUS_NOMOD_EXPR:\n+      if (op_code == PLUS_NOMOD_EXPR)\n+\top_code = PLUS_EXPR;\n+      else\n+\top_code = MINUS_EXPR;\n+      modulus = NULL_TREE;\n+\n+      /* ... fall through ... */\n+\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       /* Avoid doing arithmetics in BOOLEAN_TYPE like the other compilers.\n \t Contrary to C, Ada doesn't allow arithmetics in Standard.Boolean\n \t but we can generate addition or subtraction for 'Succ and 'Pred.  */\n       if (operation_type && TREE_CODE (operation_type) == BOOLEAN_TYPE)\n \toperation_type = left_base_type = right_base_type = integer_type_node;\n-      goto common;\n+\n+      /* ... fall through ... */\n \n     default:\n     common:"}, {"sha": "581dca746f7d05d8d13c36699e6f318495bff6b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "patch": "@@ -1,3 +1,7 @@\n+2008-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/loop_boolean.adb: New test.\n+\n 2008-11-07  Thomas Quinot  <quinot@adacore.com>\n \n \t* gnat.dg/hyper_flat.adb: New test."}, {"sha": "f2836c393431fae46532f1781931e6abc8c129a2", "filename": "gcc/testsuite/gnat.dg/loop_boolean.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Ftestsuite%2Fgnat.dg%2Floop_boolean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82d3b03a3baf4681f3d4139fbc37c7e6cc92847f/gcc%2Ftestsuite%2Fgnat.dg%2Floop_boolean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Floop_boolean.adb?ref=82d3b03a3baf4681f3d4139fbc37c7e6cc92847f", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatVaM\" }\n+\n+procedure Loop_Boolean is\n+\n+  type R is record\n+    B : Boolean;\n+  end record;\n+\n+  procedure proc (X : R) is\n+    B : Boolean;\n+  begin\n+    B := X.B;\n+  end;\n+\n+begin\n+  for I in reverse Boolean loop\n+    Proc ((B => I));\n+  end loop;\n+end;"}]}