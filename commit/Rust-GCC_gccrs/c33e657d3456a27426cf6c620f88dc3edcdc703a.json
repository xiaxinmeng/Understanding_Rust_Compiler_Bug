{"sha": "c33e657d3456a27426cf6c620f88dc3edcdc703a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMzZTY1N2QzNDU2YTI3NDI2Y2Y2YzYyMGY4OGRjM2VkY2RjNzAzYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-04-05T23:52:41Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-04-05T23:52:41Z"}, "message": "tree-flow.h (number_of_iterations_cond): Declaration removed.\n\n\t* tree-flow.h (number_of_iterations_cond): Declaration removed.\n\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Made static.\n\t(number_of_iterations_special): New function.\n\t(number_of_iterations_exit): Use number_of_iterations_special.\n\tUse simplify_using_outer_evolutions only at -O3.\n\t(number_of_iterations_cond, tree_simplify_using_condition,\n\tsimplify_using_initial_conditions, loop_niter_by_eval,\n\tcompare_trees, can_count_iv_in_wider_type_bound,\n\tsimplify_using_outer_evolutions): Use fold_build.\n\nFrom-SVN: r97673", "tree": {"sha": "0b97488c76144ca22cf32522255f9e97faa6da02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b97488c76144ca22cf32522255f9e97faa6da02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c33e657d3456a27426cf6c620f88dc3edcdc703a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c33e657d3456a27426cf6c620f88dc3edcdc703a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c33e657d3456a27426cf6c620f88dc3edcdc703a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c33e657d3456a27426cf6c620f88dc3edcdc703a/comments", "author": null, "committer": null, "parents": [{"sha": "c33b7bf04a0abea0ca5ed8ca1cbdf0a9127a64db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c33b7bf04a0abea0ca5ed8ca1cbdf0a9127a64db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c33b7bf04a0abea0ca5ed8ca1cbdf0a9127a64db"}], "stats": {"total": 395, "additions": 270, "deletions": 125}, "files": [{"sha": "4c7b2aee115bb10100b6721bb8e04cea1a494e54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33e657d3456a27426cf6c620f88dc3edcdc703a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33e657d3456a27426cf6c620f88dc3edcdc703a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c33e657d3456a27426cf6c620f88dc3edcdc703a", "patch": "@@ -1,3 +1,15 @@\n+2005-04-06  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-flow.h (number_of_iterations_cond): Declaration removed.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Made static.\n+\t(number_of_iterations_special): New function.\n+\t(number_of_iterations_exit): Use number_of_iterations_special.\n+\tUse simplify_using_outer_evolutions only at -O3.\n+\t(number_of_iterations_cond, tree_simplify_using_condition,\n+\tsimplify_using_initial_conditions, loop_niter_by_eval,\n+\tcompare_trees, can_count_iv_in_wider_type_bound,\n+\tsimplify_using_outer_evolutions): Use fold_build.\n+\n 2005-04-05  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* doc/install.texi (Configuration): Document --with-java-home."}, {"sha": "b06a802be21f8f86c97f4a279c452e05677a92e4", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33e657d3456a27426cf6c620f88dc3edcdc703a/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33e657d3456a27426cf6c620f88dc3edcdc703a/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c33e657d3456a27426cf6c620f88dc3edcdc703a", "patch": "@@ -673,8 +673,6 @@ void canonicalize_induction_variables (struct loops *);\n void tree_unroll_loops_completely (struct loops *);\n void tree_ssa_iv_optimize (struct loops *);\n \n-void number_of_iterations_cond (tree, tree, tree, enum tree_code, tree, tree,\n-\t\t\t\tstruct tree_niter_desc *);\n bool number_of_iterations_exit (struct loop *, edge,\n \t\t\t\tstruct tree_niter_desc *niter);\n tree find_loop_niter (struct loop *, edge *);"}, {"sha": "35d446cd363a8ca25e6e6ceb2eeedd8df0023d04", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 258, "deletions": 123, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33e657d3456a27426cf6c620f88dc3edcdc703a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33e657d3456a27426cf6c620f88dc3edcdc703a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=c33e657d3456a27426cf6c620f88dc3edcdc703a", "patch": "@@ -137,7 +137,7 @@ inverse (tree x, tree mask)\n    In case we are unable to determine number of iterations, contents of\n    this structure is unchanged.  */\n \n-void\n+static void\n number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t\t   enum tree_code code, tree base1, tree step1,\n \t\t\t   struct tree_niter_desc *niter)\n@@ -221,24 +221,24 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       if (zero_p (step0))\n \t{\n \t  if (mmax)\n-\t    assumption = fold (build2 (EQ_EXPR, boolean_type_node, base0, mmax));\n+\t    assumption = fold_build2 (EQ_EXPR, boolean_type_node, base0, mmax);\n \t  else\n \t    assumption = boolean_false_node;\n \t  if (nonzero_p (assumption))\n \t    goto zero_iter;\n-\t  base0 = fold (build2 (PLUS_EXPR, type, base0,\n-\t\t\t\tbuild_int_cst_type (type, 1)));\n+\t  base0 = fold_build2 (PLUS_EXPR, type, base0,\n+\t\t\t       build_int_cst_type (type, 1));\n \t}\n       else\n \t{\n \t  if (mmin)\n-\t    assumption = fold (build2 (EQ_EXPR, boolean_type_node, base1, mmin));\n+\t    assumption = fold_build2 (EQ_EXPR, boolean_type_node, base1, mmin);\n \t  else\n \t    assumption = boolean_false_node;\n \t  if (nonzero_p (assumption))\n \t    goto zero_iter;\n-\t  base1 = fold (build2 (MINUS_EXPR, type, base1,\n-\t\t\t\tbuild_int_cst_type (type, 1)));\n+\t  base1 = fold_build2 (MINUS_EXPR, type, base1,\n+\t\t\t       build_int_cst_type (type, 1));\n \t}\n       noloop_assumptions = assumption;\n       code = LE_EXPR;\n@@ -274,7 +274,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       else\n \tstep = step0;\n       delta = build2 (MINUS_EXPR, type, base1, base0);\n-      delta = fold (build2 (FLOOR_MOD_EXPR, type, delta, step));\n+      delta = fold_build2 (FLOOR_MOD_EXPR, type, delta, step);\n       may_xform = boolean_false_node;\n \n       if (TREE_CODE (delta) == INTEGER_CST)\n@@ -305,8 +305,8 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t\t\t\t\t   mmin, step);\n \t\t  bound = fold_binary_to_constant (MINUS_EXPR, type,\n \t\t\t\t\t\t   bound, delta);\n-\t\t  may_xform = fold (build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t   bound, base0));\n+\t\t  may_xform = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t   bound, base0);\n \t\t}\n \t    }\n \t  else\n@@ -319,8 +319,8 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t\t\t\t\t   mmax, step);\n \t\t  bound = fold_binary_to_constant (PLUS_EXPR, type,\n \t\t\t\t\t\t   bound, delta);\n-\t\t  may_xform = fold (build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t   base1, bound));\n+\t\t  may_xform = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t   base1, bound);\n \t\t}\n \t    }\n \t}\n@@ -335,18 +335,18 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \n \t  if (zero_p (step0))\n \t    {\n-\t      base0 = fold (build2 (PLUS_EXPR, type, base0, delta));\n-\t      base0 = fold (build2 (MINUS_EXPR, type, base0, step));\n+\t      base0 = fold_build2 (PLUS_EXPR, type, base0, delta);\n+\t      base0 = fold_build2 (MINUS_EXPR, type, base0, step);\n \t    }\n \t  else\n \t    {\n-\t      base1 = fold (build2 (MINUS_EXPR, type, base1, delta));\n-\t      base1 = fold (build2 (PLUS_EXPR, type, base1, step));\n+\t      base1 = fold_build2 (MINUS_EXPR, type, base1, delta);\n+\t      base1 = fold_build2 (PLUS_EXPR, type, base1, step);\n \t    }\n \n-\t  assumption = fold (build2 (GT_EXPR, boolean_type_node, base0, base1));\n-\t  noloop_assumptions = fold (build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t\t    noloop_assumptions, assumption));\n+\t  assumption = fold_build2 (GT_EXPR, boolean_type_node, base0, base1);\n+\t  noloop_assumptions = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t\t    noloop_assumptions, assumption);\n \t  code = NE_EXPR;\n \t}\n     }\n@@ -361,15 +361,15 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t makes us able to do more involved computations of number of iterations\n \t than in other cases.  First transform the condition into shape\n \t s * i <> c, with s positive.  */\n-      base1 = fold (build2 (MINUS_EXPR, type, base1, base0));\n+      base1 = fold_build2 (MINUS_EXPR, type, base1, base0);\n       base0 = NULL_TREE;\n       if (!zero_p (step1))\n   \tstep0 = fold_unary_to_constant (NEGATE_EXPR, type, step1);\n       step1 = NULL_TREE;\n       if (!tree_expr_nonnegative_p (fold_convert (signed_niter_type, step0)))\n \t{\n \t  step0 = fold_unary_to_constant (NEGATE_EXPR, type, step0);\n-\t  base1 = fold (build1 (NEGATE_EXPR, type, base1));\n+\t  base1 = fold_build1 (NEGATE_EXPR, type, base1);\n \t}\n \n       base1 = fold_convert (niter_type, base1);\n@@ -387,16 +387,16 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t\t\t\t   (TYPE_PRECISION (niter_type)\n \t\t\t\t    - tree_low_cst (bits, 1)));\n \n-      assumption = fold (build2 (FLOOR_MOD_EXPR, niter_type, base1, d));\n-      assumption = fold (build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t assumption,\n-\t\t\t\t build_int_cst (niter_type, 0)));\n-      assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t  assumptions, assumption));\n+      assumption = fold_build2 (FLOOR_MOD_EXPR, niter_type, base1, d);\n+      assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\tassumption,\n+\t\t\t\tbuild_int_cst (niter_type, 0));\n+      assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t assumptions, assumption);\n \n-      tmp = fold (build2 (EXACT_DIV_EXPR, niter_type, base1, d));\n-      tmp = fold (build2 (MULT_EXPR, niter_type, tmp, inverse (s, bound)));\n-      niter->niter = fold (build2 (BIT_AND_EXPR, niter_type, tmp, bound));\n+      tmp = fold_build2 (EXACT_DIV_EXPR, niter_type, base1, d);\n+      tmp = fold_build2 (MULT_EXPR, niter_type, tmp, inverse (s, bound));\n+      niter->niter = fold_build2 (BIT_AND_EXPR, niter_type, tmp, bound);\n     }\n   else\n     {\n@@ -411,17 +411,17 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t  if (mmax)\n \t    {\n \t      bound = fold_binary_to_constant (MINUS_EXPR, type, mmax, step0);\n-\t      assumption = fold (build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t base1, bound));\n-\t      assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t\t  assumptions, assumption));\n+\t      assumption = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\tbase1, bound);\n+\t      assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t assumptions, assumption);\n \t    }\n \n \t  step = step0;\n-\t  tmp = fold (build2 (PLUS_EXPR, type, base1, step0));\n-\t  assumption = fold (build2 (GT_EXPR, boolean_type_node, base0, tmp));\n-\t  delta = fold (build2 (PLUS_EXPR, type, base1, step));\n-\t  delta = fold (build2 (MINUS_EXPR, type, delta, base0));\n+\t  tmp = fold_build2 (PLUS_EXPR, type, base1, step0);\n+\t  assumption = fold_build2 (GT_EXPR, boolean_type_node, base0, tmp);\n+\t  delta = fold_build2 (PLUS_EXPR, type, base1, step);\n+\t  delta = fold_build2 (MINUS_EXPR, type, delta, base0);\n \t  delta = fold_convert (niter_type, delta);\n \t}\n       else\n@@ -432,22 +432,22 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t  if (mmin)\n \t    {\n \t      bound = fold_binary_to_constant (MINUS_EXPR, type, mmin, step1);\n-\t      assumption = fold (build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\tbound, base0));\n-\t      assumptions = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t\t assumptions, assumption));\n+\t      assumption = fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\tbound, base0);\n+\t      assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t assumptions, assumption);\n \t    }\n-\t  step = fold (build1 (NEGATE_EXPR, type, step1));\n-\t  tmp = fold (build2 (PLUS_EXPR, type, base0, step1));\n-\t  assumption = fold (build2 (GT_EXPR, boolean_type_node, tmp, base1));\n-\t  delta = fold (build2 (MINUS_EXPR, type, base0, step));\n-\t  delta = fold (build2 (MINUS_EXPR, type, base1, delta));\n+\t  step = fold_build1 (NEGATE_EXPR, type, step1);\n+\t  tmp = fold_build2 (PLUS_EXPR, type, base0, step1);\n+\t  assumption = fold_build2 (GT_EXPR, boolean_type_node, tmp, base1);\n+\t  delta = fold_build2 (MINUS_EXPR, type, base0, step);\n+\t  delta = fold_build2 (MINUS_EXPR, type, base1, delta);\n \t  delta = fold_convert (niter_type, delta);\n \t}\n-      noloop_assumptions = fold (build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t\tnoloop_assumptions, assumption));\n-      delta = fold (build2 (FLOOR_DIV_EXPR, niter_type, delta,\n-\t\t\t    fold_convert (niter_type, step)));\n+      noloop_assumptions = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t\tnoloop_assumptions, assumption);\n+      delta = fold_build2 (FLOOR_DIV_EXPR, niter_type, delta,\n+\t\t\t   fold_convert (niter_type, step));\n       niter->niter = delta;\n     }\n \n@@ -462,60 +462,131 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n   return;\n }\n \n-/* Tries to simplify EXPR using the evolutions of the loop invariants\n-   in the superloops of LOOP.  Returns the simplified expression\n-   (or EXPR unchanged, if no simplification was possible).  */\n \n-static tree\n-simplify_using_outer_evolutions (struct loop *loop, tree expr)\n+/* Similar to number_of_iterations_cond, but only handles the special\n+   case of loops with step 1 or -1.  The meaning of the arguments\n+   is the same as in number_of_iterations_cond.  The function\n+   returns true if the special case was recognized, false otherwise.  */\n+\n+static bool\n+number_of_iterations_special (tree type, tree base0, tree step0,\n+\t\t\t      enum tree_code code, tree base1, tree step1,\n+\t\t\t      struct tree_niter_desc *niter)\n {\n-  enum tree_code code = TREE_CODE (expr);\n-  bool changed;\n-  tree e, e0, e1, e2;\n+  tree niter_type = unsigned_type_for (type), mmax, mmin;\n \n-  if (is_gimple_min_invariant (expr))\n-    return expr;\n+  /* Make < comparison from > ones.  */\n+  if (code == GE_EXPR\n+      || code == GT_EXPR)\n+    {\n+      SWAP (base0, base1);\n+      SWAP (step0, step1);\n+      code = swap_tree_comparison (code);\n+    }\n \n-  if (code == TRUTH_OR_EXPR\n-      || code == TRUTH_AND_EXPR\n-      || code == COND_EXPR)\n+  switch (code)\n     {\n-      changed = false;\n+    case NE_EXPR:\n+      if (zero_p (step0))\n+\t{\n+\t  if (zero_p (step1))\n+\t    return false;\n+    \t  SWAP (base0, base1);\n+\t  SWAP (step0, step1);\n+\t}\n+      else if (!zero_p (step1))\n+\treturn false;\n \n-      e0 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 0));\n-      if (TREE_OPERAND (expr, 0) != e0)\n-\tchanged = true;\n+      if (integer_onep (step0))\n+\t{\n+\t  /* for (i = base0; i != base1; i++)  */\n+\t  niter->assumptions = boolean_true_node;\n+\t  niter->may_be_zero = boolean_false_node;\n+\t  niter->niter = fold_build2 (MINUS_EXPR, type, base1, base0);\n+\t  niter->additional_info = boolean_true_node;\n+\t}\n+      else if (integer_all_onesp (step0))\n+\t{\n+\t  /* for (i = base0; i != base1; i--)  */\n+\t  niter->assumptions = boolean_true_node;\n+\t  niter->may_be_zero = boolean_false_node;\n+\t  niter->niter = fold_build2 (MINUS_EXPR, type, base0, base1);\n+\t}\n+      else\n+\treturn false;\n \n-      e1 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 1));\n-      if (TREE_OPERAND (expr, 1) != e1)\n-\tchanged = true;\n+      break;\n \n-      if (code == COND_EXPR)\n+    case LT_EXPR:\n+      if ((step0 && integer_onep (step0) && zero_p (step1))\n+\t  || (step1 && integer_all_onesp (step1) && zero_p (step0)))\n \t{\n-\t  e2 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 2));\n-\t  if (TREE_OPERAND (expr, 2) != e2)\n-\t    changed = true;\n+\t  /* for (i = base0; i < base1; i++)\n+\t     \n+\t     or\n+\n+\t     for (i = base1; i > base0; i--).\n+\t     \n+\t     In both cases # of iterations is base1 - base0.  */\n+\n+\t  niter->assumptions = boolean_true_node;\n+\t  niter->may_be_zero = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t\t    base0, base1);\n+\t  niter->niter = fold_build2 (MINUS_EXPR, type, base1, base0);\n \t}\n       else\n-\te2 = NULL_TREE;\n+\treturn false;\n+      break;\n \n-      if (changed)\n+    case LE_EXPR:\n+      if (POINTER_TYPE_P (type))\n \t{\n-\t  if (code == COND_EXPR)\n-\t    expr = build3 (code, boolean_type_node, e0, e1, e2);\n+\t  /* We assume pointer arithmetic never overflows.  */\n+\t  mmin = mmax = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  mmin = TYPE_MIN_VALUE (type);\n+\t  mmax = TYPE_MAX_VALUE (type);\n+\t}\n+\n+      if (step0 && integer_onep (step0) && zero_p (step1))\n+\t{\n+\t  /* for (i = base0; i <= base1; i++)  */\n+\t  if (mmax)\n+\t    niter->assumptions = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t\t      base1, mmax);\n \t  else\n-\t    expr = build2 (code, boolean_type_node, e0, e1);\n-\t  expr = fold (expr);\n+\t    niter->assumptions = boolean_true_node;\n+\t  base1 = fold_build2 (PLUS_EXPR, type, base1,\n+\t\t\t       build_int_cst_type (type, 1));\n \t}\n+      else if (step1 && integer_all_onesp (step1) && zero_p (step0))\n+\t{\n+\t  /* for (i = base1; i >= base0; i--)  */\n+\t  if (mmin)\n+\t    niter->assumptions = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t\t      base0, mmin);\n+\t  else\n+\t    niter->assumptions = boolean_true_node;\n+\t  base0 = fold_build2 (MINUS_EXPR, type, base0,\n+\t\t\t       build_int_cst_type (type, 1));\n+\t}\n+      else\n+\treturn false;\n \n-      return expr;\n-    }\n+      niter->may_be_zero = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t\tbase0, base1);\n+      niter->niter = fold_build2 (MINUS_EXPR, type, base1, base0);\n+      break;\n \n-  e = instantiate_parameters (loop, expr);\n-  if (is_gimple_min_invariant (e))\n-    return e;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  return expr;\n+  niter->niter = fold_convert (niter_type, niter->niter);\n+  niter->additional_info = boolean_true_node;\n+  return true;\n }\n \n /* Substitute NEW for OLD in EXPR and fold the result.  */\n@@ -592,10 +663,9 @@ tree_simplify_using_condition (tree cond, tree expr)\n       if (changed)\n \t{\n \t  if (code == COND_EXPR)\n-\t    expr = build3 (code, boolean_type_node, e0, e1, e2);\n+\t    expr = fold_build3 (code, boolean_type_node, e0, e1, e2);\n \t  else\n-\t    expr = build2 (code, boolean_type_node, e0, e1);\n-\t  expr = fold (expr);\n+\t    expr = fold_build2 (code, boolean_type_node, e0, e1);\n \t}\n \n       return expr;\n@@ -648,14 +718,14 @@ tree_simplify_using_condition (tree cond, tree expr)\n \n   /* Check whether COND ==> EXPR.  */\n   notcond = invert_truthvalue (cond);\n-  e = fold (build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t   notcond, expr));\n+  e = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t   notcond, expr);\n   if (nonzero_p (e))\n     return e;\n \n   /* Check whether COND ==> not EXPR.  */\n-  e = fold (build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t   cond, expr));\n+  e = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t   cond, expr);\n   if (zero_p (e))\n     return e;\n \n@@ -695,17 +765,72 @@ simplify_using_initial_conditions (struct loop *loop, tree expr,\n       exp = tree_simplify_using_condition (cond, expr);\n \n       if (exp != expr)\n-\t*conds_used = fold (build2 (TRUTH_AND_EXPR,\n+\t*conds_used = fold_build2 (TRUTH_AND_EXPR,\n \t\t\t\t   boolean_type_node,\n \t\t\t\t   *conds_used,\n-\t\t\t\t   cond));\n+\t\t\t\t   cond);\n \n       expr = exp;\n     }\n \n   return expr;\n }\n \n+/* Tries to simplify EXPR using the evolutions of the loop invariants\n+   in the superloops of LOOP.  Returns the simplified expression\n+   (or EXPR unchanged, if no simplification was possible).  */\n+\n+static tree\n+simplify_using_outer_evolutions (struct loop *loop, tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+  bool changed;\n+  tree e, e0, e1, e2;\n+\n+  if (is_gimple_min_invariant (expr))\n+    return expr;\n+\n+  if (code == TRUTH_OR_EXPR\n+      || code == TRUTH_AND_EXPR\n+      || code == COND_EXPR)\n+    {\n+      changed = false;\n+\n+      e0 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 0));\n+      if (TREE_OPERAND (expr, 0) != e0)\n+\tchanged = true;\n+\n+      e1 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 1));\n+      if (TREE_OPERAND (expr, 1) != e1)\n+\tchanged = true;\n+\n+      if (code == COND_EXPR)\n+\t{\n+\t  e2 = simplify_using_outer_evolutions (loop, TREE_OPERAND (expr, 2));\n+\t  if (TREE_OPERAND (expr, 2) != e2)\n+\t    changed = true;\n+\t}\n+      else\n+\te2 = NULL_TREE;\n+\n+      if (changed)\n+\t{\n+\t  if (code == COND_EXPR)\n+\t    expr = fold_build3 (code, boolean_type_node, e0, e1, e2);\n+\t  else\n+\t    expr = fold_build2 (code, boolean_type_node, e0, e1);\n+\t}\n+\n+      return expr;\n+    }\n+\n+  e = instantiate_parameters (loop, expr);\n+  if (is_gimple_min_invariant (e))\n+    return e;\n+\n+  return expr;\n+}\n+\n /* Stores description of number of iterations of LOOP derived from\n    EXIT (an exit edge of the LOOP) in NITER.  Returns true if some\n    useful information could be derived (and fields of NITER has\n@@ -762,16 +887,28 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n     return false;\n \n   niter->niter = NULL_TREE;\n-  number_of_iterations_cond (type, base0, step0, code, base1, step1,\n-\t\t\t     niter);\n-  if (!niter->niter)\n-    return false;\n \n-  niter->assumptions = simplify_using_outer_evolutions (loop,\n-\t\t\t\t\t\t\tniter->assumptions);\n-  niter->may_be_zero = simplify_using_outer_evolutions (loop,\n-\t\t\t\t\t\t\tniter->may_be_zero);\n-  niter->niter = simplify_using_outer_evolutions (loop, niter->niter);\n+  /* Handle common special cases first, so that we do not need to use\n+     generic (and slow) analysis very often.  */\n+  if (!number_of_iterations_special (type, base0, step0, code, base1, step1,\n+\t\t\t\t     niter))\n+    {\n+\n+      number_of_iterations_cond (type, base0, step0, code, base1, step1,\n+\t\t\t\t niter);\n+\n+      if (!niter->niter)\n+\treturn false;\n+    }\n+\n+  if (optimize >= 3)\n+    {\n+      niter->assumptions = simplify_using_outer_evolutions (loop,\n+\t\t\t\t\t\t\t    niter->assumptions);\n+      niter->may_be_zero = simplify_using_outer_evolutions (loop,\n+\t\t\t\t\t\t\t    niter->may_be_zero);\n+      niter->niter = simplify_using_outer_evolutions (loop, niter->niter);\n+    }\n \n   niter->additional_info = boolean_true_node;\n   niter->assumptions\n@@ -1046,7 +1183,7 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n       for (j = 0; j < 2; j++)\n \taval[j] = get_val_for (op[j], val[j]);\n \n-      acnd = fold (build2 (cmp, boolean_type_node, aval[0], aval[1]));\n+      acnd = fold_build2 (cmp, boolean_type_node, aval[0], aval[1]);\n       if (zero_p (acnd))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1203,11 +1340,11 @@ compare_trees (tree a, tree b)\n   a = fold_convert (type, a);\n   b = fold_convert (type, b);\n \n-  if (nonzero_p (fold (build2 (EQ_EXPR, boolean_type_node, a, b))))\n+  if (nonzero_p (fold_build2 (EQ_EXPR, boolean_type_node, a, b)))\n     return 0;\n-  if (nonzero_p (fold (build2 (LT_EXPR, boolean_type_node, a, b))))\n+  if (nonzero_p (fold_build2 (LT_EXPR, boolean_type_node, a, b)))\n     return 1;\n-  if (nonzero_p (fold (build2 (GT_EXPR, boolean_type_node, a, b))))\n+  if (nonzero_p (fold_build2 (GT_EXPR, boolean_type_node, a, b)))\n     return -1;\n \n   return 2;\n@@ -1271,23 +1408,23 @@ can_count_iv_in_wider_type_bound (tree type, tree base, tree step,\n \n   b = fold_convert (type, base);\n   bplusstep = fold_convert (type,\n-\t\t\t    fold (build2 (PLUS_EXPR, inner_type, base, step)));\n-  new_step = fold (build2 (MINUS_EXPR, type, bplusstep, b));\n+\t\t\t    fold_build2 (PLUS_EXPR, inner_type, base, step));\n+  new_step = fold_build2 (MINUS_EXPR, type, bplusstep, b);\n   if (TREE_CODE (new_step) != INTEGER_CST)\n     return NULL_TREE;\n \n   switch (compare_trees (bplusstep, b))\n     {\n     case -1:\n       extreme = upper_bound_in_type (type, inner_type);\n-      delta = fold (build2 (MINUS_EXPR, type, extreme, b));\n+      delta = fold_build2 (MINUS_EXPR, type, extreme, b);\n       new_step_abs = new_step;\n       break;\n \n     case 1:\n       extreme = lower_bound_in_type (type, inner_type);\n-      new_step_abs = fold (build1 (NEGATE_EXPR, type, new_step));\n-      delta = fold (build2 (MINUS_EXPR, type, b, extreme));\n+      new_step_abs = fold_build1 (NEGATE_EXPR, type, new_step);\n+      delta = fold_build2 (MINUS_EXPR, type, b, extreme);\n       break;\n \n     case 0:\n@@ -1300,8 +1437,8 @@ can_count_iv_in_wider_type_bound (tree type, tree base, tree step,\n   unsigned_type = unsigned_type_for (type);\n   delta = fold_convert (unsigned_type, delta);\n   new_step_abs = fold_convert (unsigned_type, new_step_abs);\n-  valid_niter = fold (build2 (FLOOR_DIV_EXPR, unsigned_type,\n-\t\t\t     delta, new_step_abs));\n+  valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type,\n+\t\t\t     delta, new_step_abs);\n \n   bound_type = TREE_TYPE (bound);\n   if (TYPE_PRECISION (type) > TYPE_PRECISION (bound_type))\n@@ -1313,24 +1450,22 @@ can_count_iv_in_wider_type_bound (tree type, tree base, tree step,\n     {\n       /* After the statement OF we know that anything is executed at most\n \t BOUND times.  */\n-      cond = build2 (GE_EXPR, boolean_type_node, valid_niter, bound);\n+      cond = fold_build2 (GE_EXPR, boolean_type_node, valid_niter, bound);\n     }\n   else\n     {\n       /* Before the statement OF we know that anything is executed at most\n \t BOUND + 1 times.  */\n-      cond = build2 (GT_EXPR, boolean_type_node, valid_niter, bound);\n+      cond = fold_build2 (GT_EXPR, boolean_type_node, valid_niter, bound);\n     }\n \n-  cond = fold (cond);\n   if (nonzero_p (cond))\n     return new_step;\n \n   /* Try taking additional conditions into account.  */\n-  cond = build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\tinvert_truthvalue (additional),\n-\t\tcond);\n-  cond = fold (cond);\n+  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t      invert_truthvalue (additional),\n+\t\t      cond);\n   if (nonzero_p (cond))\n     return new_step;\n "}]}