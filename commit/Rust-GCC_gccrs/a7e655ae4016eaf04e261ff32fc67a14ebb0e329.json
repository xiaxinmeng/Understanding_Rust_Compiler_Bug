{"sha": "a7e655ae4016eaf04e261ff32fc67a14ebb0e329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdlNjU1YWU0MDE2ZWFmMDRlMjYxZmYzMmZjNjdhMTRlYmIwZTMyOQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-25T15:24:30Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-29T18:57:01Z"}, "message": "Add stmt context in simplify_using_ranges.\n\nThere were places simplify_using_ranges was not utilzing the stmt context.\n\n\t* vr-values.c (vr_values::vrp_stmt_computes_nonzero): Use stmt.\n\t(simplify_using_ranges::op_with_boolean_value_range_p): Add a\n\tstatement for location context.\n\t(check_for_binary_op_overflow): Ditto.\n\t(simplify_using_ranges::get_vr_for_comparison): Ditto.\n\t(simplify_using_ranges::compare_name_with_value): Ditto.\n\t(simplify_using_ranges::compare_names): Ditto.\n\t(vrp_evaluate_conditional_warnv_with_ops_using_ranges): Ditto.\n\t(simplify_using_ranges::simplify_truth_ops_using_ranges): Ditto.\n\t(simplify_using_ranges::simplify_min_or_max_using_ranges): Ditto.\n\t(simplify_using_ranges::simplify_internal_call_using_ranges): Ditto.\n\t(simplify_using_ranges::two_valued_val_range_p): Ditto.\n\t(simplify_using_ranges::simplify): Ditto.\n\t* vr-values.h: Adjust prototypes.", "tree": {"sha": "79247790befb4a60004473b51033f8063623ce04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79247790befb4a60004473b51033f8063623ce04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7e655ae4016eaf04e261ff32fc67a14ebb0e329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e655ae4016eaf04e261ff32fc67a14ebb0e329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e655ae4016eaf04e261ff32fc67a14ebb0e329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e655ae4016eaf04e261ff32fc67a14ebb0e329/comments", "author": null, "committer": null, "parents": [{"sha": "8a8a7d332d5d01db5aea7336a36d9fd71a679fb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8a7d332d5d01db5aea7336a36d9fd71a679fb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8a7d332d5d01db5aea7336a36d9fd71a679fb1"}], "stats": {"total": 85, "additions": 46, "deletions": 39}, "files": [{"sha": "190676de2c0332b964a1209718f6fb6cfd73a338", "filename": "gcc/vr-values.c", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e655ae4016eaf04e261ff32fc67a14ebb0e329/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e655ae4016eaf04e261ff32fc67a14ebb0e329/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=a7e655ae4016eaf04e261ff32fc67a14ebb0e329", "patch": "@@ -429,7 +429,7 @@ vr_values::vrp_stmt_computes_nonzero (gimple *stmt)\n \t\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))))\n \t    {\n \t      const value_range_equiv *vr\n-\t\t= get_value_range (TREE_OPERAND (base, 0));\n+\t\t= get_value_range (TREE_OPERAND (base, 0), stmt);\n \t      if (!range_includes_zero_p (vr))\n \t\treturn true;\n \t    }\n@@ -486,7 +486,7 @@ vr_values::op_with_constant_singleton_value_range (tree op)\n /* Return true if op is in a boolean [0, 1] value-range.  */\n \n bool\n-simplify_using_ranges::op_with_boolean_value_range_p (tree op)\n+simplify_using_ranges::op_with_boolean_value_range_p (tree op, gimple *s)\n {\n   if (TYPE_PRECISION (TREE_TYPE (op)) == 1)\n     return true;\n@@ -500,7 +500,7 @@ simplify_using_ranges::op_with_boolean_value_range_p (tree op)\n \n   /* ?? Errr, this should probably check for [0,0] and [1,1] as well\n      as [0,1].  */\n-  const value_range *vr = query->get_value_range (op);\n+  const value_range *vr = query->get_value_range (op, s);\n   return *vr == value_range (build_zero_cst (TREE_TYPE (op)),\n \t\t\t     build_one_cst (TREE_TYPE (op)));\n }\n@@ -1057,18 +1057,18 @@ vr_values::extract_range_from_comparison (value_range_equiv *vr,\n static bool\n check_for_binary_op_overflow (range_query *query,\n \t\t\t      enum tree_code subcode, tree type,\n-\t\t\t      tree op0, tree op1, bool *ovf)\n+\t\t\t      tree op0, tree op1, bool *ovf, gimple *s = NULL)\n {\n   value_range vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *query->get_value_range (op0);\n+    vr0 = *query->get_value_range (op0, s);\n   else if (TREE_CODE (op0) == INTEGER_CST)\n     vr0.set (op0);\n   else\n     vr0.set_varying (TREE_TYPE (op0));\n \n   if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = *query->get_value_range (op1);\n+    vr1 = *query->get_value_range (op1, s);\n   else if (TREE_CODE (op1) == INTEGER_CST)\n     vr1.set (op1);\n   else\n@@ -1980,10 +1980,11 @@ vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n    is varying or undefined.  Uses TEM as storage for the alternate range.  */\n \n const value_range_equiv *\n-simplify_using_ranges::get_vr_for_comparison (int i, value_range_equiv *tem)\n+simplify_using_ranges::get_vr_for_comparison (int i, value_range_equiv *tem,\n+\t\t\t\t\t      gimple *s)\n {\n   /* Shallow-copy equiv bitmap.  */\n-  const value_range_equiv *vr = query->get_value_range (ssa_name (i));\n+  const value_range_equiv *vr = query->get_value_range (ssa_name (i), s);\n \n   /* If name N_i does not have a valid range, use N_i as its own\n      range.  This allows us to compare against names that may\n@@ -2005,10 +2006,11 @@ simplify_using_ranges::get_vr_for_comparison (int i, value_range_equiv *tem)\n tree\n simplify_using_ranges::compare_name_with_value\n \t\t\t\t(enum tree_code comp, tree var, tree val,\n-\t\t\t\t bool *strict_overflow_p, bool use_equiv_p)\n+\t\t\t\t bool *strict_overflow_p, bool use_equiv_p,\n+\t\t\t\t gimple *s)\n {\n   /* Get the set of equivalences for VAR.  */\n-  bitmap e = query->get_value_range (var)->equiv ();\n+  bitmap e = query->get_value_range (var, s)->equiv ();\n \n   /* Start at -1.  Set it to 0 if we do a comparison without relying\n      on overflow, or 1 if all comparisons rely on overflow.  */\n@@ -2017,7 +2019,7 @@ simplify_using_ranges::compare_name_with_value\n   /* Compare vars' value range with val.  */\n   value_range_equiv tem_vr;\n   const value_range_equiv *equiv_vr\n-    = get_vr_for_comparison (SSA_NAME_VERSION (var), &tem_vr);\n+    = get_vr_for_comparison (SSA_NAME_VERSION (var), &tem_vr, s);\n   bool sop = false;\n   tree retval = compare_range_with_value (comp, equiv_vr, val, &sop);\n   if (retval)\n@@ -2044,7 +2046,7 @@ simplify_using_ranges::compare_name_with_value\n \t  && prop_simulate_again_p (SSA_NAME_DEF_STMT (name)))\n \tcontinue;\n \n-      equiv_vr = get_vr_for_comparison (i, &tem_vr);\n+      equiv_vr = get_vr_for_comparison (i, &tem_vr, s);\n       sop = false;\n       tree t = compare_range_with_value (comp, equiv_vr, val, &sop);\n       if (t)\n@@ -2084,12 +2086,12 @@ simplify_using_ranges::compare_name_with_value\n \n tree\n simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n-\t\t\t\t      bool *strict_overflow_p)\n+\t\t\t\t      bool *strict_overflow_p, gimple *s)\n {\n   /* Compare the ranges of every name equivalent to N1 against the\n      ranges of every name equivalent to N2.  */\n-  bitmap e1 = query->get_value_range (n1)->equiv ();\n-  bitmap e2 = query->get_value_range (n2)->equiv ();\n+  bitmap e1 = query->get_value_range (n1, s)->equiv ();\n+  bitmap e2 = query->get_value_range (n2, s)->equiv ();\n \n   /* Use the fake bitmaps if e1 or e2 are not available.  */\n   static bitmap s_e1 = NULL, s_e2 = NULL;\n@@ -2139,7 +2141,7 @@ simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n \tcontinue;\n \n       value_range_equiv tem_vr1;\n-      const value_range_equiv *vr1 = get_vr_for_comparison (i1, &tem_vr1);\n+      const value_range_equiv *vr1 = get_vr_for_comparison (i1, &tem_vr1, s);\n \n       tree t = NULL_TREE, retval = NULL_TREE;\n       bitmap_iterator bi2;\n@@ -2152,7 +2154,8 @@ simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n \t  bool sop = false;\n \n \t  value_range_equiv tem_vr2;\n-\t  const value_range_equiv *vr2 = get_vr_for_comparison (i2, &tem_vr2);\n+\t  const value_range_equiv *vr2 = get_vr_for_comparison (i2, &tem_vr2,\n+\t\t\t\t\t\t\t\ts);\n \n \t  t = compare_ranges (comp, vr1, vr2, &sop);\n \t  if (t)\n@@ -2198,11 +2201,12 @@ simplify_using_ranges::compare_names (enum tree_code comp, tree n1, tree n2,\n \n tree\n simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops_using_ranges\n-    (enum tree_code code, tree op0, tree op1, bool * strict_overflow_p)\n+    (enum tree_code code, tree op0, tree op1, bool * strict_overflow_p,\n+     gimple *s)\n {\n   const value_range_equiv *vr0, *vr1;\n-  vr0 = (TREE_CODE (op0) == SSA_NAME) ? query->get_value_range (op0) : NULL;\n-  vr1 = (TREE_CODE (op1) == SSA_NAME) ? query->get_value_range (op1) : NULL;\n+  vr0 = (TREE_CODE (op0) == SSA_NAME) ? query->get_value_range (op0, s) : NULL;\n+  vr1 = (TREE_CODE (op1) == SSA_NAME) ? query->get_value_range (op1, s) : NULL;\n \n   tree res = NULL_TREE;\n   if (vr0 && vr1)\n@@ -2302,20 +2306,20 @@ simplify_using_ranges::vrp_evaluate_conditional_warnv_with_ops\n     }\n \n   if ((ret = vrp_evaluate_conditional_warnv_with_ops_using_ranges\n-\t       (code, op0, op1, strict_overflow_p)))\n+\t       (code, op0, op1, strict_overflow_p, stmt)))\n     return ret;\n   if (only_ranges)\n     *only_ranges = false;\n   /* Do not use compare_names during propagation, it's quadratic.  */\n   if (TREE_CODE (op0) == SSA_NAME && TREE_CODE (op1) == SSA_NAME\n       && use_equiv_p)\n-    return compare_names (code, op0, op1, strict_overflow_p);\n+    return compare_names (code, op0, op1, strict_overflow_p, stmt);\n   else if (TREE_CODE (op0) == SSA_NAME)\n     return compare_name_with_value (code, op0, op1,\n-\t\t\t\t    strict_overflow_p, use_equiv_p);\n+\t\t\t\t    strict_overflow_p, use_equiv_p, stmt);\n   else if (TREE_CODE (op1) == SSA_NAME)\n     return compare_name_with_value (swap_tree_comparison (code), op1, op0,\n-\t\t\t\t    strict_overflow_p, use_equiv_p);\n+\t\t\t\t    strict_overflow_p, use_equiv_p, stmt);\n   return NULL_TREE;\n }\n \n@@ -2929,11 +2933,11 @@ simplify_using_ranges::simplify_truth_ops_using_ranges\n   gcc_assert (rhs_code == EQ_EXPR || rhs_code == NE_EXPR);\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!op_with_boolean_value_range_p (op0))\n+  if (!op_with_boolean_value_range_p (op0, stmt))\n     return false;\n \n   op1 = gimple_assign_rhs2 (stmt);\n-  if (!op_with_boolean_value_range_p (op1))\n+  if (!op_with_boolean_value_range_p (op1, stmt))\n     return false;\n \n   /* Reduce number of cases to handle to NE_EXPR.  As there is no\n@@ -3131,12 +3135,12 @@ simplify_using_ranges::simplify_min_or_max_using_ranges\n   tree val;\n \n   val = (vrp_evaluate_conditional_warnv_with_ops_using_ranges\n-\t (LE_EXPR, op0, op1, &sop));\n+\t (LE_EXPR, op0, op1, &sop, stmt));\n   if (!val)\n     {\n       sop = false;\n       val = (vrp_evaluate_conditional_warnv_with_ops_using_ranges\n-\t     (LT_EXPR, op0, op1, &sop));\n+\t     (LT_EXPR, op0, op1, &sop, stmt));\n     }\n \n   if (val)\n@@ -4000,7 +4004,7 @@ simplify_using_ranges::simplify_internal_call_using_ranges\n     return false;\n   else\n     type = TREE_TYPE (TREE_TYPE (gimple_call_lhs (stmt)));\n-  if (!check_for_binary_op_overflow (query, subcode, type, op0, op1, &ovf)\n+  if (!check_for_binary_op_overflow (query, subcode, type, op0, op1, &ovf, stmt)\n       || (is_ubsan && ovf))\n     return false;\n \n@@ -4057,9 +4061,10 @@ simplify_using_ranges::simplify_internal_call_using_ranges\n    two-values when it is true.  Return false otherwise.  */\n \n bool\n-simplify_using_ranges::two_valued_val_range_p (tree var, tree *a, tree *b)\n+simplify_using_ranges::two_valued_val_range_p (tree var, tree *a, tree *b,\n+\t\t\t\t\t       gimple *s)\n {\n-  value_range vr = *query->get_value_range (var);\n+  value_range vr = *query->get_value_range (var, s);\n   vr.normalize_symbolics ();\n   if (vr.varying_p () || vr.undefined_p ())\n     return false;\n@@ -4133,15 +4138,15 @@ simplify_using_ranges::simplify (gimple_stmt_iterator *gsi)\n \t  tree cmp_var = NULL_TREE;\n \n \t  if (TREE_CODE (rhs2) == SSA_NAME\n-\t      && two_valued_val_range_p (rhs2, &val1, &val2))\n+\t      && two_valued_val_range_p (rhs2, &val1, &val2, stmt))\n \t    {\n \t      /* Optimize RHS1 OP [VAL1, VAL2].  */\n \t      new_rhs1 = int_const_binop (rhs_code, rhs1, val1);\n \t      new_rhs2 = int_const_binop (rhs_code, rhs1, val2);\n \t      cmp_var = rhs2;\n \t    }\n \t  else if (TREE_CODE (rhs1) == SSA_NAME\n-\t\t   && two_valued_val_range_p (rhs1, &val1, &val2))\n+\t\t   && two_valued_val_range_p (rhs1, &val1, &val2, stmt))\n \t    {\n \t      /* Optimize [VAL1, VAL2] OP RHS2.  */\n \t      new_rhs1 = int_const_binop (rhs_code, val1, rhs2);"}, {"sha": "7fdefef2fdf987a6066dfa0e155ce3b6d395ae10", "filename": "gcc/vr-values.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e655ae4016eaf04e261ff32fc67a14ebb0e329/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e655ae4016eaf04e261ff32fc67a14ebb0e329/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=a7e655ae4016eaf04e261ff32fc67a14ebb0e329", "patch": "@@ -56,14 +56,16 @@ class simplify_using_ranges\n \t\t\t\t\t       gimple *);\n   bool simplify_internal_call_using_ranges (gimple_stmt_iterator *, gimple *);\n \n-  bool two_valued_val_range_p (tree, tree *, tree *);\n-  bool op_with_boolean_value_range_p (tree);\n-  tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool);\n-  tree compare_names (enum tree_code, tree, tree, bool *);\n-  const value_range_equiv *get_vr_for_comparison (int, value_range_equiv *);\n+  bool two_valued_val_range_p (tree, tree *, tree *, gimple *);\n+  bool op_with_boolean_value_range_p (tree, gimple *);\n+  tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool,\n+\t\t\t\tgimple *);\n+  tree compare_names (enum tree_code, tree, tree, bool *, gimple *s);\n+  const value_range_equiv *get_vr_for_comparison (int, value_range_equiv *,\n+\t\t\t\t\t\t  gimple *s);\n   tree vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code,\n \t\t\t\t\t\t\t     tree, tree,\n-\t\t\t\t\t\t\t     bool *);\n+\t\t\t\t\t\t\t     bool *, gimple *s);\n   void cleanup_edges_and_switches (void);\n \n   /* Vectors of edges that need removing and switch statements that"}]}