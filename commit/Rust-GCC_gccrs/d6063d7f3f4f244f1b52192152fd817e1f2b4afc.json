{"sha": "d6063d7f3f4f244f1b52192152fd817e1f2b4afc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwNjNkN2YzZjRmMjQ0ZjFiNTIxOTIxNTJmZDgxN2UxZjJiNGFmYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-10-13T18:41:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-10-13T18:41:56Z"}, "message": "re PR tree-optimization/41377 (gimple EH rewrite causes ICE with PPRE (enabled at -O3))\n\n        PR tree-optimization/41377\n        * tree-eh.c (unsplit_eh): Propagate degenerate PHIs.\n        (cleanup_empty_eh_merge_phis): New change_region parameter;\n        pass it on to redirect_eh_edge_1.  Update callers.\n        (cleanup_empty_eh_unsplit): Don't require an existing EH label\n        at the destination block.\n\nFrom-SVN: r152728", "tree": {"sha": "74fb485ab351d1834e45a278e8522553d5ee1422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74fb485ab351d1834e45a278e8522553d5ee1422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6063d7f3f4f244f1b52192152fd817e1f2b4afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6063d7f3f4f244f1b52192152fd817e1f2b4afc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6063d7f3f4f244f1b52192152fd817e1f2b4afc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6063d7f3f4f244f1b52192152fd817e1f2b4afc/comments", "author": null, "committer": null, "parents": [{"sha": "f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2"}], "stats": {"total": 123, "additions": 94, "deletions": 29}, "files": [{"sha": "a1108fca62739fef60098e9d0cf8bc150318d255", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6063d7f3f4f244f1b52192152fd817e1f2b4afc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6063d7f3f4f244f1b52192152fd817e1f2b4afc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6063d7f3f4f244f1b52192152fd817e1f2b4afc", "patch": "@@ -1,7 +1,16 @@\n+2009-10-13  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-optimization/41377\n+\t* tree-eh.c (unsplit_eh): Propagate degenerate PHIs.\n+\t(cleanup_empty_eh_merge_phis): New change_region parameter;\n+\tpass it on to redirect_eh_edge_1.  Update callers.\n+\t(cleanup_empty_eh_unsplit): Don't require an existing EH label\n+\tat the destination block.\n \n 2009-10-13  Basile Starynkevitch  <basile@starynkevitch.net>\n-    * passes.c (register_pass): Replaced gcc_unreachable by\n-    fatal_error on failure. Mentions plugins in comments & messages.\n+\n+\t* passes.c (register_pass): Replaced gcc_unreachable by\n+\tfatal_error on failure. Mentions plugins in comments & messages.\n \n 2009-10-13  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "3557ab2aa54a5a645316d2ee8c060db7ff3ac525", "filename": "gcc/testsuite/g++.dg/opt/eh5.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6063d7f3f4f244f1b52192152fd817e1f2b4afc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Feh5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6063d7f3f4f244f1b52192152fd817e1f2b4afc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Feh5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Feh5.C?ref=d6063d7f3f4f244f1b52192152fd817e1f2b4afc", "patch": "@@ -0,0 +1,43 @@\n+// PR 41377\n+// { dg-do compile }\n+// { dg-options \"-O3\" }\n+\n+struct A\n+{\n+  bool foo(int*) const;\n+} a;\n+\n+struct B {};\n+\n+struct B1 : B\n+{\n+  bool (A::*pmf)(int*) const;\n+  const A* pa;\n+\n+  B1() : pmf(&A::foo), pa(&a) {}\n+  bool operator()() const { return (pa->*pmf)(new int); }\n+};\n+\n+struct B2 : B\n+{\n+  B1 b1;\n+\n+  B2(const B1& _b1) : b1(_b1) {}\n+  bool operator()() const { return b1(); }\n+};\n+\n+template<int> struct C\n+{\n+  void bar(B2 b2) { while (b2()) ; }\n+  C() { bar(B2(B1())); }\n+};\n+\n+void baz(int i)\n+{\n+  switch(i)\n+  {\n+    case 0: new C<0>;\n+    case 1: new C<1>;\n+    case 2: new C<2>;\n+  }\n+}"}, {"sha": "c077d940eb25f07fb6c2b12f7eb82cf32b2149ce", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6063d7f3f4f244f1b52192152fd817e1f2b4afc/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6063d7f3f4f244f1b52192152fd817e1f2b4afc/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=d6063d7f3f4f244f1b52192152fd817e1f2b4afc", "patch": "@@ -3381,12 +3381,31 @@ unsplit_eh (eh_landing_pad lp)\n   if (find_edge (e_in->src, e_out->dest))\n     return false;\n \n-  /* ??? I can't imagine there would be PHI nodes, since by nature\n-     of critical edge splitting this block should never have been\n-     a dominance frontier.  If cfg cleanups somehow confuse this,\n-     due to single edges in and out we ought to have degenerate PHIs\n-     and can easily propagate the PHI arguments.  */\n-  gcc_assert (gimple_seq_empty_p (phi_nodes (bb)));\n+  /* ??? We can get degenerate phis due to cfg cleanups.  I would have\n+     thought this should have been cleaned up by a phicprop pass, but\n+     that doesn't appear to handle virtuals.  Propagate by hand.  */\n+  if (!gimple_seq_empty_p (phi_nodes (bb)))\n+    {\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n+\t{\n+\t  gimple use_stmt, phi = gsi_stmt (gsi);\n+\t  tree lhs = gimple_phi_result (phi);\n+\t  tree rhs = gimple_phi_arg_def (phi, 0);\n+\t  use_operand_p use_p;\n+\t  imm_use_iterator iter;\n+\n+\t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+\t    {\n+\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\tSET_USE (use_p, rhs);\n+\t    }\n+\n+\t  if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;\n+\n+\t  remove_phi_node (&gsi, true);\n+\t}\n+    }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Unsplit EH landing pad %d to block %i.\\n\",\n@@ -3431,7 +3450,7 @@ unsplit_all_eh (void)\n \n static bool\n cleanup_empty_eh_merge_phis (basic_block new_bb, basic_block old_bb,\n-\t\t\t     edge old_bb_out)\n+\t\t\t     edge old_bb_out, bool change_region)\n {\n   gimple_stmt_iterator ngsi, ogsi;\n   edge_iterator ei;\n@@ -3531,7 +3550,7 @@ cleanup_empty_eh_merge_phis (basic_block new_bb, basic_block old_bb,\n   for (ei = ei_start (old_bb->preds); (e = ei_safe_edge (ei)); )\n     if (e->flags & EDGE_EH)\n       {\n-\tredirect_eh_edge_1 (e, new_bb, true);\n+\tredirect_eh_edge_1 (e, new_bb, change_region);\n \tredirect_edge_succ (e, new_bb);\n \tflush_pending_stmts (e);\n       }\n@@ -3583,46 +3602,40 @@ cleanup_empty_eh_move_lp (basic_block bb, edge e_out,\n    multiple incoming edges and phis are involved.  */\n \n static bool\n-cleanup_empty_eh_unsplit (basic_block bb, edge e_out, eh_landing_pad olp)\n+cleanup_empty_eh_unsplit (basic_block bb, edge e_out, eh_landing_pad lp)\n {\n   gimple_stmt_iterator gsi;\n-  eh_landing_pad nlp;\n   tree lab;\n \n   /* We really ought not have totally lost everything following\n      a landing pad label.  Given that BB is empty, there had better\n      be a successor.  */\n   gcc_assert (e_out != NULL);\n \n-  /* Look for an EH label in the successor block.  */\n+  /* The destination block must not already have a landing pad\n+     for a different region.  */\n   lab = NULL;\n   for (gsi = gsi_start_bb (e_out->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n+      int lp_nr;\n+\n       if (gimple_code (stmt) != GIMPLE_LABEL)\n \tbreak;\n       lab = gimple_label_label (stmt);\n-      if (EH_LANDING_PAD_NR (lab))\n-\tgoto found;\n+      lp_nr = EH_LANDING_PAD_NR (lab);\n+      if (lp_nr && get_eh_region_from_lp_number (lp_nr) != lp->region)\n+\treturn false;\n     }\n-  return false;\n- found:\n-\n-  /* The other label had better be part of the same EH region.  Given that\n-     we've not lowered RESX, there should be no way to have a totally empty\n-     landing pad that crosses to another EH region.  */\n-  nlp = get_eh_landing_pad_from_number (EH_LANDING_PAD_NR (lab));\n-  gcc_assert (nlp->region == olp->region);\n \n   /* Attempt to move the PHIs into the successor block.  */\n-  if (cleanup_empty_eh_merge_phis (e_out->dest, bb, e_out))\n+  if (cleanup_empty_eh_merge_phis (e_out->dest, bb, e_out, false))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"Unsplit EH landing pad %d to block %d via lp %d.\\n\",\n-\t\t olp->index, e_out->dest->index, nlp->index);\n-\n-      remove_eh_landing_pad (olp);\n+\t\t \"Unsplit EH landing pad %d to block %i \"\n+\t\t \"(via cleanup_empty_eh).\\n\",\n+\t\t lp->index, e_out->dest->index);\n       return true;\n     }\n \n@@ -3725,7 +3738,7 @@ cleanup_empty_eh (eh_landing_pad lp)\n      landing pad block.  If the merge succeeds, we'll already have redirected\n      all the EH edges.  The handler itself will go unreachable if there were\n      no normal edges.  */\n-  if (cleanup_empty_eh_merge_phis (e_out->dest, bb, e_out))\n+  if (cleanup_empty_eh_merge_phis (e_out->dest, bb, e_out, true))\n     goto succeed;\n \n   /* Finally, if all input edges are EH edges, then we can (potentially)"}]}