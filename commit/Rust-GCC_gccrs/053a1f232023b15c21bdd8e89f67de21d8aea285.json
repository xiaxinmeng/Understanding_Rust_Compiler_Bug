{"sha": "053a1f232023b15c21bdd8e89f67de21d8aea285", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUzYTFmMjMyMDIzYjE1YzIxYmRkOGU4OWY2N2RlMjFkOGFlYTI4NQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-29T00:49:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-29T00:49:23Z"}, "message": "runtime: use the call instruction's PC for panic-in-runtime detection\n    \n    If a panic happens in the runtime we turn that into a fatal error.\n    We use the caller's PC to determine if the panic call is inside\n    the runtime. getcallerpc returns the PC immediately after the\n    call instruction. If the call is the very last instruction of a\n    function, it may not find this PC belong to a runtime function,\n    giving false result. We need to back off the PC by 1 to the call\n    instruction.\n    \n    The gc runtime doesn't do this because the gc compiler always\n    emit an instruction following a panic call, presumably an UNDEF\n    instruction which turns into an architecture-specific illegal\n    instruction. Our compiler doesn't do this.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/159437\n\nFrom-SVN: r268358", "tree": {"sha": "30cc483c1055da9667de55c49b7ef3673f6266b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30cc483c1055da9667de55c49b7ef3673f6266b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/053a1f232023b15c21bdd8e89f67de21d8aea285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053a1f232023b15c21bdd8e89f67de21d8aea285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/053a1f232023b15c21bdd8e89f67de21d8aea285", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053a1f232023b15c21bdd8e89f67de21d8aea285/comments", "author": null, "committer": null, "parents": [{"sha": "45e7df858b408b0277ee3580f6a67696d5cfd8b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e7df858b408b0277ee3580f6a67696d5cfd8b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45e7df858b408b0277ee3580f6a67696d5cfd8b4"}], "stats": {"total": 8, "additions": 4, "deletions": 4}, "files": [{"sha": "0eff5eba6a82972b6808204aeb1b8ddf6aa648c2", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053a1f232023b15c21bdd8e89f67de21d8aea285/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053a1f232023b15c21bdd8e89f67de21d8aea285/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=053a1f232023b15c21bdd8e89f67de21d8aea285", "patch": "@@ -1,4 +1,4 @@\n-5ccb2d8593963e06ec3a35d362b384e82301d9f0\n+c2cac0ba0a92e74d5675c3c9f4e53d2567dbc903\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "9b8ffb91859d7585e632ec9a0077eaeb167285d7", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053a1f232023b15c21bdd8e89f67de21d8aea285/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053a1f232023b15c21bdd8e89f67de21d8aea285/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=053a1f232023b15c21bdd8e89f67de21d8aea285", "patch": "@@ -53,7 +53,7 @@ var indexError = error(errorString(\"index out of range\"))\n // entire runtime stack for easier debugging.\n \n func panicindex() {\n-\tname, _, _ := funcfileline(getcallerpc(), -1)\n+\tname, _, _ := funcfileline(getcallerpc()-1, -1)\n \tif hasPrefix(name, \"runtime.\") {\n \t\tthrow(string(indexError.(errorString)))\n \t}\n@@ -64,7 +64,7 @@ func panicindex() {\n var sliceError = error(errorString(\"slice bounds out of range\"))\n \n func panicslice() {\n-\tname, _, _ := funcfileline(getcallerpc(), -1)\n+\tname, _, _ := funcfileline(getcallerpc()-1, -1)\n \tif hasPrefix(name, \"runtime.\") {\n \t\tthrow(string(sliceError.(errorString)))\n \t}"}, {"sha": "5db355564dc83e57df8dd78dc67330bdcedc04f1", "filename": "libgo/runtime/go-runtime-error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053a1f232023b15c21bdd8e89f67de21d8aea285/libgo%2Fruntime%2Fgo-runtime-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053a1f232023b15c21bdd8e89f67de21d8aea285/libgo%2Fruntime%2Fgo-runtime-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-runtime-error.c?ref=053a1f232023b15c21bdd8e89f67de21d8aea285", "patch": "@@ -63,7 +63,7 @@ __go_runtime_error (int32 i)\n   struct funcfileline_return fileline;\n   bool in_runtime;\n \n-  fileline = runtime_funcfileline ((uintptr) runtime_getcallerpc(), 0);\n+  fileline = runtime_funcfileline ((uintptr) runtime_getcallerpc()-1, 0);\n   in_runtime = (fileline.retfn.len > 0\n \t\t&& (__builtin_strncmp ((const char *) fileline.retfn.str,\n \t\t\t\t      \"runtime.\", 8)"}]}