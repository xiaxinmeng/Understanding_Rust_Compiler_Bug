{"sha": "51148ddab1495aa357e57f1c209940f7cde571c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTExNDhkZGFiMTQ5NWFhMzU3ZTU3ZjFjMjA5OTQwZjdjZGU1NzFjMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T09:06:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T09:06:09Z"}, "message": "[multiple changes]\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_util.adb (Check_Part_Of_Reference):\n\tContinue to examine the context if the reference appears within\n\tan expression function.\n\n2017-04-25  Justin Squirek  <squirek@adacore.com>\n\n\t* exp_ch7.adb, exp_ch7.ads Remove Build_Invariant_Procedure_Body\n\tand Build_Invariant_Procedure_Declaration.\n\t* exp_util.ads, exp_util.adb Add Build_Invariant_Procedure_Body\n\tand Build_Invariant_Procedure_Declaration from exp_ch7\n\tand break-out Is_Untagged_Private_Derivation from\n\tBuild_Invariant_Procedure_Body.\n\t(Replace_Type_References):\n\tAppend an extra parameter to allow for dispatching replacements\n\tand add the corrasponding logic.\n\t(Type_Invariant): Remove\n\tReplace_Typ_Refs and replace its references with calls to\n\tReplace_Type_References.\n\t* sem_ch3.adb, sem_prag.adb: Remove with and use of exp_ch7.\n\nFrom-SVN: r247152", "tree": {"sha": "e8706f5d60b7ce819bcdad100a6c507b0da6abe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8706f5d60b7ce819bcdad100a6c507b0da6abe0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51148ddab1495aa357e57f1c209940f7cde571c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51148ddab1495aa357e57f1c209940f7cde571c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51148ddab1495aa357e57f1c209940f7cde571c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51148ddab1495aa357e57f1c209940f7cde571c1/comments", "author": null, "committer": null, "parents": [{"sha": "b043ae011153849317d63552814f54104999eeb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b043ae011153849317d63552814f54104999eeb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b043ae011153849317d63552814f54104999eeb0"}], "stats": {"total": 2976, "additions": 1481, "deletions": 1495}, "files": [{"sha": "917785a5bfa69bf28976ce80ed1bda183e076152", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=51148ddab1495aa357e57f1c209940f7cde571c1", "patch": "@@ -1,3 +1,25 @@\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_util.adb (Check_Part_Of_Reference):\n+\tContinue to examine the context if the reference appears within\n+\tan expression function.\n+\n+2017-04-25  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_ch7.adb, exp_ch7.ads Remove Build_Invariant_Procedure_Body\n+\tand Build_Invariant_Procedure_Declaration.\n+\t* exp_util.ads, exp_util.adb Add Build_Invariant_Procedure_Body\n+\tand Build_Invariant_Procedure_Declaration from exp_ch7\n+\tand break-out Is_Untagged_Private_Derivation from\n+\tBuild_Invariant_Procedure_Body.\n+\t(Replace_Type_References):\n+\tAppend an extra parameter to allow for dispatching replacements\n+\tand add the corrasponding logic.\n+\t(Type_Invariant): Remove\n+\tReplace_Typ_Refs and replace its references with calls to\n+\tReplace_Type_References.\n+\t* sem_ch3.adb, sem_prag.adb: Remove with and use of exp_ch7.\n+\n 2017-04-25  Bob Duff  <duff@adacore.com>\n \n \t* sem_util.ads, sem_util.adb (Should_Ignore_Pragma): New function"}, {"sha": "5d981608e63ec7be3a4922cb6f3f1fa8d48b9283", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 0, "deletions": 1468, "changes": 1468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=51148ddab1495aa357e57f1c209940f7cde571c1", "patch": "@@ -42,7 +42,6 @@ with Exp_Prag; use Exp_Prag;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -55,15 +54,12 @@ with Sinfo;    use Sinfo;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch13; use Sem_Ch13;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n with Stand;    use Stand;\n-with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n@@ -3451,1470 +3447,6 @@ package body Exp_Ch7 is\n       Expand_At_End_Handler (HSS, Empty);\n    end Build_Finalizer_Call;\n \n-   ------------------------------------\n-   -- Build_Invariant_Procedure_Body --\n-   ------------------------------------\n-\n-   --  WARNING: This routine manages Ghost regions. Return statements must be\n-   --  replaced by gotos which jump to the end of the routine and restore the\n-   --  Ghost mode.\n-\n-   procedure Build_Invariant_Procedure_Body\n-     (Typ               : Entity_Id;\n-      Partial_Invariant : Boolean := False)\n-   is\n-      Loc : constant Source_Ptr := Sloc (Typ);\n-\n-      Pragmas_Seen : Elist_Id := No_Elist;\n-      --  This list contains all invariant pragmas processed so far. The list\n-      --  is used to avoid generating redundant invariant checks.\n-\n-      Produced_Check : Boolean := False;\n-      --  This flag tracks whether the type has produced at least one invariant\n-      --  check. The flag is used as a sanity check at the end of the routine.\n-\n-      --  NOTE: most of the routines in Build_Invariant_Procedure_Body are\n-      --  intentionally unnested to avoid deep indentation of code.\n-\n-      --  NOTE: all Add_xxx_Invariants routines are reactive. In other words\n-      --  they emit checks, loops (for arrays) and case statements (for record\n-      --  variant parts) only when there are invariants to verify. This keeps\n-      --  the body of the invariant procedure free from useless code.\n-\n-      procedure Add_Array_Component_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id);\n-      --  Generate an invariant check for each component of array type T.\n-      --  Obj_Id denotes the entity of the _object formal parameter of the\n-      --  invariant procedure. All created checks are added to list Checks.\n-\n-      procedure Add_Interface_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id);\n-      --  Generate an invariant check for each inherited class-wide invariant\n-      --  coming from all interfaces implemented by type T. Obj_Id denotes the\n-      --  entity of the _object formal parameter of the invariant procedure.\n-      --  All created checks are added to list Checks.\n-\n-      procedure Add_Parent_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id);\n-      --  Generate an invariant check for each inherited class-wide invariant\n-      --  coming from all parent types of type T. Obj_Id denotes the entity of\n-      --  the _object formal parameter of the invariant procedure. All created\n-      --  checks are added to list Checks.\n-\n-      procedure Add_Record_Component_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id);\n-      --  Generate an invariant check for each component of record type T.\n-      --  Obj_Id denotes the entity of the _object formal parameter of the\n-      --  invariant procedure. All created checks are added to list Checks.\n-\n-      procedure Add_Type_Invariants\n-        (Priv_Typ  : Entity_Id;\n-         Full_Typ  : Entity_Id;\n-         CRec_Typ  : Entity_Id;\n-         Obj_Id    : Entity_Id;\n-         Checks    : in out List_Id;\n-         Inherit   : Boolean := False;\n-         Priv_Item : Node_Id := Empty);\n-      --  Generate an invariant check for each invariant found in one of the\n-      --  following types (if available):\n-      --\n-      --    Priv_Typ - the partial view of a type\n-      --    Full_Typ - the full view of a type\n-      --    CRec_Typ - the corresponding record of a protected or a task type\n-      --\n-      --  Obj_Id denotes the entity of the _object formal parameter of the\n-      --  invariant procedure. All created checks are added to list Checks.\n-      --  Flag Inherit should be set when generating invariant checks for\n-      --  inherited class-wide invariants. Priv_Item denotes the first rep\n-      --  item of the private type.\n-\n-      function Is_Untagged_Private_Derivation\n-        (Priv_Typ : Entity_Id;\n-         Full_Typ : Entity_Id) return Boolean;\n-      --  Determine whether private type Priv_Typ and its full view Full_Typ\n-      --  represent an untagged derivation from a private parent.\n-\n-      ------------------------------------\n-      -- Add_Array_Component_Invariants --\n-      ------------------------------------\n-\n-      procedure Add_Array_Component_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id)\n-      is\n-         Comp_Typ : constant Entity_Id := Component_Type (T);\n-         Dims     : constant Pos       := Number_Dimensions (T);\n-\n-         procedure Process_Array_Component\n-           (Indices     : List_Id;\n-            Comp_Checks : in out List_Id);\n-         --  Generate an invariant check for an array component identified by\n-         --  the indices in list Indices. All created checks are added to list\n-         --  Comp_Checks.\n-\n-         procedure Process_One_Dimension\n-           (Dim        : Pos;\n-            Indices    : List_Id;\n-            Dim_Checks : in out List_Id);\n-         --  Generate a loop over the Nth dimension Dim of an array type. List\n-         --  Indices contains all array indices for the dimension. All created\n-         --  checks are added to list Dim_Checks.\n-\n-         -----------------------------\n-         -- Process_Array_Component --\n-         -----------------------------\n-\n-         procedure Process_Array_Component\n-           (Indices     : List_Id;\n-            Comp_Checks : in out List_Id)\n-         is\n-            Proc_Id : Entity_Id;\n-\n-         begin\n-            if Has_Invariants (Comp_Typ) then\n-\n-               --  In GNATprove mode, the component invariants are checked by\n-               --  other means. They should not be added to the array type\n-               --  invariant procedure, so that the procedure can be used to\n-               --  check the array type invariants if any.\n-\n-               if GNATprove_Mode then\n-                  null;\n-\n-               else\n-                  Proc_Id := Invariant_Procedure (Base_Type (Comp_Typ));\n-\n-                  --  The component type should have an invariant procedure\n-                  --  if it has invariants of its own or inherits class-wide\n-                  --  invariants from parent or interface types.\n-\n-                  pragma Assert (Present (Proc_Id));\n-\n-                  --  Generate:\n-                  --    <Comp_Typ>Invariant (_object (<Indices>));\n-\n-                  --  Note that the invariant procedure may have a null body if\n-                  --  assertions are disabled or Assertion_Policy Ignore is in\n-                  --  effect.\n-\n-                  if not Has_Null_Body (Proc_Id) then\n-                     Append_New_To (Comp_Checks,\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name                   =>\n-                           New_Occurrence_Of (Proc_Id, Loc),\n-                         Parameter_Associations => New_List (\n-                           Make_Indexed_Component (Loc,\n-                             Prefix      => New_Occurrence_Of (Obj_Id, Loc),\n-                             Expressions => New_Copy_List (Indices)))));\n-                  end if;\n-               end if;\n-\n-               Produced_Check := True;\n-            end if;\n-         end Process_Array_Component;\n-\n-         ---------------------------\n-         -- Process_One_Dimension --\n-         ---------------------------\n-\n-         procedure Process_One_Dimension\n-           (Dim        : Pos;\n-            Indices    : List_Id;\n-            Dim_Checks : in out List_Id)\n-         is\n-            Comp_Checks : List_Id := No_List;\n-            Index       : Entity_Id;\n-\n-         begin\n-            --  Generate the invariant checks for the array component after all\n-            --  dimensions have produced their respective loops.\n-\n-            if Dim > Dims then\n-               Process_Array_Component\n-                 (Indices     => Indices,\n-                  Comp_Checks => Dim_Checks);\n-\n-            --  Otherwise create a loop for the current dimension\n-\n-            else\n-               --  Create a new loop variable for each dimension\n-\n-               Index :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name ('I', Dim));\n-               Append_To (Indices, New_Occurrence_Of (Index, Loc));\n-\n-               Process_One_Dimension\n-                 (Dim        => Dim + 1,\n-                  Indices    => Indices,\n-                  Dim_Checks => Comp_Checks);\n-\n-               --  Generate:\n-               --    for I<Dim> in _object'Range (<Dim>) loop\n-               --       <Comp_Checks>\n-               --    end loop;\n-\n-               --  Note that the invariant procedure may have a null body if\n-               --  assertions are disabled or Assertion_Policy Ignore is in\n-               --  effect.\n-\n-               if Present (Comp_Checks) then\n-                  Append_New_To (Dim_Checks,\n-                    Make_Implicit_Loop_Statement (T,\n-                      Identifier       => Empty,\n-                      Iteration_Scheme =>\n-                        Make_Iteration_Scheme (Loc,\n-                          Loop_Parameter_Specification =>\n-                            Make_Loop_Parameter_Specification (Loc,\n-                              Defining_Identifier         => Index,\n-                              Discrete_Subtype_Definition =>\n-                                Make_Attribute_Reference (Loc,\n-                                  Prefix         =>\n-                                    New_Occurrence_Of (Obj_Id, Loc),\n-                                  Attribute_Name => Name_Range,\n-                                  Expressions    => New_List (\n-                                    Make_Integer_Literal (Loc, Dim))))),\n-\n-                      Statements => Comp_Checks));\n-               end if;\n-            end if;\n-         end Process_One_Dimension;\n-\n-      --  Start of processing for Add_Array_Component_Invariants\n-\n-      begin\n-         Process_One_Dimension\n-           (Dim        => 1,\n-            Indices    => New_List,\n-            Dim_Checks => Checks);\n-      end Add_Array_Component_Invariants;\n-\n-      ------------------------------\n-      -- Add_Interface_Invariants --\n-      ------------------------------\n-\n-      procedure Add_Interface_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id)\n-      is\n-         Iface_Elmt : Elmt_Id;\n-         Ifaces     : Elist_Id;\n-\n-      begin\n-         if Is_Tagged_Type (T) then\n-            Collect_Interfaces (T, Ifaces);\n-\n-            --  Process the class-wide invariants of all implemented interfaces\n-\n-            Iface_Elmt := First_Elmt (Ifaces);\n-            while Present (Iface_Elmt) loop\n-               Add_Type_Invariants\n-                 (Priv_Typ => Empty,\n-                  Full_Typ => Node (Iface_Elmt),\n-                  CRec_Typ => Empty,\n-                  Obj_Id   => Obj_Id,\n-                  Checks   => Checks,\n-                  Inherit  => True);\n-\n-               Next_Elmt (Iface_Elmt);\n-            end loop;\n-         end if;\n-      end Add_Interface_Invariants;\n-\n-      ---------------------------\n-      -- Add_Parent_Invariants --\n-      ---------------------------\n-\n-      procedure Add_Parent_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id)\n-      is\n-         Dummy_1 : Entity_Id;\n-         Dummy_2 : Entity_Id;\n-\n-         Curr_Typ : Entity_Id;\n-         --  The entity of the current type being examined\n-\n-         Full_Typ : Entity_Id;\n-         --  The full view of Par_Typ\n-\n-         Par_Typ : Entity_Id;\n-         --  The entity of the parent type\n-\n-         Priv_Typ : Entity_Id;\n-         --  The partial view of Par_Typ\n-\n-      begin\n-         --  Do not process array types because they cannot have true parent\n-         --  types. This also prevents the generation of a duplicate invariant\n-         --  check when the input type is an array base type because its Etype\n-         --  denotes the first subtype, both of which share the same component\n-         --  type.\n-\n-         if Is_Array_Type (T) then\n-            return;\n-         end if;\n-\n-         --  Climb the parent type chain\n-\n-         Curr_Typ := T;\n-         loop\n-            --  Do not consider subtypes as they inherit the invariants from\n-            --  their base types.\n-\n-            Par_Typ := Base_Type (Etype (Curr_Typ));\n-\n-            --  Stop the climb once the root of the parent chain is reached\n-\n-            exit when Curr_Typ = Par_Typ;\n-\n-            --  Process the class-wide invariants of the parent type\n-\n-            Get_Views (Par_Typ, Priv_Typ, Full_Typ, Dummy_1, Dummy_2);\n-\n-            Add_Type_Invariants\n-              (Priv_Typ => Priv_Typ,\n-               Full_Typ => Full_Typ,\n-               CRec_Typ => Empty,\n-               Obj_Id   => Obj_Id,\n-               Checks   => Checks,\n-               Inherit  => True);\n-\n-            Curr_Typ := Par_Typ;\n-         end loop;\n-      end Add_Parent_Invariants;\n-\n-      -------------------------------------\n-      -- Add_Record_Component_Invariants --\n-      -------------------------------------\n-\n-      procedure Add_Record_Component_Invariants\n-        (T      : Entity_Id;\n-         Obj_Id : Entity_Id;\n-         Checks : in out List_Id)\n-      is\n-         procedure Process_Component_List\n-           (Comp_List : Node_Id;\n-            CL_Checks : in out List_Id);\n-         --  Generate invariant checks for all record components found in\n-         --  component list Comp_List, including variant parts. All created\n-         --  checks are added to list CL_Checks.\n-\n-         procedure Process_Record_Component\n-           (Comp_Id     : Entity_Id;\n-            Comp_Checks : in out List_Id);\n-         --  Generate an invariant check for a record component identified by\n-         --  Comp_Id. All created checks are added to list Comp_Checks.\n-\n-         ----------------------------\n-         -- Process_Component_List --\n-         ----------------------------\n-\n-         procedure Process_Component_List\n-           (Comp_List : Node_Id;\n-            CL_Checks : in out List_Id)\n-         is\n-            Comp       : Node_Id;\n-            Var        : Node_Id;\n-            Var_Alts   : List_Id := No_List;\n-            Var_Checks : List_Id := No_List;\n-            Var_Stmts  : List_Id;\n-\n-            Produced_Variant_Check : Boolean := False;\n-            --  This flag tracks whether the component has produced at least\n-            --  one invariant check.\n-\n-         begin\n-            --  Traverse the component items\n-\n-            Comp := First (Component_Items (Comp_List));\n-            while Present (Comp) loop\n-               if Nkind (Comp) = N_Component_Declaration then\n-\n-                  --  Generate the component invariant check\n-\n-                  Process_Record_Component\n-                    (Comp_Id     => Defining_Entity (Comp),\n-                     Comp_Checks => CL_Checks);\n-               end if;\n-\n-               Next (Comp);\n-            end loop;\n-\n-            --  Traverse the variant part\n-\n-            if Present (Variant_Part (Comp_List)) then\n-               Var := First (Variants (Variant_Part (Comp_List)));\n-               while Present (Var) loop\n-                  Var_Checks := No_List;\n-\n-                  --  Generate invariant checks for all components and variant\n-                  --  parts that qualify.\n-\n-                  Process_Component_List\n-                    (Comp_List => Component_List (Var),\n-                     CL_Checks => Var_Checks);\n-\n-                  --  The components of the current variant produced at least\n-                  --  one invariant check.\n-\n-                  if Present (Var_Checks) then\n-                     Var_Stmts := Var_Checks;\n-                     Produced_Variant_Check := True;\n-\n-                  --  Otherwise there are either no components with invariants,\n-                  --  assertions are disabled, or Assertion_Policy Ignore is in\n-                  --  effect.\n-\n-                  else\n-                     Var_Stmts := New_List (Make_Null_Statement (Loc));\n-                  end if;\n-\n-                  Append_New_To (Var_Alts,\n-                    Make_Case_Statement_Alternative (Loc,\n-                      Discrete_Choices =>\n-                        New_Copy_List (Discrete_Choices (Var)),\n-                      Statements       => Var_Stmts));\n-\n-                  Next (Var);\n-               end loop;\n-\n-               --  Create a case statement which verifies the invariant checks\n-               --  of a particular component list depending on the discriminant\n-               --  values only when there is at least one real invariant check.\n-\n-               if Produced_Variant_Check then\n-                  Append_New_To (CL_Checks,\n-                    Make_Case_Statement (Loc,\n-                      Expression   =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n-                          Selector_Name =>\n-                            New_Occurrence_Of\n-                              (Entity (Name (Variant_Part (Comp_List))), Loc)),\n-                      Alternatives => Var_Alts));\n-               end if;\n-            end if;\n-         end Process_Component_List;\n-\n-         ------------------------------\n-         -- Process_Record_Component --\n-         ------------------------------\n-\n-         procedure Process_Record_Component\n-           (Comp_Id     : Entity_Id;\n-            Comp_Checks : in out List_Id)\n-         is\n-            Comp_Typ : constant Entity_Id := Etype (Comp_Id);\n-            Proc_Id  : Entity_Id;\n-\n-            Produced_Component_Check : Boolean := False;\n-            --  This flag tracks whether the component has produced at least\n-            --  one invariant check.\n-\n-         begin\n-            --  Nothing to do for internal component _parent. Note that it is\n-            --  not desirable to check whether the component comes from source\n-            --  because protected type components are relocated to an internal\n-            --  corresponding record, but still need processing.\n-\n-            if Chars (Comp_Id) = Name_uParent then\n-               return;\n-            end if;\n-\n-            --  Verify the invariant of the component. Note that an access\n-            --  type may have an invariant when it acts as the full view of a\n-            --  private type and the invariant appears on the partial view. In\n-            --  this case verify the access value itself.\n-\n-            if Has_Invariants (Comp_Typ) then\n-\n-               --  In GNATprove mode, the component invariants are checked by\n-               --  other means. They should not be added to the record type\n-               --  invariant procedure, so that the procedure can be used to\n-               --  check the record type invariants if any.\n-\n-               if GNATprove_Mode then\n-                  null;\n-\n-               else\n-                  Proc_Id := Invariant_Procedure (Base_Type (Comp_Typ));\n-\n-                  --  The component type should have an invariant procedure\n-                  --  if it has invariants of its own or inherits class-wide\n-                  --  invariants from parent or interface types.\n-\n-                  pragma Assert (Present (Proc_Id));\n-\n-                  --  Generate:\n-                  --    <Comp_Typ>Invariant (T (_object).<Comp_Id>);\n-\n-                  --  Note that the invariant procedure may have a null body if\n-                  --  assertions are disabled or Assertion_Policy Ignore is in\n-                  --  effect.\n-\n-                  if not Has_Null_Body (Proc_Id) then\n-                     Append_New_To (Comp_Checks,\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name                   =>\n-                           New_Occurrence_Of (Proc_Id, Loc),\n-                         Parameter_Associations => New_List (\n-                           Make_Selected_Component (Loc,\n-                             Prefix        =>\n-                               Unchecked_Convert_To\n-                                 (T, New_Occurrence_Of (Obj_Id, Loc)),\n-                             Selector_Name =>\n-                               New_Occurrence_Of (Comp_Id, Loc)))));\n-                  end if;\n-               end if;\n-\n-               Produced_Check           := True;\n-               Produced_Component_Check := True;\n-            end if;\n-\n-            if Produced_Component_Check and then Has_Unchecked_Union (T) then\n-               Error_Msg_NE\n-                 (\"invariants cannot be checked on components of \"\n-                  & \"unchecked_union type &?\", Comp_Id, T);\n-            end if;\n-         end Process_Record_Component;\n-\n-         --  Local variables\n-\n-         Comps : Node_Id;\n-         Def   : Node_Id;\n-\n-      --  Start of processing for Add_Record_Component_Invariants\n-\n-      begin\n-         --  An untagged derived type inherits the components of its parent\n-         --  type. In order to avoid creating redundant invariant checks, do\n-         --  not process the components now. Instead wait until the ultimate\n-         --  parent of the untagged derivation chain is reached.\n-\n-         if not Is_Untagged_Derivation (T) then\n-            Def := Type_Definition (Parent (T));\n-\n-            if Nkind (Def) = N_Derived_Type_Definition then\n-               Def := Record_Extension_Part (Def);\n-            end if;\n-\n-            pragma Assert (Nkind (Def) = N_Record_Definition);\n-            Comps := Component_List (Def);\n-\n-            if Present (Comps) then\n-               Process_Component_List\n-                 (Comp_List => Comps,\n-                  CL_Checks => Checks);\n-            end if;\n-         end if;\n-      end Add_Record_Component_Invariants;\n-\n-      -------------------------\n-      -- Add_Type_Invariants --\n-      -------------------------\n-\n-      procedure Add_Type_Invariants\n-        (Priv_Typ  : Entity_Id;\n-         Full_Typ  : Entity_Id;\n-         CRec_Typ  : Entity_Id;\n-         Obj_Id    : Entity_Id;\n-         Checks    : in out List_Id;\n-         Inherit   : Boolean := False;\n-         Priv_Item : Node_Id := Empty)\n-      is\n-         procedure Add_Invariant (Prag : Node_Id);\n-         --  Create a runtime check to verify the invariant exression of pragma\n-         --  Prag. All generated code is added to list Checks.\n-\n-         procedure Process_Type (T : Entity_Id; Stop_Item : Node_Id := Empty);\n-         --  Generate invariant checks for type T by inspecting the rep item\n-         --  chain of the type. Stop_Item denotes a rep item which once seen\n-         --  will stop the inspection.\n-\n-         -------------------\n-         -- Add_Invariant --\n-         -------------------\n-\n-         procedure Add_Invariant (Prag : Node_Id) is\n-            Rep_Typ : Entity_Id;\n-            --  The replacement type used in the substitution of the current\n-            --  instance of a type with the _object formal parameter.\n-\n-            procedure Replace_Type_Ref (N : Node_Id);\n-            --  Substitute the occurrence of a type name denoted by N with a\n-            --  reference to the _object formal parameter.\n-\n-            ----------------------\n-            -- Replace_Type_Ref --\n-            ----------------------\n-\n-            procedure Replace_Type_Ref (N : Node_Id) is\n-               Nloc : constant Source_Ptr := Sloc (N);\n-               Ref  : Node_Id;\n-\n-            begin\n-               --  Decorate the reference to Ref_Typ even though it may be\n-               --  rewritten further down. This is done for two reasons:\n-\n-               --    1) ASIS has all necessary semantic information in the\n-               --    original tree.\n-\n-               --    2) Routines which examine properties of the Original_Node\n-               --    have some semantic information.\n-\n-               if Nkind (N) = N_Identifier then\n-                  Set_Entity (N, Rep_Typ);\n-                  Set_Etype  (N, Rep_Typ);\n-\n-               elsif Nkind (N) = N_Selected_Component then\n-                  Analyze (Prefix (N));\n-                  Set_Entity (Selector_Name (N), Rep_Typ);\n-                  Set_Etype  (Selector_Name (N), Rep_Typ);\n-               end if;\n-\n-               --  Perform the following substitution:\n-\n-               --    Ref_Typ  -->  _object\n-\n-               Ref := Make_Identifier (Nloc, Chars (Obj_Id));\n-               Set_Entity (Ref, Obj_Id);\n-               Set_Etype  (Ref, Rep_Typ);\n-\n-               --  When the pragma denotes a class-wide invariant, perform the\n-               --  following substitution:\n-\n-               --    Rep_Typ  -->  Rep_Typ'Class (_object)\n-\n-               if Class_Present (Prag) then\n-                  Ref :=\n-                    Make_Type_Conversion (Nloc,\n-                      Subtype_Mark =>\n-                        Make_Attribute_Reference (Nloc,\n-                          Prefix         =>\n-                            New_Occurrence_Of (Rep_Typ, Nloc),\n-                          Attribute_Name => Name_Class),\n-                      Expression   => Ref);\n-               end if;\n-\n-               Rewrite (N, Ref);\n-               Set_Comes_From_Source (N, True);\n-            end Replace_Type_Ref;\n-\n-            procedure Replace_Type_Refs is\n-              new Replace_Type_References_Generic (Replace_Type_Ref);\n-\n-            --  Local variables\n-\n-            Asp  : constant Node_Id    := Corresponding_Aspect (Prag);\n-            Nam  : constant Name_Id    := Original_Aspect_Pragma_Name (Prag);\n-            Ploc : constant Source_Ptr := Sloc (Prag);\n-\n-            Arg1      : Node_Id;\n-            Arg2      : Node_Id;\n-            Arg3      : Node_Id;\n-            ASIS_Expr : Node_Id;\n-            Assoc     : List_Id;\n-            Expr      : Node_Id;\n-            Str       : String_Id;\n-\n-         --  Start of processing for Add_Invariant\n-\n-         begin\n-            --  Nothing to do if the pragma was already processed\n-\n-            if Contains (Pragmas_Seen, Prag) then\n-               return;\n-            end if;\n-\n-            --  Extract the arguments of the invariant pragma\n-\n-            Arg1 := First (Pragma_Argument_Associations (Prag));\n-            Arg2 := Next (Arg1);\n-            Arg3 := Next (Arg2);\n-\n-            Arg1 := Get_Pragma_Arg (Arg1);\n-            Arg2 := Get_Pragma_Arg (Arg2);\n-\n-            --  The pragma applies to the partial view\n-\n-            if Present (Priv_Typ) and then Entity (Arg1) = Priv_Typ then\n-               Rep_Typ := Priv_Typ;\n-\n-            --  The pragma applies to the full view\n-\n-            elsif Present (Full_Typ) and then Entity (Arg1) = Full_Typ then\n-               Rep_Typ := Full_Typ;\n-\n-            --  Otherwise the pragma applies to a parent type in which case it\n-            --  will be processed at a later stage by Add_Parent_Invariants or\n-            --  Add_Interface_Invariants.\n-\n-            else\n-               return;\n-            end if;\n-\n-            --  Nothing to do when the caller requests the processing of all\n-            --  inherited class-wide invariants, but the pragma does not fall\n-            --  in this category.\n-\n-            if Inherit and then not Class_Present (Prag) then\n-               return;\n-            end if;\n-\n-            Expr := New_Copy_Tree (Arg2);\n-\n-            --  Substitute all references to type Rep_Typ with references to\n-            --  the _object formal parameter.\n-\n-            Replace_Type_Refs (Expr, Rep_Typ);\n-\n-            --  Additional processing for non-class-wide invariants\n-\n-            if not Inherit then\n-\n-               --  Preanalyze the invariant expression to detect errors and at\n-               --  the same time capture the visibility of the proper package\n-               --  part.\n-\n-               --  Historical note: the old implementation of invariants used\n-               --  node N as the parent, but a package specification as parent\n-               --  of an expression is bizarre.\n-\n-               Set_Parent (Expr, Parent (Arg2));\n-               Preanalyze_Assert_Expression (Expr, Any_Boolean);\n-\n-               --  If the pragma comes from an aspect specification, replace\n-               --  the saved expression because all type references must be\n-               --  substituted for the call to Preanalyze_Spec_Expression in\n-               --  Check_Aspect_At_xxx routines.\n-\n-               if Present (Asp) then\n-                  Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n-               end if;\n-\n-               --  Analyze the original invariant expression for ASIS\n-\n-               if ASIS_Mode then\n-                  ASIS_Expr := Empty;\n-\n-                  if Comes_From_Source (Prag) then\n-                     ASIS_Expr := Arg2;\n-                  elsif Present (Asp) then\n-                     ASIS_Expr := Expression (Asp);\n-                  end if;\n-\n-                  if Present (ASIS_Expr) then\n-                     Replace_Type_Refs (ASIS_Expr, Rep_Typ);\n-                     Preanalyze_Assert_Expression (ASIS_Expr, Any_Boolean);\n-                  end if;\n-               end if;\n-\n-               --  A class-wide invariant may be inherited in a separate unit,\n-               --  where the corresponding expression cannot be resolved by\n-               --  visibility, because it refers to a local function. Propagate\n-               --  semantic information to the original representation item, to\n-               --  be used when an invariant procedure for a derived type is\n-               --  constructed.\n-\n-               --  ??? Unclear how to handle class-wide invariants that are not\n-               --  function calls.\n-\n-               if Class_Present (Prag)\n-                 and then Nkind (Expr) = N_Function_Call\n-                 and then Nkind (Arg2) = N_Indexed_Component\n-               then\n-                  Rewrite (Arg2,\n-                    Make_Function_Call (Ploc,\n-                      Name                   =>\n-                        New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n-                      Parameter_Associations => Expressions (Arg2)));\n-               end if;\n-            end if;\n-\n-            --  The invariant is ignored, nothing left to do\n-\n-            if Is_Ignored (Prag) then\n-               null;\n-\n-            --  Otherwise the invariant is checked. Build a Check pragma to\n-            --  verify the expression at runtime.\n-\n-            else\n-               Assoc := New_List (\n-                 Make_Pragma_Argument_Association (Ploc,\n-                   Expression => Make_Identifier (Ploc, Nam)),\n-                 Make_Pragma_Argument_Association (Ploc,\n-                   Expression => Expr));\n-\n-               --  Handle the String argument (if any)\n-\n-               if Present (Arg3) then\n-                  Str := Strval (Get_Pragma_Arg (Arg3));\n-\n-                  --  When inheriting an invariant, modify the message from\n-                  --  \"failed invariant\" to \"failed inherited invariant\".\n-\n-                  if Inherit then\n-                     String_To_Name_Buffer (Str);\n-\n-                     if Name_Buffer (1 .. 16) = \"failed invariant\" then\n-                        Insert_Str_In_Name_Buffer (\"inherited \", 8);\n-                        Str := String_From_Name_Buffer;\n-                     end if;\n-                  end if;\n-\n-                  Append_To (Assoc,\n-                    Make_Pragma_Argument_Association (Ploc,\n-                      Expression => Make_String_Literal (Ploc, Str)));\n-               end if;\n-\n-               --  Generate:\n-               --    pragma Check (<Nam>, <Expr>, <Str>);\n-\n-               Append_New_To (Checks,\n-                 Make_Pragma (Ploc,\n-                   Chars                        => Name_Check,\n-                   Pragma_Argument_Associations => Assoc));\n-            end if;\n-\n-            --  Output an info message when inheriting an invariant and the\n-            --  listing option is enabled.\n-\n-            if Inherit and Opt.List_Inherited_Aspects then\n-               Error_Msg_Sloc := Sloc (Prag);\n-               Error_Msg_N\n-                 (\"info: & inherits `Invariant''Class` aspect from #?L?\", Typ);\n-            end if;\n-\n-            --  Add the pragma to the list of processed pragmas\n-\n-            Append_New_Elmt (Prag, Pragmas_Seen);\n-            Produced_Check := True;\n-         end Add_Invariant;\n-\n-         ------------------\n-         -- Process_Type --\n-         ------------------\n-\n-         procedure Process_Type\n-           (T         : Entity_Id;\n-            Stop_Item : Node_Id := Empty)\n-         is\n-            Rep_Item : Node_Id;\n-\n-         begin\n-            Rep_Item := First_Rep_Item (T);\n-            while Present (Rep_Item) loop\n-               if Nkind (Rep_Item) = N_Pragma\n-                 and then Pragma_Name (Rep_Item) = Name_Invariant\n-               then\n-                  --  Stop the traversal of the rep item chain once a specific\n-                  --  item is encountered.\n-\n-                  if Present (Stop_Item) and then Rep_Item = Stop_Item then\n-                     exit;\n-\n-                  --  Otherwise generate an invariant check\n-\n-                  else\n-                     Add_Invariant (Rep_Item);\n-                  end if;\n-               end if;\n-\n-               Next_Rep_Item (Rep_Item);\n-            end loop;\n-         end Process_Type;\n-\n-      --  Start of processing for Add_Type_Invariants\n-\n-      begin\n-         --  Process the invariants of the partial view\n-\n-         if Present (Priv_Typ) then\n-            Process_Type (Priv_Typ);\n-         end if;\n-\n-         --  Process the invariants of the full view\n-\n-         if Present (Full_Typ) then\n-            Process_Type (Full_Typ, Stop_Item => Priv_Item);\n-\n-            --  Process the elements of an array type\n-\n-            if Is_Array_Type (Full_Typ) then\n-               Add_Array_Component_Invariants (Full_Typ, Obj_Id, Checks);\n-\n-            --  Process the components of a record type\n-\n-            elsif Ekind (Full_Typ) = E_Record_Type then\n-               Add_Record_Component_Invariants (Full_Typ, Obj_Id, Checks);\n-            end if;\n-         end if;\n-\n-         --  Process the components of a corresponding record type\n-\n-         if Present (CRec_Typ) then\n-            Add_Record_Component_Invariants (CRec_Typ, Obj_Id, Checks);\n-         end if;\n-      end Add_Type_Invariants;\n-\n-      ------------------------------------\n-      -- Is_Untagged_Private_Derivation --\n-      ------------------------------------\n-\n-      function Is_Untagged_Private_Derivation\n-        (Priv_Typ : Entity_Id;\n-         Full_Typ : Entity_Id) return Boolean\n-      is\n-      begin\n-         return\n-           Present (Priv_Typ)\n-             and then Is_Untagged_Derivation (Priv_Typ)\n-             and then Is_Private_Type (Etype (Priv_Typ))\n-             and then Present (Full_Typ)\n-             and then Is_Itype (Full_Typ);\n-      end Is_Untagged_Private_Derivation;\n-\n-      --  Local variables\n-\n-      Dummy        : Entity_Id;\n-      Mode         : Ghost_Mode_Type;\n-      Priv_Item    : Node_Id;\n-      Proc_Body    : Node_Id;\n-      Proc_Body_Id : Entity_Id;\n-      Proc_Decl    : Node_Id;\n-      Proc_Id      : Entity_Id;\n-      Stmts        : List_Id := No_List;\n-\n-      CRec_Typ : Entity_Id;\n-      --  The corresponding record type of Full_Typ\n-\n-      Full_Proc : Entity_Id;\n-      --  The entity of the \"full\" invariant procedure\n-\n-      Full_Typ : Entity_Id;\n-      --  The full view of the working type\n-\n-      Obj_Id : Entity_Id;\n-      --  The _object formal parameter of the invariant procedure\n-\n-      Part_Proc : Entity_Id;\n-      --  The entity of the \"partial\" invariant procedure\n-\n-      Priv_Typ : Entity_Id;\n-      --  The partial view of the working type\n-\n-      Work_Typ : Entity_Id;\n-      --  The working type\n-\n-   --  Start of processing for Build_Invariant_Procedure_Body\n-\n-   begin\n-      Work_Typ := Typ;\n-\n-      --  The input type denotes the implementation base type of a constrained\n-      --  array type. Work with the first subtype as all invariant pragmas are\n-      --  on its rep item chain.\n-\n-      if Ekind (Work_Typ) = E_Array_Type and then Is_Itype (Work_Typ) then\n-         Work_Typ := First_Subtype (Work_Typ);\n-\n-      --  The input type denotes the corresponding record type of a protected\n-      --  or task type. Work with the concurrent type because the corresponding\n-      --  record type may not be visible to clients of the type.\n-\n-      elsif Ekind (Work_Typ) = E_Record_Type\n-        and then Is_Concurrent_Record_Type (Work_Typ)\n-      then\n-         Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n-      end if;\n-\n-      --  The working type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the invariant procedure is properly marked as Ghost.\n-\n-      Set_Ghost_Mode (Work_Typ, Mode);\n-\n-      --  The type must either have invariants of its own, inherit class-wide\n-      --  invariants from parent types or interfaces, or be an array or record\n-      --  type whose components have invariants.\n-\n-      pragma Assert (Has_Invariants (Work_Typ));\n-\n-      --  Nothing to do for interface types as their class-wide invariants are\n-      --  inherited by implementing types.\n-\n-      if Is_Interface (Work_Typ) then\n-         goto Leave;\n-      end if;\n-\n-      --  Obtain both views of the type\n-\n-      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Dummy, CRec_Typ);\n-\n-      --  The caller requests a body for the partial invariant procedure\n-\n-      if Partial_Invariant then\n-         Full_Proc := Invariant_Procedure (Work_Typ);\n-         Proc_Id   := Partial_Invariant_Procedure (Work_Typ);\n-\n-         --  The \"full\" invariant procedure body was already created\n-\n-         if Present (Full_Proc)\n-           and then Present\n-                      (Corresponding_Body (Unit_Declaration_Node (Full_Proc)))\n-         then\n-            --  This scenario happens only when the type is an untagged\n-            --  derivation from a private parent and the underlying full\n-            --  view was processed before the partial view.\n-\n-            pragma Assert\n-              (Is_Untagged_Private_Derivation (Priv_Typ, Full_Typ));\n-\n-            --  Nothing to do because the processing of the underlying full\n-            --  view already checked the invariants of the partial view.\n-\n-            goto Leave;\n-         end if;\n-\n-         --  Create a declaration for the \"partial\" invariant procedure if it\n-         --  is not available.\n-\n-         if No (Proc_Id) then\n-            Build_Invariant_Procedure_Declaration\n-              (Typ               => Work_Typ,\n-               Partial_Invariant => True);\n-\n-            Proc_Id := Partial_Invariant_Procedure (Work_Typ);\n-         end if;\n-\n-      --  The caller requests a body for the \"full\" invariant procedure\n-\n-      else\n-         Proc_Id   := Invariant_Procedure (Work_Typ);\n-         Part_Proc := Partial_Invariant_Procedure (Work_Typ);\n-\n-         --  Create a declaration for the \"full\" invariant procedure if it is\n-         --  not available.\n-\n-         if No (Proc_Id) then\n-            Build_Invariant_Procedure_Declaration (Work_Typ);\n-            Proc_Id := Invariant_Procedure (Work_Typ);\n-         end if;\n-      end if;\n-\n-      --  At this point there should be an invariant procedure declaration\n-\n-      pragma Assert (Present (Proc_Id));\n-      Proc_Decl := Unit_Declaration_Node (Proc_Id);\n-\n-      --  Nothing to do if the invariant procedure already has a body\n-\n-      if Present (Corresponding_Body (Proc_Decl)) then\n-         goto Leave;\n-      end if;\n-\n-      --  Emulate the environment of the invariant procedure by installing\n-      --  its scope and formal parameters. Note that this is not needed, but\n-      --  having the scope of the invariant procedure installed helps with\n-      --  the detection of invariant-related errors.\n-\n-      Push_Scope (Proc_Id);\n-      Install_Formals (Proc_Id);\n-\n-      Obj_Id := First_Formal (Proc_Id);\n-      pragma Assert (Present (Obj_Id));\n-\n-      --  The \"partial\" invariant procedure verifies the invariants of the\n-      --  partial view only.\n-\n-      if Partial_Invariant then\n-         pragma Assert (Present (Priv_Typ));\n-\n-         Add_Type_Invariants\n-           (Priv_Typ => Priv_Typ,\n-            Full_Typ => Empty,\n-            CRec_Typ => Empty,\n-            Obj_Id   => Obj_Id,\n-            Checks   => Stmts);\n-\n-      --  Otherwise the \"full\" invariant procedure verifies the invariants of\n-      --  the full view, all array or record components, as well as class-wide\n-      --  invariants inherited from parent types or interfaces. In addition, it\n-      --  indirectly verifies the invariants of the partial view by calling the\n-      --  \"partial\" invariant procedure.\n-\n-      else\n-         pragma Assert (Present (Full_Typ));\n-\n-         --  Check the invariants of the partial view by calling the \"partial\"\n-         --  invariant procedure. Generate:\n-\n-         --    <Work_Typ>Partial_Invariant (_object);\n-\n-         if Present (Part_Proc) then\n-            Append_New_To (Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   => New_Occurrence_Of (Part_Proc, Loc),\n-                Parameter_Associations => New_List (\n-                  New_Occurrence_Of (Obj_Id, Loc))));\n-\n-            Produced_Check := True;\n-         end if;\n-\n-         Priv_Item := Empty;\n-\n-         --  Derived subtypes do not have a partial view\n-\n-         if Present (Priv_Typ) then\n-\n-            --  The processing of the \"full\" invariant procedure intentionally\n-            --  skips the partial view because a) this may result in changes of\n-            --  visibility and b) lead to duplicate checks. However, when the\n-            --  full view is the underlying full view of an untagged derived\n-            --  type whose parent type is private, partial invariants appear on\n-            --  the rep item chain of the partial view only.\n-\n-            --    package Pack_1 is\n-            --       type Root ... is private;\n-            --    private\n-            --       <full view of Root>\n-            --    end Pack_1;\n-\n-            --    with Pack_1;\n-            --    package Pack_2 is\n-            --       type Child is new Pack_1.Root with Type_Invariant => ...;\n-            --       <underlying full view of Child>\n-            --    end Pack_2;\n-\n-            --  As a result, the processing of the full view must also consider\n-            --  all invariants of the partial view.\n-\n-            if Is_Untagged_Private_Derivation (Priv_Typ, Full_Typ) then\n-               null;\n-\n-            --  Otherwise the invariants of the partial view are ignored\n-\n-            else\n-               --  Note that the rep item chain is shared between the partial\n-               --  and full views of a type. To avoid processing the invariants\n-               --  of the partial view, signal the logic to stop when the first\n-               --  rep item of the partial view has been reached.\n-\n-               Priv_Item := First_Rep_Item (Priv_Typ);\n-\n-               --  Ignore the invariants of the partial view by eliminating the\n-               --  view.\n-\n-               Priv_Typ := Empty;\n-            end if;\n-         end if;\n-\n-         --  Process the invariants of the full view and in certain cases those\n-         --  of the partial view. This also handles any invariants on array or\n-         --  record components.\n-\n-         Add_Type_Invariants\n-           (Priv_Typ  => Priv_Typ,\n-            Full_Typ  => Full_Typ,\n-            CRec_Typ  => CRec_Typ,\n-            Obj_Id    => Obj_Id,\n-            Checks    => Stmts,\n-            Priv_Item => Priv_Item);\n-\n-         --  Process the inherited class-wide invariants of all parent types.\n-         --  This also handles any invariants on record components.\n-\n-         Add_Parent_Invariants (Full_Typ, Obj_Id, Stmts);\n-\n-         --  Process the inherited class-wide invariants of all implemented\n-         --  interface types.\n-\n-         Add_Interface_Invariants (Full_Typ, Obj_Id, Stmts);\n-      end if;\n-\n-      End_Scope;\n-\n-      --  At this point there should be at least one invariant check. If this\n-      --  is not the case, then the invariant-related flags were not properly\n-      --  set, or there is a missing invariant procedure on one of the array\n-      --  or record components.\n-\n-      pragma Assert (Produced_Check);\n-\n-      --  Account for the case where assertions are disabled or all invariant\n-      --  checks are subject to Assertion_Policy Ignore. Produce a completing\n-      --  empty body.\n-\n-      if No (Stmts) then\n-         Stmts := New_List (Make_Null_Statement (Loc));\n-      end if;\n-\n-      --  Generate:\n-      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>) is\n-      --    begin\n-      --       <Stmts>\n-      --    end <Work_Typ>[Partial_]Invariant;\n-\n-      Proc_Body :=\n-        Make_Subprogram_Body (Loc,\n-          Specification                =>\n-            Copy_Subprogram_Spec (Parent (Proc_Id)),\n-          Declarations                 => Empty_List,\n-            Handled_Statement_Sequence =>\n-              Make_Handled_Sequence_Of_Statements (Loc,\n-                Statements => Stmts));\n-      Proc_Body_Id := Defining_Entity (Proc_Body);\n-\n-      --  Perform minor decoration in case the body is not analyzed\n-\n-      Set_Ekind (Proc_Body_Id, E_Subprogram_Body);\n-      Set_Etype (Proc_Body_Id, Standard_Void_Type);\n-      Set_Scope (Proc_Body_Id, Current_Scope);\n-\n-      --  Link both spec and body to avoid generating duplicates\n-\n-      Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n-      Set_Corresponding_Spec (Proc_Body, Proc_Id);\n-\n-      --  The body should not be inserted into the tree when the context is\n-      --  ASIS or a generic unit because it is not part of the template. Note\n-      --  that the body must still be generated in order to resolve the\n-      --  invariants.\n-\n-      if ASIS_Mode or Inside_A_Generic then\n-         null;\n-\n-      --  Semi-insert the body into the tree for GNATprove by setting its\n-      --  Parent field. This allows for proper upstream tree traversals.\n-\n-      elsif GNATprove_Mode then\n-         Set_Parent (Proc_Body, Parent (Declaration_Node (Work_Typ)));\n-\n-      --  Otherwise the body is part of the freezing actions of the type\n-\n-      else\n-         Append_Freeze_Action (Work_Typ, Proc_Body);\n-      end if;\n-\n-   <<Leave>>\n-      Restore_Ghost_Mode (Mode);\n-   end Build_Invariant_Procedure_Body;\n-\n-   -------------------------------------------\n-   -- Build_Invariant_Procedure_Declaration --\n-   -------------------------------------------\n-\n-   --  WARNING: This routine manages Ghost regions. Return statements must be\n-   --  replaced by gotos which jump to the end of the routine and restore the\n-   --  Ghost mode.\n-\n-   procedure Build_Invariant_Procedure_Declaration\n-     (Typ               : Entity_Id;\n-      Partial_Invariant : Boolean := False)\n-   is\n-      Loc : constant Source_Ptr := Sloc (Typ);\n-\n-      Mode      : Ghost_Mode_Type;\n-      Proc_Decl : Node_Id;\n-      Proc_Id   : Entity_Id;\n-      Proc_Nam  : Name_Id;\n-      Typ_Decl  : Node_Id;\n-\n-      CRec_Typ : Entity_Id;\n-      --  The corresponding record type of Full_Typ\n-\n-      Full_Base : Entity_Id;\n-      --  The base type of Full_Typ\n-\n-      Full_Typ : Entity_Id;\n-      --  The full view of working type\n-\n-      Obj_Id : Entity_Id;\n-      --  The _object formal parameter of the invariant procedure\n-\n-      Priv_Typ : Entity_Id;\n-      --  The partial view of working type\n-\n-      Work_Typ : Entity_Id;\n-      --  The working type\n-\n-   begin\n-      Work_Typ := Typ;\n-\n-      --  The input type denotes the implementation base type of a constrained\n-      --  array type. Work with the first subtype as all invariant pragmas are\n-      --  on its rep item chain.\n-\n-      if Ekind (Work_Typ) = E_Array_Type and then Is_Itype (Work_Typ) then\n-         Work_Typ := First_Subtype (Work_Typ);\n-\n-      --  The input denotes the corresponding record type of a protected or a\n-      --  task type. Work with the concurrent type because the corresponding\n-      --  record type may not be visible to clients of the type.\n-\n-      elsif Ekind (Work_Typ) = E_Record_Type\n-        and then Is_Concurrent_Record_Type (Work_Typ)\n-      then\n-         Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n-      end if;\n-\n-      --  The working type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the invariant procedure is properly marked as Ghost.\n-\n-      Set_Ghost_Mode (Work_Typ, Mode);\n-\n-      --  The type must either have invariants of its own, inherit class-wide\n-      --  invariants from parent or interface types, or be an array or record\n-      --  type whose components have invariants.\n-\n-      pragma Assert (Has_Invariants (Work_Typ));\n-\n-      --  Nothing to do for interface types as their class-wide invariants are\n-      --  inherited by implementing types.\n-\n-      if Is_Interface (Work_Typ) then\n-         goto Leave;\n-\n-      --  Nothing to do if the type already has a \"partial\" invariant procedure\n-\n-      elsif Partial_Invariant then\n-         if Present (Partial_Invariant_Procedure (Work_Typ)) then\n-            goto Leave;\n-         end if;\n-\n-      --  Nothing to do if the type already has a \"full\" invariant procedure\n-\n-      elsif Present (Invariant_Procedure (Work_Typ)) then\n-         goto Leave;\n-      end if;\n-\n-      --  The caller requests the declaration of the \"partial\" invariant\n-      --  procedure.\n-\n-      if Partial_Invariant then\n-         Proc_Nam := New_External_Name (Chars (Work_Typ), \"Partial_Invariant\");\n-\n-      --  Otherwise the caller requests the declaration of the \"full\" invariant\n-      --  procedure.\n-\n-      else\n-         Proc_Nam := New_External_Name (Chars (Work_Typ), \"Invariant\");\n-      end if;\n-\n-      Proc_Id := Make_Defining_Identifier (Loc, Chars => Proc_Nam);\n-\n-      --  Perform minor decoration in case the declaration is not analyzed\n-\n-      Set_Ekind (Proc_Id, E_Procedure);\n-      Set_Etype (Proc_Id, Standard_Void_Type);\n-      Set_Scope (Proc_Id, Current_Scope);\n-\n-      if Partial_Invariant then\n-         Set_Is_Partial_Invariant_Procedure (Proc_Id);\n-         Set_Partial_Invariant_Procedure (Work_Typ, Proc_Id);\n-      else\n-         Set_Is_Invariant_Procedure (Proc_Id);\n-         Set_Invariant_Procedure (Work_Typ, Proc_Id);\n-      end if;\n-\n-      --  The invariant procedure requires debug info when the invariants are\n-      --  subject to Source Coverage Obligations.\n-\n-      if Opt.Generate_SCO then\n-         Set_Needs_Debug_Info (Proc_Id);\n-      end if;\n-\n-      --  Obtain all views of the input type\n-\n-      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Full_Base, CRec_Typ);\n-\n-      --  Associate the invariant procedure with all views\n-\n-      Propagate_Invariant_Attributes (Priv_Typ,  From_Typ => Work_Typ);\n-      Propagate_Invariant_Attributes (Full_Typ,  From_Typ => Work_Typ);\n-      Propagate_Invariant_Attributes (Full_Base, From_Typ => Work_Typ);\n-      Propagate_Invariant_Attributes (CRec_Typ,  From_Typ => Work_Typ);\n-\n-      --  The declaration of the invariant procedure is inserted after the\n-      --  declaration of the partial view as this allows for proper external\n-      --  visibility.\n-\n-      if Present (Priv_Typ) then\n-         Typ_Decl := Declaration_Node (Priv_Typ);\n-\n-      --  Derived types with the full view as parent do not have a partial\n-      --  view. Insert the invariant procedure after the derived type.\n-\n-      else\n-         Typ_Decl := Declaration_Node (Full_Typ);\n-      end if;\n-\n-      --  The type should have a declarative node\n-\n-      pragma Assert (Present (Typ_Decl));\n-\n-      --  Create the formal parameter which emulates the variable-like behavior\n-      --  of the current type instance.\n-\n-      Obj_Id := Make_Defining_Identifier (Loc, Chars => Name_uObject);\n-\n-      --  Perform minor decoration in case the declaration is not analyzed\n-\n-      Set_Ekind (Obj_Id, E_In_Parameter);\n-      Set_Etype (Obj_Id, Work_Typ);\n-      Set_Scope (Obj_Id, Proc_Id);\n-\n-      Set_First_Entity (Proc_Id, Obj_Id);\n-\n-      --  Generate:\n-      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>);\n-\n-      Proc_Decl :=\n-        Make_Subprogram_Declaration (Loc,\n-          Specification =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name       => Proc_Id,\n-              Parameter_Specifications => New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier => Obj_Id,\n-                  Parameter_Type      =>\n-                    New_Occurrence_Of (Work_Typ, Loc)))));\n-\n-      --  The declaration should not be inserted into the tree when the context\n-      --  is ASIS or a generic unit because it is not part of the template.\n-\n-      if ASIS_Mode or Inside_A_Generic then\n-         null;\n-\n-      --  Semi-insert the declaration into the tree for GNATprove by setting\n-      --  its Parent field. This allows for proper upstream tree traversals.\n-\n-      elsif GNATprove_Mode then\n-         Set_Parent (Proc_Decl, Parent (Typ_Decl));\n-\n-      --  Otherwise insert the declaration\n-\n-      else\n-         pragma Assert (Present (Typ_Decl));\n-         Insert_After_And_Analyze (Typ_Decl, Proc_Decl);\n-      end if;\n-\n-   <<Leave>>\n-      Restore_Ghost_Mode (Mode);\n-   end Build_Invariant_Procedure_Declaration;\n-\n    ---------------------\n    -- Build_Late_Proc --\n    ---------------------"}, {"sha": "b0a8b0b8b8b8f42b635948d3361229f40db33fcb", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=51148ddab1495aa357e57f1c209940f7cde571c1", "patch": "@@ -118,21 +118,6 @@ package Exp_Ch7 is\n    --  finalization master must be analyzed. Insertion_Node is the insertion\n    --  point before which the master is to be inserted.\n \n-   procedure Build_Invariant_Procedure_Body\n-     (Typ               : Entity_Id;\n-      Partial_Invariant : Boolean := False);\n-   --  Create the body of the procedure which verifies the invariants of type\n-   --  Typ at runtime. Flag Partial_Invariant should be set when Typ denotes a\n-   --  private type, otherwise it is assumed that Typ denotes the full view of\n-   --  a private type.\n-\n-   procedure Build_Invariant_Procedure_Declaration\n-     (Typ               : Entity_Id;\n-      Partial_Invariant : Boolean := False);\n-   --  Create the declaration of the procedure which verifies the invariants of\n-   --  type Typ at runtime. Flag Partial_Invariant should be set when building\n-   --  the invariant procedure for a private type.\n-\n    procedure Build_Late_Proc (Typ : Entity_Id; Nam : Name_Id);\n    --  Build one controlling procedure when a late body overrides one of the\n    --  controlling operations."}, {"sha": "bb36ce99643ca49c39e8ad1daffaaf7a0f4573e2", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1420, "deletions": 5, "changes": 1425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=51148ddab1495aa357e57f1c209940f7cde571c1", "patch": "@@ -1949,6 +1949,1383 @@ package body Exp_Util is\n       Restore_Ghost_Mode (Mode);\n    end Build_DIC_Procedure_Declaration;\n \n+   ------------------------------------\n+   -- Build_Invariant_Procedure_Body --\n+   ------------------------------------\n+\n+   --  WARNING: This routine manages Ghost regions. Return statements must be\n+   --  replaced by gotos which jump to the end of the routine and restore the\n+   --  Ghost mode.\n+\n+   procedure Build_Invariant_Procedure_Body\n+     (Typ               : Entity_Id;\n+      Partial_Invariant : Boolean := False)\n+   is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+      Pragmas_Seen : Elist_Id := No_Elist;\n+      --  This list contains all invariant pragmas processed so far. The list\n+      --  is used to avoid generating redundant invariant checks.\n+\n+      Produced_Check : Boolean := False;\n+      --  This flag tracks whether the type has produced at least one invariant\n+      --  check. The flag is used as a sanity check at the end of the routine.\n+\n+      --  NOTE: most of the routines in Build_Invariant_Procedure_Body are\n+      --  intentionally unnested to avoid deep indentation of code.\n+\n+      --  NOTE: all Add_xxx_Invariants routines are reactive. In other words\n+      --  they emit checks, loops (for arrays) and case statements (for record\n+      --  variant parts) only when there are invariants to verify. This keeps\n+      --  the body of the invariant procedure free from useless code.\n+\n+      procedure Add_Array_Component_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate an invariant check for each component of array type T.\n+      --  Obj_Id denotes the entity of the _object formal parameter of the\n+      --  invariant procedure. All created checks are added to list Checks.\n+\n+      procedure Add_Interface_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate an invariant check for each inherited class-wide invariant\n+      --  coming from all interfaces implemented by type T. Obj_Id denotes the\n+      --  entity of the _object formal parameter of the invariant procedure.\n+      --  All created checks are added to list Checks.\n+\n+      procedure Add_Parent_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate an invariant check for each inherited class-wide invariant\n+      --  coming from all parent types of type T. Obj_Id denotes the entity of\n+      --  the _object formal parameter of the invariant procedure. All created\n+      --  checks are added to list Checks.\n+\n+      procedure Add_Record_Component_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate an invariant check for each component of record type T.\n+      --  Obj_Id denotes the entity of the _object formal parameter of the\n+      --  invariant procedure. All created checks are added to list Checks.\n+\n+      procedure Add_Type_Invariants\n+        (Priv_Typ  : Entity_Id;\n+         Full_Typ  : Entity_Id;\n+         CRec_Typ  : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id;\n+         Inherit   : Boolean := False;\n+         Priv_Item : Node_Id := Empty);\n+      --  Generate an invariant check for each invariant found in one of the\n+      --  following types (if available):\n+      --\n+      --    Priv_Typ - the partial view of a type\n+      --    Full_Typ - the full view of a type\n+      --    CRec_Typ - the corresponding record of a protected or a task type\n+      --\n+      --  Obj_Id denotes the entity of the _object formal parameter of the\n+      --  invariant procedure. All created checks are added to list Checks.\n+      --  Flag Inherit should be set when generating invariant checks for\n+      --  inherited class-wide invariants. Priv_Item denotes the first rep\n+      --  item of the private type.\n+\n+      ------------------------------------\n+      -- Add_Array_Component_Invariants --\n+      ------------------------------------\n+\n+      procedure Add_Array_Component_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         Comp_Typ : constant Entity_Id := Component_Type (T);\n+         Dims     : constant Pos       := Number_Dimensions (T);\n+\n+         procedure Process_Array_Component\n+           (Indices     : List_Id;\n+            Comp_Checks : in out List_Id);\n+         --  Generate an invariant check for an array component identified by\n+         --  the indices in list Indices. All created checks are added to list\n+         --  Comp_Checks.\n+\n+         procedure Process_One_Dimension\n+           (Dim        : Pos;\n+            Indices    : List_Id;\n+            Dim_Checks : in out List_Id);\n+         --  Generate a loop over the Nth dimension Dim of an array type. List\n+         --  Indices contains all array indices for the dimension. All created\n+         --  checks are added to list Dim_Checks.\n+\n+         -----------------------------\n+         -- Process_Array_Component --\n+         -----------------------------\n+\n+         procedure Process_Array_Component\n+           (Indices     : List_Id;\n+            Comp_Checks : in out List_Id)\n+         is\n+            Proc_Id : Entity_Id;\n+\n+         begin\n+            if Has_Invariants (Comp_Typ) then\n+\n+               --  In GNATprove mode, the component invariants are checked by\n+               --  other means. They should not be added to the array type\n+               --  invariant procedure, so that the procedure can be used to\n+               --  check the array type invariants if any.\n+\n+               if GNATprove_Mode then\n+                  null;\n+\n+               else\n+                  Proc_Id := Invariant_Procedure (Base_Type (Comp_Typ));\n+\n+                  --  The component type should have an invariant procedure\n+                  --  if it has invariants of its own or inherits class-wide\n+                  --  invariants from parent or interface types.\n+\n+                  pragma Assert (Present (Proc_Id));\n+\n+                  --  Generate:\n+                  --    <Comp_Typ>Invariant (_object (<Indices>));\n+\n+                  --  Note that the invariant procedure may have a null body if\n+                  --  assertions are disabled or Assertion_Policy Ignore is in\n+                  --  effect.\n+\n+                  if not Has_Null_Body (Proc_Id) then\n+                     Append_New_To (Comp_Checks,\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name                   =>\n+                           New_Occurrence_Of (Proc_Id, Loc),\n+                         Parameter_Associations => New_List (\n+                           Make_Indexed_Component (Loc,\n+                             Prefix      => New_Occurrence_Of (Obj_Id, Loc),\n+                             Expressions => New_Copy_List (Indices)))));\n+                  end if;\n+               end if;\n+\n+               Produced_Check := True;\n+            end if;\n+         end Process_Array_Component;\n+\n+         ---------------------------\n+         -- Process_One_Dimension --\n+         ---------------------------\n+\n+         procedure Process_One_Dimension\n+           (Dim        : Pos;\n+            Indices    : List_Id;\n+            Dim_Checks : in out List_Id)\n+         is\n+            Comp_Checks : List_Id := No_List;\n+            Index       : Entity_Id;\n+\n+         begin\n+            --  Generate the invariant checks for the array component after all\n+            --  dimensions have produced their respective loops.\n+\n+            if Dim > Dims then\n+               Process_Array_Component\n+                 (Indices     => Indices,\n+                  Comp_Checks => Dim_Checks);\n+\n+            --  Otherwise create a loop for the current dimension\n+\n+            else\n+               --  Create a new loop variable for each dimension\n+\n+               Index :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name ('I', Dim));\n+               Append_To (Indices, New_Occurrence_Of (Index, Loc));\n+\n+               Process_One_Dimension\n+                 (Dim        => Dim + 1,\n+                  Indices    => Indices,\n+                  Dim_Checks => Comp_Checks);\n+\n+               --  Generate:\n+               --    for I<Dim> in _object'Range (<Dim>) loop\n+               --       <Comp_Checks>\n+               --    end loop;\n+\n+               --  Note that the invariant procedure may have a null body if\n+               --  assertions are disabled or Assertion_Policy Ignore is in\n+               --  effect.\n+\n+               if Present (Comp_Checks) then\n+                  Append_New_To (Dim_Checks,\n+                    Make_Implicit_Loop_Statement (T,\n+                      Identifier       => Empty,\n+                      Iteration_Scheme =>\n+                        Make_Iteration_Scheme (Loc,\n+                          Loop_Parameter_Specification =>\n+                            Make_Loop_Parameter_Specification (Loc,\n+                              Defining_Identifier         => Index,\n+                              Discrete_Subtype_Definition =>\n+                                Make_Attribute_Reference (Loc,\n+                                  Prefix         =>\n+                                    New_Occurrence_Of (Obj_Id, Loc),\n+                                  Attribute_Name => Name_Range,\n+                                  Expressions    => New_List (\n+                                    Make_Integer_Literal (Loc, Dim))))),\n+\n+                      Statements => Comp_Checks));\n+               end if;\n+            end if;\n+         end Process_One_Dimension;\n+\n+      --  Start of processing for Add_Array_Component_Invariants\n+\n+      begin\n+         Process_One_Dimension\n+           (Dim        => 1,\n+            Indices    => New_List,\n+            Dim_Checks => Checks);\n+      end Add_Array_Component_Invariants;\n+\n+      ------------------------------\n+      -- Add_Interface_Invariants --\n+      ------------------------------\n+\n+      procedure Add_Interface_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         Iface_Elmt : Elmt_Id;\n+         Ifaces     : Elist_Id;\n+\n+      begin\n+         if Is_Tagged_Type (T) then\n+            Collect_Interfaces (T, Ifaces);\n+\n+            --  Process the class-wide invariants of all implemented interfaces\n+\n+            Iface_Elmt := First_Elmt (Ifaces);\n+            while Present (Iface_Elmt) loop\n+               Add_Type_Invariants\n+                 (Priv_Typ => Empty,\n+                  Full_Typ => Node (Iface_Elmt),\n+                  CRec_Typ => Empty,\n+                  Obj_Id   => Obj_Id,\n+                  Checks   => Checks,\n+                  Inherit  => True);\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end if;\n+      end Add_Interface_Invariants;\n+\n+      ---------------------------\n+      -- Add_Parent_Invariants --\n+      ---------------------------\n+\n+      procedure Add_Parent_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         Dummy_1 : Entity_Id;\n+         Dummy_2 : Entity_Id;\n+\n+         Curr_Typ : Entity_Id;\n+         --  The entity of the current type being examined\n+\n+         Full_Typ : Entity_Id;\n+         --  The full view of Par_Typ\n+\n+         Par_Typ : Entity_Id;\n+         --  The entity of the parent type\n+\n+         Priv_Typ : Entity_Id;\n+         --  The partial view of Par_Typ\n+\n+      begin\n+         --  Do not process array types because they cannot have true parent\n+         --  types. This also prevents the generation of a duplicate invariant\n+         --  check when the input type is an array base type because its Etype\n+         --  denotes the first subtype, both of which share the same component\n+         --  type.\n+\n+         if Is_Array_Type (T) then\n+            return;\n+         end if;\n+\n+         --  Climb the parent type chain\n+\n+         Curr_Typ := T;\n+         loop\n+            --  Do not consider subtypes as they inherit the invariants from\n+            --  their base types.\n+\n+            Par_Typ := Base_Type (Etype (Curr_Typ));\n+\n+            --  Stop the climb once the root of the parent chain is reached\n+\n+            exit when Curr_Typ = Par_Typ;\n+\n+            --  Process the class-wide invariants of the parent type\n+\n+            Get_Views (Par_Typ, Priv_Typ, Full_Typ, Dummy_1, Dummy_2);\n+\n+            Add_Type_Invariants\n+              (Priv_Typ => Priv_Typ,\n+               Full_Typ => Full_Typ,\n+               CRec_Typ => Empty,\n+               Obj_Id   => Obj_Id,\n+               Checks   => Checks,\n+               Inherit  => True);\n+\n+            Curr_Typ := Par_Typ;\n+         end loop;\n+      end Add_Parent_Invariants;\n+\n+      -------------------------------------\n+      -- Add_Record_Component_Invariants --\n+      -------------------------------------\n+\n+      procedure Add_Record_Component_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         procedure Process_Component_List\n+           (Comp_List : Node_Id;\n+            CL_Checks : in out List_Id);\n+         --  Generate invariant checks for all record components found in\n+         --  component list Comp_List, including variant parts. All created\n+         --  checks are added to list CL_Checks.\n+\n+         procedure Process_Record_Component\n+           (Comp_Id     : Entity_Id;\n+            Comp_Checks : in out List_Id);\n+         --  Generate an invariant check for a record component identified by\n+         --  Comp_Id. All created checks are added to list Comp_Checks.\n+\n+         ----------------------------\n+         -- Process_Component_List --\n+         ----------------------------\n+\n+         procedure Process_Component_List\n+           (Comp_List : Node_Id;\n+            CL_Checks : in out List_Id)\n+         is\n+            Comp       : Node_Id;\n+            Var        : Node_Id;\n+            Var_Alts   : List_Id := No_List;\n+            Var_Checks : List_Id := No_List;\n+            Var_Stmts  : List_Id;\n+\n+            Produced_Variant_Check : Boolean := False;\n+            --  This flag tracks whether the component has produced at least\n+            --  one invariant check.\n+\n+         begin\n+            --  Traverse the component items\n+\n+            Comp := First (Component_Items (Comp_List));\n+            while Present (Comp) loop\n+               if Nkind (Comp) = N_Component_Declaration then\n+\n+                  --  Generate the component invariant check\n+\n+                  Process_Record_Component\n+                    (Comp_Id     => Defining_Entity (Comp),\n+                     Comp_Checks => CL_Checks);\n+               end if;\n+\n+               Next (Comp);\n+            end loop;\n+\n+            --  Traverse the variant part\n+\n+            if Present (Variant_Part (Comp_List)) then\n+               Var := First (Variants (Variant_Part (Comp_List)));\n+               while Present (Var) loop\n+                  Var_Checks := No_List;\n+\n+                  --  Generate invariant checks for all components and variant\n+                  --  parts that qualify.\n+\n+                  Process_Component_List\n+                    (Comp_List => Component_List (Var),\n+                     CL_Checks => Var_Checks);\n+\n+                  --  The components of the current variant produced at least\n+                  --  one invariant check.\n+\n+                  if Present (Var_Checks) then\n+                     Var_Stmts := Var_Checks;\n+                     Produced_Variant_Check := True;\n+\n+                  --  Otherwise there are either no components with invariants,\n+                  --  assertions are disabled, or Assertion_Policy Ignore is in\n+                  --  effect.\n+\n+                  else\n+                     Var_Stmts := New_List (Make_Null_Statement (Loc));\n+                  end if;\n+\n+                  Append_New_To (Var_Alts,\n+                    Make_Case_Statement_Alternative (Loc,\n+                      Discrete_Choices =>\n+                        New_Copy_List (Discrete_Choices (Var)),\n+                      Statements       => Var_Stmts));\n+\n+                  Next (Var);\n+               end loop;\n+\n+               --  Create a case statement which verifies the invariant checks\n+               --  of a particular component list depending on the discriminant\n+               --  values only when there is at least one real invariant check.\n+\n+               if Produced_Variant_Check then\n+                  Append_New_To (CL_Checks,\n+                    Make_Case_Statement (Loc,\n+                      Expression   =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+                          Selector_Name =>\n+                            New_Occurrence_Of\n+                              (Entity (Name (Variant_Part (Comp_List))), Loc)),\n+                      Alternatives => Var_Alts));\n+               end if;\n+            end if;\n+         end Process_Component_List;\n+\n+         ------------------------------\n+         -- Process_Record_Component --\n+         ------------------------------\n+\n+         procedure Process_Record_Component\n+           (Comp_Id     : Entity_Id;\n+            Comp_Checks : in out List_Id)\n+         is\n+            Comp_Typ : constant Entity_Id := Etype (Comp_Id);\n+            Proc_Id  : Entity_Id;\n+\n+            Produced_Component_Check : Boolean := False;\n+            --  This flag tracks whether the component has produced at least\n+            --  one invariant check.\n+\n+         begin\n+            --  Nothing to do for internal component _parent. Note that it is\n+            --  not desirable to check whether the component comes from source\n+            --  because protected type components are relocated to an internal\n+            --  corresponding record, but still need processing.\n+\n+            if Chars (Comp_Id) = Name_uParent then\n+               return;\n+            end if;\n+\n+            --  Verify the invariant of the component. Note that an access\n+            --  type may have an invariant when it acts as the full view of a\n+            --  private type and the invariant appears on the partial view. In\n+            --  this case verify the access value itself.\n+\n+            if Has_Invariants (Comp_Typ) then\n+\n+               --  In GNATprove mode, the component invariants are checked by\n+               --  other means. They should not be added to the record type\n+               --  invariant procedure, so that the procedure can be used to\n+               --  check the record type invariants if any.\n+\n+               if GNATprove_Mode then\n+                  null;\n+\n+               else\n+                  Proc_Id := Invariant_Procedure (Base_Type (Comp_Typ));\n+\n+                  --  The component type should have an invariant procedure\n+                  --  if it has invariants of its own or inherits class-wide\n+                  --  invariants from parent or interface types.\n+\n+                  pragma Assert (Present (Proc_Id));\n+\n+                  --  Generate:\n+                  --    <Comp_Typ>Invariant (T (_object).<Comp_Id>);\n+\n+                  --  Note that the invariant procedure may have a null body if\n+                  --  assertions are disabled or Assertion_Policy Ignore is in\n+                  --  effect.\n+\n+                  if not Has_Null_Body (Proc_Id) then\n+                     Append_New_To (Comp_Checks,\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name                   =>\n+                           New_Occurrence_Of (Proc_Id, Loc),\n+                         Parameter_Associations => New_List (\n+                           Make_Selected_Component (Loc,\n+                             Prefix        =>\n+                               Unchecked_Convert_To\n+                                 (T, New_Occurrence_Of (Obj_Id, Loc)),\n+                             Selector_Name =>\n+                               New_Occurrence_Of (Comp_Id, Loc)))));\n+                  end if;\n+               end if;\n+\n+               Produced_Check           := True;\n+               Produced_Component_Check := True;\n+            end if;\n+\n+            if Produced_Component_Check and then Has_Unchecked_Union (T) then\n+               Error_Msg_NE\n+                 (\"invariants cannot be checked on components of \"\n+                  & \"unchecked_union type &?\", Comp_Id, T);\n+            end if;\n+         end Process_Record_Component;\n+\n+         --  Local variables\n+\n+         Comps : Node_Id;\n+         Def   : Node_Id;\n+\n+      --  Start of processing for Add_Record_Component_Invariants\n+\n+      begin\n+         --  An untagged derived type inherits the components of its parent\n+         --  type. In order to avoid creating redundant invariant checks, do\n+         --  not process the components now. Instead wait until the ultimate\n+         --  parent of the untagged derivation chain is reached.\n+\n+         if not Is_Untagged_Derivation (T) then\n+            Def := Type_Definition (Parent (T));\n+\n+            if Nkind (Def) = N_Derived_Type_Definition then\n+               Def := Record_Extension_Part (Def);\n+            end if;\n+\n+            pragma Assert (Nkind (Def) = N_Record_Definition);\n+            Comps := Component_List (Def);\n+\n+            if Present (Comps) then\n+               Process_Component_List\n+                 (Comp_List => Comps,\n+                  CL_Checks => Checks);\n+            end if;\n+         end if;\n+      end Add_Record_Component_Invariants;\n+\n+      -------------------------\n+      -- Add_Type_Invariants --\n+      -------------------------\n+\n+      procedure Add_Type_Invariants\n+        (Priv_Typ  : Entity_Id;\n+         Full_Typ  : Entity_Id;\n+         CRec_Typ  : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id;\n+         Inherit   : Boolean := False;\n+         Priv_Item : Node_Id := Empty)\n+      is\n+         procedure Add_Invariant (Prag : Node_Id);\n+         --  Create a runtime check to verify the invariant exression of pragma\n+         --  Prag. All generated code is added to list Checks.\n+\n+         procedure Process_Type (T : Entity_Id; Stop_Item : Node_Id := Empty);\n+         --  Generate invariant checks for type T by inspecting the rep item\n+         --  chain of the type. Stop_Item denotes a rep item which once seen\n+         --  will stop the inspection.\n+\n+         -------------------\n+         -- Add_Invariant --\n+         -------------------\n+\n+         procedure Add_Invariant (Prag : Node_Id) is\n+            Asp  : constant Node_Id    := Corresponding_Aspect (Prag);\n+            Nam  : constant Name_Id    := Original_Aspect_Pragma_Name (Prag);\n+            Ploc : constant Source_Ptr := Sloc (Prag);\n+\n+            Arg1      : Node_Id;\n+            Arg2      : Node_Id;\n+            Arg3      : Node_Id;\n+            ASIS_Expr : Node_Id;\n+            Assoc     : List_Id;\n+            Expr      : Node_Id;\n+            Str       : String_Id;\n+\n+            Rep_Typ : Entity_Id;\n+            --  The replacement type used in the substitution of the current\n+            --  instance of a type with the _object formal parameter.\n+\n+         begin\n+            --  Nothing to do if the pragma was already processed\n+\n+            if Contains (Pragmas_Seen, Prag) then\n+               return;\n+            end if;\n+\n+            --  Extract the arguments of the invariant pragma\n+\n+            Arg1 := First (Pragma_Argument_Associations (Prag));\n+            Arg2 := Next (Arg1);\n+            Arg3 := Next (Arg2);\n+\n+            Arg1 := Get_Pragma_Arg (Arg1);\n+            Arg2 := Get_Pragma_Arg (Arg2);\n+\n+            --  The pragma applies to the partial view\n+\n+            if Present (Priv_Typ) and then Entity (Arg1) = Priv_Typ then\n+               Rep_Typ := Priv_Typ;\n+\n+            --  The pragma applies to the full view\n+\n+            elsif Present (Full_Typ) and then Entity (Arg1) = Full_Typ then\n+               Rep_Typ := Full_Typ;\n+\n+            --  Otherwise the pragma applies to a parent type in which case it\n+            --  will be processed at a later stage by Add_Parent_Invariants or\n+            --  Add_Interface_Invariants.\n+\n+            else\n+               return;\n+            end if;\n+\n+            --  Nothing to do when the caller requests the processing of all\n+            --  inherited class-wide invariants, but the pragma does not fall\n+            --  in this category.\n+\n+            if Inherit and then not Class_Present (Prag) then\n+               return;\n+            end if;\n+\n+            Expr := New_Copy_Tree (Arg2);\n+\n+            --  Substitute all references to type Rep_Typ with references to\n+            --  the _object formal parameter. Dispatching here must be removed\n+            --  due to AI12-0150-1 !!!\n+\n+            Replace_Type_References\n+              (Expr, Rep_Typ, Obj_Id, Dispatch => Class_Present (Prag));\n+\n+            --  Additional processing for non-class-wide invariants\n+\n+            if not Inherit then\n+\n+               --  Preanalyze the invariant expression to detect errors and at\n+               --  the same time capture the visibility of the proper package\n+               --  part.\n+\n+               --  Historical note: the old implementation of invariants used\n+               --  node N as the parent, but a package specification as parent\n+               --  of an expression is bizarre.\n+\n+               Set_Parent (Expr, Parent (Arg2));\n+               Preanalyze_Assert_Expression (Expr, Any_Boolean);\n+\n+               --  If the pragma comes from an aspect specification, replace\n+               --  the saved expression because all type references must be\n+               --  substituted for the call to Preanalyze_Spec_Expression in\n+               --  Check_Aspect_At_xxx routines.\n+\n+               if Present (Asp) then\n+                  Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n+               end if;\n+\n+               --  Analyze the original invariant expression for ASIS\n+\n+               if ASIS_Mode then\n+                  ASIS_Expr := Empty;\n+\n+                  if Comes_From_Source (Prag) then\n+                     ASIS_Expr := Arg2;\n+                  elsif Present (Asp) then\n+                     ASIS_Expr := Expression (Asp);\n+                  end if;\n+\n+                  if Present (ASIS_Expr) then\n+                     Replace_Type_References\n+                       (ASIS_Expr, Rep_Typ, Obj_Id, Class_Present (Prag));\n+                     Preanalyze_Assert_Expression (ASIS_Expr, Any_Boolean);\n+                  end if;\n+               end if;\n+\n+               --  A class-wide invariant may be inherited in a separate unit,\n+               --  where the corresponding expression cannot be resolved by\n+               --  visibility, because it refers to a local function. Propagate\n+               --  semantic information to the original representation item, to\n+               --  be used when an invariant procedure for a derived type is\n+               --  constructed.\n+\n+               --  ??? Unclear how to handle class-wide invariants that are not\n+               --  function calls.\n+\n+               if Class_Present (Prag)\n+                 and then Nkind (Expr) = N_Function_Call\n+                 and then Nkind (Arg2) = N_Indexed_Component\n+               then\n+                  Rewrite (Arg2,\n+                    Make_Function_Call (Ploc,\n+                      Name                   =>\n+                        New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n+                      Parameter_Associations => Expressions (Arg2)));\n+               end if;\n+            end if;\n+\n+            --  The invariant is ignored, nothing left to do\n+\n+            if Is_Ignored (Prag) then\n+               null;\n+\n+            --  Otherwise the invariant is checked. Build a Check pragma to\n+            --  verify the expression at runtime.\n+\n+            else\n+               Assoc := New_List (\n+                 Make_Pragma_Argument_Association (Ploc,\n+                   Expression => Make_Identifier (Ploc, Nam)),\n+                 Make_Pragma_Argument_Association (Ploc,\n+                   Expression => Expr));\n+\n+               --  Handle the String argument (if any)\n+\n+               if Present (Arg3) then\n+                  Str := Strval (Get_Pragma_Arg (Arg3));\n+\n+                  --  When inheriting an invariant, modify the message from\n+                  --  \"failed invariant\" to \"failed inherited invariant\".\n+\n+                  if Inherit then\n+                     String_To_Name_Buffer (Str);\n+\n+                     if Name_Buffer (1 .. 16) = \"failed invariant\" then\n+                        Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+                        Str := String_From_Name_Buffer;\n+                     end if;\n+                  end if;\n+\n+                  Append_To (Assoc,\n+                    Make_Pragma_Argument_Association (Ploc,\n+                      Expression => Make_String_Literal (Ploc, Str)));\n+               end if;\n+\n+               --  Generate:\n+               --    pragma Check (<Nam>, <Expr>, <Str>);\n+\n+               Append_New_To (Checks,\n+                 Make_Pragma (Ploc,\n+                   Chars                        => Name_Check,\n+                   Pragma_Argument_Associations => Assoc));\n+            end if;\n+\n+            --  Output an info message when inheriting an invariant and the\n+            --  listing option is enabled.\n+\n+            if Inherit and Opt.List_Inherited_Aspects then\n+               Error_Msg_Sloc := Sloc (Prag);\n+               Error_Msg_N\n+                 (\"info: & inherits `Invariant''Class` aspect from #?L?\", Typ);\n+            end if;\n+\n+            --  Add the pragma to the list of processed pragmas\n+\n+            Append_New_Elmt (Prag, Pragmas_Seen);\n+            Produced_Check := True;\n+         end Add_Invariant;\n+\n+         ------------------\n+         -- Process_Type --\n+         ------------------\n+\n+         procedure Process_Type\n+           (T         : Entity_Id;\n+            Stop_Item : Node_Id := Empty)\n+         is\n+            Rep_Item : Node_Id;\n+\n+         begin\n+            Rep_Item := First_Rep_Item (T);\n+            while Present (Rep_Item) loop\n+               if Nkind (Rep_Item) = N_Pragma\n+                 and then Pragma_Name (Rep_Item) = Name_Invariant\n+               then\n+                  --  Stop the traversal of the rep item chain once a specific\n+                  --  item is encountered.\n+\n+                  if Present (Stop_Item) and then Rep_Item = Stop_Item then\n+                     exit;\n+\n+                  --  Otherwise generate an invariant check\n+\n+                  else\n+                     Add_Invariant (Rep_Item);\n+                  end if;\n+               end if;\n+\n+               Next_Rep_Item (Rep_Item);\n+            end loop;\n+         end Process_Type;\n+\n+      --  Start of processing for Add_Type_Invariants\n+\n+      begin\n+         --  Process the invariants of the partial view\n+\n+         if Present (Priv_Typ) then\n+            Process_Type (Priv_Typ);\n+         end if;\n+\n+         --  Process the invariants of the full view\n+\n+         if Present (Full_Typ) then\n+            Process_Type (Full_Typ, Stop_Item => Priv_Item);\n+\n+            --  Process the elements of an array type\n+\n+            if Is_Array_Type (Full_Typ) then\n+               Add_Array_Component_Invariants (Full_Typ, Obj_Id, Checks);\n+\n+            --  Process the components of a record type\n+\n+            elsif Ekind (Full_Typ) = E_Record_Type then\n+               Add_Record_Component_Invariants (Full_Typ, Obj_Id, Checks);\n+            end if;\n+         end if;\n+\n+         --  Process the components of a corresponding record type\n+\n+         if Present (CRec_Typ) then\n+            Add_Record_Component_Invariants (CRec_Typ, Obj_Id, Checks);\n+         end if;\n+      end Add_Type_Invariants;\n+\n+      --  Local variables\n+\n+      Dummy        : Entity_Id;\n+      Mode         : Ghost_Mode_Type;\n+      Priv_Item    : Node_Id;\n+      Proc_Body    : Node_Id;\n+      Proc_Body_Id : Entity_Id;\n+      Proc_Decl    : Node_Id;\n+      Proc_Id      : Entity_Id;\n+      Stmts        : List_Id := No_List;\n+\n+      CRec_Typ : Entity_Id;\n+      --  The corresponding record type of Full_Typ\n+\n+      Full_Proc : Entity_Id;\n+      --  The entity of the \"full\" invariant procedure\n+\n+      Full_Typ : Entity_Id;\n+      --  The full view of the working type\n+\n+      Obj_Id : Entity_Id;\n+      --  The _object formal parameter of the invariant procedure\n+\n+      Part_Proc : Entity_Id;\n+      --  The entity of the \"partial\" invariant procedure\n+\n+      Priv_Typ : Entity_Id;\n+      --  The partial view of the working type\n+\n+      Work_Typ : Entity_Id;\n+      --  The working type\n+\n+   --  Start of processing for Build_Invariant_Procedure_Body\n+\n+   begin\n+      Work_Typ := Typ;\n+\n+      --  The input type denotes the implementation base type of a constrained\n+      --  array type. Work with the first subtype as all invariant pragmas are\n+      --  on its rep item chain.\n+\n+      if Ekind (Work_Typ) = E_Array_Type and then Is_Itype (Work_Typ) then\n+         Work_Typ := First_Subtype (Work_Typ);\n+\n+      --  The input type denotes the corresponding record type of a protected\n+      --  or task type. Work with the concurrent type because the corresponding\n+      --  record type may not be visible to clients of the type.\n+\n+      elsif Ekind (Work_Typ) = E_Record_Type\n+        and then Is_Concurrent_Record_Type (Work_Typ)\n+      then\n+         Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n+      end if;\n+\n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the invariant procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode (Work_Typ, Mode);\n+\n+      --  The type must either have invariants of its own, inherit class-wide\n+      --  invariants from parent types or interfaces, or be an array or record\n+      --  type whose components have invariants.\n+\n+      pragma Assert (Has_Invariants (Work_Typ));\n+\n+      --  Nothing to do for interface types as their class-wide invariants are\n+      --  inherited by implementing types.\n+\n+      if Is_Interface (Work_Typ) then\n+         goto Leave;\n+      end if;\n+\n+      --  Obtain both views of the type\n+\n+      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Dummy, CRec_Typ);\n+\n+      --  The caller requests a body for the partial invariant procedure\n+\n+      if Partial_Invariant then\n+         Full_Proc := Invariant_Procedure (Work_Typ);\n+         Proc_Id   := Partial_Invariant_Procedure (Work_Typ);\n+\n+         --  The \"full\" invariant procedure body was already created\n+\n+         if Present (Full_Proc)\n+           and then Present\n+                      (Corresponding_Body (Unit_Declaration_Node (Full_Proc)))\n+         then\n+            --  This scenario happens only when the type is an untagged\n+            --  derivation from a private parent and the underlying full\n+            --  view was processed before the partial view.\n+\n+            pragma Assert\n+              (Is_Untagged_Private_Derivation (Priv_Typ, Full_Typ));\n+\n+            --  Nothing to do because the processing of the underlying full\n+            --  view already checked the invariants of the partial view.\n+\n+            goto Leave;\n+         end if;\n+\n+         --  Create a declaration for the \"partial\" invariant procedure if it\n+         --  is not available.\n+\n+         if No (Proc_Id) then\n+            Build_Invariant_Procedure_Declaration\n+              (Typ               => Work_Typ,\n+               Partial_Invariant => True);\n+\n+            Proc_Id := Partial_Invariant_Procedure (Work_Typ);\n+         end if;\n+\n+      --  The caller requests a body for the \"full\" invariant procedure\n+\n+      else\n+         Proc_Id   := Invariant_Procedure (Work_Typ);\n+         Part_Proc := Partial_Invariant_Procedure (Work_Typ);\n+\n+         --  Create a declaration for the \"full\" invariant procedure if it is\n+         --  not available.\n+\n+         if No (Proc_Id) then\n+            Build_Invariant_Procedure_Declaration (Work_Typ);\n+            Proc_Id := Invariant_Procedure (Work_Typ);\n+         end if;\n+      end if;\n+\n+      --  At this point there should be an invariant procedure declaration\n+\n+      pragma Assert (Present (Proc_Id));\n+      Proc_Decl := Unit_Declaration_Node (Proc_Id);\n+\n+      --  Nothing to do if the invariant procedure already has a body\n+\n+      if Present (Corresponding_Body (Proc_Decl)) then\n+         goto Leave;\n+      end if;\n+\n+      --  Emulate the environment of the invariant procedure by installing\n+      --  its scope and formal parameters. Note that this is not needed, but\n+      --  having the scope of the invariant procedure installed helps with\n+      --  the detection of invariant-related errors.\n+\n+      Push_Scope (Proc_Id);\n+      Install_Formals (Proc_Id);\n+\n+      Obj_Id := First_Formal (Proc_Id);\n+      pragma Assert (Present (Obj_Id));\n+\n+      --  The \"partial\" invariant procedure verifies the invariants of the\n+      --  partial view only.\n+\n+      if Partial_Invariant then\n+         pragma Assert (Present (Priv_Typ));\n+\n+         Add_Type_Invariants\n+           (Priv_Typ => Priv_Typ,\n+            Full_Typ => Empty,\n+            CRec_Typ => Empty,\n+            Obj_Id   => Obj_Id,\n+            Checks   => Stmts);\n+\n+      --  Otherwise the \"full\" invariant procedure verifies the invariants of\n+      --  the full view, all array or record components, as well as class-wide\n+      --  invariants inherited from parent types or interfaces. In addition, it\n+      --  indirectly verifies the invariants of the partial view by calling the\n+      --  \"partial\" invariant procedure.\n+\n+      else\n+         pragma Assert (Present (Full_Typ));\n+\n+         --  Check the invariants of the partial view by calling the \"partial\"\n+         --  invariant procedure. Generate:\n+\n+         --    <Work_Typ>Partial_Invariant (_object);\n+\n+         if Present (Part_Proc) then\n+            Append_New_To (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   => New_Occurrence_Of (Part_Proc, Loc),\n+                Parameter_Associations => New_List (\n+                  New_Occurrence_Of (Obj_Id, Loc))));\n+\n+            Produced_Check := True;\n+         end if;\n+\n+         Priv_Item := Empty;\n+\n+         --  Derived subtypes do not have a partial view\n+\n+         if Present (Priv_Typ) then\n+\n+            --  The processing of the \"full\" invariant procedure intentionally\n+            --  skips the partial view because a) this may result in changes of\n+            --  visibility and b) lead to duplicate checks. However, when the\n+            --  full view is the underlying full view of an untagged derived\n+            --  type whose parent type is private, partial invariants appear on\n+            --  the rep item chain of the partial view only.\n+\n+            --    package Pack_1 is\n+            --       type Root ... is private;\n+            --    private\n+            --       <full view of Root>\n+            --    end Pack_1;\n+\n+            --    with Pack_1;\n+            --    package Pack_2 is\n+            --       type Child is new Pack_1.Root with Type_Invariant => ...;\n+            --       <underlying full view of Child>\n+            --    end Pack_2;\n+\n+            --  As a result, the processing of the full view must also consider\n+            --  all invariants of the partial view.\n+\n+            if Is_Untagged_Private_Derivation (Priv_Typ, Full_Typ) then\n+               null;\n+\n+            --  Otherwise the invariants of the partial view are ignored\n+\n+            else\n+               --  Note that the rep item chain is shared between the partial\n+               --  and full views of a type. To avoid processing the invariants\n+               --  of the partial view, signal the logic to stop when the first\n+               --  rep item of the partial view has been reached.\n+\n+               Priv_Item := First_Rep_Item (Priv_Typ);\n+\n+               --  Ignore the invariants of the partial view by eliminating the\n+               --  view.\n+\n+               Priv_Typ := Empty;\n+            end if;\n+         end if;\n+\n+         --  Process the invariants of the full view and in certain cases those\n+         --  of the partial view. This also handles any invariants on array or\n+         --  record components.\n+\n+         Add_Type_Invariants\n+           (Priv_Typ  => Priv_Typ,\n+            Full_Typ  => Full_Typ,\n+            CRec_Typ  => CRec_Typ,\n+            Obj_Id    => Obj_Id,\n+            Checks    => Stmts,\n+            Priv_Item => Priv_Item);\n+\n+         --  Process the inherited class-wide invariants of all parent types.\n+         --  This also handles any invariants on record components.\n+\n+         Add_Parent_Invariants (Full_Typ, Obj_Id, Stmts);\n+\n+         --  Process the inherited class-wide invariants of all implemented\n+         --  interface types.\n+\n+         Add_Interface_Invariants (Full_Typ, Obj_Id, Stmts);\n+      end if;\n+\n+      End_Scope;\n+\n+      --  At this point there should be at least one invariant check. If this\n+      --  is not the case, then the invariant-related flags were not properly\n+      --  set, or there is a missing invariant procedure on one of the array\n+      --  or record components.\n+\n+      pragma Assert (Produced_Check);\n+\n+      --  Account for the case where assertions are disabled or all invariant\n+      --  checks are subject to Assertion_Policy Ignore. Produce a completing\n+      --  empty body.\n+\n+      if No (Stmts) then\n+         Stmts := New_List (Make_Null_Statement (Loc));\n+      end if;\n+\n+      --  Generate:\n+      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>) is\n+      --    begin\n+      --       <Stmts>\n+      --    end <Work_Typ>[Partial_]Invariant;\n+\n+      Proc_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification                =>\n+            Copy_Subprogram_Spec (Parent (Proc_Id)),\n+          Declarations                 => Empty_List,\n+            Handled_Statement_Sequence =>\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => Stmts));\n+      Proc_Body_Id := Defining_Entity (Proc_Body);\n+\n+      --  Perform minor decoration in case the body is not analyzed\n+\n+      Set_Ekind (Proc_Body_Id, E_Subprogram_Body);\n+      Set_Etype (Proc_Body_Id, Standard_Void_Type);\n+      Set_Scope (Proc_Body_Id, Current_Scope);\n+\n+      --  Link both spec and body to avoid generating duplicates\n+\n+      Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n+      Set_Corresponding_Spec (Proc_Body, Proc_Id);\n+\n+      --  The body should not be inserted into the tree when the context is\n+      --  ASIS or a generic unit because it is not part of the template. Note\n+      --  that the body must still be generated in order to resolve the\n+      --  invariants.\n+\n+      if ASIS_Mode or Inside_A_Generic then\n+         null;\n+\n+      --  Semi-insert the body into the tree for GNATprove by setting its\n+      --  Parent field. This allows for proper upstream tree traversals.\n+\n+      elsif GNATprove_Mode then\n+         Set_Parent (Proc_Body, Parent (Declaration_Node (Work_Typ)));\n+\n+      --  Otherwise the body is part of the freezing actions of the type\n+\n+      else\n+         Append_Freeze_Action (Work_Typ, Proc_Body);\n+      end if;\n+\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n+   end Build_Invariant_Procedure_Body;\n+\n+   -------------------------------------------\n+   -- Build_Invariant_Procedure_Declaration --\n+   -------------------------------------------\n+\n+   --  WARNING: This routine manages Ghost regions. Return statements must be\n+   --  replaced by gotos which jump to the end of the routine and restore the\n+   --  Ghost mode.\n+\n+   procedure Build_Invariant_Procedure_Declaration\n+     (Typ               : Entity_Id;\n+      Partial_Invariant : Boolean := False)\n+   is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+      Mode      : Ghost_Mode_Type;\n+      Proc_Decl : Node_Id;\n+      Proc_Id   : Entity_Id;\n+      Proc_Nam  : Name_Id;\n+      Typ_Decl  : Node_Id;\n+\n+      CRec_Typ : Entity_Id;\n+      --  The corresponding record type of Full_Typ\n+\n+      Full_Base : Entity_Id;\n+      --  The base type of Full_Typ\n+\n+      Full_Typ : Entity_Id;\n+      --  The full view of working type\n+\n+      Obj_Id : Entity_Id;\n+      --  The _object formal parameter of the invariant procedure\n+\n+      Priv_Typ : Entity_Id;\n+      --  The partial view of working type\n+\n+      Work_Typ : Entity_Id;\n+      --  The working type\n+\n+   begin\n+      Work_Typ := Typ;\n+\n+      --  The input type denotes the implementation base type of a constrained\n+      --  array type. Work with the first subtype as all invariant pragmas are\n+      --  on its rep item chain.\n+\n+      if Ekind (Work_Typ) = E_Array_Type and then Is_Itype (Work_Typ) then\n+         Work_Typ := First_Subtype (Work_Typ);\n+\n+      --  The input denotes the corresponding record type of a protected or a\n+      --  task type. Work with the concurrent type because the corresponding\n+      --  record type may not be visible to clients of the type.\n+\n+      elsif Ekind (Work_Typ) = E_Record_Type\n+        and then Is_Concurrent_Record_Type (Work_Typ)\n+      then\n+         Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n+      end if;\n+\n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the invariant procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode (Work_Typ, Mode);\n+\n+      --  The type must either have invariants of its own, inherit class-wide\n+      --  invariants from parent or interface types, or be an array or record\n+      --  type whose components have invariants.\n+\n+      pragma Assert (Has_Invariants (Work_Typ));\n+\n+      --  Nothing to do for interface types as their class-wide invariants are\n+      --  inherited by implementing types.\n+\n+      if Is_Interface (Work_Typ) then\n+         goto Leave;\n+\n+      --  Nothing to do if the type already has a \"partial\" invariant procedure\n+\n+      elsif Partial_Invariant then\n+         if Present (Partial_Invariant_Procedure (Work_Typ)) then\n+            goto Leave;\n+         end if;\n+\n+      --  Nothing to do if the type already has a \"full\" invariant procedure\n+\n+      elsif Present (Invariant_Procedure (Work_Typ)) then\n+         goto Leave;\n+      end if;\n+\n+      --  The caller requests the declaration of the \"partial\" invariant\n+      --  procedure.\n+\n+      if Partial_Invariant then\n+         Proc_Nam := New_External_Name (Chars (Work_Typ), \"Partial_Invariant\");\n+\n+      --  Otherwise the caller requests the declaration of the \"full\" invariant\n+      --  procedure.\n+\n+      else\n+         Proc_Nam := New_External_Name (Chars (Work_Typ), \"Invariant\");\n+      end if;\n+\n+      Proc_Id := Make_Defining_Identifier (Loc, Chars => Proc_Nam);\n+\n+      --  Perform minor decoration in case the declaration is not analyzed\n+\n+      Set_Ekind (Proc_Id, E_Procedure);\n+      Set_Etype (Proc_Id, Standard_Void_Type);\n+      Set_Scope (Proc_Id, Current_Scope);\n+\n+      if Partial_Invariant then\n+         Set_Is_Partial_Invariant_Procedure (Proc_Id);\n+         Set_Partial_Invariant_Procedure (Work_Typ, Proc_Id);\n+      else\n+         Set_Is_Invariant_Procedure (Proc_Id);\n+         Set_Invariant_Procedure (Work_Typ, Proc_Id);\n+      end if;\n+\n+      --  The invariant procedure requires debug info when the invariants are\n+      --  subject to Source Coverage Obligations.\n+\n+      if Opt.Generate_SCO then\n+         Set_Needs_Debug_Info (Proc_Id);\n+      end if;\n+\n+      --  Obtain all views of the input type\n+\n+      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Full_Base, CRec_Typ);\n+\n+      --  Associate the invariant procedure with all views\n+\n+      Propagate_Invariant_Attributes (Priv_Typ,  From_Typ => Work_Typ);\n+      Propagate_Invariant_Attributes (Full_Typ,  From_Typ => Work_Typ);\n+      Propagate_Invariant_Attributes (Full_Base, From_Typ => Work_Typ);\n+      Propagate_Invariant_Attributes (CRec_Typ,  From_Typ => Work_Typ);\n+\n+      --  The declaration of the invariant procedure is inserted after the\n+      --  declaration of the partial view as this allows for proper external\n+      --  visibility.\n+\n+      if Present (Priv_Typ) then\n+         Typ_Decl := Declaration_Node (Priv_Typ);\n+\n+      --  Derived types with the full view as parent do not have a partial\n+      --  view. Insert the invariant procedure after the derived type.\n+\n+      else\n+         Typ_Decl := Declaration_Node (Full_Typ);\n+      end if;\n+\n+      --  The type should have a declarative node\n+\n+      pragma Assert (Present (Typ_Decl));\n+\n+      --  Create the formal parameter which emulates the variable-like behavior\n+      --  of the current type instance.\n+\n+      Obj_Id := Make_Defining_Identifier (Loc, Chars => Name_uObject);\n+\n+      --  Perform minor decoration in case the declaration is not analyzed\n+\n+      Set_Ekind (Obj_Id, E_In_Parameter);\n+      Set_Etype (Obj_Id, Work_Typ);\n+      Set_Scope (Obj_Id, Proc_Id);\n+\n+      Set_First_Entity (Proc_Id, Obj_Id);\n+\n+      --  Generate:\n+      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>);\n+\n+      Proc_Decl :=\n+        Make_Subprogram_Declaration (Loc,\n+          Specification =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name       => Proc_Id,\n+              Parameter_Specifications => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => Obj_Id,\n+                  Parameter_Type      =>\n+                    New_Occurrence_Of (Work_Typ, Loc)))));\n+\n+      --  The declaration should not be inserted into the tree when the context\n+      --  is ASIS or a generic unit because it is not part of the template.\n+\n+      if ASIS_Mode or Inside_A_Generic then\n+         null;\n+\n+      --  Semi-insert the declaration into the tree for GNATprove by setting\n+      --  its Parent field. This allows for proper upstream tree traversals.\n+\n+      elsif GNATprove_Mode then\n+         Set_Parent (Proc_Decl, Parent (Typ_Decl));\n+\n+      --  Otherwise insert the declaration\n+\n+      else\n+         pragma Assert (Present (Typ_Decl));\n+         Insert_After_And_Analyze (Typ_Decl, Proc_Decl);\n+      end if;\n+\n+   <<Leave>>\n+      Restore_Ghost_Mode (Mode);\n+   end Build_Invariant_Procedure_Declaration;\n+\n    --------------------------\n    -- Build_Procedure_Form --\n    --------------------------\n@@ -7124,6 +8501,23 @@ package body Exp_Util is\n                    and then Etype (Full_View (T)) /= T);\n    end Is_Untagged_Derivation;\n \n+   ------------------------------------\n+   -- Is_Untagged_Private_Derivation --\n+   ------------------------------------\n+\n+   function Is_Untagged_Private_Derivation\n+     (Priv_Typ : Entity_Id;\n+      Full_Typ : Entity_Id) return Boolean\n+   is\n+   begin\n+      return\n+        Present (Priv_Typ)\n+          and then Is_Untagged_Derivation (Priv_Typ)\n+          and then Is_Private_Type (Etype (Priv_Typ))\n+          and then Present (Full_Typ)\n+          and then Is_Itype (Full_Typ);\n+   end Is_Untagged_Private_Derivation;\n+\n    ---------------------------\n    -- Is_Volatile_Reference --\n    ---------------------------\n@@ -10181,9 +11575,10 @@ package body Exp_Util is\n    -----------------------------\n \n    procedure Replace_Type_References\n-     (Expr   : Node_Id;\n-      Typ    : Entity_Id;\n-      Obj_Id : Entity_Id)\n+     (Expr     : Node_Id;\n+      Typ      : Entity_Id;\n+      Obj_Id   : Entity_Id;\n+      Dispatch : Boolean := False)\n    is\n       procedure Replace_Type_Ref (N : Node_Id);\n       --  Substitute a single reference of the current instance of type Typ\n@@ -10194,7 +11589,8 @@ package body Exp_Util is\n       ----------------------\n \n       procedure Replace_Type_Ref (N : Node_Id) is\n-         Ref : Node_Id;\n+         Nloc : constant Source_Ptr := Sloc (N);\n+         Ref  : Node_Id;\n \n       begin\n          --  Decorate the reference to Typ even though it may be rewritten\n@@ -10224,8 +11620,27 @@ package body Exp_Util is\n          Set_Entity (Ref, Obj_Id);\n          Set_Etype  (Ref, Typ);\n \n-         Rewrite (N, Ref);\n+         --  When the pragma denotes a class-wide and the Dispatch flag is set\n+         --  perform the following substitution. Note: dispatching in this\n+         --  fashion is illegal Ada according to AI12-0150-1 because class-wide\n+         --  aspects like type invariants and default initial conditions be\n+         --  evaluated statically. Currently it is used only for class-wide\n+         --  type invariants, but this will be fixed.\n+\n+         --    Rep_Typ  -->  Rep_Typ'Class (_object)\n \n+         if Dispatch then\n+            Ref :=\n+              Make_Type_Conversion (Nloc,\n+                Subtype_Mark =>\n+                  Make_Attribute_Reference (Nloc,\n+                    Prefix         =>\n+                      New_Occurrence_Of (Typ, Nloc),\n+                    Attribute_Name => Name_Class),\n+                Expression   => Ref);\n+         end if;\n+\n+         Rewrite (N, Ref);\n          Set_Comes_From_Source (N, True);\n       end Replace_Type_Ref;\n "}, {"sha": "0a409f3d22c265194b8bf21cdda5345a0cc2b026", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=51148ddab1495aa357e57f1c209940f7cde571c1", "patch": "@@ -290,6 +290,21 @@ package Exp_Util is\n    --  Create the declaration of the procedure which verifies the assertion\n    --  expression of pragma Default_Initial_Condition at run time.\n \n+   procedure Build_Invariant_Procedure_Body\n+     (Typ               : Entity_Id;\n+      Partial_Invariant : Boolean := False);\n+   --  Create the body of the procedure which verifies the invariants of type\n+   --  Typ at runtime. Flag Partial_Invariant should be set when Typ denotes a\n+   --  private type, otherwise it is assumed that Typ denotes the full view of\n+   --  a private type.\n+\n+   procedure Build_Invariant_Procedure_Declaration\n+     (Typ               : Entity_Id;\n+      Partial_Invariant : Boolean := False);\n+   --  Create the declaration of the procedure which verifies the invariants of\n+   --  type Typ at runtime. Flag Partial_Invariant should be set when building\n+   --  the invariant procedure for a private type.\n+\n    procedure Build_Procedure_Form (N : Node_Id);\n    --  Create a procedure declaration which emulates the behavior of a function\n    --  that returns an array type, for C-compatible generation.\n@@ -805,6 +820,12 @@ package Exp_Util is\n    --  Returns true if type T is not tagged and is a derived type,\n    --  or is a private type whose completion is such a type.\n \n+   function Is_Untagged_Private_Derivation\n+     (Priv_Typ : Entity_Id;\n+      Full_Typ : Entity_Id) return Boolean;\n+   --  Determine whether private type Priv_Typ and its full view Full_Typ\n+   --  represent an untagged derivation from a private parent.\n+\n    function Is_Volatile_Reference (N : Node_Id) return Boolean;\n    --  Checks if the node N represents a volatile reference, which can be\n    --  either a direct reference to a variable treated as volatile, or an\n@@ -1037,9 +1058,10 @@ package Exp_Util is\n    --      the internally-generated inherited primitive of Deriv_Typ.\n \n    procedure Replace_Type_References\n-     (Expr   : Node_Id;\n-      Typ    : Entity_Id;\n-      Obj_Id : Entity_Id);\n+     (Expr     : Node_Id;\n+      Typ      : Entity_Id;\n+      Obj_Id   : Entity_Id;\n+      Dispatch : Boolean := False);\n    --  Substitute all references of the current instance of type Typ with\n    --  references to formal parameter Obj_Id within expression Expr.\n "}, {"sha": "cbae00f158f9b2884a240d9519b4ec429796f956", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=51148ddab1495aa357e57f1c209940f7cde571c1", "patch": "@@ -33,7 +33,6 @@ with Einfo;     use Einfo;\n with Errout;    use Errout;\n with Eval_Fat;  use Eval_Fat;\n with Exp_Ch3;   use Exp_Ch3;\n-with Exp_Ch7;   use Exp_Ch7;\n with Exp_Ch9;   use Exp_Ch9;\n with Exp_Disp;  use Exp_Disp;\n with Exp_Dist;  use Exp_Dist;"}, {"sha": "2638b37d5ccd01f9d16c7827f148f2bcebd571e5", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=51148ddab1495aa357e57f1c209940f7cde571c1", "patch": "@@ -39,7 +39,6 @@ with Debug;     use Debug;\n with Einfo;     use Einfo;\n with Elists;    use Elists;\n with Errout;    use Errout;\n-with Exp_Ch7;   use Exp_Ch7;\n with Exp_Dist;  use Exp_Dist;\n with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;"}, {"sha": "ed883731b303351e5675beb14617db3aeb7c5a2b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51148ddab1495aa357e57f1c209940f7cde571c1/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=51148ddab1495aa357e57f1c209940f7cde571c1", "patch": "@@ -1823,8 +1823,20 @@ package body Sem_Util is\n                               N_Subprogram_Declaration)\n            and then not Comes_From_Source (Par)\n          then\n-            OK_Use := True;\n-            exit;\n+            --  Continue to examine the context if the reference appears in a\n+            --  subprogram body which was previously an expression function.\n+\n+            if Nkind (Par) = N_Subprogram_Body\n+              and then Was_Expression_Function (Par)\n+            then\n+               null;\n+\n+            --  Otherwise the reference is legal\n+\n+            else\n+               OK_Use := True;\n+               exit;\n+            end if;\n \n          --  The reference has been relocated to an inlined body for GNATprove.\n          --  Assume that the reference is legal as the real check was already"}]}