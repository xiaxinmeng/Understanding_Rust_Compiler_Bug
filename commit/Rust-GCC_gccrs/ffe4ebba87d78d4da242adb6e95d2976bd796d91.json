{"sha": "ffe4ebba87d78d4da242adb6e95d2976bd796d91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZlNGViYmE4N2Q3OGQ0ZGEyNDJhZGI2ZTk1ZDI5NzZiZDc5NmQ5MQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-03-24T08:27:28Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-03-24T08:27:28Z"}, "message": "DataInputStream.java (): Wrapped documentation line.\n\n2003-03-24  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/DataInputStream.java\n\t(): Wrapped documentation line.\n\t(): Fixed @return tag.\n\t* java/io/DataOutputStream.java\n\t(written): Moved to top of class.\n\t(all methods): Merged documentation from classpath.\n\t* java/io/File.java:\n\tMerged copyright year with classpath.\n\t* java/io/FileInputStream.java\n\t(all methods): Merged documentation from classpath.\n\t* java/io/LineNumberReader.java\n\t(getLineNumber): Fixed @return tag.\n\t* java/io/ObjectInputStream.java.\n\tReformatted.\n\t* java/io/ObjectOutputStream.java:\n\tReformatted, fixed some @see tags.\n\t* java/io/OutputStreamWriter.java:\n\tDeleted empty line.\n\t* java/io/Writer.java:\n\tReformatted.\n\nFrom-SVN: r64780", "tree": {"sha": "de2889adb98c833d19e91db64f8b848c8c32f46a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de2889adb98c833d19e91db64f8b848c8c32f46a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffe4ebba87d78d4da242adb6e95d2976bd796d91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe4ebba87d78d4da242adb6e95d2976bd796d91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe4ebba87d78d4da242adb6e95d2976bd796d91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe4ebba87d78d4da242adb6e95d2976bd796d91/comments", "author": null, "committer": null, "parents": [{"sha": "228115acf439b32d93b626c343d13cd3eefa5dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/228115acf439b32d93b626c343d13cd3eefa5dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/228115acf439b32d93b626c343d13cd3eefa5dab"}], "stats": {"total": 1188, "additions": 751, "deletions": 437}, "files": [{"sha": "07494cd81e077b90e1b8807d8479476a94d71165", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -1,3 +1,26 @@\n+2003-03-24  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/DataInputStream.java\n+\t(): Wrapped documentation line.\n+\t(): Fixed @return tag.\n+\t* java/io/DataOutputStream.java\n+\t(written): Moved to top of class.\n+\t(all methods): Merged documentation from classpath.\n+\t* java/io/File.java:\n+\tMerged copyright year with classpath.\n+\t* java/io/FileInputStream.java\n+\t(all methods): Merged documentation from classpath.\n+\t* java/io/LineNumberReader.java\n+\t(getLineNumber): Fixed @return tag.\n+\t* java/io/ObjectInputStream.java.\n+\tReformatted.\n+\t* java/io/ObjectOutputStream.java:\n+\tReformatted, fixed some @see tags.\n+\t* java/io/OutputStreamWriter.java:\n+\tDeleted empty line.\n+\t* java/io/Writer.java:\n+\tReformatted.\n+\n 2003-03-24  Michael Koch  <konqueror@gmx.de>\n \n \t* java/awt/Frame.java"}, {"sha": "5f8c541e8227b470361af520941278aba6e82de8", "filename": "libjava/java/io/DataInputStream.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -596,7 +596,8 @@ public final int readUnsignedShort() throws IOException\n    * character encoding, then they would be converted to a Java\n    * <code>char</code> like so:\n    * <p>\n-   * <code>(char)(((byte1 & 0x0F) << 12) | ((byte2 & 0x3F) << 6) | (byte3 & 0x3F))</code>\n+   * <code>(char)(((byte1 & 0x0F) << 12) | ((byte2 & 0x3F) << 6) | \n+   * (byte3 & 0x3F))</code>\n    * <p>\n    * Note that all characters are encoded in the method that requires\n    * the fewest number of bytes with the exception of the character\n@@ -608,7 +609,7 @@ public final int readUnsignedShort() throws IOException\n    * This method can read data that was written by an object implementing the\n    * <code>writeUTF()</code> method in <code>DataOutput</code>\n    * \n-   * @returns The <code>String</code> read\n+   * @return The <code>String</code> read\n    *\n    * @exception EOFException If end of file is reached before reading\n    * the String"}, {"sha": "8fe9bbef9628a689a8c25a179ca9015818520fc6", "filename": "libjava/java/io/DataOutputStream.java", "status": "modified", "additions": 184, "deletions": 8, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FDataOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FDataOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataOutputStream.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -38,69 +38,163 @@\n \n package java.io;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 24, 1998 \n- */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * Status:  Complete to version 1.1.\n  */\n \n+/**\n+ * This class provides a mechanism for writing primitive Java datatypes\n+ * to an <code>OutputStream</code> in a portable way.  Data written to\n+ * a stream using this class can be read back in using the\n+ * <code>DataInputStream</code> class on any platform.\n+ *\n+ * @see DataInputStream\n+ *\n+ * @author Aaron M. Renn <arenn@urbanophile.com>\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ */\n public class DataOutputStream extends FilterOutputStream implements DataOutput\n {\n+  /**\n+   * This is the total number of bytes that have been written to the\n+   * stream by this object instance.\n+   */\n+  protected int written;\n+\n+  /**\n+   * This method initializes an instance of <code>DataOutputStream</code> to\n+   * write its data to the specified underlying <code>OutputStream</code>\n+   *\n+   * @param out The subordinate <code>OutputStream</code> to which this \n+   * object will write\n+   */\n   public DataOutputStream (OutputStream out)\n   {\n     super (out);\n     written = 0;\n   }\n \n+  /**\n+   * This method flushes any unwritten bytes to the underlying stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public void flush () throws IOException\n   {\n     out.flush();\n   }\n \n+  /**\n+   * This method returns the total number of bytes that have been written to\n+   * the underlying output stream so far.  This is the value of the\n+   * <code>written</code> instance variable\n+   *\n+   * @return The number of bytes written to the stream.\n+   */\n   public final int size ()\n   {\n     return written;\n   }\n \n+  /**\n+   * This method writes the specified byte (passed as an <code>int</code>)\n+   * to the underlying output stream.\n+   *\n+   * @param b The byte to write, passed as an <code>int</code>.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public synchronized void write (int b) throws IOException\n   {\n     out.write(b);\n     ++written;\n   }\n \n+  /**\n+   * This method writes <code>len</code> bytes from the specified byte array\n+   * <code>buf</code> starting at position <code>offset</code> into the\n+   * buffer to the underlying output stream.\n+   *\n+   * @param buf The byte array to write from.\n+   * @param offset The index into the byte array to start writing from.\n+   * @param len The number of bytes to write.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public synchronized void write (byte[] b, int off, int len)\n     throws IOException, NullPointerException, IndexOutOfBoundsException\n   {\n     out.write(b, off, len);\n     written += len;\n   }\n \n+  /**\n+   * This method writes a Java <code>boolean</code> to the underlying output \n+   * stream. For a value of <code>true</code>, 1 is written to the stream.\n+   * For a value of <code>false</code>, 0 is written.\n+   *\n+   * @param b The <code>boolean</code> value to write to the stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeBoolean (boolean v) throws IOException\n   {\n     write (v ? 1 : 0);\n   }\n \n+  /**\n+   * This method writes a Java <code>byte</code> value to the underlying\n+   * output stream.\n+   *\n+   * @param b The <code>byte</code> to write to the stream, passed as \n+   * the low eight bits of an <code>int</code>.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeByte (int v) throws IOException\n   {\n     write (v & 0xff);\n   }\n \n+  /**\n+   * This method writes a Java <code>short</code> to the stream, high byte\n+   * first.  This method requires two bytes to encode the value.\n+   *\n+   * @param s The <code>short</code> value to write to the stream,\n+   * passed as an <code>int</code>.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeShort (int v) throws IOException\n   {\n     write ((byte) (0xff & (v >> 8)));\n     write ((byte) (0xff & v));\n   }\n \n+  /**\n+   * This method writes a single <code>char</code> value to the stream,\n+   * high byte first.\n+   *\n+   * @param c The <code>char</code> value to write, \n+   * passed as an <code>int</code>.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeChar (int v) throws IOException\n   {\n     write ((byte) (0xff & (v >> 8)));\n     write ((byte) (0xff & v));\n   }\n \n+  /**\n+   * This method writes a Java <code>int</code> to the stream, high bytes\n+   * first.  This method requires four bytes to encode the value.\n+   *\n+   * @param i The <code>int</code> value to write to the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeInt (int v) throws IOException\n   {\n     write ((byte) (0xff & (v >> 24)));\n@@ -109,6 +203,14 @@ public final void writeInt (int v) throws IOException\n     write ((byte) (0xff & v));\n   }\n \n+  /**\n+   * This method writes a Java <code>long</code> to the stream, high bytes\n+   * first.  This method requires eight bytes to encode the value.\n+   *\n+   * @param l The <code>long</code> value to write to the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeLong (long v) throws IOException\n   {\n     write ((byte) (0xff & (v >> 56)));\n@@ -121,30 +223,105 @@ public final void writeLong (long v) throws IOException\n     write ((byte) (0xff & v));\n   }\n \n+  /**\n+   * This method writes a Java <code>float</code> value to the stream.  This\n+   * value is written by first calling the method \n+   * <code>Float.floatToIntBits</code>\n+   * to retrieve an <code>int</code> representing the floating point number,\n+   * then writing this <code>int</code> value to the stream exactly the same\n+   * as the <code>writeInt()</code> method does.\n+   *\n+   * @param f The floating point number to write to the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @see writeInt\n+   */\n   public final void writeFloat (float v) throws IOException\n   {\n     writeInt (Float.floatToIntBits(v));\n   }\n \n+  /**\n+   * This method writes a Java <code>double</code> value to the stream.  This\n+   * value is written by first calling the method\n+   * <code>Double.doubleToLongBits</code>\n+   * to retrieve an <code>long</code> representing the floating point number,\n+   * then writing this <code>long</code> value to the stream exactly the same\n+   * as the <code>writeLong()</code> method does.\n+   *\n+   * @param d The double precision floating point number to write to \n+   * the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   *\n+   * @see writeLong\n+   */\n   public final void writeDouble (double v) throws IOException\n   {\n     writeLong (Double.doubleToLongBits(v));\n   }\n \n+  /**\n+   * This method writes all the bytes in a <code>String</code> out to the\n+   * stream.  One byte is written for each character in the\n+   * <code>String</code>.\n+   * The high eight bits of each character are discarded.\n+   *\n+   * @param s The <code>String</code> to write to the stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeBytes (String s) throws IOException\n   {\n     int len = s.length();\n     for (int i = 0; i < len; ++i)\n       writeByte (s.charAt(i));\n   }\n \n+  /**\n+   * This method writes all the characters in a <code>String</code> to the\n+   * stream.  There will be two bytes for each character value.  The high\n+   * byte of the character will be written first.\n+   *\n+   * @param s The <code>String</code> to write to the stream.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeChars (String s) throws IOException\n   {\n     int len = s.length();\n     for (int i = 0; i < len; ++i)\n       writeChar (s.charAt(i));\n   }\n \n+  /**\n+   * This method writes a Java <code>String</code> to the stream in a modified\n+   * UTF-8 format.  First, two bytes are written to the stream indicating the\n+   * number of bytes to follow.  Note that this is the number of bytes in the\n+   * encoded <code>String</code> not the <code>String</code> length.  Next\n+   * come the encoded characters.  Each character in the <code>String</code>\n+   * is encoded as either one, two or three bytes.  For characters in the\n+   * range of <code>\\u0001</code> to <\\u007F>, one byte is used.  The character\n+   * value goes into bits 0-7 and bit eight is 0.  For characters in the range\n+   * of <code>\\u0080</code> to <code>\\u007FF</code>, two bytes are used.  Bits\n+   * 6-10 of the character value are encoded bits 0-4 of the first byte, with\n+   * the high bytes having a value of \"110\".  Bits 0-5 of the character value\n+   * are stored in bits 0-5 of the second byte, with the high bits set to\n+   * \"10\".  This type of encoding is also done for the null character\n+   * <code>\\u0000</code>.  This eliminates any C style NUL character values\n+   * in the output.  All remaining characters are stored as three bytes.\n+   * Bits 12-15 of the character value are stored in bits 0-3 of the first\n+   * byte.  The high bits of the first bytes are set to \"1110\".  Bits 6-11\n+   * of the character value are stored in bits 0-5 of the second byte.  The\n+   * high bits of the second byte are set to \"10\".  And bits 0-5 of the\n+   * character value are stored in bits 0-5 of byte three, with the high bits\n+   * of that byte set to \"10\".\n+   *\n+   * @param s The <code>String</code> to write to the output in UTF format\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final void writeUTF (String s) throws IOException\n   {\n     int len = s.length();\n@@ -188,6 +365,5 @@ else if (c == '\\u0000' || (c >= '\\u0080' && c <= '\\u07ff'))\n       }\n   }\n \n-  // Number of bytes written so far.\n-  protected int written;\n-}\n+} // class DataOutputStream\n+"}, {"sha": "e0aaaf9063c87033fce30eeb87db21c6da6ea585", "filename": "libjava/java/io/File.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFile.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -1,5 +1,5 @@\n /* File.java -- Class representing a file on disk\n-   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n "}, {"sha": "63390ec0901f647f437dded0c1f4388401bf8dc8", "filename": "libjava/java/io/FileInputStream.java", "status": "modified", "additions": 166, "deletions": 7, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FFileInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FFileInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileInputStream.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -3,6 +3,11 @@\n \n This file is part of GNU Classpath.\n \n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,23 +41,43 @@\n import java.nio.channels.FileChannel;\n import gnu.java.nio.FileChannelImpl;\n \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date October 28, 1998.  \n- */\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n  \n+/**\n+ * This class is a stream that reads its bytes from a file. \n+ *\n+ * @author Aaron M. Renn <arenn@urbanophile.com>\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date October 28, 1998.  \n+ */\n public class FileInputStream extends InputStream\n {\n-  /* Contains the file descriptor for referencing the actual file. */\n+  /**\n+   * This is the native file handle for the file this stream is reading from\n+   */\n   private FileDescriptor fd;\n \n-  private FileChannel ch;\n+  private FileChannel ch;  /* cached associated file-channel */\n \n+  /**\n+   * This method initializes a <code>FileInputStream</code> to read from the\n+   * specified named file.  A security check is first made to determine\n+   * whether or not access to this file is allowed.  This is done by\n+   * calling the <code>checkRead()</code> method of the \n+   * <code>SecurityManager</code>\n+   * (if one exists) with the name of this file.  An exception is thrown\n+   * if reading is not allowed.  If the file does not exist, an exception\n+   * is also thrown.\n+   *\n+   * @param name The name of the file this stream should read from\n+   *\n+   * @exception SecurityException If read access to the file is not allowed\n+   * @exception FileNotFoundException If the file does not exist.\n+   */\n   public FileInputStream(String name) throws FileNotFoundException\n   {\n     SecurityManager s = System.getSecurityManager();\n@@ -61,24 +86,83 @@ public FileInputStream(String name) throws FileNotFoundException\n     fd = new FileDescriptor(name, FileDescriptor.READ);\n   }\n \n+  /**\n+   * This method initializes a <code>FileInputStream</code> to read from the\n+   * specified <code>File</code> object.  A security check is first\n+   * made to determine\n+   * whether or not access to this file is allowed.  This is done by\n+   * calling the <code>checkRead()</code> method of the\n+   * <code>SecurityManager</code>\n+   * (if one exists) with the name of this file.  An exception is thrown\n+   * if reading is not allowed.  If the file does not exist, an exception\n+   * is also thrown.\n+   *\n+   * @param file The <code>File</code> object this stream should read from\n+   *\n+   * @exception SecurityException If read access to the file is not allowed\n+   * @exception FileNotFoundException If the file does not exist.\n+   */\n   public FileInputStream(File file) throws FileNotFoundException\n   {\n     this(file.getPath());\n   }\n \n+  /**\n+   * This method initializes a <code>FileInputStream</code> to read from the\n+   * specified <code>FileDescriptor</code> object.  A security\n+   * check is first made to\n+   * determine whether or not access to this file is allowed.  This is done by\n+   * calling the <code>checkRead()</code> method of the \n+   * <code>SecurityManager</code>\n+   * (if one exists) with the specified <code>FileDescriptor</code>  \n+   * An exception is \n+   * thrown if reading is not allowed.\n+   *\n+   * @param fd The <code>FileDescriptor</code> object this stream \n+   * should read from\n+   *\n+   * @exception SecurityException If read access to the file is not allowed\n+   */\n   public FileInputStream(FileDescriptor fdObj)\n   {\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkRead(fdObj);\n+\n     fd = fdObj;\n   }\n \n+  /**\n+   * This method returns the number of bytes that can be read from this\n+   * stream before a read can block.  A return of 0 indicates that blocking\n+   * might (or might not) occur on the very next read attempt.\n+   * <p>\n+   * This method returns the number of unread bytes remaining in the file if\n+   * the descriptor being read from is an actual file.  If this method is\n+   * reading from a ''special'' file such a the standard input, this method\n+   * will return the appropriate value for the stream being read.\n+   * <p>\n+   * Be aware that reads on plain files that do not reside locally might\n+   * possibly block even if this method says they should not.  For example,\n+   * a remote server might crash, preventing an NFS mounted file from being\n+   * read.\n+   *\n+   * @return The number of bytes that can be read before blocking could occur\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int available() throws IOException\n   {\n     return fd.available();\n   }\n \n+  /**\n+   * This method closes the stream.  Any futher attempts to read from the\n+   * stream will likely generate an IOException since the underlying file\n+   * will be closed.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public void close() throws IOException\n   {\n     if (fd.valid())\n@@ -91,23 +175,79 @@ protected void finalize() throws IOException\n     // mentioned in the JCL.\n   }\n \n+  /**\n+   * This method returns a <code>FileDescriptor</code> object representing the\n+   * underlying native file handle of the file this stream is reading\n+   * from\n+   *\n+   * @return A <code>FileDescriptor</code> for this stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public final FileDescriptor getFD() throws IOException\n   {\n     if (!fd.valid())\n       throw new IOException();\n     return fd;\n   }\n \n+  /**\n+   * This method reads an unsigned byte from the input stream and returns it\n+   * as an int in the range of 0-255.  This method also will return -1 if\n+   * the end of the stream has been reached.\n+   * <p>\n+   * This method will block until the byte can be read.\n+   *\n+   * @return The byte read or -1 if end of stream\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int read() throws IOException\n   {\n     return fd.read();\n   }\n \n+  /**\n+   * This method reads bytes from a stream and stores them into a caller\n+   * supplied buffer.  This method attempts to completely fill the buffer,\n+   * but can return before doing so.  The actual number of bytes read is\n+   * returned as an int.  A -1 is returned to indicate the end of the stream.\n+   * <p>\n+   * This method will block until some data can be read.\n+   * <p>\n+   * This method operates by calling an overloaded read method like so:\n+   * <code>read(buf, 0, buf.length)</code>\n+   *\n+   * @param buf The buffer into which the bytes read will be stored.\n+   *\n+   * @return The number of bytes read or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public int read(byte[] b) throws IOException\n   {\n     return fd.read(b, 0, b.length);\n   }\n \n+  /**\n+   * This method read bytes from a stream and stores them into a caller\n+   * supplied buffer.  It starts storing the data at index \n+   * <code>offset</code> into\n+   * the buffer and attempts to read <code>len</code> bytes.  This method can\n+   * return before reading the number of bytes requested.  The actual number\n+   * of bytes read is returned as an int.  A -1 is returned to indicate the\n+   * end of the stream.\n+   * <p>\n+   * This method will block until some data can be read.\n+   *\n+   * @param buf The array into which the bytes read should be stored\n+   * @param offset The offset into the array to start storing bytes\n+   * @param len The requested number of bytes to read\n+   *\n+   * @return The actual number of bytes read, or -1 if end of stream.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n   public int read(byte[] b, int off, int len) throws IOException\n   {\n     if (off < 0 || len < 0 || off + len > b.length)\n@@ -116,13 +256,30 @@ public int read(byte[] b, int off, int len) throws IOException\n     return fd.read(b, off, len);\n   }\n \n+  /**\n+   * This method skips the specified number of bytes in the stream.  It\n+   * returns the actual number of bytes skipped, which may be less than the\n+   * requested amount.\n+   * <p>\n+   * @param numBytes The requested number of bytes to skip\n+   *\n+   * @return The actual number of bytes skipped.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public long skip(long n) throws IOException\n   {\n     long startPos = fd.getFilePointer();\n     long endPos = fd.seek(n, FileDescriptor.CUR, true);\n     return endPos - startPos;\n   }\n \n+  /**\n+   * This method creates a java.nio.channels.FileChannel.\n+   * Nio does not allow one to create a file channel directly.\n+   * A file channel must be created by first creating an instance of\n+   * Input/Output/RandomAccessFile and invoking the getChannel() method on it.\n+   */\n   public FileChannel getChannel ()\n   {\n     synchronized (this)\n@@ -133,4 +290,6 @@ public FileChannel getChannel ()\n         return ch;\n       }\n   }\n-}\n+\n+} // class FileInputStream\n+"}, {"sha": "73b3b90c11bbfb89ba5cfc96c51a011a1f49c585", "filename": "libjava/java/io/LineNumberReader.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FLineNumberReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FLineNumberReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FLineNumberReader.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -100,7 +100,7 @@ public LineNumberReader(Reader in, int size)\n   /**\n     * This method returns the current line number\n     *\n-    * @returns The current line number\n+    * @return The current line number\n     */\n   public int getLineNumber()\n   {"}, {"sha": "2302609837eb44000cc8ac5fe57b102578157bbf", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 130, "deletions": 145, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -57,19 +57,19 @@ public class ObjectInputStream extends InputStream\n   implements ObjectInput, ObjectStreamConstants\n {\n   /**\n-     Creates a new <code>ObjectInputStream</code> that will do all of\n-     its reading from <code>in</code>.  This method also checks\n-     the stream by reading the header information (stream magic number\n-     and stream version).\n-\n-     @exception IOException Reading stream header from underlying\n-     stream cannot be completed.\n-\n-     @exception StreamCorruptedException An invalid stream magic\n-     number or stream version was read from the stream.\n-\n-     @see readStreamHeader ()\n-  */\n+   * Creates a new <code>ObjectInputStream</code> that will do all of\n+   * its reading from <code>in</code>.  This method also checks\n+   * the stream by reading the header information (stream magic number\n+   * and stream version).\n+   *\n+   * @exception IOException Reading stream header from underlying\n+   * stream cannot be completed.\n+   *\n+   * @exception StreamCorruptedException An invalid stream magic\n+   * number or stream version was read from the stream.\n+   *\n+   * @see #readStreamHeader()\n+   */\n   public ObjectInputStream (InputStream in)\n     throws IOException, StreamCorruptedException\n   {\n@@ -104,20 +104,20 @@ else if (dump == true && (val == null || val.equals(\"\")))\n \n \n   /**\n-     Returns the next deserialized object read from the underlying stream.\n-\n-     This method can be overriden by a class by implementing\n-     <code>private void readObject (ObjectInputStream)</code>.\n-\n-     If an exception is thrown from this method, the stream is left in\n-     an undefined state.\n-\n-     @exception ClassNotFoundException The class that an object being\n-     read in belongs to cannot be found.\n-\n-     @exception IOException Exception from underlying\n-     <code>InputStream</code>.\n-  */\n+   * Returns the next deserialized object read from the underlying stream.\n+   *\n+   * This method can be overriden by a class by implementing\n+   * <code>private void readObject (ObjectInputStream)</code>.\n+   *\n+   * If an exception is thrown from this method, the stream is left in\n+   * an undefined state.\n+   *\n+   * @exception ClassNotFoundException The class that an object being\n+   * read in belongs to cannot be found.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>InputStream</code>.\n+   */\n   public final Object readObject () throws ClassNotFoundException, IOException\n   {\n     if (this.useSubclassMethod)\n@@ -452,24 +452,24 @@ public final Object readObject () throws ClassNotFoundException, IOException\n   }\n \n   /**\n-     Reads the current objects non-transient, non-static fields from\n-     the current class from the underlying output stream.\n-\n-     This method is intended to be called from within a object's\n-     <code>private void readObject (ObjectInputStream)</code>\n-     method.\n-\n-     @exception ClassNotFoundException The class that an object being\n-     read in belongs to cannot be found.\n-\n-     @exception NotActiveException This method was called from a\n-     context other than from the current object's and current class's\n-     <code>private void readObject (ObjectInputStream)</code>\n-     method.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-  */\n+   * Reads the current objects non-transient, non-static fields from\n+   * the current class from the underlying output stream.\n+   *\n+   * This method is intended to be called from within a object's\n+   * <code>private void readObject (ObjectInputStream)</code>\n+   * method.\n+   *\n+   * @exception ClassNotFoundException The class that an object being\n+   * read in belongs to cannot be found.\n+   *\n+   * @exception NotActiveException This method was called from a\n+   * context other than from the current object's and current class's\n+   * <code>private void readObject (ObjectInputStream)</code>\n+   * method.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   */\n   public void defaultReadObject ()\n     throws ClassNotFoundException, IOException, NotActiveException\n   {\n@@ -488,23 +488,23 @@ public void defaultReadObject ()\n \n \n   /**\n-     Registers a <code>ObjectInputValidation</code> to be carried out\n-     on the object graph currently being deserialized before it is\n-     returned to the original caller of <code>readObject ()</code>.\n-     The order of validation for multiple\n-     <code>ObjectInputValidation</code>s can be controled using\n-     <code>priority</code>.  Validators with higher priorities are\n-     called first.\n-\n-     @see java.io.ObjectInputValidation\n-\n-     @exception InvalidObjectException <code>validator</code> is\n-     <code>null</code>\n-\n-     @exception NotActiveException an attempt was made to add a\n-     validator outside of the <code>readObject</code> method of the\n-     object currently being deserialized\n-  */\n+   * Registers a <code>ObjectInputValidation</code> to be carried out\n+   * on the object graph currently being deserialized before it is\n+   * returned to the original caller of <code>readObject ()</code>.\n+   * The order of validation for multiple\n+   * <code>ObjectInputValidation</code>s can be controled using\n+   * <code>priority</code>.  Validators with higher priorities are\n+   * called first.\n+   *\n+   * @see java.io.ObjectInputValidation\n+   *\n+   * @exception InvalidObjectException <code>validator</code> is\n+   * <code>null</code>\n+   *\n+   * @exception NotActiveException an attempt was made to add a\n+   * validator outside of the <code>readObject</code> method of the\n+   * object currently being deserialized\n+   */\n   public void registerValidation (ObjectInputValidation validator,\n \t\t\t\t  int priority)\n     throws InvalidObjectException, NotActiveException\n@@ -521,21 +521,21 @@ public void registerValidation (ObjectInputValidation validator,\n \n \n   /**\n-     Called when a class is being deserialized.  This is a hook to\n-     allow subclasses to read in information written by the\n-     <code>annotateClass (Class)</code> method of an\n-     <code>ObjectOutputStream</code>.\n-\n-     This implementation looks up the active call stack for a\n-     <code>ClassLoader</code>; if a <code>ClassLoader</code> is found,\n-     it is used to load the class associated with <code>osc</code>,\n-     otherwise, the default system <code>ClassLoader</code> is used.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-\n-     @see java.io.ObjectOutputStream#annotateClass (java.lang.Class)\n-  */\n+   * Called when a class is being deserialized.  This is a hook to\n+   * allow subclasses to read in information written by the\n+   * <code>annotateClass (Class)</code> method of an\n+   * <code>ObjectOutputStream</code>.\n+   *\n+   * This implementation looks up the active call stack for a\n+   * <code>ClassLoader</code>; if a <code>ClassLoader</code> is found,\n+   * it is used to load the class associated with <code>osc</code>,\n+   * otherwise, the default system <code>ClassLoader</code> is used.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   *\n+   * @see java.io.ObjectOutputStream#annotateClass (java.lang.Class)\n+   */\n   protected Class resolveClass (ObjectStreamClass osc)\n     throws ClassNotFoundException, IOException\n   {\n@@ -555,18 +555,18 @@ protected Class resolveClass (ObjectStreamClass osc)\n   }\n \n   /**\n-     Allows subclasses to resolve objects that are read from the\n-     stream with other objects to be returned in their place.  This\n-     method is called the first time each object is encountered.\n-\n-     This method must be enabled before it will be called in the\n-     serialization process.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-\n-     @see enableResolveObject (boolean)\n-  */\n+   * Allows subclasses to resolve objects that are read from the\n+   * stream with other objects to be returned in their place.  This\n+   * method is called the first time each object is encountered.\n+   *\n+   * This method must be enabled before it will be called in the\n+   * serialization process.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   *\n+   * @see #enableResolveObject(boolean)\n+   */\n   protected Object resolveObject (Object obj) throws IOException\n   {\n     return obj;\n@@ -600,13 +600,13 @@ protected Class resolveProxyClass (String[] intfs)\n   }\n   \n   /**\n-     If <code>enable</code> is <code>true</code> and this object is\n-     trusted, then <code>resolveObject (Object)</code> will be called\n-     in subsequent calls to <code>readObject (Object)</code>.\n-     Otherwise, <code>resolveObject (Object)</code> will not be called.\n-\n-     @exception SecurityException This class is not trusted.\n-  */\n+   * If <code>enable</code> is <code>true</code> and this object is\n+   * trusted, then <code>resolveObject (Object)</code> will be called\n+   * in subsequent calls to <code>readObject (Object)</code>.\n+   * Otherwise, <code>resolveObject (Object)</code> will not be called.\n+   *\n+   * @exception SecurityException This class is not trusted.\n+   */\n   protected boolean enableResolveObject (boolean enable)\n     throws SecurityException\n   {\n@@ -622,16 +622,15 @@ protected boolean enableResolveObject (boolean enable)\n     return old_val;\n   }\n \n-\n   /**\n-     Reads stream magic and stream version information from the\n-     underlying stream.\n-\n-     @exception IOException Exception from underlying stream.\n-\n-     @exception StreamCorruptedException An invalid stream magic\n-     number or stream version was read from the stream.\n-  */\n+   * Reads stream magic and stream version information from the\n+   * underlying stream.\n+   *\n+   * @exception IOException Exception from underlying stream.\n+   *\n+   * @exception StreamCorruptedException An invalid stream magic\n+   * number or stream version was read from the stream.\n+   */\n   protected void readStreamHeader ()\n     throws IOException, StreamCorruptedException\n   {\n@@ -644,7 +643,6 @@ protected void readStreamHeader ()\n       throw new StreamCorruptedException (\"Invalid stream version number\");\n   }\n \n-\n   public int read () throws IOException\n   {\n     if (this.readDataFromBlock)\n@@ -769,9 +767,9 @@ public int skipBytes (int len) throws IOException\n   }\n \n   /**\n-     @deprecated\n-     @see java.io.DataInputStream#readLine ()\n-  */\n+   * @deprecated\n+   * @see java.io.DataInputStream#readLine ()\n+   */\n   public String readLine () throws IOException\n   {\n     return this.dataInputStream.readLine ();\n@@ -782,13 +780,12 @@ public String readUTF () throws IOException\n     return this.dataInputStream.readUTF ();\n   }\n \n-\n   /**\n-     This class allows a class to specify exactly which fields should\n-     be read, and what values should be read for these fields.\n-\n-     XXX: finish up comments\n-  */\n+   * This class allows a class to specify exactly which fields should\n+   * be read, and what values should be read for these fields.\n+   *\n+   * XXX: finish up comments\n+   */\n   public static abstract class GetField\n   {\n     public abstract ObjectStreamClass getObjectStreamClass ();\n@@ -1018,18 +1015,17 @@ private ObjectStreamField getField (String name, Class type)\n \n   }\n \n-\n   /**\n-     Protected constructor that allows subclasses to override\n-     deserialization.  This constructor should be called by subclasses\n-     that wish to override <code>readObject (Object)</code>.  This\n-     method does a security check <i>NOTE: currently not\n-     implemented</i>, then sets a flag that informs\n-     <code>readObject (Object)</code> to call the subclasses\n-     <code>readObjectOverride (Object)</code> method.\n-\n-     @see readObjectOverride (Object)\n-  */\n+   * Protected constructor that allows subclasses to override\n+   * deserialization.  This constructor should be called by subclasses\n+   * that wish to override <code>readObject (Object)</code>.  This\n+   * method does a security check <i>NOTE: currently not\n+   * implemented</i>, then sets a flag that informs\n+   * <code>readObject (Object)</code> to call the subclasses\n+   * <code>readObjectOverride (Object)</code> method.\n+   *\n+   * @see #readObjectOverride()\n+   */\n   protected ObjectInputStream ()\n     throws IOException, SecurityException\n   {\n@@ -1039,23 +1035,21 @@ protected ObjectInputStream ()\n     this.useSubclassMethod = true;\n   }\n \n-\n   /**\n-     This method allows subclasses to override the default\n-     de serialization mechanism provided by\n-     <code>ObjectInputStream</code>.  To make this method be used for\n-     writing objects, subclasses must invoke the 0-argument\n-     constructor on this class from their constructor.\n-\n-     @see ObjectInputStream ()\n-  */\n+   * This method allows subclasses to override the default\n+   * de serialization mechanism provided by\n+   * <code>ObjectInputStream</code>.  To make this method be used for\n+   * writing objects, subclasses must invoke the 0-argument\n+   * constructor on this class from their constructor.\n+   *\n+   * @see #ObjectInputStream()\n+   */\n   protected Object readObjectOverride ()\n     throws ClassNotFoundException, IOException, OptionalDataException\n   {\n     throw new IOException (\"Subclass of ObjectInputStream must implement readObjectOverride\");\n   }\n \n-\n   // assigns the next availible handle to OBJ\n   private int assignNewHandle (Object obj)\n   {\n@@ -1064,7 +1058,6 @@ private int assignNewHandle (Object obj)\n     return this.nextOID++;\n   }\n \n-\n   private Object processResolution (Object obj, int handle)\n     throws IOException\n   {\n@@ -1099,20 +1092,17 @@ private Object processResolution (Object obj, int handle)\n     return obj;\n   }\n \n-\n   private void clearHandles ()\n   {\n     this.objectLookupTable.clear ();\n     this.nextOID = baseWireHandle;\n   }\n \n-\n   private void readNextBlock () throws IOException\n   {\n     readNextBlock (this.realInputStream.readByte ());\n   }\n \n-\n   private void readNextBlock (byte marker) throws IOException\n   {\n     if (marker == TC_BLOCKDATA)\n@@ -1139,7 +1129,6 @@ else if (marker == TC_BLOCKDATALONG)\n     this.blockDataPosition = 0;\n   }\n \n-\n   private void readArrayElements (Object array, Class clazz)\n     throws ClassNotFoundException, IOException\n   {\n@@ -1210,7 +1199,6 @@ private void readArrayElements (Object array, Class clazz)\n       }\n   }\n \n-\n   private void readFields (Object obj, ObjectStreamClass stream_osc)\n     throws ClassNotFoundException, IOException\n   {\n@@ -1374,7 +1362,6 @@ private boolean setBlockDataMode (boolean on)\n     return oldmode;\n   }\n \n-\n   // returns a new instance of REAL_CLASS that has been constructed\n   // only to the level of CONSTRUCTOR_CLASS (a super class of REAL_CLASS)\n   private Object newObject (Class real_class, Class constructor_class)\n@@ -1391,7 +1378,6 @@ private Object newObject (Class real_class, Class constructor_class)\n       }\n   }\n \n-\n   // runs all registered ObjectInputValidations in prioritized order\n   // on OBJ\n   private void invokeValidators () throws InvalidObjectException\n@@ -1411,7 +1397,6 @@ private void invokeValidators () throws InvalidObjectException\n       }\n   }\n \n-\n   // this native method is used to get access to the protected method\n   // of the same name in SecurityManger\n   private static ClassLoader currentClassLoader (SecurityManager sm)"}, {"sha": "afa0acb8abf3edeb03652d5a4323845c37853d7c", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 161, "deletions": 164, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -49,86 +49,85 @@\n import gnu.classpath.Configuration;\n \n /**\n-   An <code>ObjectOutputStream</code> can be used to write objects\n-   as well as primitive data in a platform-independent manner to an\n-   <code>OutputStream</code>.\n-\n-   The data produced by an <code>ObjectOutputStream</code> can be read\n-   and reconstituted by an <code>ObjectInputStream</code>.\n-\n-   <code>writeObject (Object)</code> is used to write Objects, the\n-   <code>write&lt;type&gt;</code> methods are used to write primitive\n-   data (as in <code>DataOutputStream</code>). Strings can be written\n-   as objects or as primitive data.\n-\n-   Not all objects can be written out using an\n-   <code>ObjectOutputStream</code>.  Only those objects that are an\n-   instance of <code>java.io.Serializable</code> can be written.\n-\n-   Using default serialization, information about the class of an\n-   object is written, all of the non-transient, non-static fields of\n-   the object are written, if any of these fields are objects, they are\n-   written out in the same manner.\n-\n-   An object is only written out the first time it is encountered.  If\n-   the object is encountered later, a reference to it is written to\n-   the underlying stream.  Thus writing circular object graphs\n-   does not present a problem, nor are relationships between objects\n-   in a graph lost.\n-\n-   Example usage:\n-   <pre>\n-   Hashtable map = new Hashtable ();\n-   map.put (\"one\", new Integer (1));\n-   map.put (\"two\", new Integer (2));\n-\n-   ObjectOutputStream oos =\n-   new ObjectOutputStream (new FileOutputStream (\"numbers\"));\n-   oos.writeObject (map);\n-   oos.close ();\n-\n-   ObjectInputStream ois =\n-   new ObjectInputStream (new FileInputStream (\"numbers\"));\n-   Hashtable newmap = (Hashtable)ois.readObject ();\n-\n-   System.out.println (newmap);\n-   </pre>\n-\n-   The default serialization can be overriden in two ways.\n-\n-   By defining a method <code>private void\n-   writeObject (ObjectOutputStream)</code>, a class can dictate exactly\n-   how information about itself is written.\n-   <code>defaultWriteObject ()</code> may be called from this method to\n-   carry out default serialization.  This method is not\n-   responsible for dealing with fields of super-classes or subclasses.\n-\n-   By implementing <code>java.io.Externalizable</code>.  This gives\n-   the class complete control over the way it is written to the\n-   stream.  If this approach is used the burden of writing superclass\n-   and subclass data is transfered to the class implementing\n-   <code>java.io.Externalizable</code>.\n-\n-   @see java.io.DataOutputStream\n-   @see java.io.Externalizable\n-   @see java.io.ObjectInputStream\n-   @see java.io.Serializable\n-   @see XXX: java serialization spec\n-*/\n+ * An <code>ObjectOutputStream</code> can be used to write objects\n+ * as well as primitive data in a platform-independent manner to an\n+ * <code>OutputStream</code>.\n+ *\n+ * The data produced by an <code>ObjectOutputStream</code> can be read\n+ * and reconstituted by an <code>ObjectInputStream</code>.\n+ *\n+ * <code>writeObject (Object)</code> is used to write Objects, the\n+ * <code>write&lt;type&gt;</code> methods are used to write primitive\n+ * data (as in <code>DataOutputStream</code>). Strings can be written\n+ * as objects or as primitive data.\n+ *\n+ * Not all objects can be written out using an\n+ * <code>ObjectOutputStream</code>.  Only those objects that are an\n+ * instance of <code>java.io.Serializable</code> can be written.\n+ *\n+ * Using default serialization, information about the class of an\n+ * object is written, all of the non-transient, non-static fields of\n+ * the object are written, if any of these fields are objects, they are\n+ * written out in the same manner.\n+ *\n+ * An object is only written out the first time it is encountered.  If\n+ * the object is encountered later, a reference to it is written to\n+ * the underlying stream.  Thus writing circular object graphs\n+ * does not present a problem, nor are relationships between objects\n+ * in a graph lost.\n+ *\n+ * Example usage:\n+ * <pre>\n+ * Hashtable map = new Hashtable ();\n+ * map.put (\"one\", new Integer (1));\n+ * map.put (\"two\", new Integer (2));\n+ *\n+ * ObjectOutputStream oos =\n+ * new ObjectOutputStream (new FileOutputStream (\"numbers\"));\n+ * oos.writeObject (map);\n+ * oos.close ();\n+ *\n+ * ObjectInputStream ois =\n+ * new ObjectInputStream (new FileInputStream (\"numbers\"));\n+ * Hashtable newmap = (Hashtable)ois.readObject ();\n+ *\n+ * System.out.println (newmap);\n+ * </pre>\n+ *\n+ * The default serialization can be overriden in two ways.\n+ *\n+ * By defining a method <code>private void\n+ * writeObject (ObjectOutputStream)</code>, a class can dictate exactly\n+ * how information about itself is written.\n+ * <code>defaultWriteObject ()</code> may be called from this method to\n+ * carry out default serialization.  This method is not\n+ * responsible for dealing with fields of super-classes or subclasses.\n+ *\n+ * By implementing <code>java.io.Externalizable</code>.  This gives\n+ * the class complete control over the way it is written to the\n+ * stream.  If this approach is used the burden of writing superclass\n+ * and subclass data is transfered to the class implementing\n+ * <code>java.io.Externalizable</code>.\n+ *\n+ * @see java.io.DataOutputStream\n+ * @see java.io.Externalizable\n+ * @see java.io.ObjectInputStream\n+ * @see java.io.Serializable\n+ */\n public class ObjectOutputStream extends OutputStream\n   implements ObjectOutput, ObjectStreamConstants\n {\n   /**\n-     Creates a new <code>ObjectOutputStream</code> that will do all of\n-     its writing onto <code>out</code>.  This method also initializes\n-     the stream by writing the header information (stream magic number\n-     and stream version).\n-\n-     @exception IOException Writing stream header to underlying\n-     stream cannot be completed.\n-\n-     @see writeStreamHeader ()\n-  */\n+   * Creates a new <code>ObjectOutputStream</code> that will do all of\n+   * its writing onto <code>out</code>.  This method also initializes\n+   * the stream by writing the header information (stream magic number\n+   * and stream version).\n+   *\n+   * @exception IOException Writing stream header to underlying\n+   * stream cannot be completed.\n+   *\n+   * @see #writeStreamHeader()\n+   */\n   public ObjectOutputStream (OutputStream out) throws IOException\n   {\n     realOutput = new DataOutputStream (out);\n@@ -145,26 +144,25 @@ public ObjectOutputStream (OutputStream out) throws IOException\n     writeStreamHeader ();\n   }\n \n-\n   /**\n-     Writes a representation of <code>obj</code> to the underlying\n-     output stream by writing out information about its class, then\n-     writing out each of the objects non-transient, non-static\n-     fields.  If any of these fields are other objects,\n-     they are written out in the same manner.\n-\n-     This method can be overriden by a class by implementing\n-     <code>private void writeObject (ObjectOutputStream)</code>.\n-\n-     If an exception is thrown from this method, the stream is left in\n-     an undefined state.\n-\n-     @exception NotSerializableException An attempt was made to\n-     serialize an <code>Object</code> that is not serializable.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-  */\n+   * Writes a representation of <code>obj</code> to the underlying\n+   * output stream by writing out information about its class, then\n+   * writing out each of the objects non-transient, non-static\n+   * fields.  If any of these fields are other objects,\n+   * they are written out in the same manner.\n+   *\n+   * This method can be overriden by a class by implementing\n+   * <code>private void writeObject (ObjectOutputStream)</code>.\n+   *\n+   * If an exception is thrown from this method, the stream is left in\n+   * an undefined state.\n+   *\n+   * @exception NotSerializableException An attempt was made to\n+   * serialize an <code>Object</code> that is not serializable.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   */\n   public final void writeObject (Object obj) throws IOException\n   {\n     if (useSubclassMethod)\n@@ -494,7 +492,7 @@ private void reset (boolean internal) throws IOException\n      @exception IOException if <code>version</code> is not a valid\n      protocol\n \n-     @see setDefaultProtocolVersion (int)\n+     @see #setDefaultProtocolVersion(int)\n   */\n   public void useProtocolVersion (int version) throws IOException\n   {\n@@ -517,7 +515,7 @@ public void useProtocolVersion (int version) throws IOException\n      @exception IOException if <code>version</code> is not a valid\n      protocol\n \n-     @see useProtocolVersion (int)\n+     @see #useProtocolVersion(int)\n   */\n   public static void setDefaultProtocolVersion (int version)\n     throws IOException\n@@ -538,7 +536,7 @@ information about the class has been written.\n      @exception IOException Exception from underlying\n      <code>OutputStream</code>.\n \n-     @see java.io.ObjectInputStream#resolveClass (java.io.ObjectStreamClass)\n+     @see ObjectInputStream#resolveClass(java.io.ObjectStreamClass)\n   */\n   protected void annotateClass (Class cl) throws IOException\n   {}\n@@ -558,7 +556,7 @@ protected void annotateProxyClass(Class cl) throws IOException\n      @exception IOException Exception from underlying\n      <code>OutputStream</code>.\n \n-     @see enableReplaceObject (boolean)\n+     @see #enableReplaceObject(boolean)\n   */\n   protected Object replaceObject (Object obj) throws IOException\n   {\n@@ -606,16 +604,16 @@ protected void writeStreamHeader () throws IOException\n \n \n   /**\n-     Protected constructor that allows subclasses to override\n-     serialization.  This constructor should be called by subclasses\n-     that wish to override <code>writeObject (Object)</code>.  This\n-     method does a security check <i>NOTE: currently not\n-     implemented</i>, then sets a flag that informs\n-     <code>writeObject (Object)</code> to call the subclasses\n-     <code>writeObjectOverride (Object)</code> method.\n-\n-     @see writeObjectOverride (Object)\n-  */\n+   * Protected constructor that allows subclasses to override\n+   * serialization.  This constructor should be called by subclasses\n+   * that wish to override <code>writeObject (Object)</code>.  This\n+   * method does a security check <i>NOTE: currently not\n+   * implemented</i>, then sets a flag that informs\n+   * <code>writeObject (Object)</code> to call the subclasses\n+   * <code>writeObjectOverride (Object)</code> method.\n+   *\n+   * @see #writeObjectOverride(Object)\n+   */\n   protected ObjectOutputStream () throws IOException, SecurityException\n   {\n     SecurityManager sec_man = System.getSecurityManager ();\n@@ -626,17 +624,17 @@ protected ObjectOutputStream () throws IOException, SecurityException\n \n \n   /**\n-     This method allows subclasses to override the default\n-     serialization mechanism provided by\n-     <code>ObjectOutputStream</code>.  To make this method be used for\n-     writing objects, subclasses must invoke the 0-argument\n-     constructor on this class from there constructor.\n-\n-     @see ObjectOutputStream ()\n-\n-     @exception NotActiveException Subclass has arranged for this\n-     method to be called, but did not implement this method.\n-  */\n+   * This method allows subclasses to override the default\n+   * serialization mechanism provided by\n+   * <code>ObjectOutputStream</code>.  To make this method be used for\n+   * writing objects, subclasses must invoke the 0-argument\n+   * constructor on this class from there constructor.\n+   *\n+   * @see #ObjectOutputStream()\n+   *\n+   * @exception NotActiveException Subclass has arranged for this\n+   * method to be called, but did not implement this method.\n+   */\n   protected void writeObjectOverride (Object obj) throws NotActiveException,\n     IOException\n   {\n@@ -645,8 +643,8 @@ protected void writeObjectOverride (Object obj) throws NotActiveException,\n \n \n   /**\n-     @see java.io.DataOutputStream#write (int)\n-  */\n+   * @see DataOutputStream#write(int)\n+   */\n   public void write (int data) throws IOException\n   {\n     if (writeDataAsBlocks)\n@@ -662,17 +660,17 @@ public void write (int data) throws IOException\n \n \n   /**\n-     @see java.io.DataOutputStream#write (byte[])\n-  */\n+   * @see DataOutputStream#write(byte[])\n+   */\n   public void write (byte[] b) throws IOException\n   {\n     write (b, 0, b.length);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#write (byte[],int,int)\n-  */\n+   * @see DataOutputStream#write(byte[],int,int)\n+   */\n   public void write (byte[] b, int off, int len) throws IOException\n   {\n     if (writeDataAsBlocks)\n@@ -698,8 +696,8 @@ public void write (byte[] b, int off, int len) throws IOException\n \n \n   /**\n-     @see java.io.DataOutputStream#flush ()\n-  */\n+   * @see DataOutputStream#flush()\n+   */\n   public void flush () throws IOException\n   {\n     drain ();\n@@ -708,12 +706,12 @@ public void flush () throws IOException\n \n \n   /**\n-     Causes the block-data buffer to be written to the underlying\n-     stream, but does not flush underlying stream.\n-\n-     @exception IOException Exception from underlying\n-     <code>OutputStream</code>.\n-  */\n+   * Causes the block-data buffer to be written to the underlying\n+   * stream, but does not flush underlying stream.\n+   *\n+   * @exception IOException Exception from underlying\n+   * <code>OutputStream</code>.\n+   */\n   protected void drain () throws IOException\n   {\n     if (blockDataCount == 0)\n@@ -727,8 +725,8 @@ protected void drain () throws IOException\n \n \n   /**\n-     @see java.io.DataOutputStream#close ()\n-  */\n+   * @see java.io.DataOutputStream#close ()\n+   */\n   public void close () throws IOException\n   {\n     flush ();\n@@ -737,110 +735,110 @@ public void close () throws IOException\n \n \n   /**\n-     @see java.io.DataOutputStream#writeBoolean (boolean)\n-  */\n+   * @see java.io.DataOutputStream#writeBoolean (boolean)\n+   */\n   public void writeBoolean (boolean data) throws IOException\n   {\n     blockDataOutput.writeBoolean (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeByte (int)\n-  */\n+   * @see java.io.DataOutputStream#writeByte (int)\n+   */\n   public void writeByte (int data) throws IOException\n   {\n     blockDataOutput.writeByte (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeShort (int)\n-  */\n+   * @see java.io.DataOutputStream#writeShort (int)\n+   */\n   public void writeShort (int data) throws IOException\n   {\n     blockDataOutput.writeShort (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeChar (int)\n-  */\n+   * @see java.io.DataOutputStream#writeChar (int)\n+   */\n   public void writeChar (int data) throws IOException\n   {\n     blockDataOutput.writeChar (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeInt (int)\n-  */\n+   * @see java.io.DataOutputStream#writeInt (int)\n+   */\n   public void writeInt (int data) throws IOException\n   {\n     blockDataOutput.writeInt (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeLong (long)\n-  */\n+   * @see java.io.DataOutputStream#writeLong (long)\n+   */\n   public void writeLong (long data) throws IOException\n   {\n     blockDataOutput.writeLong (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeFloat (float)\n-  */\n+   * @see java.io.DataOutputStream#writeFloat (float)\n+   */\n   public void writeFloat (float data) throws IOException\n   {\n     blockDataOutput.writeFloat (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeDouble (double)\n-  */\n+   * @see java.io.DataOutputStream#writeDouble (double)\n+   */\n   public void writeDouble (double data) throws IOException\n   {\n     blockDataOutput.writeDouble (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeBytes (java.lang.String)\n-  */\n+   * @see java.io.DataOutputStream#writeBytes (java.lang.String)\n+   */\n   public void writeBytes (String data) throws IOException\n   {\n     blockDataOutput.writeBytes (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeChars (java.lang.String)\n-  */\n+   * @see java.io.DataOutputStream#writeChars (java.lang.String)\n+   */\n   public void writeChars (String data) throws IOException\n   {\n     dataOutput.writeChars (data);\n   }\n \n \n   /**\n-     @see java.io.DataOutputStream#writeUTF (java.lang.String)\n-  */\n+   * @see java.io.DataOutputStream#writeUTF (java.lang.String)\n+   */\n   public void writeUTF (String data) throws IOException\n   {\n     dataOutput.writeUTF (data);\n   }\n \n \n   /**\n-     This class allows a class to specify exactly which fields should\n-     be written, and what values should be written for these fields.\n-\n-     XXX: finish up comments\n-  */\n+   * This class allows a class to specify exactly which fields should\n+   * be written, and what values should be written for these fields.\n+   *\n+   * XXX: finish up comments\n+   */\n   public static abstract class PutField\n   {\n     public abstract void put (String name, boolean value)\n@@ -864,7 +862,6 @@ public abstract void put (String name, Object value)\n     public abstract void write (ObjectOutput out) throws IOException;\n   }\n \n-\n   public PutField putFields () throws IOException\n   {\n     markFieldsWritten ();"}, {"sha": "a284542d44ae3e391418da665de1310b5dd49705", "filename": "libjava/java/io/OutputStreamWriter.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FOutputStreamWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FOutputStreamWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FOutputStreamWriter.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -47,7 +47,6 @@\n  * API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct, but only supports 8859_1.\n  */\n-\n public class OutputStreamWriter extends Writer\n {\n   BufferedOutputStream out;"}, {"sha": "f3d6eaa73921dbced33a3ca1080e96081f35b1af", "filename": "libjava/java/io/Writer.java", "status": "modified", "additions": 82, "deletions": 108, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe4ebba87d78d4da242adb6e95d2976bd796d91/libjava%2Fjava%2Fio%2FWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FWriter.java?ref=ffe4ebba87d78d4da242adb6e95d2976bd796d91", "patch": "@@ -44,93 +44,75 @@\n  */\n \n /**\n-  * This abstract class forms the base of the hierarchy of classes that \n-  * write output as a stream of chars.  It provides a common set of methods\n-  * for writing chars to stream.  Subclasses implement and/or extend these\n-  * methods to write chars in a particular manner or to a particular \n-  * destination such as a file on disk or network connection.\n-  *\n-  * @author Aaron M. Renn (arenn@urbanophile.com)\n-  * @author Per Bothner <bothner@cygnus.com>\n-  */\n+ * This abstract class forms the base of the hierarchy of classes that \n+ * write output as a stream of chars.  It provides a common set of methods\n+ * for writing chars to stream.  Subclasses implement and/or extend these\n+ * methods to write chars in a particular manner or to a particular \n+ * destination such as a file on disk or network connection.\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Per Bothner <bothner@cygnus.com>\n+ */\n public abstract class Writer\n {\n   /**\n-    * This is the object used to synchronize criticial code sections for\n-    * thread safety.  Subclasses should use this field instead of using\n-    * synchronized methods or explicity synchronizations on <code>this</code>\n-    */\n-  protected Object lock;\n-\n-  /*************************************************************************/\n-\n-  /*\n-   * Constructors\n+   * This is the object used to synchronize criticial code sections for\n+   * thread safety.  Subclasses should use this field instead of using\n+   * synchronized methods or explicity synchronizations on <code>this</code>\n    */\n+  protected Object lock;\n \n   /**\n-    * This is the default no-argument constructor for this class.  This method\n-    * will set up the class to synchronize criticial sections on itself.\n-    */\n+   * This is the default no-argument constructor for this class.  This method\n+   * will set up the class to synchronize criticial sections on itself.\n+   */\n   protected Writer()\n   {\n     lock = this;\n   }\n \n-  /*************************************************************************/\n-\n   /**\n-    * This method initializes a <code>Writer</code> that will synchronize\n-    * on the specified <code>Object</code>.\n-    *\n-    * @param obj The <code>Object</code> to use for synchronizing critical\n-    *            sections\n-    */\n+   * This method initializes a <code>Writer</code> that will synchronize\n+   * on the specified <code>Object</code>.\n+   *\n+   * @param obj The <code>Object</code> to use for synchronizing critical\n+   *            sections\n+   */\n   protected Writer(Object lock)\n   {\n     this.lock = lock;\n   }\n \n-  /*************************************************************************/\n-\n-  /*\n-   * Instance Methods\n-   */\n-\n   /**\n-    * This method forces any data that may have been buffered to be written\n-    * to the underlying output device.  Please note that the host environment\n-    * might perform its own buffering unbeknowst to Java.  In that case, a\n-    * write made (for example, to a disk drive) might be cached in OS\n-    * buffers instead of actually being written to disk.\n-    *\n-    * @exception IOException If an error occurs\n-    */\n+   * This method forces any data that may have been buffered to be written\n+   * to the underlying output device.  Please note that the host environment\n+   * might perform its own buffering unbeknowst to Java.  In that case, a\n+   * write made (for example, to a disk drive) might be cached in OS\n+   * buffers instead of actually being written to disk.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public abstract void flush() throws IOException;\n \n-  /*************************************************************************/\n-\n   /**\n-    * This method closes the stream.  Any internal or native resources \n-    * associated\n-    * with this stream are freed.  Any subsequent attempt to access the stream\n-    * might throw an exception.\n-    * <p>\n-    * This method in this class does nothing.\n-    *\n-    * @exception IOException If an error occurs\n-    */\n+   * This method closes the stream.  Any internal or native resources \n+   * associated\n+   * with this stream are freed.  Any subsequent attempt to access the stream\n+   * might throw an exception.\n+   * <p>\n+   * This method in this class does nothing.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public abstract void close() throws IOException;\n \n-  /*************************************************************************/\n-\n   /**\n-    * This method writes a single char to the output stream. \n-    *\n-    * @param b The char to be written to the output stream, passed as an int\n-    *\n-    * @exception IOException If an error occurs\n-    */\n+   * This method writes a single char to the output stream. \n+   *\n+   * @param b The char to be written to the output stream, passed as an int\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void write(int b) throws IOException\n   {\n     char[] buf = new char[1];\n@@ -139,68 +121,60 @@ public void write(int b) throws IOException\n     write(buf, 0, buf.length);\n   }\n \n-  /*************************************************************************/\n-\n   /**\n-    * This method all the writes char from the passed array to the output \n-    * stream. This method is equivalent to \n-    * <code>write(buf, 0, buf.length)</code> which\n-    * is exactly how it is implemented in this class.\n-    *\n-    * @param buf The array of char to write\n-    *\n-    * @exception IOException If an error occurs\n-    */\n+   * This method all the writes char from the passed array to the output \n+   * stream. This method is equivalent to \n+   * <code>write(buf, 0, buf.length)</code> which\n+   * is exactly how it is implemented in this class.\n+   *\n+   * @param buf The array of char to write\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void write(char[] buf) throws IOException\n   {\n     write(buf, 0, buf.length);\n   }\n \n-  /*************************************************************************/\n-\n   /**\n-    * This method writes <code>len</code> char from the specified array\n-    * <code>buf</code> starting at index <code>offset</code> into the array.\n-    * <p>\n-    * Subclasses must provide an implementation of this abstract method.\n-    *\n-    * @param buf The array of char to write from\n-    * @param offset The index into the array to start writing from\n-    * @param len The number of char to write\n-    * \n-    * @exception IOException If an error occurs\n-    */\n+   * This method writes <code>len</code> char from the specified array\n+   * <code>buf</code> starting at index <code>offset</code> into the array.\n+   * <p>\n+   * Subclasses must provide an implementation of this abstract method.\n+   *\n+   * @param buf The array of char to write from\n+   * @param offset The index into the array to start writing from\n+   * @param len The number of char to write\n+   * \n+   * @exception IOException If an error occurs\n+   */\n   public abstract void write(char[] buf, int offset, int len) \n     throws IOException;\n \n-  /*************************************************************************/\n-\n   /**\n-    * This method writes all the characters in a <code>String</code> to the\n-    * output.\n-    *\n-    * @param str The <code>String</code> whose chars are to be written.\n-    *\n-    * @param IOException If an error occurs\n-    */\n+   * This method writes all the characters in a <code>String</code> to the\n+   * output.\n+   *\n+   * @param str The <code>String</code> whose chars are to be written.\n+   *\n+   * @param IOException If an error occurs\n+   */\n   public void write(String str) throws IOException\n   {\n     write(str, 0, str.length());\n   } \n \n-  /*************************************************************************/\n-\n   /**\n-    * This method writes <code>len</code> chars from the <code>String</code>\n-    * starting at position <code>offset</code>.\n-    *\n-    * @param str The <code>String</code> that is to be written\n-    * @param offset The character offset into the <code>String</code> to start\n-    *               writing from\n-    * @param len The number of chars to write\n-    *\n-    * @exception IOException If an error occurs\n-    */\n+   * This method writes <code>len</code> chars from the <code>String</code>\n+   * starting at position <code>offset</code>.\n+   *\n+   * @param str The <code>String</code> that is to be written\n+   * @param offset The character offset into the <code>String</code> to start\n+   *               writing from\n+   * @param len The number of chars to write\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public void write(String str, int offset, int len) throws IOException\n   {\n     // FIXME - for libgcj re-write using native code to not require "}]}