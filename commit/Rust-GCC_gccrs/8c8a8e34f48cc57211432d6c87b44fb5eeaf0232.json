{"sha": "8c8a8e34f48cc57211432d6c87b44fb5eeaf0232", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM4YThlMzRmNDhjYzU3MjExNDMyZDZjODdiNDRmYjVlZWFmMDIzMg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-06T18:29:05Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-06T18:29:05Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r696", "tree": {"sha": "9c0afadc2784895d1e52ce4d6473407d923e7cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0afadc2784895d1e52ce4d6473407d923e7cb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c8a8e34f48cc57211432d6c87b44fb5eeaf0232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c8a8e34f48cc57211432d6c87b44fb5eeaf0232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c8a8e34f48cc57211432d6c87b44fb5eeaf0232", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c8a8e34f48cc57211432d6c87b44fb5eeaf0232/comments", "author": null, "committer": null, "parents": [{"sha": "915f619f86bf1f576c909e48cda7699d1addbfbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/915f619f86bf1f576c909e48cda7699d1addbfbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/915f619f86bf1f576c909e48cda7699d1addbfbf"}], "stats": {"total": 99, "additions": 65, "deletions": 34}, "files": [{"sha": "c617894ba74427f37e592220a1cb0ce55902bcc2", "filename": "gcc/expr.c", "status": "modified", "additions": 65, "deletions": 34, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c8a8e34f48cc57211432d6c87b44fb5eeaf0232/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c8a8e34f48cc57211432d6c87b44fb5eeaf0232/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8c8a8e34f48cc57211432d6c87b44fb5eeaf0232", "patch": "@@ -3190,24 +3190,30 @@ expand_expr (exp, target, tmode, modifier)\n \t    op0 = expand_expr (exp1, 0, VOIDmode, EXPAND_SUM);\n \t    op0 = memory_address (mode, op0);\n \t  }\n-      }\n-      temp = gen_rtx (MEM, mode, op0);\n-      /* If address was computed by addition,\n-\t mark this as an element of an aggregate.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == PLUS_EXPR\n-\t  || (TREE_CODE (TREE_OPERAND (exp, 0)) == SAVE_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) == PLUS_EXPR)\n-\t  || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n-\t  || TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n-\t  || TREE_CODE (TREE_TYPE (exp)) == UNION_TYPE)\n-\tMEM_IN_STRUCT_P (temp) = 1;\n-      MEM_VOLATILE_P (temp) = TREE_THIS_VOLATILE (exp) || flag_volatile;\n+\n+\ttemp = gen_rtx (MEM, mode, op0);\n+\t/* If address was computed by addition,\n+\t   mark this as an element of an aggregate.  */\n+\tif (TREE_CODE (TREE_OPERAND (exp, 0)) == PLUS_EXPR\n+\t    || (TREE_CODE (TREE_OPERAND (exp, 0)) == SAVE_EXPR\n+\t\t&& TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) == PLUS_EXPR)\n+\t    || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n+\t    || TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE\n+\t    || TREE_CODE (TREE_TYPE (exp)) == UNION_TYPE\n+\t    || (TREE_CODE (exp1) == ADDR_EXPR\n+\t\t&& (exp2 = TREE_OPERAND (exp1, 0))\n+\t\t&& (TREE_CODE (TREE_TYPE (exp2)) == ARRAY_TYPE\n+\t\t    || TREE_CODE (TREE_TYPE (exp2)) == RECORD_TYPE\n+\t\t    || TREE_CODE (TREE_TYPE (exp2)) == UNION_TYPE)))\n+\t  MEM_IN_STRUCT_P (temp) = 1;\n+\tMEM_VOLATILE_P (temp) = TREE_THIS_VOLATILE (exp) || flag_volatile;\n #if 0 /* It is incorrectto set RTX_UNCHANGING_P here, because the fact that\n \t a location is accessed through a pointer to const does not mean\n \t that the value there can never change.  */\n-      RTX_UNCHANGING_P (temp) = TREE_READONLY (exp);\n+\tRTX_UNCHANGING_P (temp) = TREE_READONLY (exp);\n #endif\n-      return temp;\n+\treturn temp;\n+      }\n \n     case ARRAY_REF:\n       if (TREE_CODE (TREE_OPERAND (exp, 1)) != INTEGER_CST\n@@ -3293,15 +3299,29 @@ expand_expr (exp, target, tmode, modifier)\n \t  && TREE_CODE (DECL_INITIAL (TREE_OPERAND (exp, 0))) != ERROR_MARK)\n \t{\n \t  tree index = fold (TREE_OPERAND (exp, 1));\n-\t  if (TREE_CODE (index) == INTEGER_CST)\n+\t  if (TREE_CODE (index) == INTEGER_CST\n+\t      && TREE_INT_CST_HIGH (index) == 0)\n \t    {\n \t      int i = TREE_INT_CST_LOW (index);\n-\t      tree init = CONSTRUCTOR_ELTS (DECL_INITIAL (TREE_OPERAND (exp, 0)));\n+\t      tree init = DECL_INITIAL (TREE_OPERAND (exp, 0));\n \n-\t      while (init && i--)\n-\t\tinit = TREE_CHAIN (init);\n-\t      if (init)\n-\t\treturn expand_expr (fold (TREE_VALUE (init)), target, tmode, modifier);\n+\t      if (TREE_CODE (init) == CONSTRUCTOR)\n+\t\t{\n+\t\t  tree elem = CONSTRUCTOR_ELTS (init);\n+\n+\t\t  while (elem && i--)\n+\t\t    elem = TREE_CHAIN (elem);\n+\t\t  if (elem)\n+\t\t    return expand_expr (fold (TREE_VALUE (elem)), target,\n+\t\t\t\t\ttmode, modifier);\n+\t\t}\n+\t      else if (TREE_CODE (init) == STRING_CST\n+\t\t       && i < TREE_STRING_LENGTH (init))\n+\t\t{\n+\t\t  temp = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t  TREE_STRING_POINTER (init)[i]);\n+\t\t  return convert_to_mode (mode, temp, 0);\n+\t\t}\n \t    }\n \t}\n       /* Treat array-ref with constant index as a component-ref.  */\n@@ -3321,6 +3341,17 @@ expand_expr (exp, target, tmode, modifier)\n \t   directly in an insn, we validate it.  */\n \top0 = expand_expr (tem, 0, VOIDmode, EXPAND_SUM);\n \n+\t/* If this is a constant, put it into a register if it is a\n+\t   legimate constant and memory if it isn't.  */\n+\tif (CONSTANT_P (op0))\n+\t  {\n+\t    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));\n+\t    if (LEGITIMATE_CONSTANT_P (op0))\n+\t      op0 = force_reg (mode, op0);\n+\t    else\n+\t      op0 = validize_mem (force_const_mem (mode, op0));\n+\t  }\n+\n \t/* Don't forget about volatility even if this is a bitfield.  */\n \tif (GET_CODE (op0) == MEM && volatilep && ! MEM_VOLATILE_P (op0))\n \t  {\n@@ -4683,7 +4714,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n     case BUILT_IN_FSQRT:\n       /* If not optimizing, call the library function.  */\n-      if (!optimize)\n+      if (! optimize)\n \tbreak;\n \n       if (arglist == 0\n@@ -4700,21 +4731,21 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       /* Test the argument to make sure it is in the proper domain for\n \t the sqrt function.  If it is not in the domain, branch to a \n \t library call.  */\n-      start_sequence();\n-      lab1 = gen_label_rtx();\n-      lab2 = gen_label_rtx();\n+      start_sequence ();\n+      lab1 = gen_label_rtx ();\n+      lab2 = gen_label_rtx ();\n \n       /* By default check the arguments.  If flag_fast_math is turned on,\n \t then assume sqrt will always be called with valid arguments.  */\n       if (! flag_fast_math) \n \t{\n-\n-\t  /* By checking op >= 1 we are able to catch all of the\n+\t  /* By checking op > 0 we are able to catch all of the\n              IEEE special cases with a single if conditional.  */\n-          emit_cmp_insn (op0, CONST0_RTX (op0->mode), GT, 0, op0->mode, 0, 0);\n+          emit_cmp_insn (op0, CONST0_RTX (GET_MODE (op0)), GT, 0,\n+\t\t\t GET_MODE (op0), 0, 0);\n           emit_jump_insn (gen_bgt (lab1));\n \n-          /* The arguemnt was not in the domain; do this via library call.  */\n+          /* The argument was not in the domain; do this via library call.  */\n           expand_call (exp, target, 0, 0);\n \n           /* Branch around open coded version */\n@@ -4725,23 +4756,23 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       /* Arg is in the domain, compute sqrt, into TARGET. \n \t Set TARGET to wherever the result comes back.  */\n       target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n-\t\t\t    sqrt_optab, op0, target, 1);\n+\t\t\t    sqrt_optab, op0, target, 0);\n \n       /* If we were unable to expand via the builtin, stop the\n \t sequence (without outputting the insns) and break, causing\n \t a call the the library function.  */\n       if (target == 0)\n \t{\n-\t  end_sequence();\n+\t  end_sequence ();\n \t  break;\n         }\n       emit_label (lab2);\n \n \n       /* Output the entire sequence. */\n-      insns = get_insns();\n-      end_sequence();\n-      emit_insns();\n+      insns = get_insns ();\n+      end_sequence ();\n+      emit_insns (insns);\n  \n       return target;\n \n@@ -4986,7 +5017,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       op0 = expand_expr (TREE_VALUE (arglist), 0, VOIDmode, 0);\n \n       /* Allocate the desired space.  */\n-      target = allocate_dynamic_stack_space (op0, target);\n+      target = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n \n       /* Record the new stack level for nonlocal gotos.  */\n       if (nonlocal_goto_stack_level != 0)"}]}