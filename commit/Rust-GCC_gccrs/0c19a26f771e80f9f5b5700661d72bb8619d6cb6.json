{"sha": "0c19a26f771e80f9f5b5700661d72bb8619d6cb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMxOWEyNmY3NzFlODBmOWY1YjU3MDA2NjFkNzJiYjg2MTlkNmNiNg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-05-30T17:49:44Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-05-30T17:49:44Z"}, "message": "cse.c (cse_insn): Simplify REG_EQUAL note on libcalls when making a substitution.\n\n\n\t* cse.c (cse_insn): Simplify REG_EQUAL note on libcalls when\n\tmaking a substitution.\n\t(dead_libcall_p): If directly replacing a libcall with a\n\tconstant value produces an invalid instruction, also try forcing\n\tthe constant into the constant pool.\n\t* expr.c (emit_move_insn): Add a REG_EQUAL note when it is not\n\tobvious that the source is a constant.\n\t(compress_float_constant): Use set_unique_reg_note to place\n\tREG_EQUAL notes on instructions.\n\nFrom-SVN: r67247", "tree": {"sha": "82a94f53b3de8865038ee21fdc4560d6ed2c908f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82a94f53b3de8865038ee21fdc4560d6ed2c908f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c19a26f771e80f9f5b5700661d72bb8619d6cb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c19a26f771e80f9f5b5700661d72bb8619d6cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c19a26f771e80f9f5b5700661d72bb8619d6cb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c19a26f771e80f9f5b5700661d72bb8619d6cb6/comments", "author": null, "committer": null, "parents": [{"sha": "9a38893aa75ebb4447f960f3e5a865e7f580e2cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a38893aa75ebb4447f960f3e5a865e7f580e2cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a38893aa75ebb4447f960f3e5a865e7f580e2cc"}], "stats": {"total": 69, "additions": 50, "deletions": 19}, "files": [{"sha": "ff28c20fbb70530621fc9189796dc363e81041b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c19a26f771e80f9f5b5700661d72bb8619d6cb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c19a26f771e80f9f5b5700661d72bb8619d6cb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c19a26f771e80f9f5b5700661d72bb8619d6cb6", "patch": "@@ -1,3 +1,15 @@\n+2003-05-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* cse.c (cse_insn): Simplify REG_EQUAL note on libcalls when\n+\tmaking a substitution.\n+\t(dead_libcall_p): If directly replacing a libcall with a\n+\tconstant value produces an invalid instruction, also try forcing\n+\tthe constant into the constant pool.\n+\t* expr.c (emit_move_insn): Add a REG_EQUAL note when it is not\n+\tobvious that the source is a constant.\n+\t(compress_float_constant): Use set_unique_reg_note to place\n+\tREG_EQUAL notes on instructions.\n+\n 2003-05-30  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/mips.c (extern_list): Add GTY marker."}, {"sha": "4f59babbfc9ed5f1bf7aa5b397b6d9fdfa371ce0", "filename": "gcc/cse.c", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c19a26f771e80f9f5b5700661d72bb8619d6cb6/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c19a26f771e80f9f5b5700661d72bb8619d6cb6/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=0c19a26f771e80f9f5b5700661d72bb8619d6cb6", "patch": "@@ -5550,8 +5550,8 @@ cse_insn (insn, libcall_insn)\n \t\t  && (GET_CODE (sets[i].orig_src) == REG\n \t\t      || GET_CODE (sets[i].orig_src) == SUBREG\n \t\t      || GET_CODE (sets[i].orig_src) == MEM))\n-\t\treplace_rtx (REG_NOTES (libcall_insn), sets[i].orig_src,\n-\t\t\t     copy_rtx (new));\n+\t\tsimplify_replace_rtx (REG_NOTES (libcall_insn),\n+\t\t\t\t      sets[i].orig_src, copy_rtx (new));\n \n \t      /* The result of apply_change_group can be ignored; see\n \t\t canon_reg.  */\n@@ -7632,33 +7632,49 @@ dead_libcall_p (insn, counts)\n      rtx insn;\n      int *counts;\n {\n-  rtx note;\n+  rtx note, set, new;\n+\n   /* See if there's a REG_EQUAL note on this insn and try to\n      replace the source with the REG_EQUAL expression.\n \n      We assume that insns with REG_RETVALs can only be reg->reg\n      copies at this point.  */\n   note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-  if (note)\n-    {\n-      rtx set = single_set (insn);\n-      rtx new = simplify_rtx (XEXP (note, 0));\n+  if (!note)\n+    return false;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return false;\n \n-      if (!new)\n-\tnew = XEXP (note, 0);\n+  new = simplify_rtx (XEXP (note, 0));\n+  if (!new)\n+    new = XEXP (note, 0);\n \n-      /* While changing insn, we must update the counts accordingly.  */\n-      count_reg_usage (insn, counts, NULL_RTX, -1);\n+  /* While changing insn, we must update the counts accordingly.  */\n+  count_reg_usage (insn, counts, NULL_RTX, -1);\n \n-      if (set && validate_change (insn, &SET_SRC (set), new, 0))\n+  if (validate_change (insn, &SET_SRC (set), new, 0))\n+    {\n+      count_reg_usage (insn, counts, NULL_RTX, 1);\n+      remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n+      remove_note (insn, note);\n+      return true;\n+    }\n+\n+  if (CONSTANT_P (new))\n+    {\n+      new = force_const_mem (GET_MODE (SET_DEST (set)), new);\n+      if (new && validate_change (insn, &SET_SRC (set), new, 0))\n \t{\n-          count_reg_usage (insn, counts, NULL_RTX, 1);\n+\t  count_reg_usage (insn, counts, NULL_RTX, 1);\n \t  remove_note (insn, find_reg_note (insn, REG_RETVAL, NULL_RTX));\n \t  remove_note (insn, note);\n \t  return true;\n \t}\n-       count_reg_usage (insn, counts, NULL_RTX, 1);\n     }\n+      \n+  count_reg_usage (insn, counts, NULL_RTX, 1);\n   return false;\n }\n "}, {"sha": "e3872e8e2693cd958c78ae202dcfcc8dd1416375", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c19a26f771e80f9f5b5700661d72bb8619d6cb6/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c19a26f771e80f9f5b5700661d72bb8619d6cb6/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0c19a26f771e80f9f5b5700661d72bb8619d6cb6", "patch": "@@ -3166,7 +3166,7 @@ emit_move_insn (x, y)\n {\n   enum machine_mode mode = GET_MODE (x);\n   rtx y_cst = NULL_RTX;\n-  rtx last_insn;\n+  rtx last_insn, set;\n \n   x = protect_from_queue (x, 1);\n   y = protect_from_queue (y, 0);\n@@ -3184,9 +3184,10 @@ emit_move_insn (x, y)\n \t  && (last_insn = compress_float_constant (x, y)))\n \treturn last_insn;\n \n+      y_cst = y;\n+\n       if (!LEGITIMATE_CONSTANT_P (y))\n \t{\n-\t  y_cst = y;\n \t  y = force_const_mem (mode, y);\n \n \t  /* If the target's cannot_force_const_mem prevented the spill,\n@@ -3217,7 +3218,10 @@ emit_move_insn (x, y)\n \n   last_insn = emit_move_insn_1 (x, y);\n \n-  if (y_cst && GET_CODE (x) == REG)\n+  if (y_cst && GET_CODE (x) == REG\n+      && (set = single_set (last_insn)) != NULL_RTX\n+      && SET_DEST (set) == x\n+      && ! rtx_equal_p (y_cst, SET_SRC (set)))\n     set_unique_reg_note (last_insn, REG_EQUAL, y_cst);\n \n   return last_insn;\n@@ -3621,8 +3625,7 @@ compress_float_constant (x, y)\n       last_insn = get_last_insn ();\n \n       if (GET_CODE (x) == REG)\n-\tREG_NOTES (last_insn)\n-\t  = gen_rtx_EXPR_LIST (REG_EQUAL, y, REG_NOTES (last_insn));\n+\tset_unique_reg_note (last_insn, REG_EQUAL, y);\n \n       return last_insn;\n     }"}]}