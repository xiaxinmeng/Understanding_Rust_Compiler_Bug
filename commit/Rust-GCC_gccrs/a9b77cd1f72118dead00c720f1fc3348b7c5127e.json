{"sha": "a9b77cd1f72118dead00c720f1fc3348b7c5127e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTliNzdjZDFmNzIxMThkZWFkMDBjNzIwZjFmYzMzNDhiN2M1MTI3ZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-04-27T08:20:39Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-04-27T08:20:39Z"}, "message": "tree-ssa-loop-im.c (determine_invariantness_stmt): Attempt to transform only GIMPLE_MODIFY_STMTs.\n\n\t* tree-ssa-loop-im.c (determine_invariantness_stmt): Attempt to\n\ttransform only GIMPLE_MODIFY_STMTs.\n\t* tree-complex.c (expand_complex_operations_1): Ditto.\n\t(expand_complex_div_wide): Do not create gotos in COND_EXPR branches.\n\t* tree-ssa-loop-manip.c (build_if_stmt): Removed.\n\t(tree_transform_and_unroll_loop): Do not create gotos in COND_EXPR\n\tbranches.\n\t* value-prof.c (tree_divmod_fixed_value, tree_mod_pow2,\n\ttree_mod_subtract, tree_ic, tree_stringop_fixed_value): Ditto.\n\t* omp-low.c (expand_parallel_call, expand_omp_for_generic,\n\texpand_omp_for_static_chunk, expand_omp_for_static_nochunk): Ditto.\n\t* tree-vectorizer.c (slpeel_make_loop_iterate_ntimes,\n\tslpeel_add_loop_guard): Ditto.\n\t* tree-mudflap.c (mf_build_check_statement_for): Ditto.\n\t* lambda-code.c (perfect_nestify): Ditto.\n\t* tree-iterator.c (tsi_split_statement_list_before): Fix splitting\n\tbefore the first statement.\n\t* tree-optimize.c (execute_free_datastructures): Fix comments.\n\t(execute_free_cfg_annotations): Do not call disband_implicit_edges.\n\t* tree-flow.h (disband_implicit_edges): Declaration removed.\n\t* tree-cfg.c (make_cond_expr_edges): Remove gotos from COND_EXPR\n\tbranches.\n\t(cleanup_dead_labels, tree_redirect_edge_and_branch): Handle COND_EXPRs\n\twithout gotos.\n\t(disband_implicit_edges, has_label_p): Removed.\n\t(tree_verify_flow_info): Verify that COND_EXPR branches are empty.\n\t(tree_lv_add_condition_to_bb): Do not create gotos in COND_EXPR\n\tbranches.\n\t* tree.c (build3_stat): Mark COND_EXPRs used as statements as having\n\tside effects.\n\t* tree-pretty-print.c (dump_implicit_edges): Dump implicit edges\n\talso for COND_EXPRs.\n\t* cfgexpand.c (label_rtx_for_bb): New function.\n\t(expand_gimple_cond_expr): Do not expect gotos in COND_EXPR branches.\n\tUse label_rtx_for_bb to find the labels.\n\t(expand_gimple_basic_block): Remove RETURN_EXPR at the end of the\n\tlast block.  Detect fallthru edges.\n\nFrom-SVN: r124214", "tree": {"sha": "27999109f6865e3cf09cab56d6dcff63b98e5594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27999109f6865e3cf09cab56d6dcff63b98e5594"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9b77cd1f72118dead00c720f1fc3348b7c5127e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9b77cd1f72118dead00c720f1fc3348b7c5127e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9b77cd1f72118dead00c720f1fc3348b7c5127e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9b77cd1f72118dead00c720f1fc3348b7c5127e/comments", "author": null, "committer": null, "parents": [{"sha": "f5c3dc96c341e300248c37f76067b5a02d61bffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5c3dc96c341e300248c37f76067b5a02d61bffb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5c3dc96c341e300248c37f76067b5a02d61bffb"}], "stats": {"total": 532, "additions": 242, "deletions": 290}, "files": [{"sha": "447dc85588b72082d7109efbfa8ab7b7de293ad9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -1,3 +1,43 @@\n+2007-04-27  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-im.c (determine_invariantness_stmt): Attempt to\n+\ttransform only GIMPLE_MODIFY_STMTs.\n+\t* tree-complex.c (expand_complex_operations_1): Ditto.\n+\t(expand_complex_div_wide): Do not create gotos in COND_EXPR branches.\n+\t* tree-ssa-loop-manip.c (build_if_stmt): Removed.\n+\t(tree_transform_and_unroll_loop): Do not create gotos in COND_EXPR\n+\tbranches.\n+\t* value-prof.c (tree_divmod_fixed_value, tree_mod_pow2,\n+\ttree_mod_subtract, tree_ic, tree_stringop_fixed_value): Ditto.\n+\t* omp-low.c (expand_parallel_call, expand_omp_for_generic,\n+\texpand_omp_for_static_chunk, expand_omp_for_static_nochunk): Ditto.\n+\t* tree-vectorizer.c (slpeel_make_loop_iterate_ntimes,\n+\tslpeel_add_loop_guard): Ditto.\n+\t* tree-mudflap.c (mf_build_check_statement_for): Ditto.\n+\t* lambda-code.c (perfect_nestify): Ditto.\n+\t* tree-iterator.c (tsi_split_statement_list_before): Fix splitting\n+\tbefore the first statement.\n+\t* tree-optimize.c (execute_free_datastructures): Fix comments.\n+\t(execute_free_cfg_annotations): Do not call disband_implicit_edges.\n+\t* tree-flow.h (disband_implicit_edges): Declaration removed.\n+\t* tree-cfg.c (make_cond_expr_edges): Remove gotos from COND_EXPR\n+\tbranches.\n+\t(cleanup_dead_labels, tree_redirect_edge_and_branch): Handle COND_EXPRs\n+\twithout gotos.\n+\t(disband_implicit_edges, has_label_p): Removed.\n+\t(tree_verify_flow_info): Verify that COND_EXPR branches are empty.\n+\t(tree_lv_add_condition_to_bb): Do not create gotos in COND_EXPR\n+\tbranches.\n+\t* tree.c (build3_stat): Mark COND_EXPRs used as statements as having\n+\tside effects.\n+\t* tree-pretty-print.c (dump_implicit_edges): Dump implicit edges\n+\talso for COND_EXPRs.\n+\t* cfgexpand.c (label_rtx_for_bb): New function.\n+\t(expand_gimple_cond_expr): Do not expect gotos in COND_EXPR branches.\n+\tUse label_rtx_for_bb to find the labels.\n+\t(expand_gimple_basic_block): Remove RETURN_EXPR at the end of the\n+\tlast block.  Detect fallthru edges.\n+\n 2007-04-26  Ian Lance Taylor  <iant@google.com>\n \n \tPR target/28675"}, {"sha": "643ff2071088659a1b8cbdd521e34affa2cf5573", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 82, "deletions": 16, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -1244,6 +1244,38 @@ maybe_dump_rtl_for_tree_stmt (tree stmt, rtx since)\n     }\n }\n \n+/* Returns the label_rtx expression for a label starting basic block BB.  */\n+\n+static rtx\n+label_rtx_for_bb (basic_block bb)\n+{\n+  tree_stmt_iterator tsi;\n+  tree lab, lab_stmt;\n+\n+  if (bb->flags & BB_RTL)\n+    return block_label (bb);\n+\n+  /* We cannot use tree_block_label, as we no longer have stmt annotations.\n+     TODO -- avoid creating the new tree labels.  */\n+  for (tsi = tsi_start (bb_stmt_list (bb)); !tsi_end_p (tsi); tsi_next (&tsi))\n+    {\n+      lab_stmt = tsi_stmt (tsi);\n+      if (TREE_CODE (lab_stmt) != LABEL_EXPR)\n+\tbreak;\n+\n+      lab = LABEL_EXPR_LABEL (lab_stmt);\n+      if (DECL_NONLOCAL (lab))\n+\tbreak;\n+\n+      return label_rtx (lab);\n+    }\n+\n+  lab = create_artificial_label ();\n+  lab_stmt = build1 (LABEL_EXPR, void_type_node, lab);\n+  tsi_link_before (&tsi, lab_stmt, TSI_NEW_STMT);\n+  return label_rtx (lab);\n+}\n+\n /* A subroutine of expand_gimple_basic_block.  Expand one COND_EXPR.\n    Returns a new basic block if we've terminated the current basic\n    block and created a new one.  */\n@@ -1256,10 +1288,10 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n   edge true_edge;\n   edge false_edge;\n   tree pred = COND_EXPR_COND (stmt);\n-  tree then_exp = COND_EXPR_THEN (stmt);\n-  tree else_exp = COND_EXPR_ELSE (stmt);\n   rtx last2, last;\n \n+  gcc_assert (COND_EXPR_THEN (stmt) == NULL_TREE);\n+  gcc_assert (COND_EXPR_ELSE (stmt) == NULL_TREE);\n   last2 = last = get_last_insn ();\n \n   extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n@@ -1275,31 +1307,31 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n \n   /* We can either have a pure conditional jump with one fallthru edge or\n      two-way jump that needs to be decomposed into two basic blocks.  */\n-  if (TREE_CODE (then_exp) == GOTO_EXPR && IS_EMPTY_STMT (else_exp))\n+  if (false_edge->dest == bb->next_bb)\n     {\n-      jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n+      jumpif (pred, label_rtx_for_bb (true_edge->dest));\n       add_reg_br_prob_note (last, true_edge->probability);\n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n-      if (EXPR_LOCUS (then_exp))\n-\temit_line_note (*(EXPR_LOCUS (then_exp)));\n+      if (true_edge->goto_locus)\n+\temit_line_note (*true_edge->goto_locus);\n+      false_edge->flags |= EDGE_FALLTHRU;\n       return NULL;\n     }\n-  if (TREE_CODE (else_exp) == GOTO_EXPR && IS_EMPTY_STMT (then_exp))\n+  if (true_edge->dest == bb->next_bb)\n     {\n-      jumpifnot (pred, label_rtx (GOTO_DESTINATION (else_exp)));\n+      jumpifnot (pred, label_rtx_for_bb (false_edge->dest));\n       add_reg_br_prob_note (last, false_edge->probability);\n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n-      if (EXPR_LOCUS (else_exp))\n-\temit_line_note (*(EXPR_LOCUS (else_exp)));\n+      if (false_edge->goto_locus)\n+\temit_line_note (*false_edge->goto_locus);\n+      true_edge->flags |= EDGE_FALLTHRU;\n       return NULL;\n     }\n-  gcc_assert (TREE_CODE (then_exp) == GOTO_EXPR\n-\t      && TREE_CODE (else_exp) == GOTO_EXPR);\n \n-  jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n+  jumpif (pred, label_rtx_for_bb (true_edge->dest));\n   add_reg_br_prob_note (last, true_edge->probability);\n   last = get_last_insn ();\n-  expand_expr (else_exp, const0_rtx, VOIDmode, 0);\n+  emit_jump (label_rtx_for_bb (false_edge->dest));\n \n   BB_END (bb) = last;\n   if (BARRIER_P (BB_END (bb)))\n@@ -1321,8 +1353,8 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n \n   maybe_dump_rtl_for_tree_stmt (stmt, last2);\n \n-  if (EXPR_LOCUS (else_exp))\n-    emit_line_note (*(EXPR_LOCUS (else_exp)));\n+  if (false_edge->goto_locus)\n+    emit_line_note (*false_edge->goto_locus);\n \n   return new_bb;\n }\n@@ -1457,6 +1489,25 @@ expand_gimple_basic_block (basic_block bb)\n   init_rtl_bb_info (bb);\n   bb->flags |= BB_RTL;\n \n+  /* Remove the RETURN_EXPR if we may fall though to the exit\n+     instead.  */\n+  tsi = tsi_last (stmts);\n+  if (!tsi_end_p (tsi)\n+      && TREE_CODE (tsi_stmt (tsi)) == RETURN_EXPR)\n+    {\n+      tree ret_stmt = tsi_stmt (tsi);\n+\n+      gcc_assert (single_succ_p (bb));\n+      gcc_assert (single_succ (bb) == EXIT_BLOCK_PTR);\n+\n+      if (bb->next_bb == EXIT_BLOCK_PTR\n+\t  && !TREE_OPERAND (ret_stmt, 0))\n+\t{\n+\t  tsi_delink (&tsi);\n+\t  single_succ_edge (bb)->flags |= EDGE_FALLTHRU;\n+\t}\n+    }\n+\n   tsi = tsi_start (stmts);\n   if (!tsi_end_p (tsi))\n     stmt = tsi_stmt (tsi);\n@@ -1546,6 +1597,21 @@ expand_gimple_basic_block (basic_block bb)\n \t}\n     }\n \n+  /* Expand implicit goto.  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      if (e->flags & EDGE_FALLTHRU)\n+\tbreak;\n+    }\n+\n+  if (e && e->dest != bb->next_bb)\n+    {\n+      emit_jump (label_rtx_for_bb (e->dest));\n+      if (e->goto_locus)\n+\temit_line_note (*e->goto_locus);\n+      e->flags &= ~EDGE_FALLTHRU;\n+    }\n+\n   do_pending_stack_adjust ();\n \n   /* Find the block tail.  The last insn in the block is the insn"}, {"sha": "ca07bdc2f042f44763f87de8b0820aca53b0cfc9", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -2450,7 +2450,7 @@ perfect_nestify (struct loop *loop,\n {\n   basic_block *bbs;\n   tree exit_condition;\n-  tree then_label, else_label, cond_stmt;\n+  tree cond_stmt;\n   basic_block preheaderbb, headerbb, bodybb, latchbb, olddest;\n   int i;\n   block_stmt_iterator bsi, firstbsi;\n@@ -2498,13 +2498,11 @@ perfect_nestify (struct loop *loop,\n   bodybb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   latchbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   make_edge (headerbb, bodybb, EDGE_FALLTHRU); \n-  then_label = build1 (GOTO_EXPR, void_type_node, tree_block_label (latchbb));\n-  else_label = build1 (GOTO_EXPR, void_type_node, tree_block_label (olddest));\n   cond_stmt = build3 (COND_EXPR, void_type_node,\n \t\t      build2 (NE_EXPR, boolean_type_node, \n \t\t\t      integer_one_node, \n \t\t\t      integer_zero_node), \n-\t\t      then_label, else_label);\n+\t\t      NULL_TREE, NULL_TREE);\n   bsi = bsi_start (bodybb);\n   bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n   e = make_edge (bodybb, olddest, EDGE_FALSE_VALUE);"}, {"sha": "234c860418f90e0d9b0decb711a5f03e062b445e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 11, "deletions": 43, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -2203,7 +2203,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t{\n \t  basic_block cond_bb, then_bb, else_bb;\n \t  edge e;\n-\t  tree t, then_lab, else_lab, tmp;\n+\t  tree t, tmp;\n \n \t  tmp = create_tmp_var (TREE_TYPE (val), NULL);\n \t  e = split_block (bb, NULL);\n@@ -2213,26 +2213,18 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \n \t  then_bb = create_empty_bb (cond_bb);\n \t  else_bb = create_empty_bb (then_bb);\n-\t  then_lab = create_artificial_label ();\n-\t  else_lab = create_artificial_label ();\n \n \t  t = build3 (COND_EXPR, void_type_node,\n-\t\t      cond,\n-\t\t      build_and_jump (&then_lab),\n-\t\t      build_and_jump (&else_lab));\n+\t\t      cond, NULL_TREE, NULL_TREE);\n \n \t  si = bsi_start (cond_bb);\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n \t  si = bsi_start (then_bb);\n-\t  t = build1 (LABEL_EXPR, void_type_node, then_lab);\n-\t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \t  t = build_gimple_modify_stmt (tmp, val);\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n \t  si = bsi_start (else_bb);\n-\t  t = build1 (LABEL_EXPR, void_type_node, else_lab);\n-\t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \t  t = build_gimple_modify_stmt (tmp, \n \t\t\t\t\tbuild_int_cst (unsigned_type_node, 1));\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n@@ -2579,7 +2571,6 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t\tenum built_in_function start_fn,\n \t\t\tenum built_in_function next_fn)\n {\n-  tree l0, l1, l2 = NULL, l3 = NULL;\n   tree type, istart0, iend0, iend;\n   tree t, list;\n   basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb;\n@@ -2601,18 +2592,12 @@ expand_omp_for_generic (struct omp_region *region,\n   l0_bb = create_empty_bb (entry_bb);\n   l1_bb = single_succ (entry_bb);\n \n-  l0 = tree_block_label (l0_bb);\n-  l1 = tree_block_label (l1_bb);\n-\n   cont_bb = region->cont;\n   exit_bb = region->exit;\n   if (cont_bb)\n     {\n       l2_bb = create_empty_bb (cont_bb);\n       l3_bb = single_succ (cont_bb);\n-\n-      l2 = tree_block_label (l2_bb);\n-      l3 = tree_block_label (l3_bb);\n     }\n \n   si = bsi_last (entry_bb);\n@@ -2640,8 +2625,7 @@ expand_omp_for_generic (struct omp_region *region,\n       t = get_formal_tmp_var (t, &list);\n       if (cont_bb)\n \t{\n-\t  t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l0),\n-\t\t      build_and_jump (&l3));\n+\t  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n \t  append_to_statement_list (t, &list);\n \t}\n       bsi_insert_after (&si, list, BSI_SAME_STMT);\n@@ -2682,8 +2666,7 @@ expand_omp_for_generic (struct omp_region *region,\n   \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, iend);\n   t = get_formal_tmp_var (t, &list);\n-  t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l1),\n-\t      build_and_jump (&l2));\n+  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n   append_to_statement_list (t, &list);\n \n   si = bsi_last (cont_bb);\n@@ -2698,8 +2681,7 @@ expand_omp_for_generic (struct omp_region *region,\n \t\t       build_fold_addr_expr (istart0),\n \t\t       build_fold_addr_expr (iend0));\n   t = get_formal_tmp_var (t, &list);\n-  t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l0),\n-\t      build_and_jump (&l3));\n+  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n   append_to_statement_list (t, &list);\n   \n   si = bsi_start (l2_bb);\n@@ -2768,7 +2750,7 @@ static void\n expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t       struct omp_for_data *fd)\n {\n-  tree l0, l1, l2, n, q, s0, e0, e, t, nthreads, threadid;\n+  tree n, q, s0, e0, e, t, nthreads, threadid;\n   tree type, list;\n   basic_block entry_bb, exit_bb, seq_start_bb, body_bb, cont_bb;\n   basic_block fin_bb;\n@@ -2783,10 +2765,6 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   fin_bb = single_succ (cont_bb);\n   exit_bb = region->exit;\n \n-  l0 = tree_block_label (seq_start_bb);\n-  l1 = tree_block_label (body_bb);\n-  l2 = tree_block_label (fin_bb);\n-\n   /* Iteration space partitioning goes in ENTRY_BB.  */\n   list = alloc_stmt_list ();\n \n@@ -2837,8 +2815,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   e0 = get_formal_tmp_var (t, &list);\n \n   t = build2 (GE_EXPR, boolean_type_node, s0, e0);\n-  t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l2),\n-\t      build_and_jump (&l0));\n+  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n   append_to_statement_list (t, &list);\n \n   si = bsi_last (entry_bb);\n@@ -2872,8 +2849,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, e);\n   t = get_formal_tmp_var (t, &list);\n-  t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&l1),\n-\t      build_and_jump (&l2));\n+  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n   append_to_statement_list (t, &list);\n \n   si = bsi_last (cont_bb);\n@@ -2937,7 +2913,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n static void\n expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n {\n-  tree l0, l1, l2, l3, l4, n, s0, e0, e, t;\n+  tree n, s0, e0, e, t;\n   tree trip, nthreads, threadid;\n   tree type;\n   basic_block entry_bb, exit_bb, body_bb, seq_start_bb, iter_part_bb;\n@@ -2956,12 +2932,6 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   fin_bb = single_succ (cont_bb);\n   exit_bb = region->exit;\n \n-  l0 = tree_block_label (iter_part_bb);\n-  l1 = tree_block_label (seq_start_bb);\n-  l2 = tree_block_label (body_bb);\n-  l3 = tree_block_label (trip_update_bb);\n-  l4 = tree_block_label (fin_bb);\n-\n   /* Trip and adjustment setup goes in ENTRY_BB.  */\n   list = alloc_stmt_list ();\n \n@@ -3021,8 +2991,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   e0 = get_formal_tmp_var (t, &list);\n \n   t = build2 (LT_EXPR, boolean_type_node, s0, n);\n-  t = build3 (COND_EXPR, void_type_node, t,\n-\t      build_and_jump (&l1), build_and_jump (&l4));\n+  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n   append_to_statement_list (t, &list);\n \n   si = bsi_start (iter_part_bb);\n@@ -3055,8 +3024,7 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n \n   t = build2 (fd->cond_code, boolean_type_node, fd->v, e);\n   t = get_formal_tmp_var (t, &list);\n-  t = build3 (COND_EXPR, void_type_node, t,\n-\t      build_and_jump (&l2), build_and_jump (&l3));\n+  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n   append_to_statement_list (t, &list);\n   \n   si = bsi_last (cont_bb);"}, {"sha": "59e1cc3b7ab80d1035e0563a10590a01ebec97dd", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 21, "deletions": 136, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -615,6 +615,10 @@ make_cond_expr_edges (basic_block bb)\n       e->goto_locus = EXPR_LOCUS (COND_EXPR_ELSE (entry));\n #endif\n     }\n+\n+  /* We do not need the gotos anymore.  */\n+  COND_EXPR_THEN (entry) = NULL_TREE;\n+  COND_EXPR_ELSE (entry) = NULL_TREE;\n }\n \n \n@@ -928,10 +932,12 @@ cleanup_dead_labels (void)\n \t    true_branch = COND_EXPR_THEN (stmt);\n \t    false_branch = COND_EXPR_ELSE (stmt);\n \n-\t    GOTO_DESTINATION (true_branch)\n-\t      = main_block_label (GOTO_DESTINATION (true_branch));\n-\t    GOTO_DESTINATION (false_branch)\n-\t      = main_block_label (GOTO_DESTINATION (false_branch));\n+\t    if (true_branch)\n+\t      GOTO_DESTINATION (true_branch)\n+\t\t      = main_block_label (GOTO_DESTINATION (true_branch));\n+\t    if (false_branch)\n+\t      GOTO_DESTINATION (false_branch)\n+\t\t      = main_block_label (GOTO_DESTINATION (false_branch));\n \n \t    break;\n \t  }\n@@ -2522,87 +2528,6 @@ stmt_ends_bb_p (tree t)\n   return is_ctrl_stmt (t) || is_ctrl_altering_stmt (t);\n }\n \n-\n-/* Add gotos that used to be represented implicitly in the CFG.  */\n-\n-void\n-disband_implicit_edges (void)\n-{\n-  basic_block bb;\n-  block_stmt_iterator last;\n-  edge e;\n-  edge_iterator ei;\n-  tree stmt, label;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      last = bsi_last (bb);\n-      stmt = last_stmt (bb);\n-\n-      if (stmt && TREE_CODE (stmt) == COND_EXPR)\n-\t{\n-\t  /* Remove superfluous gotos from COND_EXPR branches.  Moved\n-\t     from cfg_remove_useless_stmts here since it violates the\n-\t     invariants for tree--cfg correspondence and thus fits better\n-\t     here where we do it anyway.  */\n-\t  e = find_edge (bb, bb->next_bb);\n-\t  if (e)\n-\t    {\n-\t      if (e->flags & EDGE_TRUE_VALUE)\n-\t\tCOND_EXPR_THEN (stmt) = build_empty_stmt ();\n-\t      else if (e->flags & EDGE_FALSE_VALUE)\n-\t\tCOND_EXPR_ELSE (stmt) = build_empty_stmt ();\n-\t      else\n-\t\tgcc_unreachable ();\n-\t      e->flags |= EDGE_FALLTHRU;\n-\t    }\n-\n-\t  continue;\n-\t}\n-\n-      if (stmt && TREE_CODE (stmt) == RETURN_EXPR)\n-\t{\n-\t  /* Remove the RETURN_EXPR if we may fall though to the exit\n-\t     instead.  */\n-\t  gcc_assert (single_succ_p (bb));\n-\t  gcc_assert (single_succ (bb) == EXIT_BLOCK_PTR);\n-\n-\t  if (bb->next_bb == EXIT_BLOCK_PTR\n-\t      && !TREE_OPERAND (stmt, 0))\n-\t    {\n-\t      bsi_remove (&last, true);\n-\t      single_succ_edge (bb)->flags |= EDGE_FALLTHRU;\n-\t    }\n-\t  continue;\n-\t}\n-\n-      /* There can be no fallthru edge if the last statement is a control\n-\t one.  */\n-      if (stmt && is_ctrl_stmt (stmt))\n-\tcontinue;\n-\n-      /* Find a fallthru edge and emit the goto if necessary.  */\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  break;\n-\n-      if (!e || e->dest == bb->next_bb)\n-\tcontinue;\n-\n-      gcc_assert (e->dest != EXIT_BLOCK_PTR);\n-      label = tree_block_label (e->dest);\n-\n-      stmt = build1 (GOTO_EXPR, void_type_node, label);\n-#ifdef USE_MAPPED_LOCATION\n-      SET_EXPR_LOCATION (stmt, e->goto_locus);\n-#else\n-      SET_EXPR_LOCUS (stmt, e->goto_locus);\n-#endif\n-      bsi_insert_after (&last, stmt, BSI_NEW_STMT);\n-      e->flags &= ~EDGE_FALLTHRU;\n-    }\n-}\n-\n /* Remove block annotations and other datastructures.  */\n \n void\n@@ -3136,27 +3061,6 @@ tree_split_edge (edge edge_in)\n   return new_bb;\n }\n \n-\n-/* Return true when BB has label LABEL in it.  */\n-\n-static bool\n-has_label_p (basic_block bb, tree label)\n-{\n-  block_stmt_iterator bsi;\n-\n-  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-    {\n-      tree stmt = bsi_stmt (bsi);\n-\n-      if (TREE_CODE (stmt) != LABEL_EXPR)\n-\treturn false;\n-      if (LABEL_EXPR_LABEL (stmt) == label)\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n-\n /* Callback for walk_tree, check that all elements with address taken are\n    properly noticed as such.  The DATA is an int* that is 1 if TP was seen\n    inside a PHI node.  */\n@@ -3789,10 +3693,12 @@ tree_verify_flow_info (void)\n \t  {\n \t    edge true_edge;\n \t    edge false_edge;\n-\t    if (TREE_CODE (COND_EXPR_THEN (stmt)) != GOTO_EXPR\n-\t\t|| TREE_CODE (COND_EXPR_ELSE (stmt)) != GOTO_EXPR)\n+  \n+\t    if (COND_EXPR_THEN (stmt) != NULL_TREE\n+\t\t|| COND_EXPR_ELSE (stmt) != NULL_TREE)\n \t      {\n-\t\terror (\"structured COND_EXPR at the end of bb %d\", bb->index);\n+\t\terror (\"COND_EXPR with code in branches at the end of bb %d\",\n+\t\t       bb->index);\n \t\terr = 1;\n \t      }\n \n@@ -3809,22 +3715,6 @@ tree_verify_flow_info (void)\n \t\t       bb->index);\n \t\terr = 1;\n \t      }\n-\n-\t    if (!has_label_p (true_edge->dest,\n-\t\t\t      GOTO_DESTINATION (COND_EXPR_THEN (stmt))))\n-\t      {\n-\t\terror (\"%<then%> label does not match edge at end of bb %d\",\n-\t\t       bb->index);\n-\t\terr = 1;\n-\t      }\n-\n-\t    if (!has_label_p (false_edge->dest,\n-\t\t\t      GOTO_DESTINATION (COND_EXPR_ELSE (stmt))))\n-\t      {\n-\t\terror (\"%<else%> label does not match edge at end of bb %d\",\n-\t\t       bb->index);\n-\t\terr = 1;\n-\t      }\n \t  }\n \t  break;\n \n@@ -4103,10 +3993,7 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n   switch (stmt ? TREE_CODE (stmt) : ERROR_MARK)\n     {\n     case COND_EXPR:\n-      stmt = (e->flags & EDGE_TRUE_VALUE\n-\t      ? COND_EXPR_THEN (stmt)\n-\t      : COND_EXPR_ELSE (stmt));\n-      GOTO_DESTINATION (stmt) = label;\n+      /* For COND_EXPR, we only need to redirect the edge.  */\n       break;\n \n     case GOTO_EXPR:\n@@ -5676,20 +5563,18 @@ tree_lv_adjust_loop_header_phi (basic_block first, basic_block second,\n    SECOND_HEAD is the destination of the THEN and FIRST_HEAD is\n    the destination of the ELSE part.  */\n static void\n-tree_lv_add_condition_to_bb (basic_block first_head, basic_block second_head,\n-                            basic_block cond_bb, void *cond_e)\n+tree_lv_add_condition_to_bb (basic_block first_head ATTRIBUTE_UNUSED,\n+\t\t\t     basic_block second_head ATTRIBUTE_UNUSED,\n+\t\t\t     basic_block cond_bb, void *cond_e)\n {\n   block_stmt_iterator bsi;\n-  tree goto1 = NULL_TREE;\n-  tree goto2 = NULL_TREE;\n   tree new_cond_expr = NULL_TREE;\n   tree cond_expr = (tree) cond_e;\n   edge e0;\n \n   /* Build new conditional expr */\n-  goto1 = build1 (GOTO_EXPR, void_type_node, tree_block_label (first_head));\n-  goto2 = build1 (GOTO_EXPR, void_type_node, tree_block_label (second_head));\n-  new_cond_expr = build3 (COND_EXPR, void_type_node, cond_expr, goto1, goto2);\n+  new_cond_expr = build3 (COND_EXPR, void_type_node, cond_expr,\n+\t\t\t  NULL_TREE, NULL_TREE);\n \n   /* Add new cond in cond_bb.  */\n   bsi = bsi_start (cond_bb);"}, {"sha": "71ebeacc408d91a3caac9f83697d6e1d2167c94b", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -1060,11 +1060,6 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n       bb_true = create_empty_bb (bb_cond);\n       bb_false = create_empty_bb (bb_true);\n \n-      t1 = build1 (GOTO_EXPR, void_type_node, tree_block_label (bb_true));\n-      t2 = build1 (GOTO_EXPR, void_type_node, tree_block_label (bb_false));\n-      COND_EXPR_THEN (cond) = t1;\n-      COND_EXPR_ELSE (cond) = t2;\n-\n       /* Wire the blocks together.  */\n       e->flags = EDGE_TRUE_VALUE;\n       redirect_edge_succ (e, bb_true);\n@@ -1377,8 +1372,15 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n \n     default:\n       {\n-\ttree lhs = GENERIC_TREE_OPERAND (stmt, 0);\n-\ttree rhs = GENERIC_TREE_OPERAND (stmt, 1);\n+\ttree lhs, rhs;\n+\n+\t/* COND_EXPR may also fallthru here, but we do not need to do anything\n+\t   with it.  */\n+\tif (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+\t  return;\n+\n+\tlhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+\trhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \tif (TREE_CODE (type) == COMPLEX_TYPE)\n \t  expand_complex_move (bsi, stmt, type, lhs, rhs);"}, {"sha": "d308299897f929dc8a5050fd0f1e6172d3f547da", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -722,7 +722,6 @@ extern void free_omp_regions (void);\n #define PENDING_STMT(e)\t((e)->insns.t)\n \n extern void delete_tree_cfg_annotations (void);\n-extern void disband_implicit_edges (void);\n extern bool stmt_ends_bb_p (tree);\n extern bool is_ctrl_stmt (tree);\n extern bool is_ctrl_altering_stmt (tree);"}, {"sha": "ac033ae5c39d3b00ddbd6dff9409f10239bf2a07", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -291,6 +291,8 @@ tsi_split_statement_list_before (tree_stmt_iterator *i)\n   cur->prev = NULL;\n   if (prev)\n     prev->next = NULL;\n+  else\n+    STATEMENT_LIST_HEAD (old_sl) = NULL;\n \n   return new_sl;\n }"}, {"sha": "72e53e6bdaa937ac4d2240bd03d0b696782b049b", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -630,9 +630,7 @@ mf_build_check_statement_for (tree base, tree limit,\n \n   /* Build the conditional jump.  'cond' is just a temporary so we can\n      simply build a void COND_EXPR.  We do need labels in both arms though.  */\n-  t = build3 (COND_EXPR, void_type_node, cond,\n-              build1 (GOTO_EXPR, void_type_node, tree_block_label (then_bb)),\n-              build1 (GOTO_EXPR, void_type_node, tree_block_label (join_bb)));\n+  t = build3 (COND_EXPR, void_type_node, cond, NULL_TREE, NULL_TREE);\n   SET_EXPR_LOCUS (t, locus);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n@@ -685,7 +683,6 @@ mf_build_check_statement_for (tree base, tree limit,\n     bsi_insert_after (&bsi, tsi_stmt (tsi), BSI_CONTINUE_LINKING);\n \n   *instr_bsi = bsi_start (join_bb);\n-  bsi_next (instr_bsi);\n }\n \n "}, {"sha": "c9f24cb336d8c64b22bfdac91b7f1a52f0f2f1d7", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -208,13 +208,10 @@ struct tree_opt_pass pass_cleanup_cfg_post_optimizing =\n static unsigned int\n execute_free_datastructures (void)\n {\n-  /* ??? This isn't the right place for this.  Worse, it got computed\n-     more or less at random in various passes.  */\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n-  /* Remove the ssa structures.  Do it here since this includes statement\n-     annotations that need to be intact during disband_implicit_edges.  */\n+  /* Remove the ssa structures.  */\n   if (cfun->gimple_df)\n     delete_tree_ssa ();\n   return 0;\n@@ -241,9 +238,6 @@ struct tree_opt_pass pass_free_datastructures =\n static unsigned int\n execute_free_cfg_annotations (void)\n {\n-  /* Emit gotos for implicit jumps.  */\n-  disband_implicit_edges ();\n-\n   /* And get rid of annotations we no longer need.  */\n   delete_tree_cfg_annotations ();\n "}, {"sha": "09d203fa29b1733ed42b0ebcf19e739815048fc8", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -2958,6 +2958,29 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n {\n   edge e;\n   edge_iterator ei;\n+  tree stmt;\n+\n+  stmt = last_stmt (bb);\n+  if (stmt && TREE_CODE (stmt) == COND_EXPR)\n+    {\n+      edge true_edge, false_edge;\n+\n+      /* When we are emitting the code or changing CFG, it is possible that\n+\t the edges are not yet created.  When we are using debug_bb in such\n+\t a situation, we do not want it to crash.  */\n+      if (EDGE_COUNT (bb->succs) != 2)\n+\treturn;\n+      extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+\n+      INDENT (indent + 2);\n+      pp_cfg_jump (buffer, true_edge->dest);\n+      newline_and_indent (buffer, indent);\n+      pp_string (buffer, \"else\");\n+      newline_and_indent (buffer, indent + 2);\n+      pp_cfg_jump (buffer, false_edge->dest);\n+      pp_newline (buffer);\n+      return;\n+    }\n \n   /* If there is a fallthru edge, we may need to add an artificial goto to the\n      dump.  */"}, {"sha": "c5578cfc9e37fedb84d68ea72969758851c05d45", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -731,29 +731,32 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t  continue;\n \t}\n \n-      rhs = GENERIC_TREE_OPERAND (stmt, 1);\n-\n-      /* If divisor is invariant, convert a/b to a*(1/b), allowing reciprocal\n-\t to be hoisted out of loop, saving expensive divide.  */\n-      if (pos == MOVE_POSSIBLE\n-\t  && TREE_CODE (rhs) == RDIV_EXPR\n-\t  && flag_unsafe_math_optimizations\n-\t  && !flag_trapping_math\n-\t  && outermost_invariant_loop_expr (TREE_OPERAND (rhs, 1),\n-\t\t\t\t\t    loop_containing_stmt (stmt)) != NULL\n-\t  && outermost_invariant_loop_expr (rhs,\n-\t\t\t\t\t    loop_containing_stmt (stmt)) == NULL)\n-\tstmt = rewrite_reciprocal (&bsi);\n-\n-      /* If the shift count is invariant, convert (A >> B) & 1 to\n-\t A & (1 << B) allowing the bit mask to be hoisted out of the loop\n-\t saving an expensive shift.  */\n-      if (pos == MOVE_POSSIBLE\n-\t  && TREE_CODE (rhs) == BIT_AND_EXPR\n-\t  && integer_onep (TREE_OPERAND (rhs, 1))\n-\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n-\t  && has_single_use (TREE_OPERAND (rhs, 0)))\n-\tstmt = rewrite_bittest (&bsi);\n+      if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)\n+\t{\n+\t  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+\n+\t  /* If divisor is invariant, convert a/b to a*(1/b), allowing reciprocal\n+\t     to be hoisted out of loop, saving expensive divide.  */\n+\t  if (pos == MOVE_POSSIBLE\n+\t      && TREE_CODE (rhs) == RDIV_EXPR\n+\t      && flag_unsafe_math_optimizations\n+\t      && !flag_trapping_math\n+\t      && outermost_invariant_loop_expr (TREE_OPERAND (rhs, 1),\n+\t\t\t\t\t\tloop_containing_stmt (stmt)) != NULL\n+\t      && outermost_invariant_loop_expr (rhs,\n+\t\t\t\t\t\tloop_containing_stmt (stmt)) == NULL)\n+\t    stmt = rewrite_reciprocal (&bsi);\n+\n+\t  /* If the shift count is invariant, convert (A >> B) & 1 to\n+\t     A & (1 << B) allowing the bit mask to be hoisted out of the loop\n+\t     saving an expensive shift.  */\n+\t  if (pos == MOVE_POSSIBLE\n+\t      && TREE_CODE (rhs) == BIT_AND_EXPR\n+\t      && integer_onep (TREE_OPERAND (rhs, 1))\n+\t      && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+\t      && has_single_use (TREE_OPERAND (rhs, 0)))\n+\t    stmt = rewrite_bittest (&bsi);\n+\t}\n \n       stmt_ann (stmt)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n       LIM_DATA (stmt)->always_executed_in = outermost;"}, {"sha": "7611a6f2a5da66cba7667d856a192293acf5c9d7", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -604,17 +604,6 @@ tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   return true;\n }\n \n-/* Build if (COND) goto THEN_LABEL; else goto ELSE_LABEL;  */\n-\n-static tree\n-build_if_stmt (tree cond, tree then_label, tree else_label)\n-{\n-  return build3 (COND_EXPR, void_type_node,\n-\t\t cond,\n-\t\t build1 (GOTO_EXPR, void_type_node, then_label),\n-\t\t build1 (GOTO_EXPR, void_type_node, else_label));\n-}\n-\n /* Returns true if we can unroll LOOP FACTOR times.  Number\n    of iterations of the loop is returned in NITER.  */\n \n@@ -932,9 +921,9 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n \t\t\t\t  REG_BR_PROB_BASE - exit->probability);\n \n   bsi = bsi_last (exit_bb);\n-  exit_if = build_if_stmt (boolean_true_node,\n-\t\t\t   tree_block_label (loop->latch),\n-\t\t\t   tree_block_label (rest));\n+  exit_if = build3 (COND_EXPR, void_type_node, boolean_true_node,\n+\t\t    NULL_TREE, NULL_TREE);\n+\n   bsi_insert_after (&bsi, exit_if, BSI_NEW_STMT);\n   new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);\n   rescan_loop_exit (new_exit, true, false);"}, {"sha": "d235a4917bae464ea5db01800be4baf2c9004bec", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -767,12 +767,8 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   block_stmt_iterator loop_cond_bsi;\n   block_stmt_iterator incr_bsi;\n   bool insert_after;\n-  tree begin_label = tree_block_label (loop->latch);\n-  tree exit_label = tree_block_label (single_exit (loop)->dest);\n   tree init = build_int_cst (TREE_TYPE (niters), 0);\n   tree step = build_int_cst (TREE_TYPE (niters), 1);\n-  tree then_label;\n-  tree else_label;\n   LOC loop_loc;\n \n   orig_cond = get_loop_exit_condition (loop);\n@@ -784,20 +780,12 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n              &incr_bsi, insert_after, &indx_before_incr, &indx_after_incr);\n \n   if (exit_edge->flags & EDGE_TRUE_VALUE) /* 'then' edge exits the loop.  */\n-    {\n-      cond = build2 (GE_EXPR, boolean_type_node, indx_after_incr, niters);\n-      then_label = build1 (GOTO_EXPR, void_type_node, exit_label);\n-      else_label = build1 (GOTO_EXPR, void_type_node, begin_label);\n-    }\n+    cond = build2 (GE_EXPR, boolean_type_node, indx_after_incr, niters);\n   else /* 'then' edge loops back.  */\n-    {\n-      cond = build2 (LT_EXPR, boolean_type_node, indx_after_incr, niters);\n-      then_label = build1 (GOTO_EXPR, void_type_node, begin_label);\n-      else_label = build1 (GOTO_EXPR, void_type_node, exit_label);\n-    }\n+    cond = build2 (LT_EXPR, boolean_type_node, indx_after_incr, niters);\n \n   cond_stmt = build3 (COND_EXPR, TREE_TYPE (orig_cond), cond,\n-\t\t     then_label, else_label);\n+\t\t      NULL_TREE, NULL_TREE);\n   bsi_insert_before (&loop_cond_bsi, cond_stmt, BSI_SAME_STMT);\n \n   /* Remove old loop exit test:  */\n@@ -935,19 +923,15 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb,\n {\n   block_stmt_iterator bsi;\n   edge new_e, enter_e;\n-  tree cond_stmt, then_label, else_label;\n+  tree cond_stmt;\n \n   enter_e = EDGE_SUCC (guard_bb, 0);\n   enter_e->flags &= ~EDGE_FALLTHRU;\n   enter_e->flags |= EDGE_FALSE_VALUE;\n   bsi = bsi_last (guard_bb);\n \n-  then_label = build1 (GOTO_EXPR, void_type_node,\n-                       tree_block_label (exit_bb));\n-  else_label = build1 (GOTO_EXPR, void_type_node,\n-                       tree_block_label (enter_e->dest));\n   cond_stmt = build3 (COND_EXPR, void_type_node, cond,\n-   \t\t     then_label, else_label);\n+\t\t      NULL_TREE, NULL_TREE);\n   bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n   /* Add new edge to connect guard block to the merge/loop-exit block.  */\n   new_e = make_edge (guard_bb, exit_bb, EDGE_TRUE_VALUE);"}, {"sha": "1f2e91919e8a86fa8e56cb770089809113228625", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -3128,7 +3128,16 @@ build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   t = make_node_stat (code PASS_MEM_STAT);\n   TREE_TYPE (t) = tt;\n \n-  side_effects = TREE_SIDE_EFFECTS (t);\n+  /* As a special exception, if COND_EXPR has NULL branches, we\n+     assume that it is a gimple statement and always consider\n+     it to have side effects.  */\n+  if (code == COND_EXPR\n+      && tt == void_type_node\n+      && arg1 == NULL_TREE\n+      && arg2 == NULL_TREE)\n+    side_effects = true;\n+  else\n+    side_effects = TREE_SIDE_EFFECTS (t);\n \n   PROCESS_ARG(0);\n   PROCESS_ARG(1);"}, {"sha": "e015855e8ac77aa2d14af76b69c60b22ed7d5d4c", "filename": "gcc/value-prof.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9b77cd1f72118dead00c720f1fc3348b7c5127e/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=a9b77cd1f72118dead00c720f1fc3348b7c5127e", "patch": "@@ -527,8 +527,7 @@ tree_divmod_fixed_value (tree stmt, tree operation,\n   stmt2 = build_gimple_modify_stmt (tmp1, op2);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t    build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl2),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl1));\n+\t    NULL_TREE, NULL_TREE);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n@@ -689,8 +688,7 @@ tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob,\n   stmt4 = build3 (COND_EXPR, void_type_node,\n \t\t  build2 (NE_EXPR, boolean_type_node,\n \t\t\t  tmp3, build_int_cst (optype, 0)),\n-\t\t  build1 (GOTO_EXPR, void_type_node, label_decl2),\n-\t \t  build1 (GOTO_EXPR, void_type_node, label_decl1));\n+\t\t  NULL_TREE, NULL_TREE);\n   bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt4, BSI_SAME_STMT);\n@@ -845,9 +843,7 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n   stmt2 = build_gimple_modify_stmt (tmp1, op2);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t    build2 (LT_EXPR, boolean_type_node, result, tmp1),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl3),\n-\t    build1 (GOTO_EXPR, void_type_node, \n-\t\t    ncounts ? label_decl1 : label_decl2));\n+\t    NULL_TREE, NULL_TREE);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n@@ -861,8 +857,7 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n \t\t\t\t\t\tresult, tmp1));\n       stmt2 = build3 (COND_EXPR, void_type_node,\n \t\tbuild2 (LT_EXPR, boolean_type_node, result, tmp1),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl3),\n-\t\tbuild1 (GOTO_EXPR, void_type_node, label_decl2));\n+\t\tNULL_TREE, NULL_TREE);\n       bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n       bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n       bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n@@ -1084,8 +1079,7 @@ tree_ic (tree stmt, tree call, struct cgraph_node* direct_call,\n   stmt2 = build_gimple_modify_stmt (tmp1, tmp);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t\t  build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n-\t\t  build1 (GOTO_EXPR, void_type_node, label_decl2),\n-\t\t  build1 (GOTO_EXPR, void_type_node, label_decl1));\n+\t\t  NULL_TREE, NULL_TREE);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n@@ -1288,8 +1282,7 @@ tree_stringop_fixed_value (tree stmt, tree value, int prob, gcov_type count,\n   stmt2 = build_gimple_modify_stmt (tmp1, blck_size);\n   stmt3 = build3 (COND_EXPR, void_type_node,\n \t    build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl2),\n-\t    build1 (GOTO_EXPR, void_type_node, label_decl1));\n+\t    NULL_TREE, NULL_TREE);\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n   bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);"}]}