{"sha": "dac3bede918b07ddb13d2efae1fbda9f4d81468f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFjM2JlZGU5MThiMDdkZGIxM2QyZWZhZTFmYmRhOWY0ZDgxNDY4Zg==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2011-08-04T13:35:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T13:35:20Z"}, "message": "gnat_rm.texi: Document new pragma and aspect.\n\n2011-08-04  Yannick Moy  <moy@adacore.com>\n\n\t* gnat_rm.texi: Document new pragma and aspect.\n\t* aspects.adb, aspects.ads (Aspect_Id): new value Aspect_Test_Case\n\t(No_Duplicates_Allowed): new constant array defining whether duplicates\n\taspects of each kind can appear on the same declaration.\n\t* einfo.adb, einfo.ads (Spec_PPC_List): replace field with Contract\n\tfield, which points to a node holding the previous Spec_PPC_List.\n\t* exp_ch9.adb, sem_ch6.adb, sem_prag.adb: Reach to Spec_PPC_List\n\tthrough the indirection with Contract.\n\t* exp_util.adb (Insert_Actions): raise Program_Error on N_Contract node\n\t* par-prag.adb (Prag): do nothing on Test_Case pragma\n\t* sem.adb (Analyze): abort on N_Contract, on which Analyze should not\n\tbe called directly.\n\t* sem_attr.adb (Analyze_Attribute): allow attribute 'Result in\n\tcomponent Ensures of Test_Case.\n\t* sem_ch12.adb, sem_ch6.adb, sem_ch9.adb\n\t(Analyze_Generic_Subprogram_Declaration,\n\tAnalyze_Subprogram_Instantiation,\n\tAnalyze_Abstract_Subprogram_Declaration,\n\tAnalyze_Subprogram_Body_Helper,\n\tAnalyze_Subprogram_Specification, Analyze_Entry_Declaration):\n\tinsert contract in subprogram node at point of definition\n\t* sem_ch13.adb\n\t(Aspect_Loop): do not raise error on duplicate Test_Case aspect\n\t(Analyze_Aspect_Specifications): analyze Test_Case aspect and create\n\tcorresponding pragma\n\t(Check_Aspect_At_Freeze_Point): raise Program_Error on Test_Case aspect\n\t* sem_ch3.adb (Analyze_Declarations): insert analysis of test-cases,\n\tsimilar to the analysis of pre/post\n\t(Derive_Subprogram): insert contract in subprogram node at point of\n\tderivation.\n\t* sem_prag.adb, sem_prag.ads\n\t(Check_Arg_Is_String_Literal, Check_Identifier):\n\tnew checking procedures to be called in treatment of pragmas\n\t(Check_Test_Case): new procedure to check that a Test_Case aspect or\n\tpragma is well-formed. This does not check currently that 'Result is\n\tused only in the Ensures component of a Test_Case.\n\t(Analyze_Pragma): add case for Test_Case\n\t(Analyze_TC_In_Decl_Part): pre-analyze the Requires and Ensures\n\tcomponents of a Test_Case.\n\t(Preanalyze_TC_Args): new procedure to preanalyze the boolean\n\texpressions in the 3rd (and 4th if present) arguments of a Test_Case\n\tpragma, treated as spec expressions.\n\t(Sig_Flags): add value -1 for Test_Case.\n\t* sem_util.adb, sem_util.ads (Get_Ensures_From_Test_Case_Pragma,\n\tGet_Requires_From_Test_Case_Pragma): getters for both expression\n\tcomponents of a Test_Case.\n\t* sinfo.adb, sinfo.ads (N_Contract): new kind of node used as\n\tindirection between an entry or [generic] subprogram entity and its\n\tpre/post + test-cases.\n\t(Spec_PPC_List, Spec_TC_List, Set_Spec_PPC_List, Set_Spec_TC_List):\n\tget/set for fields of an N_Contract node.\n\t* snames.ads-tmpl (Name_Test_Case, Name_Ensures, Name_Mode,\n\tName_Normal, Name_Requires, Name_Robustness, Pragma_Test_Case): new\n\tnames and pragma for Test_Case.\n\t* sprint.adb (Sprint_Node): raise Program_Error on N_Contract node\n\nFrom-SVN: r177384", "tree": {"sha": "3271b6f6746528c923b82c8e00d9fe866622065a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3271b6f6746528c923b82c8e00d9fe866622065a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dac3bede918b07ddb13d2efae1fbda9f4d81468f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac3bede918b07ddb13d2efae1fbda9f4d81468f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dac3bede918b07ddb13d2efae1fbda9f4d81468f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dac3bede918b07ddb13d2efae1fbda9f4d81468f/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a2e5d0f3d52360a6a0f036a19cedffbd4b8bd42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2e5d0f3d52360a6a0f036a19cedffbd4b8bd42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a2e5d0f3d52360a6a0f036a19cedffbd4b8bd42"}], "stats": {"total": 891, "additions": 777, "deletions": 114}, "files": [{"sha": "8484bcfac187d68460ab0db878cbcf16b4731cdf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -1,3 +1,61 @@\n+2011-08-04  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat_rm.texi: Document new pragma and aspect.\n+\t* aspects.adb, aspects.ads (Aspect_Id): new value Aspect_Test_Case\n+\t(No_Duplicates_Allowed): new constant array defining whether duplicates\n+\taspects of each kind can appear on the same declaration.\n+\t* einfo.adb, einfo.ads (Spec_PPC_List): replace field with Contract\n+\tfield, which points to a node holding the previous Spec_PPC_List.\n+\t* exp_ch9.adb, sem_ch6.adb, sem_prag.adb: Reach to Spec_PPC_List\n+\tthrough the indirection with Contract.\n+\t* exp_util.adb (Insert_Actions): raise Program_Error on N_Contract node\n+\t* par-prag.adb (Prag): do nothing on Test_Case pragma\n+\t* sem.adb (Analyze): abort on N_Contract, on which Analyze should not\n+\tbe called directly.\n+\t* sem_attr.adb (Analyze_Attribute): allow attribute 'Result in\n+\tcomponent Ensures of Test_Case.\n+\t* sem_ch12.adb, sem_ch6.adb, sem_ch9.adb\n+\t(Analyze_Generic_Subprogram_Declaration,\n+\tAnalyze_Subprogram_Instantiation,\n+\tAnalyze_Abstract_Subprogram_Declaration,\n+\tAnalyze_Subprogram_Body_Helper,\n+\tAnalyze_Subprogram_Specification, Analyze_Entry_Declaration):\n+\tinsert contract in subprogram node at point of definition\n+\t* sem_ch13.adb\n+\t(Aspect_Loop): do not raise error on duplicate Test_Case aspect\n+\t(Analyze_Aspect_Specifications): analyze Test_Case aspect and create\n+\tcorresponding pragma\n+\t(Check_Aspect_At_Freeze_Point): raise Program_Error on Test_Case aspect\n+\t* sem_ch3.adb (Analyze_Declarations): insert analysis of test-cases,\n+\tsimilar to the analysis of pre/post\n+\t(Derive_Subprogram): insert contract in subprogram node at point of\n+\tderivation.\n+\t* sem_prag.adb, sem_prag.ads\n+\t(Check_Arg_Is_String_Literal, Check_Identifier):\n+\tnew checking procedures to be called in treatment of pragmas\n+\t(Check_Test_Case): new procedure to check that a Test_Case aspect or\n+\tpragma is well-formed. This does not check currently that 'Result is\n+\tused only in the Ensures component of a Test_Case.\n+\t(Analyze_Pragma): add case for Test_Case\n+\t(Analyze_TC_In_Decl_Part): pre-analyze the Requires and Ensures\n+\tcomponents of a Test_Case.\n+\t(Preanalyze_TC_Args): new procedure to preanalyze the boolean\n+\texpressions in the 3rd (and 4th if present) arguments of a Test_Case\n+\tpragma, treated as spec expressions.\n+\t(Sig_Flags): add value -1 for Test_Case.\n+\t* sem_util.adb, sem_util.ads (Get_Ensures_From_Test_Case_Pragma,\n+\tGet_Requires_From_Test_Case_Pragma): getters for both expression\n+\tcomponents of a Test_Case.\n+\t* sinfo.adb, sinfo.ads (N_Contract): new kind of node used as\n+\tindirection between an entry or [generic] subprogram entity and its\n+\tpre/post + test-cases.\n+\t(Spec_PPC_List, Spec_TC_List, Set_Spec_PPC_List, Set_Spec_TC_List):\n+\tget/set for fields of an N_Contract node.\n+\t* snames.ads-tmpl (Name_Test_Case, Name_Ensures, Name_Mode,\n+\tName_Normal, Name_Requires, Name_Robustness, Pragma_Test_Case): new\n+\tnames and pragma for Test_Case.\n+\t* sprint.adb (Sprint_Node): raise Program_Error on N_Contract node\n+\n 2011-08-04  Vincent Celier  <celier@adacore.com>\n \n \t* gnat_ugn.texi: Improve documentation of gnatmake switch"}, {"sha": "7495a2d5aa7476890d10eb7bdb6cb56499227261", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 2010, Free Software Foundation, Inc.            --\n+--          Copyright (C) 2010-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -222,6 +222,7 @@ package body Aspects is\n     Aspect_Stream_Size                  => Aspect_Stream_Size,\n     Aspect_Suppress                     => Aspect_Suppress,\n     Aspect_Suppress_Debug_Info          => Aspect_Suppress_Debug_Info,\n+    Aspect_Test_Case                    => Aspect_Test_Case,\n     Aspect_Type_Invariant               => Aspect_Invariant,\n     Aspect_Unchecked_Union              => Aspect_Unchecked_Union,\n     Aspect_Universal_Aliasing           => Aspect_Universal_Aliasing,"}, {"sha": "4b2d814bdcae04f1b21a23bb5978432140785bea", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2010, Free Software Foundation, Inc.            --\n+--         Copyright (C) 2010-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -69,6 +69,7 @@ package Aspects is\n       Aspect_Storage_Size,\n       Aspect_Stream_Size,\n       Aspect_Suppress,\n+      Aspect_Test_Case,                     -- GNAT\n       Aspect_Type_Invariant,\n       Aspect_Unsuppress,\n       Aspect_Value_Size,                    -- GNAT\n@@ -128,6 +129,13 @@ package Aspects is\n                         Aspect_Post          => True,\n                         others               => False);\n \n+   --  The following array indicates aspects for which multiple occurrences of\n+   --  the same aspect attached to the same declaration are allowed.\n+\n+   No_Duplicates_Allowed : constant array (Aspect_Id) of Boolean :=\n+                             (Aspect_Test_Case => False,\n+                              others           => True);\n+\n    --  The following subtype defines aspects corresponding to library unit\n    --  pragmas, these can only validly appear as aspects for library units,\n    --  and result in a corresponding pragma being inserted immediately after\n@@ -185,6 +193,7 @@ package Aspects is\n                         Aspect_Storage_Size            => Expression,\n                         Aspect_Stream_Size             => Expression,\n                         Aspect_Suppress                => Name,\n+                        Aspect_Test_Case               => Expression,\n                         Aspect_Type_Invariant          => Expression,\n                         Aspect_Unsuppress              => Name,\n                         Aspect_Value_Size              => Expression,\n@@ -252,6 +261,7 @@ package Aspects is\n      Aspect_Stream_Size                  => Name_Stream_Size,\n      Aspect_Suppress                     => Name_Suppress,\n      Aspect_Suppress_Debug_Info          => Name_Suppress_Debug_Info,\n+     Aspect_Test_Case                    => Name_Test_Case,\n      Aspect_Type_Invariant               => Name_Type_Invariant,\n      Aspect_Unchecked_Union              => Name_Unchecked_Union,\n      Aspect_Universal_Aliasing           => Name_Universal_Aliasing,"}, {"sha": "a53d07ff2996f00f32e4c7cc6fb5069cbc32b971", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -209,7 +209,7 @@ package body Einfo is\n \n    --    Finalizer                       Node24\n    --    Related_Expression              Node24\n-   --    Spec_PPC_List                   Node24\n+   --    Contract                        Node24\n \n    --    Interface_Alias                 Node25\n    --    Interfaces                      Elist25\n@@ -982,6 +982,15 @@ package body Einfo is\n       return Node18 (Id);\n    end Entry_Index_Constant;\n \n+   function Contract (Id : E) return N is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Entry, E_Entry_Family)\n+          or else Is_Subprogram (Id)\n+          or else Is_Generic_Subprogram (Id));\n+      return Node24 (Id);\n+   end Contract;\n+\n    function Entry_Parameters_Type (Id : E) return E is\n    begin\n       return Node15 (Id);\n@@ -2650,15 +2659,6 @@ package body Einfo is\n       return Node19 (Id);\n    end Spec_Entity;\n \n-   function Spec_PPC_List (Id : E) return N is\n-   begin\n-      pragma Assert\n-        (Ekind_In (Id,  E_Entry, E_Entry_Family)\n-          or else Is_Subprogram (Id)\n-          or else Is_Generic_Subprogram (Id));\n-      return Node24 (Id);\n-   end Spec_PPC_List;\n-\n    function Static_Predicate (Id : E) return S is\n    begin\n       pragma Assert (Is_Discrete_Type (Id));\n@@ -3451,6 +3451,15 @@ package body Einfo is\n       Set_Node18 (Id, V);\n    end Set_Entry_Index_Constant;\n \n+   procedure Set_Contract (Id : E; V : N) is\n+   begin\n+      pragma Assert\n+        (Ekind_In (Id, E_Entry, E_Entry_Family, E_Void)\n+          or else Is_Subprogram (Id)\n+          or else Is_Generic_Subprogram (Id));\n+      Set_Node24 (Id, V);\n+   end Set_Contract;\n+\n    procedure Set_Entry_Parameters_Type (Id : E; V : E) is\n    begin\n       Set_Node15 (Id, V);\n@@ -5189,15 +5198,6 @@ package body Einfo is\n       Set_Node19 (Id, V);\n    end Set_Spec_Entity;\n \n-   procedure Set_Spec_PPC_List (Id : E; V : N) is\n-   begin\n-      pragma Assert\n-        (Ekind_In (Id, E_Entry, E_Entry_Family, E_Void)\n-          or else Is_Subprogram (Id)\n-          or else Is_Generic_Subprogram (Id));\n-      Set_Node24 (Id, V);\n-   end Set_Spec_PPC_List;\n-\n    procedure Set_Static_Predicate (Id : E; V : S) is\n    begin\n       pragma Assert\n@@ -8534,8 +8534,11 @@ package body Einfo is\n               Type_Kind                                    =>\n             Write_Str (\"Related_Expression\");\n \n-         when Subprogram_Kind                              =>\n-            Write_Str (\"Spec_PPC_List\");\n+         when E_Entry                                      |\n+              E_Entry_Family                               |\n+              Subprogram_Kind                              |\n+              Generic_Subprogram_Kind                      =>\n+            Write_Str (\"Contract\");\n \n          when others                                       =>\n             Write_Str (\"Field24???\");"}, {"sha": "29baab0b43e020537220027a1d7cb0b2903818e6", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -1009,6 +1009,11 @@ package Einfo is\n --       accept statement for a member of the family, and in the prefix of\n --       'COUNT when it applies to a family member.\n \n+--    Contract (Node24)\n+--       Present in entries, and in subprogram and generic subprogram entities.\n+--       Points to the contract of the entity, holding both pre- and\n+--       postconditions as well as test-cases.\n+\n --    Entry_Parameters_Type (Node15)\n --       Present in entries. Points to the access-to-record type that is\n --       constructed by the expander to hold a reference to the parameter\n@@ -3641,14 +3646,6 @@ package Einfo is\n --       case where there is a separate spec, where this field references\n --       the corresponding parameter entities in the spec.\n \n---    Spec_PPC_List (Node24)\n---       Present in entries, and in subprogram and generic subprogram entities.\n---       Points to a list of Precondition and Postcondition pragma nodes for\n---       preconditions and postconditions declared in the spec. The last pragma\n---       encountered is at the head of this list, so it is in reverse order of\n---       textual appearance. Note that this includes precondition/postcondition\n---       pragmas generated to correspond to Pre/Post aspects.\n-\n --    Static_Predicate (List25)\n --       Present in discrete types/subtypes with predicates (Has_Predicates\n --       set True). Points to a list of expression and N_Range nodes that\n@@ -5126,7 +5123,7 @@ package Einfo is\n    --    Accept_Address                      (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Protection_Object                   (Node23)   (protected kind)\n-   --    Spec_PPC_List                       (Node24)   (for entry only)\n+   --    Contract                            (Node24)   (for entry only)\n    --    PPC_Wrapper                         (Node25)\n    --    Default_Expressions_Processed       (Flag108)\n    --    Entry_Accepted                      (Flag152)\n@@ -5226,7 +5223,7 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n-   --    Spec_PPC_List                       (Node24)\n+   --    Contract                            (Node24)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n@@ -5490,7 +5487,7 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n-   --    Spec_PPC_List                       (Node24)\n+   --    Contract                            (Node24)\n    --    Interface_Alias                     (Node25)\n    --    Static_Initialization               (Node26)   (init_proc only)\n    --    Overridden_Operation                (Node26)   (never for init proc)\n@@ -6039,6 +6036,7 @@ package Einfo is\n    function Entry_Formal                        (Id : E) return E;\n    function Entry_Index_Constant                (Id : E) return E;\n    function Entry_Index_Type                    (Id : E) return E;\n+   function Contract                            (Id : E) return N;\n    function Entry_Parameters_Type               (Id : E) return E;\n    function Enum_Pos_To_Rep                     (Id : E) return E;\n    function Enumeration_Pos                     (Id : E) return U;\n@@ -6333,7 +6331,6 @@ package Einfo is\n    function Size_Depends_On_Discriminant        (Id : E) return B;\n    function Small_Value                         (Id : E) return R;\n    function Spec_Entity                         (Id : E) return E;\n-   function Spec_PPC_List                       (Id : E) return N;\n    function Static_Predicate                    (Id : E) return S;\n    function Storage_Size_Variable               (Id : E) return E;\n    function Static_Elaboration_Desired          (Id : E) return B;\n@@ -6626,6 +6623,7 @@ package Einfo is\n    procedure Set_Entry_Component                 (Id : E; V : E);\n    procedure Set_Entry_Formal                    (Id : E; V : E);\n    procedure Set_Entry_Index_Constant            (Id : E; V : E);\n+   procedure Set_Contract                        (Id : E; V : N);\n    procedure Set_Entry_Parameters_Type           (Id : E; V : E);\n    procedure Set_Enum_Pos_To_Rep                 (Id : E; V : E);\n    procedure Set_Enumeration_Pos                 (Id : E; V : U);\n@@ -6926,7 +6924,6 @@ package Einfo is\n    procedure Set_Size_Known_At_Compile_Time      (Id : E; V : B := True);\n    procedure Set_Small_Value                     (Id : E; V : R);\n    procedure Set_Spec_Entity                     (Id : E; V : E);\n-   procedure Set_Spec_PPC_List                   (Id : E; V : N);\n    procedure Set_Static_Predicate                (Id : E; V : S);\n    procedure Set_Storage_Size_Variable           (Id : E; V : E);\n    procedure Set_Static_Elaboration_Desired      (Id : E; V : B);\n@@ -7280,6 +7277,7 @@ package Einfo is\n    pragma Inline (Component_Clause);\n    pragma Inline (Component_Size);\n    pragma Inline (Component_Type);\n+   pragma Inline (Contract);\n    pragma Inline (Corresponding_Concurrent_Type);\n    pragma Inline (Corresponding_Discriminant);\n    pragma Inline (Corresponding_Equality);\n@@ -7664,7 +7662,6 @@ package Einfo is\n    pragma Inline (Size_Known_At_Compile_Time);\n    pragma Inline (Small_Value);\n    pragma Inline (Spec_Entity);\n-   pragma Inline (Spec_PPC_List);\n    pragma Inline (Static_Predicate);\n    pragma Inline (Storage_Size_Variable);\n    pragma Inline (Static_Elaboration_Desired);\n@@ -7724,6 +7721,7 @@ package Einfo is\n    pragma Inline (Set_Component_Clause);\n    pragma Inline (Set_Component_Size);\n    pragma Inline (Set_Component_Type);\n+   pragma Inline (Set_Contract);\n    pragma Inline (Set_Corresponding_Concurrent_Type);\n    pragma Inline (Set_Corresponding_Discriminant);\n    pragma Inline (Set_Corresponding_Equality);\n@@ -8063,7 +8061,6 @@ package Einfo is\n    pragma Inline (Set_Size_Known_At_Compile_Time);\n    pragma Inline (Set_Small_Value);\n    pragma Inline (Set_Spec_Entity);\n-   pragma Inline (Set_Spec_PPC_List);\n    pragma Inline (Set_Static_Predicate);\n    pragma Inline (Set_Storage_Size_Variable);\n    pragma Inline (Set_Static_Elaboration_Desired);"}, {"sha": "eba59842af19bf4aefbaedda4f6b438bb47cff03", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -1660,7 +1660,7 @@ package body Exp_Ch9 is\n          P : Node_Id;\n \n       begin\n-         P := Spec_PPC_List (E);\n+         P := Spec_PPC_List (Contract (E));\n          if No (P) then\n             return;\n          end if;\n@@ -10871,7 +10871,7 @@ package body Exp_Ch9 is\n          Ent := First_Entity (Tasktyp);\n          while Present (Ent) loop\n             if Ekind_In (Ent, E_Entry, E_Entry_Family)\n-              and then Present (Spec_PPC_List (Ent))\n+              and then Present (Spec_PPC_List (Contract (Ent)))\n             then\n                Build_PPC_Wrapper (Ent, N);\n             end if;"}, {"sha": "b993785f29da0a036be585f01e1b966f08c728e4", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -3186,6 +3186,11 @@ package body Exp_Util is\n                      null;\n                   end if;\n \n+            --  A contract node should not belong to the tree\n+\n+            when N_Contract =>\n+               raise Program_Error;\n+\n             --  For all other node types, keep climbing tree\n \n             when"}, {"sha": "70a678a00c450bfc337f95af116380014bc98f85", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -203,6 +203,7 @@ Implementation Defined Pragmas\n * Pragma Task_Info::\n * Pragma Task_Name::\n * Pragma Task_Storage::\n+* Pragma Test_Case::\n * Pragma Thread_Local_Storage::\n * Pragma Time_Slice::\n * Pragma Title::\n@@ -835,6 +836,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Task_Info::\n * Pragma Task_Name::\n * Pragma Task_Storage::\n+* Pragma Test_Case::\n * Pragma Thread_Local_Storage::\n * Pragma Time_Slice::\n * Pragma Title::\n@@ -3967,7 +3969,7 @@ In addition, the boolean expression which is the condition which\n must be true may contain references to function'Result in the case\n of a function to refer to the returned value.\n \n-@code{Postcondition} pragmas may appear either immediate following the\n+@code{Postcondition} pragmas may appear either immediately following the\n (separate) declaration of a subprogram, or at the start of the\n declarations of a subprogram body. Only other pragmas may intervene\n (that is appear between the subprogram declaration and its\n@@ -4133,7 +4135,7 @@ end Math_Functions;\n @end smallexample\n \n @noindent\n-@code{Precondition} pragmas may appear either immediate following the\n+@code{Precondition} pragmas may appear either immediately following the\n (separate) declaration of a subprogram, or at the start of the\n declarations of a subprogram body. Only other pragmas may intervene\n (that is appear between the subprogram declaration and its\n@@ -5007,6 +5009,58 @@ created, depending on the target.  This pragma can appear anywhere a\n @code{Storage_Size} attribute definition clause is allowed for a task\n type.\n \n+@node Pragma Test_Case\n+@unnumberedsec Pragma Test_Case\n+@cindex Test cases\n+@findex Test_Case\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Test_Case (\n+   [Name     =>] String_Expression\n+  ,[Mode     =>] (Normal | Robustness)\n+ [, Requires =>  Boolean_Expression]\n+ [, Ensures  =>  Boolean_Expression]);\n+@end smallexample\n+\n+@noindent\n+The @code{Test_Case} pragma applies to the same entities as pragmas\n+@code{Precondition} and @code{Postcondition}. In particular, the\n+placement and visibility rules are identical to those described for pre-\n+and postconditions. But the presence of pragma @code{Test_Case} does not\n+lead to any modification of the code generated by the compiler. Rather,\n+its purpose is to document finer-grain specifications for use by testing\n+and verification tools.\n+\n+The compiler checks that boolean expression given in @code{Requires} and\n+@code{Ensures} are valid, where the rules for @code{Requires} are the\n+same as the rule for an expression in @code{Precondition} and the rules\n+for @code{Ensures} are the same as the rule for an expression in\n+@code{Postcondition}. In particular, attributes @code{'Old} and\n+@code{'Result} can only be used within the @code{Ensures}\n+expression. The following is an example of use within a package spec:\n+\n+@smallexample @c ada\n+package Math_Functions is\n+   ...\n+   function Sqrt (Arg : Float) return Float;\n+   pragma Test_Case (Name     => ``Test_1``,\n+                     Mode     => Normal,\n+                     Requires => Arg < 100,\n+                     Ensures  => Sqrt'Result < 10);\n+   ...\n+end Math_Functions;\n+@end smallexample\n+\n+@noindent\n+@code{Test_Case} pragmas may appear either immediately following the\n+(separate) declaration of a subprogram, or at the start of the\n+declarations of a subprogram body. Only other pragmas may intervene\n+(that is appear between the subprogram declaration and its test cases,\n+or appear before the test case in the declaration sequence in a\n+subprogram body).\n+\n @node Pragma Thread_Local_Storage\n @unnumberedsec Pragma Thread_Local_Storage\n @findex Thread_Local_Storage\n@@ -16589,6 +16643,7 @@ A complete description of the AIs may be found in\n @item @code{Stream_Size} @tab\n @item @code{Suppress} @tab\n @item @code{Suppress_Debug_Info} @tab           -- GNAT\n+@item @code{Test_Case} @tab                     -- GNAT\n @item @code{Unchecked_Union} @tab\n @item @code{Universal_Aliasing} @tab            -- GNAT\n @item @code{Unmodified} @tab                    -- GNAT"}, {"sha": "111dee19b7b421049bd738aad2d6b4f2066eb061", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -1239,6 +1239,7 @@ begin\n            Pragma_Task_Info                     |\n            Pragma_Task_Name                     |\n            Pragma_Task_Storage                  |\n+           Pragma_Test_Case                     |\n            Pragma_Thread_Local_Storage          |\n            Pragma_Time_Slice                    |\n            Pragma_Title                         |"}, {"sha": "59626e86aa13d7829d6c1a62a169d1284e91eb4a", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -650,6 +650,7 @@ package body Sem is\n            N_Component_Definition                   |\n            N_Component_List                         |\n            N_Constrained_Array_Definition           |\n+           N_Contract                               |\n            N_Decimal_Fixed_Point_Definition         |\n            N_Defining_Character_Literal             |\n            N_Defining_Identifier                    |"}, {"sha": "7a03ad1bc9b2d4df4673b2a3b44a45799cf52120", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -4046,9 +4046,29 @@ package body Sem_Attr is\n                Prag := Parent (Prag);\n             end loop;\n \n-            if Nkind (Prag) /= N_Pragma\n-              or else Get_Pragma_Id (Prag) /= Pragma_Postcondition\n-            then\n+            if Nkind (Prag) /= N_Pragma then\n+               Error_Attr\n+                 (\"% attribute can only appear in postcondition of function\",\n+                  P);\n+\n+            elsif Get_Pragma_Id (Prag) = Pragma_Test_Case then\n+               declare\n+                  Arg_Ens : constant Node_Id :=\n+                              Get_Ensures_From_Test_Case_Pragma (Prag);\n+                  Arg     : Node_Id;\n+\n+               begin\n+                  Arg := N;\n+                  while Arg /= Prag and Arg /= Arg_Ens loop\n+                     Arg := Parent (Arg);\n+                  end loop;\n+\n+                  if Arg /= Arg_Ens then\n+                     Error_Attr (\"% attribute misplaced inside Test_Case\", P);\n+                  end if;\n+               end;\n+\n+            elsif Get_Pragma_Id (Prag) /= Pragma_Postcondition then\n                Error_Attr\n                  (\"% attribute can only appear in postcondition of function\",\n                   P);"}, {"sha": "7dc34d83a183f0d44aaa9c616966ecaea32dddea", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -2839,6 +2839,7 @@ package body Sem_Ch12 is\n       Spec := Specification (N);\n       Id := Defining_Entity (Spec);\n       Generate_Definition (Id);\n+      Set_Contract (Id, Make_Contract (Sloc (Id)));\n \n       if Nkind (Id) = N_Defining_Operator_Symbol then\n          Error_Msg_N\n@@ -4367,6 +4368,8 @@ package body Sem_Ch12 is\n          end if;\n \n          Generate_Definition (Act_Decl_Id);\n+         Set_Contract (Anon_Id, Make_Contract (Sloc (Anon_Id))); -- ??? needed?\n+         Set_Contract (Act_Decl_Id, Make_Contract (Sloc (Act_Decl_Id)));\n \n          Set_Is_Inlined (Act_Decl_Id, Is_Inlined (Gen_Unit));\n          Set_Is_Inlined (Anon_Id,     Is_Inlined (Gen_Unit));"}, {"sha": "50d295486deea62d4e87afe6d6db873b28e10901", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 109, "deletions": 43, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -812,53 +812,56 @@ package body Sem_Ch13 is\n             --  test allows duplicate Pre/Post's that we generate internally\n             --  to escape being flagged here.\n \n-            Anod := First (L);\n-            while Anod /= Aspect loop\n-               if Same_Aspect (A_Id, Get_Aspect_Id (Chars (Identifier (Anod))))\n-                 and then Comes_From_Source (Aspect)\n-               then\n-                  Error_Msg_Name_1 := Nam;\n-                  Error_Msg_Sloc := Sloc (Anod);\n+            if No_Duplicates_Allowed (A_Id) then\n+               Anod := First (L);\n+               while Anod /= Aspect loop\n+                  if Same_Aspect\n+                      (A_Id, Get_Aspect_Id (Chars (Identifier (Anod))))\n+                    and then Comes_From_Source (Aspect)\n+                  then\n+                     Error_Msg_Name_1 := Nam;\n+                     Error_Msg_Sloc := Sloc (Anod);\n \n-                  --  Case of same aspect specified twice\n+                     --  Case of same aspect specified twice\n \n-                  if Class_Present (Anod) = Class_Present (Aspect) then\n-                     if not Class_Present (Anod) then\n-                        Error_Msg_NE\n-                          (\"aspect% for & previously given#\",\n-                           Id, E);\n-                     else\n-                        Error_Msg_NE\n-                          (\"aspect `%''Class` for & previously given#\",\n-                           Id, E);\n-                     end if;\n+                     if Class_Present (Anod) = Class_Present (Aspect) then\n+                        if not Class_Present (Anod) then\n+                           Error_Msg_NE\n+                             (\"aspect% for & previously given#\",\n+                              Id, E);\n+                        else\n+                           Error_Msg_NE\n+                             (\"aspect `%''Class` for & previously given#\",\n+                              Id, E);\n+                        end if;\n \n-                  --  Case of Pre and Pre'Class both specified\n+                        --  Case of Pre and Pre'Class both specified\n \n-                  elsif Nam = Name_Pre then\n-                     if Class_Present (Aspect) then\n-                        Error_Msg_NE\n-                          (\"aspect `Pre''Class` for & is not allowed here\",\n-                           Id, E);\n-                        Error_Msg_NE\n-                          (\"\\since aspect `Pre` previously given#\",\n-                           Id, E);\n+                     elsif Nam = Name_Pre then\n+                        if Class_Present (Aspect) then\n+                           Error_Msg_NE\n+                             (\"aspect `Pre''Class` for & is not allowed here\",\n+                              Id, E);\n+                           Error_Msg_NE\n+                             (\"\\since aspect `Pre` previously given#\",\n+                              Id, E);\n \n-                     else\n-                        Error_Msg_NE\n-                          (\"aspect `Pre` for & is not allowed here\",\n-                           Id, E);\n-                        Error_Msg_NE\n-                          (\"\\since aspect `Pre''Class` previously given#\",\n-                           Id, E);\n+                        else\n+                           Error_Msg_NE\n+                             (\"aspect `Pre` for & is not allowed here\",\n+                              Id, E);\n+                           Error_Msg_NE\n+                             (\"\\since aspect `Pre''Class` previously given#\",\n+                              Id, E);\n+                        end if;\n                      end if;\n-                  end if;\n \n-                  --  Allowed case of X and X'Class both specified\n-               end if;\n+                     --  Allowed case of X and X'Class both specified\n+                  end if;\n \n-               Next (Anod);\n-            end loop;\n+                  Next (Anod);\n+               end loop;\n+            end if;\n \n             --  Copy expression for later processing by the procedures\n             --  Check_Aspect_At_[Freeze_Point | End_Of_Declarations]\n@@ -1219,7 +1222,7 @@ package body Sem_Ch13 is\n                     Aspect_Static_Predicate  =>\n \n                   --  Construct the pragma (always a pragma Predicate, with\n-                  --  flags recording whether\n+                  --  flags recording whether it is static/dynamic).\n \n                   Aitem :=\n                     Make_Pragma (Loc,\n@@ -1255,6 +1258,64 @@ package body Sem_Ch13 is\n                   Ensure_Freeze_Node (E);\n                   Set_Is_Delayed_Aspect (Aspect);\n                   Delay_Required := True;\n+\n+               when Aspect_Test_Case => declare\n+                  Args      : List_Id;\n+                  Comp_Expr : Node_Id;\n+                  Comp_Assn : Node_Id;\n+\n+               begin\n+                  Args := New_List;\n+\n+                  if Nkind (Expr) /= N_Aggregate then\n+                     Error_Msg_NE\n+                       (\"wrong syntax for aspect `Test_Case` for &\", Id, E);\n+                     goto Continue;\n+                  end if;\n+\n+                  Comp_Expr := First (Expressions (Expr));\n+                  while Present (Comp_Expr) loop\n+                     Append (Relocate_Node (Comp_Expr), Args);\n+                     Next (Comp_Expr);\n+                  end loop;\n+\n+                  Comp_Assn := First (Component_Associations (Expr));\n+                  while Present (Comp_Assn) loop\n+                     if List_Length (Choices (Comp_Assn)) /= 1\n+                       or else\n+                         Nkind (First (Choices (Comp_Assn))) /= N_Identifier\n+                     then\n+                        Error_Msg_NE\n+                          (\"wrong syntax for aspect `Test_Case` for &\", Id, E);\n+                        goto Continue;\n+                     end if;\n+\n+                     Append (Make_Pragma_Argument_Association (\n+                       Sloc       => Sloc (Comp_Assn),\n+                       Chars      => Chars (First (Choices (Comp_Assn))),\n+                       Expression => Relocate_Node (Expression (Comp_Assn))),\n+                       Args);\n+                     Next (Comp_Assn);\n+                  end loop;\n+\n+                  --  Build the test-case pragma\n+\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Test_Case),\n+                      Pragma_Argument_Associations =>\n+                        Args);\n+\n+                  Set_From_Aspect_Specification (Aitem, True);\n+                  Set_Is_Delayed_Aspect (Aspect);\n+\n+                  --  Insert immediately after the entity declaration\n+\n+                  Insert_After (N, Aitem);\n+\n+                  goto Continue;\n+               end;\n             end case;\n \n             --  If a delay is required, we delay the freeze (not much point in\n@@ -5330,6 +5391,12 @@ package body Sem_Ch13 is\n          when Boolean_Aspects =>\n             raise Program_Error;\n \n+         --  Test_Case aspect applies to entries and subprograms, hence should\n+         --  never be delayed.\n+\n+         when Aspect_Test_Case =>\n+            raise Program_Error;\n+\n          --  Default_Value is resolved with the type entity in question\n \n          when Aspect_Default_Value =>\n@@ -5354,8 +5421,7 @@ package body Sem_Ch13 is\n          when Aspect_Storage_Pool =>\n             T := Class_Wide_Type (RTE (RE_Root_Storage_Pool));\n \n-         when\n-              Aspect_Alignment      |\n+         when Aspect_Alignment      |\n               Aspect_Component_Size |\n               Aspect_Machine_Radix  |\n               Aspect_Object_Size    |\n@@ -5375,7 +5441,7 @@ package body Sem_Ch13 is\n             Analyze (Expression (ASN));\n             return;\n \n-         --  Suppress/Unsupress/Warnings should never be delayed\n+         --  Suppress/Unsuppress/Warnings should never be delayed\n \n          when Aspect_Suppress   |\n               Aspect_Unsuppress |"}, {"sha": "53ba892bd8e7cf4370c208555793e246739be7cc", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -2180,11 +2180,18 @@ package body Sem_Ch3 is\n             if Nkind (Original_Node (Decl)) = N_Subprogram_Declaration then\n                Spec := Specification (Original_Node (Decl));\n                Sent := Defining_Unit_Name (Spec);\n-               Prag := Spec_PPC_List (Sent);\n+\n+               Prag := Spec_PPC_List (Contract (Sent));\n                while Present (Prag) loop\n                   Analyze_PPC_In_Decl_Part (Prag, Sent);\n                   Prag := Next_Pragma (Prag);\n                end loop;\n+\n+               Prag := Spec_TC_List (Contract (Sent));\n+               while Present (Prag) loop\n+                  Analyze_TC_In_Decl_Part (Prag, Sent);\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n             end if;\n \n             Next (Decl);\n@@ -13001,6 +13008,7 @@ package body Sem_Ch3 is\n       New_Subp :=\n          New_Entity (Nkind (Parent_Subp), Sloc (Derived_Type));\n       Set_Ekind (New_Subp, Ekind (Parent_Subp));\n+      Set_Contract (New_Subp, Make_Contract (Sloc (New_Subp)));\n \n       --  Check whether the inherited subprogram is a private operation that\n       --  should be inherited but not yet made visible. Such subprograms can"}, {"sha": "98b6d91c4ffa9ac76195c909e06e43f19fb17b48", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -230,6 +230,7 @@ package body Sem_Ch6 is\n       Check_SPARK_Restriction (\"abstract subprogram is not allowed\", N);\n \n       Generate_Definition (Designator);\n+      Set_Contract (Designator, Make_Contract (Sloc (Designator)));\n       Set_Is_Abstract_Subprogram (Designator);\n       New_Overloaded_Entity (Designator);\n       Check_Delayed_Subprogram (Designator);\n@@ -2539,6 +2540,7 @@ package body Sem_Ch6 is\n          if Nkind (N) /= N_Subprogram_Body_Stub then\n             Set_Acts_As_Spec (N);\n             Generate_Definition (Body_Id);\n+            Set_Contract (Body_Id, Make_Contract (Sloc (Body_Id)));\n             Generate_Reference\n               (Body_Id, Body_Id, 'b', Set_Ref => False, Force => True);\n             Generate_Reference_To_Formals (Body_Id);\n@@ -2981,6 +2983,7 @@ package body Sem_Ch6 is\n \n       Designator := Analyze_Subprogram_Specification (Specification (N));\n       Generate_Definition (Designator);\n+      --  ??? why this call, already in Analyze_Subprogram_Specification\n \n       if Debug_Flag_C then\n          Write_Str (\"==> subprogram spec \");\n@@ -3170,6 +3173,7 @@ package body Sem_Ch6 is\n       --  Proceed with analysis\n \n       Generate_Definition (Designator);\n+      Set_Contract (Designator, Make_Contract (Sloc (Designator)));\n \n       if Nkind (N) = N_Function_Specification then\n          Set_Ekind (Designator, E_Function);\n@@ -7300,7 +7304,8 @@ package body Sem_Ch6 is\n \n          begin\n             for J in Inherited'Range loop\n-               P := Spec_PPC_List (Inherited (J));\n+               P := Spec_PPC_List (Contract (Inherited (J)));\n+\n                while Present (P) loop\n                   Error_Msg_Sloc := Sloc (P);\n \n@@ -9193,7 +9198,7 @@ package body Sem_Ch6 is\n          --  the body will be analyzed and converted when we scan the body\n          --  declarations below.\n \n-         Prag := Spec_PPC_List (Spec_Id);\n+         Prag := Spec_PPC_List (Contract (Spec_Id));\n          while Present (Prag) loop\n             if Pragma_Name (Prag) = Name_Precondition then\n \n@@ -9222,7 +9227,7 @@ package body Sem_Ch6 is\n          --  Now deal with inherited preconditions\n \n          for J in Inherited'Range loop\n-            Prag := Spec_PPC_List (Inherited (J));\n+            Prag := Spec_PPC_List (Contract (Inherited (J)));\n \n             while Present (Prag) loop\n                if Pragma_Name (Prag) = Name_Precondition\n@@ -9402,7 +9407,7 @@ package body Sem_Ch6 is\n \n                --  Loop through PPC pragmas from spec\n \n-               Prag := Spec_PPC_List (Spec);\n+               Prag := Spec_PPC_List (Contract (Spec));\n                loop\n                   if Pragma_Name (Prag) = Name_Postcondition\n                     and then (not Class or else Class_Present (Prag))\n@@ -9427,14 +9432,14 @@ package body Sem_Ch6 is\n          --  Start of processing for Spec_Postconditions\n \n          begin\n-            if Present (Spec_PPC_List (Spec_Id)) then\n+            if Present (Spec_PPC_List (Contract (Spec_Id))) then\n                Process_Post_Conditions (Spec_Id, Class => False);\n             end if;\n \n             --  Process inherited postconditions\n \n             for J in Inherited'Range loop\n-               if Present (Spec_PPC_List (Inherited (J))) then\n+               if Present (Spec_PPC_List (Contract (Inherited (J)))) then\n                   Process_Post_Conditions (Inherited (J), Class => True);\n                end if;\n             end loop;"}, {"sha": "410c02661b715cdd3f79befc5ba88c942edd3d16", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -885,6 +885,7 @@ package body Sem_Ch9 is\n \n    begin\n       Generate_Definition (Def_Id);\n+      Set_Contract (Def_Id, Make_Contract (Sloc (Def_Id)));\n       Tasking_Used := True;\n \n       --  Case of no discrete subtype definition"}, {"sha": "2a218612a268b7ade300cff394ed4664dcb0fef7", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 284, "deletions": 10, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -179,6 +179,11 @@ package body Sem_Prag is\n    --  original one, following the renaming chain) is returned. Otherwise the\n    --  entity is returned unchanged. Should be in Einfo???\n \n+   procedure Preanalyze_TC_Args (Arg_Req, Arg_Ens : Node_Id);\n+   --  Preanalyze the boolean expressions in the Requires and Ensures arguments\n+   --  of a Test_Case pragma if present (possibly Empty). We treat these as\n+   --  spec expressions (i.e. similar to a default expression).\n+\n    procedure rv;\n    --  This is a dummy function called by the processing for pragma Reviewable.\n    --  It is there for assisting front end debugging. By placing a Reviewable\n@@ -333,6 +338,10 @@ package body Sem_Prag is\n       --  Check the specified argument Arg to make sure that it is an integer\n       --  literal. If not give error and raise Pragma_Exit.\n \n+      procedure Check_Arg_Is_String_Literal (Arg : Node_Id);\n+      --  Check the specified argument Arg to make sure that it is a string\n+      --  literal. If not give error and raise Pragma_Exit.\n+\n       procedure Check_Arg_Is_Library_Level_Local_Name (Arg : Node_Id);\n       --  Check the specified argument Arg to make sure that it has the proper\n       --  syntactic form for a local name and meets the semantic requirements\n@@ -410,6 +419,12 @@ package body Sem_Prag is\n       --  Checks that Arg, whose expression is an entity name, references a\n       --  first subtype.\n \n+      procedure Check_Identifier (Arg : Node_Id; Id : Name_Id);\n+      --  Checks that the given argument has an identifier, and if so, requires\n+      --  it to match the given identifier name. If there is no identifier, or\n+      --  a non-matching identifier, then an error message is given and\n+      --  Error_Pragmas raised.\n+\n       procedure Check_In_Main_Program;\n       --  Common checks for pragmas that appear within a main program\n       --  (Priority, Main_Storage, Time_Slice, Relative_Deadline, CPU).\n@@ -478,6 +493,27 @@ package body Sem_Prag is\n       --  that the constraint is static as required by the restrictions for\n       --  Unchecked_Union.\n \n+      procedure Check_Test_Case;\n+      --  Called to process a test-case pragma. The treatment is similar to the\n+      --  one for pre- and postcondition in Check_Precondition_Postcondition.\n+      --  There are three cases:\n+      --\n+      --    The pragma appears after a subprogram spec\n+      --\n+      --      The first step is to analyze the pragma, but this is skipped if\n+      --      the subprogram spec appears within a package specification\n+      --      (because this is the case where we delay analysis till the end of\n+      --      the spec). Then (whether or not it was analyzed), the pragma is\n+      --      chained to the subprogram in question (using Spec_TC_List and\n+      --      Next_Pragma).\n+      --\n+      --    The pragma appears at the start of subprogram body declarations\n+      --\n+      --      In this case an immediate return to the caller is made, and the\n+      --      pragma is NOT analyzed.\n+      --\n+      --    In all other cases, an error message for bad placement is given\n+\n       procedure Check_Valid_Configuration_Pragma;\n       --  Legality checks for placement of a configuration pragma\n \n@@ -860,6 +896,19 @@ package body Sem_Prag is\n          end if;\n       end Check_Arg_Is_Integer_Literal;\n \n+      ---------------------------------\n+      -- Check_Arg_Is_String_Literal --\n+      ---------------------------------\n+\n+      procedure Check_Arg_Is_String_Literal (Arg : Node_Id) is\n+         Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n+      begin\n+         if Nkind (Argx) /= N_String_Literal then\n+            Error_Pragma_Arg\n+              (\"argument for pragma% must be string literal\", Argx);\n+         end if;\n+      end Check_Arg_Is_String_Literal;\n+\n       -------------------------------------------\n       -- Check_Arg_Is_Library_Level_Local_Name --\n       -------------------------------------------\n@@ -1036,6 +1085,7 @@ package body Sem_Prag is\n             Error_Pragma_Arg (\"invalid argument for pragma%\", Argx);\n          end if;\n       end Check_Arg_Is_One_Of;\n+\n       ---------------------------------\n       -- Check_Arg_Is_Queuing_Policy --\n       ---------------------------------\n@@ -1364,6 +1414,24 @@ package body Sem_Prag is\n          end if;\n       end Check_First_Subtype;\n \n+      ----------------------\n+      -- Check_Identifier --\n+      ----------------------\n+\n+      procedure Check_Identifier (Arg : Node_Id; Id : Name_Id) is\n+      begin\n+         if Present (Arg)\n+           and then Nkind (Arg) = N_Pragma_Argument_Association\n+         then\n+            if Chars (Arg) = No_Name or else Chars (Arg) /= Id then\n+               Error_Msg_Name_1 := Pname;\n+               Error_Msg_Name_2 := Id;\n+               Error_Msg_N (\"pragma% argument expects identifier%\", Arg);\n+               raise Pragma_Exit;\n+            end if;\n+         end if;\n+      end Check_Identifier;\n+\n       ---------------------------\n       -- Check_In_Main_Program --\n       ---------------------------\n@@ -1571,10 +1639,10 @@ package body Sem_Prag is\n          PO : Node_Id;\n \n          procedure Chain_PPC (PO : Node_Id);\n-         --  If PO is a subprogram declaration node (or a generic subprogram\n-         --  declaration node), then the precondition/postcondition applies\n-         --  to this subprogram and the processing for the pragma is completed.\n-         --  Otherwise the pragma is misplaced.\n+         --  If PO is an entry or a [generic] subprogram declaration node, then\n+         --  the precondition/postcondition applies to this subprogram and the\n+         --  processing for the pragma is completed. Otherwise the pragma is\n+         --  misplaced.\n \n          ---------------\n          -- Chain_PPC --\n@@ -1637,7 +1705,7 @@ package body Sem_Prag is\n \n             if Pragma_Name (N) = Name_Precondition then\n                if not From_Aspect_Specification (N) then\n-                  P := Spec_PPC_List (S);\n+                  P := Spec_PPC_List (Contract (S));\n                   while Present (P) loop\n                      if Pragma_Name (P) = Name_Precondition\n                        and then From_Aspect_Specification (P)\n@@ -1666,7 +1734,7 @@ package body Sem_Prag is\n \n                begin\n                   for J in Inherited'Range loop\n-                     P := Spec_PPC_List (Inherited (J));\n+                     P := Spec_PPC_List (Contract (Inherited (J)));\n                      while Present (P) loop\n                         if Pragma_Name (P) = Name_Precondition\n                           and then Class_Present (P)\n@@ -1691,8 +1759,8 @@ package body Sem_Prag is\n \n             --  Chain spec PPC pragma to list for subprogram\n \n-            Set_Next_Pragma (N, Spec_PPC_List (S));\n-            Set_Spec_PPC_List (S, N);\n+            Set_Next_Pragma (N, Spec_PPC_List (Contract (S)));\n+            Set_Spec_PPC_List (Contract (S), N);\n \n             --  Return indicating spec case\n \n@@ -1870,6 +1938,135 @@ package body Sem_Prag is\n          end case;\n       end Check_Static_Constraint;\n \n+      ---------------------\n+      -- Check_Test_Case --\n+      ---------------------\n+\n+      procedure Check_Test_Case is\n+         P  : Node_Id;\n+         PO : Node_Id;\n+\n+         procedure Chain_TC (PO : Node_Id);\n+         --  If PO is an entry or a [generic] subprogram declaration node, then\n+         --  the test-case applies to this subprogram and the processing for\n+         --  the pragma is completed. Otherwise the pragma is misplaced.\n+\n+         --------------\n+         -- Chain_TC --\n+         --------------\n+\n+         procedure Chain_TC (PO : Node_Id) is\n+            S   : Entity_Id;\n+\n+         begin\n+            if Nkind (PO) = N_Abstract_Subprogram_Declaration then\n+               if From_Aspect_Specification (N) then\n+                  Error_Pragma\n+                    (\"aspect% cannot be applied to abstract subprogram\");\n+               else\n+                  Error_Pragma\n+                    (\"pragma% cannot be applied to abstract subprogram\");\n+               end if;\n+\n+            elsif not Nkind_In (PO, N_Subprogram_Declaration,\n+                                    N_Generic_Subprogram_Declaration,\n+                                    N_Entry_Declaration)\n+            then\n+               Pragma_Misplaced;\n+            end if;\n+\n+            --  Here if we have [generic] subprogram or entry declaration\n+\n+            if Nkind (PO) = N_Entry_Declaration then\n+               S := Defining_Entity (PO);\n+            else\n+               S := Defining_Unit_Name (Specification (PO));\n+            end if;\n+\n+            --  Note: we do not analyze the pragma at this point. Instead we\n+            --  delay this analysis until the end of the declarative part in\n+            --  which the pragma appears. This implements the required delay\n+            --  in this analysis, allowing forward references. The analysis\n+            --  happens at the end of Analyze_Declarations.\n+\n+            --  Chain spec TC pragma to list for subprogram\n+\n+            Set_Next_Pragma (N, Spec_TC_List (Contract (S)));\n+            Set_Spec_TC_List (Contract (S), N);\n+         end Chain_TC;\n+\n+      --  Start of processing for Check_Test_Case\n+\n+      begin\n+         if not Is_List_Member (N) then\n+            Pragma_Misplaced;\n+         end if;\n+\n+         --  Search prior declarations\n+\n+         P := N;\n+         while Present (Prev (P)) loop\n+            P := Prev (P);\n+\n+            --  If the previous node is a generic subprogram, do not go to to\n+            --  the original node, which is the unanalyzed tree: we need to\n+            --  attach the test-case to the analyzed version at this point.\n+            --  They get propagated to the original tree when analyzing the\n+            --  corresponding body.\n+\n+            if Nkind (P) not in N_Generic_Declaration then\n+               PO := Original_Node (P);\n+            else\n+               PO := P;\n+            end if;\n+\n+            --  Skip past prior pragma\n+\n+            if Nkind (PO) = N_Pragma then\n+               null;\n+\n+            --  Skip stuff not coming from source\n+\n+            elsif not Comes_From_Source (PO) then\n+               null;\n+\n+            --  Only remaining possibility is subprogram declaration\n+\n+            else\n+               Chain_TC (PO);\n+               return;\n+            end if;\n+         end loop;\n+\n+         --  If we fall through loop, pragma is at start of list, so see if it\n+         --  is at the start of declarations of a subprogram body.\n+\n+         if Nkind (Parent (N)) = N_Subprogram_Body\n+           and then List_Containing (N) = Declarations (Parent (N))\n+         then\n+            if Operating_Mode /= Generate_Code\n+              or else Inside_A_Generic\n+            then\n+               --  Analyze pragma expressions for correctness and for ASIS use\n+\n+               Preanalyze_TC_Args (Get_Requires_From_Test_Case_Pragma (N),\n+                                   Get_Ensures_From_Test_Case_Pragma (N));\n+            end if;\n+\n+            return;\n+\n+         --  See if it is in the pragmas after a library level subprogram\n+\n+         elsif Nkind (Parent (N)) = N_Compilation_Unit_Aux then\n+            Chain_TC (Unit (Parent (Parent (N))));\n+            return;\n+         end if;\n+\n+         --  If we fall through, pragma was misplaced\n+\n+         Pragma_Misplaced;\n+      end Check_Test_Case;\n+\n       --------------------------------------\n       -- Check_Valid_Configuration_Pragma --\n       --------------------------------------\n@@ -12904,9 +13101,9 @@ package body Sem_Prag is\n             end if;\n          end;\n \n-         --------------\n+         ---------------\n          -- Task_Info --\n-         --------------\n+         ---------------\n \n          --  pragma Task_Info (EXPRESSION);\n \n@@ -13023,6 +13220,38 @@ package body Sem_Prag is\n             end if;\n          end Task_Storage;\n \n+         ---------------\n+         -- Test_Case --\n+         ---------------\n+\n+         --  pragma Test_Case ([Name     =>] String_Expression\n+         --                   ,[Mode     =>] (Normal | Robustness)\n+         --                  [, Requires =>  Boolean_Expression]\n+         --                  [, Ensures  =>  Boolean_Expression]);\n+\n+         when Pragma_Test_Case => Test_Case : declare\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (3);\n+            Check_At_Most_N_Arguments (4);\n+            Check_Arg_Order\n+              ((Name_Name, Name_Mode, Name_Requires, Name_Ensures));\n+\n+            Check_Optional_Identifier (Arg1, Name_Name);\n+            Check_Arg_Is_String_Literal (Arg1);\n+            Check_Optional_Identifier (Arg2, Name_Mode);\n+            Check_Arg_Is_One_Of (Arg2, Name_Normal, Name_Robustness);\n+            if Arg_Count = 4 then\n+               Check_Identifier (Arg3, Name_Requires);\n+               Check_Identifier (Arg4, Name_Ensures);\n+            else\n+               Check_Arg_Is_One_Of (Arg3, Name_Requires, Name_Ensures);\n+            end if;\n+\n+            Check_Test_Case;\n+         end Test_Case;\n+\n          --------------------------\n          -- Thread_Local_Storage --\n          --------------------------\n@@ -13887,6 +14116,30 @@ package body Sem_Prag is\n       when Pragma_Exit => null;\n    end Analyze_Pragma;\n \n+   -----------------------------\n+   -- Analyze_TC_In_Decl_Part --\n+   -----------------------------\n+\n+   procedure Analyze_TC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n+   begin\n+      --  Install formals and push subprogram spec onto scope stack so that we\n+      --  can see the formals from the pragma.\n+\n+      Install_Formals (S);\n+      Push_Scope (S);\n+\n+      --  Preanalyze the boolean expressions, we treat these as spec\n+      --  expressions (i.e. similar to a default expression).\n+\n+      Preanalyze_TC_Args (Get_Requires_From_Test_Case_Pragma (N),\n+                          Get_Ensures_From_Test_Case_Pragma (N));\n+\n+      --  Remove the subprogram from the scope stack now that the pre-analysis\n+      --  of the expressions in the test-case is done.\n+\n+      End_Scope;\n+   end Analyze_TC_In_Decl_Part;\n+\n    -------------------\n    -- Check_Enabled --\n    -------------------\n@@ -14214,6 +14467,7 @@ package body Sem_Prag is\n       Pragma_Task_Info                     => -1,\n       Pragma_Task_Name                     => -1,\n       Pragma_Task_Storage                  =>  0,\n+      Pragma_Test_Case                     => -1,\n       Pragma_Thread_Local_Storage          =>  0,\n       Pragma_Time_Slice                    => -1,\n       Pragma_Title                         => -1,\n@@ -14355,6 +14609,26 @@ package body Sem_Prag is\n       end if;\n    end Is_Pragma_String_Literal;\n \n+   ------------------------\n+   -- Preanalyze_TC_Args --\n+   ------------------------\n+\n+   procedure Preanalyze_TC_Args (Arg_Req, Arg_Ens : Node_Id) is\n+   begin\n+      --  Preanalyze the boolean expressions, we treat these as spec\n+      --  expressions (i.e. similar to a default expression).\n+\n+      if Present (Arg_Req) then\n+         Preanalyze_Spec_Expression\n+           (Get_Pragma_Arg (Arg_Req), Standard_Boolean);\n+      end if;\n+\n+      if Present (Arg_Ens) then\n+         Preanalyze_Spec_Expression\n+           (Get_Pragma_Arg (Arg_Ens), Standard_Boolean);\n+      end if;\n+   end Preanalyze_TC_Args;\n+\n    --------------------------------------\n    -- Process_Compilation_Unit_Pragmas --\n    --------------------------------------"}, {"sha": "5d9c741b09db8b38446ce3e2b64ac8dafef6d53e", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,6 +46,14 @@ package Sem_Prag is\n    procedure Analyze_Pragma (N : Node_Id);\n    --  Analyze procedure for pragma reference node N\n \n+   procedure Analyze_TC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n+   --  Special analyze routine for test-case pragma that appears within a\n+   --  declarative part where the pragma is associated with a subprogram\n+   --  specification. N is the pragma node, and S is the entity for the related\n+   --  subprogram. This procedure does a preanalysis of the expressions in the\n+   --  pragma as \"spec expressions\" (see section in Sem \"Handling of Default\n+   --  and Per-Object Expressions...\").\n+\n    function Check_Enabled (Nam : Name_Id) return Boolean;\n    --  This function is used in connection with pragmas Assertion, Check,\n    --  Precondition, and Postcondition to determine if Check pragmas (or"}, {"sha": "5974f9cd57d55284870335a42fe56f457a886497", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -4223,6 +4223,28 @@ package body Sem_Util is\n       end if;\n    end Get_Enum_Lit_From_Pos;\n \n+   ---------------------------------------\n+   -- Get_Ensures_From_Test_Case_Pragma --\n+   ---------------------------------------\n+\n+   function Get_Ensures_From_Test_Case_Pragma (N : Node_Id) return Node_Id is\n+      Args : constant List_Id := Pragma_Argument_Associations (N);\n+      Res  : Node_Id;\n+\n+   begin\n+      if List_Length (Args) = 4 then\n+         Res := Pick (Args, 4);\n+\n+      else\n+         Res := Pick (Args, 3);\n+         if Chars (Res) /= Name_Ensures then\n+            Res := Empty;\n+         end if;\n+      end if;\n+\n+      return Res;\n+   end Get_Ensures_From_Test_Case_Pragma;\n+\n    ------------------------\n    -- Get_Generic_Entity --\n    ------------------------\n@@ -4352,6 +4374,23 @@ package body Sem_Util is\n       return R;\n    end Get_Renamed_Entity;\n \n+   ----------------------------------------\n+   -- Get_Requires_From_Test_Case_Pragma --\n+   ----------------------------------------\n+\n+   function Get_Requires_From_Test_Case_Pragma (N : Node_Id) return Node_Id is\n+      Args : constant List_Id := Pragma_Argument_Associations (N);\n+      Res  : Node_Id;\n+\n+   begin\n+      Res := Pick (Args, 3);\n+      if Chars (Res) /= Name_Requires then\n+         Res := Empty;\n+      end if;\n+\n+      return Res;\n+   end Get_Requires_From_Test_Case_Pragma;\n+\n    -------------------------\n    -- Get_Subprogram_Body --\n    -------------------------"}, {"sha": "e880601bdf876ad957b921a04d6ee67ec6a81640", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -484,6 +484,9 @@ package Sem_Util is\n    --  If expression N references a part of an object, return this object.\n    --  Otherwise return Empty. Expression N should have been resolved already.\n \n+   function Get_Ensures_From_Test_Case_Pragma (N : Node_Id) return Node_Id;\n+   --  Return the Ensures components of Test_Case pragma N, or Empty otherwise\n+\n    function Get_Generic_Entity (N : Node_Id) return Entity_Id;\n    --  Returns the true generic entity in an instantiation. If the name in the\n    --  instantiation is a renaming, the function returns the renamed generic.\n@@ -530,6 +533,9 @@ package Sem_Util is\n    --  not a renamed entity, returns its argument. It is an error to call this\n    --  with any other kind of entity.\n \n+   function Get_Requires_From_Test_Case_Pragma (N : Node_Id) return Node_Id;\n+   --  Return the Requires components of Test_Case pragma N, or Empty otherwise\n+\n    function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id;\n    --  Nod is either a procedure call statement, or a function call, or an\n    --  accept statement node. This procedure finds the Entity_Id of the related"}, {"sha": "5ff5c474c6e109a67ef717954f6895b97d2c4657", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -2766,6 +2766,22 @@ package body Sinfo is\n       return Node1 (N);\n    end Source_Type;\n \n+   function Spec_PPC_List\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      return Node1 (N);\n+   end Spec_PPC_List;\n+\n+   function Spec_TC_List\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      return Node2 (N);\n+   end Spec_TC_List;\n+\n    function Specification\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -5792,6 +5808,22 @@ package body Sinfo is\n       Set_Node1 (N, Val); -- semantic field, no parent set\n    end Set_Source_Type;\n \n+   procedure Set_Spec_PPC_List\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      Set_Node1 (N, Val); -- semantic field, no parent set\n+   end Set_Spec_PPC_List;\n+\n+   procedure Set_Spec_TC_List\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      Set_Node2 (N, Val); -- semantic field, no parent set\n+   end Set_Spec_TC_List;\n+\n    procedure Set_Specification\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "13ee674e1cec4464b0fa8acda8f2cdbe82b41ae5", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -1694,12 +1694,12 @@ package Sinfo is\n    --    which gigi must do size validation for.\n \n    --  Split_PPC (Flag17)\n-   --     When a Pre or Postaspect specification is processed, it is broken\n-   --     into AND THEN sections. The left most section has Split_PPC set to\n-   --     False, indicating that it is the original specification (e.g. for\n-   --     posting errors). For other sections, Split_PPC is set to True.\n-   --     This flag is set in both the N_Aspect_Specification node itself,\n-   --     and in the pragma which is generated from this node.\n+   --    When a Pre or Post aspect specification is processed, it is broken\n+   --    into AND THEN sections. The left most section has Split_PPC set to\n+   --    False, indicating that it is the original specification (e.g. for\n+   --    posting errors). For other sections, Split_PPC is set to True.\n+   --    This flag is set in both the N_Aspect_Specification node itself,\n+   --    and in the pragma which is generated from this node.\n \n    --  Static_Processing_OK (Flag4-Sem)\n    --    Present in N_Aggregate nodes. When the Compile_Time_Known_Aggregate\n@@ -6894,6 +6894,39 @@ package Sinfo is\n       --  Is_Elsif (Flag13) (set if comes from ELSIF)\n       --  plus fields for expression\n \n+      --------------\n+      -- Contract --\n+      --------------\n+\n+      --  This node is used to hold the various parts of an entry or subprogram\n+      --  contract, consisting in pre- and postconditions on the one hand, and\n+      --  test-cases on the other hand.\n+\n+      --  It is referenced from an entry, a subprogram or a generic subprogram\n+      --  entity.\n+\n+      --  Sprint syntax:  <none> as the node should not appear in the tree, but\n+      --                  only attached to an entry or [generic] subprogram\n+      --                  entity.\n+\n+      --  N_Contract\n+      --  Sloc points to the subprogram's name\n+      --  Spec_PPC_List (Node1) (set to Empty if none)\n+      --  Spec_TC_List (Node2) (set to Empty if none)\n+\n+      --  Spec_PPC_List points to a list of Precondition and Postcondition\n+      --  pragma nodes for preconditions and postconditions declared in the\n+      --  spec of the entry/subprogram. The last pragma encountered is at the\n+      --  head of this list, so it is in reverse order of textual appearance.\n+      --  Note that this includes precondition/postcondition pragmas generated\n+      --  to correspond to Pre/Post aspects.\n+\n+      --  Spec_TC_List points to a list of Test_Case pragma nodes for\n+      --  test-cases declared in the spec of the entry/subprogram. The last\n+      --  pragma encountered is at the head of this list, so it is in reverse\n+      --  order of textual appearance. Note that this includes test-case\n+      --  pragmas generated to correspond to Test_Case aspects.\n+\n       -------------------\n       -- Expanded_Name --\n       -------------------\n@@ -7746,6 +7779,7 @@ package Sinfo is\n       N_Component_Association,\n       N_Component_Definition,\n       N_Component_List,\n+      N_Contract,\n       N_Derived_Type_Definition,\n       N_Decimal_Fixed_Point_Definition,\n       N_Defining_Program_Unit_Name,\n@@ -8850,6 +8884,12 @@ package Sinfo is\n    function Source_Type\n      (N : Node_Id) return Entity_Id;  -- Node1\n \n+   function Spec_PPC_List\n+     (N : Node_Id) return Node_Id;    -- Node1\n+\n+   function Spec_TC_List\n+     (N : Node_Id) return Node_Id;    -- Node2\n+\n    function Specification\n      (N : Node_Id) return Node_Id;    -- Node1\n \n@@ -9813,6 +9853,12 @@ package Sinfo is\n    procedure Set_Source_Type\n      (N : Node_Id; Val : Entity_Id);          -- Node1\n \n+   procedure Set_Spec_PPC_List\n+     (N : Node_Id; Val : Node_Id);            -- Node1\n+\n+   procedure Set_Spec_TC_List\n+     (N : Node_Id; Val : Node_Id);            -- Node2\n+\n    procedure Set_Specification\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n@@ -11447,6 +11493,13 @@ package Sinfo is\n         4 => False,   --  unused\n         5 => False),  --  Etype (Node5-Sem)\n \n+     N_Contract =>\n+       (1 => False,   --  Spec_PPC_List (Node1)\n+        2 => False,   --  Spec_TC_List (Node2)\n+        3 => False,   --  unused\n+        4 => False,   --  unused\n+        5 => False),  --  unused\n+\n      N_Expanded_Name =>\n        (1 => True,    --  Chars (Name1)\n         2 => True,    --  Selector_Name (Node2)\n@@ -11931,6 +11984,8 @@ package Sinfo is\n    pragma Inline (Selector_Names);\n    pragma Inline (Shift_Count_OK);\n    pragma Inline (Source_Type);\n+   pragma Inline (Spec_PPC_List);\n+   pragma Inline (Spec_TC_List);\n    pragma Inline (Specification);\n    pragma Inline (Split_PPC);\n    pragma Inline (Statements);\n@@ -12248,6 +12303,8 @@ package Sinfo is\n    pragma Inline (Set_Selector_Names);\n    pragma Inline (Set_Shift_Count_OK);\n    pragma Inline (Set_Source_Type);\n+   pragma Inline (Set_Spec_PPC_List);\n+   pragma Inline (Set_Spec_TC_List);\n    pragma Inline (Set_Specification);\n    pragma Inline (Set_Split_PPC);\n    pragma Inline (Set_Statements);"}, {"sha": "ba35d51d11985ccc451c3069fb93dcb44e432eb1", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -544,6 +544,7 @@ package Snames is\n    Name_Suppress_Debug_Info            : constant Name_Id := N + $; -- GNAT\n    Name_Suppress_Initialization        : constant Name_Id := N + $; -- GNAT\n    Name_System_Name                    : constant Name_Id := N + $; -- Ada 83\n+   Name_Test_Case                      : constant Name_Id := N + $; -- GNAT\n    Name_Task_Info                      : constant Name_Id := N + $; -- GNAT\n    Name_Task_Name                      : constant Name_Id := N + $; -- GNAT\n    Name_Task_Storage                   : constant Name_Id := N + $; -- VMS\n@@ -624,6 +625,7 @@ package Snames is\n    Name_Descriptor                     : constant Name_Id := N + $;\n    Name_Dot_Replacement                : constant Name_Id := N + $;\n    Name_Dynamic                        : constant Name_Id := N + $;\n+   Name_Ensures                        : constant Name_Id := N + $;\n    Name_Entity                         : constant Name_Id := N + $;\n    Name_Entry_Count                    : constant Name_Id := N + $;\n    Name_External_Name                  : constant Name_Id := N + $;\n@@ -646,6 +648,7 @@ package Snames is\n    Name_Mechanism                      : constant Name_Id := N + $;\n    Name_Message                        : constant Name_Id := N + $;\n    Name_Mixedcase                      : constant Name_Id := N + $;\n+   Name_Mode                           : constant Name_Id := N + $;\n    Name_Modified_GPL                   : constant Name_Id := N + $;\n    Name_Name                           : constant Name_Id := N + $;\n    Name_NCA                            : constant Name_Id := N + $;\n@@ -657,13 +660,16 @@ package Snames is\n    Name_No_Requeue_Statements          : constant Name_Id := N + $;\n    Name_No_Task_Attributes             : constant Name_Id := N + $;\n    Name_No_Task_Attributes_Package     : constant Name_Id := N + $;\n+   Name_Normal                         : constant Name_Id := N + $;\n    Name_On                             : constant Name_Id := N + $;\n    Name_Policy                         : constant Name_Id := N + $;\n    Name_Parameter_Types                : constant Name_Id := N + $;\n    Name_Reference                      : constant Name_Id := N + $;\n+   Name_Requires                       : constant Name_Id := N + $;\n    Name_Restricted                     : constant Name_Id := N + $;\n    Name_Result_Mechanism               : constant Name_Id := N + $;\n    Name_Result_Type                    : constant Name_Id := N + $;\n+   Name_Robustness                     : constant Name_Id := N + $;\n    Name_Runtime                        : constant Name_Id := N + $;\n    Name_SB                             : constant Name_Id := N + $;\n    Name_Secondary_Stack_Size           : constant Name_Id := N + $;\n@@ -1634,6 +1640,7 @@ package Snames is\n       Pragma_Suppress_Debug_Info,\n       Pragma_Suppress_Initialization,\n       Pragma_System_Name,\n+      Pragma_Test_Case,\n       Pragma_Task_Info,\n       Pragma_Task_Name,\n       Pragma_Task_Storage,"}, {"sha": "5c6f3297a8846c37565a76d2b50c788599bceab0", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dac3bede918b07ddb13d2efae1fbda9f4d81468f/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=dac3bede918b07ddb13d2efae1fbda9f4d81468f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1348,6 +1348,12 @@ package body Sprint is\n \n             Sprint_Node (Component_Definition (Node));\n \n+         --  A contract node should not appear in the tree. It is a semantic\n+         --  node attached to entry and [generic] subprogram entities.\n+\n+         when N_Contract =>\n+            raise Program_Error;\n+\n          when N_Decimal_Fixed_Point_Definition =>\n             Write_Str_With_Col_Check_Sloc (\" delta \");\n             Sprint_Node (Delta_Expression (Node));"}]}