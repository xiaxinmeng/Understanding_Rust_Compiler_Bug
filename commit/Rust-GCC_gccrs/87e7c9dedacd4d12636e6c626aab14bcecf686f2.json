{"sha": "87e7c9dedacd4d12636e6c626aab14bcecf686f2", "node_id": "C_kwDOANBUbNoAKDg3ZTdjOWRlZGFjZDRkMTI2MzZlNmM2MjZhYWIxNGJjZWNmNjg2ZjI", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-17T13:24:07Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-02-20T12:52:12Z"}, "message": "parser: Allow `LEFT_SHIFT` to start `parse_type`\n\nSimilarly to the last commit, we need to allow `LEFT_SHIFT` tokens to\nstart a qualified path type and split them into two `LEFT_ANGLE` tokens.\n\ngcc/rust/ChangeLog:\n\n\t* parse/rust-parse-impl.h (Parser::parse_type): Allow LEFT_SHIFT to\n\tstart a type and then split it in `parse_qualified_path_type`\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/parse_associated_type_as_generic_arg3.rs: New test.", "tree": {"sha": "a59726e8366764f7f6002c0e1ca8364a1b4d342f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a59726e8366764f7f6002c0e1ca8364a1b4d342f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e7c9dedacd4d12636e6c626aab14bcecf686f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e7c9dedacd4d12636e6c626aab14bcecf686f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e7c9dedacd4d12636e6c626aab14bcecf686f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e7c9dedacd4d12636e6c626aab14bcecf686f2/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57b64a64261ed1d1774af61a1e36eeac604abcde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57b64a64261ed1d1774af61a1e36eeac604abcde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57b64a64261ed1d1774af61a1e36eeac604abcde"}], "stats": {"total": 74, "additions": 70, "deletions": 4}, "files": [{"sha": "2cb5e3e7849bf45639b79d05f970d453a1acd265", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e7c9dedacd4d12636e6c626aab14bcecf686f2/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e7c9dedacd4d12636e6c626aab14bcecf686f2/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=87e7c9dedacd4d12636e6c626aab14bcecf686f2", "patch": "@@ -6842,11 +6842,13 @@ Parser<ManagedTokenSource>::parse_qualified_path_type (\n   if (locus == Linemap::unknown_location ())\n     {\n       locus = lexer.peek_token ()->get_locus ();\n+\n+      if (lexer.peek_token ()->get_id () == LEFT_SHIFT)\n+\tlexer.split_current_token (LEFT_ANGLE, LEFT_ANGLE);\n+\n+      // skip after somewhere?\n       if (!skip_token (LEFT_ANGLE))\n-\t{\n-\t  // skip after somewhere?\n-\t  return AST::QualifiedPathType::create_error ();\n-\t}\n+\treturn AST::QualifiedPathType::create_error ();\n     }\n \n   // parse type (required)\n@@ -9218,6 +9220,7 @@ Parser<ManagedTokenSource>::parse_type (bool save_errors)\n     case LEFT_SQUARE:\n       // slice type or array type - requires further disambiguation\n       return parse_slice_or_array_type ();\n+    case LEFT_SHIFT:\n       case LEFT_ANGLE: {\n \t// qualified path in type\n \tAST::QualifiedPathInType path = parse_qualified_path_in_type ();\n@@ -10084,6 +10087,7 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n     case LEFT_SQUARE:\n       // slice type or array type - requires further disambiguation\n       return parse_slice_or_array_type ();\n+    case LEFT_SHIFT:\n       case LEFT_ANGLE: {\n \t// qualified path in type\n \tAST::QualifiedPathInType path = parse_qualified_path_in_type ();\n@@ -10597,6 +10601,7 @@ Parser<ManagedTokenSource>::parse_range_pattern_bound ()\n \treturn std::unique_ptr<AST::RangePatternBoundPath> (\n \t  new AST::RangePatternBoundPath (std::move (path)));\n       }\n+    case LEFT_SHIFT:\n       case LEFT_ANGLE: {\n \t// qualified path in expression\n \tAST::QualifiedPathInExpression path\n@@ -10727,6 +10732,7 @@ Parser<ManagedTokenSource>::parse_pattern_no_alt ()\n     case LEFT_SQUARE:\n       // slice pattern\n       return parse_slice_pattern ();\n+    case LEFT_SHIFT:\n       case LEFT_ANGLE: {\n \t// qualified path in expression or qualified range pattern bound\n \tAST::QualifiedPathInExpression path\n@@ -12760,6 +12766,7 @@ Parser<ManagedTokenSource>::null_denotation (const_TokenPtr tok,\n        * tokens and whatever. */\n       /* FIXME: could also be path expression (and hence macro expression,\n        * struct/enum expr) */\n+    case LEFT_SHIFT:\n       case LEFT_ANGLE: {\n \t// qualified path\n \t// HACK: add outer attrs to path"}, {"sha": "f1cc9e7dcde8364d399110923b65f8e875f61e89", "filename": "gcc/testsuite/rust/compile/parse_associated_type_as_generic_arg3.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e7c9dedacd4d12636e6c626aab14bcecf686f2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_associated_type_as_generic_arg3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e7c9dedacd4d12636e6c626aab14bcecf686f2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_associated_type_as_generic_arg3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fparse_associated_type_as_generic_arg3.rs?ref=87e7c9dedacd4d12636e6c626aab14bcecf686f2", "patch": "@@ -0,0 +1,59 @@\n+// { dg-additional-options \"-fsyntax-only\" }\n+\n+trait Bar {\n+    type B;\n+\n+    fn bar();\n+}\n+\n+trait Foo {\n+    type A;\n+\n+    fn foo();\n+}\n+\n+trait Toto {\n+    type C;\n+\n+    fn toto();\n+}\n+\n+trait Tata {\n+    type D;\n+    fn tata();\n+}\n+\n+impl Toto for u32 {\n+    type C = f32;\n+\n+    fn toto() {}\n+}\n+\n+impl Tata for f32 {\n+    type D = u32;\n+\n+    fn tata() {}\n+}\n+\n+struct S;\n+\n+impl Bar for i32 {\n+    type B = u32;\n+\n+    fn bar() {}\n+}\n+\n+impl Foo for S {\n+    type A = i32;\n+\n+    fn foo() {}\n+}\n+\n+enum Maybe<T> {\n+    Something(T),\n+    Nothing,\n+}\n+\n+fn foo() -> Maybe<<<<<S as Foo>::A as Bar>::B as Toto>::C as Tata>::D> {\n+    Maybe::Something(15)\n+}"}]}