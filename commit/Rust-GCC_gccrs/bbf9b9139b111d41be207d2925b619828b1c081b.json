{"sha": "bbf9b9139b111d41be207d2925b619828b1c081b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJmOWI5MTM5YjExMWQ0MWJlMjA3ZDI5MjViNjE5ODI4YjFjMDgxYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-30T03:17:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-30T03:17:53Z"}, "message": "function.c (instantiate_decls): Remove valid_only argument.\n\n        * function.c (instantiate_decls): Remove valid_only argument.\n        (instantiate_decls_1, instantiate_decl): Likewise.\n        (instantiate_virtual_regs_1): Delete.\n        (instantiate_virtual_regs_lossage): Delete.\n        (instantiate_virtual_regs_in_rtx): New.\n        (safe_insn_predicate): New.\n        (instantiate_virtual_regs_in_insn): New.\n        (instantiate_virtual_regs): Update to match all that.  Only run\n        instantiate_decls once.\n\nFrom-SVN: r99032", "tree": {"sha": "28eeea7dc50a09256306d498bbcd725b797e56c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28eeea7dc50a09256306d498bbcd725b797e56c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbf9b9139b111d41be207d2925b619828b1c081b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf9b9139b111d41be207d2925b619828b1c081b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf9b9139b111d41be207d2925b619828b1c081b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf9b9139b111d41be207d2925b619828b1c081b/comments", "author": null, "committer": null, "parents": [{"sha": "afd4e04805e50e54c19cd72d0c0765fc9a2ef1ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afd4e04805e50e54c19cd72d0c0765fc9a2ef1ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afd4e04805e50e54c19cd72d0c0765fc9a2ef1ba"}], "stats": {"total": 898, "additions": 371, "deletions": 527}, "files": [{"sha": "7b5c62c85fefe33ebb2766a43a621379902df1e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9b9139b111d41be207d2925b619828b1c081b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9b9139b111d41be207d2925b619828b1c081b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbf9b9139b111d41be207d2925b619828b1c081b", "patch": "@@ -1,3 +1,15 @@\n+2005-04-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* function.c (instantiate_decls): Remove valid_only argument.\n+\t(instantiate_decls_1, instantiate_decl): Likewise.\n+\t(instantiate_virtual_regs_1): Delete.\n+\t(instantiate_virtual_regs_lossage): Delete.\n+\t(instantiate_virtual_regs_in_rtx): New.\n+\t(safe_insn_predicate): New.\n+\t(instantiate_virtual_regs_in_insn): New.\n+\t(instantiate_virtual_regs): Update to match all that.  Only run\n+\tinstantiate_decls once.\n+\n 2005-04-29  Richard Henderson  <rth@redhat.com>\n \t    Daniel Jacobowitz  <dan@codesourcery.com>\n "}, {"sha": "156dc3bca71554848632a87650a7be5c7b48fdc5", "filename": "gcc/function.c", "status": "modified", "additions": 359, "deletions": 527, "changes": 886, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbf9b9139b111d41be207d2925b619828b1c081b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbf9b9139b111d41be207d2925b619828b1c081b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bbf9b9139b111d41be207d2925b619828b1c081b", "patch": "@@ -189,11 +189,6 @@ struct temp_slot GTY(())\n static rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int,\n \t\t\t\t struct function *);\n static struct temp_slot *find_temp_slot_from_address (rtx);\n-static void instantiate_decls (tree, int);\n-static void instantiate_decls_1 (tree, int);\n-static void instantiate_decl (rtx, HOST_WIDE_INT, int);\n-static rtx instantiate_new_reg (rtx, HOST_WIDE_INT *);\n-static int instantiate_virtual_regs_1 (rtx *, rtx, int);\n static void pad_to_arg_alignment (struct args_size *, int, struct args_size *);\n static void pad_below (struct args_size *, enum machine_mode, tree);\n static void reorder_blocks_1 (rtx, tree, varray_type *);\n@@ -214,7 +209,6 @@ static rtx keep_stack_depressed (rtx);\n static void prepare_function_start (tree);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n-static void instantiate_virtual_regs_lossage (rtx);\n static void set_insn_locators (rtx, int) ATTRIBUTE_UNUSED;\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n@@ -1217,608 +1211,446 @@ static int cfa_offset;\n #endif\n \n \f\n-/* Pass through the INSNS of function FNDECL and convert virtual register\n-   references to hard register references.  */\n+/* Given a piece of RTX and a pointer to a HOST_WIDE_INT, if the RTX\n+   is a virtual register, return the equivalent hard register and set the\n+   offset indirectly through the pointer.  Otherwise, return 0.  */\n \n-void\n-instantiate_virtual_regs (void)\n+static rtx\n+instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n {\n-  rtx insn;\n-\n-  /* Compute the offsets to use for this function.  */\n-  in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);\n-  var_offset = STARTING_FRAME_OFFSET;\n-  dynamic_offset = STACK_DYNAMIC_OFFSET (current_function_decl);\n-  out_arg_offset = STACK_POINTER_OFFSET;\n-  cfa_offset = ARG_POINTER_CFA_OFFSET (current_function_decl);\n-\n-  /* Scan all variables and parameters of this function.  For each that is\n-     in memory, instantiate all virtual registers if the result is a valid\n-     address.  If not, we do it later.  That will handle most uses of virtual\n-     regs on many machines.  */\n-  instantiate_decls (current_function_decl, 1);\n-\n-  /* Initialize recognition, indicating that volatile is OK.  */\n-  init_recog ();\n-\n-  /* Scan through all the insns, instantiating every virtual register still\n-     present.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\tinstantiate_virtual_regs_1 (&PATTERN (insn), insn, 1);\n-\tif (INSN_DELETED_P (insn))\n-\t  continue;\n-\tinstantiate_virtual_regs_1 (&REG_NOTES (insn), NULL_RTX, 0);\n-\t/* Instantiate any virtual registers in CALL_INSN_FUNCTION_USAGE.  */\n-\tif (CALL_P (insn))\n-\t  instantiate_virtual_regs_1 (&CALL_INSN_FUNCTION_USAGE (insn),\n-\t\t\t\t      NULL_RTX, 0);\n-\n-\t/* Past this point all ASM statements should match.  Verify that\n-\t   to avoid failures later in the compilation process.  */\n-        if (asm_noperands (PATTERN (insn)) >= 0\n-\t    && ! check_asm_operands (PATTERN (insn)))\n-          instantiate_virtual_regs_lossage (insn);\n-      }\n+  rtx new;\n+  HOST_WIDE_INT offset;\n \n-  /* Now instantiate the remaining register equivalences for debugging info.\n-     These will not be valid addresses.  */\n-  instantiate_decls (current_function_decl, 0);\n+  if (x == virtual_incoming_args_rtx)\n+    new = arg_pointer_rtx, offset = in_arg_offset;\n+  else if (x == virtual_stack_vars_rtx)\n+    new = frame_pointer_rtx, offset = var_offset;\n+  else if (x == virtual_stack_dynamic_rtx)\n+    new = stack_pointer_rtx, offset = dynamic_offset;\n+  else if (x == virtual_outgoing_args_rtx)\n+    new = stack_pointer_rtx, offset = out_arg_offset;\n+  else if (x == virtual_cfa_rtx)\n+    new = arg_pointer_rtx, offset = cfa_offset;\n+  else\n+    return NULL_RTX;\n \n-  /* Indicate that, from now on, assign_stack_local should use\n-     frame_pointer_rtx.  */\n-  virtuals_instantiated = 1;\n+  *poffset = offset;\n+  return new;\n }\n \n-/* Scan all decls in FNDECL (both variables and parameters) and instantiate\n-   all virtual registers in their DECL_RTL's.\n+/* A subroutine of instantiate_virtual_regs, called via for_each_rtx.\n+   Instantiate any virtual registers present inside of *LOC.  The expression\n+   is simplified, as much as possible, but is not to be considered \"valid\"\n+   in any sense implied by the target.  If any change is made, set CHANGED\n+   to true.  */\n \n-   If VALID_ONLY, do this only if the resulting address is still valid.\n-   Otherwise, always do it.  */\n-\n-static void\n-instantiate_decls (tree fndecl, int valid_only)\n+static int\n+instantiate_virtual_regs_in_rtx (rtx *loc, void *data)\n {\n-  tree decl;\n+  HOST_WIDE_INT offset;\n+  bool *changed = (bool *) data;\n+  rtx x, new;\n \n-  /* Process all parameters of the function.  */\n-  for (decl = DECL_ARGUMENTS (fndecl); decl; decl = TREE_CHAIN (decl))\n+  x = *loc;\n+  if (x == 0)\n+    return 0;\n+\n+  switch (GET_CODE (x))\n     {\n-      HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (decl));\n-      HOST_WIDE_INT size_rtl;\n+    case REG:\n+      new = instantiate_new_reg (x, &offset);\n+      if (new)\n+\t{\n+\t  *loc = plus_constant (new, offset);\n+\t  if (changed)\n+\t    *changed = true;\n+\t}\n+      return -1;\n+\n+    case PLUS:\n+      new = instantiate_new_reg (XEXP (x, 0), &offset);\n+      if (new)\n+\t{\n+\t  new = plus_constant (new, offset);\n+\t  *loc = simplify_gen_binary (PLUS, GET_MODE (x), new, XEXP (x, 1));\n+\t  if (changed)\n+\t    *changed = true;\n+\t  return -1;\n+\t}\n \n-      instantiate_decl (DECL_RTL (decl), size, valid_only);\n+      /* FIXME -- from old code */\n+\t  /* If we have (plus (subreg (virtual-reg)) (const_int)), we know\n+\t     we can commute the PLUS and SUBREG because pointers into the\n+\t     frame are well-behaved.  */\n+      break;\n \n-      /* If the parameter was promoted, then the incoming RTL mode may be\n-\t larger than the declared type size.  We must use the larger of\n-\t the two sizes.  */\n-      size_rtl = GET_MODE_SIZE (GET_MODE (DECL_INCOMING_RTL (decl)));\n-      size = MAX (size_rtl, size);\n-      instantiate_decl (DECL_INCOMING_RTL (decl), size, valid_only);\n+    default:\n+      break;\n     }\n \n-  /* Now process all variables defined in the function or its subblocks.  */\n-  instantiate_decls_1 (DECL_INITIAL (fndecl), valid_only);\n+  return 0;\n }\n \n-/* Subroutine of instantiate_decls: Process all decls in the given\n-   BLOCK node and all its subblocks.  */\n+/* A subroutine of instantiate_virtual_regs_in_insn.  Return true if X\n+   matches the predicate for insn CODE operand OPERAND.  */\n \n-static void\n-instantiate_decls_1 (tree let, int valid_only)\n+static int\n+safe_insn_predicate (int code, int operand, rtx x)\n {\n-  tree t;\n+  const struct insn_operand_data *op_data;\n \n-  for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))\n-    if (DECL_RTL_SET_P (t))\n-      instantiate_decl (DECL_RTL (t),\n-\t\t\tint_size_in_bytes (TREE_TYPE (t)),\n-\t\t\tvalid_only);\n+  if (code < 0)\n+    return true;\n \n-  /* Process all subblocks.  */\n-  for (t = BLOCK_SUBBLOCKS (let); t; t = TREE_CHAIN (t))\n-    instantiate_decls_1 (t, valid_only);\n-}\n+  op_data = &insn_data[code].operand[operand];\n+  if (op_data->predicate == NULL)\n+    return true;\n \n-/* Subroutine of the preceding procedures: Given RTL representing a\n-   decl and the size of the object, do any instantiation required.\n+  return op_data->predicate (x, op_data->mode);\n+}\n \n-   If VALID_ONLY is nonzero, it means that the RTL should only be\n-   changed if the new address is valid.  */\n+/* A subroutine of instantiate_virtual_regs.  Instantiate any virtual\n+   registers present inside of insn.  The result will be a valid insn.  */\n \n static void\n-instantiate_decl (rtx x, HOST_WIDE_INT size, int valid_only)\n+instantiate_virtual_regs_in_insn (rtx insn)\n {\n-  enum machine_mode mode;\n-  rtx addr;\n-\n-  if (x == 0)\n-    return;\n+  HOST_WIDE_INT offset;\n+  int insn_code, i;\n+  bool any_change;\n+  rtx set, new, x, seq;\n \n-  /* If this is a CONCAT, recurse for the pieces.  */\n-  if (GET_CODE (x) == CONCAT)\n+  /* There are some special cases to be handled first.  */\n+  set = single_set (insn);\n+  if (set)\n     {\n-      instantiate_decl (XEXP (x, 0), size / 2, valid_only);\n-      instantiate_decl (XEXP (x, 1), size / 2, valid_only);\n-      return;\n-    }\n-\n-  /* If this is not a MEM, no need to do anything.  Similarly if the\n-     address is a constant or a register that is not a virtual register.  */\n-  if (!MEM_P (x))\n-    return;\n+      /* We're allowed to assign to a virtual register.  This is interpreted\n+\t to mean that the underlying register gets assigned the inverse\n+\t transformation.  This is used, for example, in the handling of\n+\t non-local gotos.  */\n+      new = instantiate_new_reg (SET_DEST (set), &offset);\n+      if (new)\n+\t{\n+\t  start_sequence ();\n \n-  addr = XEXP (x, 0);\n-  if (CONSTANT_P (addr)\n-      || (REG_P (addr)\n-\t  && (REGNO (addr) < FIRST_VIRTUAL_REGISTER\n-\t      || REGNO (addr) > LAST_VIRTUAL_REGISTER)))\n-    return;\n+\t  for_each_rtx (&SET_SRC (set), instantiate_virtual_regs_in_rtx, NULL);\n+\t  x = simplify_gen_binary (PLUS, GET_MODE (new), SET_SRC (set),\n+\t\t\t\t   GEN_INT (-offset));\n+\t  x = force_operand (x, new);\n+\t  if (x != new)\n+\t    emit_move_insn (new, x);\n \n-  /* If we should only do this if the address is valid, copy the address.\n-     We need to do this so we can undo any changes that might make the\n-     address invalid.  This copy is unfortunate, but probably can't be\n-     avoided.  */\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n \n-  if (valid_only)\n-    addr = copy_rtx (addr);\n+\t  emit_insn_before (seq, insn);\n+\t  delete_insn (insn);\n+\t  return;\n+\t}\n \n-  instantiate_virtual_regs_1 (&addr, NULL_RTX, 0);\n+      /* Handle a straight copy from a virtual register by generating a\n+\t new add insn.  The difference between this and falling through\n+\t to the generic case is avoiding a new pseudo and eliminating a\n+\t move insn in the initial rtl stream.  */\n+      new = instantiate_new_reg (SET_SRC (set), &offset);\n+      if (new && offset != 0\n+\t  && REG_P (SET_DEST (set))\n+\t  && REGNO (SET_DEST (set)) > LAST_VIRTUAL_REGISTER)\n+\t{\n+\t  start_sequence ();\n \n-  if (valid_only && size >= 0)\n-    {\n-      unsigned HOST_WIDE_INT decl_size = size;\n+\t  x = expand_simple_binop (GET_MODE (SET_DEST (set)), PLUS,\n+\t\t\t\t   new, GEN_INT (offset), SET_DEST (set),\n+\t\t\t\t   1, OPTAB_LIB_WIDEN);\n+\t  if (x != SET_DEST (set))\n+\t    emit_move_insn (SET_DEST (set), x);\n \n-      /* Now verify that the resulting address is valid for every integer or\n-\t floating-point mode up to and including SIZE bytes long.  We do this\n-\t since the object might be accessed in any mode and frame addresses\n-\t are shared.  */\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n \n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   mode != VOIDmode && GET_MODE_SIZE (mode) <= decl_size;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n-\tif (! memory_address_p (mode, addr))\n+\t  emit_insn_before (seq, insn);\n+\t  delete_insn (insn);\n \t  return;\n+\t}\n \n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t   mode != VOIDmode && GET_MODE_SIZE (mode) <= decl_size;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n-\tif (! memory_address_p (mode, addr))\n-\t  return;\n-    }\n+      extract_insn (insn);\n \n-  /* Put back the address now that we have updated it and we either know\n-     it is valid or we don't care whether it is valid.  */\n+      /* Handle a plus involving a virtual register by determining if the\n+\t operands remain valid if they're modified in place.  */\n+      if (GET_CODE (SET_SRC (set)) == PLUS\n+\t  && recog_data.n_operands >= 3\n+\t  && recog_data.operand_loc[1] == &XEXP (SET_SRC (set), 0)\n+\t  && recog_data.operand_loc[2] == &XEXP (SET_SRC (set), 1)\n+\t  && GET_CODE (recog_data.operand[2]) == CONST_INT\n+\t  && (new = instantiate_new_reg (recog_data.operand[1], &offset)))\n+\t{\n+\t  offset += INTVAL (recog_data.operand[2]);\n \n-  XEXP (x, 0) = addr;\n-}\n-\f\n-/* Given a piece of RTX and a pointer to a HOST_WIDE_INT, if the RTX\n-   is a virtual register, return the equivalent hard register and set the\n-   offset indirectly through the pointer.  Otherwise, return 0.  */\n+\t  /* If the sum is zero, then replace with a plain move.  */\n+\t  if (offset == 0)\n+\t    {\n+\t      start_sequence ();\n+\t      emit_move_insn (SET_DEST (set), new);\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n \n-static rtx\n-instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n-{\n-  rtx new;\n-  HOST_WIDE_INT offset;\n+\t      emit_insn_before (seq, insn);\n+\t      delete_insn (insn);\n+\t      return;\n+\t    }\n \n-  if (x == virtual_incoming_args_rtx)\n-    new = arg_pointer_rtx, offset = in_arg_offset;\n-  else if (x == virtual_stack_vars_rtx)\n-    new = frame_pointer_rtx, offset = var_offset;\n-  else if (x == virtual_stack_dynamic_rtx)\n-    new = stack_pointer_rtx, offset = dynamic_offset;\n-  else if (x == virtual_outgoing_args_rtx)\n-    new = stack_pointer_rtx, offset = out_arg_offset;\n-  else if (x == virtual_cfa_rtx)\n-    new = arg_pointer_rtx, offset = cfa_offset;\n+\t  x = gen_int_mode (offset, recog_data.operand_mode[2]);\n+\t  insn_code = INSN_CODE (insn);\n+\n+\t  /* Using validate_change and apply_change_group here leaves\n+\t     recog_data in an invalid state.  Since we know exactly what\n+\t     we want to check, do those two by hand.  */\n+\t  if (safe_insn_predicate (insn_code, 1, new)\n+\t      && safe_insn_predicate (insn_code, 2, x))\n+\t    {\n+\t      *recog_data.operand_loc[1] = recog_data.operand[1] = new;\n+\t      *recog_data.operand_loc[2] = recog_data.operand[2] = x;\n+\t      any_change = true;\n+\t      goto verify;\n+\t    }\n+\t}\n+    }\n   else\n-    return 0;\n+    extract_insn (insn);\n \n-  *poffset = offset;\n-  return new;\n-}\n-\f\n+  insn_code = INSN_CODE (insn);\n+  any_change = false;\n \n-/* Called when instantiate_virtual_regs has failed to update the instruction.\n-   Usually this means that non-matching instruction has been emit, however for\n-   asm statements it may be the problem in the constraints.  */\n-static void\n-instantiate_virtual_regs_lossage (rtx insn)\n-{\n-  gcc_assert (asm_noperands (PATTERN (insn)) >= 0);\n-  error_for_asm (insn, \"impossible constraint in %<asm%>\");\n-  delete_insn (insn);\n-}\n-/* Given a pointer to a piece of rtx and an optional pointer to the\n-   containing object, instantiate any virtual registers present in it.\n+  /* In the general case, we expect virtual registers to appear only in\n+     operands, and then only as either bare registers or inside memories.  */\n+  for (i = 0; i < recog_data.n_operands; ++i)\n+    {\n+      x = recog_data.operand[i];\n+      switch (GET_CODE (x))\n+\t{\n+\tcase MEM:\n+\t  {\n+\t    rtx addr = XEXP (x, 0);\n+\t    bool changed = false;\n \n-   If EXTRA_INSNS, we always do the replacement and generate\n-   any extra insns before OBJECT.  If it zero, we do nothing if replacement\n-   is not valid.\n+\t    for_each_rtx (&addr, instantiate_virtual_regs_in_rtx, &changed);\n+\t    if (!changed)\n+\t      continue;\n \n-   Return 1 if we either had nothing to do or if we were able to do the\n-   needed replacement.  Return 0 otherwise; we only return zero if\n-   EXTRA_INSNS is zero.\n+\t    start_sequence ();\n+\t    x = replace_equiv_address (x, addr);\n+\t    seq = get_insns ();\n+\t    end_sequence ();\n+\t    if (seq)\n+\t      emit_insn_before (seq, insn);\n+\t  }\n+\t  break;\n \n-   We first try some simple transformations to avoid the creation of extra\n-   pseudos.  */\n+\tcase REG:\n+\t  new = instantiate_new_reg (x, &offset);\n+\t  if (new == NULL)\n+\t    continue;\n+\t  if (offset == 0)\n+\t    x = new;\n+\t  else\n+\t    {\n+\t      start_sequence ();\n \n-static int\n-instantiate_virtual_regs_1 (rtx *loc, rtx object, int extra_insns)\n-{\n-  rtx x;\n-  RTX_CODE code;\n-  rtx new = 0;\n-  HOST_WIDE_INT offset = 0;\n-  rtx temp;\n-  rtx seq;\n-  int i, j;\n-  const char *fmt;\n+\t      /* Careful, special mode predicates may have stuff in\n+\t\t insn_data[insn_code].operand[i].mode that isn't useful\n+\t\t to us for computing a new value.  */\n+\t      /* ??? Recognize address_operand and/or \"p\" constraints\n+\t\t to see if (plus new offset) is a valid before we put\n+\t\t this through expand_simple_binop.  */\n+\t      x = expand_simple_binop (GET_MODE (x), PLUS, new,\n+\t\t\t\t       GEN_INT (offset), NULL_RTX,\n+\t\t\t\t       1, OPTAB_LIB_WIDEN);\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n+\t      emit_insn_before (seq, insn);\n+\t    }\n+\t  break;\n \n-  /* Re-start here to avoid recursion in common cases.  */\n- restart:\n+\tcase SUBREG:\n+\t  new = instantiate_new_reg (SUBREG_REG (x), &offset);\n+\t  if (new == NULL)\n+\t    continue;\n+\t  if (offset != 0)\n+\t    {\n+\t      start_sequence ();\n+\t      new = expand_simple_binop (GET_MODE (new), PLUS, new,\n+\t\t\t\t\t GEN_INT (offset), NULL_RTX,\n+\t\t\t\t\t 1, OPTAB_LIB_WIDEN);\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n+\t      emit_insn_before (seq, insn);\n+\t    }\n+\t  x = simplify_gen_subreg (insn_data[insn_code].operand[i].mode,\n+\t\t\t\t   new, GET_MODE (new), SUBREG_BYTE (x));\n+\t  break;\n \n-  x = *loc;\n-  if (x == 0)\n-    return 1;\n+\tdefault:\n+\t  continue;\n+\t}\n \n-  /* We may have detected and deleted invalid asm statements.  */\n-  if (object && INSN_P (object) && INSN_DELETED_P (object))\n-    return 1;\n+      /* At this point, X contains the new value for the operand.\n+\t Validate the new value vs the insn predicate.  Note that\n+\t asm insns will have insn_code -1 here.  */\n+      if (!safe_insn_predicate (insn_code, i, x))\n+\tx = force_reg (insn_data[insn_code].operand[i].mode, x);\n \n-  code = GET_CODE (x);\n+      *recog_data.operand_loc[i] = recog_data.operand[i] = x;\n+      any_change = true;\n+    }\n \n-  /* Check for some special cases.  */\n-  switch (code)\n+ verify:\n+  if (any_change)\n     {\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case CODE_LABEL:\n-    case PC:\n-    case CC0:\n-    case ASM_INPUT:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-    case RETURN:\n-      return 1;\n+      /* Propagate operand changes into the duplicates.  */\n+      for (i = 0; i < recog_data.n_dups; ++i)\n+\t*recog_data.dup_loc[i]\n+\t  = recog_data.operand[(unsigned)recog_data.dup_num[i]];\n \n-    case SET:\n-      /* We are allowed to set the virtual registers.  This means that\n-\t the actual register should receive the source minus the\n-\t appropriate offset.  This is used, for example, in the handling\n-\t of non-local gotos.  */\n-      if ((new = instantiate_new_reg (SET_DEST (x), &offset)) != 0)\n+      /* Force re-recognition of the instruction for validation.  */\n+      INSN_CODE (insn) = -1;\n+    }\n+\n+  if (asm_noperands (PATTERN (insn)) >= 0)\n+    {\n+      if (!check_asm_operands (PATTERN (insn)))\n \t{\n-\t  rtx src = SET_SRC (x);\n+\t  error_for_asm (insn, \"impossible constraint in %<asm%>\");\n+\t  delete_insn (insn);\n+\t}\n+    }\n+  else\n+    {\n+      if (recog_memoized (insn) < 0)\n+\tfatal_insn_not_found (insn);\n+    }\n+}\n \n-\t  /* We are setting the register, not using it, so the relevant\n-\t     offset is the negative of the offset to use were we using\n-\t     the register.  */\n-\t  offset = - offset;\n-\t  instantiate_virtual_regs_1 (&src, NULL_RTX, 0);\n+/* Subroutine of instantiate_decls.  Given RTL representing a decl,\n+   do any instantiation required.  */\n \n-\t  /* The only valid sources here are PLUS or REG.  Just do\n-\t     the simplest possible thing to handle them.  */\n-\t  if (!REG_P (src) && GET_CODE (src) != PLUS)\n-\t    {\n-\t      instantiate_virtual_regs_lossage (object);\n-\t      return 1;\n-\t    }\n+static void\n+instantiate_decl (rtx x)\n+{\n+  rtx addr;\n \n-\t  start_sequence ();\n-\t  if (!REG_P (src))\n-\t    temp = force_operand (src, NULL_RTX);\n-\t  else\n-\t    temp = src;\n-\t  temp = force_operand (plus_constant (temp, offset), NULL_RTX);\n-\t  seq = get_insns ();\n-\t  end_sequence ();\n+  if (x == 0)\n+    return;\n \n-\t  emit_insn_before (seq, object);\n-\t  SET_DEST (x) = new;\n+  /* If this is a CONCAT, recurse for the pieces.  */\n+  if (GET_CODE (x) == CONCAT)\n+    {\n+      instantiate_decl (XEXP (x, 0));\n+      instantiate_decl (XEXP (x, 1));\n+      return;\n+    }\n \n-\t  if (! validate_change (object, &SET_SRC (x), temp, 0)\n-\t      || ! extra_insns)\n-\t    instantiate_virtual_regs_lossage (object);\n+  /* If this is not a MEM, no need to do anything.  Similarly if the\n+     address is a constant or a register that is not a virtual register.  */\n+  if (!MEM_P (x))\n+    return;\n \n-\t  return 1;\n-\t}\n+  addr = XEXP (x, 0);\n+  if (CONSTANT_P (addr)\n+      || (REG_P (addr)\n+\t  && (REGNO (addr) < FIRST_VIRTUAL_REGISTER\n+\t      || REGNO (addr) > LAST_VIRTUAL_REGISTER)))\n+    return;\n \n-      instantiate_virtual_regs_1 (&SET_DEST (x), object, extra_insns);\n-      loc = &SET_SRC (x);\n-      goto restart;\n+  for_each_rtx (&XEXP (x, 0), instantiate_virtual_regs_in_rtx, NULL);\n+}\n \n-    case PLUS:\n-      /* Handle special case of virtual register plus constant.  */\n-      if (CONSTANT_P (XEXP (x, 1)))\n-\t{\n-\t  rtx old, new_offset;\n+/* Subroutine of instantiate_decls: Process all decls in the given\n+   BLOCK node and all its subblocks.  */\n \n-\t  /* Check for (plus (plus VIRT foo) (const_int)) first.  */\n-\t  if (GET_CODE (XEXP (x, 0)) == PLUS)\n-\t    {\n-\t      if ((new = instantiate_new_reg (XEXP (XEXP (x, 0), 0), &offset)))\n-\t\t{\n-\t\t  instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 1), object,\n-\t\t\t\t\t      extra_insns);\n-\t\t  new = gen_rtx_PLUS (Pmode, new, XEXP (XEXP (x, 0), 1));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  loc = &XEXP (x, 0);\n-\t\t  goto restart;\n-\t\t}\n-\t    }\n+static void\n+instantiate_decls_1 (tree let)\n+{\n+  tree t;\n \n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t  /* If we have (plus (subreg (virtual-reg)) (const_int)), we know\n-\t     we can commute the PLUS and SUBREG because pointers into the\n-\t     frame are well-behaved.  */\n-\t  else if (GET_CODE (XEXP (x, 0)) == SUBREG && GET_MODE (x) == ptr_mode\n-\t\t   && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t\t   && 0 != (new\n-\t\t\t    = instantiate_new_reg (SUBREG_REG (XEXP (x, 0)),\n-\t\t\t\t\t\t   &offset))\n-\t\t   && validate_change (object, loc,\n-\t\t\t\t       plus_constant (gen_lowpart (ptr_mode,\n-\t\t\t\t\t\t\t\t   new),\n-\t\t\t\t\t\t      offset\n-\t\t\t\t\t\t      + INTVAL (XEXP (x, 1))),\n-\t\t\t\t       0))\n-\t\treturn 1;\n-#endif\n-\t  else if ((new = instantiate_new_reg (XEXP (x, 0), &offset)) == 0)\n-\t    {\n-\t      /* We know the second operand is a constant.  Unless the\n-\t\t first operand is a REG (which has been already checked),\n-\t\t it needs to be checked.  */\n-\t      if (!REG_P (XEXP (x, 0)))\n-\t\t{\n-\t\t  loc = &XEXP (x, 0);\n-\t\t  goto restart;\n-\t\t}\n-\t      return 1;\n-\t    }\n+  for (t = BLOCK_VARS (let); t; t = TREE_CHAIN (t))\n+    if (DECL_RTL_SET_P (t))\n+      instantiate_decl (DECL_RTL (t));\n \n-\t  new_offset = plus_constant (XEXP (x, 1), offset);\n-\n-\t  /* If the new constant is zero, try to replace the sum with just\n-\t     the register.  */\n-\t  if (new_offset == const0_rtx\n-\t      && validate_change (object, loc, new, 0))\n-\t    return 1;\n-\n-\t  /* Next try to replace the register and new offset.\n-\t     There are two changes to validate here and we can't assume that\n-\t     in the case of old offset equals new just changing the register\n-\t     will yield a valid insn.  In the interests of a little efficiency,\n-\t     however, we only call validate change once (we don't queue up the\n-\t     changes and then call apply_change_group).  */\n-\n-\t  old = XEXP (x, 0);\n-\t  if (offset == 0\n-\t      ? ! validate_change (object, &XEXP (x, 0), new, 0)\n-\t      : (XEXP (x, 0) = new,\n-\t\t ! validate_change (object, &XEXP (x, 1), new_offset, 0)))\n-\t    {\n-\t      if (! extra_insns)\n-\t\t{\n-\t\t  XEXP (x, 0) = old;\n-\t\t  return 0;\n-\t\t}\n+  /* Process all subblocks.  */\n+  for (t = BLOCK_SUBBLOCKS (let); t; t = TREE_CHAIN (t))\n+    instantiate_decls_1 (t);\n+}\n \n-\t      /* Otherwise copy the new constant into a register and replace\n-\t\t constant with that register.  */\n-\t      temp = gen_reg_rtx (Pmode);\n-\t      XEXP (x, 0) = new;\n-\t      if (validate_change (object, &XEXP (x, 1), temp, 0))\n-\t\temit_insn_before (gen_move_insn (temp, new_offset), object);\n-\t      else\n-\t\t{\n-\t\t  /* If that didn't work, replace this expression with a\n-\t\t     register containing the sum.  */\n+/* Scan all decls in FNDECL (both variables and parameters) and instantiate\n+   all virtual registers in their DECL_RTL's.  */\n \n-\t\t  XEXP (x, 0) = old;\n-\t\t  new = gen_rtx_PLUS (Pmode, new, new_offset);\n+static void\n+instantiate_decls (tree fndecl)\n+{\n+  tree decl;\n \n-\t\t  start_sequence ();\n-\t\t  temp = force_operand (new, NULL_RTX);\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n+  /* Process all parameters of the function.  */\n+  for (decl = DECL_ARGUMENTS (fndecl); decl; decl = TREE_CHAIN (decl))\n+    {\n+      instantiate_decl (DECL_RTL (decl));\n+      instantiate_decl (DECL_INCOMING_RTL (decl));\n+    }\n \n-\t\t  emit_insn_before (seq, object);\n-\t\t  if (! validate_change (object, loc, temp, 0)\n-\t\t      && ! validate_replace_rtx (x, temp, object))\n-\t\t    {\n-\t\t      instantiate_virtual_regs_lossage (object);\n-\t\t      return 1;\n-\t\t    }\n-\t\t}\n-\t    }\n+  /* Now process all variables defined in the function or its subblocks.  */\n+  instantiate_decls_1 (DECL_INITIAL (fndecl));\n+}\n \n-\t  return 1;\n-\t}\n+/* Pass through the INSNS of function FNDECL and convert virtual register\n+   references to hard register references.  */\n \n-      /* Fall through to generic two-operand expression case.  */\n-    case EXPR_LIST:\n-    case CALL:\n-    case COMPARE:\n-    case MINUS:\n-    case MULT:\n-    case DIV:      case UDIV:\n-    case MOD:      case UMOD:\n-    case AND:      case IOR:      case XOR:\n-    case ROTATERT: case ROTATE:\n-    case ASHIFTRT: case LSHIFTRT: case ASHIFT:\n-    case NE:       case EQ:\n-    case GE:       case GT:       case GEU:    case GTU:\n-    case LE:       case LT:       case LEU:    case LTU:\n-      if (XEXP (x, 1) && ! CONSTANT_P (XEXP (x, 1)))\n-\tinstantiate_virtual_regs_1 (&XEXP (x, 1), object, extra_insns);\n-      loc = &XEXP (x, 0);\n-      goto restart;\n-\n-    case MEM:\n-      /* Most cases of MEM that convert to valid addresses have already been\n-\t handled by our scan of decls.  The only special handling we\n-\t need here is to make a copy of the rtx to ensure it isn't being\n-\t shared if we have to change it to a pseudo.\n-\n-\t If the rtx is a simple reference to an address via a virtual register,\n-\t it can potentially be shared.  In such cases, first try to make it\n-\t a valid address, which can also be shared.  Otherwise, copy it and\n-\t proceed normally.\n-\n-\t First check for common cases that need no processing.  These are\n-\t usually due to instantiation already being done on a previous instance\n-\t of a shared rtx.  */\n-\n-      temp = XEXP (x, 0);\n-      if (CONSTANT_ADDRESS_P (temp)\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t  || temp == arg_pointer_rtx\n-#endif\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t  || temp == hard_frame_pointer_rtx\n-#endif\n-\t  || temp == frame_pointer_rtx)\n-\treturn 1;\n-\n-      if (GET_CODE (temp) == PLUS\n-\t  && CONSTANT_ADDRESS_P (XEXP (temp, 1))\n-\t  && (XEXP (temp, 0) == frame_pointer_rtx\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t      || XEXP (temp, 0) == hard_frame_pointer_rtx\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t      || XEXP (temp, 0) == arg_pointer_rtx\n-#endif\n-\t      ))\n-\treturn 1;\n-\n-      if (temp == virtual_stack_vars_rtx\n-\t  || temp == virtual_incoming_args_rtx\n-\t  || (GET_CODE (temp) == PLUS\n-\t      && CONSTANT_ADDRESS_P (XEXP (temp, 1))\n-\t      && (XEXP (temp, 0) == virtual_stack_vars_rtx\n-\t\t  || XEXP (temp, 0) == virtual_incoming_args_rtx)))\n-\t{\n-\t  /* This MEM may be shared.  If the substitution can be done without\n-\t     the need to generate new pseudos, we want to do it in place\n-\t     so all copies of the shared rtx benefit.  The call below will\n-\t     only make substitutions if the resulting address is still\n-\t     valid.\n-\n-\t     Note that we cannot pass X as the object in the recursive call\n-\t     since the insn being processed may not allow all valid\n-\t     addresses.  However, if we were not passed on object, we can\n-\t     only modify X without copying it if X will have a valid\n-\t     address.\n-\n-\t     ??? Also note that this can still lose if OBJECT is an insn that\n-\t     has less restrictions on an address that some other insn.\n-\t     In that case, we will modify the shared address.  This case\n-\t     doesn't seem very likely, though.  One case where this could\n-\t     happen is in the case of a USE or CLOBBER reference, but we\n-\t     take care of that below.  */\n-\n-\t  if (instantiate_virtual_regs_1 (&XEXP (x, 0),\n-\t\t\t\t\t  object ? object : x, 0))\n-\t    return 1;\n-\n-\t  /* Otherwise make a copy and process that copy.  We copy the entire\n-\t     RTL expression since it might be a PLUS which could also be\n-\t     shared.  */\n-\t  *loc = x = copy_rtx (x);\n-\t}\n+void\n+instantiate_virtual_regs (void)\n+{\n+  rtx insn;\n \n-      /* Fall through to generic unary operation case.  */\n-    case PREFETCH:\n-    case SUBREG:\n-    case STRICT_LOW_PART:\n-    case NEG:          case NOT:\n-    case PRE_DEC:      case PRE_INC:      case POST_DEC:    case POST_INC:\n-    case SIGN_EXTEND:  case ZERO_EXTEND:\n-    case TRUNCATE:     case FLOAT_EXTEND: case FLOAT_TRUNCATE:\n-    case FLOAT:        case FIX:\n-    case UNSIGNED_FIX: case UNSIGNED_FLOAT:\n-    case ABS:\n-    case SQRT:\n-    case FFS:\n-    case CLZ:          case CTZ:\n-    case POPCOUNT:     case PARITY:\n-      /* These case either have just one operand or we know that we need not\n-\t check the rest of the operands.  */\n-      loc = &XEXP (x, 0);\n-      goto restart;\n-\n-    case USE:\n-    case CLOBBER:\n-      /* If the operand is a MEM, see if the change is a valid MEM.  If not,\n-\t go ahead and make the invalid one, but do it to a copy.  For a REG,\n-\t just make the recursive call, since there's no chance of a problem.  */\n-\n-      if ((MEM_P (XEXP (x, 0))\n-\t   && instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 0), XEXP (x, 0),\n-\t\t\t\t\t  0))\n-\t  || (REG_P (XEXP (x, 0))\n-\t      && instantiate_virtual_regs_1 (&XEXP (x, 0), object, 0)))\n-\treturn 1;\n-\n-      XEXP (x, 0) = copy_rtx (XEXP (x, 0));\n-      loc = &XEXP (x, 0);\n-      goto restart;\n+  /* Compute the offsets to use for this function.  */\n+  in_arg_offset = FIRST_PARM_OFFSET (current_function_decl);\n+  var_offset = STARTING_FRAME_OFFSET;\n+  dynamic_offset = STACK_DYNAMIC_OFFSET (current_function_decl);\n+  out_arg_offset = STACK_POINTER_OFFSET;\n+  cfa_offset = ARG_POINTER_CFA_OFFSET (current_function_decl);\n \n-    case REG:\n-      /* Try to replace with a PLUS.  If that doesn't work, compute the sum\n-\t in front of this insn and substitute the temporary.  */\n-      if ((new = instantiate_new_reg (x, &offset)) != 0)\n-\t{\n-\t  temp = plus_constant (new, offset);\n-\t  if (!validate_change (object, loc, temp, 0))\n-\t    {\n-\t      if (! extra_insns)\n-\t\treturn 0;\n+  /* Initialize recognition, indicating that volatile is OK.  */\n+  init_recog ();\n \n-\t      start_sequence ();\n-\t      temp = force_operand (temp, NULL_RTX);\n-\t      seq = get_insns ();\n-\t      end_sequence ();\n+  /* Scan through all the insns, instantiating every virtual register still\n+     present.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      {\n+\t/* These patterns in the instruction stream can never be recognized.\n+\t   Fortunately, they shouldn't contain virtual registers either.  */\n+\tif (GET_CODE (PATTERN (insn)) == USE\n+\t    || GET_CODE (PATTERN (insn)) == CLOBBER\n+\t    || GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t    || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+\t    || GET_CODE (PATTERN (insn)) == ASM_INPUT)\n+\t  continue;\n \n-\t      emit_insn_before (seq, object);\n-\t      if (! validate_change (object, loc, temp, 0)\n-\t\t  && ! validate_replace_rtx (x, temp, object))\n-\t        instantiate_virtual_regs_lossage (object);\n-\t    }\n-\t}\n+\tinstantiate_virtual_regs_in_insn (insn);\n \n-      return 1;\n+\tif (INSN_DELETED_P (insn))\n+\t  continue;\n \n-    default:\n-      break;\n-    }\n+\tfor_each_rtx (&REG_NOTES (insn), instantiate_virtual_regs_in_rtx, NULL);\n \n-  /* Scan all subexpressions.  */\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n-    if (*fmt == 'e')\n-      {\n-\tif (!instantiate_virtual_regs_1 (&XEXP (x, i), object, extra_insns))\n-\t  return 0;\n+\t/* Instantiate any virtual registers in CALL_INSN_FUNCTION_USAGE.  */\n+\tif (GET_CODE (insn) == CALL_INSN)\n+\t  for_each_rtx (&CALL_INSN_FUNCTION_USAGE (insn),\n+\t\t\tinstantiate_virtual_regs_in_rtx, NULL);\n       }\n-    else if (*fmt == 'E')\n-      for (j = 0; j < XVECLEN (x, i); j++)\n-\tif (! instantiate_virtual_regs_1 (&XVECEXP (x, i, j), object,\n-\t\t\t\t\t  extra_insns))\n-\t  return 0;\n \n-  return 1;\n+  /* Instantiate the virtual registers in the DECLs for debugging purposes.  */\n+  instantiate_decls (current_function_decl);\n+\n+  /* Indicate that, from now on, assign_stack_local should use\n+     frame_pointer_rtx.  */\n+  virtuals_instantiated = 1;\n }\n \f\n /* Return 1 if EXP is an aggregate type (or a value with aggregate type)."}]}