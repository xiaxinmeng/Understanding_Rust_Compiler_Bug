{"sha": "d962e073a077fe4066b937412d0f6d435f2f4f92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk2MmUwNzNhMDc3ZmU0MDY2YjkzNzQxMmQwZjZkNDM1ZjJmNGY5Mg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-06-14T19:40:45Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-14T19:40:45Z"}, "message": "hash_map: Trivial formatting fixes.\n\n2004-06-14  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/hash_map: Trivial formatting fixes.\n\t* include/ext/hash_set: Likewise.\n\t* include/ext/memory: Likewise.\n\t* include/ext/numeric: Likewise.\n\nFrom-SVN: r83131", "tree": {"sha": "e5032559fc9d1fe4df369033b7e88567f6f92795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5032559fc9d1fe4df369033b7e88567f6f92795"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d962e073a077fe4066b937412d0f6d435f2f4f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d962e073a077fe4066b937412d0f6d435f2f4f92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d962e073a077fe4066b937412d0f6d435f2f4f92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d962e073a077fe4066b937412d0f6d435f2f4f92/comments", "author": null, "committer": null, "parents": [{"sha": "f51d8522f761fab8df285b2fa3aa8c6a931509c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f51d8522f761fab8df285b2fa3aa8c6a931509c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f51d8522f761fab8df285b2fa3aa8c6a931509c3"}], "stats": {"total": 1788, "additions": 1057, "deletions": 731}, "files": [{"sha": "f18473f246b1a2d02ebf02762cf4fb5304850398", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d962e073a077fe4066b937412d0f6d435f2f4f92", "patch": "@@ -1,3 +1,10 @@\n+2004-06-14  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/hash_map: Trivial formatting fixes.\n+\t* include/ext/hash_set: Likewise.\n+\t* include/ext/memory: Likewise.\n+\t* include/ext/numeric: Likewise.\n+\n 2004-06-14  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* Makefile.in: Regenerate with automake 1.8.5."}, {"sha": "d1514c4d02fe5415d5d82c096d28aa5be44a06e9", "filename": "libstdc++-v3/include/ext/hash_map", "status": "modified", "additions": 526, "deletions": 352, "changes": 878, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map?ref=d962e073a077fe4066b937412d0f6d435f2f4f92", "patch": "@@ -1,6 +1,6 @@\n // Hashing map implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -74,314 +74,456 @@ namespace __gnu_cxx\n \n   // Forward declaration of equality operator; needed for friend\n   // declaration.\n-  template<class _Key, class _Tp, class _HashFcn  = hash<_Key>,\n-\t    class _EqualKey = equal_to<_Key>, class _Alloc =  allocator<_Tp> >\n+  template<class _Key, class _Tp, class _HashFcn = hash<_Key>,\n+\t   class _EqualKey = equal_to<_Key>, class _Alloc = allocator<_Tp> >\n     class hash_map;\n \n   template<class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>\n-  inline bool operator==(const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&,\n-\t\t\t const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&);\n-/**\n- *  This is an SGI extension.\n- *  @ingroup SGIextensions\n- *  @doctodo\n-*/\n-template <class _Key, class _Tp, class _HashFcn, class _EqualKey,\n-          class _Alloc>\n-class hash_map\n-{\n-private:\n-  typedef hashtable<pair<const _Key,_Tp>,_Key,_HashFcn,\n-                    _Select1st<pair<const _Key,_Tp> >,_EqualKey,_Alloc> _Ht;\n-  _Ht _M_ht;\n-\n-public:\n-  typedef typename _Ht::key_type key_type;\n-  typedef _Tp data_type;\n-  typedef _Tp mapped_type;\n-  typedef typename _Ht::value_type value_type;\n-  typedef typename _Ht::hasher hasher;\n-  typedef typename _Ht::key_equal key_equal;\n-\n-  typedef typename _Ht::size_type size_type;\n-  typedef typename _Ht::difference_type difference_type;\n-  typedef typename _Ht::pointer pointer;\n-  typedef typename _Ht::const_pointer const_pointer;\n-  typedef typename _Ht::reference reference;\n-  typedef typename _Ht::const_reference const_reference;\n-\n-  typedef typename _Ht::iterator iterator;\n-  typedef typename _Ht::const_iterator const_iterator;\n-\n-  typedef typename _Ht::allocator_type allocator_type;\n-\n-  hasher hash_funct() const { return _M_ht.hash_funct(); }\n-  key_equal key_eq() const { return _M_ht.key_eq(); }\n-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n-\n-public:\n-  hash_map() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n-  explicit hash_map(size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n-  hash_map(size_type __n, const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n-  hash_map(size_type __n, const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a) {}\n-\n-  template <class _InputIterator>\n-  hash_map(_InputIterator __f, _InputIterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-\n-public:\n-  size_type size() const { return _M_ht.size(); }\n-  size_type max_size() const { return _M_ht.max_size(); }\n-  bool empty() const { return _M_ht.empty(); }\n-  void swap(hash_map& __hs) { _M_ht.swap(__hs._M_ht); }\n-\n-  template <class _K1, class _T1, class _HF, class _EqK, class _Al>\n-  friend bool operator== (const hash_map<_K1, _T1, _HF, _EqK, _Al>&,\n-                          const hash_map<_K1, _T1, _HF, _EqK, _Al>&);\n-\n-  iterator begin() { return _M_ht.begin(); }\n-  iterator end() { return _M_ht.end(); }\n-  const_iterator begin() const { return _M_ht.begin(); }\n-  const_iterator end() const { return _M_ht.end(); }\n-\n-public:\n-  pair<iterator,bool> insert(const value_type& __obj)\n-    { return _M_ht.insert_unique(__obj); }\n-  template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l)\n-    { _M_ht.insert_unique(__f,__l); }\n-  pair<iterator,bool> insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_unique_noresize(__obj); }\n-\n-  iterator find(const key_type& __key) { return _M_ht.find(__key); }\n-  const_iterator find(const key_type& __key) const\n-    { return _M_ht.find(__key); }\n-\n-  _Tp& operator[](const key_type& __key) {\n-    return _M_ht.find_or_insert(value_type(__key, _Tp())).second;\n-  }\n-\n-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-\n-  pair<iterator, iterator> equal_range(const key_type& __key)\n-    { return _M_ht.equal_range(__key); }\n-  pair<const_iterator, const_iterator>\n-  equal_range(const key_type& __key) const\n-    { return _M_ht.equal_range(__key); }\n-\n-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n-  void erase(iterator __it) { _M_ht.erase(__it); }\n-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n-  void clear() { _M_ht.clear(); }\n-\n-  void resize(size_type __hint) { _M_ht.resize(__hint); }\n-  size_type bucket_count() const { return _M_ht.bucket_count(); }\n-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type __n) const\n-    { return _M_ht.elems_in_bucket(__n); }\n-};\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline bool\n-operator==(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n-           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n-{\n-  return __hm1._M_ht == __hm2._M_ht;\n-}\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline bool\n-operator!=(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n-           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2) {\n-  return !(__hm1 == __hm2);\n-}\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline void\n-swap(hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n-     hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n-{\n-  __hm1.swap(__hm2);\n-}\n-\n-// Forward declaration of equality operator; needed for friend declaration.\n-\n-template <class _Key, class _Tp,\n-          class _HashFcn  = hash<_Key>,\n-          class _EqualKey = equal_to<_Key>,\n-          class _Alloc =  allocator<_Tp> >\n-class hash_multimap;\n-\n-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool\n-operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2);\n-\n-/**\n- *  This is an SGI extension.\n- *  @ingroup SGIextensions\n- *  @doctodo\n-*/\n-template <class _Key, class _Tp, class _HashFcn, class _EqualKey, class _Alloc>\n-class hash_multimap\n-{\n-  // concept requirements\n-  __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n-  __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-  __glibcxx_class_requires3(_HashFcn, size_t, _Key, _UnaryFunctionConcept)\n-  __glibcxx_class_requires3(_EqualKey, _Key, _Key, _BinaryPredicateConcept)\n-\n-private:\n-  typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,\n-                    _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc>\n+    inline bool\n+    operator==(const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&,\n+\t       const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&);\n+\n+  /**\n+   *  This is an SGI extension.\n+   *  @ingroup SGIextensions\n+   *  @doctodo\n+   */\n+  template <class _Key, class _Tp, class _HashFcn, class _EqualKey,\n+\t    class _Alloc>\n+    class hash_map\n+    {\n+    private:\n+      typedef hashtable<pair<const _Key, _Tp>,_Key, _HashFcn,\n+\t\t\t_Select1st<pair<const _Key, _Tp> >,\n+\t\t\t_EqualKey, _Alloc> _Ht;\n+\n+      _Ht _M_ht;\n+\n+    public:\n+      typedef typename _Ht::key_type key_type;\n+      typedef _Tp data_type;\n+      typedef _Tp mapped_type;\n+      typedef typename _Ht::value_type value_type;\n+      typedef typename _Ht::hasher hasher;\n+      typedef typename _Ht::key_equal key_equal;\n+      \n+      typedef typename _Ht::size_type size_type;\n+      typedef typename _Ht::difference_type difference_type;\n+      typedef typename _Ht::pointer pointer;\n+      typedef typename _Ht::const_pointer const_pointer;\n+      typedef typename _Ht::reference reference;\n+      typedef typename _Ht::const_reference const_reference;\n+      \n+      typedef typename _Ht::iterator iterator;\n+      typedef typename _Ht::const_iterator const_iterator;\n+      \n+      typedef typename _Ht::allocator_type allocator_type;\n+      \n+      hasher\n+      hash_funct() const\n+      { return _M_ht.hash_funct(); }\n+\n+      key_equal\n+      key_eq() const\n+      { return _M_ht.key_eq(); }\n+\n+      allocator_type\n+      get_allocator() const\n+      { return _M_ht.get_allocator(); }\n+\n+    public:\n+      hash_map()\n+      : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n+  \n+      explicit\n+      hash_map(size_type __n)\n+      : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n+\n+      hash_map(size_type __n, const hasher& __hf)\n+      : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n+\n+      hash_map(size_type __n, const hasher& __hf, const key_equal& __eql,\n+\t       const allocator_type& __a = allocator_type())\n+      : _M_ht(__n, __hf, __eql, __a) {}\n+\n+      template <class _InputIterator>\n+        hash_map(_InputIterator __f, _InputIterator __l)\n+\t: _M_ht(100, hasher(), key_equal(), allocator_type())\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_map(_InputIterator __f, _InputIterator __l, size_type __n)\n+\t: _M_ht(__n, hasher(), key_equal(), allocator_type())\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t const hasher& __hf)\n+\t: _M_ht(__n, __hf, key_equal(), allocator_type())\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t const hasher& __hf, const key_equal& __eql,\n+\t\t const allocator_type& __a = allocator_type())\n+\t: _M_ht(__n, __hf, __eql, __a)\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+    public:\n+      size_type\n+      size() const\n+      { return _M_ht.size(); }\n+      \n+      size_type\n+      max_size() const\n+      { return _M_ht.max_size(); }\n+      \n+      bool\n+      empty() const\n+      { return _M_ht.empty(); }\n+  \n+      void\n+      swap(hash_map& __hs)\n+      { _M_ht.swap(__hs._M_ht); }\n+\n+      template <class _K1, class _T1, class _HF, class _EqK, class _Al>\n+        friend bool\n+        operator== (const hash_map<_K1, _T1, _HF, _EqK, _Al>&,\n+\t\t    const hash_map<_K1, _T1, _HF, _EqK, _Al>&);\n+\n+      iterator\n+      begin()\n+      { return _M_ht.begin(); }\n+\n+      iterator\n+      end()\n+      { return _M_ht.end(); }\n+\n+      const_iterator\n+      begin() const\n+      { return _M_ht.begin(); }\n+\n+      const_iterator\n+      end() const\n+      { return _M_ht.end(); }\n+\n+    public:\n+      pair<iterator, bool>\n+      insert(const value_type& __obj)\n+      { return _M_ht.insert_unique(__obj); }\n+\n+      template <class _InputIterator>\n+        void\n+        insert(_InputIterator __f, _InputIterator __l)\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+      pair<iterator, bool>\n+      insert_noresize(const value_type& __obj)\n+      { return _M_ht.insert_unique_noresize(__obj); }\n+\n+      iterator\n+      find(const key_type& __key)\n+      { return _M_ht.find(__key); }\n+\n+      const_iterator\n+      find(const key_type& __key) const\n+      { return _M_ht.find(__key); }\n+\n+      _Tp&\n+      operator[](const key_type& __key)\n+      { return _M_ht.find_or_insert(value_type(__key, _Tp())).second; }\n+\n+      size_type\n+      count(const key_type& __key) const\n+      { return _M_ht.count(__key); }\n+\n+      pair<iterator, iterator>\n+      equal_range(const key_type& __key)\n+      { return _M_ht.equal_range(__key); }\n+\n+      pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const\n+      { return _M_ht.equal_range(__key); }\n+\n+      size_type\n+      erase(const key_type& __key)\n+      {return _M_ht.erase(__key); }\n+\n+      void\n+      erase(iterator __it)\n+      { _M_ht.erase(__it); }\n+\n+      void\n+      erase(iterator __f, iterator __l)\n+      { _M_ht.erase(__f, __l); }\n+\n+      void\n+      clear()\n+      { _M_ht.clear(); }\n+\n+      void\n+      resize(size_type __hint)\n+      { _M_ht.resize(__hint); }\n+\n+      size_type\n+      bucket_count() const\n+      { return _M_ht.bucket_count(); }\n+\n+      size_type\n+      max_bucket_count() const\n+      { return _M_ht.max_bucket_count(); }\n+\n+      size_type\n+      elems_in_bucket(size_type __n) const\n+      { return _M_ht.elems_in_bucket(__n); }\n+    };\n+\n+  template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n+    inline bool\n+    operator==(const hash_map<_Key, _Tp, _HashFcn, _EqlKey, _Alloc>& __hm1,\n+\t       const hash_map<_Key, _Tp, _HashFcn, _EqlKey, _Alloc>& __hm2)\n+    { return __hm1._M_ht == __hm2._M_ht; }\n+\n+  template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n+    inline bool\n+    operator!=(const hash_map<_Key, _Tp, _HashFcn, _EqlKey, _Alloc>& __hm1,\n+\t       const hash_map<_Key, _Tp, _HashFcn, _EqlKey, _Alloc>& __hm2)\n+    { return !(__hm1 == __hm2); }\n+\n+  template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n+    inline void\n+    swap(hash_map<_Key, _Tp, _HashFcn, _EqlKey, _Alloc>& __hm1,\n+\t hash_map<_Key, _Tp, _HashFcn, _EqlKey, _Alloc>& __hm2)\n+    { __hm1.swap(__hm2); }\n+\n+  // Forward declaration of equality operator; needed for friend declaration.\n+\n+  template <class _Key, class _Tp,\n+\t    class _HashFcn  = hash<_Key>,\n+\t    class _EqualKey = equal_to<_Key>,\n+\t    class _Alloc =  allocator<_Tp> >\n+    class hash_multimap;\n+\n+  template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n+    inline bool\n+    operator==(const hash_multimap<_Key, _Tp, _HF, _EqKey, _Alloc>& __hm1,\n+\t       const hash_multimap<_Key, _Tp, _HF, _EqKey, _Alloc>& __hm2);\n+\n+  /**\n+   *  This is an SGI extension.\n+   *  @ingroup SGIextensions\n+   *  @doctodo\n+   */\n+  template <class _Key, class _Tp, class _HashFcn, class _EqualKey,\n+\t    class _Alloc>\n+    class hash_multimap\n+    {\n+      // concept requirements\n+      __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires3(_HashFcn, size_t, _Key, _UnaryFunctionConcept)\n+      __glibcxx_class_requires3(_EqualKey, _Key, _Key, _BinaryPredicateConcept)\n+\t\n+    private:\n+      typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,\n+\t\t\t_Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc>\n           _Ht;\n-  _Ht _M_ht;\n \n-public:\n-  typedef typename _Ht::key_type key_type;\n-  typedef _Tp data_type;\n-  typedef _Tp mapped_type;\n-  typedef typename _Ht::value_type value_type;\n-  typedef typename _Ht::hasher hasher;\n-  typedef typename _Ht::key_equal key_equal;\n-\n-  typedef typename _Ht::size_type size_type;\n-  typedef typename _Ht::difference_type difference_type;\n-  typedef typename _Ht::pointer pointer;\n-  typedef typename _Ht::const_pointer const_pointer;\n-  typedef typename _Ht::reference reference;\n-  typedef typename _Ht::const_reference const_reference;\n-\n-  typedef typename _Ht::iterator iterator;\n-  typedef typename _Ht::const_iterator const_iterator;\n-\n-  typedef typename _Ht::allocator_type allocator_type;\n-\n-  hasher hash_funct() const { return _M_ht.hash_funct(); }\n-  key_equal key_eq() const { return _M_ht.key_eq(); }\n-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n-\n-public:\n-  hash_multimap() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n-  explicit hash_multimap(size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n-  hash_multimap(size_type __n, const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n-  hash_multimap(size_type __n, const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a) {}\n-\n-  template <class _InputIterator>\n-  hash_multimap(_InputIterator __f, _InputIterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n+      _Ht _M_ht;\n+\n+    public:\n+      typedef typename _Ht::key_type key_type;\n+      typedef _Tp data_type;\n+      typedef _Tp mapped_type;\n+      typedef typename _Ht::value_type value_type;\n+      typedef typename _Ht::hasher hasher;\n+      typedef typename _Ht::key_equal key_equal;\n+      \n+      typedef typename _Ht::size_type size_type;\n+      typedef typename _Ht::difference_type difference_type;\n+      typedef typename _Ht::pointer pointer;\n+      typedef typename _Ht::const_pointer const_pointer;\n+      typedef typename _Ht::reference reference;\n+      typedef typename _Ht::const_reference const_reference;\n+      \n+      typedef typename _Ht::iterator iterator;\n+      typedef typename _Ht::const_iterator const_iterator;\n+      \n+      typedef typename _Ht::allocator_type allocator_type;\n+      \n+      hasher\n+      hash_funct() const\n+      { return _M_ht.hash_funct(); }\n+\n+      key_equal\n+      key_eq() const\n+      { return _M_ht.key_eq(); }\n+\n+      allocator_type\n+      get_allocator() const\n+      { return _M_ht.get_allocator(); }\n+\n+    public:\n+      hash_multimap()\n+      : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n+\n+      explicit\n+      hash_multimap(size_type __n)\n+      : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n+\n+      hash_multimap(size_type __n, const hasher& __hf)\n+      : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n+\n+      hash_multimap(size_type __n, const hasher& __hf, const key_equal& __eql,\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _M_ht(__n, __hf, __eql, __a) {}\n+\n+      template <class _InputIterator>\n+        hash_multimap(_InputIterator __f, _InputIterator __l)\n+\t: _M_ht(100, hasher(), key_equal(), allocator_type())\n+        { _M_ht.insert_equal(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n)\n+\t: _M_ht(__n, hasher(), key_equal(), allocator_type())\n+        { _M_ht.insert_equal(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t      const hasher& __hf)\n+\t: _M_ht(__n, __hf, key_equal(), allocator_type())\n+        { _M_ht.insert_equal(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t      const hasher& __hf, const key_equal& __eql,\n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _M_ht(__n, __hf, __eql, __a)\n+        { _M_ht.insert_equal(__f, __l); }\n+\n+    public:\n+      size_type\n+      size() const\n+      { return _M_ht.size(); }\n+\n+      size_type\n+      max_size() const\n+      { return _M_ht.max_size(); }\n+\n+      bool\n+      empty() const\n+      { return _M_ht.empty(); }\n+\n+      void\n+      swap(hash_multimap& __hs)\n+      { _M_ht.swap(__hs._M_ht); }\n+\n+      template <class _K1, class _T1, class _HF, class _EqK, class _Al>\n+        friend bool\n+        operator==(const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&,\n+\t\t   const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&);\n+\n+      iterator\n+      begin()\n+      { return _M_ht.begin(); }\n+\n+      iterator\n+      end()\n+      { return _M_ht.end(); }\n+\n+      const_iterator\n+      begin() const\n+      { return _M_ht.begin(); }\n+\n+      const_iterator\n+      end() const\n+      { return _M_ht.end(); }\n \n public:\n-  size_type size() const { return _M_ht.size(); }\n-  size_type max_size() const { return _M_ht.max_size(); }\n-  bool empty() const { return _M_ht.empty(); }\n-  void swap(hash_multimap& __hs) { _M_ht.swap(__hs._M_ht); }\n-\n-  template <class _K1, class _T1, class _HF, class _EqK, class _Al>\n-  friend bool operator== (const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&,\n-                          const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&);\n-\n-  iterator begin() { return _M_ht.begin(); }\n-  iterator end() { return _M_ht.end(); }\n-  const_iterator begin() const { return _M_ht.begin(); }\n-  const_iterator end() const { return _M_ht.end(); }\n+      iterator\n+      insert(const value_type& __obj)\n+      { return _M_ht.insert_equal(__obj); }\n+\n+      template <class _InputIterator>\n+        void\n+        insert(_InputIterator __f, _InputIterator __l)\n+        { _M_ht.insert_equal(__f,__l); }\n+\n+      iterator\n+      insert_noresize(const value_type& __obj)\n+      { return _M_ht.insert_equal_noresize(__obj); }\n+\n+      iterator\n+      find(const key_type& __key)\n+      { return _M_ht.find(__key); }\n+\n+      const_iterator\n+      find(const key_type& __key) const\n+      { return _M_ht.find(__key); }\n+\n+      size_type\n+      count(const key_type& __key) const\n+      { return _M_ht.count(__key); }\n+\n+      pair<iterator, iterator>\n+      equal_range(const key_type& __key)\n+      { return _M_ht.equal_range(__key); }\n+\n+      pair<const_iterator, const_iterator>\n+      equal_range(const key_type& __key) const\n+      { return _M_ht.equal_range(__key); }\n+\n+      size_type\n+      erase(const key_type& __key)\n+      { return _M_ht.erase(__key); }\n+\n+      void\n+      erase(iterator __it)\n+      { _M_ht.erase(__it); }\n+\n+      void\n+      erase(iterator __f, iterator __l)\n+      { _M_ht.erase(__f, __l); }\n+\n+      void\n+      clear()\n+      { _M_ht.clear(); }\n+\n+    public:\n+      void\n+      resize(size_type __hint)\n+      { _M_ht.resize(__hint); }\n+\n+      size_type\n+      bucket_count() const\n+      { return _M_ht.bucket_count(); }\n+\n+      size_type\n+      max_bucket_count() const\n+      { return _M_ht.max_bucket_count(); }\n+      \n+      size_type\n+      elems_in_bucket(size_type __n) const\n+      { return _M_ht.elems_in_bucket(__n); }\n+};\n \n-public:\n-  iterator insert(const value_type& __obj)\n-    { return _M_ht.insert_equal(__obj); }\n-  template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l)\n-    { _M_ht.insert_equal(__f,__l); }\n-  iterator insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_equal_noresize(__obj); }\n-\n-  iterator find(const key_type& __key) { return _M_ht.find(__key); }\n-  const_iterator find(const key_type& __key) const\n-    { return _M_ht.find(__key); }\n-\n-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-\n-  pair<iterator, iterator> equal_range(const key_type& __key)\n-    { return _M_ht.equal_range(__key); }\n-  pair<const_iterator, const_iterator>\n-  equal_range(const key_type& __key) const\n-    { return _M_ht.equal_range(__key); }\n-\n-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n-  void erase(iterator __it) { _M_ht.erase(__it); }\n-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n-  void clear() { _M_ht.clear(); }\n+  template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n+    inline bool\n+    operator==(const hash_multimap<_Key, _Tp, _HF, _EqKey, _Alloc>& __hm1,\n+\t       const hash_multimap<_Key, _Tp, _HF, _EqKey, _Alloc>& __hm2)\n+    { return __hm1._M_ht == __hm2._M_ht; }\n \n-public:\n-  void resize(size_type __hint) { _M_ht.resize(__hint); }\n-  size_type bucket_count() const { return _M_ht.bucket_count(); }\n-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type __n) const\n-    { return _M_ht.elems_in_bucket(__n); }\n-};\n+  template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n+    inline bool\n+    operator!=(const hash_multimap<_Key, _Tp, _HF, _EqKey, _Alloc>& __hm1,\n+\t       const hash_multimap<_Key, _Tp, _HF, _EqKey, _Alloc>& __hm2)\n+    { return !(__hm1 == __hm2); }\n \n-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool\n-operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2)\n-{\n-  return __hm1._M_ht == __hm2._M_ht;\n-}\n-\n-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>\n-inline bool\n-operator!=(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,\n-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2) {\n-  return !(__hm1 == __hm2);\n-}\n-\n-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n-inline void\n-swap(hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,\n-     hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)\n-{\n-  __hm1.swap(__hm2);\n-}\n+  template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>\n+    inline void\n+    swap(hash_multimap<_Key, _Tp, _HashFcn, _EqlKey, _Alloc>& __hm1,\n+\t hash_multimap<_Key, _Tp, _HashFcn, _EqlKey, _Alloc>& __hm2)\n+    { __hm1.swap(__hm2); }\n \n } // namespace __gnu_cxx\n \n@@ -390,58 +532,90 @@ namespace std\n // Specialization of insert_iterator so that it will work for hash_map\n // and hash_multimap.\n \n-template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>\n-class insert_iterator<__gnu_cxx::hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {\n-protected:\n-  typedef __gnu_cxx::hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;\n-  _Container* container;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x) : container(&__x) {}\n-  insert_iterator(_Container& __x, typename _Container::iterator)\n-    : container(&__x) {}\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) {\n-    container->insert(__value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n-\n-template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>\n-class insert_iterator<__gnu_cxx::hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {\n-protected:\n-  typedef __gnu_cxx::hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;\n-  _Container* container;\n-  typename _Container::iterator iter;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x) : container(&__x) {}\n-  insert_iterator(_Container& __x, typename _Container::iterator)\n-    : container(&__x) {}\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) {\n-    container->insert(__value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n+  template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>\n+    class insert_iterator<__gnu_cxx::hash_map<_Key, _Tp, _HashFn,\n+\t\t\t\t\t      _EqKey, _Alloc> >\n+    {\n+    protected:\n+      typedef __gnu_cxx::hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>\n+        _Container;\n+      _Container* container;\n+\n+    public:\n+      typedef _Container          container_type;\n+      typedef output_iterator_tag iterator_category;\n+      typedef void                value_type;\n+      typedef void                difference_type;\n+      typedef void                pointer;\n+      typedef void                reference;\n+      \n+      insert_iterator(_Container& __x)\n+      : container(&__x) {}\n+\n+      insert_iterator(_Container& __x, typename _Container::iterator)\n+      : container(&__x) {}\n+\n+      insert_iterator<_Container>&\n+      operator=(const typename _Container::value_type& __value)\n+      {\n+\tcontainer->insert(__value);\n+\treturn *this;\n+      }\n+\n+      insert_iterator<_Container>&\n+      operator*()\n+      { return *this; }\n+\n+      insert_iterator<_Container>&\n+      operator++() { return *this; }\n+\n+      insert_iterator<_Container>&\n+      operator++(int)\n+      { return *this; }\n+    };\n+\n+  template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>\n+    class insert_iterator<__gnu_cxx::hash_multimap<_Key, _Tp, _HashFn,\n+\t\t\t\t\t\t   _EqKey, _Alloc> >\n+    {\n+    protected:\n+      typedef __gnu_cxx::hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc>\n+        _Container;\n+      _Container* container;\n+      typename _Container::iterator iter;\n+\n+    public:\n+      typedef _Container          container_type;\n+      typedef output_iterator_tag iterator_category;\n+      typedef void                value_type;\n+      typedef void                difference_type;\n+      typedef void                pointer;\n+      typedef void                reference;\n+\n+      insert_iterator(_Container& __x)\n+      : container(&__x) {}\n+\n+      insert_iterator(_Container& __x, typename _Container::iterator)\n+      : container(&__x) {}\n+\n+      insert_iterator<_Container>&\n+      operator=(const typename _Container::value_type& __value)\n+      {\n+\tcontainer->insert(__value);\n+\treturn *this;\n+      }\n+\n+      insert_iterator<_Container>&\n+      operator*()\n+      { return *this; }\n+\n+      insert_iterator<_Container>&\n+      operator++()\n+      { return *this; }\n+\n+      insert_iterator<_Container>&\n+      operator++(int)\n+      { return *this; }\n+    };\n } // namespace std\n-\n #endif"}, {"sha": "ffa3c36d03bf402e787612b24535d1abe106aa84", "filename": "libstdc++-v3/include/ext/hash_set", "status": "modified", "additions": 488, "deletions": 340, "changes": 828, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set?ref=d962e073a077fe4066b937412d0f6d435f2f4f92", "patch": "@@ -1,6 +1,6 @@\n // Hashing set implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -76,364 +76,512 @@ namespace __gnu_cxx\n   // declaration.\n   template <class _Value, class _HashFcn  = hash<_Value>,\n \t    class _EqualKey = equal_to<_Value>,\n-\t    class _Alloc =  allocator<_Value> >\n-  class hash_set;\n+\t    class _Alloc = allocator<_Value> >\n+    class hash_set;\n \n   template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n     inline bool\n-    operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-\t       const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2);\n-\n-/**\n- *  This is an SGI extension.\n- *  @ingroup SGIextensions\n- *  @doctodo\n-*/\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-class hash_set\n-{\n-  // concept requirements\n-  __glibcxx_class_requires(_Value, _SGIAssignableConcept)\n-  __glibcxx_class_requires3(_HashFcn, size_t, _Value, _UnaryFunctionConcept)\n-  __glibcxx_class_requires3(_EqualKey, _Value, _Value, _BinaryPredicateConcept)\n-\n-private:\n-  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>,\n-                    _EqualKey, _Alloc> _Ht;\n-  _Ht _M_ht;\n-\n-public:\n-  typedef typename _Ht::key_type key_type;\n-  typedef typename _Ht::value_type value_type;\n-  typedef typename _Ht::hasher hasher;\n-  typedef typename _Ht::key_equal key_equal;\n-\n-  typedef typename _Ht::size_type size_type;\n-  typedef typename _Ht::difference_type difference_type;\n-  typedef typename _Alloc::pointer pointer;\n-  typedef typename _Alloc::const_pointer const_pointer;\n-  typedef typename _Alloc::reference reference;\n-  typedef typename _Alloc::const_reference const_reference;\n-\n-  typedef typename _Ht::const_iterator iterator;\n-  typedef typename _Ht::const_iterator const_iterator;\n-\n-  typedef typename _Ht::allocator_type allocator_type;\n-\n-  hasher hash_funct() const { return _M_ht.hash_funct(); }\n-  key_equal key_eq() const { return _M_ht.key_eq(); }\n-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n-\n-public:\n-  hash_set()\n-    : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n-  explicit hash_set(size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n-  hash_set(size_type __n, const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n-  hash_set(size_type __n, const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a) {}\n-\n-  template <class _InputIterator>\n-  hash_set(_InputIterator __f, _InputIterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n-           const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_unique(__f, __l); }\n-  template <class _InputIterator>\n-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n-           const hasher& __hf, const key_equal& __eql,\n-           const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_unique(__f, __l); }\n-\n-public:\n-  size_type size() const { return _M_ht.size(); }\n-  size_type max_size() const { return _M_ht.max_size(); }\n-  bool empty() const { return _M_ht.empty(); }\n-  void swap(hash_set& __hs) { _M_ht.swap(__hs._M_ht); }\n-\n-  template <class _Val, class _HF, class _EqK, class _Al>\n-  friend bool operator== (const hash_set<_Val, _HF, _EqK, _Al>&,\n-                          const hash_set<_Val, _HF, _EqK, _Al>&);\n-\n-  iterator begin() const { return _M_ht.begin(); }\n-  iterator end() const { return _M_ht.end(); }\n-\n-public:\n-  pair<iterator, bool> insert(const value_type& __obj)\n+    operator==(const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __hs1,\n+\t       const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __hs2);\n+\n+  /**\n+   *  This is an SGI extension.\n+   *  @ingroup SGIextensions\n+   *  @doctodo\n+   */\n+  template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n+    class hash_set\n     {\n-      pair<typename _Ht::iterator, bool> __p = _M_ht.insert_unique(__obj);\n-      return pair<iterator,bool>(__p.first, __p.second);\n-    }\n-  template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l)\n-    { _M_ht.insert_unique(__f,__l); }\n-  pair<iterator, bool> insert_noresize(const value_type& __obj)\n-  {\n-    pair<typename _Ht::iterator, bool> __p =\n-      _M_ht.insert_unique_noresize(__obj);\n-    return pair<iterator, bool>(__p.first, __p.second);\n-  }\n-\n-  iterator find(const key_type& __key) const { return _M_ht.find(__key); }\n-\n-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n-\n-  pair<iterator, iterator> equal_range(const key_type& __key) const\n-    { return _M_ht.equal_range(__key); }\n-\n-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n-  void erase(iterator __it) { _M_ht.erase(__it); }\n-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n-  void clear() { _M_ht.clear(); }\n-\n-public:\n-  void resize(size_type __hint) { _M_ht.resize(__hint); }\n-  size_type bucket_count() const { return _M_ht.bucket_count(); }\n-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type __n) const\n-    { return _M_ht.elems_in_bucket(__n); }\n-};\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool\n-operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2)\n-{\n-  return __hs1._M_ht == __hs2._M_ht;\n-}\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool\n-operator!=(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n-  return !(__hs1 == __hs2);\n-}\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline void\n-swap(hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-     hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)\n-{\n-  __hs1.swap(__hs2);\n-}\n-\n-\n-template <class _Value,\n-          class _HashFcn  = hash<_Value>,\n-          class _EqualKey = equal_to<_Value>,\n-          class _Alloc =  allocator<_Value> >\n-class hash_multiset;\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool\n-operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2);\n-\n-\n-/**\n- *  This is an SGI extension.\n- *  @ingroup SGIextensions\n- *  @doctodo\n-*/\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-class hash_multiset\n-{\n-  // concept requirements\n-  __glibcxx_class_requires(_Value, _SGIAssignableConcept)\n-  __glibcxx_class_requires3(_HashFcn, size_t, _Value, _UnaryFunctionConcept)\n-  __glibcxx_class_requires3(_EqualKey, _Value, _Value, _BinaryPredicateConcept)\n-\n-private:\n-  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>,\n-                    _EqualKey, _Alloc> _Ht;\n-  _Ht _M_ht;\n+      // concept requirements\n+      __glibcxx_class_requires(_Value, _SGIAssignableConcept)\n+      __glibcxx_class_requires3(_HashFcn, size_t, _Value, _UnaryFunctionConcept)\n+      __glibcxx_class_requires3(_EqualKey, _Value, _Value, _BinaryPredicateConcept)\n+\n+    private:\n+      typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>,\n+\t\t\t_EqualKey, _Alloc> _Ht;\n+      _Ht _M_ht;\n+\n+    public:\n+      typedef typename _Ht::key_type key_type;\n+      typedef typename _Ht::value_type value_type;\n+      typedef typename _Ht::hasher hasher;\n+      typedef typename _Ht::key_equal key_equal;\n+      \n+      typedef typename _Ht::size_type size_type;\n+      typedef typename _Ht::difference_type difference_type;\n+      typedef typename _Alloc::pointer pointer;\n+      typedef typename _Alloc::const_pointer const_pointer;\n+      typedef typename _Alloc::reference reference;\n+      typedef typename _Alloc::const_reference const_reference;\n+      \n+      typedef typename _Ht::const_iterator iterator;\n+      typedef typename _Ht::const_iterator const_iterator;\n+      \n+      typedef typename _Ht::allocator_type allocator_type;\n+      \n+      hasher\n+      hash_funct() const\n+      { return _M_ht.hash_funct(); }\n+\n+      key_equal\n+      key_eq() const\n+      { return _M_ht.key_eq(); }\n+\n+      allocator_type\n+      get_allocator() const\n+      { return _M_ht.get_allocator(); }\n+\n+    public:\n+      hash_set()\n+      : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n+\n+      explicit\n+      hash_set(size_type __n)\n+      : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n+\n+      hash_set(size_type __n, const hasher& __hf)\n+      : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n+\n+      hash_set(size_type __n, const hasher& __hf, const key_equal& __eql,\n+\t       const allocator_type& __a = allocator_type())\n+      : _M_ht(__n, __hf, __eql, __a) {}\n+\n+      template <class _InputIterator>\n+        hash_set(_InputIterator __f, _InputIterator __l)\n+\t: _M_ht(100, hasher(), key_equal(), allocator_type())\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_set(_InputIterator __f, _InputIterator __l, size_type __n)\n+\t: _M_ht(__n, hasher(), key_equal(), allocator_type())\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t const hasher& __hf)\n+\t: _M_ht(__n, __hf, key_equal(), allocator_type())\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t const hasher& __hf, const key_equal& __eql,\n+\t\t const allocator_type& __a = allocator_type())\n+\t: _M_ht(__n, __hf, __eql, __a)\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+    public:\n+      size_type\n+      size() const\n+      { return _M_ht.size(); }\n+\n+      size_type\n+      max_size() const\n+      { return _M_ht.max_size(); }\n+      \n+      bool\n+      empty() const\n+      { return _M_ht.empty(); }\n+      \n+      void\n+      swap(hash_set& __hs)\n+      { _M_ht.swap(__hs._M_ht); }\n+\n+      template <class _Val, class _HF, class _EqK, class _Al>\n+        friend bool\n+        operator==(const hash_set<_Val, _HF, _EqK, _Al>&,\n+\t\t   const hash_set<_Val, _HF, _EqK, _Al>&);\n+\n+      iterator\n+      begin() const\n+      { return _M_ht.begin(); }\n+      \n+      iterator\n+      end() const\n+      { return _M_ht.end(); }\n+\n+    public:\n+      pair<iterator, bool>\n+      insert(const value_type& __obj)\n+      {\n+\tpair<typename _Ht::iterator, bool> __p = _M_ht.insert_unique(__obj);\n+\treturn pair<iterator,bool>(__p.first, __p.second);\n+      }\n+\n+      template <class _InputIterator>\n+        void\n+        insert(_InputIterator __f, _InputIterator __l)\n+        { _M_ht.insert_unique(__f, __l); }\n+\n+      pair<iterator, bool>\n+      insert_noresize(const value_type& __obj)\n+      {\n+\tpair<typename _Ht::iterator, bool> __p\n+\t  = _M_ht.insert_unique_noresize(__obj);\n+\treturn pair<iterator, bool>(__p.first, __p.second);\n+      }\n+\n+      iterator\n+      find(const key_type& __key) const\n+      { return _M_ht.find(__key); }\n+\n+      size_type\n+      count(const key_type& __key) const\n+      { return _M_ht.count(__key); }\n+\n+      pair<iterator, iterator>\n+      equal_range(const key_type& __key) const\n+      { return _M_ht.equal_range(__key); }\n+\n+      size_type\n+      erase(const key_type& __key)\n+      {return _M_ht.erase(__key); }\n+      \n+      void\n+      erase(iterator __it)\n+      { _M_ht.erase(__it); }\n+      \n+      void\n+      erase(iterator __f, iterator __l)\n+      { _M_ht.erase(__f, __l); }\n+      \n+      void\n+      clear()\n+      { _M_ht.clear(); }\n \n public:\n-  typedef typename _Ht::key_type key_type;\n-  typedef typename _Ht::value_type value_type;\n-  typedef typename _Ht::hasher hasher;\n-  typedef typename _Ht::key_equal key_equal;\n-\n-  typedef typename _Ht::size_type size_type;\n-  typedef typename _Ht::difference_type difference_type;\n-  typedef typename _Alloc::pointer pointer;\n-  typedef typename _Alloc::const_pointer const_pointer;\n-  typedef typename _Alloc::reference reference;\n-  typedef typename _Alloc::const_reference const_reference;\n+      void\n+      resize(size_type __hint)\n+      { _M_ht.resize(__hint); }\n+      \n+      size_type\n+      bucket_count() const\n+      { return _M_ht.bucket_count(); }\n+      \n+      size_type\n+      max_bucket_count() const\n+      { return _M_ht.max_bucket_count(); }\n+      \n+      size_type\n+      elems_in_bucket(size_type __n) const\n+      { return _M_ht.elems_in_bucket(__n); }\n+    };\n \n-  typedef typename _Ht::const_iterator iterator;\n-  typedef typename _Ht::const_iterator const_iterator;\n-\n-  typedef typename _Ht::allocator_type allocator_type;\n-\n-  hasher hash_funct() const { return _M_ht.hash_funct(); }\n-  key_equal key_eq() const { return _M_ht.key_eq(); }\n-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }\n+  template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n+    inline bool\n+    operator==(const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __hs1,\n+\t       const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __hs2)\n+    { return __hs1._M_ht == __hs2._M_ht; }\n \n-public:\n-  hash_multiset()\n-    : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n-  explicit hash_multiset(size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n-  hash_multiset(size_type __n, const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n-  hash_multiset(size_type __n, const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a) {}\n-\n-  template <class _InputIterator>\n-  hash_multiset(_InputIterator __f, _InputIterator __l)\n-    : _M_ht(100, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n)\n-    : _M_ht(__n, hasher(), key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n-                const hasher& __hf)\n-    : _M_ht(__n, __hf, key_equal(), allocator_type())\n-    { _M_ht.insert_equal(__f, __l); }\n-  template <class _InputIterator>\n-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n-                const hasher& __hf, const key_equal& __eql,\n-                const allocator_type& __a = allocator_type())\n-    : _M_ht(__n, __hf, __eql, __a)\n-    { _M_ht.insert_equal(__f, __l); }\n+  template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n+    inline bool\n+    operator!=(const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __hs1,\n+\t       const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __hs2)\n+    { return !(__hs1 == __hs2); }\n+\n+  template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n+    inline void\n+    swap(hash_set<_Val, _HashFcn, _EqualKey, _Alloc>& __hs1,\n+\t hash_set<_Val, _HashFcn, _EqualKey, _Alloc>& __hs2)\n+    { __hs1.swap(__hs2); }\n+\n+  template <class _Value,\n+\t    class _HashFcn = hash<_Value>,\n+\t    class _EqualKey = equal_to<_Value>,\n+\t    class _Alloc = allocator<_Value> >\n+    class hash_multiset;\n \n-public:\n-  size_type size() const { return _M_ht.size(); }\n-  size_type max_size() const { return _M_ht.max_size(); }\n-  bool empty() const { return _M_ht.empty(); }\n-  void swap(hash_multiset& hs) { _M_ht.swap(hs._M_ht); }\n+  template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n+    inline bool\n+    operator==(const hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs1,\n+\t       const hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs2);\n \n-  template <class _Val, class _HF, class _EqK, class _Al>\n-  friend bool operator== (const hash_multiset<_Val, _HF, _EqK, _Al>&,\n-                          const hash_multiset<_Val, _HF, _EqK, _Al>&);\n \n-  iterator begin() const { return _M_ht.begin(); }\n-  iterator end() const { return _M_ht.end(); }\n+  /**\n+   *  This is an SGI extension.\n+   *  @ingroup SGIextensions\n+   *  @doctodo\n+   */\n+  template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n+    class hash_multiset\n+    {\n+      // concept requirements\n+      __glibcxx_class_requires(_Value, _SGIAssignableConcept)\n+      __glibcxx_class_requires3(_HashFcn, size_t, _Value, _UnaryFunctionConcept)\n+      __glibcxx_class_requires3(_EqualKey, _Value, _Value, _BinaryPredicateConcept)\n+\n+    private:\n+      typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>,\n+\t\t\t_EqualKey, _Alloc> _Ht;\n+      _Ht _M_ht;\n+\n+    public:\n+      typedef typename _Ht::key_type key_type;\n+      typedef typename _Ht::value_type value_type;\n+      typedef typename _Ht::hasher hasher;\n+      typedef typename _Ht::key_equal key_equal;\n+      \n+      typedef typename _Ht::size_type size_type;\n+      typedef typename _Ht::difference_type difference_type;\n+      typedef typename _Alloc::pointer pointer;\n+      typedef typename _Alloc::const_pointer const_pointer;\n+      typedef typename _Alloc::reference reference;\n+      typedef typename _Alloc::const_reference const_reference;\n+\n+      typedef typename _Ht::const_iterator iterator;\n+      typedef typename _Ht::const_iterator const_iterator;\n+      \n+      typedef typename _Ht::allocator_type allocator_type;\n+      \n+      hasher\n+      hash_funct() const\n+      { return _M_ht.hash_funct(); }\n+      \n+      key_equal\n+      key_eq() const\n+      { return _M_ht.key_eq(); }\n+      \n+      allocator_type\n+      get_allocator() const\n+      { return _M_ht.get_allocator(); }\n+\n+    public:\n+      hash_multiset()\n+      : _M_ht(100, hasher(), key_equal(), allocator_type()) {}\n+\n+      explicit\n+      hash_multiset(size_type __n)\n+      : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}\n+\n+      hash_multiset(size_type __n, const hasher& __hf)\n+      : _M_ht(__n, __hf, key_equal(), allocator_type()) {}\n+      \n+      hash_multiset(size_type __n, const hasher& __hf, const key_equal& __eql,\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _M_ht(__n, __hf, __eql, __a) {}\n+\n+      template <class _InputIterator>\n+        hash_multiset(_InputIterator __f, _InputIterator __l)\n+\t: _M_ht(100, hasher(), key_equal(), allocator_type())\n+        { _M_ht.insert_equal(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n)\n+\t: _M_ht(__n, hasher(), key_equal(), allocator_type())\n+        { _M_ht.insert_equal(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t      const hasher& __hf)\n+\t: _M_ht(__n, __hf, key_equal(), allocator_type())\n+        { _M_ht.insert_equal(__f, __l); }\n+\n+      template <class _InputIterator>\n+        hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t      const hasher& __hf, const key_equal& __eql,\n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _M_ht(__n, __hf, __eql, __a)\n+        { _M_ht.insert_equal(__f, __l); }\n+\n+    public:\n+      size_type\n+      size() const\n+      { return _M_ht.size(); }\n+\n+      size_type\n+      max_size() const\n+      { return _M_ht.max_size(); }\n+\n+      bool\n+      empty() const\n+      { return _M_ht.empty(); }\n+\n+      void\n+      swap(hash_multiset& hs)\n+      { _M_ht.swap(hs._M_ht); }\n+\n+      template <class _Val, class _HF, class _EqK, class _Al>\n+        friend bool\n+        operator==(const hash_multiset<_Val, _HF, _EqK, _Al>&,\n+\t\t   const hash_multiset<_Val, _HF, _EqK, _Al>&);\n+\n+      iterator\n+      begin() const\n+      { return _M_ht.begin(); }\n+      \n+      iterator\n+      end() const\n+      { return _M_ht.end(); }\n \n public:\n-  iterator insert(const value_type& __obj)\n-    { return _M_ht.insert_equal(__obj); }\n-  template <class _InputIterator>\n-  void insert(_InputIterator __f, _InputIterator __l)\n-    { _M_ht.insert_equal(__f,__l); }\n-  iterator insert_noresize(const value_type& __obj)\n-    { return _M_ht.insert_equal_noresize(__obj); }\n-\n-  iterator find(const key_type& __key) const { return _M_ht.find(__key); }\n-\n-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }\n+      iterator\n+      insert(const value_type& __obj)\n+      { return _M_ht.insert_equal(__obj); }\n+  \n+      template <class _InputIterator>\n+        void\n+        insert(_InputIterator __f, _InputIterator __l)\n+        { _M_ht.insert_equal(__f,__l); }\n+  \n+      iterator\n+      insert_noresize(const value_type& __obj)\n+      { return _M_ht.insert_equal_noresize(__obj); }\n+\n+      iterator\n+      find(const key_type& __key) const\n+      { return _M_ht.find(__key); }\n+\n+      size_type\n+      count(const key_type& __key) const\n+      { return _M_ht.count(__key); }\n+\n+      pair<iterator, iterator>\n+      equal_range(const key_type& __key) const\n+      { return _M_ht.equal_range(__key); }\n+\n+      size_type\n+      erase(const key_type& __key)\n+      { return _M_ht.erase(__key); }\n+  \n+      void\n+      erase(iterator __it)\n+      { _M_ht.erase(__it); }\n+  \n+      void\n+      erase(iterator __f, iterator __l)\n+      { _M_ht.erase(__f, __l); }\n+  \n+      void\n+      clear()\n+      { _M_ht.clear(); }\n+\n+    public:\n+      void\n+      resize(size_type __hint)\n+      { _M_ht.resize(__hint); }\n+  \n+      size_type\n+      bucket_count() const\n+      { return _M_ht.bucket_count(); }\n+\n+      size_type\n+      max_bucket_count() const\n+      { return _M_ht.max_bucket_count(); }\n+\n+      size_type\n+      elems_in_bucket(size_type __n) const\n+      { return _M_ht.elems_in_bucket(__n); }\n+    };\n+\n+  template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n+    inline bool\n+    operator==(const hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs1,\n+\t       const hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs2)\n+    { return __hs1._M_ht == __hs2._M_ht; }\n \n-  pair<iterator, iterator> equal_range(const key_type& __key) const\n-    { return _M_ht.equal_range(__key); }\n+  template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n+    inline bool\n+    operator!=(const hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs1,\n+\t       const hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs2)\n+    { return !(__hs1 == __hs2); }\n \n-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }\n-  void erase(iterator __it) { _M_ht.erase(__it); }\n-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }\n-  void clear() { _M_ht.clear(); }\n-\n-public:\n-  void resize(size_type __hint) { _M_ht.resize(__hint); }\n-  size_type bucket_count() const { return _M_ht.bucket_count(); }\n-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }\n-  size_type elems_in_bucket(size_type __n) const\n-    { return _M_ht.elems_in_bucket(__n); }\n-};\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool\n-operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)\n-{\n-  return __hs1._M_ht == __hs2._M_ht;\n-}\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline bool\n-operator!=(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n-  return !(__hs1 == __hs2);\n-}\n-\n-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n-inline void\n-swap(hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n-     hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {\n-  __hs1.swap(__hs2);\n-}\n+  template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>\n+    inline void\n+    swap(hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs1,\n+\t hash_multiset<_Val, _HashFcn, _EqualKey, _Alloc>& __hs2)\n+    { __hs1.swap(__hs2); }\n \n } // namespace __gnu_cxx\n \n namespace std\n {\n-// Specialization of insert_iterator so that it will work for hash_set\n-// and hash_multiset.\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-class insert_iterator<__gnu_cxx::hash_set<_Value, _HashFcn, _EqualKey, _Alloc> > {\n-protected:\n-  typedef __gnu_cxx::hash_set<_Value, _HashFcn, _EqualKey, _Alloc> _Container;\n-  _Container* container;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x) : container(&__x) {}\n-  insert_iterator(_Container& __x, typename _Container::iterator)\n-    : container(&__x) {}\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) {\n-    container->insert(__value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n-\n-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n-class insert_iterator<__gnu_cxx::hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc> > {\n-protected:\n-  typedef __gnu_cxx::hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc> _Container;\n-  _Container* container;\n-  typename _Container::iterator iter;\n-public:\n-  typedef _Container          container_type;\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-\n-  insert_iterator(_Container& __x) : container(&__x) {}\n-  insert_iterator(_Container& __x, typename _Container::iterator)\n-    : container(&__x) {}\n-  insert_iterator<_Container>&\n-  operator=(const typename _Container::value_type& __value) {\n-    container->insert(__value);\n-    return *this;\n-  }\n-  insert_iterator<_Container>& operator*() { return *this; }\n-  insert_iterator<_Container>& operator++() { return *this; }\n-  insert_iterator<_Container>& operator++(int) { return *this; }\n-};\n-} // namespace std\n+  // Specialization of insert_iterator so that it will work for hash_set\n+  // and hash_multiset.\n+\n+  template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n+    class insert_iterator<__gnu_cxx::hash_set<_Value, _HashFcn,\n+\t\t\t\t\t      _EqualKey, _Alloc> >\n+    {\n+    protected:\n+      typedef __gnu_cxx::hash_set<_Value, _HashFcn, _EqualKey, _Alloc>\n+        _Container;\n+      _Container* container;\n+\n+    public:\n+      typedef _Container          container_type;\n+      typedef output_iterator_tag iterator_category;\n+      typedef void                value_type;\n+      typedef void                difference_type;\n+      typedef void                pointer;\n+      typedef void                reference;\n+\n+      insert_iterator(_Container& __x)\n+      : container(&__x) {}\n+      \n+      insert_iterator(_Container& __x, typename _Container::iterator)\n+      : container(&__x) {}\n+\n+      insert_iterator<_Container>&\n+      operator=(const typename _Container::value_type& __value)\n+      {\n+\tcontainer->insert(__value);\n+\treturn *this;\n+      }\n+\n+      insert_iterator<_Container>&\n+      operator*()\n+      { return *this; }\n+      \n+      insert_iterator<_Container>&\n+      operator++()\n+      { return *this; }\n+      \n+      insert_iterator<_Container>&\n+      operator++(int)\n+      { return *this; }\n+    };\n \n+  template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n+    class insert_iterator<__gnu_cxx::hash_multiset<_Value, _HashFcn,\n+\t\t\t\t\t\t   _EqualKey, _Alloc> >\n+    {\n+    protected:\n+      typedef __gnu_cxx::hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>\n+        _Container;\n+      _Container* container;\n+      typename _Container::iterator iter;\n+\n+    public:\n+      typedef _Container          container_type;\n+      typedef output_iterator_tag iterator_category;\n+      typedef void                value_type;\n+      typedef void                difference_type;\n+      typedef void                pointer;\n+      typedef void                reference;\n+      \n+      insert_iterator(_Container& __x)\n+      : container(&__x) {}\n+      \n+      insert_iterator(_Container& __x, typename _Container::iterator)\n+      : container(&__x) {}\n+\n+      insert_iterator<_Container>&\n+      operator=(const typename _Container::value_type& __value)\n+      {\n+\tcontainer->insert(__value);\n+\treturn *this;\n+      }\n+\n+      insert_iterator<_Container>&\n+      operator*()\n+      { return *this; }\n+\n+      insert_iterator<_Container>&\n+      operator++()\n+      { return *this; }\n+\n+      insert_iterator<_Container>&\n+      operator++(int) { return *this; }\n+    };\n+} // namespace std\n #endif"}, {"sha": "adb15ce29921e8070f22050098c20cc3b5b2218e", "filename": "libstdc++-v3/include/ext/memory", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmemory?ref=d962e073a077fe4066b937412d0f6d435f2f4f92", "patch": "@@ -1,6 +1,6 @@\n // Memory extensions -*- C++ -*-\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -82,7 +82,7 @@ namespace __gnu_cxx\n       _ForwardIter __cur = __result;\n       try\n \t{\n-\t  for ( ; __count > 0 ; --__count, ++__first, ++__cur)\n+\t  for (; __count > 0 ; --__count, ++__first, ++__cur)\n \t    std::_Construct(&*__cur, *__first);\n \t  return pair<_InputIter, _ForwardIter>(__first, __cur);\n \t}\n@@ -100,19 +100,16 @@ namespace __gnu_cxx\n \t\t\t   std::random_access_iterator_tag)\n     {\n       _RandomAccessIter __last = __first + __count;\n-      return pair<_RandomAccessIter, _ForwardIter>(\n-\t\t     __last,\n-\t\t     std::uninitialized_copy(__first, __last, __result));\n+      return (pair<_RandomAccessIter, _ForwardIter>\n+\t      (__last, std::uninitialized_copy(__first, __last, __result)));\n     }\n \n   template<typename _InputIter, typename _Size, typename _ForwardIter>\n     inline pair<_InputIter, _ForwardIter>\n     __uninitialized_copy_n(_InputIter __first, _Size __count,\n \t\t\t _ForwardIter __result)\n-    {\n-      return __uninitialized_copy_n(__first, __count, __result,\n-\t\t\t\t    __iterator_category(__first));\n-    }\n+    { return __uninitialized_copy_n(__first, __count, __result,\n+\t\t\t\t    __iterator_category(__first)); }\n \n   /**\n    *  @brief Copies the range [first,last) into result.\n@@ -128,11 +125,8 @@ namespace __gnu_cxx\n     inline pair<_InputIter, _ForwardIter>\n     uninitialized_copy_n(_InputIter __first, _Size __count,\n \t\t\t _ForwardIter __result)\n-    {\n-      return __uninitialized_copy_n(__first, __count, __result,\n-\t\t\t\t    __iterator_category(__first));\n-    }\n-\n+    { return __uninitialized_copy_n(__first, __count, __result,\n+\t\t\t\t    __iterator_category(__first)); }\n \n   /**\n    *  This class provides similar behavior and semantics of the standard\n@@ -155,16 +149,16 @@ namespace __gnu_cxx\n    *  @ingroup SGIextensions\n   */\n   template <class _ForwardIterator, class _Tp\n-\t      = typename std::iterator_traits<_ForwardIterator>::value_type >\n-  struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>\n-  {\n-    /// Requests storage large enough to hold a copy of [first,last).\n-    temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)\n-    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) { }\n-\n-    /// Destroys objects and frees storage.\n-    ~temporary_buffer() { }\n-  };\n+\t    = typename std::iterator_traits<_ForwardIterator>::value_type >\n+    struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>\n+    {\n+      /// Requests storage large enough to hold a copy of [first,last).\n+      temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)\n+      : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) { }\n+      \n+      /// Destroys objects and frees storage.\n+      ~temporary_buffer() { }\n+    };\n } // namespace __gnu_cxx\n \n #endif"}, {"sha": "8879be4d2efbdd9505a9117d25aa61b2ab9b944c", "filename": "libstdc++-v3/include/ext/numeric", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d962e073a077fe4066b937412d0f6d435f2f4f92/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnumeric?ref=d962e073a077fe4066b937412d0f6d435f2f4f92", "patch": "@@ -1,6 +1,6 @@\n // Numeric extensions -*- C++ -*-\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -79,22 +79,25 @@ namespace __gnu_cxx\n     {\n       if (__n == 0)\n \treturn identity_element(__monoid_op);\n-      else {\n-\twhile ((__n & 1) == 0) {\n+      else\n+\t{\n+\t  while ((__n & 1) == 0)\n+\t    {\n+\t      __n >>= 1;\n+\t      __x = __monoid_op(__x, __x);\n+\t    }\n+\n+\t  _Tp __result = __x;\n \t  __n >>= 1;\n-\t  __x = __monoid_op(__x, __x);\n+\t  while (__n != 0)\n+\t    {\n+\t      __x = __monoid_op(__x, __x);\n+\t      if ((__n & 1) != 0)\n+\t\t__result = __monoid_op(__result, __x);\n+\t      __n >>= 1;\n+\t    }\n+\t  return __result;\n \t}\n-\n-\t_Tp __result = __x;\n-\t__n >>= 1;\n-\twhile (__n != 0) {\n-\t  __x = __monoid_op(__x, __x);\n-\t  if ((__n & 1) != 0)\n-\t    __result = __monoid_op(__result, __x);\n-\t  __n >>= 1;\n-\t}\n-\treturn __result;\n-      }\n     }\n \n   template<typename _Tp, typename _Integer>"}]}