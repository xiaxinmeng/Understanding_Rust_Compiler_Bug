{"sha": "6a96fcb4958d449901e87d75d08b4e8eede54e1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE5NmZjYjQ5NThkNDQ5OTAxZTg3ZDc1ZDA4YjRlOGVlZGU1NGUxYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T15:55:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T15:55:06Z"}, "message": "(fold, case PLUS_EXPR, MINUS_EXPR): Apply distributive law to multiplication.\n\n(fold, case *_DIV_EXPR): Replace code to handle (A*C1)/C2 with more general\ncode to handle addition as well.\n(fold, case *_MOD_EXPR): Add simplified version of above code.\n\nFrom-SVN: r4757", "tree": {"sha": "88e7590ac3c9554b358cc0c8203a6c406c4972e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88e7590ac3c9554b358cc0c8203a6c406c4972e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a96fcb4958d449901e87d75d08b4e8eede54e1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a96fcb4958d449901e87d75d08b4e8eede54e1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a96fcb4958d449901e87d75d08b4e8eede54e1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a96fcb4958d449901e87d75d08b4e8eede54e1b/comments", "author": null, "committer": null, "parents": [{"sha": "f62f398a28629937d937cae5bbc43e2d1e76e967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62f398a28629937d937cae5bbc43e2d1e76e967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62f398a28629937d937cae5bbc43e2d1e76e967"}], "stats": {"total": 158, "additions": 122, "deletions": 36}, "files": [{"sha": "bc584356f64484d1f17955910d4fbb62d6694257", "filename": "gcc/fold-const.c", "status": "modified", "additions": 122, "deletions": 36, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a96fcb4958d449901e87d75d08b4e8eede54e1b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a96fcb4958d449901e87d75d08b4e8eede54e1b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6a96fcb4958d449901e87d75d08b4e8eede54e1b", "patch": "@@ -3496,6 +3496,19 @@ fold (expr)\n \t      code = BIT_IOR_EXPR;\n \t      goto bit_ior;\n \t    }\n+\n+\t  /* (A * C) + (B * C) -> (A+B) * C.  Since we are most concerned\n+\t     about the case where C is a constant, just try one of the\n+\t     four possibilities.  */\n+\n+\t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR\n+\t      && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t  TREE_OPERAND (arg1, 1), 0))\n+\t    return fold (build (MULT_EXPR, type,\n+\t\t\t\tfold (build (PLUS_EXPR, type,\n+\t\t\t\t\t     TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t     TREE_OPERAND (arg1, 0))),\n+\t\t\t\tTREE_OPERAND (arg0, 1)));\n \t}\n       /* In IEEE floating point, x+0 may not equal x.  */\n       else if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n@@ -3622,6 +3635,19 @@ fold (expr)\n \t    return build1 (NEGATE_EXPR, type, arg1);\n \t  if (integer_zerop (arg1))\n \t    return non_lvalue (convert (type, arg0));\n+\n+\t  /* (A * C) - (B * C) -> (A-B) * C.  Since we are most concerned\n+\t     about the case where C is a constant, just try one of the\n+\t     four possibilities.  */\n+\n+\t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR\n+\t      && operand_equal_p (TREE_OPERAND (arg0, 1),\n+\t\t\t\t  TREE_OPERAND (arg1, 1), 0))\n+\t    return fold (build (MULT_EXPR, type,\n+\t\t\t\tfold (build (MINUS_EXPR, type,\n+\t\t\t\t\t     TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t     TREE_OPERAND (arg1, 0))),\n+\t\t\t\tTREE_OPERAND (arg0, 1)));\n \t}\n       /* Convert A - (-B) to A + B.  */\n       else if (TREE_CODE (arg1) == NEGATE_EXPR)\n@@ -3778,46 +3804,73 @@ fold (expr)\n       if (integer_zerop (arg1))\n \treturn t;\n \n-      /* If we have ((a * C1) / C2) and C1 % C2 == 0, we can replace this with\n-\t (a * (C1/C2).  Also look for when we have a SAVE_EXPR in\n-\t between.  */\n+      /* Look for ((a * C1) / C3) or (((a * C1) + C2) / C3),\n+\t where C1 % C3 == 0 or C3 % C1 == 0.  We can simplify these\n+\t expressions, which often appear in the offsets or sizes of\n+\t objects with a varying size.  Only deal with positive divisors\n+\t and multiplicands. \n+\n+\t Look for NOPs and SAVE_EXPRs inside.  */\n+\n       if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_INT_CST_LOW (arg1) > 0 && TREE_INT_CST_HIGH (arg1) == 0\n-\t  && TREE_CODE (arg0) == MULT_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)) > 0\n-\t  && TREE_INT_CST_HIGH (TREE_OPERAND (arg0, 1)) == 0\n-\t  && 0 == (TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1))\n-\t\t   % TREE_INT_CST_LOW (arg1)))\n+\t  && tree_int_cst_lt (integer_zero_node, arg1))\n \t{\n-\t  tree new_op\n-\t    = build_int_2 (TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1))\n-\t\t\t   / TREE_INT_CST_LOW (arg1), 0);\n+\t  int have_save_expr = 0;\n+\t  tree c2 = integer_zero_node;\n+\t  tree xarg0 = arg0;\n \n-\t  TREE_TYPE (new_op) = type;\n-\t  return build (MULT_EXPR, type, TREE_OPERAND (arg0, 0), new_op);\n-\t}\n+\t  if (TREE_CODE (xarg0) == SAVE_EXPR)\n+\t    have_save_expr = 1, xarg0 = TREE_OPERAND (xarg0, 0);\n \n-      else if (TREE_CODE (arg1) == INTEGER_CST\n-\t       && TREE_INT_CST_LOW (arg1) > 0 && TREE_INT_CST_HIGH (arg1) == 0\n-\t       && TREE_CODE (arg0) == SAVE_EXPR\n-\t       && TREE_CODE (TREE_OPERAND (arg0, 0)) == MULT_EXPR\n-\t       && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1))\n-\t\t   == INTEGER_CST)\n-\t       && (TREE_INT_CST_LOW (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1))\n-\t\t   > 0)\n-\t       && (TREE_INT_CST_HIGH (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1))\n-\t\t   == 0)\n-\t       && (TREE_INT_CST_LOW (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1))\n-\t\t   % TREE_INT_CST_LOW (arg1)) == 0)\n-\t{\n-\t  tree new_op\n-\t    = build_int_2 (TREE_INT_CST_LOW (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1))\n-\t\t\t   / TREE_INT_CST_LOW (arg1), 0);\n-\t  \n-\t  TREE_TYPE (new_op) = type;\n-\t  return build (MULT_EXPR, type,\n-\t\t\tTREE_OPERAND (TREE_OPERAND (arg0, 0), 0), new_op);\n+\t  STRIP_NOPS (xarg0);\n+\n+\t  if (TREE_CODE (xarg0) == PLUS_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n+\t    c2 = TREE_OPERAND (xarg0, 1), xarg0 = TREE_OPERAND (xarg0, 0);\n+\t  else if (TREE_CODE (xarg0) == MINUS_EXPR\n+\t\t   && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n+\t    {\n+\t      c2 = fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (xarg0, 1)));\n+\t      xarg0 = TREE_OPERAND (xarg0, 0);\n+\t    }\n+\n+\t  if (TREE_CODE (xarg0) == SAVE_EXPR)\n+\t    have_save_expr = 1, xarg0 = TREE_OPERAND (xarg0, 0);\n+\n+\t  STRIP_NOPS (xarg0);\n+\n+\t  if (TREE_CODE (xarg0) == MULT_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n+\t      && tree_int_cst_lt (integer_zero_node, TREE_OPERAND (xarg0, 1))\n+\t      && (integer_zerop (const_binop (TRUNC_MOD_EXPR,\n+\t\t\t\t\t      TREE_OPERAND (xarg0, 1), arg1, 1))\n+\t\t  || integer_zerop (const_binop (TRUNC_MOD_EXPR, arg1,\n+\t\t\t\t\t\t TREE_OPERAND (xarg0, 1), 1))))\n+\t    {\n+\t      tree outer_div = integer_one_node;\n+\t      tree c1 = TREE_OPERAND (xarg0, 1);\n+\t      tree c3 = arg1;\n+\n+\t      /* If C3 > C1, set them equal and do a divide by\n+\t\t C3/C1 at the end of the operation.  */\n+\t      if (tree_int_cst_lt (c1, c3))\n+\t\touter_div = const_binop (code, c3, c1, 0), c3 = c1;\n+\t\t\n+\t      /* The result is A * (C1/C3) + (C2/C3).  */\n+\t      t = fold (build (PLUS_EXPR, type,\n+\t\t\t       fold (build (MULT_EXPR, type,\n+\t\t\t\t\t    TREE_OPERAND (xarg0, 0),\n+\t\t\t\t\t    const_binop (code, c1, c3, 1))),\n+\t\t\t       const_binop (code, c2, c3, 1)));\n+\n+\t      if (! integer_onep (outer_div))\n+\t\tt = fold (build (code, type, t, outer_div));\n+\n+\t      if (have_save_expr)\n+\t\tt = save_expr (t);\n+\n+\t      return t;\n+\t    }\n \t}\n \n #if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n@@ -3838,6 +3891,39 @@ fold (expr)\n \treturn omit_one_operand (type, integer_zero_node, arg0);\n       if (integer_zerop (arg1))\n \treturn t;\n+\n+      /* Look for ((a * C1) % C3) or (((a * C1) + C2) % C3),\n+\t where C1 % C3 == 0.  Handle similarly to the division case,\n+\t but don't bother with SAVE_EXPRs.  */\n+\n+      if (TREE_CODE (arg1) == INTEGER_CST\n+\t  && ! integer_zerop (arg1))\n+\t{\n+\t  tree c2 = integer_zero_node;\n+\t  tree xarg0 = arg0;\n+\n+\t  if (TREE_CODE (xarg0) == PLUS_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n+\t    c2 = TREE_OPERAND (xarg0, 1), xarg0 = TREE_OPERAND (xarg0, 0);\n+\t  else if (TREE_CODE (xarg0) == MINUS_EXPR\n+\t\t   && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST)\n+\t    {\n+\t      c2 = fold (build1 (NEGATE_EXPR, type, TREE_OPERAND (xarg0, 1)));\n+\t      xarg0 = TREE_OPERAND (xarg0, 0);\n+\t    }\n+\n+\t  STRIP_NOPS (xarg0);\n+\n+\t  if (TREE_CODE (xarg0) == MULT_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (xarg0, 1)) == INTEGER_CST\n+\t      && integer_zerop (const_binop (TRUNC_MOD_EXPR,\n+\t\t\t\t\t     TREE_OPERAND (xarg0, 1),\n+\t\t\t\t\t     arg1, 1)))\n+\t    /* The result is (C2%C3).  */\n+\t    return omit_one_operand (type, const_binop (code, c2, arg1, 1),\n+\t\t\t\t     TREE_OPERAND (xarg0, 0));\n+\t}\n+\n       goto binary;\n \n     case LSHIFT_EXPR:"}]}