{"sha": "44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ2NjJmNjgxZThiZTZiM2I3ZWFmY2VjNGFmYTBlY2I4Y2M1ODdjZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-09-28T21:20:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-09-28T21:20:53Z"}, "message": "calls.c (expand_call): Try to do a tail call for thunks at -O0 too.\n\n\t* calls.c (expand_call): Try to do a tail call for thunks at -O0 too.\n\t* cgraph.h (struct cgraph_thunk_info): Add indirect_offset.\n\t(cgraph_node::create_thunk): Add indirect_offset parameter.\n\t(thunk_adjust): Likewise.\n\t* cgraph.c (cgraph_node::create_thunk): Add indirect_offset parameter\n\tand initialize the corresponding field with it.\n\t(cgraph_node::dump): Dump indirect_offset field.\n\t* cgraphclones.c (duplicate_thunk_for_node): Deal with indirect_offset.\n\t* cgraphunit.c (cgraph_node::analyze): Be prepared for external thunks.\n\t(thunk_adjust): Add indirect_offset parameter and deal with it.\n\t(cgraph_node::expand_thunk): Deal with the indirect_offset field and\n\tpass it to thunk_adjust.  Do not call the target hook if it's non-zero\n\tor if the thunk is external or local.  Fix formatting.  Do not chain\n\tthe RESULT_DECL to BLOCK_VARS.  Pass the static chain to the target,\n\tif any, in the GIMPLE representation.\n\t* ipa-icf.c (sem_function::equals_wpa): Deal with indirect_offset.\n\t* lto-cgraph.c (lto_output_node): Write indirect_offset field.\n\t(input_node): Read indirect_offset field.\n\t* tree-inline.c (expand_call_inline): Pass indirect_offset field in the\n\tcall to thunk_adjust.\n\t* tree-nested.c (struct nesting_info): Add thunk_p field.\n\t(create_nesting_tree): Set it.\n\t(convert_all_function_calls): Copy static chain from targets to thunks.\n\t(finalize_nesting_tree_1): Return early for thunks.\n\t(unnest_nesting_tree_1): Do not finalize thunks.\n\t(gimplify_all_functions): Do not gimplify thunks.\ncp/\n\t* method.c (use_thunk): Adjust call to cgraph_node::create_thunk.\nada/\n\t* gcc-interface/decl.c (is_cplusplus_method): Do not require C++\n\tconvention on Interfaces.\n\t* gcc-interface/trans.c (Subprogram_Body_to_gnu): Try to create a\n\tbona-fide thunk and hand it over to the middle-end.\n\t(get_controlling_type): New function.\n\t(use_alias_for_thunk_p): Likewise.\n\t(thunk_labelno): New static variable.\n\t(make_covariant_thunk): New function.\n\t(maybe_make_gnu_thunk): Likewise.\n\t* gcc-interface/utils.c (finish_subprog_decl): Set DECL_CONTEXT of the\n\tresult DECL here instead of...\n\t(end_subprog_body): ...here.\n\nCo-Authored-By: Pierre-Marie de Rodat <derodat@adacore.com>\n\nFrom-SVN: r264701", "tree": {"sha": "1c0470d4d2c3d3ea333d09879f17a86087934d93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c0470d4d2c3d3ea333d09879f17a86087934d93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/comments", "author": null, "committer": null, "parents": [{"sha": "5c441345a343d0ef90e5ac9ef95039030ecef1ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c441345a343d0ef90e5ac9ef95039030ecef1ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c441345a343d0ef90e5ac9ef95039030ecef1ee"}], "stats": {"total": 490, "additions": 441, "deletions": 49}, "files": [{"sha": "96baa7d48e2f8c154f0b9f8830759ff0afc5fb42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -1,3 +1,33 @@\n+2018-09-28  Eric Botcazou  <ebotcazou@adacore.com>\n+            Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* calls.c (expand_call): Try to do a tail call for thunks at -O0 too.\n+\t* cgraph.h (struct cgraph_thunk_info): Add indirect_offset.\n+\t(cgraph_node::create_thunk): Add indirect_offset parameter.\n+\t(thunk_adjust): Likewise.\n+\t* cgraph.c (cgraph_node::create_thunk): Add indirect_offset parameter\n+\tand initialize the corresponding field with it.\n+\t(cgraph_node::dump): Dump indirect_offset field.\n+\t* cgraphclones.c (duplicate_thunk_for_node): Deal with indirect_offset.\n+\t* cgraphunit.c (cgraph_node::analyze): Be prepared for external thunks.\n+\t(thunk_adjust): Add indirect_offset parameter and deal with it.\n+\t(cgraph_node::expand_thunk): Deal with the indirect_offset field and\n+\tpass it to thunk_adjust.  Do not call the target hook if it's non-zero\n+\tor if the thunk is external or local.  Fix formatting.  Do not chain\n+\tthe RESULT_DECL to BLOCK_VARS.  Pass the static chain to the target,\n+\tif any, in the GIMPLE representation.\n+\t* ipa-icf.c (sem_function::equals_wpa): Deal with indirect_offset.\n+\t* lto-cgraph.c (lto_output_node): Write indirect_offset field.\n+\t(input_node): Read indirect_offset field.\n+\t* tree-inline.c (expand_call_inline): Pass indirect_offset field in the\n+\tcall to thunk_adjust.\n+\t* tree-nested.c (struct nesting_info): Add thunk_p field.\n+\t(create_nesting_tree): Set it.\n+\t(convert_all_function_calls): Copy static chain from targets to thunks.\n+\t(finalize_nesting_tree_1): Return early for thunks.\n+\t(unnest_nesting_tree_1): Do not finalize thunks.\n+\t(gimplify_all_functions): Do not gimplify thunks.\n+\n 2018-09-28  David Malcolm  <dmalcolm@redhat.com>\n \n \t* opt-suggestions.c (option_proposer::build_option_suggestions):"}, {"sha": "c18c4c8852eb5a5c8d9940d0ea2728a0eb2c81f7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -1,3 +1,19 @@\n+2018-09-28  Eric Botcazou  <ebotcazou@adacore.com>\n+            Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/decl.c (is_cplusplus_method): Do not require C++\n+\tconvention on Interfaces.\n+\t* gcc-interface/trans.c (Subprogram_Body_to_gnu): Try to create a\n+\tbona-fide thunk and hand it over to the middle-end.\n+\t(get_controlling_type): New function.\n+\t(use_alias_for_thunk_p): Likewise.\n+\t(thunk_labelno): New static variable.\n+\t(make_covariant_thunk): New function.\n+\t(maybe_make_gnu_thunk): Likewise.\n+\t* gcc-interface/utils.c (finish_subprog_decl): Set DECL_CONTEXT of the\n+\tresult DECL here instead of...\n+\t(end_subprog_body): ...here.\n+\n 2018-09-27  Martin Sebor  <msebor@redhat.com>\n \n \t* gcc-interface/utils.c (make_packable_type): Introduce a temporary"}, {"sha": "4a1845a33b6d48730b90a4b658c8d311334b03be", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -4851,15 +4851,15 @@ is_cplusplus_method (Entity_Id gnat_entity)\n   if (Convention (gnat_entity) != Convention_CPP)\n     return false;\n \n-  /* And that the type of the first parameter (indirectly) has it too.  */\n+  /* And that the type of the first parameter (indirectly) has it too, but\n+     we make an exception for Interfaces because they need not be imported.  */\n   Entity_Id gnat_first = First_Formal (gnat_entity);\n   if (No (gnat_first))\n     return false;\n-\n   Entity_Id gnat_type = Etype (gnat_first);\n   if (Is_Access_Type (gnat_type))\n     gnat_type = Directly_Designated_Type (gnat_type);\n-  if (Convention (gnat_type) != Convention_CPP)\n+  if (Convention (gnat_type) != Convention_CPP && !Is_Interface (gnat_type))\n     return false;\n \n   /* This is the main case: a C++ virtual method imported as a primitive"}, {"sha": "53513e538f14b2498bd96fb17916a797381d075d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -247,6 +247,7 @@ static bool set_end_locus_from_node (tree, Node_Id);\n static int lvalue_required_p (Node_Id, tree, bool, bool);\n static tree build_raise_check (int, enum exception_info_kind);\n static tree create_init_temporary (const char *, tree, tree *, Node_Id);\n+static bool maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk);\n \n /* Hooks for debug info back-ends, only supported and used in a restricted set\n    of configurations.  */\n@@ -3791,6 +3792,11 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   if (Was_Expression_Function (gnat_node))\n     DECL_DISREGARD_INLINE_LIMITS (gnu_subprog_decl) = 1;\n \n+  /* Try to create a bona-fide thunk and hand it over to the middle-end.  */\n+  if (Is_Thunk (gnat_subprog_id)\n+      && maybe_make_gnu_thunk (gnat_subprog_id, gnu_subprog_decl))\n+    return;\n+\n   /* Initialize the information structure for the function.  */\n   allocate_struct_function (gnu_subprog_decl, false);\n   gnu_subprog_language = ggc_cleared_alloc<language_function> ();\n@@ -10333,6 +10339,242 @@ get_elaboration_procedure (void)\n   return gnu_elab_proc_stack->last ();\n }\n \n+/* Return the controlling type of a dispatching subprogram.  */\n+\n+static Entity_Id\n+get_controlling_type (Entity_Id subprog)\n+{\n+  /* This is modelled on Expand_Interface_Thunk.  */\n+  Entity_Id controlling_type = Etype (First_Formal (subprog));\n+  if (Is_Access_Type (controlling_type))\n+    controlling_type = Directly_Designated_Type (controlling_type);\n+  controlling_type = Underlying_Type (controlling_type);\n+  if (Is_Concurrent_Type (controlling_type))\n+    controlling_type = Corresponding_Record_Type (controlling_type);\n+  controlling_type = Base_Type (controlling_type);\n+  return controlling_type;\n+}\n+\n+/* Return whether we should use an alias for the TARGET of a thunk\n+   in order to make the call generated in the thunk local.  */\n+\n+static bool\n+use_alias_for_thunk_p (tree target)\n+{\n+  /* We cannot generate a local call in this case.  */\n+  if (DECL_EXTERNAL (target))\n+    return false;\n+\n+  /* The call is already local in this case.  */\n+  if (TREE_CODE (DECL_CONTEXT (target)) == FUNCTION_DECL)\n+    return false;\n+\n+  return TARGET_USE_LOCAL_THUNK_ALIAS_P (target);\n+}\n+\n+static GTY(()) unsigned long thunk_labelno = 0;\n+\n+/* Create an alias for TARGET to be used as the target of a thunk.  */\n+\n+static tree\n+make_alias_for_thunk (tree target)\n+{\n+  char buf[64];\n+  targetm.asm_out.generate_internal_label (buf, \"LTHUNK\", thunk_labelno++);\n+\n+  tree alias = build_decl (DECL_SOURCE_LOCATION (target), TREE_CODE (target),\n+\t\t\t   get_identifier (buf), TREE_TYPE (target));\n+\n+  DECL_LANG_SPECIFIC (alias) = DECL_LANG_SPECIFIC (target);\n+  DECL_CONTEXT (alias) = DECL_CONTEXT (target);\n+  TREE_READONLY (alias) = TREE_READONLY (target);\n+  TREE_THIS_VOLATILE (alias) = TREE_THIS_VOLATILE (target);\n+  DECL_ARTIFICIAL (alias) = 1;\n+  DECL_INITIAL (alias) = error_mark_node;\n+  DECL_ARGUMENTS (alias) = copy_list (DECL_ARGUMENTS (target));\n+  TREE_ADDRESSABLE (alias) = 1;\n+  SET_DECL_ASSEMBLER_NAME (alias, DECL_NAME (alias));\n+\n+  cgraph_node *n = cgraph_node::create_same_body_alias (alias, target);\n+  gcc_assert (n);\n+\n+  return alias;\n+}\n+\n+/* Create the covariant part of the {GNAT,GNU}_THUNK.  */\n+\n+static tree\n+make_covariant_thunk (Entity_Id gnat_thunk, tree gnu_thunk)\n+{\n+  tree gnu_name = create_concat_name (gnat_thunk, \"CV\");\n+  tree gnu_cv_thunk\n+    = build_decl (DECL_SOURCE_LOCATION (gnu_thunk), TREE_CODE (gnu_thunk),\n+\t\t  gnu_name, TREE_TYPE (gnu_thunk));\n+\n+  DECL_ARGUMENTS (gnu_cv_thunk) = copy_list (DECL_ARGUMENTS (gnu_thunk));\n+  DECL_RESULT (gnu_cv_thunk) = copy_node (DECL_RESULT (gnu_thunk));\n+  DECL_CONTEXT (DECL_RESULT (gnu_cv_thunk)) = gnu_cv_thunk;\n+\n+  DECL_LANG_SPECIFIC (gnu_cv_thunk) = DECL_LANG_SPECIFIC (gnu_thunk);\n+  DECL_CONTEXT (gnu_cv_thunk) = DECL_CONTEXT (gnu_thunk);\n+  TREE_READONLY (gnu_cv_thunk) = TREE_READONLY (gnu_thunk);\n+  TREE_THIS_VOLATILE (gnu_cv_thunk) = TREE_THIS_VOLATILE (gnu_thunk);\n+  TREE_PUBLIC (gnu_cv_thunk) = TREE_PUBLIC (gnu_thunk);\n+  DECL_ARTIFICIAL (gnu_cv_thunk) = 1;\n+\n+  return gnu_cv_thunk;\n+}\n+\n+/* Try to create a GNU thunk for {GNAT,GNU}_THUNK and return true on success.\n+\n+   GNU thunks are more efficient than GNAT thunks because they don't call into\n+   the runtime to retrieve the offset used in the displacement operation, but\n+   they are tailored to C++ and thus too limited to support the full range of\n+   thunks generated in Ada.  Here's the complete list of limitations:\n+\n+     1. Multi-controlling thunks, i.e thunks with more than one controlling\n+\tparameter, are simply not supported.\n+\n+     2. Covariant thunks, i.e. thunks for which the result is also controlling,\n+\tare split into a pair of (this, covariant-only) thunks.\n+\n+     3. Variable-offset thunks, i.e. thunks for which the offset depends on the\n+\tobject and not only on its type, are supported as 2nd class citizens.\n+\n+     4. External thunks, i.e. thunks for which the target is not declared in\n+\tthe same unit as the thunk, are supported as 2nd class citizens.\n+\n+     5. Local thunks, i.e. thunks generated for a local type, are supported as\n+\t2nd class citizens.  */\n+\n+static bool\n+maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk)\n+{\n+  const Entity_Id gnat_target = Thunk_Entity (gnat_thunk);\n+\n+  /* Check that the first formal of the target is the only controlling one.  */\n+  Entity_Id gnat_formal = First_Formal (gnat_target);\n+  if (!Is_Controlling_Formal (gnat_formal))\n+    return false;\n+  for (gnat_formal = Next_Formal (gnat_formal);\n+       Present (gnat_formal);\n+       gnat_formal = Next_Formal (gnat_formal))\n+    if (Is_Controlling_Formal (gnat_formal))\n+      return false;\n+\n+  /* Look for the types that control the target and the thunk.  */\n+  const Entity_Id gnat_controlling_type = get_controlling_type (gnat_target);\n+  const Entity_Id gnat_interface_type = get_controlling_type (gnat_thunk);\n+\n+  /* Now compute whether the former covers the latter.  */\n+  const Entity_Id gnat_interface_tag\n+    = Is_Interface (gnat_interface_type)\n+      ? Find_Interface_Tag (gnat_controlling_type, gnat_interface_type)\n+      : Empty;\n+  tree gnu_interface_tag\n+    = Present (gnat_interface_tag)\n+      ? gnat_to_gnu_field_decl (gnat_interface_tag)\n+      : NULL_TREE;\n+  tree gnu_interface_offset\n+    = gnu_interface_tag ? byte_position (gnu_interface_tag) : NULL_TREE;\n+\n+  /* There are three ways to retrieve the offset between the interface view\n+     and the base object.  Either the controlling type covers the interface\n+     type and the offset of the corresponding tag is fixed, in which case it\n+     can be statically encoded in the thunk (see FIXED_OFFSET below).  Or the\n+     controlling type doesn't cover the interface type but is of fixed size,\n+     in which case the offset is stored in the dispatch table, two pointers\n+     above the dispatch table address (see VIRTUAL_VALUE below).  Otherwise,\n+     the offset is variable and is stored right after the tag in every object\n+     (see INDIRECT_OFFSET below).  See also a-tags.ads for more details.  */\n+  HOST_WIDE_INT fixed_offset, virtual_value, indirect_offset;\n+  tree virtual_offset;\n+\n+  if (gnu_interface_offset && TREE_CODE (gnu_interface_offset) == INTEGER_CST)\n+    {\n+      fixed_offset = - tree_to_shwi (gnu_interface_offset);\n+      virtual_value = 0;\n+      virtual_offset = NULL_TREE;\n+      indirect_offset = 0;\n+    }\n+  else if (!gnu_interface_offset\n+\t   && !Is_Variable_Size_Record (gnat_controlling_type))\n+    {\n+      fixed_offset = 0;\n+      virtual_value = - 2 * (HOST_WIDE_INT) (POINTER_SIZE / BITS_PER_UNIT);\n+      virtual_offset = build_int_cst (integer_type_node, virtual_value);\n+      indirect_offset = 0;\n+    }\n+  else\n+    {\n+      /* Covariant thunks with variable offset are not supported.  */\n+      if (Has_Controlling_Result (gnat_target))\n+\treturn false;\n+\n+      fixed_offset = 0;\n+      virtual_value = 0;\n+      virtual_offset = NULL_TREE;\n+      indirect_offset = (HOST_WIDE_INT) (POINTER_SIZE / BITS_PER_UNIT);\n+    }\n+\n+  tree gnu_target = gnat_to_gnu_entity (gnat_target, NULL_TREE, false);\n+\n+  /* Thunk and target must have the same nesting level, if any.  */\n+  gcc_assert (DECL_CONTEXT (gnu_thunk) == DECL_CONTEXT (gnu_target));\n+\n+  /* If the target returns by invisible reference and is external, apply the\n+     same transformation as Subprogram_Body_to_gnu here.  */\n+  if (TREE_ADDRESSABLE (TREE_TYPE (gnu_target))\n+      && DECL_EXTERNAL (gnu_target)\n+      && !POINTER_TYPE_P (TREE_TYPE (DECL_RESULT (gnu_target))))\n+    {\n+      TREE_TYPE (DECL_RESULT (gnu_target))\n+\t= build_reference_type (TREE_TYPE (DECL_RESULT (gnu_target)));\n+      relayout_decl (DECL_RESULT (gnu_target));\n+    }\n+\n+  /* The thunk expander requires the return types of thunk and target to be\n+     compatible, which is not fully the case with the CICO mechanism.  */\n+  if (TYPE_CI_CO_LIST (TREE_TYPE (gnu_thunk)))\n+    {\n+      tree gnu_target_type = TREE_TYPE (gnu_target);\n+      gcc_assert (TYPE_CI_CO_LIST (gnu_target_type));\n+      TYPE_CANONICAL (TREE_TYPE (TREE_TYPE (gnu_thunk)))\n+\t= TYPE_CANONICAL (TREE_TYPE (gnu_target_type));\n+    }\n+\n+  cgraph_node *target_node = cgraph_node::get_create (gnu_target);\n+\n+  /* If the return type of the target is a controlling type, then we need\n+     both an usual this thunk and a covariant thunk in this order:\n+\n+       this thunk  -->  covariant thunk  -->  target\n+\n+     For covariant thunks, we can only handle a fixed offset.  */\n+  if (Has_Controlling_Result (gnat_target))\n+    {\n+      gcc_assert (fixed_offset < 0);\n+      tree gnu_cv_thunk = make_covariant_thunk (gnat_thunk, gnu_thunk);\n+      target_node->create_thunk (gnu_cv_thunk, gnu_target, false,\n+\t\t\t\t - fixed_offset, 0, 0,\n+\t\t\t\t NULL_TREE, gnu_target);\n+\n+      gnu_target = gnu_cv_thunk;\n+    }\n+\n+  /* We may also need to create an alias for the target in order to make\n+     the call local, depending on the linkage of the target.  */\n+  tree gnu_alias = use_alias_for_thunk_p (gnu_target)\n+\t\t  ? make_alias_for_thunk (gnu_target)\n+\t\t  : gnu_target;\n+\n+  target_node->create_thunk (gnu_thunk, gnu_target, true,\n+\t\t\t     fixed_offset, virtual_value, indirect_offset,\n+\t\t\t     virtual_offset, gnu_alias);\n+\n+  return true;\n+}\n+\n /* Initialize the table that maps GNAT codes to GCC codes for simple\n    binary and unary operations.  */\n "}, {"sha": "1ce2f7259270741466678d8aaea195fa557e124f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -3294,6 +3294,7 @@ finish_subprog_decl (tree decl, tree asm_name, tree type)\n \n   DECL_ARTIFICIAL (result_decl) = 1;\n   DECL_IGNORED_P (result_decl) = 1;\n+  DECL_CONTEXT (result_decl) = decl;\n   DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (type);\n   DECL_RESULT (decl) = result_decl;\n \n@@ -3369,9 +3370,6 @@ end_subprog_body (tree body)\n   DECL_INITIAL (fndecl) = current_binding_level->block;\n   gnat_poplevel ();\n \n-  /* Mark the RESULT_DECL as being in this subprogram. */\n-  DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n-\n   /* The body should be a BIND_EXPR whose BLOCK is the top-level one.  */\n   if (TREE_CODE (body) == BIND_EXPR)\n     {"}, {"sha": "80af5c3b3b3309637da270b571721e6d567b5c51", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -3610,9 +3610,8 @@ expand_call (tree exp, rtx target, int ignore)\n      pushed these optimizations into -O2.  Don't try if we're already\n      expanding a call, as that means we're an argument.  Don't try if\n      there's cleanups, as we know there's code to follow the call.  */\n-\n   if (currently_expanding_call++ != 0\n-      || !flag_optimize_sibling_calls\n+      || (!flag_optimize_sibling_calls && !CALL_FROM_THUNK_P (exp))\n       || args_size.var\n       || dbg_cnt (tail_call) == false)\n     try_tail_call = 0;"}, {"sha": "8a03f3d6828d088e8e5649e0eac2fcf237a3b59b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -617,6 +617,7 @@ cgraph_node *\n cgraph_node::create_thunk (tree alias, tree, bool this_adjusting,\n \t\t\t   HOST_WIDE_INT fixed_offset,\n \t\t\t   HOST_WIDE_INT virtual_value,\n+\t\t\t   HOST_WIDE_INT indirect_offset,\n \t\t\t   tree virtual_offset,\n \t\t\t   tree real_alias)\n {\n@@ -635,6 +636,7 @@ cgraph_node::create_thunk (tree alias, tree, bool this_adjusting,\n \n   node->thunk.fixed_offset = fixed_offset;\n   node->thunk.virtual_value = virtual_value;\n+  node->thunk.indirect_offset = indirect_offset;\n   node->thunk.alias = real_alias;\n   node->thunk.this_adjusting = this_adjusting;\n   node->thunk.virtual_offset_p = virtual_offset != NULL;\n@@ -2099,10 +2101,11 @@ cgraph_node::dump (FILE *f)\n         fprintf (f, \"  of %s (asm: %s)\",\n \t\t lang_hooks.decl_printable_name (thunk.alias, 2),\n \t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (thunk.alias)));\n-      fprintf (f, \" fixed offset %i virtual value %i has \"\n-\t       \"virtual offset %i)\\n\",\n+      fprintf (f, \" fixed offset %i virtual value %i indirect_offset %i \"\n+\t\t  \"has virtual offset %i\\n\",\n \t       (int)thunk.fixed_offset,\n \t       (int)thunk.virtual_value,\n+\t       (int)thunk.indirect_offset,\n \t       (int)thunk.virtual_offset_p);\n     }\n   if (alias && thunk.alias"}, {"sha": "71c54537b932d4aef4f226303e90a9edeb700a55", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -666,6 +666,10 @@ struct GTY(()) cgraph_thunk_info {\n      VIRTUAL_OFFSET_P is true.  */\n   HOST_WIDE_INT virtual_value;\n \n+  /* Offset from \"this\" to get the offset to adjust \"this\".  Zero means: this\n+     offset is to be ignored.  */\n+  HOST_WIDE_INT indirect_offset;\n+\n   /* Thunk target, i.e. the method that this thunk wraps.  Depending on the\n      TARGET_USE_LOCAL_THUNK_ALIAS_P macro, this may have to be a new alias.  */\n   tree alias;\n@@ -1033,6 +1037,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   cgraph_node * create_thunk (tree alias, tree, bool this_adjusting,\n \t\t\t      HOST_WIDE_INT fixed_offset,\n \t\t\t      HOST_WIDE_INT virtual_value,\n+\t\t\t      HOST_WIDE_INT indirect_offset,\n \t\t\t      tree virtual_offset,\n \t\t\t      tree real_alias);\n \n@@ -2373,7 +2378,8 @@ void cgraphunit_c_finalize (void);\n     IN_SSA is true if the gimple is in SSA.  */\n basic_block init_lowered_empty_function (tree, bool, profile_count);\n \n-tree thunk_adjust (gimple_stmt_iterator *, tree, bool, HOST_WIDE_INT, tree);\n+tree thunk_adjust (gimple_stmt_iterator *, tree, bool, HOST_WIDE_INT, tree,\n+\t\t   HOST_WIDE_INT);\n /* In cgraphclones.c  */\n \n tree clone_function_name_1 (const char *, const char *);"}, {"sha": "2af45bd4fecfa5ee5e59faa845d6b1a7bfb10e59", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -274,10 +274,11 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   cgraph_edge *cs;\n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (cs->caller->thunk.thunk_p\n-\t&& cs->caller->thunk.this_adjusting == thunk->thunk.this_adjusting\n \t&& cs->caller->thunk.fixed_offset == thunk->thunk.fixed_offset\n-\t&& cs->caller->thunk.virtual_offset_p == thunk->thunk.virtual_offset_p\n-\t&& cs->caller->thunk.virtual_value == thunk->thunk.virtual_value)\n+\t&& cs->caller->thunk.virtual_value == thunk->thunk.virtual_value\n+\t&& cs->caller->thunk.indirect_offset == thunk->thunk.indirect_offset\n+\t&& cs->caller->thunk.this_adjusting == thunk->thunk.this_adjusting\n+\t&& cs->caller->thunk.virtual_offset_p == thunk->thunk.virtual_offset_p)\n       return cs->caller;\n \n   tree new_decl;"}, {"sha": "c0baaeaefa4ee2a5699e3e402c6d74ff5118e51f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 90, "deletions": 28, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -623,20 +623,18 @@ cgraph_node::analyze (void)\n       callees->can_throw_external = !TREE_NOTHROW (t->decl);\n       /* Target code in expand_thunk may need the thunk's target\n \t to be analyzed, so recurse here.  */\n-      if (!t->analyzed)\n+      if (!t->analyzed && t->definition)\n \tt->analyze ();\n       if (t->alias)\n \t{\n \t  t = t->get_alias_target ();\n-\t  if (!t->analyzed)\n+\t  if (!t->analyzed && t->definition)\n \t    t->analyze ();\n \t}\n-      if (!expand_thunk (false, false))\n-\t{\n-\t  thunk.alias = NULL;\n-\t  return;\n-\t}\n+      bool ret = expand_thunk (false, false);\n       thunk.alias = NULL;\n+      if (!ret)\n+\treturn;\n     }\n   if (alias)\n     resolve_alias (cgraph_node::get (alias_target), transparent_alias);\n@@ -1609,15 +1607,16 @@ init_lowered_empty_function (tree decl, bool in_ssa, profile_count count)\n   return bb;\n }\n \n-/* Adjust PTR by the constant FIXED_OFFSET, and by the vtable\n-   offset indicated by VIRTUAL_OFFSET, if that is\n-   non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and\n-   zero for a result adjusting thunk.  */\n+/* Adjust PTR by the constant FIXED_OFFSET, by the vtable offset indicated by\n+   VIRTUAL_OFFSET, and by the indirect offset indicated by INDIRECT_OFFSET, if\n+   it is non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and zero\n+   for a result adjusting thunk.  */\n \n tree\n thunk_adjust (gimple_stmt_iterator * bsi,\n \t      tree ptr, bool this_adjusting,\n-\t      HOST_WIDE_INT fixed_offset, tree virtual_offset)\n+\t      HOST_WIDE_INT fixed_offset, tree virtual_offset,\n+\t      HOST_WIDE_INT indirect_offset)\n {\n   gassign *stmt;\n   tree ret;\n@@ -1632,6 +1631,16 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n       gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n     }\n \n+  if (!vtable_entry_type && (virtual_offset || indirect_offset != 0))\n+    {\n+      tree vfunc_type = make_node (FUNCTION_TYPE);\n+      TREE_TYPE (vfunc_type) = integer_type_node;\n+      TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n+      layout_type (vfunc_type);\n+\n+      vtable_entry_type = build_pointer_type (vfunc_type);\n+    }\n+\n   /* If there's a virtual offset, look up that value in the vtable and\n      adjust the pointer again.  */\n   if (virtual_offset)\n@@ -1640,16 +1649,6 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n       tree vtabletmp2;\n       tree vtabletmp3;\n \n-      if (!vtable_entry_type)\n-\t{\n-\t  tree vfunc_type = make_node (FUNCTION_TYPE);\n-\t  TREE_TYPE (vfunc_type) = integer_type_node;\n-\t  TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n-\t  layout_type (vfunc_type);\n-\n-\t  vtable_entry_type = build_pointer_type (vfunc_type);\n-\t}\n-\n       vtabletmp =\n \tcreate_tmp_reg (build_pointer_type\n \t\t\t  (build_pointer_type (vtable_entry_type)), \"vptr\");\n@@ -1687,6 +1686,41 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n \t\t\t\t      GSI_CONTINUE_LINKING);\n     }\n \n+  /* Likewise for an offset that is stored in the object that contains the\n+     vtable.  */\n+  if (indirect_offset != 0)\n+    {\n+      tree offset_ptr, offset_tree;\n+\n+      /* Get the address of the offset.  */\n+      offset_ptr\n+        = create_tmp_reg (build_pointer_type\n+\t\t\t  (build_pointer_type (vtable_entry_type)),\n+\t\t\t  \"offset_ptr\");\n+      stmt = gimple_build_assign (offset_ptr,\n+\t\t\t\t  build1 (NOP_EXPR, TREE_TYPE (offset_ptr),\n+\t\t\t\t\t  ptr));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      stmt = gimple_build_assign\n+\t     (offset_ptr,\n+\t      fold_build_pointer_plus_hwi_loc (input_location, offset_ptr,\n+\t\t\t\t\t       indirect_offset));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Get the offset itself.  */\n+      offset_tree = create_tmp_reg (TREE_TYPE (TREE_TYPE (offset_ptr)),\n+\t\t\t\t    \"offset\");\n+      stmt = gimple_build_assign (offset_tree,\n+\t\t\t\t  build_simple_mem_ref (offset_ptr));\n+      gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n+\n+      /* Adjust the `this' pointer.  */\n+      ptr = fold_build_pointer_plus_loc (input_location, ptr, offset_tree);\n+      ptr = force_gimple_operand_gsi (bsi, ptr, true, NULL_TREE, false,\n+\t\t\t\t      GSI_CONTINUE_LINKING);\n+    }\n+\n   if (!this_adjusting\n       && fixed_offset != 0)\n     /* Adjust the pointer by the constant.  */\n@@ -1725,6 +1759,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n   bool this_adjusting = thunk.this_adjusting;\n   HOST_WIDE_INT fixed_offset = thunk.fixed_offset;\n   HOST_WIDE_INT virtual_value = thunk.virtual_value;\n+  HOST_WIDE_INT indirect_offset = thunk.indirect_offset;\n   tree virtual_offset = NULL;\n   tree alias = callees->callee->decl;\n   tree thunk_fndecl = decl;\n@@ -1735,7 +1770,11 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n   if (thunk.add_pointer_bounds_args)\n     return false;\n \n-  if (!force_gimple_thunk && this_adjusting\n+  if (!force_gimple_thunk\n+      && this_adjusting\n+      && indirect_offset == 0\n+      && !DECL_EXTERNAL (alias)\n+      && !DECL_STATIC_CHAIN (alias)\n       && targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n \t\t\t\t\t      virtual_value, alias))\n     {\n@@ -1838,8 +1877,8 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t  resdecl = build_decl (input_location, RESULT_DECL, 0, restype);\n \t  DECL_ARTIFICIAL (resdecl) = 1;\n \t  DECL_IGNORED_P (resdecl) = 1;\n+\t  DECL_CONTEXT (resdecl) = thunk_fndecl;\n \t  DECL_RESULT (thunk_fndecl) = resdecl;\n-          DECL_CONTEXT (DECL_RESULT (thunk_fndecl)) = thunk_fndecl;\n \t}\n       else\n \tresdecl = DECL_RESULT (thunk_fndecl);\n@@ -1876,8 +1915,11 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t  restmp = resdecl;\n \n \t\t  if (VAR_P (restmp))\n-\t\t    add_local_decl (cfun, restmp);\n-\t\t  BLOCK_VARS (DECL_INITIAL (current_function_decl)) = restmp;\n+\t\t    {\n+\t\t      add_local_decl (cfun, restmp);\n+\t\t      BLOCK_VARS (DECL_INITIAL (current_function_decl))\n+\t\t\t= restmp;\n+\t\t    }\n \t\t}\n \t      else\n \t\trestmp = create_tmp_var (restype, \"retval\");\n@@ -1894,7 +1936,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n       if (this_adjusting)\n \t{\n \t  vargs.quick_push (thunk_adjust (&bsi, a, 1, fixed_offset,\n-\t\t\t\t\t  virtual_offset));\n+\t\t\t\t\t  virtual_offset, indirect_offset));\n \t  arg = DECL_CHAIN (a);\n \t  i = 1;\n \t}\n@@ -1919,6 +1961,25 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n       call = gimple_build_call_vec (build_fold_addr_expr_loc (0, alias), vargs);\n       callees->call_stmt = call;\n       gimple_call_set_from_thunk (call, true);\n+      if (DECL_STATIC_CHAIN (alias))\n+\t{\n+\t  tree p = DECL_STRUCT_FUNCTION (alias)->static_chain_decl;\n+\t  tree type = TREE_TYPE (p);\n+\t  tree decl = build_decl (DECL_SOURCE_LOCATION (thunk_fndecl),\n+\t\t\t\t  PARM_DECL, create_tmp_var_name (\"CHAIN\"),\n+\t\t\t\t  type);\n+\t  DECL_ARTIFICIAL (decl) = 1;\n+\t  DECL_IGNORED_P (decl) = 1;\n+\t  TREE_USED (decl) = 1;\n+\t  DECL_CONTEXT (decl) = thunk_fndecl;\n+\t  DECL_ARG_TYPE (decl) = type;\n+\t  TREE_READONLY (decl) = 1;\n+\n+\t  struct function *sf = DECL_STRUCT_FUNCTION (thunk_fndecl);\n+\t  sf->static_chain_decl = decl;\n+\n+\t  gimple_call_set_chain (call, decl);\n+\t}\n \n       /* Return slot optimization is always possible and in fact requred to\n          return values with DECL_BY_REFERENCE.  */\n@@ -1979,7 +2040,8 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t\t}\n \n \t      restmp = thunk_adjust (&bsi, restmp, /*this_adjusting=*/0,\n-\t\t\t\t     fixed_offset, virtual_offset);\n+\t\t\t\t     fixed_offset, virtual_offset,\n+\t\t\t\t     indirect_offset);\n \t      if (true_label)\n \t\t{\n \t\t  gimple *stmt;"}, {"sha": "e10ada2d7b67eaa0d4bb59c41a3cd137e3db46a6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -1,3 +1,8 @@\n+2018-09-28  Eric Botcazou  <ebotcazou@adacore.com>\n+            Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* method.c (use_thunk): Adjust call to cgraph_node::create_thunk.\n+\n 2018-09-28  Richard Biener  <rguenther@suse.de>\n \n \t* error.c (cp_print_error_function): Simplify by eliding"}, {"sha": "2de2d105224b4fe60b67faaf1c48fceb3454e325", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -375,7 +375,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   gcc_checking_assert (funcn);\n   thunk_node = funcn->create_thunk (thunk_fndecl, function,\n \t\t\t\t    this_adjusting, fixed_offset, virtual_value,\n-\t\t\t\t    virtual_offset, alias);\n+\t\t\t\t    0, virtual_offset, alias);\n   if (DECL_ONE_ONLY (function))\n     thunk_node->add_to_same_comdat_group (funcn);\n "}, {"sha": "3c54f8d4b6d42112eea434311e7fecca5a320d3e", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -593,6 +593,8 @@ sem_function::equals_wpa (sem_item *item,\n         return return_false_with_msg (\"thunk fixed_offset mismatch\");\n       if (cnode->thunk.virtual_value != cnode2->thunk.virtual_value)\n         return return_false_with_msg (\"thunk virtual_value mismatch\");\n+      if (cnode->thunk.indirect_offset != cnode2->thunk.indirect_offset)\n+        return return_false_with_msg (\"thunk indirect_offset mismatch\");\n       if (cnode->thunk.this_adjusting != cnode2->thunk.this_adjusting)\n         return return_false_with_msg (\"thunk this_adjusting mismatch\");\n       if (cnode->thunk.virtual_offset_p != cnode2->thunk.virtual_offset_p)"}, {"sha": "99998cc3c754c1fd3720213271c93808d2affeb0", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -556,6 +556,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t  + (node->thunk.add_pointer_bounds_args != 0) * 8);\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.fixed_offset);\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n+      streamer_write_uhwi_stream (ob->main_stream, node->thunk.indirect_offset);\n     }\n   streamer_write_hwi_stream (ob->main_stream, node->profile_id);\n   if (DECL_STATIC_CONSTRUCTOR (node->decl))\n@@ -1271,10 +1272,12 @@ input_node (struct lto_file_decl_data *file_data,\n       int type = streamer_read_uhwi (ib);\n       HOST_WIDE_INT fixed_offset = streamer_read_uhwi (ib);\n       HOST_WIDE_INT virtual_value = streamer_read_uhwi (ib);\n+      HOST_WIDE_INT indirect_offset = streamer_read_uhwi (ib);\n \n       node->thunk.fixed_offset = fixed_offset;\n-      node->thunk.this_adjusting = (type & 2);\n       node->thunk.virtual_value = virtual_value;\n+      node->thunk.indirect_offset = indirect_offset;\n+      node->thunk.this_adjusting = (type & 2);\n       node->thunk.virtual_offset_p = (type & 4);\n       node->thunk.add_pointer_bounds_args = (type & 8);\n     }"}, {"sha": "2eac7b7cc4ae45971d3f2ba39ab7a784e941cb2d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -4473,7 +4473,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n \t\t\t GSI_NEW_STMT);\n       gcc_assert (id->src_node->thunk.this_adjusting);\n       op = thunk_adjust (&iter, op, 1, id->src_node->thunk.fixed_offset,\n-\t\t\t virtual_offset);\n+\t\t\t virtual_offset, id->src_node->thunk.indirect_offset);\n \n       gimple_call_set_arg (stmt, 0, op);\n       gimple_call_set_fndecl (stmt, edge->callee->decl);"}, {"sha": "4579b4c58390a78f70ff07cd33383f8ff609052e", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44662f681e8be6b3b7eafcec4afa0ecb8cc587cd/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=44662f681e8be6b3b7eafcec4afa0ecb8cc587cd", "patch": "@@ -104,6 +104,7 @@ struct nesting_info\n   tree chain_decl;\n   tree nl_goto_field;\n \n+  bool thunk_p;\n   bool any_parm_remapped;\n   bool any_tramp_created;\n   bool any_descr_created;\n@@ -834,6 +835,7 @@ create_nesting_tree (struct cgraph_node *cgn)\n   info->mem_refs = new hash_set<tree *>;\n   info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n   info->context = cgn->decl;\n+  info->thunk_p = cgn->thunk.thunk_p;\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n     {\n@@ -2786,6 +2788,8 @@ convert_all_function_calls (struct nesting_info *root)\n      within the debugger.  */\n   FOR_EACH_NEST_INFO (n, root)\n     {\n+      if (n->thunk_p)\n+\tcontinue;\n       tree decl = n->context;\n       if (!optimize)\n \t{\n@@ -2806,6 +2810,14 @@ convert_all_function_calls (struct nesting_info *root)\n       chain_count += DECL_STATIC_CHAIN (decl);\n     }\n \n+  FOR_EACH_NEST_INFO (n, root)\n+    if (n->thunk_p)\n+      {\n+\ttree decl = n->context;\n+\ttree alias = cgraph_node::get (decl)->thunk.alias;\n+\tDECL_STATIC_CHAIN (decl) = DECL_STATIC_CHAIN (alias);\n+      }\n+\n   /* Walk the functions and perform transformations.  Note that these\n      transformations can induce new uses of the static chain, which in turn\n      require re-examining all users of the decl.  */\n@@ -2825,12 +2837,22 @@ convert_all_function_calls (struct nesting_info *root)\n \n       FOR_EACH_NEST_INFO (n, root)\n \t{\n+\t  if (n->thunk_p)\n+\t    continue;\n \t  tree decl = n->context;\n \t  walk_function (convert_tramp_reference_stmt,\n \t\t\t convert_tramp_reference_op, n);\n \t  walk_function (convert_gimple_call, NULL, n);\n \t  chain_count += DECL_STATIC_CHAIN (decl);\n \t}\n+\n+      FOR_EACH_NEST_INFO (n, root)\n+\tif (n->thunk_p)\n+\t  {\n+\t    tree decl = n->context;\n+\t    tree alias = cgraph_node::get (decl)->thunk.alias;\n+\t    DECL_STATIC_CHAIN (decl) = DECL_STATIC_CHAIN (alias);\n+\t  }\n     }\n   while (chain_count != old_chain_count);\n \n@@ -3055,12 +3077,13 @@ build_init_call_stmt (struct nesting_info *info, tree decl, tree field,\n static void\n finalize_nesting_tree_1 (struct nesting_info *root)\n {\n-  gimple_seq stmt_list;\n+  gimple_seq stmt_list = NULL;\n   gimple *stmt;\n   tree context = root->context;\n   struct function *sf;\n \n-  stmt_list = NULL;\n+  if (root->thunk_p)\n+    return;\n \n   /* If we created a non-local frame type or decl, we need to lay them\n      out at this time.  */\n@@ -3340,7 +3363,8 @@ unnest_nesting_tree_1 (struct nesting_info *root)\n   if (node->origin)\n     {\n        node->unnest ();\n-       cgraph_node::finalize_function (root->context, true);\n+       if (!root->thunk_p)\n+\t cgraph_node::finalize_function (root->context, true);\n     }\n }\n \n@@ -3380,7 +3404,8 @@ gimplify_all_functions (struct cgraph_node *root)\n   if (!gimple_body (root->decl))\n     gimplify_function_tree (root->decl);\n   for (iter = root->nested; iter; iter = iter->next_nested)\n-    gimplify_all_functions (iter);\n+    if (!iter->thunk.thunk_p)\n+      gimplify_all_functions (iter);\n }\n \n /* Main entry point for this pass.  Process FNDECL and all of its nested"}]}