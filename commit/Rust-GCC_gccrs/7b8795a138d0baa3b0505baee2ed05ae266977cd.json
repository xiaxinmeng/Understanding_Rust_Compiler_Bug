{"sha": "7b8795a138d0baa3b0505baee2ed05ae266977cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I4Nzk1YTEzOGQwYmFhM2IwNTA1YmFlZTJlZDA1YWUyNjY5NzdjZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-07-01T18:33:36Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-07-01T18:33:36Z"}, "message": "PR middle-end/90923 - hash_map destroys elements without constructing them\n\ngcc/ChangeLog:\n\n\tPR middle-end/90923\n\t* hash-map.h (hash_map::put): On insertion invoke element ctor.\n\t(hash_map::get_or_insert): Same.  Reformat comment.\n\t* hash-set.h (hash_set::add): On insertion invoke element ctor.\n\t* hash-map-tests.c (test_map_of_type_with_ctor_and_dtor): New.\n \t* hash-set-tests.c (test_map_of_type_with_ctor_and_dtor): New.\n\t* hash-table.h (hash_table::operator=): Prevent copy assignment.\n\t (hash_table::hash_table (const hash_table&)): Use copy ctor\n\t instead of assignment to copy elements.\n\nFrom-SVN: r272893", "tree": {"sha": "74e86b5944db91f0d3068ed61906a8a389b0cf42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74e86b5944db91f0d3068ed61906a8a389b0cf42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b8795a138d0baa3b0505baee2ed05ae266977cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b8795a138d0baa3b0505baee2ed05ae266977cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b8795a138d0baa3b0505baee2ed05ae266977cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b8795a138d0baa3b0505baee2ed05ae266977cd/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25cd9afbc1dc6bd9d4afccab3f09f0fbc811291a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25cd9afbc1dc6bd9d4afccab3f09f0fbc811291a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25cd9afbc1dc6bd9d4afccab3f09f0fbc811291a"}], "stats": {"total": 363, "additions": 349, "deletions": 14}, "files": [{"sha": "a3bad8c42119bf579105c50306bdd1dd27ac4ce6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b8795a138d0baa3b0505baee2ed05ae266977cd", "patch": "@@ -1,3 +1,15 @@\n+2019-07-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/90923\n+\t* hash-map.h (hash_map::put): On insertion invoke element ctor.\n+\t(hash_map::get_or_insert): Same.  Reformat comment.\n+\t* hash-set.h (hash_set::add): On insertion invoke element ctor.\n+\t* hash-map-tests.c (test_map_of_type_with_ctor_and_dtor): New.\n+ \t* hash-set-tests.c (test_map_of_type_with_ctor_and_dtor): New.\n+\t* hash-table.h (hash_table::operator=): Prevent copy assignment.\n+\t (hash_table::hash_table (const hash_table&)): Use copy ctor\n+\t instead of assignment to copy elements.\n+\n 2019-07-01  Wilco Dijkstra  <wdijkstr@arm.com>\n \t    John David Anglin  <danglin@gcc.gnu.org>\n "}, {"sha": "5888f259b2077ce3e0c47db40c25ee6b53671edf", "filename": "gcc/hash-map-tests.c", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-map-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-map-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map-tests.c?ref=7b8795a138d0baa3b0505baee2ed05ae266977cd", "patch": "@@ -103,12 +103,146 @@ test_map_of_strings_to_int ()\n   ASSERT_EQ (1, string_map.elements ());\n }\n \n+typedef struct hash_map_test_val_t\n+{\n+  static int ndefault;\n+  static int ncopy;\n+  static int nassign;\n+  static int ndtor;\n+\n+  hash_map_test_val_t ()\n+    : ptr (&ptr)\n+  {\n+    ++ndefault;\n+  }\n+\n+  hash_map_test_val_t (const hash_map_test_val_t &)\n+    : ptr (&ptr)\n+  {\n+    ++ncopy;\n+  }\n+\n+  hash_map_test_val_t& operator= (const hash_map_test_val_t &)\n+    {\n+     ++nassign;\n+     return *this;\n+    }\n+\n+  ~hash_map_test_val_t ()\n+    {\n+     gcc_assert (ptr == &ptr);\n+     ++ndtor;\n+    }\n+\n+  void *ptr;\n+} val_t;\n+\n+int val_t::ndefault;\n+int val_t::ncopy;\n+int val_t::nassign;\n+int val_t::ndtor;\n+\n+static void\n+test_map_of_type_with_ctor_and_dtor ()\n+{\n+  typedef hash_map <void *, val_t> Map;\n+\n+  {\n+    /* Test default ctor.  */\n+    Map m;\n+    (void)&m;\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault == 0);\n+  ASSERT_TRUE (val_t::ncopy == 0);\n+  ASSERT_TRUE (val_t::nassign == 0);\n+  ASSERT_TRUE (val_t::ndtor == 0);\n+\n+  {\n+    /* Test single insertion.  */\n+    Map m;\n+    void *p = &p;\n+    m.get_or_insert (p);\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n+\n+  {\n+    /* Test copy ctor.  */\n+    Map m1;\n+    void *p = &p;\n+    val_t &rv1 = m1.get_or_insert (p);\n+\n+    int ncopy = val_t::ncopy;\n+    int nassign = val_t::nassign;\n+\n+    Map m2 (m1);\n+    val_t *pv2 = m2.get (p);\n+\n+    ASSERT_TRUE (ncopy + 1 == val_t::ncopy);\n+    ASSERT_TRUE (nassign == val_t::nassign);\n+\n+    ASSERT_TRUE (&rv1 != pv2);\n+    ASSERT_TRUE (pv2->ptr == &pv2->ptr);\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n+\n+#if 0   /* Avoid testing until bug 90959 is fixed.  */\n+  {\n+    /* Test copy assignment into an empty map.  */\n+    Map m1;\n+    void *p = &p;\n+    val_t &rv1 = m1.get_or_insert (p);\n+\n+    int ncopy = val_t::ncopy;\n+    int nassign = val_t::nassign;\n+\n+    Map m2;\n+    m2 = m1;\n+    val_t *pv2 = m2.get (p);\n+\n+    ASSERT_TRUE (ncopy == val_t::ncopy);\n+    ASSERT_TRUE (nassign + 1 == val_t::nassign);\n+\n+    ASSERT_TRUE (&rv1 != pv2);\n+    ASSERT_TRUE (pv2->ptr == &pv2->ptr);\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n+\n+#endif\n+\n+  {\n+    Map m;\n+    void *p = &p, *q = &q;\n+    val_t &v1 = m.get_or_insert (p);\n+    val_t &v2 = m.get_or_insert (q);\n+\n+    ASSERT_TRUE (v1.ptr == &v1.ptr && &v2.ptr == v2.ptr);\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n+\n+  {\n+    Map m;\n+    void *p = &p, *q = &q;\n+    m.get_or_insert (p);\n+    m.remove (p);\n+    m.get_or_insert (q);\n+    m.remove (q);\n+\n+    ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n+  }\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n hash_map_tests_c_tests ()\n {\n   test_map_of_strings_to_int ();\n+  test_map_of_type_with_ctor_and_dtor ();\n }\n \n } // namespace selftest"}, {"sha": "f3f1f9a89ff697e0526e9b00d1864ecd33016843", "filename": "gcc/hash-map.h", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=7b8795a138d0baa3b0505baee2ed05ae266977cd", "patch": "@@ -21,8 +21,20 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef hash_map_h\n #define hash_map_h\n \n+/* Class hash_map is a hash-value based container mapping objects of\n+   KeyId type to those of the Value type.\n+   Both KeyId and Value may be non-trivial (non-POD) types provided\n+   a suitabe Traits class.  A few default Traits specializations are\n+   provided for basic types such as integers, pointers, and std::pair.\n+   Inserted elements are value-initialized either to zero for POD types\n+   or by invoking their default ctor.  Removed elements are destroyed\n+   by invoking their dtor.   On hash_map destruction all elements are\n+   removed.  Objects of hash_map type are copy-constructible but not\n+   assignable.  */\n+\n template<typename KeyId, typename Value,\n-\t typename Traits>\n+\t typename Traits /* = simple_hashmap_traits<default_hash_traits<Key>,\n+\t\t\t                            Value> */>\n class GTY((user)) hash_map\n {\n   typedef typename Traits::key_type Key;\n@@ -151,12 +163,16 @@ class GTY((user)) hash_map\n     {\n       hash_entry *e = m_table.find_slot_with_hash (k, Traits::hash (k),\n \t\t\t\t\t\t   INSERT);\n-      bool existed = !hash_entry::is_empty (*e);\n-      if (!existed)\n-\te->m_key = k;\n+      bool ins = hash_entry::is_empty (*e);\n+      if (ins)\n+\t{\n+\t  e->m_key = k;\n+\t  new ((void *) &e->m_value) Value (v);\n+\t}\n+      else\n+\te->m_value = v;\n \n-      e->m_value = v;\n-      return existed;\n+      return !ins;\n     }\n \n   /* if the passed in key is in the map return its value otherwise NULL.  */\n@@ -168,16 +184,19 @@ class GTY((user)) hash_map\n     }\n \n   /* Return a reference to the value for the passed in key, creating the entry\n-     if it doesn't already exist.  If existed is not NULL then it is set to false\n-     if the key was not previously in the map, and true otherwise.  */\n+     if it doesn't already exist.  If existed is not NULL then it is set to\n+     false if the key was not previously in the map, and true otherwise.  */\n \n   Value &get_or_insert (const Key &k, bool *existed = NULL)\n     {\n       hash_entry *e = m_table.find_slot_with_hash (k, Traits::hash (k),\n \t\t\t\t\t\t   INSERT);\n       bool ins = Traits::is_empty (*e);\n       if (ins)\n-\te->m_key = k;\n+\t{\n+\t  e->m_key = k;\n+\t  new ((void *)&e->m_value) Value ();\n+\t}\n \n       if (existed != NULL)\n \t*existed = !ins;"}, {"sha": "c96fe538d9ff7f301625a9346f3b3c71cd6d7508", "filename": "gcc/hash-set-tests.c", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-set-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-set-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set-tests.c?ref=7b8795a138d0baa3b0505baee2ed05ae266977cd", "patch": "@@ -134,12 +134,166 @@ test_set_of_strings ()\n   ASSERT_EQ (2, t.elements ());\n }\n \n+typedef struct hash_set_test_value_t\n+{\n+  static int ndefault;\n+  static int ncopy;\n+  static int nassign;\n+  static int ndtor;\n+\n+  hash_set_test_value_t (int v = 1): pval (&val), val (v)\n+  {\n+    ++ndefault;\n+  }\n+\n+  hash_set_test_value_t (const hash_set_test_value_t &rhs)\n+    : pval (&val), val (rhs.val)\n+  {\n+    ++ncopy;\n+  }\n+\n+  hash_set_test_value_t& operator= (const hash_set_test_value_t &rhs)\n+    {\n+     ++nassign;\n+     val = rhs.val;\n+     return *this;\n+    }\n+\n+  ~hash_set_test_value_t ()\n+    {\n+     /* Verify that the value hasn't been corrupted.  */\n+     gcc_assert (*pval > 0);\n+     gcc_assert (pval == &val);\n+     *pval = -3;\n+     ++ndtor;\n+    }\n+\n+  int *pval;\n+  int val;\n+} val_t;\n+\n+int val_t::ndefault;\n+int val_t::ncopy;\n+int val_t::nassign;\n+int val_t::ndtor;\n+\n+struct value_hash_traits: int_hash<int, -1, -2>\n+{\n+  typedef int_hash<int, -1, -2> base_type;\n+  typedef val_t                 value_type;\n+  typedef value_type            compare_type;\n+\n+  static hashval_t hash (const value_type &v)\n+  {\n+    return base_type::hash (v.val);\n+  }\n+\n+  static bool equal (const value_type &a, const compare_type &b)\n+  {\n+    return base_type::equal (a.val, b.val);\n+  }\n+\n+  static void mark_deleted (value_type &v)\n+  {\n+    base_type::mark_deleted (v.val);\n+  }\n+\n+  static void mark_empty (value_type &v)\n+  {\n+    base_type::mark_empty (v.val);\n+  }\n+\n+  static bool is_deleted (const value_type &v)\n+  {\n+    return base_type::is_deleted (v.val);\n+  }\n+\n+  static bool is_empty (const value_type &v)\n+  {\n+    return base_type::is_empty (v.val);\n+  }\n+\n+  static void remove (value_type &v)\n+  {\n+    v.~value_type ();\n+  }\n+};\n+\n+static void\n+test_set_of_type_with_ctor_and_dtor ()\n+{\n+  typedef hash_set <val_t, false, value_hash_traits> Set;\n+\n+  {\n+    Set s;\n+    (void)&s;\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault == 0);\n+  ASSERT_TRUE (val_t::ncopy == 0);\n+  ASSERT_TRUE (val_t::nassign == 0);\n+  ASSERT_TRUE (val_t::ndtor == 0);\n+\n+  {\n+    Set s;\n+    ASSERT_EQ (false, s.add (val_t ()));\n+    ASSERT_EQ (true, 1 == s.elements ());\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n+\n+  {\n+    Set s;\n+    ASSERT_EQ (false, s.add (val_t ()));\n+    ASSERT_EQ (true, s.add (val_t ()));\n+    ASSERT_EQ (true, 1 == s.elements ());\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n+\n+  {\n+    Set s;\n+    val_t v1 (1), v2 (2), v3 (3);\n+    int ndefault = val_t::ndefault;\n+    int nassign = val_t::nassign;\n+\n+    ASSERT_EQ (false, s.add (v1));\n+    ASSERT_EQ (true, s.contains (v1));\n+    ASSERT_EQ (true, 1 == s.elements ());\n+\n+    ASSERT_EQ (false, s.add (v2));\n+    ASSERT_EQ (true, s.contains (v2));\n+    ASSERT_EQ (true, 2 == s.elements ());\n+\n+    ASSERT_EQ (false, s.add (v3));\n+    ASSERT_EQ (true, s.contains (v3));\n+    ASSERT_EQ (true, 3 == s.elements ());\n+\n+    ASSERT_EQ (true, s.add (v2));\n+    ASSERT_EQ (true, s.contains (v2));\n+    ASSERT_EQ (true, 3 == s.elements ());\n+\n+    s.remove (v2);\n+    ASSERT_EQ (true, 2 == s.elements ());\n+    s.remove (v3);\n+    ASSERT_EQ (true, 1 == s.elements ());\n+\n+    /* Verify that no default ctors or assignment operators have\n+       been called.  */\n+    ASSERT_EQ (true, ndefault == val_t::ndefault);\n+    ASSERT_EQ (true, nassign == val_t::nassign);\n+  }\n+\n+  ASSERT_TRUE (val_t::ndefault + val_t::ncopy == val_t::ndtor);\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n hash_set_tests_c_tests ()\n {\n   test_set_of_strings ();\n+  test_set_of_type_with_ctor_and_dtor ();\n }\n \n } // namespace selftest"}, {"sha": "a79a88d1ab91b1583ebbb617bdb0c7899bb63b68", "filename": "gcc/hash-set.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=7b8795a138d0baa3b0505baee2ed05ae266977cd", "patch": "@@ -21,6 +21,16 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef hash_set_h\n #define hash_set_h\n \n+/* Class hash_set is a hash-value based container for objects of\n+   KeyId type.\n+   KeyId may be a non-trivial (non-POD) type provided a suitabe Traits\n+   class.  Default Traits specializations are provided for basic types\n+   such as integers, pointers, and std::pair.  Inserted elements are\n+   value-initialized either to zero for POD types or by invoking their\n+   default ctor.  Removed elements are destroyed by invoking their dtor.\n+   On hash_set destruction all elements are removed.  Objects of\n+   hash_set type are copy-constructible but not assignable.  */\n+\n template<typename KeyId, bool Lazy = false,\n \t typename Traits = default_hash_traits<KeyId> >\n class hash_set\n@@ -48,7 +58,7 @@ class hash_set\n       Key *e = m_table.find_slot_with_hash (k, Traits::hash (k), INSERT);\n       bool existed = !Traits::is_empty (*e);\n       if (!existed)\n-\t*e = k;\n+\tnew (e) Key (k);\n \n       return existed;\n     }"}, {"sha": "0e95f5b4042f2462bed1cc926f0bf8eef54f7658", "filename": "gcc/hash-table.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b8795a138d0baa3b0505baee2ed05ae266977cd/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=7b8795a138d0baa3b0505baee2ed05ae266977cd", "patch": "@@ -35,14 +35,17 @@ along with GCC; see the file COPYING3.  If not see\n       several things.\n \n          - A typedef named 'value_type' to the value type (from above).\n+\t Provided a suitable Descriptor class it may be a user-defined,\n+\t non-POD type.\n \n          - A static member function named 'hash' that takes a value_type\n          (or 'const value_type &') and returns a hashval_t value.\n \n          - A typedef named 'compare_type' that is used to test when a value\n-         is found.  This type is the comparison type.  Usually, it will be the\n-         same as value_type.  If it is not the same type, you must generally\n-         explicitly compute hash values and pass them to the hash table.\n+\t is found.  This type is the comparison type.  Usually, it will be\n+\t the same as value_type and may be a user-defined, non-POD type.\n+\t If it is not the same type, you must generally explicitly compute\n+\t hash values and pass them to the hash table.\n \n          - A static member function named 'equal' that takes a value_type\n          and a compare_type, and returns a bool.  Both arguments can be\n@@ -505,6 +508,9 @@ class hash_table\n     }\n \n private:\n+  /* FIXME: Make the class assignable.  See pr90959.  */\n+  void operator= (hash_table&);\n+\n   template<typename T> friend void gt_ggc_mx (hash_table<T> *);\n   template<typename T> friend void gt_pch_nx (hash_table<T> *);\n   template<typename T> friend void\n@@ -657,7 +663,7 @@ hash_table<Descriptor, Lazy, Allocator>::hash_table (const hash_table &h,\n \t  if (is_deleted (entry))\n \t    mark_deleted (nentries[i]);\n \t  else if (!is_empty (entry))\n-\t    nentries[i] = entry;\n+\t    new ((void*) (nentries + i)) value_type (entry);\n \t}\n       m_entries = nentries;\n     }"}]}