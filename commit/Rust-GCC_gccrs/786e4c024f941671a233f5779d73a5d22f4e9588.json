{"sha": "786e4c024f941671a233f5779d73a5d22f4e9588", "node_id": "C_kwDOANBUbNoAKDc4NmU0YzAyNGY5NDE2NzFhMjMzZjU3NzlkNzNhNWQyMmY0ZTk1ODg", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-13T10:59:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-13T11:48:54Z"}, "message": "diagnose return statement in match.pd (with { ... } expressions\n\nThe expression in (with { ... } is used like a statement expression\nwhich means control flow that leaves it is not allowed.  The following\nexplicitely diagnoses 'return' and fixes up the few cases that crept\ninto match.pd (oops).  Any such return will prematurely end matching\nthe current expression.\n\n\t* genmatch.cc (parser::parse_c_expr): Diagnose 'return'.\n\t* match.pd: Replace 'return' statements in with expressions\n\twith appropriate variants.", "tree": {"sha": "53acf5ed89d025c51d9961c64f2451a4d9071af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53acf5ed89d025c51d9961c64f2451a4d9071af4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/786e4c024f941671a233f5779d73a5d22f4e9588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786e4c024f941671a233f5779d73a5d22f4e9588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786e4c024f941671a233f5779d73a5d22f4e9588", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786e4c024f941671a233f5779d73a5d22f4e9588/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f0d4adabe2035886a1aa8d2ca990a90de000613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f0d4adabe2035886a1aa8d2ca990a90de000613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f0d4adabe2035886a1aa8d2ca990a90de000613"}], "stats": {"total": 300, "additions": 150, "deletions": 150}, "files": [{"sha": "4a8802469cd9ed89e5c351f393d8e54c86905978", "filename": "gcc/genmatch.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786e4c024f941671a233f5779d73a5d22f4e9588/gcc%2Fgenmatch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786e4c024f941671a233f5779d73a5d22f4e9588/gcc%2Fgenmatch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.cc?ref=786e4c024f941671a233f5779d73a5d22f4e9588", "patch": "@@ -4447,8 +4447,11 @@ parser::parse_c_expr (cpp_ttype start)\n       /* If this is possibly a user-defined identifier mark it used.  */\n       if (token->type == CPP_NAME)\n \t{\n-\t  id_base *idb = get_operator ((const char *)CPP_HASHNODE\n-\t\t\t\t      (token->val.node.node)->ident.str);\n+\t  const char *str\n+\t    = (const char *)CPP_HASHNODE (token->val.node.node)->ident.str;\n+\t  if (strcmp (str, \"return\") == 0)\n+\t    fatal_at (token, \"return statement not allowed in C expression\");\n+\t  id_base *idb = get_operator (str);\n \t  user_id *p;\n \t  if (idb && (p = dyn_cast<user_id *> (idb)) && p->is_oper_list)\n \t    record_operlist (token->src_loc, p);"}, {"sha": "fd64ad740b61c8d51c5564abff41a38edfdea8c4", "filename": "gcc/match.pd", "status": "modified", "additions": 145, "deletions": 148, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786e4c024f941671a233f5779d73a5d22f4e9588/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786e4c024f941671a233f5779d73a5d22f4e9588/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=786e4c024f941671a233f5779d73a5d22f4e9588", "patch": "@@ -7930,131 +7930,131 @@ and,\n \n     /* Build a vector of integers from the tree mask.  */\n     vec_perm_builder builder;\n-    if (!tree_to_vec_perm_builder (&builder, op2))\n-      return NULL_TREE;\n-\n-    /* Create a vec_perm_indices for the integer vector.  */\n-    poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (type);\n-    bool single_arg = (op0 == op1);\n-    vec_perm_indices sel (builder, single_arg ? 1 : 2, nelts);\n   }\n-  (if (sel.series_p (0, 1, 0, 1))\n-   { op0; }\n-   (if (sel.series_p (0, 1, nelts, 1))\n-    { op1; }\n-    (with\n-     {\n-       if (!single_arg)\n-         {\n-\t   if (sel.all_from_input_p (0))\n-\t     op1 = op0;\n-\t   else if (sel.all_from_input_p (1))\n+  (if (tree_to_vec_perm_builder (&builder, op2))\n+   (with\n+    {\n+      /* Create a vec_perm_indices for the integer vector.  */\n+      poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (type);\n+      bool single_arg = (op0 == op1);\n+      vec_perm_indices sel (builder, single_arg ? 1 : 2, nelts);\n+    }\n+    (if (sel.series_p (0, 1, 0, 1))\n+     { op0; }\n+     (if (sel.series_p (0, 1, nelts, 1))\n+      { op1; }\n+      (with\n+       {\n+         if (!single_arg)\n+\t   {\n+\t     if (sel.all_from_input_p (0))\n+\t       op1 = op0;\n+\t     else if (sel.all_from_input_p (1))\n+\t       {\n+\t         op0 = op1;\n+\t         sel.rotate_inputs (1);\n+\t       }\n+\t     else if (known_ge (poly_uint64 (sel[0]), nelts))\n+\t       {\n+\t         std::swap (op0, op1);\n+\t         sel.rotate_inputs (1);\n+\t       }\n+\t   }\n+\t gassign *def;\n+\t tree cop0 = op0, cop1 = op1;\n+\t if (TREE_CODE (op0) == SSA_NAME\n+\t     && (def = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (op0)))\n+\t     && gimple_assign_rhs_code (def) == CONSTRUCTOR)\n+\t   cop0 = gimple_assign_rhs1 (def);\n+\t if (TREE_CODE (op1) == SSA_NAME\n+\t     && (def = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (op1)))\n+\t     && gimple_assign_rhs_code (def) == CONSTRUCTOR)\n+\t   cop1 = gimple_assign_rhs1 (def);\n+\t tree t;\n+       }\n+       (if ((TREE_CODE (cop0) == VECTOR_CST\n+\t     || TREE_CODE (cop0) == CONSTRUCTOR)\n+\t    && (TREE_CODE (cop1) == VECTOR_CST\n+\t\t|| TREE_CODE (cop1) == CONSTRUCTOR)\n+\t    && (t = fold_vec_perm (type, cop0, cop1, sel)))\n+\t{ t; }\n+\t(with\n+\t {\n+\t   bool changed = (op0 == op1 && !single_arg);\n+\t   tree ins = NULL_TREE;\n+\t   unsigned at = 0;\n+\n+\t   /* See if the permutation is performing a single element\n+\t      insert from a CONSTRUCTOR or constant and use a BIT_INSERT_EXPR\n+\t      in that case.  But only if the vector mode is supported,\n+\t      otherwise this is invalid GIMPLE.  */\n+\t   if (op_mode != BLKmode\n+\t       && (TREE_CODE (cop0) == VECTOR_CST\n+\t\t   || TREE_CODE (cop0) == CONSTRUCTOR\n+\t\t   || TREE_CODE (cop1) == VECTOR_CST\n+\t\t   || TREE_CODE (cop1) == CONSTRUCTOR))\n \t     {\n-\t       op0 = op1;\n-\t       sel.rotate_inputs (1);\n+\t       bool insert_first_p = sel.series_p (1, 1, nelts + 1, 1);\n+\t       if (insert_first_p)\n+\t         {\n+\t\t   /* After canonicalizing the first elt to come from the\n+\t\t      first vector we only can insert the first elt from\n+\t\t      the first vector.  */\n+\t\t   at = 0;\n+\t\t   if ((ins = fold_read_from_vector (cop0, sel[0])))\n+\t\t     op0 = op1;\n+\t\t }\n+\t       /* The above can fail for two-element vectors which always\n+\t\t  appear to insert the first element, so try inserting\n+\t\t  into the second lane as well.  For more than two\n+\t\t  elements that's wasted time.  */\n+\t       if (!insert_first_p || (!ins && maybe_eq (nelts, 2u)))\n+\t\t {\n+\t\t   unsigned int encoded_nelts = sel.encoding ().encoded_nelts ();\n+\t\t   for (at = 0; at < encoded_nelts; ++at)\n+\t\t     if (maybe_ne (sel[at], at))\n+\t\t       break;\n+\t\t   if (at < encoded_nelts\n+\t\t       && (known_eq (at + 1, nelts)\n+\t\t\t   || sel.series_p (at + 1, 1, at + 1, 1)))\n+\t\t     {\n+\t\t       if (known_lt (poly_uint64 (sel[at]), nelts))\n+\t\t\t ins = fold_read_from_vector (cop0, sel[at]);\n+\t\t       else\n+\t\t\t ins = fold_read_from_vector (cop1, sel[at] - nelts);\n+\t\t     }\n+\t\t }\n \t     }\n-\t   else if (known_ge (poly_uint64 (sel[0]), nelts))\n+\n+\t   /* Generate a canonical form of the selector.  */\n+\t   if (!ins && sel.encoding () != builder)\n \t     {\n-\t       std::swap (op0, op1);\n-\t       sel.rotate_inputs (1);\n+\t       /* Some targets are deficient and fail to expand a single\n+\t\t  argument permutation while still allowing an equivalent\n+\t\t  2-argument version.  */\n+\t       tree oldop2 = op2;\n+\t       if (sel.ninputs () == 2\n+\t\t   || can_vec_perm_const_p (result_mode, op_mode, sel, false))\n+\t\t op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel);\n+\t       else\n+\t\t {\n+\t\t   vec_perm_indices sel2 (builder, 2, nelts);\n+\t\t   if (can_vec_perm_const_p (result_mode, op_mode, sel2, false))\n+\t\t     op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel2);\n+\t\t   else\n+\t\t     /* Not directly supported with either encoding,\n+\t\t\tso use the preferred form.  */\n+\t\t     op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel);\n+\t\t }\n+\t       if (!operand_equal_p (op2, oldop2, 0))\n+\t\t changed = true;\n \t     }\n-         }\n-       gassign *def;\n-       tree cop0 = op0, cop1 = op1;\n-       if (TREE_CODE (op0) == SSA_NAME\n-           && (def = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (op0)))\n-\t   && gimple_assign_rhs_code (def) == CONSTRUCTOR)\n-\t cop0 = gimple_assign_rhs1 (def);\n-       if (TREE_CODE (op1) == SSA_NAME\n-           && (def = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (op1)))\n-\t   && gimple_assign_rhs_code (def) == CONSTRUCTOR)\n-\t cop1 = gimple_assign_rhs1 (def);\n-\n-       tree t;\n-    }\n-    (if ((TREE_CODE (cop0) == VECTOR_CST\n-\t  || TREE_CODE (cop0) == CONSTRUCTOR)\n-\t && (TREE_CODE (cop1) == VECTOR_CST\n-\t     || TREE_CODE (cop1) == CONSTRUCTOR)\n-\t && (t = fold_vec_perm (type, cop0, cop1, sel)))\n-     { t; }\n-     (with\n-      {\n-\tbool changed = (op0 == op1 && !single_arg);\n-\ttree ins = NULL_TREE;\n-\tunsigned at = 0;\n-\n-\t/* See if the permutation is performing a single element\n-\t   insert from a CONSTRUCTOR or constant and use a BIT_INSERT_EXPR\n-\t   in that case.  But only if the vector mode is supported,\n-\t   otherwise this is invalid GIMPLE.  */\n-        if (op_mode != BLKmode\n-\t    && (TREE_CODE (cop0) == VECTOR_CST\n-\t\t|| TREE_CODE (cop0) == CONSTRUCTOR\n-\t\t|| TREE_CODE (cop1) == VECTOR_CST\n-\t\t|| TREE_CODE (cop1) == CONSTRUCTOR))\n-          {\n-\t    bool insert_first_p = sel.series_p (1, 1, nelts + 1, 1);\n-\t    if (insert_first_p)\n-\t      {\n-\t        /* After canonicalizing the first elt to come from the\n-\t\t   first vector we only can insert the first elt from\n-\t\t   the first vector.  */\n-\t        at = 0;\n-\t\tif ((ins = fold_read_from_vector (cop0, sel[0])))\n-\t\t  op0 = op1;\n-\t      }\n-\t    /* The above can fail for two-element vectors which always\n-\t       appear to insert the first element, so try inserting\n-\t       into the second lane as well.  For more than two\n-\t       elements that's wasted time.  */\n-\t    if (!insert_first_p || (!ins && maybe_eq (nelts, 2u)))\n-\t      {\n-\t        unsigned int encoded_nelts = sel.encoding ().encoded_nelts ();\n-\t\tfor (at = 0; at < encoded_nelts; ++at)\n-\t\t  if (maybe_ne (sel[at], at))\n-\t\t    break;\n-\t\tif (at < encoded_nelts\n-\t\t    && (known_eq (at + 1, nelts)\n-\t\t\t|| sel.series_p (at + 1, 1, at + 1, 1)))\n-\t\t  {\n-\t\t    if (known_lt (poly_uint64 (sel[at]), nelts))\n-\t\t      ins = fold_read_from_vector (cop0, sel[at]);\n-\t\t    else\n-\t\t      ins = fold_read_from_vector (cop1, sel[at] - nelts);\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\t/* Generate a canonical form of the selector.  */\n-\tif (!ins && sel.encoding () != builder)\n-\t  {\n-\t    /* Some targets are deficient and fail to expand a single\n-\t       argument permutation while still allowing an equivalent\n-\t       2-argument version.  */\n-\t    tree oldop2 = op2;\n-\t    if (sel.ninputs () == 2\n-\t       || can_vec_perm_const_p (result_mode, op_mode, sel, false))\n-\t      op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel);\n-\t    else\n-\t      {\n-\t        vec_perm_indices sel2 (builder, 2, nelts);\n-\t\tif (can_vec_perm_const_p (result_mode, op_mode, sel2, false))\n-\t          op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel2);\n-\t        else\n-\t          /* Not directly supported with either encoding,\n-\t\t     so use the preferred form.  */\n-\t\t  op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel);\n-\t      }\n-\t    if (!operand_equal_p (op2, oldop2, 0))\n-\t      changed = true;\n-\t  }\n-      }\n-      (if (ins)\n-       (bit_insert { op0; } { ins; }\n-         { bitsize_int (at * vector_element_bits (type)); })\n-       (if (changed)\n-        (vec_perm { op0; } { op1; } { op2; }))))))))))\n+\t }\n+\t (if (ins)\n+\t  (bit_insert { op0; } { ins; }\n+\t   { bitsize_int (at * vector_element_bits (type)); })\n+\t  (if (changed)\n+\t   (vec_perm { op0; } { op1; } { op2; }))))))))))))\n \n /* VEC_PERM_EXPR (v, v, mask) -> v where v contains same element.  */\n \n@@ -8094,37 +8094,34 @@ and,\n \n (simplify\n  (vec_perm (vec_perm@0 @1 @2 VECTOR_CST@3) @0 VECTOR_CST@4)\n- (with\n-  {\n-    if (!TYPE_VECTOR_SUBPARTS (type).is_constant ())\n-      return NULL_TREE;\n-\n-    tree op0;\n-    machine_mode result_mode = TYPE_MODE (type);\n-    machine_mode op_mode = TYPE_MODE (TREE_TYPE (@1));\n-    int nelts = TYPE_VECTOR_SUBPARTS (type).to_constant ();\n-    vec_perm_builder builder0;\n-    vec_perm_builder builder1;\n-    vec_perm_builder builder2 (nelts, nelts, 1);\n-\n-    if (!tree_to_vec_perm_builder (&builder0, @3)\n-\t|| !tree_to_vec_perm_builder (&builder1, @4))\n-      return NULL_TREE;\n-\n-    vec_perm_indices sel0 (builder0, 2, nelts);\n-    vec_perm_indices sel1 (builder1, 1, nelts);\n-\n-    for (int i = 0; i < nelts; i++)\n-      builder2.quick_push (sel0[sel1[i].to_constant ()]);\n+ (if (TYPE_VECTOR_SUBPARTS (type).is_constant ())\n+  (with\n+   {\n+     machine_mode result_mode = TYPE_MODE (type);\n+     machine_mode op_mode = TYPE_MODE (TREE_TYPE (@1));\n+     int nelts = TYPE_VECTOR_SUBPARTS (type).to_constant ();\n+     vec_perm_builder builder0;\n+     vec_perm_builder builder1;\n+     vec_perm_builder builder2 (nelts, nelts, 1);\n+   }\n+   (if (tree_to_vec_perm_builder (&builder0, @3)\n+\t&& tree_to_vec_perm_builder (&builder1, @4))\n+    (with\n+     {\n+       vec_perm_indices sel0 (builder0, 2, nelts);\n+       vec_perm_indices sel1 (builder1, 1, nelts);\n \n-    vec_perm_indices sel2 (builder2, 2, nelts);\n+       for (int i = 0; i < nelts; i++)\n+\t builder2.quick_push (sel0[sel1[i].to_constant ()]);\n \n-    if (!can_vec_perm_const_p (result_mode, op_mode, sel2, false))\n-      return NULL_TREE;\n+       vec_perm_indices sel2 (builder2, 2, nelts);\n \n-    op0 = vec_perm_indices_to_tree (TREE_TYPE (@4), sel2);\n-  }\n-  (vec_perm @1 @2 { op0; })))\n+       tree op0 = NULL_TREE;\n+       if (can_vec_perm_const_p (result_mode, op_mode, sel2, false))\n+\t op0 = vec_perm_indices_to_tree (TREE_TYPE (@4), sel2);\n+     }\n+     (if (op0)\n+      (vec_perm @1 @2 { op0; })))))))\n \n \n /* Match count trailing zeroes for simplify_count_trailing_zeroes in fwprop."}]}