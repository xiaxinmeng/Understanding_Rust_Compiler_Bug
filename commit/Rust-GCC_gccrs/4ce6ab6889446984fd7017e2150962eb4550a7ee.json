{"sha": "4ce6ab6889446984fd7017e2150962eb4550a7ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNlNmFiNjg4OTQ0Njk4NGZkNzAxN2UyMTUwOTYyZWI0NTUwYTdlZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-07-29T08:40:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-07-29T08:40:21Z"}, "message": "Implement more rtx vector folds on variable-length vectors\n\nThis patch extends the tree-level folding of variable-length vectors\nso that it can also be used on rtxes.  The first step is to move\nthe tree_vector_builder new_unary/binary_operator routines to the\nparent vector_builder class (which in turn means adding a new\ntemplate parameter).  The second step is to make simplify-rtx.c\nuse a direct rtx analogue of the VECTOR_CST handling in fold-const.c.\n\n2019-07-29  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* vector-builder.h (vector_builder): Add a shape template parameter.\n\t(vector_builder::new_unary_operation): New function, generalizing\n\tthe old tree_vector_builder function.\n\t(vector_builder::new_binary_operation): Likewise.\n\t(vector_builder::binary_encoded_nelts): Likewise.\n\t* int-vector-builder.h (int_vector_builder): Update template\n\tparameters to vector_builder.\n\t(int_vector_builder::shape_nelts): New function.\n\t* rtx-vector-builder.h (rtx_vector_builder): Update template\n\tparameters to vector_builder.\n\t(rtx_vector_builder::shape_nelts): New function.\n\t(rtx_vector_builder::nelts_of): Likewise.\n\t(rtx_vector_builder::npatterns_of): Likewise.\n\t(rtx_vector_builder::nelts_per_pattern_of): Likewise.\n\t* tree-vector-builder.h (tree_vector_builder): Update template\n\tparameters to vector_builder.\n\t(tree_vector_builder::shape_nelts): New function.\n\t(tree_vector_builder::nelts_of): Likewise.\n\t(tree_vector_builder::npatterns_of): Likewise.\n\t(tree_vector_builder::nelts_per_pattern_of): Likewise.\n\t* tree-vector-builder.c (tree_vector_builder::new_unary_operation)\n\t(tree_vector_builder::new_binary_operation): Delete.\n\t(tree_vector_builder::binary_encoded_nelts): Likewise.\n\t* simplify-rtx.c: Include rtx-vector-builder.h.\n\t(distributes_over_addition_p): New function.\n\t(simplify_const_unary_operation)\n\t(simplify_const_binary_operation): Generalize handling of vector\n\tconstants to include variable-length vectors.\n\t(test_vector_ops_series): Add more tests.\n\nFrom-SVN: r273867", "tree": {"sha": "703d424c2a70fdb6d25fec4f41ba93f2545d277b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/703d424c2a70fdb6d25fec4f41ba93f2545d277b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ce6ab6889446984fd7017e2150962eb4550a7ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce6ab6889446984fd7017e2150962eb4550a7ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce6ab6889446984fd7017e2150962eb4550a7ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce6ab6889446984fd7017e2150962eb4550a7ee/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66fafc3bf683405e6fedb4fe18dc09035b0073c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66fafc3bf683405e6fedb4fe18dc09035b0073c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66fafc3bf683405e6fedb4fe18dc09035b0073c2"}], "stats": {"total": 522, "additions": 350, "deletions": 172}, "files": [{"sha": "d80cd319bb65fbec37ea84e955384a11a7a230d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ce6ab6889446984fd7017e2150962eb4550a7ee", "patch": "@@ -1,3 +1,35 @@\n+2019-07-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* vector-builder.h (vector_builder): Add a shape template parameter.\n+\t(vector_builder::new_unary_operation): New function, generalizing\n+\tthe old tree_vector_builder function.\n+\t(vector_builder::new_binary_operation): Likewise.\n+\t(vector_builder::binary_encoded_nelts): Likewise.\n+\t* int-vector-builder.h (int_vector_builder): Update template\n+\tparameters to vector_builder.\n+\t(int_vector_builder::shape_nelts): New function.\n+\t* rtx-vector-builder.h (rtx_vector_builder): Update template\n+\tparameters to vector_builder.\n+\t(rtx_vector_builder::shape_nelts): New function.\n+\t(rtx_vector_builder::nelts_of): Likewise.\n+\t(rtx_vector_builder::npatterns_of): Likewise.\n+\t(rtx_vector_builder::nelts_per_pattern_of): Likewise.\n+\t* tree-vector-builder.h (tree_vector_builder): Update template\n+\tparameters to vector_builder.\n+\t(tree_vector_builder::shape_nelts): New function.\n+\t(tree_vector_builder::nelts_of): Likewise.\n+\t(tree_vector_builder::npatterns_of): Likewise.\n+\t(tree_vector_builder::nelts_per_pattern_of): Likewise.\n+\t* tree-vector-builder.c (tree_vector_builder::new_unary_operation)\n+\t(tree_vector_builder::new_binary_operation): Delete.\n+\t(tree_vector_builder::binary_encoded_nelts): Likewise.\n+\t* simplify-rtx.c: Include rtx-vector-builder.h.\n+\t(distributes_over_addition_p): New function.\n+\t(simplify_const_unary_operation)\n+\t(simplify_const_binary_operation): Generalize handling of vector\n+\tconstants to include variable-length vectors.\n+\t(test_vector_ops_series): Add more tests.\n+\n 2019-07-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/91222"}, {"sha": "dc96510217ce9662ac8deedb99b6ce53051bf2cb", "filename": "gcc/int-vector-builder.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Fint-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Fint-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fint-vector-builder.h?ref=4ce6ab6889446984fd7017e2150962eb4550a7ee", "patch": "@@ -26,10 +26,11 @@ along with GCC; see the file COPYING3.  If not see\n    encoding as tree and rtx constants.  See vector_builder for more\n    details.  */\n template<typename T>\n-class int_vector_builder : public vector_builder<T, int_vector_builder<T> >\n+class int_vector_builder : public vector_builder<T, poly_uint64,\n+\t\t\t\t\t\t int_vector_builder<T> >\n {\n-  typedef vector_builder<T, int_vector_builder> parent;\n-  friend class vector_builder<T, int_vector_builder>;\n+  typedef vector_builder<T, poly_uint64, int_vector_builder> parent;\n+  friend class vector_builder<T, poly_uint64, int_vector_builder>;\n \n public:\n   int_vector_builder () {}\n@@ -45,6 +46,8 @@ class int_vector_builder : public vector_builder<T, int_vector_builder<T> >\n   T apply_step (T, unsigned int, T) const;\n   bool can_elide_p (T) const { return true; }\n   void note_representative (T *, T) {}\n+\n+  static poly_uint64 shape_nelts (poly_uint64 x) { return x; }\n };\n \n /* Create a new builder for a vector with FULL_NELTS elements."}, {"sha": "08b55dd36263f670ea0b8eca1d755afa58cd0f83", "filename": "gcc/rtx-vector-builder.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Frtx-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Frtx-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtx-vector-builder.h?ref=4ce6ab6889446984fd7017e2150962eb4550a7ee", "patch": "@@ -24,10 +24,11 @@ along with GCC; see the file COPYING3.  If not see\n \n /* This class is used to build VECTOR_CSTs from a sequence of elements.\n    See vector_builder for more details.  */\n-class rtx_vector_builder : public vector_builder<rtx, rtx_vector_builder>\n+class rtx_vector_builder : public vector_builder<rtx, machine_mode,\n+\t\t\t\t\t\t rtx_vector_builder>\n {\n-  typedef vector_builder<rtx, rtx_vector_builder> parent;\n-  friend class vector_builder<rtx, rtx_vector_builder>;\n+  typedef vector_builder<rtx, machine_mode, rtx_vector_builder> parent;\n+  friend class vector_builder<rtx, machine_mode, rtx_vector_builder>;\n \n public:\n   rtx_vector_builder () : m_mode (VOIDmode) {}\n@@ -48,6 +49,15 @@ class rtx_vector_builder : public vector_builder<rtx, rtx_vector_builder>\n   bool can_elide_p (rtx) const { return true; }\n   void note_representative (rtx *, rtx) {}\n \n+  static poly_uint64 shape_nelts (machine_mode mode)\n+    { return GET_MODE_NUNITS (mode); }\n+  static poly_uint64 nelts_of (const_rtx x)\n+    { return CONST_VECTOR_NUNITS (x); }\n+  static unsigned int npatterns_of (const_rtx x)\n+    { return CONST_VECTOR_NPATTERNS (x); }\n+  static unsigned int nelts_per_pattern_of (const_rtx x)\n+    { return CONST_VECTOR_NELTS_PER_PATTERN (x); }\n+\n   rtx find_cached_value ();\n \n   machine_mode m_mode;"}, {"sha": "0a69c0503abec311aea987567b7e2dc8552d6f31", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 114, "deletions": 25, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=4ce6ab6889446984fd7017e2150962eb4550a7ee", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"selftest.h\"\n #include \"selftest-rtl.h\"\n+#include \"rtx-vector-builder.h\"\n \n /* Simplification and canonicalization of RTL.  */\n \n@@ -1753,27 +1754,23 @@ simplify_const_unary_operation (enum rtx_code code, machine_mode mode,\n \n   if (VECTOR_MODE_P (mode) && GET_CODE (op) == CONST_VECTOR)\n     {\n-      unsigned int n_elts;\n-      if (!CONST_VECTOR_NUNITS (op).is_constant (&n_elts))\n-\treturn NULL_RTX;\n-\n-      machine_mode opmode = GET_MODE (op);\n-      gcc_assert (known_eq (GET_MODE_NUNITS (mode), n_elts));\n-      gcc_assert (known_eq (GET_MODE_NUNITS (opmode), n_elts));\n+      gcc_assert (GET_MODE (op) == op_mode);\n \n-      rtvec v = rtvec_alloc (n_elts);\n-      unsigned int i;\n+      rtx_vector_builder builder;\n+      if (!builder.new_unary_operation (mode, op, false))\n+\treturn 0;\n \n-      for (i = 0; i < n_elts; i++)\n+      unsigned int count = builder.encoded_nelts ();\n+      for (unsigned int i = 0; i < count; i++)\n \t{\n \t  rtx x = simplify_unary_operation (code, GET_MODE_INNER (mode),\n \t\t\t\t\t    CONST_VECTOR_ELT (op, i),\n-\t\t\t\t\t    GET_MODE_INNER (opmode));\n+\t\t\t\t\t    GET_MODE_INNER (op_mode));\n \t  if (!x || !valid_for_const_vector_p (mode, x))\n \t    return 0;\n-\t  RTVEC_ELT (v, i) = x;\n+\t  builder.quick_push (x);\n \t}\n-      return gen_rtx_CONST_VECTOR (mode, v);\n+      return builder.build ();\n     }\n \n   /* The order of these tests is critical so that, for example, we don't\n@@ -4059,6 +4056,27 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n   return 0;\n }\n \n+/* Return true if binary operation OP distributes over addition in operand\n+   OPNO, with the other operand being held constant.  OPNO counts from 1.  */\n+\n+static bool\n+distributes_over_addition_p (rtx_code op, int opno)\n+{\n+  switch (op)\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+      return true;\n+\n+    case ASHIFT:\n+      return opno == 1;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n rtx\n simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n \t\t\t\t rtx op0, rtx op1)\n@@ -4068,26 +4086,45 @@ simplify_const_binary_operation (enum rtx_code code, machine_mode mode,\n       && GET_CODE (op0) == CONST_VECTOR\n       && GET_CODE (op1) == CONST_VECTOR)\n     {\n-      unsigned int n_elts;\n-      if (!CONST_VECTOR_NUNITS (op0).is_constant (&n_elts))\n-\treturn NULL_RTX;\n-\n-      gcc_assert (known_eq (n_elts, CONST_VECTOR_NUNITS (op1)));\n-      gcc_assert (known_eq (n_elts, GET_MODE_NUNITS (mode)));\n-      rtvec v = rtvec_alloc (n_elts);\n-      unsigned int i;\n+      bool step_ok_p;\n+      if (CONST_VECTOR_STEPPED_P (op0)\n+\t  && CONST_VECTOR_STEPPED_P (op1))\n+\t/* We can operate directly on the encoding if:\n+\n+\t      a3 - a2 == a2 - a1 && b3 - b2 == b2 - b1\n+\t    implies\n+\t      (a3 op b3) - (a2 op b2) == (a2 op b2) - (a1 op b1)\n+\n+\t   Addition and subtraction are the supported operators\n+\t   for which this is true.  */\n+\tstep_ok_p = (code == PLUS || code == MINUS);\n+      else if (CONST_VECTOR_STEPPED_P (op0))\n+\t/* We can operate directly on stepped encodings if:\n+\n+\t     a3 - a2 == a2 - a1\n+\t   implies:\n+\t     (a3 op c) - (a2 op c) == (a2 op c) - (a1 op c)\n+\n+\t   which is true if (x -> x op c) distributes over addition.  */\n+\tstep_ok_p = distributes_over_addition_p (code, 1);\n+      else\n+\t/* Similarly in reverse.  */\n+\tstep_ok_p = distributes_over_addition_p (code, 2);\n+      rtx_vector_builder builder;\n+      if (!builder.new_binary_operation (mode, op0, op1, step_ok_p))\n+\treturn 0;\n \n-      for (i = 0; i < n_elts; i++)\n+      unsigned int count = builder.encoded_nelts ();\n+      for (unsigned int i = 0; i < count; i++)\n \t{\n \t  rtx x = simplify_binary_operation (code, GET_MODE_INNER (mode),\n \t\t\t\t\t     CONST_VECTOR_ELT (op0, i),\n \t\t\t\t\t     CONST_VECTOR_ELT (op1, i));\n \t  if (!x || !valid_for_const_vector_p (mode, x))\n \t    return 0;\n-\t  RTVEC_ELT (v, i) = x;\n+\t  builder.quick_push (x);\n \t}\n-\n-      return gen_rtx_CONST_VECTOR (mode, v);\n+      return builder.build ();\n     }\n \n   if (VECTOR_MODE_P (mode)\n@@ -7012,6 +7049,58 @@ test_vector_ops_series (machine_mode mode, rtx scalar_reg)\n   ASSERT_RTX_EQ (series_0_m1,\n \t\t simplify_binary_operation (VEC_SERIES, mode, const0_rtx,\n \t\t\t\t\t    constm1_rtx));\n+\n+  /* Test NEG on constant vector series.  */\n+  ASSERT_RTX_EQ (series_0_m1,\n+\t\t simplify_unary_operation (NEG, mode, series_0_1, mode));\n+  ASSERT_RTX_EQ (series_0_1,\n+\t\t simplify_unary_operation (NEG, mode, series_0_m1, mode));\n+\n+  /* Test PLUS and MINUS on constant vector series.  */\n+  rtx scalar2 = gen_int_mode (2, inner_mode);\n+  rtx scalar3 = gen_int_mode (3, inner_mode);\n+  rtx series_1_1 = gen_const_vec_series (mode, const1_rtx, const1_rtx);\n+  rtx series_0_2 = gen_const_vec_series (mode, const0_rtx, scalar2);\n+  rtx series_1_3 = gen_const_vec_series (mode, const1_rtx, scalar3);\n+  ASSERT_RTX_EQ (series_1_1,\n+\t\t simplify_binary_operation (PLUS, mode, series_0_1,\n+\t\t\t\t\t    CONST1_RTX (mode)));\n+  ASSERT_RTX_EQ (series_0_m1,\n+\t\t simplify_binary_operation (PLUS, mode, CONST0_RTX (mode),\n+\t\t\t\t\t    series_0_m1));\n+  ASSERT_RTX_EQ (series_1_3,\n+\t\t simplify_binary_operation (PLUS, mode, series_1_1,\n+\t\t\t\t\t    series_0_2));\n+  ASSERT_RTX_EQ (series_0_1,\n+\t\t simplify_binary_operation (MINUS, mode, series_1_1,\n+\t\t\t\t\t    CONST1_RTX (mode)));\n+  ASSERT_RTX_EQ (series_1_1,\n+\t\t simplify_binary_operation (MINUS, mode, CONST1_RTX (mode),\n+\t\t\t\t\t    series_0_m1));\n+  ASSERT_RTX_EQ (series_1_1,\n+\t\t simplify_binary_operation (MINUS, mode, series_1_3,\n+\t\t\t\t\t    series_0_2));\n+\n+  /* Test MULT between constant vectors.  */\n+  rtx vec2 = gen_const_vec_duplicate (mode, scalar2);\n+  rtx vec3 = gen_const_vec_duplicate (mode, scalar3);\n+  rtx scalar9 = gen_int_mode (9, inner_mode);\n+  rtx series_3_9 = gen_const_vec_series (mode, scalar3, scalar9);\n+  ASSERT_RTX_EQ (series_0_2,\n+\t\t simplify_binary_operation (MULT, mode, series_0_1, vec2));\n+  ASSERT_RTX_EQ (series_3_9,\n+\t\t simplify_binary_operation (MULT, mode, vec3, series_1_3));\n+  if (!GET_MODE_NUNITS (mode).is_constant ())\n+    ASSERT_FALSE (simplify_binary_operation (MULT, mode, series_0_1,\n+\t\t\t\t\t     series_0_1));\n+\n+  /* Test ASHIFT between constant vectors.  */\n+  ASSERT_RTX_EQ (series_0_2,\n+\t\t simplify_binary_operation (ASHIFT, mode, series_0_1,\n+\t\t\t\t\t    CONST1_RTX (mode)));\n+  if (!GET_MODE_NUNITS (mode).is_constant ())\n+    ASSERT_FALSE (simplify_binary_operation (ASHIFT, mode, CONST1_RTX (mode),\n+\t\t\t\t\t     series_0_1));\n }\n \n /* Verify simplify_merge_mask works correctly.  */"}, {"sha": "d02fb950c5e70addd65d9cbefef9e133139ac9df", "filename": "gcc/tree-vector-builder.c", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Ftree-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Ftree-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.c?ref=4ce6ab6889446984fd7017e2150962eb4550a7ee", "patch": "@@ -24,103 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const.h\"\n #include \"tree-vector-builder.h\"\n \n-/* Try to start building a new vector of type TYPE that holds the result of\n-   a unary operation on VECTOR_CST T.  ALLOW_STEPPED_P is true if the\n-   operation can handle stepped encodings directly, without having to\n-   expand the full sequence.\n-\n-   Return true if the operation is possible, which it always is when\n-   ALLOW_STEPPED_P is true.  Leave the builder unchanged otherwise.  */\n-\n-bool\n-tree_vector_builder::new_unary_operation (tree type, tree t,\n-\t\t\t\t\t  bool allow_stepped_p)\n-{\n-  poly_uint64 full_nelts = TYPE_VECTOR_SUBPARTS (type);\n-  gcc_assert (known_eq (full_nelts, TYPE_VECTOR_SUBPARTS (TREE_TYPE (t))));\n-  unsigned int npatterns = VECTOR_CST_NPATTERNS (t);\n-  unsigned int nelts_per_pattern = VECTOR_CST_NELTS_PER_PATTERN (t);\n-  if (!allow_stepped_p && nelts_per_pattern > 2)\n-    {\n-      if (!full_nelts.is_constant ())\n-\treturn false;\n-      npatterns = full_nelts.to_constant ();\n-      nelts_per_pattern = 1;\n-    }\n-  new_vector (type, npatterns, nelts_per_pattern);\n-  return true;\n-}\n-\n-/* Try to start building a new vector of type TYPE that holds the result of\n-   a binary operation on VECTOR_CSTs T1 and T2.  ALLOW_STEPPED_P is true if\n-   the operation can handle stepped encodings directly, without having to\n-   expand the full sequence.\n-\n-   Return true if the operation is possible.  Leave the builder unchanged\n-   otherwise.  */\n-\n-bool\n-tree_vector_builder::new_binary_operation (tree type, tree t1, tree t2,\n-\t\t\t\t\t   bool allow_stepped_p)\n-{\n-  poly_uint64 full_nelts = TYPE_VECTOR_SUBPARTS (type);\n-  gcc_assert (known_eq (full_nelts, TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1)))\n-\t      && known_eq (full_nelts, TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2))));\n-  /* Conceptually we split the patterns in T1 and T2 until we have\n-     an equal number for both.  Each split pattern requires the same\n-     number of elements per pattern as the original.  E.g. splitting:\n-\n-       { 1, 2, 3, ... }\n-\n-     into two gives:\n-\n-       { 1, 3, 5, ... }\n-       { 2, 4, 6, ... }\n-\n-     while splitting:\n-\n-       { 1, 0, ... }\n-\n-     into two gives:\n-\n-       { 1, 0, ... }\n-       { 0, 0, ... }.  */\n-  unsigned int npatterns = least_common_multiple (VECTOR_CST_NPATTERNS (t1),\n-\t\t\t\t\t\t  VECTOR_CST_NPATTERNS (t2));\n-  unsigned int nelts_per_pattern = MAX (VECTOR_CST_NELTS_PER_PATTERN (t1),\n-\t\t\t\t\tVECTOR_CST_NELTS_PER_PATTERN (t2));\n-  if (!allow_stepped_p && nelts_per_pattern > 2)\n-    {\n-      if (!full_nelts.is_constant ())\n-\treturn false;\n-      npatterns = full_nelts.to_constant ();\n-      nelts_per_pattern = 1;\n-    }\n-  new_vector (type, npatterns, nelts_per_pattern);\n-  return true;\n-}\n-\n-/* Return the number of elements that the caller needs to operate on in\n-   order to handle a binary operation on VECTOR_CSTs T1 and T2.  This static\n-   function is used instead of new_binary_operation if the result of the\n-   operation is not a VECTOR_CST.  */\n-\n-unsigned int\n-tree_vector_builder::binary_encoded_nelts (tree t1, tree t2)\n-{\n-  poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1));\n-  gcc_assert (known_eq (nelts, TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2))));\n-  /* See new_binary_operation for details.  */\n-  unsigned int npatterns = least_common_multiple (VECTOR_CST_NPATTERNS (t1),\n-\t\t\t\t\t\t  VECTOR_CST_NPATTERNS (t2));\n-  unsigned int nelts_per_pattern = MAX (VECTOR_CST_NELTS_PER_PATTERN (t1),\n-\t\t\t\t\tVECTOR_CST_NELTS_PER_PATTERN (t2));\n-  unsigned HOST_WIDE_INT const_nelts;\n-  if (nelts.is_constant (&const_nelts))\n-    return MIN (npatterns * nelts_per_pattern, const_nelts);\n-  return npatterns * nelts_per_pattern;\n-}\n-\n /* Return a vector element with the value BASE + FACTOR * STEP.  */\n \n tree"}, {"sha": "6a4cf6fbe01e1880c41fa3f756dd1deaf46d9487", "filename": "gcc/tree-vector-builder.h", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Ftree-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Ftree-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.h?ref=4ce6ab6889446984fd7017e2150962eb4550a7ee", "patch": "@@ -24,10 +24,11 @@ along with GCC; see the file COPYING3.  If not see\n \n /* This class is used to build VECTOR_CSTs from a sequence of elements.\n    See vector_builder for more details.  */\n-class tree_vector_builder : public vector_builder<tree, tree_vector_builder>\n+class tree_vector_builder : public vector_builder<tree, tree,\n+\t\t\t\t\t\t  tree_vector_builder>\n {\n-  typedef vector_builder<tree, tree_vector_builder> parent;\n-  friend class vector_builder<tree, tree_vector_builder>;\n+  typedef vector_builder<tree, tree, tree_vector_builder> parent;\n+  friend class vector_builder<tree, tree, tree_vector_builder>;\n \n public:\n   tree_vector_builder () : m_type (0) {}\n@@ -37,10 +38,6 @@ class tree_vector_builder : public vector_builder<tree, tree_vector_builder>\n   tree type () const { return m_type; }\n \n   void new_vector (tree, unsigned int, unsigned int);\n-  bool new_unary_operation (tree, tree, bool);\n-  bool new_binary_operation (tree, tree, tree, bool);\n-\n-  static unsigned int binary_encoded_nelts (tree, tree);\n \n private:\n   bool equal_p (const_tree, const_tree) const;\n@@ -51,6 +48,15 @@ class tree_vector_builder : public vector_builder<tree, tree_vector_builder>\n   bool can_elide_p (const_tree) const;\n   void note_representative (tree *, tree);\n \n+  static poly_uint64 shape_nelts (const_tree t)\n+    { return TYPE_VECTOR_SUBPARTS (t); }\n+  static poly_uint64 nelts_of (const_tree t)\n+    { return VECTOR_CST_NELTS (t); }\n+  static unsigned int npatterns_of (const_tree t)\n+    { return VECTOR_CST_NPATTERNS (t); }\n+  static unsigned int nelts_per_pattern_of (const_tree t)\n+    { return VECTOR_CST_NELTS_PER_PATTERN (t); }\n+\n   tree m_type;\n };\n "}, {"sha": "37911ac693dbc68b2b0a212d253eb54ce58b6b30", "filename": "gcc/vector-builder.h", "status": "modified", "additions": 172, "deletions": 37, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Fvector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce6ab6889446984fd7017e2150962eb4550a7ee/gcc%2Fvector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvector-builder.h?ref=4ce6ab6889446984fd7017e2150962eb4550a7ee", "patch": "@@ -45,8 +45,11 @@ along with GCC; see the file COPYING3.  If not see\n       variable-length vectors.  finalize () then canonicalizes the encoding\n       to a simpler form if possible.\n \n-   The derived class Derived provides this functionality for specific Ts.\n-   Derived needs to provide the following interface:\n+   Shape is the type that specifies the number of elements in the vector\n+   and (where relevant) the type of each element.\n+\n+   The derived class Derived provides the functionality of this class\n+   for specific Ts.  Derived needs to provide the following interface:\n \n       bool equal_p (T elt1, T elt2) const;\n \n@@ -82,9 +85,30 @@ along with GCC; see the file COPYING3.  If not see\n \n \t  Record that ELT2 is being elided, given that ELT1_PTR points to\n \t  the last encoded element for the containing pattern.  This is\n-\t  again provided for TREE_OVERFLOW handling.  */\n+\t  again provided for TREE_OVERFLOW handling.\n+\n+      static poly_uint64 shape_nelts (Shape shape);\n+\n+\t  Return the number of elements in SHAPE.\n+\n+    The class provides additional functionality for the case in which\n+    T can describe a vector constant as well as an individual element.\n+    This functionality requires:\n+\n+      static poly_uint64 nelts_of (T x);\n+\n+\t  Return the number of elements in vector constant X.\n \n-template<typename T, typename Derived>\n+      static unsigned int npatterns_of (T x);\n+\n+\t  Return the number of patterns used to encode vector constant X.\n+\n+      static unsigned int nelts_per_pattern_of (T x);\n+\n+\t  Return the number of elements used to encode each pattern\n+\t  in vector constant X.  */\n+\n+template<typename T, typename Shape, typename Derived>\n class vector_builder : public auto_vec<T, 32>\n {\n public:\n@@ -101,8 +125,13 @@ class vector_builder : public auto_vec<T, 32>\n   bool operator == (const Derived &) const;\n   bool operator != (const Derived &x) const { return !operator == (x); }\n \n+  bool new_unary_operation (Shape, T, bool);\n+  bool new_binary_operation (Shape, T, T, bool);\n+\n   void finalize ();\n \n+  static unsigned int binary_encoded_nelts (T, T);\n+\n protected:\n   void new_vector (poly_uint64, unsigned int, unsigned int);\n   void reshape (unsigned int, unsigned int);\n@@ -121,16 +150,16 @@ class vector_builder : public auto_vec<T, 32>\n   unsigned int m_nelts_per_pattern;\n };\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n inline const Derived *\n-vector_builder<T, Derived>::derived () const\n+vector_builder<T, Shape, Derived>::derived () const\n {\n   return static_cast<const Derived *> (this);\n }\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n inline\n-vector_builder<T, Derived>::vector_builder ()\n+vector_builder<T, Shape, Derived>::vector_builder ()\n   : m_full_nelts (0),\n     m_npatterns (0),\n     m_nelts_per_pattern (0)\n@@ -140,30 +169,30 @@ vector_builder<T, Derived>::vector_builder ()\n    starts with these explicitly-encoded elements and may contain additional\n    elided elements.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n inline unsigned int\n-vector_builder<T, Derived>::encoded_nelts () const\n+vector_builder<T, Shape, Derived>::encoded_nelts () const\n {\n   return m_npatterns * m_nelts_per_pattern;\n }\n \n /* Return true if every element of the vector is explicitly encoded.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n inline bool\n-vector_builder<T, Derived>::encoded_full_vector_p () const\n+vector_builder<T, Shape, Derived>::encoded_full_vector_p () const\n {\n   return known_eq (m_npatterns * m_nelts_per_pattern, m_full_nelts);\n }\n \n /* Start building a vector that has FULL_NELTS elements.  Initially\n    encode it using NPATTERNS patterns with NELTS_PER_PATTERN each.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n void\n-vector_builder<T, Derived>::new_vector (poly_uint64 full_nelts,\n-\t\t\t\t\tunsigned int npatterns,\n-\t\t\t\t\tunsigned int nelts_per_pattern)\n+vector_builder<T, Shape, Derived>::new_vector (poly_uint64 full_nelts,\n+\t\t\t\t\t       unsigned int npatterns,\n+\t\t\t\t\t       unsigned int nelts_per_pattern)\n {\n   m_full_nelts = full_nelts;\n   m_npatterns = npatterns;\n@@ -175,9 +204,9 @@ vector_builder<T, Derived>::new_vector (poly_uint64 full_nelts,\n /* Return true if this vector and OTHER have the same elements and\n    are encoded in the same way.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n bool\n-vector_builder<T, Derived>::operator == (const Derived &other) const\n+vector_builder<T, Shape, Derived>::operator == (const Derived &other) const\n {\n   if (maybe_ne (m_full_nelts, other.m_full_nelts)\n       || m_npatterns != other.m_npatterns\n@@ -195,9 +224,9 @@ vector_builder<T, Derived>::operator == (const Derived &other) const\n /* Return the value of vector element I, which might or might not be\n    encoded explicitly.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n T\n-vector_builder<T, Derived>::elt (unsigned int i) const\n+vector_builder<T, Shape, Derived>::elt (unsigned int i) const\n {\n   /* First handle elements that are already present in the underlying\n      vector, regardless of whether they're part of the encoding or not.  */\n@@ -225,12 +254,118 @@ vector_builder<T, Derived>::elt (unsigned int i) const\n \t\t\t\t derived ()->step (prev, final));\n }\n \n+/* Try to start building a new vector of shape SHAPE that holds the result of\n+   a unary operation on vector constant VEC.  ALLOW_STEPPED_P is true if the\n+   operation can handle stepped encodings directly, without having to expand\n+   the full sequence.\n+\n+   Return true if the operation is possible, which it always is when\n+   ALLOW_STEPPED_P is true.  Leave the builder unchanged otherwise.  */\n+\n+template<typename T, typename Shape, typename Derived>\n+bool\n+vector_builder<T, Shape, Derived>::new_unary_operation (Shape shape, T vec,\n+\t\t\t\t\t\t\tbool allow_stepped_p)\n+{\n+  poly_uint64 full_nelts = Derived::shape_nelts (shape);\n+  gcc_assert (known_eq (full_nelts, Derived::nelts_of (vec)));\n+  unsigned int npatterns = Derived::npatterns_of (vec);\n+  unsigned int nelts_per_pattern = Derived::nelts_per_pattern_of (vec);\n+  if (!allow_stepped_p && nelts_per_pattern > 2)\n+    {\n+      if (!full_nelts.is_constant ())\n+\treturn false;\n+      npatterns = full_nelts.to_constant ();\n+      nelts_per_pattern = 1;\n+    }\n+  derived ()->new_vector (shape, npatterns, nelts_per_pattern);\n+  return true;\n+}\n+\n+/* Try to start building a new vector of shape SHAPE that holds the result of\n+   a binary operation on vector constants VEC1 and VEC2.  ALLOW_STEPPED_P is\n+   true if the operation can handle stepped encodings directly, without\n+   having to expand the full sequence.\n+\n+   Return true if the operation is possible.  Leave the builder unchanged\n+   otherwise.  */\n+\n+template<typename T, typename Shape, typename Derived>\n+bool\n+vector_builder<T, Shape, Derived>::new_binary_operation (Shape shape,\n+\t\t\t\t\t\t\t T vec1, T vec2,\n+\t\t\t\t\t\t\t bool allow_stepped_p)\n+{\n+  poly_uint64 full_nelts = Derived::shape_nelts (shape);\n+  gcc_assert (known_eq (full_nelts, Derived::nelts_of (vec1))\n+\t      && known_eq (full_nelts, Derived::nelts_of (vec2)));\n+  /* Conceptually we split the patterns in VEC1 and VEC2 until we have\n+     an equal number for both.  Each split pattern requires the same\n+     number of elements per pattern as the original.  E.g. splitting:\n+\n+       { 1, 2, 3, ... }\n+\n+     into two gives:\n+\n+       { 1, 3, 5, ... }\n+       { 2, 4, 6, ... }\n+\n+     while splitting:\n+\n+       { 1, 0, ... }\n+\n+     into two gives:\n+\n+       { 1, 0, ... }\n+       { 0, 0, ... }.  */\n+  unsigned int npatterns\n+    = least_common_multiple (Derived::npatterns_of (vec1),\n+\t\t\t     Derived::npatterns_of (vec2));\n+  unsigned int nelts_per_pattern\n+    = MAX (Derived::nelts_per_pattern_of (vec1),\n+\t   Derived::nelts_per_pattern_of (vec2));\n+  if (!allow_stepped_p && nelts_per_pattern > 2)\n+    {\n+      if (!full_nelts.is_constant ())\n+\treturn false;\n+      npatterns = full_nelts.to_constant ();\n+      nelts_per_pattern = 1;\n+    }\n+  derived ()->new_vector (shape, npatterns, nelts_per_pattern);\n+  return true;\n+}\n+\n+/* Return the number of elements that the caller needs to operate on in\n+   order to handle a binary operation on vector constants VEC1 and VEC2.\n+   This static function is used instead of new_binary_operation if the\n+   result of the operation is not a constant vector.  */\n+\n+template<typename T, typename Shape, typename Derived>\n+unsigned int\n+vector_builder<T, Shape, Derived>::binary_encoded_nelts (T vec1, T vec2)\n+{\n+  poly_uint64 nelts = Derived::nelts_of (vec1);\n+  gcc_assert (known_eq (nelts, Derived::nelts_of (vec2)));\n+  /* See new_binary_operation for details.  */\n+  unsigned int npatterns\n+    = least_common_multiple (Derived::npatterns_of (vec1),\n+\t\t\t     Derived::npatterns_of (vec2));\n+  unsigned int nelts_per_pattern\n+    = MAX (Derived::nelts_per_pattern_of (vec1),\n+\t   Derived::nelts_per_pattern_of (vec2));\n+  unsigned HOST_WIDE_INT const_nelts;\n+  if (nelts.is_constant (&const_nelts))\n+    return MIN (npatterns * nelts_per_pattern, const_nelts);\n+  return npatterns * nelts_per_pattern;\n+}\n+\n /* Return the number of leading duplicate elements in the range\n    [START:END:STEP].  The value is always at least 1.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n unsigned int\n-vector_builder<T, Derived>::count_dups (int start, int end, int step) const\n+vector_builder<T, Shape, Derived>::count_dups (int start, int end,\n+\t\t\t\t\t       int step) const\n {\n   gcc_assert ((end - start) % step == 0);\n \n@@ -245,10 +380,10 @@ vector_builder<T, Derived>::count_dups (int start, int end, int step) const\n /* Change the encoding to NPATTERNS patterns of NELTS_PER_PATTERN each,\n    but without changing the underlying vector.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n void\n-vector_builder<T, Derived>::reshape (unsigned int npatterns,\n-\t\t\t\t     unsigned int nelts_per_pattern)\n+vector_builder<T, Shape, Derived>::reshape (unsigned int npatterns,\n+\t\t\t\t\t    unsigned int nelts_per_pattern)\n {\n   unsigned int old_encoded_nelts = encoded_nelts ();\n   unsigned int new_encoded_nelts = npatterns * nelts_per_pattern;\n@@ -268,11 +403,11 @@ vector_builder<T, Derived>::reshape (unsigned int npatterns,\n /* Return true if elements [START, END) contain a repeating sequence of\n    STEP elements.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n bool\n-vector_builder<T, Derived>::repeating_sequence_p (unsigned int start,\n-\t\t\t\t\t\t  unsigned int end,\n-\t\t\t\t\t\t  unsigned int step)\n+vector_builder<T, Shape, Derived>::repeating_sequence_p (unsigned int start,\n+\t\t\t\t\t\t\t unsigned int end,\n+\t\t\t\t\t\t\t unsigned int step)\n {\n   for (unsigned int i = start; i < end - step; ++i)\n     if (!derived ()->equal_p ((*this)[i], (*this)[i + step]))\n@@ -283,11 +418,11 @@ vector_builder<T, Derived>::repeating_sequence_p (unsigned int start,\n /* Return true if elements [START, END) contain STEP interleaved linear\n    series.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n bool\n-vector_builder<T, Derived>::stepped_sequence_p (unsigned int start,\n-\t\t\t\t\t\tunsigned int end,\n-\t\t\t\t\t\tunsigned int step)\n+vector_builder<T, Shape, Derived>::stepped_sequence_p (unsigned int start,\n+\t\t\t\t\t\t       unsigned int end,\n+\t\t\t\t\t\t       unsigned int step)\n {\n   if (!derived ()->allow_steps_p ())\n     return false;\n@@ -316,9 +451,9 @@ vector_builder<T, Derived>::stepped_sequence_p (unsigned int start,\n /* Try to change the number of encoded patterns to NPATTERNS, returning\n    true on success.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n bool\n-vector_builder<T, Derived>::try_npatterns (unsigned int npatterns)\n+vector_builder<T, Shape, Derived>::try_npatterns (unsigned int npatterns)\n {\n   if (m_nelts_per_pattern == 1)\n     {\n@@ -369,9 +504,9 @@ vector_builder<T, Derived>::try_npatterns (unsigned int npatterns)\n \n /* Replace the current encoding with the canonical form.  */\n \n-template<typename T, typename Derived>\n+template<typename T, typename Shape, typename Derived>\n void\n-vector_builder<T, Derived>::finalize ()\n+vector_builder<T, Shape, Derived>::finalize ()\n {\n   /* The encoding requires the same number of elements to come from each\n      pattern.  */"}]}