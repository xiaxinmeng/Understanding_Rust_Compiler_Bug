{"sha": "c5defebb1327cff5dbb383d5cf14d9a719994b16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkZWZlYmIxMzI3Y2ZmNWRiYjM4M2Q1Y2YxNGQ5YTcxOTk5NGIxNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-05T22:44:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-05T22:44:18Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r691", "tree": {"sha": "01c9f4995fc892acdb2de436c527a89bc791eaba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01c9f4995fc892acdb2de436c527a89bc791eaba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5defebb1327cff5dbb383d5cf14d9a719994b16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5defebb1327cff5dbb383d5cf14d9a719994b16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5defebb1327cff5dbb383d5cf14d9a719994b16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5defebb1327cff5dbb383d5cf14d9a719994b16/comments", "author": null, "committer": null, "parents": [{"sha": "5f61baa4801a3ac976cca28086025bd46023d0ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f61baa4801a3ac976cca28086025bd46023d0ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f61baa4801a3ac976cca28086025bd46023d0ba"}], "stats": {"total": 87, "additions": 78, "deletions": 9}, "files": [{"sha": "3d8712e2a92e69de07f24e9e26859360db83941f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5defebb1327cff5dbb383d5cf14d9a719994b16/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5defebb1327cff5dbb383d5cf14d9a719994b16/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c5defebb1327cff5dbb383d5cf14d9a719994b16", "patch": "@@ -516,6 +516,9 @@ scc_comparison_operator (op, mode)\n       && (cc_mode != CCUNSmode))\n     return 0;\n \n+  if (cc_mode == CCEQmode && code != EQ && code != NE)\n+    return 0;\n+\n   return 1;\n }\n \f\n@@ -607,6 +610,12 @@ ccr_bit (op, scc_p)\n   cc_regnum = REGNO (XEXP (op, 0));\n   base_bit = 4 * (cc_regnum - 68);\n \n+  /* In CCEQmode cases we have made sure that the result is always in the\n+     third bit of the CR field.  */\n+\n+  if (cc_mode == CCEQmode)\n+    return base_bit + 3;\n+\n   switch (code)\n     {\n     case NE:\n@@ -817,6 +826,14 @@ print_operand (file, x, code)\n \tfprintf (file, \"%d\", 32 - 4 * (REGNO (x) - 68));\n       return;\n \n+    case 'E':\n+      /* X is a CR register.  Print the number of the third bit of the CR */\n+      if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%E value\");\n+\n+      fprintf(file, \"%d\", 4 * (REGNO (x) - 68) + 3);\n+      break;\n+\n     case 'R':\n       /* X is a CR register.  Print the mask for `mtcrf'.  */\n       if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))"}, {"sha": "8ef2cd06e60f2fda5866094b4ddbefd8c5811d36", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5defebb1327cff5dbb383d5cf14d9a719994b16/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5defebb1327cff5dbb383d5cf14d9a719994b16/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c5defebb1327cff5dbb383d5cf14d9a719994b16", "patch": "@@ -1245,22 +1245,26 @@ struct rs6000_args {int words, fregno, nargs_prototype; };\n /* Add any extra modes needed to represent the condition code.\n \n    For the RS/6000, we need separate modes when unsigned (logical) comparisons\n-   are being done and we need a separate mode for floating-point.  */\n+   are being done and we need a separate mode for floating-point.  We also\n+   use a mode for the case when we are comparing the results of two\n+   comparisons.  */\n \n-#define EXTRA_CC_MODES CCUNSmode, CCFPmode\n+#define EXTRA_CC_MODES CCUNSmode, CCFPmode, CCEQmode\n \n /* Define the names for the modes specified above.  */\n-#define EXTRA_CC_NAMES \"CCUNS\", \"CCFP\"\n+#define EXTRA_CC_NAMES \"CCUNS\", \"CCFP\", \"CCEQ\"\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point, CCFPmode\n-   should be used.  CC_NOOVmode should be used when the first operand is a\n-   PLUS, MINUS, or NEG.  CCmode should be used when no special processing is\n-   needed.  */\n+   should be used.  CCUNSmode should be used for unsigned comparisons.\n+   CCEQmode should be used when we are doing an inequality comparison on\n+   the result of a comparison. CCmode should be used in all other cases.  */\n+\n #define SELECT_CC_MODE(OP,X) \\\n   (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode\t\\\n-   : ((OP) == GTU || (OP) == LTU || (OP) == GEU || (OP) == LEU\t\\\n-      ? CCUNSmode : CCmode))\n+   : (OP) == GTU || (OP) == LTU || (OP) == GEU || (OP) == LEU ? CCUNSmode \\\n+   : (((OP) == EQ || (OP) == NE) && GET_RTX_CLASS (GET_CODE (X)) == '<'   \\\n+      ? CCEQmode : CCmode))\n \n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here"}, {"sha": "e9edc98090be939f66605084bd678c96dd6bdfc2", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5defebb1327cff5dbb383d5cf14d9a719994b16/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5defebb1327cff5dbb383d5cf14d9a719994b16/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c5defebb1327cff5dbb383d5cf14d9a719994b16", "patch": "@@ -3294,7 +3294,9 @@\n ;; way the machine works.\n ;;\n ;; Note that this is probably faster if we can put an insn between the\n-;; mfcr and rlinm, but this is tricky.  Let's leave it for now.\n+;; mfcr and rlinm, but this is tricky.  Let's leave it for now.  In most\n+;; cases the insns below which don't use an intermediate CR field will\n+;; be used instead.\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n \t(match_operator:SI 1 \"scc_comparison_operator\"\n@@ -3369,6 +3371,52 @@\n }\"\n   [(set_attr \"type\" \"delayed_compare\")])\n \n+;; If we are comparing the result of two comparisons, this can be done\n+;; using creqv or crxor.\n+\n+(define_insn \"\"\n+  [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCEQ (match_operator 1 \"scc_comparison_operator\"\n+\t\t\t      [(match_operand 2 \"cc_reg_operand\" \"y\")\n+\t\t\t       (const_int 0)])\n+\t\t      (match_operator 3 \"scc_comparison_operator\"\n+\t\t\t      [(match_operand 4 \"cc_reg_operand\" \"y\")\n+\t\t\t       (const_int 0)])))]\n+  \"REGNO (operands[2]) != REGNO (operands[4])\"\n+  \"*\n+{\n+  enum rtx_code code1, code2;\n+\n+  code1 = GET_CODE (operands[1]);\n+  code2 = GET_CODE (operands[3]);\n+\n+  if ((code1 == EQ || code1 == LT || code1 == GT\n+       || code1 == LTU || code1 == GTU\n+       || (code1 != NE && GET_MODE (operands[2]) == CCFPmode))\n+      !=\n+      (code2 == EQ || code2 == LT || code2 == GT\n+       || code2 == LTU || code2 == GTU\n+       || (code2 != NE && GET_MODE (operands[4]) == CCFPmode)))\n+    return \\\"%C1%C3crxor %E0,%j1,%j3\\\";\n+  else\n+    return \\\"%C1%C3creqv %E0,%j1,%j3\\\";\n+}\")\n+\n+;; There is a 3 cycle delay between consecutive mfcr instructions\n+;; so it is useful to combine 2 scc instructions to use only one mfcr.\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"gen_reg_operand\" \"=r\")\n+\t(match_operator:SI 1 \"scc_comparison_operator\"\n+\t\t\t   [(match_operand 2 \"cc_reg_operand\" \"y\")\n+\t\t\t    (const_int 0)]))\n+   (set (match_operand:SI 3 \"gen_reg_operand\" \"=r\")\n+\t(match_operator:SI 4 \"scc_comparison_operator\"\n+\t\t\t   [(match_operand 5 \"cc_reg_operand\" \"y\")\n+\t\t\t    (const_int 0)]))]\n+   \"REGNO (operands[2]) != REGNO (operands[5])\"\n+   \"%D1%D4mfcr %3\\;rlinm %0,%3,%J1,31,31\\;rlinm %3,%3,%J4,31,31\")\n+\n ;; There are some scc insns that can be done directly, without a compare.\n ;; These are faster because they don't involve the communications between\n ;; the FXU and branch units.   In fact, we will be replacing all of the"}]}