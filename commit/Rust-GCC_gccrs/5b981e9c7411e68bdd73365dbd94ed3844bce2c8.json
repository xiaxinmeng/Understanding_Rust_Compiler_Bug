{"sha": "5b981e9c7411e68bdd73365dbd94ed3844bce2c8", "node_id": "C_kwDOANBUbNoAKDViOTgxZTljNzQxMWU2OGJkZDczMzY1ZGJkOTRlZDM4NDRiY2UyYzg", "commit": {"author": {"name": "Joel Phillips", "email": "simplytheother@gmail.com", "date": "2022-10-21T11:35:58Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:04Z"}, "message": "gccrs: Add Rust AST visitors\n\nThis patch contains the basic framework of our AST visitors, as well as\none aimed at pretty-printing and exporting these AST nodes.\n\n\tgcc/rust/\n\t* ast/rust-ast-dump.cc: New.\n\t* ast/rust-ast-dump.h: New.\n\t* ast/rust-ast-visitor.h: New.\n\t* ast/rust-cond-compilation.h: New.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n\nSigned-off-by: Joel Phillips <simplytheother@gmail.com>", "tree": {"sha": "ebb356f13a21d844351b84c5e3c892ad52561a3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebb356f13a21d844351b84c5e3c892ad52561a3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b981e9c7411e68bdd73365dbd94ed3844bce2c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b981e9c7411e68bdd73365dbd94ed3844bce2c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b981e9c7411e68bdd73365dbd94ed3844bce2c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d588754c8266d74c9eef1e38d2d96e66ff876107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d588754c8266d74c9eef1e38d2d96e66ff876107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d588754c8266d74c9eef1e38d2d96e66ff876107"}], "stats": {"total": 1818, "additions": 1818, "deletions": 0}, "files": [{"sha": "ad9ad0b7de72f9ff7be1be4509c5b03962fa6330", "filename": "gcc/rust/ast/rust-ast-dump.cc", "status": "added", "additions": 1089, "deletions": 0, "changes": 1089, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/gcc%2Frust%2Fast%2Frust-ast-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/gcc%2Frust%2Fast%2Frust-ast-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-dump.cc?ref=5b981e9c7411e68bdd73365dbd94ed3844bce2c8", "patch": "@@ -0,0 +1,1089 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-dump.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+Indent::Indent () : tabs (0) {}\n+\n+std::ostream &\n+operator<< (std::ostream &stream, const Indent &indent)\n+{\n+  return stream << std::string (indent.tabs, '\\t');\n+}\n+\n+void\n+Indent::increment ()\n+{\n+  tabs++;\n+}\n+\n+void\n+Indent::decrement ()\n+{\n+  rust_assert (tabs != 0);\n+  tabs--;\n+}\n+\n+Dump::Dump (std::ostream &stream) : stream (stream), indentation (Indent ()) {}\n+\n+void\n+Dump::go (AST::Crate &crate)\n+{\n+  for (auto &item : crate.items)\n+    {\n+      stream << indentation;\n+      item->accept_vis (*this);\n+      stream << \"\\n\";\n+    }\n+}\n+\n+void\n+Dump::go (AST::Item &item)\n+{\n+  item.accept_vis (*this);\n+}\n+\n+void\n+Dump::format_function_param (FunctionParam &param)\n+{\n+  param.get_pattern ()->accept_vis (*this);\n+  stream << \": \";\n+  param.get_type ()->accept_vis (*this);\n+}\n+\n+void\n+Dump::emit_attrib (const Attribute &attrib)\n+{\n+  stream << \"#\";\n+  stream << \"[\";\n+\n+  for (size_t i = 0; i < attrib.get_path ().get_segments ().size (); i++)\n+    {\n+      const auto &seg = attrib.get_path ().get_segments ().at (i);\n+      bool has_next = (i + 1) < attrib.get_path ().get_segments ().size ();\n+\n+      stream << seg.get_segment_name ();\n+      if (has_next)\n+\tstream << \"::\";\n+    }\n+\n+  if (attrib.has_attr_input ())\n+    {\n+      stream << \" = \";\n+\n+      bool is_literal = attrib.get_attr_input ().get_attr_input_type ()\n+\t\t\t== AST::AttrInput::AttrInputType::LITERAL;\n+      if (is_literal)\n+\t{\n+\t  auto &literal\n+\t    = static_cast<AST::AttrInputLiteral &> (attrib.get_attr_input ());\n+\t  const auto &value = literal.get_literal ().as_string ();\n+\n+\t  stream << \"\\\"\" << value << \"\\\"\";\n+\t}\n+      else\n+\t{\n+\t  stream << \"FIXME\";\n+\t}\n+    }\n+\n+  stream << \"]\";\n+}\n+\n+void\n+Dump::visit (Token &tok)\n+{}\n+\n+void\n+Dump::visit (DelimTokenTree &delim_tok_tree)\n+{}\n+\n+void\n+Dump::visit (AttrInputMetaItemContainer &input)\n+{}\n+\n+void\n+Dump::visit (IdentifierExpr &ident_expr)\n+{\n+  stream << ident_expr.get_ident ();\n+}\n+\n+void\n+Dump::visit (Lifetime &lifetime)\n+{}\n+\n+void\n+Dump::visit (LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+Dump::visit (ConstGenericParam &lifetime_param)\n+{}\n+\n+// rust-path.h\n+void\n+Dump::visit (PathInExpression &path)\n+{}\n+\n+void\n+Dump::visit (TypePathSegment &segment)\n+{}\n+\n+void\n+Dump::visit (TypePathSegmentGeneric &segment)\n+{}\n+\n+void\n+Dump::visit (TypePathSegmentFunction &segment)\n+{}\n+\n+void\n+Dump::visit (TypePath &path)\n+{\n+  stream << path.as_string ();\n+}\n+\n+void\n+Dump::visit (QualifiedPathInExpression &path)\n+{}\n+\n+void\n+Dump::visit (QualifiedPathInType &path)\n+{}\n+\n+// rust-expr.h\n+void\n+Dump::visit (LiteralExpr &expr)\n+{\n+  stream << expr.as_string ();\n+}\n+\n+void\n+Dump::visit (AttrInputLiteral &attr_input)\n+{}\n+\n+void\n+Dump::visit (MetaItemLitExpr &meta_item)\n+{}\n+\n+void\n+Dump::visit (MetaItemPathLit &meta_item)\n+{}\n+\n+void\n+Dump::visit (BorrowExpr &expr)\n+{}\n+\n+void\n+Dump::visit (DereferenceExpr &expr)\n+{}\n+\n+void\n+Dump::visit (ErrorPropagationExpr &expr)\n+{}\n+\n+void\n+Dump::visit (NegationExpr &expr)\n+{}\n+\n+void\n+Dump::visit (ArithmeticOrLogicalExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  stream << \" \";\n+\n+  switch (expr.get_expr_type ())\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+      stream << \"+\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+      stream << \"-\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      stream << \"*\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n+      stream << \"/\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::MODULUS:\n+      stream << \"%\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n+      stream << \"&\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n+      stream << \"|\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      stream << \"^\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      stream << \"<<\";\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      stream << \">>\";\n+      break;\n+    }\n+\n+  stream << \" \";\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+Dump::visit (ComparisonExpr &expr)\n+{}\n+\n+void\n+Dump::visit (LazyBooleanExpr &expr)\n+{}\n+\n+void\n+Dump::visit (TypeCastExpr &expr)\n+{}\n+\n+void\n+Dump::visit (AssignmentExpr &expr)\n+{}\n+\n+void\n+Dump::visit (CompoundAssignmentExpr &expr)\n+{}\n+\n+void\n+Dump::visit (GroupedExpr &expr)\n+{}\n+\n+void\n+Dump::visit (ArrayElemsValues &elems)\n+{}\n+\n+void\n+Dump::visit (ArrayElemsCopied &elems)\n+{}\n+\n+void\n+Dump::visit (ArrayExpr &expr)\n+{}\n+\n+void\n+Dump::visit (ArrayIndexExpr &expr)\n+{}\n+\n+void\n+Dump::visit (TupleExpr &expr)\n+{}\n+\n+void\n+Dump::visit (TupleIndexExpr &expr)\n+{}\n+\n+void\n+Dump::visit (StructExprStruct &expr)\n+{}\n+\n+void\n+Dump::visit (StructExprFieldIdentifier &field)\n+{}\n+\n+void\n+Dump::visit (StructExprFieldIdentifierValue &field)\n+{}\n+\n+void\n+Dump::visit (StructExprFieldIndexValue &field)\n+{}\n+\n+void\n+Dump::visit (StructExprStructFields &expr)\n+{}\n+\n+void\n+Dump::visit (StructExprStructBase &expr)\n+{}\n+\n+void\n+Dump::visit (CallExpr &expr)\n+{}\n+\n+void\n+Dump::visit (MethodCallExpr &expr)\n+{}\n+\n+void\n+Dump::visit (FieldAccessExpr &expr)\n+{}\n+\n+void\n+Dump::visit (ClosureExprInner &expr)\n+{}\n+\n+void\n+Dump::visit (BlockExpr &expr)\n+{\n+  stream << \"{\\n\";\n+  indentation.increment ();\n+\n+  for (auto &stmt : expr.get_statements ())\n+    {\n+      stream << indentation;\n+      stmt->accept_vis (*this);\n+      stream << \";\\n\";\n+    }\n+\n+  if (expr.has_tail_expr ())\n+    {\n+      stream << indentation;\n+      expr.get_tail_expr ()->accept_vis (*this);\n+    }\n+\n+  indentation.decrement ();\n+  stream << \"\\n\" << indentation << \"}\\n\";\n+}\n+\n+void\n+Dump::visit (ClosureExprInnerTyped &expr)\n+{}\n+\n+void\n+Dump::visit (ContinueExpr &expr)\n+{}\n+\n+void\n+Dump::visit (BreakExpr &expr)\n+{}\n+\n+void\n+Dump::visit (RangeFromToExpr &expr)\n+{}\n+\n+void\n+Dump::visit (RangeFromExpr &expr)\n+{}\n+\n+void\n+Dump::visit (RangeToExpr &expr)\n+{}\n+\n+void\n+Dump::visit (RangeFullExpr &expr)\n+{}\n+\n+void\n+Dump::visit (RangeFromToInclExpr &expr)\n+{}\n+\n+void\n+Dump::visit (RangeToInclExpr &expr)\n+{}\n+\n+void\n+Dump::visit (ReturnExpr &expr)\n+{}\n+\n+void\n+Dump::visit (UnsafeBlockExpr &expr)\n+{}\n+\n+void\n+Dump::visit (LoopExpr &expr)\n+{}\n+\n+void\n+Dump::visit (WhileLoopExpr &expr)\n+{}\n+\n+void\n+Dump::visit (WhileLetLoopExpr &expr)\n+{}\n+\n+void\n+Dump::visit (ForLoopExpr &expr)\n+{}\n+\n+void\n+Dump::visit (IfExpr &expr)\n+{}\n+\n+void\n+Dump::visit (IfExprConseqElse &expr)\n+{}\n+\n+void\n+Dump::visit (IfExprConseqIf &expr)\n+{}\n+\n+void\n+Dump::visit (IfExprConseqIfLet &expr)\n+{}\n+\n+void\n+Dump::visit (IfLetExpr &expr)\n+{}\n+\n+void\n+Dump::visit (IfLetExprConseqElse &expr)\n+{}\n+\n+void\n+Dump::visit (IfLetExprConseqIf &expr)\n+{}\n+\n+void\n+Dump::visit (IfLetExprConseqIfLet &expr)\n+{}\n+\n+void\n+Dump::visit (MatchExpr &expr)\n+{}\n+\n+void\n+Dump::visit (AwaitExpr &expr)\n+{}\n+\n+void\n+Dump::visit (AsyncBlockExpr &expr)\n+{}\n+\n+// rust-item.h\n+void\n+Dump::visit (TypeParam &param)\n+{\n+  stream << param.get_type_representation ();\n+  if (param.has_type ())\n+    {\n+      stream << \" = \";\n+      param.get_type ()->accept_vis (*this);\n+    }\n+}\n+\n+void\n+Dump::visit (LifetimeWhereClauseItem &item)\n+{}\n+\n+void\n+Dump::visit (TypeBoundWhereClauseItem &item)\n+{}\n+\n+void\n+Dump::visit (Method &method)\n+{\n+  stream << indentation << \"fn \" << method.get_method_name () << '(';\n+\n+  auto &self = method.get_self_param ();\n+  stream << self.as_string ();\n+\n+  auto &params = method.get_function_params ();\n+  for (auto &param : params)\n+    {\n+      stream << \", \";\n+      format_function_param (param);\n+    }\n+\n+  stream << \") \";\n+\n+  if (method.has_return_type ())\n+    {\n+      stream << \"-> \";\n+      method.get_return_type ()->accept_vis (*this);\n+      stream << \" \";\n+    }\n+\n+  auto &block = method.get_definition ();\n+  if (!block)\n+    stream << ';';\n+  else\n+    block->accept_vis (*this);\n+\n+  stream << '\\n';\n+}\n+\n+void\n+Dump::visit (Module &module)\n+{}\n+\n+void\n+Dump::visit (ExternCrate &crate)\n+{}\n+\n+void\n+Dump::visit (UseTreeGlob &use_tree)\n+{}\n+\n+void\n+Dump::visit (UseTreeList &use_tree)\n+{}\n+\n+void\n+Dump::visit (UseTreeRebind &use_tree)\n+{}\n+\n+void\n+Dump::visit (UseDeclaration &use_decl)\n+{}\n+\n+void\n+Dump::visit (Function &function)\n+{\n+  stream << \"fn \" << function.get_function_name ();\n+\n+  if (function.has_generics ())\n+    {\n+      stream << \"<\";\n+      for (size_t i = 0; i < function.get_generic_params ().size (); i++)\n+\t{\n+\t  auto &param = function.get_generic_params ().at (i);\n+\t  param->accept_vis (*this);\n+\n+\t  bool has_next = (i + 1) < function.get_generic_params ().size ();\n+\t  if (has_next)\n+\t    stream << \", \";\n+\t}\n+      stream << \">\";\n+    }\n+\n+  stream << '(';\n+  auto &params = function.get_function_params ();\n+  if (params.size () >= 1)\n+    {\n+      format_function_param (params[0]);\n+      for (size_t i = 1; i < params.size (); i++)\n+\t{\n+\t  stream << \", \";\n+\t  format_function_param (params[i]);\n+\t}\n+    }\n+\n+  stream << \") \";\n+\n+  if (function.has_return_type ())\n+    {\n+      stream << \"-> \";\n+      function.get_return_type ()->accept_vis (*this);\n+      stream << \" \";\n+    }\n+\n+  auto &block = function.get_definition ();\n+  if (!block)\n+    stream << ';';\n+  else\n+    block->accept_vis (*this);\n+\n+  stream << '\\n';\n+}\n+\n+void\n+Dump::visit (TypeAlias &type_alias)\n+{}\n+\n+void\n+Dump::visit (StructStruct &struct_item)\n+{}\n+\n+void\n+Dump::visit (TupleStruct &tuple_struct)\n+{}\n+\n+void\n+Dump::visit (EnumItem &item)\n+{}\n+\n+void\n+Dump::visit (EnumItemTuple &item)\n+{}\n+\n+void\n+Dump::visit (EnumItemStruct &item)\n+{}\n+\n+void\n+Dump::visit (EnumItemDiscriminant &item)\n+{}\n+\n+void\n+Dump::visit (Enum &enum_item)\n+{}\n+\n+void\n+Dump::visit (Union &union_item)\n+{}\n+\n+void\n+Dump::visit (ConstantItem &const_item)\n+{}\n+\n+void\n+Dump::visit (StaticItem &static_item)\n+{}\n+\n+void\n+Dump::format_function_common (std::unique_ptr<Type> &return_type,\n+\t\t\t      std::unique_ptr<BlockExpr> &block)\n+{\n+  if (return_type)\n+    {\n+      stream << \"-> \";\n+      return_type->accept_vis (*this);\n+    }\n+\n+  if (block)\n+    {\n+      if (return_type)\n+\tstream << ' ';\n+      block->accept_vis (*this);\n+    }\n+  else\n+    stream << \";\\n\";\n+}\n+\n+void\n+Dump::visit (TraitItemFunc &item)\n+{\n+  auto func = item.get_trait_function_decl ();\n+  stream << indentation << \"fn \" << func.get_identifier () << '(';\n+\n+  auto &params = func.get_function_params ();\n+  for (auto &param : params)\n+    {\n+      stream << \", \";\n+      format_function_param (param);\n+    }\n+\n+  stream << \") \";\n+\n+  format_function_common (func.get_return_type (), item.get_definition ());\n+}\n+\n+void\n+Dump::visit (TraitItemMethod &item)\n+{\n+  auto method = item.get_trait_method_decl ();\n+  stream << indentation << \"fn \" << method.get_identifier () << '(';\n+\n+  auto &self = method.get_self_param ();\n+  stream << self.as_string ();\n+\n+  auto &params = method.get_function_params ();\n+  for (auto &param : params)\n+    {\n+      stream << \", \";\n+      format_function_param (param);\n+    }\n+\n+  stream << \") \";\n+\n+  format_function_common (method.get_return_type (), item.get_definition ());\n+}\n+\n+void\n+Dump::visit (TraitItemConst &item)\n+{\n+  stream << indentation << \"const \" << item.get_identifier () << \": \";\n+  item.get_type ()->accept_vis (*this);\n+  stream << \";\\n\";\n+}\n+\n+void\n+Dump::visit (TraitItemType &item)\n+{\n+  stream << indentation << \"type \" << item.get_identifier () << \";\\n\";\n+}\n+\n+void\n+Dump::visit (Trait &trait)\n+{\n+  for (const auto &attr : trait.get_outer_attrs ())\n+    {\n+      emit_attrib (attr);\n+      stream << \"\\n\" << indentation;\n+    }\n+\n+  stream << \"trait \" << trait.get_identifier ();\n+\n+  // Traits actually have an implicit Self thrown at the start so we must expect\n+  // the number of generic params to be > 1\n+  if (trait.get_generic_params ().size () > 1)\n+    {\n+      stream << \"<\";\n+      for (size_t i = 1; i < trait.get_generic_params ().size (); i++)\n+\t{\n+\t  auto &param = trait.get_generic_params ().at (i);\n+\t  param->accept_vis (*this);\n+\n+\t  bool has_next = (i + 1) < trait.get_generic_params ().size ();\n+\t  if (has_next)\n+\t    stream << \", \";\n+\t}\n+      stream << \">\";\n+    }\n+\n+  stream << \" {\\n\";\n+\n+  indentation.increment ();\n+\n+  for (auto &item : trait.get_trait_items ())\n+    item->accept_vis (*this);\n+\n+  indentation.decrement ();\n+  stream << \"\\n}\\n\";\n+}\n+\n+void\n+Dump::visit (InherentImpl &impl)\n+{\n+  stream << \"impl \";\n+\n+  // FIXME: Handle generics\n+\n+  impl.get_type ()->accept_vis (*this);\n+\n+  // FIXME: Handle where-clause\n+  // FIXME: Handle inner attributes\n+\n+  stream << \" {\\n\";\n+  indentation.increment ();\n+\n+  for (auto &item : impl.get_impl_items ())\n+    item->accept_vis (*this);\n+\n+  indentation.decrement ();\n+  stream << \"\\n}\\n\";\n+}\n+\n+void\n+Dump::visit (TraitImpl &impl)\n+{\n+  stream << \"impl \";\n+  impl.get_trait_path ().accept_vis (*this);\n+  stream << \" for \";\n+  impl.get_type ()->accept_vis (*this);\n+\n+  stream << \" {\\n\";\n+  indentation.increment ();\n+\n+  for (auto &item : impl.get_impl_items ())\n+    item->accept_vis (*this);\n+\n+  indentation.decrement ();\n+  stream << \"\\n}\\n\";\n+}\n+\n+void\n+Dump::visit (ExternalStaticItem &item)\n+{}\n+\n+void\n+Dump::visit (ExternalFunctionItem &function)\n+{\n+  stream << \"fn \" << function.get_identifier () << '(';\n+\n+  for (size_t i = 0; i < function.get_function_params ().size (); i++)\n+    {\n+      auto &param = function.get_function_params ().at (i);\n+      bool has_next = (i + 1) < function.get_function_params ().size ();\n+\n+      stream << param.get_name () << \": \";\n+      param.get_type ()->accept_vis (*this);\n+\n+      if (has_next)\n+\tstream << \", \";\n+    }\n+\n+  stream << ')';\n+  if (function.has_return_type ())\n+    {\n+      stream << \"-> \";\n+      function.get_return_type ()->accept_vis (*this);\n+    }\n+}\n+\n+void\n+Dump::visit (ExternBlock &block)\n+{\n+  stream << \"extern \";\n+\n+  if (block.has_abi ())\n+    {\n+      stream << \"\\\"\";\n+      stream << block.get_abi ();\n+      stream << \"\\\" \";\n+    }\n+\n+  stream << \"{\\n\";\n+  indentation.increment ();\n+\n+  for (auto &item : block.get_extern_items ())\n+    {\n+      stream << indentation;\n+      item->accept_vis (*this);\n+      stream << \";\\n\";\n+    }\n+\n+  indentation.decrement ();\n+  stream << \"\\n\" << indentation << \"}\\n\";\n+}\n+\n+// rust-macro.h\n+void\n+Dump::visit (MacroMatchFragment &match)\n+{}\n+\n+void\n+Dump::visit (MacroMatchRepetition &match)\n+{}\n+\n+void\n+Dump::visit (MacroMatcher &matcher)\n+{}\n+\n+void\n+Dump::visit (MacroRulesDefinition &rules_def)\n+{}\n+\n+void\n+Dump::visit (MacroInvocation &macro_invoc)\n+{}\n+\n+void\n+Dump::visit (MetaItemPath &meta_item)\n+{}\n+\n+void\n+Dump::visit (MetaItemSeq &meta_item)\n+{}\n+\n+void\n+Dump::visit (MetaWord &meta_item)\n+{}\n+\n+void\n+Dump::visit (MetaNameValueStr &meta_item)\n+{}\n+\n+void\n+Dump::visit (MetaListPaths &meta_item)\n+{}\n+\n+void\n+Dump::visit (MetaListNameValueStr &meta_item)\n+{}\n+\n+// rust-pattern.h\n+void\n+Dump::visit (LiteralPattern &pattern)\n+{}\n+\n+void\n+Dump::visit (IdentifierPattern &pattern)\n+{\n+  stream << pattern.get_ident ();\n+}\n+\n+void\n+Dump::visit (WildcardPattern &pattern)\n+{}\n+\n+// void Dump::visit(RangePatternBound& bound){}\n+\n+void\n+Dump::visit (RangePatternBoundLiteral &bound)\n+{}\n+\n+void\n+Dump::visit (RangePatternBoundPath &bound)\n+{}\n+\n+void\n+Dump::visit (RangePatternBoundQualPath &bound)\n+{}\n+\n+void\n+Dump::visit (RangePattern &pattern)\n+{}\n+\n+void\n+Dump::visit (ReferencePattern &pattern)\n+{}\n+\n+// void Dump::visit(StructPatternField& field){}\n+\n+void\n+Dump::visit (StructPatternFieldTuplePat &field)\n+{}\n+\n+void\n+Dump::visit (StructPatternFieldIdentPat &field)\n+{}\n+\n+void\n+Dump::visit (StructPatternFieldIdent &field)\n+{}\n+\n+void\n+Dump::visit (StructPattern &pattern)\n+{}\n+\n+// void Dump::visit(TupleStructItems& tuple_items){}\n+\n+void\n+Dump::visit (TupleStructItemsNoRange &tuple_items)\n+{}\n+\n+void\n+Dump::visit (TupleStructItemsRange &tuple_items)\n+{}\n+\n+void\n+Dump::visit (TupleStructPattern &pattern)\n+{}\n+\n+// void Dump::visit(TuplePatternItems& tuple_items){}\n+\n+void\n+Dump::visit (TuplePatternItemsMultiple &tuple_items)\n+{}\n+\n+void\n+Dump::visit (TuplePatternItemsRanged &tuple_items)\n+{}\n+\n+void\n+Dump::visit (TuplePattern &pattern)\n+{}\n+\n+void\n+Dump::visit (GroupedPattern &pattern)\n+{}\n+\n+void\n+Dump::visit (SlicePattern &pattern)\n+{}\n+\n+// rust-stmt.h\n+void\n+Dump::visit (EmptyStmt &stmt)\n+{}\n+\n+void\n+Dump::visit (LetStmt &stmt)\n+{\n+  stream << \"let \";\n+  auto &pattern = stmt.get_pattern ();\n+  if (pattern)\n+    pattern->accept_vis (*this);\n+\n+  if (stmt.has_type ())\n+    {\n+      stream << \": \";\n+      stmt.get_type ()->accept_vis (*this);\n+    }\n+\n+  if (stmt.has_init_expr ())\n+    {\n+      stream << \" = \";\n+      stmt.get_init_expr ()->accept_vis (*this);\n+    }\n+}\n+\n+void\n+Dump::visit (ExprStmtWithoutBlock &stmt)\n+{}\n+\n+void\n+Dump::visit (ExprStmtWithBlock &stmt)\n+{}\n+\n+// rust-type.h\n+void\n+Dump::visit (TraitBound &bound)\n+{}\n+\n+void\n+Dump::visit (ImplTraitType &type)\n+{}\n+\n+void\n+Dump::visit (TraitObjectType &type)\n+{}\n+\n+void\n+Dump::visit (ParenthesisedType &type)\n+{}\n+\n+void\n+Dump::visit (ImplTraitTypeOneBound &type)\n+{}\n+\n+void\n+Dump::visit (TraitObjectTypeOneBound &type)\n+{}\n+\n+void\n+Dump::visit (TupleType &type)\n+{}\n+\n+void\n+Dump::visit (NeverType &type)\n+{}\n+\n+void\n+Dump::visit (RawPointerType &type)\n+{}\n+\n+void\n+Dump::visit (ReferenceType &type)\n+{\n+  type.get_type_referenced ()->accept_vis (*this);\n+}\n+\n+void\n+Dump::visit (ArrayType &type)\n+{\n+  type.get_elem_type ()->accept_vis (*this);\n+}\n+\n+void\n+Dump::visit (SliceType &type)\n+{\n+  type.get_elem_type ()->accept_vis (*this);\n+}\n+\n+void\n+Dump::visit (InferredType &type)\n+{\n+  stream << \"_\";\n+}\n+\n+void\n+Dump::visit (BareFunctionType &type)\n+{}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "c3854e8287dbfaca0bdc699acea966fd44006fdc", "filename": "gcc/rust/ast/rust-ast-dump.h", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/gcc%2Frust%2Fast%2Frust-ast-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/gcc%2Frust%2Fast%2Frust-ast-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-dump.h?ref=5b981e9c7411e68bdd73365dbd94ed3844bce2c8", "patch": "@@ -0,0 +1,246 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-ast-full.h\"\n+\n+#ifndef RUST_AST_DUMP_H\n+#define RUST_AST_DUMP_H\n+\n+namespace Rust {\n+namespace AST {\n+\n+// TODO: We might want to reuse this class somewhere else\n+class Indent\n+{\n+public:\n+  Indent ();\n+\n+  friend std::ostream &operator<< (std::ostream &stream, const Indent &indent);\n+\n+  void increment ();\n+  void decrement ();\n+\n+private:\n+  size_t tabs;\n+};\n+\n+class Dump : public ASTVisitor\n+{\n+public:\n+  Dump (std::ostream &stream);\n+\n+  /**\n+   * Run the visitor on an entire crate and its items\n+   */\n+  void go (AST::Crate &crate);\n+  void go (AST::Item &item);\n+\n+private:\n+  std::ostream &stream;\n+  Indent indentation;\n+\n+  // Format together common items of functions: Parameters, return type, block\n+  void format_function_common (std::unique_ptr<Type> &return_type,\n+\t\t\t       std::unique_ptr<BlockExpr> &block);\n+\n+  /**\n+   * Format a function's definition parameter\n+   */\n+  void format_function_param (FunctionParam &param);\n+  void emit_attrib (const Attribute &attrib);\n+\n+  // rust-ast.h\n+  void visit (Token &tok);\n+  void visit (DelimTokenTree &delim_tok_tree);\n+  void visit (AttrInputMetaItemContainer &input);\n+  void visit (IdentifierExpr &ident_expr);\n+  void visit (Lifetime &lifetime);\n+  void visit (LifetimeParam &lifetime_param);\n+  void visit (ConstGenericParam &const_param);\n+\n+  // rust-path.h\n+  void visit (PathInExpression &path);\n+  void visit (TypePathSegment &segment);\n+  void visit (TypePathSegmentGeneric &segment);\n+  void visit (TypePathSegmentFunction &segment);\n+  void visit (TypePath &path);\n+  void visit (QualifiedPathInExpression &path);\n+  void visit (QualifiedPathInType &path);\n+\n+  // rust-expr.h\n+  void visit (LiteralExpr &expr);\n+  void visit (AttrInputLiteral &attr_input);\n+  void visit (MetaItemLitExpr &meta_item);\n+  void visit (MetaItemPathLit &meta_item);\n+  void visit (BorrowExpr &expr);\n+  void visit (DereferenceExpr &expr);\n+  void visit (ErrorPropagationExpr &expr);\n+  void visit (NegationExpr &expr);\n+  void visit (ArithmeticOrLogicalExpr &expr);\n+  void visit (ComparisonExpr &expr);\n+  void visit (LazyBooleanExpr &expr);\n+  void visit (TypeCastExpr &expr);\n+  void visit (AssignmentExpr &expr);\n+  void visit (CompoundAssignmentExpr &expr);\n+  void visit (GroupedExpr &expr);\n+  void visit (ArrayElemsValues &elems);\n+  void visit (ArrayElemsCopied &elems);\n+  void visit (ArrayExpr &expr);\n+  void visit (ArrayIndexExpr &expr);\n+  void visit (TupleExpr &expr);\n+  void visit (TupleIndexExpr &expr);\n+  void visit (StructExprStruct &expr);\n+  void visit (StructExprFieldIdentifier &field);\n+  void visit (StructExprFieldIdentifierValue &field);\n+  void visit (StructExprFieldIndexValue &field);\n+  void visit (StructExprStructFields &expr);\n+  void visit (StructExprStructBase &expr);\n+  void visit (CallExpr &expr);\n+  void visit (MethodCallExpr &expr);\n+  void visit (FieldAccessExpr &expr);\n+  void visit (ClosureExprInner &expr);\n+  void visit (BlockExpr &expr);\n+  void visit (ClosureExprInnerTyped &expr);\n+  void visit (ContinueExpr &expr);\n+  void visit (BreakExpr &expr);\n+  void visit (RangeFromToExpr &expr);\n+  void visit (RangeFromExpr &expr);\n+  void visit (RangeToExpr &expr);\n+  void visit (RangeFullExpr &expr);\n+  void visit (RangeFromToInclExpr &expr);\n+  void visit (RangeToInclExpr &expr);\n+  void visit (ReturnExpr &expr);\n+  void visit (UnsafeBlockExpr &expr);\n+  void visit (LoopExpr &expr);\n+  void visit (WhileLoopExpr &expr);\n+  void visit (WhileLetLoopExpr &expr);\n+  void visit (ForLoopExpr &expr);\n+  void visit (IfExpr &expr);\n+  void visit (IfExprConseqElse &expr);\n+  void visit (IfExprConseqIf &expr);\n+  void visit (IfExprConseqIfLet &expr);\n+  void visit (IfLetExpr &expr);\n+  void visit (IfLetExprConseqElse &expr);\n+  void visit (IfLetExprConseqIf &expr);\n+  void visit (IfLetExprConseqIfLet &expr);\n+  void visit (MatchExpr &expr);\n+  void visit (AwaitExpr &expr);\n+  void visit (AsyncBlockExpr &expr);\n+\n+  // rust-item.h\n+  void visit (TypeParam &param);\n+  void visit (LifetimeWhereClauseItem &item);\n+  void visit (TypeBoundWhereClauseItem &item);\n+  void visit (Method &method);\n+  void visit (Module &module);\n+  void visit (ExternCrate &crate);\n+  void visit (UseTreeGlob &use_tree);\n+  void visit (UseTreeList &use_tree);\n+  void visit (UseTreeRebind &use_tree);\n+  void visit (UseDeclaration &use_decl);\n+  void visit (Function &function);\n+  void visit (TypeAlias &type_alias);\n+  void visit (StructStruct &struct_item);\n+  void visit (TupleStruct &tuple_struct);\n+  void visit (EnumItem &item);\n+  void visit (EnumItemTuple &item);\n+  void visit (EnumItemStruct &item);\n+  void visit (EnumItemDiscriminant &item);\n+  void visit (Enum &enum_item);\n+  void visit (Union &union_item);\n+  void visit (ConstantItem &const_item);\n+  void visit (StaticItem &static_item);\n+  void visit (TraitItemFunc &item);\n+  void visit (TraitItemMethod &item);\n+  void visit (TraitItemConst &item);\n+  void visit (TraitItemType &item);\n+  void visit (Trait &trait);\n+  void visit (InherentImpl &impl);\n+  void visit (TraitImpl &impl);\n+  void visit (ExternalStaticItem &item);\n+  void visit (ExternalFunctionItem &item);\n+  void visit (ExternBlock &block);\n+\n+  // rust-macro.h\n+  void visit (MacroMatchFragment &match);\n+  void visit (MacroMatchRepetition &match);\n+  void visit (MacroMatcher &matcher);\n+  void visit (MacroRulesDefinition &rules_def);\n+  void visit (MacroInvocation &macro_invoc);\n+  void visit (MetaItemPath &meta_item);\n+  void visit (MetaItemSeq &meta_item);\n+  void visit (MetaWord &meta_item);\n+  void visit (MetaNameValueStr &meta_item);\n+  void visit (MetaListPaths &meta_item);\n+  void visit (MetaListNameValueStr &meta_item);\n+\n+  // rust-pattern.h\n+  void visit (LiteralPattern &pattern);\n+  void visit (IdentifierPattern &pattern);\n+  void visit (WildcardPattern &pattern);\n+  // void visit(RangePatternBound& bound);\n+  void visit (RangePatternBoundLiteral &bound);\n+  void visit (RangePatternBoundPath &bound);\n+  void visit (RangePatternBoundQualPath &bound);\n+  void visit (RangePattern &pattern);\n+  void visit (ReferencePattern &pattern);\n+  // void visit(StructPatternField& field);\n+  void visit (StructPatternFieldTuplePat &field);\n+  void visit (StructPatternFieldIdentPat &field);\n+  void visit (StructPatternFieldIdent &field);\n+  void visit (StructPattern &pattern);\n+  // void visit(TupleStructItems& tuple_items);\n+  void visit (TupleStructItemsNoRange &tuple_items);\n+  void visit (TupleStructItemsRange &tuple_items);\n+  void visit (TupleStructPattern &pattern);\n+  // void visit(TuplePatternItems& tuple_items);\n+  void visit (TuplePatternItemsMultiple &tuple_items);\n+  void visit (TuplePatternItemsRanged &tuple_items);\n+  void visit (TuplePattern &pattern);\n+  void visit (GroupedPattern &pattern);\n+  void visit (SlicePattern &pattern);\n+\n+  // rust-stmt.h\n+  void visit (EmptyStmt &stmt);\n+  void visit (LetStmt &stmt);\n+  void visit (ExprStmtWithoutBlock &stmt);\n+  void visit (ExprStmtWithBlock &stmt);\n+\n+  // rust-type.h\n+  void visit (TraitBound &bound);\n+  void visit (ImplTraitType &type);\n+  void visit (TraitObjectType &type);\n+  void visit (ParenthesisedType &type);\n+  void visit (ImplTraitTypeOneBound &type);\n+  void visit (TraitObjectTypeOneBound &type);\n+  void visit (TupleType &type);\n+  void visit (NeverType &type);\n+  void visit (RawPointerType &type);\n+  void visit (ReferenceType &type);\n+  void visit (ArrayType &type);\n+  void visit (SliceType &type);\n+  void visit (InferredType &type);\n+  void visit (BareFunctionType &type);\n+};\n+\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif // !RUST_AST_DUMP_H"}, {"sha": "bbb04771fea9a7142b3d608e4147651dd3a333c6", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=5b981e9c7411e68bdd73365dbd94ed3844bce2c8", "patch": "@@ -0,0 +1,234 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_VISITOR_H\n+#define RUST_AST_VISITOR_H\n+// Visitor base for AST\n+\n+// full include not required - only forward decls\n+#include \"rust-ast-full-decls.h\"\n+\n+namespace Rust {\n+namespace AST {\n+/* Pure abstract class that provides an interface for accessing different\n+ * classes of the AST. */\n+class ASTVisitor\n+{\n+public:\n+  // only concrete class overloads are required\n+\n+  // rust-ast.h\n+  // virtual void visit(AttrInput& attr_input) = 0;\n+  // virtual void visit(TokenTree& token_tree) = 0;\n+  // virtual void visit(MacroMatch& macro_match) = 0;\n+  virtual void visit (Token &tok) = 0;\n+  virtual void visit (DelimTokenTree &delim_tok_tree) = 0;\n+  virtual void visit (AttrInputMetaItemContainer &input) = 0;\n+  // virtual void visit(MetaItem& meta_item) = 0;\n+  // virtual void visit(Stmt& stmt) = 0;\n+  // virtual void visit(Expr& expr) = 0;\n+  virtual void visit (IdentifierExpr &ident_expr) = 0;\n+  // virtual void visit(Pattern& pattern) = 0;\n+  // virtual void visit(Type& type) = 0;\n+  // virtual void visit(TypeParamBound& type_param_bound) = 0;\n+  virtual void visit (Lifetime &lifetime) = 0;\n+  // virtual void visit(GenericParam& generic_param) = 0;\n+  virtual void visit (LifetimeParam &lifetime_param) = 0;\n+  virtual void visit (ConstGenericParam &const_param) = 0;\n+  // virtual void visit(TraitItem& trait_item) = 0;\n+  // virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n+  // virtual void visit(TraitImplItem& trait_impl_item) = 0;\n+\n+  // rust-path.h\n+  virtual void visit (PathInExpression &path) = 0;\n+  virtual void visit (TypePathSegment &segment) = 0;\n+  virtual void visit (TypePathSegmentGeneric &segment) = 0;\n+  virtual void visit (TypePathSegmentFunction &segment) = 0;\n+  virtual void visit (TypePath &path) = 0;\n+  virtual void visit (QualifiedPathInExpression &path) = 0;\n+  virtual void visit (QualifiedPathInType &path) = 0;\n+\n+  // rust-expr.h\n+  virtual void visit (LiteralExpr &expr) = 0;\n+  virtual void visit (AttrInputLiteral &attr_input) = 0;\n+  virtual void visit (MetaItemLitExpr &meta_item) = 0;\n+  virtual void visit (MetaItemPathLit &meta_item) = 0;\n+  virtual void visit (BorrowExpr &expr) = 0;\n+  virtual void visit (DereferenceExpr &expr) = 0;\n+  virtual void visit (ErrorPropagationExpr &expr) = 0;\n+  virtual void visit (NegationExpr &expr) = 0;\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) = 0;\n+  virtual void visit (ComparisonExpr &expr) = 0;\n+  virtual void visit (LazyBooleanExpr &expr) = 0;\n+  virtual void visit (TypeCastExpr &expr) = 0;\n+  virtual void visit (AssignmentExpr &expr) = 0;\n+  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n+  virtual void visit (GroupedExpr &expr) = 0;\n+  // virtual void visit(ArrayElems& elems) = 0;\n+  virtual void visit (ArrayElemsValues &elems) = 0;\n+  virtual void visit (ArrayElemsCopied &elems) = 0;\n+  virtual void visit (ArrayExpr &expr) = 0;\n+  virtual void visit (ArrayIndexExpr &expr) = 0;\n+  virtual void visit (TupleExpr &expr) = 0;\n+  virtual void visit (TupleIndexExpr &expr) = 0;\n+  virtual void visit (StructExprStruct &expr) = 0;\n+  // virtual void visit(StructExprField& field) = 0;\n+  virtual void visit (StructExprFieldIdentifier &field) = 0;\n+  virtual void visit (StructExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (StructExprFieldIndexValue &field) = 0;\n+  virtual void visit (StructExprStructFields &expr) = 0;\n+  virtual void visit (StructExprStructBase &expr) = 0;\n+  virtual void visit (CallExpr &expr) = 0;\n+  virtual void visit (MethodCallExpr &expr) = 0;\n+  virtual void visit (FieldAccessExpr &expr) = 0;\n+  virtual void visit (ClosureExprInner &expr) = 0;\n+  virtual void visit (BlockExpr &expr) = 0;\n+  virtual void visit (ClosureExprInnerTyped &expr) = 0;\n+  virtual void visit (ContinueExpr &expr) = 0;\n+  virtual void visit (BreakExpr &expr) = 0;\n+  virtual void visit (RangeFromToExpr &expr) = 0;\n+  virtual void visit (RangeFromExpr &expr) = 0;\n+  virtual void visit (RangeToExpr &expr) = 0;\n+  virtual void visit (RangeFullExpr &expr) = 0;\n+  virtual void visit (RangeFromToInclExpr &expr) = 0;\n+  virtual void visit (RangeToInclExpr &expr) = 0;\n+  virtual void visit (ReturnExpr &expr) = 0;\n+  virtual void visit (UnsafeBlockExpr &expr) = 0;\n+  virtual void visit (LoopExpr &expr) = 0;\n+  virtual void visit (WhileLoopExpr &expr) = 0;\n+  virtual void visit (WhileLetLoopExpr &expr) = 0;\n+  virtual void visit (ForLoopExpr &expr) = 0;\n+  virtual void visit (IfExpr &expr) = 0;\n+  virtual void visit (IfExprConseqElse &expr) = 0;\n+  virtual void visit (IfExprConseqIf &expr) = 0;\n+  virtual void visit (IfExprConseqIfLet &expr) = 0;\n+  virtual void visit (IfLetExpr &expr) = 0;\n+  virtual void visit (IfLetExprConseqElse &expr) = 0;\n+  virtual void visit (IfLetExprConseqIf &expr) = 0;\n+  virtual void visit (IfLetExprConseqIfLet &expr) = 0;\n+  // virtual void visit(MatchCase& match_case) = 0;\n+  // virtual void visit (MatchCaseBlockExpr &match_case) = 0;\n+  // virtual void visit (MatchCaseExpr &match_case) = 0;\n+  virtual void visit (MatchExpr &expr) = 0;\n+  virtual void visit (AwaitExpr &expr) = 0;\n+  virtual void visit (AsyncBlockExpr &expr) = 0;\n+\n+  // rust-item.h\n+  virtual void visit (TypeParam &param) = 0;\n+  // virtual void visit(WhereClauseItem& item) = 0;\n+  virtual void visit (LifetimeWhereClauseItem &item) = 0;\n+  virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n+  virtual void visit (Method &method) = 0;\n+  virtual void visit (Module &module) = 0;\n+  virtual void visit (ExternCrate &crate) = 0;\n+  // virtual void visit(UseTree& use_tree) = 0;\n+  virtual void visit (UseTreeGlob &use_tree) = 0;\n+  virtual void visit (UseTreeList &use_tree) = 0;\n+  virtual void visit (UseTreeRebind &use_tree) = 0;\n+  virtual void visit (UseDeclaration &use_decl) = 0;\n+  virtual void visit (Function &function) = 0;\n+  virtual void visit (TypeAlias &type_alias) = 0;\n+  virtual void visit (StructStruct &struct_item) = 0;\n+  virtual void visit (TupleStruct &tuple_struct) = 0;\n+  virtual void visit (EnumItem &item) = 0;\n+  virtual void visit (EnumItemTuple &item) = 0;\n+  virtual void visit (EnumItemStruct &item) = 0;\n+  virtual void visit (EnumItemDiscriminant &item) = 0;\n+  virtual void visit (Enum &enum_item) = 0;\n+  virtual void visit (Union &union_item) = 0;\n+  virtual void visit (ConstantItem &const_item) = 0;\n+  virtual void visit (StaticItem &static_item) = 0;\n+  virtual void visit (TraitItemFunc &item) = 0;\n+  virtual void visit (TraitItemMethod &item) = 0;\n+  virtual void visit (TraitItemConst &item) = 0;\n+  virtual void visit (TraitItemType &item) = 0;\n+  virtual void visit (Trait &trait) = 0;\n+  virtual void visit (InherentImpl &impl) = 0;\n+  virtual void visit (TraitImpl &impl) = 0;\n+  // virtual void visit(ExternalItem& item) = 0;\n+  virtual void visit (ExternalStaticItem &item) = 0;\n+  virtual void visit (ExternalFunctionItem &item) = 0;\n+  virtual void visit (ExternBlock &block) = 0;\n+\n+  // rust-macro.h\n+  virtual void visit (MacroMatchFragment &match) = 0;\n+  virtual void visit (MacroMatchRepetition &match) = 0;\n+  virtual void visit (MacroMatcher &matcher) = 0;\n+  virtual void visit (MacroRulesDefinition &rules_def) = 0;\n+  virtual void visit (MacroInvocation &macro_invoc) = 0;\n+  virtual void visit (MetaItemPath &meta_item) = 0;\n+  virtual void visit (MetaItemSeq &meta_item) = 0;\n+  virtual void visit (MetaWord &meta_item) = 0;\n+  virtual void visit (MetaNameValueStr &meta_item) = 0;\n+  virtual void visit (MetaListPaths &meta_item) = 0;\n+  virtual void visit (MetaListNameValueStr &meta_item) = 0;\n+\n+  // rust-pattern.h\n+  virtual void visit (LiteralPattern &pattern) = 0;\n+  virtual void visit (IdentifierPattern &pattern) = 0;\n+  virtual void visit (WildcardPattern &pattern) = 0;\n+  // virtual void visit(RangePatternBound& bound) = 0;\n+  virtual void visit (RangePatternBoundLiteral &bound) = 0;\n+  virtual void visit (RangePatternBoundPath &bound) = 0;\n+  virtual void visit (RangePatternBoundQualPath &bound) = 0;\n+  virtual void visit (RangePattern &pattern) = 0;\n+  virtual void visit (ReferencePattern &pattern) = 0;\n+  // virtual void visit(StructPatternField& field) = 0;\n+  virtual void visit (StructPatternFieldTuplePat &field) = 0;\n+  virtual void visit (StructPatternFieldIdentPat &field) = 0;\n+  virtual void visit (StructPatternFieldIdent &field) = 0;\n+  virtual void visit (StructPattern &pattern) = 0;\n+  // virtual void visit(TupleStructItems& tuple_items) = 0;\n+  virtual void visit (TupleStructItemsNoRange &tuple_items) = 0;\n+  virtual void visit (TupleStructItemsRange &tuple_items) = 0;\n+  virtual void visit (TupleStructPattern &pattern) = 0;\n+  // virtual void visit(TuplePatternItems& tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsMultiple &tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsRanged &tuple_items) = 0;\n+  virtual void visit (TuplePattern &pattern) = 0;\n+  virtual void visit (GroupedPattern &pattern) = 0;\n+  virtual void visit (SlicePattern &pattern) = 0;\n+\n+  // rust-stmt.h\n+  virtual void visit (EmptyStmt &stmt) = 0;\n+  virtual void visit (LetStmt &stmt) = 0;\n+  virtual void visit (ExprStmtWithoutBlock &stmt) = 0;\n+  virtual void visit (ExprStmtWithBlock &stmt) = 0;\n+\n+  // rust-type.h\n+  virtual void visit (TraitBound &bound) = 0;\n+  virtual void visit (ImplTraitType &type) = 0;\n+  virtual void visit (TraitObjectType &type) = 0;\n+  virtual void visit (ParenthesisedType &type) = 0;\n+  virtual void visit (ImplTraitTypeOneBound &type) = 0;\n+  virtual void visit (TraitObjectTypeOneBound &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n+  virtual void visit (NeverType &type) = 0;\n+  virtual void visit (RawPointerType &type) = 0;\n+  virtual void visit (ReferenceType &type) = 0;\n+  virtual void visit (ArrayType &type) = 0;\n+  virtual void visit (SliceType &type) = 0;\n+  virtual void visit (InferredType &type) = 0;\n+  virtual void visit (BareFunctionType &type) = 0;\n+\n+  // TODO: rust-cond-compilation.h visiting? not currently used\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "71188ef3b4b7c11da5d9621f1aec755193423263", "filename": "gcc/rust/ast/rust-cond-compilation.h", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b981e9c7411e68bdd73365dbd94ed3844bce2c8/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-cond-compilation.h?ref=5b981e9c7411e68bdd73365dbd94ed3844bce2c8", "patch": "@@ -0,0 +1,249 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_CONDCOMPILATION\n+#define RUST_AST_CONDCOMPILATION\n+// Conditional compilation-related AST stuff\n+\n+#include \"rust-ast.h\"\n+\n+namespace Rust {\n+namespace AST {\n+// Base conditional compilation configuration predicate thing - abstract\n+class ConfigurationPredicate\n+{\n+public:\n+  virtual ~ConfigurationPredicate () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ConfigurationPredicate> clone_configuration_predicate () const\n+  {\n+    return std::unique_ptr<ConfigurationPredicate> (\n+      clone_configuration_predicate_impl ());\n+  }\n+\n+  // not sure if I'll use this but here anyway\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function impl to be overriden in base classes\n+  virtual ConfigurationPredicate *\n+  clone_configuration_predicate_impl () const = 0;\n+};\n+\n+// A configuration option - true if option is set, false if option is not set.\n+class ConfigurationOption : public ConfigurationPredicate\n+{\n+  Identifier option_name;\n+\n+  // bool has_string_literal_option_body;\n+  std::string option_value; // technically a string or raw string literal\n+\n+public:\n+  /* Returns whether the configuration option has a \"value\" part of the\n+   * key-value pair. */\n+  bool has_option_value () const { return !option_value.empty (); }\n+\n+  // Key-value pair constructor\n+  ConfigurationOption (Identifier option_name, std::string option_value)\n+    : option_name (option_name), option_value (option_value)\n+  {}\n+\n+  // Name-only constructor\n+  ConfigurationOption (Identifier option_name) : option_name (option_name) {}\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationOption *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationOption (*this);\n+  }\n+};\n+\n+// TODO: inline\n+struct ConfigurationPredicateList\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate>> predicate_list;\n+};\n+\n+// Predicate that returns true if all of the supplied predicates return true.\n+class ConfigurationAll : public ConfigurationPredicate\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate>>\n+    predicate_list; // inlined form\n+\n+public:\n+  ConfigurationAll (\n+    std::vector<std::unique_ptr<ConfigurationPredicate>> predicate_list)\n+    : predicate_list (predicate_list)\n+  {}\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationAll *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationAll (*this);\n+  }\n+};\n+\n+// Predicate that returns true if any of the supplied predicates are true.\n+class ConfigurationAny : public ConfigurationPredicate\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate>>\n+    predicate_list; // inlined form\n+\n+public:\n+  ConfigurationAny (\n+    std::vector<std::unique_ptr<ConfigurationPredicate>> predicate_list)\n+    : predicate_list (predicate_list)\n+  {}\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationAny *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationAny (*this);\n+  }\n+};\n+\n+/* Predicate that produces the negation of a supplied other configuration\n+ * predicate. */\n+class ConfigurationNot : public ConfigurationPredicate\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_negate;\n+\n+public:\n+  ConfigurationNot (ConfigurationPredicate *config_to_negate)\n+    : config_to_negate (config_to_negate)\n+  {}\n+\n+  // Copy constructor with clone\n+  ConfigurationNot (ConfigurationNot const &other)\n+    : config_to_negate (\n+      other.config_to_negate->clone_configuration_predicate ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ConfigurationNot &operator= (ConfigurationNot const &other)\n+  {\n+    config_to_negate = other.config_to_negate->clone_configuration_predicate ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ConfigurationNot (ConfigurationNot &&other) = default;\n+  ConfigurationNot &operator= (ConfigurationNot &&other) = default;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationNot *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationNot (*this);\n+  }\n+};\n+\n+// TODO: relationship to other attributes?\n+class CfgAttribute\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_include;\n+\n+public:\n+  CfgAttribute (ConfigurationPredicate *config_to_include)\n+    : config_to_include (config_to_include)\n+  {}\n+\n+  // Copy constructor with clone\n+  CfgAttribute (CfgAttribute const &other)\n+    : config_to_include (\n+      other.config_to_include->clone_configuration_predicate ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  CfgAttribute &operator= (CfgAttribute const &other)\n+  {\n+    config_to_include\n+      = other.config_to_include->clone_configuration_predicate ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CfgAttribute (CfgAttribute &&other) = default;\n+  CfgAttribute &operator= (CfgAttribute &&other) = default;\n+};\n+/* TODO: ok, best thing to do would be eliminating this class, making Attribute\n+ * has a \"is_cfg()\" method, and having attribute path as \"cfg\" and AttrInput as\n+ * ConfigurationPredicate (so make ConfigurationPredicate a subclass of\n+ * AttrInput?). Would need special handling in parser, however. */\n+\n+// TODO: inline\n+struct CfgAttrs\n+{\n+  std::vector<Attribute> cfg_attrs;\n+};\n+\n+// TODO: relationship to other attributes?\n+class CfgAttrAttribute\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_include;\n+  std::vector<Attribute> cfg_attrs;\n+\n+public:\n+  CfgAttrAttribute (ConfigurationPredicate *config_to_include,\n+\t\t    std::vector<Attribute> cfg_attrs)\n+    : config_to_include (config_to_include), cfg_attrs (cfg_attrs)\n+  {}\n+\n+  // Copy constructor with clone\n+  CfgAttrAttribute (CfgAttrAttribute const &other)\n+    : config_to_include (\n+      other.config_to_include->clone_configuration_predicate ()),\n+      cfg_attrs (cfg_attrs)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  CfgAttrAttribute &operator= (CfgAttrAttribute const &other)\n+  {\n+    config_to_include\n+      = other.config_to_include->clone_configuration_predicate ();\n+    cfg_attrs = other.cfg_attrs;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CfgAttrAttribute (CfgAttrAttribute &&other) = default;\n+  CfgAttrAttribute &operator= (CfgAttrAttribute &&other) = default;\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}]}