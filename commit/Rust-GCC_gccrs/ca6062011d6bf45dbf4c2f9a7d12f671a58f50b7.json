{"sha": "ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E2MDYyMDExZDZiZjQ1ZGJmNGMyZjlhN2QxMmY2NzFhNThmNTBiNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@zembu.com", "date": "1999-08-04T07:45:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-04T07:45:10Z"}, "message": "gcc.c (access_check): New static function.\n\n        * gcc.c (access_check): New static function.\n        (find_a_file): Use it when searching a directory list.\n        * collect2.c (find_a_file): Don't accept directories found when\n        searching a directory list.\n\nFrom-SVN: r28486", "tree": {"sha": "89008bf231e3566bf6c5354c788a05cf2957f413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89008bf231e3566bf6c5354c788a05cf2957f413"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7/comments", "author": null, "committer": null, "parents": [{"sha": "0c26b18a0dbb2225f7524b1c83f9d88ad1966bdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c26b18a0dbb2225f7524b1c83f9d88ad1966bdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c26b18a0dbb2225f7524b1c83f9d88ad1966bdc"}], "stats": {"total": 50, "additions": 42, "deletions": 8}, "files": [{"sha": "fb4b3a8166e89ecaa28c4acd1dd857fe4807e6a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7", "patch": "@@ -1,3 +1,10 @@\n+Wed Aug  4 01:43:01 1999  Ian Lance Taylor  <ian@zembu.com>\n+\n+\t* gcc.c (access_check): New static function.\n+\t(find_a_file): Use it when searching a directory list.\n+\t* collect2.c (find_a_file): Don't accept directories found when\n+\tsearching a directory list.\n+\n Wed Aug  4 01:40:43 1999  Philippe De Muyter  <phdm@macqel.be>\n \n \t* tlink.c (symbol_hash_lookup): Do not prefix functions used as"}, {"sha": "ea97261a762fd8bccc2d63bbc865e3eb915ac2fc", "filename": "gcc/collect2.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7", "patch": "@@ -853,18 +853,24 @@ find_a_file (pprefix, name)\n   else\n     for (pl = pprefix->plist; pl; pl = pl->next)\n       {\n+\tstruct stat st;\n+\n \tstrcpy (temp, pl->prefix);\n \tstrcat (temp, name);\n \t\n-\tif (access (temp, X_OK) == 0)\n+\tif (stat (temp, &st) >= 0\n+\t    && ! S_ISDIR (st.st_mode)\n+\t    && access (temp, X_OK) == 0)\n \t  return temp;\n \n #ifdef EXECUTABLE_SUFFIX\n \t/* Some systems have a suffix for executable files.\n \t   So try appending that.  */\n \tstrcat (temp, EXECUTABLE_SUFFIX);\n \t\n-\tif (access (temp, X_OK) == 0)\n+\tif (stat (temp, &st) >= 0\n+\t    && ! S_ISDIR (st.st_mode)\n+\t    && access (temp, X_OK) == 0)\n \t  return temp;\n #endif\n       }"}, {"sha": "cf84e51c161b2aa7cb6e404c5a47877d359a85fd", "filename": "gcc/gcc.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=ca6062011d6bf45dbf4c2f9a7d12f671a58f50b7", "patch": "@@ -177,6 +177,7 @@ static void set_spec\t\tPROTO((const char *, const char *));\n static struct compiler *lookup_compiler PROTO((const char *, size_t, const char *));\n static char *build_search_list\tPROTO((struct path_prefix *, const char *, int));\n static void putenv_from_prefixes PROTO((struct path_prefix *, const char *));\n+static int access_check\t\tPROTO((const char *, int));\n static char *find_a_file\tPROTO((struct path_prefix *, const char *, int));\n static void add_prefix\t\tPROTO((struct path_prefix *, const char *,\n \t\t\t\t       const char *, int, int, int *));\n@@ -1954,6 +1955,26 @@ putenv_from_prefixes (paths, env_var)\n   putenv (build_search_list (paths, env_var, 1));\n }\n \f\n+/* Check whether NAME can be accessed in MODE.  This is like access,\n+   except that it never considers directories to be executable.  */\n+\n+static int\n+access_check (name, mode)\n+     const char *name;\n+     int mode;\n+{\n+  if (mode == X_OK)\n+    {\n+      struct stat st;\n+\n+      if (stat (name, &st) < 0\n+\t  || S_ISDIR (st.st_mode))\n+\treturn -1;\n+    }\n+\n+  return access (name, mode);\n+}\n+\n /* Search for NAME using the prefix list PREFIXES.  MODE is passed to\n    access to check permissions.\n    Return 0 if not found, otherwise return its name, allocated with malloc.  */\n@@ -2022,7 +2043,7 @@ find_a_file (pprefix, name, mode)\n \t\tstrcat (temp, machine_suffix);\n \t\tstrcat (temp, name);\n \t\tstrcat (temp, file_suffix);\n-\t\tif (access (temp, mode) == 0)\n+\t\tif (access_check (temp, mode) == 0)\n \t\t  {\n \t\t    if (pl->used_flag_ptr != 0)\n \t\t      *pl->used_flag_ptr = 1;\n@@ -2034,7 +2055,7 @@ find_a_file (pprefix, name, mode)\n \t    strcpy (temp, pl->prefix);\n \t    strcat (temp, machine_suffix);\n \t    strcat (temp, name);\n-\t    if (access (temp, mode) == 0)\n+\t    if (access_check (temp, mode) == 0)\n \t      {\n \t\tif (pl->used_flag_ptr != 0)\n \t\t  *pl->used_flag_ptr = 1;\n@@ -2054,7 +2075,7 @@ find_a_file (pprefix, name, mode)\n \t\tstrcat (temp, just_machine_suffix);\n \t\tstrcat (temp, name);\n \t\tstrcat (temp, file_suffix);\n-\t\tif (access (temp, mode) == 0)\n+\t\tif (access_check (temp, mode) == 0)\n \t\t  {\n \t\t    if (pl->used_flag_ptr != 0)\n \t\t      *pl->used_flag_ptr = 1;\n@@ -2065,7 +2086,7 @@ find_a_file (pprefix, name, mode)\n \t    strcpy (temp, pl->prefix);\n \t    strcat (temp, just_machine_suffix);\n \t    strcat (temp, name);\n-\t    if (access (temp, mode) == 0)\n+\t    if (access_check (temp, mode) == 0)\n \t      {\n \t\tif (pl->used_flag_ptr != 0)\n \t\t  *pl->used_flag_ptr = 1;\n@@ -2084,7 +2105,7 @@ find_a_file (pprefix, name, mode)\n \t\tstrcpy (temp, pl->prefix);\n \t\tstrcat (temp, name);\n \t\tstrcat (temp, file_suffix);\n-\t\tif (access (temp, mode) == 0)\n+\t\tif (access_check (temp, mode) == 0)\n \t\t  {\n \t\t    if (pl->used_flag_ptr != 0)\n \t\t      *pl->used_flag_ptr = 1;\n@@ -2094,7 +2115,7 @@ find_a_file (pprefix, name, mode)\n \n \t    strcpy (temp, pl->prefix);\n \t    strcat (temp, name);\n-\t    if (access (temp, mode) == 0)\n+\t    if (access_check (temp, mode) == 0)\n \t      {\n \t\tif (pl->used_flag_ptr != 0)\n \t\t  *pl->used_flag_ptr = 1;"}]}