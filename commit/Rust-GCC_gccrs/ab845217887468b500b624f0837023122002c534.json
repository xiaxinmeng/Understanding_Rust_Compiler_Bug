{"sha": "ab845217887468b500b624f0837023122002c534", "node_id": "C_kwDOANBUbNoAKGFiODQ1MjE3ODg3NDY4YjUwMGI2MjRmMDgzNzAyMzEyMjAwMmM1MzQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-26T09:13:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-26T09:13:40Z"}, "message": "Merge #1162 #1167 #1168 #1170\n\n1162: CI: catch malformed test cases r=philberty a=liushuyu\n\n- catch malformed test cases and use GitHub Actions' annotation feature to mark the failures\n\n1167: Fix nullptr when resolving the root of a path expression r=philberty a=philberty\n\nWhen we resolve paths we don't have a _type_, in this scenario there is a\r\nbug in our resolution of this generic function so this means the root_tyty\r\nis nullptr but the offset is non zero so we return nullptr.\r\n\r\nAddresses #1132\r\n\r\nThis test case no longer ICE's but still fails. I have a fix in progress for this\r\n\r\n```rust\r\nmod mem {\r\n    extern \"rust-intrinsic\" {\r\n        fn transmute<U, V>(_: U) -> V;\r\n    }\r\n}\r\n\r\npub trait Hasher {\r\n    fn write(&mut self, bytes: &[u8]);\r\n    fn write_u16(&mut self, i: u16) {\r\n        self.write(&mem::transmute::<_, [u8; 2]>(i))\r\n    }\r\n}\r\n\r\npub struct SipHasher;\r\n\r\nimpl Hasher for SipHasher {\r\n    #[inline]\r\n    fn write(&mut self, msg: &[u8]) {}\r\n}\r\n\r\n```\n\n1168: ast: resolve: Move ResolveItem into its own source file r=CohenArthur a=CohenArthur\n\nSince we need to add new functions to resolve visibilities, we might as well refactor this file before hand :) \n\n1170: Implement macro expansion in `IfExpr`, `IfExprConseqElse`, `IfExprConseqIf`, `IfExprConseqIfLet`. r=CohenArthur a=antego\n\nAddresses #1141. Following up on #1161.\r\n\r\nThis change adds support for the macros inside the `if` condition expressions.\r\n\r\nThings to note:\r\n1. Judging by my research, the `IfExprConseqIfLet` isn't used. The parser treats the syntax `let var = if ...` as a `let` expression followed by `if` expression:\r\n![Screen Shot 2022-04-26 at 9 47 29 am](https://user-images.githubusercontent.com/1451467/165258060-6a42f918-2585-4aef-9da5-9d60d69ca248.png)\r\n2. I didn't add the macro expansion to the `IfLetExpr...` family of expressions because I wasn't able to write a test case reproducing the missing macro expansion. I've tried the following code\r\n```rust\r\nfn main() -> i32 {\r\n    let mut res = 0;\r\n\r\n    enum E {\r\n        X(u8),\r\n        Y(u8),\r\n        Z(u8),\r\n    }\r\n    let v = E::Y(12);\r\n    if let E::Y(n) = v {\r\n        res = 1;\r\n    }\r\n\r\n    0\r\n}\r\n```\r\nwhich caused the compiler error\r\n```\r\nFAIL: rust/compile/macro43.rs (internal compiler error: in append_reference_for_def, at rust/resolve/rust-name-resolver.h:227)\r\n```\r\n\r\n\n\nCo-authored-by: liushuyu <liushuyu011@gmail.com>\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\nCo-authored-by: antego <antego@users.noreply.github.com>", "tree": {"sha": "e54833a2cf855895e81f16e78dd546e2cb9a51e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e54833a2cf855895e81f16e78dd546e2cb9a51e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab845217887468b500b624f0837023122002c534", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiZ7fECRBK7hj4Ov3rIwAAWogIAJS71+tcSaHLYH0U8rONiwfl\nejfedsBga4IqWRBk7nUi+Ncqh1iaz4kzlv6Fhi2CyUSfGAW3SV/Wq4xUsXvoui+u\novuNuqEIKpmSFbCKPSk67lXCnTiuqAsKLRGw3Jj4Y96ZDZhO03D0YBleWcqCK3w1\nuDhmpjC1E55yRrrk9TwGbGoNiTjfWHt6yMsTkZNj9LPmwI6SX6wff1aLo0HaQPJ+\nTO86vdS9H1jxhuvNoAt2eSr1CxiJjf6b32aU1kXGaV99B5zJ1lk3y5IpK0iL03Ng\nRTmvSWUa4B7x/aQ95nhpE8juVHlpPvqJI5ohwNp3UWKeMKLIylOPDzXQW8FQipI=\n=urvq\n-----END PGP SIGNATURE-----\n", "payload": "tree e54833a2cf855895e81f16e78dd546e2cb9a51e5\nparent d7c5bbe6af7189a95d1e4f2d4171fd8b53e826b3\nparent 461bf1369fa0bb1c411ecdf649dbbe62f86d0070\nparent 1d19dd8a691fd3fcc6214e99d9da5bc9fcb1c122\nparent 3e01b6b2a8727142e3bfd8229e8272c288421c5d\nparent d780b204d84433fa3bd88853985e073b02b8f3a2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1650964420 +0000\ncommitter GitHub <noreply@github.com> 1650964420 +0000\n\nMerge #1162 #1167 #1168 #1170\n\n1162: CI: catch malformed test cases r=philberty a=liushuyu\n\n- catch malformed test cases and use GitHub Actions' annotation feature to mark the failures\n\n1167: Fix nullptr when resolving the root of a path expression r=philberty a=philberty\n\nWhen we resolve paths we don't have a _type_, in this scenario there is a\r\nbug in our resolution of this generic function so this means the root_tyty\r\nis nullptr but the offset is non zero so we return nullptr.\r\n\r\nAddresses #1132\r\n\r\nThis test case no longer ICE's but still fails. I have a fix in progress for this\r\n\r\n```rust\r\nmod mem {\r\n    extern \"rust-intrinsic\" {\r\n        fn transmute<U, V>(_: U) -> V;\r\n    }\r\n}\r\n\r\npub trait Hasher {\r\n    fn write(&mut self, bytes: &[u8]);\r\n    fn write_u16(&mut self, i: u16) {\r\n        self.write(&mem::transmute::<_, [u8; 2]>(i))\r\n    }\r\n}\r\n\r\npub struct SipHasher;\r\n\r\nimpl Hasher for SipHasher {\r\n    #[inline]\r\n    fn write(&mut self, msg: &[u8]) {}\r\n}\r\n\r\n```\n\n1168: ast: resolve: Move ResolveItem into its own source file r=CohenArthur a=CohenArthur\n\nSince we need to add new functions to resolve visibilities, we might as well refactor this file before hand :) \n\n1170: Implement macro expansion in `IfExpr`, `IfExprConseqElse`, `IfExprConseqIf`, `IfExprConseqIfLet`. r=CohenArthur a=antego\n\nAddresses #1141. Following up on #1161.\r\n\r\nThis change adds support for the macros inside the `if` condition expressions.\r\n\r\nThings to note:\r\n1. Judging by my research, the `IfExprConseqIfLet` isn't used. The parser treats the syntax `let var = if ...` as a `let` expression followed by `if` expression:\r\n![Screen Shot 2022-04-26 at 9 47 29 am](https://user-images.githubusercontent.com/1451467/165258060-6a42f918-2585-4aef-9da5-9d60d69ca248.png)\r\n2. I didn't add the macro expansion to the `IfLetExpr...` family of expressions because I wasn't able to write a test case reproducing the missing macro expansion. I've tried the following code\r\n```rust\r\nfn main() -> i32 {\r\n    let mut res = 0;\r\n\r\n    enum E {\r\n        X(u8),\r\n        Y(u8),\r\n        Z(u8),\r\n    }\r\n    let v = E::Y(12);\r\n    if let E::Y(n) = v {\r\n        res = 1;\r\n    }\r\n\r\n    0\r\n}\r\n```\r\nwhich caused the compiler error\r\n```\r\nFAIL: rust/compile/macro43.rs (internal compiler error: in append_reference_for_def, at rust/resolve/rust-name-resolver.h:227)\r\n```\r\n\r\n\n\nCo-authored-by: liushuyu <liushuyu011@gmail.com>\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\nCo-authored-by: antego <antego@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab845217887468b500b624f0837023122002c534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab845217887468b500b624f0837023122002c534", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab845217887468b500b624f0837023122002c534/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7c5bbe6af7189a95d1e4f2d4171fd8b53e826b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7c5bbe6af7189a95d1e4f2d4171fd8b53e826b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7c5bbe6af7189a95d1e4f2d4171fd8b53e826b3"}, {"sha": "461bf1369fa0bb1c411ecdf649dbbe62f86d0070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/461bf1369fa0bb1c411ecdf649dbbe62f86d0070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/461bf1369fa0bb1c411ecdf649dbbe62f86d0070"}, {"sha": "1d19dd8a691fd3fcc6214e99d9da5bc9fcb1c122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d19dd8a691fd3fcc6214e99d9da5bc9fcb1c122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d19dd8a691fd3fcc6214e99d9da5bc9fcb1c122"}, {"sha": "3e01b6b2a8727142e3bfd8229e8272c288421c5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e01b6b2a8727142e3bfd8229e8272c288421c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e01b6b2a8727142e3bfd8229e8272c288421c5d"}, {"sha": "d780b204d84433fa3bd88853985e073b02b8f3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d780b204d84433fa3bd88853985e073b02b8f3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d780b204d84433fa3bd88853985e073b02b8f3a2"}], "stats": {"total": 1959, "additions": 1059, "deletions": 900}, "files": [{"sha": "cf8c3ad8042e049f40b2f8d600f81ecc9726af14", "filename": ".github/emit_test_errors.pl", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab845217887468b500b624f0837023122002c534/.github%2Femit_test_errors.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab845217887468b500b624f0837023122002c534/.github%2Femit_test_errors.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Femit_test_errors.pl?ref=ab845217887468b500b624f0837023122002c534", "patch": "@@ -0,0 +1,25 @@\n+#!/bin/perl -n\n+\n+sub analyze_errors() {\n+    /^(FAIL|ERROR|XPASS):\\s([^:\\s]+):?\\s+(.+)/;\n+\n+    my $type     = $1;\n+    my $filename = $2;\n+    my $message  = $3;\n+    my $line;\n+\n+    if ( !$type ) { return; }\n+\n+    if ( $message =~ /(at line (\\d+))?.+(test for \\w+, line (\\d+))/g ) {\n+        $line = $2 || $4;\n+    }\n+\n+    my $command = \"::error file=gcc/testsuite/$filename\";\n+    if ($line) {\n+        $command = \"$command,line=$line\";\n+    }\n+\n+    print \"$command,title=Test failure ($type)::$message\\n\";\n+}\n+\n+analyze_errors();"}, {"sha": "6fdfd9748b8e76f56abeb246de30a3cc9390f997", "filename": ".github/workflows/ccpp.yml", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab845217887468b500b624f0837023122002c534/.github%2Fworkflows%2Fccpp.yml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab845217887468b500b624f0837023122002c534/.github%2Fworkflows%2Fccpp.yml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fworkflows%2Fccpp.yml?ref=ab845217887468b500b624f0837023122002c534", "patch": "@@ -77,9 +77,10 @@ jobs:\n     - name: Check regressions\n       run: |\n            cd gccrs-build; \\\n-           if grep -e \"unexpected\" -e \"unresolved\" gcc/testsuite/rust/rust.sum;\\\n+           if grep -e \"unexpected\" -e \"unresolved\" -e \"ERROR:\" gcc/testsuite/rust/rust.sum;\\\n            then \\\n-              echo \"some tests are not correct\"; \\\n+              echo \"::error title=Regression test failed::some tests are not correct\"; \\\n+              perl -n ../.github/emit_test_errors.pl < gcc/testsuite/rust/rust.sum; \\\n               exit 1; \\\n             else \\\n               exit 0; \\\n@@ -142,9 +143,9 @@ jobs:\n     - name: Check regressions\n       run: |\n            cd gccrs-build; \\\n-           if grep -e \"unexpected\" -e \"unresolved\" gcc/testsuite/rust/rust.sum;\\\n+           if grep -e \"unexpected\" -e \"unresolved\" -e \"ERROR:\" gcc/testsuite/rust/rust.sum;\\\n            then \\\n-              echo \"some tests are not correct\"; \\\n+              echo \"::error title=Regression test failed::some tests are not correct\"; \\\n               exit 1; \\\n             else \\\n               exit 0; \\\n@@ -196,9 +197,9 @@ jobs:\n     - name: Check regressions\n       run: |\n            cd gccrs-build; \\\n-           if grep -e \"unexpected\" -e \"unresolved\" gcc/testsuite/rust/rust.sum;\\\n+           if grep -e \"unexpected\" -e \"unresolved\" -e \"ERROR:\" gcc/testsuite/rust/rust.sum;\\\n            then \\\n-              echo \"some tests are not correct\"; \\\n+              echo \"::error title=Regression test failed::some tests are not correct\"; \\\n               exit 1; \\\n             else \\\n               exit 0; \\"}, {"sha": "5fa93a08ddb5dd499113fc271cec6288328d7b2a", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=ab845217887468b500b624f0837023122002c534", "patch": "@@ -87,6 +87,7 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-pattern.o \\\n     rust/rust-name-resolver.o \\\n     rust/rust-ast-resolve.o \\\n+    rust/rust-ast-resolve-item.o \\\n     rust/rust-ast-resolve-pattern.o \\\n     rust/rust-ast-resolve-expr.o \\\n     rust/rust-ast-resolve-type.o \\"}, {"sha": "842fbdf680a50615b9ba817b2076d4ad107611a6", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=ab845217887468b500b624f0837023122002c534", "patch": "@@ -1630,6 +1630,9 @@ AttrVisitor::visit (AST::IfExpr &expr)\n   // can't strip condition expr itself, but can strip sub-expressions\n   auto &condition_expr = expr.get_condition_expr ();\n   condition_expr->accept_vis (*this);\n+  auto cond_fragment = expander.take_expanded_fragment (*this);\n+  if (cond_fragment.should_expand ())\n+    condition_expr = cond_fragment.take_expression_fragment ();\n   if (condition_expr->is_marked_for_strip ())\n     rust_error_at (condition_expr->get_locus (),\n \t\t   \"cannot strip expression in this position - outer \"\n@@ -1657,6 +1660,9 @@ AttrVisitor::visit (AST::IfExprConseqElse &expr)\n   // can't strip condition expr itself, but can strip sub-expressions\n   auto &condition_expr = expr.get_condition_expr ();\n   condition_expr->accept_vis (*this);\n+  auto cond_fragment = expander.take_expanded_fragment (*this);\n+  if (cond_fragment.should_expand ())\n+    condition_expr = cond_fragment.take_expression_fragment ();\n   if (condition_expr->is_marked_for_strip ())\n     rust_error_at (condition_expr->get_locus (),\n \t\t   \"cannot strip expression in this position - outer \"\n@@ -1692,6 +1698,9 @@ AttrVisitor::visit (AST::IfExprConseqIf &expr)\n   // can't strip condition expr itself, but can strip sub-expressions\n   auto &condition_expr = expr.get_condition_expr ();\n   condition_expr->accept_vis (*this);\n+  auto cond_fragment = expander.take_expanded_fragment (*this);\n+  if (cond_fragment.should_expand ())\n+    condition_expr = cond_fragment.take_expression_fragment ();\n   if (condition_expr->is_marked_for_strip ())\n     rust_error_at (condition_expr->get_locus (),\n \t\t   \"cannot strip expression in this position - outer \"\n@@ -1727,6 +1736,9 @@ AttrVisitor::visit (AST::IfExprConseqIfLet &expr)\n   // can't strip condition expr itself, but can strip sub-expressions\n   auto &condition_expr = expr.get_condition_expr ();\n   condition_expr->accept_vis (*this);\n+  auto cond_fragment = expander.take_expanded_fragment (*this);\n+  if (cond_fragment.should_expand ())\n+    condition_expr = cond_fragment.take_expression_fragment ();\n   if (condition_expr->is_marked_for_strip ())\n     rust_error_at (condition_expr->get_locus (),\n \t\t   \"cannot strip expression in this position - outer \""}, {"sha": "954669818dec07fec4af092d40de65c1bd630b5c", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "added", "additions": 952, "deletions": 0, "changes": 952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=ab845217887468b500b624f0837023122002c534", "patch": "@@ -0,0 +1,952 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-item.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+void\n+ResolveTraitItems::go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t       const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveTraitItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemType &type)\n+{\n+  auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   type.get_node_id (), cpath);\n+\n+  for (auto &bound : type.get_type_param_bounds ())\n+    ResolveTypeBound::go (bound.get (), type.get_node_id ());\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemFunc &func)\n+{\n+  auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (func);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   func.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = func.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), func.get_node_id ());\n+    }\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      param.get_node_id ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+      resolver->mark_assignment_to_decl (\n+\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+    }\n+\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  // trait items have an optional body\n+  if (func.has_definition ())\n+    ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n+\t\t     cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemMethod &func)\n+{\n+  auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (func);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   func.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = func.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), func.get_node_id ());\n+    }\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+  // self turns into (self: Self) as a function param\n+  AST::SelfParam &self_param = function.get_self_param ();\n+  AST::IdentifierPattern self_pattern (self_param.get_node_id (), \"self\",\n+\t\t\t\t       self_param.get_locus (),\n+\t\t\t\t       self_param.get_has_ref (),\n+\t\t\t\t       self_param.get_is_mut (),\n+\t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n+\n+  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+    new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+  AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n+\n+  ResolveType::go (&self_type_path, self_param.get_node_id ());\n+  PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+  resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t     self_pattern.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      param.get_node_id ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+      resolver->mark_assignment_to_decl (\n+\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+    }\n+\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  // trait items have an optional body\n+  if (func.has_definition ())\n+    ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n+\t\t     cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemConst &constant)\n+{\n+  auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   constant.get_node_id (), cpath);\n+\n+  ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+\n+  if (constant.has_expr ())\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n+\t\t     cpath);\n+\n+  // the mutability checker needs to verify for immutable decls the number\n+  // of assignments are <1. This marks an implicit assignment\n+  resolver->mark_decl_mutability (constant.get_node_id (), false);\n+  resolver->mark_assignment_to_decl (constant.get_node_id (),\n+\t\t\t\t     constant.get_node_id ());\n+}\n+\n+void\n+ResolveItem::go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t const CanonicalPath &canonical_prefix)\n+{\n+  ResolveItem resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveItem::visit (AST::TypeAlias &alias)\n+{\n+  auto talias\n+    = CanonicalPath::new_seg (alias.get_node_id (), alias.get_new_type_name ());\n+  auto path = prefix.append (talias);\n+  auto cpath = canonical_prefix.append (talias);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   alias.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = alias.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (alias.has_generics ())\n+    {\n+      for (auto &generic : alias.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), alias.get_node_id ());\n+    }\n+\n+  if (alias.has_where_clause ())\n+    ResolveWhereClause::Resolve (alias.get_where_clause ());\n+\n+  ResolveType::go (alias.get_type_aliased ().get (), alias.get_node_id ());\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Module &module)\n+{\n+  auto mod = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n+  auto path = prefix.append (mod);\n+  auto cpath = canonical_prefix.append (mod);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   module.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = module.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  for (auto &item : module.get_items ())\n+    ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath);\n+\n+  for (auto &item : module.get_items ())\n+    ResolveItem::go (item.get (), path, cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::TupleStruct &struct_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t      struct_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   struct_decl.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = struct_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (struct_decl.has_generics ())\n+    {\n+      for (auto &generic : struct_decl.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), struct_decl.get_node_id ());\n+\t}\n+    }\n+\n+  if (struct_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n+\n+  for (AST::TupleField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       struct_decl.get_node_id ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Enum &enum_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t      enum_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   enum_decl.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = enum_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (enum_decl.has_generics ())\n+    {\n+      for (auto &generic : enum_decl.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), enum_decl.get_node_id ());\n+\t}\n+    }\n+\n+  if (enum_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (enum_decl.get_where_clause ());\n+\n+  /* The actual fields are inside the variants.  */\n+  for (auto &variant : enum_decl.get_variants ())\n+    ResolveItem::go (variant.get (), path, cpath);\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+/* EnumItem doesn't need to be handled, no fields.  */\n+void\n+ResolveItem::visit (AST::EnumItem &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   item.get_node_id (), cpath);\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemTuple &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   item.get_node_id (), cpath);\n+\n+  for (auto &field : item.get_tuple_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+    }\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemStruct &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   item.get_node_id (), cpath);\n+\n+  for (auto &field : item.get_struct_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+    }\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemDiscriminant &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   item.get_node_id (), cpath);\n+}\n+\n+void\n+ResolveItem::visit (AST::StructStruct &struct_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t      struct_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   struct_decl.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = struct_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (struct_decl.has_generics ())\n+    {\n+      for (auto &generic : struct_decl.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), struct_decl.get_node_id ());\n+\t}\n+    }\n+\n+  if (struct_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n+\n+  for (AST::StructField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       struct_decl.get_node_id ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Union &union_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t      union_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   union_decl.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = union_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (union_decl.has_generics ())\n+    {\n+      for (auto &generic : union_decl.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), union_decl.get_node_id ());\n+\t}\n+    }\n+\n+  if (union_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (union_decl.get_where_clause ());\n+\n+  for (AST::StructField &field : union_decl.get_variants ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       union_decl.get_node_id ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::StaticItem &var)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   var.get_node_id (), cpath);\n+\n+  ResolveType::go (var.get_type ().get (), var.get_node_id ());\n+  ResolveExpr::go (var.get_expr ().get (), var.get_node_id (), path, cpath);\n+\n+  // the mutability checker needs to verify for immutable decls the number\n+  // of assignments are <1. This marks an implicit assignment\n+  resolver->mark_assignment_to_decl (var.get_node_id (), var.get_node_id ());\n+}\n+\n+void\n+ResolveItem::visit (AST::ConstantItem &constant)\n+{\n+  auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   constant.get_node_id (), cpath);\n+\n+  ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+  ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n+\t\t   cpath);\n+\n+  // the mutability checker needs to verify for immutable decls the number\n+  // of assignments are <1. This marks an implicit assignment\n+  resolver->mark_decl_mutability (constant.get_node_id (), false);\n+  resolver->mark_assignment_to_decl (constant.get_node_id (),\n+\t\t\t\t     constant.get_node_id ());\n+}\n+\n+void\n+ResolveItem::visit (AST::Function &function)\n+{\n+  auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   function.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = function.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), function.get_node_id ());\n+    }\n+\n+  // resolve any where clause items\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get (),\n+\t\t     function.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      param.get_node_id ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+      resolver->mark_assignment_to_decl (\n+\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+    }\n+\n+  // resolve the function body\n+  ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n+\t\t   path, cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::InherentImpl &impl_block)\n+{\n+  NodeId scope_node_id = impl_block.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  if (impl_block.has_generics ())\n+    {\n+      for (auto &generic : impl_block.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n+\t}\n+    }\n+\n+  // resolve any where clause items\n+  if (impl_block.has_where_clause ())\n+    ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n+\n+  // FIXME this needs to be protected behind nominal type-checks see:\n+  // rustc --explain E0118\n+\n+  CanonicalPath self_cpath = CanonicalPath::create_empty ();\n+  bool canonicalize_type_with_generics = false;\n+  NodeId resolved_node\n+    = ResolveType::go (impl_block.get_type ().get (), impl_block.get_node_id (),\n+\t\t       canonicalize_type_with_generics, &self_cpath);\n+  if (resolved_node == UNKNOWN_NODEID)\n+    {\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_name_scope ().pop ();\n+      return;\n+    }\n+\n+  // Setup paths\n+  bool canonicalize_type_args = !impl_block.has_generics ();\n+  bool type_resolve_generic_args = false;\n+\n+  CanonicalPath impl_type\n+    = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+  CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n+  // see https://godbolt.org/z/a3vMbsT6W\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  if (canonical_prefix.size () <= 1)\n+    {\n+      cpath = self_cpath;\n+    }\n+  else\n+    {\n+      std::string seg_buf = \"<impl \" + self_cpath.get () + \">\";\n+      CanonicalPath seg\n+\t= CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+      cpath = canonical_prefix.append (seg);\n+    }\n+  // done setup paths\n+\n+  auto Self\n+    = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().insert (Self,\n+\t\t\t\t      impl_block.get_type ()->get_node_id (),\n+\t\t\t\t      impl_block.get_type ()->get_locus ());\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      resolve_impl_item (impl_item.get (), impl_prefix, cpath);\n+    }\n+\n+  resolver->get_type_scope ().peek ()->clear_name (\n+    Self, impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_name_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Method &method)\n+{\n+  auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   method.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = method.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  if (method.has_generics ())\n+    {\n+      for (auto &generic : method.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), method.get_node_id ());\n+    }\n+\n+  // resolve any where clause items\n+  if (method.has_where_clause ())\n+    ResolveWhereClause::Resolve (method.get_where_clause ());\n+\n+  if (method.has_return_type ())\n+    ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n+\n+  // self turns into (self: Self) as a function param\n+  AST::SelfParam &self_param = method.get_self_param ();\n+  AST::IdentifierPattern self_pattern (self_param.get_node_id (), \"self\",\n+\t\t\t\t       self_param.get_locus (),\n+\t\t\t\t       self_param.get_has_ref (),\n+\t\t\t\t       self_param.get_is_mut (),\n+\t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n+\n+  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+    new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+  AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n+\n+  ResolveType::go (&self_type_path, self_param.get_node_id ());\n+  PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+  resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t     self_pattern.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : method.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      param.get_node_id ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+      resolver->mark_assignment_to_decl (\n+\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+    }\n+\n+  // resolve any where clause items\n+  if (method.has_where_clause ())\n+    ResolveWhereClause::Resolve (method.get_where_clause ());\n+\n+  // resolve the function body\n+  ResolveExpr::go (method.get_definition ().get (), method.get_node_id (), path,\n+\t\t   cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::TraitImpl &impl_block)\n+{\n+  NodeId scope_node_id = impl_block.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  if (impl_block.has_generics ())\n+    {\n+      for (auto &generic : impl_block.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n+\t}\n+    }\n+\n+  // resolve any where clause items\n+  if (impl_block.has_where_clause ())\n+    ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n+\n+  CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n+  bool canonicalize_type_with_generics = false;\n+  NodeId trait_resolved_node\n+    = ResolveType::go (&impl_block.get_trait_path (), impl_block.get_node_id (),\n+\t\t       canonicalize_type_with_generics, &canonical_trait_type);\n+  if (trait_resolved_node == UNKNOWN_NODEID)\n+    {\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_name_scope ().pop ();\n+      return;\n+    }\n+\n+  CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n+  NodeId type_resolved_node\n+    = ResolveType::go (impl_block.get_type ().get (), impl_block.get_node_id (),\n+\t\t       canonicalize_type_with_generics, &canonical_impl_type);\n+  if (type_resolved_node == UNKNOWN_NODEID)\n+    {\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_name_scope ().pop ();\n+      return;\n+    }\n+\n+  // setup paths\n+  bool canonicalize_type_args = !impl_block.has_generics ();\n+  bool type_resolve_generic_args = false;\n+\n+  CanonicalPath impl_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+  CanonicalPath trait_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (impl_block.get_trait_path (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+\n+  CanonicalPath projection\n+    = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n+\t\t\t\t    impl_type_seg);\n+  CanonicalPath impl_prefix = prefix.append (projection);\n+\n+  // setup canonical-path\n+  CanonicalPath canonical_projection\n+    = TraitImplProjection::resolve (impl_block.get_node_id (),\n+\t\t\t\t    canonical_trait_type, canonical_impl_type);\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  if (canonical_prefix.size () <= 1)\n+    {\n+      cpath = canonical_projection;\n+    }\n+  else\n+    {\n+      std::string projection_str = canonical_projection.get ();\n+      std::string seg_buf\n+\t= \"<impl \" + projection_str.substr (1, projection_str.size () - 2)\n+\t  + \">\";\n+      CanonicalPath seg\n+\t= CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+      cpath = canonical_prefix.append (seg);\n+    }\n+\n+  // DONE setup canonical-path\n+\n+  auto Self\n+    = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().insert (Self,\n+\t\t\t\t      impl_block.get_type ()->get_node_id (),\n+\t\t\t\t      impl_block.get_type ()->get_locus ());\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      resolve_impl_item (impl_item.get (), impl_prefix, cpath);\n+    }\n+\n+  resolver->get_type_scope ().peek ()->clear_name (\n+    Self, impl_block.get_type ()->get_node_id ());\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Trait &trait)\n+{\n+  NodeId scope_node_id = trait.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  // we need to inject an implicit self TypeParam here\n+  AST::TypeParam *implicit_self\n+    = new AST::TypeParam (\"Self\", trait.get_locus ());\n+  trait.insert_implict_self (\n+    std::unique_ptr<AST::GenericParam> (implicit_self));\n+  CanonicalPath Self = CanonicalPath::get_big_self (trait.get_node_id ());\n+\n+  for (auto &generic : trait.get_generic_params ())\n+    {\n+      ResolveGenericParam::go (generic.get (), trait.get_node_id ());\n+    }\n+\n+  // Self is an implicit TypeParam so lets mark it as such\n+  resolver->get_type_scope ().append_reference_for_def (\n+    Self.get_node_id (), implicit_self->get_node_id ());\n+\n+  if (trait.has_type_param_bounds ())\n+    {\n+      for (auto &bound : trait.get_type_param_bounds ())\n+\t{\n+\t  ResolveTypeBound::go (bound.get (), trait.get_node_id ());\n+\t}\n+    }\n+\n+  // resolve any where clause items\n+  if (trait.has_where_clause ())\n+    ResolveWhereClause::Resolve (trait.get_where_clause ());\n+\n+  // resolve the paths\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  //\n+\n+  for (auto &item : trait.get_trait_items ())\n+    {\n+      ResolveTraitItems::go (item.get (), path, cpath);\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_name_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      resolve_extern_item (item.get ());\n+    }\n+}\n+\n+void\n+ResolveImplItems::go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveImplItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveImplItems::go (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveImplItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveImplItems::visit (AST::TypeAlias &alias)\n+{\n+  ResolveItem::visit (alias);\n+\n+  // FIXME this stops the erronious unused decls which will be fixed later on\n+  resolver->get_type_scope ().append_reference_for_def (alias.get_node_id (),\n+\t\t\t\t\t\t\talias.get_node_id ());\n+}\n+\n+void\n+ResolveExternItem::go (AST::ExternalItem *item)\n+{\n+  ResolveExternItem resolver;\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveExternItem::visit (AST::ExternalFunctionItem &function)\n+{\n+  NodeId scope_node_id = function.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  // resolve the generics\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), function.get_node_id ());\n+    }\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get (),\n+\t\t     function.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+    }\n+\n+  // done\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExternItem::visit (AST::ExternalStaticItem &item)\n+{\n+  ResolveType::go (item.get_type ().get (), item.get_node_id ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "da5d4e823eb22c52551b870ab431390bce930b6b", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 30, "deletions": 893, "changes": 923, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=ab845217887468b500b624f0837023122002c534", "patch": "@@ -36,173 +36,12 @@ class ResolveTraitItems : public ResolverBase\n \n public:\n   static void go (AST::TraitItem *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    if (item->is_marked_for_strip ())\n-      return;\n+\t\t  const CanonicalPath &canonical_prefix);\n \n-    ResolveTraitItems resolver (prefix, canonical_prefix);\n-    item->accept_vis (resolver);\n-  };\n-\n-  void visit (AST::TraitItemType &type) override\n-  {\n-    auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     type.get_node_id (), cpath);\n-\n-    for (auto &bound : type.get_type_param_bounds ())\n-      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n-  }\n-\n-  void visit (AST::TraitItemFunc &func) override\n-  {\n-    auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (func);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     func.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = func.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n-      }\n-\n-    if (function.has_where_clause ())\n-      ResolveWhereClause::Resolve (function.get_where_clause ());\n-\n-    // trait items have an optional body\n-    if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n-\t\t       cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::TraitItemMethod &func) override\n-  {\n-    auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (func);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     func.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = func.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n-\n-    // self turns into (self: Self) as a function param\n-    AST::SelfParam &self_param = function.get_self_param ();\n-    AST::IdentifierPattern self_pattern (\n-      self_param.get_node_id (), \"self\", self_param.get_locus (),\n-      self_param.get_has_ref (), self_param.get_is_mut (),\n-      std::unique_ptr<AST::Pattern> (nullptr));\n-\n-    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n-    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n-      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n-\n-    AST::TypePath self_type_path (std::move (segments),\n-\t\t\t\t  self_param.get_locus ());\n-\n-    ResolveType::go (&self_type_path, self_param.get_node_id ());\n-    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n-\n-    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n-\t\t\t\t       self_pattern.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n-      }\n-\n-    if (function.has_where_clause ())\n-      ResolveWhereClause::Resolve (function.get_where_clause ());\n-\n-    // trait items have an optional body\n-    if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n-\t\t       cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::TraitItemConst &constant) override\n-  {\n-    auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     constant.get_node_id (), cpath);\n-\n-    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-\n-    if (constant.has_expr ())\n-      ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (),\n-\t\t       path, cpath);\n-\n-    // the mutability checker needs to verify for immutable decls the number\n-    // of assignments are <1. This marks an implicit assignment\n-    resolver->mark_decl_mutability (constant.get_node_id (), false);\n-    resolver->mark_assignment_to_decl (constant.get_node_id (),\n-\t\t\t\t       constant.get_node_id ());\n-  }\n+  void visit (AST::TraitItemType &type) override;\n+  void visit (AST::TraitItemFunc &func) override;\n+  void visit (AST::TraitItemMethod &func) override;\n+  void visit (AST::TraitItemConst &constant) override;\n \n private:\n   ResolveTraitItems (const CanonicalPath &prefix,\n@@ -221,667 +60,27 @@ class ResolveItem : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n   static void go (AST::Item *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    ResolveItem resolver (prefix, canonical_prefix);\n-    item->accept_vis (resolver);\n-  };\n-\n-  void visit (AST::TypeAlias &alias) override\n-  {\n-    auto talias = CanonicalPath::new_seg (alias.get_node_id (),\n-\t\t\t\t\t  alias.get_new_type_name ());\n-    auto path = prefix.append (talias);\n-    auto cpath = canonical_prefix.append (talias);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     alias.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = alias.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (alias.has_generics ())\n-      {\n-\tfor (auto &generic : alias.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), alias.get_node_id ());\n-      }\n-\n-    if (alias.has_where_clause ())\n-      ResolveWhereClause::Resolve (alias.get_where_clause ());\n-\n-    ResolveType::go (alias.get_type_aliased ().get (), alias.get_node_id ());\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::Module &module) override\n-  {\n-    auto mod\n-      = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n-    auto path = prefix.append (mod);\n-    auto cpath = canonical_prefix.append (mod);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     module.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = module.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    for (auto &item : module.get_items ())\n-      ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath);\n-\n-    for (auto &item : module.get_items ())\n-      ResolveItem::go (item.get (), path, cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::TupleStruct &struct_decl) override\n-  {\n-    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n-\t\t\t\t\tstruct_decl.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     struct_decl.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = struct_decl.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (struct_decl.has_generics ())\n-      {\n-\tfor (auto &generic : struct_decl.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (),\n-\t\t\t\t     struct_decl.get_node_id ());\n-\t  }\n-      }\n-\n-    if (struct_decl.has_where_clause ())\n-      ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n-\n-    for (AST::TupleField &field : struct_decl.get_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t struct_decl.get_node_id ());\n-      }\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::Enum &enum_decl) override\n-  {\n-    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n-\t\t\t\t\tenum_decl.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     enum_decl.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = enum_decl.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (enum_decl.has_generics ())\n-      {\n-\tfor (auto &generic : enum_decl.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), enum_decl.get_node_id ());\n-\t  }\n-      }\n-\n-    if (enum_decl.has_where_clause ())\n-      ResolveWhereClause::Resolve (enum_decl.get_where_clause ());\n-\n-    /* The actual fields are inside the variants.  */\n-    for (auto &variant : enum_decl.get_variants ())\n-      ResolveItem::go (variant.get (), path, cpath);\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n+\t\t  const CanonicalPath &canonical_prefix);\n \n+  void visit (AST::TypeAlias &alias) override;\n+  void visit (AST::Module &module) override;\n+  void visit (AST::TupleStruct &struct_decl) override;\n+  void visit (AST::Enum &enum_decl) override;\n   /* EnumItem doesn't need to be handled, no fields.  */\n-  void visit (AST::EnumItem &item) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     item.get_node_id (), cpath);\n-  }\n-\n-  void visit (AST::EnumItemTuple &item) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     item.get_node_id (), cpath);\n-\n-    for (auto &field : item.get_tuple_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n-      }\n-  }\n-\n-  void visit (AST::EnumItemStruct &item) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     item.get_node_id (), cpath);\n-\n-    for (auto &field : item.get_struct_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n-      }\n-  }\n-\n-  void visit (AST::EnumItemDiscriminant &item) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     item.get_node_id (), cpath);\n-  }\n-\n-  void visit (AST::StructStruct &struct_decl) override\n-  {\n-    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n-\t\t\t\t\tstruct_decl.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     struct_decl.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = struct_decl.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (struct_decl.has_generics ())\n-      {\n-\tfor (auto &generic : struct_decl.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (),\n-\t\t\t\t     struct_decl.get_node_id ());\n-\t  }\n-      }\n-\n-    if (struct_decl.has_where_clause ())\n-      ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n-\n-    for (AST::StructField &field : struct_decl.get_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t struct_decl.get_node_id ());\n-      }\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::Union &union_decl) override\n-  {\n-    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n-\t\t\t\t\tunion_decl.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     union_decl.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = union_decl.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (union_decl.has_generics ())\n-      {\n-\tfor (auto &generic : union_decl.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), union_decl.get_node_id ());\n-\t  }\n-      }\n-\n-    if (union_decl.has_where_clause ())\n-      ResolveWhereClause::Resolve (union_decl.get_where_clause ());\n-\n-    for (AST::StructField &field : union_decl.get_variants ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t union_decl.get_node_id ());\n-      }\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::StaticItem &var) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     var.get_node_id (), cpath);\n-\n-    ResolveType::go (var.get_type ().get (), var.get_node_id ());\n-    ResolveExpr::go (var.get_expr ().get (), var.get_node_id (), path, cpath);\n-\n-    // the mutability checker needs to verify for immutable decls the number\n-    // of assignments are <1. This marks an implicit assignment\n-    resolver->mark_assignment_to_decl (var.get_node_id (), var.get_node_id ());\n-  }\n-\n-  void visit (AST::ConstantItem &constant) override\n-  {\n-    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     constant.get_node_id (), cpath);\n-\n-    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n-\t\t     cpath);\n-\n-    // the mutability checker needs to verify for immutable decls the number\n-    // of assignments are <1. This marks an implicit assignment\n-    resolver->mark_decl_mutability (constant.get_node_id (), false);\n-    resolver->mark_assignment_to_decl (constant.get_node_id (),\n-\t\t\t\t       constant.get_node_id ());\n-  }\n-\n-  void visit (AST::Function &function) override\n-  {\n-    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     function.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = function.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), function.get_node_id ());\n-      }\n-\n-    // resolve any where clause items\n-    if (function.has_where_clause ())\n-      ResolveWhereClause::Resolve (function.get_where_clause ());\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (),\n-\t\t       function.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n-      }\n-\n-    // resolve the function body\n-    ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n-\t\t     path, cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::InherentImpl &impl_block) override\n-  {\n-    NodeId scope_node_id = impl_block.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-\n-    if (impl_block.has_generics ())\n-      {\n-\tfor (auto &generic : impl_block.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n-\t  }\n-      }\n-\n-    // resolve any where clause items\n-    if (impl_block.has_where_clause ())\n-      ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n-\n-    // FIXME this needs to be protected behind nominal type-checks see:\n-    // rustc --explain E0118\n-\n-    CanonicalPath self_cpath = CanonicalPath::create_empty ();\n-    bool canonicalize_type_with_generics = false;\n-    NodeId resolved_node\n-      = ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics, &self_cpath);\n-    if (resolved_node == UNKNOWN_NODEID)\n-      {\n-\tresolver->get_type_scope ().pop ();\n-\tresolver->get_name_scope ().pop ();\n-\treturn;\n-      }\n-\n-    // Setup paths\n-    bool canonicalize_type_args = !impl_block.has_generics ();\n-    bool type_resolve_generic_args = false;\n-\n-    CanonicalPath impl_type\n-      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n-    CanonicalPath impl_prefix = prefix.append (impl_type);\n-\n-    // see https://godbolt.org/z/a3vMbsT6W\n-    CanonicalPath cpath = CanonicalPath::create_empty ();\n-    if (canonical_prefix.size () <= 1)\n-      {\n-\tcpath = self_cpath;\n-      }\n-    else\n-      {\n-\tstd::string seg_buf = \"<impl \" + self_cpath.get () + \">\";\n-\tCanonicalPath seg\n-\t  = CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n-\tcpath = canonical_prefix.append (seg);\n-      }\n-    // done setup paths\n-\n-    auto Self\n-      = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n-\n-    resolver->get_type_scope ().insert (Self,\n-\t\t\t\t\timpl_block.get_type ()->get_node_id (),\n-\t\t\t\t\timpl_block.get_type ()->get_locus ());\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      {\n-\tresolve_impl_item (impl_item.get (), impl_prefix, cpath);\n-      }\n-\n-    resolver->get_type_scope ().peek ()->clear_name (\n-      Self, impl_block.get_type ()->get_node_id ());\n-\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_name_scope ().pop ();\n-  }\n-\n-  void visit (AST::Method &method) override\n-  {\n-    auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     method.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = method.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    if (method.has_generics ())\n-      {\n-\tfor (auto &generic : method.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), method.get_node_id ());\n-      }\n-\n-    // resolve any where clause items\n-    if (method.has_where_clause ())\n-      ResolveWhereClause::Resolve (method.get_where_clause ());\n-\n-    if (method.has_return_type ())\n-      ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n-\n-    // self turns into (self: Self) as a function param\n-    AST::SelfParam &self_param = method.get_self_param ();\n-    AST::IdentifierPattern self_pattern (\n-      self_param.get_node_id (), \"self\", self_param.get_locus (),\n-      self_param.get_has_ref (), self_param.get_is_mut (),\n-      std::unique_ptr<AST::Pattern> (nullptr));\n-\n-    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n-    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n-      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n-\n-    AST::TypePath self_type_path (std::move (segments),\n-\t\t\t\t  self_param.get_locus ());\n-\n-    ResolveType::go (&self_type_path, self_param.get_node_id ());\n-    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n-\n-    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n-\t\t\t\t       self_pattern.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : method.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n-      }\n-\n-    // resolve any where clause items\n-    if (method.has_where_clause ())\n-      ResolveWhereClause::Resolve (method.get_where_clause ());\n-\n-    // resolve the function body\n-    ResolveExpr::go (method.get_definition ().get (), method.get_node_id (),\n-\t\t     path, cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::TraitImpl &impl_block) override\n-  {\n-    NodeId scope_node_id = impl_block.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-\n-    if (impl_block.has_generics ())\n-      {\n-\tfor (auto &generic : impl_block.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n-\t  }\n-      }\n-\n-    // resolve any where clause items\n-    if (impl_block.has_where_clause ())\n-      ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n-\n-    CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n-    bool canonicalize_type_with_generics = false;\n-    NodeId trait_resolved_node\n-      = ResolveType::go (&impl_block.get_trait_path (),\n-\t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics,\n-\t\t\t &canonical_trait_type);\n-    if (trait_resolved_node == UNKNOWN_NODEID)\n-      {\n-\tresolver->get_type_scope ().pop ();\n-\tresolver->get_name_scope ().pop ();\n-\treturn;\n-      }\n-\n-    CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n-    NodeId type_resolved_node\n-      = ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics, &canonical_impl_type);\n-    if (type_resolved_node == UNKNOWN_NODEID)\n-      {\n-\tresolver->get_type_scope ().pop ();\n-\tresolver->get_name_scope ().pop ();\n-\treturn;\n-      }\n-\n-    // setup paths\n-    bool canonicalize_type_args = !impl_block.has_generics ();\n-    bool type_resolve_generic_args = false;\n-\n-    CanonicalPath impl_type_seg\n-      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n-    CanonicalPath trait_type_seg\n-      = ResolveTypeToCanonicalPath::resolve (impl_block.get_trait_path (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n-\n-    CanonicalPath projection\n-      = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n-\t\t\t\t      impl_type_seg);\n-    CanonicalPath impl_prefix = prefix.append (projection);\n-\n-    // setup canonical-path\n-    CanonicalPath canonical_projection\n-      = TraitImplProjection::resolve (impl_block.get_node_id (),\n-\t\t\t\t      canonical_trait_type,\n-\t\t\t\t      canonical_impl_type);\n-    CanonicalPath cpath = CanonicalPath::create_empty ();\n-    if (canonical_prefix.size () <= 1)\n-      {\n-\tcpath = canonical_projection;\n-      }\n-    else\n-      {\n-\tstd::string projection_str = canonical_projection.get ();\n-\tstd::string seg_buf\n-\t  = \"<impl \" + projection_str.substr (1, projection_str.size () - 2)\n-\t    + \">\";\n-\tCanonicalPath seg\n-\t  = CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n-\tcpath = canonical_prefix.append (seg);\n-      }\n-\n-    // DONE setup canonical-path\n-\n-    auto Self\n-      = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n-\n-    resolver->get_type_scope ().insert (Self,\n-\t\t\t\t\timpl_block.get_type ()->get_node_id (),\n-\t\t\t\t\timpl_block.get_type ()->get_locus ());\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      {\n-\tresolve_impl_item (impl_item.get (), impl_prefix, cpath);\n-      }\n-\n-    resolver->get_type_scope ().peek ()->clear_name (\n-      Self, impl_block.get_type ()->get_node_id ());\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::Trait &trait) override\n-  {\n-    NodeId scope_node_id = trait.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-\n-    // we need to inject an implicit self TypeParam here\n-    AST::TypeParam *implicit_self\n-      = new AST::TypeParam (\"Self\", trait.get_locus ());\n-    trait.insert_implict_self (\n-      std::unique_ptr<AST::GenericParam> (implicit_self));\n-    CanonicalPath Self = CanonicalPath::get_big_self (trait.get_node_id ());\n-\n-    for (auto &generic : trait.get_generic_params ())\n-      {\n-\tResolveGenericParam::go (generic.get (), trait.get_node_id ());\n-      }\n-\n-    // Self is an implicit TypeParam so lets mark it as such\n-    resolver->get_type_scope ().append_reference_for_def (\n-      Self.get_node_id (), implicit_self->get_node_id ());\n-\n-    if (trait.has_type_param_bounds ())\n-      {\n-\tfor (auto &bound : trait.get_type_param_bounds ())\n-\t  {\n-\t    ResolveTypeBound::go (bound.get (), trait.get_node_id ());\n-\t  }\n-      }\n-\n-    // resolve any where clause items\n-    if (trait.has_where_clause ())\n-      ResolveWhereClause::Resolve (trait.get_where_clause ());\n-\n-    // resolve the paths\n-    CanonicalPath path = CanonicalPath::create_empty ();\n-    CanonicalPath cpath = CanonicalPath::create_empty ();\n-    //\n-\n-    for (auto &item : trait.get_trait_items ())\n-      {\n-\tResolveTraitItems::go (item.get (), path, cpath);\n-      }\n-\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_name_scope ().pop ();\n-  }\n-\n-  void visit (AST::ExternBlock &extern_block) override\n-  {\n-    for (auto &item : extern_block.get_extern_items ())\n-      {\n-\tresolve_extern_item (item.get ());\n-      }\n-  }\n+  void visit (AST::EnumItem &item) override;\n+  void visit (AST::EnumItemTuple &item) override;\n+  void visit (AST::EnumItemStruct &item) override;\n+  void visit (AST::EnumItemDiscriminant &item) override;\n+  void visit (AST::StructStruct &struct_decl) override;\n+  void visit (AST::Union &union_decl) override;\n+  void visit (AST::StaticItem &var) override;\n+  void visit (AST::ConstantItem &constant) override;\n+  void visit (AST::Function &function) override;\n+  void visit (AST::InherentImpl &impl_block) override;\n+  void visit (AST::Method &method) override;\n+  void visit (AST::TraitImpl &impl_block) override;\n+  void visit (AST::Trait &trait) override;\n+  void visit (AST::ExternBlock &extern_block) override;\n \n protected:\n   void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &prefix,\n@@ -907,33 +106,11 @@ class ResolveImplItems : public ResolveItem\n \n public:\n   static void go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    if (item->is_marked_for_strip ())\n-      return;\n-\n-    ResolveImplItems resolver (prefix, canonical_prefix);\n-    item->accept_vis (resolver);\n-  };\n-\n+\t\t  const CanonicalPath &canonical_prefix);\n   static void go (AST::TraitImplItem *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    if (item->is_marked_for_strip ())\n-      return;\n-\n-    ResolveImplItems resolver (prefix, canonical_prefix);\n-    item->accept_vis (resolver);\n-  };\n+\t\t  const CanonicalPath &canonical_prefix);\n \n-  void visit (AST::TypeAlias &alias) override\n-  {\n-    ResolveItem::visit (alias);\n-\n-    // FIXME this stops the erronious unused decls which will be fixed later on\n-    resolver->get_type_scope ().append_reference_for_def (alias.get_node_id (),\n-\t\t\t\t\t\t\t  alias.get_node_id ());\n-  }\n+  void visit (AST::TypeAlias &alias) override;\n \n private:\n   ResolveImplItems (const CanonicalPath &prefix,\n@@ -947,50 +124,10 @@ class ResolveExternItem : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::ExternalItem *item)\n-  {\n-    ResolveExternItem resolver;\n-    item->accept_vis (resolver);\n-  };\n-\n-  void visit (AST::ExternalFunctionItem &function) override\n-  {\n-    NodeId scope_node_id = function.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    // resolve the generics\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), function.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (),\n-\t\t       function.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-      }\n-\n-    // done\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n+  static void go (AST::ExternalItem *item);\n \n-  void visit (AST::ExternalStaticItem &item) override\n-  {\n-    ResolveType::go (item.get_type ().get (), item.get_node_id ());\n-  }\n+  void visit (AST::ExternalFunctionItem &function) override;\n+  void visit (AST::ExternalStaticItem &item) override;\n \n private:\n   ResolveExternItem () : ResolverBase (UNKNOWN_NODEID) {}"}, {"sha": "530f630d5ec088bc78ac5c3dbe1c66bbc091ea71", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab845217887468b500b624f0837023122002c534/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=ab845217887468b500b624f0837023122002c534", "patch": "@@ -178,7 +178,7 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n       HIR::PathExprSegment &seg = expr.get_segments ().at (i);\n \n       bool have_more_segments = (expr.get_num_segments () - 1 != i);\n-      bool is_root = *offset == 0;\n+      bool is_root = *offset == 0 || root_tyty == nullptr;\n       NodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n \n       // then lookup the reference_node_id"}, {"sha": "29fa651fcd279ff9a98759dffddd3dc92c9ac113", "filename": "gcc/testsuite/rust/compile/macro42.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab845217887468b500b624f0837023122002c534/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro42.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab845217887468b500b624f0837023122002c534/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro42.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro42.rs?ref=ab845217887468b500b624f0837023122002c534", "patch": "@@ -0,0 +1,31 @@\n+// { dg-additional-options \"-w -frust-cfg=A\" }\n+macro_rules! cfg {\n+    () => {{}};\n+}\n+\n+fn main() -> i32 {\n+    let mut res = 0;\n+    if cfg!(A) {\n+        res = 1;\n+    }\n+\n+    if cfg!(A) {\n+        res = 2;\n+    } else {\n+        res = 3;\n+    }\n+\n+    if cfg!(A) {\n+        res = 4;\n+    } else if cfg!(A) {\n+        res = 5;\n+    }\n+\n+    let res = if cfg!(A) {\n+        6\n+    } else {\n+        7\n+    };\n+\n+    return res;\n+}"}]}