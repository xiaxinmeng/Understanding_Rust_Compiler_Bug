{"sha": "32fc3719e06899d43e2298ad6d0028efe5ec3024", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJmYzM3MTllMDY4OTlkNDNlMjI5OGFkNmQwMDI4ZWZlNWVjMzAyNA==", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2019-11-16T15:32:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-11-16T15:32:50Z"}, "message": "[PATCH] Refactor rust-demangle to be independent of C++ demangling.\n\n\t* demangle.h (rust_demangle_callback): Add.\n\n\t* cplus-dem.c (cplus_demangle): Use rust_demangle directly.\n\t(rust_demangle): Remove.\n\t* rust-demangle.c (is_prefixed_hash): Rename to is_legacy_prefixed_hash.\n\t(parse_lower_hex_nibble): Rename to decode_lower_hex_nibble.\n\t(parse_legacy_escape): Rename to decode_legacy_escape.\n\t(rust_is_mangled): Remove.\n\t(struct rust_demangler): Add.\n\t(peek): Add.\n\t(next): Add.\n\t(struct rust_mangled_ident): Add.\n\t(parse_ident): Add.\n\t(rust_demangle_sym): Remove.\n\t(print_str): Add.\n\t(PRINT): Add.\n\t(print_ident): Add.\n\t(rust_demangle_callback): Add.\n\t(struct str_buf): Add.\n\t(str_buf_reserve): Add.\n\t(str_buf_append): Add.\n\t(str_buf_demangle_callback): Add.\n\t(rust_demangle): Add.\n\t* rust-demangle.h: Remove.\n\nFrom-SVN: r278358", "tree": {"sha": "6e8ed402acee2f31567b1089bbf6877a76127df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e8ed402acee2f31567b1089bbf6877a76127df3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32fc3719e06899d43e2298ad6d0028efe5ec3024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32fc3719e06899d43e2298ad6d0028efe5ec3024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32fc3719e06899d43e2298ad6d0028efe5ec3024", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32fc3719e06899d43e2298ad6d0028efe5ec3024/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f73cb38f6530432ba15abf4bb6a58188479f1bc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f73cb38f6530432ba15abf4bb6a58188479f1bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f73cb38f6530432ba15abf4bb6a58188479f1bc3"}], "stats": {"total": 702, "additions": 436, "deletions": 266}, "files": [{"sha": "5e18fa3d5a6191b6c936ad220658eaf1d1e3c984", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc3719e06899d43e2298ad6d0028efe5ec3024/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc3719e06899d43e2298ad6d0028efe5ec3024/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=32fc3719e06899d43e2298ad6d0028efe5ec3024", "patch": "@@ -1,3 +1,7 @@\n+2019-10-22  Eduard-Mihai Burtescu  <eddyb@lyken.rs>\n+\n+\t* demangle.h (rust_demangle_callback): Add.\n+\n 2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n \t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n \t    Julian Brown  <julian@codesourcery.com>"}, {"sha": "ce7235d13f38719a5795d6bd5c454e33abab8863", "filename": "include/demangle.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc3719e06899d43e2298ad6d0028efe5ec3024/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc3719e06899d43e2298ad6d0028efe5ec3024/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=32fc3719e06899d43e2298ad6d0028efe5ec3024", "patch": "@@ -159,6 +159,11 @@ ada_demangle (const char *mangled, int options);\n extern char *\n dlang_demangle (const char *mangled, int options);\n \n+extern int\n+rust_demangle_callback (const char *mangled, int options,\n+                        demangle_callbackref callback, void *opaque);\n+\n+\n extern char *\n rust_demangle (const char *mangled, int options);\n "}, {"sha": "db5cf3dd323347ea2bfa6243afc7a41926f53ffa", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc3719e06899d43e2298ad6d0028efe5ec3024/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc3719e06899d43e2298ad6d0028efe5ec3024/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=32fc3719e06899d43e2298ad6d0028efe5ec3024", "patch": "@@ -1,3 +1,28 @@\n+2019-10-22  Eduard-Mihai Burtescu  <eddyb@lyken.rs>\n+\n+\t* cplus-dem.c (cplus_demangle): Use rust_demangle directly.\n+\t(rust_demangle): Remove.\n+\t* rust-demangle.c (is_prefixed_hash): Rename to is_legacy_prefixed_hash.\n+\t(parse_lower_hex_nibble): Rename to decode_lower_hex_nibble.\n+\t(parse_legacy_escape): Rename to decode_legacy_escape.\n+\t(rust_is_mangled): Remove.\n+\t(struct rust_demangler): Add.\n+\t(peek): Add.\n+\t(next): Add.\n+\t(struct rust_mangled_ident): Add.\n+\t(parse_ident): Add.\n+\t(rust_demangle_sym): Remove.\n+\t(print_str): Add.\n+\t(PRINT): Add.\n+\t(print_ident): Add.\n+\t(rust_demangle_callback): Add.\n+\t(struct str_buf): Add.\n+\t(str_buf_reserve): Add.\n+\t(str_buf_append): Add.\n+\t(str_buf_demangle_callback): Add.\n+\t(rust_demangle): Add.\n+\t* rust-demangle.h: Remove.\n+\n 2019-11-15  Miguel Saldivar  <saldivarcher@gmail.com>\n \n \t* testsuite/demangle-expected: Fix test."}, {"sha": "735a61d7a824ea2ac427ce1d5e62419671c81d9f", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 11, "deletions": 40, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc3719e06899d43e2298ad6d0028efe5ec3024/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc3719e06899d43e2298ad6d0028efe5ec3024/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=32fc3719e06899d43e2298ad6d0028efe5ec3024", "patch": "@@ -52,7 +52,6 @@ void * realloc ();\n #define CURRENT_DEMANGLING_STYLE options\n \n #include \"libiberty.h\"\n-#include \"rust-demangle.h\"\n \n enum demangling_styles current_demangling_style = auto_demangling;\n \n@@ -160,27 +159,20 @@ cplus_demangle (const char *mangled, int options)\n   if ((options & DMGL_STYLE_MASK) == 0)\n     options |= (int) current_demangling_style & DMGL_STYLE_MASK;\n \n+  /* The Rust demangling is implemented elsewhere.\n+     Legacy Rust symbols overlap with GNU_V3, so try Rust first.  */\n+  if (RUST_DEMANGLING || AUTO_DEMANGLING)\n+    {\n+      ret = rust_demangle (mangled, options);\n+      if (ret || RUST_DEMANGLING)\n+        return ret;\n+    }\n+\n   /* The V3 ABI demangling is implemented elsewhere.  */\n-  if (GNU_V3_DEMANGLING || RUST_DEMANGLING || AUTO_DEMANGLING)\n+  if (GNU_V3_DEMANGLING || AUTO_DEMANGLING)\n     {\n       ret = cplus_demangle_v3 (mangled, options);\n-      if (GNU_V3_DEMANGLING)\n-\treturn ret;\n-\n-      if (ret)\n-\t{\n-\t  /* Rust symbols are GNU_V3 mangled plus some extra subtitutions.\n-\t     The subtitutions are always smaller, so do in place changes.  */\n-\t  if (rust_is_mangled (ret))\n-\t    rust_demangle_sym (ret);\n-\t  else if (RUST_DEMANGLING)\n-\t    {\n-\t      free (ret);\n-\t      ret = NULL;\n-\t    }\n-\t}\n-\n-      if (ret || RUST_DEMANGLING)\n+      if (ret || GNU_V3_DEMANGLING)\n \treturn ret;\n     }\n \n@@ -204,27 +196,6 @@ cplus_demangle (const char *mangled, int options)\n   return (ret);\n }\n \n-char *\n-rust_demangle (const char *mangled, int options)\n-{\n-  /* Rust symbols are GNU_V3 mangled plus some extra subtitutions.  */\n-  char *ret = cplus_demangle_v3 (mangled, options);\n-\n-  /* The Rust subtitutions are always smaller, so do in place changes.  */\n-  if (ret != NULL)\n-    {\n-      if (rust_is_mangled (ret))\n-\trust_demangle_sym (ret);\n-      else\n-\t{\n-\t  free (ret);\n-\t  ret = NULL;\n-\t}\n-    }\n-\n-  return ret;\n-}\n-\n /* Demangle ada names.  The encoding is documented in gcc/ada/exp_dbug.ads.  */\n \n char *"}, {"sha": "fa9d4724010af392e334c8db7a1c7a09c807dee5", "filename": "libiberty/rust-demangle.c", "status": "modified", "additions": 391, "deletions": 181, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32fc3719e06899d43e2298ad6d0028efe5ec3024/libiberty%2Frust-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32fc3719e06899d43e2298ad6d0028efe5ec3024/libiberty%2Frust-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frust-demangle.c?ref=32fc3719e06899d43e2298ad6d0028efe5ec3024", "patch": "@@ -33,9 +33,11 @@ If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"safe-ctype.h\"\n \n+#include <inttypes.h>\n #include <sys/types.h>\n #include <string.h>\n #include <stdio.h>\n+#include <stdlib.h>\n \n #ifdef HAVE_STRING_H\n #include <string.h>\n@@ -47,207 +49,110 @@ extern void *memset(void *s, int c, size_t n);\n \n #include <demangle.h>\n #include \"libiberty.h\"\n-#include \"rust-demangle.h\"\n \n+struct rust_demangler\n+{\n+  const char *sym;\n+  size_t sym_len;\n \n-/* Mangled (legacy) Rust symbols look like this:\n-     _$LT$std..sys..fd..FileDesc$u20$as$u20$core..ops..Drop$GT$::drop::hc68340e1baa4987a\n-\n-   The original symbol is:\n-     <std::sys::fd::FileDesc as core::ops::Drop>::drop\n-\n-   The last component of the path is a 64-bit hash in lowercase hex,\n-   prefixed with \"h\". Rust does not have a global namespace between\n-   crates, an illusion which Rust maintains by using the hash to\n-   distinguish things that would otherwise have the same symbol.\n-\n-   Any path component not starting with a XID_Start character is\n-   prefixed with \"_\".\n-\n-   The following escape sequences are used:\n-\n-   \",\"  =>  $C$\n-   \"@\"  =>  $SP$\n-   \"*\"  =>  $BP$\n-   \"&\"  =>  $RF$\n-   \"<\"  =>  $LT$\n-   \">\"  =>  $GT$\n-   \"(\"  =>  $LP$\n-   \")\"  =>  $RP$\n-   \"\\u{XY}\"  =>  $uXY$\n-\n-   A double \"..\" means \"::\" and a single \".\" means \"-\".\n-\n-   The only characters allowed in the mangled symbol are a-zA-Z0-9 and _.:$  */\n-\n-static const char *hash_prefix = \"::h\";\n-static const size_t hash_prefix_len = 3;\n-static const size_t hash_len = 16;\n-\n-static int is_prefixed_hash (const char *start);\n-static int parse_lower_hex_nibble (char nibble);\n-static char parse_legacy_escape (const char **in);\n+  void *callback_opaque;\n+  demangle_callbackref callback;\n \n-/* INPUT: sym: symbol that has been through C++ (gnu v3) demangling\n+  /* Position of the next character to read from the symbol. */\n+  size_t next;\n \n-   This function looks for the following indicators:\n+  /* Non-zero if any error occurred. */\n+  int errored;\n \n-   1. The hash must consist of \"h\" followed by 16 lowercase hex digits.\n+  /* Non-zero if printing should be verbose (e.g. include hashes). */\n+  int verbose;\n \n-   2. As a sanity check, the hash must use between 5 and 15 of the 16\n-      possible hex digits. This is true of 99.9998% of hashes so once\n-      in your life you may see a false negative. The point is to\n-      notice path components that could be Rust hashes but are\n-      probably not, like \"haaaaaaaaaaaaaaaa\". In this case a false\n-      positive (non-Rust symbol has an important path component\n-      removed because it looks like a Rust hash) is worse than a false\n-      negative (the rare Rust symbol is not demangled) so this sets\n-      the balance in favor of false negatives.\n+  /* Rust mangling version, with legacy mangling being -1. */\n+  int version;\n+};\n \n-   3. There must be no characters other than a-zA-Z0-9 and _.:$  */\n+/* Parsing functions. */\n \n-int\n-rust_is_mangled (const char *sym)\n+static char\n+peek (const struct rust_demangler *rdm)\n {\n-  size_t len, len_without_hash;\n-  const char *end;\n+  if (rdm->next < rdm->sym_len)\n+    return rdm->sym[rdm->next];\n+  return 0;\n+}\n \n-  if (!sym)\n-    return 0;\n+static char\n+next (struct rust_demangler *rdm)\n+{\n+  char c = peek (rdm);\n+  if (!c)\n+    rdm->errored = 1;\n+  else\n+    rdm->next++;\n+  return c;\n+}\n \n-  len = strlen (sym);\n-  if (len <= hash_prefix_len + hash_len)\n-    /* Not long enough to contain \"::h\" + hash + something else */\n-    return 0;\n+struct rust_mangled_ident\n+{\n+  /* ASCII part of the identifier. */\n+  const char *ascii;\n+  size_t ascii_len;\n+};\n \n-  len_without_hash = len - (hash_prefix_len + hash_len);\n-  if (!is_prefixed_hash (sym + len_without_hash))\n-    return 0;\n+static struct rust_mangled_ident\n+parse_ident (struct rust_demangler *rdm)\n+{\n+  char c;\n+  size_t start, len;\n+  struct rust_mangled_ident ident;\n \n-  end = sym + len_without_hash;\n+  ident.ascii = NULL;\n+  ident.ascii_len = 0;\n \n-  while (sym < end)\n+  c = next (rdm);\n+  if (!ISDIGIT (c))\n     {\n-      if (*sym == '$' || *sym == '.' || *sym == '_' || *sym == ':'\n-          || ISALNUM (*sym))\n-        sym++;\n-      else\n-        return 0;\n+      rdm->errored = 1;\n+      return ident;\n     }\n+  len = c - '0';\n \n-  return 1;\n-}\n-\n-/* A hash is the prefix \"::h\" followed by 16 lowercase hex digits. The\n-   hex digits must contain at least 5 distinct digits.  */\n-\n-static int\n-is_prefixed_hash (const char *str)\n-{\n-  const char *end;\n-  char seen[16];\n-  size_t i;\n-  int count, nibble;\n-\n-  if (strncmp (str, hash_prefix, hash_prefix_len))\n-    return 0;\n-  str += hash_prefix_len;\n+  if (c != '0')\n+    while (ISDIGIT (peek (rdm)))\n+      len = len * 10 + (next (rdm) - '0');\n \n-  memset (seen, 0, sizeof(seen));\n-  for (end = str + hash_len; str < end; str++)\n+  start = rdm->next;\n+  rdm->next += len;\n+  /* Check for overflows. */\n+  if ((start > rdm->next) || (rdm->next > rdm->sym_len))\n     {\n-      nibble = parse_lower_hex_nibble (*str);\n-      if (nibble < 0)\n-        return 0;\n-      seen[nibble] = 1;\n+      rdm->errored = 1;\n+      return ident;\n     }\n \n-  /* Count how many distinct digits seen */\n-  count = 0;\n-  for (i = 0; i < 16; i++)\n-    if (seen[i])\n-      count++;\n+  ident.ascii = rdm->sym + start;\n+  ident.ascii_len = len;\n \n-  return count >= 5;\n-}\n+  if (ident.ascii_len == 0)\n+    ident.ascii = NULL;\n \n-/*\n-  INPUT: sym: symbol for which rust_is_mangled(sym) returned 1.\n+  return ident;\n+}\n \n-  The input is demangled in-place because the mangled name is always\n-  longer than the demangled one.  */\n+/* Printing functions. */\n \n-void\n-rust_demangle_sym (char *sym)\n+static void\n+print_str (struct rust_demangler *rdm, const char *data, size_t len)\n {\n-  const char *in;\n-  char *out;\n-  const char *end;\n-  char unescaped;\n-\n-  if (!sym)\n-    return;\n-\n-  in = sym;\n-  out = sym;\n-  end = sym + strlen (sym) - (hash_prefix_len + hash_len);\n-\n-  while (in < end)\n-    {\n-      if (*in == '$')\n-        {\n-          unescaped = parse_legacy_escape (&in);\n-          if (unescaped)\n-            *out++ = unescaped;\n-          else\n-            /* unexpected escape sequence, skip the rest of this segment. */\n-            while (in < end && *in != ':')\n-              *out++ = *in++;\n-        }\n-      else if (*in == '_')\n-        {\n-          /* If this is the start of a path component and the next\n-             character is an escape sequence, ignore the underscore. The\n-             mangler inserts an underscore to make sure the path\n-             component begins with a XID_Start character. */\n-          if ((in == sym || in[-1] == ':') && in[1] == '$')\n-            in++;\n-          else\n-            *out++ = *in++;\n-        }\n-      else if (*in == '.')\n-        {\n-          if (in[1] == '.')\n-            {\n-              /* \"..\" becomes \"::\" */\n-              *out++ = ':';\n-              *out++ = ':';\n-              in += 2;\n-            }\n-          else\n-            {\n-              /* \".\" becomes \"-\" */\n-              *out++ = '-';\n-              in++;\n-            }\n-        }\n-      else if (*in == ':' || ISALNUM (*in))\n-        *out++ = *in++;\n-      else\n-        {\n-          /* unexpected character in symbol, not rust_is_mangled.  */\n-          *out++ = '?'; /* This is pretty lame, but it's hard to do better. */\n-          *out = '\\0';\n-          return;\n-        }\n-    }\n-\n-  *out = '\\0';\n+  if (!rdm->errored)\n+    rdm->callback (data, len, rdm->callback_opaque);\n }\n \n+#define PRINT(s) print_str (rdm, s, strlen (s))\n+\n /* Return a 0x0-0xf value if the char is 0-9a-f, and -1 otherwise. */\n static int\n-parse_lower_hex_nibble (char nibble)\n+decode_lower_hex_nibble (char nibble)\n {\n   if ('0' <= nibble && nibble <= '9')\n     return nibble - '0';\n@@ -258,25 +163,25 @@ parse_lower_hex_nibble (char nibble)\n \n /* Return the unescaped character for a \"$...$\" escape, or 0 if invalid. */\n static char\n-parse_legacy_escape (const char **in)\n+decode_legacy_escape (const char *e, size_t len, size_t *out_len)\n {\n   char c = 0;\n-  const char *e;\n   size_t escape_len = 0;\n   int lo_nibble = -1, hi_nibble = -1;\n \n-  if ((*in)[0] != '$')\n+  if (len < 3 || e[0] != '$')\n     return 0;\n \n-  e = *in + 1;\n+  e++;\n+  len--;\n \n   if (e[0] == 'C')\n     {\n       escape_len = 1;\n \n       c = ',';\n     }\n-  else\n+  else if (len > 2)\n     {\n       escape_len = 2;\n \n@@ -294,14 +199,14 @@ parse_legacy_escape (const char **in)\n         c = '(';\n       else if (e[0] == 'R' && e[1] == 'P')\n         c = ')';\n-      else if (e[0] == 'u')\n+      else if (e[0] == 'u' && len > 3)\n         {\n           escape_len = 3;\n \n-          hi_nibble = parse_lower_hex_nibble (e[1]);\n+          hi_nibble = decode_lower_hex_nibble (e[1]);\n           if (hi_nibble < 0)\n             return 0;\n-          lo_nibble = parse_lower_hex_nibble (e[2]);\n+          lo_nibble = decode_lower_hex_nibble (e[2]);\n           if (lo_nibble < 0)\n             return 0;\n \n@@ -314,9 +219,314 @@ parse_legacy_escape (const char **in)\n         }\n     }\n \n-  if (!c || e[escape_len] != '$')\n+  if (!c || len <= escape_len || e[escape_len] != '$')\n     return 0;\n \n-  *in += 2 + escape_len;\n+  *out_len = 2 + escape_len;\n   return c;\n }\n+\n+static void\n+print_ident (struct rust_demangler *rdm, struct rust_mangled_ident ident)\n+{\n+  char unescaped;\n+  size_t len;\n+\n+  if (rdm->errored)\n+    return;\n+\n+  if (rdm->version == -1)\n+    {\n+      /* Ignore leading underscores preceding escape sequences.\n+         The mangler inserts an underscore to make sure the\n+         identifier begins with a XID_Start character. */\n+      if (ident.ascii_len >= 2 && ident.ascii[0] == '_'\n+          && ident.ascii[1] == '$')\n+        {\n+          ident.ascii++;\n+          ident.ascii_len--;\n+        }\n+\n+      while (ident.ascii_len > 0)\n+        {\n+          /* Handle legacy escape sequences (\"$...$\", \"..\" or \".\"). */\n+          if (ident.ascii[0] == '$')\n+            {\n+              unescaped\n+                  = decode_legacy_escape (ident.ascii, ident.ascii_len, &len);\n+              if (unescaped)\n+                print_str (rdm, &unescaped, 1);\n+              else\n+                {\n+                  /* Unexpected escape sequence, print the rest verbatim. */\n+                  print_str (rdm, ident.ascii, ident.ascii_len);\n+                  return;\n+                }\n+            }\n+          else if (ident.ascii[0] == '.')\n+            {\n+              if (ident.ascii_len >= 2 && ident.ascii[1] == '.')\n+                {\n+                  /* \"..\" becomes \"::\" */\n+                  PRINT (\"::\");\n+                  len = 2;\n+                }\n+              else\n+                {\n+                  /* \".\" becomes \"-\" */\n+                  PRINT (\"-\");\n+                  len = 1;\n+                }\n+            }\n+          else\n+            {\n+              /* Print everything before the next escape sequence, at once. */\n+              for (len = 0; len < ident.ascii_len; len++)\n+                if (ident.ascii[len] == '$' || ident.ascii[len] == '.')\n+                  break;\n+\n+              print_str (rdm, ident.ascii, len);\n+            }\n+\n+          ident.ascii += len;\n+          ident.ascii_len -= len;\n+        }\n+\n+      return;\n+    }\n+}\n+\n+/* A legacy hash is the prefix \"h\" followed by 16 lowercase hex digits.\n+   The hex digits must contain at least 5 distinct digits. */\n+static int\n+is_legacy_prefixed_hash (struct rust_mangled_ident ident)\n+{\n+  uint16_t seen;\n+  int nibble;\n+  size_t i, count;\n+\n+  if (ident.ascii_len != 17 || ident.ascii[0] != 'h')\n+    return 0;\n+\n+  seen = 0;\n+  for (i = 0; i < 16; i++)\n+    {\n+      nibble = decode_lower_hex_nibble (ident.ascii[1 + i]);\n+      if (nibble < 0)\n+        return 0;\n+      seen |= (uint16_t)1 << nibble;\n+    }\n+\n+  /* Count how many distinct digits were seen. */\n+  count = 0;\n+  while (seen)\n+    {\n+      if (seen & 1)\n+        count++;\n+      seen >>= 1;\n+    }\n+\n+  return count >= 5;\n+}\n+\n+int\n+rust_demangle_callback (const char *mangled, int options,\n+                        demangle_callbackref callback, void *opaque)\n+{\n+  const char *p;\n+  struct rust_demangler rdm;\n+  struct rust_mangled_ident ident;\n+\n+  rdm.sym = mangled;\n+  rdm.sym_len = 0;\n+\n+  rdm.callback_opaque = opaque;\n+  rdm.callback = callback;\n+\n+  rdm.next = 0;\n+  rdm.errored = 0;\n+  rdm.verbose = (options & DMGL_VERBOSE) != 0;\n+  rdm.version = 0;\n+\n+  /* Rust symbols always start with _ZN (legacy). */\n+  if (rdm.sym[0] == '_' && rdm.sym[1] == 'Z' && rdm.sym[2] == 'N')\n+    {\n+      rdm.sym += 3;\n+      rdm.version = -1;\n+    }\n+  else\n+    return 0;\n+\n+  /* Legacy Rust symbols use only [_0-9a-zA-Z.:$] characters. */\n+  for (p = rdm.sym; *p; p++)\n+    {\n+      rdm.sym_len++;\n+\n+      if (*p == '_' || ISALNUM (*p))\n+        continue;\n+\n+      if (rdm.version == -1 && (*p == '$' || *p == '.' || *p == ':'))\n+        continue;\n+\n+      return 0;\n+    }\n+\n+  /* Legacy Rust symbols need to be handled separately. */\n+  if (rdm.version == -1)\n+    {\n+      /* Legacy Rust symbols always end with E. */\n+      if (!(rdm.sym_len > 0 && rdm.sym[rdm.sym_len - 1] == 'E'))\n+        return 0;\n+      rdm.sym_len--;\n+\n+      /* Legacy Rust symbols also always end with a path segment\n+         that encodes a 16 hex digit hash, i.e. '17h[a-f0-9]{16}'.\n+         This early check, before any parse_ident calls, should\n+         quickly filter out most C++ symbols unrelated to Rust. */\n+      if (!(rdm.sym_len > 19\n+            && !memcmp (&rdm.sym[rdm.sym_len - 19], \"17h\", 3)))\n+        return 0;\n+\n+      do\n+        {\n+          ident = parse_ident (&rdm);\n+          if (rdm.errored || !ident.ascii)\n+            return 0;\n+        }\n+      while (rdm.next < rdm.sym_len);\n+\n+      /* The last path segment should be the hash. */\n+      if (!is_legacy_prefixed_hash (ident))\n+        return 0;\n+\n+      /* Reset the state for a second pass, to print the symbol. */\n+      rdm.next = 0;\n+      if (!rdm.verbose && rdm.sym_len > 19)\n+        {\n+          /* Hide the last segment, containing the hash, if not verbose. */\n+          rdm.sym_len -= 19;\n+        }\n+\n+      do\n+        {\n+          if (rdm.next > 0)\n+            print_str (&rdm, \"::\", 2);\n+\n+          ident = parse_ident (&rdm);\n+          print_ident (&rdm, ident);\n+        }\n+      while (rdm.next < rdm.sym_len);\n+    }\n+  else\n+    return 0;\n+\n+  return !rdm.errored;\n+}\n+\n+/* Growable string buffers. */\n+struct str_buf\n+{\n+  char *ptr;\n+  size_t len;\n+  size_t cap;\n+  int errored;\n+};\n+\n+static void\n+str_buf_reserve (struct str_buf *buf, size_t extra)\n+{\n+  size_t available, min_new_cap, new_cap;\n+  char *new_ptr;\n+\n+  /* Allocation failed before. */\n+  if (buf->errored)\n+    return;\n+\n+  available = buf->cap - buf->len;\n+\n+  if (extra <= available)\n+    return;\n+\n+  min_new_cap = buf->cap + (extra - available);\n+\n+  /* Check for overflows. */\n+  if (min_new_cap < buf->cap)\n+    {\n+      buf->errored = 1;\n+      return;\n+    }\n+\n+  new_cap = buf->cap;\n+\n+  if (new_cap == 0)\n+    new_cap = 4;\n+\n+  /* Double capacity until sufficiently large. */\n+  while (new_cap < min_new_cap)\n+    {\n+      new_cap *= 2;\n+\n+      /* Check for overflows. */\n+      if (new_cap < buf->cap)\n+        {\n+          buf->errored = 1;\n+          return;\n+        }\n+    }\n+\n+  new_ptr = (char *)realloc (buf->ptr, new_cap);\n+  if (new_ptr == NULL)\n+    {\n+      free (buf->ptr);\n+      buf->ptr = NULL;\n+      buf->len = 0;\n+      buf->cap = 0;\n+      buf->errored = 1;\n+    }\n+  else\n+    {\n+      buf->ptr = new_ptr;\n+      buf->cap = new_cap;\n+    }\n+}\n+\n+static void\n+str_buf_append (struct str_buf *buf, const char *data, size_t len)\n+{\n+  str_buf_reserve (buf, len);\n+  if (buf->errored)\n+    return;\n+\n+  memcpy (buf->ptr + buf->len, data, len);\n+  buf->len += len;\n+}\n+\n+static void\n+str_buf_demangle_callback (const char *data, size_t len, void *opaque)\n+{\n+  str_buf_append ((struct str_buf *)opaque, data, len);\n+}\n+\n+char *\n+rust_demangle (const char *mangled, int options)\n+{\n+  struct str_buf out;\n+  int success;\n+\n+  out.ptr = NULL;\n+  out.len = 0;\n+  out.cap = 0;\n+  out.errored = 0;\n+\n+  success = rust_demangle_callback (mangled, options,\n+                                    str_buf_demangle_callback, &out);\n+\n+  if (!success)\n+    {\n+      free (out.ptr);\n+      return NULL;\n+    }\n+\n+  str_buf_append (&out, \"\\0\", 1);\n+  return out.ptr;\n+}"}, {"sha": "abf4c6cde559bc45e3020d86e5c811b46e8f6e05", "filename": "libiberty/rust-demangle.h", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73cb38f6530432ba15abf4bb6a58188479f1bc3/libiberty%2Frust-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73cb38f6530432ba15abf4bb6a58188479f1bc3/libiberty%2Frust-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Frust-demangle.h?ref=f73cb38f6530432ba15abf4bb6a58188479f1bc3", "patch": "@@ -1,45 +0,0 @@\n-/* Internal demangler interface for the Rust programming language.\n-   Copyright (C) 2016-2019 Free Software Foundation, Inc.\n-   Written by David Tolnay (dtolnay@gmail.com).\n-\n-This file is part of the libiberty library.\n-Libiberty is free software; you can redistribute it and/or\n-modify it under the terms of the GNU Library General Public\n-License as published by the Free Software Foundation; either\n-version 2 of the License, or (at your option) any later version.\n-\n-In addition to the permissions in the GNU Library General Public\n-License, the Free Software Foundation gives you unlimited permission\n-to link the compiled version of this file into combinations with other\n-programs, and to distribute those combinations without any restriction\n-coming from the use of this file.  (The Library Public License\n-restrictions do apply in other respects; for example, they cover\n-modification of the file, and distribution when not linked into a\n-combined executable.)\n-\n-Libiberty is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-Library General Public License for more details.\n-\n-You should have received a copy of the GNU Library General Public\n-License along with libiberty; see the file COPYING.LIB.\n-If not, see <http://www.gnu.org/licenses/>.  */\n-\n-/* This file provides some definitions shared by cplus-dem.c and\n-   rust-demangle.c.  It should not be included by any other files.  */\n-\n-/* Returns non-zero iff MANGLED is a rust mangled symbol.  MANGLED must\n-   already have been demangled through cplus_demangle_v3.  If this function\n-   returns non-zero then MANGLED can be demangled (in-place) using\n-   RUST_DEMANGLE_SYM.  */\n-extern int\n-rust_is_mangled (const char *mangled);\n-\n-/* Demangles SYM (in-place) if RUST_IS_MANGLED returned non-zero for SYM.\n-   If RUST_IS_MANGLED returned zero for SYM then RUST_DEMANGLE_SYM might\n-   replace characters that cannot be demangled with '?' and might truncate\n-   SYM.  After calling RUST_DEMANGLE_SYM SYM might be shorter, but never\n-   larger.  */\n-extern void\n-rust_demangle_sym (char *sym);"}]}