{"sha": "34540fe35ebce1d18cf6a43983c669db5df61b36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1NDBmZTM1ZWJjZTFkMThjZjZhNDM5ODNjNjY5ZGI1ZGY2MWIzNg==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "2000-02-14T10:23:29Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2000-02-14T10:23:29Z"}, "message": "MPN.java (findLowestBit): Made methods public.\n\n\t* gnu/gcj/math/MPN.java(findLowestBit): Made methods public.\n\n\t* java/math/BigInteger.java(BigInteger(int,int,java.util.Random):\n\t  New constructor.\n\t(min): Implemented.\n\t(max): Implemented.\n\t(modPow): Rewritten to not use the naive, slow, brute force approach.\n\t(isProbablePrime): Implemented.\n\t(testBit): Implemented.\n\t(flipBit): Implemented.\n\t(getLowestSetBit): Implemented.\n\nFrom-SVN: r31966", "tree": {"sha": "25b7abd6d60029d846218b9f467ae92b950c211c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25b7abd6d60029d846218b9f467ae92b950c211c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34540fe35ebce1d18cf6a43983c669db5df61b36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34540fe35ebce1d18cf6a43983c669db5df61b36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34540fe35ebce1d18cf6a43983c669db5df61b36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34540fe35ebce1d18cf6a43983c669db5df61b36/comments", "author": null, "committer": null, "parents": [{"sha": "eb3e566556e0588e7f4433e881ebe238346dd704", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb3e566556e0588e7f4433e881ebe238346dd704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb3e566556e0588e7f4433e881ebe238346dd704"}], "stats": {"total": 194, "additions": 171, "deletions": 23}, "files": [{"sha": "0a9aa3e3e51993b993cecc710fb3fd6ef9eca526", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34540fe35ebce1d18cf6a43983c669db5df61b36/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34540fe35ebce1d18cf6a43983c669db5df61b36/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=34540fe35ebce1d18cf6a43983c669db5df61b36", "patch": "@@ -1,3 +1,17 @@\n+2000-02-14  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* gnu/gcj/math/MPN.java(findLowestBit): Made methods public.\n+\n+\t* java/math/BigInteger.java(BigInteger(int,int,java.util.Random):\n+\t  New constructor.\n+\t(min): Implemented.\n+\t(max): Implemented.\n+\t(modPow): Rewritten to not use the naive, slow, brute force approach.\n+\t(isProbablePrime): Implemented.\n+\t(testBit): Implemented.\n+\t(flipBit): Implemented.\n+\t(getLowestSetBit): Implemented.\n+\n 2000-02-16  Anthony Green  <green@redhat.com>\n \n \t* configure.host: Use the same options for i386 and i486 as we do\n@@ -17,7 +31,7 @@ Fri Feb 11 19:48:08 2000  Anthony Green  <green@cygnus.com>\n \t* interpret.cc (continue1): Use STOREA, not STOREI, to implement\n \tastore instruction.  From Hans Boehm.\n \n-2000-02-04  Warren Levy  <warrenl@cygnus.com>\n+2000-02-11  Warren Levy  <warrenl@cygnus.com>\n \n \t* java/math/BigInteger.java(BigInteger(String, int)): New constructor.\n \t(BigInteger(String)): New constructor."}, {"sha": "6ae60f26a223ec3373f5a98b9fc3b32b9dbf4ddb", "filename": "libjava/gnu/gcj/math/MPN.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34540fe35ebce1d18cf6a43983c669db5df61b36/libjava%2Fgnu%2Fgcj%2Fmath%2FMPN.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34540fe35ebce1d18cf6a43983c669db5df61b36/libjava%2Fgnu%2Fgcj%2Fmath%2FMPN.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fmath%2FMPN.java?ref=34540fe35ebce1d18cf6a43983c669db5df61b36", "patch": "@@ -571,7 +571,7 @@ public static int lshift (int[] dest, int d_offset,\n \n   /** Return least i such that word&(1<<i). Assumes word!=0. */\n \n-  static int findLowestBit (int word)\n+  public static int findLowestBit (int word)\n   {\n     int i = 0;\n     while ((word & 0xF) == 0)\n@@ -591,7 +591,7 @@ static int findLowestBit (int word)\n \n   /** Return least i such that words & (1<<i). Assumes there is such an i. */\n \n-  static int findLowestBit (int[] words)\n+  public static int findLowestBit (int[] words)\n   {\n     for (int i = 0;  ; i++)\n       {"}, {"sha": "3a5a26b8d67ea8b945737c4fdc365ed16f15b575", "filename": "libjava/java/math/BigInteger.java", "status": "modified", "additions": 154, "deletions": 20, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34540fe35ebce1d18cf6a43983c669db5df61b36/libjava%2Fjava%2Fmath%2FBigInteger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34540fe35ebce1d18cf6a43983c669db5df61b36/libjava%2Fjava%2Fmath%2FBigInteger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fmath%2FBigInteger.java?ref=34540fe35ebce1d18cf6a43983c669db5df61b36", "patch": "@@ -19,7 +19,9 @@\n \n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n- * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n+ * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998) and\n+ * \"Applied Cryptography, Second Edition\" by Bruce Schneier (Wiley, 1996).\n+\n  * \n  * Based primarily on IntNum.java BitOps.java by Per Bothner <per@bothner.com>\n  * (found in Kawa 1.6.62).\n@@ -60,6 +62,15 @@ public class BigInteger extends Number implements Comparable\n   private static final int TRUNCATE = 3;\n   private static final int ROUND = 4;\n \n+  /** When checking the probability of primes, it is most efficient to\n+   * first check the factoring of small primes, so we'll use this array.\n+   */\n+  private static final int[] primes =\n+    {   2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43,\n+       47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101, 103, 107,\n+      109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181,\n+      191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251 };\n+\n   private BigInteger()\n   {\n   }\n@@ -138,6 +149,21 @@ public BigInteger(int numBits, Random rnd)\n     this.words = result.words;\n   }\n \n+  public BigInteger(int bitLength, int certainty, Random rnd)\n+  {\n+    this(bitLength, rnd);\n+\n+    // Keep going until we find a probable prime.\n+    while (true)\n+      {\n+\tif (isProbablePrime(certainty))\n+\t  return;\n+\n+\tBigInteger next = new BigInteger(bitLength, rnd);\n+\tthis.ival = next.ival;\n+\tthis.words = next.words;\n+      }\n+  }\n \n   /** Return a (possibly-shared) BigInteger with a given long value. */\n   private static BigInteger make(long value)\n@@ -290,6 +316,16 @@ public int compareTo(BigInteger val)\n     return compareTo(this, val);\n   }\n \n+  public BigInteger min(BigInteger val)\n+  {\n+    return compareTo(this, val) < 0 ? this : val;\n+  }\n+\n+  public BigInteger max(BigInteger val)\n+  {\n+    return compareTo(this, val) > 0 ? this : val;\n+  }\n+\n   private final boolean isOdd()\n   {\n     int low = words == null ? ival : words[0];\n@@ -1121,7 +1157,29 @@ public BigInteger modPow(BigInteger exponent, BigInteger m)\n     if (exponent.isOne())\n       return mod(m);\n \n-    return pow(exponent).mod(m);\n+    // To do this naively by first raising this to the power of exponent\n+    // and then performing modulo m would be extremely expensive, especially\n+    // for very large numbers.  The solution is found in Number Theory\n+    // where a combination of partial powers and modulos can be done easily.\n+    //\n+    // We'll use the algorithm for Additive Chaining which can be found on\n+    // p. 244 of \"Applied Cryptography, Second Edition\" by Bruce Schneier.\n+    BigInteger s, t, u;\n+    int i;\n+\n+    s = ONE;\n+    t = this;\n+    u = exponent;\n+\n+    while (!u.isZero())\n+      {\n+\tif (u.and(ONE).isOne())\n+\t  s = times(s, t).mod(m);\n+\tu = u.shiftRight(1);\n+\tt = times(t, t).mod(m);\n+      }\n+\n+    return s;\n   }\n \n   /** Calculate Greatest Common Divisor for non-negative ints. */\n@@ -1184,6 +1242,72 @@ public BigInteger gcd(BigInteger y)\n     return result.canonicalize();\n   }\n \n+  public boolean isProbablePrime(int certainty)\n+  {\n+    /** We'll use the Rabin-Miller algorithm for doing a probabilistic\n+     * primality test.  It is fast, easy and has faster decreasing odds of a\n+     * composite passing than with other tests.  This means that this\n+     * method will actually have a probability much greater than the\n+     * 1 - .5^certainty specified in the JCL (p. 117), but I don't think\n+     * anyone will complain about better performance with greater certainty.\n+     *\n+     * The Rabin-Miller algorithm can be found on pp. 259-261 of \"Applied\n+     * Cryptography, Second Edition\" by Bruce Schneier.\n+     */\n+\n+    // First rule out small prime factors and assure the number is odd.\n+    for (int i = 0; i < primes.length; i++)\n+      {\n+\tif (words == null && ival == primes[i])\n+\t  return true;\n+        if (remainder(make(primes[i])).isZero())\n+\t  return false;\n+      }\n+\n+    // Now perform the Rabin-Miller test.\n+    // NB: I know that this can be simplified programatically, but\n+    // I have tried to keep it as close as possible to the algorithm\n+    // as written in the Schneier book for reference purposes.\n+\n+    // Set b to the number of times 2 evenly divides (this - 1).\n+    // I.e. 2^b is the largest power of 2 that divides (this - 1).\n+    BigInteger pMinus1 = add(this, -1);\n+    int b = pMinus1.getLowestSetBit();\n+\n+    // Set m such that this = 1 + 2^b * m.\n+    BigInteger m = pMinus1.divide(make(2L << b - 1));\n+\n+    Random rand = new Random();\n+    while (certainty-- > 0)\n+      {\n+        // Pick a random number greater than 1 and less than this.\n+\t// The algorithm says to pick a small number to make the calculations\n+\t// go faster, but it doesn't say how small; we'll use 2 to 1024.\n+\tint a = rand.nextInt();\n+\ta = (a < 0 ? -a : a) % 1023 + 2;\n+\n+\tBigInteger z = make(a).modPow(m, this);\n+\tif (z.isOne() || z.equals(pMinus1))\n+\t  continue;\t\t\t// Passes the test; may be prime.\n+\n+\tint i;\n+\tfor (i = 0; i < b; )\n+\t  {\n+\t    if (z.isOne())\n+\t      return false;\n+\t    i++;\n+\t    if (z.equals(pMinus1))\n+\t      break;\t\t\t// Passes the test; may be prime.\n+\n+\t    z = z.modPow(make(2), this);\n+\t  }\n+\n+\tif (i == b && !z.equals(pMinus1))\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n   private void setInvert()\n   {\n     if (words == null)\n@@ -1727,7 +1851,7 @@ private static BigInteger bitOp(int op, BigInteger x, BigInteger y)\n         case 1:  return x.and(y);\n         case 3:  return x;\n         case 5:  return y;\n-        case 15: return smallFixNums[-1 - minFixNum];\t// Returns -1.\n+        case 15: return make(-1);\n       }\n     BigInteger result = new BigInteger();\n     setBitOp(result, op, x, y);\n@@ -1998,6 +2122,33 @@ public BigInteger setBit(int n)\n     return or(ONE.shiftLeft(n));\n   }\n \n+  public boolean testBit(int n)\n+  {\n+    if (n < 0)\n+      throw new ArithmeticException();\n+\n+    return !and(ONE.shiftLeft(n)).isZero();\n+  }\n+\n+  public BigInteger flipBit(int n)\n+  {\n+    if (n < 0)\n+      throw new ArithmeticException();\n+\n+    return xor(ONE.shiftLeft(n));\n+  }\n+\n+  public int getLowestSetBit()\n+  {\n+    if (isZero())\n+      return -1;\n+\n+    if (words == null)\n+      return MPN.findLowestBit(ival);\n+    else\n+      return MPN.findLowestBit(words);\n+  }\n+\n   // bit4count[I] is number of '1' bits in I.\n   private static final byte[] bit4_count = { 0, 1, 1, 2,  1, 2, 2, 3,\n \t\t\t\t\t     1, 2, 2, 3,  2, 3, 3, 4};\n@@ -2039,21 +2190,4 @@ public int bitCount()\n       }\n     return isNegative() ? x_len * 32 - i : i;\n   }\n-\n-/* TODO:\n-\n-  public BigInteger(int bitLength, int certainty, Random rnd)\n-\n-  public boolean testBit(int n)\n-\n-  public BigInteger flipBit(int n)\n-\n-  public int getLowestSetBit()\n-\n-  public boolean isProbablePrime(int certainty)\n-\n-  public BigInteger min(BigInteger val)\n-\n-  public BigInteger max(BigInteger val)\n-*/\n }"}]}