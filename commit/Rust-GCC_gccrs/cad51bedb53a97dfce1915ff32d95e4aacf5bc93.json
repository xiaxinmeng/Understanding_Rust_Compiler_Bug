{"sha": "cad51bedb53a97dfce1915ff32d95e4aacf5bc93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FkNTFiZWRiNTNhOTdkZmNlMTkxNWZmMzJkOTVlNGFhY2Y1YmM5Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-14T22:58:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-14T22:58:23Z"}, "message": "Don't crash on invalid parameters/results.\n\nFrom-SVN: r167820", "tree": {"sha": "e106b845953a1f1d1f6b21dffe5303e6cf9d89b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e106b845953a1f1d1f6b21dffe5303e6cf9d89b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cad51bedb53a97dfce1915ff32d95e4aacf5bc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad51bedb53a97dfce1915ff32d95e4aacf5bc93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad51bedb53a97dfce1915ff32d95e4aacf5bc93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad51bedb53a97dfce1915ff32d95e4aacf5bc93/comments", "author": null, "committer": null, "parents": [{"sha": "86137e8127767846e7a3a686273d454cc342d6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86137e8127767846e7a3a686273d454cc342d6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86137e8127767846e7a3a686273d454cc342d6e1"}], "stats": {"total": 110, "additions": 82, "deletions": 28}, "files": [{"sha": "d3f77ad68aa3f34cb2c4e969104da83cd98b0735", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad51bedb53a97dfce1915ff32d95e4aacf5bc93/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad51bedb53a97dfce1915ff32d95e4aacf5bc93/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=cad51bedb53a97dfce1915ff32d95e4aacf5bc93", "patch": "@@ -8662,8 +8662,7 @@ Call_result_expression::do_check_types(Gogo*)\n       ok = false;\n     }\n   if (!ok)\n-    error_at(this->location(),\n-\t     \"number of results does not match number of values\");\n+    this->report_error(_(\"number of results does not match number of values\"));\n }\n \n // Determine the type.  We have nothing to do here, but the 0 result"}, {"sha": "ef63754dc8e493e8cb7eb571093c68e0739b4f78", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 78, "deletions": 23, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad51bedb53a97dfce1915ff32d95e4aacf5bc93/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad51bedb53a97dfce1915ff32d95e4aacf5bc93/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=cad51bedb53a97dfce1915ff32d95e4aacf5bc93", "patch": "@@ -244,7 +244,10 @@ Parse::type()\n     {\n       source_location location = token->location();\n       this->advance_token();\n-      return this->signature(NULL, location);\n+      Type* type = this->signature(NULL, location);\n+      if (type == NULL)\n+\treturn Type::make_error_type();\n+      return type;\n     }\n   else if (token->is_keyword(KEYWORD_MAP))\n     return this->map_type();\n@@ -662,16 +665,25 @@ Parse::channel_type()\n // RECEIVER is the receiver if there is one, or NULL.  LOCATION is the\n // location of the start of the type.\n \n+// This returns NULL on a parse error.\n+\n Function_type*\n Parse::signature(Typed_identifier* receiver, source_location location)\n {\n   bool is_varargs = false;\n-  Typed_identifier_list* params = this->parameters(&is_varargs);\n+  Typed_identifier_list* params;\n+  bool params_ok = this->parameters(&params, &is_varargs);\n \n   Typed_identifier_list* result = NULL;\n   if (this->peek_token()->is_op(OPERATOR_LPAREN)\n       || this->type_may_start_here())\n-    result = this->result();\n+    {\n+      if (!this->result(&result))\n+\treturn NULL;\n+    }\n+\n+  if (!params_ok)\n+    return NULL;\n \n   Function_type* ret = Type::make_function_type(receiver, params, result,\n \t\t\t\t\t\tlocation);\n@@ -682,21 +694,28 @@ Parse::signature(Typed_identifier* receiver, source_location location)\n \n // Parameters     = \"(\" [ ParameterList [ \",\" ] ] \")\" .\n \n-Typed_identifier_list*\n-Parse::parameters(bool* is_varargs)\n+// This returns false on a parse error.\n+\n+bool\n+Parse::parameters(Typed_identifier_list** pparams, bool* is_varargs)\n {\n+  *pparams = NULL;\n+\n   if (!this->peek_token()->is_op(OPERATOR_LPAREN))\n     {\n       error_at(this->location(), \"expected %<(%>\");\n-      return NULL;\n+      return false;\n     }\n \n   Typed_identifier_list* params = NULL;\n+  bool saw_error = false;\n \n   const Token* token = this->advance_token();\n   if (!token->is_op(OPERATOR_RPAREN))\n     {\n       params = this->parameter_list(is_varargs);\n+      if (params == NULL)\n+\tsaw_error = true;\n       token = this->peek_token();\n     }\n \n@@ -707,7 +726,11 @@ Parse::parameters(bool* is_varargs)\n   else\n     this->advance_token();\n \n-  return params;\n+  if (saw_error)\n+    return false;\n+\n+  *pparams = params;\n+  return true;\n }\n \n // ParameterList  = ParameterDecl { \",\" ParameterDecl } .\n@@ -717,12 +740,16 @@ Parse::parameters(bool* is_varargs)\n \n // We pick up an optional trailing comma.\n \n+// This returns NULL if some error is seen.\n+\n Typed_identifier_list*\n Parse::parameter_list(bool* is_varargs)\n {\n   source_location location = this->location();\n   Typed_identifier_list* ret = new Typed_identifier_list();\n \n+  bool saw_error = false;\n+\n   // If we see an identifier and then a comma, then we don't know\n   // whether we are looking at a list of identifiers followed by a\n   // type, or a list of types given by name.  We have to do an\n@@ -834,15 +861,16 @@ Parse::parameter_list(bool* is_varargs)\n \t      else\n \t\t{\n \t\t  error_at(this->location(), \"%<...%> only permits one name\");\n+\t\t  saw_error = true;\n \t\t  this->advance_token();\n \t\t  type = this->type();\n \t\t}\n \t      for (size_t i = 0; i < ret->size(); ++i)\n \t\tret->set_type(i, type);\n \t      if (!this->peek_token()->is_op(OPERATOR_COMMA))\n-\t\treturn ret;\n+\t\treturn saw_error ? NULL : ret;\n \t      if (this->advance_token()->is_op(OPERATOR_RPAREN))\n-\t\treturn ret;\n+\t\treturn saw_error ? NULL : ret;\n \t    }\n \t  else\n \t    {\n@@ -865,6 +893,7 @@ Parse::parameter_list(bool* is_varargs)\n \t\t    {\n \t\t      error_at(p->location(), \"expected %<%s%> to be a type\",\n \t\t\t       Gogo::message_name(p->name()).c_str());\n+\t\t      saw_error = true;\n \t\t      type = Type::make_error_type();\n \t\t    }\n \t\t  tret->push_back(Typed_identifier(\"\", type, p->location()));\n@@ -873,7 +902,7 @@ Parse::parameter_list(bool* is_varargs)\n \t      ret = tret;\n \t      if (!just_saw_comma\n \t\t  || this->peek_token()->is_op(OPERATOR_RPAREN))\n-\t\treturn ret;\n+\t\treturn saw_error ? NULL : ret;\n \t    }\n \t}\n     }\n@@ -883,13 +912,24 @@ Parse::parameter_list(bool* is_varargs)\n   while (this->peek_token()->is_op(OPERATOR_COMMA))\n     {\n       if (is_varargs != NULL && *is_varargs)\n-\terror_at(this->location(), \"%<...%> must be last parameter\");\n+\t{\n+\t  error_at(this->location(), \"%<...%> must be last parameter\");\n+\t  saw_error = true;\n+\t}\n       if (this->advance_token()->is_op(OPERATOR_RPAREN))\n \tbreak;\n       this->parameter_decl(parameters_have_names, ret, is_varargs, &mix_error);\n     }\n   if (mix_error)\n-    error_at(location, \"invalid named/anonymous mix\");\n+    {\n+      error_at(location, \"invalid named/anonymous mix\");\n+      saw_error = true;\n+    }\n+  if (saw_error)\n+    {\n+      delete ret;\n+      return NULL;\n+    }\n   return ret;\n }\n \n@@ -973,18 +1013,26 @@ Parse::parameter_decl(bool parameters_have_names,\n \n // Result         = Parameters | Type .\n \n-Typed_identifier_list*\n-Parse::result()\n+// This returns false on a parse error.\n+\n+bool\n+Parse::result(Typed_identifier_list** presults)\n {\n   if (this->peek_token()->is_op(OPERATOR_LPAREN))\n-    return this->parameters(NULL);\n+    return this->parameters(presults, NULL);\n   else\n     {\n       source_location location = this->location();\n-      Typed_identifier_list* til = new Typed_identifier_list();\n       Type* type = this->type();\n+      if (type->is_error_type())\n+\t{\n+\t  *presults = NULL;\n+\t  return false;\n+\t}\n+      Typed_identifier_list* til = new Typed_identifier_list();\n       til->push_back(Typed_identifier(\"\", type, location));\n-      return til;\n+      *presults = til;\n+      return true;\n     }\n }\n \n@@ -1108,14 +1156,14 @@ Parse::interface_type()\n // MethodName         = identifier .\n // InterfaceTypeName  = TypeName .\n \n-bool\n+void\n Parse::method_spec(Typed_identifier_list* methods)\n {\n   const Token* token = this->peek_token();\n   if (!token->is_identifier())\n     {\n       error_at(this->location(), \"expected identifier\");\n-      return false;\n+      return;\n     }\n \n   std::string name = token->identifier();\n@@ -1126,7 +1174,9 @@ Parse::method_spec(Typed_identifier_list* methods)\n     {\n       // This is a MethodName.\n       name = this->gogo_->pack_hidden_name(name, is_exported);\n-      Function_type* type = this->signature(NULL, location);\n+      Type* type = this->signature(NULL, location);\n+      if (type == NULL)\n+\treturn;\n       methods->push_back(Typed_identifier(name, type, location));\n     }\n   else\n@@ -1148,15 +1198,13 @@ Parse::method_spec(Typed_identifier_list* methods)\n \t\t && !token->is_op(OPERATOR_SEMICOLON)\n \t\t && !token->is_op(OPERATOR_RCURLY))\n \t    token = this->advance_token();\n-\t  return false;\n+\t  return;\n \t}\n       // This must be an interface type, but we can't check that now.\n       // We check it and pull out the methods in\n       // Interface_type::do_verify.\n       methods->push_back(Typed_identifier(\"\", type, location));\n     }\n-\n-  return false;\n }\n \n // Declaration = ConstDecl | TypeDecl | VarDecl | FunctionDecl | MethodDecl .\n@@ -1933,6 +1981,8 @@ Parse::function_decl()\n   this->advance_token();\n \n   Function_type* fntype = this->signature(rec, this->location());\n+  if (fntype == NULL)\n+    return;\n \n   Named_object* named_object = NULL;\n \n@@ -2462,6 +2512,11 @@ Parse::function_lit()\n   hold_enclosing_vars.swap(this->enclosing_vars_);\n \n   Function_type* type = this->signature(NULL, location);\n+  if (type == NULL)\n+    {\n+      this->block();\n+      return Expression::make_error(location);\n+    }\n \n   // For a function literal, the next token must be a '{'.  If we\n   // don't see that, then we may have a type expression."}, {"sha": "5f6e26aedea8277ba5a717c7f608708e3cf70ab1", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad51bedb53a97dfce1915ff32d95e4aacf5bc93/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad51bedb53a97dfce1915ff32d95e4aacf5bc93/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=cad51bedb53a97dfce1915ff32d95e4aacf5bc93", "patch": "@@ -167,13 +167,13 @@ class Parse\n   Type* pointer_type();\n   Type* channel_type();\n   Function_type* signature(Typed_identifier*, source_location);\n-  Typed_identifier_list* parameters(bool* is_varargs);\n+  bool parameters(Typed_identifier_list**, bool* is_varargs);\n   Typed_identifier_list* parameter_list(bool* is_varargs);\n   void parameter_decl(bool, Typed_identifier_list*, bool*, bool*);\n-  Typed_identifier_list* result();\n+  bool result(Typed_identifier_list**);\n   source_location block();\n   Type* interface_type();\n-  bool method_spec(Typed_identifier_list*);\n+  void method_spec(Typed_identifier_list*);\n   void declaration();\n   bool declaration_may_start_here();\n   void decl(void (Parse::*)(void*), void*);"}]}