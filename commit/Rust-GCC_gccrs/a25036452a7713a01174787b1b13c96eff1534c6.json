{"sha": "a25036452a7713a01174787b1b13c96eff1534c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1MDM2NDUyYTc3MTNhMDExNzQ3ODdiMWIxM2M5NmVmZjE1MzRjNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-10-14T07:37:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-10-14T07:37:11Z"}, "message": "arm.h (CONDITIONAL_REGISTER_USAGE): Make r11 fixed and global for -mcaller-super-interworking.\n\n\t* config/arm/arm.h (CONDITIONAL_REGISTER_USAGE): Make r11 fixed and\n\tglobal for -mcaller-super-interworking.\n\t(CALLER_INTERWORKING_SLOT_SIZE): New macro.\n\t* config/arm/arm.c (thumb_compute_save_reg_mask): Save r11 if\n\tCALLER_INTERWORKING_SLOT_SIZE is nonzero and the function does\n\tnot need a frame pointer.\n\t(arm_get_frame_offsets): Add CALLER_INTERWORKING_SLOT_SIZE bytes to\n\tthe soft frame pointer offset.\n\t(thumb_expand_prologue): Set up r11 for -mcaller-super-interworking.\n\t* config/arm/arm.md (*call_reg_thumb, *call_value_reg_thumb): Use\n\t_interwork_{r7,r11}_call_via_rN if some arguments are passed on\n\tthe stack.  Use frame_pointer_needed to choose between them.\n\t* config/arm/lib1funcs.asm (_arm_return_{r7,r11}): New functions.\n\t(interwork_with_frame): New macro.\n\t(interwork): Add _interwork_{r7,r11}_call_via_rN().\n\nFrom-SVN: r89031", "tree": {"sha": "ea8dff30aa2a512ad4558c2e8c0f0d85f3ed1300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea8dff30aa2a512ad4558c2e8c0f0d85f3ed1300"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a25036452a7713a01174787b1b13c96eff1534c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25036452a7713a01174787b1b13c96eff1534c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25036452a7713a01174787b1b13c96eff1534c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25036452a7713a01174787b1b13c96eff1534c6/comments", "author": null, "committer": null, "parents": [{"sha": "ef9af07733703a8309a44b80b1b2d0e35bdd0d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9af07733703a8309a44b80b1b2d0e35bdd0d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef9af07733703a8309a44b80b1b2d0e35bdd0d87"}], "stats": {"total": 110, "additions": 102, "deletions": 8}, "files": [{"sha": "bc9ad2a90426f6fe193925b6c950870d51c45993", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a25036452a7713a01174787b1b13c96eff1534c6", "patch": "@@ -1,3 +1,21 @@\n+2004-10-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/arm/arm.h (CONDITIONAL_REGISTER_USAGE): Make r11 fixed and\n+\tglobal for -mcaller-super-interworking.\n+\t(CALLER_INTERWORKING_SLOT_SIZE): New macro.\n+\t* config/arm/arm.c (thumb_compute_save_reg_mask): Save r11 if\n+\tCALLER_INTERWORKING_SLOT_SIZE is nonzero and the function does\n+\tnot need a frame pointer.\n+\t(arm_get_frame_offsets): Add CALLER_INTERWORKING_SLOT_SIZE bytes to\n+\tthe soft frame pointer offset.\n+\t(thumb_expand_prologue): Set up r11 for -mcaller-super-interworking.\n+\t* config/arm/arm.md (*call_reg_thumb, *call_value_reg_thumb): Use\n+\t_interwork_{r7,r11}_call_via_rN if some arguments are passed on\n+\tthe stack.  Use frame_pointer_needed to choose between them.\n+\t* config/arm/lib1funcs.asm (_arm_return_{r7,r11}): New functions.\n+\t(interwork_with_frame): New macro.\n+\t(interwork): Add _interwork_{r7,r11}_call_via_rN().\n+\n 2004-10-14  Ben Elliston  <bje@au.ibm.com>\n \n \tPR other/17900"}, {"sha": "498218d077b2e213bdc329f1fdda45740d4320bf", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a25036452a7713a01174787b1b13c96eff1534c6", "patch": "@@ -8741,6 +8741,9 @@ thumb_compute_save_reg_mask (void)\n     mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n   if (TARGET_SINGLE_PIC_BASE)\n     mask &= ~(1 << arm_pic_register);\n+  /* See if we might need r11 for calls to _interwork_r11_call_via_rN().  */\n+  if (!frame_pointer_needed && CALLER_INTERWORKING_SLOT_SIZE > 0)\n+    mask |= 1 << ARM_HARD_FRAME_POINTER_REGNUM;\n \n   /* lr will also be pushed if any lo regs are pushed.  */\n   if (mask & 0xff || thumb_force_lr_save ())\n@@ -9820,7 +9823,7 @@ arm_get_frame_offsets (void)\n \n   /* Saved registers include the stack frame.  */\n   offsets->saved_regs = offsets->saved_args + saved;\n-  offsets->soft_frame = offsets->saved_regs;\n+  offsets->soft_frame = offsets->saved_regs + CALLER_INTERWORKING_SLOT_SIZE;\n   /* A leaf function does not need any stack alignment if it has nothing\n      on the stack.  */\n   if (leaf && frame_size == 0)\n@@ -12977,6 +12980,9 @@ thumb_expand_prologue (void)\n \t\t\t\t   stack_pointer_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n+  else if (CALLER_INTERWORKING_SLOT_SIZE > 0)\n+    emit_move_insn (gen_rtx_REG (Pmode, ARM_HARD_FRAME_POINTER_REGNUM),\n+\t\t    stack_pointer_rtx);\n \n   amount = offsets->outgoing_args - offsets->saved_regs;\n   if (amount)"}, {"sha": "8e3844787eff10950c5ae8b46c91f33927a7b75e", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=a25036452a7713a01174787b1b13c96eff1534c6", "patch": "@@ -917,10 +917,16 @@ extern const char * structure_size_string;\n       fixed_regs[10]     = 1;\t\t\t\t\t\\\n       call_used_regs[10] = 1;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n-  if (TARGET_APCS_FRAME)\t\t\t\t\t\\\n+  /* -mcaller-super-interworking reserves r11 for calls to\t\\\n+     _interwork_r11_call_via_rN().  Making the register global\t\\\n+     is an easy way of ensuring that it remains valid for all\t\\\n+     calls.  */\t\t\t\t\t\t\t\\\n+  if (TARGET_APCS_FRAME || TARGET_CALLER_INTERWORKING)\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       fixed_regs[ARM_HARD_FRAME_POINTER_REGNUM] = 1;\t\t\\\n       call_used_regs[ARM_HARD_FRAME_POINTER_REGNUM] = 1;\t\\\n+      if (TARGET_CALLER_INTERWORKING)\t\t\t\t\\\n+\tglobal_regs[ARM_HARD_FRAME_POINTER_REGNUM] = 1;\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   SUBTARGET_CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n }\n@@ -1519,6 +1525,20 @@ enum reg_class\n    goes at a more negative offset in the frame.  */\n #define FRAME_GROWS_DOWNWARD 1\n \n+/* The amount of scratch space needed by _interwork_{r7,r11}_call_via_rN().\n+   When present, it is one word in size, and sits at the top of the frame,\n+   between the soft frame pointer and either r7 or r11.\n+\n+   We only need _interwork_rM_call_via_rN() for -mcaller-super-interworking,\n+   and only then if some outgoing arguments are passed on the stack.  It would\n+   be tempting to also check whether the stack arguments are passed by indirect\n+   calls, but there seems to be no reason in principle why a post-reload pass\n+   couldn't convert a direct call into an indirect one.  */\n+#define CALLER_INTERWORKING_SLOT_SIZE\t\t\t\\\n+  (TARGET_CALLER_INTERWORKING\t\t\t\t\\\n+   && current_function_outgoing_args_size != 0\t\t\\\n+   ? UNITS_PER_WORD : 0)\n+\n /* Offset within stack frame to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING"}, {"sha": "375f92eef54fd73938115c331a9eebb2fcfc88cf", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=a25036452a7713a01174787b1b13c96eff1534c6", "patch": "@@ -7435,10 +7435,14 @@\n   \"TARGET_THUMB && !arm_arch5\"\n   \"*\n   {\n-    if (TARGET_CALLER_INTERWORKING)\n+    if (!TARGET_CALLER_INTERWORKING)\n+      return \\\"bl\\\\t%__call_via_%0\\\";\n+    else if (operands[1] == const0_rtx)\n       return \\\"bl\\\\t%__interwork_call_via_%0\\\";\n+    else if (frame_pointer_needed)\n+      return \\\"bl\\\\t%__interwork_r7_call_via_%0\\\";\n     else\n-      return \\\"bl\\\\t%__call_via_%0\\\";\n+      return \\\"bl\\\\t%__interwork_r11_call_via_%0\\\";\n   }\"\n   [(set_attr \"type\" \"call\")]\n )\n@@ -7525,10 +7529,14 @@\n   \"TARGET_THUMB && !arm_arch5\"\n   \"*\n   {\n-    if (TARGET_CALLER_INTERWORKING)\n+    if (!TARGET_CALLER_INTERWORKING)\n+      return \\\"bl\\\\t%__call_via_%1\\\";\n+    else if (operands[2] == const0_rtx)\n       return \\\"bl\\\\t%__interwork_call_via_%1\\\";\n+    else if (frame_pointer_needed)\n+      return \\\"bl\\\\t%__interwork_r7_call_via_%1\\\";\n     else\n-      return \\\"bl\\\\t%__call_via_%1\\\";\n+      return \\\"bl\\\\t%__interwork_r11_call_via_%1\\\";\n   }\"\n   [(set_attr \"type\" \"call\")]\n )"}, {"sha": "d6bf195ee2d610a1d7a9fd959ade02efa17e82bb", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25036452a7713a01174787b1b13c96eff1534c6/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=a25036452a7713a01174787b1b13c96eff1534c6", "patch": "@@ -1098,7 +1098,20 @@ LSYM(Lover12):\n    the target code cannot be relied upon to return via a BX instruction, so\n    instead we have to store the resturn address on the stack and allow the\n    called function to return here instead.  Upon return we recover the real\n-   return address and use a BX to get back to Thumb mode.  */\n+   return address and use a BX to get back to Thumb mode.\n+\n+   There are three variations of this code.  The first,\n+   _interwork_call_via_rN(), will push the return address onto the\n+   stack and pop it in _arm_return().  It should only be used if all\n+   arguments are passed in registers.\n+\n+   The second, _interwork_r7_call_via_rN(), instead stores the return\n+   address at [r7, #-4].  It is the caller's responsibility to ensure\n+   that this address is valid and contains no useful data.\n+\n+   The third, _interwork_r11_call_via_rN(), works in the same way but\n+   uses r11 instead of r7.  It is useful if the caller does not really\n+   need a frame pointer.  */\n \t\n \t.text\n \t.align 0\n@@ -1107,7 +1120,33 @@ LSYM(Lover12):\n \t.globl _arm_return\n _arm_return:\n \tRETLDM\n-\t.code   16\n+\n+\t.globl _arm_return_r7\n+_arm_return_r7:\n+\tldr\tlr, [r7, #-4]\n+\tbx\tlr\n+\n+\t.globl _arm_return_r11\n+_arm_return_r11:\n+\tldr\tlr, [r11, #-4]\n+\tbx\tlr\n+\n+.macro interwork_with_frame frame, register, name, return\n+\t.code\t16\n+\n+\tTHUMB_FUNC_START \\name\n+\n+\tbx\tpc\n+\tnop\n+\n+\t.code\t32\n+\ttst\t\\register, #1\n+\tstreq\tlr, [\\frame, #-4]\n+\tadreq\tlr, _arm_return_\\frame\n+\tbx\t\\register\n+\n+\tSIZE\t(\\name)\n+.endm\n \n .macro interwork register\n \t.code\t16\n@@ -1126,6 +1165,9 @@ LSYM(Lchange_\\register):\n \tbx\t\\register\n \n \tSIZE\t(_interwork_call_via_\\register)\n+\n+\tinterwork_with_frame r7,\\register,_interwork_r7_call_via_\\register\n+\tinterwork_with_frame r11,\\register,_interwork_r11_call_via_\\register\n .endm\n \t\n \tinterwork r0"}]}