{"sha": "be1bb652637d5d8785993a4cd197d989dc4b5260", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUxYmI2NTI2MzdkNWQ4Nzg1OTkzYTRjZDE5N2Q5ODlkYzRiNTI2MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-12T16:26:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-12T16:26:15Z"}, "message": "Makefile.in (final.o): Depend on BASIC_BLOCK_H.\n\n\t* Makefile.in (final.o): Depend on BASIC_BLOCK_H.\n\t* final.c (final_end_function): Use app_disable.  Rearrange note\n\thandling into a switch.  Emit deleted labels.\n\t(output_asm_label): Generate label strings for deleted labels.\n\t* flow.c (tail_recursion_label_list): New.\n\t(find_basic_blocks_1): Set label_value_list directly.  Collect list\n\tof tail recursion labels from call_placeholders.  Don't add deleted\n\tlabels to the label value list.\n\t(cleanup_cfg): Use free_EXPR_LIST_list.\n\t(flow_delete_insn_chain): Turn non-removable labels into notes.\n\t(flow_delete_block): Don't disable deleting the block because of\n\ta non-removable label.\n\t(tail_recursion_label_p): New.\n\t(merge_blocks_move_predecessor_nojumps): Don't disable the merge\n\tbecause of a label.\n\t(merge_blocks_move_successor_nojumps): Likewise.  Also move a\n\tjump table.\n\t(merge_blocks): Disable a merge because of tail recursion labels.\n\t* ifcvt.c (merge_if_block): Don't disable a merge because of a label.\n\tUse a more accurate measure of not merging the join block.\n\t(find_if_block): Don't disable conversion because of a label.\n\t(find_if_case_1, find_if_case_2): Likewise.\n\t* jump.c (duplicate_loop_exit_test): Preserve the kind of list\n\telement when copying.\n\t(squeeze_notes): Also leave EH notes.\n\t(mark_jump_label): Ignore deleted labels.  Use an INSN_LIST for\n\tREG_LABEL notes.\n\t(delete_insn): Preserve LABEL_NAME in NOTE_SOURCE_FILE when\n\tdeleting a label.\n\t* print-rtl.c (print_rtx): Print NOTE_SOURCE_FILE for\n\tNOTE_INSN_DELETED_LABEL.  Print `[# deleted]' for a label_ref\n\treferring to a deleted label.  Convert tail handling to a switch.\n\t* rtl.def (CODE_LABEL): Rearrange elements to be compatible with NOTE\n\tfor NOTE_INSN_DELETED_LABEL.\n\t(NOTE): Fix commentary.\n\t* rtl.h (REG_LABEL): Update commentary wrt INSN_LIST.\n\t(REG_CC_SETTER, REG_CC_USER, REG_LIBCALL): Likewise.\n\t(CODE_LABEL_NUMBER, LABEL_NAME): Update index.\n\t(LABEL_NUSES, LABEL_REFS): Likewise.\n\t* unroll.c (copy_loop_body): Don't copy NOTE_INSN_DELETED_LABEL.\n\nFrom-SVN: r33876", "tree": {"sha": "d0c01aedfa0c100dbc8cf6e908311acdea960127", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0c01aedfa0c100dbc8cf6e908311acdea960127"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be1bb652637d5d8785993a4cd197d989dc4b5260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1bb652637d5d8785993a4cd197d989dc4b5260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be1bb652637d5d8785993a4cd197d989dc4b5260", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1bb652637d5d8785993a4cd197d989dc4b5260/comments", "author": null, "committer": null, "parents": [{"sha": "fb0f12c9326308579f89b0961681ffdb85288228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb0f12c9326308579f89b0961681ffdb85288228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb0f12c9326308579f89b0961681ffdb85288228"}], "stats": {"total": 698, "additions": 388, "deletions": 310}, "files": [{"sha": "d5ff1679f7549fc3032a5a4185070488083554c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -1,3 +1,46 @@\n+2000-05-12  Richard Henderson  <rth@cygnus.com>\n+\n+\t* Makefile.in (final.o): Depend on BASIC_BLOCK_H.\n+\t* final.c (final_end_function): Use app_disable.  Rearrange note\n+\thandling into a switch.  Emit deleted labels.\n+\t(output_asm_label): Generate label strings for deleted labels.\n+\t* flow.c (tail_recursion_label_list): New.\n+\t(find_basic_blocks_1): Set label_value_list directly.  Collect list\n+\tof tail recursion labels from call_placeholders.  Don't add deleted\n+\tlabels to the label value list.\n+\t(cleanup_cfg): Use free_EXPR_LIST_list.\n+\t(flow_delete_insn_chain): Turn non-removable labels into notes.\n+\t(flow_delete_block): Don't disable deleting the block because of\n+\ta non-removable label.\n+\t(tail_recursion_label_p): New.\n+\t(merge_blocks_move_predecessor_nojumps): Don't disable the merge\n+\tbecause of a label.\n+\t(merge_blocks_move_successor_nojumps): Likewise.  Also move a\n+\tjump table.\n+\t(merge_blocks): Disable a merge because of tail recursion labels.\n+\t* ifcvt.c (merge_if_block): Don't disable a merge because of a label.\n+\tUse a more accurate measure of not merging the join block.\n+\t(find_if_block): Don't disable conversion because of a label.\n+\t(find_if_case_1, find_if_case_2): Likewise.\n+\t* jump.c (duplicate_loop_exit_test): Preserve the kind of list\n+\telement when copying.\n+\t(squeeze_notes): Also leave EH notes.\n+\t(mark_jump_label): Ignore deleted labels.  Use an INSN_LIST for\n+\tREG_LABEL notes.\n+\t(delete_insn): Preserve LABEL_NAME in NOTE_SOURCE_FILE when\n+\tdeleting a label.\n+\t* print-rtl.c (print_rtx): Print NOTE_SOURCE_FILE for\n+\tNOTE_INSN_DELETED_LABEL.  Print `[# deleted]' for a label_ref\n+\treferring to a deleted label.  Convert tail handling to a switch.\n+\t* rtl.def (CODE_LABEL): Rearrange elements to be compatible with NOTE\n+\tfor NOTE_INSN_DELETED_LABEL.\n+\t(NOTE): Fix commentary.\n+\t* rtl.h (REG_LABEL): Update commentary wrt INSN_LIST.\n+\t(REG_CC_SETTER, REG_CC_USER, REG_LIBCALL): Likewise.\n+\t(CODE_LABEL_NUMBER, LABEL_NAME): Update index.\n+\t(LABEL_NUSES, LABEL_REFS): Likewise.\n+\t* unroll.c (copy_loop_body): Don't copy NOTE_INSN_DELETED_LABEL.\n+\n 2000-05-12  Zack Weinberg <zack@wolery.cumb.org>\n \n         * fixinc/fixfixes.c (IO_use_fix, IO_defn_fix, CTRL_use_fix,"}, {"sha": "3da7dee8447d30ea6e19ec4ecbf8efde50e05afa", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -1374,7 +1374,7 @@ final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\\n    $(REGS_H) $(RECOG_H) conditions.h insn-config.h insn-attr.h function.h \\\n    real.h output.h hard-reg-set.h insn-flags.h insn-codes.h gstab.h except.h \\\n    xcoffout.h defaults.h toplev.h reload.h dwarfout.h dwarf2out.h sdbout.h \\\n-   dbxout.h\n+   dbxout.h $(BASIC_BLOCK_H)\n recog.o : recog.c $(CONFIG_H) system.h $(RTL_H) function.h $(BASIC_BLOCK_H) \\\n    $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n    insn-flags.h insn-codes.h real.h toplev.h output.h resource.h "}, {"sha": "02dc418a35fb8a2dc364e19ff844af8a50f2a55d", "filename": "gcc/final.c", "status": "modified", "additions": 170, "deletions": 146, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -68,6 +68,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"reload.h\"\n #include \"intl.h\"\n+#include \"basic-block.h\"\n \n /* Get N_SLINE and N_SOL from stab.h if we can expect the file to exist.  */\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n@@ -1782,11 +1783,7 @@ final_end_function (first, file, optimize)\n      FILE *file;\n      int optimize ATTRIBUTE_UNUSED;\n {\n-  if (app_on)\n-    {\n-      fputs (ASM_APP_OFF, file);\n-      app_on = 0;\n-    }\n+  app_disable ();\n \n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)\n@@ -2082,218 +2079,243 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n       if (prescan > 0)\n \tbreak;\n \n-      /* Align the beginning of a loop, for higher speed\n-\t on certain machines.  */\n+      switch (NOTE_LINE_NUMBER (insn))\n+\t{\n+\tcase NOTE_INSN_DELETED:\n+\tcase NOTE_INSN_LOOP_BEG:\n+\tcase NOTE_INSN_LOOP_END:\n+\tcase NOTE_INSN_LOOP_CONT:\n+\tcase NOTE_INSN_LOOP_VTOP:\n+\tcase NOTE_INSN_FUNCTION_END:\n+\tcase NOTE_INSN_SETJMP:\n+\tcase NOTE_INSN_REPEATED_LINE_NUMBER:\n+\tcase NOTE_INSN_RANGE_BEG:\n+\tcase NOTE_INSN_RANGE_END:\n+\tcase NOTE_INSN_LIVE:\n+\tcase NOTE_INSN_EXPECTED_VALUE:\n+\t  break;\n \n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\tbreak; /* This used to depend on optimize, but that was bogus.  */\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\tbreak;\n+\tcase NOTE_INSN_BASIC_BLOCK:\n+\t  if (flag_debug_asm)\n+\t    fprintf (asm_out_file, \"\\t%s basic block %d\\n\",\n+\t\t     ASM_COMMENT_START, NOTE_BASIC_BLOCK (insn)->index);\n+\t  break;\n \n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n-\t  && ! exceptions_via_longjmp)\n-\t{\n-\t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHB\", NOTE_EH_HANDLER (insn));\n-          if (! flag_new_exceptions)\n-            add_eh_table_entry (NOTE_EH_HANDLER (insn));\n+\tcase NOTE_INSN_EH_REGION_BEG:\n+\t  if (! exceptions_via_longjmp)\n+\t    {\n+\t      ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHB\", NOTE_EH_HANDLER (insn));\n+\t      if (! flag_new_exceptions)\n+\t\tadd_eh_table_entry (NOTE_EH_HANDLER (insn));\n #ifdef ASM_OUTPUT_EH_REGION_BEG\n-\t  ASM_OUTPUT_EH_REGION_BEG (file, NOTE_EH_HANDLER (insn));\n+\t      ASM_OUTPUT_EH_REGION_BEG (file, NOTE_EH_HANDLER (insn));\n #endif\n+\t    }\n \t  break;\n-\t}\n \n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END\n-\t  && ! exceptions_via_longjmp)\n-\t{\n-\t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHE\", NOTE_EH_HANDLER (insn));\n-          if (flag_new_exceptions)\n-            add_eh_table_entry (NOTE_EH_HANDLER (insn));\n+\tcase NOTE_INSN_EH_REGION_END:\n+\t  if (! exceptions_via_longjmp)\n+\t    {\n+\t      ASM_OUTPUT_INTERNAL_LABEL (file, \"LEHE\", NOTE_EH_HANDLER (insn));\n+\t      if (flag_new_exceptions)\n+\t\tadd_eh_table_entry (NOTE_EH_HANDLER (insn));\n #ifdef ASM_OUTPUT_EH_REGION_END\n-\t  ASM_OUTPUT_EH_REGION_END (file, NOTE_EH_HANDLER (insn));\n+\t      ASM_OUTPUT_EH_REGION_END (file, NOTE_EH_HANDLER (insn));\n #endif\n+\t    }\n \t  break;\n-\t}\n \n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n-\t{\n+\tcase NOTE_INSN_PROLOGUE_END:\n #ifdef FUNCTION_END_PROLOGUE\n \t  FUNCTION_END_PROLOGUE (file);\n #endif\n \t  profile_after_prologue (file);\n \t  break;\n-\t}\n \n+\tcase NOTE_INSN_EPILOGUE_BEG:\n #ifdef FUNCTION_BEGIN_EPILOGUE\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n-\t{\n \t  FUNCTION_BEGIN_EPILOGUE (file);\n-\t  break;\n-\t}\n #endif\n+\t  break;\n \n-      if (write_symbols == NO_DEBUG)\n-\tbreak;\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n-\t{\n+\tcase NOTE_INSN_FUNCTION_BEG:\n+\t  if (write_symbols == NO_DEBUG)\n+\t    break;\n #if defined(SDB_DEBUGGING_INFO) && defined(MIPS_DEBUGGING_INFO)\n \t  /* MIPS stabs require the parameter descriptions to be after the\n \t     function entry point rather than before.  */\n \t  if (write_symbols == SDB_DEBUG)\n-\t    sdbout_begin_function (last_linenum);\n+\t    {\n+\t      app_disable ();\n+\t      sdbout_begin_function (last_linenum);\n+\t    }\n \t  else\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n \t  /* This outputs a marker where the function body starts, so it\n \t     must be after the prologue.  */\n \t  if (write_symbols == DWARF_DEBUG)\n-\t    dwarfout_begin_function ();\n+\t    {\n+\t      app_disable ();\n+\t      dwarfout_begin_function ();\n+\t    }\n #endif\n \t  break;\n-\t}\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n-\tbreak;\t\t\t/* An insn that was \"deleted\" */\n-      if (app_on)\n-\t{\n-\t  fputs (ASM_APP_OFF, file);\n-\t  app_on = 0;\n-\t}\n-      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n-\t  && (debug_info_level == DINFO_LEVEL_NORMAL\n+\n+\tcase NOTE_INSN_BLOCK_BEG:\n+\t  if (debug_info_level == DINFO_LEVEL_NORMAL\n \t      || debug_info_level == DINFO_LEVEL_VERBOSE\n \t      || write_symbols == DWARF_DEBUG\n-\t      || write_symbols == DWARF2_DEBUG))\n-\t{\n-\t  int n = BLOCK_NUMBER (NOTE_BLOCK (insn));\n+\t      || write_symbols == DWARF2_DEBUG)\n+\t    {\n+\t      int n = BLOCK_NUMBER (NOTE_BLOCK (insn));\n \n-\t  ++block_depth;\n-\t  high_block_linenum = last_linenum;\n+\t      app_disable ();\n+\t      ++block_depth;\n+\t      high_block_linenum = last_linenum;\n \n-\t  /* Output debugging info about the symbol-block beginning.  */\n+\t    /* Output debugging info about the symbol-block beginning.  */\n #ifdef SDB_DEBUGGING_INFO\n-\t  if (write_symbols == SDB_DEBUG)\n-\t    sdbout_begin_block (file, last_linenum, n);\n+\t      if (write_symbols == SDB_DEBUG)\n+\t\tsdbout_begin_block (file, last_linenum, n);\n #endif\n #ifdef XCOFF_DEBUGGING_INFO\n-\t  if (write_symbols == XCOFF_DEBUG)\n-\t    xcoffout_begin_block (file, last_linenum, n);\n+\t      if (write_symbols == XCOFF_DEBUG)\n+\t\txcoffout_begin_block (file, last_linenum, n);\n #endif\n #ifdef DBX_DEBUGGING_INFO\n-\t  if (write_symbols == DBX_DEBUG)\n-\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LBB\", n);\n+\t      if (write_symbols == DBX_DEBUG)\n+\t\tASM_OUTPUT_INTERNAL_LABEL (file, \"LBB\", n);\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF_DEBUG)\n-\t    dwarfout_begin_block (n);\n+\t      if (write_symbols == DWARF_DEBUG)\n+\t\tdwarfout_begin_block (n);\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF2_DEBUG)\n-\t    dwarf2out_begin_block (n);\n+\t      if (write_symbols == DWARF2_DEBUG)\n+\t\tdwarf2out_begin_block (n);\n #endif\n \n-\t  /* Mark this block as output.  */\n-\t  TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;\n-\t}\n-      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END\n-\t       && (debug_info_level == DINFO_LEVEL_NORMAL\n-\t\t   || debug_info_level == DINFO_LEVEL_VERBOSE\n-\t           || write_symbols == DWARF_DEBUG\n-\t           || write_symbols == DWARF2_DEBUG))\n-\t{\n-\t  int n = BLOCK_NUMBER (NOTE_BLOCK (insn));\n+\t      /* Mark this block as output.  */\n+\t      TREE_ASM_WRITTEN (NOTE_BLOCK (insn)) = 1;\n+\t    }\n+\t  break;\n \n-\t  /* End of a symbol-block.  */\n+\tcase NOTE_INSN_BLOCK_END:\n+\t  if (debug_info_level == DINFO_LEVEL_NORMAL\n+\t      || debug_info_level == DINFO_LEVEL_VERBOSE\n+\t      || write_symbols == DWARF_DEBUG\n+\t      || write_symbols == DWARF2_DEBUG)\n+\t    {\n+\t      int n = BLOCK_NUMBER (NOTE_BLOCK (insn));\n \n-\t  --block_depth;\n-\t  if (block_depth < 0)\n-\t    abort ();\n+\t      app_disable ();\n+\n+\t      /* End of a symbol-block.  */\n+\t      --block_depth;\n+\t      if (block_depth < 0)\n+\t\tabort ();\n \n #ifdef XCOFF_DEBUGGING_INFO\n-\t  if (write_symbols == XCOFF_DEBUG)\n-\t    xcoffout_end_block (file, high_block_linenum, n);\n+\t      if (write_symbols == XCOFF_DEBUG)\n+\t\txcoffout_end_block (file, high_block_linenum, n);\n #endif\n #ifdef DBX_DEBUGGING_INFO\n-\t  if (write_symbols == DBX_DEBUG)\n-\t    ASM_OUTPUT_INTERNAL_LABEL (file, \"LBE\", n);\n+\t      if (write_symbols == DBX_DEBUG)\n+\t\tASM_OUTPUT_INTERNAL_LABEL (file, \"LBE\", n);\n #endif\n #ifdef SDB_DEBUGGING_INFO\n-\t  if (write_symbols == SDB_DEBUG)\n-\t    sdbout_end_block (file, high_block_linenum, n);\n+\t      if (write_symbols == SDB_DEBUG)\n+\t\tsdbout_end_block (file, high_block_linenum, n);\n #endif\n #ifdef DWARF_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF_DEBUG)\n-\t    dwarfout_end_block (n);\n+\t      if (write_symbols == DWARF_DEBUG)\n+\t\tdwarfout_end_block (n);\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n-\t  if (write_symbols == DWARF2_DEBUG)\n-\t    dwarf2out_end_block (n);\n+\t      if (write_symbols == DWARF2_DEBUG)\n+\t\tdwarf2out_end_block (n);\n #endif\n-\t}\n-      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL\n-\t       && (debug_info_level == DINFO_LEVEL_NORMAL\n-\t\t   || debug_info_level == DINFO_LEVEL_VERBOSE))\n-\t{\n+\t    }\n+\t  break;\n+\n+\tcase NOTE_INSN_DELETED_LABEL:\n+\t  /* Emit the label.  We may have deleted the CODE_LABEL because\n+\t     the label could be proved to be unreachable, though still\n+\t     referenced (in the form of having its address taken.  */\n+\t  /* ??? Figure out how not to do this unconditionally.  This\n+\t     interferes with bundling on LIW targets.  */\n+\t  ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n+\n+\t  if (debug_info_level == DINFO_LEVEL_NORMAL\n+\t      || debug_info_level == DINFO_LEVEL_VERBOSE)\n+\t    {\n #ifdef DWARF_DEBUGGING_INFO\n-          if (write_symbols == DWARF_DEBUG)\n-            dwarfout_label (insn);\n+              if (write_symbols == DWARF_DEBUG)\n+\t\tdwarfout_label (insn);\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n-          if (write_symbols == DWARF2_DEBUG)\n-            dwarf2out_label (insn);\n+              if (write_symbols == DWARF2_DEBUG)\n+\t\tdwarf2out_label (insn);\n #endif\n-\t}\n-      else if (NOTE_LINE_NUMBER (insn) > 0)\n-\t/* This note is a line-number.  */\n-\t{\n-\t  register rtx note;\n+\t    }\n+\t  break;\n \n-#if 0 /* This is what we used to do.  */\n-\t  output_source_line (file, insn);\n-#endif\n-\t  int note_after = 0;\n+\tdefault:\n+\t  if (NOTE_LINE_NUMBER (insn) <= 0)\n+\t    abort ();\n \n-\t  /* If there is anything real after this note,\n-\t     output it.  If another line note follows, omit this one.  */\n-\t  for (note = NEXT_INSN (insn); note; note = NEXT_INSN (note))\n-\t    {\n-\t      if (GET_CODE (note) != NOTE && GET_CODE (note) != CODE_LABEL)\n-\t\tbreak;\n-\t      /* These types of notes can be significant\n-\t\t so make sure the preceding line number stays.  */\n-\t      else if (GET_CODE (note) == NOTE\n-\t\t       && (NOTE_LINE_NUMBER (note) == NOTE_INSN_BLOCK_BEG\n-\t\t\t   || NOTE_LINE_NUMBER (note) == NOTE_INSN_BLOCK_END\n-\t\t\t   || NOTE_LINE_NUMBER (note) == NOTE_INSN_FUNCTION_BEG))\n-  \t\tbreak;\n-\t      else if (GET_CODE (note) == NOTE && NOTE_LINE_NUMBER (note) > 0)\n-\t\t{\n-\t\t  /* Another line note follows; we can delete this note\n-\t\t     if no intervening line numbers have notes elsewhere.  */\n-\t\t  int num;\n-\t\t  for (num = NOTE_LINE_NUMBER (insn) + 1;\n-\t\t       num < NOTE_LINE_NUMBER (note);\n-\t\t       num++)\n-\t\t    if (line_note_exists[num])\n-\t\t      break;\n-\n-\t\t  if (num >= NOTE_LINE_NUMBER (note))\n-\t\t    note_after = 1;\n+\t  /* This note is a line-number.  */\n+\t  {\n+\t    register rtx note;\n+\t    int note_after = 0;\n+\n+\t    /* If there is anything real after this note, output it. \n+\t       If another line note follows, omit this one.  */\n+\t    for (note = NEXT_INSN (insn); note; note = NEXT_INSN (note))\n+\t      {\n+\t\tif (GET_CODE (note) != NOTE && GET_CODE (note) != CODE_LABEL)\n \t\t  break;\n-\t\t}\n-\t    }\n \n-\t  /* Output this line note\n-\t     if it is the first or the last line note in a row.  */\n-\t  if (!note_after)\n-\t    output_source_line (file, insn);\n+\t\t/* These types of notes can be significant\n+\t\t   so make sure the preceding line number stays.  */\n+\t\telse if (GET_CODE (note) == NOTE\n+\t\t\t && (NOTE_LINE_NUMBER (note) == NOTE_INSN_BLOCK_BEG\n+\t\t\t     || NOTE_LINE_NUMBER (note) == NOTE_INSN_BLOCK_END\n+\t\t\t     || NOTE_LINE_NUMBER (note) == NOTE_INSN_FUNCTION_BEG))\n+\t\t  break;\n+\t\telse if (GET_CODE (note) == NOTE && NOTE_LINE_NUMBER (note) > 0)\n+\t\t  {\n+\t\t    /* Another line note follows; we can delete this note\n+\t\t       if no intervening line numbers have notes elsewhere.  */\n+\t\t    int num;\n+\t\t    for (num = NOTE_LINE_NUMBER (insn) + 1;\n+\t\t         num < NOTE_LINE_NUMBER (note);\n+\t\t         num++)\n+\t\t      if (line_note_exists[num])\n+\t\t\tbreak;\n+\n+\t\t    if (num >= NOTE_LINE_NUMBER (note))\n+\t\t      note_after = 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\n+\t    /* Output this line note if it is the first or the last line\n+\t       note in a row.  */\n+\t    if (!note_after)\n+\t      output_source_line (file, insn);\n+\t  }\n+          break;\n \t}\n       break;\n \n     case BARRIER:\n #if defined (DWARF2_UNWIND_INFO)\n-\t/* If we push arguments, we need to check all insns for stack\n-\t   adjustments.  */\n-\tif (!ACCUMULATE_OUTGOING_ARGS && dwarf2out_do_frame ())\n-\t  dwarf2out_frame_debug (insn);\n+      /* If we push arguments, we need to check all insns for stack\n+\t adjustments.  */\n+      if (!ACCUMULATE_OUTGOING_ARGS && dwarf2out_do_frame ())\n+\tdwarf2out_frame_debug (insn);\n #endif\n       break;\n \n@@ -3544,8 +3566,10 @@ output_asm_label (x)\n   char buf[256];\n \n   if (GET_CODE (x) == LABEL_REF)\n-    ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (XEXP (x, 0)));\n-  else if (GET_CODE (x) == CODE_LABEL)\n+    x = XEXP (x, 0);\n+  if (GET_CODE (x) == CODE_LABEL\n+      || (GET_CODE (x) == NOTE\n+\t  && NOTE_LINE_NUMBER (x) == NOTE_INSN_DELETED_LABEL))\n     ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (x));\n   else\n     output_operand_lossage (\"`%l' operand isn't a label\");"}, {"sha": "a8573e1642a106f510a49e84de117b5ef04af231", "filename": "gcc/flow.c", "status": "modified", "additions": 68, "deletions": 59, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -253,6 +253,7 @@ varray_type basic_block_for_insn;\n    bit of surgery to be able to use or co-opt the routines in jump.  */\n \n static rtx label_value_list;\n+static rtx tail_recursion_label_list;\n \n /* Holds information for tracking conditional register life information.  */\n struct reg_cond_life_info\n@@ -307,7 +308,7 @@ struct propagate_block_info\n \n /* Forward declarations */\n static int count_basic_blocks\t\tPARAMS ((rtx));\n-static rtx find_basic_blocks_1\t\tPARAMS ((rtx));\n+static void find_basic_blocks_1\t\tPARAMS ((rtx));\n static void clear_edges\t\t\tPARAMS ((void));\n static void make_edges\t\t\tPARAMS ((rtx));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n@@ -325,6 +326,7 @@ static void delete_eh_regions\t\tPARAMS ((void));\n static int can_delete_note_p\t\tPARAMS ((rtx));\n static void expunge_block\t\tPARAMS ((basic_block));\n static int can_delete_label_p\t\tPARAMS ((rtx));\n+static int tail_recursion_label_p\tPARAMS ((rtx));\n static int merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\t  basic_block));\n static int merge_blocks_move_successor_nojumps PARAMS ((basic_block,\n@@ -437,7 +439,7 @@ find_basic_blocks (f, nregs, file)\n \n   VARRAY_BB_INIT (basic_block_info, n_basic_blocks, \"basic_block_info\");\n \n-  label_value_list = find_basic_blocks_1 (f);\n+  find_basic_blocks_1 (f);\n   \n   /* Record the block to which an insn belongs.  */\n   /* ??? This should be done another way, by which (perhaps) a label is\n@@ -535,15 +537,16 @@ count_basic_blocks (f)\n    Collect and return a list of labels whose addresses are taken.  This\n    will be used in make_edges for use with computed gotos.  */\n \n-static rtx\n+static void\n find_basic_blocks_1 (f)\n      rtx f;\n {\n   register rtx insn, next;\n   int i = 0;\n   rtx bb_note = NULL_RTX;\n   rtx eh_list = NULL_RTX;\n-  rtx label_value_list = NULL_RTX;\n+  rtx lvl = NULL_RTX;\n+  rtx trll = NULL_RTX;\n   rtx head = NULL_RTX;\n   rtx end = NULL_RTX;\n   \n@@ -667,6 +670,12 @@ find_basic_blocks_1 (f)\n \t    int region = (note ? INTVAL (XEXP (note, 0)) : 1);\n \t    int call_has_abnormal_edge = 0;\n \n+\t    /* If this is a call placeholder, record its tail recursion\n+\t       label, if any.  */\n+\t    if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER\n+\t\t&& XEXP (PATTERN (insn), 3) != NULL_RTX)\n+\t      trll = alloc_EXPR_LIST (0, XEXP (PATTERN (insn), 3), trll);\n+\n \t    /* If there is an EH region or rethrow, we have an edge.  */\n \t    if ((eh_list && region > 0)\n \t\t|| find_reg_note (insn, REG_EH_RETHROW, NULL_RTX))\n@@ -724,15 +733,16 @@ find_basic_blocks_1 (f)\n \t\trtx lab = XEXP (note, 0), next;\n \n \t\tif (lab == eh_return_stub_label)\n-\t\t    ;\n+\t\t  ;\n \t\telse if ((next = next_nonnote_insn (lab)) != NULL\n \t\t\t && GET_CODE (next) == JUMP_INSN\n \t\t\t && (GET_CODE (PATTERN (next)) == ADDR_VEC\n \t\t\t     || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n \t\t  ;\n+\t\telse if (GET_CODE (lab) == NOTE)\n+\t\t  ;\n \t\telse\n-\t\t  label_value_list\n-\t\t    = alloc_EXPR_LIST (0, XEXP (note, 0), label_value_list);\n+\t\t  lvl = alloc_EXPR_LIST (0, XEXP (note, 0), lvl);\n \t      }\n \t}\n     }\n@@ -745,7 +755,8 @@ find_basic_blocks_1 (f)\n   if (i != n_basic_blocks)\n     abort ();\n \n-  return label_value_list;\n+  label_value_list = lvl;\n+  tail_recursion_label_list = trll;\n }\n \n /* Tidy the CFG by deleting unreachable code and whatnot.  */\n@@ -761,7 +772,8 @@ cleanup_cfg (f)\n   mark_critical_edges ();\n \n   /* Kill the data we won't maintain.  */\n-  label_value_list = NULL_RTX;\n+  free_EXPR_LIST_list (&label_value_list);\n+  free_EXPR_LIST_list (&tail_recursion_label_list);\n }\n \n /* Create a new basic block consisting of the instructions between\n@@ -1853,8 +1865,14 @@ flow_delete_insn_chain (start, finish)\n       next = NEXT_INSN (start);\n       if (GET_CODE (start) == NOTE && !can_delete_note_p (start))\n \t;\n-      else if (GET_CODE (start) == CODE_LABEL && !can_delete_label_p (start))\n-\t;\n+      else if (GET_CODE (start) == CODE_LABEL\n+\t       && ! can_delete_label_p (start))\n+\t{\n+\t  const char *name = LABEL_NAME (start);\n+\t  PUT_CODE (start, NOTE);\n+\t  NOTE_LINE_NUMBER (start) = NOTE_INSN_DELETED_LABEL;\n+\t  NOTE_SOURCE_FILE (start) = name;\n+\t}\n       else\n \tnext = flow_delete_insn (start);\n \n@@ -1910,20 +1928,6 @@ flow_delete_block (b)\n \t    }\n \t  prev = &XEXP (x, 1);\n \t}\n-\n-      /* This label may be referenced by code solely for its value, or\n-\t referenced by static data, or something.  We have determined\n-\t that it is not reachable, but cannot delete the label itself.\n-\t Save code space and continue to delete the balance of the block,\n-\t along with properly updating the cfg.  */\n-      if (!can_delete_label_p (insn))\n-\t{\n-\t  /* If we've only got one of these, skip the whole deleting\n-\t     insns thing.  */\n-\t  if (insn == b->end)\n-\t    goto no_delete_insns;\n-\t  insn = NEXT_INSN (insn);\n-\t}\n     }\n \n   /* Include any jump table following the basic block.  */\n@@ -1944,8 +1948,6 @@ flow_delete_block (b)\n   /* Selectively delete the entire chain.  */\n   flow_delete_insn_chain (insn, end);\n \n- no_delete_insns:\n-\n   /* Remove the edges into and out of this block.  Note that there may \n      indeed be edges in, if we are removing an unreachable loop.  */\n   {\n@@ -2063,6 +2065,19 @@ can_delete_label_p (label)\n   return 1;\n }\n \n+static int\n+tail_recursion_label_p (label)\n+     rtx label;\n+{\n+  rtx x;\n+\n+  for (x = tail_recursion_label_list; x ; x = XEXP (x, 1))\n+    if (label == XEXP (x, 0))\n+      return 1;\n+\n+  return 0;\n+}\n+\n /* Blocks A and B are to be merged into a single block A.  The insns\n    are already contiguous, hence `nomove'.  */\n \n@@ -2180,19 +2195,10 @@ merge_blocks_move_predecessor_nojumps (a, b)\n   start = a->head;\n   end = a->end;\n \n-  /* We want to delete the BARRIER after the end of the insns we are\n-     going to move.  If we don't find a BARRIER, then do nothing.  This\n-     can happen in some cases if we have labels we can not delete. \n-\n-     Similarly, do nothing if we can not delete the label at the start\n-     of the target block.  */\n   barrier = next_nonnote_insn (end);\n-  if (GET_CODE (barrier) != BARRIER\n-      || (GET_CODE (b->head) == CODE_LABEL\n-\t  && ! can_delete_label_p (b->head)))\n-    return 0;\n-  else\n-    flow_delete_insn (barrier);\n+  if (GET_CODE (barrier) != BARRIER)\n+    abort ();\n+  flow_delete_insn (barrier);\n \n   /* Move block and loop notes out of the chain so that we do not\n      disturb their order.\n@@ -2240,20 +2246,23 @@ merge_blocks_move_successor_nojumps (a, b)\n \n   start = b->head;\n   end = b->end;\n+  barrier = NEXT_INSN (end);\n \n-  /* We want to delete the BARRIER after the end of the insns we are\n-     going to move.  If we don't find a BARRIER, then do nothing.  This\n-     can happen in some cases if we have labels we can not delete. \n+  /* Recognize a jump table following block B.  */\n+  if (GET_CODE (barrier) == CODE_LABEL\n+      && NEXT_INSN (barrier)\n+      && GET_CODE (NEXT_INSN (barrier)) == JUMP_INSN\n+      && (GET_CODE (PATTERN (NEXT_INSN (barrier))) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (NEXT_INSN (barrier))) == ADDR_DIFF_VEC))\n+    {\n+      end = NEXT_INSN (barrier);\n+      barrier = NEXT_INSN (end);\n+    }\n \n-     Similarly, do nothing if we can not delete the label at the start\n-     of the target block.  */\n-  barrier = next_nonnote_insn (end);\n-  if (GET_CODE (barrier) != BARRIER\n-      || (GET_CODE (b->head) == CODE_LABEL\n-\t  && ! can_delete_label_p (b->head)))\n-    return 0;\n-  else\n-    flow_delete_insn (barrier);\n+  /* There had better have been a barrier there.  Delete it.  */\n+  if (GET_CODE (barrier) != BARRIER)\n+    abort ();\n+  flow_delete_insn (barrier);\n \n   /* Move block and loop notes out of the chain so that we do not\n      disturb their order.\n@@ -2287,17 +2296,17 @@ merge_blocks (e, b, c)\n      edge e;\n      basic_block b, c;\n {\n+  /* If C has a tail recursion label, do not merge.  There is no\n+     edge recorded from the call_placeholder back to this label, as\n+     that would make optimize_sibling_and_tail_recursive_calls more\n+     complex for no gain.  */\n+  if (GET_CODE (c->head) == CODE_LABEL\n+      && tail_recursion_label_p (c->head))\n+    return 0;\n+\n   /* If B has a fallthru edge to C, no need to move anything.  */\n   if (e->flags & EDGE_FALLTHRU)\n     {\n-      /* If a label still appears somewhere and we cannot delete the label,\n-\t then we cannot merge the blocks.  The edge was tidied already.  */\n-\n-      rtx insn, stop = NEXT_INSN (c->head);\n-      for (insn = NEXT_INSN (b->end); insn != stop; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == CODE_LABEL && !can_delete_label_p (insn))\n-\t  return 0;\n-\n       merge_blocks_nomove (b, c);\n \n       if (rtl_dump_file)"}, {"sha": "aa54390e73a3ee3ab818f25553299ef5bf04ad26", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 7, "deletions": 52, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -1275,37 +1275,8 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n      get their addresses taken.  */\n   if (else_bb)\n     {\n-      if (LABEL_NUSES (else_bb->head) == 0\n-\t  && ! LABEL_PRESERVE_P (else_bb->head)\n-\t  && ! LABEL_NAME (else_bb->head))\n-\t{\n-\t  /* We can merge the ELSE.  */\n-\t  merge_blocks_nomove (combo_bb, else_bb);\n-\t  num_removed_blocks++;\n-\t}\n-      else\n-\t{\n-\t  /* We cannot merge the ELSE.  */\n-\n-\t  /* Properly rewire the edge out of the now combined\n-\t     TEST-THEN block to point here.  */\n-\t  remove_edge (combo_bb->succ);\n-\t  if (combo_bb->succ || else_bb->pred)\n-\t    abort ();\n-\t  make_edge (NULL, combo_bb, else_bb, EDGE_FALLTHRU);\n-\n-\t  /* Remove the jump and cruft from the end of the TEST-THEN block.  */\n-\t  tidy_fallthru_edge (combo_bb->succ, combo_bb, else_bb);\n-\n-\t  /* Make sure we update life info properly.  */\n-\t  SET_UPDATE_LIFE(combo_bb);\n-\t  if (else_bb->global_live_at_end)\n-\t    COPY_REG_SET (else_bb->global_live_at_start,\n-\t\t\t  else_bb->global_live_at_end);\n-\n-\t  /* The ELSE is the new combo block.  */\n-\t  combo_bb = else_bb;\n-\t}\n+      merge_blocks_nomove (combo_bb, else_bb);\n+      num_removed_blocks++;\n     }\n \n   /* If there was no join block reported, that means it was not adjacent\n@@ -1325,12 +1296,11 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n \tabort ();\n     }\n \n-  /* The JOIN block had a label.  It may have had quite a number\n-     of other predecessors too, but probably not.  See if we can\n-     merge this with the others.  */\n-  else if (LABEL_NUSES (join_bb->head) == 0\n-      && ! LABEL_PRESERVE_P (join_bb->head)\n-      && ! LABEL_NAME (join_bb->head))\n+  /* The JOIN block may have had quite a number of other predecessors too.\n+     Since we've already merged the TEST, THEN and ELSE blocks, we should\n+     have only one remaining edge from our if-then-else diamond.  If there\n+     is more than one remaining edge, it must come from elsewhere.  */\n+  else if (join_bb->pred->pred_next == NULL)\n     {\n       /* We can merge the JOIN.  */\n       if (combo_bb->global_live_at_end)\n@@ -1438,11 +1408,6 @@ find_if_block (test_bb, then_edge, else_edge)\n       || (then_succ->flags & EDGE_COMPLEX))\n     return FALSE;\n \n-  /* The THEN block may not start with a label, as might happen with an\n-     unused user label that has had its address taken.  */\n-  if (GET_CODE (then_bb->head) == CODE_LABEL)\n-    return FALSE;\n-\n   /* If the THEN block's successor is the other edge out of the TEST block,\n      then we have an IF-THEN combo without an ELSE.  */\n   if (then_succ->dest == else_bb)\n@@ -1600,10 +1565,6 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   if (then_bb->pred->pred_next != NULL)\n     return FALSE;\n \n-  /* THEN has no label.  */\n-  if (GET_CODE (then_bb->head) == CODE_LABEL)\n-    return FALSE;\n-\n   /* ELSE follows THEN.  (??? could be moved)  */\n   if (else_bb->index != then_bb->index + 1)\n     return FALSE;\n@@ -1674,12 +1635,6 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   if (else_bb->pred->pred_next != NULL)\n     return FALSE;\n \n-  /* ELSE has a label we can delete.  */\n-  if (LABEL_NUSES (else_bb->head) > 1\n-      || LABEL_PRESERVE_P (else_bb->head)\n-      || LABEL_NAME (else_bb->head))\n-    return FALSE;\n-\n   /* ELSE is predicted or SUCC(ELSE) postdominates THEN.  */\n   note = find_reg_note (test_bb->end, REG_BR_PROB, NULL_RTX);\n   if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)"}, {"sha": "4296759545f488a4eba2094ac3475fd8d3be7850", "filename": "gcc/jump.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -1262,10 +1262,19 @@ duplicate_loop_exit_test (loop_start)\n \t     make them.  */\n \t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t    if (REG_NOTE_KIND (link) != REG_LABEL)\n-\t      REG_NOTES (copy)\n-\t\t= copy_insn_1 (gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),\n-\t\t\t\t\t       XEXP (link, 0),\n-\t\t\t\t\t       REG_NOTES (copy)));\n+\t      {\n+\t\tif (GET_CODE (link) == EXPR_LIST)\n+\t\t  REG_NOTES (copy)\n+\t\t    = copy_insn_1 (gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),\n+\t\t\t\t\t\t      XEXP (link, 0),\n+\t\t\t\t\t\t      REG_NOTES (copy)));\n+\t\telse\n+\t\t  REG_NOTES (copy)\n+\t\t    = copy_insn_1 (gen_rtx_INSN_LIST (REG_NOTE_KIND (link),\n+\t\t\t\t\t\t      XEXP (link, 0),\n+\t\t\t\t\t\t      REG_NOTES (copy)));\n+\t      }\n+\n \t  if (reg_map && REG_NOTES (copy))\n \t    replace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n \t  break;\n@@ -1345,8 +1354,8 @@ duplicate_loop_exit_test (loop_start)\n   return 1;\n }\n \f\n-/* Move all block-beg, block-end, loop-beg, loop-cont, loop-vtop, and\n-   loop-end notes between START and END out before START.  Assume that\n+/* Move all block-beg, block-end, loop-beg, loop-cont, loop-vtop, loop-end,\n+   eh-beg, eh-end notes between START and END out before START.  Assume that\n    END is not such a note.  START may be such a note.  Returns the value\n    of the new starting insn, which may be different if the original start\n    was such a note.  */\n@@ -1367,7 +1376,9 @@ squeeze_notes (start, end)\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n \t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_CONT\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP))\n+\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP\n+\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n+\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n \t{\n \t  if (insn == start)\n \t    start = next;\n@@ -2389,6 +2400,12 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \trtx note;\n \trtx next;\n \n+\t/* Ignore remaining references to unreachable labels that\n+\t   have been deleted.  */\n+        if (GET_CODE (label) == NOTE\n+\t    && NOTE_LINE_NUMBER (label) == NOTE_INSN_DELETED_LABEL)\n+\t  break;\n+\n \tif (GET_CODE (label) != CODE_LABEL)\n \t  abort ();\n \n@@ -2449,7 +2466,7 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \t\t   is no longer valid because of the more accurate cfg\n \t\t   we build in find_basic_blocks -- it no longer pessimizes\n \t\t   code when it finds a REG_LABEL note.  */\n-\t\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t\tREG_NOTES (insn) = gen_rtx_INSN_LIST (REG_LABEL, label,\n \t\t\t\t\t\t      REG_NOTES (insn));\n \t      }\n \t  }\n@@ -2755,9 +2772,10 @@ delete_insn (insn)\n \tdont_really_delete = 1;\n       else if (! dont_really_delete)\n \t{\n+\t  const char *name = LABEL_NAME (insn);\n \t  PUT_CODE (insn, NOTE);\n \t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED_LABEL;\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t  NOTE_SOURCE_FILE (insn) = name;\n \t  dont_really_delete = 1;\n \t}\n     }"}, {"sha": "d8008380215d6f57d1d383edadedad808e89ba2f", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -210,6 +210,13 @@ print_rtx (in_rtx)\n \t\tindent -= 2;\n \t\tbreak;\n \n+\t      case NOTE_INSN_DELETED_LABEL:\n+\t\tif (NOTE_SOURCE_FILE (in_rtx))\n+\t\t  fprintf (outfile, \" (\\\"%s\\\")\", NOTE_SOURCE_FILE (in_rtx));\n+\t\telse\n+\t\t  fprintf (outfile, \" \\\"\\\"\");\n+\t\tbreak;\n+\n \t      default:\n \t\t{\n \t\t  const char * const str = X0STR (in_rtx, i);\n@@ -334,11 +341,25 @@ print_rtx (in_rtx)\n \t    rtx sub = XEXP (in_rtx, i);\n \t    enum rtx_code subc = GET_CODE (sub);\n \n-\t    if (GET_CODE (in_rtx) == LABEL_REF && subc != CODE_LABEL)\n-\t      goto do_e;\n+\t    if (GET_CODE (in_rtx) == LABEL_REF)\n+\t      {\n+\t\tif (subc == NOTE\n+\t\t    && NOTE_LINE_NUMBER (sub) == NOTE_INSN_DELETED_LABEL)\n+\t\t  {\n+\t\t    if (flag_dump_unnumbered)\n+\t\t      fprintf (outfile, \" [# deleted]\");\n+\t\t    else\n+\t\t      fprintf (outfile, \" [%d deleted]\", INSN_UID (sub));\n+\t\t    sawclose = 0;\n+\t\t    break;\n+\t\t  }\n+\n+\t\tif (subc != CODE_LABEL)\n+\t\t  goto do_e;\n+\t      }\n \n \t    if (flag_dump_unnumbered)\n-\t      fputc ('#', outfile);\n+\t      fputs (\" #\", outfile);\n \t    else\n \t      fprintf (outfile, \" %d\", INSN_UID (sub));\n \t  }\n@@ -372,34 +393,43 @@ print_rtx (in_rtx)\n \tabort ();\n       }\n \n-  if (GET_CODE (in_rtx) == MEM)\n-    fprintf (outfile, \" %d\", MEM_ALIAS_SET (in_rtx));\n+  switch (GET_CODE (in_rtx))\n+    {\n+    case MEM:\n+      fprintf (outfile, \" %d\", MEM_ALIAS_SET (in_rtx));\n+      break;\n \n #if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT && MAX_LONG_DOUBLE_TYPE_SIZE == 64\n-  if (GET_CODE (in_rtx) == CONST_DOUBLE && FLOAT_MODE_P (GET_MODE (in_rtx)))\n-    {\n-      double val;\n-      REAL_VALUE_FROM_CONST_DOUBLE (val, in_rtx);\n-      fprintf (outfile, \" [%.16g]\", val);\n-    }\n+    case CONST_DOUBLE:\n+      if (FLOAT_MODE_P (GET_MODE (in_rtx)))\n+\t{\n+\t  double val;\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (val, in_rtx);\n+\t  fprintf (outfile, \" [%.16g]\", val);\n+\t}\n+      break;\n #endif\n \n-  if (GET_CODE (in_rtx) == CODE_LABEL)\n-    {\n+    case CODE_LABEL:\n       fprintf (outfile, \" [%d uses]\", LABEL_NUSES (in_rtx));\n       if (LABEL_ALTERNATE_NAME (in_rtx))\n         fprintf (outfile, \" [alternate name: %s]\",\n \t\t LABEL_ALTERNATE_NAME (in_rtx));\n+      break;\n+\n+    case CALL_PLACEHOLDER:\n+      for (tem = XEXP (in_rtx, 0); tem != 0; tem = NEXT_INSN (tem))\n+\tif (GET_CODE (tem) == CALL_INSN)\n+\t  {\n+\t    fprintf (outfile, \" \");\n+\t    print_rtx (tem);\n+\t    break;\n+\t  }\n+      break;\n+\n+    default:\n+      break;\n     }\n-  \n-  if (GET_CODE (in_rtx) == CALL_PLACEHOLDER)\n-    for (tem = XEXP (in_rtx, 0); tem != 0; tem = NEXT_INSN (tem))\n-      if (GET_CODE (tem) == CALL_INSN)\n-\t{\n-\t  fprintf (outfile, \" \");\n-\t  print_rtx (tem);\n-\t  break;\n-\t}\n \n   if (dump_for_graph\n       && (is_insn || GET_CODE (in_rtx) == NOTE"}, {"sha": "97df5373e3ee679987432efd517899efc70ddff8", "filename": "gcc/rtl.def", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -413,21 +413,16 @@ DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu\", 'x')\n \n /* Holds a label that is followed by instructions.\n    Operand:\n-   3: is a number that is unique in the entire compilation.\n-   4: is the user-given name of the label, if any.\n-   5: is used in jump.c for the use-count of the label.\n-   6: is used in flow.c to point to the chain of label_ref's to this label.\n+   3: is used in jump.c for the use-count of the label.\n+   4: is used in flow.c to point to the chain of label_ref's to this label.\n+   5: is a number that is unique in the entire compilation.\n+   6: is the user-given name of the label, if any.\n    7: is the alternate label name.  */\n-DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuis00s\", 'x')\n+DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuu00iss\", 'x')\n      \n /* Say where in the code a source line starts, for symbol table's sake.\n-   Contains a filename and a line number.  Line numbers <= 0 are special:\n-   0 is used in a dummy placed at the front of every function\n-      just so there will never be a need to delete the first insn;\n-   -1 indicates a dummy; insns to be deleted by flow analysis and combining\n-      are really changed to NOTEs with a number of -1.\n-   -2 means beginning of a name binding contour; output N_LBRAC.\n-   -3 means end of a contour; output N_RBRAC.  */\n+   Contains a filename and a line number.  Line numbers <= 0 are special;\n+   See enum note_insn in rtl.h.  */\n DEF_RTL_EXPR(NOTE, \"note\", \"iuu0n\", 'x')\n \n /* ----------------------------------------------------------------------"}, {"sha": "ccd143ecf02454b1224348822202e2291e592af2", "filename": "gcc/rtl.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -417,7 +417,7 @@ enum reg_note\n      appear on an insn which copies a register parameter to a pseudo-register,\n      if there is a memory address which could be used to hold that\n      pseudo-register throughout the function.  */\n-   REG_EQUIV,\n+  REG_EQUIV,\n \n   /* Like REG_EQUIV except that the destination is only momentarily equal\n      to the specified rtx.  Therefore, it cannot be used for substitution;\n@@ -437,7 +437,8 @@ enum reg_note\n   REG_RETVAL,\n \n   /* The inverse of REG_RETVAL: it goes on the first insn of the library call\n-     and points at the one that has the REG_RETVAL.  */\n+     and points at the one that has the REG_RETVAL.  This note is also an\n+     INSN_LIST.  */\n   REG_LIBCALL,\n \n   /* The register is always nonnegative during the containing loop.  This is\n@@ -459,11 +460,13 @@ enum reg_note\n      we permit putting a cc0-setting insn in the delay slot of a branch as\n      long as only one copy of the insn exists.  In that case, these notes\n      point from one to the other to allow code generation to determine what\n-     any require information and to properly update CC_STATUS.  */\n+     any require information and to properly update CC_STATUS.  These notes\n+     are INSN_LISTs.  */\n   REG_CC_SETTER, REG_CC_USER,\n \n   /* Points to a CODE_LABEL.  Used by non-JUMP_INSNs to say that the\n-     CODE_LABEL contained in the REG_LABEL note is used by the insn.  */\n+     CODE_LABEL contained in the REG_LABEL note is used by the insn. \n+     This note is an INSN_LIST.  */\n   REG_LABEL,\n \n   /* REG_DEP_ANTI and REG_DEP_OUTPUT are used in LOG_LINKS to represent\n@@ -544,7 +547,7 @@ extern const char * const reg_note_name[];\n /* The label-number of a code-label.  The assembler label\n    is made from `L' and the label-number printed in decimal.\n    Label numbers are unique in a compilation.  */\n-#define CODE_LABEL_NUMBER(INSN)\tXINT(INSN, 3)\n+#define CODE_LABEL_NUMBER(INSN)\tXINT(INSN, 5)\n \n #define LINE_NUMBER NOTE\n \n@@ -664,11 +667,11 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n \n /* The name of a label, in case it corresponds to an explicit label\n    in the input source code.  */\n-#define LABEL_NAME(RTX) XCSTR(RTX, 4, CODE_LABEL)\n+#define LABEL_NAME(RTX) XCSTR(RTX, 6, CODE_LABEL)\n \n /* In jump.c, each label contains a count of the number\n    of LABEL_REFs that point at it, so unused labels can be deleted.  */\n-#define LABEL_NUSES(RTX) XCINT(RTX, 5, CODE_LABEL)\n+#define LABEL_NUSES(RTX) XCINT(RTX, 3, CODE_LABEL)\n \n /* Associate a name with a CODE_LABEL.  */\n #define LABEL_ALTERNATE_NAME(RTX) XCSTR(RTX, 7, CODE_LABEL)\n@@ -687,8 +690,8 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* Once basic blocks are found in flow.c,\n    each CODE_LABEL starts a chain that goes through\n    all the LABEL_REFs that jump to that label.\n-   The chain eventually winds up at the CODE_LABEL; it is circular.  */\n-#define LABEL_REFS(LABEL) XCEXP(LABEL, 6, CODE_LABEL)\n+   The chain eventually winds up at the CODE_LABEL: it is circular.  */\n+#define LABEL_REFS(LABEL) XCEXP(LABEL, 4, CODE_LABEL)\n \f\n /* This is the field in the LABEL_REF through which the circular chain\n    of references to a particular label is linked."}, {"sha": "82d2d69d8368377b6dd32d638dc82c0afdd82579", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1bb652637d5d8785993a4cd197d989dc4b5260/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=be1bb652637d5d8785993a4cd197d989dc4b5260", "patch": "@@ -2207,6 +2207,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t     this new block.  */\n \n \t  if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED_LABEL\n \t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n \t      && ((NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_VTOP\n \t\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_CONT)"}]}