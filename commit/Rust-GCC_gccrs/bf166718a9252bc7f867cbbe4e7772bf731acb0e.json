{"sha": "bf166718a9252bc7f867cbbe4e7772bf731acb0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYxNjY3MThhOTI1MmJjN2Y4NjdjYmJlNGU3NzcyYmY3MzFhY2IwZQ==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2016-11-14T18:55:05Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2016-11-14T18:55:05Z"}, "message": "tree-ssa-math-opts.c (find_bswap_or_nop): Zero out bytes in cmpxchg and cmpnop in two steps...\n\n2016-11-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    * tree-ssa-math-opts.c (find_bswap_or_nop): Zero out bytes in cmpxchg\n    and cmpnop in two steps: first the ones not accessed in original gimple\n    expression in a endian independent way and then the ones not accessed\n    in the final result in an endian-specific way.\n    (bswap_replace): Stop doing big endian adjustment.\n\nFrom-SVN: r242394", "tree": {"sha": "79b8405f2e07fe96cbec3d3749ccad885c4f34b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79b8405f2e07fe96cbec3d3749ccad885c4f34b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf166718a9252bc7f867cbbe4e7772bf731acb0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf166718a9252bc7f867cbbe4e7772bf731acb0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf166718a9252bc7f867cbbe4e7772bf731acb0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf166718a9252bc7f867cbbe4e7772bf731acb0e/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d32e1fd8b9e1263d50bb697e40d4d92ece54c439", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d32e1fd8b9e1263d50bb697e40d4d92ece54c439", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d32e1fd8b9e1263d50bb697e40d4d92ece54c439"}], "stats": {"total": 74, "additions": 37, "deletions": 37}, "files": [{"sha": "f259470e9fabcedd8a300c3d59981bbf4e5ff35e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf166718a9252bc7f867cbbe4e7772bf731acb0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf166718a9252bc7f867cbbe4e7772bf731acb0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf166718a9252bc7f867cbbe4e7772bf731acb0e", "patch": "@@ -1,3 +1,11 @@\n+2016-11-14  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+        * tree-ssa-math-opts.c (find_bswap_or_nop): Zero out bytes in cmpxchg\n+\tand cmpnop in two steps: first the ones not accessed in original gimple\n+\texpression in a endian independent way and then the ones not accessed\n+\tin the final result in an endian-specific way.\n+\t(bswap_replace): Stop doing big endian adjustment.\n+\n 2016-11-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*andndi3_doubleword): Merge operand constraints."}, {"sha": "b28c808c55489ae1ae16c173d66c561c1897e6ab", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf166718a9252bc7f867cbbe4e7772bf731acb0e/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf166718a9252bc7f867cbbe4e7772bf731acb0e/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=bf166718a9252bc7f867cbbe4e7772bf731acb0e", "patch": "@@ -2504,9 +2504,11 @@ find_bswap_or_nop_1 (gimple *stmt, struct symbolic_number *n, int limit)\n static gimple *\n find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n {\n-  /* The number which the find_bswap_or_nop_1 result should match in order\n-     to have a full byte swap.  The number is shifted to the right\n-     according to the size of the symbolic number before using it.  */\n+  unsigned rsize;\n+  uint64_t tmpn, mask;\n+/* The number which the find_bswap_or_nop_1 result should match in order\n+   to have a full byte swap.  The number is shifted to the right\n+   according to the size of the symbolic number before using it.  */\n   uint64_t cmpxchg = CMPXCHG;\n   uint64_t cmpnop = CMPNOP;\n \n@@ -2527,28 +2529,38 @@ find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n \n   /* Find real size of result (highest non-zero byte).  */\n   if (n->base_addr)\n-    {\n-      unsigned HOST_WIDE_INT rsize;\n-      uint64_t tmpn;\n-\n-      for (tmpn = n->n, rsize = 0; tmpn; tmpn >>= BITS_PER_MARKER, rsize++);\n-      if (BYTES_BIG_ENDIAN && n->range != rsize)\n-\t/* This implies an offset, which is currently not handled by\n-\t   bswap_replace.  */\n-\treturn NULL;\n-      n->range = rsize;\n-    }\n+    for (tmpn = n->n, rsize = 0; tmpn; tmpn >>= BITS_PER_MARKER, rsize++);\n+  else\n+    rsize = n->range;\n \n-  /* Zero out the extra bits of N and CMP*.  */\n+  /* Zero out the bits corresponding to untouched bytes in original gimple\n+     expression.  */\n   if (n->range < (int) sizeof (int64_t))\n     {\n-      uint64_t mask;\n-\n       mask = ((uint64_t) 1 << (n->range * BITS_PER_MARKER)) - 1;\n       cmpxchg >>= (64 / BITS_PER_MARKER - n->range) * BITS_PER_MARKER;\n       cmpnop &= mask;\n     }\n \n+  /* Zero out the bits corresponding to unused bytes in the result of the\n+     gimple expression.  */\n+  if (rsize < n->range)\n+    {\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  mask = ((uint64_t) 1 << (rsize * BITS_PER_MARKER)) - 1;\n+\t  cmpxchg &= mask;\n+\t  cmpnop >>= (n->range - rsize) * BITS_PER_MARKER;\n+\t}\n+      else\n+\t{\n+\t  mask = ((uint64_t) 1 << (rsize * BITS_PER_MARKER)) - 1;\n+\t  cmpxchg >>= (n->range - rsize) * BITS_PER_MARKER;\n+\t  cmpnop &= mask;\n+\t}\n+      n->range = rsize;\n+    }\n+\n   /* A complete byte swap should make the symbolic number to start with\n      the largest digit in the highest order byte. Unchanged symbolic\n      number indicates a read with same endianness as target architecture.  */\n@@ -2636,26 +2648,6 @@ bswap_replace (gimple *cur_stmt, gimple *src_stmt, tree fndecl,\n       HOST_WIDE_INT load_offset = 0;\n \n       align = get_object_alignment (src);\n-      /* If the new access is smaller than the original one, we need\n-\t to perform big endian adjustment.  */\n-      if (BYTES_BIG_ENDIAN)\n-\t{\n-\t  HOST_WIDE_INT bitsize, bitpos;\n-\t  machine_mode mode;\n-\t  int unsignedp, reversep, volatilep;\n-\t  tree offset;\n-\n-\t  get_inner_reference (src, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t       &unsignedp, &reversep, &volatilep);\n-\t  if (n->range < (unsigned HOST_WIDE_INT) bitsize)\n-\t    {\n-\t      load_offset = (bitsize - n->range) / BITS_PER_UNIT;\n-\t      unsigned HOST_WIDE_INT l\n-\t\t= (load_offset * BITS_PER_UNIT) & (align - 1);\n-\t      if (l)\n-\t\talign = least_bit_hwi (l);\n-\t    }\n-\t}\n \n       if (bswap\n \t  && align < GET_MODE_ALIGNMENT (TYPE_MODE (load_type))"}]}