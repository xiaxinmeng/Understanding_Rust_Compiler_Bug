{"sha": "cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f", "node_id": "C_kwDOANBUbNoAKGNiYWExZDljMjE4ZDljMGI1ZTM0ZTUxMGE0NjJmZjRlMjk5YTBmM2Y", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-03-02T19:03:21Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-03-02T19:03:21Z"}, "message": "c++: constant non-copy-init is manifestly constant [PR108243]\n\nAccording to [basic.start.static]/2 and [expr.const]/2, a variable\nwith static storage duration initialized with a constant initializer\nhas constant initialization, and such an initializer is manifestly\nconstant-evaluated.\n\nFor copy initialization, we're already getting this right because in\nthat case check_initializer would consistently call store_init_value,\nwhich for TREE_STATIC variables calls fold_non_dependent_init with\nm_c_e=true.\n\nBut for direct (or default) initialization, check_initializer doesn't\nalways call store_init_value.  We instead however always call\nmaybe_constant_init from expand_default_init[1], albeit with m_c_e=false\nwhich means we don't get the \"manifestly constant-evaluated\" part right\nfor non-copy-init.\n\nThis patch fixes this by setting m_c_e=true in maybe_constant_init for\nstatic storage duration variables, mainly for benefit of the call\nto maybe_constant_init from expand_default_init.\n\n[1]: this maybe_constant_init call isn't reached in the copy-init\ncase because there init is a CONSTRUCTOR rather than a TREE_LIST,\nand so we exit early from expand_default_init, returning an INIT_EXPR.\nThis INIT_EXPR is ultimately what causes us to consistently hit the\nstore_init_value code path from check_initializer in the copy-init case.\n\n\tPR c++/108243\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (maybe_constant_init_1): Override\n\tmanifestly_const_eval to true if is_static.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/is-constant-evaluated14.C: New test.", "tree": {"sha": "fdea0865f0d6bb42ef6b39e6c06d943f9064fd32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdea0865f0d6bb42ef6b39e6c06d943f9064fd32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f/comments", "author": null, "committer": null, "parents": [{"sha": "20bd258d0fa09837b3a93478ef92d8789cbcd442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bd258d0fa09837b3a93478ef92d8789cbcd442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20bd258d0fa09837b3a93478ef92d8789cbcd442"}], "stats": {"total": 142, "additions": 142, "deletions": 0}, "files": [{"sha": "acf9847a4d104dbd5b0677a28af9562dee2f6551", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f", "patch": "@@ -8770,6 +8770,8 @@ maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n \t shouldn't bend the rules the same way for automatic variables.  */\n       bool is_static = (decl && DECL_P (decl)\n \t\t\t&& (TREE_STATIC (decl) || DECL_EXTERNAL (decl)));\n+      if (is_static)\n+\tmanifestly_const_eval = true;\n       t = cxx_eval_outermost_constant_expr (t, allow_non_constant, !is_static,\n \t\t\t\t\t    mce_value (manifestly_const_eval),\n \t\t\t\t\t    false, decl);"}, {"sha": "a41461f3604382c5d22fc93da79fb241caf976b5", "filename": "gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated14.C", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated14.C?ref=cbaa1d9c218d9c0b5e34e510a462ff4e299a0f3f", "patch": "@@ -0,0 +1,140 @@\n+// PR c++/108243\n+// Verify a variable with static storage duration initialized with a\n+// constant initializer has constant initialization, and the initializer\n+// is manifestly constant-evaluated.\n+// { dg-do run { target c++11 } }\n+// { dg-additional-options \"-fdump-tree-original\" }\n+\n+// { dg-final { scan-tree-dump-not \"static initializers for\" \"original\" } }\n+// { dg-final { scan-tree-dump-not \"cxa_guard_acquire\" \"original\" } }\n+\n+#include <initializer_list>\n+\n+struct A {\n+  constexpr A(int n) : n(n), m(__builtin_is_constant_evaluated()) { }\n+  constexpr A() : A(42) { }\n+  void verify_mce() const {\n+    if (m != 1) __builtin_abort();\n+  }\n+  int n;\n+  int m;\n+};\n+\n+A a1 = {42};\n+A a2{42};\n+A a3(42);\n+A a4;\n+A a5{};\n+\n+void f() {\n+  static A a1 = {42};\n+  static A a2{42};\n+  static A a3(42);\n+  static A a4;\n+  static A a5{};\n+  for (auto& a : {a1, a2, a3, a4, a5})\n+    a.verify_mce();\n+}\n+\n+template<int... N>\n+void g() {\n+  static A a1 = {42};\n+  static A a2{42};\n+  static A a3(42);\n+  static A a4;\n+  static A a5{};\n+  static A a6 = {N...};\n+  static A a7{N...};\n+  static A a8(N...);\n+  for (auto& a : {a1, a2, a3, a4, a5, a6, a7, a8})\n+    a.verify_mce();\n+}\n+\n+struct B {\n+  static A a1;\n+  static A a2;\n+  static A a3;\n+  static A a4;\n+  static A a5;\n+  static void verify_mce() {\n+    for (auto& a : {a1, a2, a3, a4, a5})\n+      a.verify_mce();\n+  }\n+};\n+\n+A B::a1 = {42};\n+A B::a2{42};\n+A B::a3(42);\n+A B::a4;\n+A B::a5{};\n+\n+template<int... N>\n+struct BT {\n+  static A a1;\n+  static A a2;\n+  static A a3;\n+  static A a4;\n+  static A a5;\n+  static A a6;\n+  static A a7;\n+  static A a8;\n+  static void verify_mce() {\n+    for (auto& a : {a1, a2, a3, a4, a5})\n+      a.verify_mce();\n+  }\n+};\n+\n+template<int... N> A BT<N...>::a1 = {42};\n+template<int... N> A BT<N...>::a2{42};\n+template<int... N> A BT<N...>::a3(42);\n+template<int... N> A BT<N...>::a4;\n+template<int... N> A BT<N...>::a5{};\n+template<int... N> A BT<N...>::a6 = {N...};\n+template<int... N> A BT<N...>::a7{N...};\n+template<int... N> A BT<N...>::a8(N...);\n+\n+#if __cpp_inline_variables\n+struct BI {\n+  static inline A a1 = {42};\n+  static inline A a2{42};\n+  static inline A a3;\n+  static inline A a4{};\n+  static void verify_mce() {\n+    for (auto& a : {a1, a2, a3, a4})\n+      a.verify_mce();\n+  }\n+};\n+\n+template<int... N>\n+struct BIT {\n+  static inline A a1 = {42};\n+  static inline A a2{42};\n+  static inline A a3;\n+  static inline A a4{};\n+  static inline A a5 = {N...};\n+  static inline A a6{N...};\n+  static void verify_mce() {\n+    for (auto& a : {a1, a2, a3, a4, a5, a6})\n+      a.verify_mce();\n+  }\n+};\n+#endif\n+\n+int main() {\n+  for (auto& a : {a1, a2, a3, a4, a5})\n+    a.verify_mce();\n+\n+  f();\n+  g<42>();\n+  g<>();\n+\n+  B::verify_mce();\n+  BT<42>::verify_mce();\n+  BT<>::verify_mce();\n+\n+#if __cpp_inline_variables\n+  BI::verify_mce();\n+  BIT<42>::verify_mce();\n+  BIT<>::verify_mce();\n+#endif\n+}"}]}