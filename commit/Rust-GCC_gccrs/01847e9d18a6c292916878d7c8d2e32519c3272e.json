{"sha": "01847e9d18a6c292916878d7c8d2e32519c3272e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE4NDdlOWQxOGE2YzI5MjkxNjg3OGQ3YzhkMmUzMjUxOWMzMjcyZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-18T17:46:16Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-18T17:46:16Z"}, "message": "builtins.c (simplify_builtin_memcmp, [...]): Delete.\n\n\n\t* builtins.c (simplify_builtin_memcmp, simplify_builtin_strcmp,\n\tsimplify_builtin_strncmp): Delete.\n\t(fold_builtin_memcmp, fold_builtin_strcmp, fold_builtin_strncmp):\n\tChange argument to accept an arglist instead of an \"exp\".  Assume\n\tthat the return type is always integer_type_node.  Copy missing\n\ttransformations from their now obsolete simplify_builtin_*\n\tequivalents.\n\t(fold_builtin_1): Pass arglist instead of exp to fold_builtin_memcmp,\n\tfold_builtin_strcmp and fold_builtin_strncmp.\n\t(simplify_builtin): Call fold_builtin_memcmp, fold_builtin_strcmp\n\tand fold_builtin_strncmp instead of simplify_builtin_memcmp,\n\tsimplify_builtin_strcmp and simplify_builtin_strncmp respectively.\n\nFrom-SVN: r84898", "tree": {"sha": "d2f5f06114807657231f0bd8b3e16275d811ec1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f5f06114807657231f0bd8b3e16275d811ec1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01847e9d18a6c292916878d7c8d2e32519c3272e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01847e9d18a6c292916878d7c8d2e32519c3272e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01847e9d18a6c292916878d7c8d2e32519c3272e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01847e9d18a6c292916878d7c8d2e32519c3272e/comments", "author": null, "committer": null, "parents": [{"sha": "e2d4f634d54135debe57500ef94ecbcaaba0382b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d4f634d54135debe57500ef94ecbcaaba0382b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2d4f634d54135debe57500ef94ecbcaaba0382b"}], "stats": {"total": 400, "additions": 146, "deletions": 254}, "files": [{"sha": "b62a65c4e81c9cc5c6ab6570063831cf97447a4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01847e9d18a6c292916878d7c8d2e32519c3272e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01847e9d18a6c292916878d7c8d2e32519c3272e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01847e9d18a6c292916878d7c8d2e32519c3272e", "patch": "@@ -1,3 +1,18 @@\n+2004-07-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (simplify_builtin_memcmp, simplify_builtin_strcmp,\n+\tsimplify_builtin_strncmp): Delete.\n+\t(fold_builtin_memcmp, fold_builtin_strcmp, fold_builtin_strncmp):\n+\tChange argument to accept an arglist instead of an \"exp\".  Assume\n+\tthat the return type is always integer_type_node.  Copy missing\n+\ttransformations from their now obsolete simplify_builtin_*\n+\tequivalents.\n+\t(fold_builtin_1): Pass arglist instead of exp to fold_builtin_memcmp,\n+\tfold_builtin_strcmp and fold_builtin_strncmp.\n+\t(simplify_builtin): Call fold_builtin_memcmp, fold_builtin_strcmp\n+\tand fold_builtin_strncmp instead of simplify_builtin_memcmp,\n+\tsimplify_builtin_strcmp and simplify_builtin_strncmp respectively.\n+\n 2004-07-18  Daniel Jacobowitz  <dan@debian.org>\n \n \t* Makefile.in (tree-alias-common.o): Update dependencies."}, {"sha": "902227705d7ef415492e5fdf0bdff2a9c33603a5", "filename": "gcc/builtins.c", "status": "modified", "additions": 131, "deletions": 254, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01847e9d18a6c292916878d7c8d2e32519c3272e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01847e9d18a6c292916878d7c8d2e32519c3272e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=01847e9d18a6c292916878d7c8d2e32519c3272e", "patch": "@@ -170,9 +170,6 @@ static tree fold_builtin_abs (tree, tree);\n static tree fold_builtin_unordered_cmp (tree, enum tree_code, enum tree_code);\n static tree fold_builtin_1 (tree, bool);\n \n-static tree simplify_builtin_memcmp (tree);\n-static tree simplify_builtin_strcmp (tree);\n-static tree simplify_builtin_strncmp (tree);\n static tree simplify_builtin_strpbrk (tree);\n static tree simplify_builtin_strstr (tree);\n static tree simplify_builtin_strchr (tree);\n@@ -7279,10 +7276,10 @@ fold_builtin_strchr (tree exp, bool actually_strrchr)\n    NULL_TREE if no simplification can be made.  */\n \n static tree\n-fold_builtin_memcmp (tree exp)\n+fold_builtin_memcmp (tree arglist)\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n   tree arg1, arg2, len;\n+  const char *p1, *p2;\n \n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n@@ -7294,14 +7291,48 @@ fold_builtin_memcmp (tree exp)\n \n   /* If the LEN parameter is zero, return zero.  */\n   if (integer_zerop (len))\n-    {\n-      tree temp = omit_one_operand (TREE_TYPE (exp), integer_zero_node, arg2);\n-      return omit_one_operand (TREE_TYPE (exp), temp, arg1);\n-    }\n+    return omit_two_operands (integer_type_node, integer_zero_node,\n+\t\t\t      arg1, arg2);\n \n   /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n   if (operand_equal_p (arg1, arg2, 0))\n-    return omit_one_operand (TREE_TYPE (exp), integer_zero_node, len);\n+    return omit_one_operand (integer_type_node, integer_zero_node, len);\n+\n+  p1 = c_getstr (arg1);\n+  p2 = c_getstr (arg2);\n+\n+  /* If all arguments are constant, and the value of len is not greater\n+     than the lengths of arg1 and arg2, evaluate at compile-time.  */\n+  if (host_integerp (len, 1) && p1 && p2\n+      && compare_tree_int (len, strlen (p1) + 1) <= 0\n+      && compare_tree_int (len, strlen (p2) + 1) <= 0)\n+    {\n+      const int r = memcmp (p1, p2, tree_low_cst (len, 1));\n+\n+      if (r > 0)\n+\treturn integer_one_node;\n+      else if (r < 0)\n+\treturn integer_minus_one_node;\n+      else\n+\treturn integer_zero_node;\n+    }\n+\n+  /* If len parameter is one, return an expression corresponding to\n+     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n+  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 1)\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      tree ind1 = fold_convert (integer_type_node,\n+\t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n+\t\t\t\t\t\t      arg1)));\n+      tree ind2 = fold_convert (integer_type_node,\n+\t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n+\t\t\t\t\t\t      arg2)));\n+      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n+    }\n \n   return 0;\n }\n@@ -7310,37 +7341,56 @@ fold_builtin_memcmp (tree exp)\n    NULL_TREE if no simplification can be made.  */\n \n static tree\n-fold_builtin_strcmp (tree exp)\n+fold_builtin_strcmp (tree arglist)\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n   tree arg1, arg2;\n   const char *p1, *p2;\n \n-  if (!validate_arglist (arglist,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n \n   arg1 = TREE_VALUE (arglist);\n   arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n \n   /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n   if (operand_equal_p (arg1, arg2, 0))\n-    return fold_convert (TREE_TYPE (exp), integer_zero_node);\n+    return integer_zero_node;\n \n   p1 = c_getstr (arg1);\n   p2 = c_getstr (arg2);\n \n   if (p1 && p2)\n     {\n-      tree temp;\n       const int i = strcmp (p1, p2);\n       if (i < 0)\n-\ttemp = integer_minus_one_node;\n+\treturn integer_minus_one_node;\n       else if (i > 0)\n-\ttemp = integer_one_node;\n+\treturn integer_one_node;\n       else\n-\ttemp = integer_zero_node;\n-      return fold_convert (TREE_TYPE (exp), temp);\n+\treturn integer_zero_node;\n+    }\n+\n+  /* If the second arg is \"\", return *(const unsigned char*)arg1.  */\n+  if (p2 && *p2 == '\\0')\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      return fold_convert (integer_type_node,\n+\t\t\t   build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t\t   fold_convert (cst_uchar_ptr_node,\n+\t\t\t\t\t\t arg1)));\n+    }\n+\n+  /* If the first arg is \"\", return -*(const unsigned char*)arg2.  */\n+  if (p1 && *p1 == '\\0')\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      tree temp = fold_convert (integer_type_node,\n+\t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n+\t\t\t\t\t\t      arg2)));\n+      return fold (build1 (NEGATE_EXPR, integer_type_node, temp));\n     }\n \n   return 0;\n@@ -7350,9 +7400,8 @@ fold_builtin_strcmp (tree exp)\n    NULL_TREE if no simplification can be made.  */\n \n static tree\n-fold_builtin_strncmp (tree exp)\n+fold_builtin_strncmp (tree arglist)\n {\n-  tree arglist = TREE_OPERAND (exp, 1);\n   tree arg1, arg2, len;\n   const char *p1, *p2;\n \n@@ -7366,29 +7415,71 @@ fold_builtin_strncmp (tree exp)\n \n   /* If the LEN parameter is zero, return zero.  */\n   if (integer_zerop (len))\n-    {\n-      tree temp = omit_one_operand (TREE_TYPE (exp), integer_zero_node, arg2);\n-      return omit_one_operand (TREE_TYPE (exp), temp, arg1);\n-    }\n+    return omit_two_operands (integer_type_node, integer_zero_node,\n+\t\t\t      arg1, arg2);\n \n   /* If ARG1 and ARG2 are the same (and not volatile), return zero.  */\n   if (operand_equal_p (arg1, arg2, 0))\n-    return omit_one_operand (TREE_TYPE (exp), integer_zero_node, len);\n+    return omit_one_operand (integer_type_node, integer_zero_node, len);\n \n   p1 = c_getstr (arg1);\n   p2 = c_getstr (arg2);\n \n   if (host_integerp (len, 1) && p1 && p2)\n     {\n-      tree temp;\n       const int i = strncmp (p1, p2, tree_low_cst (len, 1));\n-      if (i < 0)\n-\ttemp = integer_minus_one_node;\n-      else if (i > 0)\n-\ttemp = integer_one_node;\n+      if (i > 0)\n+\treturn integer_one_node;\n+      else if (i < 0)\n+\treturn integer_minus_one_node;\n       else\n-\ttemp = integer_zero_node;\n-      return fold_convert (TREE_TYPE (exp), temp);\n+\treturn integer_zero_node;\n+    }\n+\n+  /* If the second arg is \"\", and the length is greater than zero,\n+     return *(const unsigned char*)arg1.  */\n+  if (p2 && *p2 == '\\0'\n+      && TREE_CODE (len) == INTEGER_CST\n+      && tree_int_cst_sgn (len) == 1)\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      return fold_convert (integer_type_node,\n+\t\t\t   build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t\t   fold_convert (cst_uchar_ptr_node,\n+\t\t\t\t\t\t arg1)));\n+    }\n+\n+  /* If the first arg is \"\", and the length is greater than zero,\n+     return -*(const unsigned char*)arg2.  */\n+  if (p1 && *p1 == '\\0'\n+      && TREE_CODE (len) == INTEGER_CST\n+      && tree_int_cst_sgn (len) == 1)\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      tree temp = fold_convert (integer_type_node,\n+\t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n+\t\t\t\t\t\t      arg2)));\n+      return fold (build1 (NEGATE_EXPR, integer_type_node, temp));\n+    }\n+\n+  /* If len parameter is one, return an expression corresponding to\n+     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n+  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 1)\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      tree ind1 = fold_convert (integer_type_node,\n+\t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n+\t\t\t\t\t\t      arg1)));\n+      tree ind2 = fold_convert (integer_type_node,\n+\t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n+\t\t\t\t\t\t      arg2)));\n+      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n     }\n \n   return 0;\n@@ -8271,13 +8362,13 @@ fold_builtin_1 (tree exp, bool ignore)\n       return fold_builtin_strchr (exp, true);\n \n     case BUILT_IN_MEMCMP:\n-      return fold_builtin_memcmp (exp);\n+      return fold_builtin_memcmp (arglist);\n \n     case BUILT_IN_STRCMP:\n-      return fold_builtin_strcmp (exp);\n+      return fold_builtin_strcmp (arglist);\n \n     case BUILT_IN_STRNCMP:\n-      return fold_builtin_strncmp (exp);\n+      return fold_builtin_strncmp (arglist);\n \n     case BUILT_IN_SIGNBIT:\n     case BUILT_IN_SIGNBITF:\n@@ -8515,17 +8606,17 @@ simplify_builtin (tree exp, int ignore)\n       val = fold_builtin_strncpy (exp, NULL_TREE);\n       break;\n     case BUILT_IN_STRCMP:\n-      val = simplify_builtin_strcmp (arglist);\n+      val = fold_builtin_strcmp (arglist);\n       break;\n     case BUILT_IN_STRNCMP:\n-      val = simplify_builtin_strncmp (arglist);\n+      val = fold_builtin_strncmp (arglist);\n       break;\n     case BUILT_IN_STRPBRK:\n       val = simplify_builtin_strpbrk (arglist);\n       break;\n     case BUILT_IN_BCMP:\n     case BUILT_IN_MEMCMP:\n-      val = simplify_builtin_memcmp (arglist);\n+      val = fold_builtin_memcmp (arglist);\n       break;\n     case BUILT_IN_VA_START:\n       simplify_builtin_va_start (arglist);\n@@ -8802,220 +8893,6 @@ simplify_builtin_strpbrk (tree arglist)\n     }\n }\n \n-/* Simplify a call to the memcmp builtin.\n-\n-   Return 0 if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-static tree\n-simplify_builtin_memcmp (tree arglist)\n-{\n-  tree arg1, arg2, len;\n-  const char *p1, *p2;\n-\n-  if (!validate_arglist (arglist,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return 0;\n-\n-  arg1 = TREE_VALUE (arglist);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\n-  /* If the len parameter is zero, return zero.  */\n-  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n-    /* Evaluate and ignore arg1 and arg2 in case they have side-effects.  */\n-    return omit_two_operands (integer_type_node, integer_zero_node,\n-\t\t\t      arg1, arg2);\n-\n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  /* If all arguments are constant, and the value of len is not greater\n-     than the lengths of arg1 and arg2, evaluate at compile-time.  */\n-  if (host_integerp (len, 1) && p1 && p2\n-      && compare_tree_int (len, strlen (p1) + 1) <= 0\n-      && compare_tree_int (len, strlen (p2) + 1) <= 0)\n-    {\n-      const int r = memcmp (p1, p2, tree_low_cst (len, 1));\n-\n-      return (r < 0\n-\t      ? integer_minus_one_node\n-\t      : (r > 0 ? integer_one_node : integer_zero_node));\n-    }\n-\n-  /* If len parameter is one, return an expression corresponding to\n-     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n-  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 1)\n-    {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n-      tree ind1 =\n-      fold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t    build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n-      tree ind2 =\n-      fold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t    build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n-      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n-    }\n-\n-  return 0;\n-}\n-\n-/* Simplify a call to the strcmp builtin.\n-\n-   Return 0 if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-static tree\n-simplify_builtin_strcmp (tree arglist)\n-{\n-  tree arg1, arg2;\n-  const char *p1, *p2;\n-\n-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    return 0;\n-\n-  arg1 = TREE_VALUE (arglist);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-\n-  /* If both arguments are equal (and not volatile), return zero.  */\n-  if (operand_equal_p (arg1, arg2, 0))\n-    return integer_zero_node;\n-\n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  if (p1 && p2)\n-    {\n-      const int i = strcmp (p1, p2);\n-      return (i < 0\n-\t      ? integer_minus_one_node\n-\t      : (i > 0 ? integer_one_node : integer_zero_node));\n-    }\n-\n-  /* If either arg is \"\", return an expression corresponding to\n-     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n-  if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n-    {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n-      tree ind1 =\n-\tfold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n-      tree ind2 =\n-\tfold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n-      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n-    }\n-\n-  return 0;\n-}\n-\n-/* Simplify a call to the strncmp builtin.\n-\n-   Return 0 if no simplification was possible, otherwise return the\n-   simplified form of the call as a tree.\n-\n-   The simplified form may be a constant or other expression which\n-   computes the same value, but in a more efficient manner (including\n-   calls to other builtin functions).\n-\n-   The call may contain arguments which need to be evaluated, but\n-   which are not useful to determine the result of the call.  In\n-   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n-   COMPOUND_EXPR will be an argument which must be evaluated.\n-   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n-   COMPOUND_EXPR in the chain will contain the tree for the simplified\n-   form of the builtin function call.  */\n-\n-static tree\n-simplify_builtin_strncmp (tree arglist)\n-{\n-  tree arg1, arg2, arg3;\n-  const char *p1, *p2;\n-\n-  if (!validate_arglist (arglist,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return 0;\n-\n-  arg1 = TREE_VALUE (arglist);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-  arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\n-  /* If the len parameter is zero, return zero.  */\n-  if (integer_zerop (arg3))\n-    /* Evaluate and ignore arg1 and arg2 in case they have side-effects.  */\n-    return omit_two_operands (integer_type_node, integer_zero_node,\n-\t\t\t      arg1, arg2);\n-\n-  /* If arg1 and arg2 are equal (and not volatile), return zero.  */\n-  if (operand_equal_p (arg1, arg2, 0))\n-    /* Evaluate and ignore arg3 in case it has side-effects.  */\n-    return omit_one_operand (integer_type_node, integer_zero_node, arg3);\n-\n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  /* If all arguments are constant, evaluate at compile-time.  */\n-  if (host_integerp (arg3, 1) && p1 && p2)\n-    {\n-      const int r = strncmp (p1, p2, tree_low_cst (arg3, 1));\n-      return (r < 0\n-\t      ? integer_minus_one_node\n-\t      : (r > 0 ? integer_one_node : integer_zero_node));\n-    }\n-\n-  /* If len == 1 or (either string parameter is \"\" and (len >= 1)),\n-      return (*(const u_char*)arg1 - *(const u_char*)arg2).  */\n-  if (host_integerp (arg3, 1)\n-      && (tree_low_cst (arg3, 1) == 1\n-\t  || (tree_low_cst (arg3, 1) > 1\n-\t      && ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0')))))\n-    {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n-      tree ind1 =\n-\tfold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n-      tree ind2 =\n-\tfold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n-      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n-    }\n-\n-  return 0;\n-}\n-\n /* Simplify a call to the strcat builtin.\n \n    Return 0 if no simplification was possible, otherwise return the"}]}