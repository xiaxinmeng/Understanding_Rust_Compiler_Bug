{"sha": "7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIzN2Y5M2ViM2FhZWNiMjc4MDBjZTE2ODhlY2U0YzRjYmNiNzkwYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-11-04T14:07:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-04T14:07:09Z"}, "message": "cgraphclones.c (cgraph_node::create_version_clone): Do not duplicate summaries.\n\n\n\t* cgraphclones.c (cgraph_node::create_version_clone): Do not\n\tduplicate summaries.\n\t* ipa-fnsummary.c (ipa_fn_summary_alloc): Allocate size summary\n\tfirst.\n\t(ipa_fn_summary_t::duplicate): Use get instead of get_create to\n\taccess call summaries.\n\t(dump_ipa_call_summary): Be ready for missing edge summaries.\n\t(analyze_function_body): Use get instead of get_create to access\n\tedge summary.\n\t(estimate_calls_size_and_time): Do not access summaries of\n\tinlined edges; sanity check they are missing.\n\t(ipa_call_context::estimate_size_and_time): Use get instead\n\tof get_create to access node summary.\n\t(inline_update_callee_summaries): Do not update depth of\n\tinlined edge.\n\t(ipa_merge_fn_summary_after_inlining): Remove inline edge from\n\tgrowth caches.\n\t(ipa_merge_fn_summary_after_inlining): Use get instead\n\tof get_create.\n\t* ipa-fnsummary.h (ipa_remove_from_growth_caches): Declare.\n\t* ipa-inline-analyssi.c (edge_growth_cache): Turn to\n\tfast summary.\n\t(initialize_growth_caches): Update.\n\t(do_estimate_edge_time): Remove redundant copy of context.\n\t(ipa_remove_from_growth_caches): New function.\n\t* ipa-inline.c (flatten_function): Update overall summary\n\tonly when optimizing.\n\t(inline_to_all_callers): Update overall summary of function\n\tinlined to.\n\t* ipa-inline.h (edge_growth_cache): Turn to fast summary.\n\t* symbol-summary.h (call_summary_base): Set m_initialize_when_cloning\n\tto false.\n\nFrom-SVN: r277780", "tree": {"sha": "de11c563dd2b2c4fbed7b425e99ea70d6cb79842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de11c563dd2b2c4fbed7b425e99ea70d6cb79842"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/comments", "author": null, "committer": null, "parents": [{"sha": "6fb349540ce6464e9222d4c236a2c43a174d058b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fb349540ce6464e9222d4c236a2c43a174d058b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fb349540ce6464e9222d4c236a2c43a174d058b"}], "stats": {"total": 135, "additions": 92, "deletions": 43}, "files": [{"sha": "a9222a8deafeebf77326c3428882e29327e5e5d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "patch": "@@ -1,3 +1,38 @@\n+2019-11-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphclones.c (cgraph_node::create_version_clone): Do not\n+\tduplicate summaries.\n+\t* ipa-fnsummary.c (ipa_fn_summary_alloc): Allocate size summary\n+\tfirst.\n+\t(ipa_fn_summary_t::duplicate): Use get instead of get_create to\n+\taccess call summaries.\n+\t(dump_ipa_call_summary): Be ready for missing edge summaries.\n+\t(analyze_function_body): Use get instead of get_create to access\n+\tedge summary.\n+\t(estimate_calls_size_and_time): Do not access summaries of\n+\tinlined edges; sanity check they are missing.\n+\t(ipa_call_context::estimate_size_and_time): Use get instead\n+\tof get_create to access node summary.\n+\t(inline_update_callee_summaries): Do not update depth of\n+\tinlined edge.\n+\t(ipa_merge_fn_summary_after_inlining): Remove inline edge from\n+\tgrowth caches.\n+\t(ipa_merge_fn_summary_after_inlining): Use get instead\n+\tof get_create.\n+\t* ipa-fnsummary.h (ipa_remove_from_growth_caches): Declare.\n+\t* ipa-inline-analyssi.c (edge_growth_cache): Turn to\n+\tfast summary.\n+\t(initialize_growth_caches): Update.\n+\t(do_estimate_edge_time): Remove redundant copy of context.\n+\t(ipa_remove_from_growth_caches): New function.\n+\t* ipa-inline.c (flatten_function): Update overall summary\n+\tonly when optimizing.\n+\t(inline_to_all_callers): Update overall summary of function\n+\tinlined to.\n+\t* ipa-inline.h (edge_growth_cache): Turn to fast summary.\n+\t* symbol-summary.h (call_summary_base): Set m_initialize_when_cloning\n+\tto false.\n+\n 2019-11-04  Richard Biener  <rguenther@suse.de>\n \n \t* system.h: Include malloc.h if INCLUDE_MALLOC_H and HAVE_MALLINFO."}, {"sha": "b0dc3722293fbe0456be42e924d25088bafce64a", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "patch": "@@ -892,8 +892,6 @@ cgraph_node::create_version_clone (tree new_decl,\n        e->redirect_callee (new_version);\n      }\n \n-   symtab->call_cgraph_duplication_hooks (this, new_version);\n-\n    dump_callgraph_transformation (this, new_version, suffix);\n \n    return new_version;"}, {"sha": "64c4d95ccd4a4341e16d2e42eea3f4b361db0f29", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "patch": "@@ -553,9 +553,9 @@ static void\n ipa_fn_summary_alloc (void)\n {\n   gcc_checking_assert (!ipa_fn_summaries);\n-  ipa_fn_summaries = ipa_fn_summary_t::create_ggc (symtab);\n   ipa_size_summaries = new fast_function_summary <ipa_size_summary *, va_heap>\n \t\t\t\t\t\t\t (symtab);\n+  ipa_fn_summaries = ipa_fn_summary_t::create_ggc (symtab);\n   ipa_call_summaries = new ipa_call_summary_t (symtab);\n }\n \n@@ -688,7 +688,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       for (edge = dst->callees; edge; edge = next)\n \t{\n \t  predicate new_predicate;\n-\t  class ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+\t  class ipa_call_summary *es = ipa_call_summaries->get (edge);\n \t  next = edge->next_callee;\n \n \t  if (!edge->inline_failed)\n@@ -707,7 +707,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       for (edge = dst->indirect_calls; edge; edge = next)\n \t{\n \t  predicate new_predicate;\n-\t  class ipa_call_summary *es = ipa_call_summaries->get_create (edge);\n+\t  class ipa_call_summary *es = ipa_call_summaries->get (edge);\n \t  next = edge->next_callee;\n \n \t  gcc_checking_assert (edge->inline_failed);\n@@ -787,12 +787,15 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n       int i;\n \n       fprintf (f,\n-\t       \"%*s%s/%i %s\\n%*s  loop depth:%2i freq:%4.2f size:%2i time: %2i\",\n+\t       \"%*s%s/%i %s\\n%*s  freq:%4.2f\",\n \t       indent, \"\", callee->name (), callee->order,\n \t       !edge->inline_failed\n \t       ? \"inlined\" : cgraph_inline_failed_string (edge-> inline_failed),\n-\t       indent, \"\", es->loop_depth, edge->sreal_frequency ().to_double (),\n-\t       es->call_stmt_size, es->call_stmt_time);\n+\t       indent, \"\", edge->sreal_frequency ().to_double ());\n+\n+      if (es)\n+\tfprintf (f, \" loop depth:%2i size:%2i time: %2i\",\n+\t\t es->loop_depth, es->call_stmt_size, es->call_stmt_time);\n \n       ipa_fn_summary *s = ipa_fn_summaries->get (callee);\n       ipa_size_summary *ss = ipa_size_summaries->get (callee);\n@@ -801,14 +804,14 @@ dump_ipa_call_summary (FILE *f, int indent, struct cgraph_node *node,\n \t\t (int) (ss->size / ipa_fn_summary::size_scale),\n \t\t (int) s->estimated_stack_size);\n \n-      if (es->predicate)\n+      if (es && es->predicate)\n \t{\n \t  fprintf (f, \" predicate: \");\n \t  es->predicate->dump (f, info->conds);\n \t}\n       else\n \tfprintf (f, \"\\n\");\n-      if (es->param.exists ())\n+      if (es && es->param.exists ())\n \tfor (i = 0; i < (int) es->param.length (); i++)\n \t  {\n \t    int prob = es->param[i].change_prob;\n@@ -2480,7 +2483,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t  edge->speculative_call_info (direct, indirect, ref);\n \t\t  gcc_assert (direct == edge);\n \t          ipa_call_summary *es2\n-\t\t\t = ipa_call_summaries->get_create (indirect);\n+\t\t\t = ipa_call_summaries->get (indirect);\n \t\t  ipa_call_summaries->duplicate (edge, indirect,\n \t\t\t\t\t\t es, es2);\n \t\t}\n@@ -2924,38 +2927,39 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      class ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+      if (!e->inline_failed)\n+\t{\n+\t  gcc_checking_assert (!ipa_call_summaries->get (e));\n+\t  estimate_calls_size_and_time (e->callee, size, min_size, time,\n+\t\t\t\t\thints,\n+\t\t\t\t\tpossible_truths,\n+\t\t\t\t\tknown_vals, known_contexts,\n+\t\t\t\t\tknown_aggs);\n+\t  continue;\n+\t}\n+      class ipa_call_summary *es = ipa_call_summaries->get (e);\n \n       /* Do not care about zero sized builtins.  */\n-      if (e->inline_failed && !es->call_stmt_size)\n+      if (!es->call_stmt_size)\n \t{\n \t  gcc_checking_assert (!es->call_stmt_time);\n \t  continue;\n \t}\n       if (!es->predicate\n \t  || es->predicate->evaluate (possible_truths))\n \t{\n-\t  if (e->inline_failed)\n-\t    {\n-\t      /* Predicates of calls shall not use NOT_CHANGED codes,\n-\t         sowe do not need to compute probabilities.  */\n-\t      estimate_edge_size_and_time (e, size,\n-\t\t\t\t\t   es->predicate ? NULL : min_size,\n-\t\t\t\t\t   time, REG_BR_PROB_BASE,\n-\t\t\t\t\t   known_vals, known_contexts,\n-\t\t\t\t\t   known_aggs, hints);\n-\t    }\n-\t  else\n-\t    estimate_calls_size_and_time (e->callee, size, min_size, time,\n-\t\t\t\t\t  hints,\n-\t\t\t\t\t  possible_truths,\n-\t\t\t\t\t  known_vals, known_contexts,\n-\t\t\t\t\t  known_aggs);\n+\t  /* Predicates of calls shall not use NOT_CHANGED codes,\n+\t     sowe do not need to compute probabilities.  */\n+\t  estimate_edge_size_and_time (e, size,\n+\t\t\t\t       es->predicate ? NULL : min_size,\n+\t\t\t\t       time, REG_BR_PROB_BASE,\n+\t\t\t\t       known_vals, known_contexts,\n+\t\t\t\t       known_aggs, hints);\n \t}\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n-      class ipa_call_summary *es = ipa_call_summaries->get_create (e);\n+      class ipa_call_summary *es = ipa_call_summaries->get (e);\n       if (!es->predicate\n \t  || es->predicate->evaluate (possible_truths))\n \testimate_edge_size_and_time (e, size,\n@@ -3204,7 +3208,7 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n \t\t\t\t\t  sreal *ret_nonspecialized_time,\n \t\t\t\t\t  ipa_hints *ret_hints)\n {\n-  class ipa_fn_summary *info = ipa_fn_summaries->get_create (m_node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get (m_node);\n   size_time_entry *e;\n   int size = 0;\n   sreal time = 0;\n@@ -3382,7 +3386,8 @@ inline_update_callee_summaries (struct cgraph_node *node, int depth)\n     {\n       if (!e->inline_failed)\n \tinline_update_callee_summaries (e->callee, depth);\n-      ipa_call_summaries->get (e)->loop_depth += depth;\n+      else\n+\tipa_call_summaries->get (e)->loop_depth += depth;\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     ipa_call_summaries->get (e)->loop_depth += depth;\n@@ -3649,6 +3654,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   /* Free summaries that are not maintained for inline clones/edges.  */\n   ipa_call_summaries->remove (edge);\n   ipa_fn_summaries->remove (edge->callee);\n+  ipa_remove_from_growth_caches (edge);\n }\n \n /* For performance reasons ipa_merge_fn_summary_after_inlining is not updating\n@@ -3657,8 +3663,8 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n void\n ipa_update_overall_fn_summary (struct cgraph_node *node)\n {\n-  class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n-  class ipa_size_summary *size_info = ipa_size_summaries->get_create (node);\n+  class ipa_fn_summary *info = ipa_fn_summaries->get (node);\n+  class ipa_size_summary *size_info = ipa_size_summaries->get (node);\n   size_time_entry *e;\n   int i;\n "}, {"sha": "8f9eaf560acf0069e9eb93352eb1c458cb0e1c05", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "patch": "@@ -364,5 +364,6 @@ void evaluate_properties_for_edge (struct cgraph_edge *e,\n \n void ipa_fnsummary_c_finalize (void);\n HOST_WIDE_INT ipa_get_stack_frame_offset (struct cgraph_node *node);\n+void ipa_remove_from_growth_caches (struct cgraph_edge *edge);\n \n #endif /* GCC_IPA_FNSUMMARY_H */"}, {"sha": "ea1fae484ff1e62a652816310129289d1b1588f9", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n \n /* Cached node/edge growths.  */\n-call_summary<edge_growth_cache_entry *> *edge_growth_cache = NULL;\n+fast_call_summary<edge_growth_cache_entry *, va_heap> *edge_growth_cache = NULL;\n \n /* The context cache remembers estimated time/size and hints for given\n    ipa_call_context of a call.  */\n@@ -125,7 +125,7 @@ void\n initialize_growth_caches ()\n {\n   edge_growth_cache\n-    = new call_summary<edge_growth_cache_entry *> (symtab, false);\n+    = new fast_call_summary<edge_growth_cache_entry *, va_heap> (symtab);\n   node_context_cache\n     = new fast_function_summary<node_context_summary *, va_heap> (symtab);\n }\n@@ -219,7 +219,6 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \t  else\n \t    node_context_cache_clear++;\n \t  e->entry.ctx.release (true);\n-\t  e->entry.ctx = ctx;\n \t  ctx.estimate_size_and_time (&size, &min_size,\n \t\t\t\t      &time, &nonspec_time, &hints);\n \t  e->entry.size = size;\n@@ -275,6 +274,16 @@ reset_node_cache (struct cgraph_node *node)\n     node_context_cache->remove (node);\n }\n \n+/* Remove EDGE from caches once it was inlined.  */\n+void\n+ipa_remove_from_growth_caches (struct cgraph_edge *edge)\n+{\n+  if (node_context_cache)\n+    node_context_cache->remove (edge->callee);\n+  if (edge_growth_cache)\n+    edge_growth_cache->remove (edge);\n+}\n+\n /* Return estimated callee growth after inlining EDGE.\n    Only to be called via estimate_edge_size.  */\n "}, {"sha": "b2c90cc2dd99e001ce31868cefe6fccd730cfe3e", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "patch": "@@ -2290,9 +2290,9 @@ flatten_function (struct cgraph_node *node, bool early, bool update)\n     }\n \n   node->aux = NULL;\n-  if (update)\n-    ipa_update_overall_fn_summary (node->inlined_to\n-\t\t\t\t   ? node->inlined_to : node);\n+  cgraph_node *where = node->inlined_to ? node->inlined_to : node;\n+  if (update && opt_for_fn (where->decl, optimize))\n+    ipa_update_overall_fn_summary (where);\n }\n \n /* Inline NODE to all callers.  Worker for cgraph_for_node_and_aliases.\n@@ -2367,7 +2367,7 @@ inline_to_all_callers (struct cgraph_node *node, void *data)\n      we have a lot of calls to the same function.  */\n   for (hash_set<cgraph_node *>::iterator i = callers.begin ();\n        i != callers.end (); ++i)\n-    ipa_update_overall_fn_summary (*i);\n+    ipa_update_overall_fn_summary ((*i)->inlined_to ? (*i)->inlined_to : *i);\n   return res;\n }\n "}, {"sha": "33205a0e6dba3006dc78e83e99badcd46289559e", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "patch": "@@ -39,7 +39,7 @@ class edge_growth_cache_entry\n       hints (hints) {}\n };\n \n-extern call_summary<edge_growth_cache_entry *> *edge_growth_cache;\n+extern fast_call_summary<edge_growth_cache_entry *, va_heap> *edge_growth_cache;\n \n /* In ipa-inline-analysis.c  */\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);"}, {"sha": "f677f16e0cea1626b23c336d604ef43d9caaf4eb", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7237f93eb3aaecb27800ce1688ece4c4cbcb790b/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=7237f93eb3aaecb27800ce1688ece4c4cbcb790b", "patch": "@@ -532,7 +532,7 @@ class call_summary_base\n public:\n   /* Default construction takes SYMTAB as an argument.  */\n   call_summary_base (symbol_table *symtab): m_symtab (symtab),\n-  m_initialize_when_cloning (true)\n+  m_initialize_when_cloning (false)\n   {}\n \n   /* Basic implementation of removal operation.  */"}]}