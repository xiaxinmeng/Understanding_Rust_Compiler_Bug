{"sha": "c81b60b8c6ff3d4db2e395a628e114df812cfc48", "node_id": "C_kwDOANBUbNoAKGM4MWI2MGI4YzZmZjNkNGRiMmUzOTVhNjI4ZTExNGRmODEyY2ZjNDg", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-09-09T21:13:04Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-09-09T21:13:04Z"}, "message": "analyzer: implement trust boundaries via a plugin for Linux kernel\n\nThis is a less ambitious version of:\n  [PATCH 0/6] RFC: adding support to GCC for detecting trust boundaries\n    https://gcc.gnu.org/pipermail/gcc-patches/2021-November/584372.html\n\nEarlier versions of this patch attempted:\n(a) various ways of identifying \"untrusted\" memory regions\n(b) providing a way to support the Linux kernel's \"__user\" annotation,\n    either via type attributes, or via custom address spaces\n(c) enough attributes to identify \"copy_from_user\" and \"copy_to_user\",\n(d) wiring all of the above together to detect infoleaks and taint\n\nThis patch adds a new -Wanalyzer-exposure-through-uninit-copy, emitted\nby -fanalyzer if it detects copying of uninitialized data through\na pointer to an untrusted region, but requires a plugin to tell it when\na copy crosses a trust boundary.\n\nThis patch adds a proof-of-concept gcc plugin for the analyzer for use\nwith the Linux kernel that special-cases calls to \"copy_from_user\" and\ncalls to \"copy_to_user\": calls to copy_to_user are checked for\n-Wanalyzer-exposure-through-uninit-copy, and data copied via\ncopy_from_user is marked as tainted when -fanalyzer-checker=taint is\nactive.\n\nThis is very much just a proof-of-concept.  A big limitation is that the\ncopy_{from,to}_user special-casing only happens if these functions have\nno body in the TU being analyzed, which isn't the case for a normal\nkernel build.  I'd much prefer to provide a more general mechanism for\nhandling such behavior without resorting to plugins (e.g. via attributes\nor custom address spaces), but in the interest of not \"letting perfect\nbe the enemy of the good\" this patch at least allows parts of this\n\"trust boundaries\" code to be merged for experimentation with the idea.\n\nThe -Wanalyzer-exposure-through-uninit-copy diagnostic uses notes to\nexpress what fields and padding within a struct have not been initialized.\nFor example:\n\ninfoleak-CVE-2011-1078-2.c: In function 'test_1':\ninfoleak-CVE-2011-1078-2.c:32:9: warning: potential exposure of sensitive\n  information by copying uninitialized data from stack across trust\n  boundary [CWE-200] [-Wanalyzer-exposure-through-uninit-copy]\n   32 |         copy_to_user(optval, &cinfo, sizeof(cinfo));\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  'test_1': events 1-3\n    |\n    |   25 |         struct sco_conninfo cinfo;\n    |      |                             ^~~~~\n    |      |                             |\n    |      |                             (1) region created on stack here\n    |      |                             (2) capacity: 6 bytes\n    |......\n    |   32 |         copy_to_user(optval, &cinfo, sizeof(cinfo));\n    |      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |         |\n    |      |         (3) uninitialized data copied from stack here\n    |\ninfoleak-CVE-2011-1078-2.c:32:9: note: 1 byte is uninitialized\n   32 |         copy_to_user(optval, &cinfo, sizeof(cinfo));\n      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninfoleak-CVE-2011-1078-2.c:18:15: note: padding after field 'dev_class'\n  is uninitialized (1 byte)\n   18 |         __u8  dev_class[3];\n      |               ^~~~~~~~~\ninfoleak-CVE-2011-1078-2.c:25:29: note: suggest forcing\n  zero-initialization by providing a '{0}' initializer\n   25 |         struct sco_conninfo cinfo;\n      |                             ^~~~~\n      |                                   = {0}\n\nFor taint-detection, the patch includes a series of reproducers for\ndetecting CVE-2011-0521.  Unfortunately the analyzer doesn't yet detect\nthe issue until the code has been significantly simplified from its\noriginal form: currently only in -5.c and -6.c in the series of test\n(see notes in the individual cases), such as:\n\ntaint-CVE-2011-0521-6.c:33:48: warning: use of attacker-controlled value\n  '*info.num' in array lookup without bounds checking [CWE-129]\n  [-Wanalyzer-tainted-array-index]\n   33 |             av7110->ci_slot[info->num].num = info->num;\n      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~\n  'test_1': events 1-3\n    |\n    |   19 |    if (copy_from_user(&sbuf, (void __user *)arg, sizeof(sbuf)) != 0)\n    |      |        ^\n    |      |        |\n    |      |        (1) following 'false' branch...\n    |......\n    |   23 |             struct dvb_device *dvbdev = file->private_data;\n    |      |                                ~~~~~~\n    |      |                                |\n    |      |                                (2) ...to here\n    |......\n    |   33 |             av7110->ci_slot[info->num].num = info->num;\n    |      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    |      |                                            |\n    |      |                                            (3) use of attacker-controlled value '*info.num' in array lookup without bounds checking\n    |\n\nThe patch also includes various infoleak and taint cases from my\nantipatterns.ko kernel module:\n  https://github.com/davidmalcolm/antipatterns.ko\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.opt (Wanalyzer-exposure-through-uninit-copy): New.\n\t* checker-path.cc (region_creation_event::region_creation_event):\n\tAdd \"capacity\" and \"kind\" params.\n\t(region_creation_event::get_desc): Generalize to different kinds\n\tof event.\n\t(checker_path::add_region_creation_event): Convert to...\n\t(checker_path::add_region_creation_events): ...this.\n\t* checker-path.h (enum rce_kind): New.\n\t(region_creation_event::region_creation_event): Add \"capacity\" and\n\t\"kind\" params.\n\t(region_creation_event::m_capacity): New field.\n\t(region_creation_event::m_rce_kind): New field.\n\t(checker_path::add_region_creation_event): Convert to...\n\t(checker_path::add_region_creation_events): ...this.\n\t* diagnostic-manager.cc (diagnostic_manager::build_emission_path):\n\tUpdate for multiple region creation events.\n\t(diagnostic_manager::add_event_on_final_node): Likewise.\n\t(diagnostic_manager::add_events_for_eedge): Likewise.\n\t* region-model-impl-calls.cc (call_details::get_logger): New.\n\t* region-model.cc: Define INCLUDE_MEMORY before including\n\t\"system.h\".  Include \"gcc-rich-location.h\".\n\t(class record_layout): New.\n\t(class exposure_through_uninit_copy): New.\n\t(contains_uninit_p): New.\n\t(region_model::maybe_complain_about_infoleak): New.\n\t* region-model.h (call_details::get_logger): New decl.\n\t(region_model::maybe_complain_about_infoleak): New decl.\n\t(region_model::mark_as_tainted): New decl.\n\t* sm-taint.cc (region_model::mark_as_tainted): New.\n\ngcc/ChangeLog:\n\t* doc/invoke.texi (Static Analyzer Options): Add\n\t-Wanalyzer-exposure-through-uninit-copy.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/analyzer_kernel_plugin.c: New test.\n\t* gcc.dg/plugin/copy_from_user-1.c: New test.\n\t* gcc.dg/plugin/infoleak-1.c: New test.\n\t* gcc.dg/plugin/infoleak-2.c: New test.\n\t* gcc.dg/plugin/infoleak-3.c: New test.\n\t* gcc.dg/plugin/infoleak-CVE-2011-1078-1.c: New test.\n\t* gcc.dg/plugin/infoleak-CVE-2011-1078-2.c: New test.\n\t* gcc.dg/plugin/infoleak-CVE-2014-1446-1.c: New test.\n\t* gcc.dg/plugin/infoleak-CVE-2017-18549-1.c: New test.\n\t* gcc.dg/plugin/infoleak-CVE-2017-18550-1.c: New test.\n\t* gcc.dg/plugin/infoleak-antipatterns-1.c: New test.\n\t* gcc.dg/plugin/infoleak-fixit-1.c: New test.\n\t* gcc.dg/plugin/infoleak-net-ethtool-ioctl.c: New test.\n\t* gcc.dg/plugin/infoleak-vfio_iommu_type1.c: New test.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add\n\tanalyzer_kernel_plugin.c and the new test cases.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-1-fixed.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-1.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-2-fixed.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-2.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-3-fixed.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-3.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-4.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-5-fixed.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-5.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521-6.c: New test.\n\t* gcc.dg/plugin/taint-CVE-2011-0521.h: New test.\n\t* gcc.dg/plugin/taint-antipatterns-1.c: New test.\n\t* gcc.dg/plugin/test-uaccess.h: New header for tests.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "e1e3715a12fdaf50af93746d0df9ec4c744f8321", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1e3715a12fdaf50af93746d0df9ec4c744f8321"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c81b60b8c6ff3d4db2e395a628e114df812cfc48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81b60b8c6ff3d4db2e395a628e114df812cfc48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c81b60b8c6ff3d4db2e395a628e114df812cfc48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81b60b8c6ff3d4db2e395a628e114df812cfc48/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07e30160beaa207f56f170900fac0d799c6af410", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07e30160beaa207f56f170900fac0d799c6af410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07e30160beaa207f56f170900fac0d799c6af410"}], "stats": {"total": 3367, "additions": 3336, "deletions": 31}, "files": [{"sha": "dbab3b82deb34a5aab1f155b9bda60c255f2d7b3", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -70,6 +70,10 @@ Wanalyzer-exposure-through-output-file\n Common Var(warn_analyzer_exposure_through_output_file) Init(1) Warning\n Warn about code paths in which sensitive data is written to a file.\n \n+Wanalyzer-exposure-through-uninit-copy\n+Common Var(warn_analyzer_exposure_through_uninit_copy) Init(1) Warning\n+Warn about code paths in which sensitive data is copied across a security boundary.\n+\n Wanalyzer-fd-access-mode-mismatch\n Common Var(warn_analyzer_fd_mode_mismatch) Init(1) Warning\n Warn about code paths in which read on a write-only file descriptor is attempted, or vice versa."}, {"sha": "22bae2f34b1c227e1c820329b5f308212f17320c", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -288,16 +288,25 @@ statement_event::get_desc (bool) const\n /* class region_creation_event : public checker_event.  */\n \n region_creation_event::region_creation_event (const region *reg,\n+\t\t\t\t\t      tree capacity,\n+\t\t\t\t\t      enum rce_kind kind,\n \t\t\t\t\t      location_t loc,\n \t\t\t\t\t      tree fndecl,\n \t\t\t\t\t      int depth)\n : checker_event (EK_REGION_CREATION, loc, fndecl, depth),\n-  m_reg (reg)\n+  m_reg (reg),\n+  m_capacity (capacity),\n+  m_rce_kind (kind)\n {\n+  if (m_rce_kind == RCE_CAPACITY)\n+    gcc_assert (capacity);\n }\n \n /* Implementation of diagnostic_event::get_desc vfunc for\n-   region_creation_event.  */\n+   region_creation_event.\n+   There are effectively 3 kinds of region_region_event, to\n+   avoid combinatorial explosion by trying to convy the\n+   information in a single message.  */\n \n label_text\n region_creation_event::get_desc (bool can_colorize) const\n@@ -311,14 +320,50 @@ region_creation_event::get_desc (bool can_colorize) const\n \treturn custom_desc;\n     }\n \n-  switch (m_reg->get_memory_space ())\n+  switch (m_rce_kind)\n     {\n     default:\n-      return label_text::borrow (\"region created here\");\n-    case MEMSPACE_STACK:\n-      return label_text::borrow (\"region created on stack here\");\n-    case MEMSPACE_HEAP:\n-      return label_text::borrow (\"region created on heap here\");\n+      gcc_unreachable ();\n+\n+    case RCE_MEM_SPACE:\n+      switch (m_reg->get_memory_space ())\n+\t{\n+\tdefault:\n+\t  return label_text::borrow (\"region created here\");\n+\tcase MEMSPACE_STACK:\n+\t  return label_text::borrow (\"region created on stack here\");\n+\tcase MEMSPACE_HEAP:\n+\t  return label_text::borrow (\"region created on heap here\");\n+\t}\n+      break;\n+\n+    case RCE_CAPACITY:\n+      gcc_assert (m_capacity);\n+      if (TREE_CODE (m_capacity) == INTEGER_CST)\n+\t{\n+\t  unsigned HOST_WIDE_INT hwi = tree_to_uhwi (m_capacity);\n+\t  if (hwi == 1)\n+\t    return make_label_text (can_colorize,\n+\t\t\t\t    \"capacity: %wu byte\", hwi);\n+\t  else\n+\t    return make_label_text (can_colorize,\n+\t\t\t\t    \"capacity: %wu bytes\", hwi);\n+\t}\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"capacity: %qE bytes\", m_capacity);\n+\n+    case RCE_DEBUG:\n+      {\n+\tpretty_printer pp;\n+\tpp_format_decoder (&pp) = default_tree_printer;\n+\tpp_string (&pp, \"region creation: \");\n+\tm_reg->dump_to_pp (&pp, true);\n+\tif (m_capacity)\n+\t  pp_printf (&pp, \" capacity: %qE\", m_capacity);\n+\treturn label_text::take (xstrdup (pp_formatted_text (&pp)));\n+      }\n+      break;\n     }\n }\n \n@@ -1207,15 +1252,33 @@ checker_path::debug () const\n     }\n }\n \n-/* Add region_creation_event instance to this path for REG,\n-   describing whether REG is on the stack or heap.  */\n+/* Add region_creation_event instances to this path for REG,\n+   describing whether REG is on the stack or heap and what\n+   its capacity is (if known).\n+   If DEBUG is true, also create an RCE_DEBUG event.  */\n \n void\n-checker_path::add_region_creation_event (const region *reg,\n-\t\t\t\t\t location_t loc,\n-\t\t\t\t\t tree fndecl, int depth)\n+checker_path::add_region_creation_events (const region *reg,\n+\t\t\t\t\t  const region_model *model,\n+\t\t\t\t\t  location_t loc,\n+\t\t\t\t\t  tree fndecl, int depth,\n+\t\t\t\t\t  bool debug)\n {\n-  add_event (new region_creation_event (reg, loc, fndecl, depth));\n+  tree capacity = NULL_TREE;\n+  if (model)\n+    if (const svalue *capacity_sval = model->get_capacity (reg))\n+      capacity = model->get_representative_tree (capacity_sval);\n+\n+  add_event (new region_creation_event (reg, capacity, RCE_MEM_SPACE,\n+\t\t\t\t\tloc, fndecl, depth));\n+\n+  if (capacity)\n+    add_event (new region_creation_event (reg, capacity, RCE_CAPACITY,\n+\t\t\t\t\t  loc, fndecl, depth));\n+\n+  if (debug)\n+    add_event (new region_creation_event (reg, capacity, RCE_DEBUG,\n+\t\t\t\t\t  loc, fndecl, depth));\n }\n \n /* Add a warning_event to the end of this path.  */"}, {"sha": "5d009340189543d466ad071d71b49cb75a7b1557", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -210,19 +210,43 @@ class statement_event : public checker_event\n   const program_state m_dst_state;\n };\n \n+/* There are too many combinations to express region creation in one message,\n+   so we emit multiple region_creation_event instances when each pertinent\n+   region is created.\n+\n+   This enum distinguishes between the different messages.  */\n+\n+enum rce_kind\n+{\n+  /* Generate a message based on the memory space of the region\n+     e.g. \"region created on stack here\".  */\n+  RCE_MEM_SPACE,\n+\n+  /* Generate a message based on the capacity of the region\n+     e.g. \"capacity: 100 bytes\".  */\n+  RCE_CAPACITY,\n+\n+  /* Generate a debug message.  */\n+  RCE_DEBUG\n+};\n+\n /* A concrete event subclass describing the creation of a region that\n-   is significant for a diagnostic  e.g. \"region created on stack here\".  */\n+   is significant for a diagnostic.  */\n \n class region_creation_event : public checker_event\n {\n public:\n   region_creation_event (const region *reg,\n+\t\t\t tree capacity,\n+\t\t\t enum rce_kind kind,\n \t\t\t location_t loc, tree fndecl, int depth);\n \n   label_text get_desc (bool can_colorize) const final override;\n \n private:\n   const region *m_reg;\n+  tree m_capacity;\n+  enum rce_kind m_rce_kind;\n };\n \n /* An event subclass describing the entry to a function.  */\n@@ -632,9 +656,11 @@ class checker_path : public diagnostic_path\n     m_events[idx] = new_event;\n   }\n \n-  void add_region_creation_event (const region *reg,\n-\t\t\t\t  location_t loc,\n-\t\t\t\t  tree fndecl, int depth);\n+  void add_region_creation_events (const region *reg,\n+\t\t\t\t   const region_model *model,\n+\t\t\t\t   location_t loc,\n+\t\t\t\t   tree fndecl, int depth,\n+\t\t\t\t   bool debug);\n \n   void add_final_event (const state_machine *sm,\n \t\t\tconst exploded_node *enode, const gimple *stmt,"}, {"sha": "2d185a1f3e6bb8a8fa98de89061bb2f411561b16", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -1460,11 +1460,12 @@ diagnostic_manager::build_emission_path (const path_builder &pb,\n \t      if (DECL_P (decl)\n \t\t  && DECL_SOURCE_LOCATION (decl) != UNKNOWN_LOCATION)\n \t\t{\n-\t\t  emission_path->add_region_creation_event\n-\t\t    (reg,\n+\t\t  emission_path->add_region_creation_events\n+\t\t    (reg, NULL,\n \t\t     DECL_SOURCE_LOCATION (decl),\n \t\t     NULL_TREE,\n-\t\t     0);\n+\t\t     0,\n+\t\t     m_verbosity > 3);\n \t\t}\n \t  }\n \t}\n@@ -1524,11 +1525,13 @@ diagnostic_manager::add_event_on_final_node (const exploded_node *final_enode,\n \t\t  break;\n \t\tcase RK_HEAP_ALLOCATED:\n \t\tcase RK_ALLOCA:\n-\t\t  emission_path->add_region_creation_event\n+\t\t  emission_path->add_region_creation_events\n \t\t    (reg,\n-\t\t    src_point.get_location (),\n-\t\t    src_point.get_fndecl (),\n-\t\t    src_stack_depth);\n+\t\t     dst_model,\n+\t\t     src_point.get_location (),\n+\t\t     src_point.get_fndecl (),\n+\t\t     src_stack_depth,\n+\t\t     false);\n \t\t  emitted = true;\n \t\t  break;\n \t\t}\n@@ -1939,11 +1942,12 @@ diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n \t\t\tif (DECL_P (decl)\n \t\t\t    && DECL_SOURCE_LOCATION (decl) != UNKNOWN_LOCATION)\n \t\t\t  {\n-\t\t\t    emission_path->add_region_creation_event\n-\t\t\t      (reg,\n+\t\t\t    emission_path->add_region_creation_events\n+\t\t\t      (reg, dst_state.m_region_model,\n \t\t\t       DECL_SOURCE_LOCATION (decl),\n \t\t\t       dst_point.get_fndecl (),\n-\t\t\t       dst_stack_depth);\n+\t\t\t       dst_stack_depth,\n+\t\t\t       m_verbosity > 3);\n \t\t\t  }\n \t\t    }\n \t    }\n@@ -2033,11 +2037,12 @@ diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n \t\t    break;\n \t\t  case RK_HEAP_ALLOCATED:\n \t\t  case RK_ALLOCA:\n-\t\t    emission_path->add_region_creation_event\n-\t\t      (reg,\n+\t\t    emission_path->add_region_creation_events\n+\t\t      (reg, dst_model,\n \t\t       src_point.get_location (),\n \t\t       src_point.get_fndecl (),\n-\t\t       src_stack_depth);\n+\t\t       src_stack_depth,\n+\t\t       m_verbosity > 3);\n \t\t    break;\n \t\t  }\n \t    }"}, {"sha": "71fb2770143224c72387824b06b48e16d3c07f98", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -91,6 +91,17 @@ call_details::get_manager () const\n   return m_model->get_manager ();\n }\n \n+/* Get any logger associated with this object.  */\n+\n+logger *\n+call_details::get_logger () const\n+{\n+  if (m_ctxt)\n+    return m_ctxt->get_logger ();\n+  else\n+    return NULL;\n+}\n+\n /* Get any uncertainty_t associated with the region_model_context.  */\n \n uncertainty_t *"}, {"sha": "6eeb684844dad76edd43c664b8d7c84b60eb2b85", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -19,6 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n+#define INCLUDE_MEMORY\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n@@ -74,6 +75,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa-iterators.h\"\n #include \"calls.h\"\n #include \"is-a.h\"\n+#include \"gcc-rich-location.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -5784,6 +5786,572 @@ region_model::unset_dynamic_extents (const region *reg)\n   m_dynamic_extents.remove (reg);\n }\n \n+/* Information of the layout of a RECORD_TYPE, capturing it as a vector\n+   of items, where each item is either a field or padding.  */\n+\n+class record_layout\n+{\n+public:\n+  /* An item within a record; either a field, or padding after a field.  */\n+  struct item\n+  {\n+  public:\n+    item (const bit_range &br,\n+\t  tree field,\n+\t  bool is_padding)\n+    : m_bit_range (br),\n+      m_field (field),\n+      m_is_padding (is_padding)\n+    {\n+    }\n+\n+    bit_offset_t get_start_bit_offset () const\n+    {\n+      return m_bit_range.get_start_bit_offset ();\n+    }\n+    bit_offset_t get_next_bit_offset () const\n+    {\n+      return m_bit_range.get_next_bit_offset ();\n+    }\n+\n+    bool contains_p (bit_offset_t offset) const\n+    {\n+      return m_bit_range.contains_p (offset);\n+    }\n+\n+    void dump_to_pp (pretty_printer *pp) const\n+    {\n+      if (m_is_padding)\n+\tpp_printf (pp, \"padding after %qD\", m_field);\n+      else\n+\tpp_printf (pp, \"%qD\", m_field);\n+      pp_string (pp, \", \");\n+      m_bit_range.dump_to_pp (pp);\n+    }\n+\n+    bit_range m_bit_range;\n+    tree m_field;\n+    bool m_is_padding;\n+  };\n+\n+  record_layout (tree record_type)\n+  : m_record_type (record_type)\n+  {\n+    gcc_assert (TREE_CODE (record_type) == RECORD_TYPE);\n+\n+    for (tree iter = TYPE_FIELDS (record_type); iter != NULL_TREE;\n+\t iter = DECL_CHAIN (iter))\n+      {\n+\tif (TREE_CODE (iter) == FIELD_DECL)\n+\t  {\n+\t    int iter_field_offset = int_bit_position (iter);\n+\t    bit_size_t size_in_bits;\n+\t    if (!int_size_in_bits (TREE_TYPE (iter), &size_in_bits))\n+\t      size_in_bits = 0;\n+\n+\t    maybe_pad_to (iter_field_offset);\n+\n+\t    /* Add field.  */\n+\t    m_items.safe_push (item (bit_range (iter_field_offset,\n+\t\t\t\t\t\tsize_in_bits),\n+\t\t\t\t     iter, false));\n+\t  }\n+      }\n+\n+    /* Add any trailing padding.  */\n+    bit_size_t size_in_bits;\n+    if (int_size_in_bits (record_type, &size_in_bits))\n+      maybe_pad_to (size_in_bits);\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp) const\n+  {\n+    unsigned i;\n+    item *it;\n+    FOR_EACH_VEC_ELT (m_items, i, it)\n+      {\n+\tit->dump_to_pp (pp);\n+\tpp_newline (pp);\n+      }\n+  }\n+\n+  DEBUG_FUNCTION void dump () const\n+  {\n+    pretty_printer pp;\n+    pp_format_decoder (&pp) = default_tree_printer;\n+    pp.buffer->stream = stderr;\n+    dump_to_pp (&pp);\n+    pp_flush (&pp);\n+  }\n+\n+  const record_layout::item *get_item_at (bit_offset_t offset) const\n+  {\n+    unsigned i;\n+    item *it;\n+    FOR_EACH_VEC_ELT (m_items, i, it)\n+      if (it->contains_p (offset))\n+\treturn it;\n+    return NULL;\n+  }\n+\n+private:\n+  /* Subroutine of ctor.  Add padding item to NEXT_OFFSET if necessary.  */\n+\n+  void maybe_pad_to (bit_offset_t next_offset)\n+  {\n+    if (m_items.length () > 0)\n+      {\n+\tconst item &last_item = m_items[m_items.length () - 1];\n+\tbit_offset_t offset_after_last_item\n+\t  = last_item.get_next_bit_offset ();\n+\tif (next_offset > offset_after_last_item)\n+\t  {\n+\t    bit_size_t padding_size\n+\t      = next_offset - offset_after_last_item;\n+\t    m_items.safe_push (item (bit_range (offset_after_last_item,\n+\t\t\t\t\t\tpadding_size),\n+\t\t\t\t     last_item.m_field, true));\n+\t  }\n+      }\n+  }\n+\n+  tree m_record_type;\n+  auto_vec<item> m_items;\n+};\n+\n+/* A subclass of pending_diagnostic for complaining about uninitialized data\n+   being copied across a trust boundary to an untrusted output\n+   (e.g. copy_to_user infoleaks in the Linux kernel).  */\n+\n+class exposure_through_uninit_copy\n+  : public pending_diagnostic_subclass<exposure_through_uninit_copy>\n+{\n+public:\n+  exposure_through_uninit_copy (const region *src_region,\n+\t\t\t\tconst region *dest_region,\n+\t\t\t\tconst svalue *copied_sval,\n+\t\t\t\tregion_model_manager *mgr)\n+  : m_src_region (src_region),\n+    m_dest_region (dest_region),\n+    m_copied_sval (copied_sval),\n+    m_mgr (mgr)\n+  {\n+    gcc_assert (m_copied_sval->get_kind () == SK_POISONED\n+\t\t|| m_copied_sval->get_kind () == SK_COMPOUND);\n+  }\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"exposure_through_uninit_copy\";\n+  }\n+\n+  bool operator== (const exposure_through_uninit_copy &other) const\n+  {\n+    return (m_src_region == other.m_src_region\n+\t    && m_dest_region == other.m_dest_region\n+\t    && m_copied_sval == other.m_copied_sval);\n+  }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_exposure_through_uninit_copy;\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    /* CWE-200: Exposure of Sensitive Information to an Unauthorized Actor.  */\n+    m.add_cwe (200);\n+    enum memory_space mem_space = get_src_memory_space ();\n+    bool warned;\n+    switch (mem_space)\n+      {\n+      default:\n+\twarned = warning_meta\n+\t  (rich_loc, m, get_controlling_option (),\n+\t   \"potential exposure of sensitive information\"\n+\t   \" by copying uninitialized data across trust boundary\");\n+\tbreak;\n+      case MEMSPACE_STACK:\n+\twarned = warning_meta\n+\t  (rich_loc, m, get_controlling_option (),\n+\t   \"potential exposure of sensitive information\"\n+\t   \" by copying uninitialized data from stack across trust boundary\");\n+\tbreak;\n+      case MEMSPACE_HEAP:\n+\twarned = warning_meta\n+\t  (rich_loc, m, get_controlling_option (),\n+\t   \"potential exposure of sensitive information\"\n+\t   \" by copying uninitialized data from heap across trust boundary\");\n+\tbreak;\n+      }\n+    if (warned)\n+      {\n+\tlocation_t loc = rich_loc->get_loc ();\n+\tinform_number_of_uninit_bits (loc);\n+\tcomplain_about_uninit_ranges (loc);\n+\n+\tif (mem_space == MEMSPACE_STACK)\n+\t  maybe_emit_fixit_hint ();\n+      }\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &) final override\n+  {\n+    enum memory_space mem_space = get_src_memory_space ();\n+    switch (mem_space)\n+      {\n+      default:\n+\treturn label_text::borrow (\"uninitialized data copied here\");\n+\n+      case MEMSPACE_STACK:\n+\treturn label_text::borrow (\"uninitialized data copied from stack here\");\n+\n+      case MEMSPACE_HEAP:\n+\treturn label_text::borrow (\"uninitialized data copied from heap here\");\n+      }\n+  }\n+\n+  void mark_interesting_stuff (interesting_t *interest) final override\n+  {\n+    if (m_src_region)\n+      interest->add_region_creation (m_src_region);\n+  }\n+\n+private:\n+  enum memory_space get_src_memory_space () const\n+  {\n+    return m_src_region ? m_src_region->get_memory_space () : MEMSPACE_UNKNOWN;\n+  }\n+\n+  bit_size_t calc_num_uninit_bits () const\n+  {\n+    switch (m_copied_sval->get_kind ())\n+      {\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      case SK_POISONED:\n+\t{\n+\t  const poisoned_svalue *poisoned_sval\n+\t    = as_a <const poisoned_svalue *> (m_copied_sval);\n+\t  gcc_assert (poisoned_sval->get_poison_kind () == POISON_KIND_UNINIT);\n+\n+\t  /* Give up if don't have type information.  */\n+\t  if (m_copied_sval->get_type () == NULL_TREE)\n+\t    return 0;\n+\n+\t  bit_size_t size_in_bits;\n+\t  if (int_size_in_bits (m_copied_sval->get_type (), &size_in_bits))\n+\t    return size_in_bits;\n+\n+\t  /* Give up if we can't get the size of the type.  */\n+\t  return 0;\n+\t}\n+\tbreak;\n+      case SK_COMPOUND:\n+\t{\n+\t  const compound_svalue *compound_sval\n+\t    = as_a <const compound_svalue *> (m_copied_sval);\n+\t  bit_size_t result = 0;\n+\t  /* Find keys for uninit svals.  */\n+\t  for (auto iter : *compound_sval)\n+\t    {\n+\t      const svalue *sval = iter.second;\n+\t      if (const poisoned_svalue *psval\n+\t\t  = sval->dyn_cast_poisoned_svalue ())\n+\t\tif (psval->get_poison_kind () == POISON_KIND_UNINIT)\n+\t\t  {\n+\t\t    const binding_key *key = iter.first;\n+\t\t    const concrete_binding *ckey\n+\t\t      = key->dyn_cast_concrete_binding ();\n+\t\t    gcc_assert (ckey);\n+\t\t    result += ckey->get_size_in_bits ();\n+\t\t  }\n+\t    }\n+\t  return result;\n+\t}\n+      }\n+  }\n+\n+  void inform_number_of_uninit_bits (location_t loc) const\n+  {\n+    bit_size_t num_uninit_bits = calc_num_uninit_bits ();\n+    if (num_uninit_bits <= 0)\n+      return;\n+    if (num_uninit_bits % BITS_PER_UNIT == 0)\n+      {\n+\t/* Express in bytes.  */\n+\tbyte_size_t num_uninit_bytes = num_uninit_bits / BITS_PER_UNIT;\n+\tif (num_uninit_bytes == 1)\n+\t  inform (loc, \"1 byte is uninitialized\");\n+\telse\n+\t  inform (loc,\n+\t\t  \"%wu bytes are uninitialized\", num_uninit_bytes.to_uhwi ());\n+      }\n+    else\n+      {\n+\t/* Express in bits.  */\n+\tif (num_uninit_bits == 1)\n+\t  inform (loc, \"1 bit is uninitialized\");\n+\telse\n+\t  inform (loc,\n+\t\t  \"%wu bits are uninitialized\", num_uninit_bits.to_uhwi ());\n+      }\n+  }\n+\n+  void complain_about_uninit_ranges (location_t loc) const\n+  {\n+    if (const compound_svalue *compound_sval\n+\t= m_copied_sval->dyn_cast_compound_svalue ())\n+      {\n+\t/* Find keys for uninit svals.  */\n+\tauto_vec<const concrete_binding *> uninit_keys;\n+\tfor (auto iter : *compound_sval)\n+\t  {\n+\t    const svalue *sval = iter.second;\n+\t    if (const poisoned_svalue *psval\n+\t\t= sval->dyn_cast_poisoned_svalue ())\n+\t      if (psval->get_poison_kind () == POISON_KIND_UNINIT)\n+\t\t{\n+\t\t  const binding_key *key = iter.first;\n+\t\t  const concrete_binding *ckey\n+\t\t    = key->dyn_cast_concrete_binding ();\n+\t\t  gcc_assert (ckey);\n+\t\t  uninit_keys.safe_push (ckey);\n+\t\t}\n+\t  }\n+\t/* Complain about them in sorted order.  */\n+\tuninit_keys.qsort (concrete_binding::cmp_ptr_ptr);\n+\n+\tstd::unique_ptr<record_layout> layout;\n+\n+\ttree type = m_copied_sval->get_type ();\n+\tif (type && TREE_CODE (type) == RECORD_TYPE)\n+\t  {\n+\t    // (std::make_unique is C++14)\n+\t    layout = std::unique_ptr<record_layout> (new record_layout (type));\n+\n+\t    if (0)\n+\t      layout->dump ();\n+\t  }\n+\n+\tunsigned i;\n+\tconst concrete_binding *ckey;\n+\tFOR_EACH_VEC_ELT (uninit_keys, i, ckey)\n+\t  {\n+\t    bit_offset_t start_bit = ckey->get_start_bit_offset ();\n+\t    bit_offset_t next_bit = ckey->get_next_bit_offset ();\n+\t    complain_about_uninit_range (loc, start_bit, next_bit,\n+\t\t\t\t\t layout.get ());\n+\t  }\n+      }\n+  }\n+\n+  void complain_about_uninit_range (location_t loc,\n+\t\t\t\t    bit_offset_t start_bit,\n+\t\t\t\t    bit_offset_t next_bit,\n+\t\t\t\t    const record_layout *layout) const\n+  {\n+    if (layout)\n+      {\n+\twhile (start_bit < next_bit)\n+\t  {\n+\t    if (const record_layout::item *item\n+\t\t  = layout->get_item_at (start_bit))\n+\t      {\n+\t\tgcc_assert (start_bit >= item->get_start_bit_offset ());\n+\t\tgcc_assert (start_bit < item->get_next_bit_offset ());\n+\t\tif (item->get_start_bit_offset () == start_bit\n+\t\t    && item->get_next_bit_offset () <= next_bit)\n+\t\t  complain_about_fully_uninit_item (*item);\n+\t\telse\n+\t\t  complain_about_partially_uninit_item (*item);\n+\t\tstart_bit = item->get_next_bit_offset ();\n+\t\tcontinue;\n+\t      }\n+\t    else\n+\t      break;\n+\t  }\n+      }\n+\n+    if (start_bit >= next_bit)\n+      return;\n+\n+    if (start_bit % 8 == 0 && next_bit % 8 == 0)\n+      {\n+\t/* Express in bytes.  */\n+\tbyte_offset_t start_byte = start_bit / 8;\n+\tbyte_offset_t last_byte = (next_bit / 8) - 1;\n+\tif (last_byte == start_byte)\n+\t  inform (loc,\n+\t\t  \"byte %wu is uninitialized\",\n+\t\t  start_byte.to_uhwi ());\n+\telse\n+\t  inform (loc,\n+\t\t  \"bytes %wu - %wu are uninitialized\",\n+\t\t  start_byte.to_uhwi (),\n+\t\t  last_byte.to_uhwi ());\n+      }\n+    else\n+      {\n+\t/* Express in bits.  */\n+\tbit_offset_t last_bit = next_bit - 1;\n+\tif (last_bit == start_bit)\n+\t  inform (loc,\n+\t\t  \"bit %wu is uninitialized\",\n+\t\t  start_bit.to_uhwi ());\n+\telse\n+\t  inform (loc,\n+\t\t  \"bits %wu - %wu are uninitialized\",\n+\t\t  start_bit.to_uhwi (),\n+\t\t  last_bit.to_uhwi ());\n+      }\n+  }\n+\n+  static void\n+  complain_about_fully_uninit_item (const record_layout::item &item)\n+  {\n+    tree field = item.m_field;\n+    bit_size_t num_bits = item.m_bit_range.m_size_in_bits;\n+    if (item.m_is_padding)\n+      {\n+\tif (num_bits % 8 == 0)\n+\t  {\n+\t    /* Express in bytes.  */\n+\t    byte_size_t num_bytes = num_bits / BITS_PER_UNIT;\n+\t    if (num_bytes == 1)\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"padding after field %qD is uninitialized (1 byte)\",\n+\t\t      field);\n+\t    else\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"padding after field %qD is uninitialized (%wu bytes)\",\n+\t\t      field, num_bytes.to_uhwi ());\n+\t  }\n+\telse\n+\t  {\n+\t    /* Express in bits.  */\n+\t    if (num_bits == 1)\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"padding after field %qD is uninitialized (1 bit)\",\n+\t\t      field);\n+\t    else\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"padding after field %qD is uninitialized (%wu bits)\",\n+\t\t      field, num_bits.to_uhwi ());\n+\t  }\n+      }\n+    else\n+      {\n+\tif (num_bits % 8 == 0)\n+\t  {\n+\t    /* Express in bytes.  */\n+\t    byte_size_t num_bytes = num_bits / BITS_PER_UNIT;\n+\t    if (num_bytes == 1)\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"field %qD is uninitialized (1 byte)\", field);\n+\t    else\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"field %qD is uninitialized (%wu bytes)\",\n+\t\t      field, num_bytes.to_uhwi ());\n+\t  }\n+\telse\n+\t  {\n+\t    /* Express in bits.  */\n+\t    if (num_bits == 1)\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"field %qD is uninitialized (1 bit)\", field);\n+\t    else\n+\t      inform (DECL_SOURCE_LOCATION (field),\n+\t\t      \"field %qD is uninitialized (%wu bits)\",\n+\t\t      field, num_bits.to_uhwi ());\n+\t  }\n+      }\n+  }\n+\n+  static void\n+  complain_about_partially_uninit_item (const record_layout::item &item)\n+  {\n+    tree field = item.m_field;\n+    if (item.m_is_padding)\n+      inform (DECL_SOURCE_LOCATION (field),\n+\t      \"padding after field %qD is partially uninitialized\",\n+\t      field);\n+    else\n+      inform (DECL_SOURCE_LOCATION (field),\n+\t      \"field %qD is partially uninitialized\",\n+\t      field);\n+    /* TODO: ideally we'd describe what parts are uninitialized.  */\n+  }\n+\n+  void maybe_emit_fixit_hint () const\n+  {\n+    if (tree decl = m_src_region->maybe_get_decl ())\n+      {\n+\tgcc_rich_location hint_richloc (DECL_SOURCE_LOCATION (decl));\n+\thint_richloc.add_fixit_insert_after (\" = {0}\");\n+\tinform (&hint_richloc,\n+\t\t\"suggest forcing zero-initialization by\"\n+\t\t\" providing a %<{0}%> initializer\");\n+      }\n+  }\n+\n+private:\n+  const region *m_src_region;\n+  const region *m_dest_region;\n+  const svalue *m_copied_sval;\n+  region_model_manager *m_mgr;\n+};\n+\n+/* Return true if any part of SVAL is uninitialized.  */\n+\n+static bool\n+contains_uninit_p (const svalue *sval)\n+{\n+  struct uninit_finder : public visitor\n+  {\n+  public:\n+    uninit_finder () : m_found_uninit (false) {}\n+    void visit_poisoned_svalue (const poisoned_svalue *sval)\n+    {\n+      if (sval->get_poison_kind () == POISON_KIND_UNINIT)\n+\tm_found_uninit = true;\n+    }\n+    bool m_found_uninit;\n+  };\n+\n+  uninit_finder v;\n+  sval->accept (&v);\n+\n+  return v.m_found_uninit;\n+}\n+\n+/* Function for use by plugins when simulating writing data through a\n+   pointer to an \"untrusted\" region DST_REG (and thus crossing a security\n+   boundary), such as copying data to user space in an OS kernel.\n+\n+   Check that COPIED_SVAL is fully initialized.  If not, complain about\n+   an infoleak to CTXT.\n+\n+   SRC_REG can be NULL; if non-NULL it is used as a hint in the diagnostic\n+   as to where COPIED_SVAL came from.  */\n+\n+void\n+region_model::maybe_complain_about_infoleak (const region *dst_reg,\n+\t\t\t\t\t     const svalue *copied_sval,\n+\t\t\t\t\t     const region *src_reg,\n+\t\t\t\t\t     region_model_context *ctxt)\n+{\n+  /* Check for exposure.  */\n+  if (contains_uninit_p (copied_sval))\n+    ctxt->warn (new exposure_through_uninit_copy (src_reg,\n+\t\t\t\t\t\t  dst_reg,\n+\t\t\t\t\t\t  copied_sval,\n+\t\t\t\t\t\t  m_mgr));\n+}\n+\n /* class noop_region_model_context : public region_model_context.  */\n \n void"}, {"sha": "e86720a645c72d25c6398b921c9e4824c1b5baac", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -532,6 +532,8 @@ class call_details\n   region_model *get_model () const { return m_model; }\n   region_model_manager *get_manager () const;\n   region_model_context *get_ctxt () const { return m_ctxt; }\n+  logger *get_logger () const;\n+\n   uncertainty_t *get_uncertainty () const;\n   tree get_lhs_type () const { return m_lhs_type; }\n   const region *get_lhs_region () const { return m_lhs_region; }\n@@ -814,11 +816,20 @@ class region_model\n   const svalue *get_string_size (const svalue *sval) const;\n   const svalue *get_string_size (const region *reg) const;\n \n+  void maybe_complain_about_infoleak (const region *dst_reg,\n+\t\t\t\t      const svalue *copied_sval,\n+\t\t\t\t      const region *src_reg,\n+\t\t\t\t      region_model_context *ctxt);\n+\n   /* Implemented in sm-malloc.cc  */\n   void on_realloc_with_move (const call_details &cd,\n \t\t\t     const svalue *old_ptr_sval,\n \t\t\t     const svalue *new_ptr_sval);\n \n+  /* Implemented in sm-taint.cc.  */\n+  void mark_as_tainted (const svalue *sval,\n+\t\t\tregion_model_context *ctxt);\n+\n  private:\n   const region *get_lvalue_1 (path_var pv, region_model_context *ctxt) const;\n   const svalue *get_rvalue_1 (path_var pv, region_model_context *ctxt) const;"}, {"sha": "f5c0cc13a2f39123ca7e5c460bf656f3195fefa7", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -1365,6 +1365,33 @@ region_model::check_dynamic_size_for_taint (enum memory_space mem_space,\n     }\n }\n \n+/* Mark SVAL as TAINTED.  CTXT must be non-NULL.  */\n+\n+void\n+region_model::mark_as_tainted (const svalue *sval,\n+\t\t\t       region_model_context *ctxt)\n+{\n+  gcc_assert (sval);\n+  gcc_assert (ctxt);\n+\n+  sm_state_map *smap;\n+  const state_machine *sm;\n+  unsigned sm_idx;\n+  if (!ctxt->get_taint_map (&smap, &sm, &sm_idx))\n+    return;\n+\n+  gcc_assert (smap);\n+  gcc_assert (sm);\n+\n+  const taint_state_machine &taint_sm = (const taint_state_machine &)*sm;\n+\n+  const extrinsic_state *ext_state = ctxt->get_ext_state ();\n+  if (!ext_state)\n+    return;\n+\n+  smap->set_state (this, sval, taint_sm.m_tainted, NULL, *ext_state);\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "eaee5166822f1685a916585231a5d13647e1ca7b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -447,6 +447,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-analyzer-double-fclose @gol\n -Wno-analyzer-double-free @gol\n -Wno-analyzer-exposure-through-output-file @gol\n+-Wno-analyzer-exposure-through-uninit-copy @gol\n -Wno-analyzer-fd-access-mode-mismatch @gol\n -Wno-analyzer-fd-double-close @gol\n -Wno-analyzer-fd-leak @gol\n@@ -9797,6 +9798,7 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-double-fclose @gol\n -Wanalyzer-double-free @gol\n -Wanalyzer-exposure-through-output-file @gol\n+-Wanalyzer-exposure-through-uninit-copy @gol\n -Wanalyzer-fd-access-mode-mismatch @gol\n -Wanalyzer-fd-double-close @gol\n -Wanalyzer-fd-leak @gol\n@@ -9899,6 +9901,20 @@ security-sensitive value is written to an output file\n \n See @uref{https://cwe.mitre.org/data/definitions/532.html, CWE-532: Information Exposure Through Log Files}.\n \n+@item Wanalyzer-exposure-through-uninit-copy\n+@opindex Wanalyzer-exposure-through-uninit-copy\n+@opindex Wno-analyzer-exposure-through-uninit-copy\n+This warning requires both @option{-fanalyzer} and the use of a plugin\n+to specify a function that copies across a ``trust boundary''.  Use\n+@option{-Wno-analyzer-exposure-through-uninit-copy} to disable it.\n+\n+This diagnostic warns for ``infoleaks'' - paths through the code in which\n+uninitialized values are copied across a security boundary\n+(such as code within an OS kernel that copies a partially-initialized\n+struct on the stack to user space).\n+\n+See @uref{https://cwe.mitre.org/data/definitions/200.html, CWE-200: Exposure of Sensitive Information to an Unauthorized Actor}.\n+\n @item -Wno-analyzer-fd-access-mode-mismatch\n @opindex Wanalyzer-fd-access-mode-mismatch\n @opindex Wno-analyzer-fd-access-mode-mismatch"}, {"sha": "6ec08bff73cfcc946fe31049392afbedda711299", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_kernel_plugin.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_kernel_plugin.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,237 @@\n+/* Proof-of-concept of a -fanalyzer plugin for the Linux kernel.  */\n+/* { dg-options \"-g\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"diagnostic-color.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/call-info.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Implementation of \"copy_from_user\" and \"copy_to_user\".  */\n+  \n+class copy_across_boundary_fn : public known_function\n+{\n+ public:\n+  virtual bool untrusted_source_p () const = 0;\n+  virtual bool untrusted_destination_p () const = 0;\n+\n+  void impl_call_pre (const call_details &cd) const final override\n+  {\n+    region_model_manager *mgr = cd.get_manager ();\n+    region_model *model = cd.get_model ();\n+    region_model_context *ctxt = cd.get_ctxt ();\n+\n+    const svalue *dest_sval = cd.get_arg_svalue (0);\n+    const svalue *src_sval = cd.get_arg_svalue (1);\n+    const svalue *num_bytes_sval = cd.get_arg_svalue (2);\n+\n+    const region *dest_reg = model->deref_rvalue (dest_sval,\n+\t\t\t\t\t\t  cd.get_arg_tree (0),\n+\t\t\t\t\t\t  ctxt);\n+    const region *src_reg = model->deref_rvalue (src_sval,\n+\t\t\t\t\t\t cd.get_arg_tree (1),\n+\t\t\t\t\t\t ctxt);\n+    if (const svalue *bounded_sval\n+\t  = model->maybe_get_copy_bounds (src_reg, num_bytes_sval))\n+      num_bytes_sval = bounded_sval;\n+\n+    if (tree cst = num_bytes_sval->maybe_get_constant ())\n+      if (zerop (cst))\n+\t/* No-op.  */\n+\treturn;\n+\n+    const region *sized_src_reg = mgr->get_sized_region (src_reg,\n+\t\t\t\t\t\t\t NULL_TREE,\n+\t\t\t\t\t\t\t num_bytes_sval);\n+\n+    const svalue *copied_sval\n+      = model->get_store_value (sized_src_reg, ctxt);\n+    const region *sized_dest_reg = mgr->get_sized_region (dest_reg,\n+\t\t\t\t\t\t\t  NULL_TREE,\n+\t\t\t\t\t\t\t  num_bytes_sval);\n+\n+    if (ctxt)\n+      {\n+\t/* Bifurcate state, creating a \"failure\" out-edge.  */\n+\tctxt->bifurcate (new copy_failure (cd));\n+\n+\t/* The \"unbifurcated\" state is the \"success\" case.  */\n+\tcopy_success success (cd,\n+\t\t\t      sized_dest_reg,\n+\t\t\t      copied_sval,\n+\t\t\t      sized_src_reg,\n+\t\t\t      untrusted_source_p (),\n+\t\t\t      untrusted_destination_p ());\n+\tsuccess.update_model (model, NULL, ctxt);\n+      }\n+  }\n+\n+ private:\n+  class copy_success : public success_call_info\n+  {\n+  public:\n+    copy_success (const call_details &cd,\n+\t\t  const region *sized_dest_reg,\n+\t\t  const svalue *copied_sval,\n+\t\t  const region *sized_src_reg,\n+\t\t  bool untrusted_source,\n+\t\t  bool untrusted_destination)\n+    : success_call_info (cd),\n+      m_sized_dest_reg (sized_dest_reg),\n+      m_copied_sval (copied_sval),\n+      m_sized_src_reg (sized_src_reg),\n+      m_untrusted_source (untrusted_source),\n+      m_untrusted_destination (untrusted_destination)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      call_details cd (get_call_details (model, ctxt));\n+      model->update_for_zero_return (cd, true);\n+      model->set_value (m_sized_dest_reg, m_copied_sval, ctxt);\n+      if (ctxt && m_untrusted_source)\n+\tmodel->mark_as_tainted (m_copied_sval, ctxt);\n+      if (m_untrusted_destination)\n+\tmodel->maybe_complain_about_infoleak (m_sized_dest_reg,\n+\t\t\t\t\t      m_copied_sval,\n+\t\t\t\t\t      m_sized_src_reg,\n+\t\t\t\t\t      ctxt);\n+      return true;\n+    }\n+\n+    const region *m_sized_dest_reg;\n+    const svalue *m_copied_sval;\n+    const region *m_sized_src_reg;\n+    bool m_untrusted_source;\n+    bool m_untrusted_destination;\n+  };\n+\n+  class copy_failure : public failed_call_info\n+  {\n+  public:\n+    copy_failure (const call_details &cd)\n+    : failed_call_info (cd)\n+    {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      call_details cd (get_call_details (model, ctxt));\n+      model->update_for_nonzero_return (cd);\n+      /* Leave the destination region untouched.  */\n+      return true;\n+    }\n+  };\n+};\n+\n+/* \"copy_from_user\".  */\n+\n+class known_function_copy_from_user : public copy_across_boundary_fn\n+{\n+public:\n+  bool untrusted_source_p () const final override\n+  {\n+    return true;\n+  }\n+  bool untrusted_destination_p () const final override\n+  {\n+    return false;\n+  }\n+};\n+\n+/* \"copy_to_user\".  */\n+\n+class known_function_copy_to_user : public copy_across_boundary_fn\n+{\n+public:\n+  bool untrusted_source_p () const final override\n+  {\n+    return false;\n+  }\n+  bool untrusted_destination_p () const final override\n+  {\n+    return true;\n+  }\n+};\n+\n+/* Callback handler for the PLUGIN_ANALYZER_INIT event.  */\n+\n+static void\n+kernel_analyzer_init_cb (void *gcc_data, void */*user_data*/)\n+{\n+  ana::plugin_analyzer_init_iface *iface\n+    = (ana::plugin_analyzer_init_iface *)gcc_data;\n+  LOG_SCOPE (iface->get_logger ());\n+  if (0)\n+    inform (input_location, \"got here: kernel_analyzer_init_cb\");\n+  iface->register_known_function (\"copy_from_user\",\n+\t\t\t\t  new known_function_copy_from_user ());\n+  iface->register_known_function (\"copy_to_user\",\n+\t\t\t\t  new known_function_copy_to_user ());\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+#if ENABLE_ANALYZER\n+  const char *plugin_name = plugin_info->base_name;\n+  if (0)\n+    inform (input_location, \"got here; %qs\", plugin_name);\n+  register_callback (plugin_info->base_name,\n+\t\t     PLUGIN_ANALYZER_INIT,\n+\t\t     ana::kernel_analyzer_init_cb,\n+\t\t     NULL); /* void *user_data */\n+#else\n+  sorry_no_analyzer ();\n+#endif\n+  return 0;\n+}"}, {"sha": "a1415f38aa6578d111a7b19f918ad31de3a22c07", "filename": "gcc/testsuite/gcc.dg/plugin/copy_from_user-1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcopy_from_user-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcopy_from_user-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fcopy_from_user-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,45 @@\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define __user\n+\n+extern int copy_from_user(void *to, const void __user *from, long n)\n+  __attribute__((access (write_only, 1, 3),\n+\t\t access (read_only, 2, 3)\n+\t\t ));\n+\n+#define   EFAULT          14\n+#define   EINVAL          22\n+\n+/* Taken from Linux: fs/binfmt_misc.c (GPL-2.0-only).  */\n+\n+int parse_command(const char __user *buffer, size_t count)\n+{\n+\tchar s[4];\n+\n+\tif (count > 3)\n+\t\treturn -EINVAL;\n+\tif (copy_from_user(s, buffer, count))\n+\t\treturn -EFAULT;\n+\tif (!count)\n+\t\treturn 0;\n+\tif (s[count - 1] == '\\n') /* { dg-bogus \"uninit\" } */\n+\t\tcount--;\n+\tif (count == 1 && s[0] == '0') /* { dg-bogus \"uninit\" } */\n+\t\treturn 1;\n+\tif (count == 1 && s[0] == '1') /* { dg-bogus \"uninit\" } */\n+\t\treturn 2;\n+\tif (count == 2 && s[0] == '-' && s[1] == '1') /* { dg-bogus \"uninit\" } */\n+\t\treturn 3;\n+\treturn -EINVAL;\n+}\n+\n+/* Not using return value from copy_from_user.  */\n+\n+int test_2 (const char __user *buffer, size_t count)\n+{\n+  char s[4];\n+  if (count > 3)\n+    return -EINVAL;\n+  copy_from_user(s, buffer, count);\n+  return 0;  \n+}"}, {"sha": "b4958e7bbb6394f9ca617f0e569fc46073d6f1e3", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-1.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,185 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include <string.h>\n+\n+#include \"test-uaccess.h\"\n+\n+typedef unsigned char u8;\n+typedef unsigned __INT16_TYPE__ u16;\n+typedef unsigned __INT32_TYPE__ u32;\n+\n+struct s1\n+{\n+  u32 i;\n+};\n+\n+void test_1a (void __user *dst, u32 a)\n+{\n+  struct s1 s;\n+  s.i = a;\n+  copy_to_user(dst, &s, sizeof (struct s1)); /* { dg-bogus \"\" } */\n+}\n+\n+void test_1b (void __user *dst, u32 a)\n+{\n+  struct s1 s;\n+  copy_to_user(dst, &s, sizeof (struct s1)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+  /* { dg-message \"4 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+}\n+\n+void test_1c (void __user *dst, u32 a)\n+{\n+  struct s1 s;\n+  memset (&s, 0, sizeof (struct s1));\n+  copy_to_user(dst, &s, sizeof (struct s1)); /* { dg-bogus \"\" } */\n+}\n+\n+void test_1d (void __user *dst, u32 a)\n+{\n+  struct s1 s = {0};\n+  copy_to_user(dst, &s, sizeof (struct s1)); /* { dg-bogus \"\" } */\n+}\n+\n+struct s2\n+{\n+  u32 i;\n+  u32 j; /* { dg-message \"field 'j' is uninitialized \\\\(4 bytes\\\\)\" } */\n+};\n+\n+void test_2a (void __user *dst, u32 a)\n+{\n+  struct s2 s; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 8 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+  s.i = a;\n+  copy_to_user(dst, &s, sizeof (struct s2)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+  /* { dg-message \"4 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+}\n+\n+void test_2b (void __user *dst, u32 a)\n+{\n+  struct s2 s;\n+  s.i = a;\n+  /* Copy with wrong size (only part of s2).  */\n+  copy_to_user(dst, &s, sizeof (struct s1));\n+}\n+\n+void test_2d (void __user *dst, u32 a)\n+{\n+  struct s2 s = {0};\n+  s.i = a;\n+  copy_to_user(dst, &s, sizeof (struct s2)); /* { dg-bogus\" } */\n+}\n+\n+struct empty {};\n+\n+void test_empty (void __user *dst)\n+{\n+  struct empty e;\n+  copy_to_user(dst, &e, sizeof (struct empty));\n+}\n+\n+union un_a\n+{\n+  u32 i;\n+  u8  j;\n+};\n+\n+/* As above, but in a different order.  */\n+\n+union un_b\n+{\n+  u8  j;\n+  u32 i;\n+};\n+\n+void test_union_1a (void __user *dst, u8 v)\n+{\n+  union un_a u; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 4 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+  u.j = v;\n+  copy_to_user(dst, &u, sizeof (union un_a)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+  /* { dg-message \"3 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+  /* { dg-message \"bytes 1 - 3 are uninitialized\" \"note how much\" { target *-*-* } .-2 } */\n+}\n+\n+void test_union_1b (void __user *dst, u8 v)\n+{\n+  union un_b u; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 4 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+  u.j = v;\n+  copy_to_user(dst, &u, sizeof (union un_b)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+  /* { dg-message \"3 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+  /* { dg-message \"bytes 1 - 3 are uninitialized\" \"note how much\" { target *-*-* } .-2 } */\n+}\n+\n+void test_union_2a (void __user *dst, u8 v)\n+{\n+  union un_a u = {0};\n+  u.j = v;\n+  copy_to_user(dst, &u, sizeof (union un_a));\n+}\n+\n+void test_union_2b (void __user *dst, u8 v)\n+{\n+  union un_b u = {0};\n+  u.j = v;\n+  copy_to_user(dst, &u, sizeof (union un_b));\n+}\n+\n+void test_union_3a (void __user *dst, u32 v)\n+{\n+  union un_a u;\n+  u.i = v;\n+  copy_to_user(dst, &u, sizeof (union un_a)); /* { dg-bogus \"\" } */\n+}\n+\n+void test_union_3b (void __user *dst, u32 v)\n+{\n+  union un_b u;\n+  u.i = v;\n+  copy_to_user(dst, &u, sizeof (union un_b)); /* { dg-bogus \"\" } */\n+}\n+\n+void test_union_4a (void __user *dst, u8 v)\n+{\n+  union un_a u = {0};\n+  copy_to_user(dst, &u, sizeof (union un_a)); /* { dg-bogus \"\" } */\n+}\n+\n+void test_union_4b (void __user *dst, u8 v)\n+{\n+  union un_b u = {0};\n+  copy_to_user(dst, &u, sizeof (union un_b)); /* { dg-bogus \"\" } */\n+}\n+\n+struct st_union_5\n+{\n+  union {\n+    u8 f1;\n+    u32 f2;\n+  } u; /* { dg-message \"field 'u' is partially uninitialized\" } */\n+};\n+\n+void test_union_5 (void __user *dst, u8 v)\n+{\n+  struct st_union_5 st; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 4 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+\n+  /* This write only initializes the u8 within the union \"u\",\n+     leaving the remaining 3 bytes uninitialized.  */\n+  st.u.f1 = v;\n+\n+  copy_to_user (dst, &st, sizeof(st)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+  /* { dg-message \"3 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+}\n+\n+void test_one_byte (void __user *dst)\n+{\n+  char src;  /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 1 byte\" \"capacity\" { target *-*-* } .-1 } */\n+\n+  copy_to_user (dst, &src, sizeof(src)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+  /* { dg-message \"1 byte is uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+}"}, {"sha": "252f8f25918ac57d5cd017eed37c1005cac9db8e", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-2.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include <string.h>\n+\n+#include \"test-uaccess.h\"\n+\n+typedef unsigned char u8;\n+typedef unsigned __INT16_TYPE__ u16;\n+typedef unsigned __INT32_TYPE__ u32;\n+\n+/* Coverage for the various singular and plural forms of bits, bytes, and fields vs padding.  */\n+\n+struct st\n+{\n+  u32 a;   /* { dg-message \"field 'a' is uninitialized \\\\(4 bytes\\\\)\" } */\n+  int b:1; /* { dg-message \"field 'b' is uninitialized \\\\(1 bit\\\\)\" \"field\" } */\n+           /* { dg-message \"padding after field 'b' is uninitialized \\\\(7 bits\\\\)\" \"padding\" { target *-*-* } .-1 } */\n+  u8 d;    /* { dg-message \"field 'd' is uninitialized \\\\(1 byte\\\\)\" } */\n+  int c:7; /* { dg-message \"padding after field 'c' is uninitialized \\\\(9 bits\\\\)\" } */\n+  u16 e;   /* { dg-message \"padding after field 'e' is uninitialized \\\\(2 bytes\\\\)\" } */  \n+};\n+\n+void test (void __user *dst, u16 v)\n+{\n+  struct st s; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 12 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+  /* { dg-message \"suggest forcing zero-initialization by providing a '\\\\{0\\\\}' initializer\" \"fix-it\" { target *-*-* } .-2 } */  \n+  s.e = v;\n+  copy_to_user(dst, &s, sizeof (struct st)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+  /* { dg-message \"10 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+}"}, {"sha": "097a0d8d33b7bc1e610498f804a925d3e547e0dc", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-3.c", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-3.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,145 @@\n+/* Verify that -Wanalyzer-exposure-through-uninit-copy doesn't get confused\n+   if size argument to copy_to_user is an upper bound, rather than a\n+   constant.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include \"../analyzer/analyzer-decls.h\"\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#include \"test-uaccess.h\"\n+\n+typedef unsigned __INT32_TYPE__ u32;\n+\n+/* min_t adapted from include/linux/kernel.h.  */\n+\n+#define min_t(type, x, y) ({\t\t\t\\\n+\ttype __min1 = (x);\t\t\t\\\n+\ttype __min2 = (y);\t\t\t\\\n+\t__min1 < __min2 ? __min1: __min2; })\n+\n+struct st\n+{\n+  u32 a;\n+  u32 b;\n+};\n+\n+/* Verify that we cope with min_t.  */\n+\n+void test_1_full_init (void __user *dst, u32 x, u32 y, unsigned long in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  s.b = y;\n+  unsigned long copy_sz = min_t(unsigned long, in_sz, sizeof(s));\n+  copy_to_user(dst, &s, copy_sz); /* { dg-bogus \"exposure\" } */\n+}\n+\n+void test_1_partial_init (void __user *dst, u32 x, u32 y, unsigned long in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  /* s.y not initialized.  */\n+  unsigned long copy_sz = min_t(unsigned long, in_sz, sizeof(s));\n+  copy_to_user(dst, &s, copy_sz); /* { dg-warning \"exposure\" } */\n+}\n+\n+/* Constant on LHS rather than RHS.  */\n+\n+void test_2_full_init (void __user *dst, u32 x, u32 y, unsigned long in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  s.b = y;\n+  unsigned long copy_sz = min_t(unsigned long, sizeof(s), in_sz);\n+  copy_to_user(dst, &s, copy_sz); /* { dg-bogus \"exposure\" } */\n+}\n+\n+void test_2_partial_init (void __user *dst, u32 x, u32 y, unsigned long in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  /* s.y not initialized.  */\n+  unsigned long copy_sz = min_t(unsigned long, sizeof(s), in_sz);\n+  copy_to_user(dst, &s, copy_sz); /* { dg-warning \"exposure\" } */\n+}\n+\n+/* min_t with various casts.  */\n+\n+void test_3_full_init (void __user *dst, u32 x, u32 y, int in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  s.b = y;\n+  int copy_sz = min_t(unsigned int, in_sz, sizeof(s));\n+  copy_to_user(dst, &s, copy_sz); /* { dg-bogus \"exposure\" } */\n+}\n+\n+void test_3_partial_init (void __user *dst, u32 x, u32 y, int in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  /* s.y not initialized.  */\n+  int copy_sz = min_t(unsigned int, in_sz, sizeof(s));\n+  copy_to_user(dst, &s, copy_sz); /* { dg-warning \"exposure\" } */\n+}\n+\n+/* Comparison against an upper bound.  */\n+\n+void test_4_full_init (void __user *dst, u32 x, u32 y, size_t in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  s.b = y;\n+  \n+  size_t copy_sz = in_sz;\n+  if (copy_sz > sizeof(s))\n+    copy_sz = sizeof(s);\n+\n+  copy_to_user(dst, &s, copy_sz); /* { dg-bogus \"exposure\" } */\n+}\n+\n+void test_4_partial_init (void __user *dst, u32 x, u32 y, size_t in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  /* s.y not initialized.  */\n+  \n+  size_t copy_sz = in_sz;\n+  if (copy_sz > sizeof(s))\n+    copy_sz = sizeof(s);\n+\n+  copy_to_user(dst, &s, copy_sz); /* { dg-warning \"exposure\" } */\n+}\n+\n+/* Comparison against an upper bound with casts.  */\n+\n+void test_5_full_init (void __user *dst, u32 x, u32 y, int in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  s.b = y;\n+  \n+  int copy_sz = in_sz;\n+  if (copy_sz > sizeof(s))\n+    copy_sz = sizeof(s);\n+  copy_to_user(dst, &s, copy_sz); /* { dg-bogus \"exposure\" } */\n+}\n+\n+/* Comparison against an upper bound with casts.  */\n+\n+void test_5_partial_init (void __user *dst, u32 x, u32 y, int in_sz)\n+{\n+  struct st s;\n+  s.a = x;\n+  /* s.y not initialized.  */\n+  \n+  int copy_sz = in_sz;\n+  if (copy_sz > sizeof(s))\n+    copy_sz = sizeof(s);\n+\n+  copy_to_user(dst, &s, copy_sz); /* { dg-warning \"exposure\" \"\" } */\n+}"}, {"sha": "3616fbe176b39493982dbca6cf85478d4b57bf5f", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-CVE-2011-1078-1.c", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2011-1078-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2011-1078-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2011-1078-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,138 @@\n+/* \"The sco_sock_getsockopt_old function in net/bluetooth/sco.c in the\n+   Linux kernel before 2.6.39 does not initialize a certain structure,\n+   which allows local users to obtain potentially sensitive information\n+   from kernel stack memory via the SCO_CONNINFO option.\"\n+\n+   Fixed e.g. by c4c896e1471aec3b004a693c689f60be3b17ac86 on linux-2.6.39.y\n+   in linux-stable.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include <string.h>\n+\n+typedef unsigned char __u8;\n+typedef unsigned short __u16;\n+\n+#include \"test-uaccess.h\"\n+\n+/* Adapted from include/asm-generic/uaccess.h.  */\n+\n+#define get_user(x, ptr)\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\\\n+\t/* [...snip...] */\t\t\t\t\t\\\n+\t__get_user_fn(sizeof (*(ptr)), ptr, &(x));\t\t\\\n+\t/* [...snip...] */\t\t\t\t\t\\\n+})\n+\n+static inline int __get_user_fn(size_t size, const void __user *ptr, void *x)\n+{\n+\tsize = copy_from_user(x, ptr, size);\n+\treturn size ? -1 : size;\n+}\n+\n+/* Adapted from include/linux/kernel.h.  */\n+\n+#define min_t(type, x, y) ({\t\t\t\\\n+\ttype __min1 = (x);\t\t\t\\\n+\ttype __min2 = (y);\t\t\t\\\n+\t__min1 < __min2 ? __min1: __min2; })\n+\n+/* Adapted from include/linux/net.h.  */\n+\n+struct socket {\n+\t/* [...snip...] */\n+\tstruct sock\t\t*sk;\n+\t/* [...snip...] */\n+};\n+\n+/* Adapted from include/net/bluetooth/sco.h.  */\n+\n+struct sco_conninfo {\n+\t__u16 hci_handle;\n+\t__u8  dev_class[3]; /* { dg-message \"padding after field 'dev_class' is uninitialized \\\\(1 byte\\\\)\" } */\n+};\n+\n+struct sco_conn {\n+\n+\tstruct hci_conn\t*hcon;\n+\t/* [...snip...] */\n+};\n+\n+#define sco_pi(sk) ((struct sco_pinfo *) sk)\n+\n+struct sco_pinfo {\n+\t/* [...snip...] */\n+\tstruct sco_conn\t*conn;\n+};\n+\n+/* Adapted from include/net/bluetooth/hci_core.h.  */\n+\n+struct hci_conn {\n+\t/* [...snip...] */\n+\t__u16\t\thandle;\n+\t/* [...snip...] */\n+\t__u8\t\tdev_class[3];\n+\t/* [...snip...] */\n+};\n+\n+/* Adapted from sco_sock_getsockopt_old in net/bluetooth/sco.c.  */\n+\n+static int sco_sock_getsockopt_old_broken(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n+{\n+\tstruct sock *sk = sock->sk;\n+\t/* [...snip...] */\n+\tstruct sco_conninfo cinfo; /* { dg-message \"region created on stack here\" \"where\" } */\n+\t\t\t\t   /* { dg-message \"capacity: 6 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+\t/* Note: 40 bits of fields, padded to 48.  */\n+\n+\tint len, err = 0;\n+\n+\t/* [...snip...] */\n+\n+\tif (get_user(len, optlen))\n+\t\treturn -1;\n+\n+\t/* [...snip...] */\n+\n+\t/* case SCO_CONNINFO: */\n+\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n+\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n+\n+\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n+\t\tif (copy_to_user(optval, (char *)&cinfo, len)) /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" { target *-*-* } } */\n+\t\t\t/* { dg-message \"1 byte is uninitialized\" \"how much note\" { target *-*-* } .-1 } */\n+\t\t\terr = -1;\n+\n+\t/* [...snip...] */\n+}\n+\n+static int sco_sock_getsockopt_fixed(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n+{\n+\tstruct sock *sk = sock->sk;\n+\t/* [...snip...] */\n+\tstruct sco_conninfo cinfo;\n+\t/* Note: 40 bits of fields, padded to 48.  */\n+\n+\tint len, err = 0;\n+\n+\t/* [...snip...] */\n+\n+\tif (get_user(len, optlen))\n+\t\treturn -1;\n+\n+\t/* [...snip...] */\n+\n+\t/* case SCO_CONNINFO: */\n+\t\t/* Infoleak fixed by this memset call.  */\n+\t\tmemset(&cinfo, 0, sizeof(cinfo));\n+\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n+\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n+\n+\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n+\t\tif (copy_to_user(optval, (char *)&cinfo, len)) /* { dg-bogus \"exposure\" } */\n+\t\t\terr = -1;\n+\n+\t/* [...snip...] */\n+}"}, {"sha": "2096bda71798fff83cc75f34511abf701aac95b7", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-CVE-2011-1078-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2011-1078-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2011-1078-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2011-1078-2.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,46 @@\n+/* Simplified versions of infoleak-CVE-2011-1078-1.c.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include <string.h>\n+\n+typedef unsigned char __u8;\n+typedef unsigned short __u16;\n+\n+#include \"test-uaccess.h\"\n+\n+/* Adapted from include/net/bluetooth/sco.h.  */\n+\n+struct sco_conninfo {\n+\t__u16 hci_handle;\n+\t__u8  dev_class[3]; /* { dg-message \"padding after field 'dev_class' is uninitialized \\\\(1 byte\\\\)\" } */\n+};\n+\n+/* Adapted from sco_sock_getsockopt_old in net/bluetooth/sco.c.  */\n+\n+int test_1 (char __user *optval, const struct sco_conninfo *in)\n+{\n+\tstruct sco_conninfo cinfo; /* { dg-message \"region created on stack here\" \"where\" } */\n+\t\t\t\t   /* { dg-message \"capacity: 6 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+\t/* Note: 40 bits of fields, padded to 48.  */\n+\n+\tcinfo.hci_handle = in->hci_handle;\n+\tmemcpy(cinfo.dev_class, in->dev_class, 3);\n+\n+\tcopy_to_user(optval, &cinfo, sizeof(cinfo)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+\t/* { dg-message \"1 byte is uninitialized\" \"how much note\" { target *-*-* } .-1 } */\n+}\n+\n+int test_2 (char __user *optval, const struct sco_conninfo *in)\n+{\n+\tstruct sco_conninfo cinfo;\n+\t/* Note: 40 bits of fields, padded to 48.  */\n+\n+\tmemset(&cinfo, 0, sizeof(cinfo));\n+\tcinfo.hci_handle = in->hci_handle;\n+\tmemcpy(cinfo.dev_class, in->dev_class, 3);\n+\n+\tcopy_to_user(optval, &cinfo, sizeof(cinfo)); /* { dg-bogus \"\" } */\n+}"}, {"sha": "2726a9c0f3850f385f18f7753dedeff6d0822888", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-CVE-2014-1446-1.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2014-1446-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2014-1446-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2014-1446-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,117 @@\n+/* \"The yam_ioctl function in drivers/net/hamradio/yam.c in the Linux kernel\n+   before 3.12.8 does not initialize a certain structure member, which allows\n+   local users to obtain sensitive information from kernel memory by\n+   leveraging the CAP_NET_ADMIN capability for an SIOCYAMGCFG ioctl call.\"\n+\n+   Fixed e.g. by e7834c71c2cacc621ddc64bd71f83ef2054f6539 on linux-3.12.y\n+   in linux-stable.  */\n+\n+#include <string.h>\n+\n+#include \"test-uaccess.h\"\n+\n+/* Adapted from include/linux/yam.h  */\n+\n+struct yamcfg {\n+\tunsigned int mask;\t\t/* Mask of commands */\n+\tunsigned int iobase;\t/* IO Base of COM port */\n+\tunsigned int irq;\t\t/* IRQ of COM port */\n+\tunsigned int bitrate;\t/* Bit rate of radio port */\n+\tunsigned int baudrate;\t/* Baud rate of the RS232 port */\n+\tunsigned int txdelay;\t/* TxDelay */\n+\tunsigned int txtail;\t/* TxTail */\n+\tunsigned int persist;\t/* Persistence */\n+\tunsigned int slottime;\t/* Slottime */\n+\tunsigned int mode;\t\t/* mode 0 (simp), 1(Dupl), 2(Dupl+delay) */\n+\tunsigned int holddly;\t/* PTT delay in FullDuplex 2 mode */\n+};\n+\n+struct yamdrv_ioctl_cfg {\n+\tint cmd; /* { dg-message \"field 'cmd' is uninitialized \\\\(4 bytes\\\\)\" } */\n+\tstruct yamcfg cfg;\n+};\n+\n+/* Adapted from include/asm-generic/errno-base.h  */\n+\n+#define\tEFAULT\t\t14\t/* Bad address */\n+\n+/* Adapted from drivers/net/hamradio/yam.c  */\n+\n+struct yam_port {\n+\t/* [...snip...] */\n+\n+\tint bitrate;\n+\tint baudrate;\n+\tint iobase;\n+\tint irq;\n+\tint dupmode;\n+\n+\t/* [...snip...] */\n+\n+\tint txd;\t\t\t\t/* tx delay */\n+\tint holdd;\t\t\t\t/* duplex ptt delay */\n+\tint txtail;\t\t\t\t/* txtail delay */\n+\tint slot;\t\t\t\t/* slottime */\n+\tint pers;\t\t\t\t/* persistence */\n+\n+\t/* [...snip...] */\n+};\n+\n+/* Broken version, leaving yi.cmd uninitialized.  */\n+\n+static int yam_ioctl(/* [...snip...] */\n+\t\t     void __user *dst, struct yam_port *yp)\n+{\n+\tstruct yamdrv_ioctl_cfg yi; /* { dg-message \"region created on stack here\" \"memspace event\" } */\n+\t/* { dg-message \"capacity: 48 bytes\" \"capacity event\" { target *-*-* } .-1 } */\n+\n+\t/* [...snip...] */\n+\n+\t/* case SIOCYAMGCFG: */\n+\t\tyi.cfg.mask = 0xffffffff;\n+\t\tyi.cfg.iobase = yp->iobase;\n+\t\tyi.cfg.irq = yp->irq;\n+\t\tyi.cfg.bitrate = yp->bitrate;\n+\t\tyi.cfg.baudrate = yp->baudrate;\n+\t\tyi.cfg.mode = yp->dupmode;\n+\t\tyi.cfg.txdelay = yp->txd;\n+\t\tyi.cfg.holddly = yp->holdd;\n+\t\tyi.cfg.txtail = yp->txtail;\n+\t\tyi.cfg.persist = yp->pers;\n+\t\tyi.cfg.slottime = yp->slot;\n+\t\tif (copy_to_user(dst, &yi, sizeof(struct yamdrv_ioctl_cfg))) /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+\t\t\t/* { dg-message \"4 bytes are uninitialized\" \"how much note\" { target *-*-* } .-1 } */\n+\t\t\t return -EFAULT;\n+\t/* [...snip...] */\n+\n+\treturn 0;\n+}\n+\n+/* Fixed version, with a memset.  */\n+\n+static int yam_ioctl_fixed(/* [...snip...] */\n+\t\t\t   void __user *dst, struct yam_port *yp)\n+{\n+\tstruct yamdrv_ioctl_cfg yi;\n+\n+\t/* [...snip...] */\n+\n+\t/* case SIOCYAMGCFG: */\n+\t\tmemset(&yi, 0, sizeof(yi));\n+\t\tyi.cfg.mask = 0xffffffff;\n+\t\tyi.cfg.iobase = yp->iobase;\n+\t\tyi.cfg.irq = yp->irq;\n+\t\tyi.cfg.bitrate = yp->bitrate;\n+\t\tyi.cfg.baudrate = yp->baudrate;\n+\t\tyi.cfg.mode = yp->dupmode;\n+\t\tyi.cfg.txdelay = yp->txd;\n+\t\tyi.cfg.holddly = yp->holdd;\n+\t\tyi.cfg.txtail = yp->txtail;\n+\t\tyi.cfg.persist = yp->pers;\n+\t\tyi.cfg.slottime = yp->slot;\n+\t\tif (copy_to_user(dst, &yi, sizeof(struct yamdrv_ioctl_cfg))) /* { dg-bogus \"\" } */\n+\t\t\t return -EFAULT;\n+\t/* [...snip...] */\n+\n+\treturn 0;\n+}"}, {"sha": "8a1c816cc1b5089effff42fd060f89c7cb8c78b3", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-CVE-2017-18549-1.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2017-18549-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2017-18549-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2017-18549-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,105 @@\n+/* \"An issue was discovered in drivers/scsi/aacraid/commctrl.c in the\n+   Linux kernel before 4.13. There is potential exposure of kernel stack\n+   memory because aac_send_raw_srb does not initialize the reply structure.\"\n+\n+   Fixed e.g. by 342ffc26693b528648bdc9377e51e4f2450b4860 on linux-4.13.y \n+   in linux-stable.\n+\n+   This is a very simplified version of that code (before and after the fix). */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include <string.h>\n+\n+typedef unsigned int __u32;\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#include \"test-uaccess.h\"\n+\n+/* Adapted from include/uapi/linux/types.h  */\n+\n+#define __bitwise\n+typedef __u32 __bitwise __le32;\n+\n+/* Adapted from drivers/scsi/aacraid/aacraid.h  */\n+\n+#define\t\tAAC_SENSE_BUFFERSIZE\t 30\n+\n+struct aac_srb_reply\n+{\n+\t__le32\t\tstatus;\n+\t__le32\t\tsrb_status;\n+\t__le32\t\tscsi_status;\n+\t__le32\t\tdata_xfer_length;\n+\t__le32\t\tsense_data_size;\n+\tu8\t\tsense_data[AAC_SENSE_BUFFERSIZE]; /* { dg-message \"padding after field 'sense_data' is uninitialized \\\\(2 bytes\\\\)\" } */\n+};\n+\n+#define\t\tST_OK\t\t0\n+#define SRB_STATUS_SUCCESS                  0x01\n+\n+/* Adapted from drivers/scsi/aacraid/commctrl.c  */\n+\n+static int aac_send_raw_srb(/* [...snip...] */\n+\t\t\t    void __user *user_reply)\n+{\n+\tu32 byte_count = 0;\n+\n+\t/* [...snip...] */\n+\n+\tstruct aac_srb_reply reply; /* { dg-message \"region created on stack here\" \"memspace message\" } */\n+\t/* { dg-message \"capacity: 52 bytes\" \"capacity message\" { target *-*-* } .-1 } */\n+\n+\treply.status = ST_OK;\n+\t\t\n+\t/* [...snip...] */\n+\n+\treply.srb_status = SRB_STATUS_SUCCESS;\n+\treply.scsi_status = 0;\n+\treply.data_xfer_length = byte_count;\n+\treply.sense_data_size = 0;\n+\tmemset(reply.sense_data, 0, AAC_SENSE_BUFFERSIZE);\n+\n+\t/* [...snip...] */\n+\n+\tif (copy_to_user(user_reply, &reply, /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" } */\n+\t\t\t\t\t     /* { dg-message \"2 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+\t\t\t sizeof(struct aac_srb_reply))) {\n+\t\t/* [...snip...] */\n+\t}\n+\t/* [...snip...] */\n+}\n+\n+static int aac_send_raw_srb_fixed(/* [...snip...] */\n+\t\t\t\t  void __user *user_reply)\n+{\n+\tu32 byte_count = 0;\n+\n+\t/* [...snip...] */\n+\n+\tstruct aac_srb_reply reply;\n+\n+\t/* This is the fix.  */\n+\tmemset(&reply, 0, sizeof(reply));\n+\n+\treply.status = ST_OK;\n+\t\t\n+\t/* [...snip...] */\n+\n+\treply.srb_status = SRB_STATUS_SUCCESS;\n+\treply.scsi_status = 0;\n+\treply.data_xfer_length = byte_count;\n+\treply.sense_data_size = 0;\n+\tmemset(reply.sense_data, 0, AAC_SENSE_BUFFERSIZE);\n+\n+\t/* [...snip...] */\n+\n+\tif (copy_to_user(user_reply, &reply, /* { dg-bogus \"\" } */\n+\t\t\t sizeof(struct aac_srb_reply))) {\n+\t\t/* [...snip...] */\n+\t}\n+\t/* [...snip...] */\n+}"}, {"sha": "4272da96bab0faecc11367c2e837708c78eff2f8", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-CVE-2017-18550-1.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2017-18550-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2017-18550-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-CVE-2017-18550-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,175 @@\n+/* \"An issue was discovered in drivers/scsi/aacraid/commctrl.c in the \n+   Linux kernel before 4.13. There is potential exposure of kernel stack\n+   memory because aac_get_hba_info does not initialize the hbainfo structure.\"\n+\n+   Fixed e.g. by 342ffc26693b528648bdc9377e51e4f2450b4860 on linux-4.13.y\n+   in linux-stable.\n+\n+   This is a simplified version of that code (before and after the fix). */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include <string.h>\n+\n+typedef unsigned int __u32;\n+typedef unsigned int u32;\n+typedef unsigned char u8;\n+\n+#include \"test-uaccess.h\"\n+\n+/* Adapted from include/uapi/linux/types.h  */\n+\n+#define __bitwise\n+typedef __u32 __bitwise __le32;\n+\n+/* Adapted from drivers/scsi/aacraid/aacraid.h  */\n+\n+struct aac_hba_info {\n+\n+\tu8\tdriver_name[50]; /* { dg-message \"field 'driver_name' is uninitialized \\\\(50 bytes\\\\)\" } */\n+\tu8\tadapter_number;\n+\tu8\tsystem_io_bus_number;\n+\tu8\tdevice_number; /* { dg-message \"padding after field 'device_number' is uninitialized \\\\(3 bytes\\\\)\" } */\n+\tu32\tfunction_number;\n+\tu32\tvendor_id;\n+\tu32\tdevice_id;\n+\tu32\tsub_vendor_id;\n+\tu32\tsub_system_id;\n+\tu32\tmapped_base_address_size; /* { dg-message \"field 'mapped_base_address_size' is uninitialized \\\\(4 bytes\\\\)\"  } */\n+\tu32\tbase_physical_address_high_part;\n+\tu32\tbase_physical_address_low_part;\n+\n+\tu32\tmax_command_size;\n+\tu32\tmax_fib_size;\n+\tu32\tmax_scatter_gather_from_os;\n+\tu32\tmax_scatter_gather_to_fw;\n+\tu32\tmax_outstanding_fibs;\n+\n+\tu32\tqueue_start_threshold;\n+\tu32\tqueue_dump_threshold;\n+\tu32\tmax_io_size_queued;\n+\tu32\toutstanding_io;\n+\n+\tu32\tfirmware_build_number;\n+\tu32\tbios_build_number;\n+\tu32\tdriver_build_number;\n+\tu32\tserial_number_high_part;\n+\tu32\tserial_number_low_part;\n+\tu32\tsupported_options;\n+\tu32\tfeature_bits;\n+\tu32\tcurrentnumber_ports;\n+\n+\tu8\tnew_comm_interface:1; /* { dg-message \"field 'new_comm_interface' is uninitialized \\\\(1 bit\\\\)\" } */\n+\tu8\tnew_commands_supported:1;\n+\tu8\tdisable_passthrough:1;\n+\tu8\texpose_non_dasd:1;\n+\tu8\tqueue_allowed:1;\n+\tu8\tbled_check_enabled:1;\n+\tu8\treserved1:1;\n+\tu8\treserted2:1;\n+\n+\tu32\treserved3[10]; /* { dg-message \"field 'reserved3' is uninitialized \\\\(40 bytes\\\\)\" } */\n+\n+};\n+\n+struct aac_dev\n+{\n+\t/* [...snip...] */\n+\tint\t\t\tid;\n+\t/* [...snip...] */\n+\tstruct pci_dev\t\t*pdev;\t\t/* Our PCI interface */\n+\t/* [...snip...] */\n+};\n+\n+/* Adapted from include/linux/pci.h  */\n+\n+struct pci_dev {\n+\t/* [...snip...] */\n+\tstruct pci_bus\t*bus;\t\t/* bus this device is on */\n+\t/* [...snip...] */\n+\tunsigned int\tdevfn;\t\t/* encoded device & function index */\n+\tunsigned short\tvendor;\n+\tunsigned short\tdevice;\n+\tunsigned short\tsubsystem_vendor;\n+\tunsigned short\tsubsystem_device;\n+\t/* [...snip...] */\n+};\n+\n+struct pci_bus {\n+\t/* [...snip...] */\n+\tunsigned char\tnumber;\t\t/* bus number */\n+\t/* [...snip...] */\n+};\n+\n+/* Adapted from drivers/scsi/aacraid/commctrl.c  */\n+\n+static int aac_get_hba_info(struct aac_dev *dev, void __user *arg)\n+{\n+\tstruct aac_hba_info hbainfo; /* { dg-message \"region created on stack here\" \"memspace message\" } */\n+\t/* { dg-message \"capacity: 200 bytes\" \"capacity message\" { target *-*-* } .-1 } */\n+\n+\thbainfo.adapter_number\t\t= (u8) dev->id;\n+\thbainfo.system_io_bus_number\t= dev->pdev->bus->number;\n+\thbainfo.device_number\t\t= (dev->pdev->devfn >> 3);\n+\thbainfo.function_number\t\t= (dev->pdev->devfn & 0x0007);\n+\n+\thbainfo.vendor_id\t\t= dev->pdev->vendor;\n+\thbainfo.device_id\t\t= dev->pdev->device;\n+\thbainfo.sub_vendor_id\t\t= dev->pdev->subsystem_vendor;\n+\thbainfo.sub_system_id\t\t= dev->pdev->subsystem_device;\n+\n+\tif (copy_to_user(arg, &hbainfo, sizeof(struct aac_hba_info))) { /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+\t\t/* { dg-message \"177 bytes are uninitialized\" \"how much\" { target *-*-* } .-1 } */\n+\t\t/* [...snip...] */\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static int aac_get_hba_info_fixed(struct aac_dev *dev, void __user *arg)\n+{\n+\tstruct aac_hba_info hbainfo;\n+\n+\tmemset(&hbainfo, 0, sizeof(hbainfo));\n+\thbainfo.adapter_number\t\t= (u8) dev->id;\n+\thbainfo.system_io_bus_number\t= dev->pdev->bus->number;\n+\thbainfo.device_number\t\t= (dev->pdev->devfn >> 3);\n+\thbainfo.function_number\t\t= (dev->pdev->devfn & 0x0007);\n+\n+\thbainfo.vendor_id\t\t= dev->pdev->vendor;\n+\thbainfo.device_id\t\t= dev->pdev->device;\n+\thbainfo.sub_vendor_id\t\t= dev->pdev->subsystem_vendor;\n+\thbainfo.sub_system_id\t\t= dev->pdev->subsystem_device;\n+\n+\tif (copy_to_user(arg, &hbainfo, sizeof(struct aac_hba_info))) { /* { dg-bogus \"\" } */\n+\t\t/* [...snip...] */\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* An alternate fix using \"= {0}\" rather than memset.  */\n+\n+static int aac_get_hba_info_fixed_alt(struct aac_dev *dev, void __user *arg)\n+{\n+\tstruct aac_hba_info hbainfo = {0};\n+\n+\tmemset(&hbainfo, 0, sizeof(hbainfo));\n+\thbainfo.adapter_number\t\t= (u8) dev->id;\n+\thbainfo.system_io_bus_number\t= dev->pdev->bus->number;\n+\thbainfo.device_number\t\t= (dev->pdev->devfn >> 3);\n+\thbainfo.function_number\t\t= (dev->pdev->devfn & 0x0007);\n+\n+\thbainfo.vendor_id\t\t= dev->pdev->vendor;\n+\thbainfo.device_id\t\t= dev->pdev->device;\n+\thbainfo.sub_vendor_id\t\t= dev->pdev->subsystem_vendor;\n+\thbainfo.sub_system_id\t\t= dev->pdev->subsystem_device;\n+\n+\tif (copy_to_user(arg, &hbainfo, sizeof(struct aac_hba_info))) { /* { dg-bogus \"\" } */\n+\t\t/* [...snip...] */\n+\t}\n+\n+\treturn 0;\n+}"}, {"sha": "500845364388791c04754f3bc8fe33578f01cb4d", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-antipatterns-1.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-antipatterns-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-antipatterns-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-antipatterns-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,166 @@\n+/* Adapted and simplified decls from linux kernel headers.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+typedef unsigned char u8;\n+typedef unsigned __INT16_TYPE__ u16;\n+typedef unsigned __INT32_TYPE__ u32;\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define   EFAULT          14\n+\n+#include \"test-uaccess.h\"\n+\n+typedef unsigned int gfp_t;\n+#define GFP_KERNEL 0\n+\n+void kfree(const void *);\n+void *kmalloc(size_t size, gfp_t flags)\n+  __attribute__((malloc (kfree)));\n+\n+/* Adapted from antipatterns.ko:infoleak.c (GPL-v2.0).   */\n+\n+struct infoleak_buf\n+{\n+  char buf[256];\n+};\n+\n+int infoleak_stack_no_init(void __user *dst)\n+{\n+  struct infoleak_buf st; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 256 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+  \n+  /* No initialization of \"st\" at all.  */\n+  if (copy_to_user(dst, &st, sizeof(st))) /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+    /* { dg-message \"256 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+int infoleak_heap_no_init(void __user *dst)\n+{\n+  struct infoleak_buf *heapbuf = kmalloc(sizeof(*heapbuf), GFP_KERNEL);\n+  /* No initialization of \"heapbuf\" at all.  */\n+\n+  /* TODO: we also don't check that heapbuf could be NULL when copying\n+     from it.  */\n+  if (copy_to_user(dst, heapbuf, sizeof(*heapbuf))) /* { dg-warning \"exposure\" \"warning\" { xfail *-*-* } } */\n+    /* TODO(xfail).  */\n+    return -EFAULT; /* { dg-warning \"leak of 'heapbuf'\" } */\n+\n+  kfree(heapbuf);\n+  return 0;\n+}\n+\n+struct infoleak_2\n+{\n+  u32 a;\n+  u32 b; /* { dg-message \"field 'b' is uninitialized \\\\(4 bytes\\\\)\" } */\n+};\n+\n+int infoleak_stack_missing_a_field(void __user *dst, u32 v)\n+{\n+  struct infoleak_2 st; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 8 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+  \n+  st.a = v;\n+  /* No initialization of \"st.b\".  */\n+  if (copy_to_user(dst, &st, sizeof(st))) /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+    /* { dg-message \"4 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+int infoleak_heap_missing_a_field(void __user *dst, u32 v)\n+{\n+  struct infoleak_2 *heapbuf = kmalloc(sizeof(*heapbuf), GFP_KERNEL);\n+  heapbuf->a = v; /* { dg-warning \"dereference of possibly-NULL 'heapbuf'\" } */\n+  /* No initialization of \"heapbuf->b\".  */\n+  if (copy_to_user(dst, heapbuf, sizeof(*heapbuf))) /* { dg-warning \"exposure\" \"warning\" { xfail *-*-* } } */\n+    /* TODO(xfail).  */\n+    {\n+      kfree(heapbuf);\n+      return -EFAULT;\n+    }\n+  kfree(heapbuf);\n+  return 0;\n+}\n+\n+struct infoleak_3\n+{\n+  u8 a; /* { dg-message \"padding after field 'a' is uninitialized \\\\(3 bytes\\\\)\" } */\n+  /* padding here */\n+  u32 b;\n+};\n+\n+int infoleak_stack_padding(void __user *dst, u8 p, u32 q)\n+{\n+  struct infoleak_3 st; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 8 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+\n+  st.a = p;\n+  st.b = q;\n+  /* No initialization of padding.  */\n+  if (copy_to_user(dst, &st, sizeof(st))) /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+    /* { dg-message \"3 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+int infoleak_stack_unchecked_err(void __user *dst, void __user *src)\n+{\n+  struct infoleak_buf st;  /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 256 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+\n+  /*\n+   * If the copy_from_user call fails, then st is still uninitialized,\n+   * and if the copy_to_user call succeds, we have an infoleak.\n+   */\n+  int err = copy_from_user (&st, src, sizeof(st)); /* { dg-message \"when 'copy_from_user' fails\" } */\n+  err |= copy_to_user (dst, &st, sizeof(st)); /* { dg-warning \"exposure\" \"warning\" } */\n+  /* { dg-message \"256 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+  /* Actually, it's *up to* 256 bytes.  */\n+\n+  if (err)\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+struct infoleak_4\n+{\n+  union {\n+    u8 f1;\n+    u32 f2;\n+  } u;\n+};\n+\n+int infoleak_stack_union(void __user *dst, u8 v)\n+{\n+  struct infoleak_4 st;\n+  /*\n+   * This write only initializes the u8 within the union \"u\",\n+   * leaving the remaining 3 bytes uninitialized.\n+   */\n+  st.u.f1 = v;\n+  if (copy_to_user(dst, &st, sizeof(st))) /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+    /* { dg-message \"3 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+struct infoleak_5\n+{\n+  void *ptr;\n+};\n+\n+int infoleak_stack_kernel_ptr(void __user *dst, void *kp)\n+{\n+  struct infoleak_5 st;\n+  /* This writes a kernel-space pointer into a user space buffer.  */\n+  st.ptr = kp;\n+  if (copy_to_user(dst, &st, sizeof(st))) // TODO: we don't complain about this yet\n+    return -EFAULT;\n+  return 0;\n+}"}, {"sha": "6961b44f76b9e1b3338fcbaba2bb3c36e398d61f", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-fixit-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-fixit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-fixit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-fixit-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include <string.h>\n+\n+#include \"test-uaccess.h\"\n+\n+typedef unsigned char u8;\n+typedef unsigned int u32;\n+\n+struct st\n+{\n+  u8 i;  /* { dg-message \"padding after field 'i' is uninitialized \\\\(3 bytes\\\\)\" } */\n+  u32 j; /* { dg-message \"field 'j' is uninitialized \\\\(4 bytes\\\\)\" } */\n+};\n+\n+void test (void __user *dst, u8 a)\n+{\n+  struct st s; /* { dg-message \"region created on stack here\" \"where\" } */\n+  /* { dg-message \"capacity: 8 bytes\" \"capacity\" { target *-*-* } .-1 } */\n+  /* { dg-message \"suggest forcing zero-initialization by providing a '.0.' initializer\" \"fix-it hint\" { target *-*-* } .-2 } */  \n+  s.i = a;\n+  copy_to_user(dst, &s, sizeof (struct st)); /* { dg-warning \"potential exposure of sensitive information by copying uninitialized data from stack\" \"warning\" } */\n+  /* { dg-message \"7 bytes are uninitialized\" \"note how much\" { target *-*-* } .-1 } */\n+}"}, {"sha": "dce6e44ae130eee8ed4a943715078a653d043d06", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-net-ethtool-ioctl.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-net-ethtool-ioctl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-net-ethtool-ioctl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-net-ethtool-ioctl.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,82 @@\n+/* Reduced from infoleak false positive seen on Linux kernel with\n+   net/ethtool/ioctl.c  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+typedef signed char __s8;\n+typedef unsigned char __u8;\n+typedef unsigned int __u32;\n+typedef __s8 s8;\n+typedef __u32 u32;\n+enum { false = 0, true = 1 };\n+typedef unsigned long __kernel_ulong_t;\n+typedef __kernel_ulong_t __kernel_size_t;\n+typedef _Bool bool;\n+typedef __kernel_size_t size_t;\n+\n+void *memset(void *s, int c, size_t n);\n+\n+extern bool\n+check_copy_size(const void *addr, size_t bytes, bool is_source);\n+extern unsigned long\n+_copy_from_user(void *, const void *, unsigned long);\n+extern unsigned long\n+_copy_to_user(void *, const void *, unsigned long);\n+\n+static inline\n+__attribute__((__always_inline__)) unsigned long\n+copy_from_user(void *to, const void *from, unsigned long n) {\n+  if (__builtin_expect(!!(check_copy_size(to, n, false)), 1))\n+    n = _copy_from_user(to, from, n);\n+  return n;\n+}\n+static inline\n+__attribute__((__always_inline__)) unsigned long\n+copy_to_user(void *to, const void *from, unsigned long n) {\n+  if (__builtin_expect(!!(check_copy_size(from, n, true)), 1))\n+    n = _copy_to_user(to, from, n);\n+  return n;\n+}\n+enum ethtool_link_mode_bit_indices {\n+  __ETHTOOL_LINK_MODE_MASK_NBITS = 92\n+};\n+struct ethtool_link_settings {\n+  __u32 cmd;\n+  /* [...snip...] */\n+  __s8 link_mode_masks_nwords;\n+  /* [...snip...] */\n+};\n+\n+struct ethtool_link_ksettings {\n+  struct ethtool_link_settings base;\n+  u32 lanes;\n+};\n+\n+int ethtool_get_link_ksettings(void *useraddr) {\n+  int err = 0;\n+  struct ethtool_link_ksettings link_ksettings;\n+\n+  if (copy_from_user(&link_ksettings.base, useraddr,\n+                     sizeof(link_ksettings.base)))\n+    return -14;\n+\n+  if ((((__ETHTOOL_LINK_MODE_MASK_NBITS) + (32) - 1) / (32)) !=\n+      link_ksettings.base.link_mode_masks_nwords) {\n+\n+    memset(&link_ksettings, 0, sizeof(link_ksettings));\n+    link_ksettings.base.cmd = 0x0000004c;\n+\n+    link_ksettings.base.link_mode_masks_nwords =\n+        -((s8)(((__ETHTOOL_LINK_MODE_MASK_NBITS) + (32) - 1) / (32)));\n+\n+    if (copy_to_user(useraddr, &link_ksettings.base,\n+                     sizeof(link_ksettings.base)))\n+      return -14;\n+\n+    return 0;\n+  }\n+\n+  return 0;\n+}"}, {"sha": "51ad5db2bab2d4d0e3686b8ca7e937d8e06eb6ac", "filename": "gcc/testsuite/gcc.dg/plugin/infoleak-vfio_iommu_type1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-vfio_iommu_type1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-vfio_iommu_type1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Finfoleak-vfio_iommu_type1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,44 @@\n+/* Reduced from infoleak false positive in drivers/vfio/vfio_iommu_type1.c  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fanalyzer\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+typedef unsigned int u32;\n+typedef unsigned long long u64;\n+\n+unsigned long\n+copy_from_user(void *to, const void *from, unsigned long n);\n+\n+unsigned long\n+copy_to_user(void *to, const void *from, unsigned long n);\n+\n+struct vfio_iommu_type1_info {\n+  u32 argsz;\n+  u32 flags;\n+  u64 iova_pgsizes;\n+  u32 cap_offset;\n+  /* bytes 20-23 are padding.  */\n+};\n+\n+int vfio_iommu_type1_get_info(unsigned long arg)\n+{\n+  struct vfio_iommu_type1_info info;\n+  unsigned long minsz = 16;\n+\n+  if (copy_from_user(&info, (void *)arg, 16))\n+    return -14;\n+\n+  if (info.argsz < 16)\n+    return -22;\n+\n+  if (info.argsz >= 20) {\n+    minsz = 20;\n+    info.cap_offset = 0;\n+  }\n+\n+  /* The padding bytes (20-23) are uninitialized, but can't be written\n+     back, since minsz is either 16 or 20.  */\n+  return copy_to_user((void *)arg, &info, minsz) ? -14 : 0; /* { dg-bogus \"exposure\" \"\" { xfail *-*-* } } */\n+  // TODO: false +ve due to not handling minsz being either 16 or 20\n+}"}, {"sha": "5b7efa4afb6d30b9eb5e4b06c2fbde7e5670973e", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -125,6 +125,30 @@ set plugin_test_list [list \\\n \t  gil-1.c } \\\n     { analyzer_known_fns_plugin.c \\\n \t  known-fns-1.c } \\\n+    { analyzer_kernel_plugin.c \\\n+\t  copy_from_user-1.c \\\n+\t  infoleak-1.c \\\n+\t  infoleak-2.c \\\n+\t  infoleak-3.c \\\n+\t  infoleak-CVE-2011-1078-1.c \\\n+\t  infoleak-CVE-2011-1078-2.c \\\n+\t  infoleak-CVE-2017-18549-1.c \\\n+\t  infoleak-CVE-2017-18550-1.c \\\n+\t  infoleak-antipatterns-1.c \\\n+\t  infoleak-fixit-1.c \\\n+\t  infoleak-net-ethtool-ioctl.c \\\n+\t  infoleak-vfio_iommu_type1.c \\\n+\t  taint-CVE-2011-0521-1-fixed.c \\\n+\t  taint-CVE-2011-0521-1.c \\\n+\t  taint-CVE-2011-0521-2-fixed.c \\\n+\t  taint-CVE-2011-0521-2.c \\\n+\t  taint-CVE-2011-0521-3-fixed.c \\\n+\t  taint-CVE-2011-0521-3.c \\\n+\t  taint-CVE-2011-0521-4.c \\\n+\t  taint-CVE-2011-0521-5.c \\\n+\t  taint-CVE-2011-0521-5-fixed.c \\\n+\t  taint-CVE-2011-0521-6.c \\\n+\t  taint-antipatterns-1.c } \\\n ]\n \n foreach plugin_test $plugin_test_list {"}, {"sha": "0ca8137c3ef3967006abc5d5946ec9a07e1c7892", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-1-fixed.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-1-fixed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-1-fixed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-1-fixed.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+/* Adapted from drivers/media/dvb/ttpci/av7110_ca.c  */\n+\n+int dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg)\n+{\n+\tstruct dvb_device *dvbdev = file->private_data;\n+\tstruct av7110 *av7110 = dvbdev->priv;\n+\tunsigned long arg = (unsigned long) parg;\n+\n+\t/* case CA_GET_SLOT_INFO:  */\n+\t{\n+\t\tca_slot_info_t *info=(ca_slot_info_t *)parg;\n+\n+\t\tif (info->num < 0 || info->num > 1)\n+\t\t\treturn -EINVAL;\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-bogus \"attacker-controlled value\" } */\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t));\n+\t}\n+\treturn 0;\n+}\n+\n+static struct dvb_device dvbdev_ca = {\n+\t.priv\t\t= NULL,\n+\t/* [...snip...] */\n+\t.kernel_ioctl\t= dvb_ca_ioctl,\n+};\n+\n+/* Adapted from drivers/media/dvb/dvb-core/dvbdev.c  */\n+\n+static DEFINE_MUTEX(dvbdev_mutex);\n+\n+int dvb_usercopy(struct file *file,\n+\t\t     unsigned int cmd, unsigned long arg,\n+\t\t     int (*func)(struct file *file,\n+\t\t     unsigned int cmd, void *arg))\n+{\n+\tchar    sbuf[128];\n+\tvoid    *mbuf = NULL;\n+\tvoid    *parg = NULL;\n+\tint     err  = -1;\n+\n+\t/*  Copy arguments into temp kernel buffer  */\n+\tswitch (_IOC_DIR(cmd)) {\n+\tcase _IOC_NONE:\n+\t\t/*\n+\t\t * For this command, the pointer is actually an integer\n+\t\t * argument.\n+\t\t */\n+\t\tparg = (void *) arg;\n+\t\tbreak;\n+\tcase _IOC_READ: /* some v4l ioctls are marked wrong ... */\n+\tcase _IOC_WRITE:\n+\tcase (_IOC_WRITE | _IOC_READ):\n+\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n+\t\t\tparg = sbuf;\n+\t\t} else {\n+\t\t\t/* too big to allocate from stack */\n+\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);\n+\t\t\tif (NULL == mbuf)\n+\t\t\t\treturn -ENOMEM;\n+\t\t\tparg = mbuf;\n+\t\t}\n+\n+\t\terr = -EFAULT;\n+\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n+\t\t\tgoto out;\n+\t\tbreak;\n+\t}\n+\n+\t/* call driver */\n+\tmutex_lock(&dvbdev_mutex);\n+\tif ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)\n+\t\terr = -EINVAL;\n+\tmutex_unlock(&dvbdev_mutex);\n+\n+\tif (err < 0)\n+\t\tgoto out;\n+\n+\t/*  Copy results into user buffer  */\n+\tswitch (_IOC_DIR(cmd))\n+\t{\n+\tcase _IOC_READ:\n+\tcase (_IOC_WRITE | _IOC_READ):\n+\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n+\t\t\terr = -EFAULT;\n+\t\tbreak;\n+\t}\n+\n+out:\n+\tkfree(mbuf);\n+\treturn err;\n+}\n+\n+long dvb_generic_ioctl(struct file *file,\n+\t\t       unsigned int cmd, unsigned long arg)\n+{\n+\tstruct dvb_device *dvbdev = file->private_data;\n+\n+\tif (!dvbdev)\n+\t\treturn -ENODEV;\n+\n+\tif (!dvbdev->kernel_ioctl)\n+\t\treturn -EINVAL;\n+\n+\treturn dvb_usercopy(file, cmd, arg, dvbdev->kernel_ioctl);\n+}"}, {"sha": "cde12b3b761ce331e7281a5469bd1b754045b880", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-1.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,115 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+/* Adapted from drivers/media/dvb/ttpci/av7110_ca.c  */\n+\n+int dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg)\n+{\n+\tstruct dvb_device *dvbdev = file->private_data;\n+\tstruct av7110 *av7110 = dvbdev->priv;\n+\tunsigned long arg = (unsigned long) parg;\n+\n+\t/* case CA_GET_SLOT_INFO:  */\n+\t{\n+\t\tca_slot_info_t *info=(ca_slot_info_t *)parg;\n+\n+\t\tif (info->num > 1)\n+\t\t\treturn -EINVAL;\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-warning \"attacker-controlled value\" \"\" { xfail *-*-* } } */\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t));\n+\t}\n+\treturn 0;\n+}\n+\n+static struct dvb_device dvbdev_ca = {\n+\t.priv\t\t= NULL,\n+\t/* [...snip...] */\n+\t.kernel_ioctl\t= dvb_ca_ioctl,\n+};\n+\n+/* Adapted from drivers/media/dvb/dvb-core/dvbdev.c  */\n+\n+static DEFINE_MUTEX(dvbdev_mutex);\n+\n+int dvb_usercopy(struct file *file,\n+\t\t     unsigned int cmd, unsigned long arg,\n+\t\t     int (*func)(struct file *file,\n+\t\t     unsigned int cmd, void *arg))\n+{\n+\tchar    sbuf[128];\n+\tvoid    *mbuf = NULL;\n+\tvoid    *parg = NULL;\n+\tint     err  = -1;\n+\n+\t/*  Copy arguments into temp kernel buffer  */\n+\tswitch (_IOC_DIR(cmd)) {\n+\tcase _IOC_NONE:\n+\t\t/*\n+\t\t * For this command, the pointer is actually an integer\n+\t\t * argument.\n+\t\t */\n+\t\tparg = (void *) arg;\n+\t\tbreak;\n+\tcase _IOC_READ: /* some v4l ioctls are marked wrong ... */\n+\tcase _IOC_WRITE:\n+\tcase (_IOC_WRITE | _IOC_READ):\n+\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n+\t\t\tparg = sbuf;\n+\t\t} else {\n+\t\t\t/* too big to allocate from stack */\n+\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);\n+\t\t\tif (NULL == mbuf)\n+\t\t\t\treturn -ENOMEM;\n+\t\t\tparg = mbuf;\n+\t\t}\n+\n+\t\terr = -EFAULT;\n+\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n+\t\t\tgoto out;\n+\t\tbreak;\n+\t}\n+\n+\t/* call driver */\n+\tmutex_lock(&dvbdev_mutex);\n+\tif ((err = func(file, cmd, parg)) == -ENOIOCTLCMD)\n+\t\terr = -EINVAL;\n+\tmutex_unlock(&dvbdev_mutex);\n+\n+\tif (err < 0)\n+\t\tgoto out;\n+\n+\t/*  Copy results into user buffer  */\n+\tswitch (_IOC_DIR(cmd))\n+\t{\n+\tcase _IOC_READ:\n+\tcase (_IOC_WRITE | _IOC_READ):\n+\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n+\t\t\terr = -EFAULT;\n+\t\tbreak;\n+\t}\n+\n+out:\n+\tkfree(mbuf);\n+\treturn err;\n+}\n+\n+long dvb_generic_ioctl(struct file *file,\n+\t\t       unsigned int cmd, unsigned long arg)\n+{\n+\tstruct dvb_device *dvbdev = file->private_data;\n+\n+\tif (!dvbdev)\n+\t\treturn -ENODEV;\n+\n+\tif (!dvbdev->kernel_ioctl)\n+\t\treturn -EINVAL;\n+\n+\treturn dvb_usercopy(file, cmd, arg, dvbdev->kernel_ioctl);\n+}"}, {"sha": "8a211cefe4e5c79305bd4f2cd89aefe206dcd49a", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-2-fixed.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-2-fixed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-2-fixed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-2-fixed.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,98 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+/* Adapted from drivers/media/dvb/ttpci/av7110_ca.c  */\n+\n+int dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg)\n+{\n+\tstruct dvb_device *dvbdev = file->private_data;\n+\tstruct av7110 *av7110 = dvbdev->priv;\n+\tunsigned long arg = (unsigned long) parg;\n+\n+\t/* case CA_GET_SLOT_INFO:  */\n+\t{\n+\t\tca_slot_info_t *info=(ca_slot_info_t *)parg;\n+\n+\t\tif (info->num < 0 || info->num > 1)\n+\t\t\treturn -EINVAL;\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-bogus \"attacker-controlled value\" } */\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t));\n+\t}\n+\treturn 0;\n+}\n+\n+/* Adapted from drivers/media/dvb/dvb-core/dvbdev.c\n+   Somewhat simplified: rather than pass in a callback that can\n+   be dvb_ca_ioctl, call dvb_ca_ioctl directly.  */\n+\n+static DEFINE_MUTEX(dvbdev_mutex);\n+\n+int dvb_usercopy(struct file *file,\n+\t\t unsigned int cmd, unsigned long arg)\n+{\n+\tchar    sbuf[128];\n+\tvoid    *mbuf = NULL;\n+\tvoid    *parg = NULL;\n+\tint     err  = -1;\n+\n+\t/*  Copy arguments into temp kernel buffer  */\n+\tswitch (_IOC_DIR(cmd)) {\n+\tcase _IOC_NONE:\n+\t\t/*\n+\t\t * For this command, the pointer is actually an integer\n+\t\t * argument.\n+\t\t */\n+\t\tparg = (void *) arg;\n+\t\tbreak;\n+\tcase _IOC_READ: /* some v4l ioctls are marked wrong ... */\n+\tcase _IOC_WRITE:\n+\tcase (_IOC_WRITE | _IOC_READ):\n+\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n+\t\t\tparg = sbuf;\n+\t\t} else {\n+\t\t\t/* too big to allocate from stack */\n+\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);\n+\t\t\tif (NULL == mbuf)\n+\t\t\t\treturn -ENOMEM;\n+\t\t\tparg = mbuf;\n+\t\t}\n+\n+\t\terr = -EFAULT;\n+\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n+\t\t\tgoto out;\n+\t\tbreak;\n+\t}\n+\n+\t/* call driver */\n+\tmutex_lock(&dvbdev_mutex);\n+\tif ((err = dvb_ca_ioctl(file, cmd, parg)) == -ENOIOCTLCMD)\n+\t\terr = -EINVAL;\n+\tmutex_unlock(&dvbdev_mutex);\n+\n+\tif (err < 0)\n+\t\tgoto out;\n+\n+\t/*  Copy results into user buffer  */\n+\tswitch (_IOC_DIR(cmd))\n+\t{\n+\tcase _IOC_READ:\n+\tcase (_IOC_WRITE | _IOC_READ):\n+\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n+\t\t\terr = -EFAULT;\n+\t\tbreak;\n+\t}\n+\n+out:\n+\tkfree(mbuf);\n+\treturn err;\n+}"}, {"sha": "30cab38e002f033827113661bca102eb22b56ee0", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-2.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-2.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+/* Adapted from drivers/media/dvb/ttpci/av7110_ca.c  */\n+\n+int dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg)\n+{\n+\tstruct dvb_device *dvbdev = file->private_data;\n+\tstruct av7110 *av7110 = dvbdev->priv;\n+\tunsigned long arg = (unsigned long) parg;\n+\n+\t/* case CA_GET_SLOT_INFO:  */\n+\t{\n+\t\tca_slot_info_t *info=(ca_slot_info_t *)parg;\n+\n+\t\tif (info->num > 1)\n+\t\t\treturn -EINVAL;\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-warning \"attacker-controlled value\" \"\" { xfail *-*-* } } */\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t));\n+\t}\n+\treturn 0;\n+}\n+\n+/* Adapted from drivers/media/dvb/dvb-core/dvbdev.c\n+   Somewhat simplified: rather than pass in a callback that can\n+   be dvb_ca_ioctl, call dvb_ca_ioctl directly.  */\n+\n+static DEFINE_MUTEX(dvbdev_mutex);\n+\n+int dvb_usercopy(struct file *file,\n+\t\t unsigned int cmd, unsigned long arg)\n+{\n+\tchar    sbuf[128];\n+\tvoid    *mbuf = NULL;\n+\tvoid    *parg = NULL;\n+\tint     err  = -1;\n+\n+\t/*  Copy arguments into temp kernel buffer  */\n+\tswitch (_IOC_DIR(cmd)) {\n+\tcase _IOC_NONE:\n+\t\t/*\n+\t\t * For this command, the pointer is actually an integer\n+\t\t * argument.\n+\t\t */\n+\t\tparg = (void *) arg;\n+\t\tbreak;\n+\tcase _IOC_READ: /* some v4l ioctls are marked wrong ... */\n+\tcase _IOC_WRITE:\n+\tcase (_IOC_WRITE | _IOC_READ):\n+\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n+\t\t\tparg = sbuf;\n+\t\t} else {\n+\t\t\t/* too big to allocate from stack */\n+\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);\n+\t\t\tif (NULL == mbuf)\n+\t\t\t\treturn -ENOMEM;\n+\t\t\tparg = mbuf;\n+\t\t}\n+\n+\t\terr = -EFAULT;\n+\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n+\t\t\tgoto out;\n+\t\tbreak;\n+\t}\n+\n+\t/* call driver */\n+\tmutex_lock(&dvbdev_mutex);\n+\tif ((err = dvb_ca_ioctl(file, cmd, parg)) == -ENOIOCTLCMD)\n+\t\terr = -EINVAL;\n+\tmutex_unlock(&dvbdev_mutex);\n+\n+\tif (err < 0)\n+\t\tgoto out;\n+\n+\t/*  Copy results into user buffer  */\n+\tswitch (_IOC_DIR(cmd))\n+\t{\n+\tcase _IOC_READ:\n+\tcase (_IOC_WRITE | _IOC_READ):\n+\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n+\t\t\terr = -EFAULT;\n+\t\tbreak;\n+\t}\n+\n+out:\n+\tkfree(mbuf);\n+\treturn err;\n+}"}, {"sha": "b7852b40dcf86dda99d3d9bbafa78b26c07a9295", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-3-fixed.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-3-fixed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-3-fixed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-3-fixed.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+/* Adapted from drivers/media/dvb/ttpci/av7110_ca.c  */\n+\n+int dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg)\n+{\n+\tstruct dvb_device *dvbdev = file->private_data;\n+\tstruct av7110 *av7110 = dvbdev->priv;\n+\tunsigned long arg = (unsigned long) parg;\n+\n+\t/* case CA_GET_SLOT_INFO:  */\n+\t{\n+\t\tca_slot_info_t *info=(ca_slot_info_t *)parg;\n+\n+\t\tif (info->num < 0 || info->num > 1)\n+\t\t\treturn -EINVAL;\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-bogus \"attacker-controlled value\" } */\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t));\n+\t}\n+\treturn 0;\n+}\n+\n+/* Adapted from drivers/media/dvb/dvb-core/dvbdev.c\n+   Further simplified from -2; always use an on-stack buffer.  */\n+\n+static DEFINE_MUTEX(dvbdev_mutex);\n+\n+int dvb_usercopy(struct file *file,\n+\t\t unsigned int cmd, unsigned long arg)\n+{\n+\tchar    sbuf[128];\n+\tvoid    *parg = sbuf;\n+\tint     err = -EFAULT;\n+\tif (copy_from_user(parg, (void __user *)arg, sizeof(sbuf)))\n+\t  goto out;\n+\n+\tmutex_lock(&dvbdev_mutex);\n+\tif ((err = dvb_ca_ioctl(file, cmd, parg)) == -ENOIOCTLCMD)\n+\t\terr = -EINVAL;\n+\tmutex_unlock(&dvbdev_mutex);\n+\n+\tif (err < 0)\n+\t\tgoto out;\n+\n+\tif (copy_to_user((void __user *)arg, parg, sizeof(sbuf)))\n+\t  err = -EFAULT;\n+\n+out:\n+\treturn err;\n+}"}, {"sha": "6b9e034eea77514f3b7e571b5099f583b2a85261", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-3.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-3.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+/* Adapted from drivers/media/dvb/ttpci/av7110_ca.c  */\n+\n+int dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg)\n+{\n+\tstruct dvb_device *dvbdev = file->private_data;\n+\tstruct av7110 *av7110 = dvbdev->priv;\n+\tunsigned long arg = (unsigned long) parg;\n+\n+\t/* case CA_GET_SLOT_INFO:  */\n+\t{\n+\t\tca_slot_info_t *info=(ca_slot_info_t *)parg;\n+\n+\t\tif (info->num > 1)\n+\t\t\treturn -EINVAL;\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-warning \"attacker-controlled value\" \"\" { xfail *-*-* } } */\n+\t\t// TODO(xfail)\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t));\n+\t}\n+\treturn 0;\n+}\n+\n+/* Adapted from drivers/media/dvb/dvb-core/dvbdev.c\n+   Further simplified from -2; always use an on-stack buffer.  */\n+\n+static DEFINE_MUTEX(dvbdev_mutex);\n+\n+int dvb_usercopy(struct file *file,\n+\t\t unsigned int cmd, unsigned long arg)\n+{\n+\tchar    sbuf[128];\n+\tvoid    *parg = sbuf;\n+\tint     err = -EFAULT;\n+\tif (copy_from_user(parg, (void __user *)arg, sizeof(sbuf)))\n+\t  goto out;\n+\n+\tmutex_lock(&dvbdev_mutex);\n+\tif ((err = dvb_ca_ioctl(file, cmd, parg)) == -ENOIOCTLCMD)\n+\t\terr = -EINVAL;\n+\tmutex_unlock(&dvbdev_mutex);\n+\n+\tif (err < 0)\n+\t\tgoto out;\n+\n+\tif (copy_to_user((void __user *)arg, parg, sizeof(sbuf)))\n+\t  err = -EFAULT;\n+\n+out:\n+\treturn err;\n+}"}, {"sha": "f314c64ce70cbaaba5cab5bcd28dc2b602559db8", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-4.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-4.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+// TODO: remove need for --param=analyzer-max-svalue-depth=25 here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint --param=analyzer-max-svalue-depth=25\" } */\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+/* Adapted from dvb_ca_ioctl in drivers/media/dvb/ttpci/av7110_ca.c and\n+   dvb_usercopy in drivers/media/dvb/dvb-core/dvbdev.c\n+\n+   Further simplified from -3; merge into a single function; drop the mutex,\n+   remove control flow.  */\n+\n+int test_1(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tchar    sbuf[128];\n+\tvoid    *parg = sbuf;\n+\n+\tif (copy_from_user(parg, (void __user *)arg, sizeof(sbuf)))\n+\t  return -1;\n+\n+\t{\n+\t\tstruct dvb_device *dvbdev = file->private_data;\n+\t\tstruct av7110 *av7110 = dvbdev->priv;\n+\t\tunsigned long arg = (unsigned long) parg;\n+\n+\t\t/* case CA_GET_SLOT_INFO:  */\n+\t\tca_slot_info_t *info=(ca_slot_info_t *)parg;\n+\n+\t\tif (info->num > 1)\n+\t\t\treturn -EINVAL;\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-warning \"attacker-controlled value\" \"\" { xfail *-*-* } } */\n+\t\t// TODO(xfail)\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t));\n+\t}\n+\n+\tcopy_to_user((void __user *)arg, parg, sizeof(sbuf));\n+\n+\treturn 0;\n+}"}, {"sha": "8cb067c6542bba0c1dd1daa81f2d7213af62038b", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-5-fixed.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-5-fixed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-5-fixed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-5-fixed.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+// TODO: remove need for --param=analyzer-max-svalue-depth=25 here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint --param=analyzer-max-svalue-depth=25\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+/* Adapted from dvb_ca_ioctl in drivers/media/dvb/ttpci/av7110_ca.c and\n+   dvb_usercopy in drivers/media/dvb/dvb-core/dvbdev.c\n+\n+   Further simplified from -4; avoid parg and the cast to char[128].  */\n+\n+int test_1(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tca_slot_info_t sbuf;\n+\n+\tif (copy_from_user(&sbuf, (void __user *)arg, sizeof(sbuf)) != 0)\n+\t\treturn -1;\n+\n+\t{\n+\t\tstruct dvb_device *dvbdev = file->private_data;\n+\t\tstruct av7110 *av7110 = dvbdev->priv;\n+\n+\t\t/* case CA_GET_SLOT_INFO:  */\n+\t\tca_slot_info_t *info= &sbuf;\n+\n+\t\t__analyzer_dump_state (\"taint\", info->num); /* { dg-warning \"tainted\" } */\n+\n+\t\tif (info->num < 0 || info->num > 1)\n+\t\t\treturn -EINVAL;\n+\n+\t\t__analyzer_dump_state (\"taint\", info->num); /* { dg-warning \"stop\" } */\n+\n+\t\tav7110->ci_slot[info->num].num = info->num;\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t)); /* { dg-bogus \"use of attacker-controlled value in array lookup without bounds checking\" \"\" { xfail *-*-* } } */\n+\t\t// FIXME: why the above false +ve?\n+\t}\n+\n+\tcopy_to_user((void __user *)arg, &sbuf, sizeof(sbuf));\n+\n+\treturn 0;\n+}"}, {"sha": "4ce047902d3e4901513c6efcbdb926305e3290e6", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-5.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-5.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+// TODO: remove need for --param=analyzer-max-svalue-depth=25 here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint --param=analyzer-max-svalue-depth=25\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+/* Adapted from dvb_ca_ioctl in drivers/media/dvb/ttpci/av7110_ca.c and\n+   dvb_usercopy in drivers/media/dvb/dvb-core/dvbdev.c\n+\n+   Further simplified from -4; avoid parg and the cast to char[128].  */\n+\n+int test_1(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tca_slot_info_t sbuf;\n+\n+\tif (copy_from_user(&sbuf, (void __user *)arg, sizeof(sbuf)) != 0)\n+\t\treturn -1;\n+\n+\t{\n+\t\tstruct dvb_device *dvbdev = file->private_data;\n+\t\tstruct av7110 *av7110 = dvbdev->priv;\n+\n+\t\t/* case CA_GET_SLOT_INFO:  */\n+\t\tca_slot_info_t *info= &sbuf;\n+\n+\t\t__analyzer_dump_state (\"taint\", info->num); /* { dg-warning \"tainted\" } */\n+\n+\t\tif (info->num > 1)\n+\t\t\treturn -EINVAL;\n+\n+\t\t__analyzer_dump_state (\"taint\", info->num); /* { dg-warning \"has_ub\" } */\n+\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-warning \"use of attacker-controlled value '\\\\*info\\\\.num' in array lookup without checking for negative\" } */\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ? /* { dg-warning \"use of attacker-controlled value '\\\\*info\\\\.num' in array lookup without checking for negative\" } */\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t)); /* { dg-warning \"use of attacker-controlled value in array lookup without bounds checking\" } */\n+\t}\n+\n+\tcopy_to_user((void __user *)arg, &sbuf, sizeof(sbuf));\n+\n+\treturn 0;\n+}"}, {"sha": "c54af790a564ea312b6120dd8dd08e7c4cb047f5", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521-6.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521-6.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+// TODO: remove need for --param=analyzer-max-svalue-depth=25 here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint --param=analyzer-max-svalue-depth=25\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+/* See notes in this header.  */\n+#include \"taint-CVE-2011-0521.h\"\n+\n+/* Adapted from dvb_ca_ioctl in drivers/media/dvb/ttpci/av7110_ca.c and\n+   dvb_usercopy in drivers/media/dvb/dvb-core/dvbdev.c\n+\n+   Further simplified from -5; remove all control flow.  */\n+\n+int test_1(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tca_slot_info_t sbuf;\n+\n+\tif (copy_from_user(&sbuf, (void __user *)arg, sizeof(sbuf)) != 0)\n+\t\treturn -1;\n+\n+\t{\n+\t\tstruct dvb_device *dvbdev = file->private_data;\n+\t\tstruct av7110 *av7110 = dvbdev->priv;\n+\n+\t\t/* case CA_GET_SLOT_INFO:  */\n+\t\tca_slot_info_t *info= &sbuf;\n+\n+\t\t__analyzer_dump_state (\"taint\", info->num); /* { dg-warning \"tainted\" } */\n+\n+\t\t//__analyzer_break ();\n+\n+\t\tav7110->ci_slot[info->num].num = info->num; /* { dg-warning \"use of attacker-controlled value '\\\\*info\\\\.num' in array lookup without bounds checking\" } */\n+\t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?  /* { dg-warning \"use of attacker-controlled value '\\\\*info\\\\.num' in array lookup without bounds checking\" } */\n+\t\t\t\t\t\t\tCA_CI_LINK : CA_CI;\n+\t\tmemcpy(info, &av7110->ci_slot[info->num], sizeof(ca_slot_info_t));  /* { dg-warning \"use of attacker-controlled value in array lookup without bounds checking\" } */\n+\t}\n+\n+\tcopy_to_user((void __user *)arg, &sbuf, sizeof(sbuf));\n+\n+\treturn 0;\n+}"}, {"sha": "29f66b6e76e0cc1a6a276c37181b3fd00bd7fd76", "filename": "gcc/testsuite/gcc.dg/plugin/taint-CVE-2011-0521.h", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-CVE-2011-0521.h?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,136 @@\n+/* Shared header for the various taint-CVE-2011-0521-*.c tests.\n+   These are a series of successively simpler reductions of the reproducer.\n+   Ideally the analyzer would detect the issue in all of the testcases,\n+   but currently requires some simplification of the code to do so.\n+\n+   \"The dvb_ca_ioctl function in drivers/media/dvb/ttpci/av7110_ca.c in the\n+   Linux kernel before 2.6.38-rc2 does not check the sign of a certain integer\n+   field, which allows local users to cause a denial of service (memory\n+   corruption) or possibly have unspecified other impact via a negative value.\"\n+\n+   Adapted from Linux 2.6.38, which is under the GPLv2.\n+\n+   Fixed in e.g. cb26a24ee9706473f31d34cc259f4dcf45cd0644 on linux-2.6.38.y  */\n+\n+#include <string.h>\n+#include \"test-uaccess.h\"\n+#include \"../analyzer/analyzer-decls.h\"\n+\n+typedef unsigned int u32;\n+\n+/* Adapted from include/linux/compiler.h  */\n+\n+#define __force\n+\n+/* Adapted from include/asm-generic/errno-base.h  */\n+\n+#define\tENOMEM\t\t12\t/* Out of memory */\n+#define\tEFAULT\t\t14\t/* Bad address */\n+#define\tENODEV\t\t19\t/* No such device */\n+#define\tEINVAL\t\t22\t/* Invalid argument */\n+\n+/* Adapted from include/linux/errno.h  */\n+\n+#define ENOIOCTLCMD\t515\t/* No ioctl command */\n+\n+/* Adapted from include/linux/fs.h  */\n+\n+struct file {\n+\t/* [...snip...] */\n+\tvoid\t\t\t*private_data;\n+\t/* [...snip...] */\n+};\n+\n+/* Adapted from drivers/media/dvb/dvb-core/dvbdev.h  */\n+\n+struct dvb_device {\n+\t/* [...snip...] */\n+\tint (*kernel_ioctl)(struct file *file, unsigned int cmd, void *arg);\n+\n+\tvoid *priv;\n+};\n+\n+\n+/* Adapted from include/linux/dvb/ca.h  */\n+\n+typedef struct ca_slot_info {\n+\tint num;               /* slot number */\n+\n+\tint type;              /* CA interface this slot supports */\n+#define CA_CI            1     /* CI high level interface */\n+#define CA_CI_LINK       2     /* CI link layer level interface */\n+\t/* [...snip...] */\n+} ca_slot_info_t;\n+\n+\n+/* Adapted from drivers/media/dvb/ttpci/av7110.h  */\n+\n+struct av7110 {\n+\t/* [...snip...] */\n+\tca_slot_info_t\t\tci_slot[2];\n+\t/* [...snip...] */\n+\tu32\t\t    arm_app;\n+\t/* [...snip...] */\n+};\n+\n+/* Adapted from drivers/media/dvb/ttpci/av7110_hw.h  */\n+\n+#define FW_CI_LL_SUPPORT(arm_app) ((arm_app) & 0x80000000)\n+\n+/* Adapted from include/asm-generic/ioctl.h  */\n+\n+#define _IOC_NRBITS\t8\n+#define _IOC_TYPEBITS\t8\n+\n+#define _IOC_SIZEBITS\t14\n+#define _IOC_DIRBITS\t2\n+\n+#define _IOC_SIZEMASK\t((1 << _IOC_SIZEBITS)-1)\n+#define _IOC_DIRMASK\t((1 << _IOC_DIRBITS)-1)\n+#define _IOC_NRSHIFT\t0\n+#define _IOC_TYPESHIFT\t(_IOC_NRSHIFT+_IOC_NRBITS)\n+#define _IOC_SIZESHIFT\t(_IOC_TYPESHIFT+_IOC_TYPEBITS)\n+#define _IOC_DIRSHIFT\t(_IOC_SIZESHIFT+_IOC_SIZEBITS)\n+\n+#define _IOC_NONE\t0U\n+#define _IOC_WRITE\t1U\n+#define _IOC_READ\t2U\n+\n+#define _IOC_DIR(nr)\t\t(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)\n+#define _IOC_SIZE(nr)\t\t(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)\n+\n+/* Adapted from include/linux/mutex.h  */\n+\n+struct mutex {\n+\t/* [...snip...] */\n+};\n+\n+#define __MUTEX_INITIALIZER(lockname) \\\n+\t\t{ /* [...snip...] */ }\n+\n+#define DEFINE_MUTEX(mutexname) \\\n+\tstruct mutex mutexname = __MUTEX_INITIALIZER(mutexname)\n+\n+extern void mutex_lock(struct mutex *lock);\n+extern void mutex_unlock(struct mutex *lock);\n+\n+/* Adapted from include/linux/types.h  */\n+\n+#define __bitwise__\n+typedef unsigned __bitwise__ gfp_t;\n+\n+/* Adapted from include/linux/gfp.h  */\n+\n+#define ___GFP_WAIT\t\t0x10u\n+#define ___GFP_IO\t\t0x40u\n+#define ___GFP_FS\t\t0x80u\n+#define __GFP_WAIT\t((__force gfp_t)___GFP_WAIT)\n+#define __GFP_IO\t((__force gfp_t)___GFP_IO)\n+#define __GFP_FS\t((__force gfp_t)___GFP_FS)\n+#define GFP_KERNEL  (__GFP_WAIT | __GFP_IO | __GFP_FS)\n+\n+/* Adapted from include/linux/slab.h  */\n+\n+void kfree(const void *);\n+void *kmalloc(size_t size, gfp_t flags)\n+  __attribute__((malloc (kfree)));"}, {"sha": "6bb6f1be25cab3b1ea9b9353829a1a34adce15cd", "filename": "gcc/testsuite/gcc.dg/plugin/taint-antipatterns-1.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-antipatterns-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-antipatterns-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftaint-antipatterns-1.c?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,139 @@\n+/* { dg-do compile } */\n+// TODO: remove need for -fanalyzer-checker=taint here:\n+/* { dg-options \"-fanalyzer -fanalyzer-checker=taint\" } */\n+/* { dg-require-effective-target analyzer } */\n+\n+#include \"test-uaccess.h\"\n+\n+/* Adapted and simplified decls from linux kernel headers.  */\n+\n+typedef unsigned char u8;\n+typedef unsigned __INT16_TYPE__ u16;\n+typedef unsigned __INT32_TYPE__ u32;\n+typedef signed __INT32_TYPE__ s32;\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define   EFAULT          14\n+\n+typedef unsigned int gfp_t;\n+#define GFP_KERNEL 0\n+\n+void kfree(const void *);\n+void *kmalloc(size_t size, gfp_t flags)\n+  __attribute__((malloc (kfree)));\n+\n+/* Adapted from antipatterns.ko:taint.c (GPL-v2.0).   */\n+\n+struct cmd_1\n+{\n+  u32 idx;\n+  u32 val;\n+};\n+\n+static u32 arr[16];\n+\n+int taint_array_access(void __user *src)\n+{\n+  struct cmd_1 cmd;\n+  if (copy_from_user(&cmd, src, sizeof(cmd)))\n+    return -EFAULT;\n+  /*\n+   * cmd.idx is an unsanitized value from user-space, hence\n+   * this is an arbitrary kernel memory access.\n+   */\n+  arr[cmd.idx] = cmd.val; /* { dg-warning \"use of attacker-controlled value 'cmd.idx' in array lookup without upper-bounds checking\" } */\n+  return 0;\n+}\n+\n+struct cmd_2\n+{\n+  s32 idx;\n+  u32 val;\n+};\n+\n+int taint_signed_array_access(void __user *src)\n+{\n+  struct cmd_2 cmd;\n+  if (copy_from_user(&cmd, src, sizeof(cmd)))\n+    return -EFAULT;\n+  if (cmd.idx >= 16)\n+    return -EFAULT;\n+\n+  /*\n+   * cmd.idx hasn't been checked for being negative, hence\n+   * this is an arbitrary kernel memory access.\n+   */\n+  arr[cmd.idx] = cmd.val; /* { dg-warning \"use of attacker-controlled value 'cmd.idx' in array lookup without checking for negative\" } */\n+  return 0;\n+}\n+\n+struct cmd_s32_binop\n+{\n+  s32 a;\n+  s32 b;\n+  s32 result;\n+};\n+\n+int taint_divide_by_zero_direct(void __user *uptr)\n+{\n+  struct cmd_s32_binop cmd;\n+  if (copy_from_user(&cmd, uptr, sizeof(cmd)))\n+    return -EFAULT;\n+\n+  /* cmd.b is attacker-controlled and could be zero */\n+  cmd.result = cmd.a / cmd.b; /* { dg-warning \"use of attacker-controlled value 'cmd.b' as divisor without checking for zero\" } */\n+\n+  if (copy_to_user (uptr, &cmd, sizeof(cmd)))\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+int taint_divide_by_zero_compound(void __user *uptr)\n+{\n+  struct cmd_s32_binop cmd;\n+  if (copy_from_user(&cmd, uptr, sizeof(cmd)))\n+    return -EFAULT;\n+\n+  /*\n+   * cmd.b is attacker-controlled and could be -1, hence\n+   * the divisor could be zero\n+   */\n+  cmd.result = cmd.a / (cmd.b + 1); /* { dg-warning \"use of attacker-controlled value 'cmd.b \\\\+ 1' as divisor without checking for zero\" } */\n+\n+  if (copy_to_user (uptr, &cmd, sizeof(cmd)))\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+int taint_mod_by_zero_direct(void __user *uptr)\n+{\n+  struct cmd_s32_binop cmd;\n+  if (copy_from_user(&cmd, uptr, sizeof(cmd)))\n+    return -EFAULT;\n+\n+  /* cmd.b is attacker-controlled and could be zero */\n+  cmd.result = cmd.a % cmd.b; /* { dg-warning \"use of attacker-controlled value 'cmd.b' as divisor without checking for zero\" } */\n+\n+  if (copy_to_user (uptr, &cmd, sizeof(cmd)))\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+int taint_mod_by_zero_compound(void __user *uptr)\n+{\n+  struct cmd_s32_binop cmd;\n+  if (copy_from_user(&cmd, uptr, sizeof(cmd)))\n+    return -EFAULT;\n+\n+  /*\n+   * cmd.b is attacker-controlled and could be -1, hence\n+   * the divisor could be zero\n+   */\n+  cmd.result = cmd.a % (cmd.b + 1); /* { dg-warning \"use of attacker-controlled value 'cmd.b \\\\+ 1' as divisor without checking for zero\" } */\n+\n+  if (copy_to_user (uptr, &cmd, sizeof(cmd)))\n+    return -EFAULT;\n+  return 0;\n+}\n+\n+/* TODO: etc.  */"}, {"sha": "42eac9852589ba19166f1fbce1c1799b6fd5c861", "filename": "gcc/testsuite/gcc.dg/plugin/test-uaccess.h", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftest-uaccess.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c81b60b8c6ff3d4db2e395a628e114df812cfc48/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftest-uaccess.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Ftest-uaccess.h?ref=c81b60b8c6ff3d4db2e395a628e114df812cfc48", "patch": "@@ -0,0 +1,10 @@\n+/* Shared header for testcases for copy_from_user/copy_to_user.  */\n+\n+/* Adapted from include/linux/compiler.h  */\n+\n+#define __user\n+\n+/* Adapted from include/asm-generic/uaccess.h  */\n+\n+extern long copy_from_user(void *to, const void __user *from, long n);\n+extern long copy_to_user(void __user *to, const void *from, long n);"}]}