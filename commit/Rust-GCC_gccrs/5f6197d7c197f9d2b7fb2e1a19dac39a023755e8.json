{"sha": "5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "node_id": "C_kwDOANBUbNoAKDVmNjE5N2Q3YzE5N2Y5ZDJiN2ZiMmUxYTE5ZGFjMzlhMDIzNzU1ZTg", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-25T00:58:10Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-25T00:58:10Z"}, "message": "analyzer: add region::tracked_p to optimize state objects [PR104954]\n\nPR analyzer/104954 tracks that -fanalyzer was taking a very long time\non a particular source file in the Linux kernel:\n  drivers/gpu/drm/amd/display/dc/calcs/dce_calcs.c\n\nOne issue occurs with the repeated use of dynamic debug lines e.g. via\nthe DC_LOG_BANDWIDTH_CALCS macro, such as in print_bw_calcs_dceip in\ndrivers/gpu/drm/amd/display/dc/calcs/calcs_logger.h:\n\n  DC_LOG_BANDWIDTH_CALCS(\"#####################################################################\");\n  DC_LOG_BANDWIDTH_CALCS(\"struct bw_calcs_dceip\");\n  DC_LOG_BANDWIDTH_CALCS(\"#####################################################################\");\n\n  [...snip dozens of lines...]\n\n  DC_LOG_BANDWIDTH_CALCS(\"[bw_fixed] dmif_request_buffer_size: %d\",\n                         bw_fixed_to_int(dceip->dmif_request_buffer_size));\n\nWhen this is configured to use __dynamic_pr_debug, each of these becomes\ncode like:\n\n  do {\n    static struct _ddebug __attribute__((__aligned__(8)))\n    __attribute__((__section__(\"__dyndbg\"))) __UNIQUE_ID_ddebug277 = {\n      [...snip...]\n    };\n    if (arch_static_branch(&__UNIQUE_ID_ddebug277.key, false))\n      __dynamic_pr_debug(&__UNIQUE_ID_ddebug277, [...the message...]);\n  } while (0);\n\nThe analyzer was naively seeing each call to __dynamic_pr_debug, noting\nthat the __UNIQUE_ID_nnnn object escapes.  At each call, as successive\n__UNIQUE_ID_nnnn object escapes, there are N escaped objects, and thus N\nneed clobbering, and so we have O(N^2) clobbering of escaped objects overall,\nleading to huge amounts of pointless work: print_bw_calcs_data has 225\nuses of DC_LOG_BANDWIDTH_CALCS, many of which are in loops.\n\nThis patch adds a way to identify declarations that aren't interesting\nto the analyzer, so that we don't attempt to create binding_clusters\nfor them (i.e. we don't store any state for them in our state objects).\nThis is implemented by adding a new region::tracked_p, implemented for\ndeclarations by walking the existing IPA data the first time the\nanalyzer sees a declaration, setting it to false for global vars that\nhave no loads/stores/aliases, and \"sufficiently safe\" address-of\nipa-refs.\n\nThe patch gives a large speedup of -fanalyzer on the above kernel\nsource file:\n                           Before  After\nTotal cc1 wallclock time:    180s    36s\nanalyzer wallclock time:     162s    17s\n% spent in analyzer:          90%    47%\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/104954\n\t* analyzer.opt (-fdump-analyzer-untracked): New option.\n\t* engine.cc (impl_run_checkers): Handle it.\n\t* region-model-asm.cc (region_model::on_asm_stmt): Don't attempt\n\tto clobber regions with !tracked_p ().\n\t* region-model-manager.cc (dump_untracked_region): New.\n\t(region_model_manager::dump_untracked_regions): New.\n\t(frame_region::dump_untracked_regions): New.\n\t* region-model.h (region_model_manager::dump_untracked_regions):\n\tNew decl.\n\t* region.cc (ipa_ref_requires_tracking): New.\n\t(symnode_requires_tracking_p): New.\n\t(decl_region::calc_tracked_p): New.\n\t* region.h (region::tracked_p): New vfunc.\n\t(frame_region::dump_untracked_regions): New decl.\n\t(class decl_region): Note that this is also used fo SSA names.\n\t(decl_region::decl_region): Initialize m_tracked.\n\t(decl_region::tracked_p): New.\n\t(decl_region::calc_tracked_p): New decl.\n\t(decl_region::m_tracked): New.\n\t* store.cc (store::get_or_create_cluster): Assert that we\n\tdon't try to create clusters for base regions that aren't\n\ttrackable.\n\t(store::mark_as_escaped): Don't mark base regions that we're not\n\ttracking.\n\ngcc/ChangeLog:\n\tPR analyzer/104954\n\t* doc/invoke.texi (Static Analyzer Options): Add\n\t-fdump-analyzer-untracked.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/104954\n\t* gcc.dg/analyzer/asm-x86-dyndbg-1.c: New test.\n\t* gcc.dg/analyzer/asm-x86-dyndbg-2.c: New test.\n\t* gcc.dg/analyzer/many-unused-locals.c: New test.\n\t* gcc.dg/analyzer/untracked-1.c: New test.\n\t* gcc.dg/analyzer/unused-local-1.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "55c78e08c0ae81516a4c8708283d76352ae64b52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55c78e08c0ae81516a4c8708283d76352ae64b52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "319ba7e241e7e21f9eb481f075310796f13d2035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/319ba7e241e7e21f9eb481f075310796f13d2035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/319ba7e241e7e21f9eb481f075310796f13d2035"}], "stats": {"total": 569, "additions": 565, "deletions": 4}, "files": [{"sha": "a0ba2c94fb3f49a74999ee87802d8813d0364398", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -250,4 +250,8 @@ fdump-analyzer-supergraph\n Common RejectNegative Var(flag_dump_analyzer_supergraph)\n Dump the analyzer supergraph to a SRCFILE.supergraph.dot file.\n \n+fdump-analyzer-untracked\n+Common RejectNegative Var(flag_dump_analyzer_untracked)\n+Emit custom warnings with internal details intended for analyzer developers.\n+\n ; This comment is to ensure we retain the blank line above."}, {"sha": "d8b61955aa64a16e3be4b811da36bfd21a8181f0", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -5811,6 +5811,9 @@ impl_run_checkers (logger *logger)\n   if (flag_dump_analyzer_json)\n     dump_analyzer_json (sg, eg);\n \n+  if (flag_dump_analyzer_untracked)\n+    eng.get_model_manager ()->dump_untracked_regions ();\n+\n   delete purge_map;\n }\n "}, {"sha": "c7389f0e38ddde908e31d55d23e51fef3faab5d5", "filename": "gcc/analyzer/region-model-asm.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion-model-asm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion-model-asm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-asm.cc?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -267,7 +267,8 @@ region_model::on_asm_stmt (const gasm *stmt, region_model_context *ctxt)\n        iter != reachable_regs.end_mutable_base_regs (); ++iter)\n     {\n       const region *base_reg = *iter;\n-      if (base_reg->symbolic_for_unknown_ptr_p ())\n+      if (base_reg->symbolic_for_unknown_ptr_p ()\n+\t  || !base_reg->tracked_p ())\n \tcontinue;\n \n       binding_cluster *cluster = m_store.get_or_create_cluster (base_reg);"}, {"sha": "61c7fb32628bbb3a5959868d52d9b43eb038809b", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -1740,6 +1740,47 @@ store_manager::log_stats (logger *logger, bool show_objs) const\n \t\tm_symbolic_binding_key_mgr);\n }\n \n+/* Emit a warning showing DECL_REG->tracked_p () for use in DejaGnu tests\n+   (using -fdump-analyzer-untracked).  */\n+\n+static void\n+dump_untracked_region (const decl_region *decl_reg)\n+{\n+  tree decl = decl_reg->get_decl ();\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return;\n+  warning_at (DECL_SOURCE_LOCATION (decl), 0,\n+\t      \"track %qD: %s\",\n+\t      decl, (decl_reg->tracked_p () ? \"yes\" : \"no\"));\n+}\n+\n+/* Implementation of -fdump-analyzer-untracked.  */\n+\n+void\n+region_model_manager::dump_untracked_regions () const\n+{\n+  for (auto iter : m_globals_map)\n+    {\n+      const decl_region *decl_reg = iter.second;\n+      dump_untracked_region (decl_reg);\n+    }\n+  for (auto frame_iter : m_frame_regions)\n+    {\n+      const frame_region *frame_reg = frame_iter.second;\n+      frame_reg->dump_untracked_regions ();\n+    }\n+}\n+\n+void\n+frame_region::dump_untracked_regions () const\n+{\n+  for (auto iter : m_locals)\n+    {\n+      const decl_region *decl_reg = iter.second;\n+      dump_untracked_region (decl_reg);\n+    }\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "13a2ea94a3fc5788661383b96ad814222d19cdc1", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -349,6 +349,8 @@ class region_model_manager\n \n   logger *get_logger () const { return m_logger; }\n \n+  void dump_untracked_regions () const;\n+\n private:\n   bool too_complex_p (const complexity &c) const;\n   bool reject_if_too_complex (svalue *sval);"}, {"sha": "9c9e043c658dd7ebfaafb2104137bd9dd7e945bf", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -1167,6 +1167,94 @@ decl_region::get_svalue_for_initializer (region_model_manager *mgr) const\n   return m.get_rvalue (path_var (init, 0), NULL);\n }\n \n+/* Subroutine of symnode_requires_tracking_p; return true if REF\n+   within CONTEXT_FNDECL might imply that we should be tracking the\n+   value of a decl.  */\n+\n+static bool\n+ipa_ref_requires_tracking (const ipa_ref *ref, tree context_fndecl)\n+{\n+  /* If we have a load/store/alias of the symbol, then we'll track\n+     the decl's value.  */\n+  if (ref->use != IPA_REF_ADDR)\n+    return true;\n+\n+  if (ref->stmt == NULL)\n+    return true;\n+\n+  switch (ref->stmt->code)\n+    {\n+    default:\n+      return true;\n+    case GIMPLE_CALL:\n+      {\n+\tcgraph_node *context_cnode = cgraph_node::get (context_fndecl);\n+\tcgraph_edge *edge = context_cnode->get_edge (ref->stmt);\n+\tif (!edge)\n+\t  return true;\n+\tif (edge->callee == NULL)\n+\t  return true; /* e.g. call through function ptr.  */\n+\tif (edge->callee->definition)\n+\t  return true;\n+\t/* If we get here, then this ref is a pointer passed to\n+\t   a function we don't have the definition for.  */\n+\treturn false;\n+      }\n+      break;\n+    case GIMPLE_ASM:\n+      {\n+\tconst gasm *asm_stmt = as_a <const gasm *> (ref->stmt);\n+\tif (gimple_asm_noutputs (asm_stmt) > 0)\n+\t  return true;\n+\tif (gimple_asm_nclobbers (asm_stmt) > 0)\n+\t  return true;\n+\t/* If we get here, then this ref is the decl being passed\n+\t   by pointer to asm with no outputs.  */\n+\treturn false;\n+      }\n+      break;\n+    }\n+}\n+\n+/* Determine if the decl for SYMNODE should have binding_clusters\n+   in our state objects; return false to optimize away tracking\n+   certain decls in our state objects, as an optimization.  */\n+\n+static bool\n+symnode_requires_tracking_p (symtab_node *symnode)\n+{\n+  gcc_assert (symnode);\n+  if (symnode->externally_visible)\n+    return true;\n+  tree context_fndecl = DECL_CONTEXT (symnode->decl);\n+  if (context_fndecl == NULL)\n+    return true;\n+  if (TREE_CODE (context_fndecl) != FUNCTION_DECL)\n+    return true;\n+  for (auto ref : symnode->ref_list.referring)\n+    if (ipa_ref_requires_tracking (ref, context_fndecl))\n+      return true;\n+\n+  /* If we get here, then we don't have uses of this decl that require\n+     tracking; we never read from it or write to it explicitly.  */\n+  return false;\n+}\n+\n+/* Subroutine of decl_region ctor: determine whether this decl_region\n+   can have binding_clusters; return false to optimize away tracking\n+   of certain decls in our state objects, as an optimization.  */\n+\n+bool\n+decl_region::calc_tracked_p (tree decl)\n+{\n+  /* Precondition of symtab_node::get.  */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl) || in_lto_p))\n+    if (symtab_node *symnode = symtab_node::get (decl))\n+      return symnode_requires_tracking_p (symnode);\n+  return true;\n+}\n+\n /* class field_region : public region.  */\n \n /* Implementation of region::dump_to_pp vfunc for field_region.  */"}, {"sha": "5150be76d0ba09878deb40c161e5ef797e8f508d", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -197,6 +197,11 @@ class region\n \n   bool symbolic_for_unknown_ptr_p () const;\n \n+  /* For most base regions it makes sense to track the bindings of the region\n+     within the store.  As an optimization, some are not tracked (to avoid\n+     bloating the store object with redundant binding clusters).  */\n+  virtual bool tracked_p () const { return true; }\n+\n   const complexity &get_complexity () const { return m_complexity; }\n \n   bool is_named_decl_p (const char *decl_name) const;\n@@ -319,6 +324,9 @@ class frame_region : public space_region\n \n   unsigned get_num_locals () const { return m_locals.elements (); }\n \n+  /* Implemented in region-model-manager.cc.  */\n+  void dump_untracked_regions () const;\n+\n  private:\n   const frame_region *m_calling_frame;\n   function *m_fun;\n@@ -633,13 +641,15 @@ template <> struct default_hash_traits<symbolic_region::key_t>\n namespace ana {\n \n /* Concrete region subclass representing the memory occupied by a\n-   variable (whether for a global or a local).  */\n+   variable (whether for a global or a local).\n+   Also used for representing SSA names, as if they were locals.  */\n \n class decl_region : public region\n {\n public:\n   decl_region (unsigned id, const region *parent, tree decl)\n-  : region (complexity (parent), id, parent, TREE_TYPE (decl)), m_decl (decl)\n+  : region (complexity (parent), id, parent, TREE_TYPE (decl)), m_decl (decl),\n+    m_tracked (calc_tracked_p (decl))\n   {}\n \n   enum region_kind get_kind () const FINAL OVERRIDE { return RK_DECL; }\n@@ -648,6 +658,8 @@ class decl_region : public region\n \n   void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n \n+  bool tracked_p () const FINAL OVERRIDE { return m_tracked; }\n+\n   tree get_decl () const { return m_decl; }\n   int get_stack_depth () const;\n \n@@ -657,7 +669,15 @@ class decl_region : public region\n   const svalue *get_svalue_for_initializer (region_model_manager *mgr) const;\n \n private:\n+  static bool calc_tracked_p (tree decl);\n+\n   tree m_decl;\n+\n+  /* Cached result of calc_tracked_p, so that we can quickly determine when\n+     we don't to track a binding_cluster for this decl (to avoid bloating\n+     store objects).\n+     This can be debugged using -fdump-analyzer-untracked.  */\n+  bool m_tracked;\n };\n \n } // namespace ana"}, {"sha": "62733b9777ff4205863cf4f3feedc4243a27b8af", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -2654,6 +2654,9 @@ store::get_or_create_cluster (const region *base_reg)\n   /* We shouldn't create clusters for dereferencing an UNKNOWN ptr.  */\n   gcc_assert (!base_reg->symbolic_for_unknown_ptr_p ());\n \n+  /* We shouldn't create clusters for base regions that aren't trackable.  */\n+  gcc_assert (base_reg->tracked_p ());\n+\n   if (binding_cluster **slot = m_cluster_map.get (base_reg))\n     return *slot;\n \n@@ -2742,7 +2745,8 @@ store::mark_as_escaped (const region *base_reg)\n   gcc_assert (base_reg);\n   gcc_assert (base_reg->get_base_region () == base_reg);\n \n-  if (base_reg->symbolic_for_unknown_ptr_p ())\n+  if (base_reg->symbolic_for_unknown_ptr_p ()\n+      || !base_reg->tracked_p ())\n     return;\n \n   binding_cluster *cluster = get_or_create_cluster (base_reg);"}, {"sha": "afb21d9154c98131001803e66a5fd4c9a5c072d5", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -439,6 +439,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-analyzer-state-purge @gol\n -fdump-analyzer-stderr @gol\n -fdump-analyzer-supergraph @gol\n+-fdump-analyzer-untracked @gol\n -Wno-analyzer-double-fclose @gol\n -Wno-analyzer-double-free @gol\n -Wno-analyzer-exposure-through-output-file @gol\n@@ -10212,6 +10213,10 @@ control flow graphs in the program, with interprocedural edges for\n calls and returns.  The second dump contains annotations showing nodes\n in the ``exploded graph'' and diagnostics associated with them.\n \n+@item -fdump-analyzer-untracked\n+@opindex fdump-analyzer-untracked\n+Emit custom warnings with internal details intended for analyzer developers.\n+\n @end table\n \n @node Debugging Options"}, {"sha": "cce3f6b80bcdd5fea8b6e7b0586915b1c2bdf199", "filename": "gcc/testsuite/gcc.dg/analyzer/asm-x86-dyndbg-1.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-dyndbg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-dyndbg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-dyndbg-1.c?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -0,0 +1,126 @@\n+/* Test reduced from use of dynamic_pr_debug on Linux kernel, to verify that\n+   we treat the static struct _ddebug as not needing to be tracked by the\n+   analyzer, thus optimizing away bloat in the analyzer's state tracking.  */\n+\n+/* { dg-do compile { target x86_64-*-* } } */\n+/* { dg-additional-options \"-fdump-analyzer-untracked\" } */\n+\n+/* Adapted from various files in the Linux kernel, all of which have:  */\n+/* SPDX-License-Identifier: GPL-2.0 */\n+\n+typedef _Bool\t\t\tbool;\n+#define true 1\n+#define false 0\n+\n+typedef struct {\n+\tint counter;\n+} atomic_t;\n+\n+/* Adapted from include/linux/compiler_attributes.h  */\n+#define __always_inline                 inline __attribute__((__always_inline__))\n+\n+/* Adapted from include/linux/compiler-gcc.h */\n+#define asm_volatile_goto(x...)\tdo { asm goto(x); asm (\"\"); } while (0)\n+\n+/* Adapted from include/linux/jump_label.h, which has:  */\n+\n+struct static_key {\n+\tatomic_t enabled;\n+\tunion {\n+\t\t/* [...snip...] */\n+\t\tstruct jump_entry *entries;\n+\t\t/* [...snip...] */\n+\t};\n+};\n+\n+struct static_key_true {\n+\tstruct static_key key;\n+};\n+\n+struct static_key_false {\n+\tstruct static_key key;\n+};\n+\n+extern bool ____wrong_branch_error(void);\n+\n+/* Adapted from arch/x86/include/asm/jump_label.h */\n+\n+#define JUMP_TABLE_ENTRY\t\t\t\t\\\n+\t\".pushsection __jump_table,  \\\"aw\\\" \\n\\t\"\t\\\n+\t/*_ASM_ALIGN*/ \"\\n\\t\"\t\t\t\t\\\n+\t\".long 1b - . \\n\\t\"\t\t\t\t\\\n+\t\".long %l[l_yes] - . \\n\\t\"\t\t\t\\\n+\t/*_ASM_PTR*/ \"%c0 + %c1 - .\\n\\t\"\t\t\\\n+\t\".popsection \\n\\t\"\n+\n+static __always_inline bool arch_static_branch(struct static_key * const key, const bool branch)\n+{\n+\tasm_volatile_goto(\"1:\"\n+\t\t/*\".byte \" __stringify(BYTES_NOP5) \"\\n\\t\" */\n+\t\tJUMP_TABLE_ENTRY\n+\t\t: :  \"i\" (key), \"i\" (branch) : : l_yes);\n+\n+\treturn false;\n+l_yes:\n+\treturn true;\n+}\n+\n+static __always_inline bool arch_static_branch_jump(struct static_key * const key, const bool branch)\n+{\n+\tasm_volatile_goto(\"1:\"\n+\t\t\"jmp %l[l_yes]\\n\\t\"\n+\t\tJUMP_TABLE_ENTRY\n+\t\t: :  \"i\" (key), \"i\" (branch) : : l_yes);\n+\n+\treturn false;\n+l_yes:\n+\treturn true;\n+}\n+\n+/* Adapted from include/linux/dynamic_debug.h  */\n+\n+struct _ddebug {\n+\t/* [...snip...] */\n+\tconst char *function;\n+\tconst char *filename;\n+\tconst char *format;\n+\tunsigned int lineno:18;\n+\t/* [...snip...] */\n+\tunsigned int flags:8;\n+\tunion {\n+\t\tstruct static_key_true dd_key_true;\n+\t\tstruct static_key_false dd_key_false;\n+\t} key;\n+} __attribute__((aligned(8)));\n+\n+extern void __dynamic_pr_debug(struct _ddebug *descriptor, const char *fmt, ...);\n+\n+static void expanded_dynamic_pr_debug(void) {\n+  do {\n+    static struct _ddebug __attribute__((__aligned__(8)))\n+    __attribute__((__section__(\"__dyndbg\"))) __UNIQUE_ID_ddebug277 = { /* { dg-warning \"track '__UNIQUE_ID_ddebug277': no\" } */\n+        .function = __func__,\n+        .filename = __FILE__,\n+        .format = (\"hello world\"),\n+        .lineno = __LINE__,\n+        .flags = 0};\n+    if (({\n+          bool branch;\n+          if (__builtin_types_compatible_p(\n+                  typeof(*&__UNIQUE_ID_ddebug277.key.dd_key_false),\n+                  struct static_key_true))\n+            branch = arch_static_branch_jump(\n+                &(&__UNIQUE_ID_ddebug277.key.dd_key_false)->key, false);\n+          else if (__builtin_types_compatible_p(\n+                       typeof(*&__UNIQUE_ID_ddebug277.key.dd_key_false),\n+                       struct static_key_false))\n+            branch = arch_static_branch(\n+                &(&__UNIQUE_ID_ddebug277.key.dd_key_false)->key, false);\n+          else\n+            branch = ____wrong_branch_error();\n+          __builtin_expect(!!(branch), 0);\n+        }))\n+      __dynamic_pr_debug(&__UNIQUE_ID_ddebug277,\n+\t\t\t \"hello world\");\n+  } while (0);\n+}"}, {"sha": "8111709206f21d418083a268523421468fd5c99e", "filename": "gcc/testsuite/gcc.dg/analyzer/asm-x86-dyndbg-2.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-dyndbg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-dyndbg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-dyndbg-2.c?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -0,0 +1,77 @@\n+/* Test reduced from use of dynamic_pr_debug on Linux kernel, to verify that\n+   we treat the static struct _ddebug as not needing to be tracked by the\n+   analyzer, thus optimizing away bloat in the analyzer's state tracking.  */\n+\n+/* { dg-do compile { target x86_64-*-* } } */\n+/* { dg-additional-options \"-fdump-analyzer-untracked\" } */\n+\n+/* Adapted from various files in the Linux kernel, all of which have:  */\n+/* SPDX-License-Identifier: GPL-2.0 */\n+\n+typedef _Bool\t\t\tbool;\n+#define true 1\n+#define false 0\n+\n+typedef struct {} atomic_t;\n+\n+/* Adapted from include/linux/compiler_attributes.h  */\n+#define __always_inline                 inline __attribute__((__always_inline__))\n+\n+/* Adapted from include/linux/compiler-gcc.h */\n+#define asm_volatile_goto(x...)\tdo { asm goto(x); asm (\"\"); } while (0)\n+\n+/* Adapted from include/linux/jump_label.h, which has:  */\n+\n+struct static_key {};\n+\n+/* Adapted from arch/x86/include/asm/jump_label.h */\n+\n+static __always_inline bool arch_static_branch(struct static_key * const key, const bool branch)\n+{\n+\tasm_volatile_goto(\"1:\"\n+\t\t: :  \"i\" (key), \"i\" (branch) : : l_yes);\n+\n+\treturn false;\n+l_yes:\n+\treturn true;\n+}\n+\n+static __always_inline bool arch_static_branch_jump(struct static_key * const key, const bool branch)\n+{\n+\tasm_volatile_goto(\"1:\"\n+\t\t: :  \"i\" (key), \"i\" (branch) : : l_yes);\n+\n+\treturn false;\n+l_yes:\n+\treturn true;\n+}\n+\n+/* Adapted from include/linux/dynamic_debug.h  */\n+\n+struct _ddebug {\n+\t/* [...snip...] */\n+\tconst char *function;\n+\tconst char *filename;\n+\tconst char *format;\n+\tunsigned int lineno:18;\n+\t/* [...snip...] */\n+\tunsigned int flags:8;\n+\tstruct static_key key;\n+} __attribute__((aligned(8)));\n+\n+extern void __dynamic_pr_debug(struct _ddebug *descriptor, const char *fmt, ...);\n+\n+static void expanded_dynamic_pr_debug(void) {\n+  do {\n+    static struct _ddebug __attribute__((__aligned__(8)))\n+    __attribute__((__section__(\"__dyndbg\"))) __UNIQUE_ID_ddebug277 = { /* { dg-warning \"track '__UNIQUE_ID_ddebug277': no\" } */\n+        .function = __func__,\n+        .filename = __FILE__,\n+        .format = (\"hello world\"),\n+        .lineno = __LINE__,\n+        .flags = 0};\n+    if (arch_static_branch(&__UNIQUE_ID_ddebug277.key, false))\n+      __dynamic_pr_debug(&__UNIQUE_ID_ddebug277,\n+\t\t\t \"hello world\");\n+  } while (0);\n+}"}, {"sha": "6b5c85557c991c1cc130035598513948abf916c9", "filename": "gcc/testsuite/gcc.dg/analyzer/many-unused-locals.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmany-unused-locals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmany-unused-locals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmany-unused-locals.c?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -0,0 +1,69 @@\n+struct st\n+{\n+  const char *m_filename;\n+  int m_line;\n+  const char *m_function;\n+};\n+\n+extern void debug (struct st *);\n+\n+#define TEST_x_1(NAME)\t\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static struct st NAME = { __FILE__, __LINE__, __func__ };\t\t\\\n+      debug (&NAME);\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TEST_x_10(PREFIX)\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _1);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _2);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _3);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _4);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _5);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _6);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _7);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _8);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _9);\t\t\t\t\t\t\\\n+      TEST_x_1(PREFIX ## _10);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while(0)\n+\n+#define TEST_x_100(PREFIX)\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _1);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _2);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _3);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _4);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _5);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _6);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _7);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _8);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _9);\t\t\t\t\t\t\\\n+      TEST_x_10(PREFIX ## _10);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while(0)\n+\n+#define TEST_x_1000(PREFIX)\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _1);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _2);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _3);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _4);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _5);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _6);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _7);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _8);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _9);\t\t\t\t\t\t\\\n+      TEST_x_100(PREFIX ## _10);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while(0)\n+\n+void test_many (void)\n+{\n+  TEST_x_1000(s);\n+}"}, {"sha": "b7536c399fd5446cc7fc7e5e84f421aab1820a4f", "filename": "gcc/testsuite/gcc.dg/analyzer/untracked-1.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funtracked-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funtracked-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funtracked-1.c?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-additional-options \"-fdump-analyzer-untracked\" } */\n+\n+struct st\n+{\n+  const char *m_filename;\n+  int m_line;\n+};\n+\n+typedef struct boxed_int { int value; } boxed_int;\n+\n+extern void extern_fn (struct st *);\n+static void __attribute__((noinline)) internal_fn (struct st *) {}\n+extern int extern_get_int (void);\n+\n+void test_0 (void)\n+{\n+  /* Not ever referenced; will get optimized away before\n+     analyzer ever sees it, so no message.  */\n+  static struct st s1 = { __FILE__, __LINE__ };\n+}\n+\n+void test_1 (void)\n+{\n+  static struct st s1 = { __FILE__, __LINE__ }; /* { dg-warning \"track 's1': no\" } */\n+  extern_fn (&s1);\n+}\n+\n+static struct st s2 = { __FILE__, __LINE__ }; /* { dg-warning \"track 's2': yes\" } */\n+\n+void test_2 (void)\n+{\n+  extern_fn (&s2);\n+}\n+\n+void test_3 (void)\n+{\n+  struct st s3 = { __FILE__, __LINE__ }; /* { dg-warning \"track 's3': yes\" } */\n+  extern_fn (&s3);\n+}\n+\n+extern void called_by_test_4 (int *);\n+\n+int test_4 (void)\n+{\n+  int i; /* { dg-warning \"track 'i': yes\" } */\n+  called_by_test_4 (&i);\n+  return i;\n+}\n+\n+void test_5 (int i)\n+{\n+  boxed_int bi5 = { i }; /* { dg-warning \"track 'bi5': yes\" } */\n+}\n+\n+int test_6 (int i)\n+{\n+  static boxed_int bi6; /* { dg-warning \"track 'bi6': yes\" } */\n+  bi6.value = i;\n+  return bi6.value;\n+}\n+\n+int test_7 (void)\n+{\n+  boxed_int bi7; /* { dg-warning \"track 'bi7': yes\" } */\n+  return bi7.value; /* { dg-warning \"use of uninitialized value 'bi7.value'\" \"uninit\" } */\n+}\n+\n+void test_8 (void)\n+{\n+  static struct st s8 = { __FILE__, __LINE__ }; /* { dg-warning \"track 's8': no\" } */\n+  extern_fn (&s8);\n+  extern_fn (&s8);\n+}\n+\n+void test_9 (void)\n+{\n+  static struct st s9 = { __FILE__, __LINE__ }; /* { dg-warning \"track 's9': yes\" } */\n+  internal_fn (&s9);\n+}\n+\n+int test_10 (void)\n+{\n+  static struct st s10 = { __FILE__, __LINE__ }; /* { dg-warning \"track 's10': yes\" } */\n+  extern_fn (&s10);\n+  return s10.m_line;\n+}\n+\n+int test_11 (void)\n+{\n+  static struct st s10 = { __FILE__, __LINE__ }; /* { dg-warning \"track 's10': yes\" } */\n+  s10.m_line = extern_get_int ();\n+  return 42;\n+}\n+\n+int test_12 (void (*fnptr) (struct st *))\n+{\n+  static struct st s12 = { __FILE__, __LINE__ }; /* { dg-warning \"track 's12': yes\" } */\n+  fnptr (&s12);\n+}"}, {"sha": "361cdced6e3ab100acbe2e26f071f4400fae8352", "filename": "gcc/testsuite/gcc.dg/analyzer/unused-local-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funused-local-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f6197d7c197f9d2b7fb2e1a19dac39a023755e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funused-local-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funused-local-1.c?ref=5f6197d7c197f9d2b7fb2e1a19dac39a023755e8", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-additional-options \"-fdump-analyzer-untracked\" } */\n+\n+struct st\n+{\n+  const char *m_filename;\n+  int m_line;\n+  const char *m_function;\n+};\n+\n+extern void debug (struct st *);\n+\n+void test (void)\n+{\n+  {\n+    static struct st s1 = { __FILE__, __LINE__, __func__ }; /* { dg-warning \"track 's1': no\" } */\n+    debug (&s1);\n+  }\n+  {\n+    static struct st s2 = { __FILE__, __LINE__, __func__ }; /* { dg-warning \"track 's2': no\" } */\n+    debug (&s2);\n+  }\n+}"}]}