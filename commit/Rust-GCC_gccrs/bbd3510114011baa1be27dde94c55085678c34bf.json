{"sha": "bbd3510114011baa1be27dde94c55085678c34bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJkMzUxMDExNDAxMWJhYTFiZTI3ZGRlOTRjNTUwODU2NzhjMzRiZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-09-06T17:41:08Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-09-06T17:41:08Z"}, "message": "rs6000-cpus.def (OTHER_VSX_VECTOR_MASKS): Delete OPTION_MASK_FLOAT128_KEYWORD.\n\n[gcc]\n2017-09-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000-cpus.def (OTHER_VSX_VECTOR_MASKS): Delete\n\tOPTION_MASK_FLOAT128_KEYWORD.\n\t(POWERPC_MASKS): Likewise.\n\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Delete\n\tsupport for the -mfloat128-type option, and make -mfloat128\n\tdefault on PowerPC Linux systems.  Define or undefine\n\t__FLOAT128__ and  __FLOAT128_HARDWARE__ for the current options.\n\tDefine __float128 to be __ieee128 if IEEE 128-bit support is\n\tenabled, or undefine it.\n\t(rs6000_cpu_cpp_builtins): Delete defining __FLOAT128__ here.\n\tDelete defining __FLOAT128_TYPE__.\n\t* config/rs6000/rs6000.opt (x_TARGET_FLOAT128_TYPE): Delete the\n\t-mfloat128-type option and make -mfloat128 default on PowerPC\n\tLinux systems.\n\t(TARGET_FLOAT128_TYPE): Likewise.\n\t(-mfloat128-type): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal):\n\tDelete the -mfloat128-type option and make -mfloat128 default on\n\tPowerPC Linux systems.  Always use __ieee128 to be the keyword for\n\tthe IEEE 128-bit type, and map __float128 to __ieee128 if IEEE\n\t128-bit floating point is enabled.  Change tests from using\n\t-mfloat128-type to -mfloat128.\n\t(rs6000_mangle_type): Use the correct mangling for the __float128\n\ttype even if normal long double is restricted to 64-bits.\n\t(floatn_mode): Enable the _Float128 type by default on VSX Linux\n\tsystems.\n\t* config/rs6000/rs6000.h (MASK_FLOAT128_TYPE): Delete.\n\t(MASK_FLOAT128_KEYWORD): Define new shortcut macro.\n\t(RS6000BTM_FLOAT128): Define in terms of -mfloat128, not\n\t-mfloat128-type.\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Update\n\tdocumentation for -mfloat128.\n\n[gcc/testsuite]\n2017-09-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/float128-1.c: Update options to know that\n\t-mfloat128 is now on by default on PowerPC VSX systems.  Remove\n\t-static-libgcc option which is no longer needed.  Use -mvsx or\n\t-mpower9-vector to enable VSX or hardware IEEE support, rather\n\tthan specifying a particular CPU.\n\t* gcc.target/powerpc/float128-2.c: Likewise.\n\t* gcc.target/powerpc/float128-cmp.c: Likewise.\n\t* gcc.target/powerpc/float128-complex-1.c: Likewise.\n\t* gcc.target/powerpc/float128-complex-2.c: Likewise.\n\t* gcc.target/powerpc/float128-hw.c: Likewise.\n\t* gcc.target/powerpc/float128-mix.c: Likewise.\n\t* gcc.target/powerpc/float128-type-1.c: Likewise.\n\t* gcc.target/powerpc/float128-type-2.c: Likewise.\n\t* gcc.target/powerpc/float128-3.c: New test.\n\t* gcc.target/powerpc/float128-4.c: Likewise.\n\t* gcc.target/powerpc/float128-5.c: Likewise.\n\nFrom-SVN: r251814", "tree": {"sha": "ed01c1eedb33370ffddc2ccfe2f0fe47b9d335c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed01c1eedb33370ffddc2ccfe2f0fe47b9d335c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbd3510114011baa1be27dde94c55085678c34bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd3510114011baa1be27dde94c55085678c34bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbd3510114011baa1be27dde94c55085678c34bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd3510114011baa1be27dde94c55085678c34bf/comments", "author": null, "committer": null, "parents": [{"sha": "3f8cf83477cc336b1fec73ef16293644cd5ec453", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8cf83477cc336b1fec73ef16293644cd5ec453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f8cf83477cc336b1fec73ef16293644cd5ec453"}], "stats": {"total": 517, "additions": 366, "deletions": 151}, "files": [{"sha": "6213a2aad571b2b99c4aaec61cf172a4f1a60a09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,3 +1,38 @@\n+2017-09-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000-cpus.def (OTHER_VSX_VECTOR_MASKS): Delete\n+\tOPTION_MASK_FLOAT128_KEYWORD.\n+\t(POWERPC_MASKS): Likewise.\n+\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Delete\n+\tsupport for the -mfloat128-type option, and make -mfloat128\n+\tdefault on PowerPC Linux systems.  Define or undefine\n+\t__FLOAT128__ and  __FLOAT128_HARDWARE__ for the current options.\n+\tDefine __float128 to be __ieee128 if IEEE 128-bit support is\n+\tenabled, or undefine it.\n+\t(rs6000_cpu_cpp_builtins): Delete defining __FLOAT128__ here.\n+\tDelete defining __FLOAT128_TYPE__.\n+\t* config/rs6000/rs6000.opt (x_TARGET_FLOAT128_TYPE): Delete the\n+\t-mfloat128-type option and make -mfloat128 default on PowerPC\n+\tLinux systems.\n+\t(TARGET_FLOAT128_TYPE): Likewise.\n+\t(-mfloat128-type): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal):\n+\tDelete the -mfloat128-type option and make -mfloat128 default on\n+\tPowerPC Linux systems.  Always use __ieee128 to be the keyword for\n+\tthe IEEE 128-bit type, and map __float128 to __ieee128 if IEEE\n+\t128-bit floating point is enabled.  Change tests from using\n+\t-mfloat128-type to -mfloat128.\n+\t(rs6000_mangle_type): Use the correct mangling for the __float128\n+\ttype even if normal long double is restricted to 64-bits.\n+\t(floatn_mode): Enable the _Float128 type by default on VSX Linux\n+\tsystems.\n+\t* config/rs6000/rs6000.h (MASK_FLOAT128_TYPE): Delete.\n+\t(MASK_FLOAT128_KEYWORD): Define new shortcut macro.\n+\t(RS6000BTM_FLOAT128): Define in terms of -mfloat128, not\n+\t-mfloat128-type.\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Update\n+\tdocumentation for -mfloat128.\n+\n 2017-09-06  Olivier Hainque  <hainque@adacore.com>\n \n \t* config.gcc (powerpc-wrs-vxworksspe): Now match as vxworks*spe."}, {"sha": "b2df850e81b239c0298f014eaf560dcf0fdc9bf1", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -574,6 +574,18 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n      2. If TARGET_ALTIVEC is turned off.  */\n   if ((flags & OPTION_MASK_CRYPTO) != 0)\n     rs6000_define_or_undefine_macro (define_p, \"__CRYPTO__\");\n+  if ((flags & OPTION_MASK_FLOAT128_KEYWORD) != 0)\n+    {\n+      rs6000_define_or_undefine_macro (define_p, \"__FLOAT128__\");\n+      if (define_p)\n+\trs6000_define_or_undefine_macro (true, \"__float128=__ieee128\");\n+      else\n+\trs6000_define_or_undefine_macro (false, \"__float128\");\n+    }\n+  /* OPTION_MASK_FLOAT128_HARDWARE can be turned on if -mcpu=power9 is used or\n+     via the target attribute/pragma.  */\n+  if ((flags & OPTION_MASK_FLOAT128_HW) != 0)\n+    rs6000_define_or_undefine_macro (define_p, \"__FLOAT128_HARDWARE__\");\n \n   /* options from the builtin masks.  */\n   /* Note that RS6000_BTM_PAIRED is enabled only if\n@@ -601,24 +613,14 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     builtin_define (\"__RSQRTE__\");\n   if (TARGET_FRSQRTES)\n     builtin_define (\"__RSQRTEF__\");\n-  if (TARGET_FLOAT128_KEYWORD)\n-    builtin_define (\"__FLOAT128__\");\n   if (TARGET_FLOAT128_TYPE)\n     builtin_define (\"__FLOAT128_TYPE__\");\n-  if (TARGET_FLOAT128_HW)\n-    builtin_define (\"__FLOAT128_HARDWARE__\");\n   if (TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (TFmode))\n     builtin_define (\"__ibm128=long double\");\n #ifdef TARGET_LIBC_PROVIDES_HWCAP_IN_TCB\n   builtin_define (\"__BUILTIN_CPU_SUPPORTS__\");\n #endif\n \n-  /* We needed to create a keyword if -mfloat128-type was used but not -mfloat,\n-     so we used __ieee128.  If -mfloat128 was used, create a #define back to\n-     the real keyword in case somebody used it.  */\n-  if (TARGET_FLOAT128_KEYWORD)\n-    builtin_define (\"__ieee128=__float128\");\n-\n   if (TARGET_EXTRA_BUILTINS && cpp_get_options (pfile)->lang != CLK_ASM)\n     {\n       /* Define the AltiVec syntactic elements.  */"}, {"sha": "f9822e1ce7cda9c5a6a4f0004fd880aabf08c86c", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -86,7 +86,6 @@\n #define OTHER_VSX_VECTOR_MASKS\t(OTHER_P8_VECTOR_MASKS\t\t\t\\\n \t\t\t\t | OPTION_MASK_EFFICIENT_UNALIGNED_VSX\t\\\n \t\t\t\t | OPTION_MASK_FLOAT128_KEYWORD\t\t\\\n-\t\t\t\t | OPTION_MASK_FLOAT128_TYPE\t\t\\\n \t\t\t\t | OPTION_MASK_P8_VECTOR)\n \n #define POWERPC_7400_MASK\t(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)\n@@ -112,7 +111,6 @@\n \t\t\t\t | OPTION_MASK_EFFICIENT_UNALIGNED_VSX\t\\\n \t\t\t\t | OPTION_MASK_FLOAT128_HW\t\t\\\n \t\t\t\t | OPTION_MASK_FLOAT128_KEYWORD\t\t\\\n-\t\t\t\t | OPTION_MASK_FLOAT128_TYPE\t\t\\\n \t\t\t\t | OPTION_MASK_FPRND\t\t\t\\\n \t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\"}, {"sha": "fdc39d9a64d3bbe46566b4e42a82d4be1f6c3cd9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 45, "deletions": 90, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -4608,73 +4608,42 @@ rs6000_option_override_internal (bool global_init_p)\n #endif\n \n   /* Enable the default support for IEEE 128-bit floating point on Linux VSX\n-     sytems, but don't enable the __float128 keyword.  */\n-  if (TARGET_VSX && TARGET_LONG_DOUBLE_128\n-      && (TARGET_FLOAT128_ENABLE_TYPE || TARGET_IEEEQUAD)\n-      && ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_TYPE) == 0))\n-    rs6000_isa_flags |= OPTION_MASK_FLOAT128_TYPE;\n+     sytems.  In GCC 7, we would enable the the IEEE 128-bit floating point\n+     infrastructure (-mfloat128-type) but not enable the actual __float128 type\n+     unless the user used the explicit -mfloat128.  In GCC 8, we enable both\n+     the keyword as well as the type.  */\n+  TARGET_FLOAT128_TYPE = TARGET_FLOAT128_ENABLE_TYPE && TARGET_VSX;\n \n   /* IEEE 128-bit floating point requires VSX support.  */\n-  if (!TARGET_VSX)\n+  if (TARGET_FLOAT128_KEYWORD)\n     {\n-      if (TARGET_FLOAT128_KEYWORD)\n+      if (!TARGET_VSX)\n \t{\n \t  if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_KEYWORD) != 0)\n \t    error (\"%qs requires VSX support\", \"-mfloat128\");\n \n-\t  rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_TYPE\n-\t\t\t\t| OPTION_MASK_FLOAT128_KEYWORD\n+\t  TARGET_FLOAT128_TYPE = 0;\n+\t  rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_KEYWORD\n \t\t\t\t| OPTION_MASK_FLOAT128_HW);\n \t}\n-\n-      else if (TARGET_FLOAT128_TYPE)\n+      else if (!TARGET_FLOAT128_TYPE)\n \t{\n-\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_TYPE) != 0)\n-\t    error (\"%qs requires VSX support\", \"-mfloat128-type\");\n-\n-\t  rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_TYPE\n-\t\t\t\t| OPTION_MASK_FLOAT128_KEYWORD\n-\t\t\t\t| OPTION_MASK_FLOAT128_HW);\n+\t  TARGET_FLOAT128_TYPE = 1;\n+\t  warning (0, \"The -mfloat128 option may not be fully supported\");\n \t}\n     }\n \n-  /* -mfloat128 and -mfloat128-hardware internally require the underlying IEEE\n-      128-bit floating point support to be enabled.  */\n-  if (!TARGET_FLOAT128_TYPE)\n-    {\n-      if (TARGET_FLOAT128_KEYWORD)\n-\t{\n-\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_KEYWORD) != 0)\n-\t    {\n-\t      error (\"%qs requires %qs\", \"-mfloat128\", \"-mfloat128-type\");\n-\t      rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_TYPE\n-\t\t\t\t    | OPTION_MASK_FLOAT128_KEYWORD\n-\t\t\t\t    | OPTION_MASK_FLOAT128_HW);\n-\t    }\n-\t  else\n-\t    rs6000_isa_flags |= OPTION_MASK_FLOAT128_TYPE;\n-\t}\n-\n-      if (TARGET_FLOAT128_HW)\n-\t{\n-\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW) != 0)\n-\t    {\n-\t      error (\"%qs requires %qs\", \"-mfloat128-hardware\",\n-\t\t     \"-mfloat128-type\");\n-\t      rs6000_isa_flags &= ~OPTION_MASK_FLOAT128_HW;\n-\t    }\n-\t  else\n-\t    rs6000_isa_flags &= ~(OPTION_MASK_FLOAT128_TYPE\n-\t\t\t\t  | OPTION_MASK_FLOAT128_KEYWORD\n-\t\t\t\t  | OPTION_MASK_FLOAT128_HW);\n-\t}\n-    }\n+  /* Enable the __float128 keyword under Linux by default.  */\n+  if (TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_KEYWORD\n+      && (rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_KEYWORD) == 0)\n+    rs6000_isa_flags |= OPTION_MASK_FLOAT128_KEYWORD;\n \n-  /* If we have -mfloat128-type and full ISA 3.0 support, enable\n-     -mfloat128-hardware by default.  However, don't enable the __float128\n-     keyword.  If the user explicitly turned on -mfloat128-hardware, enable the\n-     -mfloat128 option as well if it was not already set.  */\n-  if (TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW\n+  /* If we have are supporting the float128 type and full ISA 3.0 support,\n+     enable -mfloat128-hardware by default.  However, don't enable the\n+     __float128 keyword if it was explicitly turned off.  64-bit mode is needed\n+     because sometimes the compiler wants to put things in an integer\n+     container, and if we don't have __int128 support, it is impossible.  */\n+  if (TARGET_FLOAT128_TYPE && !TARGET_FLOAT128_HW && TARGET_64BIT\n       && (rs6000_isa_flags & ISA_3_0_MASKS_IEEE) == ISA_3_0_MASKS_IEEE\n       && !(rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW))\n     rs6000_isa_flags |= OPTION_MASK_FLOAT128_HW;\n@@ -4696,11 +4665,6 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_FLOAT128_HW;\n     }\n \n-  if (TARGET_FLOAT128_HW && !TARGET_FLOAT128_KEYWORD\n-      && (rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_HW) != 0\n-      && (rs6000_isa_flags_explicit & OPTION_MASK_FLOAT128_KEYWORD) == 0)\n-    rs6000_isa_flags |= OPTION_MASK_FLOAT128_KEYWORD;\n-\n   /* Print the options after updating the defaults.  */\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"after defaults\", rs6000_isa_flags);\n@@ -4767,10 +4731,12 @@ rs6000_option_override_internal (bool global_init_p)\n      unless the altivec ABI was set.  This is set by default for 64-bit, but\n      not for 32-bit.  */\n   if (main_target_opt != NULL && !main_target_opt->x_rs6000_altivec_abi)\n-    rs6000_isa_flags &= ~((OPTION_MASK_VSX | OPTION_MASK_ALTIVEC\n-\t\t\t   | OPTION_MASK_FLOAT128_TYPE\n-\t\t\t   | OPTION_MASK_FLOAT128_KEYWORD)\n-\t\t\t  & ~rs6000_isa_flags_explicit);\n+    {\n+      TARGET_FLOAT128_TYPE = 0;\n+      rs6000_isa_flags &= ~((OPTION_MASK_VSX | OPTION_MASK_ALTIVEC\n+\t\t\t     | OPTION_MASK_FLOAT128_KEYWORD)\n+\t\t\t    & ~rs6000_isa_flags_explicit);\n+    }\n \n   /* Enable Altivec ABI for AIX -maltivec.  */\n   if (TARGET_XCOFF && (TARGET_ALTIVEC || TARGET_VSX))\n@@ -16884,16 +16850,17 @@ rs6000_init_builtins (void)\n      format that uses a pair of doubles, depending on the switches and\n      defaults.\n \n-     We do not enable the actual __float128 keyword unless the user explicitly\n-     asks for it, because the library support is not yet complete.\n-\n      If we don't support for either 128-bit IBM double double or IEEE 128-bit\n      floating point, we need make sure the type is non-zero or else self-test\n      fails during bootstrap.\n \n      We don't register a built-in type for __ibm128 if the type is the same as\n      long double.  Instead we add a #define for __ibm128 in\n-     rs6000_cpu_cpp_builtins to long double.  */\n+     rs6000_cpu_cpp_builtins to long double.\n+\n+     For IEEE 128-bit floating point, always create the type __ieee128.  If the\n+     user used -mfloat128, rs6000-c.c will create a define from __float128 to\n+     __ieee128.  */\n   if (TARGET_LONG_DOUBLE_128 && FLOAT128_IEEE_P (TFmode))\n     {\n       ibm128_float_type_node = make_node (REAL_TYPE);\n@@ -16907,23 +16874,9 @@ rs6000_init_builtins (void)\n   else\n     ibm128_float_type_node = long_double_type_node;\n \n-  if (TARGET_FLOAT128_KEYWORD)\n+  if (TARGET_FLOAT128_TYPE)\n     {\n       ieee128_float_type_node = float128_type_node;\n-      lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n-\t\t\t\t\t      \"__float128\");\n-    }\n-\n-  else if (TARGET_FLOAT128_TYPE)\n-    {\n-      ieee128_float_type_node = make_node (REAL_TYPE);\n-      TYPE_PRECISION (ibm128_float_type_node) = 128;\n-      SET_TYPE_MODE (ieee128_float_type_node, KFmode);\n-      layout_type (ieee128_float_type_node);\n-\n-      /* If we are not exporting the __float128/_Float128 keywords, we need a\n-\t keyword to get the types created.  Use __ieee128 as the dummy\n-\t keyword.  */\n       lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n \t\t\t\t\t      \"__ieee128\");\n     }\n@@ -32555,11 +32508,14 @@ rs6000_mangle_type (const_tree type)\n       if (type == ieee128_float_type_node)\n \treturn \"U10__float128\";\n \n-      if (type == ibm128_float_type_node)\n-\treturn \"g\";\n+      if (TARGET_LONG_DOUBLE_128)\n+\t{\n+\t  if (type == long_double_type_node)\n+\t    return (TARGET_IEEEQUAD) ? \"U10__float128\" : \"g\";\n \n-      if (type == long_double_type_node && TARGET_LONG_DOUBLE_128)\n-\treturn (TARGET_IEEEQUAD) ? \"U10__float128\" : \"g\";\n+\t  if (type == ibm128_float_type_node)\n+\t    return \"g\";\n+\t}\n     }\n \n   /* Mangle IBM extended float long double as `g' (__float128) on\n@@ -36037,7 +35993,7 @@ rs6000_floatn_mode (int n, bool extended)\n \t  return DFmode;\n \n \tcase 64:\n-\t  if (TARGET_FLOAT128_KEYWORD)\n+\t  if (TARGET_FLOAT128_TYPE)\n \t    return (FLOAT128_IEEE_P (TFmode)) ? TFmode : KFmode;\n \t  else\n \t    return opt_scalar_float_mode ();\n@@ -36061,7 +36017,7 @@ rs6000_floatn_mode (int n, bool extended)\n \t  return DFmode;\n \n \tcase 128:\n-\t  if (TARGET_FLOAT128_KEYWORD)\n+\t  if (TARGET_FLOAT128_TYPE)\n \t    return (FLOAT128_IEEE_P (TFmode)) ? TFmode : KFmode;\n \t  else\n \t    return opt_scalar_float_mode ();\n@@ -36151,9 +36107,8 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"dlmzb\",\t\t\tOPTION_MASK_DLMZB,\t\tfalse, true  },\n   { \"efficient-unaligned-vsx\",\tOPTION_MASK_EFFICIENT_UNALIGNED_VSX,\n \t\t\t\t\t\t\t\tfalse, true  },\n-  { \"float128\",\t\t\tOPTION_MASK_FLOAT128_KEYWORD,\tfalse, false },\n-  { \"float128-type\",\t\tOPTION_MASK_FLOAT128_TYPE,\tfalse, false },\n-  { \"float128-hardware\",\tOPTION_MASK_FLOAT128_HW,\tfalse, false },\n+  { \"float128\",\t\t\tOPTION_MASK_FLOAT128_KEYWORD,\tfalse, true  },\n+  { \"float128-hardware\",\tOPTION_MASK_FLOAT128_HW,\tfalse, true  },\n   { \"fprnd\",\t\t\tOPTION_MASK_FPRND,\t\tfalse, true  },\n   { \"hard-dfp\",\t\t\tOPTION_MASK_DFP,\t\tfalse, true  },\n   { \"htm\",\t\t\tOPTION_MASK_HTM,\t\tfalse, true  },"}, {"sha": "20f5b6acffac1b6521cb97eda6b61002212198de", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -639,7 +639,7 @@ extern int rs6000_vector_align[];\n #define MASK_DIRECT_MOVE\t\tOPTION_MASK_DIRECT_MOVE\n #define MASK_DLMZB\t\t\tOPTION_MASK_DLMZB\n #define MASK_EABI\t\t\tOPTION_MASK_EABI\n-#define MASK_FLOAT128_TYPE\t\tOPTION_MASK_FLOAT128_TYPE\n+#define MASK_FLOAT128_KEYWORD\t\tOPTION_MASK_FLOAT128_KEYWORD\n #define MASK_FPRND\t\t\tOPTION_MASK_FPRND\n #define MASK_P8_FUSION\t\t\tOPTION_MASK_P8_FUSION\n #define MASK_HARD_FLOAT\t\t\tOPTION_MASK_HARD_FLOAT\n@@ -2531,7 +2531,7 @@ extern int frame_pointer_needed;\n #define RS6000_BTM_HARD_FLOAT\tMASK_SOFT_FLOAT\t/* Hardware floating point.  */\n #define RS6000_BTM_LDBL128\tMASK_MULTIPLE\t/* 128-bit long double.  */\n #define RS6000_BTM_64BIT\tMASK_64BIT\t/* 64-bit addressing.  */\n-#define RS6000_BTM_FLOAT128\tMASK_FLOAT128_TYPE /* IEEE 128-bit float.  */\n+#define RS6000_BTM_FLOAT128\tMASK_FLOAT128_KEYWORD /* IEEE 128-bit float.  */\n \n #define RS6000_BTM_COMMON\t(RS6000_BTM_ALTIVEC\t\t\t\\\n \t\t\t\t | RS6000_BTM_VSX\t\t\t\\"}, {"sha": "c42818fbc04e1fdff5a5a5099d5c7d3e5efae012", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -100,6 +100,14 @@ HOST_WIDE_INT rs6000_builtin_mask\n TargetVariable\n unsigned int rs6000_debug\n \n+;; Whether to enable the -mfloat128 stuff without necessarily enabling the\n+;; __float128 keyword.\n+TargetSave\n+unsigned char x_TARGET_FLOAT128_TYPE\n+\n+Variable\n+unsigned char TARGET_FLOAT128_TYPE\n+\n ;; This option existed in the past, but now is always on.\n mpowerpc\n Target RejectNegative Undocumented Ignore\n@@ -562,14 +570,6 @@ mmodulo\n Target Undocumented Report Mask(MODULO) Var(rs6000_isa_flags)\n Generate the integer modulo instructions.\n \n-; We want to enable the internal support for the IEEE 128-bit floating point\n-; type without necessarily enabling the __float128 keyword.  This is to allow\n-; Boost and other libraries that know about __float128 to work until the\n-; official library support is finished.\n-mfloat128-type\n-Target Undocumented Mask(FLOAT128_TYPE) Var(rs6000_isa_flags)\n-Allow the IEEE 128-bit types without requiring the __float128 keyword.\n-\n mfloat128\n Target Report Mask(FLOAT128_KEYWORD) Var(rs6000_isa_flags)\n Enable IEEE 128-bit floating point via the __float128 keyword."}, {"sha": "6c844c6ab767c5faeb007fdf871f6bf3db29d4dd", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -22014,15 +22014,21 @@ Enable/disable the @var{__float128} keyword for IEEE 128-bit floating point\n and use either software emulation for IEEE 128-bit floating point or\n hardware instructions.\n \n-The VSX instruction set (@option{-mvsx}, @option{-mcpu=power7}, or\n-@option{-mcpu=power8}) must be enabled to use the @option{-mfloat128}\n-option.  The @option{-mfloat128} option only works on PowerPC 64-bit\n-Linux systems.\n-\n-If you use the ISA 3.0 instruction set (@option{-mcpu=power9}), the\n-@option{-mfloat128} option will also enable the generation of ISA 3.0\n-IEEE 128-bit floating point instructions.  Otherwise, IEEE 128-bit\n-floating point will be done with software emulation.\n+The VSX instruction set (@option{-mvsx}, @option{-mcpu=power7},\n+@option{-mcpu=power8}), or @option{-mcpu=power9} must be enabled to\n+use the IEEE 128-bit floating point support.  The IEEE 128-bit\n+floating point support only works on PowerPC Linux systems.\n+\n+The default for @option{-mfloat128} is enabled on PowerPC Linux\n+systems using the VSX instruction set, and disabled on other systems.\n+\n+If you use the ISA 3.0 instruction set (@option{-mpower9-vector} or\n+@option{-mcpu=power9}) on a 64-bit system, the IEEE 128-bit floating\n+point support will also enable the generation of ISA 3.0 IEEE 128-bit\n+floating point instructions.  Otherwise, if you do not specify to\n+generate ISA 3.0 instructions or you are targeting a 32-bit big endian\n+system, IEEE 128-bit floating point will be done with software\n+emulation.\n \n @item -mfloat128-hardware\n @itemx -mno-float128-hardware\n@@ -22031,12 +22037,9 @@ floating point will be done with software emulation.\n Enable/disable using ISA 3.0 hardware instructions to support the\n @var{__float128} data type.\n \n-If you use @option{-mfloat128-hardware}, it will enable the option\n-@option{-mfloat128} as well.\n-\n-If you select ISA 3.0 instructions with @option{-mcpu=power9}, but do\n-not use either @option{-mfloat128} or @option{-mfloat128-hardware},\n-the IEEE 128-bit floating point support will not be enabled.\n+The default for @option{-mfloat128-hardware} is enabled on PowerPC\n+Linux systems using the ISA 3.0 instruction set, and disabled on other\n+systems.\n \n @item -mfloat-gprs=@var{yes/single/double/no}\n @itemx -mfloat-gprs"}, {"sha": "7edf509b554f26e0a62724a49be2522184f89704", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,3 +1,22 @@\n+2017-09-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/float128-1.c: Update options to know that\n+\t-mfloat128 is now on by default on PowerPC VSX systems.  Remove\n+\t-static-libgcc option which is no longer needed.  Use -mvsx or\n+\t-mpower9-vector to enable VSX or hardware IEEE support, rather\n+\tthan specifying a particular CPU.\n+\t* gcc.target/powerpc/float128-2.c: Likewise.\n+\t* gcc.target/powerpc/float128-cmp.c: Likewise.\n+\t* gcc.target/powerpc/float128-complex-1.c: Likewise.\n+\t* gcc.target/powerpc/float128-complex-2.c: Likewise.\n+\t* gcc.target/powerpc/float128-hw.c: Likewise.\n+\t* gcc.target/powerpc/float128-mix.c: Likewise.\n+\t* gcc.target/powerpc/float128-type-1.c: Likewise.\n+\t* gcc.target/powerpc/float128-type-2.c: Likewise.\n+\t* gcc.target/powerpc/float128-3.c: New test.\n+\t* gcc.target/powerpc/float128-4.c: Likewise.\n+\t* gcc.target/powerpc/float128-5.c: Likewise.\n+\n 2017-09-06  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \tPR middle-end/78468"}, {"sha": "8a4565341b6a90c9ee16e7e6c8edd4ffe9eae8f8", "filename": "gcc/testsuite/gcc.target/powerpc/float128-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-1.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,6 +1,7 @@\n /* { dg-do run { target { powerpc*-*-linux* } } } */\n /* { dg-require-effective-target ppc_float128_sw } */\n-/* { dg-options \"-mcpu=power7 -O2 -mfloat128 -static-libgcc\" } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O2\" } */\n \n #ifdef DEBUG\n #include <stdio.h>"}, {"sha": "63b0f8d35bdb7dbde8a0b1a0ae48c1657c4a3fb4", "filename": "gcc/testsuite/gcc.target/powerpc/float128-2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-2.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,6 +1,7 @@\n /* { dg-do run { target { powerpc*-*-linux* } } } */\n /* { dg-require-effective-target ppc_float128_sw } */\n-/* { dg-options \"-mcpu=power7 -O2 -mfloat128 -static-libgcc\" } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O2\" } */\n \n /*\n  * Test program to make sure we are getting more precision than the 53 bits we"}, {"sha": "6daf290d12b26d354e5ee8d078bc8b12854dfc08", "filename": "gcc/testsuite/gcc.target/powerpc/float128-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-3.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mvsx -mno-float128\" } */\n+\n+/* Test that we can use #pragma GCC target to enable -mfloat128.  */\n+\n+#ifdef __FLOAT128__\n+#error \"-mno-float128 should disable initially defining __FLOAT128__\"\n+#endif\n+\n+#pragma GCC target(\"float128\")\n+\n+#ifndef __FLOAT128__\n+#error \"#pragma GCC target(\\\"float128\\\") should enable -mfloat128\"\n+#endif\n+\n+__float128\n+qadd (__float128 a, __float128 b)\n+{\n+  return a+b;\n+}"}, {"sha": "00b18881a0b966e08dd69c05f810b3c06d4f08b5", "filename": "gcc/testsuite/gcc.target/powerpc/float128-4.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-4.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -0,0 +1,152 @@\n+/* { dg-do run { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target ppc_float128_sw } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+/* This is the same as test float128-1.c, using the _Float128 keyword instead\n+   of __float128, and not using -mfloat128.  */\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <inttypes.h>\n+#endif\n+\n+#if !defined(__FLOAT128__) || !defined(_ARCH_PPC)\n+static _Float128\n+pass_through (_Float128 x)\n+{\n+  return x;\n+}\n+\n+_Float128 (*no_optimize) (_Float128) = pass_through;\n+#endif\n+\n+#ifdef DEBUG\n+__attribute__((__noinline__))\n+static void\n+print_f128 (_Float128 x)\n+{\n+  unsigned sign;\n+  unsigned exponent;\n+  uint64_t mantissa1;\n+  uint64_t mantissa2;\n+  uint64_t upper;\n+  uint64_t lower;\n+\n+#if defined(_ARCH_PPC) && defined(__BIG_ENDIAN__)\n+  struct ieee128 {\n+    uint64_t upper;\n+    uint64_t lower;\n+  };\n+\n+#elif (defined(_ARCH_PPC) && defined(__LITTLE_ENDIAN__)) || defined(__x86_64__)\n+  struct ieee128 {\n+    uint64_t lower;\n+    uint64_t upper;\n+  };\n+\n+#else\n+#error \"Unknown system\"\n+#endif\n+\n+  union {\n+    _Float128 f128;\n+    struct ieee128 s128;\n+  } u;\n+\n+  u.f128 = x;\n+  upper  = u.s128.upper;\n+  lower  = u.s128.lower;\n+\n+  sign      = (unsigned)((upper >> 63) & 1);\n+  exponent  = (unsigned)((upper >> 48) & ((((uint64_t)1) << 16) - 1));\n+  mantissa1 = (upper & ((((uint64_t)1) << 48) - 1));\n+  mantissa2 = lower;\n+\n+  printf (\"%c 0x%.4x 0x%.12\" PRIx64 \" 0x%.16\" PRIx64,\n+\t  sign ? '-' : '+',\n+\t  exponent,\n+\t  mantissa1,\n+\t  mantissa2);\n+}\n+#endif\n+\n+__attribute__((__noinline__))\n+static void\n+do_test (_Float128 expected, _Float128 got, const char *name)\n+{\n+  int equal_p = (expected == got);\n+\n+#ifdef DEBUG\n+  printf (\"Test %s, expected: \", name);\n+  print_f128 (expected);\n+  printf (\" %5g, got: \", (double) expected);\n+  print_f128 (got);\n+  printf (\" %5g, result %s\\n\",\n+\t  (double) got,\n+\t  (equal_p) ? \"equal\" : \"not equal\");\n+#endif\n+\n+  if (!equal_p)\n+    __builtin_abort ();\n+}\n+\n+\n+int\n+main (void)\n+{\n+  _Float128 one\t\t= 1.0f128;\n+  _Float128 two\t\t= 2.0f128;\n+  _Float128 three\t= 3.0f128;\n+  _Float128 four\t= 4.0f128;\n+  _Float128 five\t= 5.0f128;\n+  _Float128 add_result = (1.0f128 + 2.0f128);\n+  _Float128 mul_result = ((1.0f128 + 2.0f128) * 3.0f128);\n+  _Float128 div_result = (((1.0f128 + 2.0f128) * 3.0f128) / 4.0f128);\n+  _Float128 sub_result = ((((1.0f128 + 2.0f128) * 3.0f128) / 4.0f128)\n+\t\t\t  - 5.0f128);\n+  _Float128 neg_result = - sub_result;\n+  _Float128 add_xresult;\n+  _Float128 mul_xresult;\n+  _Float128 div_xresult;\n+  _Float128 sub_xresult;\n+  _Float128 neg_xresult;\n+\n+#if defined(__FLOAT128__) && defined(_ARCH_PPC)\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (one));\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (two));\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (three));\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (four));\n+  __asm__ (\" #prevent constant folding, %x0\" : \"+wa\" (five));\n+\n+#else\n+  one   = no_optimize (one);\n+  two   = no_optimize (two);\n+  three = no_optimize (three);\n+  four  = no_optimize (four);\n+  five  = no_optimize (five);\n+#endif\n+\n+  add_xresult = (one + two);\n+  do_test (add_result, add_xresult, \"add\");\n+\n+  mul_xresult = add_xresult * three;\n+  do_test (mul_result, mul_xresult, \"mul\");\n+\n+  div_xresult = mul_xresult / four;\n+  do_test (div_result, div_xresult, \"div\");\n+\n+  sub_xresult = div_xresult - five;\n+  do_test (sub_result, sub_xresult, \"sub\");\n+\n+  neg_xresult = - sub_xresult;\n+  do_test (neg_result, neg_xresult, \"neg\");\n+\n+#ifdef DEBUG\n+  printf (\"Passed\\n\");\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "f3cfee9baae4d0e9105b6685ec0132011bd4951a", "filename": "gcc/testsuite/gcc.target/powerpc/float128-5.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-5.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-O2 -mpower9-vector -mno-float128\" } */\n+\n+/* Test that we can use #pragma GCC target to enable -mfloat128 and generate\n+   code on ISA 3.0 for the float128 built-in functions.  */\n+\n+#ifdef __FLOAT128__\n+#error \"-mno-float128 should disable initially defining __FLOAT128__\"\n+#endif\n+\n+#pragma GCC target(\"float128\")\n+\n+#ifndef __FLOAT128__\n+#error \"#pragma GCC target(\\\"float128\\\") should enable -mfloat128\"\n+#endif\n+\n+__float128\n+qabs (__float128 a)\n+{\n+  return __builtin_fabsq (a);\n+}\n+\n+/* { dg-final { scan-assembler \"xsabsqp\"  } } */"}, {"sha": "ede510d8484f19173fc349efeee44e6dc9e2cffa", "filename": "gcc/testsuite/gcc.target/powerpc/float128-cmp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmp.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run { target { powerpc*-*-linux* } } } */\n /* { dg-require-effective-target ppc_float128_sw } */\n-/* { dg-options \"-mvsx -O2 -mfloat128\" } */\n+/* { dg-options \"-mvsx -O2\" } */\n \n #include <stddef.h>\n #include <stdlib.h>"}, {"sha": "008cc17643f1cba81205264e11a2fc1659f138d4", "filename": "gcc/testsuite/gcc.target/powerpc/float128-complex-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-1.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,7 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-linux* } } } */\n /* { dg-require-effective-target powerpc_float128_sw_ok } */\n-/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-O2 -mcpu=power7 -mfloat128\" } */\n+/* { dg-options \"-O2 -mvsx\" } */\n \n #ifndef NO_FLOAT\n typedef _Complex float\tfloat_complex;"}, {"sha": "2364e1288c265f0a0ebd5d954cba01adaee411b3", "filename": "gcc/testsuite/gcc.target/powerpc/float128-complex-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-complex-2.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile { target { powerpc*-*-linux* } } } */\n /* { dg-require-effective-target powerpc_float128_hw_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n-/* { dg-options \"-O2 -mcpu=power9 -mfloat128 -mfloat128-hardware\" } */\n+/* { dg-options \"-O2 -mpower9-vector -mfloat128-hardware\" } */\n \n #ifndef NO_FLOAT\n typedef _Complex float\tfloat_complex;"}, {"sha": "68e4c27aa5869cb38556c10e0bd0ee8f6ac1e314", "filename": "gcc/testsuite/gcc.target/powerpc/float128-hw.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,7 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n /* { dg-require-effective-target powerpc_p9vector_ok } */\n-/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n-/* { dg-options \"-mcpu=power9 -O2 -mfloat128\" } */\n+/* { dg-options \"-mpower9-vector -O2\" } */\n \n __float128 f128_add (__float128 a, __float128 b) { return a+b; }\n __float128 f128_sub (__float128 a, __float128 b) { return a-b; }"}, {"sha": "71f840c9490d7189839006e7a5376542aae1c8ec", "filename": "gcc/testsuite/gcc.target/powerpc/float128-mix.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-mix.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,7 +1,6 @@\n /* { dg-do compile { target { powerpc*-*-linux* } } } */\n-/* { dg-require-effective-target powerpc_float128_sw_ok } */\n-/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n-/* { dg-options \"-O2 -mcpu=power7 -mfloat128\" } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mvsx\" } */\n \n \n /* Test to make sure that __float128 and long double cannot be combined together.  */"}, {"sha": "e148948a4b0cd36c2e1a6322344689de566f0f11", "filename": "gcc/testsuite/gcc.target/powerpc/float128-type-1.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-1.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,16 +1,21 @@\n /* { dg-do compile { target { powerpc64*-*-linux* && lp64 } } } */\n-/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n-/* { dg-options \"-mcpu=power8 -O2\" } */\n+/* { dg-options \"-mcpu=power8 -O2 -mno-float128\" } */\n \n-/* This test tests whether -mfloat128-type (which enables the underlying IEEE\n-   128-bit floating point) is enabled by default on VSX Linux 64-bit systems,\n-   even if the keywords __float128 and _Float128 (-mfloat128) are not enabled\n-   via the -mfloat128 switch.  Test that power8 generates a call to the\n+/* This test tests whether the underlying IEEE 128-bit floating point) is\n+   enabled by default on VSX Linux 64-bit systems, even if the keyword\n+   __float128 is not enabled .  Test that power8 generates a call to the\n    __addkf3 emulation function.  */\n \n+#ifdef __LONG_DOUBLE_IEEE128\n+typedef double          __attribute__((__mode__(__TF__))) f128_t;\n+typedef _Complex double __attribute__((__mode__(__TC__))) f128c_t;\n+\n+#else\n typedef double          __attribute__((__mode__(__KF__))) f128_t;\n typedef _Complex double __attribute__((__mode__(__KC__))) f128c_t;\n+#endif\n \n f128_t\n add_scalar (f128_t a, f128_t b)"}, {"sha": "99100f1d3dad1319399b4b0a208fafa04262db00", "filename": "gcc/testsuite/gcc.target/powerpc/float128-type-2.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd3510114011baa1be27dde94c55085678c34bf/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-type-2.c?ref=bbd3510114011baa1be27dde94c55085678c34bf", "patch": "@@ -1,19 +1,21 @@\n /* { dg-do compile { target { powerpc64-*-linux* && lp64 } } } */\n /* { dg-require-effective-target powerpc_p9vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n-/* { dg-options \"-mcpu=power9 -O2\" } */\n+/* { dg-options \"-mcpu=power9 -O2 -mno-float128\" } */\n \n-/* This test tests whether -mfloat128-type (which enables the underlying IEEE\n-   128-bit floating point) is enabled by default on VSX Linux 64-bit systems,\n-   even if the keywords __float128 and _Float128 (-mfloat128) are not enabled\n-   via the -mfloat128 switch.  Test that power9 generates the xsaddqp\n+/* This test tests whether the underlying IEEE 128-bit floating point) is\n+   enabled by default on VSX Linux 64-bit systems, even if the keyword\n+   __float128 is not enabled .  Test that power9 generates the xsaddqp\n    instruction.  */\n \n-/* The effective target powerpc_float128_hw_ok is not used, as that will pass\n-   -mfloat128.  */\n+#ifdef __LONG_DOUBLE_IEEE128\n+typedef double          __attribute__((__mode__(__TF__))) f128_t;\n+typedef _Complex double __attribute__((__mode__(__TC__))) f128c_t;\n \n+#else\n typedef double          __attribute__((__mode__(__KF__))) f128_t;\n typedef _Complex double __attribute__((__mode__(__KC__))) f128c_t;\n+#endif\n \n f128_t\n add_scalar (f128_t a, f128_t b)"}]}