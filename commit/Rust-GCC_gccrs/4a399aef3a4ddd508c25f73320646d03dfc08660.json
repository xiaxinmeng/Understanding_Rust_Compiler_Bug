{"sha": "4a399aef3a4ddd508c25f73320646d03dfc08660", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEzOTlhZWYzYTRkZGQ1MDhjMjVmNzMzMjA2NDZkMDNkZmMwODY2MA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2007-03-26T20:49:17Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2007-03-26T20:49:17Z"}, "message": "vec.h: Remove all #if IN_GENGTYPE blocks.\n\n\t* vec.h: Remove all #if IN_GENGTYPE blocks.\n\tAdd comment saying that changes may require adjustments to gengtype.\n\t* gengtype.c: Don't include coretypes.h or tm.h.\n\tAdd comment to inclusion of errors.h.\n\t(note_def_vec, note_def_vec_alloc): New functions.\n\t* gengtype.h: Declare new functions.\n\t* gengtype-lex.l: Don't include coretypes.h.\n\t(YY_INPUT, macro_input, push_macro_expansion, mangle_macro_name):\n\tDelete.\n\t(update_lineno): Remove unnecessary prototype.\n\t(DEF_VEC_* rules): Simplify using note_def_vec / note_def_vec_alloc.\n\t(VEC rule): Just return VEC_TOKEN.\n\t* gengtype-yacc.y (VEC_TOKEN): New token type.\n\t(type): Add a production for VEC(a,b).\n\t* Makefile.in: Update dependencies.\n\nFrom-SVN: r123229", "tree": {"sha": "5c5425e795d5f2118efc197d6f1f21ff945b4933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c5425e795d5f2118efc197d6f1f21ff945b4933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a399aef3a4ddd508c25f73320646d03dfc08660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a399aef3a4ddd508c25f73320646d03dfc08660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a399aef3a4ddd508c25f73320646d03dfc08660", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a399aef3a4ddd508c25f73320646d03dfc08660/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d287ace688a2c48801eb479c7a60948a939c00aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d287ace688a2c48801eb479c7a60948a939c00aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d287ace688a2c48801eb479c7a60948a939c00aa"}], "stats": {"total": 427, "additions": 165, "deletions": 262}, "files": [{"sha": "077fc93f9364ba30c9be1879ed08c65e4e70a0c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a399aef3a4ddd508c25f73320646d03dfc08660", "patch": "@@ -1,5 +1,21 @@\n 2007-03-26  Zack Weinberg  <zackw@panix.com>\n \n+\t* vec.h: Remove all #if IN_GENGTYPE blocks.\n+\tAdd comment saying that changes may require adjustments to gengtype.\n+\t* gengtype.c: Don't include coretypes.h or tm.h.\n+\tAdd comment to inclusion of errors.h.\n+\t(note_def_vec, note_def_vec_alloc): New functions.\n+\t* gengtype.h: Declare new functions.\n+\t* gengtype-lex.l: Don't include coretypes.h.\n+\t(YY_INPUT, macro_input, push_macro_expansion, mangle_macro_name):\n+\tDelete.\n+\t(update_lineno): Remove unnecessary prototype.\n+\t(DEF_VEC_* rules): Simplify using note_def_vec / note_def_vec_alloc.\n+\t(VEC rule): Just return VEC_TOKEN.\n+\t* gengtype-yacc.y (VEC_TOKEN): New token type.\n+\t(type): Add a production for VEC(a,b).\n+\t* Makefile.in: Update dependencies.\n+\n \t* gengtype-lex.l: Remove rules for parsing pointer-to-function\n \ttypedefs that use the old PARAMS macro.\n "}, {"sha": "c51376c98969a32132be81cab173f707e08a4805", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4a399aef3a4ddd508c25f73320646d03dfc08660", "patch": "@@ -3138,11 +3138,11 @@ build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h\n build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def\n build/gengtype-lex.o : gengtype-lex.c gengtype.h gengtype-yacc.h\t\\\n-  $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) vec.h\n+  $(BCONFIG_H) $(SYSTEM_H)\n build/gengtype-yacc.o : gengtype-yacc.c gengtype.h $(BCONFIG_H)\t\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H)\n-build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n-  $(GTM_H) gengtype.h gtyp-gen.h rtl.def insn-notes.def errors.h\n+  $(SYSTEM_H)\n+build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) gengtype.h \t\\\n+  gtyp-gen.h rtl.def insn-notes.def errors.h\n build/genmddeps.o: genmddeps.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H) errors.h gensupport.h\n build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h\t\t\\"}, {"sha": "ad4b1d545120b8139baacb7788b77016d28187d4", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 52, "deletions": 233, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=4a399aef3a4ddd508c25f73320646d03dfc08660", "patch": "@@ -21,7 +21,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n %{\n #include \"bconfig.h\"\n-#include \"coretypes.h\"\n #include \"system.h\"\n \n #define malloc xmalloc\n@@ -30,15 +29,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"gengtype.h\"\n #include \"gengtype-yacc.h\"\n \n-#define YY_INPUT(BUF,RESULT,SIZE) ((RESULT) = macro_input (BUF,SIZE))\n-\n-static unsigned macro_input (char *buffer, unsigned);\n-static const char *push_macro_expansion (const char *, unsigned,\n-\t\t\t\t\t const char *, unsigned);\n-static char *mangle_macro_name (const char *, unsigned,\n-       \t\t\t        const char *, unsigned);\n-static void update_lineno (const char *l, size_t len);\n-\n struct fileloc lexer_line;\n int lexer_toplevel_done;\n \n@@ -199,40 +189,58 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   return ENT_EXTERNSTATIC;\n }\n \n-^\"DEF_VEC_\"[[:alnum:]_]*{WS}?\"(\"{WS}?{ID}{WS}?(\",\"{WS}?{ID}{WS}?)*\")\" {\n-  char *macro, *arg;\n-  unsigned macro_len, arg_len;\n-  char *ptr = yytext;\n-  const char *additional;\n-  type_p t;\n-\n-  /* Find the macro name.  */\n-  for (macro = ptr; *ptr != '(' && !ISSPACE (*ptr); ptr++)\n-    continue;\n-  for (macro_len = ptr - macro; !(ISALNUM (*ptr) || *ptr == '_'); ptr++)\n-    continue;\n-\n-  /* Find the argument(s).  */\n-  for (arg = ptr; *ptr != ')'; ptr++)\n-    continue;\n-  arg_len = ptr - arg;\n-\n-  /* Create the struct and typedef.  */\n-  ptr = mangle_macro_name (\"VEC\", 3, arg, arg_len);\n-\n-  t = find_structure (ptr, 0);\n-  do_typedef (ptr, t, &lexer_line);\n-\n-  /* Push the macro for later expansion.  */\n-  additional = push_macro_expansion (macro, macro_len, arg, arg_len);\n+^\"DEF_VEC_\"[IPO]{WS}?\"(\"{WS}?{ID}{WS}?\")\" {\n+  /* Definition of a generic VEC structure.  If the letter after\n+     DEF_VEC_ is \"I\", the structure definition is slightly different\n+     than if it is \"P\" or \"O\".  */\n+\n+  char *p = yytext + sizeof(\"DEF_VEC_\") - 1;\n+  char *q;\n+  const char *type;\n+  bool is_I = (*p == 'I');\n+\n+  /* Extract the argument to the macro.  */\n+  p++;\n+  while (!ISALNUM(*p) && *p != '_')\n+    p++;\n+  q = p;\n+  while (ISALNUM(*q) || *q == '_')\n+    ++;\n+  type = xmemdup (p, q - p, q - p + 1);\n+\n+  note_def_vec (type, is_I, &lexer_line);\n+  note_def_vec_alloc (type, \"none\", &lexer_line);\n+}\n \n-  if (additional)\n-    {\n-      ptr = mangle_macro_name (ptr, strlen (ptr),\n-\t\t\t       additional, strlen (additional));\n-      t = find_structure (ptr, 0);\n-      do_typedef (ptr, t, &lexer_line);\n-    }\n+^\"DEF_VEC_ALLOC_\"[IPO]{WS}?\"(\"{WS}?{ID}{WS}?\",\"{WS}?{ID}{WS}?\")\" {\n+  /* Definition of an allocation strategy for a VEC structure.  For\n+     purposes of gengtype, this just declares a wrapper structure.  */\n+\n+  char *p = yytext + sizeof(\"DEF_VEC_ALLOC_I\") - 1;\n+  char *q;\n+  char *type, *astrat;\n+\n+  /* Extract the two arguments to the macro.  */\n+  while (!ISALNUM(*p) && *p != '_')\n+    p++;\n+  q = p;\n+  while (ISALNUM(*q) || *q == '_')\n+    q++;\n+  type = alloca (q - p + 1);\n+  memcpy (type, p, q - p);\n+  type[q - p] = '\\0';\n+  p = q;\n+\n+  while (!ISALNUM(*p) && *p != '_')\n+    p++;\n+  q = p;\n+  while (ISALNUM(*q) || *q == '_')\n+    q++;\n+  astrat = alloca (q - p + 1);\n+  memcpy (astrat, p, q - p);\n+  astrat[q - p] = '\\0';\n+\n+  note_def_vec_alloc (type, astrat, &lexer_line);\n }\n \n <in_struct>{\n@@ -243,6 +251,7 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n \n \"const\"/[^[:alnum:]_]\t\t/* don't care */\n \"GTY\"/[^[:alnum:]_]\t\t{ return GTY_TOKEN; }\n+\"VEC\"/[^[:alnum:]_]\t\t{ return VEC_TOKEN; }\n \"union\"/[^[:alnum:]_]\t\t{ return UNION; }\n \"struct\"/[^[:alnum:]_]\t\t{ return STRUCT; }\n \"enum\"/[^[:alnum:]_]\t\t{ return ENUM; }\n@@ -266,26 +275,6 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   return SCALAR;\n }\n \n-\"VEC\"{WS}?\"(\"{WS}?{ID}{WS}?(\",\"{WS}?{ID}{WS}?)*\")\" {\n-  char *macro, *arg;\n-  unsigned macro_len, arg_len;\n-  char *ptr = yytext;\n-\n-  /* Find the macro name */\n-  for (macro = ptr; *ptr != '(' && !ISSPACE (*ptr); ptr++)\n-    continue;\n-  for (macro_len = ptr - macro; !(ISALNUM(*ptr) || *ptr == '_'); ptr++)\n-    continue;\n-\n-  /* Find the arguments.  */\n-  for (arg = ptr; *ptr != ')'; ptr++)\n-    continue;\n-  arg_len = ptr - arg;\n-\n-  ptr = mangle_macro_name (macro, macro_len, arg, arg_len);\n-  yylval.s = ptr;\n-  return ID;\n-}\n \n {ID}/[^[:alnum:]_]\t\t{\n   yylval.s = (const char *) xmemdup (yytext, yyleng, yyleng+1);\n@@ -353,176 +342,6 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n \n %%\n \n-/* Deal with the expansion caused by the DEF_VEC_x macros.  */\n-\n-/* Mangle a macro and argument list as done by cpp concatenation in\n-   the compiler proper.  */\n-static char *\n-mangle_macro_name (const char *macro, unsigned macro_len,\n-\t\t   const char *arg, unsigned arg_len)\n-{\n-  char *ptr = (char *) xmemdup (macro, macro_len, macro_len + arg_len + 2);\n-\n-  /* Now copy and concatenate each argument */\n-  while (arg_len)\n-    {\n-      ptr[macro_len++] = '_';\n-      for (; arg_len && (ISALNUM(*arg) || *arg == '_'); arg_len--)\n-        ptr[macro_len++] = *arg++;\n-      for (; arg_len && !(ISALNUM(*arg) || *arg == '_'); arg_len--)\n-        arg++;\n-    }\n-  ptr[macro_len] = 0;\n-\n-  return ptr;\n-}\n-\n-typedef struct macro_def\n-{\n-  const char *name;\n-  const char *expansion;\n-  const char *additional;\n-} macro_def_t;\n-\n-typedef struct macro\n-{\n-  const macro_def_t *def;\n-  struct macro *next;\n-  const char *args[10];\n-} macro_t;\n-\n-static const macro_def_t macro_defs[] = \n-{\n-#define IN_GENGTYPE 1\n-#include \"vec.h\"\n-  {NULL, NULL, NULL}\n-};\n-\n-/* Chain of macro expansions to do at end of scanning.  */\n-static macro_t *macro_expns;\n-static macro_t *macro_expns_end;\n-\n-/* Push macro NAME (NAME_LEN) with argument ARG (ARG_LEN) onto the\n-   expansion queue.  We ensure NAME is known at this point.  */\n-\n-static const char *\n-push_macro_expansion (const char *name, unsigned name_len,\n-\t\t      const char *arg, unsigned arg_len)\n-{\n-  unsigned ix;\n-\n-  for (ix = 0; macro_defs[ix].name; ix++)\n-    if (strlen (macro_defs[ix].name) == name_len\n-        && !memcmp (name, macro_defs[ix].name, name_len))\n-      {\n-        macro_t *expansion = XNEW (macro_t);\n-        char *args;\n-\tunsigned argno, last_arg;\n-\n-\texpansion->def = &macro_defs[ix];\n-\texpansion->next = NULL;\n-\targs = (char *) xmemdup (arg, arg_len, arg_len+1);\n-\targs[arg_len] = 0;\n-        for (argno = 0; *args;)\n-\t  {\n-   \t    expansion->args[argno++] = args;\n-\t    while (*args && (ISALNUM (*args) || *args == '_'))\n-\t      args++;\n-\t    if (argno == 1)\n-\t      expansion->args[argno++] = \"base\";\n-\t    if (!*args)\n-\t      break;\n-\t    *args++ = 0;\n-\t    while (*args && !(ISALNUM (*args) || *args == '_'))\n-\t      args++;\n-          }\n-\tlast_arg = argno;\n-        for (; argno != 10; argno++)\n-\t  expansion->args[argno] = NULL;\n-\tif (macro_expns_end)\n-          macro_expns_end->next = expansion;\n-\telse\n-\t  macro_expns = expansion;\n-\tmacro_expns_end = expansion;\n-\tif (macro_defs[ix].additional)\n-\t  {\n-\t    macro_t *expn2 = XNEW (macro_t);\n-            memcpy (expn2, expansion, sizeof (*expn2));\n-\t    expansion = expn2;\n-\t    expansion->def += 1;\n-\t    expansion->args[last_arg++] = macro_defs[ix].additional;\n-\t    macro_expns_end->next = expansion;\n-\t    macro_expns_end = expansion;\n-\t  }\n-        if (last_arg > 2 && strcmp (expansion->args[last_arg - 1], \"heap\"))\n-\t  expansion->args[last_arg++] = \"GTY (())\";\n-\treturn macro_defs[ix].additional;\n-      }\n-  error_at_line (&lexer_line, \"unrecognized macro `%.*s(%.*s)'\",\n-\t\t name_len, name, arg_len, arg);\n-  return NULL;\n-}\n-\n-/* Attempt to read some input.  Use fread until we're at the end of\n-   file.  At end of file expand the next queued macro.  We presume the\n-   buffer is large enough for the entire expansion.  */\n-\n-static unsigned\n-macro_input (char *buffer, unsigned size)\n-{\n-  unsigned result;\n-\n-  result = fread (buffer, 1, size, yyin);\n-  if (result)\n-    /*NOP*/;\n-  else if (ferror (yyin))\n-    YY_FATAL_ERROR (\"read of source file failed\");\n-  else if (macro_expns)\n-    {\n-      const char *expn;\n-      unsigned len;\n-\n-      for (expn = macro_expns->def->expansion; *expn; expn++)\n-        {\n-\t  if (*expn == '#')\n-\t    {\n-\t      int argno;\n-\n-\t      argno = expn[1] - '0';\n-\t      expn += 1;\n-\n-\t      /* Remove inserted space? */\n-\t      if (buffer[result-1] == ' ' && buffer[result-2] == '_')\n-\t        result--;\n-\n-\t      /* Insert the argument value */\n-\t      if (macro_expns->args[argno])\n-\t        {\n-\t\t  len = strlen (macro_expns->args[argno]);\n-\t\t  memcpy (&buffer[result], macro_expns->args[argno], len);\n-\t\t  result += len;\n-\t\t}\n-\n-\t      /* Skip next space? */\n-\t      if (expn[1] == ' ' && expn[2] == '_')\n-\t        expn++;\n-\t    }\n-\t  else\n-\t    {\n-\t      buffer[result++] = *expn;\n-\t      if (*expn == ';' || *expn == '{')\n-\t        buffer[result++] = '\\n';\n-\t    }\n-        }\n-      if (result > size)\n-        YY_FATAL_ERROR (\"buffer too small to expand macro\");\n-      macro_expns = macro_expns->next;\n-      if (!macro_expns)\n-        macro_expns_end = NULL;\n-    }\n-  return result;\n-}\n-\n void\n yyerror (const char *s)\n {"}, {"sha": "e97e88a9809f15a5ad898e163b941704af68f4cf", "filename": "gcc/gengtype-yacc.y", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=4a399aef3a4ddd508c25f73320646d03dfc08660", "patch": "@@ -39,6 +39,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n %token <t>ENT_STRUCT\n %token ENT_EXTERNSTATIC\n %token GTY_TOKEN\n+%token VEC_TOKEN\n %token UNION\n %token STRUCT\n %token ENUM\n@@ -160,6 +161,9 @@ type: SCALAR\n          { $$ = $1; }\n       | ID\n          { $$ = resolve_typedef ($1, &lexer_line); }\n+      | VEC_TOKEN '(' ID ',' ID ')'\n+         { $$ = resolve_typedef (concat (\"VEC_\", $3, \"_\", $5, (char *)0),\n+\t      \t\t\t &lexer_line); }\n       | type '*'\n          { $$ = create_pointer ($1); }\n       | STRUCT ID '{' struct_fields '}'"}, {"sha": "beec06954b10a309ee82defda54c092e5ea3d17c", "filename": "gcc/gengtype.c", "status": "modified", "additions": 81, "deletions": 3, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=4a399aef3a4ddd508c25f73320646d03dfc08660", "patch": "@@ -21,11 +21,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"bconfig.h\"\n #include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n #include \"gengtype.h\"\n #include \"gtyp-gen.h\"\n-#include \"errors.h\"\n+#include \"errors.h\"\t/* for fatal */\n \n /* Nonzero iff an error has occurred.  */\n static int hit_error = 0;\n@@ -2996,6 +2994,86 @@ write_roots (pair_p variables)\n \t\t     \"gt_pch_scalar_rtab\");\n }\n \n+/* Record the definition of a generic VEC structure, as if we had expanded\n+   the macros in vec.h:\n+\n+   typedef struct VEC_<type>_base GTY(()) {\n+   unsigned num;\n+   unsigned alloc;\n+   <type> GTY((length (\"%h.num\"))) vec[1];\n+   } VEC_<type>_base\n+\n+   where the GTY(()) tags are only present if is_scalar is _false_.  */\n+\n+void\n+note_def_vec (const char *typename, bool is_scalar, struct fileloc *pos)\n+{\n+  pair_p f, fields;\n+  type_p t;\n+  options_p o;\n+  const char *name = concat (\"VEC_\", typename, \"_base\", (char *)0);\n+\n+  if (is_scalar)\n+    {\n+      t = create_scalar_type (typename, strlen (typename));\n+      o = 0;\n+    }\n+  else\n+    {\n+      t = resolve_typedef (typename, pos);\n+      o = create_option (0, \"length\", \"%h.num\");\n+    }\n+\n+  /* We assemble the field list in reverse order.  */\n+  f = XNEW (struct pair);\n+  f->type = adjust_field_type (create_array (t, \"1\"), o);\n+  f->name = \"vec\";\n+  f->opt = o;\n+  f->line = *pos;\n+  f->next = 0;\n+  fields = f;\n+\n+  f = XNEW (struct pair);\n+  f->type = adjust_field_type (create_scalar_type (\"unsigned\", 8), 0);\n+  f->name = \"alloc\";\n+  f->opt = 0;\n+  f->line = *pos;\n+  f->next = fields;\n+  fields = f;\n+\n+  f = XNEW (struct pair);\n+  f->type = adjust_field_type (create_scalar_type (\"unsigned\", 8), 0);\n+  f->name = \"num\";\n+  f->opt = 0;\n+  f->line = *pos;\n+  f->next = fields;\n+  fields = f;\n+\n+  do_typedef (name, new_structure (name, 0, pos, fields, 0), pos);\n+}\n+\n+/* Record the definition of an allocation-specific VEC structure, as if\n+   we had expanded the macros in vec.h:\n+\n+   typedef struct VEC_<type>_<astrat> {\n+     VEC_<type>_base base;\n+   } VEC_<type>_<astrat>;\n+*/\n+void\n+note_def_vec_alloc (const char *type, const char *astrat, struct fileloc *pos)\n+{\n+  const char *astratname = concat (\"VEC_\", type, \"_\", astrat, (char *)0);\n+  const char *basename = concat (\"VEC_\", type, \"_base\", (char *)0);\n+\n+  pair_p field = XNEW (struct pair);\n+  field->name = \"base\";\n+  field->type = adjust_field_type (resolve_typedef (basename, pos), 0);\n+  field->line = *pos;\n+  field->next = 0;\n+\n+  do_typedef (astratname, new_structure (astratname, 0, pos, field, 0), pos);\n+}\n+\n \f\n extern int main (int argc, char **argv);\n int"}, {"sha": "034a7314cbbdf0039c21e80a69b06ab1fd3cb4d0", "filename": "gcc/gengtype.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=4a399aef3a4ddd508c25f73320646d03dfc08660", "patch": "@@ -144,6 +144,10 @@ extern options_p create_option (options_p, const char *name, const void *info);\n extern type_p adjust_field_type (type_p, options_p);\n extern void note_variable (const char *s, type_p t, options_p o,\n \t\t\t   struct fileloc *pos);\n+extern void note_def_vec (const char *typename, bool is_scalar,\n+\t\t\t  struct fileloc *pos);\n+extern void note_def_vec_alloc (const char *type, const char *astrat,\n+\t\t\t\tstruct fileloc *pos);\n \n /* Lexer and parser routines, most automatically generated.  */\n extern int yylex (void);"}, {"sha": "c8eabc99f8516522c64763b2abae24026c1959b2", "filename": "gcc/vec.h", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a399aef3a4ddd508c25f73320646d03dfc08660/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=4a399aef3a4ddd508c25f73320646d03dfc08660", "patch": "@@ -417,7 +417,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #define VEC_lower_bound(T,V,O,LT)    \\\n        (VEC_OP(T,base,lower_bound)(VEC_BASE(V),O,LT VEC_CHECK_INFO))\n \n-#if !IN_GENGTYPE\n /* Reallocate an array of elements with prefix.  */\n extern void *vec_gc_p_reserve (void *, int MEM_STAT_DECL);\n extern void *vec_gc_p_reserve_exact (void *, int MEM_STAT_DECL);\n@@ -451,14 +450,12 @@ extern void vec_assert_fail (const char *, const char * VEC_CHECK_DECL)\n #define VEC_ASSERT(EXPR,OP,T,A) (void)(EXPR)\n #endif\n \n+/* Note: gengtype has hardwired knowledge of the expansions of the\n+   VEC, DEF_VEC_*, and DEF_VEC_ALLOC_* macros.  If you change the\n+   expansions of these macros you may need to change gengtype too.  */\n+\n #define VEC(T,A) VEC_##T##_##A\n #define VEC_OP(T,A,OP) VEC_##T##_##A##_##OP\n-#else  /* IN_GENGTYPE */\n-#define VEC(T,A) VEC_ T _ A\n-#define VEC_STRINGIFY(X) VEC_STRINGIFY_(X)\n-#define VEC_STRINGIFY_(X) #X\n-#undef GTY\n-#endif /* IN_GENGTYPE */\n \n /* Base of vector type, not user visible.  */     \n #define VEC_T(T,B)\t\t\t\t\t\t\t  \\\n@@ -488,10 +485,6 @@ typedef struct VEC(T,A) GTY\t\t\t\t\t\t  \\\n #define VEC_BASE(P)  ((P) ? &(P)->base : 0)\n \n /* Vector of integer-like object.  */\n-#if IN_GENGTYPE\n-{\"DEF_VEC_I\", VEC_STRINGIFY (VEC_T(#0,#1)) \";\", \"none\"},\n-{\"DEF_VEC_ALLOC_I\", VEC_STRINGIFY (VEC_TA (#0,#1,#2,#3)) \";\", NULL},\n-#else\n #define DEF_VEC_I(T)\t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,must_be,integral_type) (void) \t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -506,13 +499,8 @@ struct vec_swallow_trailing_semi\n VEC_TA_GTY(T,base,A,);\t\t\t\t\t\t\t  \\\n DEF_VEC_ALLOC_FUNC_I(T,A)\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n-#endif\n \n /* Vector of pointer to object.  */\n-#if IN_GENGTYPE\n-{\"DEF_VEC_P\", VEC_STRINGIFY (VEC_T_GTY(#0,#1)) \";\", \"none\"},\n-{\"DEF_VEC_ALLOC_P\", VEC_STRINGIFY (VEC_TA_GTY (#0,#1,#2,#3)) \";\", NULL},\n-#else\n #define DEF_VEC_P(T) \t\t\t\t\t\t\t  \\\n static inline void VEC_OP (T,must_be,pointer_type) (void) \t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -527,7 +515,6 @@ struct vec_swallow_trailing_semi\n VEC_TA_GTY(T,base,A,);\t\t\t\t\t\t\t  \\\n DEF_VEC_ALLOC_FUNC_P(T,A)\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n-#endif\n \n #define DEF_VEC_FUNC_P(T)\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)   \\\n@@ -809,10 +796,6 @@ static inline T *VEC_OP (T,A,safe_insert)\t\t     \t  \t  \\\n }\n \n /* Vector of object.  */\n-#if IN_GENGTYPE\n-{\"DEF_VEC_O\", VEC_STRINGIFY (VEC_T_GTY(#0,#1)) \";\", \"none\"},\n-{\"DEF_VEC_ALLOC_O\", VEC_STRINGIFY (VEC_TA_GTY(#0,#1,#2,#3)) \";\", NULL},\n-#else\n #define DEF_VEC_O(T)\t\t\t\t\t\t\t  \\\n VEC_T_GTY(T,base);\t\t\t\t\t\t\t  \\\n VEC_TA_GTY(T,base,none,);\t\t\t\t\t\t  \\\n@@ -822,7 +805,6 @@ struct vec_swallow_trailing_semi\n VEC_TA_GTY(T,base,A,);\t\t\t\t\t\t\t  \\\n DEF_VEC_ALLOC_FUNC_O(T,A)\t\t\t\t\t\t  \\\n struct vec_swallow_trailing_semi\n-#endif\n \n #define DEF_VEC_FUNC_O(T)\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (T,base,length) (const VEC(T,base) *vec_)\t  \\"}]}