{"sha": "1b8ad134da972e9d151a068e4abfdfec883b0e9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI4YWQxMzRkYTk3MmU5ZDE1MWEwNjhlNGFiZmRmZWM4ODNiMGU5Zg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-07-29T06:21:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-07-29T06:21:12Z"}, "message": "pa.c (emit_move_sequence): Always convert scratch_reg to the proper mode before using it.\n\n        * pa.c (emit_move_sequence): Always convert scratch_reg to the\n        proper mode before using it.\n\nFrom-SVN: r28331", "tree": {"sha": "5e1ab7f3f9389ff660d20ba006bf05d36beed75e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e1ab7f3f9389ff660d20ba006bf05d36beed75e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b8ad134da972e9d151a068e4abfdfec883b0e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b8ad134da972e9d151a068e4abfdfec883b0e9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b8ad134da972e9d151a068e4abfdfec883b0e9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b8ad134da972e9d151a068e4abfdfec883b0e9f/comments", "author": null, "committer": null, "parents": [{"sha": "be44d23e64a7487fa9c23160ce24e5aae3aa7d19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be44d23e64a7487fa9c23160ce24e5aae3aa7d19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be44d23e64a7487fa9c23160ce24e5aae3aa7d19"}], "stats": {"total": 50, "additions": 46, "deletions": 4}, "files": [{"sha": "6fdd03c0e18759a22e3e259a2a91d697d3793a2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b8ad134da972e9d151a068e4abfdfec883b0e9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b8ad134da972e9d151a068e4abfdfec883b0e9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b8ad134da972e9d151a068e4abfdfec883b0e9f", "patch": "@@ -5,6 +5,9 @@ Wed Jul 28 12:50:48 1999  Geoff Keating  <geoffk@cygnus.com>\n \n Wed Jul 28 13:18:35 1999  Jeffrey A Law  (law@cygnus.com)\n \n+        * pa.c (emit_move_sequence): Always convert scratch_reg to the\n+        proper mode before using it.\n+\n \t* pa.md (adddi3, subdi3): Turn into a define_expand/define_insn\n \tpair.\n "}, {"sha": "42234321b8a18d2ca0d82eec990cf47c662d1e8e", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b8ad134da972e9d151a068e4abfdfec883b0e9f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b8ad134da972e9d151a068e4abfdfec883b0e9f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=1b8ad134da972e9d151a068e4abfdfec883b0e9f", "patch": "@@ -1100,7 +1100,11 @@ hppa_address_cost (X)\n \n    Return 1 if we have written out everything that needs to be done to\n    do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally.  */\n+   normally. \n+\n+   Note SCRATCH_REG may not be in the proper mode depending on how it\n+   will be used.  This routine is resposible for creating a new copy\n+   of SCRATCH_REG in the proper mode.  */\n \n int\n emit_move_sequence (operands, mode, scratch_reg)\n@@ -1161,6 +1165,9 @@ emit_move_sequence (operands, mode, scratch_reg)\n       if (GET_CODE (operand1) == SUBREG)\n \toperand1 = XEXP (operand1, 0);\n \n+      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n+\t it in WORD_MODE regardless of what mode it was originally given\n+\t to us.  */\n       scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n \n       /* D might not fit in 14 bits either; for such cases load D into\n@@ -1190,7 +1197,11 @@ emit_move_sequence (operands, mode, scratch_reg)\n       if (GET_CODE (operand0) == SUBREG)\n \toperand0 = XEXP (operand0, 0);\n \n+      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n+\t it in WORD_MODE regardless of what mode it was originally given\n+\t to us.  */\n       scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+\n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n       if (!memory_address_p (Pmode, XEXP (operand0, 0)))\n@@ -1224,6 +1235,11 @@ emit_move_sequence (operands, mode, scratch_reg)\n     {\n       rtx xoperands[2];\n \n+      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n+\t it in WORD_MODE regardless of what mode it was originally given\n+\t to us.  */\n+      scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+\n       /* Force the constant into memory and put the address of the\n \t memory location into scratch_reg.  */\n       xoperands[0] = scratch_reg;\n@@ -1244,6 +1260,11 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t   && FP_REG_CLASS_P (REGNO_REG_CLASS (REGNO (operand1)))))\n \t   && scratch_reg)\n     {\n+      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n+\t it in WORD_MODE regardless of what mode it was originally given\n+\t to us.  */\n+      scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+\n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n       if (GET_CODE (operand1) == MEM\n@@ -1336,7 +1357,13 @@ emit_move_sequence (operands, mode, scratch_reg)\n \n \t      /* Figure out what (if any) scratch register to use.  */\n \t      if (reload_in_progress || reload_completed)\n-\t\tscratch_reg = scratch_reg ? scratch_reg : operand0;\n+\t\t{\n+\t\t  scratch_reg = scratch_reg ? scratch_reg : operand0;\n+\t\t  /* SCRATCH_REG will hold an address and maybe the actual\n+\t\t     data.  We want it in WORD_MODE regardless of what mode it\n+\t\t     was originally given to us.  */\n+\t\t  scratch_reg = gen_rtx_REG (word_mode, REGNO (scratch_reg));\n+\t\t}\n \t      else if (flag_pic)\n \t\tscratch_reg = gen_reg_rtx (Pmode);\n \n@@ -1388,7 +1415,13 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      rtx temp;\n \n \t      if (reload_in_progress || reload_completed)\n-\t\ttemp = scratch_reg ? scratch_reg : operand0;\n+\t\t{\n+\t\t  temp = scratch_reg ? scratch_reg : operand0;\n+\t\t  /* TEMP will hold an address and maybe the actual\n+\t\t     data.  We want it in WORD_MODE regardless of what mode it\n+\t\t     was originally given to us.  */\n+\t\t  temp = gen_rtx_REG (word_mode, REGNO (temp));\n+\t\t}\n \t      else\n \t\ttemp = gen_reg_rtx (Pmode);\n \n@@ -1421,7 +1454,13 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t      rtx temp, set;\n \n \t      if (reload_in_progress || reload_completed)\n-\t\ttemp = scratch_reg ? scratch_reg : operand0;\n+\t\t{\n+\t\t  temp = scratch_reg ? scratch_reg : operand0;\n+\t\t  /* TEMP will hold an address and maybe the actual\n+\t\t     data.  We want it in WORD_MODE regardless of what mode it\n+\t\t     was originally given to us.  */\n+\t\t  temp = gen_rtx_REG (word_mode, REGNO (temp));\n+\t\t}\n \t      else\n \t\ttemp = gen_reg_rtx (mode);\n "}]}