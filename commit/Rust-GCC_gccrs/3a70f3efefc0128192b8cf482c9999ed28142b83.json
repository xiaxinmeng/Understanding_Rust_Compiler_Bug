{"sha": "3a70f3efefc0128192b8cf482c9999ed28142b83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E3MGYzZWZlZmMwMTI4MTkyYjhjZjQ4MmM5OTk5ZWQyODE0MmI4Mw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-07-05T13:15:20Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-07-05T13:15:20Z"}, "message": "tree-vectorizer.c (new_loop_vec_info): Initialize LOOP_VINFO_COST_MODEL_MIN_ITERS.\n\n        * tree-vectorizer.c (new_loop_vec_info): Initialize\n        LOOP_VINFO_COST_MODEL_MIN_ITERS.\n        * tree-vectorizer.h (_loop_vec_info): Added new filed\n        min_profitable_iters.\n        (LOOP_VINFO_COST_MODEL_MIN_ITERS): New access macro to above new field.\n        (TARG_SCALAR_TO_VEC_COST): Define cost of scalar to vector operation.\n        * tree-vect-analyze.c (vect_analyze_operations): Set\n        LOOP_VINFO_COST_MODEL_MIN_ITERS.\n        * tree-vect-transform.c (vect_estimate_min_profitable_iters): Use\n        VEC_length to determine if there are any LOOP_VINFO_MAY_MISALIGN_STMTS.\n        Fix calculation of peel_iters_prologue. Move consideration of epilogue\n        and prologue cost to after they are computed.\n        (vect_model_induction_cost): Use TARG_SCALAR_TO_VEC_COST instead of\n        TARG_VEC_STMT_COST.\n        (vect_model_simple_cost): Takes additional argument dt. Consider cost\n        of creating vectors from scalars according to dt.\n        (vect_model_store_cost): Likewise.\n        (vectorizable_call): Use dt array instead of scalar dt. Call\n        vect_model_simple_cost with additional argument dt.\n        (vectorizable_assignment): Likewise.\n        (vectorizable_operation): Likewise.\n        (vectorizable_type_demotion): Likewise.\n        (vectorizable_type_promotion): Likewise.\n        (vectorizable_store): Use dt array instead of scalar dt. Call\n        vect_model_store_cost with additional argument dt.\n        (vect_do_peeling_for_loop_bound): Don't call\n        vect_estimate_min_profitable_iters. Instead, lookup\n        LOOP_VINFO_COST_MODEL_MIN_ITERS. Don't always print\n        \"may not be profitable\".\n\n        * gcc.dg/vect/costmodel/ppc: New directory.\n        * gcc.dg/vect/costmodel/ppc/ppc-costmodel-vect.exp: New.\n        * gcc.dg/vect/costmodel/ppc/costmodel-fast-math-vect-pr29925.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-31b.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-31c.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-31d.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-33.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-76a.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-76c.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-68a.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-68b.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-68c.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-68d.c: New test.\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-reduc-1char.c: New test.\n\t  * gcc.dg/vect/costmodel/i386/costmodel-vect-68.c: Now vectorized.\n\nFrom-SVN: r126368", "tree": {"sha": "ee93a0ac09d7ead4c5c794ce3dc4ce957c9b9d27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee93a0ac09d7ead4c5c794ce3dc4ce957c9b9d27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a70f3efefc0128192b8cf482c9999ed28142b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a70f3efefc0128192b8cf482c9999ed28142b83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a70f3efefc0128192b8cf482c9999ed28142b83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a70f3efefc0128192b8cf482c9999ed28142b83/comments", "author": null, "committer": null, "parents": [{"sha": "fd06b1700741dc4f9b1a8ce457f8eae8c9ad8c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd06b1700741dc4f9b1a8ce457f8eae8c9ad8c83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd06b1700741dc4f9b1a8ce457f8eae8c9ad8c83"}], "stats": {"total": 982, "additions": 913, "deletions": 69}, "files": [{"sha": "e39fb1431197b49273672a513218e950acaeb42a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -1,3 +1,35 @@\n+2007-07-05  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.c (new_loop_vec_info): Initialize\n+\tLOOP_VINFO_COST_MODEL_MIN_ITERS.\n+\t* tree-vectorizer.h (_loop_vec_info): Added new filed\n+\tmin_profitable_iters.\n+\t(LOOP_VINFO_COST_MODEL_MIN_ITERS): New access macro to above new field.\n+\t(TARG_SCALAR_TO_VEC_COST): Define cost of scalar to vector operation.\n+\t* tree-vect-analyze.c (vect_analyze_operations): Set\n+\tLOOP_VINFO_COST_MODEL_MIN_ITERS.\n+\t* tree-vect-transform.c (vect_estimate_min_profitable_iters): Use\n+\tVEC_length to determine if there are any LOOP_VINFO_MAY_MISALIGN_STMTS.\n+\tFix calculation of peel_iters_prologue. Move consideration of epilogue\n+\tand prologue cost to after they are computed.\n+\t(vect_model_induction_cost): Use TARG_SCALAR_TO_VEC_COST instead of\n+\tTARG_VEC_STMT_COST.\n+\t(vect_model_simple_cost): Takes additional argument dt. Consider cost\n+\tof creating vectors from scalars according to dt.\n+\t(vect_model_store_cost): Likewise.\n+\t(vectorizable_call): Use dt array instead of scalar dt. Call\n+\tvect_model_simple_cost with additional argument dt.\n+\t(vectorizable_assignment): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_type_demotion): Likewise.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vectorizable_store): Use dt array instead of scalar dt. Call\n+\tvect_model_store_cost with additional argument dt.\n+\t(vect_do_peeling_for_loop_bound): Don't call\n+\tvect_estimate_min_profitable_iters. Instead, lookup\n+\tLOOP_VINFO_COST_MODEL_MIN_ITERS. Don't always print\n+\t\"may not be profitable\".\t\n+\n 2007-07-05  Dorit Nuzman  <dorit@il.ibm.com>\n \n \tPR testsuite/32014"}, {"sha": "d2ff6b2b8d3baf8167e05a1b351c54e8b31e1ed4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -1,3 +1,23 @@\n+2007-07-05  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/costmodel/ppc: New directory.\n+\t* gcc.dg/vect/costmodel/ppc/ppc-costmodel-vect.exp: New.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-fast-math-vect-pr29925.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-31b.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-31c.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-31d.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-33.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-76a.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-76c.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-68a.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-68b.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-68c.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-68d.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-reduc-1char.c: New test.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-68.c: Now vectorized.\t\n+\n 2007-07-05  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/32359"}, {"sha": "b916cd91dfb5bce1ae70200ac63fd28ff4abac3b", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-68.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-68.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -84,6 +84,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9347d05ea2d981d9beaf9e5287079fac3c7a5bba", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-fast-math-vect-pr29925.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-fast-math-vect-pr29925.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-fast-math-vect-pr29925.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-fast-math-vect-pr29925.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdlib.h>\n+#include \"../../tree-vect.h\"\n+\n+void interp_pitch(float *exc, float *interp, int pitch, int len)\n+{\n+   int i,k;\n+   int maxj;\n+\n+   maxj=3;\n+   for (i=0;i<len;i++)\n+   {\n+      float tmp = 0;\n+      for (k=0;k<7;k++)\n+      {\n+         tmp += exc[i-pitch+k+maxj-6];\n+      }\n+      interp[i] = tmp;\n+   }\n+}\n+\n+int main()\n+{\n+   float *exc = calloc(126,sizeof(float));\n+   float *interp = calloc(80,sizeof(float));\n+   int pitch = -35;\n+\n+   check_vect ();\n+\n+   interp_pitch(exc, interp, pitch, 80);\n+   free(exc);\n+   free(interp);\n+   return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "272b3f0d73308eaeb64d0c9d4b963bd6cba90d81", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31a.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31a.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* unaligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.b[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.b[i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b3224f943d6238ec34469a0b4fa121f9670b18ab", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31b.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31b.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* aligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.c[i] = 6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.c[i] != 6)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9dcd09aba42ab3266c68ead749fa3e1e851d73e1", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31c.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31c.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* aligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.d.k[i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.d.k[i] != 7)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "3c811f0a4accf65e7b8c218c6a153c5a913cdb02", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-31d.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-31d.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* unaligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.e.k[i] = 8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.e.k[i] != 8)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "feaf58591300b775dbf5458cb6f38f51860e51d2", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-33.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-33.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16\n+struct test {\n+  char ca[N];\n+};\n+\n+extern struct test s;\n+ \n+int main1 ()\n+{  \n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      s.ca[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (s.ca[i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d0d40ac338a310a2d044d807f3fb56d3188becd9", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68a.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68a.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 1. unaligned */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.a.n[1][2][i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N; i++)\n+    {\n+      if (tmp1.a.n[1][2][i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4e52af8b851fefe2d6ef2f131f6a48e91043cc57", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68b.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68b.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 2. aligned */\n+  for (i = 3; i < N-1; i++)\n+    {\n+      tmp1.a.n[1][2][i] = 6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 3; i < N-1; i++)\n+    {\n+      if (tmp1.a.n[1][2][i] != 6)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "58c5e9fdbe5488a3642e6a624d8932d6d221248f", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68c.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68c.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 3. aligned */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.e.n[1][2][i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (tmp1.e.n[1][2][i] != 7)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "df30caae047a3b8ea670c705f139e54e6c42440b", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-68d.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-68d.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 20\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 4. unaligned */\n+  for (i = 3; i < N-3; i++)\n+    {\n+      tmp1.e.n[1][2][i] = 8;\n+    }\n+ \n+  /* check results:  */\n+  for (i = 3; i <N-3; i++)\n+    {\n+      if (tmp1.e.n[1][2][i] != 8)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "41fe3aebf90a37f9d3db09a47d89bdf9b8ca6a90", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76a.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76a.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 8\n+#define OFF 4\n+\n+/* Check handling of accesses for which the \"initial condition\" -\n+   the expression that represents the first location accessed - is\n+   more involved than just an ssa_name.  */\n+\n+int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+int main1 (int *pib)\n+{\n+  int i;\n+  int ia[N+OFF];\n+  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+  for (i = OFF; i < N; i++)\n+    {\n+      ia[i] = pib[i - OFF];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = OFF; i < N; i++)\n+    {\n+     if (ia[i] != pib[i - OFF])\n+        abort ();\n+    }\n+\n+  return 0;  \n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (&ib[OFF]);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "08b2239eb9fb940c8040727b8414ed92a7a9c6ac", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76b.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76b.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 8\n+#define OFF 4\n+\n+/* Check handling of accesses for which the \"initial condition\" -\n+   the expression that represents the first location accessed - is\n+   more involved than just an ssa_name.  */\n+\n+int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+int main1 (int *pib)\n+{\n+  int i;\n+  int ia[N+OFF];\n+  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+  for (i = OFF; i < N; i++)\n+    {\n+      pib[i - OFF] = ic[i];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = OFF; i < N; i++)\n+    {\n+     if (pib[i - OFF] != ic[i])\n+        abort ();\n+    }\n+\n+  return 0;  \n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (&ib[OFF]);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f6127ba873ba9d6c83865f42922fa2659debdee4", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-76c.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-76c.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 8\n+#define OFF 4\n+\n+/* Check handling of accesses for which the \"initial condition\" -\n+   the expression that represents the first location accessed - is\n+   more involved than just an ssa_name.  */\n+\n+int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+int main1 (int *pib)\n+{\n+  int i;\n+  int ia[N+OFF];\n+  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+  for (i = OFF; i < N; i++)\n+    {\n+      ia[i] = ic[i - OFF];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = OFF; i < N; i++)\n+    {\n+     if (ia[i] != ic[i - OFF])\n+        abort ();  \n+    }\n+\n+  return 0;  \n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (&ib[OFF]);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "cf5becc4908b0b67f1733cd102e2c7c4a3f520b4", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-reduc-1char.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-reduc-1char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-reduc-1char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-reduc-1char.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+void\n+main1 (unsigned char x, unsigned char max_result, unsigned char min_result)\n+{\n+  int i;\n+  unsigned char ub[N] = {1,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned char uc[N] = {1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned char udiff = 2;\n+  unsigned char umax = x;\n+  unsigned char umin = x;\n+\n+  for (i = 0; i < N; i++) {\n+    udiff += (unsigned char)(ub[i] - uc[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umax = umax < uc[i] ? uc[i] : umax;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umin = umin > uc[i] ? uc[i] : umin;\n+  }\n+\n+  /* check results:  */\n+  if (udiff != DIFF)\n+    abort ();\n+  if (umax != max_result)\n+    abort ();\n+  if (umin != min_result)\n+    abort ();\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100, 1);\n+  main1 (0, 15, 0);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "98af2ff85d9b7ab16887bdf488a7ec34e726a76a", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/ppc-costmodel-vect.exp", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -0,0 +1,82 @@\n+# Copyright (C) 1997, 2004, 2005, 2006 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Exit immediately if this isn't a powerpc target.\n+if { ![istarget powerpc*-*-*] } then {\n+  return\n+}\n+\n+# Skip targets not supporting -maltivec.\n+if ![is-effective-target powerpc_altivec_ok] {\n+  return\n+}\n+\n+# Set up flags used for tests that don't specify options.\n+set DEFAULT_VECTCFLAGS \"\"\n+\n+# These flags are used for all targets.\n+lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \"-fvect-cost-model\"\n+\n+# If the target system supports vector instructions, the default action\n+# for a test is 'run', otherwise it's 'compile'.  Save current default.\n+# Executing vector instructions on a system without hardware vector support\n+# is also disabled by a call to check_vect, but disabling execution here is\n+# more efficient.\n+global dg-do-what-default\n+set save-dg-do-what-default ${dg-do-what-default}\n+\n+lappend DEFAULT_VECTCFLAGS \"-maltivec\"\n+if [check_vmx_hw_available] {\n+    set dg-do-what-default run\n+} else {\n+    if [is-effective-target ilp32] {\n+        # Specify a cpu that supports VMX for compile-only tests.\n+        lappend DEFAULT_VECTCFLAGS \"-mcpu=7400\"\n+    }\n+    set dg-do-what-default compile\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+lappend DEFAULT_VECTCFLAGS \"-fdump-tree-vect-details\"\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-pr*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-vect-*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+#### Tests with special options\n+global SAVED_DEFAULT_VECTCFLAGS\n+set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n+\n+# -ffast-math tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-fast-math-vect*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+# Clean up.\n+set dg-do-what-default ${save-dg-do-what-default}\n+\n+# All done.\n+dg-finish"}, {"sha": "b916cd91dfb5bce1ae70200ac63fd28ff4abac3b", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-68.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-68.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -84,6 +84,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "2b8f318097328c0b88f8a0e8393f15e39c3ba2e9", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -482,7 +482,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   /* Analyze cost. Decide if worth while to vectorize.  */\n \n   min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n-\n+  LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo) = min_profitable_iters;\n   if (min_profitable_iters < 0)\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))"}, {"sha": "cecf1a086cc912fbcc585f8f35727069db00e199", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 93, "deletions": 64, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -97,6 +97,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n+  int byte_misalign;\n \n   /* Cost model disabled.  */\n   if (!flag_vect_cost_model)\n@@ -109,40 +110,14 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   /* Requires loop versioning tests to handle misalignment.\n      FIXME: Make cost depend on number of stmts in may_misalign list.  */\n \n-  if (LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+  if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n     {\n       vec_outside_cost += TARG_COND_BRANCH_COST;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n                  \"versioning.\\n\");\n     }\n \n-  /* Requires a prologue loop when peeling to handle misalignment. Add cost of\n-     two guards, one for the peeled loop and one for the vector loop.  */\n-\n-  peel_iters_prologue = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-  if (peel_iters_prologue)\n-    {\n-      vec_outside_cost += 2 * TARG_COND_BRANCH_COST;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"cost model: Adding cost of checks for \"\n-                 \"prologue.\\n\");\n-    }\n-\n- /* Requires an epilogue loop to finish up remaining iterations after vector\n-    loop. Add cost of two guards, one for the peeled loop and one for the\n-    vector loop.  */\n-\n-  if ((peel_iters_prologue < 0)\n-      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vf)\n-    {\n-      vec_outside_cost += 2 * TARG_COND_BRANCH_COST;\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"cost model : Adding cost of checks for \"\n-                 \"epilogue.\\n\");\n-    }\n-\n   /* Count statements in scalar loop.  Using this as scalar cost for a single\n      iteration for now.\n \n@@ -178,9 +153,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      TODO: Build an expression that represents peel_iters for prologue and\n      epilogue to be used in a run-time test.  */\n \n-  peel_iters_prologue = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+  byte_misalign = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n \n-  if (peel_iters_prologue < 0)\n+  if (byte_misalign < 0)\n     {\n       peel_iters_prologue = vf - 1;\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -197,6 +172,18 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n     }\n   else \n     {\n+      if (byte_misalign)\n+\t{\n+\t  struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n+\t  int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n+\t  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr)));\n+\t  int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+\t  peel_iters_prologue = nelements - (byte_misalign / element_size);\n+\t}\n+      else\n+\tpeel_iters_prologue = 0;\n+\n       if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n         {\n           peel_iters_epilogue = vf - 1;\n@@ -206,9 +193,37 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n                      \"loop iterations are unknown .\");\n         }\n       else      \n-        peel_iters_epilogue = \n-                     (LOOP_VINFO_INT_NITERS (loop_vinfo) - peel_iters_prologue)\n-                     % vf;\n+\t{\n+\t  int niters = LOOP_VINFO_INT_NITERS (loop_vinfo);\n+\t  peel_iters_prologue = niters < peel_iters_prologue ? \n+\t\t\t\t\tniters : peel_iters_prologue;\n+\t  peel_iters_epilogue = (niters - peel_iters_prologue) % vf;\n+\t}\n+    }\n+\n+  /* Requires a prologue loop when peeling to handle misalignment. Add cost of\n+     two guards, one for the peeled loop and one for the vector loop.  */\n+\n+  if (peel_iters_prologue)\n+    {\n+      vec_outside_cost += 2 * TARG_COND_BRANCH_COST;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model: Adding cost of checks for \"\n+                 \"prologue.\\n\");\n+    }\n+\n+ /* Requires an epilogue loop to finish up remaining iterations after vector\n+    loop. Add cost of two guards, one for the peeled loop and one for the\n+    vector loop.  */\n+\n+  if (peel_iters_epilogue\n+      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vf)\n+    {\n+      vec_outside_cost += 2 * TARG_COND_BRANCH_COST;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model : Adding cost of checks for \"\n+                 \"epilogue.\\n\");\n     }\n \n   vec_outside_cost += (peel_iters_prologue * scalar_single_iter_cost)\n@@ -356,7 +371,7 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n   /* loop cost for vec_loop.  */\n   STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = ncopies * TARG_VEC_STMT_COST;\n   /* prologue cost for vec_init and vec_step.  */\n-  STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = 2 * TARG_VEC_STMT_COST;\n+  STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = 2 * TARG_SCALAR_TO_VEC_COST;\n   \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_model_induction_cost: inside_cost = %d, \"\n@@ -372,10 +387,19 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n    be generated for the single vector op.  We will handle that shortly.  */\n \n static void\n-vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies)\n+vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies, enum vect_def_type *dt)\n {\n+  int i;\n+\n   STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = ncopies * TARG_VEC_STMT_COST;\n \n+  /* FORNOW: Assuming maximum 2 args per stmts.  */\n+  for (i=0; i<2; i++)\n+    {\n+      if (dt[i] == vect_constant_def || dt[i] == vect_invariant_def)\n+\tSTMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) += TARG_SCALAR_TO_VEC_COST; \n+    }\n+  \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_model_simple_cost: inside_cost = %d, \"\n              \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n@@ -407,11 +431,14 @@ vect_cost_strided_group_size (stmt_vec_info stmt_info)\n    has the overhead of the strided access attributed to it.  */\n \n static void\n-vect_model_store_cost (stmt_vec_info stmt_info, int ncopies)\n+vect_model_store_cost (stmt_vec_info stmt_info, int ncopies, enum vect_def_type dt)\n {\n   int cost = 0;\n   int group_size;\n \n+  if (dt == vect_constant_def || dt == vect_invariant_def)\n+    STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = TARG_SCALAR_TO_VEC_COST;\n+\n   /* Strided access?  */\n   if (DR_GROUP_FIRST_DR (stmt_info)) \n     group_size = vect_cost_strided_group_size (stmt_info);\n@@ -1275,6 +1302,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n \t/* FIXME: use build_constructor directly.  */\n \tvector_type = get_vectype_for_scalar_type (TREE_TYPE (def));\n         vec_inv = build_constructor_from_list (vector_type, t);\n+\n         return vect_init_vector (stmt, vec_inv, vector_type);\n       }\n \n@@ -2260,7 +2288,7 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   int nunits_out;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree fndecl, rhs, new_temp, def, def_stmt, rhs_type, lhs_type;\n-  enum vect_def_type dt[2];\n+  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   tree new_stmt;\n   int ncopies, j, nargs;\n   call_expr_arg_iterator iter;\n@@ -2373,7 +2401,7 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_call ===\");\n-      vect_model_simple_cost (stmt_info, ncopies);\n+      vect_model_simple_cost (stmt_info, ncopies, dt);\n       return true;\n     }\n \n@@ -2826,7 +2854,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   tree new_temp;\n   tree def, def_stmt;\n-  enum vect_def_type dt;\n+  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n \n@@ -2857,7 +2885,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     return false;\n \n   op = GIMPLE_STMT_OPERAND (stmt, 1);\n-  if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -2869,7 +2897,7 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_assignment ===\");\n-      vect_model_simple_cost (stmt_info, ncopies);\n+      vect_model_simple_cost (stmt_info, ncopies, dt);\n       return true;\n     }\n \n@@ -3003,7 +3031,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   int icode;\n   enum machine_mode optab_op2_mode;\n   tree def, def_stmt;\n-  enum vect_def_type dt0, dt1;\n+  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   tree new_stmt;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -3061,7 +3089,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     }\n \n   op0 = TREE_OPERAND (operation, 0);\n-  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n+  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -3071,7 +3099,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (op_type == binary_op)\n     {\n       op1 = TREE_OPERAND (operation, 1);\n-      if (!vect_is_simple_use (op1, loop_vinfo, &def_stmt, &def, &dt1))\n+      if (!vect_is_simple_use (op1, loop_vinfo, &def_stmt, &def, &dt[1]))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n@@ -3120,8 +3148,8 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t by a scalar shift operand.  */\n       optab_op2_mode = insn_data[icode].operand[2].mode;\n       if (! (VECTOR_MODE_P (optab_op2_mode)\n-\t     || dt1 == vect_constant_def\n-\t     || dt1 == vect_invariant_def))\n+\t     || dt[1] == vect_constant_def\n+\t     || dt[1] == vect_invariant_def))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"operand mode requires invariant argument.\");\n@@ -3134,7 +3162,7 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_operation ===\");\n-      vect_model_simple_cost (stmt_info, ncopies);\n+      vect_model_simple_cost (stmt_info, ncopies, dt);\n       return true;\n     }\n \n@@ -3228,9 +3256,9 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \t}\n       else\n \t{\n-\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \t  if (op_type == binary_op)\n-\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt1, vec_oprnd1);\n+\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd1);\n \t}\n \n       /* Arguments are ready. create the new vector stmt.  */\n@@ -3278,7 +3306,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n   enum tree_code code, code1 = ERROR_MARK;\n   tree new_temp;\n   tree def, def_stmt;\n-  enum vect_def_type dt0;\n+  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   tree new_stmt;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n@@ -3336,7 +3364,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n     return false;\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n+  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -3354,7 +3382,7 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n       STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_demotion ===\");\n-      vect_model_simple_cost (stmt_info, ncopies);\n+      vect_model_simple_cost (stmt_info, ncopies, dt);\n       return true;\n     }\n \n@@ -3377,12 +3405,12 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n       if (j == 0)\n \t{\n \t  vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n-\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \t}\n       else\n \t{\n-\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd1);\n-\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd1);\n+\t  vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \t}\n \n       /* Arguments are ready. Create the new vector stmt.  */\n@@ -3428,7 +3456,7 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n   tree decl1 = NULL_TREE, decl2 = NULL_TREE;\n   int op_type; \n   tree def, def_stmt;\n-  enum vect_def_type dt0, dt1;\n+  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   tree new_stmt;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n@@ -3486,7 +3514,7 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n     return false;\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt0))\n+  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"use not simple.\");\n@@ -3497,7 +3525,7 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n   if (op_type == binary_op)\n     {\n       op1 = TREE_OPERAND (operation, 1);\n-      if (!vect_is_simple_use (op1, loop_vinfo, &def_stmt, &def, &dt1))\n+      if (!vect_is_simple_use (op1, loop_vinfo, &def_stmt, &def, &dt[1]))\n         {\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n@@ -3517,7 +3545,7 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n       STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"=== vectorizable_promotion ===\");\n-      vect_model_simple_cost (stmt_info, 2*ncopies);\n+      vect_model_simple_cost (stmt_info, 2*ncopies, dt);\n       return true;\n     }\n \n@@ -3547,9 +3575,9 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n         }\n       else\n         {\n-\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt0, vec_oprnd0);\n+\t  vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \t  if (op_type == binary_op)\n-\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt1, vec_oprnd1);\n+\t    vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[1], vec_oprnd1);\n         }\n \n       /* Arguments are ready. Create the new vector stmt.  We are creating \n@@ -3838,7 +3866,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n-      vect_model_store_cost (stmt_info, ncopies);\n+      vect_model_store_cost (stmt_info, ncopies, dt);\n       return true;\n     }\n \n@@ -5423,8 +5451,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n   loop_num  = loop->num; \n \n   /* Analyze cost to set threshhold for vectorized loop.  */\n-  min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n-\n+  min_profitable_iters = LOOP_VINFO_COST_MODEL_MIN_ITERS (loop_vinfo);\n   min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND))\n                           * LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n \n@@ -5437,7 +5464,9 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n           || min_profitable_iters > min_scalar_loop_bound))\n     th = (unsigned) min_profitable_iters;\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (min_profitable_iters\n+      && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vectorization may not be profitable.\");\n \n   new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),"}, {"sha": "b0bb5076c583a569da6945db79393ea568ff42ea", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -1408,6 +1408,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_BBS (res) = bbs;\n   LOOP_VINFO_EXIT_COND (res) = NULL;\n   LOOP_VINFO_NITERS (res) = NULL;\n+  LOOP_VINFO_COST_MODEL_MIN_ITERS (res) = 0;\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n   LOOP_PEELING_FOR_ALIGNMENT (res) = 0;\n   LOOP_VINFO_VECT_FACTOR (res) = 0;"}, {"sha": "e5957ca4a3d8465ad06149c1ccc666013369e81f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a70f3efefc0128192b8cf482c9999ed28142b83/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=3a70f3efefc0128192b8cf482c9999ed28142b83", "patch": "@@ -99,6 +99,13 @@ typedef struct _loop_vec_info {\n   /* Number of iterations.  */\n   tree num_iters;\n \n+  /* Minimum number of iterations below which vectorization is expected to\n+     not be profitable (as estimated by the cost model). \n+     -1 indicates that vectorization will not be profitable.\n+     FORNOW: This field is an int. Will be a tree in the future, to represent\n+\t     values unknown at compile time.  */ \n+  int min_profitable_iters;  \n+  \n   /* Is the loop vectorizable? */\n   bool vectorizable;\n \n@@ -140,6 +147,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_BBS(L)             (L)->bbs\n #define LOOP_VINFO_EXIT_COND(L)       (L)->exit_cond\n #define LOOP_VINFO_NITERS(L)          (L)->num_iters\n+#define LOOP_VINFO_COST_MODEL_MIN_ITERS(L)\t(L)->min_profitable_iters\n #define LOOP_VINFO_VECTORIZABLE_P(L)  (L)->vectorizable\n #define LOOP_VINFO_VECT_FACTOR(L)     (L)->vectorization_factor\n #define LOOP_VINFO_PTR_MASK(L)        (L)->ptr_mask\n@@ -329,6 +337,11 @@ typedef struct _stmt_vec_info {\n #define TARG_VEC_TO_SCALAR_COST      1\n #endif\n \n+/* Cost of scalar to vector operation.  */\n+#ifndef TARG_SCALAR_TO_VEC_COST\n+#define TARG_SCALAR_TO_VEC_COST      1\n+#endif\n+\n /* Cost of aligned vector load.  */\n #ifndef TARG_VEC_LOAD_COST\n #define TARG_VEC_LOAD_COST           1"}]}