{"sha": "35a093b60bcc40cf31e47a2336b50311578fc973", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVhMDkzYjYwYmNjNDBjZjMxZTQ3YTIzMzZiNTAzMTE1NzhmYzk3Mw==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2016-02-16T16:02:09Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2016-02-16T16:02:09Z"}, "message": "[Patch AArch64] GCC 6 regression in vector performance. - Fix vector initialization to happen with lane load instructions.\n\ngcc/\n\n\t* config/aarch64/aarch64.c (aarch64_expand_vector_init): Refactor,\n\talways use lane loads to construct non-constant vectors.\n\ngcc/testsuite/\n\n\t* gcc.target/aarch64/vector_initialization_nostack.c: New.\n\n\nCo-Authored-By: Ramana Radhakrishnan <ramana.radhakrishnan@arm.com>\n\nFrom-SVN: r233461", "tree": {"sha": "b2c3f6801774f27a05ac2e7e0e6d644d1ad4f9c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2c3f6801774f27a05ac2e7e0e6d644d1ad4f9c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35a093b60bcc40cf31e47a2336b50311578fc973", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a093b60bcc40cf31e47a2336b50311578fc973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35a093b60bcc40cf31e47a2336b50311578fc973", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a093b60bcc40cf31e47a2336b50311578fc973/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "51b3f0773f84ef1e3aac56e687f67027c3fb070c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b3f0773f84ef1e3aac56e687f67027c3fb070c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b3f0773f84ef1e3aac56e687f67027c3fb070c"}], "stats": {"total": 120, "additions": 92, "deletions": 28}, "files": [{"sha": "08b3f0d43ee31490ccbfbe0865b4c9a78226d849", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a093b60bcc40cf31e47a2336b50311578fc973/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a093b60bcc40cf31e47a2336b50311578fc973/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35a093b60bcc40cf31e47a2336b50311578fc973", "patch": "@@ -1,3 +1,9 @@\n+2016-02-16  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_expand_vector_init): Refactor,\n+\talways use lane loads to construct non-constant vectors.\n+\n 2016-02-16  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64.md"}, {"sha": "974a789721b55a2806f1cfc13cf3712b17bc067b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a093b60bcc40cf31e47a2336b50311578fc973/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a093b60bcc40cf31e47a2336b50311578fc973/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=35a093b60bcc40cf31e47a2336b50311578fc973", "patch": "@@ -11053,28 +11053,37 @@ aarch64_simd_make_constant (rtx vals)\n     return NULL_RTX;\n }\n \n+/* Expand a vector initialisation sequence, such that TARGET is\n+   initialised to contain VALS.  */\n+\n void\n aarch64_expand_vector_init (rtx target, rtx vals)\n {\n   machine_mode mode = GET_MODE (target);\n   machine_mode inner_mode = GET_MODE_INNER (mode);\n+  /* The number of vector elements.  */\n   int n_elts = GET_MODE_NUNITS (mode);\n+  /* The number of vector elements which are not constant.  */\n   int n_var = 0;\n   rtx any_const = NULL_RTX;\n+  /* The first element of vals.  */\n+  rtx v0 = XVECEXP (vals, 0, 0);\n   bool all_same = true;\n \n+  /* Count the number of variable elements to initialise.  */\n   for (int i = 0; i < n_elts; ++i)\n     {\n       rtx x = XVECEXP (vals, 0, i);\n-      if (!CONST_INT_P (x) && !CONST_DOUBLE_P (x))\n+      if (!(CONST_INT_P (x) || CONST_DOUBLE_P (x)))\n \t++n_var;\n       else\n \tany_const = x;\n \n-      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n-\tall_same = false;\n+      all_same &= rtx_equal_p (x, v0);\n     }\n \n+  /* No variable elements, hand off to aarch64_simd_make_constant which knows\n+     how best to handle this.  */\n   if (n_var == 0)\n     {\n       rtx constant = aarch64_simd_make_constant (vals);\n@@ -11088,14 +11097,15 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n   /* Splat a single non-constant element if we can.  */\n   if (all_same)\n     {\n-      rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, 0));\n+      rtx x = copy_to_mode_reg (inner_mode, v0);\n       aarch64_emit_move (target, gen_rtx_VEC_DUPLICATE (mode, x));\n       return;\n     }\n \n-  /* Half the fields (or less) are non-constant.  Load constant then overwrite\n-     varying fields.  Hope that this is more efficient than using the stack.  */\n-  if (n_var <= n_elts/2)\n+  /* Initialise a vector which is part-variable.  We want to first try\n+     to build those lanes which are constant in the most efficient way we\n+     can.  */\n+  if (n_var != n_elts)\n     {\n       rtx copy = copy_rtx (vals);\n \n@@ -11122,31 +11132,21 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n \t  XVECEXP (copy, 0, i) = subst;\n \t}\n       aarch64_expand_vector_init (target, copy);\n+    }\n \n-      /* Insert variables.  */\n-      enum insn_code icode = optab_handler (vec_set_optab, mode);\n-      gcc_assert (icode != CODE_FOR_nothing);\n+  /* Insert the variable lanes directly.  */\n \n-      for (int i = 0; i < n_elts; i++)\n-\t{\n-\t  rtx x = XVECEXP (vals, 0, i);\n-\t  if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n-\t    continue;\n-\t  x = copy_to_mode_reg (inner_mode, x);\n-\t  emit_insn (GEN_FCN (icode) (target, x, GEN_INT (i)));\n-\t}\n-      return;\n-    }\n+  enum insn_code icode = optab_handler (vec_set_optab, mode);\n+  gcc_assert (icode != CODE_FOR_nothing);\n \n-  /* Construct the vector in memory one field at a time\n-     and load the whole vector.  */\n-  rtx mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n   for (int i = 0; i < n_elts; i++)\n-    emit_move_insn (adjust_address_nv (mem, inner_mode,\n-\t\t\t\t    i * GET_MODE_SIZE (inner_mode)),\n-\t\t    XVECEXP (vals, 0, i));\n-  emit_move_insn (target, mem);\n-\n+    {\n+      rtx x = XVECEXP (vals, 0, i);\n+      if (CONST_INT_P (x) || CONST_DOUBLE_P (x))\n+\tcontinue;\n+      x = copy_to_mode_reg (inner_mode, x);\n+      emit_insn (GEN_FCN (icode) (target, x, GEN_INT (i)));\n+    }\n }\n \n static unsigned HOST_WIDE_INT"}, {"sha": "cf1da01f8bab7046ba8140aaafc87a1db2ed9217", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a093b60bcc40cf31e47a2336b50311578fc973/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a093b60bcc40cf31e47a2336b50311578fc973/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35a093b60bcc40cf31e47a2336b50311578fc973", "patch": "@@ -1,3 +1,8 @@\n+2016-02-16  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\t* gcc.target/aarch64/vector_initialization_nostack.c: New.\n+\n 2016-02-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/69801"}, {"sha": "bbad04d00263b6a91b826b4911af92bdd226c821", "filename": "gcc/testsuite/gcc.target/aarch64/vector_initialization_nostack.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35a093b60bcc40cf31e47a2336b50311578fc973/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvector_initialization_nostack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35a093b60bcc40cf31e47a2336b50311578fc973/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvector_initialization_nostack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvector_initialization_nostack.c?ref=35a093b60bcc40cf31e47a2336b50311578fc973", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ftree-vectorize -fno-vect-cost-model\" } */\n+float arr_f[100][100];\n+float\n+f9 (void)\n+{\n+\n+  int i;\n+  float sum = 0;\n+  for (i = 0; i < 100; i++)\n+    sum += arr_f[i][0] * arr_f[0][i];\n+  return sum;\n+\n+}\n+\n+\n+int arr[100][100];\n+int\n+f10 (void)\n+{\n+\n+  int i;\n+  int sum = 0;\n+  for (i = 0; i < 100; i++)\n+    sum += arr[i][0] * arr[0][i];\n+  return sum;\n+\n+}\n+\n+double arr_d[100][100];\n+double\n+f11 (void)\n+{\n+  int i;\n+  double sum = 0;\n+  for (i = 0; i < 100; i++)\n+    sum += arr_d[i][0] * arr_d[0][i];\n+  return sum;\n+}\n+\n+char arr_c[100][100];\n+char\n+f12 (void)\n+{\n+  int i;\n+  char sum = 0;\n+  for (i = 0; i < 100; i++)\n+    sum += arr_c[i][0] * arr_c[0][i];\n+  return sum;\n+}\n+\n+\n+/* { dg-final { scan-assembler-not \"sp\" } } */"}]}