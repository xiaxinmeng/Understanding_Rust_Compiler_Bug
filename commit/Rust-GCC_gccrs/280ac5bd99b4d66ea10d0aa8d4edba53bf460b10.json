{"sha": "280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwYWM1YmQ5OWI0ZDY2ZWExMGQwYWE4ZDRlZGJhNTNiZjQ2MGIxMA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-03-10T18:10:06Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-03-22T20:01:30Z"}, "message": "Generics continued this adds more type resolution to ADT and Functions\n\nAdds recursive generic argument handling for structs and functions. With a\nnew substitution mapper class to coerce the HIR::GenericArgs appropriately.\nThis is the building block to work on impl blocks with generics and\nbetter Monomorphization support to handle duplicate functions etc.\n\nFixes: #236 #234 #235\nAddresses: #237", "tree": {"sha": "e67968afbe4668e6a2679ed961d137cdb409166d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e67968afbe4668e6a2679ed961d137cdb409166d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb33139efa7bbbd09ad26403c36a5dcf31e1b14e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb33139efa7bbbd09ad26403c36a5dcf31e1b14e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb33139efa7bbbd09ad26403c36a5dcf31e1b14e"}], "stats": {"total": 1384, "additions": 1082, "deletions": 302}, "files": [{"sha": "6f45e5784ad3c13015432067269dbef7a6606a34", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -61,10 +61,26 @@ class Context\n       }\n   }\n \n-  ~Context () {}\n-\n-  bool lookup_compiled_types (HirId id, ::Btype **type)\n+  bool lookup_compiled_types (HirId id, ::Btype **type,\n+\t\t\t      const TyTy::BaseType *ref = nullptr)\n   {\n+    if (ref != nullptr && ref->has_subsititions_defined ())\n+      {\n+\tfor (auto it = mono.begin (); it != mono.end (); it++)\n+\t  {\n+\t    std::pair<HirId, ::Btype *> &val = it->second;\n+\t    const TyTy::BaseType *r = it->first;\n+\n+\t    if (ref->is_equal (*r))\n+\t      {\n+\t\t*type = val.second;\n+\n+\t\treturn true;\n+\t      }\n+\t  }\n+\treturn false;\n+      }\n+\n     auto it = compiled_type_map.find (id);\n     if (it == compiled_type_map.end ())\n       return false;\n@@ -73,9 +89,15 @@ class Context\n     return true;\n   }\n \n-  void insert_compiled_type (HirId id, ::Btype *type)\n+  void insert_compiled_type (HirId id, ::Btype *type,\n+\t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n     compiled_type_map[id] = type;\n+    if (ref != nullptr)\n+      {\n+\tstd::pair<HirId, ::Btype *> elem (id, type);\n+\tmono[ref] = std::move (elem);\n+      }\n   }\n \n   ::Backend *get_backend () { return backend; }\n@@ -250,6 +272,7 @@ class Context\n   std::vector< ::Bblock *> scope_stack;\n   std::vector< ::Bvariable *> loop_value_stack;\n   std::vector< ::Blabel *> loop_begin_labels;\n+  std::map<const TyTy::BaseType *, std::pair<HirId, ::Btype *> > mono;\n \n   // To GCC middle-end\n   std::vector< ::Btype *> type_decls;\n@@ -274,12 +297,8 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ParamType &param) override\n   {\n-    rust_assert (param.get_ref () != param.get_ty_ref ());\n-\n-    TyTy::BaseType *lookup = nullptr;\n-    bool ok = ctx->get_tyctx ()->lookup_type (param.get_ty_ref (), &lookup);\n-    rust_assert (ok);\n-    lookup->accept_vis (*this);\n+    TyTy::TyVar var (param.get_ty_ref ());\n+    var.get_tyty ()->accept_vis (*this);\n   }\n \n   void visit (TyTy::FnType &type) override\n@@ -339,8 +358,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ADTType &type) override\n   {\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &translated);\n-    if (ok)\n+    if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n       return;\n \n     // create implicit struct\n@@ -361,11 +379,12 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     Btype *named_struct\n       = ctx->get_backend ()->named_type (type.get_name (), struct_type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t   type.get_ref ()));\n+\t\t\t\t\t   type.get_ty_ref ()));\n \n     ctx->push_type (named_struct);\n-    ctx->insert_compiled_type (type.get_ty_ref (), named_struct);\n     translated = named_struct;\n+\n+    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n   }\n \n   void visit (TyTy::TupleType &type) override\n@@ -485,7 +504,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n   }\n \n private:\n-  TyTyResolveCompile (Context *ctx) : ctx (ctx) {}\n+  TyTyResolveCompile (Context *ctx) : ctx (ctx), translated (nullptr) {}\n \n   Context *ctx;\n   ::Btype *translated;"}, {"sha": "08174247a4399a752706ec792b3626d75a244aa4", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -91,7 +91,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \treturn;\n       }\n \n-    TyTy::FnType *fntype = (TyTy::FnType *) fntype_tyty;\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n     // convert to the actual function type\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n@@ -108,7 +108,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n-    ctx->insert_function_decl (function.get_mappings ().get_hirid (), fndecl);\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n \n     // setup the params\n \n@@ -256,7 +256,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \treturn;\n       }\n \n-    TyTy::FnType *fntype = (TyTy::FnType *) fntype_tyty;\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n     // convert to the actual function type\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n@@ -273,7 +273,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, method.get_locus ());\n-    ctx->insert_function_decl (method.get_mappings ().get_hirid (), fndecl);\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();"}, {"sha": "2bbfe4cbee70033f016d008d65edd03ae647b173", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -35,9 +35,10 @@ class CompileItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static void compile (HIR::Item *item, Context *ctx, bool compile_fns = true)\n+  static void compile (HIR::Item *item, Context *ctx, bool compile_fns = true,\n+\t\t       TyTy::BaseType *concrete = nullptr)\n   {\n-    CompileItem compiler (ctx, compile_fns);\n+    CompileItem compiler (ctx, compile_fns, concrete);\n     item->accept_vis (compiler);\n   }\n \n@@ -118,8 +119,22 @@ class CompileItem : public HIRCompileBase\n \treturn;\n       }\n \n-    TyTy::FnType *fntype = (TyTy::FnType *) fntype_tyty;\n-    // convert to the actual function type\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// we cant do anything for this only when it is used\n+\tif (concrete == nullptr)\n+\t  return;\n+\telse\n+\t  {\n+\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+\t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\n+\t    // override the Hir Lookups for the substituions in this context\n+\t    fntype->override_context ();\n+\t  }\n+      }\n+\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n@@ -130,21 +145,30 @@ class CompileItem : public HIRCompileBase\n     if (is_main_fn || function.has_visibility ())\n       flags |= Backend::function_is_visible;\n \n+    std::string ir_symbol_name = function.get_function_name ();\n     std::string asm_name = function.get_function_name ();\n     if (!is_main_fn)\n       {\n \t// FIXME need name mangling\n-\tasm_name = \"__\" + function.get_function_name ();\n+\tif (concrete == nullptr)\n+\t  asm_name = \"__\" + function.get_function_name ();\n+\telse\n+\t  {\n+\t    ir_symbol_name\n+\t      = function.get_function_name () + fntype->subst_as_string ();\n+\n+\t    asm_name = \"__\" + function.get_function_name ();\n+\t    for (auto &sub : fntype->get_substs ())\n+\t      asm_name += \"G\" + sub.as_string ();\n+\t  }\n       }\n \n     Bfunction *fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type,\n-\t\t\t\t       function.get_function_name (), asm_name,\n-\t\t\t\t       flags, function.get_locus ());\n-    ctx->insert_function_decl (function.get_mappings ().get_hirid (), fndecl);\n+      = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n+\t\t\t\t       asm_name, flags, function.get_locus ());\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n \n     // setup the params\n-\n     TyTy::BaseType *tyret = fntype->get_return_type ();\n     std::vector<Bvariable *> param_vars;\n \n@@ -274,11 +298,12 @@ class CompileItem : public HIRCompileBase\n   }\n \n private:\n-  CompileItem (Context *ctx, bool compile_fns)\n-    : HIRCompileBase (ctx), compile_fns (compile_fns)\n+  CompileItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete)\n+    : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete)\n   {}\n \n   bool compile_fns;\n+  TyTy::BaseType *concrete;\n };\n \n } // namespace Compile"}, {"sha": "4fbaae32191f160a9ca7a2ed963d1a7a7f1867e5", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -67,24 +67,35 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n       return;\n     }\n \n-  // must be a function call\n+  // must be a function call but it might be a generic function which needs to\n+  // be compiled first\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t    &lookup);\n+  rust_assert (ok);\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n   Bfunction *fn = nullptr;\n-  if (!ctx->lookup_function_decl (ref, &fn))\n+  if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n     {\n-      // this might fail because its a forward decl so we can attempt to\n-      // resolve it now\n+      // it must resolve to some kind of HIR::Item\n       HIR::Item *resolved_item = ctx->get_mappings ()->lookup_hir_item (\n \texpr.get_mappings ().get_crate_num (), ref);\n       if (resolved_item == nullptr)\n \t{\n-\t  rust_error_at (expr.get_locus (), \"failed to lookup forward decl\");\n+\t  rust_error_at (expr.get_locus (), \"failed to lookup definition decl\");\n \t  return;\n \t}\n \n-      CompileItem::compile (resolved_item, ctx);\n-      if (!ctx->lookup_function_decl (ref, &fn))\n+      if (!lookup->has_subsititions_defined ())\n+\tCompileItem::compile (resolved_item, ctx);\n+      else\n+\tCompileItem::compile (resolved_item, ctx, true, lookup);\n+\n+      if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n \t{\n-\t  rust_error_at (expr.get_locus (), \"forward decl was not compiled 1\");\n+\t  rust_fatal_error (expr.get_locus (),\n+\t\t\t    \"forward decl was not compiled 1\");\n \t  return;\n \t}\n     }"}, {"sha": "774fd2e943a2a4c045acdbdd08b0d24460126230", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -102,7 +102,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::IntType &type) override\n   {\n-    switch (type.get_kind ())\n+    switch (type.get_int_kind ())\n       {\n       case TyTy::IntType::I8:\n \ttranslated\n@@ -139,7 +139,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::UintType &type) override\n   {\n-    switch (type.get_kind ())\n+    switch (type.get_uint_kind ())\n       {\n       case TyTy::UintType::U8:\n \ttranslated = backend->named_type (\"u8\", backend->integer_type (true, 8),\n@@ -175,7 +175,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::FloatType &type) override\n   {\n-    switch (type.get_kind ())\n+    switch (type.get_float_kind ())\n       {\n       case TyTy::FloatType::F32:\n \ttranslated = backend->named_type (\"f32\", backend->float_type (32),"}, {"sha": "7c0ac6ed6ed9e875c20a57114e45547313f20613", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -785,6 +785,9 @@ class Backend\n   // is like a C99 function marked inline but not extern.\n   static const unsigned int function_only_inline = 1 << 6;\n \n+  // const function\n+  static const unsigned int function_read_only = 1 << 7;\n+\n   // Declare or define a function of FNTYPE.\n   // NAME is the Go name of the function.  ASM_NAME, if not the empty\n   // string, is the name that should be used in the symbol table; this"}, {"sha": "d1ab3a6dce629334453e54780208a9654959ca63", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 3, "deletions": 37, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -1254,6 +1254,7 @@ Gcc_backend::named_type (const std::string &name, Btype *btype,\n \n   tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n \t\t\t  get_identifier_from_string (name), type);\n+\n   TYPE_NAME (type) = decl;\n   return this->make_type (type);\n }\n@@ -3207,43 +3208,8 @@ Gcc_backend::function (Btype *fntype, const std::string &name,\n       DECL_EXTERNAL (decl) = 1;\n       DECL_DECLARED_INLINE_P (decl) = 1;\n     }\n-\n-  // Optimize thunk functions for size.  A thunk created for a defer\n-  // statement that may call recover looks like:\n-  //     if runtime.setdeferretaddr(L1) {\n-  //         goto L1\n-  //     }\n-  //     realfn()\n-  // L1:\n-  // The idea is that L1 should be the address to which realfn\n-  // returns.  This only works if this little function is not over\n-  // optimized.  At some point GCC started duplicating the epilogue in\n-  // the basic-block reordering pass, breaking this assumption.\n-  // Optimizing the function for size avoids duplicating the epilogue.\n-  // This optimization shouldn't matter for any thunk since all thunks\n-  // are small.\n-  size_t pos = name.find (\"..thunk\");\n-  if (pos != std::string::npos)\n-    {\n-      for (pos += 7; pos < name.length (); ++pos)\n-\t{\n-\t  if (name[pos] < '0' || name[pos] > '9')\n-\t    break;\n-\t}\n-      if (pos == name.length ())\n-\t{\n-\t  struct cl_optimization cur_opts;\n-\t  cl_optimization_save (&cur_opts, &global_options,\n-\t\t\t\t&global_options_set);\n-\t  global_options.x_optimize_size = 1;\n-\t  global_options.x_optimize_fast = 0;\n-\t  global_options.x_optimize_debug = 0;\n-\t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (decl)\n-\t    = build_optimization_node (&global_options, &global_options_set);\n-\t  cl_optimization_restore (&global_options, &global_options_set,\n-\t\t\t\t   &cur_opts);\n-\t}\n-    }\n+  if ((flags & function_read_only) != 0)\n+    TREE_READONLY (decl) = 1;\n \n   rust_preserve_from_gc (decl);\n   return new Bfunction (decl);"}, {"sha": "c2c016003b1e424da92daecd820eec05c5bae90a", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -25,6 +25,7 @@\n #include \"rust-tyty-call.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n #include \"rust-hir-method-resolve.h\"\n+#include \"rust-substitution-mapper.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -716,7 +717,7 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    TyTy::ADTType *adt = (TyTy::ADTType *) struct_base;\n+    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (struct_base);\n     auto resolved = adt->get_field (expr.get_field_name ());\n     if (resolved == nullptr)\n       {\n@@ -789,17 +790,18 @@ class TypeCheckExpr : public TypeCheckBase\n \n     if (infered->has_subsititions_defined ())\n       {\n-\tif (infered->get_kind () != TyTy::TypeKind::ADT)\n+\tif (!infered->can_substitute ())\n \t  {\n \t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"substitutions only support on ADT types so far\");\n+\t\t\t   \"substitutions not supported for %s\",\n+\t\t\t   infered->as_string ().c_str ());\n \t    return;\n \t  }\n \n-\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (infered);\n-\tinfered = seg.has_generic_args ()\n-\t\t    ? adt->handle_substitutions (seg.get_generic_args ())\n-\t\t    : adt->infer_substitutions ();\n+\tinfered = SubstMapper::Resolve (infered, expr.get_locus (),\n+\t\t\t\t\tseg.has_generic_args ()\n+\t\t\t\t\t  ? &seg.get_generic_args ()\n+\t\t\t\t\t  : nullptr);\n       }\n   }\n "}, {"sha": "b8df74fcf19855121503ee19cff3de27e3f16a7c", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -50,6 +50,20 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \n   void visit (HIR::Function &function) override\n   {\n+    std::vector<TyTy::SubstitutionParamMapping> substitions;\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic_param : function.get_generic_params ())\n+\t  {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    substitions.push_back (\n+\t      TyTy::SubstitutionParamMapping (generic_param, param_type));\n+\t  }\n+      }\n+\n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_function_return_type ())\n       ret_type = new TyTy::UnitType (function.get_mappings ().get_hirid ());\n@@ -82,12 +96,27 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       }\n \n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    params, ret_type);\n+\t\t\t\t    std::move (params), ret_type,\n+\t\t\t\t    std::move (substitions));\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n   void visit (HIR::Method &method) override\n   {\n+    std::vector<TyTy::SubstitutionParamMapping> substitions;\n+    if (method.has_generics ())\n+      {\n+\tfor (auto &generic_param : method.get_generic_params ())\n+\t  {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    substitions.push_back (\n+\t      TyTy::SubstitutionParamMapping (generic_param, param_type));\n+\t  }\n+      }\n+\n     TyTy::BaseType *ret_type = nullptr;\n     if (!method.has_function_return_type ())\n       ret_type = new TyTy::UnitType (method.get_mappings ().get_hirid ());\n@@ -133,8 +162,9 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n-    auto fnType = new TyTy::FnType (method.get_mappings ().get_hirid (), params,\n-\t\t\t\t    ret_type);\n+    auto fnType = new TyTy::FnType (method.get_mappings ().get_hirid (),\n+\t\t\t\t    std::move (params), ret_type,\n+\t\t\t\t    std::move (substitions));\n     context->insert_type (method.get_mappings (), fnType);\n   }\n "}, {"sha": "44fe94346a9c2ee22bfaaa6150e0c81f283077bf", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -73,8 +73,8 @@ class TypeCheckItem : public TypeCheckBase\n       }\n \n     // need to get the return type from this\n-    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n-    auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n+    TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (lookup);\n+    auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n     auto block_expr_ty"}, {"sha": "abe7a556384fc662f27bde313589118cf7f2a120", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -105,6 +105,10 @@ class TypeCheckStmt : public TypeCheckBase\n \t\t\t\t   TyTy::InferType::InferTypeKind::GENERAL));\n \t  }\n       }\n+\n+    TyTy::BaseType *lookup = nullptr;\n+    bool ok = context->lookup_type (stmt.get_mappings ().get_hirid (), &lookup);\n+    rust_assert (ok);\n   }\n \n private:"}, {"sha": "4f800b3b7b353299d0a9a2aea7319c4299c7c446", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -42,7 +42,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n   void visit (HIR::TupleStruct &struct_decl) override\n   {\n-    std::vector<TyTy::SubstitutionMapping> substitutions;\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n     if (struct_decl.has_generics ())\n       {\n \tfor (auto &generic_param : struct_decl.get_generic_params ())\n@@ -52,7 +52,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    context->insert_type (generic_param->get_mappings (), param_type);\n \n \t    substitutions.push_back (\n-\t      TyTy::SubstitutionMapping (generic_param, param_type));\n+\t      TyTy::SubstitutionParamMapping (generic_param, param_type));\n \t  }\n       }\n \n@@ -82,7 +82,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n   void visit (HIR::StructStruct &struct_decl) override\n   {\n-    std::vector<TyTy::SubstitutionMapping> substitutions;\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n     if (struct_decl.has_generics ())\n       {\n \tfor (auto &generic_param : struct_decl.get_generic_params ())\n@@ -92,7 +92,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    context->insert_type (generic_param->get_mappings (), param_type);\n \n \t    substitutions.push_back (\n-\t      TyTy::SubstitutionMapping (generic_param, param_type));\n+\t      TyTy::SubstitutionParamMapping (generic_param, param_type));\n \t  }\n       }\n \n@@ -136,7 +136,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n   void visit (HIR::Function &function) override\n   {\n-    std::vector<TyTy::SubstitutionMapping> substitutions;\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n     if (function.has_generics ())\n       {\n \tfor (auto &generic_param : function.get_generic_params ())\n@@ -146,7 +146,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    context->insert_type (generic_param->get_mappings (), param_type);\n \n \t    substitutions.push_back (\n-\t      TyTy::SubstitutionMapping (generic_param, param_type));\n+\t      TyTy::SubstitutionParamMapping (generic_param, param_type));\n \t  }\n       }\n \n@@ -182,7 +182,8 @@ class TypeCheckTopLevel : public TypeCheckBase\n       }\n \n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    params, ret_type);\n+\t\t\t\t    std::move (params), ret_type,\n+\t\t\t\t    std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n   }\n "}, {"sha": "de3dfa7af09e504f5e37e3725519659d18cefe55", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-hir-type-check-base.h\"\n #include \"rust-hir-full.h\"\n+#include \"rust-substitution-mapper.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -182,20 +183,9 @@ class TypeCheckType : public TypeCheckBase\n \t      {\n \t\tif (translated->has_subsititions_defined ())\n \t\t  {\n-\t\t    // so far we only support ADT so lets just handle it here\n-\t\t    // for now\n-\t\t    if (translated->get_kind () != TyTy::TypeKind::ADT)\n-\t\t      {\n-\t\t\trust_error_at (\n-\t\t\t  path.get_locus (),\n-\t\t\t  \"unsupported type for generic substitution: %s\",\n-\t\t\t  translated->as_string ().c_str ());\n-\t\t\treturn;\n-\t\t      }\n-\n-\t\t    TyTy::ADTType *adt\n-\t\t      = static_cast<TyTy::ADTType *> (translated);\n-\t\t    translated = adt->handle_substitutions (args);\n+\t\t    translated\n+\t\t      = SubstMapper::Resolve (translated, path.get_locus (),\n+\t\t\t\t\t      &args);\n \t\t  }\n \t\telse\n \t\t  {\n@@ -208,23 +198,11 @@ class TypeCheckType : public TypeCheckBase\n \t\t    return;\n \t\t  }\n \t      }\n-\t    else if (translated->supports_substitutions ())\n+\t    else if (translated->has_subsititions_defined ())\n \t      {\n-\t\t// so far we only support ADT so lets just handle it here\n-\t\t// for now\n-\t\tif (translated->get_kind () != TyTy::TypeKind::ADT)\n-\t\t  {\n-\t\t    rust_error_at (\n-\t\t      path.get_locus (),\n-\t\t      \"unsupported type for generic substitution: %s\",\n-\t\t      translated->as_string ().c_str ());\n-\t\t    return;\n-\t\t  }\n-\n-\t\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (translated);\n-\t\ttranslated = adt->infer_substitutions ();\n+\t\ttranslated\n+\t\t  = SubstMapper::Resolve (translated, path.get_locus ());\n \t      }\n-\n \t    return;\n \t  }\n       }"}, {"sha": "9c25bfb5a0d9f72a9ee43e02f0c366fa5900bd31", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -305,10 +305,19 @@ TypeCheckStructExpr::visit (HIR::PathInExpression &expr)\n   if (struct_path_resolved->has_substitutions ())\n     {\n       HIR::PathExprSegment seg = expr.get_final_segment ();\n-      struct_path_resolved = seg.has_generic_args ()\n-\t\t\t       ? struct_path_resolved->handle_substitutions (\n-\t\t\t\t seg.get_generic_args ())\n-\t\t\t       : struct_path_resolved->infer_substitutions ();\n+\n+      TyTy::BaseType *subst\n+\t= SubstMapper::Resolve (struct_path_resolved, expr.get_locus (),\n+\t\t\t\tseg.has_generic_args ()\n+\t\t\t\t  ? &seg.get_generic_args ()\n+\t\t\t\t  : nullptr);\n+      if (subst == nullptr || subst->get_kind () != TyTy::TypeKind::ADT)\n+\t{\n+\t  rust_fatal_error (mappings->lookup_location (ref),\n+\t\t\t    \"expected a substituted ADT type\");\n+\t  return;\n+\t}\n+      struct_path_resolved = static_cast<TyTy::ADTType *> (subst);\n     }\n }\n "}, {"sha": "516b0b7781a337b459b0098a317cbb91ce8064db", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -0,0 +1,170 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_SUBSTITUTION_MAPPER_H\n+#define RUST_SUBSTITUTION_MAPPER_H\n+\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class SubstMapper : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (TyTy::BaseType *base, Location locus,\n+\t\t\t\t  HIR::GenericArgs *generics = nullptr)\n+  {\n+    SubstMapper mapper (base->get_ref (), generics, locus);\n+    base->accept_vis (mapper);\n+    rust_assert (mapper.resolved != nullptr);\n+    return mapper.resolved;\n+  }\n+\n+  bool have_generic_args () const { return generics != nullptr; }\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    TyTy::FnType *concrete = nullptr;\n+    if (!have_generic_args ())\n+      {\n+\tTyTy::BaseType *substs = type.infer_substitions (locus);\n+\trust_assert (substs->get_kind () == TyTy::TypeKind::FNDEF);\n+\tconcrete = static_cast<TyTy::FnType *> (substs);\n+      }\n+    else\n+      {\n+\tTyTy::SubstitutionArgumentMappings mappings\n+\t  = type.get_mappings_from_generic_args (*generics);\n+\tconcrete = type.handle_substitions (mappings);\n+      }\n+\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  void visit (TyTy::ADTType &type) override\n+  {\n+    TyTy::ADTType *concrete = nullptr;\n+    if (!have_generic_args ())\n+      {\n+\tTyTy::BaseType *substs = type.infer_substitions (locus);\n+\trust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n+\tconcrete = static_cast<TyTy::ADTType *> (substs);\n+      }\n+    else\n+      {\n+\tTyTy::SubstitutionArgumentMappings mappings\n+\t  = type.get_mappings_from_generic_args (*generics);\n+\tconcrete = type.handle_substitions (mappings);\n+      }\n+\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  void visit (TyTy::UnitType &) override { gcc_unreachable (); }\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n+  void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n+  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+  void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n+  void visit (TyTy::IntType &) override { gcc_unreachable (); }\n+  void visit (TyTy::UintType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FloatType &) override { gcc_unreachable (); }\n+  void visit (TyTy::USizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ISizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n+  void visit (TyTy::CharType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n+  void visit (TyTy::StrType &) override { gcc_unreachable (); }\n+\n+private:\n+  SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n+    : resolved (new TyTy::ErrorType (ref)), generics (generics), locus (locus)\n+  {}\n+\n+  TyTy::BaseType *resolved;\n+  HIR::GenericArgs *generics;\n+  Location locus;\n+};\n+\n+class SubstMapperInternal : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (TyTy::BaseType *base,\n+\t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings)\n+  {\n+    SubstMapperInternal mapper (base->get_ref (), mappings);\n+    base->accept_vis (mapper);\n+    rust_assert (mapper.resolved != nullptr);\n+    return mapper.resolved;\n+  }\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    TyTy::SubstitutionArgumentMappings adjusted\n+      = type.adjust_mappings_for_this (mappings);\n+\n+    TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  void visit (TyTy::ADTType &type) override\n+  {\n+    TyTy::SubstitutionArgumentMappings adjusted\n+      = type.adjust_mappings_for_this (mappings);\n+\n+    TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  void visit (TyTy::UnitType &) override { gcc_unreachable (); }\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n+  void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n+  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+  void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n+  void visit (TyTy::IntType &) override { gcc_unreachable (); }\n+  void visit (TyTy::UintType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FloatType &) override { gcc_unreachable (); }\n+  void visit (TyTy::USizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ISizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n+  void visit (TyTy::CharType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n+  void visit (TyTy::StrType &) override { gcc_unreachable (); }\n+\n+private:\n+  SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n+    : resolved (new TyTy::ErrorType (ref)), mappings (mappings)\n+  {}\n+\n+  TyTy::BaseType *resolved;\n+  TyTy::SubstitutionArgumentMappings &mappings;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_SUBSTITUTION_MAPPER_H"}, {"sha": "e17f89dc16b077effce276bdaf868b39d3337107", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -240,7 +240,6 @@ class BaseRules : public TyVisitor\n     rust_error_at (ref_locus, \"expected [%s] got [ParamTy <%s>]\",\n \t\t   get_base ()->as_string ().c_str (),\n \t\t   type.as_string ().c_str ());\n-    gcc_unreachable ();\n   }\n \n   virtual void visit (StrType &type) override\n@@ -487,6 +486,19 @@ class InferRules : public BaseRules\n     BaseRules::visit (type);\n   }\n \n+  void visit (ParamType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n \n@@ -714,6 +726,20 @@ class BoolRules : public BaseRules\n     resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n   }\n \n+  void visit (InferType &type) override\n+  {\n+    switch (type.get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = base->clone ();\n+\tbreak;\n+\n+      default:\n+\tBaseRules::visit (type);\n+\tbreak;\n+      }\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n \n@@ -742,14 +768,14 @@ class IntRules : public BaseRules\n \n   void visit (IntType &type) override\n   {\n-    if (type.get_kind () != base->get_kind ())\n+    if (type.get_int_kind () != base->get_int_kind ())\n       {\n \tBaseRules::visit (type);\n \treturn;\n       }\n \n     resolved\n-      = new IntType (type.get_ref (), type.get_ty_ref (), type.get_kind ());\n+      = new IntType (type.get_ref (), type.get_ty_ref (), type.get_int_kind ());\n   }\n \n private:\n@@ -780,14 +806,14 @@ class UintRules : public BaseRules\n \n   void visit (UintType &type) override\n   {\n-    if (type.get_kind () != base->get_kind ())\n+    if (type.get_uint_kind () != base->get_uint_kind ())\n       {\n \tBaseRules::visit (type);\n \treturn;\n       }\n \n-    resolved\n-      = new UintType (type.get_ref (), type.get_ty_ref (), type.get_kind ());\n+    resolved = new UintType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t     type.get_uint_kind ());\n   }\n \n private:\n@@ -817,14 +843,14 @@ class FloatRules : public BaseRules\n \n   void visit (FloatType &type) override\n   {\n-    if (type.get_kind () != base->get_kind ())\n+    if (type.get_float_kind () != base->get_float_kind ())\n       {\n \tBaseRules::visit (type);\n \treturn;\n       }\n \n-    resolved\n-      = new FloatType (type.get_ref (), type.get_ty_ref (), type.get_kind ());\n+    resolved = new FloatType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_float_kind ());\n   }\n \n private:\n@@ -864,7 +890,7 @@ class ADTRules : public BaseRules\n \t  }\n       }\n \n-    resolved = base->clone ();\n+    resolved = type.clone ();\n   }\n \n private:\n@@ -1029,6 +1055,8 @@ class ReferenceRules : public BaseRules\n \n class ParamRules : public BaseRules\n {\n+  using Rust::TyTy::BaseRules::visit;\n+\n public:\n   ParamRules (ParamType *base) : BaseRules (base), base (base) {}\n \n@@ -1044,15 +1072,7 @@ class ParamRules : public BaseRules\n   BaseType *unify (BaseType *other) override final\n   {\n     if (base->get_ref () == base->get_ty_ref ())\n-      {\n-\tLocation locus = mappings->lookup_location (base->get_ref ());\n-\trust_fatal_error (locus,\n-\t\t\t  \"invalid use of unify with ParamTy [%s] and [%s]\",\n-\t\t\t  base->as_string ().c_str (),\n-\t\t\t  other->as_string ().c_str ());\n-\treturn nullptr;\n-      }\n-\n+      return BaseRules::unify (other);\n     auto context = Resolver::TypeCheckContext::get ();\n     BaseType *lookup = nullptr;\n     bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n@@ -1061,6 +1081,17 @@ class ParamRules : public BaseRules\n     return lookup->unify (other);\n   }\n \n+  void visit (ParamType &type) override\n+  {\n+    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n "}, {"sha": "e5bd96ab67c9d3f6ec0de7d58f4c9dfa550f3c80", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 393, "deletions": 85, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-tyty-rules.h\"\n #include \"rust-hir-map.h\"\n+#include \"rust-substitution-mapper.h\"\n \n namespace Rust {\n namespace TyTy {\n@@ -46,6 +47,22 @@ TyVar::get_tyty () const\n   return lookup;\n }\n \n+TyVar\n+TyVar::get_implict_infer_var ()\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  InferType *infer = new InferType (mappings->get_next_hir_id (),\n+\t\t\t\t    InferType::InferTypeKind::GENERAL);\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       infer->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tinfer);\n+  return TyVar (infer->get_ref ());\n+}\n+\n void\n UnitType::accept_vis (TyVisitor &vis)\n {\n@@ -156,14 +173,24 @@ ErrorType::clone ()\n std::string\n StructFieldType::as_string () const\n {\n-  return name + \":\" + ty->as_string ();\n+  return name + \":\" + get_field_type ()->debug_str ();\n }\n \n bool\n StructFieldType::is_equal (const StructFieldType &other) const\n {\n-  return get_name ().compare (other.get_name ()) == 0\n-\t && get_field_type ()->is_equal (*other.get_field_type ());\n+  bool names_eq = get_name ().compare (other.get_name ()) == 0;\n+\n+  TyTy::BaseType &o = *other.get_field_type ();\n+  if (o.get_kind () == TypeKind::PARAM)\n+    {\n+      ParamType &op = static_cast<ParamType &> (o);\n+      o = *op.resolve ();\n+    }\n+\n+  bool types_eq = get_field_type ()->is_equal (o);\n+\n+  return names_eq && types_eq;\n }\n \n StructFieldType *\n@@ -173,6 +200,87 @@ StructFieldType::clone () const\n \t\t\t      get_field_type ()->clone ());\n }\n \n+void\n+SubstitutionParamMapping::override_context ()\n+{\n+  rust_assert (param->can_resolve ());\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       param->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tparam->resolve ());\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n+{\n+  if (args.get_type_args ().size () != substitutions.size ())\n+    {\n+      rust_error_at (args.get_locus (),\n+\t\t     \"Invalid number of generic arguments to generic type\");\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  std::vector<SubstitutionArg> mappings;\n+\n+  // FIXME does not support binding yet\n+  for (auto &arg : args.get_type_args ())\n+    {\n+      BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n+      if (resolved == nullptr || resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (args.get_locus (), \"failed to resolve type arguments\");\n+\t  return SubstitutionArgumentMappings::error ();\n+\t}\n+\n+      SubstitutionArg subst_arg (&substitutions.at (mappings.size ()),\n+\t\t\t\t resolved);\n+      mappings.push_back (std::move (subst_arg));\n+    }\n+\n+  return SubstitutionArgumentMappings (mappings, args.get_locus ());\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::adjust_mappings_for_this (\n+  SubstitutionArgumentMappings &mappings)\n+{\n+  if (substitutions.size () > mappings.size ())\n+    {\n+      rust_error_at (mappings.get_locus (),\n+\t\t     \"not enough type arguments: subs %s vs mappings %s\",\n+\t\t     subst_as_string ().c_str (),\n+\t\t     mappings.as_string ().c_str ());\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  Analysis::Mappings *mappings_table = Analysis::Mappings::get ();\n+\n+  std::vector<SubstitutionArg> resolved_mappings;\n+  for (auto &subst : substitutions)\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok = mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n+      if (!ok)\n+\t{\n+\t  rust_error_at (mappings_table->lookup_location (\n+\t\t\t   subst.get_param_ty ()->get_ref ()),\n+\t\t\t \"failed to find parameter type: %s\",\n+\t\t\t subst.get_param_ty ()->as_string ().c_str ());\n+\t  return SubstitutionArgumentMappings::error ();\n+\t}\n+\n+      SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+      resolved_mappings.push_back (std::move (adjusted));\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_locus ());\n+}\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -230,10 +338,34 @@ ADTType::is_equal (const BaseType &other) const\n   if (num_fields () != other2.num_fields ())\n     return false;\n \n-  for (size_t i = 0; i < num_fields (); i++)\n+  if (has_subsititions_defined () != other2.has_subsititions_defined ())\n+    return false;\n+\n+  if (has_subsititions_defined ())\n     {\n-      if (!get_field (i)->is_equal (*other2.get_field (i)))\n+      if (get_num_substitutions () != other2.get_num_substitutions ())\n \treturn false;\n+\n+      for (size_t i = 0; i < get_num_substitutions (); i++)\n+\t{\n+\t  const SubstitutionParamMapping &a = substitutions.at (i);\n+\t  const SubstitutionParamMapping &b = other2.substitutions.at (i);\n+\n+\t  const ParamType *aa = a.get_param_ty ();\n+\t  const ParamType *bb = b.get_param_ty ();\n+\t  BaseType *aaa = aa->resolve ();\n+\t  BaseType *bbb = bb->resolve ();\n+\t  if (!aaa->is_equal (*bbb))\n+\t    return false;\n+\t}\n+    }\n+  else\n+    {\n+      for (size_t i = 0; i < num_fields (); i++)\n+\t{\n+\t  if (!get_field (i)->is_equal (*other2.get_field (i)))\n+\t    return false;\n+\t}\n     }\n \n   return true;\n@@ -251,88 +383,83 @@ ADTType::clone ()\n }\n \n ADTType *\n-ADTType::infer_substitutions ()\n+ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n-  auto context = Resolver::TypeCheckContext::get ();\n-  ADTType *adt = static_cast<ADTType *> (clone ());\n+  if (subst_mappings.size () != get_num_substitutions ())\n \n-  for (auto &sub : adt->get_substs ())\n     {\n-      // generate an new inference variable\n-      InferType *infer = new InferType (mappings->get_next_hir_id (),\n-\t\t\t\t\tInferType::InferTypeKind::GENERAL);\n-      context->insert_type (\n-\tAnalysis::NodeMapping (mappings->get_current_crate (), UNKNOWN_NODEID,\n-\t\t\t       infer->get_ref (), UNKNOWN_LOCAL_DEFID),\n-\tinfer);\n-\n-      sub.fill_param_ty (infer);\n-      adt->fill_in_params_for (sub, infer);\n-    }\n-\n-  // generate new ty ref id since this is an instantiate of the generic\n-  adt->set_ty_ref (mappings->get_next_hir_id ());\n-\n-  return adt;\n-}\n-\n-ADTType *\n-ADTType::handle_substitutions (HIR::GenericArgs &generic_args)\n-{\n-  if (generic_args.get_type_args ().size () != get_num_substitutions ())\n-    {\n-      rust_error_at (generic_args.get_locus (),\n+      rust_error_at (subst_mappings.get_locus (),\n \t\t     \"invalid number of generic arguments to generic ADT type\");\n       return nullptr;\n     }\n \n   ADTType *adt = static_cast<ADTType *> (clone ());\n-  size_t index = 0;\n-  for (auto &arg : generic_args.get_type_args ())\n-    {\n-      BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n-      if (resolved == nullptr)\n-\t{\n-\t  rust_error_at (generic_args.get_locus (),\n-\t\t\t \"failed to resolve type arguments\");\n-\t  return nullptr;\n-\t}\n-\n-      adt->fill_in_at (index, resolved);\n-      index++;\n-    }\n-\n-  // generate new ty ref id since this is an instantiate of the generic\n   adt->set_ty_ref (mappings->get_next_hir_id ());\n \n-  return adt;\n-}\n-\n-void\n-ADTType::fill_in_at (size_t index, BaseType *type)\n-{\n-  SubstitutionMapping sub = get_substitution_mapping_at (index);\n-  SubstitutionRef<ADTType>::fill_in_at (index, type);\n-  fill_in_params_for (sub, type);\n-}\n-\n-void\n-ADTType::fill_in_params_for (SubstitutionMapping sub, BaseType *type)\n-{\n-  iterate_fields ([&] (StructFieldType *field) mutable -> bool {\n-    bool is_param_ty = field->get_field_type ()->get_kind () == TypeKind::PARAM;\n-    if (!is_param_ty)\n-      return true;\n-\n-    const ParamType *pp = sub.get_param_ty ();\n-    ParamType *p = static_cast<ParamType *> (field->get_field_type ());\n+  for (auto &sub : adt->get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      rust_assert (ok);\n+      sub.fill_param_ty (arg.get_tyty ());\n+    }\n \n-    // for now let just see what symbols match up for the substitution\n-    if (p->get_symbol ().compare (pp->get_symbol ()) == 0)\n-      p->set_ty_ref (type->get_ref ());\n+  adt->iterate_fields ([&] (StructFieldType *field) mutable -> bool {\n+    auto fty = field->get_field_type ();\n+    bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+    if (is_param_ty)\n+      {\n+\tParamType *p = static_cast<ParamType *> (fty);\n+\n+\tSubstitutionArg arg = SubstitutionArg::error ();\n+\tbool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+\tif (!ok)\n+\t  {\n+\t    rust_error_at (subst_mappings.get_locus (),\n+\t\t\t   \"Failed to resolve parameter type: %s\",\n+\t\t\t   p->as_string ().c_str ());\n+\t    return false;\n+\t  }\n+\n+\tauto argt = arg.get_tyty ();\n+\tbool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\tif (arg_is_param || arg_is_concrete)\n+\t  {\n+\t    auto new_field = argt->clone ();\n+\t    new_field->set_ref (fty->get_ref ());\n+\t    field->set_field_type (new_field);\n+\t  }\n+\telse\n+\t  {\n+\t    field->get_field_type ()->set_ty_ref (argt->get_ref ());\n+\t  }\n+      }\n+    else if (fty->has_subsititions_defined ())\n+      {\n+\tBaseType *concrete\n+\t  = Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+\tif (concrete == nullptr\n+\t    || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    rust_error_at (subst_mappings.get_locus (),\n+\t\t\t   \"Failed to resolve field substitution type: %s\",\n+\t\t\t   fty->as_string ().c_str ());\n+\t    return false;\n+\t  }\n+\n+\tauto new_field = concrete->clone ();\n+\tnew_field->set_ref (fty->get_ref ());\n+\tfield->set_field_type (new_field);\n+      }\n \n     return true;\n   });\n+\n+  return adt;\n }\n \n void\n@@ -452,7 +579,135 @@ FnType::clone ()\n       std::pair<HIR::Pattern *, BaseType *> (p.first, p.second->clone ()));\n \n   return new FnType (get_ref (), get_ty_ref (), std::move (cloned_params),\n-\t\t     get_return_type ()->clone (), get_combined_refs ());\n+\t\t     get_return_type ()->clone (), clone_substs (),\n+\t\t     get_combined_refs ());\n+}\n+\n+FnType *\n+FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n+{\n+  if (subst_mappings.size () != get_num_substitutions ())\n+    {\n+      rust_error_at (subst_mappings.get_locus (),\n+\t\t     \"invalid number of generic arguments to generic ADT type\");\n+      return nullptr;\n+    }\n+\n+  FnType *fn = static_cast<FnType *> (clone ());\n+  fn->set_ty_ref (mappings->get_next_hir_id ());\n+\n+  for (auto &sub : fn->get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      rust_assert (ok);\n+      sub.fill_param_ty (arg.get_tyty ());\n+    }\n+\n+  auto fty = fn->get_return_type ();\n+  bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+  if (is_param_ty)\n+    {\n+      ParamType *p = static_cast<ParamType *> (fty);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+      if (!ok)\n+\t{\n+\t  rust_error_at (subst_mappings.get_locus (),\n+\t\t\t \"Failed to resolve parameter type: %s\",\n+\t\t\t p->as_string ().c_str ());\n+\t  return nullptr;\n+\t}\n+\n+      auto argt = arg.get_tyty ();\n+      bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+      bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+      if (arg_is_param || arg_is_concrete)\n+\t{\n+\t  auto new_field = argt->clone ();\n+\t  new_field->set_ref (fty->get_ref ());\n+\t  fn->type = new_field;\n+\t}\n+      else\n+\t{\n+\t  fty->set_ty_ref (argt->get_ref ());\n+\t}\n+    }\n+  else if (fty->has_subsititions_defined ())\n+    {\n+      BaseType *concrete\n+\t= Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+      if (concrete == nullptr || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (subst_mappings.get_locus (),\n+\t\t\t \"Failed to resolve field substitution type: %s\",\n+\t\t\t fty->as_string ().c_str ());\n+\t  return nullptr;\n+\t}\n+\n+      auto new_field = concrete->clone ();\n+      new_field->set_ref (fty->get_ref ());\n+      fn->type = new_field;\n+    }\n+\n+  for (auto &param : fn->get_params ())\n+    {\n+      auto fty = param.second;\n+      bool is_param_ty = fty->get_kind () == TypeKind::PARAM;\n+      if (is_param_ty)\n+\t{\n+\t  ParamType *p = static_cast<ParamType *> (fty);\n+\n+\t  SubstitutionArg arg = SubstitutionArg::error ();\n+\t  bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n+\t  if (!ok)\n+\t    {\n+\t      rust_error_at (subst_mappings.get_locus (),\n+\t\t\t     \"Failed to resolve parameter type: %s\",\n+\t\t\t     p->as_string ().c_str ());\n+\t      return nullptr;\n+\t    }\n+\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      param.second = new_field;\n+\t    }\n+\t  else\n+\t    {\n+\t      fty->set_ty_ref (argt->get_ref ());\n+\t    }\n+\t}\n+      else if (fty->has_subsititions_defined ())\n+\t{\n+\t  BaseType *concrete\n+\t    = Resolver::SubstMapperInternal::Resolve (fty, subst_mappings);\n+\n+\t  if (concrete == nullptr\n+\t      || concrete->get_kind () == TyTy::TypeKind::ERROR)\n+\t    {\n+\t      rust_error_at (subst_mappings.get_locus (),\n+\t\t\t     \"Failed to resolve field substitution type: %s\",\n+\t\t\t     fty->as_string ().c_str ());\n+\t      return nullptr;\n+\t    }\n+\n+\t  auto new_field = concrete->clone ();\n+\t  new_field->set_ref (fty->get_ref ());\n+\t  param.second = new_field;\n+\t}\n+    }\n+\n+  return fn;\n }\n \n void\n@@ -623,10 +878,20 @@ IntType::unify (BaseType *other)\n BaseType *\n IntType::clone ()\n {\n-  return new IntType (get_ref (), get_ty_ref (), get_kind (),\n+  return new IntType (get_ref (), get_ty_ref (), get_int_kind (),\n \t\t      get_combined_refs ());\n }\n \n+bool\n+IntType::is_equal (const BaseType &other) const\n+{\n+  if (!BaseType::is_equal (other))\n+    return false;\n+\n+  const IntType &o = static_cast<const IntType &> (other);\n+  return get_int_kind () == o.get_int_kind ();\n+}\n+\n void\n UintType::accept_vis (TyVisitor &vis)\n {\n@@ -663,10 +928,20 @@ UintType::unify (BaseType *other)\n BaseType *\n UintType::clone ()\n {\n-  return new UintType (get_ref (), get_ty_ref (), get_kind (),\n+  return new UintType (get_ref (), get_ty_ref (), get_uint_kind (),\n \t\t       get_combined_refs ());\n }\n \n+bool\n+UintType::is_equal (const BaseType &other) const\n+{\n+  if (!BaseType::is_equal (other))\n+    return false;\n+\n+  const UintType &o = static_cast<const UintType &> (other);\n+  return get_uint_kind () == o.get_uint_kind ();\n+}\n+\n void\n FloatType::accept_vis (TyVisitor &vis)\n {\n@@ -697,10 +972,20 @@ FloatType::unify (BaseType *other)\n BaseType *\n FloatType::clone ()\n {\n-  return new FloatType (get_ref (), get_ty_ref (), get_kind (),\n+  return new FloatType (get_ref (), get_ty_ref (), get_float_kind (),\n \t\t\tget_combined_refs ());\n }\n \n+bool\n+FloatType::is_equal (const BaseType &other) const\n+{\n+  if (!BaseType::is_equal (other))\n+    return false;\n+\n+  const FloatType &o = static_cast<const FloatType &> (other);\n+  return get_float_kind () == o.get_float_kind ();\n+}\n+\n void\n USizeType::accept_vis (TyVisitor &vis)\n {\n@@ -828,7 +1113,9 @@ std::string\n ParamType::as_string () const\n {\n   if (get_ref () == get_ty_ref ())\n-    return get_symbol ();\n+    {\n+      return get_symbol () + \" REF: \" + std::to_string (get_ref ());\n+    }\n \n   auto context = Resolver::TypeCheckContext::get ();\n   BaseType *lookup = nullptr;\n@@ -859,14 +1146,33 @@ ParamType::get_symbol () const\n }\n \n BaseType *\n-ParamType::resolve ()\n+ParamType::resolve () const\n {\n-  auto context = Resolver::TypeCheckContext::get ();\n-  BaseType *lookup = nullptr;\n-  bool ok = context->lookup_type (get_ty_ref (), &lookup);\n-  rust_assert (ok);\n+  rust_assert (can_resolve ());\n \n-  return lookup;\n+  TyVar var (get_ty_ref ());\n+  BaseType *r = var.get_tyty ();\n+\n+  while (r->get_kind () == TypeKind::PARAM)\n+    {\n+      ParamType *rr = static_cast<ParamType *> (r);\n+      if (!rr->can_resolve ())\n+\tbreak;\n+\n+      TyVar v (rr->get_ty_ref ());\n+      r = v.get_tyty ();\n+    }\n+\n+  return TyVar (r->get_ty_ref ()).get_tyty ();\n+}\n+\n+bool\n+ParamType::is_equal (const BaseType &other) const\n+{\n+  if (!can_resolve ())\n+    return BaseType::is_equal (other);\n+\n+  return resolve ()->is_equal (other);\n }\n \n BaseType *\n@@ -936,7 +1242,9 @@ TypeCheckCallExpr::visit (ADTType &type)\n \n     auto res = field_tyty->unify (arg);\n     if (res == nullptr)\n-      return false;\n+      {\n+\treturn false;\n+      }\n \n     delete res;\n     i++;"}, {"sha": "27cfe46a4c71f2abc13f49dd978dda8c2f8c168c", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 230, "deletions": 67, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -20,6 +20,7 @@\n #define RUST_TYTY\n \n #include \"rust-hir-map.h\"\n+#include \"rust-hir-full.h\"\n \n namespace Rust {\n namespace TyTy {\n@@ -106,6 +107,11 @@ class BaseType\n \n   virtual bool has_subsititions_defined () const { return false; }\n \n+  virtual bool can_substitute () const\n+  {\n+    return supports_substitutions () && has_subsititions_defined ();\n+  }\n+\n   std::string mappings_str () const\n   {\n     std::string buffer = \"Ref: \" + std::to_string (get_ref ())\n@@ -149,6 +155,8 @@ class TyVar\n \n   BaseType *get_tyty () const;\n \n+  static TyVar get_implict_infer_var ();\n+\n private:\n   HirId ref;\n };\n@@ -241,6 +249,46 @@ class UnitType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n };\n \n+class ParamType : public BaseType\n+{\n+public:\n+  ParamType (std::string symbol, HirId ref, HIR::GenericParam &param,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PARAM, refs), symbol (symbol), param (param)\n+  {}\n+\n+  ParamType (std::string symbol, HirId ref, HirId ty_ref,\n+\t     HIR::GenericParam &param,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::PARAM, refs), symbol (symbol),\n+      param (param)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+\n+  BaseType *clone () final override;\n+\n+  std::string get_symbol () const;\n+\n+  HIR::GenericParam &get_generic_param () { return param; }\n+\n+  bool can_resolve () const { return get_ref () != get_ty_ref (); }\n+\n+  BaseType *resolve () const;\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+private:\n+  std::string symbol;\n+  HIR::GenericParam &param;\n+};\n+\n class StructFieldType\n {\n public:\n@@ -258,8 +306,12 @@ class StructFieldType\n \n   BaseType *get_field_type () const { return ty; }\n \n+  void set_field_type (BaseType *fty) { ty = fty; }\n+\n   StructFieldType *clone () const;\n \n+  void debug () const { printf (\"%s\\n\", as_string ().c_str ()); }\n+\n private:\n   HirId ref;\n   std::string name;\n@@ -310,72 +362,142 @@ class TupleType : public BaseType\n   std::vector<TyVar> fields;\n };\n \n-class ParamType : public BaseType\n+class SubstitutionParamMapping\n {\n public:\n-  ParamType (std::string symbol, HirId ref, HIR::GenericParam &param,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PARAM), symbol (symbol), param (param)\n+  SubstitutionParamMapping (std::unique_ptr<HIR::GenericParam> &generic,\n+\t\t\t    ParamType *param)\n+\n+    : generic (generic), param (param)\n   {}\n \n-  ParamType (std::string symbol, HirId ref, HirId ty_ref,\n-\t     HIR::GenericParam &param,\n-\t     std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PARAM), symbol (symbol), param (param)\n+  SubstitutionParamMapping (const SubstitutionParamMapping &other)\n+    : generic (other.generic), param (other.param)\n   {}\n \n-  void accept_vis (TyVisitor &vis) override;\n+  std::string as_string () const { return param->as_string (); }\n \n-  std::string as_string () const override;\n+  void fill_param_ty (BaseType *type)\n+  {\n+    if (type->get_kind () == TypeKind::PARAM)\n+      {\n+\tdelete param;\n+\tparam = static_cast<ParamType *> (type->clone ());\n+      }\n+    else\n+      {\n+\tparam->set_ty_ref (type->get_ref ());\n+      }\n+  }\n \n-  BaseType *unify (BaseType *other) override;\n+  SubstitutionParamMapping clone ()\n+  {\n+    return SubstitutionParamMapping (generic, static_cast<ParamType *> (\n+\t\t\t\t\t\tparam->clone ()));\n+  }\n \n-  BaseType *clone () final override;\n+  const ParamType *get_param_ty () const { return param; }\n \n-  std::string get_symbol () const;\n+  std::unique_ptr<HIR::GenericParam> &get_generic_param () { return generic; };\n \n-  HIR::GenericParam &get_generic_param () { return param; }\n+  void override_context ();\n \n-  bool can_resolve () const { return get_ref () != get_ty_ref (); }\n+private:\n+  std::unique_ptr<HIR::GenericParam> &generic;\n+  ParamType *param;\n+};\n \n-  BaseType *resolve ();\n+class SubstitutionArg\n+{\n+public:\n+  SubstitutionArg (SubstitutionParamMapping *param, BaseType *argument)\n+    : param (std::move (param)), argument (argument)\n+  {}\n \n-  std::string get_name () const override final { return as_string (); }\n+  SubstitutionArg (const SubstitutionArg &other)\n+    : param (other.param), argument (other.argument)\n+  {}\n+\n+  SubstitutionArg &operator= (const SubstitutionArg &other)\n+  {\n+    param = other.param;\n+    argument = other.argument;\n+    return *this;\n+  }\n+\n+  BaseType *get_tyty () { return argument; }\n+\n+  SubstitutionParamMapping *get_param_mapping () { return param; }\n+\n+  static SubstitutionArg error () { return SubstitutionArg (nullptr, nullptr); }\n+\n+  std::string as_string () const\n+  {\n+    return param->as_string () + \":\" + argument->as_string ();\n+  }\n \n private:\n-  std::string symbol;\n-  HIR::GenericParam &param;\n+  SubstitutionParamMapping *param;\n+  BaseType *argument;\n };\n \n-class SubstitutionMapping\n+class SubstitutionArgumentMappings\n {\n public:\n-  SubstitutionMapping (std::unique_ptr<HIR::GenericParam> &generic,\n-\t\t       ParamType *param)\n-    : generic (generic), param (param)\n+  SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n+\t\t\t\tLocation locus)\n+    : mappings (mappings), locus (locus)\n   {}\n \n-  std::string as_string () const { return param->as_string (); }\n+  static SubstitutionArgumentMappings error ()\n+  {\n+    return SubstitutionArgumentMappings ({}, Location ());\n+  }\n \n-  void fill_param_ty (BaseType *type) { param->set_ty_ref (type->get_ref ()); }\n+  bool is_error () const { return mappings.size () == 0; }\n \n-  SubstitutionMapping clone ()\n+  bool get_argument_for_symbol (const ParamType *param_to_find,\n+\t\t\t\tSubstitutionArg *argument)\n   {\n-    return SubstitutionMapping (generic,\n-\t\t\t\tstatic_cast<ParamType *> (param->clone ()));\n+    for (auto &mapping : mappings)\n+      {\n+\tSubstitutionParamMapping *param = mapping.get_param_mapping ();\n+\tconst ParamType *p = param->get_param_ty ();\n+\n+\tif (p->get_symbol ().compare (param_to_find->get_symbol ()) == 0)\n+\t  {\n+\t    *argument = mapping;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n   }\n \n-  const ParamType *get_param_ty () const { return param; }\n+  Location get_locus () { return locus; }\n+\n+  size_t size () const { return mappings.size (); }\n+\n+  std::vector<SubstitutionArg> &get_mappings () { return mappings; }\n+\n+  std::string as_string () const\n+  {\n+    std::string buffer;\n+    for (auto &mapping : mappings)\n+      {\n+\tbuffer += mapping.as_string () + \", \";\n+      }\n+    return \"<\" + buffer + \">\";\n+  }\n \n private:\n-  std::unique_ptr<HIR::GenericParam> &generic;\n-  ParamType *param;\n+  std::vector<SubstitutionArg> mappings;\n+  Location locus;\n };\n \n-template <class T> class SubstitutionRef\n+class SubstitutionRef\n {\n public:\n-  SubstitutionRef (std::vector<SubstitutionMapping> substitutions)\n+  SubstitutionRef (std::vector<SubstitutionParamMapping> substitutions)\n     : substitutions (substitutions)\n   {}\n \n@@ -386,7 +508,7 @@ template <class T> class SubstitutionRef\n     std::string buffer;\n     for (size_t i = 0; i < substitutions.size (); i++)\n       {\n-\tconst SubstitutionMapping &sub = substitutions.at (i);\n+\tconst SubstitutionParamMapping &sub = substitutions.at (i);\n \tbuffer += sub.as_string ();\n \n \tif ((i + 1) < substitutions.size ())\n@@ -398,42 +520,69 @@ template <class T> class SubstitutionRef\n \n   size_t get_num_substitutions () const { return substitutions.size (); }\n \n-  std::vector<SubstitutionMapping> &get_substs () { return substitutions; }\n+  std::vector<SubstitutionParamMapping> &get_substs () { return substitutions; }\n \n-  std::vector<SubstitutionMapping> clone_substs ()\n+  std::vector<SubstitutionParamMapping> clone_substs ()\n   {\n-    std::vector<SubstitutionMapping> clone;\n+    std::vector<SubstitutionParamMapping> clone;\n+\n     for (auto &sub : substitutions)\n       clone.push_back (sub.clone ());\n \n     return clone;\n   }\n \n-  virtual T *infer_substitutions () = 0;\n-\n-  virtual T *handle_substitutions (HIR::GenericArgs &generic_args) = 0;\n-\n-protected:\n-  virtual void fill_in_at (size_t index, BaseType *type)\n+  void override_context ()\n   {\n-    substitutions.at (index).fill_param_ty (type);\n+    for (auto &sub : substitutions)\n+      {\n+\tsub.override_context ();\n+      }\n   }\n \n-  SubstitutionMapping get_substitution_mapping_at (size_t index)\n+  // We are trying to subst <i32, f32> into Struct Foo<X,Y> {}\n+  // in the case of Foo<i32,f32>{...}\n+  //\n+  // the substitions we have here define X,Y but the arguments have no bindings\n+  // so its a matter of ordering\n+  SubstitutionArgumentMappings\n+  get_mappings_from_generic_args (HIR::GenericArgs &args);\n+\n+  // Recursive substitutions\n+  // Foo <A,B> { a:A, b: B}; Bar <X,Y,Z>{a:X, b: Foo<Y,Z>}\n+  //\n+  // we have bindings for X Y Z and need to propagate the binding Y,Z into Foo\n+  // Which binds to A,B\n+  SubstitutionArgumentMappings\n+  adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n+\n+  BaseType *infer_substitions (Location locus)\n   {\n-    return substitutions.at (index);\n+    std::vector<SubstitutionArg> args;\n+    for (auto &sub : get_substs ())\n+      {\n+\tTyVar infer_var = TyVar::get_implict_infer_var ();\n+\targs.push_back (SubstitutionArg (&sub, infer_var.get_tyty ()));\n+      }\n+\n+    SubstitutionArgumentMappings infer_arguments (std::move (args), locus);\n+    return handle_substitions (std::move (infer_arguments));\n   }\n \n-private:\n-  std::vector<SubstitutionMapping> substitutions;\n+  virtual BaseType *handle_substitions (SubstitutionArgumentMappings mappings)\n+    = 0;\n+\n+protected:\n+  std::vector<SubstitutionParamMapping> substitutions;\n };\n \n-class ADTType : public BaseType, public SubstitutionRef<ADTType>\n+class ADTType : public BaseType, public SubstitutionRef\n+\n {\n public:\n   ADTType (HirId ref, std::string identifier, bool is_tuple,\n \t   std::vector<StructFieldType *> fields,\n-\t   std::vector<SubstitutionMapping> subst_refs,\n+\t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ADT, refs),\n       SubstitutionRef (std::move (subst_refs)), identifier (identifier),\n@@ -442,7 +591,7 @@ class ADTType : public BaseType, public SubstitutionRef<ADTType>\n \n   ADTType (HirId ref, HirId ty_ref, std::string identifier, bool is_tuple,\n \t   std::vector<StructFieldType *> fields,\n-\t   std::vector<SubstitutionMapping> subst_refs,\n+\t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ADT, refs),\n       SubstitutionRef (std::move (subst_refs)), identifier (identifier),\n@@ -514,34 +663,32 @@ class ADTType : public BaseType, public SubstitutionRef<ADTType>\n     return has_substitutions ();\n   }\n \n-  ADTType *infer_substitutions () override final;\n-\n-  ADTType *handle_substitutions (HIR::GenericArgs &generic_args) override final;\n-\n-  void fill_in_at (size_t index, BaseType *type) override final;\n-\n-  void fill_in_params_for (SubstitutionMapping sub, BaseType *type);\n+  ADTType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n private:\n   std::string identifier;\n   std::vector<StructFieldType *> fields;\n   bool is_tuple;\n };\n \n-class FnType : public BaseType\n+class FnType : public BaseType, public SubstitutionRef\n {\n public:\n   FnType (HirId ref, std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n-\t  BaseType *type, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::FNDEF, refs), params (std::move (params)),\n+\t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n+\t  std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::FNDEF, refs),\n+      SubstitutionRef (std::move (subst_refs)), params (std::move (params)),\n       type (type)\n   {}\n \n   FnType (HirId ref, HirId ty_ref,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n-\t  BaseType *type, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::FNDEF, refs), params (params),\n-      type (type)\n+\t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n+\t  std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::FNDEF, refs),\n+      SubstitutionRef (std::move (subst_refs)), params (params), type (type)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -580,6 +727,16 @@ class FnType : public BaseType\n \n   BaseType *clone () final override;\n \n+  bool supports_substitutions () const override final { return true; }\n+\n+  bool has_subsititions_defined () const override final\n+  {\n+    return has_substitutions ();\n+  }\n+\n+  FnType *\n+  handle_substitions (SubstitutionArgumentMappings mappings) override final;\n+\n private:\n   std::vector<std::pair<HIR::Pattern *, BaseType *> > params;\n   BaseType *type;\n@@ -719,10 +876,12 @@ class IntType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n-  IntKind get_kind () const { return int_kind; }\n+  IntKind get_int_kind () const { return int_kind; }\n \n   BaseType *clone () final override;\n \n+  bool is_equal (const BaseType &other) const override;\n+\n private:\n   IntKind int_kind;\n };\n@@ -756,10 +915,12 @@ class UintType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n-  UintKind get_kind () const { return uint_kind; }\n+  UintKind get_uint_kind () const { return uint_kind; }\n \n   BaseType *clone () final override;\n \n+  bool is_equal (const BaseType &other) const override;\n+\n private:\n   UintKind uint_kind;\n };\n@@ -791,10 +952,12 @@ class FloatType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n \n-  FloatKind get_kind () const { return float_kind; }\n+  FloatKind get_float_kind () const { return float_kind; }\n \n   BaseType *clone () final override;\n \n+  bool is_equal (const BaseType &other) const override;\n+\n private:\n   FloatKind float_kind;\n };"}, {"sha": "0dc41c3114967155796c6cadc37a1456418566a3", "filename": "gcc/testsuite/rust.test/compilable/generics3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics3.rs?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -0,0 +1,13 @@\n+fn test<T>(a: T) -> T {\n+    a\n+}\n+\n+fn main() {\n+    let a;\n+    a = test(123);\n+    let aa: i32 = a;\n+\n+    let b;\n+    b = test::<u32>(456);\n+    let bb: u32 = b;\n+}"}, {"sha": "81ac4e6a31888eb1e39fff0ad85e4876e803722d", "filename": "gcc/testsuite/rust.test/compilable/generics4.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics4.rs?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -0,0 +1,13 @@\n+struct Foo<T> {\n+    a: T,\n+    b: bool,\n+}\n+\n+fn test<T>(a: T) -> Foo<T> {\n+    Foo { a: a, b: true }\n+}\n+\n+fn main() {\n+    let a: Foo<i32> = test(123);\n+    let b: Foo<u32> = test(456);\n+}"}, {"sha": "3d7f70d280c41c4ed43caaad5faa512599039f54", "filename": "gcc/testsuite/rust.test/compilable/generics5.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics5.rs?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -0,0 +1,8 @@\n+fn test<T>(a: T) -> T {\n+    a\n+}\n+\n+fn main() {\n+    let a: i32 = test(123);\n+    let b: i32 = test(456);\n+}"}, {"sha": "da9f16798306b426bf9a7d62a96973621d9149e8", "filename": "gcc/testsuite/rust.test/compilable/generics6.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics6.rs?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -0,0 +1,14 @@\n+struct Foo<T>(T);\n+\n+struct Bar<T> {\n+    a: Foo<T>,\n+    b: bool,\n+}\n+\n+fn main() {\n+    let a: Bar<i32> = Bar::<i32> {\n+        a: Foo::<i32>(123),\n+        b: true,\n+    };\n+    let b: i32 = a.a.0;\n+}"}, {"sha": "b534708439484ed52036474d651e9e46df949a31", "filename": "gcc/testsuite/rust.test/compilable/generics7.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280ac5bd99b4d66ea10d0aa8d4edba53bf460b10/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics7.rs?ref=280ac5bd99b4d66ea10d0aa8d4edba53bf460b10", "patch": "@@ -0,0 +1,12 @@\n+struct Foo<T>(T);\n+\n+struct Bar {\n+    a: Foo<i32>,\n+    b: bool,\n+}\n+\n+fn main() {\n+    let a = Foo::<i32>(123);\n+    let b: Bar = Bar { a: a, b: true };\n+    let c: i32 = b.a.0;\n+}"}]}