{"sha": "ed1f5d718b537106ca546813538abbc9ae733f10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQxZjVkNzE4YjUzNzEwNmNhNTQ2ODEzNTM4YWJiYzlhZTczM2YxMA==", "commit": {"author": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2009-10-24T15:36:40Z"}, "committer": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2009-10-24T15:36:40Z"}, "message": "re PR middle-end/19154 (miss-optimization of (x & pow2C) avr conditionals returning bool equivalent values)\n\nPR middle-end/19154\n* avr.md (QIDI): Add new mode iterator.\n(sbrx_branch<mode>): Create new zero extract bit, test and jump\npatterns for all QI-DI modes combinations.\n(sbrx_and_branch<mode>): Create new and based bit test and jump\npatterns for QI-SI modes.\navr.c (avr_out_sbxx_branch): Use only bit number.\n\nFrom-SVN: r153530", "tree": {"sha": "ece8541554fb70badea5c95b1c2e0e7881fbd68d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ece8541554fb70badea5c95b1c2e0e7881fbd68d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed1f5d718b537106ca546813538abbc9ae733f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1f5d718b537106ca546813538abbc9ae733f10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed1f5d718b537106ca546813538abbc9ae733f10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1f5d718b537106ca546813538abbc9ae733f10/comments", "author": null, "committer": null, "parents": [{"sha": "8b583a0651c326c12cd2a3d6a4cfba7bf6b68963", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963"}], "stats": {"total": 56, "additions": 23, "deletions": 33}, "files": [{"sha": "cb2d709c89a1c32c36b75e747567c06f9c4d6c46", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1f5d718b537106ca546813538abbc9ae733f10/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1f5d718b537106ca546813538abbc9ae733f10/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=ed1f5d718b537106ca546813538abbc9ae733f10", "patch": "@@ -5877,12 +5877,12 @@ avr_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n-/* Output a branch that tests a single bit of a register (QI, HI or SImode)\n+/* Output a branch that tests a single bit of a register (QI, HI, SI or DImode)\n    or memory location in the I/O space (QImode only).\n \n    Operand 0: comparison operator (must be EQ or NE, compare bit to zero).\n    Operand 1: register operand to test, or CONST_INT memory address.\n-   Operand 2: bit number (for QImode operand) or mask (HImode, SImode).\n+   Operand 2: bit number.\n    Operand 3: label to jump to if the test is true.  */\n \n const char *\n@@ -5930,9 +5930,7 @@ avr_out_sbxx_branch (rtx insn, rtx operands[])\n       else  /* HImode or SImode */\n \t{\n \t  static char buf[] = \"sbrc %A1,0\";\n-\t  int bit_nr = exact_log2 (INTVAL (operands[2])\n-\t\t\t\t   & GET_MODE_MASK (GET_MODE (operands[1])));\n-\n+\t  int bit_nr = INTVAL (operands[2]);\n \t  buf[3] = (comp == EQ) ? 's' : 'c';\n \t  buf[6] = 'A' + (bit_nr >> 3);\n \t  buf[9] = '0' + (bit_nr & 7);"}, {"sha": "51fc1f99b8b4800a35da7ac5ac07ddd84a806247", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1f5d718b537106ca546813538abbc9ae733f10/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1f5d718b537106ca546813538abbc9ae733f10/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=ed1f5d718b537106ca546813538abbc9ae733f10", "patch": "@@ -118,6 +118,7 @@\n \n ;; Define mode iterator\n (define_mode_iterator QISI [(QI \"\") (HI \"\") (SI \"\")])\n+(define_mode_iterator QIDI [(QI \"\") (HI \"\") (SI \"\") (DI \"\")])\n \n ;;========================================================================\n ;; The following is used by nonlocal_goto and setjmp.\n@@ -2448,12 +2449,15 @@\n \n \n ;; Test a single bit in a QI/HI/SImode register.\n-(define_insn \"*sbrx_branch\"\n+;; Combine will create zero extract patterns for single bit tests.\n+;; permit any mode in source pattern by using VOIDmode.\n+\n+(define_insn \"*sbrx_branch<mode>\"\n   [(set (pc)\n         (if_then_else\n \t (match_operator 0 \"eqne_operator\"\n-\t\t\t [(zero_extract:HI\n-\t\t\t   (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t\t [(zero_extract:QIDI\n+\t\t\t   (match_operand:VOID 1 \"register_operand\" \"r\")\n \t\t\t   (const_int 1)\n \t\t\t   (match_operand 2 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n@@ -2470,39 +2474,27 @@\n \t\t\t\t    (const_int 4))))\n    (set_attr \"cc\" \"clobber\")])\n \n-(define_insn \"*sbrx_and_branchhi\"\n-  [(set (pc)\n-        (if_then_else\n-\t (match_operator 0 \"eqne_operator\"\n-\t\t\t [(and:HI\n-\t\t\t   (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:HI 2 \"single_one_operand\" \"n\"))\n-\t\t\t  (const_int 0)])\n-\t (label_ref (match_operand 3 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"* return avr_out_sbxx_branch (insn, operands);\"\n-  [(set (attr \"length\")\n-\t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n-\t\t\t   (le (minus (pc) (match_dup 3)) (const_int 2046)))\n-\t\t      (const_int 2)\n-\t\t      (if_then_else (eq_attr \"mcu_mega\" \"no\")\n-\t\t\t\t    (const_int 2)\n-\t\t\t\t    (const_int 4))))\n-   (set_attr \"cc\" \"clobber\")])\n+;; Same test based on Bitwise AND RTL. Keep this incase gcc changes patterns.\n+;; or for old peepholes.\n+;; Fixme - bitwise Mask will not work for DImode\n \n-(define_insn \"*sbrx_and_branchsi\"\n+(define_insn \"*sbrx_and_branch<mode>\"\n   [(set (pc)\n         (if_then_else\n \t (match_operator 0 \"eqne_operator\"\n-\t\t\t [(and:SI\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:SI 2 \"single_one_operand\" \"n\"))\n+\t\t\t [(and:QISI\n+\t\t\t   (match_operand:QISI 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:QISI 2 \"single_one_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n   \"\"\n-  \"* return avr_out_sbxx_branch (insn, operands);\"\n+{\n+    HOST_WIDE_INT bitnumber;\n+    bitnumber = exact_log2 (GET_MODE_MASK (<MODE>mode) & INTVAL (operands[2]));\n+    operands[2] = GEN_INT (bitnumber);\n+    return avr_out_sbxx_branch (insn, operands);\n+}\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n \t\t\t   (le (minus (pc) (match_dup 3)) (const_int 2046)))"}]}