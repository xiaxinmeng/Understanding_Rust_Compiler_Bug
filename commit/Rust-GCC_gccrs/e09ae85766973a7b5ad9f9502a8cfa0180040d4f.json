{"sha": "e09ae85766973a7b5ad9f9502a8cfa0180040d4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA5YWU4NTc2Njk3M2E3YjVhZDlmOTUwMmE4Y2ZhMDE4MDA0MGQ0Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-16T18:29:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-16T18:29:36Z"}, "message": "cp-tree.h (OVL_NESTED_P, [...]): New.\n\n\t* cp-tree.h (OVL_NESTED_P, OVL_LOOKUP_P): New.\n\t(ovl_first): Move inline definition to end of file.\n\t(ovl_make, lookup_add): Declare.\n\t(get_fns, get_first_fn): Make pure.\n\t* tree.c (ovl_cache): New.\n\t(ovl_make, lookup_add): New.\n\t* pt.c (do_class_deduction): Don't add candidates that will be\n\telided.\n\nFrom-SVN: r248121", "tree": {"sha": "f88c3f27212d6bb2bfbe0c7ef8f6ced3cc679f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f88c3f27212d6bb2bfbe0c7ef8f6ced3cc679f27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e09ae85766973a7b5ad9f9502a8cfa0180040d4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09ae85766973a7b5ad9f9502a8cfa0180040d4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09ae85766973a7b5ad9f9502a8cfa0180040d4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a736411aca6ab397d453e4ec8613933d3b304ac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a736411aca6ab397d453e4ec8613933d3b304ac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a736411aca6ab397d453e4ec8613933d3b304ac2"}], "stats": {"total": 165, "additions": 123, "deletions": 42}, "files": [{"sha": "5d336127cdbc6f1ec1fc92bb5f174bf4fc864546", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e09ae85766973a7b5ad9f9502a8cfa0180040d4f", "patch": "@@ -1,7 +1,16 @@\n 2017-05-16  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (OVL_NESTED_P, OVL_LOOKUP_P): New.\n+\t(ovl_first): Move inline definition to end of file.\n+\t(ovl_make, lookup_add): Declare.\n+\t(get_fns, get_first_fn): Make pure.\n+\t* tree.c (ovl_cache): New.\n+\t(ovl_make, lookup_add): New.\n+\t* pt.c (do_class_deduction): Don't add candidates that will be\n+\telided.\n+\n \t* call.c (build_user_type_conversion_1): Use OVL_FIRST.\n-\t(print_error_for_call_faulure): Use OVL_NAME.\n+\t(print_error_for_call_failure): Use OVL_NAME.\n \t(build_op_call_1): Use ovl_iterator.\n \t(add_candidates): Use OVL_FIRST & lkp_iterator.\n \t(build_op_delete_call): Use MAYBE_BASELINK_FUNCTIONS &"}, {"sha": "739ff184abb3e98b64f8b2a24cc85f691d071e3b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e09ae85766973a7b5ad9f9502a8cfa0180040d4f", "patch": "@@ -371,11 +371,13 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       CALL_EXPR_ORDERED_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n       DECLTYPE_FOR_REF_CAPTURE (in DECLTYPE_TYPE)\n       CONSTUCTOR_C99_COMPOUND_LITERAL (in CONSTRUCTOR)\n+      OVL_NESTED_P (in OVERLOAD)\n    4: TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n \t  CALL_EXPR, or FIELD_DECL).\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n       DECL_TINFO_P (in VAR_DECL)\n       FUNCTION_REF_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n+      OVL_LOOKUP_P (in OVERLOAD)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n       DECL_VTABLE_OR_VTT_P (in VAR_DECL)\n       FUNCTION_RVALUE_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n@@ -626,6 +628,11 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n    and can be freed afterward.  */\n #define OVL_ARG_DEPENDENT(NODE) TREE_LANG_FLAG_0 (OVERLOAD_CHECK (NODE))\n \n+/* If set, this overload contains a nested overload.  */\n+#define OVL_NESTED_P(NODE)\tTREE_LANG_FLAG_3 (OVERLOAD_CHECK (NODE))\n+/* If set, this overload was constructed during lookup.  */\n+#define OVL_LOOKUP_P(NODE)\tTREE_LANG_FLAG_4 (OVERLOAD_CHECK (NODE))\n+\n /* The first decl of an overload.  */\n #define OVL_FIRST(NODE)\tovl_first (NODE)\n /* The name of the overload set.  */\n@@ -6733,17 +6740,14 @@ extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n extern tree build_qualified_name\t\t(tree, tree, tree, bool);\n extern tree build_ref_qualified_type\t\t(tree, cp_ref_qualifier);\n-inline tree\n-ovl_first (tree node)\n-{\n-  while (TREE_CODE (node) == OVERLOAD)\n-    node = OVL_FUNCTION (node);\n-  return node;\n-}\n+inline tree ovl_first\t\t\t\t(tree) ATTRIBUTE_PURE;\n+extern tree ovl_make\t\t\t\t(tree fn,\n+\t\t\t\t\t\t tree next = NULL_TREE);\n+extern tree lookup_add\t\t\t\t(tree lookup, tree ovl);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree dependent_name\t\t\t(tree);\n-extern tree get_fns\t\t\t\t(tree);\n-extern tree get_first_fn\t\t\t(tree);\n+extern tree get_fns\t\t\t\t(tree) ATTRIBUTE_PURE;\n+extern tree get_first_fn\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree ovl_cons\t\t\t\t(tree, tree);\n extern tree build_overload\t\t\t(tree, tree);\n extern tree ovl_scope\t\t\t\t(tree);\n@@ -7188,6 +7192,16 @@ extern tree cp_ubsan_maybe_instrument_downcast\t(location_t, tree, tree, tree);\n extern tree cp_ubsan_maybe_instrument_cast_to_vbase (location_t, tree, tree);\n extern void cp_ubsan_maybe_initialize_vtbl_ptrs (tree);\n \n+/* Inline bodies.  */\n+\n+inline tree\n+ovl_first (tree node)\n+{\n+  while (TREE_CODE (node) == OVERLOAD)\n+    node = OVL_FUNCTION (node);\n+  return node;\n+}\n+\n /* -- end of C++ */\n \n #endif /* ! GCC_CP_TREE_H */"}, {"sha": "242b78c42aaf9d953dca0aa718848d2df5c1a326", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e09ae85766973a7b5ad9f9502a8cfa0180040d4f", "patch": "@@ -25157,9 +25157,29 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n   tree cands = lookup_qualified_name (CP_DECL_CONTEXT (tmpl), dname,\n \t\t\t\t      /*type*/false, /*complain*/false,\n \t\t\t\t      /*hidden*/false);\n+  bool elided = false;\n   if (cands == error_mark_node)\n     cands = NULL_TREE;\n \n+  /* Prune explicit deduction guides in copy-initialization context.  */\n+  if (flags & LOOKUP_ONLYCONVERTING)\n+    {\n+      for (lkp_iterator iter (cands); !elided && iter; ++iter)\n+\tif (DECL_NONCONVERTING_P (STRIP_TEMPLATE (*iter)))\n+\t  elided = true;\n+\n+      if (elided)\n+\t{\n+\t  /* Found a nonconverting guide, prune the candidates.  */\n+\t  tree pruned = NULL_TREE;\n+\t  for (lkp_iterator iter (cands); iter; ++iter)\n+\t    if (!DECL_NONCONVERTING_P (STRIP_TEMPLATE (*iter)))\n+\t      pruned = lookup_add (pruned, *iter);\n+\n+\t  cands = pruned;\n+\t}\n+    }\n+\n   tree outer_args = NULL_TREE;\n   if (DECL_CLASS_SCOPE_P (tmpl)\n       && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (tmpl)))\n@@ -25171,53 +25191,45 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n   bool saw_ctor = false;\n   if (CLASSTYPE_METHOD_VEC (type))\n     // FIXME cache artificial deduction guides\n-    for (tree fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))\n+    for (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (type));\n+\t iter; ++iter)\n       {\n-\ttree fn = OVL_CURRENT (fns);\n-\ttree guide = build_deduction_guide (fn, outer_args, complain);\n-\tcands = ovl_cons (guide, cands);\n+\ttree guide = build_deduction_guide (*iter, outer_args, complain);\n+\tif ((flags & LOOKUP_ONLYCONVERTING)\n+\t    && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n+\t  elided = true;\n+\telse\n+\t  cands = lookup_add (cands, guide);\n \n \tsaw_ctor = true;\n       }\n \n   if (!saw_ctor && args->length() == 0)\n     {\n       tree guide = build_deduction_guide (type, outer_args, complain);\n-      cands = ovl_cons (guide, cands);\n+      if ((flags & LOOKUP_ONLYCONVERTING)\n+\t  && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n+\telided = true;\n+      else\n+\tcands = lookup_add (cands, guide);\n     }\n   if (args->length() == 1)\n     {\n       tree guide = build_deduction_guide (build_reference_type (type),\n \t\t\t\t\t  outer_args, complain);\n-      cands = ovl_cons (guide, cands);\n+      if ((flags & LOOKUP_ONLYCONVERTING)\n+\t  && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n+\telided = true;\n+      else\n+\tcands = lookup_add (cands, guide);\n     }\n \n-  /* Prune explicit deduction guides in copy-initialization context.  */\n-  tree old_cands = cands;\n-  if (flags & LOOKUP_ONLYCONVERTING)\n+  if (elided && !cands)\n     {\n-      tree t = cands;\n-      for (; t; t = OVL_NEXT (t))\n-\tif (DECL_NONCONVERTING_P (STRIP_TEMPLATE (OVL_CURRENT (t))))\n-\t  break;\n-      if (t)\n-\t{\n-\t  tree pruned = NULL_TREE;\n-\t  for (t = cands; t; t = OVL_NEXT (t))\n-\t    {\n-\t      tree f = OVL_CURRENT (t);\n-\t      if (!DECL_NONCONVERTING_P (STRIP_TEMPLATE (f)))\n-\t\tpruned = build_overload (f, pruned);\n-\t    }\n-\t  cands = pruned;\n-\t  if (cands == NULL_TREE)\n-\t    {\n-\t      error (\"cannot deduce template arguments for copy-initialization\"\n-\t\t     \" of %qT, as it has no non-explicit deduction guides or \"\n-\t\t     \"user-declared constructors\", type);\n-\t      return error_mark_node;\n-\t    }\n-\t}\n+      error (\"cannot deduce template arguments for copy-initialization\"\n+\t     \" of %qT, as it has no non-explicit deduction guides or \"\n+\t     \"user-declared constructors\", type);\n+      return error_mark_node;\n     }\n \n   ++cp_unevaluated_operand;\n@@ -25227,7 +25239,7 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n     {\n       error (\"class template argument deduction failed:\");\n       t = build_new_function_call (cands, &args, complain | tf_decltype);\n-      if (old_cands != cands)\n+      if (elided)\n \tinform (input_location, \"explicit deduction guides not considered \"\n \t\t\"for copy-initialization\");\n     }"}, {"sha": "edc012087462e8bce134daa7e8222fea07eefba9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09ae85766973a7b5ad9f9502a8cfa0180040d4f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e09ae85766973a7b5ad9f9502a8cfa0180040d4f", "patch": "@@ -2094,6 +2094,52 @@ build_ref_qualified_type (tree type, cp_ref_qualifier rqual)\n   return t;\n }\n \n+/* Cache of free ovl nodes.  Uses OVL_FUNCTION for chaining.  */\n+static GTY((deletable)) tree ovl_cache;\n+\n+/* Make a raw overload node containing FN.  */\n+\n+tree\n+ovl_make (tree fn, tree next)\n+{\n+  tree result = ovl_cache;\n+\n+  if (result)\n+    {\n+      ovl_cache = OVL_FUNCTION (result);\n+      /* Zap the flags.  */\n+      memset (result, 0, sizeof (tree_base));\n+      TREE_SET_CODE (result, OVERLOAD);\n+    }\n+  else\n+    result = make_node (OVERLOAD);\n+\n+  if (TREE_CODE (fn) == OVERLOAD)\n+    OVL_NESTED_P (result) = true;\n+\n+  TREE_TYPE (result) = (next || TREE_CODE (fn) == TEMPLATE_DECL\n+\t\t\t? unknown_type_node : TREE_TYPE (fn));\n+  OVL_FUNCTION (result) = fn;\n+  OVL_CHAIN (result) = next;\n+  return result;\n+}\n+\n+/* Add a potential overload into a lookup set.  */\n+\n+tree\n+lookup_add (tree lookup, tree ovl)\n+{\n+  if (lookup || TREE_CODE (ovl) == TEMPLATE_DECL)\n+    {\n+      lookup = ovl_make (ovl, lookup);\n+      OVL_LOOKUP_P (lookup) = true;\n+    }\n+  else\n+    lookup = ovl;\n+\n+  return lookup;\n+}\n+\n /* Returns nonzero if X is an expression for a (possibly overloaded)\n    function.  If \"f\" is a function or function template, \"f\", \"c->f\",\n    \"c.f\", \"C::f\", and \"f<int>\" will all be considered possibly"}]}