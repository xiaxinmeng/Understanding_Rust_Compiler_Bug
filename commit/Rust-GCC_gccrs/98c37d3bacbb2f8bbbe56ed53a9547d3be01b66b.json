{"sha": "98c37d3bacbb2f8bbbe56ed53a9547d3be01b66b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjMzdkM2JhY2JiMmY4YmJiZTU2ZWQ1M2E5NTQ3ZDNiZTAxYjY2Yg==", "commit": {"author": {"name": "Daniel Lemire", "email": "lemire@gmail.com", "date": "2020-10-09T13:09:36Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-10-09T13:09:36Z"}, "message": "libstdc++: Optimize uniform_int_distribution using Lemire's algorithm\n\nCo-authored-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/uniform_int_dist.h (uniform_int_distribution::_S_nd):\n\tNew member function implementing Lemire's \"nearly divisionless\"\n\talgorithm.\n\t(uniform_int_distribution::operator()): Use _S_nd when the range\n\tof the URBG is the full width of the result type.", "tree": {"sha": "072d00b35158c00d6488a97790c217d4bb27b563", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/072d00b35158c00d6488a97790c217d4bb27b563"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98c37d3bacbb2f8bbbe56ed53a9547d3be01b66b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c37d3bacbb2f8bbbe56ed53a9547d3be01b66b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c37d3bacbb2f8bbbe56ed53a9547d3be01b66b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c37d3bacbb2f8bbbe56ed53a9547d3be01b66b/comments", "author": {"login": "lemire", "id": 391987, "node_id": "MDQ6VXNlcjM5MTk4Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/391987?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lemire", "html_url": "https://github.com/lemire", "followers_url": "https://api.github.com/users/lemire/followers", "following_url": "https://api.github.com/users/lemire/following{/other_user}", "gists_url": "https://api.github.com/users/lemire/gists{/gist_id}", "starred_url": "https://api.github.com/users/lemire/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lemire/subscriptions", "organizations_url": "https://api.github.com/users/lemire/orgs", "repos_url": "https://api.github.com/users/lemire/repos", "events_url": "https://api.github.com/users/lemire/events{/privacy}", "received_events_url": "https://api.github.com/users/lemire/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ce2cb116af6e0965ff0dd69e7fd1925cf5dc68c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce2cb116af6e0965ff0dd69e7fd1925cf5dc68c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ce2cb116af6e0965ff0dd69e7fd1925cf5dc68c"}], "stats": {"total": 61, "additions": 54, "deletions": 7}, "files": [{"sha": "ecb8574864aee10b9ea164379fffef27c7bdb0df", "filename": "libstdc++-v3/include/bits/uniform_int_dist.h", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c37d3bacbb2f8bbbe56ed53a9547d3be01b66b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funiform_int_dist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c37d3bacbb2f8bbbe56ed53a9547d3be01b66b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funiform_int_dist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funiform_int_dist.h?ref=98c37d3bacbb2f8bbbe56ed53a9547d3be01b66b", "patch": "@@ -234,6 +234,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\tconst param_type& __p);\n \n       param_type _M_param;\n+\n+      // Lemire's nearly divisionless algorithm.\n+      // Returns an unbiased random number from __g downscaled to [0,__range)\n+      // using an unsigned type _Wp twice as wide as unsigned type _Up.\n+      template<typename _Wp, typename _Urbg, typename _Up>\n+\tstatic _Up\n+\t_S_nd(_Urbg& __g, _Up __range)\n+\t{\n+\t  using __gnu_cxx::__int_traits;\n+\t  static_assert(!__int_traits<_Up>::__is_signed, \"U must be unsigned\");\n+\t  static_assert(!__int_traits<_Wp>::__is_signed, \"W must be unsigned\");\n+\n+\t  // reference: Fast Random Integer Generation in an Interval\n+\t  // ACM Transactions on Modeling and Computer Simulation 29 (1), 2019\n+\t  // https://arxiv.org/abs/1805.10941\n+\t  _Wp __product = _Wp(__g()) * _Wp(__range);\n+\t  _Up __low = _Up(__product);\n+\t  if (__low < __range)\n+\t    {\n+\t      _Up __threshold = -__range % __range;\n+\t      while (__low < __threshold)\n+\t\t{\n+\t\t  __product = _Wp(__g()) * _Wp(__range);\n+\t\t  __low = _Up(__product);\n+\t\t}\n+\t    }\n+\t  return __product >> __gnu_cxx::__int_traits<_Up>::__digits;\n+\t}\n     };\n \n   template<typename _IntType>\n@@ -256,17 +284,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  = __uctype(__param.b()) - __uctype(__param.a());\n \n \t__uctype __ret;\n-\n \tif (__urngrange > __urange)\n \t  {\n \t    // downscaling\n+\n \t    const __uctype __uerange = __urange + 1; // __urange can be zero\n-\t    const __uctype __scaling = __urngrange / __uerange;\n-\t    const __uctype __past = __uerange * __scaling;\n-\t    do\n-\t      __ret = __uctype(__urng()) - __urngmin;\n-\t    while (__ret >= __past);\n-\t    __ret /= __scaling;\n+\n+\t    using __gnu_cxx::__int_traits;\n+#if __SIZEOF_INT128__\n+\t    if (__int_traits<__uctype>::__digits == 64\n+\t\t&& __urngrange == __int_traits<__uctype>::__max)\n+\t      {\n+\t\t__ret = _S_nd<unsigned __int128>(__urng, __uerange);\n+\t      }\n+\t    else\n+#endif\n+\t    if (__int_traits<__uctype>::__digits == 32\n+\t\t&& __urngrange == __int_traits<__uctype>::__max)\n+\t      {\n+\t\t__ret = _S_nd<__UINT64_TYPE__>(__urng, __uerange);\n+\t      }\n+\t    else\n+\t      {\n+\t\t// fallback case (2 divisions)\n+\t\tconst __uctype __scaling = __urngrange / __uerange;\n+\t\tconst __uctype __past = __uerange * __scaling;\n+\t\tdo\n+\t\t  __ret = __uctype(__urng()) - __urngmin;\n+\t\twhile (__ret >= __past);\n+\t\t__ret /= __scaling;\n+\t      }\n \t  }\n \telse if (__urngrange < __urange)\n \t  {"}]}