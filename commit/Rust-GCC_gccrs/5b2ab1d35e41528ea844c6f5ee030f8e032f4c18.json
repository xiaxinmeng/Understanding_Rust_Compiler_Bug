{"sha": "5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIyYWIxZDM1ZTQxNTI4ZWE4NDRjNmY1ZWUwMzBmOGUwMzJmNGMxOA==", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-09-08T17:26:15Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-09-10T16:06:58Z"}, "message": "bpf: add -mcpu and related feature options\n\nNew instructions have been added over time to the eBPF ISA, but\npreviously there has been no good method to select which version to\ntarget in GCC.\n\nThis patch adds the following options to the BPF backend:\n\n  -mcpu={v1, v2, v3}\n    Select which version of the eBPF ISA to target. This enables or\n    disables generation of certain instructions. The default is v3.\n\n  -mjmpext\n    Enable extra conditional branch instructions.\n    Enabled for CPU v2 and above.\n\n  -mjmp32\n    Enable 32-bit jump/branch instructions.\n    Enabled for CPU v3 and above.\n\n  -malu32\n    Enable 32-bit ALU instructions.\n    Enabled for CPU v3 and above.\n\ngcc/ChangeLog:\n\t* config/bpf/bpf-opts.h (bpf_isa_version): New enum.\n\t* config/bpf/bpf-protos.h (bpf_expand_cbranch): New.\n\t* config/bpf/bpf.c (bpf_option_override): Handle -mcpu option.\n\t(bpf_expand_cbranch): New function.\n\t* config/bpf/bpf.md (AM mode iterator): Conditionalize support for SI\n\tmode.\n\t(zero_extendsidi2): Only use mov32 instruction if it is available.\n\t(SIM mode iterator): Conditionalize support for SI mode.\n\t(JM mode iterator): New.\n\t(cbranchdi4): Update name, use new JM iterator. Use bpf_expand_cbranch.\n\t(*branch_on_di): Update name, use new JM iterator.\n\t* config/bpf/bpf.opt: (mjmpext): New option.\n\t(malu32): Likewise.\n\t(mjmp32): Likewise.\n\t(mcpu): Likewise.\n\t(bpf_isa): New enum.", "tree": {"sha": "3db086072fed1cfcbd481e7c67fec2a661548741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3db086072fed1cfcbd481e7c67fec2a661548741"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f0f696fea17cd91b184181abcf596df0e857304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0f696fea17cd91b184181abcf596df0e857304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0f696fea17cd91b184181abcf596df0e857304"}], "stats": {"total": 122, "additions": 102, "deletions": 20}, "files": [{"sha": "456e39c2200e7a90e946b88d6674fc96df978ed4", "filename": "gcc/config/bpf/bpf-opts.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf-opts.h?ref=5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "patch": "@@ -53,4 +53,11 @@ enum bpf_kernel_version\n   LINUX_NATIVE,\n };\n \n+enum bpf_isa_version\n+{\n+  ISA_V1,\n+  ISA_V2,\n+  ISA_V3,\n+};\n+\n #endif /* ! BPF_OPTS_H */"}, {"sha": "e6bb9015449d96d0ea55db31dd14bbcc76460363", "filename": "gcc/config/bpf/bpf-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf-protos.h?ref=5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "patch": "@@ -29,6 +29,7 @@ extern void bpf_print_operand (FILE *, rtx, int);\n extern void bpf_print_operand_address (FILE *, rtx);\n extern void bpf_expand_prologue (void);\n extern void bpf_expand_epilogue (void);\n+extern void bpf_expand_cbranch (machine_mode, rtx *);\n \n rtl_opt_pass * make_pass_bpf_core_attr (gcc::context *);\n "}, {"sha": "82bb698bd917893ab1e613cf905699a5b5270362", "filename": "gcc/config/bpf/bpf.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.c?ref=5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "patch": "@@ -242,6 +242,17 @@ bpf_option_override (void)\n       target_flags |= MASK_BPF_CORE;\n       write_symbols |= BTF_WITH_CORE_DEBUG;\n     }\n+\n+  /* Determine available features from ISA setting (-mcpu=).  */\n+  if (bpf_has_jmpext == -1)\n+    bpf_has_jmpext = (bpf_isa >= ISA_V2);\n+\n+  if (bpf_has_alu32 == -1)\n+    bpf_has_alu32 = (bpf_isa >= ISA_V3);\n+\n+  if (bpf_has_jmp32 == -1)\n+    bpf_has_jmp32 = (bpf_isa >= ISA_V3);\n+\n }\n \n #undef TARGET_OPTION_OVERRIDE\n@@ -540,6 +551,36 @@ bpf_expand_epilogue (void)\n   emit_jump_insn (gen_exit ());\n }\n \n+/* Expand to the instructions for a conditional branch. This function\n+   is called when expanding the 'cbranch<mode>4' pattern in bpf.md.  */\n+\n+void\n+bpf_expand_cbranch (machine_mode mode, rtx *operands)\n+{\n+  /* If all jump instructions are available, nothing special to do here.  */\n+  if (bpf_has_jmpext)\n+    return;\n+\n+  enum rtx_code code = GET_CODE (operands[0]);\n+\n+  /* Without the conditional branch instructions jslt, jsle, jlt, jle, we need\n+     to convert conditional branches that would use them to an available\n+     operation instead by reversing the comparison.  */\n+  if ((code == LT || code == LE || code == LTU || code == LEU))\n+    {\n+      /* Reverse the condition.  */\n+      PUT_CODE (operands[0], reverse_condition (code));\n+\n+      /* Swap the operands, and ensure that the first is a register.  */\n+      if (!register_operand (operands[2], mode))\n+\toperands[2] = force_reg (mode, operands[2]);\n+\n+      rtx tmp = operands[1];\n+      operands[1] = operands[2];\n+      operands[2] = tmp;\n+    }\n+}\n+\n /* Return the initial difference between the specified pair of\n    registers.  The registers that can figure in FROM, and TO, are\n    specified by ELIMINABLE_REGS in bpf.h."}, {"sha": "436c8dfa0597da952b3582e8267b24a0d738609c", "filename": "gcc/config/bpf/bpf.md", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.md?ref=5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "patch": "@@ -100,9 +100,9 @@\n ;; insns, with the proper modes.\n ;;\n ;; 32-bit arithmetic (for SI modes) is implemented using the alu32\n-;; instructions.\n+;; instructions, if available.\n \n-(define_mode_iterator AM [SI DI])\n+(define_mode_iterator AM [(SI \"bpf_has_alu32\") DI])\n \n ;;; Addition\n (define_insn \"add<AM:mode>3\"\n@@ -266,7 +266,7 @@\n \t  (match_operand:SI 1 \"nonimmediate_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-   mov32\\t%0,%1\n+   * return bpf_has_alu32 ? \\\"mov32\\t%0,%1\\\" : \\\"mov\\t%0,%1\\;and\\t%0,0xffffffff\\\";\n    ldxw\\t%0,%1\"\n   [(set_attr \"type\" \"alu,ldx\")])\n \n@@ -315,7 +315,7 @@\n \n ;;;; Shifts\n \n-(define_mode_iterator SIM [SI DI])\n+(define_mode_iterator SIM [(SI \"bpf_has_alu32\") DI])\n \n (define_insn \"ashr<SIM:mode>3\"\n   [(set (match_operand:SIM 0 \"register_operand\"                 \"=r,r\")\n@@ -346,24 +346,28 @@\n ;; The eBPF jump instructions use 64-bit arithmetic when evaluating\n ;; the jump conditions.  Therefore we use DI modes below.\n \n-(define_expand \"cbranchdi4\"\n+(define_mode_iterator JM [(SI \"bpf_has_jmp32\") DI])\n+\n+(define_expand \"cbranch<JM:mode>4\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t[(match_operand:DI 1 \"register_operand\")\n-\t\t\t (match_operand:DI 2 \"reg_or_imm_operand\")])\n+\t\t\t[(match_operand:JM 1 \"register_operand\")\n+\t\t\t (match_operand:JM 2 \"reg_or_imm_operand\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n {\n   if (!ordered_comparison_operator (operands[0], VOIDmode))\n     FAIL;\n+\n+  bpf_expand_cbranch (<JM:MODE>mode, operands);\n })\n \n-(define_insn \"*branch_on_di\"\n+(define_insn \"*branch_on_<JM:mode>\"\n   [(set (pc)\n \t(if_then_else (match_operator 3 \"ordered_comparison_operator\"\n-\t\t\t [(match_operand:DI 0 \"register_operand\" \"r\")\n-\t\t\t  (match_operand:DI 1 \"reg_or_imm_operand\" \"rI\")])\n+\t\t\t [(match_operand:JM 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:JM 1 \"reg_or_imm_operand\" \"rI\")])\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -372,16 +376,16 @@\n \n   switch (code)\n   {\n-  case EQ: return \"jeq\\t%0,%1,%2\"; break;\n-  case NE: return \"jne\\t%0,%1,%2\"; break;\n-  case LT: return \"jslt\\t%0,%1,%2\"; break;\n-  case LE: return \"jsle\\t%0,%1,%2\"; break;\n-  case GT: return \"jsgt\\t%0,%1,%2\"; break;\n-  case GE: return \"jsge\\t%0,%1,%2\"; break;\n-  case LTU: return \"jlt\\t%0,%1,%2\"; break;\n-  case LEU: return \"jle\\t%0,%1,%2\"; break;\n-  case GTU: return \"jgt\\t%0,%1,%2\"; break;\n-  case GEU: return \"jge\\t%0,%1,%2\"; break;\n+  case EQ: return \"jeq<msuffix>\\t%0,%1,%2\"; break;\n+  case NE: return \"jne<msuffix>\\t%0,%1,%2\"; break;\n+  case LT: return \"jslt<msuffix>\\t%0,%1,%2\"; break;\n+  case LE: return \"jsle<msuffix>\\t%0,%1,%2\"; break;\n+  case GT: return \"jsgt<msuffix>\\t%0,%1,%2\"; break;\n+  case GE: return \"jsge<msuffix>\\t%0,%1,%2\"; break;\n+  case LTU: return \"jlt<msuffix>\\t%0,%1,%2\"; break;\n+  case LEU: return \"jle<msuffix>\\t%0,%1,%2\"; break;\n+  case GTU: return \"jgt<msuffix>\\t%0,%1,%2\"; break;\n+  case GEU: return \"jge<msuffix>\\t%0,%1,%2\"; break;\n   default:\n     gcc_unreachable ();\n     return \"\";"}, {"sha": "e8b728ca69f07246432b2a4da250933c1bafc3eb", "filename": "gcc/config/bpf/bpf.opt", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b2ab1d35e41528ea844c6f5ee030f8e032f4c18/gcc%2Fconfig%2Fbpf%2Fbpf.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.opt?ref=5b2ab1d35e41528ea844c6f5ee030f8e032f4c18", "patch": "@@ -131,3 +131,32 @@ Set a hard limit for the size of each stack frame, in bytes.\n mco-re\n Target Mask(BPF_CORE)\n Generate all necessary information for BPF Compile Once - Run Everywhere.\n+\n+; Selecting BPF ISA features and versions\n+\n+mjmpext\n+Target Var(bpf_has_jmpext) Init(-1)\n+Enable extra conditional-branch instructions j(s)lt and j(s)le.\n+\n+malu32\n+Target Var(bpf_has_alu32) Init(-1)\n+Enable 32-bit ALU instructions.\n+\n+mjmp32\n+Target Var(bpf_has_jmp32) Init(-1)\n+Enable 32-bit jump instructions.\n+\n+mcpu=\n+Target RejectNegative Joined Var(bpf_isa) Enum(bpf_isa) Init(ISA_V3)\n+\n+Enum\n+Name(bpf_isa) Type(enum bpf_isa_version)\n+\n+EnumValue\n+Enum(bpf_isa) String(v1) Value(ISA_V1)\n+\n+EnumValue\n+Enum(bpf_isa) String(v2) Value(ISA_V2)\n+\n+EnumValue\n+Enum(bpf_isa) String(v3) Value(ISA_V3)"}]}