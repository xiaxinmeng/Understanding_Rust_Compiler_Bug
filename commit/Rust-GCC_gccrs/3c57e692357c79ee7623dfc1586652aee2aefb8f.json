{"sha": "3c57e692357c79ee7623dfc1586652aee2aefb8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M1N2U2OTIzNTdjNzllZTc2MjNkZmMxNTg2NjUyYWVlMmFlZmI4Zg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T04:11:34Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-18T04:11:34Z"}, "message": "libstdc++: Add floating-point std::to_chars implementation\n\nThis implements the floating-point std::to_chars overloads for float,\ndouble and long double.  We use the Ryu library to compute the shortest\nround-trippable fixed and scientific forms for float, double and long\ndouble.  We also use Ryu for performing explicit-precision fixed and\nscientific formatting for float and double. For explicit-precision\nformatting for long double we fall back to using printf.  Hexadecimal\nformatting for float, double and long double is implemented from\nscratch.\n\nThe supported long double binary formats are binary64, binary80 (x86\n80-bit extended precision), binary128 and ibm128.\n\nMuch of the complexity of the implementation is in computing the exact\noutput length before handing it off to Ryu (which doesn't do bounds\nchecking).  In some cases it's hard to compute the output length\nbeforehand, so in these cases we instead compute an upper bound on the\noutput length and use a sufficiently-sized intermediate buffer only if\nnecessary.\n\nAnother source of complexity is in the general-with-precision formatting\nmode, where we need to do zero-trimming of the string returned by Ryu,\nand where we also take care to avoid having to format the number through\nRyu a second time when the general formatting mode resolves to fixed\n(which we determine by doing a scientific formatting first and\ninspecting the scientific exponent).  We avoid going through Ryu twice\nby instead transforming the scientific form to the corresponding fixed\nform via in-place string manipulation.\n\nThis implementation is non-conforming in a couple of ways:\n\n1. For the shortest hexadecimal formatting, we currently follow the\n   Microsoft implementation's decision to be consistent with the\n   output of printf's '%a' specifier at the expense of sometimes not\n   printing the shortest representation.  For example, the shortest hex\n   form for the number 1.08p+0 is 2.1p-1, but we output the former\n   instead of the latter, as does printf.\n\n2. The Ryu routine generic_binary_to_decimal that we use for performing\n   shortest formatting for large floating point types is implemented\n   using the __int128 type, but some targets with a large long double\n   type lack __int128 (e.g. i686), so we can't perform shortest\n   formatting of long double on such targets through Ryu.  As a\n   temporary stopgap this patch makes the long double to_chars overloads\n   just dispatch to the double overloads on these targets, which means\n   we lose precision in the output.  (We could potentially fix this by\n   writing a specialized version of Ryu's generic_binary_to_decimal\n   routine that uses uint64_t instead of __int128.)  [Though I wonder if\n   there's a better way to work around the lack of __int128 on i686\n   specifically?]\n\n3. Our shortest formatting for __ibm128 doesn't guarantee the round-trip\n   property if the difference between the high- and low-order exponent\n   is large.  This is because we treat __ibm128 as if it has a\n   contiguous 105-bit mantissa by merging the mantissas of the high-\n   and low-order parts (using code extracted from glibc), so we\n   potentially lose precision from the low-order part.  This seems to be\n   consistent with how glibc printf formats __ibm128.\n\nlibstdc++-v3/ChangeLog:\n\n\t* config/abi/pre/gnu.ver: Add new exports.\n\t* include/std/charconv (to_chars): Declare the floating-point\n\toverloads for float, double and long double.\n\t* src/c++17/Makefile.am (sources): Add floating_to_chars.cc.\n\t* src/c++17/Makefile.in: Regenerate.\n\t* src/c++17/floating_to_chars.cc: New file.\n\t(to_chars): Define for float, double and long double.\n\t* testsuite/20_util/to_chars/long_double.cc: New test.", "tree": {"sha": "8ee7365cc85f9dcf280b78803b76e0544d843451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ee7365cc85f9dcf280b78803b76e0544d843451"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c57e692357c79ee7623dfc1586652aee2aefb8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c57e692357c79ee7623dfc1586652aee2aefb8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c57e692357c79ee7623dfc1586652aee2aefb8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c57e692357c79ee7623dfc1586652aee2aefb8f/comments", "author": null, "committer": null, "parents": [{"sha": "5033506993ef92589373270a8e8dbbf50e3ebef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5033506993ef92589373270a8e8dbbf50e3ebef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5033506993ef92589373270a8e8dbbf50e3ebef1"}], "stats": {"total": 1797, "additions": 1796, "deletions": 1}, "files": [{"sha": "05e0a512247d623228511c85d9ace47d836b05b0", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=3c57e692357c79ee7623dfc1586652aee2aefb8f", "patch": "@@ -2393,6 +2393,13 @@ GLIBCXX_3.4.29 {\n     # std::once_flag::_M_finish(bool)\n     _ZNSt9once_flag9_M_finishEb;\n \n+    # std::to_chars(char*, char*, [float|double|long double])\n+    _ZSt8to_charsPcS_[defg];\n+    # std::to_chars(char*, char*, [float|double|long double], chars_format)\n+    _ZSt8to_charsPcS_[defg]St12chars_format;\n+    # std::to_chars(char*, char*, [float|double|long double], chars_format, int)\n+    _ZSt8to_charsPcS_[defg]St12chars_formati;\n+\n } GLIBCXX_3.4.28;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "b57b0a16db27a14fc294eb28079d41e9888d75b2", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=3c57e692357c79ee7623dfc1586652aee2aefb8f", "patch": "@@ -702,6 +702,30 @@ namespace __detail\n \t     chars_format __fmt = chars_format::general) noexcept;\n #endif\n \n+  // Floating-point std::to_chars\n+\n+  // Overloads for float.\n+  to_chars_result to_chars(char* __first, char* __last, float __value) noexcept;\n+  to_chars_result to_chars(char* __first, char* __last, float __value,\n+\t\t\t   chars_format __fmt) noexcept;\n+  to_chars_result to_chars(char* __first, char* __last, float __value,\n+\t\t\t   chars_format __fmt, int __precision) noexcept;\n+\n+  // Overloads for double.\n+  to_chars_result to_chars(char* __first, char* __last, double __value) noexcept;\n+  to_chars_result to_chars(char* __first, char* __last, double __value,\n+\t\t\t   chars_format __fmt) noexcept;\n+  to_chars_result to_chars(char* __first, char* __last, double __value,\n+\t\t\t   chars_format __fmt, int __precision) noexcept;\n+\n+  // Overloads for long double.\n+  to_chars_result to_chars(char* __first, char* __last, long double __value)\n+    noexcept;\n+  to_chars_result to_chars(char* __first, char* __last, long double __value,\n+\t\t\t   chars_format __fmt) noexcept;\n+  to_chars_result to_chars(char* __first, char* __last, long double __value,\n+\t\t\t   chars_format __fmt, int __precision) noexcept;\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n #endif // C++14"}, {"sha": "2ec5ed621ca681a9eed138acbf88641629beffd5", "filename": "libstdc++-v3/src/c++17/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.am?ref=3c57e692357c79ee7623dfc1586652aee2aefb8f", "patch": "@@ -51,6 +51,7 @@ endif\n \n sources = \\\n \tfloating_from_chars.cc \\\n+\tfloating_to_chars.cc \\\n \tfs_dir.cc \\\n \tfs_ops.cc \\\n \tfs_path.cc \\"}, {"sha": "9b36b7a916c8591e073ae07aaf59a87834105e75", "filename": "libstdc++-v3/src/c++17/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2FMakefile.in?ref=3c57e692357c79ee7623dfc1586652aee2aefb8f", "patch": "@@ -124,7 +124,7 @@ LTLIBRARIES = $(noinst_LTLIBRARIES)\n libc__17convenience_la_LIBADD =\n @ENABLE_DUAL_ABI_TRUE@am__objects_1 = cow-fs_dir.lo cow-fs_ops.lo \\\n @ENABLE_DUAL_ABI_TRUE@\tcow-fs_path.lo\n-am__objects_2 = floating_from_chars.lo fs_dir.lo fs_ops.lo fs_path.lo \\\n+am__objects_2 = floating_from_chars.lo floating_to_chars.lo fs_dir.lo fs_ops.lo fs_path.lo \\\n \tmemory_resource.lo $(am__objects_1)\n @ENABLE_DUAL_ABI_TRUE@am__objects_3 = cow-string-inst.lo\n @ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = ostream-inst.lo \\\n@@ -440,6 +440,7 @@ headers =\n \n sources = \\\n \tfloating_from_chars.cc \\\n+\tfloating_to_chars.cc \\\n \tfs_dir.cc \\\n \tfs_ops.cc \\\n \tfs_path.cc \\"}, {"sha": "dd83f5eea93fdc609e7516c03fb47bebb6ee9662", "filename": "libstdc++-v3/src/c++17/floating_to_chars.cc", "status": "added", "additions": 1563, "deletions": 0, "changes": 1563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc?ref=3c57e692357c79ee7623dfc1586652aee2aefb8f", "patch": "@@ -0,0 +1,1563 @@\n+// std::to_chars implementation for floating-point types -*- C++ -*-\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Activate __glibcxx_assert within this file to shake out any bugs.\n+#define _GLIBCXX_ASSERTIONS 1\n+\n+#include <charconv>\n+\n+#include <bit>\n+#include <cfenv>\n+#include <cassert>\n+#include <cmath>\n+#include <cstdio>\n+#include <cstring>\n+#include <langinfo.h>\n+#include <optional>\n+#include <string_view>\n+#include <type_traits>\n+\n+// Determine the binary format of 'long double'.\n+\n+// We support the binary64, float80 (i.e. x86 80-bit extended precision),\n+// binary128, and ibm128 formats.\n+#define LDK_UNSUPPORTED 0\n+#define LDK_BINARY64    1\n+#define LDK_FLOAT80     2\n+#define LDK_BINARY128   3\n+#define LDK_IBM128      4\n+\n+#if __LDBL_MANT_DIG__ == __DBL_MANT_DIG__\n+# define LONG_DOUBLE_KIND LDK_BINARY64\n+#elif defined(__SIZEOF_INT128__)\n+// The Ryu routines need a 128-bit integer type in order to do shortest\n+// formatting of types larger than 64-bit double, so without __int128 we can't\n+// support any large long double format.  This is the case for e.g. i386.\n+# if __LDBL_MANT_DIG__ == 64\n+#  define LONG_DOUBLE_KIND LDK_FLOAT80\n+# elif __LDBL_MANT_DIG__ == 113\n+#  define LONG_DOUBLE_KIND LDK_BINARY128\n+# elif __LDBL_MANT_DIG__ == 106\n+#  define LONG_DOUBLE_KIND LDK_IBM128\n+# endif\n+#endif\n+#if !defined(LONG_DOUBLE_KIND)\n+# define LONG_DOUBLE_KIND LDK_UNSUPPORTED\n+#endif\n+\n+namespace\n+{\n+  namespace ryu\n+  {\n+#include \"ryu/common.h\"\n+#include \"ryu/digit_table.h\"\n+#include \"ryu/d2s_intrinsics.h\"\n+#include \"ryu/d2s_full_table.h\"\n+#include \"ryu/d2fixed_full_table.h\"\n+#include \"ryu/f2s_intrinsics.h\"\n+#include \"ryu/d2s.c\"\n+#include \"ryu/d2fixed.c\"\n+#include \"ryu/f2s.c\"\n+\n+#ifdef __SIZEOF_INT128__\n+    namespace generic128\n+    {\n+      // Put the generic Ryu bits in their own namespace to avoid name conflicts.\n+# include \"ryu/generic_128.h\"\n+# include \"ryu/ryu_generic_128.h\"\n+# include \"ryu/generic_128.c\"\n+    } // namespace generic128\n+\n+    using generic128::floating_decimal_128;\n+    using generic128::generic_binary_to_decimal;\n+\n+    int\n+    to_chars(const floating_decimal_128 v, char* const result)\n+    { return generic128::generic_to_chars(v, result); }\n+#endif\n+  } // namespace ryu\n+\n+  // A traits class that contains pertinent information about the binary\n+  // format of each of the floating-point types we support.\n+  template<typename T>\n+    struct floating_type_traits\n+    { };\n+\n+  template<>\n+    struct floating_type_traits<float>\n+    {\n+      // We (and Ryu) assume float has the IEEE binary32 format.\n+      static_assert(__FLT_MANT_DIG__ == 24);\n+      static constexpr int mantissa_bits = 23;\n+      static constexpr int exponent_bits = 8;\n+      static constexpr bool has_implicit_leading_bit = true;\n+      using mantissa_t = uint32_t;\n+      using shortest_scientific_t = ryu::floating_decimal_32;\n+\n+      static constexpr uint64_t pow10_adjustment_tab[]\n+\t= { 0b0000000000011101011100110101100101101110000000000000000000000000 };\n+    };\n+\n+  template<>\n+    struct floating_type_traits<double>\n+    {\n+      // We (and Ryu) assume double has the IEEE binary64 format.\n+      static_assert(__DBL_MANT_DIG__ == 53);\n+      static constexpr int mantissa_bits = 52;\n+      static constexpr int exponent_bits = 11;\n+      static constexpr bool has_implicit_leading_bit = true;\n+      using mantissa_t = uint64_t;\n+      using shortest_scientific_t = ryu::floating_decimal_64;\n+\n+      static constexpr uint64_t pow10_adjustment_tab[]\n+\t= { 0b0000000000000000000000011000110101110111000001100101110000111100,\n+\t    0b0111100011110101011000011110000000110110010101011000001110011111,\n+\t    0b0101101100000000011100100100111100110110110100010001010101110000,\n+\t    0b0011110010111000101111110101100011101100010001010000000101100111,\n+\t    0b0001010000011001011100100001010000010101101000001101000000000000 };\n+    };\n+\n+#if LONG_DOUBLE_KIND == LDK_BINARY64\n+  // When long double is equivalent to double, we just forward the long double\n+  // overloads to the double overloads, so we don't need to define a a\n+  // floating_type_traits<long double> specialization in this case.\n+#elif LONG_DOUBLE_KIND == LDK_FLOAT80\n+  template<>\n+    struct floating_type_traits<long double>\n+    {\n+      static constexpr int mantissa_bits = 64;\n+      static constexpr int exponent_bits = 15;\n+      static constexpr bool has_implicit_leading_bit = false;\n+      using mantissa_t = uint64_t;\n+      using shortest_scientific_t = ryu::floating_decimal_128;\n+\n+      static constexpr uint64_t pow10_adjustment_tab[]\n+\t= { 0b0000000000000000000000000000110101011111110100010100110000011101,\n+\t    0b1001100101001111010011011111101000101111110001011001011101110000,\n+\t    0b0000101111111011110010001000001010111101011110111111010100011001,\n+\t    0b0011100000011111001101101011111001111100100010000101001111101001,\n+\t    0b0100100100000000100111010010101110011000110001101101110011001010,\n+\t    0b0111100111100010100000010011000010010110101111110101000011110100,\n+\t    0b1010100111100010011110000011011101101100010110000110101010101010,\n+\t    0b0000001111001111000000101100111011011000101000110011101100110010,\n+\t    0b0111000011100100101101010100001101111110101111001000010011111111,\n+\t    0b0010111000100110100100100010101100111010110001101010010111001000,\n+\t    0b0000100000010110000011001001000111000001111010100101101000001111,\n+\t    0b0010101011101000111100001011000010011101000101010010010000101111,\n+\t    0b1011111011101101110010101011010001111000101000101101011001100011,\n+\t    0b1010111011011011110111110011001010000010011001110100101101000101,\n+\t    0b0011000001110110011010010000011100100011001011001100001101010110,\n+\t    0b0100011111011000111111101000011110000010111110101001000000001001,\n+\t    0b1110000001110001001101101110011000100000001010000111100010111010,\n+\t    0b1110001001010011101000111000001000010100110000010110100011110000,\n+\t    0b0000011010110000110001111000011111000011001101001101001001000110,\n+\t    0b1010010111001000101001100101010110100100100010010010000101000010,\n+\t    0b1011001110000111100010100110000011100011111001110111001100000101,\n+\t    0b0110101001001000010110001000010001010101110101100001111100011001,\n+\t    0b1111100011110101011110011010101001010010100011000010110001101001,\n+\t    0b0100000100001000111101011100010011011111011001000000001100011000,\n+\t    0b1110111111000111100101110111110000000011001110011100011011011001,\n+\t    0b1100001100100000010001100011011000111011110000110011010101000011,\n+\t    0b1111111011100111011101001111111000010000001111010111110010000100,\n+\t    0b1110111001111110101111000101000000001010001110011010001000111010,\n+\t    0b1000010001011000101111111010110011111101110101101001111000111010,\n+\t    0b0100000111101001000111011001101000001010111011101001101111000100,\n+\t    0b0000011100110001000111011100111100110001101111111010110111100000,\n+\t    0b0000011101011100100110010011110101010100010011110010010111010000,\n+\t    0b0011011001100111110101111100001001101110101101001110110011110110,\n+\t    0b1011000101000001110100111001100100111100110011110000000001101000,\n+\t    0b1011100011110100001001110101010110111001000000001011101001011110,\n+\t    0b1111001010010010100000010110101010101011101000101000000000001100,\n+\t    0b1000001111100100111001110101100001010011111111000001000011110000,\n+\t    0b0001011101001000010000101101111000001110101100110011001100110111,\n+\t    0b1110011100000010101011011111001010111101111110100000011100000011,\n+\t    0b1001110110011100101010011110100010110001001110110000101011100110,\n+\t    0b1001101000100011100111010000011011100001000000110101100100001001,\n+\t    0b1010111000101000101101010111000010001100001010100011111100000100,\n+\t    0b0111101000100011000101101011111011100010001101110111001111001011,\n+\t    0b1110100111010110001110110110000000010110100011110000010001111100,\n+\t    0b1100010100011010001011001000111001010101011110100101011001000000,\n+\t    0b0000110001111001100110010110111010101101001101000000000010010101,\n+\t    0b0001110111101000001111101010110010010000111110111100000111110100,\n+\t    0b0111110111001001111000110001101101001010101110110101111110000100,\n+\t    0b0000111110111010101111100010111010011100010110011011011001000001,\n+\t    0b1010010100100100101110111111111000101100000010111111101101000110,\n+\t    0b1000100111111101100011001101000110001000000100010101010100001101,\n+\t    0b1100101010101000111100101100001000110001110010100000000010110101,\n+\t    0b1010000100111101100100101010010110100010000000110101101110000100,\n+\t    0b1011111011110001110000100100000000001010111010001101100000100100,\n+\t    0b0111101101100011001110011100000001000101101101111000100111011111,\n+\t    0b0100111010010011011001010011110100001100111010010101111111100011,\n+\t    0b0010001001011000111000001100110111110111110010100011000110110110,\n+\t    0b0101010110000000010000100000110100111011111101000100000111010010,\n+\t    0b0110000011011101000001010100110101101110011100110101000000001001,\n+\t    0b1101100110100000011000001111000100100100110001100110101010101100,\n+\t    0b0010100101010110010010001010101000011111111111001011001010001111,\n+\t    0b0111001010001111001100111001010101001000110101000011110000001000,\n+\t    0b0110010011001001001111110001010010001011010010001101110110110011,\n+\t    0b0110010100111011000100111000001001101011111001110010111110111111,\n+\t    0b0101110111001001101100110100101001110010101110011001101110001000,\n+\t    0b0100110101010111011010001100010111100011010011111001010100111000,\n+\t    0b0111000110110111011110100100010111000110000110110110110001111110,\n+\t    0b1000101101010100100100111110100011110110110010011001110011110101,\n+\t    0b1001101110101001010100111101101011000101000010110101101111110000,\n+\t    0b0100100101001011011001001011000010001101001010010001010110101000,\n+\t    0b0010100001001011100110101000010110000111000111000011100101011011,\n+\t    0b0110111000011001111101101011111010001000000010101000101010011110,\n+\t    0b1000110110100001111011000001111100001001000000010110010100100100,\n+\t    0b1001110100011111100111101011010000010101011100101000010010100110,\n+\t    0b0001010110101110100010101010001110110110100011101010001001111100,\n+\t    0b1010100101101100000010110011100110100010010000100100001110000100,\n+\t    0b0001000000010000001010000010100110000001110100111001110111101101,\n+\t    0b1100000000000000000000000000000000000000000000000000000000000000 };\n+    };\n+#elif LONG_DOUBLE_KIND == LDK_BINARY128\n+  template<>\n+    struct floating_type_traits<long double>\n+    {\n+      static constexpr int mantissa_bits = 112;\n+      static constexpr int exponent_bits = 15;\n+      static constexpr bool has_implicit_leading_bit = true;\n+      using mantissa_t = unsigned __int128;\n+      using shortest_scientific_t = ryu::floating_decimal_128;\n+\n+      static constexpr uint64_t pow10_adjustment_tab[]\n+\t= { 0b0000000000000000000000000000000000000000000000000100000010000000,\n+\t    0b1011001111110100000100010101101110011100100110000110010110011000,\n+\t    0b1010100010001101111111000000001101010010100010010000111011110111,\n+\t    0b1011111001110001111000011111000010110111000111110100101010100101,\n+\t    0b0110100110011110011011000011000010011001110001001001010011100011,\n+\t    0b0000011111110010101111101011101010000110011111100111001110100111,\n+\t    0b0100010101010110000010111011110100000010011001001010001110111101,\n+\t    0b1101110111000010001101100000110100000111001001101011000101011011,\n+\t    0b0100111011101101010000001101011000101100101110010010110000101011,\n+\t    0b0100000110111000000110101000010011101000110100010110000011101101,\n+\t    0b1011001101001000100001010001100100001111011101010101110001010110,\n+\t    0b1000000001000000101001110010110010001111101101010101001100000110,\n+\t    0b0101110110100110000110000001001010111110001110010000111111010011,\n+\t    0b1010001111100111000100011100100100111100100101000001011001000111,\n+\t    0b1010011000011100110101100111001011100101111111100001110100000100,\n+\t    0b1100011100100010100000110001001010000000100000001001010111011101,\n+\t    0b0101110000100011001111101101000000100110000010010111010001111010,\n+\t    0b0100111100011010110111101000100110000111001001101100000001111100,\n+\t    0b1100100100111110101011000100000101011010110111000111110100110101,\n+\t    0b0110010000010111010100110011000000111010000010111011010110000100,\n+\t    0b0101001001010010110111010111000101011100000111100111000001110010,\n+\t    0b1101111111001011101010110001000111011010111101001011010110100100,\n+\t    0b0001000100110000011111101011001101110010110110010000000011100100,\n+\t    0b0001000000000101001001001000000000011000100011001110101001001110,\n+\t    0b0010010010001000111010011011100001000110011011011110110100111000,\n+\t    0b0000100110101100000111100010100100011100110111011100001111001100,\n+\t    0b1011111010001110001100000011110111111111100000001011111111101100,\n+\t    0b0000011100001111010101110000100110111100101101110111101001000001,\n+\t    0b1100010001110110111100001001001101101000011100000010110101001011,\n+\t    0b0100101001101011111001011110101101100011011111011100101010101111,\n+\t    0b0001101001111001110000101101101100001011010001011110011101000010,\n+\t    0b1111000000101001101111011010110011101110100001011011001011100010,\n+\t    0b0101001010111101101100001111100010010110001101001000001101100100,\n+\t    0b0101100101011110001100101011111000111001111001001001101101100001,\n+\t    0b1111001101010010100100011011000110110010001111000111010001001101,\n+\t    0b0001110010011000000001000110110111011000011100001000011001110111,\n+\t    0b0100001011011011011011110011101100100101111111101100101000001110,\n+\t    0b0101011110111101010111100111101111000101111111111110100011011010,\n+\t    0b1110101010001001110100000010110111010111111010111110100110010110,\n+\t    0b1010001111100001001100101000110100001100011100110010000011010111,\n+\t    0b1111111101101111000100111100000101011000001110011011101010111001,\n+\t    0b1111101100001110100101111101011001000100000101110000110010100011,\n+\t    0b1001010110110101101101000101010001010000101011011111010011010000,\n+\t    0b0111001110110011101001100111000001000100001010110000010000001101,\n+\t    0b0101111100111110100111011001111001111011011110010111010011101010,\n+\t    0b1110111000000001100100111001100100110001011011001110101111110111,\n+\t    0b0001010001001101010111101010011111000011110001101101011001111111,\n+\t    0b0101000011100011010010001101100001011101011010100110101100100010,\n+\t    0b0001000101011000100101111100110110000101101101111000110001001011,\n+\t    0b0101100101001011011000010101000000010100011100101101000010011111,\n+\t    0b1000010010001011101001011010100010111011110100110011011000100111,\n+\t    0b1000011011100001010111010111010011101100100010010010100100101001,\n+\t    0b1001001001010111110101000010111010000000101111010100001010010010,\n+\t    0b0011011110110010010101111011000001000000000011011111000011111011,\n+\t    0b1011000110100011001110000001000100000001011100010111010010011110,\n+\t    0b0111101110110101110111110000011000000100011100011000101101101110,\n+\t    0b1001100101111011011100011110101011001111100111101010101010110111,\n+\t    0b1100110010010001100011001111010000000100011101001111011101001111,\n+\t    0b1000111001111010100101000010000100000001001100101010001011001101,\n+\t    0b0011101011110000110010100101010100110010100001000010101011111101,\n+\t    0b1100000000000110000010101011000000011101000110011111100010111111,\n+\t    0b0010100110000011011100010110111100010110101100110011101110001101,\n+\t    0b0010111101010011111000111001111100110111111100100011110001101110,\n+\t    0b1001110111001001101001001001011000010100110001000000100011010110,\n+\t    0b0011110101100111011011111100001000011001010100111100100101111010,\n+\t    0b0010001101000011000010100101110000010101101000100110000100001010,\n+\t    0b0010000010100110010101100101110011101111000111111111001001100001,\n+\t    0b0100111111011011011011100111111011000010011101101111011111110110,\n+\t    0b1111111111010110101011101000100101110100001110001001101011100111,\n+\t    0b1011111101000101110000111100100010111010100001010000010010110010,\n+\t    0b1111010101001011101011101010000100110110001110111100100110111111,\n+\t    0b1011001101000001001101000010101010010110010001100001011100011010,\n+\t    0b0101001011011101010001110100010000010001111100100100100001001101,\n+\t    0b0010100000111001100011000101100101000001111100111001101000000010,\n+\t    0b1011001111010101011001000100100110100100110111110100000110111000,\n+\t    0b0101011111010011100011010010111101110010100001111111100010001001,\n+\t    0b0010111011101100100000000000001111111010011101100111100001001101,\n+\t    0b1101000000000000000000000000000000000000000000000000000000000000 };\n+    };\n+#elif LONG_DOUBLE_KIND == LDK_IBM128\n+  template<>\n+    struct floating_type_traits<long double>\n+    {\n+      static constexpr int mantissa_bits = 105;\n+      static constexpr int exponent_bits = 11;\n+      static constexpr bool has_implicit_leading_bit = true;\n+      using mantissa_t = unsigned __int128;\n+      using shortest_scientific_t = ryu::floating_decimal_128;\n+\n+      static constexpr uint64_t pow10_adjustment_tab[]\n+\t= { 0b0000000000000000000000000000000000000000000000001000000100000000,\n+\t    0b0000000000000000000100000000000000000000001000000000000000000010,\n+\t    0b0000100000000000000000001001000000000000000001100100000000000000,\n+\t    0b0011000000000000000000000000000001110000010000000000000000000000,\n+\t    0b0000100000000000001000000000000000000000000000100000000000000000 };\n+    };\n+#endif\n+\n+  // An IEEE-style decomposition of a floating-point value of type T.\n+  template<typename T>\n+    struct ieee_t\n+    {\n+      typename floating_type_traits<T>::mantissa_t mantissa;\n+      uint32_t biased_exponent;\n+      bool sign;\n+    };\n+\n+  // Decompose the floating-point value into its IEEE components.\n+  template<typename T>\n+    ieee_t<T>\n+    get_ieee_repr(const T value)\n+    {\n+      constexpr int mantissa_bits = floating_type_traits<T>::mantissa_bits;\n+      constexpr int exponent_bits = floating_type_traits<T>::exponent_bits;\n+      constexpr int total_bits = mantissa_bits + exponent_bits + 1;\n+\n+      constexpr auto get_uint_t = [] {\n+\tif constexpr (total_bits <= 32)\n+\t  return uint32_t{};\n+\telse if constexpr (total_bits <= 64)\n+\t  return uint64_t{};\n+#ifdef __SIZEOF_INT128__\n+\telse if constexpr (total_bits <= 128)\n+\t  return (unsigned __int128){};\n+#endif\n+      };\n+      using uint_t = decltype(get_uint_t());\n+      uint_t value_bits = 0;\n+      memcpy(&value_bits, &value, sizeof(value));\n+\n+      ieee_t<T> ieee_repr;\n+      ieee_repr.mantissa = value_bits & ((uint_t{1} << mantissa_bits) - 1u);\n+      ieee_repr.biased_exponent\n+\t= (value_bits >> mantissa_bits) & ((uint_t{1} << exponent_bits) - 1u);\n+      ieee_repr.sign = (value_bits >> (mantissa_bits + exponent_bits)) & 1;\n+      return ieee_repr;\n+    }\n+\n+#if LONG_DOUBLE_KIND == LDK_IBM128\n+  template<>\n+    ieee_t<long double>\n+    get_ieee_repr(const long double value)\n+    {\n+      // The layout of __ibm128 isn't compatible with the standard IEEE format.\n+      // So we transform it into an IEEE-compatible format, suitable for\n+      // consumption by the generic Ryu API, with an 11-bit exponent and 105-bit\n+      // mantissa (plus an implicit leading bit).  We use the exponent and sign\n+      // of the high part, and we merge the mantissa of the high part with the\n+      // mantissa (and the implicit leading bit) of the low part.\n+      using uint_t = unsigned __int128;\n+      uint_t value_bits = 0;\n+      memcpy(&value_bits, &value, sizeof(value_bits));\n+\n+      const uint64_t value_hi = value_bits;\n+      const uint64_t value_lo = value_bits >> 64;\n+\n+      uint64_t mantissa_hi = value_hi & ((1ull << 52) - 1);\n+      unsigned exponent_hi = (value_hi >> 52) & ((1ull << 11) - 1);\n+      const int sign_hi = (value_hi >> 63) & 1;\n+\n+      uint64_t mantissa_lo = value_lo & ((1ull << 52) - 1);\n+      const unsigned exponent_lo = (value_lo >> 52) & ((1ull << 11) - 1);\n+      const int sign_lo = (value_lo >> 63) & 1;\n+\n+\t{\n+\t  // The following code for adjusting the low-part mantissa to combine\n+\t  // it with the high-part mantissa is taken from the glibc source file\n+\t  // sysdeps/ieee754/ldbl-128ibm/printf_fphex.c.\n+\t  mantissa_lo <<= 7;\n+\t  if (exponent_lo != 0)\n+\t    mantissa_lo |= (1ull << (52 + 7));\n+\t  else\n+\t    mantissa_lo <<= 1;\n+\n+\t  const int ediff = exponent_hi - exponent_lo - 53;\n+\t  if (ediff > 63)\n+\t    mantissa_lo = 0;\n+\t  else if (ediff > 0)\n+\t    mantissa_lo >>= ediff;\n+\t  else if (ediff < 0)\n+\t    mantissa_lo <<= -ediff;\n+\n+\t  if (sign_lo != sign_hi && mantissa_lo != 0)\n+\t    {\n+\t      mantissa_lo = (1ull << 60) - mantissa_lo;\n+\t      if (mantissa_hi == 0)\n+\t\t{\n+\t\t  mantissa_hi = 0xffffffffffffeLL | (mantissa_lo >> 59);\n+\t\t  mantissa_lo = 0xfffffffffffffffLL & (mantissa_lo << 1);\n+\t\t  exponent_hi--;\n+\t\t}\n+\t      else\n+\t\tmantissa_hi--;\n+\t    }\n+\t}\n+\n+      ieee_t<long double> ieee_repr;\n+      ieee_repr.mantissa = ((uint_t{mantissa_hi} << 64)\n+\t\t\t    | (uint_t{mantissa_lo} << 4)) >> 11;\n+      ieee_repr.biased_exponent = exponent_hi;\n+      ieee_repr.sign = sign_hi;\n+      return ieee_repr;\n+    }\n+#endif\n+\n+  // Invoke Ryu to obtain the shortest scientific form for the given\n+  // floating-point number.\n+  template<typename T>\n+    typename floating_type_traits<T>::shortest_scientific_t\n+    floating_to_shortest_scientific(const T value)\n+    {\n+      if constexpr (std::is_same_v<T, float>)\n+\treturn ryu::floating_to_fd32(value);\n+      else if constexpr (std::is_same_v<T, double>)\n+\treturn ryu::floating_to_fd64(value);\n+#ifdef __SIZEOF_INT128__\n+      else if constexpr (std::is_same_v<T, long double>)\n+\t{\n+\t  constexpr int mantissa_bits\n+\t    = floating_type_traits<T>::mantissa_bits;\n+\t  constexpr int exponent_bits\n+\t    = floating_type_traits<T>::exponent_bits;\n+\t  constexpr bool has_implicit_leading_bit\n+\t    = floating_type_traits<T>::has_implicit_leading_bit;\n+\n+\t  const auto [mantissa, exponent, sign] = get_ieee_repr(value);\n+\t  return ryu::generic_binary_to_decimal(mantissa, exponent, sign,\n+\t\t\t\t\t\tmantissa_bits, exponent_bits,\n+\t\t\t\t\t\t!has_implicit_leading_bit);\n+\t}\n+#endif\n+    }\n+\n+  // This subroutine returns true if the shortest scientific form fd is a\n+  // positive power of 10, and the floating-point number that has this shortest\n+  // scientific form is smaller than this power of 10.\n+  //\n+  // For instance, the exactly-representable 64-bit number\n+  // 99999999999999991611392.0 has the shortest scientific form 1e23, so its\n+  // exact value is smaller than its shortest scientific form.\n+  //\n+  // For these powers of 10 the length of the fixed form is one digit less\n+  // than what the scientific exponent suggests.\n+  //\n+  // This subroutine inspects a lookup table to detect when fd is such a\n+  // \"rounded up\" power of 10.\n+  template<typename T>\n+    bool\n+    is_rounded_up_pow10_p(const typename\n+\t\t\t  floating_type_traits<T>::shortest_scientific_t fd)\n+    {\n+      if (fd.exponent < 0 || fd.mantissa != 1) [[likely]]\n+\treturn false;\n+\n+      constexpr auto& pow10_adjustment_tab\n+\t= floating_type_traits<T>::pow10_adjustment_tab;\n+      __glibcxx_assert(fd.exponent/64 < (int)std::size(pow10_adjustment_tab));\n+      return (pow10_adjustment_tab[fd.exponent/64]\n+\t      & (1ull << (63 - fd.exponent%64)));\n+    }\n+\n+  int\n+  get_mantissa_length(const ryu::floating_decimal_32 fd)\n+  { return ryu::decimalLength9(fd.mantissa); }\n+\n+  int\n+  get_mantissa_length(const ryu::floating_decimal_64 fd)\n+  { return ryu::decimalLength17(fd.mantissa); }\n+\n+#ifdef __SIZEOF_INT128__\n+  int\n+  get_mantissa_length(const ryu::floating_decimal_128 fd)\n+  { return ryu::generic128::decimalLength(fd.mantissa); }\n+#endif\n+} // anon namespace\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+// This subroutine of __floating_to_chars_* handles writing nan, inf and 0 in\n+// all formatting modes.\n+template<typename T>\n+  static optional<to_chars_result>\n+  __handle_special_value(char* first, char* const last, const T value,\n+\t\t\t const chars_format fmt, const int precision)\n+  {\n+    __glibcxx_assert(precision >= 0);\n+\n+    string_view str;\n+    switch (__builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL,\n+\t\t\t\t FP_ZERO, value))\n+      {\n+      case FP_INFINITE:\n+\tstr = \"-inf\";\n+\tbreak;\n+\n+      case FP_NAN:\n+\tstr = \"-nan\";\n+\tbreak;\n+\n+      case FP_ZERO:\n+\tbreak;\n+\n+      default:\n+      case FP_SUBNORMAL:\n+      case FP_NORMAL: [[likely]]\n+\treturn nullopt;\n+      }\n+\n+    if (!str.empty())\n+      {\n+\t// We're formatting +-inf or +-nan.\n+\tif (!__builtin_signbit(value))\n+\t  str.remove_prefix(strlen(\"-\"));\n+\n+\tif (last - first < (int)str.length())\n+\t  return {{last, errc::value_too_large}};\n+\n+\tmemcpy(first, &str[0], str.length());\n+\tfirst += str.length();\n+\treturn {{first, errc{}}};\n+      }\n+\n+    // We're formatting 0.\n+    __glibcxx_assert(value == 0);\n+    const auto orig_first = first;\n+    const bool sign = __builtin_signbit(value);\n+    int expected_output_length;\n+    switch (fmt)\n+      {\n+      case chars_format::fixed:\n+      case chars_format::scientific:\n+      case chars_format::hex:\n+\texpected_output_length = sign + 1;\n+\tif (precision)\n+\t  expected_output_length += strlen(\".\") + precision;\n+\tif (fmt == chars_format::scientific)\n+\t  expected_output_length += strlen(\"e+00\");\n+\telse if (fmt == chars_format::hex)\n+\t  expected_output_length += strlen(\"p+0\");\n+\tif (last - first < expected_output_length)\n+\t  return {{last, errc::value_too_large}};\n+\n+\tif (sign)\n+\t  *first++ = '-';\n+\t*first++ = '0';\n+\tif (precision)\n+\t  {\n+\t    *first++ = '.';\n+\t    memset(first, '0', precision);\n+\t    first += precision;\n+\t  }\n+\tif (fmt == chars_format::scientific)\n+\t  {\n+\t    memcpy(first, \"e+00\", 4);\n+\t    first += 4;\n+\t  }\n+\telse if (fmt == chars_format::hex)\n+\t  {\n+\t    memcpy(first, \"p+0\", 3);\n+\t    first += 3;\n+\t  }\n+\tbreak;\n+\n+      case chars_format::general:\n+      default: // case chars_format{}:\n+\texpected_output_length = sign + 1;\n+\tif (last - first < expected_output_length)\n+\t  return {{last, errc::value_too_large}};\n+\n+\tif (sign)\n+\t  *first++ = '-';\n+\t*first++ = '0';\n+\tbreak;\n+      }\n+    __glibcxx_assert(first - orig_first == expected_output_length);\n+    return {{first, errc{}}};\n+  }\n+\n+// This subroutine of the floating-point to_chars overloads performs\n+// hexadecimal formatting.\n+template<typename T>\n+  static to_chars_result\n+  __floating_to_chars_hex(char* first, char* const last, const T value,\n+\t\t\t  const optional<int> precision)\n+  {\n+    if (precision.has_value() && precision.value() < 0) [[unlikely]]\n+      // A negative precision argument is treated as if it were omitted.\n+      return __floating_to_chars_hex(first, last, value, nullopt);\n+\n+    __glibcxx_requires_valid_range(first, last);\n+\n+    constexpr int mantissa_bits = floating_type_traits<T>::mantissa_bits;\n+    constexpr bool has_implicit_leading_bit\n+      = floating_type_traits<T>::has_implicit_leading_bit;\n+    constexpr int exponent_bits = floating_type_traits<T>::exponent_bits;\n+    constexpr int exponent_bias = (1u << (exponent_bits - 1)) - 1;\n+    using mantissa_t = typename floating_type_traits<T>::mantissa_t;\n+    constexpr int mantissa_t_width = sizeof(mantissa_t) * __CHAR_BIT__;\n+\n+    if (auto result = __handle_special_value(first, last, value,\n+\t\t\t\t\t     chars_format::hex,\n+\t\t\t\t\t     precision.value_or(0)))\n+      return *result;\n+\n+    // Extract the sign, mantissa and exponent from the value.\n+    const auto [ieee_mantissa, biased_exponent, sign] = get_ieee_repr(value);\n+    const bool is_normal_number = (biased_exponent != 0);\n+\n+    // Calculate the unbiased exponent.\n+    const int32_t unbiased_exponent = (is_normal_number\n+\t\t\t\t       ? biased_exponent - exponent_bias\n+\t\t\t\t       : 1 - exponent_bias);\n+\n+    // Shift the mantissa so that its bitwidth is a multiple of 4.\n+    constexpr unsigned rounded_mantissa_bits = (mantissa_bits + 3) / 4 * 4;\n+    static_assert(mantissa_t_width >= rounded_mantissa_bits);\n+    mantissa_t effective_mantissa\n+      = ieee_mantissa << (rounded_mantissa_bits - mantissa_bits);\n+    if (is_normal_number)\n+      {\n+\tif constexpr (has_implicit_leading_bit)\n+\t  // Restore the mantissa's implicit leading bit.\n+\t  effective_mantissa |= mantissa_t{1} << rounded_mantissa_bits;\n+\telse\n+\t  // The explicit mantissa bit should already be set.\n+\t  __glibcxx_assert(effective_mantissa & (mantissa_t{1} << (mantissa_bits\n+\t\t\t\t\t\t\t\t   - 1u)));\n+      }\n+\n+    // Compute the shortest precision needed to print this value exactly,\n+    // disregarding trailing zeros.\n+    constexpr int full_hex_precision = (has_implicit_leading_bit\n+\t\t\t\t\t? (mantissa_bits + 3) / 4\n+\t\t\t\t\t// With an explicit leading bit, we\n+\t\t\t\t\t// use the four leading nibbles as the\n+\t\t\t\t\t// hexit before the decimal point.\n+\t\t\t\t\t: (mantissa_bits - 4 + 3) / 4);\n+    const int trailing_zeros = __countr_zero(effective_mantissa) / 4;\n+    const int shortest_full_precision = full_hex_precision - trailing_zeros;\n+    __glibcxx_assert(shortest_full_precision >= 0);\n+\n+    int written_exponent = unbiased_exponent;\n+    const int effective_precision = precision.value_or(shortest_full_precision);\n+    if (effective_precision < shortest_full_precision)\n+      {\n+\t// When limiting the precision, we need to determine how to round the\n+\t// least significant printed hexit.  The following branchless\n+\t// bit-level-parallel technique computes whether to round up the\n+\t// mantissa bit at index N (according to round-to-nearest rules) when\n+\t// dropping N bits of precision, for each index N in the bit vector.\n+\t// This technique is borrowed from the MSVC implementation.\n+\tusing bitvec = mantissa_t;\n+\tconst bitvec round_bit = effective_mantissa << 1;\n+\tconst bitvec has_tail_bits = round_bit - 1;\n+\tconst bitvec lsb_bit = effective_mantissa;\n+\tconst bitvec should_round = round_bit & (has_tail_bits | lsb_bit);\n+\n+\tconst int dropped_bits = 4*(full_hex_precision - effective_precision);\n+\t// Mask out the dropped nibbles.\n+\teffective_mantissa >>= dropped_bits;\n+\teffective_mantissa <<= dropped_bits;\n+\tif (should_round & (mantissa_t{1} << dropped_bits))\n+\t  {\n+\t    // Round up the least significant nibble.\n+\t    effective_mantissa += mantissa_t{1} << dropped_bits;\n+\t    // Check and adjust for overflow of the leading nibble.  When the\n+\t    // type has an implicit leading bit, then the leading nibble\n+\t    // before rounding is either 0 or 1, so it can't overflow.\n+\t    if constexpr (!has_implicit_leading_bit)\n+\t      {\n+\t\t// The only supported floating-point type with explicit\n+\t\t// leading mantissa bit is LDK_FLOAT80, i.e. x86 80-bit\n+\t\t// extended precision, and so we hardcode the below overflow\n+\t\t// check+adjustment for this type.\n+\t\tstatic_assert(mantissa_t_width == 64\n+\t\t\t      && rounded_mantissa_bits == 64);\n+\t\tif (effective_mantissa == 0)\n+\t\t  {\n+\t\t    // We rounded up the least significant nibble and the\n+\t\t    // mantissa overflowed, e.g f.fcp+10 with precision=1\n+\t\t    // became 10.0p+10.  Absorb this extra hexit into the\n+\t\t    // exponent to obtain 1.0p+14.\n+\t\t    effective_mantissa\n+\t\t      = mantissa_t{1} << (rounded_mantissa_bits - 4);\n+\t\t    written_exponent += 4;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // Compute the leading hexit and mask it out from the mantissa.\n+    char leading_hexit;\n+    if constexpr (has_implicit_leading_bit)\n+      {\n+\tconst unsigned nibble = effective_mantissa >> rounded_mantissa_bits;\n+\t__glibcxx_assert(nibble <= 2);\n+\tleading_hexit = '0' + nibble;\n+\teffective_mantissa &= ~(mantissa_t{0b11} << rounded_mantissa_bits);\n+      }\n+    else\n+      {\n+\tconst unsigned nibble = effective_mantissa >> (rounded_mantissa_bits-4);\n+\t__glibcxx_assert(nibble < 16);\n+\tleading_hexit = \"0123456789abcdef\"[nibble];\n+\teffective_mantissa &= ~(mantissa_t{0b1111} << (rounded_mantissa_bits-4));\n+\twritten_exponent -= 3;\n+      }\n+\n+    // Now before we start writing the string, determine the total length of\n+    // the output string and perform a single bounds check.\n+    int expected_output_length = sign + 1;\n+    if (effective_precision != 0)\n+      expected_output_length += strlen(\".\") + effective_precision;\n+    const int abs_written_exponent = abs(written_exponent);\n+    expected_output_length += (abs_written_exponent >= 10000 ? strlen(\"p+ddddd\")\n+\t\t\t       : abs_written_exponent >= 1000 ? strlen(\"p+dddd\")\n+\t\t\t       : abs_written_exponent >= 100 ? strlen(\"p+ddd\")\n+\t\t\t       : abs_written_exponent >= 10 ? strlen(\"p+dd\")\n+\t\t\t       : strlen(\"p+d\"));\n+    if (last - first < expected_output_length)\n+      return {last, errc::value_too_large};\n+\n+    const auto saved_first = first;\n+    // Write the negative sign and the leading hexit.\n+    if (sign)\n+      *first++ = '-';\n+    *first++ = leading_hexit;\n+\n+    if (effective_precision > 0)\n+      {\n+\t*first++ = '.';\n+\tint written_hexits = 0;\n+\t// Extract and mask out the leading nibble after the decimal point,\n+\t// write its corresponding hexit, and repeat until the mantissa is\n+\t// empty.\n+\tint nibble_offset = rounded_mantissa_bits;\n+\tif constexpr (!has_implicit_leading_bit)\n+\t  // We already printed the entire leading hexit.\n+\t  nibble_offset -= 4;\n+\twhile (effective_mantissa != 0)\n+\t  {\n+\t    nibble_offset -= 4;\n+\t    const unsigned nibble = effective_mantissa >> nibble_offset;\n+\t    __glibcxx_assert(nibble < 16);\n+\t    *first++ = \"0123456789abcdef\"[nibble];\n+\t    ++written_hexits;\n+\t     effective_mantissa &= ~(mantissa_t{0b1111} << nibble_offset);\n+\t  }\n+\t__glibcxx_assert(nibble_offset >= 0);\n+\t__glibcxx_assert(written_hexits <= effective_precision);\n+\t// Since the mantissa is now empty, every hexit hereafter must be '0'.\n+\tif (int remaining_hexits = effective_precision - written_hexits)\n+\t  {\n+\t    memset(first, '0', remaining_hexits);\n+\t    first += remaining_hexits;\n+\t  }\n+      }\n+\n+    // Finally, write the exponent.\n+    *first++ = 'p';\n+    if (written_exponent >= 0)\n+      *first++ = '+';\n+    const to_chars_result result = to_chars(first, last, written_exponent);\n+    __glibcxx_assert(result.ec == errc{}\n+\t\t     && result.ptr == saved_first + expected_output_length);\n+    return result;\n+  }\n+\n+template<typename T>\n+  static to_chars_result\n+  __floating_to_chars_shortest(char* first, char* const last, const T value,\n+\t\t\t       chars_format fmt)\n+  {\n+    if (fmt == chars_format::hex)\n+      return __floating_to_chars_hex(first, last, value, nullopt);\n+\n+    __glibcxx_assert(fmt == chars_format::fixed\n+\t\t     || fmt == chars_format::scientific\n+\t\t     || fmt == chars_format::general\n+\t\t     || fmt == chars_format{});\n+    __glibcxx_requires_valid_range(first, last);\n+\n+    if (auto result = __handle_special_value(first, last, value, fmt, 0))\n+      return *result;\n+\n+    const auto fd = floating_to_shortest_scientific(value);\n+    const int mantissa_length = get_mantissa_length(fd);\n+    const int scientific_exponent = fd.exponent + mantissa_length - 1;\n+\n+    if (fmt == chars_format::general)\n+      {\n+\t// Resolve the 'general' formatting mode as per the specification of\n+\t// the 'g' printf output specifier.  Since there is no precision\n+\t// argument, the default precision of the 'g' specifier, 6, applies.\n+\tif (scientific_exponent >= -4 && scientific_exponent < 6)\n+\t  fmt = chars_format::fixed;\n+\telse\n+\t  fmt = chars_format::scientific;\n+      }\n+    else if (fmt == chars_format{})\n+      {\n+\t// The 'plain' formatting mode resolves to 'scientific' if it yields\n+\t// the shorter string, and resolves to 'fixed' otherwise.  The\n+\t// following lower and upper bounds on the exponent characterize when\n+\t// to prefer 'fixed' over 'scientific'.\n+\tint lower_bound = -(mantissa_length + 3);\n+\tint upper_bound = 5;\n+\tif (mantissa_length == 1)\n+\t  // The decimal point in scientific notation will be omitted in this\n+\t  // case; tighten the bounds appropriately.\n+\t  ++lower_bound, --upper_bound;\n+\n+\tif (fd.exponent >= lower_bound && fd.exponent <= upper_bound)\n+\t  fmt = chars_format::fixed;\n+\telse\n+\t  fmt = chars_format::scientific;\n+      }\n+\n+    if (fmt == chars_format::scientific)\n+      {\n+\t// Calculate the total length of the output string, perform a bounds\n+\t// check, and then defer to Ryu's to_chars subroutine.\n+\tint expected_output_length = fd.sign + mantissa_length;\n+\tif (mantissa_length > 1)\n+\t  expected_output_length += strlen(\".\");\n+\tconst int abs_exponent = abs(scientific_exponent);\n+\texpected_output_length += (abs_exponent >= 1000 ? strlen(\"e+dddd\")\n+\t\t\t\t   : abs_exponent >= 100 ? strlen(\"e+ddd\")\n+\t\t\t\t   : strlen(\"e+dd\"));\n+\tif (last - first < expected_output_length)\n+\t  return {last, errc::value_too_large};\n+\n+\tconst int output_length = ryu::to_chars(fd, first);\n+\t__glibcxx_assert(output_length == expected_output_length);\n+\treturn {first + output_length, errc{}};\n+      }\n+    else if (fmt == chars_format::fixed && fd.exponent >= 0)\n+      {\n+\t// The Ryu exponent is positive, and so this number's shortest\n+\t// representation is a whole number, to be formatted in fixed instead\n+\t// of scientific notation \"as if by std::printf\".  This means we may\n+\t// need to print more digits of the IEEE mantissa than what the\n+\t// shortest scientific form given by Ryu provides.\n+\t//\n+\t// For instance, the exactly representable number\n+\t// 12300000000000001048576.0 has as its shortest scientific\n+\t// representation 123e+22, so in this case fd.mantissa is 123 and\n+\t// fd.exponent is 22, which doesn't have enough information to format\n+\t// the number exactly.  So we defer to Ryu's d2fixed_buffered_n with\n+\t// precision=0 to format the number in the general case here.\n+\n+\t// To that end, first compute the output length and perform a bounds\n+\t// check.\n+\tint expected_output_length = fd.sign + mantissa_length + fd.exponent;\n+\tif (is_rounded_up_pow10_p<T>(fd))\n+\t  --expected_output_length;\n+\tif (last - first < expected_output_length)\n+\t  return {last, errc::value_too_large};\n+\n+\t// Optimization: if the shortest representation fits inside the IEEE\n+\t// mantissa, then the number is certainly exactly-representable and\n+\t// its shortest scientific form must be equal to its exact form.  So\n+\t// we can write the value in fixed form exactly via fd.mantissa and\n+\t// fd.exponent.\n+\t//\n+\t// Taking log2 of both sides of the desired condition\n+\t//   fd.mantissa * 10^fd.exponent < 2^mantissa_bits\n+\t// we get\n+\t//   log2 fd.mantissa + fd.exponent * log2 10 < mantissa_bits\n+\t// where log2 10 is slightly smaller than 10/3=3.333...\n+\t//\n+\t// After adding some wiggle room due to rounding we get the condition\n+\t// value_fits_inside_mantissa_p below.\n+\tconst int log2_mantissa = __bit_width(fd.mantissa) - 1;\n+\tconst bool value_fits_inside_mantissa_p\n+\t  = (log2_mantissa + (fd.exponent*10 + 2) / 3\n+\t     < floating_type_traits<T>::mantissa_bits - 2);\n+\tif (value_fits_inside_mantissa_p)\n+\t  {\n+\t    // Print the small exactly-represantable number in fixed form by\n+\t    // writing out fd.mantissa followed by fd.exponent many 0s.\n+\t    if (fd.sign)\n+\t      *first++ = '-';\n+\t    to_chars_result result = to_chars(first, last, fd.mantissa);\n+\t    __glibcxx_assert(result.ec == errc{});\n+\t    memset(result.ptr, '0', fd.exponent);\n+\t    result.ptr += fd.exponent;\n+\t    const int output_length = fd.sign + (result.ptr - first);\n+\t    __glibcxx_assert(output_length == expected_output_length);\n+\t    return result;\n+\t  }\n+\telse if constexpr (is_same_v<T, long double>)\n+\t  {\n+\t    // We can't use d2fixed_buffered_n for types larger than double,\n+\t    // so we instead format larger types through sprintf.\n+\t    // TODO: We currently go through an intermediate buffer in order\n+\t    // to accomodate the mandatory null terminator of sprintf, but we\n+\t    // can avoid this if we use sprintf to write all but the last\n+\t    // digit, and carefully compute and write the last digit\n+\t    // ourselves.\n+\t    char buffer[expected_output_length+1];\n+#if _GLIBCXX_USE_C99_FENV_TR1\n+\t    const int saved_rounding_mode = fegetround();\n+\t    if (saved_rounding_mode != FE_TONEAREST)\n+\t      fesetround(FE_TONEAREST); // We want round-to-nearest behavior.\n+#endif\n+\t    const int output_length = sprintf(buffer, \"%.0Lf\", value);\n+#if _GLIBCXX_USE_C99_FENV_TR1\n+\t    if (saved_rounding_mode != FE_TONEAREST)\n+\t      fesetround(saved_rounding_mode);\n+#endif\n+\t    __glibcxx_assert(output_length == expected_output_length);\n+\t    memcpy(first, buffer, output_length);\n+\t    return {first + output_length, errc{}};\n+\t  }\n+\telse\n+\t  {\n+\t    // Otherwise, the number is too big, so defer to d2fixed_buffered_n.\n+\t    const int output_length = ryu::d2fixed_buffered_n(value, 0, first);\n+\t    __glibcxx_assert(output_length == expected_output_length);\n+\t    return {first + output_length, errc{}};\n+\t  }\n+      }\n+    else if (fmt == chars_format::fixed && fd.exponent < 0)\n+      {\n+\t// The Ryu exponent is negative, so fd.mantissa definitely contains\n+\t// all of the whole part of the number, and therefore fd.mantissa and\n+\t// fd.exponent contain all of the information needed to format the\n+\t// number in fixed notation \"as if by std::printf\" (with precision\n+\t// equal to -fd.exponent).\n+\tconst int whole_digits = max(mantissa_length + fd.exponent, 1);\n+\tconst int expected_output_length\n+\t  = fd.sign + whole_digits + strlen(\".\") + -fd.exponent;\n+\tif (last - first < expected_output_length)\n+\t  return {last, errc::value_too_large};\n+\tif (mantissa_length <= -fd.exponent)\n+\t  {\n+\t    // The magnitude of the number is less than one.  Format the\n+\t    // number appropriately.\n+\t    const auto orig_first = first;\n+\t    if (fd.sign)\n+\t      *first++ = '-';\n+\t    *first++ = '0';\n+\t    *first++ = '.';\n+\t    const int leading_zeros = -fd.exponent - mantissa_length;\n+\t    memset(first, '0', leading_zeros);\n+\t    first += leading_zeros;\n+\t    const to_chars_result result = to_chars(first, last, fd.mantissa);\n+\t    const int output_length = result.ptr - orig_first;\n+\t    __glibcxx_assert(output_length == expected_output_length\n+\t\t\t     && result.ec == errc{});\n+\t    return result;\n+\t  }\n+\telse\n+\t  {\n+\t    // The magnitude of the number is at least one.\n+\t    const auto orig_first = first;\n+\t    if (fd.sign)\n+\t      *first++ = '-';\n+\t    to_chars_result result = to_chars(first, last, fd.mantissa);\n+\t    __glibcxx_assert(result.ec == errc{});\n+\t    // Make space for and write the decimal point in the correct spot.\n+\t    memmove(&result.ptr[fd.exponent+1], &result.ptr[fd.exponent],\n+\t\t    -fd.exponent);\n+\t    result.ptr[fd.exponent] = '.';\n+\t    const int output_length = result.ptr + 1 - orig_first;\n+\t    __glibcxx_assert(output_length == expected_output_length);\n+\t    ++result.ptr;\n+\t    return result;\n+\t  }\n+      }\n+\n+    __glibcxx_assert(false);\n+  }\n+\n+template<typename T>\n+  static to_chars_result\n+  __floating_to_chars_precision(char* first, char* const last, const T value,\n+\t\t\t\tchars_format fmt, const int precision)\n+  {\n+    if (fmt == chars_format::hex)\n+      return __floating_to_chars_hex(first, last, value, precision);\n+\n+    if (precision < 0) [[unlikely]]\n+      // A negative precision argument is treated as if it were omitted, in\n+      // which case the default precision of 6 applies, as per the printf\n+      // specification.\n+      return __floating_to_chars_precision(first, last, value, fmt, 6);\n+\n+    __glibcxx_assert(fmt == chars_format::fixed\n+\t\t     || fmt == chars_format::scientific\n+\t\t     || fmt == chars_format::general);\n+    __glibcxx_requires_valid_range(first, last);\n+\n+    if (auto result = __handle_special_value(first, last, value,\n+\t\t\t\t\t     fmt, precision))\n+      return *result;\n+\n+    constexpr int mantissa_bits = floating_type_traits<T>::mantissa_bits;\n+    constexpr int exponent_bits = floating_type_traits<T>::exponent_bits;\n+    constexpr int exponent_bias = (1u << (exponent_bits - 1)) - 1;\n+\n+    // Extract the sign and exponent from the value.\n+    const auto [mantissa, biased_exponent, sign] = get_ieee_repr(value);\n+    const bool is_normal_number = (biased_exponent != 0);\n+\n+    // Calculate the unbiased exponent.\n+    const int32_t unbiased_exponent = (is_normal_number\n+\t\t\t\t       ? biased_exponent - exponent_bias\n+\t\t\t\t       : 1 - exponent_bias);\n+\n+    // Obtain trunc(log2(abs(value))), which is just the unbiased exponent.\n+    const int floor_log2_value = unbiased_exponent;\n+    // This is within +-1 of log10(abs(value)).  Note that log10 2 is 0.3010..\n+    const int approx_log10_value = (floor_log2_value >= 0\n+\t\t\t\t    ? (floor_log2_value*301 + 999)/1000\n+\t\t\t\t    : (floor_log2_value*301 - 999)/1000);\n+\n+    // Compute (an upper bound of) the number's effective precision when it is\n+    // formatted in scientific and fixed notation.  Beyond this precision all\n+    // digits are definitely zero, and this fact allows us to bound the sizes\n+    // of any local output buffers that we may need to use.  TODO: Consider\n+    // the number of trailing zero bits in the mantissa to obtain finer upper\n+    // bounds.\n+    // ???: Using \"mantissa_bits + 1\" instead of just \"mantissa_bits\" in the\n+    // bounds below is necessary only for __ibm128, it seems.  Even though the\n+    // type has 105 bits of precision, printf may output 106 fractional digits\n+    // on some inputs, e.g. 0x1.bcd19f5d720d12a3513e3301028p+0.\n+    const int max_eff_scientific_precision\n+      = (floor_log2_value >= 0\n+\t ? max(mantissa_bits + 1, approx_log10_value + 1)\n+\t : -(7*floor_log2_value + 9)/10 + 2 + mantissa_bits + 1);\n+    __glibcxx_assert(max_eff_scientific_precision > 0);\n+\n+    const int max_eff_fixed_precision\n+      = (floor_log2_value >= 0\n+\t ? mantissa_bits + 1\n+\t : -floor_log2_value + mantissa_bits + 1);\n+    __glibcxx_assert(max_eff_fixed_precision > 0);\n+\n+    // Ryu doesn't support formatting floating-point types larger than double\n+    // with an explicit precision, so instead we just go through printf.\n+    if constexpr (is_same_v<T, long double>)\n+      {\n+\tint effective_precision;\n+\tconst char* output_specifier;\n+\tif (fmt == chars_format::scientific)\n+\t  {\n+\t    effective_precision = min(precision, max_eff_scientific_precision);\n+\t    output_specifier = \"%.*Le\";\n+\t  }\n+\telse if (fmt == chars_format::fixed)\n+\t  {\n+\t    effective_precision = min(precision, max_eff_fixed_precision);\n+\t    output_specifier = \"%.*Lf\";\n+\t  }\n+\telse if (fmt == chars_format::general)\n+\t  {\n+\t    effective_precision = min(precision, max_eff_scientific_precision);\n+\t    output_specifier = \"%.*Lg\";\n+\t  }\n+\tconst int excess_precision = (fmt != chars_format::general\n+\t\t\t\t      ? precision - effective_precision : 0);\n+\n+\t// Since the output of printf is locale-sensitive, we need to be able\n+\t// to handle a radix point that's different from '.'.\n+\tchar radix[6] = {'.', '\\0', '\\0', '\\0', '\\0', '\\0'};\n+\tif (effective_precision > 0)\n+\t  // ???: Can nl_langinfo() ever return null?\n+\t  if (const char* const radix_ptr = nl_langinfo(RADIXCHAR))\n+\t    {\n+\t      strncpy(radix, radix_ptr, sizeof(radix)-1);\n+\t      // We accept only radix points which are at most 4 bytes (one\n+\t      // UTF-8 character) wide.\n+\t      __glibcxx_assert(radix[4] == '\\0');\n+\t    }\n+\n+\t// Compute straightforward upper bounds on the output length.\n+\tint output_length_upper_bound;\n+\tif (fmt == chars_format::scientific || fmt == chars_format::general)\n+\t  output_length_upper_bound = (strlen(\"-d\") + sizeof(radix)\n+\t\t\t\t       + effective_precision\n+\t\t\t\t       + strlen(\"e+dddd\"));\n+\telse if (fmt == chars_format::fixed)\n+\t  {\n+\t    if (approx_log10_value >= 0)\n+\t      output_length_upper_bound = sign + approx_log10_value + 1;\n+\t    else\n+\t      output_length_upper_bound = sign + strlen(\"0\");\n+\t    output_length_upper_bound += sizeof(radix) + effective_precision;\n+\t  }\n+\n+\t// Do the sprintf into the local buffer.\n+\tchar buffer[output_length_upper_bound+1];\n+#if _GLIBCXX_USE_C99_FENV_TR1\n+\tconst int saved_rounding_mode = fegetround();\n+\tif (saved_rounding_mode != FE_TONEAREST)\n+\t  fesetround(FE_TONEAREST); // We want round-to-nearest behavior.\n+#endif\n+\tint output_length\n+\t  = sprintf(buffer, output_specifier, effective_precision, value);\n+#if _GLIBCXX_USE_C99_FENV_TR1\n+\tif (saved_rounding_mode != FE_TONEAREST)\n+\t  fesetround(saved_rounding_mode);\n+#endif\n+\t__glibcxx_assert(output_length <= output_length_upper_bound);\n+\n+\tif (effective_precision > 0)\n+\t  // We need to replace a radix that is different from '.' with '.'.\n+\t  if (const string_view radix_sv = {radix}; radix_sv != \".\")\n+\t    {\n+\t      const string_view buffer_sv = {buffer, (size_t)output_length};\n+\t      const size_t radix_index = buffer_sv.find(radix_sv);\n+\t      if (radix_index != string_view::npos)\n+\t\t{\n+\t\t  buffer[radix_index] = '.';\n+\t\t  if (radix_sv.length() > 1)\n+\t\t    {\n+\t\t      memmove(&buffer[radix_index + 1],\n+\t\t\t      &buffer[radix_index + radix_sv.length()],\n+\t\t\t      output_length - radix_index - radix_sv.length());\n+\t\t      output_length -= radix_sv.length() - 1;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t// Copy the string from the buffer over to the output range.\n+\tif (last - first < output_length + excess_precision)\n+\t  return {last, errc::value_too_large};\n+\tmemcpy(first, buffer, output_length);\n+\tfirst += output_length;\n+\n+\t// Add the excess 0s to the result.\n+\tif (excess_precision > 0)\n+\t  {\n+\t    if (fmt == chars_format::scientific)\n+\t      {\n+\t\tchar* const significand_end\n+\t\t  = (output_length >= 6 && first[-6] == 'e' ? &first[-6]\n+\t\t     : first[-5] == 'e' ? &first[-5]\n+\t\t     : &first[-4]);\n+\t\t__glibcxx_assert(*significand_end == 'e');\n+\t\t  memmove(significand_end + excess_precision, significand_end,\n+\t\t\t  first - significand_end);\n+\t\t  memset(significand_end, '0', excess_precision);\n+\t\t  first += excess_precision;\n+\t      }\n+\t    else if (fmt == chars_format::fixed)\n+\t      {\n+\t\tmemset(first, '0', excess_precision);\n+\t\tfirst += excess_precision;\n+\t      }\n+\t  }\n+\treturn {first, errc{}};\n+      }\n+    else if (fmt == chars_format::scientific)\n+      {\n+\tconst int effective_precision\n+\t  = min(precision, max_eff_scientific_precision);\n+\tconst int excess_precision = precision - effective_precision;\n+\n+\t// We can easily compute the output length exactly whenever the\n+\t// scientific exponent is far enough away from +-100.  But if it's\n+\t// near +-100, then our log2 approximation is too coarse (and doesn't\n+\t// consider precision-dependent rounding) in order to accurately\n+\t// distinguish between a scientific exponent of +-100 and +-99.\n+\tconst bool scientific_exponent_near_100_p\n+\t  = abs(abs(floor_log2_value) - 332) <= 4;\n+\n+\t// Compute an upper bound on the output length.  TODO: Maybe also\n+\t// consider a lower bound on the output length.\n+\tint output_length_upper_bound = sign + strlen(\"d\");\n+\tif (effective_precision > 0)\n+\t  output_length_upper_bound += strlen(\".\") + effective_precision;\n+\tif (scientific_exponent_near_100_p\n+\t    || (floor_log2_value >= 332 || floor_log2_value <= -333))\n+\t  output_length_upper_bound += strlen(\"e+ddd\");\n+\telse\n+\t  output_length_upper_bound += strlen(\"e+dd\");\n+\n+\tint output_length;\n+\tif (last - first >= output_length_upper_bound + excess_precision)\n+\t  {\n+\t    // The result will definitely fit into the output range, so we can\n+\t    // write directly into it.\n+\t    output_length = ryu::d2exp_buffered_n(value, effective_precision,\n+\t\t\t\t\t\t  first, nullptr);\n+\t    __glibcxx_assert(output_length == output_length_upper_bound\n+\t\t\t     || (scientific_exponent_near_100_p\n+\t\t\t\t && (output_length\n+\t\t\t\t     == output_length_upper_bound - 1)));\n+\t  }\n+\telse if (scientific_exponent_near_100_p)\n+\t  {\n+\t    // Write the result of d2exp_buffered_n into an intermediate\n+\t    // buffer, do a bounds check, and copy the result into the output\n+\t    // range.\n+\t    char buffer[output_length_upper_bound];\n+\t    output_length = ryu::d2exp_buffered_n(value, effective_precision,\n+\t\t\t\t\t\t  buffer, nullptr);\n+\t    __glibcxx_assert(output_length == output_length_upper_bound - 1\n+\t\t\t     || output_length == output_length_upper_bound);\n+\t    if (last - first < output_length + excess_precision)\n+\t      return {last, errc::value_too_large};\n+\t    memcpy(first, buffer, output_length);\n+\t  }\n+\telse\n+\t  // If the scientific exponent is not near 100, then the upper bound\n+\t  // is actually the exact length, and so the result will definitely\n+\t  // not fit into the output range.\n+\t  return {last, errc::value_too_large};\n+\tfirst += output_length;\n+\tif (excess_precision > 0)\n+\t  {\n+\t    // Splice the excess zeros into the result.\n+\t    char* const significand_end = (first[-5] == 'e'\n+\t\t\t\t\t   ? &first[-5] : &first[-4]);\n+\t    __glibcxx_assert(*significand_end == 'e');\n+\t    memmove(significand_end + excess_precision, significand_end,\n+\t\t    first - significand_end);\n+\t    memset(significand_end, '0', excess_precision);\n+\t    first += excess_precision;\n+\t  }\n+\treturn {first, errc{}};\n+      }\n+    else if (fmt == chars_format::fixed)\n+      {\n+\tconst int effective_precision\n+\t  = min(precision, max_eff_fixed_precision);\n+\tconst int excess_precision = precision - effective_precision;\n+\n+\t// Compute an upper bound on the output length.  TODO: Maybe also\n+\t// consider a lower bound on the output length.\n+\tint output_length_upper_bound;\n+\tif (approx_log10_value >= 0)\n+\t  output_length_upper_bound = sign + approx_log10_value + 1;\n+\telse\n+\t  output_length_upper_bound = sign + strlen(\"0\");\n+\tif (effective_precision > 0)\n+\t  output_length_upper_bound += strlen(\".\") + effective_precision;\n+\n+\tint output_length;\n+\tif (last - first >= output_length_upper_bound + excess_precision)\n+\t  {\n+\t    // The result will definitely fit into the output range, so we can\n+\t    // write directly into it.\n+\t    output_length = ryu::d2fixed_buffered_n(value, effective_precision,\n+\t\t\t\t\t\t    first);\n+\t    __glibcxx_assert(output_length <= output_length_upper_bound);\n+\t  }\n+\telse\n+\t  {\n+\t    // Write the result of d2fixed_buffered_n into an intermediate\n+\t    // buffer, do a bounds check, and copy the result into the output\n+\t    // range.\n+\t    char buffer[output_length_upper_bound];\n+\t    output_length = ryu::d2fixed_buffered_n(value, effective_precision,\n+\t\t\t\t\t\t    buffer);\n+\t    __glibcxx_assert(output_length <= output_length_upper_bound);\n+\t    if (last - first < output_length + excess_precision)\n+\t      return {last, errc::value_too_large};\n+\t    memcpy(first, buffer, output_length);\n+\t  }\n+\tfirst += output_length;\n+\tif (excess_precision > 0)\n+\t  {\n+\t    // Append the excess zeros into the result.\n+\t    memset(first, '0', excess_precision);\n+\t    first += excess_precision;\n+\t  }\n+\treturn {first, errc{}};\n+      }\n+    else if (fmt == chars_format::general)\n+      {\n+\t// Handle the 'general' formatting mode as per C11 printf's %g output\n+\t// specifier.  Since Ryu doesn't do zero-trimming, we always write to\n+\t// an intermediate buffer and manually perform zero-trimming there\n+\t// before copying the result over to the output range.\n+\tint effective_precision\n+\t  = min(precision, max_eff_scientific_precision + 1);\n+\tconst int output_length_upper_bound\n+\t  = strlen(\"-d.\") + effective_precision + strlen(\"e+ddd\");\n+\t// The four bytes of headroom is to avoid needing to do a memmove when\n+\t// rewriting a scientific form such as 1.00e-2 into the equivalent\n+\t// fixed form 0.001.\n+\tchar buffer[4 + output_length_upper_bound];\n+\n+\t// 7.21.6.1/8: \"Let P equal ... 1 if the precision is zero.\"\n+\tif (effective_precision == 0)\n+\t  effective_precision = 1;\n+\n+\t// Perform a trial formatting in scientific form, and obtain the\n+\t// scientific exponent.\n+\tint scientific_exponent;\n+\tchar* buffer_start = buffer + 4;\n+\tint output_length\n+\t  = ryu::d2exp_buffered_n(value, effective_precision - 1,\n+\t\t\t\t  buffer_start, &scientific_exponent);\n+\t__glibcxx_assert(output_length <= output_length_upper_bound);\n+\n+\t// 7.21.6.1/8: \"Then, if a conversion with style E would have an\n+\t// exponent of X:\n+\t//   if P > X >= -4, the conversion is with style f and\n+\t//     precision P - (X + 1).\n+\t//   otherwise, the conversion is with style e and precision P - 1.\"\n+\tconst bool resolve_to_fixed_form\n+\t  = (scientific_exponent >= -4\n+\t     && scientific_exponent < effective_precision);\n+\tif (resolve_to_fixed_form)\n+\t  {\n+\t    // Rather than invoking d2fixed_buffered_n to reformat the number\n+\t    // for us from scratch, we can just rewrite the scientific form\n+\t    // into fixed form in-place.  This is safe to do because whenever\n+\t    // %g resolves to %f, the fixed form will be no larger than the\n+\t    // corresponding scientific form, and it will also contain the\n+\t    // same significant digits as the scientific form.\n+\t    fmt = chars_format::fixed;\n+\t    if (scientific_exponent < 0)\n+\t      {\n+\t\t// e.g. buffer_start == \"-1.234e-04\"\n+\t\tchar* leading_digit = &buffer_start[sign];\n+\t\tleading_digit[1] = leading_digit[0];\n+\t\t// buffer_start == \"-11234e-04\"\n+\t\tbuffer_start -= -scientific_exponent;\n+\t\t__glibcxx_assert(buffer_start >= buffer);\n+\t\t// buffer_start == \"????-11234e-04\"\n+\t\tchar* head = buffer_start;\n+\t\tif (sign)\n+\t\t  *head++ = '-';\n+\t\t*head++ = '0';\n+\t\t*head++ = '.';\n+\t\tmemset(head, '0', -scientific_exponent - 1);\n+\t\t// buffer_start == \"-0.00011234e-04\"\n+\n+\t\t// Now drop the exponent suffix, and add the leading zeros to\n+\t\t// the output length.\n+\t\toutput_length -= strlen(\"e-0d\");\n+\t\toutput_length += -scientific_exponent;\n+\t\tif (effective_precision - 1 == 0)\n+\t\t  // The scientific form had no decimal point, but the fixed\n+\t\t  // form now does.\n+\t\t  output_length += strlen(\".\");\n+\t      }\n+\t    else if (effective_precision == 1)\n+\t      {\n+\t\t// The scientific exponent must be 0, so the fixed form\n+\t\t// coincides with the scientific form (minus the exponent\n+\t\t// suffix).\n+\t\t__glibcxx_assert(scientific_exponent == 0);\n+\t\toutput_length -= strlen(\"e+dd\");\n+\t      }\n+\t    else\n+\t      {\n+\t\t// We are dealing with a scientific form which has a\n+\t\t// non-empty fractional part and a nonnegative exponent,\n+\t\t// e.g. buffer_start == \"1.234e+02\".\n+\t\t__glibcxx_assert(effective_precision >= 1);\n+\t\tchar* const decimal_point = &buffer_start[sign + 1];\n+\t\t__glibcxx_assert(*decimal_point == '.');\n+\t\tmemmove(decimal_point, decimal_point+1,\n+\t\t\tscientific_exponent);\n+\t\t// buffer_start == \"123.4e+02\"\n+\t\tdecimal_point[scientific_exponent] = '.';\n+\t\tif (scientific_exponent >= 100)\n+\t\t  output_length -= strlen(\"e+ddd\");\n+\t\telse\n+\t\t  output_length -= strlen(\"e+dd\");\n+\t\tif (effective_precision - 1 == scientific_exponent)\n+\t\t  output_length -= strlen(\".\");\n+\t      }\n+\t    effective_precision -= 1 + scientific_exponent;\n+\n+\t    __glibcxx_assert(output_length <= output_length_upper_bound);\n+\t  }\n+\telse\n+\t  {\n+\t    // We're sticking to the scientific form, so keep the output as-is.\n+\t    fmt = chars_format::scientific;\n+\t    effective_precision = effective_precision - 1;\n+\t  }\n+\n+\t// 7.21.6.1/8: \"Finally ... any any trailing zeros are removed from\n+\t// the fractional portion of the result and the decimal-point\n+\t// character is removed if there is no fractional portion remaining.\"\n+\tif (effective_precision > 0)\n+\t  {\n+\t    char* decimal_point = nullptr;\n+\t    if (fmt == chars_format::scientific)\n+\t      decimal_point = &buffer_start[sign + 1];\n+\t    else if (fmt == chars_format::fixed)\n+\t      decimal_point\n+\t\t= &buffer_start[output_length] - effective_precision - 1;\n+\t    __glibcxx_assert(*decimal_point == '.');\n+\n+\t    char* const fractional_part_start = decimal_point + 1;\n+\t    char* fractional_part_end = nullptr;\n+\t    if (fmt == chars_format::scientific)\n+\t      {\n+\t\tfractional_part_end = (buffer_start[output_length-5] == 'e'\n+\t\t\t\t       ? &buffer_start[output_length-5]\n+\t\t\t\t       : &buffer_start[output_length-4]);\n+\t\t__glibcxx_assert(*fractional_part_end == 'e');\n+\t      }\n+\t    else if (fmt == chars_format::fixed)\n+\t      fractional_part_end = &buffer_start[output_length];\n+\n+\t    const string_view fractional_part\n+\t      = {fractional_part_start, (size_t)(fractional_part_end\n+\t\t\t\t\t\t - fractional_part_start) };\n+\t    const size_t last_nonzero_digit_pos\n+\t      = fractional_part.find_last_not_of('0');\n+\n+\t    char* trim_start;\n+\t    if (last_nonzero_digit_pos == string_view::npos)\n+\t      trim_start = decimal_point;\n+\t    else\n+\t      trim_start = &fractional_part_start[last_nonzero_digit_pos] + 1;\n+\t    if (fmt == chars_format::scientific)\n+\t      memmove(trim_start, fractional_part_end,\n+\t\t      &buffer_start[output_length] - fractional_part_end);\n+\t    output_length -= fractional_part_end - trim_start;\n+\t  }\n+\n+\tif (last - first < output_length)\n+\t  return {last, errc::value_too_large};\n+\n+\tmemcpy(first, buffer_start, output_length);\n+\treturn {first + output_length, errc{}};\n+      }\n+\n+    __glibcxx_assert(false);\n+  }\n+\n+// Define the overloads for float.\n+to_chars_result\n+to_chars(char* first, char* last, float value) noexcept\n+{ return __floating_to_chars_shortest(first, last, value, chars_format{}); }\n+\n+to_chars_result\n+to_chars(char* first, char* last, float value, chars_format fmt) noexcept\n+{ return __floating_to_chars_shortest(first, last, value, fmt); }\n+\n+to_chars_result\n+to_chars(char* first, char* last, float value, chars_format fmt,\n+\t int precision) noexcept\n+{ return __floating_to_chars_precision(first, last, value, fmt, precision); }\n+\n+// Define the overloads for double.\n+to_chars_result\n+to_chars(char* first, char* last, double value) noexcept\n+{ return __floating_to_chars_shortest(first, last, value, chars_format{}); }\n+\n+to_chars_result\n+to_chars(char* first, char* last, double value, chars_format fmt) noexcept\n+{ return __floating_to_chars_shortest(first, last, value, fmt); }\n+\n+to_chars_result\n+to_chars(char* first, char* last, double value, chars_format fmt,\n+\t int precision) noexcept\n+{ return __floating_to_chars_precision(first, last, value, fmt, precision); }\n+\n+// Define the overloads for long double.\n+to_chars_result\n+to_chars(char* first, char* last, long double value) noexcept\n+{\n+  if constexpr (LONG_DOUBLE_KIND == LDK_BINARY64\n+\t\t|| LONG_DOUBLE_KIND == LDK_UNSUPPORTED)\n+    return __floating_to_chars_shortest(first, last, static_cast<double>(value),\n+\t\t\t\t\tchars_format{});\n+  else\n+    return __floating_to_chars_shortest(first, last, value, chars_format{});\n+}\n+\n+to_chars_result\n+to_chars(char* first, char* last, long double value, chars_format fmt) noexcept\n+{\n+  if constexpr (LONG_DOUBLE_KIND == LDK_BINARY64\n+\t\t|| LONG_DOUBLE_KIND == LDK_UNSUPPORTED)\n+    return __floating_to_chars_shortest(first, last, static_cast<double>(value),\n+\t\t\t\t\tfmt);\n+  else\n+    return __floating_to_chars_shortest(first, last, value, fmt);\n+}\n+\n+to_chars_result\n+to_chars(char* first, char* last, long double value, chars_format fmt,\n+\t int precision) noexcept\n+{\n+  if constexpr (LONG_DOUBLE_KIND == LDK_BINARY64\n+\t\t|| LONG_DOUBLE_KIND == LDK_UNSUPPORTED)\n+    return __floating_to_chars_precision(first, last, static_cast<double>(value),\n+\t\t\t\t\t fmt,\n+\t\t\t\t\t precision);\n+  else\n+    return __floating_to_chars_precision(first, last, value, fmt, precision);\n+}\n+\n+#ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n+// Map the -mlong-double-64 long double overloads to the double overloads.\n+extern \"C\" to_chars_result\n+_ZSt8to_charsPcS_e(char* first, char* last, double value) noexcept\n+  __attribute__((alias (\"_ZSt8to_charsPcS_d\")));\n+\n+extern \"C\" to_chars_result\n+_ZSt8to_charsPcS_eSt12chars_format(char* first, char* last, double value,\n+\t\t\t\t   chars_format fmt) noexcept\n+  __attribute__((alias (\"_ZSt8to_charsPcS_dSt12chars_format\")));\n+\n+extern \"C\" to_chars_result\n+_ZSt8to_charsPcS_eSt12chars_formati(char* first, char* last, double value,\n+\t\t\t\t    chars_format fmt, int precision) noexcept\n+  __attribute__((alias (\"_ZSt8to_charsPcS_dSt12chars_formati\")));\n+#endif\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std"}, {"sha": "12ac8ae78225761729e6c2a44db1e75880dc33b1", "filename": "libstdc++-v3/testsuite/20_util/to_chars/long_double.cc", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c57e692357c79ee7623dfc1586652aee2aefb8f/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc?ref=3c57e692357c79ee7623dfc1586652aee2aefb8f", "patch": "@@ -0,0 +1,199 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// <charconv> is supported in C++14 as a GNU extension, but this test uses C++17\n+// hexadecimal floating-point literals.\n+// { dg-do run { target c++17 } }\n+// { dg-xfail-run-if \"Ryu needs __int128\" { large_long_double && { ! int128 } } }\n+\n+#include <charconv>\n+\n+#include <cmath>\n+#include <cstring>\n+#include <iterator>\n+#include <limits>\n+\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+// The long double overloads of std::to_chars currently just go through printf\n+// (except for the hexadecimal formatting).\n+\n+// Test our hand-written hexadecimal formatting implementation.\n+void\n+test01()\n+{\n+  const long double hex_testcases[]\n+    = { nextdownl(numeric_limits<long double>::max()),\n+\tnextupl(numeric_limits<long double>::min()),\n+\t42.0L,\n+\t0x1.2p+0L,\n+\t0x1.23p+0L,\n+\t0x1.234p+0L,\n+\t0x1.2345p+0L,\n+\t0x1.23456p+0L,\n+\t0x1.234567p+0L,\n+\t0x1.2345678p+0L,\n+\t0x1.23456789p+0L,\n+\t0x1.23456789p+0L,\n+\t0x1.23456789ap+0L,\n+\t0x1.23456789abp+0L,\n+\t0x1.23456789abcp+0L,\n+\t0x1.23456789abcdp+0L,\n+\t0x1.23456789abcdep+0L,\n+\t0x1.23456789abcdefp+0L,\n+\t0x1.23456789abcdef0p+0L,\n+\t0x1.23456789abcdef01p+0L,\n+\t0x1.23456789abcdef012p+0L,\n+\t0x1.23456789abcdef0123p+0L,\n+\t0x1.23456789abcdef01234p+0L,\n+\t0x1.23456789abcdef012345p+0L,\n+\t0x1.23456789abcdef0123456p+0L,\n+\t0x1.23456789abcdef01234567p+0L,\n+\t0x1.23456789abcdef012345678p+0L,\n+\t0x1.23456789abcdef0123456789p+0L,\n+\t0x1.23456789abcdef0123456789ap+0L,\n+\t0x1.23456789abcdef0123456789abp+0L,\n+\t0x1.23456789abcdef0123456789abcp+0L,\n+\t0x1.23456789abcdef0123456789abcdp+0L,\n+    };\n+\n+  for (int exponent : {-11000, -3000, -300, -50, -7, 0, 7, 50, 300, 3000, 11000})\n+    for (long double testcase : hex_testcases)\n+      {\n+\ttestcase = ldexpl(testcase, exponent);\n+\tif (testcase == 0.0L || isinf(testcase))\n+\t  continue;\n+\n+\tchar to_chars_buffer[1024], printf_buffer[1024];\n+\tmemset(to_chars_buffer, '\\0', sizeof(to_chars_buffer));\n+\tmemset(printf_buffer, '\\0', sizeof(printf_buffer));\n+\n+\tauto result = to_chars(begin(to_chars_buffer), end(to_chars_buffer),\n+\t\t\t       testcase, chars_format::hex);\n+\tVERIFY( result.ec == errc{} );\n+\t*result.ptr = '\\0';\n+\tsprintf(printf_buffer, \"%La\", testcase);\n+\tVERIFY( !strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) );\n+\n+\t  {\n+\t    // Verify that the nearby values have a different shortest form.\n+\t    testcase = nextdownl(testcase);\n+\t    result = to_chars(begin(to_chars_buffer), end(to_chars_buffer),\n+\t\t\t      testcase, chars_format::hex);\n+\t    VERIFY( result.ec == errc{} );\n+\t    *result.ptr = '\\0';\n+\t    VERIFY( strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) != 0);\n+\t    sprintf(printf_buffer, \"%La\", testcase);\n+\t    VERIFY( !strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) );\n+\n+\t    testcase = nextupl(nextupl(testcase));\n+\t    result = to_chars(begin(to_chars_buffer), end(to_chars_buffer),\n+\t\t\t      testcase, chars_format::hex);\n+\t    VERIFY( result.ec == errc{} );\n+\t    *result.ptr = '\\0';\n+\t    VERIFY( strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) != 0);\n+\t    sprintf(printf_buffer, \"%La\", testcase);\n+\t    VERIFY( !strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) );\n+\n+\t    testcase = nextdownl(testcase);\n+\t  }\n+\n+\tfor (int precision = -1; precision < 50; precision++)\n+\t  {\n+\t    result = to_chars(begin(to_chars_buffer), end(to_chars_buffer),\n+\t\t\t      testcase, chars_format::hex, precision);\n+\t    VERIFY( result.ec == errc{} );\n+\t    *result.ptr = '\\0';\n+\t    sprintf(printf_buffer, \"%.*La\", precision, testcase);\n+\t    VERIFY( !strcmp(to_chars_buffer, printf_buffer+strlen(\"0x\")) );\n+\t  }\n+      }\n+}\n+\n+// Test the rest of the formatting modes, which go through printf.\n+void\n+test02()\n+{\n+  const long double growth_factor = 1.442695040888963407359924681001892137L;\n+  for (chars_format fmt : {chars_format::fixed, chars_format::scientific,\n+\t\t\t   chars_format::general})\n+    for (long double __value = 1.0L, count = 0; !isinf(__value);\n+\t ++count <= 100.0L ? __value *= growth_factor : __value *= __value)\n+      for (const long double value : {__value, 1.0L/__value})\n+\t{\n+\t  for (const int precision : {-1, 0, 10, 100, 10000})\n+\t    {\n+\t      const char* const printf_specifier\n+\t\t= (fmt == chars_format::fixed ? \"%.*Lf\"\n+\t\t   : fmt == chars_format::scientific ? \"%.*Le\"\n+\t\t   : fmt == chars_format::general ? \"%.*Lg\"\n+\t\t   : nullptr);\n+\t      unsigned output_length = snprintf(nullptr, 0, printf_specifier,\n+\t\t\t\t\t\tprecision, value);\n+\n+\t      char printf_buffer[output_length+1];\n+\t      snprintf(printf_buffer, output_length+1, printf_specifier,\n+\t\t       precision, value);\n+\n+\t      char to_chars_buffer[output_length];\n+\t      auto result = to_chars(to_chars_buffer,\n+\t\t\t\t     to_chars_buffer+output_length,\n+\t\t\t\t     value, fmt, precision);\n+\t      VERIFY( result.ec == errc{} );\n+\t      VERIFY( !memcmp(printf_buffer, to_chars_buffer, output_length) );\n+\n+\t      result = to_chars(to_chars_buffer,\n+\t\t\t\tto_chars_buffer+output_length-1,\n+\t\t\t\tvalue, fmt, precision);\n+\t      VERIFY( result.ec == errc::value_too_large );\n+\t    }\n+\n+\t  // Verify that the nearby values have a different shortest form.\n+\t  char to_chars_buffer[50000];\n+\t  auto result = to_chars(begin(to_chars_buffer), end(to_chars_buffer),\n+\t\t\t\t value, fmt);\n+\t  VERIFY( result.ec == errc{} );\n+\t  *result.ptr = '\\0';\n+\t  char nearby_buffer[50000];\n+\t    {\n+\t      const long double smaller = nextdownl(value);\n+\t      result = to_chars(begin(nearby_buffer), end(nearby_buffer),\n+\t\t\t\tsmaller, fmt);\n+\t      VERIFY( result.ec == errc{} );\n+\t      *result.ptr = '\\0';\n+\t      VERIFY( strcmp(to_chars_buffer, nearby_buffer) != 0 );\n+\t    }\n+\n+\t    {\n+\t      long double larger = nextupl(value);\n+\t      result = to_chars(begin(nearby_buffer), end(nearby_buffer),\n+\t\t\t\tlarger, fmt);\n+\t      VERIFY( result.ec == errc{} );\n+\t      *result.ptr = '\\0';\n+\t      VERIFY( strcmp(to_chars_buffer, nearby_buffer) != 0 );\n+\t    }\n+\t}\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}