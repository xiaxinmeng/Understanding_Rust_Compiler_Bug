{"sha": "d6901754328ca02294c088a792630ed81dc63165", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY5MDE3NTQzMjhjYTAyMjk0YzA4OGE3OTI2MzBlZDgxZGM2MzE2NQ==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2004-11-19T19:03:56Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-11-19T19:03:56Z"}, "message": "tree-vectorizer.c (slpeel_can_duplicate_loop_p): New name for function previously called verify_loop_for_duplication.\n\n        * tree-vectorizer.c (slpeel_can_duplicate_loop_p): New name for function\n        previously called verify_loop_for_duplication. All conditions compacted\n        into one compound condition. Removed debug dumps.\n        (vect_analyze_loop_with_symbolic_num_of_iters): Removed. Some of the\n        functionality moved to vect_can_advance_ivs_p, and some to\n        vect_analyze_loop_form.\n        (vect_can_advance_ivs_p): New function. Contains functionality that was\n        taken out of vect_analyze_loop_with_symbolic_num_of_iters.\n        (slpeel_tree_peel_loop_to_edge): Call slpeel_can_duplicate_loop_p.\n        (vect_analyze_operations): Call vect_can_advance_ivs_p and\n        slpeel_can_duplicate_loop_p.\n        (vect_get_loop_niters): Added documentation.\n        (vect_analyze_loop_form): Check the loop entry always - not only in case\n        of unknown loop bound. Create preheader and exit bb if necessary. Apply\n        a check that used to take place in\n        vect_analyze_loop_with_symbolic_num_of_iters.\n        (vectorize_loops): Call verify_loop_closed_ssa under ENABLE_CHECKING.\n        Remove redundant call to rewrite_into_loop_closed_ssa.\n        (vect_compute_data_refs_alignment): Removed obsolete comment.\n\nFrom-SVN: r90930", "tree": {"sha": "1b648cc2716c5a9aad0c3d7343735729201ff1cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b648cc2716c5a9aad0c3d7343735729201ff1cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6901754328ca02294c088a792630ed81dc63165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6901754328ca02294c088a792630ed81dc63165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6901754328ca02294c088a792630ed81dc63165", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6901754328ca02294c088a792630ed81dc63165/comments", "author": null, "committer": null, "parents": [{"sha": "f88a8cfa39503d0d4e5a36cc8207983bea7ad70e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f88a8cfa39503d0d4e5a36cc8207983bea7ad70e"}], "stats": {"total": 291, "additions": 130, "deletions": 161}, "files": [{"sha": "de6cbda1f03079745ac13df75a930cfa02e96a95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6901754328ca02294c088a792630ed81dc63165/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6901754328ca02294c088a792630ed81dc63165/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6901754328ca02294c088a792630ed81dc63165", "patch": "@@ -1,3 +1,25 @@\n+2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.c (slpeel_can_duplicate_loop_p): New name for function\n+\tpreviously called verify_loop_for_duplication. All conditions compacted\n+\tinto one compound condition. Removed debug dumps.\n+\t(vect_analyze_loop_with_symbolic_num_of_iters): Removed. Some of the\n+\tfunctionality moved to vect_can_advance_ivs_p, and some to\n+\tvect_analyze_loop_form.\n+\t(vect_can_advance_ivs_p): New function. Contains functionality that was\n+\ttaken out of vect_analyze_loop_with_symbolic_num_of_iters.\n+\t(slpeel_tree_peel_loop_to_edge): Call slpeel_can_duplicate_loop_p.\n+\t(vect_analyze_operations): Call vect_can_advance_ivs_p and\n+\tslpeel_can_duplicate_loop_p.\n+\t(vect_get_loop_niters): Added documentation.\n+\t(vect_analyze_loop_form): Check the loop entry always - not only in case\n+\tof unknown loop bound. Create preheader and exit bb if necessary. Apply\n+\ta check that used to take place in\n+\tvect_analyze_loop_with_symbolic_num_of_iters.\n+\t(vectorize_loops): Call verify_loop_closed_ssa under ENABLE_CHECKING.\n+\tRemove redundant call to rewrite_into_loop_closed_ssa.\n+\t(vect_compute_data_refs_alignment): Removed obsolete comment.\n+\n 2004-11-19  Dorit Naishlos  <dorit@il.ibm.com>\n \n \t* tree-vectorizer.c (slpeel_tree_peel_loop_to_edge): New name for"}, {"sha": "0b3796f6015032f8062f21c4f6df713c67f2bf0b", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 108, "deletions": 161, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6901754328ca02294c088a792630ed81dc63165/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6901754328ca02294c088a792630ed81dc63165/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=d6901754328ca02294c088a792630ed81dc63165", "patch": "@@ -167,6 +167,7 @@ static void slpeel_update_phis_for_duplicate_loop\n static void slpeel_update_phi_nodes_for_guard (edge, struct loop *);\n static void slpeel_make_loop_iterate_ntimes (struct loop *, tree, tree, tree);\n static edge slpeel_add_loop_guard (basic_block, tree, basic_block);\n+static bool slpeel_can_duplicate_loop_p (struct loop *, edge);\n static void allocate_new_names (bitmap);\n static void rename_use_op (use_operand_p);\n static void rename_def_op (def_operand_p, tree);\n@@ -217,8 +218,7 @@ static bool vect_get_first_index (tree, tree *);\n static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n static struct data_reference * vect_analyze_pointer_ref_access \n   (tree, tree, bool);\n-static bool vect_analyze_loop_with_symbolic_num_of_iters \n-  (tree niters, struct loop *loop);\n+static bool vect_can_advance_ivs_p (struct loop *);\n static tree vect_get_base_and_bit_offset\n   (struct data_reference *, tree, tree, loop_vec_info, tree *, bool*);\n static struct data_reference * vect_analyze_pointer_ref_access\n@@ -799,83 +799,37 @@ slpeel_add_loop_guard (basic_block guard_bb, tree cond, basic_block exit_bb)\n }\n \n \n-/* This function verifies that certain restrictions apply to LOOP.  */\n+/* This function verifies that the following restrictions apply to LOOP:\n+   (1) it is innermost\n+   (2) it consists of exactly 2 basic blocks - header, and an empty latch.\n+   (3) it is single entry, single exit\n+   (4) its exit condition is the last stmt in the header\n+   (5) E is the entry/exit edge of LOOP.\n+ */\n \n static bool\n-slpeel_verify_loop_for_duplication (struct loop *loop,\n-\t\t\t\t    bool update_first_loop_count, edge e)\n+slpeel_can_duplicate_loop_p (struct loop *loop, edge e)\n {\n   edge exit_e = loop->exit_edges [0];\n   edge entry_e = loop_preheader_edge (loop);\n+  tree orig_cond = get_loop_exit_condition (loop);\n+  block_stmt_iterator loop_exit_bsi = bsi_last (exit_e->src);\n \n-  /* We duplicate only innermost loops.  */\n-  if (loop->inner)\n-    {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t  fprintf (dump_file,\n-\t\t   \"Loop duplication failed. Loop is not innermost.\\n\");\n-      return false;\n-    }\n-\n-  /* Only loops with 1 exit.  */\n-  if (loop->num_exits != 1)\n-    {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t  fprintf (dump_file,\n-\t\t   \"More than one exit from loop.\\n\");\n-      return false;\n-    }\n-\n-  /* Only loops with 1 entry.  */\n-  if (loop->num_entries != 1)\n-    {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t  fprintf (dump_file,\n-\t\t   \"More than one exit from loop.\\n\");\n-      return false;\n-    }\n-\n-  /* All loops has outers, the only case loop->outer is NULL is for\n-     the function itself.  */\n-  if (!loop->outer)\n-    {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t  fprintf (dump_file,\n-\t\t   \"Loop is outer-most loop.\\n\");\n-      return false;\n-    }\n-  \n-  /* Verify that new IV can be created and loop condition \n-     can be changed to make first loop iterate first_niters times.  */\n-  if (!update_first_loop_count)\n-    {\n-      tree orig_cond = get_loop_exit_condition (loop);\n-      block_stmt_iterator loop_exit_bsi = bsi_last (exit_e->src);\n-      \n-      if (!orig_cond)\n-\t{\n-\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t    fprintf (dump_file,\n-\t\t     \"Loop has no exit condition.\\n\");\n-\t  return false;\n-\t}\n-      if (orig_cond != bsi_stmt (loop_exit_bsi))\n-\t{\n-\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\t    fprintf (dump_file,\n-\t\t     \"Loop exit condition is not loop header last stmt.\\n\");\n-\t  return false;\n-\t}\n-    }\n+  if (any_marked_for_rewrite_p ())\n+    return false;\n \n-  /* Make sure E is either an entry or an exit edge.  */\n-  if (e != exit_e && e != entry_e)\n-    {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n-\tfprintf (dump_file,\n-\t\t \"E is not loop entry or exit edge.\\n\");\n-      return false;\n-    }\n+  if (loop->inner\n+      /* All loops have an outer scope; the only case loop->outer is NULL is for\n+         the function itself.  */\n+      || !loop->outer\n+      || loop->num_nodes != 2\n+      || !empty_block_p (loop->latch)\n+      || loop->num_exits != 1\n+      || loop->num_entries != 1\n+      /* Verify that new loop exit condition can be trivially modified.  */\n+      || (!orig_cond || orig_cond != bsi_stmt (loop_exit_bsi))\n+      || (e != exit_e && e != entry_e))\n+    return false;\n \n   return true;\n }\n@@ -949,10 +903,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   basic_block pre_header_bb;\n   edge exit_e = loop->exit_edges [0];\n \n-  gcc_assert (!any_marked_for_rewrite_p ());\n-\n-  if (!slpeel_verify_loop_for_duplication (loop, update_first_loop_count, e))\n-      return NULL;\n+  if (!slpeel_can_duplicate_loop_p (loop, e))\n+    return NULL;\n \n   /* We have to initialize cfg_hooks. Then, when calling \n    cfg_hooks->split_edge, the function tree_split_edge \n@@ -3595,27 +3547,30 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n     }\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n \n-  \n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) \n-      && vect_debug_details (NULL))\n-    fprintf (dump_file, \n-\t\"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n-\tvectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n-\n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n-    {\n-      /* In this case we have to generate epilog loop, that \n-\t can be done only for loops with one entry edge.  */\n-      if (LOOP_VINFO_LOOP (loop_vinfo)->num_entries != 1\n-\t  || !(LOOP_VINFO_LOOP (loop_vinfo)->pre_header))\n-\t{\n-\t  if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t    fprintf (dump_file, \"not vectorized: more than one entry.\");\n-\t  return false;\n-\t}\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && vect_debug_details (NULL))\n+    fprintf (dump_file,\n+        \"vectorization_factor = %d, niters = \" HOST_WIDE_INT_PRINT_DEC,\n+        vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n+\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n+    {\n+      if (vect_debug_stats (loop) || vect_debug_details (loop))\n+        fprintf (dump_file, \"epilog loop required.\");\n+      if (!vect_can_advance_ivs_p (loop))\n+        {\n+          if (vect_debug_stats (loop) || vect_debug_details (loop))\n+            fprintf (dump_file, \"not vectorized: can't create epilog loop 1.\");\n+          return false;\n+        }\n+      if (!slpeel_can_duplicate_loop_p (loop, loop->exit_edges[0]))\n+        {\n+          if (vect_debug_stats (loop) || vect_debug_details (loop))\n+            fprintf (dump_file, \"not vectorized: can't create epilog loop 2.\");\n+          return false;\n+        }\n     }\n-  \n+\n   return true;\n }\n \n@@ -4358,9 +4313,7 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n    FOR NOW: we assume that whatever versioning/peeling takes place, only the\n    original loop is to be vectorized; Any other loops that are created by\n    the transformations performed in this pass - are not supposed to be\n-   vectorized. This restriction will be relaxed.\n-\n-   FOR NOW: No transformation is actually performed. TODO.  */\n+   vectorized. This restriction will be relaxed.  */\n \n static void\n vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n@@ -5347,46 +5300,21 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_analyze_loop_with_symbolic_num_of_iters.\n+/* Function vect_can_advance_ivs_p\n \n    In case the number of iterations that LOOP iterates in unknown at compile \n    time, an epilog loop will be generated, and the loop induction variables \n    (IVs) will be \"advanced\" to the value they are supposed to take just before \n-   the epilog loop. Here we check that the access function of the loop IVs\n+   the epilog loop.  Here we check that the access function of the loop IVs\n    and the expression that represents the loop bound are simple enough.\n    These restrictions will be relaxed in the future.  */\n \n static bool \n-vect_analyze_loop_with_symbolic_num_of_iters (tree niters, \n-\t\t\t\t\t      struct loop *loop)\n+vect_can_advance_ivs_p (struct loop *loop)\n {\n   basic_block bb = loop->header;\n   tree phi;\n \n-  if (vect_debug_details (NULL))\n-    fprintf (dump_file, \n-\t     \"\\n<<vect_analyze_loop_with_symbolic_num_of_iters>>\\n\");\n-  \n-  if (chrec_contains_undetermined (niters))\n-    {\n-      if (vect_debug_details (NULL))\n-        fprintf (dump_file, \"Infinite number of iterations.\");\n-      return false;\n-    }\n-\n-  if (!niters)\n-    {\n-      if (vect_debug_details (NULL))\n-        fprintf (dump_file, \"niters is NULL pointer.\");\n-      return false;\n-    }\n-\n-  if (vect_debug_details (NULL))\n-    {\n-      fprintf (dump_file, \"Symbolic number of iterations is \");\n-      print_generic_expr (dump_file, niters, TDF_DETAILS);\n-    }\n-   \n   /* Analyze phi functions of the loop header.  */\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n@@ -5440,13 +5368,16 @@ vect_analyze_loop_with_symbolic_num_of_iters (tree niters,\n \treturn false;  \n     }\n \n-  return  true;\n+  return true;\n }\n \n \n /* Function vect_get_loop_niters.\n \n-   Determine how many iterations the loop is executed.  */\n+   Determine how many iterations the loop is executed.\n+   If an expression that represents the number of iterations\n+   can be constructed, place it in NUMBER_OF_ITERATIONS.\n+   Return the loop exit condition.  */\n \n static tree\n vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n@@ -5490,13 +5421,16 @@ vect_analyze_loop_form (struct loop *loop)\n   loop_vec_info loop_vinfo;\n   tree loop_cond;\n   tree number_of_iterations = NULL;\n+  bool rescan = false;\n \n   if (vect_debug_details (loop))\n     fprintf (dump_file, \"\\n<<vect_analyze_loop_form>>\\n\");\n \n   if (loop->inner\n       || !loop->single_exit\n-      || loop->num_nodes != 2)\n+      || loop->num_nodes != 2\n+      || EDGE_COUNT (loop->header->preds) != 2\n+      || loop->num_entries != 1)\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\t\n \t{\n@@ -5507,6 +5441,10 @@ vect_analyze_loop_form (struct loop *loop)\n \t    fprintf (dump_file, \"multiple exits.\");\n \t  else if (loop->num_nodes != 2)\n \t    fprintf (dump_file, \"too many BBs in loop.\");\n+\t  else if (EDGE_COUNT (loop->header->preds) != 2)\n+            fprintf (dump_file, \"too many incoming edges.\");\n+          else if (loop->num_entries != 1)\n+            fprintf (dump_file, \"too many entries.\");\n \t}\n \n       return NULL;\n@@ -5523,6 +5461,27 @@ vect_analyze_loop_form (struct loop *loop)\n       return NULL;\n     }\n \n+  /* Make sure we have a preheader basic block.  */\n+  if (!loop->pre_header)\n+    {\n+      rescan = true;\n+      loop_split_edge_with (loop_preheader_edge (loop), NULL);\n+    }\n+    \n+  /* Make sure there exists a single-predecessor exit bb:  */\n+  if (EDGE_COUNT (loop->exit_edges[0]->dest->preds) != 1)\n+    {\n+      rescan = true;\n+      loop_split_edge_with (loop->exit_edges[0], NULL);\n+    }\n+    \n+  if (rescan)\n+    {\n+      flow_loop_scan (loop, LOOP_ALL);\n+      /* Flow loop scan does not update loop->single_exit field.  */\n+      loop->single_exit = loop->exit_edges[0];\n+    }\n+\n   if (empty_block_p (loop->header))\n     {\n       if (vect_debug_stats (loop) || vect_debug_details (loop))\n@@ -5546,33 +5505,24 @@ vect_analyze_loop_form (struct loop *loop)\n       return NULL;\n     }\n \n+  if (chrec_contains_undetermined (number_of_iterations))\n+    {\n+      if (vect_debug_details (NULL))\n+        fprintf (dump_file, \"Infinite number of iterations.\");\n+      return false;\n+    }\n+\n   loop_vinfo = new_loop_vec_info (loop);\n   LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n+\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\tfprintf (dump_file, \"loop bound unknown.\");\n-\n-      /* Unknown loop bound.  */\n-      if (!vect_analyze_loop_with_symbolic_num_of_iters \n-\t\t\t\t\t(number_of_iterations, loop))\n-\t{\n-          if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t    fprintf (dump_file, \n-\t\t     \"not vectorized: can't determine loop bound.\");\n-\t  return NULL;\n-\t}\n-      else\n-\t{\n-\t  /* We need only one loop entry for unknown loop bound support.  */\n-\t  if (loop->num_entries != 1 || !loop->pre_header)\n-\t    {\t      \n-\t      if (vect_debug_stats (loop) || vect_debug_details (loop))\n-\t\tfprintf (dump_file, \n-\t\t\t \"not vectorized: more than one loop entry.\");\n-\t      return NULL;\n-\t    }\n-\t}\n+      if (vect_debug_details (loop))\n+        {\n+          fprintf (dump_file, \"loop bound unknown.\\n\");\n+          fprintf (dump_file, \"Symbolic number of iterations is \");\n+          print_generic_expr (dump_file, number_of_iterations, TDF_DETAILS);\n+        }\n     }\n   else\n   if (LOOP_VINFO_INT_NITERS (loop_vinfo) == 0)\n@@ -5739,6 +5689,10 @@ vectorize_loops (struct loops *loops)\n       return;\n     }\n \n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa ();\n+#endif\n+\n   compute_immediate_uses (TDFA_USE_OPS, need_imm_uses_for);\n \n   /*  ----------- Analyze loops. -----------  */\n@@ -5785,13 +5739,6 @@ vectorize_loops (struct loops *loops)\n     }\n \n   rewrite_into_ssa (false);\n-  if (!bitmap_empty_p (vars_to_rename))\n-    {\n-      /* The rewrite of ssa names may cause violation of loop closed ssa\n-         form invariants.  TODO -- avoid these rewrites completely.\n-         Information in virtual phi nodes is sufficient for it.  */\n-      rewrite_into_loop_closed_ssa (); \n-    }\n-  rewrite_into_loop_closed_ssa (); \n+  rewrite_into_loop_closed_ssa (); /* FORNOW */\n   bitmap_clear (vars_to_rename);\n }"}]}