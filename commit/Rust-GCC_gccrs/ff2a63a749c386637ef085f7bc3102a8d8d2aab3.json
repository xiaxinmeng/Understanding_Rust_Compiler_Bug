{"sha": "ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYyYTYzYTc0OWMzODY2MzdlZjA4NWY3YmMzMTAyYThkOGQyYWFiMw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-09-26T13:23:31Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-09-26T13:23:31Z"}, "message": "gimple.c (gimple_replace_lhs): Move to tree-ssa.c and rename.\n\n\n2013-09-26  Andrew MacLeod <amacleod@redhat.com>\n\n\t* gimple.c (gimple_replace_lhs): Move to tree-ssa.c and rename.\n\t(struct count_ptr_d, count_ptr_derefs, count_uses_and_derefs): Move to\n\ttree-ssa.c\n\t(create_gimple_tmp): Delete.\n\t(get_expr_type, build_assign, build_type_cast): Move to...\n\t* gimple-builder.c: New File.\n\t(get_expr_type): Relocate from gimple.c.\n\t(build_assign, build_type_cast): Change to only create ssanames.\n\t* gimple.h: Move prototypes to...\n\t* gimple-builder.h: New File. Here.\n\t* tree-ssa.h: And here.\n\t* tree-ssa.c (struct count_ptr_d, count_ptr_derefs,\n\tcount_uses_and_derefs): Relocate from gimple.c.\n\t(gimple_replace_ssa_lhs): Renamed gimple_replace_ssa from gimple.c\n\t* tree-ssa-reassoc.c (repropagate_negates): Use gimple_replace_ssa_lhs.\n\t* tree-ssa-math-opts (execute_cse_reciprocals): Use\n\tgimple_replace_ssa_lhs.\n\t* asan.c: Include gimple-builder.h.\n\t* Makefile.in: Add gimple-builder.o.\n\nFrom-SVN: r202945", "tree": {"sha": "0bdac19cc1c197b2e326293eb4c1344554b4e7b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bdac19cc1c197b2e326293eb4c1344554b4e7b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/comments", "author": null, "committer": null, "parents": [{"sha": "a2544177b989c29fe893e55d422c8d9e6f27c6b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2544177b989c29fe893e55d422c8d9e6f27c6b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2544177b989c29fe893e55d422c8d9e6f27c6b3"}], "stats": {"total": 552, "additions": 311, "deletions": 241}, "files": [{"sha": "eb83ea893232364f7611ea1846936a5f4a9f17f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -1,3 +1,25 @@\n+2013-09-26  Andrew MacLeod <amacleod@redhat.com>\n+\n+\t* gimple.c (gimple_replace_lhs): Move to tree-ssa.c and rename.\n+\t(struct count_ptr_d, count_ptr_derefs, count_uses_and_derefs): Move to\n+\ttree-ssa.c\n+\t(create_gimple_tmp): Delete.\n+\t(get_expr_type, build_assign, build_type_cast): Move to...\n+\t* gimple-builder.c: New File.\n+\t(get_expr_type): Relocate from gimple.c.\n+\t(build_assign, build_type_cast): Change to only create ssanames.\n+\t* gimple.h: Move prototypes to...\n+\t* gimple-builder.h: New File. Here.\n+\t* tree-ssa.h: And here.\n+\t* tree-ssa.c (struct count_ptr_d, count_ptr_derefs,\n+\tcount_uses_and_derefs): Relocate from gimple.c.\n+\t(gimple_replace_ssa_lhs): Renamed gimple_replace_ssa from gimple.c\n+\t* tree-ssa-reassoc.c (repropagate_negates): Use gimple_replace_ssa_lhs.\n+\t* tree-ssa-math-opts (execute_cse_reciprocals): Use\n+\tgimple_replace_ssa_lhs.\n+\t* asan.c: Include gimple-builder.h.\n+\t* Makefile.in: Add gimple-builder.o.\n+\n 2013-09-26  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-live.c (var_map_base_init): Handle SSA names with"}, {"sha": "f55f1d15a9ceba85e0897b84fb7eb2b6049466b0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -1220,6 +1220,7 @@ OBJS = \\\n \tgcse.o \\\n \tggc-common.o \\\n \tgimple.o \\\n+\tgimple-builder.o \\\n \tgimple-iterator.o \\\n \tgimple-fold.o \\\n \tgimple-low.o \\"}, {"sha": "2e1fb0e4082538ae0404a1fe511057b3c52c8b7c", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hash-table.h\"\n #include \"alloc-pool.h\"\n #include \"cfgloop.h\"\n+#include \"gimple-builder.h\"\n \n /* AddressSanitizer finds out-of-bounds and use-after-free bugs\n    with <2x slowdown on average."}, {"sha": "665c8020b93e5d765772496b6803dcf014051714", "filename": "gcc/gimple-builder.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fgimple-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fgimple-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-builder.c?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -0,0 +1,118 @@\n+/* Functions for high level gimple building routines.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-ssa.h\"\n+\n+\n+/* Return the expression type to use based on the CODE and type of\n+   the given operand OP.  If the expression CODE is a comparison,\n+   the returned type is boolean_type_node.  Otherwise, it returns\n+   the type of OP.  */\n+\n+static tree\n+get_expr_type (enum tree_code code, tree op)\n+{\n+  return (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t ? boolean_type_node\n+\t : TREE_TYPE (op);\n+}\n+\n+\n+/* Build a new gimple assignment.  The LHS of the assignment is a new\n+   temporary whose type matches the given expression.  MODE indicates\n+   whether the LHS should be an SSA or a normal temporary.  CODE is\n+   the expression code for the RHS.  OP1 is the first operand and VAL\n+   is an integer value to be used as the second operand.  */\n+\n+gimple\n+build_assign (enum tree_code code, tree op1, int val, tree lhs)\n+{\n+  tree op2 = build_int_cst (TREE_TYPE (op1), val);\n+  if (lhs == NULL_TREE)\n+    lhs = make_ssa_name (get_expr_type (code, op1), NULL);\n+  return gimple_build_assign_with_ops (code, lhs, op1, op2);\n+}\n+\n+gimple\n+build_assign (enum tree_code code, gimple g, int val, tree lhs )\n+{\n+  return build_assign (code, gimple_assign_lhs (g), val, lhs);\n+}\n+\n+\n+/* Build and return a new GIMPLE assignment.  The new assignment will\n+   have the opcode CODE and operands OP1 and OP2.  The type of the\n+   expression on the RHS is inferred to be the type of OP1.\n+\n+   The LHS of the statement will be an SSA name or a GIMPLE temporary\n+   in normal form depending on the type of builder invoking this\n+   function.  */\n+\n+gimple\n+build_assign (enum tree_code code, tree op1, tree op2, tree lhs)\n+{\n+  if (lhs == NULL_TREE)\n+    lhs = make_ssa_name (get_expr_type (code, op1), NULL);\n+  return gimple_build_assign_with_ops (code, lhs, op1, op2);\n+}\n+\n+gimple\n+build_assign (enum tree_code code, gimple op1, tree op2, tree lhs)\n+{\n+  return build_assign (code, gimple_assign_lhs (op1), op2, lhs);\n+}\n+\n+gimple\n+build_assign (enum tree_code code, tree op1, gimple op2, tree lhs)\n+{\n+  return build_assign (code, op1, gimple_assign_lhs (op2), lhs);\n+}\n+\n+gimple\n+build_assign (enum tree_code code, gimple op1, gimple op2, tree lhs)\n+{\n+  return build_assign (code, gimple_assign_lhs (op1), gimple_assign_lhs (op2),\n+                       lhs);\n+}\n+\n+\n+/* Create and return a type cast assignment. This creates a NOP_EXPR\n+   that converts OP to TO_TYPE.  */\n+\n+gimple\n+build_type_cast (tree to_type, tree op, tree lhs)\n+{\n+  if (lhs == NULL_TREE)\n+    lhs = make_ssa_name (to_type, NULL);\n+  return gimple_build_assign_with_ops (NOP_EXPR, lhs, op, NULL_TREE);\n+}\n+\n+gimple\n+build_type_cast (tree to_type, gimple op, tree lhs)\n+{\n+  return build_type_cast (to_type, gimple_assign_lhs (op), lhs);\n+}\n+\n+\n+"}, {"sha": "532c04e2189bd59d2269fe2eb9036ac23f00527c", "filename": "gcc/gimple-builder.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fgimple-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fgimple-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-builder.h?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -0,0 +1,34 @@\n+/* Header file for high level statement building routines.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef GCC_GIMPLE_BUILDER_H\n+#define GCC_GIMPLE_BUILDER_H\n+\n+tree create_gimple_tmp (tree, tree lhs = NULL_TREE);\n+gimple build_assign (enum tree_code, tree, int, tree lhs = NULL_TREE);\n+gimple build_assign (enum tree_code, gimple, int, tree lhs = NULL_TREE);\n+gimple build_assign (enum tree_code, tree, tree, tree lhs = NULL_TREE);\n+gimple build_assign (enum tree_code, gimple, tree, tree lhs = NULL_TREE);\n+gimple build_assign (enum tree_code, tree, gimple, tree lhs = NULL_TREE);\n+gimple build_assign (enum tree_code, gimple, gimple, tree lhs = NULL_TREE);\n+gimple build_type_cast (tree, tree, tree lhs = NULL_TREE);\n+gimple build_type_cast (tree, gimple, tree lhs = NULL_TREE);\n+\n+#endif /* GCC_GIMPLE_BUILDER_H */"}, {"sha": "6a182700cfd5eefe227f55176c78f053338f8b47", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 224, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -30,7 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"gimple.h\"\n #include \"diagnostic.h\"\n-#include \"tree-ssa.h\"\n+#include \"tree-flow.h\"\n #include \"value-prof.h\"\n #include \"flags.h\"\n #include \"alias.h\"\n@@ -2156,39 +2156,6 @@ gimple_set_lhs (gimple stmt, tree lhs)\n     gcc_unreachable();\n }\n \n-/* Replace the LHS of STMT, an assignment, either a GIMPLE_ASSIGN or a\n-   GIMPLE_CALL, with NLHS, in preparation for modifying the RHS to an\n-   expression with a different value.\n-\n-   This will update any annotations (say debug bind stmts) referring\n-   to the original LHS, so that they use the RHS instead.  This is\n-   done even if NLHS and LHS are the same, for it is understood that\n-   the RHS will be modified afterwards, and NLHS will not be assigned\n-   an equivalent value.\n-\n-   Adjusting any non-annotation uses of the LHS, if needed, is a\n-   responsibility of the caller.\n-\n-   The effect of this call should be pretty much the same as that of\n-   inserting a copy of STMT before STMT, and then removing the\n-   original stmt, at which time gsi_remove() would have update\n-   annotations, but using this function saves all the inserting,\n-   copying and removing.  */\n-\n-void\n-gimple_replace_lhs (gimple stmt, tree nlhs)\n-{\n-  if (MAY_HAVE_DEBUG_STMTS)\n-    {\n-      tree lhs = gimple_get_lhs (stmt);\n-\n-      gcc_assert (SSA_NAME_DEF_STMT (lhs) == stmt);\n-\n-      insert_debug_temp_for_var_def (NULL, lhs);\n-    }\n-\n-  gimple_set_lhs (stmt, nlhs);\n-}\n \n /* Return a deep copy of statement STMT.  All the operands from STMT\n    are reallocated and copied using unshare_expr.  The DEF, USE, VDEF\n@@ -3739,96 +3706,6 @@ gimple_get_alias_set (tree t)\n }\n \n \n-/* Data structure used to count the number of dereferences to PTR\n-   inside an expression.  */\n-struct count_ptr_d\n-{\n-  tree ptr;\n-  unsigned num_stores;\n-  unsigned num_loads;\n-};\n-\n-/* Helper for count_uses_and_derefs.  Called by walk_tree to look for\n-   (ALIGN/MISALIGNED_)INDIRECT_REF nodes for the pointer passed in DATA.  */\n-\n-static tree\n-count_ptr_derefs (tree *tp, int *walk_subtrees, void *data)\n-{\n-  struct walk_stmt_info *wi_p = (struct walk_stmt_info *) data;\n-  struct count_ptr_d *count_p = (struct count_ptr_d *) wi_p->info;\n-\n-  /* Do not walk inside ADDR_EXPR nodes.  In the expression &ptr->fld,\n-     pointer 'ptr' is *not* dereferenced, it is simply used to compute\n-     the address of 'fld' as 'ptr + offsetof(fld)'.  */\n-  if (TREE_CODE (*tp) == ADDR_EXPR)\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (*tp) == MEM_REF && TREE_OPERAND (*tp, 0) == count_p->ptr)\n-    {\n-      if (wi_p->is_lhs)\n-\tcount_p->num_stores++;\n-      else\n-\tcount_p->num_loads++;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Count the number of direct and indirect uses for pointer PTR in\n-   statement STMT.  The number of direct uses is stored in\n-   *NUM_USES_P.  Indirect references are counted separately depending\n-   on whether they are store or load operations.  The counts are\n-   stored in *NUM_STORES_P and *NUM_LOADS_P.  */\n-\n-void\n-count_uses_and_derefs (tree ptr, gimple stmt, unsigned *num_uses_p,\n-\t\t       unsigned *num_loads_p, unsigned *num_stores_p)\n-{\n-  ssa_op_iter i;\n-  tree use;\n-\n-  *num_uses_p = 0;\n-  *num_loads_p = 0;\n-  *num_stores_p = 0;\n-\n-  /* Find out the total number of uses of PTR in STMT.  */\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, i, SSA_OP_USE)\n-    if (use == ptr)\n-      (*num_uses_p)++;\n-\n-  /* Now count the number of indirect references to PTR.  This is\n-     truly awful, but we don't have much choice.  There are no parent\n-     pointers inside INDIRECT_REFs, so an expression like\n-     '*x_1 = foo (x_1, *x_1)' needs to be traversed piece by piece to\n-     find all the indirect and direct uses of x_1 inside.  The only\n-     shortcut we can take is the fact that GIMPLE only allows\n-     INDIRECT_REFs inside the expressions below.  */\n-  if (is_gimple_assign (stmt)\n-      || gimple_code (stmt) == GIMPLE_RETURN\n-      || gimple_code (stmt) == GIMPLE_ASM\n-      || is_gimple_call (stmt))\n-    {\n-      struct walk_stmt_info wi;\n-      struct count_ptr_d count;\n-\n-      count.ptr = ptr;\n-      count.num_stores = 0;\n-      count.num_loads = 0;\n-\n-      memset (&wi, 0, sizeof (wi));\n-      wi.info = &count;\n-      walk_gimple_op (stmt, count_ptr_derefs, &wi);\n-\n-      *num_stores_p = count.num_stores;\n-      *num_loads_p = count.num_loads;\n-    }\n-\n-  gcc_assert (*num_uses_p >= *num_loads_p + *num_stores_p);\n-}\n-\n /* From a tree operand OP return the base of a load or store operation\n    or NULL_TREE if OP is not a load or a store.  */\n \n@@ -4225,106 +4102,6 @@ gimple_asm_clobbers_memory_p (const_gimple stmt)\n }\n \n \n-/* Create and return an unnamed temporary.  MODE indicates whether\n-   this should be an SSA or NORMAL temporary.  TYPE is the type to use\n-   for the new temporary.  */\n-\n-tree\n-create_gimple_tmp (tree type, enum ssa_mode mode)\n-{\n-  return (mode == M_SSA)\n-         ? make_ssa_name (type, NULL)\n-         : create_tmp_var (type, NULL);\n-}\n-\n-\n-/* Return the expression type to use based on the CODE and type of\n-   the given operand OP.  If the expression CODE is a comparison,\n-   the returned type is boolean_type_node.  Otherwise, it returns\n-   the type of OP.  */\n-\n-static tree\n-get_expr_type (enum tree_code code, tree op)\n-{\n-  return (TREE_CODE_CLASS (code) == tcc_comparison)\n-\t ? boolean_type_node\n-\t : TREE_TYPE (op);\n-}\n-\n-\n-/* Build a new gimple assignment.  The LHS of the assignment is a new\n-   temporary whose type matches the given expression.  MODE indicates\n-   whether the LHS should be an SSA or a normal temporary.  CODE is\n-   the expression code for the RHS.  OP1 is the first operand and VAL\n-   is an integer value to be used as the second operand.  */\n-\n-gimple\n-build_assign (enum tree_code code, tree op1, int val, enum ssa_mode mode)\n-{\n-  tree op2 = build_int_cst (TREE_TYPE (op1), val);\n-  tree lhs = create_gimple_tmp (get_expr_type (code, op1), mode);\n-  return gimple_build_assign_with_ops (code, lhs, op1, op2);\n-}\n-\n-gimple\n-build_assign (enum tree_code code, gimple g, int val, enum ssa_mode mode)\n-{\n-  return build_assign (code, gimple_assign_lhs (g), val, mode);\n-}\n-\n-\n-/* Build and return a new GIMPLE assignment.  The new assignment will\n-   have the opcode CODE and operands OP1 and OP2.  The type of the\n-   expression on the RHS is inferred to be the type of OP1.\n-\n-   The LHS of the statement will be an SSA name or a GIMPLE temporary\n-   in normal form depending on the type of builder invoking this\n-   function.  */\n-\n-gimple\n-build_assign (enum tree_code code, tree op1, tree op2, enum ssa_mode mode)\n-{\n-  tree lhs = create_gimple_tmp (get_expr_type (code, op1), mode);\n-  return gimple_build_assign_with_ops (code, lhs, op1, op2);\n-}\n-\n-gimple\n-build_assign (enum tree_code code, gimple op1, tree op2, enum ssa_mode mode)\n-{\n-  return build_assign (code, gimple_assign_lhs (op1), op2, mode);\n-}\n-\n-gimple\n-build_assign (enum tree_code code, tree op1, gimple op2, enum ssa_mode mode)\n-{\n-  return build_assign (code, op1, gimple_assign_lhs (op2), mode);\n-}\n-\n-gimple\n-build_assign (enum tree_code code, gimple op1, gimple op2, enum ssa_mode mode)\n-{\n-  return build_assign (code, gimple_assign_lhs (op1), gimple_assign_lhs (op2),\n-                       mode);\n-}\n-\n-\n-/* Create and return a type cast assignment. This creates a NOP_EXPR\n-   that converts OP to TO_TYPE.  */\n-\n-gimple\n-build_type_cast (tree to_type, tree op, enum ssa_mode mode)\n-{\n-  tree lhs = create_gimple_tmp (to_type, mode);\n-  return gimple_build_assign_with_ops (NOP_EXPR, lhs, op, NULL_TREE);\n-}\n-\n-gimple\n-build_type_cast (tree to_type, gimple op, enum ssa_mode mode)\n-{\n-  return build_type_cast (to_type, gimple_assign_lhs (op), mode);\n-}\n-\n-\n /* Return true if the conversion from INNER_TYPE to OUTER_TYPE is a\n    useless type conversion, otherwise return false.\n "}, {"sha": "3047ab4b66780696ca4a168ee4cf86c7ff2e7815", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -730,19 +730,6 @@ union GTY ((desc (\"gimple_statement_structure (&%h)\"),\n   struct gimple_statement_transaction GTY((tag (\"GSS_TRANSACTION\"))) gimple_transaction;\n };\n \n-/* In gimple.c.  */\n-\n-/* Helper functions to build GIMPLE statements.  */\n-tree create_gimple_tmp (tree, enum ssa_mode = M_SSA);\n-gimple build_assign (enum tree_code, tree, int, enum ssa_mode = M_SSA);\n-gimple build_assign (enum tree_code, gimple, int, enum ssa_mode = M_SSA);\n-gimple build_assign (enum tree_code, tree, tree, enum ssa_mode = M_SSA);\n-gimple build_assign (enum tree_code, gimple, tree, enum ssa_mode = M_SSA);\n-gimple build_assign (enum tree_code, tree, gimple, enum ssa_mode = M_SSA);\n-gimple build_assign (enum tree_code, gimple, gimple, enum ssa_mode = M_SSA);\n-gimple build_type_cast (tree, tree, enum ssa_mode = M_SSA);\n-gimple build_type_cast (tree, gimple, enum ssa_mode = M_SSA);\n-\n /* Offset in bytes to the location of the operand vector.\n    Zero if there is no operand vector for this tuple structure.  */\n extern size_t const gimple_ops_offset_[];\n@@ -909,8 +896,6 @@ extern void free_gimple_type_tables (void);\n extern tree gimple_unsigned_type (tree);\n extern tree gimple_signed_type (tree);\n extern alias_set_type gimple_get_alias_set (tree);\n-extern void count_uses_and_derefs (tree, gimple, unsigned *, unsigned *,\n-\t\t\t\t   unsigned *);\n extern bool walk_stmt_load_store_addr_ops (gimple, void *,\n \t\t\t\t\t   bool (*)(gimple, tree, void *),\n \t\t\t\t\t   bool (*)(gimple, tree, void *),"}, {"sha": "149e080ff194693adfcfdb15ea783bb3e5d62c47", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -608,7 +608,7 @@ execute_cse_reciprocals (void)\n \t\t  if (fail)\n \t\t    continue;\n \n-\t\t  gimple_replace_lhs (stmt1, arg1);\n+\t\t  gimple_replace_ssa_lhs (stmt1, arg1);\n \t\t  gimple_call_set_fndecl (stmt1, fndecl);\n \t\t  update_stmt (stmt1);\n \t\t  reciprocal_stats.rfuncs_inserted++;"}, {"sha": "b378f57e8f5fdccb00c895bb8d24f4f4555be77b", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -3682,7 +3682,7 @@ repropagate_negates (void)\n \t      tree a = gimple_assign_rhs1 (feed);\n \t      tree rhs2 = gimple_assign_rhs2 (user);\n \t      gimple_stmt_iterator gsi = gsi_for_stmt (feed), gsi2;\n-\t      gimple_replace_lhs (feed, negate);\n+\t      gimple_replace_ssa_lhs (feed, negate);\n \t      gimple_assign_set_rhs_with_ops (&gsi, PLUS_EXPR, a, rhs2);\n \t      update_stmt (gsi_stmt (gsi));\n \t      gsi2 = gsi_for_stmt (user);"}, {"sha": "8c340ded1af18e41ab9ff818a1c7d53a229be9b9", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -231,6 +231,135 @@ flush_pending_stmts (edge e)\n   redirect_edge_var_map_clear (e);\n }\n \n+\n+/* Data structure used to count the number of dereferences to PTR\n+   inside an expression.  */\n+struct count_ptr_d\n+{\n+  tree ptr;\n+  unsigned num_stores;\n+  unsigned num_loads;\n+};\n+\n+\n+/* Helper for count_uses_and_derefs.  Called by walk_tree to look for\n+   (ALIGN/MISALIGNED_)INDIRECT_REF nodes for the pointer passed in DATA.  */\n+\n+static tree\n+count_ptr_derefs (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct walk_stmt_info *wi_p = (struct walk_stmt_info *) data;\n+  struct count_ptr_d *count_p = (struct count_ptr_d *) wi_p->info;\n+\n+  /* Do not walk inside ADDR_EXPR nodes.  In the expression &ptr->fld,\n+     pointer 'ptr' is *not* dereferenced, it is simply used to compute\n+     the address of 'fld' as 'ptr + offsetof(fld)'.  */\n+  if (TREE_CODE (*tp) == ADDR_EXPR)\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (*tp) == MEM_REF && TREE_OPERAND (*tp, 0) == count_p->ptr)\n+    {\n+      if (wi_p->is_lhs)\n+\tcount_p->num_stores++;\n+      else\n+\tcount_p->num_loads++;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Count the number of direct and indirect uses for pointer PTR in\n+   statement STMT.  The number of direct uses is stored in\n+   *NUM_USES_P.  Indirect references are counted separately depending\n+   on whether they are store or load operations.  The counts are\n+   stored in *NUM_STORES_P and *NUM_LOADS_P.  */\n+\n+void\n+count_uses_and_derefs (tree ptr, gimple stmt, unsigned *num_uses_p,\n+\t\t       unsigned *num_loads_p, unsigned *num_stores_p)\n+{\n+  ssa_op_iter i;\n+  tree use;\n+\n+  *num_uses_p = 0;\n+  *num_loads_p = 0;\n+  *num_stores_p = 0;\n+\n+  /* Find out the total number of uses of PTR in STMT.  */\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, i, SSA_OP_USE)\n+    if (use == ptr)\n+      (*num_uses_p)++;\n+\n+  /* Now count the number of indirect references to PTR.  This is\n+     truly awful, but we don't have much choice.  There are no parent\n+     pointers inside INDIRECT_REFs, so an expression like\n+     '*x_1 = foo (x_1, *x_1)' needs to be traversed piece by piece to\n+     find all the indirect and direct uses of x_1 inside.  The only\n+     shortcut we can take is the fact that GIMPLE only allows\n+     INDIRECT_REFs inside the expressions below.  */\n+  if (is_gimple_assign (stmt)\n+      || gimple_code (stmt) == GIMPLE_RETURN\n+      || gimple_code (stmt) == GIMPLE_ASM\n+      || is_gimple_call (stmt))\n+    {\n+      struct walk_stmt_info wi;\n+      struct count_ptr_d count;\n+\n+      count.ptr = ptr;\n+      count.num_stores = 0;\n+      count.num_loads = 0;\n+\n+      memset (&wi, 0, sizeof (wi));\n+      wi.info = &count;\n+      walk_gimple_op (stmt, count_ptr_derefs, &wi);\n+\n+      *num_stores_p = count.num_stores;\n+      *num_loads_p = count.num_loads;\n+    }\n+\n+  gcc_assert (*num_uses_p >= *num_loads_p + *num_stores_p);\n+}\n+\n+\n+/* Replace the LHS of STMT, an assignment, either a GIMPLE_ASSIGN or a\n+   GIMPLE_CALL, with NLHS, in preparation for modifying the RHS to an\n+   expression with a different value.\n+\n+   This will update any annotations (say debug bind stmts) referring\n+   to the original LHS, so that they use the RHS instead.  This is\n+   done even if NLHS and LHS are the same, for it is understood that\n+   the RHS will be modified afterwards, and NLHS will not be assigned\n+   an equivalent value.\n+\n+   Adjusting any non-annotation uses of the LHS, if needed, is a\n+   responsibility of the caller.\n+\n+   The effect of this call should be pretty much the same as that of\n+   inserting a copy of STMT before STMT, and then removing the\n+   original stmt, at which time gsi_remove() would have update\n+   annotations, but using this function saves all the inserting,\n+   copying and removing.  */\n+\n+void\n+gimple_replace_ssa_lhs (gimple stmt, tree nlhs)\n+{\n+  if (MAY_HAVE_DEBUG_STMTS)\n+    {\n+      tree lhs = gimple_get_lhs (stmt);\n+\n+      gcc_assert (SSA_NAME_DEF_STMT (lhs) == stmt);\n+\n+      insert_debug_temp_for_var_def (NULL, lhs);\n+    }\n+\n+  gimple_set_lhs (stmt, nlhs);\n+}\n+\n+\n /* Given a tree for an expression for which we might want to emit\n    locations or values in debug information (generally a variable, but\n    we might deal with other kinds of trees in the future), return the"}, {"sha": "7ffb332252bf4813247641b7e5f3bbeea9ee36d0", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff2a63a749c386637ef085f7bc3102a8d8d2aab3/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "patch": "@@ -42,6 +42,9 @@ extern edge_var_map_vector *redirect_edge_var_map_vector (edge);\n extern void redirect_edge_var_map_destroy (void);\n extern edge ssa_redirect_edge (edge, basic_block);\n extern void flush_pending_stmts (edge);\n+extern void count_uses_and_derefs (tree, gimple, unsigned *, unsigned *,\n+\t\t\t\t   unsigned *);\n+extern void gimple_replace_ssa_lhs (gimple, tree);\n extern tree target_for_debug_bind (tree);\n extern void insert_debug_temp_for_var_def (gimple_stmt_iterator *, tree);\n extern void insert_debug_temps_for_defs (gimple_stmt_iterator *);"}]}