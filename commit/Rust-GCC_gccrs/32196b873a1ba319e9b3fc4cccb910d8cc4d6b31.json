{"sha": "32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIxOTZiODczYTFiYTMxOWU5YjNmYzRjY2NiOTEwZDhjYzRkNmIzMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-26T15:01:07Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-26T15:01:07Z"}, "message": "cp-tree.h (OVL_CHAIN): Check looking at OVERLOAD.\n\n\t* cp-tree.h (OVL_CHAIN): Check looking at OVERLOAD.\n\t(ovl_iterator): Add allow_inner field.  Adjust ctor.  Make\n\tunduplicatable.\n\t(ovl_iterator::maybe_push, ovl_iterator::pop): New.\n\t(lkp_iterator): Add outer field.  Adjust ctor.\n\t(lkp_iterator::operator++): New.\n\t(lookup_mark, lookup_maybe_add): Declare.\n\t* name-lookup.c (name_lookup): Delete fn_set member.\n\t(name_lookup::preserve_state, name_lookup::restore_state): Unmark\n\tand mark lookup.\n\t(name_lookup::add_value): Use lookup_add directly.\n\t(name_lookup::add_fns: Use lookup_maybe_add.\n\t(name_lookup::search_adl): Mark and unmark fns.\n\t(pushdecl): Adjust.\n\t* pt.c (check_explicit_specialization): Use lookup_add directly.\n\t* ptree.c (cxx_print_xnode): Show complete overload structure.\n\t* tree.c (lookup_mark, lookup_maybe_add): New.\n\nFrom-SVN: r248517", "tree": {"sha": "b5d1722f7346122ff6f56ed689c65ce9caf9c0fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5d1722f7346122ff6f56ed689c65ce9caf9c0fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "262149f536cdfbe64ebce8fd80958d10b7a47f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/262149f536cdfbe64ebce8fd80958d10b7a47f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/262149f536cdfbe64ebce8fd80958d10b7a47f2e"}], "stats": {"total": 236, "additions": 191, "deletions": 45}, "files": [{"sha": "b1a72ee5fb77ba17a779762e9a26a31cfc158867", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "patch": "@@ -1,5 +1,23 @@\n 2017-05-26  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (OVL_CHAIN): Check looking at OVERLOAD.\n+\t(ovl_iterator): Add allow_inner field.  Adjust ctor.  Make\n+\tunduplicatable.\n+\t(ovl_iterator::maybe_push, ovl_iterator::pop): New.\n+\t(lkp_iterator): Add outer field.  Adjust ctor.\n+\t(lkp_iterator::operator++): New.\n+\t(lookup_mark, lookup_maybe_add): Declare.\n+\t* name-lookup.c (name_lookup): Delete fn_set member.\n+\t(name_lookup::preserve_state, name_lookup::restore_state): Unmark\n+\tand mark lookup.\n+\t(name_lookup::add_value): Use lookup_add directly.\n+\t(name_lookup::add_fns: Use lookup_maybe_add.\n+\t(name_lookup::search_adl): Mark and unmark fns.\n+\t(pushdecl): Adjust.\n+\t* pt.c (check_explicit_specialization): Use lookup_add directly.\n+\t* ptree.c (cxx_print_xnode): Show complete overload structure.\n+\t* tree.c (lookup_mark, lookup_maybe_add): New.\n+\n \t* name-lookup.c (name_lookup::search_adl): ADL OMP UDR type args.\n \n 2017-05-26  Jakub Jelinek  <jakub@redhat.com>"}, {"sha": "64dca460394b627ec1d78313bce9f816533d2f0e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "patch": "@@ -657,7 +657,8 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n    Other users should use iterators and convenience functions.  */\n #define OVL_FUNCTION(NODE) \\\n   (((struct tree_overload*)OVERLOAD_CHECK (NODE))->function)\n-#define OVL_CHAIN(NODE)      TREE_CHAIN (NODE)\n+#define OVL_CHAIN(NODE) \\\n+  (((struct tree_overload*)OVERLOAD_CHECK (NODE))->common.chain)\n \n /* If set, this was imported in a using declaration.   */\n #define OVL_USING_P(NODE)\tTREE_LANG_FLAG_1 (OVERLOAD_CHECK (NODE))\n@@ -684,6 +685,9 @@ typedef struct ptrmem_cst * ptrmem_cst_t;\n #define OVL_SINGLE_P(NODE) \\\n   (TREE_CODE (NODE) != OVERLOAD || !OVL_CHAIN (NODE))\n \n+/* OVL_HIDDEN_P nodes come first, then OVL_USING_P nodes, then regular\n+   fns.  */\n+\n struct GTY(()) tree_overload {\n   struct tree_common common;\n   tree function;\n@@ -694,19 +698,19 @@ struct GTY(()) tree_overload {\n class ovl_iterator \n {\n   tree ovl;\n+  const bool allow_inner; /* Only used when checking.  */\n \n  public:\n-  ovl_iterator (tree o)\n-  :ovl (o)\n-    {}\n-\n-  ovl_iterator &operator= (const ovl_iterator &from)\n+  explicit ovl_iterator (tree o, bool allow = false)\n+    : ovl (o), allow_inner (allow)\n   {\n-    ovl = from.ovl;\n-\n-    return *this;\n   }\n \n+ private:\n+  /* Do not duplicate.  */\n+  ovl_iterator &operator= (const ovl_iterator &);\n+  ovl_iterator (const ovl_iterator &);\n+\n  public:\n   operator bool () const\n   {\n@@ -722,7 +726,7 @@ class ovl_iterator\n     tree fn = TREE_CODE (ovl) != OVERLOAD ? ovl : OVL_FUNCTION (ovl);\n \n     /* Check this is not an unexpected 2-dimensional overload.  */\n-    gcc_checking_assert (TREE_CODE (fn) != OVERLOAD);\n+    gcc_checking_assert (allow_inner || TREE_CODE (fn) != OVERLOAD);\n \n     return fn;\n   }\n@@ -748,6 +752,27 @@ class ovl_iterator\n     return reveal_node (head, ovl);\n   }\n \n+ protected:\n+  /* If we have a nested overload, point at the inner overload and\n+     return the next link on the outer one.  */\n+  tree maybe_push ()\n+  {\n+    tree r = NULL_TREE;\n+\n+    if (ovl && TREE_CODE (ovl) == OVERLOAD && OVL_NESTED_P (ovl))\n+      {\n+\tr = OVL_CHAIN (ovl);\n+\tovl = OVL_FUNCTION (ovl);\n+      }\n+    return r;\n+  }\n+  /* Restore an outer nested overload.  */\n+  void pop (tree outer)\n+  {\n+    gcc_checking_assert (!ovl);\n+    ovl = outer;\n+  }\n+\n  private:\n   /* We make these static functions to avoid the address of the\n      iterator escaping the local context.  */\n@@ -758,17 +783,33 @@ class ovl_iterator\n /* Iterator over a (potentially) 2 dimensional overload, which is\n    produced by name lookup.  */\n \n-/* Note this is currently a placeholder, as the name-lookup changes\n-   are not yet committed.  */\n-\n class lkp_iterator : public ovl_iterator\n {\n   typedef ovl_iterator parent;\n \n+  tree outer;\n+\n+ public:\n+  explicit lkp_iterator (tree o)\n+    : parent (o, true), outer (maybe_push ())\n+  {\n+  }\n+\n  public:\n-  lkp_iterator (tree o)\n-    : parent (o)\n+  lkp_iterator &operator++ ()\n   {\n+    bool repush = !outer;\n+\n+    if (!parent::operator++ () && !repush)\n+      {\n+\tpop (outer);\n+\trepush = true;\n+      }\n+\n+    if (repush)\n+      outer = maybe_push ();\n+\n+    return *this;\n   }\n };\n \n@@ -6865,7 +6906,9 @@ extern tree ovl_make\t\t\t\t(tree fn,\n extern tree ovl_insert\t\t\t\t(tree fn, tree maybe_ovl,\n \t\t\t\t\t\t bool using_p = false);\n extern tree ovl_skip_hidden\t\t\t(tree) ATTRIBUTE_PURE;\n+extern void lookup_mark\t\t\t\t(tree lookup, bool val);\n extern tree lookup_add\t\t\t\t(tree fns, tree lookup);\n+extern tree lookup_maybe_add\t\t\t(tree fns, tree lookup);\n extern void lookup_keep\t\t\t\t(tree lookup, bool keep);\n extern int is_overloaded_fn\t\t\t(tree) ATTRIBUTE_PURE;\n extern bool really_overloaded_fn\t\t(tree) ATTRIBUTE_PURE;"}, {"sha": "b85061fd843b1e4374eaaa0570e370b95db140ad", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "patch": "@@ -161,7 +161,6 @@ struct name_lookup\n   int flags;\t/* Lookup flags.  */\n   vec<tree, va_heap, vl_embed> *scopes;\n   name_lookup *previous; /* Previously active lookup.  */\n-  hash_set<tree> *fn_set;\n \n protected:\n   /* Marked scope stack for outermost name lookup.  */\n@@ -172,13 +171,12 @@ struct name_lookup\n public:\n   name_lookup (tree n, int f = 0)\n   : name (n), value (NULL_TREE), type (NULL_TREE), flags (f),\n-    scopes (NULL), previous (NULL), fn_set (NULL)\n+    scopes (NULL), previous (NULL)\n   {\n     preserve_state ();\n   }\n   ~name_lookup ()\n   {\n-    gcc_checking_assert (!fn_set);\n     restore_state ();\n   }\n \n@@ -299,6 +297,9 @@ name_lookup::preserve_state ()\n \t      previous->scopes->quick_push (decl);\n \t    }\n \t}\n+\n+      /* Unmark the outer partial lookup.  */\n+      lookup_mark (previous->value, false);\n     }\n   else\n     scopes = shared_scopes;\n@@ -322,6 +323,8 @@ name_lookup::restore_state ()\n   active = previous;\n   if (previous)\n     {\n+      free (scopes);\n+\n       unsigned length = vec_safe_length (previous->scopes);\n       for (unsigned ix = 0; ix != length; ix++)\n \t{\n@@ -345,7 +348,8 @@ name_lookup::restore_state ()\n \t  LOOKUP_SEEN_P (decl) = true;\n \t}\n \n-      free (scopes);\n+      /* Remark the outer partial lookup.  */\n+      lookup_mark (previous->value, true);\n     }\n   else\n     shared_scopes = scopes;\n@@ -403,10 +407,7 @@ name_lookup::add_value (tree new_val)\n \t    && same_type_p (TREE_TYPE (value), TREE_TYPE (new_val))))\n     ;\n   else if (OVL_P (value) && OVL_P (new_val))\n-    {\n-      for (ovl_iterator iter (new_val); iter; ++iter)\n-\tvalue = lookup_add (*iter, value);\n-    }\n+    value = lookup_add (new_val, value);\n   else\n     value = ambiguous (new_val, value);\n }\n@@ -684,9 +685,7 @@ name_lookup::add_fns (tree fns)\n     return;\n \n   /* Only add those that aren't already there.  */\n-  for (ovl_iterator iter (fns); iter; ++iter)\n-    if (!fn_set->add (*iter))\n-      value = lookup_add (*iter, value);\n+  value = lookup_maybe_add (fns, value);\n }\n \n /* Add functions of a namespace to the lookup structure.  */\n@@ -987,13 +986,9 @@ name_lookup::adl_template_arg (tree arg)\n tree\n name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n {\n+  lookup_mark (fns, true);\n   value = fns;\n \n-  /* Add the current overload set into the hash table.  */\n-  fn_set = new hash_set<tree>;\n-  for (lkp_iterator iter (fns); iter; ++iter)\n-    fn_set->add (*iter);\n-\n   unsigned ix;\n   tree arg;\n \n@@ -1005,10 +1000,8 @@ name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n     else\n       adl_expr (arg);\n \n-  delete fn_set;\n-  fn_set = NULL;\n-\n   fns = value;\n+  lookup_mark (fns, false);\n \n   return fns;\n }\n@@ -2101,7 +2094,6 @@ check_local_shadow (tree decl)\n   inform (DECL_SOURCE_LOCATION (shadowed), \"shadowed declaration is here\");\n }\n \n-\n /* DECL is being pushed inside function CTX.  Set its context, if\n    needed.  */\n \n@@ -2394,14 +2386,14 @@ do_pushdecl (tree decl, bool is_friend)\n }\n \n /* Record a decl-node X as belonging to the current lexical scope.\n-   It's a friend if IS_FRIEND is true.  */\n+   It's a friend if IS_FRIEND is true -- which affects exactly where\n+   we push it.  */\n \n tree\n pushdecl (tree x, bool is_friend)\n {\n-  tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = do_pushdecl (x, is_friend);\n+  tree ret = do_pushdecl (x, is_friend);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n@@ -4199,7 +4191,7 @@ set_namespace_binding (tree scope, tree name, tree val)\n     supplement_binding (binding, val);\n }\n \n-/* Set value binding og NAME in the global namespace to VAL.  Does not\n+/* Set value binding of NAME in the global namespace to VAL.  Does not\n    add it to the list of things in the namespace.  */\n \n void"}, {"sha": "68514c911e95edf3a29e5511cc49270c622c1682", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "patch": "@@ -2931,8 +2931,7 @@ check_explicit_specialization (tree declarator,\n \n \t\t    /* Glue all these conversion functions together\n \t\t       with those we already have.  */\n-\t\t    for (ovl_iterator iter (ovl); iter; ++iter)\n-\t\t      fns = lookup_add (*iter, fns);\n+\t\t    fns = lookup_add (ovl, fns);\n \t\t  }\n \t    }\n "}, {"sha": "a2977e86e7bdfea541762815fe992240bc054c93", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "patch": "@@ -237,8 +237,10 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n       break;\n     case OVERLOAD:\n       print_node (file, \"name\", OVL_NAME (node), indent+4);\n-      for (lkp_iterator iter (node); iter; ++iter)\n-\tprint_node (file, \"function\", *iter, indent+4);\n+      for (ovl_iterator iter (node, true); iter; ++iter)\n+\tprint_node (file,\n+\t\t    TREE_CODE (*iter) == OVERLOAD ? \"inner\" : \"function\",\n+\t\t    *iter, indent+4);\n       break;\n     case TEMPLATE_PARM_INDEX:\n       print_node (file, \"decl\", TEMPLATE_PARM_DECL (node), indent+4);"}, {"sha": "343708f430232ce564bad346cdf6648932e41aba", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32196b873a1ba319e9b3fc4cccb910d8cc4d6b31/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=32196b873a1ba319e9b3fc4cccb910d8cc4d6b31", "patch": "@@ -2150,8 +2150,8 @@ ovl_copy (tree ovl)\n }\n \n /* Add FN to the (potentially NULL) overload set OVL.  USING_P is\n-   true, if FN is via a using declaration.  Overloads are ordered as\n-   using, regular.  */\n+   true, if FN is via a using declaration.  We also pay attention to\n+   DECL_HIDDEN.  Overloads are ordered as hidden, using, regular.  */\n \n tree\n ovl_insert (tree fn, tree maybe_ovl, bool using_p)\n@@ -2287,6 +2287,29 @@ ovl_iterator::remove_node (tree overload, tree node)\n   return overload;\n }\n \n+/* Mark or unmark a lookup set. */\n+\n+void\n+lookup_mark (tree ovl, bool val)\n+{\n+  /* For every node that is a lookup, mark the thing it points to.  */\n+  for (; ovl && TREE_CODE (ovl) == OVERLOAD && OVL_LOOKUP_P (ovl);\n+       ovl = OVL_CHAIN (ovl))\n+    {\n+      tree targ = OVL_FUNCTION (ovl);\n+      gcc_checking_assert (LOOKUP_SEEN_P (targ) != val);\n+      LOOKUP_SEEN_P (targ) = val;\n+    }\n+\n+  if (ovl && (TREE_CODE (ovl) == OVERLOAD ||\n+\t      TREE_CODE (ovl) == FUNCTION_DECL))\n+    {\n+      /* Mark the overload itsef.  */\n+      gcc_checking_assert (LOOKUP_SEEN_P (ovl) != val);\n+      LOOKUP_SEEN_P (ovl) = val;\n+    }\n+}\n+\n /* Add a set of new FNS into a lookup.  */\n \n tree\n@@ -2303,6 +2326,75 @@ lookup_add (tree fns, tree lookup)\n   return lookup;\n }\n \n+/* FNS is a new overload set, add it to LOOKUP, if it is not already\n+   present there.  */\n+\n+tree\n+lookup_maybe_add (tree fns, tree lookup)\n+{\n+  if (LOOKUP_SEEN_P (fns))\n+    return lookup;\n+\n+  if (lookup && TREE_CODE (fns) == OVERLOAD)\n+    {\n+      /* Determine if we already have some part of this overload in\n+\t the overload set.  If so fix things up so we only have the\n+\t overload set once.  */\n+      tree marked = NULL_TREE;\n+\n+      for (tree probe = fns; probe; probe = OVL_CHAIN (probe))\n+\tif (LOOKUP_SEEN_P (probe))\n+\t  {\n+\t    marked = probe;\n+\t    break;\n+\t  }\n+\telse if (TREE_CODE (probe) != OVERLOAD)\n+\t  break;\n+\n+      if (marked)\n+\t{\n+\t  /* The tail of this overload is already in the lookup\n+\t     set.  Stitch out the tail case, which might involve\n+\t     copying.  */\n+\t  bool rewrite = false;\n+\n+\t  LOOKUP_SEEN_P (marked) = false;\n+\t  for (tree *prev = &lookup, probe = *prev;\n+\t       ; prev = &OVL_CHAIN (probe), probe = *prev)\n+\t    {\n+\t      if (probe == marked)\n+\t\t{\n+\t\t  *prev = NULL_TREE;\n+\t\t  break;\n+\t\t}\n+\t      gcc_checking_assert (OVL_LOOKUP_P (probe));\n+\t      if (marked == OVL_FUNCTION (probe))\n+\t\t{\n+\t\t  *prev = OVL_CHAIN (probe);\n+\t\t  break;\n+\t\t}\n+\n+\t      /* If we're in a used part of the lookup set, copy the\n+\t\t node, so as to not disturb stored uses.  */\n+\t      gcc_checking_assert (!rewrite || OVL_USED_P (probe));\n+\t      if (OVL_USED_P (probe))\n+\t\t{\n+\t\t  rewrite = true;\n+\t\t  probe = ovl_copy (probe);\n+\t\t  OVL_LOOKUP_P (probe) = true;\n+\t\t  *prev = probe;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Finally mark the new overload and prepend it to the current\n+     lookup.  */\n+  LOOKUP_SEEN_P (fns) = true;\n+\n+  return lookup_add (fns, lookup);\n+}\n+\n /* If KEEP is true, preserve the contents of a lookup so that it is\n    available for a later instantiation.  Otherwise release the LOOKUP\n    nodes for reuse.  */"}]}