{"sha": "9dfc162c47a8485b032af6af78e3790940a9d210", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRmYzE2MmM0N2E4NDg1YjAzMmFmNmFmNzhlMzc5MDk0MGE5ZDIxMA==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-05-16T08:47:59Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2014-05-16T08:47:59Z"}, "message": "[AArch64 costs 4/18] Better estimate cost of building a constant\n\ngcc/\n\n\t* config/aarch64/aarch64.c (aarch64_build_constant): Conditionally\n\temit instructions, return number of instructions which would\n\tbe emitted.\n\t(aarch64_add_constant): Update call to aarch64_build_constant.\n\t(aarch64_output_mi_thunk): Likewise.\n\t(aarch64_rtx_costs): Estimate cost of a CONST_INT, cost\n\ta CONST_DOUBLE.\n\n\nCo-Authored-By: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>\n\nFrom-SVN: r210496", "tree": {"sha": "64c86e2439dc7e841cbd6bc1e4bc11b7604381e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64c86e2439dc7e841cbd6bc1e4bc11b7604381e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dfc162c47a8485b032af6af78e3790940a9d210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfc162c47a8485b032af6af78e3790940a9d210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dfc162c47a8485b032af6af78e3790940a9d210", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dfc162c47a8485b032af6af78e3790940a9d210/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ee859b53ba2af19f58f9e58ab38da1a8a16b5d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee859b53ba2af19f58f9e58ab38da1a8a16b5d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee859b53ba2af19f58f9e58ab38da1a8a16b5d6"}], "stats": {"total": 107, "additions": 95, "deletions": 12}, "files": [{"sha": "41a39a2b8feeab26cb4a1352cfb3839ec1fd440f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc162c47a8485b032af6af78e3790940a9d210/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc162c47a8485b032af6af78e3790940a9d210/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dfc162c47a8485b032af6af78e3790940a9d210", "patch": "@@ -1,3 +1,14 @@\n+2014-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Philipp Tomsich  <philipp.tomsich@theobroma-systems.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_build_constant): Conditionally\n+\temit instructions, return number of instructions which would\n+\tbe emitted.\n+\t(aarch64_add_constant): Update call to aarch64_build_constant.\n+\t(aarch64_output_mi_thunk): Likewise.\n+\t(aarch64_rtx_costs): Estimate cost of a CONST_INT, cost\n+\ta CONST_DOUBLE.\n+\n 2014-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_rtx_costs_wrapper): New."}, {"sha": "b3e6f5c3fc28acae16e400cf3328d82188d98e3f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 84, "deletions": 12, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dfc162c47a8485b032af6af78e3790940a9d210/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dfc162c47a8485b032af6af78e3790940a9d210/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=9dfc162c47a8485b032af6af78e3790940a9d210", "patch": "@@ -2547,12 +2547,22 @@ aarch64_final_eh_return_addr (void)\n \t\t\t\t       - 2 * UNITS_PER_WORD));\n }\n \n-/* Output code to build up a constant in a register.  */\n-static void\n-aarch64_build_constant (int regnum, HOST_WIDE_INT val)\n+/* Possibly output code to build up a constant in a register.  For\n+   the benefit of the costs infrastructure, returns the number of\n+   instructions which would be emitted.  GENERATE inhibits or\n+   enables code generation.  */\n+\n+static int\n+aarch64_build_constant (int regnum, HOST_WIDE_INT val, bool generate)\n {\n+  int insns = 0;\n+\n   if (aarch64_bitmask_imm (val, DImode))\n-    emit_move_insn (gen_rtx_REG (Pmode, regnum), GEN_INT (val));\n+    {\n+      if (generate)\n+\temit_move_insn (gen_rtx_REG (Pmode, regnum), GEN_INT (val));\n+      insns = 1;\n+    }\n   else\n     {\n       int i;\n@@ -2583,27 +2593,37 @@ aarch64_build_constant (int regnum, HOST_WIDE_INT val)\n \t the same.  */\n       if (ncount < zcount)\n \t{\n-\t  emit_move_insn (gen_rtx_REG (Pmode, regnum),\n-\t\t\t  GEN_INT (val | ~(HOST_WIDE_INT) 0xffff));\n+\t  if (generate)\n+\t    emit_move_insn (gen_rtx_REG (Pmode, regnum),\n+\t\t\t    GEN_INT (val | ~(HOST_WIDE_INT) 0xffff));\n \t  tval = 0xffff;\n+\t  insns++;\n \t}\n       else\n \t{\n-\t  emit_move_insn (gen_rtx_REG (Pmode, regnum),\n-\t\t\t  GEN_INT (val & 0xffff));\n+\t  if (generate)\n+\t    emit_move_insn (gen_rtx_REG (Pmode, regnum),\n+\t\t\t    GEN_INT (val & 0xffff));\n \t  tval = 0;\n+\t  insns++;\n \t}\n \n       val >>= 16;\n \n       for (i = 16; i < 64; i += 16)\n \t{\n \t  if ((val & 0xffff) != tval)\n-\t    emit_insn (gen_insv_immdi (gen_rtx_REG (Pmode, regnum),\n-\t\t\t\t       GEN_INT (i), GEN_INT (val & 0xffff)));\n+\t    {\n+\t      if (generate)\n+\t\temit_insn (gen_insv_immdi (gen_rtx_REG (Pmode, regnum),\n+\t\t\t\t\t   GEN_INT (i),\n+\t\t\t\t\t   GEN_INT (val & 0xffff)));\n+\t      insns++;\n+\t    }\n \t  val >>= 16;\n \t}\n     }\n+  return insns;\n }\n \n static void\n@@ -2618,7 +2638,7 @@ aarch64_add_constant (int regnum, int scratchreg, HOST_WIDE_INT delta)\n \n   if (mdelta >= 4096 * 4096)\n     {\n-      aarch64_build_constant (scratchreg, delta);\n+      (void) aarch64_build_constant (scratchreg, delta, true);\n       emit_insn (gen_add3_insn (this_rtx, this_rtx, scratch_rtx));\n     }\n   else if (mdelta > 0)\n@@ -2692,7 +2712,7 @@ aarch64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t  addr = plus_constant (Pmode, temp0, vcall_offset);\n       else\n \t{\n-\t  aarch64_build_constant (IP1_REGNUM, vcall_offset);\n+\t  (void) aarch64_build_constant (IP1_REGNUM, vcall_offset, true);\n \t  addr = gen_rtx_PLUS (Pmode, temp0, temp1);\n \t}\n \n@@ -4705,6 +4725,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n   rtx op0, op1;\n   const struct cpu_cost_table *extra_cost\n     = aarch64_tune_params->insn_extra_cost;\n+  enum machine_mode mode = GET_MODE (x);\n \n   switch (code)\n     {\n@@ -4751,6 +4772,57 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t}\n       return false;\n \n+    case CONST_INT:\n+      /* If an instruction can incorporate a constant within the\n+\t instruction, the instruction's expression avoids calling\n+\t rtx_cost() on the constant.  If rtx_cost() is called on a\n+\t constant, then it is usually because the constant must be\n+\t moved into a register by one or more instructions.\n+\n+\t The exception is constant 0, which can be expressed\n+\t as XZR/WZR and is therefore free.  The exception to this is\n+\t if we have (set (reg) (const0_rtx)) in which case we must cost\n+\t the move.  However, we can catch that when we cost the SET, so\n+\t we don't need to consider that here.  */\n+      if (x == const0_rtx)\n+\t*cost = 0;\n+      else\n+\t{\n+\t  /* To an approximation, building any other constant is\n+\t     proportionally expensive to the number of instructions\n+\t     required to build that constant.  This is true whether we\n+\t     are compiling for SPEED or otherwise.  */\n+\t  *cost = COSTS_N_INSNS (aarch64_build_constant (0,\n+\t\t\t\t\t\t\t INTVAL (x),\n+\t\t\t\t\t\t\t false));\n+\t}\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (speed)\n+\t{\n+\t  /* mov[df,sf]_aarch64.  */\n+\t  if (aarch64_float_const_representable_p (x))\n+\t    /* FMOV (scalar immediate).  */\n+\t    *cost += extra_cost->fp[mode == DFmode].fpconst;\n+\t  else if (!aarch64_float_const_zero_rtx_p (x))\n+\t    {\n+\t      /* This will be a load from memory.  */\n+\t      if (mode == DFmode)\n+\t\t*cost += extra_cost->ldst.loadd;\n+\t      else\n+\t\t*cost += extra_cost->ldst.loadf;\n+\t    }\n+\t  else\n+\t    /* Otherwise this is +0.0.  We get this using MOVI d0, #0\n+\t       or MOV v0.s[0], wzr - neither of which are modeled by the\n+\t       cost tables.  Just use the default cost.  */\n+\t    {\n+\t    }\n+\t}\n+\n+      return true;\n+\n     case MEM:\n       if (speed)\n \t*cost += extra_cost->ldst.load;"}]}