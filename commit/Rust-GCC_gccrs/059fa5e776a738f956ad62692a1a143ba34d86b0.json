{"sha": "059fa5e776a738f956ad62692a1a143ba34d86b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU5ZmE1ZTc3NmE3MzhmOTU2YWQ2MjY5MmExYTE0M2JhMzRkODZiMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "sidwell@codesourcery.com", "date": "2000-01-24T12:16:59Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-01-24T12:16:59Z"}, "message": "cp-tree.h (CPTI_BAD_CAST, [...]): New cp_tree_index values.\n\n\t* cp-tree.h (CPTI_BAD_CAST, CPTI_BAD_TYPEID, CPTI_DCAST): New\n\tcp_tree_index values.\n\t(throw_bad_cast_node, throw_bad_typeid_node, dynamic_cast_node):\n\tNew global node #defines for them.\n\t* rtti.c (call_void_fn): Replace with ...\n\t(build_runtime_decl): ... new static function.\n\t(throw_bad_cast): Use throw_bad_cast_node and build_runtime_decl.\n\t(throw_bad_typeid): Use throw_bad_typeid_node and build_runtime_decl.\n\t(build_dynamic_cast_1): Always produce correctly typed result.\n\tExplicitly produce type_info addresses. Use dynamic_cast_node.\n\t* exception.cc (__throw_bad_cast): Return `void *'.\n\t(__throw_bad_typeid): Return `const type_info &'.\n\nFrom-SVN: r31585", "tree": {"sha": "df697d14090e35118e009ab8a988bd3c7fb22ff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df697d14090e35118e009ab8a988bd3c7fb22ff9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/059fa5e776a738f956ad62692a1a143ba34d86b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059fa5e776a738f956ad62692a1a143ba34d86b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059fa5e776a738f956ad62692a1a143ba34d86b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059fa5e776a738f956ad62692a1a143ba34d86b0/comments", "author": null, "committer": null, "parents": [{"sha": "f1c9d505f9a22db6ecc95516d3581c8b019b14f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c9d505f9a22db6ecc95516d3581c8b019b14f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c9d505f9a22db6ecc95516d3581c8b019b14f0"}], "stats": {"total": 112, "additions": 83, "deletions": 29}, "files": [{"sha": "0b2cda1c9211e1f3ff2a5a0f8ae9419880df4f5e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059fa5e776a738f956ad62692a1a143ba34d86b0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059fa5e776a738f956ad62692a1a143ba34d86b0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=059fa5e776a738f956ad62692a1a143ba34d86b0", "patch": "@@ -1,3 +1,18 @@\n+2000-01-24  Nathan Sidwell  <sidwell@codesourcery.com>\n+\n+\t* cp-tree.h (CPTI_BAD_CAST, CPTI_BAD_TYPEID, CPTI_DCAST): New\n+\tcp_tree_index values.\n+\t(throw_bad_cast_node, throw_bad_typeid_node, dynamic_cast_node):\n+\tNew global node #defines for them.\n+\t* rtti.c (call_void_fn): Replace with ...\n+\t(build_runtime_decl): ... new static function.\n+\t(throw_bad_cast): Use throw_bad_cast_node and build_runtime_decl.\n+\t(throw_bad_typeid): Use throw_bad_typeid_node and build_runtime_decl.\n+\t(build_dynamic_cast_1): Always produce correctly typed result.\n+\tExplicitly produce type_info addresses. Use dynamic_cast_node.\n+\t* exception.cc (__throw_bad_cast): Return `void *'.\n+\t(__throw_bad_typeid): Return `const type_info &'.\n+\n 2000-01-24  Nathan Sidwell  <sidwell@codesourcery.com>\n \n \t* cp-tree.h (get_vtable_decl): Prototype new function."}, {"sha": "564cbe36bc2c10dbc3772f7a9f9f9c081567c49d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059fa5e776a738f956ad62692a1a143ba34d86b0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059fa5e776a738f956ad62692a1a143ba34d86b0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=059fa5e776a738f956ad62692a1a143ba34d86b0", "patch": "@@ -557,6 +557,9 @@ enum cp_tree_index\n     CPTI_TERMINATE,\n     CPTI_ATEXIT,\n     CPTI_DSO_HANDLE,\n+    CPTI_BAD_CAST,\n+    CPTI_BAD_TYPEID,\n+    CPTI_DCAST,\n \n     CPTI_MAX\n };\n@@ -659,6 +662,15 @@ extern tree cp_global_trees[CPTI_MAX];\n /* A pointer to `__dso_handle'.  */\n #define dso_handle_node                 cp_global_trees[CPTI_DSO_HANDLE]\n \n+/* The declaration of __throw_bad_cast.  */\n+#define throw_bad_cast_node             cp_global_trees[CPTI_BAD_CAST]\n+\n+/* The declaration of __throw_bad_typeid.  */\n+#define throw_bad_typeid_node           cp_global_trees[CPTI_BAD_TYPEID]\n+\n+/* The declaration of the dynamic_cast runtime.  */\n+#define dynamic_cast_node               cp_global_trees[CPTI_DCAST]\n+\n /* The type of a destructor.  */\n #define cleanup_type                    cp_global_trees[CPTI_CLEANUP_TYPE]\n "}, {"sha": "d00e0f28a38fc7bf99613a4e626d0705b0616251", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059fa5e776a738f956ad62692a1a143ba34d86b0/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059fa5e776a738f956ad62692a1a143ba34d86b0/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=059fa5e776a738f956ad62692a1a143ba34d86b0", "patch": "@@ -317,16 +317,21 @@ __check_eh_spec (int n, const void **spec)\n     }\n }\n \n-extern \"C\" void\n-__throw_bad_cast (void)\n+// Helpers for rtti. Although these don't return, we give them return types so\n+// that the type system is not broken.\n+\n+extern \"C\" void *\n+__throw_bad_cast ()\n {\n   throw std::bad_cast ();\n+  return 0;\n }\n \n-extern \"C\" void\n-__throw_bad_typeid (void)\n+extern \"C\" type_info const &\n+__throw_bad_typeid ()\n {\n   throw std::bad_typeid ();\n+  return typeid (void);\n }\n \n /* Has the current exception been caught?  */"}, {"sha": "2341a229d265053c356e9d7e2544a28a6afba87f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059fa5e776a738f956ad62692a1a143ba34d86b0/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059fa5e776a738f956ad62692a1a143ba34d86b0/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=059fa5e776a738f956ad62692a1a143ba34d86b0", "patch": "@@ -35,7 +35,7 @@ Boston, MA 02111-1307, USA.  */\n \n extern struct obstack permanent_obstack;\n \n-static tree call_void_fn PROTO((const char *));\n+static tree build_runtime_decl PROTO((const char *, tree));\n static tree build_headof_sub PROTO((tree));\n static tree build_headof PROTO((tree));\n static tree get_tinfo_var PROTO((tree));\n@@ -133,20 +133,22 @@ build_headof (exp)\n \t\tcp_convert (ptrdiff_type_node, offset));\n }\n \n-/* Build a call to a generic entry point taking and returning void.  */\n+/* Build a decl to a runtime entry point taking void and returning TYPE. \n+   Although the entry point may never return, making its return type\n+   consistent is necessary.  */\n \n static tree\n-call_void_fn (name)\n+build_runtime_decl (name, type)\n      const char *name;\n+     tree type;\n {\n   tree d = get_identifier (name);\n-  tree type;\n   \n   if (IDENTIFIER_GLOBAL_VALUE (d))\n     d = IDENTIFIER_GLOBAL_VALUE (d);\n   else\n     {\n-      type = build_function_type (void_type_node, void_list_node);\n+      type = build_function_type (type, void_list_node);\n       d = build_lang_decl (FUNCTION_DECL, d, type);\n       DECL_EXTERNAL (d) = 1;\n       TREE_PUBLIC (d) = 1;\n@@ -156,7 +158,7 @@ call_void_fn (name)\n     }\n \n   mark_used (d);\n-  return build_call (d, void_type_node, NULL_TREE);\n+  return d;\n }\n \n /* Get a bad_cast node for the program to throw...\n@@ -166,13 +168,28 @@ call_void_fn (name)\n static tree\n throw_bad_cast ()\n {\n-  return call_void_fn (\"__throw_bad_cast\");\n+  if (!throw_bad_cast_node)\n+    throw_bad_cast_node = build_runtime_decl\n+        (\"__throw_bad_cast\", ptr_type_node);\n+  \n+  return build_call (throw_bad_cast_node,\n+                     TREE_TYPE (TREE_TYPE (throw_bad_cast_node)),\n+                     NULL_TREE);\n }\n \n static tree\n throw_bad_typeid ()\n {\n-  return call_void_fn (\"__throw_bad_typeid\");\n+  if (!throw_bad_typeid_node)\n+    throw_bad_typeid_node = build_runtime_decl\n+        (\"__throw_bad_typeid\",\n+         build_reference_type\n+          (build_qualified_type\n+            (type_info_type_node, TYPE_QUAL_CONST)));\n+\n+  return build_call (throw_bad_typeid_node,\n+                     TREE_TYPE (TREE_TYPE (throw_bad_typeid_node)),\n+                     NULL_TREE);\n }\n \f\n /* Return a pointer to type_info function associated with the expression EXP.\n@@ -624,9 +641,12 @@ build_dynamic_cast_1 (type, expr)\n \t      if (TREE_CODE (old_expr) == VAR_DECL\n \t\t  && TREE_CODE (TREE_TYPE (old_expr)) == RECORD_TYPE)\n \t\t{\n+\t          tree expr = throw_bad_cast ();\n \t\t  cp_warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n \t\t\t      old_expr, type);\n-\t\t  return throw_bad_cast ();\n+\t          /* Bash it to the expected type.  */\n+\t          TREE_TYPE (expr) = type;\n+\t\t  return expr;\n \t\t}\n \t    }\n \t  /* Ditto for dynamic_cast<D*>(&b).  */\n@@ -658,12 +678,11 @@ build_dynamic_cast_1 (type, expr)\n \t    td1 = get_tinfo_decl_dynamic (build_indirect_ref (expr, NULL_PTR));\n \t  else\n \t    td1 = get_tinfo_decl_dynamic (expr);\n-\t  td1 = decay_conversion (td1);\n \t  \n \t  target_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n \t  static_type = TYPE_MAIN_VARIANT (TREE_TYPE (exprtype));\n-\t  td2 = decay_conversion (get_tinfo_decl (target_type));\n-\t  td3 = decay_conversion (get_tinfo_decl (static_type));\n+\t  td2 = build_unary_op (ADDR_EXPR, get_tinfo_decl (target_type), 0);\n+\t  td3 = build_unary_op (ADDR_EXPR, get_tinfo_decl (static_type), 0);\n \n           /* Determine how T and V are related.  */\n           boff = get_dynamic_cast_base_type (static_type, target_type);\n@@ -676,29 +695,32 @@ build_dynamic_cast_1 (type, expr)\n \t        (NULL_TREE, td3, tree_cons\n \t\t (NULL_TREE, expr1, NULL_TREE))))));\n \n-\t  dcast_fn = get_identifier (\"__dynamic_cast_2\");\n-\t  if (IDENTIFIER_GLOBAL_VALUE (dcast_fn))\n-\t    dcast_fn = IDENTIFIER_GLOBAL_VALUE (dcast_fn);\n-\t  else\n+\t  dcast_fn = dynamic_cast_node;\n+\t  if (!dcast_fn)\n \t    {\n \t      tree tmp;\n-\n+\t      tree tinfo_ptr = build_pointer_type (tinfo_decl_type);\n+  \t      \n \t      tmp = tree_cons\n-\t\t(NULL_TREE, TREE_TYPE (td1), tree_cons\n-\t\t (NULL_TREE, TREE_TYPE (td1), tree_cons\n-\t          (NULL_TREE, integer_type_node, tree_cons\n-\t\t   (NULL_TREE, ptr_type_node, tree_cons\n-\t\t    (NULL_TREE, TREE_TYPE (td1), tree_cons\n-\t\t     (NULL_TREE, ptr_type_node, void_list_node))))));\n+\t\t    (NULL_TREE, tinfo_ptr, tree_cons\n+\t\t      (NULL_TREE, tinfo_ptr, tree_cons\n+\t                (NULL_TREE, integer_type_node, tree_cons\n+\t\t          (NULL_TREE, ptr_type_node, tree_cons\n+\t\t            (NULL_TREE, tinfo_ptr, tree_cons\n+\t\t              (NULL_TREE, ptr_type_node, void_list_node))))));\n+\n \t      tmp = build_function_type (ptr_type_node, tmp);\n-\t      dcast_fn = build_lang_decl (FUNCTION_DECL, dcast_fn, tmp);\n+\t      dcast_fn = build_lang_decl (FUNCTION_DECL,\n+\t                                  get_identifier (\"__dynamic_cast_2\"),\n+\t                                  tmp);\n \t      DECL_EXTERNAL (dcast_fn) = 1;\n \t      TREE_PUBLIC (dcast_fn) = 1;\n \t      DECL_ARTIFICIAL (dcast_fn) = 1;\n \t      pushdecl_top_level (dcast_fn);\n \t      make_function_rtl (dcast_fn);\n+\t      \n+\t      dynamic_cast_node = dcast_fn;\n \t    }\n-\t  \n \t  mark_used (dcast_fn);\n           result = build_call\n \t    (dcast_fn, TREE_TYPE (TREE_TYPE (dcast_fn)), elems);"}]}