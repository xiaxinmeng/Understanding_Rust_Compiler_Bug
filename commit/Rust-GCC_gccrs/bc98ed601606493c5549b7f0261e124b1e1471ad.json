{"sha": "bc98ed601606493c5549b7f0261e124b1e1471ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5OGVkNjAxNjA2NDkzYzU1NDliN2YwMjYxZTEyNGIxZTE0NzFhZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-09-02T14:04:06Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-09-02T14:04:06Z"}, "message": "re PR fortran/45186 (Gfortran 4.5.0 emits wrong linenumbers)\n\n2010-09-02  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45186\n        * trans-common.c (create_common): Change build[0-9] to\n        build[0-9]_loc.\n        * trans-const.c (gfc_conv_constant_to_tree,\n        gfc_conv_constant_to_tree): Ditto.\n        * trans-decl.c (gfc_build_qualified_array, build_entry_thunks,\n        gfc_get_fake_result_decl, gfc_trans_auto_character_variable,\n        add_argument_checking, create_main_function,\n        gfc_generate_return): Ditto.\n        * trans-types.c (gfc_get_dtype, gfc_get_array_type_bounds):\n        * Ditto.\n        * trans-stmt.c (allocate_temp_for_forall_nest_1,\n        compute_inner_temp_size, compute_overall_iter_number,\n        generate_loop_for_rhs_to_temp, generate_loop_for_temp_to_lhs,\n        gfc_conv_elemental_dependencies, gfc_do_allocate,\n        gfc_evaluate_where_mask, gfc_trans_allocate,\n        gfc_trans_arithmetic_if, gfc_trans_call,\n        gfc_trans_character_select, gfc_trans_deallocate,\n        gfc_trans_do, gfc_trans_do_while, gfc_trans_forall_1,\n        gfc_trans_forall_loop, gfc_trans_goto, gfc_trans_if_1,\n        gfc_trans_integer_select, gfc_trans_logical_select,\n        gfc_trans_pointer_assign_need_temp, gfc_trans_return,\n        gfc_trans_simple_do, gfc_trans_sync, gfc_trans_where_2,\n        gfc_trans_where_assign) Ditto.\n\nFrom-SVN: r163776", "tree": {"sha": "02bcde35de036e554b07d7c293359406a8db0ee1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02bcde35de036e554b07d7c293359406a8db0ee1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc98ed601606493c5549b7f0261e124b1e1471ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc98ed601606493c5549b7f0261e124b1e1471ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc98ed601606493c5549b7f0261e124b1e1471ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc98ed601606493c5549b7f0261e124b1e1471ad/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6b8c9df82298ae20f04f5774c8572539159de0f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8c9df82298ae20f04f5774c8572539159de0f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8c9df82298ae20f04f5774c8572539159de0f3"}], "stats": {"total": 563, "additions": 326, "deletions": 237}, "files": [{"sha": "61f57f1ac8ed82ab75dcaee1d23961bb6ae7a78d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bc98ed601606493c5549b7f0261e124b1e1471ad", "patch": "@@ -1,3 +1,29 @@\n+2010-09-02  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/45186\n+\t* trans-common.c (create_common): Change build[0-9] to\n+\tbuild[0-9]_loc.\n+\t* trans-const.c (gfc_conv_constant_to_tree,\n+\tgfc_conv_constant_to_tree): Ditto.\n+\t* trans-decl.c (gfc_build_qualified_array, build_entry_thunks,\n+\tgfc_get_fake_result_decl, gfc_trans_auto_character_variable,\n+\tadd_argument_checking, create_main_function,\n+\tgfc_generate_return): Ditto.\n+\t* trans-types.c (gfc_get_dtype, gfc_get_array_type_bounds): Ditto.\n+\t* trans-stmt.c (allocate_temp_for_forall_nest_1,\n+\tcompute_inner_temp_size, compute_overall_iter_number,\n+\tgenerate_loop_for_rhs_to_temp, generate_loop_for_temp_to_lhs,\n+\tgfc_conv_elemental_dependencies, gfc_do_allocate,\n+\tgfc_evaluate_where_mask, gfc_trans_allocate,\n+\tgfc_trans_arithmetic_if, gfc_trans_call,\n+\tgfc_trans_character_select, gfc_trans_deallocate,\n+\tgfc_trans_do, gfc_trans_do_while, gfc_trans_forall_1,\n+\tgfc_trans_forall_loop, gfc_trans_goto, gfc_trans_if_1,\n+\tgfc_trans_integer_select, gfc_trans_logical_select,\n+\tgfc_trans_pointer_assign_need_temp, gfc_trans_return,\n+\tgfc_trans_simple_do, gfc_trans_sync, gfc_trans_where_2,\n+\tgfc_trans_where_assign) Ditto.\n+\n 2010-09-02  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44541"}, {"sha": "486fbbbb3de343a54ac68cb04597697d4bc8216d", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=bc98ed601606493c5549b7f0261e124b1e1471ad", "patch": "@@ -703,8 +703,9 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n \tgfc_add_decl_to_function (var_decl);\n \n       SET_DECL_VALUE_EXPR (var_decl,\n-\t\t\t   fold_build3 (COMPONENT_REF, TREE_TYPE (s->field),\n-\t\t\t\t\tdecl, s->field, NULL_TREE));\n+\t\t\t   fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t    TREE_TYPE (s->field),\n+\t\t\t\t\t    decl, s->field, NULL_TREE));\n       DECL_HAS_VALUE_EXPR_P (var_decl) = 1;\n       GFC_DECL_COMMON_OR_EQUIV (var_decl) = 1;\n "}, {"sha": "51bc02011187e1cb6fffd4925732a750c9ca66de", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=bc98ed601606493c5549b7f0261e124b1e1471ad", "patch": "@@ -266,29 +266,29 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n     {\n     case BT_INTEGER:\n       if (expr->representation.string)\n-\treturn fold_build1 (VIEW_CONVERT_EXPR,\n-\t\t\t    gfc_get_int_type (expr->ts.kind),\n-\t\t\t    gfc_build_string_const (expr->representation.length,\n-\t\t\t\t\t\t    expr->representation.string));\n+\treturn fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t gfc_get_int_type (expr->ts.kind),\n+\t\t\t gfc_build_string_const (expr->representation.length,\n+\t\t\t\t\t\t expr->representation.string));\n       else\n \treturn gfc_conv_mpz_to_tree (expr->value.integer, expr->ts.kind);\n \n     case BT_REAL:\n       if (expr->representation.string)\n-\treturn fold_build1 (VIEW_CONVERT_EXPR,\n-\t\t\t    gfc_get_real_type (expr->ts.kind),\n-\t\t\t    gfc_build_string_const (expr->representation.length,\n-\t\t\t\t\t\t    expr->representation.string));\n+\treturn fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t gfc_get_real_type (expr->ts.kind),\n+\t\t\t gfc_build_string_const (expr->representation.length,\n+\t\t\t\t\t\t expr->representation.string));\n       else\n \treturn gfc_conv_mpfr_to_tree (expr->value.real, expr->ts.kind, expr->is_snan);\n \n     case BT_LOGICAL:\n       if (expr->representation.string)\n \t{\n-\t  tree tmp = fold_build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t  gfc_get_int_type (expr->ts.kind),\n-\t\t\t\t  gfc_build_string_const (expr->representation.length,\n-\t\t\t\t\t\t\t  expr->representation.string));\n+\t  tree tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\tgfc_get_int_type (expr->ts.kind),\n+\t\t\tgfc_build_string_const (expr->representation.length,\n+\t\t\t\t\t\texpr->representation.string));\n \t  if (!integer_zerop (tmp) && !integer_onep (tmp))\n \t    gfc_warning (\"Assigning value other than 0 or 1 to LOGICAL\"\n \t\t\t \" has undefined result at %L\", &expr->where);\n@@ -300,10 +300,10 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n \n     case BT_COMPLEX:\n       if (expr->representation.string)\n-\treturn fold_build1 (VIEW_CONVERT_EXPR,\n-\t\t\t    gfc_get_complex_type (expr->ts.kind),\n-\t\t\t    gfc_build_string_const (expr->representation.length,\n-\t\t\t\t\t\t    expr->representation.string));\n+\treturn fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t gfc_get_complex_type (expr->ts.kind),\n+\t\t\t gfc_build_string_const (expr->representation.length,\n+\t\t\t\t\t\t expr->representation.string));\n       else\n \t{\n \t  tree real = gfc_conv_mpfr_to_tree (mpc_realref (expr->value.complex),"}, {"sha": "3514adaa83e0c0722f0d6af69bca499f6f044286", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=bc98ed601606493c5549b7f0261e124b1e1471ad", "patch": "@@ -724,8 +724,8 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n     {\n       tree size, range;\n \n-      size = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t  GFC_TYPE_ARRAY_SIZE (type), gfc_index_one_node);\n+      size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t      GFC_TYPE_ARRAY_SIZE (type), gfc_index_one_node);\n       range = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n \t\t\t\tsize);\n       TYPE_DOMAIN (type) = range;\n@@ -2108,8 +2108,8 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n \t  pushdecl (union_decl);\n \n \t  DECL_CONTEXT (union_decl) = current_function_decl;\n-\t  tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (union_decl),\n-\t\t\t     union_decl, tmp);\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t TREE_TYPE (union_decl), union_decl, tmp);\n \t  gfc_add_expr_to_block (&body, tmp);\n \n \t  for (field = TYPE_FIELDS (TREE_TYPE (union_decl));\n@@ -2118,17 +2118,18 @@ build_entry_thunks (gfc_namespace * ns, bool global)\n \t\tthunk_sym->result->name) == 0)\n \t      break;\n \t  gcc_assert (field != NULL_TREE);\n-\t  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t\t     union_decl, field, NULL_TREE);\n-\t  tmp = fold_build2 (MODIFY_EXPR, \n+\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t TREE_TYPE (field), union_decl, field,\n+\t\t\t\t NULL_TREE);\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, \n \t\t\t     TREE_TYPE (DECL_RESULT (current_function_decl)),\n \t\t\t     DECL_RESULT (current_function_decl), tmp);\n \t  tmp = build1_v (RETURN_EXPR, tmp);\n \t}\n       else if (TREE_TYPE (DECL_RESULT (current_function_decl))\n \t       != void_type_node)\n \t{\n-\t  tmp = fold_build2 (MODIFY_EXPR,\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t     TREE_TYPE (DECL_RESULT (current_function_decl)),\n \t\t\t     DECL_RESULT (current_function_decl), tmp);\n \t  tmp = build1_v (RETURN_EXPR, tmp);\n@@ -2256,8 +2257,8 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n \t      break;\n \n \t  gcc_assert (field != NULL_TREE);\n-\t  decl = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t\t      decl, field, NULL_TREE);\n+\t  decl = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t  TREE_TYPE (field), decl, field, NULL_TREE);\n \t}\n \n       var = create_tmp_var_raw (TREE_TYPE (decl), sym->name);\n@@ -2949,7 +2950,7 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, gfc_wrapped_block * block)\n \n   /* Emit a DECL_EXPR for this variable, which will cause the\n      gimplifier to allocate storage, and all that good stuff.  */\n-  tmp = fold_build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n+  tmp = fold_build1_loc (input_location, DECL_EXPR, TREE_TYPE (decl), decl);\n   gfc_add_expr_to_block (&init, tmp);\n \n   gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);\n@@ -4198,27 +4199,29 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n \t/* Build the condition.  For optional arguments, an actual length\n \t   of 0 is also acceptable if the associated string is NULL, which\n \t   means the argument was not passed.  */\n-\tcond = fold_build2 (comparison, boolean_type_node,\n-\t\t\t    cl->passed_length, cl->backend_decl);\n+\tcond = fold_build2_loc (input_location, comparison, boolean_type_node,\n+\t\t\t\tcl->passed_length, cl->backend_decl);\n \tif (fsym->attr.optional)\n \t  {\n \t    tree not_absent;\n \t    tree not_0length;\n \t    tree absent_failed;\n \n-\t    not_0length = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t       cl->passed_length,\n-\t\t\t\t       fold_convert (gfc_charlen_type_node,\n-\t\t\t\t\t\t     integer_zero_node));\n+\t    not_0length = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   cl->passed_length,\n+\t\t\t\t\t   fold_convert (gfc_charlen_type_node,\n+\t\t\t\t\t\t\t integer_zero_node));\n \t    /* The symbol needs to be referenced for gfc_get_symbol_decl.  */\n \t    fsym->attr.referenced = 1;\n \t    not_absent = gfc_conv_expr_present (fsym);\n \n-\t    absent_failed = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t\t not_0length, not_absent);\n+\t    absent_failed = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t\t     boolean_type_node, not_0length,\n+\t\t\t\t\t     not_absent);\n \n-\t    cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\tcond, absent_failed);\n+\t    cond = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t    boolean_type_node, cond, absent_failed);\n \t  }\n \n \t/* Build the runtime check.  */\n@@ -4431,8 +4434,9 @@ create_main_function (tree fndecl)\n   TREE_USED (fndecl) = 1;\n \n   /* \"return 0\".  */\n-  tmp = fold_build2 (MODIFY_EXPR, integer_type_node, DECL_RESULT (ftn_main),\n-\t\t     build_int_cst (integer_type_node, 0));\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, integer_type_node,\n+\t\t\t DECL_RESULT (ftn_main),\n+\t\t\t build_int_cst (integer_type_node, 0));\n   tmp = build1_v (RETURN_EXPR, tmp);\n   gfc_add_expr_to_block (&body, tmp);\n \n@@ -4503,8 +4507,9 @@ gfc_generate_return (void)\n       if (result != NULL_TREE)\n \t{\n \t  result = convert (TREE_TYPE (DECL_RESULT (fndecl)), result);\n-\t  result = fold_build2 (MODIFY_EXPR, TREE_TYPE (result),\n-\t\t\t\tDECL_RESULT (fndecl), result);\n+\t  result = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t    TREE_TYPE (result), DECL_RESULT (fndecl),\n+\t\t\t\t    result);\n \t}\n     }\n "}, {"sha": "4c6136226877e6f62a5469bbacac0bec34e45f06", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 239, "deletions": 186, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=bc98ed601606493c5549b7f0261e124b1e1471ad", "patch": "@@ -149,8 +149,8 @@ gfc_trans_goto (gfc_code * code)\n   gfc_start_block (&se.pre);\n   gfc_conv_label_variable (&se, code->expr1);\n   tmp = GFC_DECL_STRING_LEN (se.expr);\n-  tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n-\t\t     build_int_cst (TREE_TYPE (tmp), -1));\n+  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+\t\t\t build_int_cst (TREE_TYPE (tmp), -1));\n   gfc_trans_runtime_check (true, false, tmp, &se.pre, &loc,\n \t\t\t   \"Assigned label is not a target label\");\n \n@@ -162,7 +162,8 @@ gfc_trans_goto (gfc_code * code)\n      that's a very fragile business and may break with optimization.  So\n      just ignore it.  */\n \n-  target = fold_build1 (GOTO_EXPR, void_type_node, assigned_goto);\n+  target = fold_build1_loc (input_location, GOTO_EXPR, void_type_node,\n+\t\t\t    assigned_goto);\n   gfc_add_expr_to_block (&se.pre, target);\n   return gfc_finish_block (&se.pre);\n }\n@@ -321,10 +322,11 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t    {\n \t      tmp = gfc_conv_descriptor_stride_get (info->descriptor,\n \t\t\t\t\t\t    gfc_rank_cst[n]);\n-\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t loopse->loop->from[n], tmp);\n-\t      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t    offset, tmp);\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     loopse->loop->from[n], tmp);\n+\t      offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\tgfc_array_index_type, offset, tmp);\n \t    }\n \t  info->offset = gfc_create_var (gfc_array_index_type, NULL);\t  \n \t  gfc_add_modify (&se->pre, info->offset, offset);\n@@ -452,8 +454,8 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \t  index = count1;\n \t  maskexpr = gfc_build_array_ref (mask, index, NULL);\n \t  if (invert)\n-\t    maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr),\n-\t\t\t\t    maskexpr);\n+\t    maskexpr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t\t\tTREE_TYPE (maskexpr), maskexpr);\n \t}\n \n       /* Add the subroutine call to the block.  */\n@@ -465,8 +467,9 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \t  tmp = build3_v (COND_EXPR, maskexpr, loopse.expr,\n \t\t\t  build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&loopse.pre, tmp);\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     count1, gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t count1, gfc_index_one_node);\n \t  gfc_add_modify (&loopse.pre, count1, tmp);\n \t}\n       else\n@@ -520,8 +523,9 @@ gfc_trans_return (gfc_code * code)\n       /* Note that the actually returned expression is a simple value and\n \t does not depend on any pointers or such; thus we can clean-up with\n \t se.post before returning.  */\n-      tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (result), result,\n-\t\t\t fold_convert (TREE_TYPE (result), se.expr));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, TREE_TYPE (result),\n+\t\t\t     result, fold_convert (TREE_TYPE (result),\n+\t\t\t     se.expr));\n       gfc_add_expr_to_block (&se.pre, tmp);\n       gfc_add_block_to_block (&se.pre, &se.post);\n \n@@ -644,8 +648,8 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type __attribute__ ((unused)))\n     {\n       tree cond;\n       gfc_conv_expr (&se, code->expr1);\n-      cond = fold_build2 (NE_EXPR, boolean_type_node, se.expr,\n-\t\t\t  build_int_cst (TREE_TYPE (se.expr), 1));\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      se.expr, build_int_cst (TREE_TYPE (se.expr), 1));\n       gfc_trans_runtime_check (true, false, cond, &se.pre,\n \t\t\t       &code->expr1->where, \"Invalid image number \"\n \t\t\t       \"%d in SYNC IMAGES\",\n@@ -734,7 +738,8 @@ gfc_trans_if_1 (gfc_code * code)\n     elsestmt = build_empty_stmt (input_location);\n \n   /* Build the condition expression and add it to the condition block.  */\n-  stmt = fold_build3 (COND_EXPR, void_type_node, if_se.expr, stmt, elsestmt);\n+  stmt = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t  if_se.expr, stmt, elsestmt);\n   \n   gfc_add_expr_to_block (&if_se.pre, stmt);\n \n@@ -803,11 +808,14 @@ gfc_trans_arithmetic_if (gfc_code * code)\n       branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label2));\n \n       if (code->label1->value != code->label3->value)\n-        tmp = fold_build2 (LT_EXPR, boolean_type_node, se.expr, zero);\n+        tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       se.expr, zero);\n       else\n-        tmp = fold_build2 (NE_EXPR, boolean_type_node, se.expr, zero);\n+        tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       se.expr, zero);\n \n-      branch1 = fold_build3 (COND_EXPR, void_type_node, tmp, branch1, branch2);\n+      branch1 = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t tmp, branch1, branch2);\n     }\n   else\n     branch1 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label1));\n@@ -817,8 +825,10 @@ gfc_trans_arithmetic_if (gfc_code * code)\n     {\n       /* if (cond <= 0) take branch1 else take branch2.  */\n       branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label3));\n-      tmp = fold_build2 (LE_EXPR, boolean_type_node, se.expr, zero);\n-      branch1 = fold_build3 (COND_EXPR, void_type_node, tmp, branch1, branch2);\n+      tmp = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+\t\t\t     se.expr, zero);\n+      branch1 = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t tmp, branch1, branch2);\n     }\n \n   /* Append the COND_EXPR to the evaluation of COND, and return.  */\n@@ -948,7 +958,8 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   /* Check whether someone has modified the loop variable. */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, dovar, saved_dovar);\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t     dovar, saved_dovar);\n       gfc_trans_runtime_check (true, false, tmp, &body, &code->loc,\n \t\t\t       \"Loop variable has been modified\");\n     }\n@@ -957,17 +968,19 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   if (exit_cond)\n     {\n       tmp = build1_v (GOTO_EXPR, exit_label);\n-      tmp = fold_build3 (COND_EXPR, void_type_node, exit_cond, tmp,\n-\t\t\t build_empty_stmt (input_location));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     exit_cond, tmp,\n+\t\t\t     build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n   /* Evaluate the loop condition.  */\n-  cond = fold_build2 (EQ_EXPR, boolean_type_node, dovar, to);\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, dovar,\n+\t\t\t  to);\n   cond = gfc_evaluate_now (cond, &body);\n \n   /* Increment the loop variable.  */\n-  tmp = fold_build2 (PLUS_EXPR, type, dovar, step);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, dovar, step);\n   gfc_add_modify (&body, dovar, tmp);\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n@@ -976,8 +989,8 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   /* The loop exit.  */\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n-  tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond, tmp, build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Finish the loop body.  */\n@@ -986,11 +999,13 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n \n   /* Only execute the loop if the number of iterations is positive.  */\n   if (tree_int_cst_sgn (step) > 0)\n-    cond = fold_build2 (LE_EXPR, boolean_type_node, dovar, to);\n+    cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, dovar,\n+\t\t\t    to);\n   else\n-    cond = fold_build2 (GE_EXPR, boolean_type_node, dovar, to);\n-  tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond, tmp, build_empty_stmt (input_location));\n+    cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, dovar,\n+\t\t\t    to);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n+\t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (pblock, tmp);\n \n   /* Add the exit label.  */\n@@ -1080,8 +1095,8 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n-      tmp = fold_build2 (EQ_EXPR, boolean_type_node, step,\n-\t\t\t fold_convert (type, integer_zero_node));\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, step,\n+\t\t\t     fold_convert (type, integer_zero_node));\n       gfc_trans_runtime_check (true, false, tmp, &block, &code->loc,\n \t\t\t       \"DO step value is zero\");\n     }\n@@ -1092,8 +1107,8 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \t|| tree_int_cst_equal (step, integer_minus_one_node)))\n     return gfc_trans_simple_do (code, &block, dovar, from, to, step, exit_cond);\n \n-  pos_step = fold_build2 (GT_EXPR, boolean_type_node, step,\n-\t\t\t  fold_convert (type, integer_zero_node));\n+  pos_step = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, step,\n+\t\t\t      fold_convert (type, integer_zero_node));\n \n   if (TREE_CODE (type) == INTEGER_TYPE)\n     utype = unsigned_type_for (type);\n@@ -1139,36 +1154,43 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n       /* Calculate SIGN (1,step), as (step < 0 ? -1 : 1)  */\n \n-      tmp = fold_build2 (LT_EXPR, boolean_type_node, step, \n-\t\t\t build_int_cst (TREE_TYPE (step), 0));\n-      step_sign = fold_build3 (COND_EXPR, type, tmp, \n-\t\t\t       build_int_cst (type, -1), \n-\t\t\t       build_int_cst (type, 1));\n+      tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, step,\n+\t\t\t     build_int_cst (TREE_TYPE (step), 0));\n+      step_sign = fold_build3_loc (input_location, COND_EXPR, type, tmp, \n+\t\t\t\t   build_int_cst (type, -1), \n+\t\t\t\t   build_int_cst (type, 1));\n \n-      tmp = fold_build2 (LT_EXPR, boolean_type_node, to, from);\n-      pos = fold_build3 (COND_EXPR, void_type_node, tmp,\n-\t\t\t build1_v (GOTO_EXPR, exit_label),\n-\t\t\t build_empty_stmt (input_location));\n+      tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, to,\n+\t\t\t     from);\n+      pos = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n+\t\t\t     build1_v (GOTO_EXPR, exit_label),\n+\t\t\t     build_empty_stmt (input_location));\n \n-      tmp = fold_build2 (GT_EXPR, boolean_type_node, to, from);\n-      neg = fold_build3 (COND_EXPR, void_type_node, tmp,\n-\t\t\t build1_v (GOTO_EXPR, exit_label),\n-\t\t\t build_empty_stmt (input_location));\n-      tmp = fold_build3 (COND_EXPR, void_type_node, pos_step, pos, neg);\n+      tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, to,\n+\t\t\t     from);\n+      neg = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n+\t\t\t     build1_v (GOTO_EXPR, exit_label),\n+\t\t\t     build_empty_stmt (input_location));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     pos_step, pos, neg);\n \n       gfc_add_expr_to_block (&block, tmp);\n \n       /* Calculate the loop count.  to-from can overflow, so\n \t we cast to unsigned.  */\n \n-      to2 = fold_build2 (MULT_EXPR, type, step_sign, to);\n-      from2 = fold_build2 (MULT_EXPR, type, step_sign, from);\n-      step2 = fold_build2 (MULT_EXPR, type, step_sign, step);\n+      to2 = fold_build2_loc (input_location, MULT_EXPR, type, step_sign, to);\n+      from2 = fold_build2_loc (input_location, MULT_EXPR, type, step_sign,\n+\t\t\t       from);\n+      step2 = fold_build2_loc (input_location, MULT_EXPR, type, step_sign,\n+\t\t\t       step);\n       step2 = fold_convert (utype, step2);\n-      tmp = fold_build2 (MINUS_EXPR, type, to2, from2);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, type, to2, from2);\n       tmp = fold_convert (utype, tmp);\n-      tmp = fold_build2 (TRUNC_DIV_EXPR, utype, tmp, step2);\n-      tmp = fold_build2 (MODIFY_EXPR, void_type_node, countm1, tmp);\n+      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, utype, tmp,\n+\t\t\t     step2);\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t     countm1, tmp);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   else\n@@ -1177,18 +1199,21 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \t This would probably cause more problems that it solves\n \t when we implement \"long double\" types.  */\n \n-      tmp = fold_build2 (MINUS_EXPR, type, to, from);\n-      tmp = fold_build2 (RDIV_EXPR, type, tmp, step);\n-      tmp = fold_build1 (FIX_TRUNC_EXPR, utype, tmp);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, type, to, from);\n+      tmp = fold_build2_loc (input_location, RDIV_EXPR, type, tmp, step);\n+      tmp = fold_build1_loc (input_location, FIX_TRUNC_EXPR, utype, tmp);\n       gfc_add_modify (&block, countm1, tmp);\n \n       /* We need a special check for empty loops:\n \t empty = (step > 0 ? to < from : to > from);  */\n-      tmp = fold_build3 (COND_EXPR, boolean_type_node, pos_step,\n-\t\t\t fold_build2 (LT_EXPR, boolean_type_node, to, from),\n-\t\t\t fold_build2 (GT_EXPR, boolean_type_node, to, from));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, boolean_type_node,\n+\t\t\t     pos_step,\n+\t\t\t     fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t\t      boolean_type_node, to, from),\n+\t\t\t     fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t\t      boolean_type_node, to, from));\n       /* If the loop is empty, go directly to the exit label.  */\n-      tmp = fold_build3 (COND_EXPR, void_type_node, tmp,\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n \t\t\t build1_v (GOTO_EXPR, exit_label),\n \t\t\t build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n@@ -1216,7 +1241,8 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   /* Check whether someone has modified the loop variable. */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, dovar, saved_dovar);\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, dovar,\n+\t\t\t     saved_dovar);\n       gfc_trans_runtime_check (true, false, tmp, &body, &code->loc,\n \t\t\t       \"Loop variable has been modified\");\n     }\n@@ -1225,28 +1251,30 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   if (exit_cond)\n     {\n       tmp = build1_v (GOTO_EXPR, exit_label);\n-      tmp = fold_build3 (COND_EXPR, void_type_node, exit_cond, tmp,\n-\t\t\t build_empty_stmt (input_location));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     exit_cond, tmp,\n+\t\t\t     build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n   /* Increment the loop variable.  */\n-  tmp = fold_build2 (PLUS_EXPR, type, dovar, step);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, dovar, step);\n   gfc_add_modify (&body, dovar, tmp);\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     gfc_add_modify (&body, saved_dovar, dovar);\n \n   /* End with the loop condition.  Loop until countm1 == 0.  */\n-  cond = fold_build2 (EQ_EXPR, boolean_type_node, countm1,\n-\t\t      build_int_cst (utype, 0));\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, countm1,\n+\t\t\t  build_int_cst (utype, 0));\n   tmp = build1_v (GOTO_EXPR, exit_label);\n-  tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond, tmp, build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Decrement the loop count.  */\n-  tmp = fold_build2 (MINUS_EXPR, utype, countm1, build_int_cst (utype, 1));\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, utype, countm1,\n+\t\t\t build_int_cst (utype, 1));\n   gfc_add_modify (&body, countm1, tmp);\n \n   /* End of loop body.  */\n@@ -1311,13 +1339,14 @@ gfc_trans_do_while (gfc_code * code)\n   gfc_init_se (&cond, NULL);\n   gfc_conv_expr_val (&cond, code->expr1);\n   gfc_add_block_to_block (&block, &cond.pre);\n-  cond.expr = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, cond.expr);\n+  cond.expr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t       boolean_type_node, cond.expr);\n \n   /* Build \"IF (! cond) GOTO exit_label\".  */\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n-  tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond.expr, tmp, build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t cond.expr, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* The main body of the loop.  */\n@@ -1470,8 +1499,8 @@ gfc_trans_integer_select (gfc_code * code)\n \n \t  /* Add this case label.\n              Add parameter 'label', make it match GCC backend.  */\n-\t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t     low, high, label);\n+\t  tmp = fold_build3_loc (input_location, CASE_LABEL_EXPR,\n+\t\t\t\t void_type_node, low, high, label);\n \t  gfc_add_expr_to_block (&body, tmp);\n \t}\n \n@@ -1586,8 +1615,8 @@ gfc_trans_logical_select (gfc_code * code)\n       if (f != NULL)\n \tfalse_tree = gfc_trans_code (f->next);\n \n-      stmt = fold_build3 (COND_EXPR, void_type_node, se.expr,\n-\t\t\t  true_tree, false_tree);\n+      stmt = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t      se.expr, true_tree, false_tree);\n       gfc_add_expr_to_block (&block, stmt);\n     }\n \n@@ -1748,8 +1777,8 @@ gfc_trans_character_select (gfc_code *code)\n \n \t\t  /* Add this case label.\n \t\t     Add parameter 'label', make it match GCC backend.  */\n-\t\t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t\t     low, high, label);\n+\t\t  tmp = fold_build3_loc (input_location, CASE_LABEL_EXPR,\n+\t\t\t\t\t void_type_node, low, high, label);\n \t\t  gfc_add_expr_to_block (&body, tmp);\n \t\t}\n \n@@ -1828,10 +1857,11 @@ gfc_trans_character_select (gfc_code *code)\n       for (d = c->ext.case_list; d; d = d->next)\n         {\n \t  label = gfc_build_label_decl (NULL_TREE);\n-\t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t     (d->low == NULL && d->high == NULL)\n-\t\t\t     ? NULL : build_int_cst (NULL_TREE, d->n),\n-\t\t\t     NULL, label);\n+\t  tmp = fold_build3_loc (input_location, CASE_LABEL_EXPR,\n+\t\t\t\t void_type_node,\n+\t\t\t\t (d->low == NULL && d->high == NULL)\n+\t\t\t\t ? NULL : build_int_cst (NULL_TREE, d->n),\n+\t\t\t\t NULL, label);\n           gfc_add_expr_to_block (&body, tmp);\n         }\n \n@@ -2218,33 +2248,34 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n       gfc_init_block (&block);\n \n       /* The exit condition.  */\n-      cond = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t  count, build_int_cst (TREE_TYPE (count), 0));\n+      cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+\t\t\t      count, build_int_cst (TREE_TYPE (count), 0));\n       tmp = build1_v (GOTO_EXPR, exit_label);\n-      tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t cond, tmp, build_empty_stmt (input_location));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     cond, tmp, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n \n       /* The main loop body.  */\n       gfc_add_expr_to_block (&block, body);\n \n       /* Increment the loop variable.  */\n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (var), var, step);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (var), var,\n+\t\t\t     step);\n       gfc_add_modify (&block, var, tmp);\n \n       /* Advance to the next mask element.  Only do this for the\n \t innermost loop.  */\n       if (n == 0 && mask_flag && forall_tmp->mask)\n \t{\n \t  tree maskindex = forall_tmp->maskindex;\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     maskindex, gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t maskindex, gfc_index_one_node);\n \t  gfc_add_modify (&block, maskindex, tmp);\n \t}\n \n       /* Decrement the loop counter.  */\n-      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (var), count,\n-\t\t\t build_int_cst (TREE_TYPE (var), 1));\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (var), count,\n+\t\t\t     build_int_cst (TREE_TYPE (var), 1));\n       gfc_add_modify (&block, count, tmp);\n \n       body = gfc_finish_block (&block);\n@@ -2255,9 +2286,12 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n \n \n       /* Initialize the loop counter.  */\n-      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (var), step, start);\n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (var), end, tmp);\n-      tmp = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (var), tmp, step);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (var), step,\n+\t\t\t     start);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (var), end,\n+\t\t\t     tmp);\n+      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, TREE_TYPE (var),\n+\t\t\t     tmp, step);\n       gfc_add_modify (&block, count, tmp);\n \n       /* The loop expression.  */\n@@ -2330,10 +2364,8 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n   tree tmp;\n \n   if (INTEGER_CST_P (size))\n-    {\n-      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t\t gfc_index_one_node);\n-    }\n+    tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t   size, gfc_index_one_node);\n   else\n     tmp = NULL_TREE;\n \n@@ -2391,8 +2423,8 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n       gfc_add_block_to_block (&block, &lse.post);\n \n       /* Increment the count1.  */\n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1,\n-\t\t\t gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (count1),\n+\t\t\t     count1, gfc_index_one_node);\n       gfc_add_modify (&block, count1, tmp);\n \n       tmp = gfc_finish_block (&block);\n@@ -2437,26 +2469,27 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n \t{\n \t  wheremaskexpr = gfc_build_array_ref (wheremask, count3, NULL);\n \t  if (invert)\n-\t    wheremaskexpr = fold_build1 (TRUTH_NOT_EXPR,\n-\t\t\t\t\t TREE_TYPE (wheremaskexpr),\n-\t\t\t\t\t wheremaskexpr);\n-\t  tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t     wheremaskexpr, tmp,\n-\t\t\t     build_empty_stmt (input_location));\n+\t    wheremaskexpr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t\t\t     TREE_TYPE (wheremaskexpr),\n+\t\t\t\t\t     wheremaskexpr);\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t wheremaskexpr, tmp,\n+\t\t\t\t build_empty_stmt (input_location));\n        }\n \n       gfc_add_expr_to_block (&body, tmp);\n \n       /* Increment count1.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count1, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count1, gfc_index_one_node);\n       gfc_add_modify (&body, count1, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n \t{\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     count3, gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, count3,\n+\t\t\t\t gfc_index_one_node);\n \t  gfc_add_modify (&body, count3, tmp);\n \t}\n \n@@ -2535,11 +2568,12 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n     {\n       wheremaskexpr = gfc_build_array_ref (wheremask, count3, NULL);\n       if (invert)\n-\twheremaskexpr = fold_build1 (TRUTH_NOT_EXPR,\n-\t\t\t\t     TREE_TYPE (wheremaskexpr),\n-\t\t\t\t     wheremaskexpr);\n-      tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t wheremaskexpr, tmp, build_empty_stmt (input_location));\n+\twheremaskexpr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t\t\t TREE_TYPE (wheremaskexpr),\n+\t\t\t\t\t wheremaskexpr);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     wheremaskexpr, tmp,\n+\t\t\t     build_empty_stmt (input_location));\n     }\n \n   gfc_add_expr_to_block (&body1, tmp);\n@@ -2549,22 +2583,23 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n       gfc_add_block_to_block (&block, &body1);\n \n       /* Increment count1.  */\n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (count1), count1,\n-\t\t\t gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (count1),\n+\t\t\t     count1, gfc_index_one_node);\n       gfc_add_modify (&block, count1, tmp);\n     }\n   else\n     {\n       /* Increment count1.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count1, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count1, gfc_index_one_node);\n       gfc_add_modify (&body1, count1, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n \t{\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     count3, gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t count3, gfc_index_one_node);\n \t  gfc_add_modify (&body1, count3, tmp);\n \t}\n \n@@ -2637,11 +2672,13 @@ compute_inner_temp_size (gfc_expr *expr1, gfc_expr *expr2,\n       /* Figure out how many elements we need.  */\n       for (i = 0; i < loop.dimen; i++)\n         {\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     gfc_index_one_node, loop.from[i]);\n-          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, loop.to[i]);\n-          size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t gfc_index_one_node, loop.from[i]);\n+          tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp, loop.to[i]);\n+          size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t  gfc_array_index_type, size, tmp);\n         }\n       gfc_add_block_to_block (pblock, &loop.pre);\n       size = gfc_evaluate_now (size, pblock);\n@@ -2679,8 +2716,9 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n \t     && !forall_tmp->mask \n \t     && INTEGER_CST_P (forall_tmp->size))\n \t{\n-\t  inner_size = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t    inner_size, forall_tmp->size);\n+\t  inner_size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\tgfc_array_index_type,\n+\t\t\t\t\tinner_size, forall_tmp->size);\n \t  forall_tmp = forall_tmp->prev_nest;\n \t}\n \n@@ -2697,8 +2735,8 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n   if (inner_size_body)\n     gfc_add_block_to_block (&body, inner_size_body);\n   if (forall_tmp)\n-    tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t       number, inner_size);\n+    tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t   gfc_array_index_type, number, inner_size);\n   else\n     tmp = inner_size;\n   gfc_add_modify (&body, number, tmp);\n@@ -2727,7 +2765,8 @@ allocate_temp_for_forall_nest_1 (tree type, tree size, stmtblock_t * block,\n \n   unit = fold_convert (gfc_array_index_type, TYPE_SIZE_UNIT (type));\n   if (!integer_onep (unit))\n-    bytesize = fold_build2 (MULT_EXPR, gfc_array_index_type, size, unit);\n+    bytesize = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\tgfc_array_index_type, size, unit);\n   else\n     bytesize = size;\n \n@@ -2929,8 +2968,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &rse.post);\n \n       /* Increment count.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count, gfc_index_one_node);\n       gfc_add_modify (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -2953,8 +2992,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_modify (&body, lse.expr, rse.expr);\n       gfc_add_block_to_block (&body, &lse.post);\n       /* Increment count.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count, gfc_index_one_node);\n       gfc_add_modify (&body, count, tmp);\n       tmp = gfc_finish_block (&body);\n \n@@ -2998,8 +3037,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count, gfc_index_one_node);\n       gfc_add_modify (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -3022,8 +3061,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count, gfc_index_one_node);\n       gfc_add_modify (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -3199,14 +3238,16 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   for (n = 0; n < nvar; n++)\n     {\n       /* size = (end + step - start) / step.  */\n-      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (start[n]), \n-\t\t\t step[n], start[n]);\n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (end[n]), end[n], tmp);\n-\n-      tmp = fold_build2 (FLOOR_DIV_EXPR, TREE_TYPE (tmp), tmp, step[n]);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (start[n]), \n+\t\t\t     step[n], start[n]);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (end[n]),\n+\t\t\t     end[n], tmp);\n+      tmp = fold_build2_loc (input_location, FLOOR_DIV_EXPR, TREE_TYPE (tmp),\n+\t\t\t     tmp, step[n]);\n       tmp = convert (gfc_array_index_type, tmp);\n \n-      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      size, tmp);\n     }\n \n   /* Record the nvar and size of current forall level.  */\n@@ -3273,8 +3314,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       gfc_add_modify (&body, tmp, se.expr);\n \n       /* Advance to the next mask element.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t maskindex, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     maskindex, gfc_index_one_node);\n       gfc_add_modify (&body, maskindex, tmp);\n \n       /* Generate the loops.  */\n@@ -3481,7 +3522,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n     {\n       tmp = gfc_build_array_ref (mask, count, NULL);\n       if (invert)\n-\ttmp = fold_build1 (TRUTH_NOT_EXPR, mask_type, tmp);\n+\ttmp = fold_build1_loc (input_location, TRUTH_NOT_EXPR, mask_type, tmp);\n       gfc_add_modify (&body1, mtmp, tmp);\n     }\n \n@@ -3490,16 +3531,18 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n       tmp1 = gfc_build_array_ref (cmask, count, NULL);\n       tmp = cond;\n       if (mask)\n-\ttmp = fold_build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n+\ttmp = fold_build2_loc (input_location, TRUTH_AND_EXPR, mask_type,\n+\t\t\t       mtmp, tmp);\n       gfc_add_modify (&body1, tmp1, tmp);\n     }\n \n   if (pmask)\n     {\n       tmp1 = gfc_build_array_ref (pmask, count, NULL);\n-      tmp = fold_build1 (TRUTH_NOT_EXPR, mask_type, cond);\n+      tmp = fold_build1_loc (input_location, TRUTH_NOT_EXPR, mask_type, cond);\n       if (mask)\n-\ttmp = fold_build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n+\ttmp = fold_build2_loc (input_location, TRUTH_AND_EXPR, mask_type, mtmp,\n+\t\t\t       tmp);\n       gfc_add_modify (&body1, tmp1, tmp);\n     }\n \n@@ -3513,8 +3556,8 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   else\n     {\n       /* Increment count.  */\n-      tmp1 = fold_build2 (PLUS_EXPR, gfc_array_index_type, count,\n-                          gfc_index_one_node);\n+      tmp1 = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      count, gfc_index_one_node);\n       gfc_add_modify (&body1, count, tmp1);\n \n       /* Generate the copying loops.  */\n@@ -3662,7 +3705,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n   index = count1;\n   maskexpr = gfc_build_array_ref (mask, index, NULL);\n   if (invert)\n-    maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr), maskexpr);\n+    maskexpr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t\tTREE_TYPE (maskexpr), maskexpr);\n \n   /* Use the scalar assignment as is.  */\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n@@ -3675,8 +3719,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n   if (lss == gfc_ss_terminator)\n     {\n       /* Increment count1.  */\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count1, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     count1, gfc_index_one_node);\n       gfc_add_modify (&body, count1, tmp);\n \n       /* Use the scalar assignment as is.  */\n@@ -3691,8 +3735,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n         {\n           /* Increment count1 before finish the main body of a scalarized\n              expression.  */\n-          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     count1, gfc_index_one_node);\n+          tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, count1, gfc_index_one_node);\n           gfc_add_modify (&body, count1, tmp);\n           gfc_trans_scalarized_loop_boundary (&loop, &body);\n \n@@ -3716,8 +3760,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n           index = count2;\n           maskexpr = gfc_build_array_ref (mask, index, NULL);\n \t  if (invert)\n-\t    maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr),\n-\t\t\t\t    maskexpr);\n+\t    maskexpr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n+\t\t\t\t\tTREE_TYPE (maskexpr), maskexpr);\n \n           /* Use the scalar assignment as is.  */\n           tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts, false, false,\n@@ -3727,15 +3771,17 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n           gfc_add_expr_to_block (&body, tmp);\n \n           /* Increment count2.  */\n-          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     count2, gfc_index_one_node);\n+          tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, count2,\n+\t\t\t\t gfc_index_one_node);\n           gfc_add_modify (&body, count2, tmp);\n         }\n       else\n         {\n           /* Increment count1.  */\n-          tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     count1, gfc_index_one_node);\n+          tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, count1,\n+\t\t\t\t gfc_index_one_node);\n           gfc_add_modify (&body, count1, tmp);\n         }\n \n@@ -3837,10 +3883,10 @@ gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n \t\t\t\t\t  &inner_size_body, block);\n \n       /* Check whether the size is negative.  */\n-      cond = fold_build2 (LE_EXPR, boolean_type_node, size,\n-\t\t\t  gfc_index_zero_node);\n-      size = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n-\t\t\t  gfc_index_zero_node, size);\n+      cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, size,\n+\t\t\t      gfc_index_zero_node);\n+      size = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,\n+\t\t\t      cond, gfc_index_zero_node, size);\n       size = gfc_evaluate_now (size, block);\n \n       /* Allocate temporary for WHERE mask if needed.  */\n@@ -4351,17 +4397,20 @@ gfc_trans_allocate (gfc_code * code)\n \t      tmp = gfc_allocate_with_status (&se.pre, memsz, pstat);\n \t  }\n \n-\t  tmp = fold_build2 (MODIFY_EXPR, void_type_node, se.expr,\n-\t\t\t     fold_convert (TREE_TYPE (se.expr), tmp));\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t\t se.expr,\n+\t\t\t\t fold_convert (TREE_TYPE (se.expr), tmp));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n \t  if (code->expr1 || code->expr2)\n \t    {\n \t      tmp = build1_v (GOTO_EXPR, error_label);\n-\t      parm = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t  stat, build_int_cst (TREE_TYPE (stat), 0));\n-\t      tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t\t parm, tmp, build_empty_stmt (input_location));\n+\t      parm = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t      boolean_type_node, stat,\n+\t\t\t\t      build_int_cst (TREE_TYPE (stat), 0));\n+\t      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t     parm, tmp,\n+\t\t\t\t     build_empty_stmt (input_location));\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \n@@ -4532,14 +4581,15 @@ gfc_trans_allocate (gfc_code * code)\n \n       slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n       dlen = gfc_get_expr_charlen (code->expr2);\n-      slen = fold_build2 (MIN_EXPR, TREE_TYPE (slen), dlen, slen);\n+      slen = fold_build2_loc (input_location, MIN_EXPR, TREE_TYPE (slen), dlen,\n+\t\t\t      slen);\n \n       dlen = build_call_expr_loc (input_location,\n \t\t\t      built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n \n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, stat,\n-\t\t\t build_int_cst (TREE_TYPE (stat), 0));\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n+\t\t\t     build_int_cst (TREE_TYPE (stat), 0));\n \n       tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt (input_location));\n \n@@ -4621,8 +4671,9 @@ gfc_trans_deallocate (gfc_code *code)\n \t  tmp = gfc_deallocate_with_status (se.expr, pstat, false, expr);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n-\t  tmp = fold_build2 (MODIFY_EXPR, void_type_node,\n-\t\t\t     se.expr, build_int_cst (TREE_TYPE (se.expr), 0));\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t\t se.expr,\n+\t\t\t\t build_int_cst (TREE_TYPE (se.expr), 0));\n \t}\n \n       gfc_add_expr_to_block (&se.pre, tmp);\n@@ -4631,7 +4682,8 @@ gfc_trans_deallocate (gfc_code *code)\n \t of the last deallocation to the running total.  */\n       if (code->expr1 || code->expr2)\n \t{\n-\t  apstat = fold_build2 (PLUS_EXPR, TREE_TYPE (stat), astat, stat);\n+\t  apstat = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t    TREE_TYPE (stat), astat, stat);\n \t  gfc_add_modify (&se.pre, astat, apstat);\n \t}\n \n@@ -4667,14 +4719,15 @@ gfc_trans_deallocate (gfc_code *code)\n \n       slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n       dlen = gfc_get_expr_charlen (code->expr2);\n-      slen = fold_build2 (MIN_EXPR, TREE_TYPE (slen), dlen, slen);\n+      slen = fold_build2_loc (input_location, MIN_EXPR, TREE_TYPE (slen), dlen,\n+\t\t\t      slen);\n \n       dlen = build_call_expr_loc (input_location,\n \t\t\t      built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\tgfc_build_addr_expr (pvoid_type_node, se.expr), errmsg, slen);\n \n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, astat,\n-\t\t\t build_int_cst (TREE_TYPE (astat), 0));\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, astat,\n+\t\t\t     build_int_cst (TREE_TYPE (astat), 0));\n \n       tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt (input_location));\n "}, {"sha": "46ddfed8151bbd7071bd3c46fdfc63d75a447963", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc98ed601606493c5549b7f0261e124b1e1471ad/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=bc98ed601606493c5549b7f0261e124b1e1471ad", "patch": "@@ -1360,9 +1360,11 @@ gfc_get_dtype (tree type)\n   if (size && !INTEGER_CST_P (size))\n     {\n       tmp = build_int_cst (gfc_array_index_type, GFC_DTYPE_SIZE_SHIFT);\n-      tmp  = fold_build2 (LSHIFT_EXPR, gfc_array_index_type,\n-\t\t\t  fold_convert (gfc_array_index_type, size), tmp);\n-      dtype = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp, dtype);\n+      tmp  = fold_build2_loc (input_location, LSHIFT_EXPR,\n+\t\t\t      gfc_array_index_type,\n+\t\t\t      fold_convert (gfc_array_index_type, size), tmp);\n+      dtype = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t       tmp, dtype);\n     }\n   /* If we don't know the size we leave it as zero.  This should never happen\n      for anything that is actually used.  */\n@@ -1677,11 +1679,13 @@ gfc_get_array_type_bounds (tree etype, int dimen, int codimen, tree * lbound,\n \n       if (upper != NULL_TREE && lower != NULL_TREE && stride != NULL_TREE)\n \t{\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, upper, lower);\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp,\n-\t\t\t     gfc_index_one_node);\n-\t  stride =\n-\t    fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, stride);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, upper, lower);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp,\n+\t\t\t\t gfc_index_one_node);\n+\t  stride = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t    gfc_array_index_type, tmp, stride);\n \t  /* Check the folding worked.  */\n \t  gcc_assert (INTEGER_CST_P (stride));\n \t}"}]}