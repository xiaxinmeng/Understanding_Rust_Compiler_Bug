{"sha": "cad6f7d0500211029f717912048103063ea93df5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FkNmY3ZDA1MDAyMTEwMjlmNzE3OTEyMDQ4MTAzMDYzZWE5M2RmNQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-06T00:39:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-06T00:39:23Z"}, "message": "Makefile.in (stupid.o): Update dependencies.\n\n\t* Makefile.in (stupid.o): Update dependencies.\n\t(global.o): Likewise.\n\t* global.c: Include reload.h\n\t(reg_becomes_live): New function.\n\t(reg_dies): New function.\n\t(build_insn_chain): New function.\n\t(global_alloc): Call build_insn_chain before calling reload.\n\t* reload.h (struct needs): New structure definition.\n\t(struct insn_chain): Likewise.\n\t(reload_insn_chain): Declare variable.\n\t(new_insn_chain): Declare function.\n\t* reload1.c (reload_startobj): New variable.\n\t(reload_insn_chain): New variable.\n\t(unused_insn_chains): New variable.\n\t(new_insn_chain): New function.\n\t(init_reload): Initialize reload_startobj, not reload_firstobj.\n\t(reload): Initialize reload_firstobj.\n\tBefore returning, free everything on the reload_obstack.\n\t* stupid.c: Include insn-config.h, reload.h and basic-block.h.\n\t(reg_where_dead_chain, reg_where_born_exact, reg_where_born_clobber,\n\tcurrent_chain): New variables.\n\t(reg_where_born): Delete variable.\n\t(REG_WHERE_BORN): New macro.\n\t(find_clobbered_regs): New function.\n\t(stupid_life_analysis): Don't allocate/free reg_where_born.\n\tAllocate and free reg_where_born_exact, reg_where_born_clobber,\n\treg_where_dead_chain.\n\tUse REG_WHERE_BORN instead of reg_where_born.\n\tWhile processing the insns, build the reload_insn_chain with\n\tinformation about register lifetimes.\n\t(stupid_reg_compare): Use REG_WHERE_BORN instead of reg_where_born.\n\t(stupid_mark_refs): Replace arg INSN with arg CHAIN.  All callers\n\tchanged.\n\tCompute and information about birth and death of pseudo registers in\n\treg_where_dead_chain, reg_where_born_exact and reg_where_born_clobber.\n\tDelete code to set elements of reg_where_born.\n\nFrom-SVN: r22862", "tree": {"sha": "8d139251935aba1755bfaa2510b2f95b82ebf53f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d139251935aba1755bfaa2510b2f95b82ebf53f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cad6f7d0500211029f717912048103063ea93df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad6f7d0500211029f717912048103063ea93df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad6f7d0500211029f717912048103063ea93df5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad6f7d0500211029f717912048103063ea93df5/comments", "author": null, "committer": null, "parents": [{"sha": "0eaae86cabfda78baec29e96a461f6bc52f60e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eaae86cabfda78baec29e96a461f6bc52f60e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eaae86cabfda78baec29e96a461f6bc52f60e6e"}], "stats": {"total": 481, "additions": 454, "deletions": 27}, "files": [{"sha": "e50a261eb31912c0bdde06f50d299f4b7d79fa3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad6f7d0500211029f717912048103063ea93df5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad6f7d0500211029f717912048103063ea93df5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cad6f7d0500211029f717912048103063ea93df5", "patch": "@@ -1,3 +1,47 @@\n+Tue Oct  6 01:36:00 1998  Bernd Schmidt <crux@Pool.Informatik.RWTH-Aachen.DE>\n+\n+\t* Makefile.in (stupid.o): Update dependencies.\n+\t(global.o): Likewise.\n+\n+\t* global.c: Include reload.h\n+\t(reg_becomes_live): New function.\n+\t(reg_dies): New function.\n+\t(build_insn_chain): New function.\n+\t(global_alloc): Call build_insn_chain before calling reload.\n+\n+\t* reload.h (struct needs): New structure definition.\n+\t(struct insn_chain): Likewise.\n+\t(reload_insn_chain): Declare variable.\n+\t(new_insn_chain): Declare function.\n+\n+\n+\t* reload1.c (reload_startobj): New variable.\n+\t(reload_insn_chain): New variable.\n+\t(unused_insn_chains): New variable.\n+\t(new_insn_chain): New function.\n+\t(init_reload): Initialize reload_startobj, not reload_firstobj.\n+\t(reload): Initialize reload_firstobj.\n+\tBefore returning, free everything on the reload_obstack.\n+\n+\t* stupid.c: Include insn-config.h, reload.h and basic-block.h.\n+\t(reg_where_dead_chain, reg_where_born_exact, reg_where_born_clobber,\n+\tcurrent_chain): New variables.\n+\t(reg_where_born): Delete variable.\n+\t(REG_WHERE_BORN): New macro.\n+\t(find_clobbered_regs): New function.\n+\t(stupid_life_analysis): Don't allocate/free reg_where_born.\n+\tAllocate and free reg_where_born_exact, reg_where_born_clobber,\n+\treg_where_dead_chain.\n+\tUse REG_WHERE_BORN instead of reg_where_born.\n+\tWhile processing the insns, build the reload_insn_chain with\n+\tinformation about register lifetimes.\n+\t(stupid_reg_compare): Use REG_WHERE_BORN instead of reg_where_born.\n+\t(stupid_mark_refs): Replace arg INSN with arg CHAIN.  All callers\n+\tchanged.\n+\tCompute and information about birth and death of pseudo registers in\n+\treg_where_dead_chain, reg_where_born_exact and reg_where_born_clobber.\n+\tDelete code to set elements of reg_where_born.\t\n+\n Mon Oct  5 22:34:30 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* tree.def (GOTO_EXPR): Modified documentation."}, {"sha": "e97246df4ba03d9bb6a5216f7ccd76a8fa44b861", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad6f7d0500211029f717912048103063ea93df5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad6f7d0500211029f717912048103063ea93df5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cad6f7d0500211029f717912048103063ea93df5", "patch": "@@ -1461,7 +1461,7 @@ jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n    insn-config.h insn-flags.h $(RECOG_H) $(EXPR_H) real.h except.h \\\n    toplev.h\n stupid.o : stupid.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n-   flags.h toplev.h\n+   $(BASIC_BLOCK_H) insn-config.h reload.h flags.h toplev.h\n \n cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h\n@@ -1487,7 +1487,7 @@ local-alloc.o : local-alloc.c $(CONFIG_H) system.h $(RTL_H) flags.h \\\n    insn-attr.h toplev.h\n bitmap.o : bitmap.c $(CONFIG_H) system.h $(RTL_H) flags.h $(BASIC_BLOCK_H) \\\n    $(REGS_H)\n-global.o : global.c $(CONFIG_H) system.h $(RTL_H) flags.h  \\\n+global.o : global.c $(CONFIG_H) system.h $(RTL_H) flags.h reload.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h insn-config.h output.h toplev.h\n varray.o : varray.c $(CONFIG_H) system.h varray.h $(RTL_H) $(TREE_H) bitmap.h\n "}, {"sha": "04a836c0003b2c9b87b40122b44ad18a6d8fe45c", "filename": "gcc/global.c", "status": "modified", "additions": 137, "deletions": 1, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad6f7d0500211029f717912048103063ea93df5/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad6f7d0500211029f717912048103063ea93df5/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=cad6f7d0500211029f717912048103063ea93df5", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"basic-block.h\"\n #include \"regs.h\"\n #include \"insn-config.h\"\n+#include \"reload.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n \n@@ -268,6 +269,9 @@ static void mark_reg_death\tPROTO((rtx));\n static void mark_reg_live_nc\tPROTO((int, enum machine_mode));\n static void set_preference\tPROTO((rtx, rtx));\n static void dump_conflicts\tPROTO((FILE *));\n+static void reg_becomes_live\tPROTO((rtx, rtx));\n+static void reg_dies\t\tPROTO((int, enum machine_mode));\n+static void build_insn_chain\tPROTO((rtx));\n \f\n /* Perform allocation of pseudo-registers not allocated by local_alloc.\n    FILE is a file to output debugging information on,\n@@ -573,7 +577,10 @@ global_alloc (file)\n \t for the sake of debugging information.  */\n   if (n_basic_blocks > 0)\n #endif\n-    retval = reload (get_insns (), 1, file);\n+    {\n+      build_insn_chain (get_insns ());\n+      retval = reload (get_insns (), 1, file);\n+    }\n \n   free (conflicts);\n   return retval;\n@@ -1648,6 +1655,135 @@ mark_elimination (from, to)\n       }\n }\n \f\n+/* Used for communication between the following functions.  Holds the\n+   current life information.  */\n+static regset live_relevant_regs;\n+\n+/* Record in live_relevant_regs that register REG became live.  This\n+   is called via note_stores.  */\n+static void\n+reg_becomes_live (reg, setter)\n+     rtx reg;\n+     rtx setter ATTRIBUTE_UNUSED;\n+{\n+  int regno;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+  \n+  regno = REGNO (reg);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (nregs-- > 0)\n+\tSET_REGNO_REG_SET (live_relevant_regs, regno++);\n+    }\n+  else if (reg_renumber[regno] >= 0)\n+    SET_REGNO_REG_SET (live_relevant_regs, regno);\n+}\n+\n+/* Record in live_relevant_regs that register REGNO died.  */\n+static void\n+reg_dies (regno, mode)\n+     int regno;\n+     enum machine_mode mode;\n+{\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      int nregs = HARD_REGNO_NREGS (regno, mode);\n+      while (nregs-- > 0)\n+\tCLEAR_REGNO_REG_SET (live_relevant_regs, regno++);\n+    }\n+  else\n+    CLEAR_REGNO_REG_SET (live_relevant_regs, regno);\n+}\n+\n+/* Walk the insns of the current function and build reload_insn_chain,\n+   and record register life information.  */\n+static void\n+build_insn_chain (first)\n+     rtx first;\n+{\n+  struct insn_chain **p = &reload_insn_chain;\n+  struct insn_chain *prev = 0;\n+  int b = 0;\n+\n+  live_relevant_regs = ALLOCA_REG_SET ();\n+\n+  for (; first; first = NEXT_INSN (first))\n+    {\n+      struct insn_chain *c;\n+\n+      if (first == basic_block_head[b])\n+\t{\n+\t  int i;\n+\t  CLEAR_REG_SET (live_relevant_regs);\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (REGNO_REG_SET_P (basic_block_live_at_start[b], i)\n+\t\t&& ! TEST_HARD_REG_BIT (eliminable_regset, i))\n+\t      SET_REGNO_REG_SET (live_relevant_regs, i);\n+\n+\t  for (; i < max_regno; i++)\n+\t    if (reg_renumber[i] >= 0\n+\t\t&& REGNO_REG_SET_P (basic_block_live_at_start[b], i))\n+\t      SET_REGNO_REG_SET (live_relevant_regs, i);\n+\t}\n+\n+      if (GET_CODE (first) != NOTE && GET_CODE (first) != BARRIER)\n+\t{\n+\t  c = new_insn_chain ();\n+\t  c->prev = prev;\n+\t  prev = c;\n+\t  *p = c;\n+\t  p = &c->next;\n+\t  c->insn = first;\n+\t  c->block = b;\n+\n+\t  COPY_REG_SET (c->live_before, live_relevant_regs);\n+\n+\t  if (GET_RTX_CLASS (GET_CODE (first)) == 'i')\n+\t    {\n+\t      rtx link;\n+\n+\t      /* Mark the death of everything that dies in this instruction.  */\n+\n+\t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_DEAD\n+\t\t    && GET_CODE (XEXP (link, 0)) == REG)\n+\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)));\n+\n+\t      /* Mark everything born in this instruction as live.  */\n+\n+\t      note_stores (PATTERN (first), reg_becomes_live);\n+\t    }\n+\n+\t  /* Remember which registers are live at the end of the insn, before\n+\t     killing those with REG_UNUSED notes.  */\n+\t  COPY_REG_SET (c->live_after, live_relevant_regs);\n+\n+\t  if (GET_RTX_CLASS (GET_CODE (first)) == 'i')\n+\t    {\n+\t      rtx link;\n+\n+\t      /* Mark anything that is set in this insn and then unused as dying.  */\n+\n+\t      for (link = REG_NOTES (first); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_UNUSED\n+\t\t    && GET_CODE (XEXP (link, 0)) == REG)\n+\t\t  reg_dies (REGNO (XEXP (link, 0)), GET_MODE (XEXP (link, 0)));\n+\t    }\n+\t}\n+\n+      if (first == basic_block_end[b])\n+\tb++;\n+    }\n+  FREE_REG_SET (live_relevant_regs);\n+  *p = 0;\n+}\n+\f\n /* Print debugging trace information if -greg switch is given,\n    showing the information on which the allocation decisions are based.  */\n "}, {"sha": "58f6be3a1014e2b211ad0a838bc5380cce699db7", "filename": "gcc/reload.h", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad6f7d0500211029f717912048103063ea93df5/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad6f7d0500211029f717912048103063ea93df5/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=cad6f7d0500211029f717912048103063ea93df5", "patch": "@@ -142,6 +142,81 @@ extern enum insn_code reload_in_optab[];\n extern enum insn_code reload_out_optab[];\n #endif\n \n+struct needs\n+{\n+  /* [0] is normal, [1] is nongroup.  */\n+  short regs[2][N_REG_CLASSES];\n+  short groups[N_REG_CLASSES];\n+};\n+\n+#if defined SET_HARD_REG_BIT && defined CLEAR_REG_SET\n+/* This structure describes instructions which are relevant for reload.\n+   Apart from all regular insns, this also includes CODE_LABELs, since they\n+   must be examined for register elimination.  */\n+struct insn_chain \n+{\n+  /* Links to the neighbour instructions.  */\n+  struct insn_chain *next, *prev;\n+\n+  /* Link through a chains set up by calculate_needs_all_insns, containing\n+     all insns that need reloading.  */\n+  struct insn_chain *next_need_reload;\n+\n+  /* The basic block this insn is in.  */\n+  int block;\n+  /* The rtx of the insn.  */\n+  rtx insn;\n+  /* Register life information: record all live hard registers, and all\n+     live pseudos that have a hard register.\n+     This information is recorded for the point immediately before the insn\n+     (in live_before), and for the point within the insn at which all\n+     outputs have just been written to (in live_after).  */\n+  regset live_before;\n+  regset live_after;\n+\n+  /* For each class, size of group of consecutive regs\n+     that is needed for the reloads of this class.  */\n+  char group_size[N_REG_CLASSES];\n+  /* For each class, the machine mode which requires consecutive\n+     groups of regs of that class.\n+     If two different modes ever require groups of one class,\n+     they must be the same size and equally restrictive for that class,\n+     otherwise we can't handle the complexity.  */\n+  enum machine_mode group_mode[N_REG_CLASSES];\n+\n+  /* Indicates if a register was counted against the need for\n+     groups.  0 means it can count against max_nongroup instead.  */\n+  HARD_REG_SET counted_for_groups;\n+\n+  /* Indicates if a register was counted against the need for\n+     non-groups.  0 means it can become part of a new group.\n+     During choose_reload_regs, 1 here means don't use this reg\n+     as part of a group, even if it seems to be otherwise ok.  */\n+  HARD_REG_SET counted_for_nongroups;\n+\n+  /* Indicates which registers have already been used for spills.  */\n+  HARD_REG_SET used_spill_regs;\n+\n+  /* Describe the needs for reload registers of this insn.  */\n+  struct needs need;\n+\n+  /* Nonzero if find_reloads said the insn requires reloading.  */\n+  unsigned int need_reload:1;\n+  /* Nonzero if eliminate_regs_in_insn said it requires eliminations.  */\n+  unsigned int need_elim:1;\n+  /* Nonzero if this insn was inserted by perform_caller_saves.  */\n+  unsigned int is_caller_save_insn:1;\n+};\n+\n+/* A chain of insn_chain structures to describe all non-note insns in\n+   a function.  */\n+extern struct insn_chain *reload_insn_chain;\n+\n+/* Allocate a new insn_chain structure.  */\n+extern struct insn_chain *new_insn_chain\tPROTO((void));\n+\n+#endif\n+\n /* Functions from reload.c:  */\n \n /* Return a memory location that will be used to copy X in mode MODE.  "}, {"sha": "8b15e0e8e8d04a4f769bf3da7339e0fbd9403a7e", "filename": "gcc/reload1.c", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad6f7d0500211029f717912048103063ea93df5/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad6f7d0500211029f717912048103063ea93df5/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cad6f7d0500211029f717912048103063ea93df5", "patch": "@@ -32,9 +32,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"expr.h\"\n #include \"regs.h\"\n+#include \"basic-block.h\"\n #include \"reload.h\"\n #include \"recog.h\"\n-#include \"basic-block.h\"\n #include \"output.h\"\n #include \"real.h\"\n #include \"toplev.h\"\n@@ -279,13 +279,24 @@ enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n    insn.  */\n \n struct obstack reload_obstack;\n+\n+/* Points to the beginning of the reload_obstack.  All insn_chain structures\n+   are allocated first.  */\n+char *reload_startobj;\n+\n+/* The point after all insn_chain structures.  Used to quickly deallocate\n+   memory used while processing one insn.  */\n char *reload_firstobj;\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n /* List of labels that must never be deleted.  */\n extern rtx forced_labels;\n+\n+/* List of insn_chain instructions, one for every insn that reload needs to\n+   examine.  */\n+struct insn_chain *reload_insn_chain;\n \f\n /* This structure is used to record information about register eliminations.\n    Each array entry describes one possible way of eliminating a register\n@@ -461,7 +472,7 @@ init_reload ()\n \n   /* Initialize obstack for our rtl allocation.  */\n   gcc_obstack_init (&reload_obstack);\n-  reload_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n+  reload_startobj = (char *) obstack_alloc (&reload_obstack, 0);\n \n   /* Decide which register class should be used when reloading\n      addresses.  If we are using SMALL_REGISTER_CLASSES, and any\n@@ -522,6 +533,32 @@ init_reload ()\n     }\n }\n \n+/* List of insn chains that are currently unused.  */\n+static struct insn_chain *unused_insn_chains = 0;\n+\n+/* Allocate an empty insn_chain structure.  */\n+struct insn_chain *\n+new_insn_chain ()\n+{\n+  struct insn_chain *c;\n+\n+  if (unused_insn_chains == 0)\n+    {\n+      c = obstack_alloc (&reload_obstack, sizeof (struct insn_chain));\n+      c->live_before = OBSTACK_ALLOC_REG_SET (&reload_obstack);\n+      c->live_after = OBSTACK_ALLOC_REG_SET (&reload_obstack);\n+    }\n+  else\n+    {\n+      c = unused_insn_chains;\n+      unused_insn_chains = c->next;\n+    }\n+  c->is_caller_save_insn = 0;\n+  c->need_reload = 0;\n+  c->need_elim = 0;\n+  return c;\n+}\n+\n /* Global variables used by reload and its subroutines.  */\n \n /* Set during calculate_needs if an insn needs reloading.  */\n@@ -605,6 +642,8 @@ reload (first, global, dumpfile)\n \n   failure = 0;\n \n+  reload_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n+\n   /* Enable find_equiv_reg to distinguish insns made by reload.  */\n   reload_first_uid = get_max_uid ();\n \n@@ -1217,7 +1256,9 @@ reload (first, global, dumpfile)\n       if (size > STACK_CHECK_MAX_FRAME_SIZE)\n \twarning (\"frame size too large for reliable stack checking\");\n     }\n-\t\n+\n+  obstack_free (&reload_obstack, reload_startobj);\n+\n   /* Indicate that we no longer have known memory locations or constants.  */\n   reg_equiv_constant = 0;\n   reg_equiv_memory_loc = 0;"}, {"sha": "cd1329f83d7e4b4223f9c26da3edc658c3128af3", "filename": "gcc/stupid.c", "status": "modified", "additions": 152, "deletions": 21, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad6f7d0500211029f717912048103063ea93df5/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad6f7d0500211029f717912048103063ea93df5/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=cad6f7d0500211029f717912048103063ea93df5", "patch": "@@ -47,7 +47,10 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"rtl.h\"\n #include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n #include \"regs.h\"\n+#include \"insn-config.h\"\n+#include \"reload.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n \f\n@@ -77,9 +80,21 @@ static int last_setjmp_suid;\n \n static int *reg_where_dead;\n \n+/* Likewise, but point to the insn_chain structure of the insn at which\n+   the reg dies.  */\n+static struct insn_chain **reg_where_dead_chain;\n+\n /* Element N is suid of insn where life span of pseudo reg N begins.  */\n+static int *reg_where_born_exact;\n+\n+/* Element N is 1 if the birth of pseudo reg N is due to a CLOBBER, \n+   0 otherwise.  */\n+static int *reg_where_born_clobber;\n \n-static int *reg_where_born;\n+/* Return the suid of the insn where the register is born, or the suid\n+   of the insn before if the birth is due to a CLOBBER.  */\n+#define REG_WHERE_BORN(N) \\\n+  (reg_where_born_exact[(N)] - reg_where_born_clobber[(N)])\n \n /* Numbers of pseudo-regs to be allocated, highest priority first.  */\n \n@@ -111,7 +126,43 @@ static HARD_REG_SET *after_insn_hard_regs;\n static int stupid_reg_compare\tPROTO((const GENERIC_PTR,const GENERIC_PTR));\n static int stupid_find_reg\tPROTO((int, enum reg_class, enum machine_mode,\n \t\t\t\t       int, int, int));\n-static void stupid_mark_refs\tPROTO((rtx, rtx));\n+static void stupid_mark_refs\tPROTO((rtx, struct insn_chain *));\n+static void find_clobbered_regs\tPROTO((rtx, rtx));\n+\f\n+/* For communication between stupid_life_analysis and find_clobbered_regs.  */\n+static struct insn_chain *current_chain;\n+\n+/* This function, called via note_stores, marks any hard registers that are\n+   clobbered in an insn as being live in the live_after and live_before fields\n+   of the appropriate insn_chain structure.  */\n+\n+static void\n+find_clobbered_regs (reg, setter)\n+     rtx reg, setter;\n+{\n+  int regno, nregs;\n+  if (setter == 0 || GET_CODE (setter) != CLOBBER)\n+    return;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+  regno = REGNO (reg);\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return;\n+\n+  if (GET_MODE (reg) == VOIDmode)\n+    abort ();\n+  else\n+    nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+  while (nregs-- > 0)\n+    {\n+      SET_REGNO_REG_SET (current_chain->live_after, regno);\n+      SET_REGNO_REG_SET (current_chain->live_before, regno++);\n+    }\n+}\n \f\n /* Stupid life analysis is for the case where only variables declared\n    `register' go in registers.  For this case, we mark all\n@@ -171,9 +222,15 @@ stupid_life_analysis (f, nregs, file)\n   reg_where_dead = (int *) xmalloc (nregs * sizeof (int));\n   bzero ((char *) reg_where_dead, nregs * sizeof (int));\n \n-  reg_where_born = (int *) xmalloc (nregs * sizeof (int));\n-  bzero ((char *) reg_where_born, nregs * sizeof (int));\n+  reg_where_born_exact = (int *) xmalloc (nregs * sizeof (int));\n+  bzero ((char *) reg_where_born_exact, nregs * sizeof (int));\n \n+  reg_where_born_clobber = (int *) xmalloc (nregs * sizeof (int));\n+  bzero ((char *) reg_where_born_clobber, nregs * sizeof (int));\n+\n+  reg_where_dead_chain = (struct insn_chain **) xmalloc (nregs * sizeof (struct insn_chain *));\n+  bzero ((char *) reg_where_dead_chain, nregs * sizeof (struct insn_chain *));\n+ \n   reg_order = (int *) xmalloc (nregs * sizeof (int));\n   bzero ((char *) reg_order, nregs * sizeof (int));\n \n@@ -210,11 +267,15 @@ stupid_life_analysis (f, nregs, file)\n      Also find where each hard register is live\n      and record that info in after_insn_hard_regs.\n      regs_live[I] is 1 if hard reg I is live\n-     at the current point in the scan.  */\n+     at the current point in the scan.  \n+   \n+     Build reload_insn_chain while we're walking the insns.  */\n \n+  reload_insn_chain = 0;\n   for (insn = last; insn; insn = PREV_INSN (insn))\n     {\n       register HARD_REG_SET *p = after_insn_hard_regs + INSN_SUID (insn);\n+      struct insn_chain *chain;\n \n       /* Copy the info in regs_live into the element of after_insn_hard_regs\n \t for the current position in the rtl code.  */\n@@ -223,12 +284,27 @@ stupid_life_analysis (f, nregs, file)\n \tif (regs_live[i])\n \t  SET_HARD_REG_BIT (*p, i);\n \n+      if (GET_CODE (insn) != NOTE && GET_CODE (insn) != BARRIER)\n+\t{\n+\t  chain = new_insn_chain ();\n+\t  if (reload_insn_chain)\n+\t    reload_insn_chain->prev = chain;\n+\t  chain->next = reload_insn_chain;\n+\t  chain->prev = 0;\n+\t  reload_insn_chain = chain;\n+\t  chain->block = 0;\n+\t  chain->insn = insn;\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (regs_live[i])\n+\t      SET_REGNO_REG_SET (chain->live_before, i);\n+\t}\n+\n       /* Update which hard regs are currently live\n \t and also the birth and death suids of pseudo regs\n \t based on the pattern of this insn.  */\n \n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\tstupid_mark_refs (PATTERN (insn), insn);\n+\tstupid_mark_refs (PATTERN (insn), chain);\n \n       if (GET_CODE (insn) == NOTE\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n@@ -266,8 +342,23 @@ stupid_life_analysis (f, nregs, file)\n \t  /* It is important that this be done after processing the insn's\n \t     pattern because we want the function result register to still\n \t     be live if it's also used to pass arguments.  */\n-\t  stupid_mark_refs (CALL_INSN_FUNCTION_USAGE (insn), insn);\n+\t  stupid_mark_refs (CALL_INSN_FUNCTION_USAGE (insn), chain);\n \t}\n+\n+      if (GET_CODE (insn) != NOTE && GET_CODE (insn) != BARRIER)\n+\t{\t  \n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (regs_live[i])\n+\t      SET_REGNO_REG_SET (chain->live_after, i);\n+\n+\t  /* The regs_live array doesn't say anything about hard registers\n+\t     clobbered by this insn.  So we need an extra pass over the\n+\t     pattern.  */\n+\t  current_chain = chain;\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    note_stores (PATTERN (insn), find_clobbered_regs);\n+\t}\n+\n       if (GET_CODE (insn) == JUMP_INSN && computed_jump_p (insn))\n \tcurrent_function_has_computed_jump = 1;\n     }\n@@ -289,8 +380,10 @@ stupid_life_analysis (f, nregs, file)\n \n       /* Some regnos disappear from the rtl.  Ignore them to avoid crash. \n \t Also don't allocate registers that cross a setjmp, or live across\n-\t a call if this function receives a nonlocal goto.  */\n+\t a call if this function receives a nonlocal goto.\n+\t Also ignore registers we didn't see during the scan.  */\n       if (regno_reg_rtx[r] == 0 || regs_crosses_setjmp[r]\n+\t  || (reg_where_born_exact[r] == 0 && reg_where_dead[r] == 0)\n \t  || (REG_N_CALLS_CROSSED (r) > 0 \n \t      && current_function_has_nonlocal_label))\n \tcontinue;\n@@ -300,7 +393,7 @@ stupid_life_analysis (f, nregs, file)\n \treg_renumber[r] = stupid_find_reg (REG_N_CALLS_CROSSED (r), \n \t\t\t\t\t   reg_preferred_class (r),\n \t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n-\t\t\t\t\t   reg_where_born[r],\n+\t\t\t\t\t   REG_WHERE_BORN (r),\n \t\t\t\t\t   reg_where_dead[r],\n \t\t\t\t\t   regs_change_size[r]);\n \n@@ -309,18 +402,48 @@ stupid_life_analysis (f, nregs, file)\n \treg_renumber[r] = stupid_find_reg (REG_N_CALLS_CROSSED (r),\n \t\t\t\t\t   reg_alternate_class (r),\n \t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n-\t\t\t\t\t   reg_where_born[r],\n+\t\t\t\t\t   REG_WHERE_BORN (r),\n \t\t\t\t\t   reg_where_dead[r],\n \t\t\t\t\t   regs_change_size[r]);\n     }\n \n+  /* Fill in the pseudo reg life information into the insn chain.  */\n+  for (i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n+    {\n+      struct insn_chain *chain;\n+      int regno;\n+\n+      regno = reg_renumber[i];\n+      if (regno < 0)\n+\tcontinue;\n+\n+      chain = reg_where_dead_chain[i];\n+      if (reg_where_dead[i] > INSN_SUID (chain->insn))\n+\tSET_REGNO_REG_SET (chain->live_after, i);\n+\n+      while (INSN_SUID (chain->insn) > reg_where_born_exact[i])\n+\t{\n+\t  SET_REGNO_REG_SET (chain->live_before, i);\n+\t  chain = chain->prev;\n+\t  if (!chain)\n+\t    break;\n+\t  SET_REGNO_REG_SET (chain->live_after, i);\n+\t}\n+\n+      if (INSN_SUID (chain->insn) == reg_where_born_exact[i]\n+\t  && reg_where_born_clobber[i])\n+\tSET_REGNO_REG_SET (chain->live_before, i);\n+    }\n+\n   if (file)\n     dump_flow_info (file);\n \n   free (regs_live);\n   free (uid_suid);\n   free (reg_where_dead);\n-  free (reg_where_born);\n+  free (reg_where_born_exact);\n+  free (reg_where_born_clobber);\n+  free (reg_where_dead_chain);\n   free (reg_order);\n   free (regs_change_size);\n   free (regs_crosses_setjmp);\n@@ -336,8 +459,8 @@ stupid_reg_compare (r1p, r2p)\n      const GENERIC_PTR r2p;\n {\n   register int r1 = *(int *)r1p, r2 = *(int *)r2p;\n-  register int len1 = reg_where_dead[r1] - reg_where_born[r1];\n-  register int len2 = reg_where_dead[r2] - reg_where_born[r2];\n+  register int len1 = reg_where_dead[r1] - REG_WHERE_BORN (r1);\n+  register int len2 = reg_where_dead[r2] - REG_WHERE_BORN (r2);\n   int tem;\n \n   tem = len2 - len1;\n@@ -470,12 +593,14 @@ stupid_find_reg (call_preserved, class, mode,\n    INSN is the current insn, supplied so we can find its suid.  */\n \n static void\n-stupid_mark_refs (x, insn)\n-     rtx x, insn;\n+stupid_mark_refs (x, chain)\n+     rtx x;\n+     struct insn_chain *chain;\n {\n   register RTX_CODE code;\n   register char *fmt;\n   register int regno, i;\n+  rtx insn = chain->insn;\n \n   if (x == 0)\n     return;\n@@ -530,7 +655,11 @@ stupid_mark_refs (x, insn)\n \t\t the clobbering insn.  When setting, just after.  */\n \t      int where_born = INSN_SUID (insn) - (code == CLOBBER);\n \n-\t      reg_where_born[regno] = where_born;\n+\t      reg_where_born_exact[regno] = INSN_SUID (insn);\n+\t      reg_where_born_clobber[regno] = (code == CLOBBER);\n+\n+\t      if (reg_where_dead_chain[regno] == 0)\n+\t\treg_where_dead_chain[regno] = chain;\n \n \t      /* The reg must live at least one insn even\n \t\t in it is never again used--because it has to go\n@@ -573,9 +702,9 @@ stupid_mark_refs (x, insn)\n \t If setting a SUBREG, we treat the entire reg as *used*.  */\n       if (code == SET)\n \t{\n-\t  stupid_mark_refs (SET_SRC (x), insn);\n+\t  stupid_mark_refs (SET_SRC (x), chain);\n \t  if (GET_CODE (SET_DEST (x)) != REG)\n-\t    stupid_mark_refs (SET_DEST (x), insn);\n+\t    stupid_mark_refs (SET_DEST (x), chain);\n \t}\n       return;\n     }\n@@ -608,12 +737,14 @@ stupid_mark_refs (x, insn)\n \t{\n \t  /* Pseudo reg: record first use, last use and number of uses.  */\n \n-\t  reg_where_born[regno] = INSN_SUID (insn);\n+\t  reg_where_born_exact[regno] = INSN_SUID (insn);\n+\t  reg_where_born_clobber[regno] = 0;\n \t  REG_N_REFS (regno)++;\n \t  if (regs_live[regno] == 0)\n \t    {\n \t      regs_live[regno] = 1;\n \t      reg_where_dead[regno] = INSN_SUID (insn);\n+\t      reg_where_dead_chain[regno] = chain;\n \t    }\n \t}\n       return;\n@@ -625,12 +756,12 @@ stupid_mark_refs (x, insn)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tstupid_mark_refs (XEXP (x, i), insn);\n+\tstupid_mark_refs (XEXP (x, i), chain);\n       if (fmt[i] == 'E')\n \t{\n \t  register int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    stupid_mark_refs (XVECEXP (x, i, j), insn);\n+\t    stupid_mark_refs (XVECEXP (x, i, j), chain);\n \t}\n     }\n }"}]}