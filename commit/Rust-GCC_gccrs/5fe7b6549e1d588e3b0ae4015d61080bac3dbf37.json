{"sha": "5fe7b6549e1d588e3b0ae4015d61080bac3dbf37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZlN2I2NTQ5ZTFkNTg4ZTNiMGFlNDAxNWQ2MTA4MGJhYzNkYmYzNw==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-07-21T00:06:45Z"}, "committer": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-07-21T00:06:45Z"}, "message": "re PR c++/509 (G++ forbids template specialization as ambiguous)\n\n\tPR c++/509\n\t* pt.c (determine_specialization): New parameter template_count.\n\tDisambiguate between member templates and member functions counting\n\tthe template headers.\n\t(check_explicit_specialization): Update caller.\n\t(tsubst_friend_function): Likewise.\n\n\tPR c++/509\n\t* g++.dg/template/spec15.C: New test.\n\nFrom-SVN: r84982", "tree": {"sha": "1312c53d8cf381419e2804cabd75d2dfe5541a6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1312c53d8cf381419e2804cabd75d2dfe5541a6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66e4969bb93f7012d6cc11131132424ea336cd4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e4969bb93f7012d6cc11131132424ea336cd4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e4969bb93f7012d6cc11131132424ea336cd4e"}], "stats": {"total": 102, "additions": 98, "deletions": 4}, "files": [{"sha": "5883b7e26deed87065665e3e15f2b94838dde228", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5fe7b6549e1d588e3b0ae4015d61080bac3dbf37", "patch": "@@ -1,3 +1,12 @@\n+2004-07-21  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/509\n+\t* pt.c (determine_specialization): New parameter template_count.\n+\tDisambiguate between member templates and member functions counting\n+\tthe template headers.\n+\t(check_explicit_specialization): Update caller.\n+\t(tsubst_friend_function): Likewise.\n+\n 2004-07-20  Steven Bosscher  <stevenb@suse.de>\n \n \t* cp-tree.def (TINST_LEVEL): Make it an 'x' node."}, {"sha": "3971b6d37d2b89c0d29d94055550ce5dbf9972da", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5fe7b6549e1d588e3b0ae4015d61080bac3dbf37", "patch": "@@ -155,7 +155,7 @@ static int verify_class_unification (tree, tree, tree);\n static tree try_class_unification (tree, tree, tree, tree);\n static int coerce_template_template_parms (tree, tree, tsubst_flags_t,\n \t\t\t\t\t   tree, tree);\n-static tree determine_specialization (tree, tree, tree *, int);\n+static tree determine_specialization (tree, tree, tree *, int, int);\n static int template_args_equal (tree, tree);\n static void tsubst_default_arguments (tree);\n static tree for_each_template_parm_r (tree *, int *, void *);\n@@ -1205,6 +1205,10 @@ print_candidates (tree fns)\n    If NEED_MEMBER_TEMPLATE is nonzero the function is known to be a\n    specialization of a member template.\n \n+   The TEMPLATE_COUNT is the number of references to qualifying\n+   template classes that appeared in the name of the function. See\n+   check_explicit_specialization for a more accurate description.\n+\n    The template args (those explicitly specified and those deduced)\n    are output in a newly created vector *TARGS_OUT.\n \n@@ -1215,13 +1219,16 @@ static tree\n determine_specialization (tree template_id, \n                           tree decl, \n                           tree* targs_out, \n-\t\t\t  int need_member_template)\n+\t\t\t  int need_member_template,\n+\t\t\t  int template_count)\n {\n   tree fns;\n   tree targs;\n   tree explicit_targs;\n   tree candidates = NULL_TREE;\n   tree templates = NULL_TREE;\n+  int header_count;\n+  struct cp_binding_level *b;\n \n   *targs_out = NULL_TREE;\n \n@@ -1244,6 +1251,14 @@ determine_specialization (tree template_id,\n       return error_mark_node;\n     }\n \n+  /* Count the number of template headers specified for this\n+     specialization.  */\n+  header_count = 0;\n+  for (b = current_binding_level;\n+       b->kind == sk_template_parms || b->kind == sk_template_spec;\n+       b = b->level_chain)\n+    ++header_count;\n+\n   for (; fns; fns = OVL_NEXT (fns))\n     {\n       tree fn = OVL_CURRENT (fns);\n@@ -1280,6 +1295,35 @@ determine_specialization (tree template_id,\n \t\t\t       TREE_VALUE (decl_arg_types)))\n \t    continue;\n \n+\t  /* In case of explicit specialization, we need to check if\n+\t     the number of template headers appearing in the specialization\n+\t     is correct. This is usually done in check_explicit_specialization,\n+\t     but the check done there cannot be exhaustive when specializing\n+\t     member functions. Consider the following code:\n+\n+\t     template <> void A<int>::f(int);\n+\t     template <> template <> void A<int>::f(int);\n+\n+\t     Assuming that A<int> is not itself an explicit specialization\n+\t     already, the first line specializes \"f\" which is a non-template\n+\t     member function, whilst the second line specializes \"f\" which\n+\t     is a template member function. So both lines are syntactically\n+\t     correct, and check_explicit_specialization does not reject\n+\t     them.\n+\t     \n+\t     Here, we can do better, as we are matching the specialization\n+\t     against the declarations. We count the number of template\n+\t     headers, and we check if they match TEMPLATE_COUNT + 1\n+\t     (TEMPLATE_COUNT is the number of qualifying template classes,\n+\t     plus there must be another header for the member template\n+\t     itself).\n+\t     \n+\t     Notice that if header_count is zero, this is not a\n+\t     specialization but rather a template instantiation, so there\n+\t     is no check we can perform here.  */\n+\t  if (header_count && header_count != template_count + 1)\n+\t    continue;\n+\n \t  /* See whether this function might be a specialization of this\n \t     template.  */\n \t  targs = get_bindings (fn, decl, explicit_targs);\n@@ -1872,7 +1916,8 @@ check_explicit_specialization (tree declarator,\n \t declaration.  */\n       tmpl = determine_specialization (declarator, decl,\n \t\t\t\t       &targs, \n-\t\t\t\t       member_specialization);\n+\t\t\t\t       member_specialization,\n+\t\t\t\t       template_count);\n \t    \n       if (!tmpl || tmpl == error_mark_node)\n \t/* We couldn't figure out what this declaration was\n@@ -4980,7 +5025,8 @@ tsubst_friend_function (tree decl, tree args)\n       new_friend = tsubst (decl, args, tf_error | tf_warning, NULL_TREE);\n       tmpl = determine_specialization (template_id, new_friend,\n \t\t\t\t       &new_args, \n-\t\t\t\t       /*need_member_template=*/0);\n+\t\t\t\t       /*need_member_template=*/0,\n+\t\t\t\t       TREE_VEC_LENGTH (args));\n       new_friend = instantiate_template (tmpl, new_args, tf_error);\n       goto done;\n     }"}, {"sha": "b939e330a34ac8d68d86947bae1ba324ab245f1e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5fe7b6549e1d588e3b0ae4015d61080bac3dbf37", "patch": "@@ -1,3 +1,8 @@\n+2004-07-21  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/509\n+\t* g++.dg/template/spec15.C: New test.\n+\n 2004-07-21  David Billinghurst (David.Billinghurst@riotinto.com)\n \n \tCopy cases from g77.f-torture/execute and add dg-run"}, {"sha": "fcf4ecb904dd157c004c670a99856da37105aee2", "filename": "gcc/testsuite/g++.dg/template/spec15.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fe7b6549e1d588e3b0ae4015d61080bac3dbf37/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fspec15.C?ref=5fe7b6549e1d588e3b0ae4015d61080bac3dbf37", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+// Contributed by Wolfgang Bangerth <bangerth at ticam dot utexas dot edu>\n+// PR c++/509: Make sure specializations of member templates match correctly\n+//  between template and non-template overloads.\n+\n+template <class T>\n+struct A {\n+  template <class U> void f (U);\n+  void f2 (int);\n+\n+  template <class U> void h (U);\n+  void h (long);\n+};\n+\n+template <>\n+struct A<float> {\n+  template <class U> void g (U);\n+  void g2 (float);\n+};\n+\n+template <> void A<int>::f (int);                    // { dg-error \"\" }\n+template <> template <> void A<int>::f (int);\n+\n+template <> void A<int>::f2 (int);\n+template <> template <> void A<int>::f2 (int);       // { dg-error \"\" }\n+\n+template <> void A<float>::g (float);\n+template <> template <> void A<float>::g(float);     // { dg-error \"\" }\n+\n+template <> void A<float>::g2 (float);               // { dg-error \"\" }\n+template <> template <> void A<float>::g2(float);    // { dg-error \"\" }\n+\n+template <> void A<long>::h (long);\n+template <> template <> void A<long>::h(long);"}]}