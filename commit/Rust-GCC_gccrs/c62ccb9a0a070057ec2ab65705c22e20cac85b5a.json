{"sha": "c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYyY2NiOWEwYTA3MDA1N2VjMmFiNjU3MDVjMjJlMjBjYWM4NWI1YQ==", "commit": {"author": {"name": "Yury Gribov", "email": "y.gribov@samsung.com", "date": "2014-08-11T06:12:12Z"}, "committer": {"name": "Yury Gribov", "email": "ygribov@gcc.gnu.org", "date": "2014-08-11T06:12:12Z"}, "message": "Move inlining of Asan memory checks to sanopt pass.\n\nChange asan-instrumentation-with-call-threshold to more closely match LLVM.\n\n2014-08-11  Yury Gribov  <y.gribov@samsung.com>\n\ngcc/\n\t* asan.c (asan_check_flags): New enum.\n\t(build_check_stmt_with_calls): Removed function.\n\t(build_check_stmt): Split inlining logic to\n\tasan_expand_check_ifn.\n\t(instrument_derefs): Rename parameter.\n\t(instrument_mem_region_access): Rename parameter.\n\t(instrument_strlen_call): Likewise.\n\t(asan_expand_check_ifn): New function.\n\t(asan_instrument): Remove old code.\n\t(pass_sanopt::execute): Change handling of\n\tasan-instrumentation-with-call-threshold.\n\t(asan_clear_shadow): Fix formatting.\n\t(asan_function_start): Likewise.\n\t(asan_emit_stack_protection): Likewise.\n\t* doc/invoke.texi (asan-instrumentation-with-call-threshold):\n\tUpdate description.\n\t* internal-fn.c (expand_ASAN_CHECK): New function.\n\t* internal-fn.def (ASAN_CHECK): New internal function.\n\t* params.def (PARAM_ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD):\n\tUpdate description.\n\t(PARAM_ASAN_USE_AFTER_RETURN): Likewise.\n\t* tree.c: Small comment fix.\n\ngcc/testsuite/\n\t* c-c++-common/asan/inc.c: Update test.\n\t* c-c++-common/asan/instrument-with-calls-2.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-1.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-2.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-3.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-4.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-5.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-6.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-7.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-8.c: Likewise.\n\t* c-c++-common/asan/no-redundant-instrumentation-9.c: Likewise.\n\nFrom-SVN: r213807", "tree": {"sha": "6826f489d7504e14431774d4f067f4d6a123551a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6826f489d7504e14431774d4f067f4d6a123551a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/comments", "author": null, "committer": null, "parents": [{"sha": "b78475cf7322cdce66bae717ee5768baabe8f8d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78475cf7322cdce66bae717ee5768baabe8f8d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78475cf7322cdce66bae717ee5768baabe8f8d6"}], "stats": {"total": 729, "additions": 403, "deletions": 326}, "files": [{"sha": "be17bd84dd0c7a9f92de91a6dedbec7d83c58253", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,3 +1,28 @@\n+2014-08-11  Yury Gribov  <y.gribov@samsung.com>\n+\n+\t* asan.c (asan_check_flags): New enum.\n+\t(build_check_stmt_with_calls): Removed function.\n+\t(build_check_stmt): Split inlining logic to\n+\tasan_expand_check_ifn.\n+\t(instrument_derefs): Rename parameter.\n+\t(instrument_mem_region_access): Rename parameter.\n+\t(instrument_strlen_call): Likewise.\n+\t(asan_expand_check_ifn): New function.\n+\t(asan_instrument): Remove old code.\n+\t(pass_sanopt::execute): Change handling of\n+\tasan-instrumentation-with-call-threshold.\n+\t(asan_clear_shadow): Fix formatting.\n+\t(asan_function_start): Likewise.\n+\t(asan_emit_stack_protection): Likewise.\n+\t* doc/invoke.texi (asan-instrumentation-with-call-threshold):\n+\tUpdate description.\n+\t* internal-fn.c (expand_ASAN_CHECK): New function.\n+\t* internal-fn.def (ASAN_CHECK): New internal function.\n+\t* params.def (PARAM_ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD):\n+\tUpdate description.\n+\t(PARAM_ASAN_USE_AFTER_RETURN): Likewise.\n+\t* tree.c: Small comment fix.\n+\n 2014-08-11  Yury Gribov  <y.gribov@samsung.com>\n \n \t* gimple.c (gimple_call_fnspec): Support internal functions."}, {"sha": "4e6f43860fa48f8eed8cba081b0916b93863bf91", "filename": "gcc/asan.c", "status": "modified", "additions": 293, "deletions": 264, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -244,18 +244,16 @@ static GTY(()) tree shadow_ptr_types[2];\n /* Decl for __asan_option_detect_stack_use_after_return.  */\n static GTY(()) tree asan_detect_stack_use_after_return;\n \n-/* Number of instrumentations in current function so far.  */\n-\n-static int asan_num_accesses;\n-\n-/* Check whether we should replace inline instrumentation with calls.  */\n-\n-static inline bool\n-use_calls_p ()\n+/* Various flags for Asan builtins.  */\n+enum asan_check_flags\n {\n-  return ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD < INT_MAX\n-    && asan_num_accesses >= ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD;\n-}\n+  ASAN_CHECK_STORE = 1 << 0,\n+  ASAN_CHECK_SCALAR_ACCESS = 1 << 1,\n+  ASAN_CHECK_NON_ZERO_LEN = 1 << 2,\n+  ASAN_CHECK_START_INSTRUMENTED = 1 << 3,\n+  ASAN_CHECK_END_INSTRUMENTED = 1 << 4,\n+  ASAN_CHECK_LAST\n+};\n \n /* Hashtable support for memory references used by gimple\n    statements.  */\n@@ -945,7 +943,7 @@ asan_clear_shadow (rtx shadow_mem, HOST_WIDE_INT len)\n \n   emit_move_insn (shadow_mem, const0_rtx);\n   tmp = expand_simple_binop (Pmode, PLUS, addr, gen_int_mode (4, Pmode), addr,\n-                             true, OPTAB_LIB_WIDEN);\n+\t\t\t     true, OPTAB_LIB_WIDEN);\n   if (tmp != addr)\n     emit_move_insn (addr, tmp);\n   emit_cmp_and_jump_insns (addr, end, LT, NULL_RTX, Pmode, true, top_label);\n@@ -960,7 +958,7 @@ asan_function_start (void)\n   section *fnsec = function_section (current_function_decl);\n   switch_to_section (fnsec);\n   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LASANPC\",\n-                         current_function_funcdef_no);\n+\t\t\t current_function_funcdef_no);\n }\n \n /* Insert code to protect stack vars.  The prologue sequence should be emitted\n@@ -1025,7 +1023,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n     {\n       use_after_return_class = floor_log2 (asan_frame_size - 1) - 5;\n       /* __asan_stack_malloc_N guarantees alignment\n-         N < 6 ? (64 << N) : 4096 bytes.  */\n+\t N < 6 ? (64 << N) : 4096 bytes.  */\n       if (alignb > (use_after_return_class < 6\n \t\t    ? (64U << use_after_return_class) : 4096U))\n \tuse_after_return_class = -1;\n@@ -1098,7 +1096,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LASANPC\", current_function_funcdef_no);\n   id = get_identifier (buf);\n   decl = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n-                    VAR_DECL, id, char_type_node);\n+\t\t    VAR_DECL, id, char_type_node);\n   SET_DECL_ASSEMBLER_NAME (decl, id);\n   TREE_ADDRESSABLE (decl) = 1;\n   TREE_READONLY (decl) = 1;\n@@ -1555,55 +1553,6 @@ maybe_create_ssa_name (location_t loc, tree base, gimple_stmt_iterator *iter,\n   return gimple_assign_lhs (g);\n }\n \n-/* Instrument the memory access instruction using callbacks.\n-   Parameters are similar to BUILD_CHECK_STMT.  */\n-\n-static void\n-build_check_stmt_with_calls (location_t loc, tree base, tree len,\n-\t\t\t     HOST_WIDE_INT size_in_bytes, gimple_stmt_iterator *iter,\n-\t\t\t     bool before_p, bool is_store, bool is_scalar_access)\n-{\n-  gimple_stmt_iterator gsi = *iter;\n-  tree base_ssa = maybe_create_ssa_name (loc, base, &gsi, before_p);\n-\n-  gimple g\n-    = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (pointer_sized_int_node, NULL),\n-\t\t\t\t    base_ssa, NULL_TREE);\n-  gimple_set_location (g, loc);\n-  if (before_p)\n-    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n-  else\n-    gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-  tree base_addr = gimple_assign_lhs (g);\n-\n-  int nargs;\n-  tree fun\n-    = check_func (is_store, is_scalar_access ? size_in_bytes : -1, &nargs);\n-  if (nargs == 1)\n-    g = gimple_build_call (fun, 1, base_addr);\n-  else\n-    {\n-      gcc_assert (nargs == 2);\n-      g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\tmake_ssa_name (pointer_sized_int_node,\n-\t\t\t\t\t\t       NULL),\n-\t\t\t\t\tlen, NULL_TREE);\n-      gimple_set_location (g, loc);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-      tree sz_arg = gimple_assign_lhs (g);\n-      g = gimple_build_call (fun, nargs, base_addr, sz_arg);\n-    }\n-  gimple_set_location (g, loc);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n-  if (!before_p)\n-    {\n-      gsi_next (&gsi);\n-      *iter = gsi;\n-    }\n-}\n-\n /* Instrument the memory access instruction BASE.  Insert new\n    statements before or after ITER.\n \n@@ -1624,27 +1573,30 @@ build_check_stmt_with_calls (location_t loc, tree base, tree len,\n    otherwise, it points to the statement logically following it.  */\n \n static void\n-build_check_stmt (location_t location, tree base, tree len,\n+build_check_stmt (location_t loc, tree base, tree len,\n \t\t  HOST_WIDE_INT size_in_bytes, gimple_stmt_iterator *iter,\n-\t\t  bool non_zero_len_p, bool before_p, bool is_store,\n+\t\t  bool is_non_zero_len, bool before_p, bool is_store,\n \t\t  bool is_scalar_access, unsigned int align = 0,\n \t\t  bool start_instrumented = false,\n \t\t  bool end_instrumented = false)\n {\n   gimple_stmt_iterator gsi = *iter;\n   gimple g;\n-  tree uintptr_type\n-    = build_nonstandard_integer_type (TYPE_PRECISION (TREE_TYPE (base)), 1);\n \n-  gcc_assert (!(size_in_bytes > 0 && !non_zero_len_p));\n+  gcc_assert (!(size_in_bytes > 0 && !is_non_zero_len));\n \n   if (start_instrumented && end_instrumented)\n     {\n       if (!before_p)\n-        gsi_next (iter);\n+\tgsi_next (iter);\n       return;\n     }\n \n+  gsi = *iter;\n+\n+  base = unshare_expr (base);\n+  base = maybe_create_ssa_name (loc, base, &gsi, before_p);\n+\n   if (len)\n     len = unshare_expr (len);\n   else\n@@ -1656,9 +1608,8 @@ build_check_stmt (location_t location, tree base, tree len,\n   if (size_in_bytes > 1)\n     {\n       if ((size_in_bytes & (size_in_bytes - 1)) != 0\n-\t  || !is_scalar_access\n \t  || size_in_bytes > 16)\n-\tsize_in_bytes = -1;\n+\tis_scalar_access = false;\n       else if (align && align < size_in_bytes * BITS_PER_UNIT)\n \t{\n \t  /* On non-strict alignment targets, if\n@@ -1669,189 +1620,34 @@ build_check_stmt (location_t location, tree base, tree len,\n \t  if (size_in_bytes != 16\n \t      || STRICT_ALIGNMENT\n \t      || align < 8 * BITS_PER_UNIT)\n-\t    size_in_bytes = -1;\n-\t}\n-    }\n-\n-  HOST_WIDE_INT real_size_in_bytes = size_in_bytes == -1 ? 1 : size_in_bytes;\n-\n-  tree shadow_ptr_type = shadow_ptr_types[real_size_in_bytes == 16 ? 1 : 0];\n-  tree shadow_type = TREE_TYPE (shadow_ptr_type);\n-\n-  base = unshare_expr (base);\n-\n-  if (use_calls_p ())\n-    {\n-      gsi = *iter;\n-      build_check_stmt_with_calls (location, base, len, size_in_bytes, iter,\n-\t\t\t\t   before_p, is_store, is_scalar_access);\n-      return;\n-    }\n-\n-  ++asan_num_accesses;\n-\n-  if (!non_zero_len_p)\n-    {\n-      gcc_assert (before_p);\n-\n-      /* So, the length of the memory area to asan-protect is\n-\t non-constant.  Let's guard the generated instrumentation code\n-\t like:\n-\n-\t if (len != 0)\n-\t   {\n-\t     //asan instrumentation code goes here.\n-\t   }\n-\t // falltrough instructions, starting with *ITER.  */\n-\n-      g = gimple_build_cond (NE_EXPR,\n-\t\t\t     len,\n-\t\t\t     build_int_cst (TREE_TYPE (len), 0),\n-\t\t\t     NULL_TREE, NULL_TREE);\n-      gimple_set_location (g, location);\n-\n-      basic_block then_bb, fallthrough_bb;\n-      insert_if_then_before_iter (g, iter, /*then_more_likely_p=*/true,\n-\t\t\t\t  &then_bb, &fallthrough_bb);\n-      /* Note that fallthrough_bb starts with the statement that was\n-\t pointed to by ITER.  */\n-\n-      /* The 'then block' of the 'if (len != 0) condition is where\n-\t we'll generate the asan instrumentation code now.  */\n-      gsi = gsi_last_bb (then_bb);\n-      build_check_stmt (location, base, len, size_in_bytes, &gsi,\n-\t\t\t/*non_zero_len_p*/true, /*before_p*/true, is_store,\n-\t\t\tis_scalar_access, align,\n-\t\t\tstart_instrumented, end_instrumented);\n-      return;\n-    }\n-\n-  /* Get an iterator on the point where we can add the condition\n-     statement for the instrumentation.  */\n-  basic_block then_bb, else_bb;\n-  gsi = create_cond_insert_point (&gsi, before_p,\n-\t\t\t\t  /*then_more_likely_p=*/false,\n-\t\t\t\t  /*create_then_fallthru_edge=*/false,\n-\t\t\t\t  &then_bb,\n-\t\t\t\t  &else_bb);\n-\n-  tree base_ssa = maybe_create_ssa_name (location, base, &gsi,\n-\t\t\t\t\t /*before_p*/false);\n-\n-  g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n-\t\t\t\t    base_ssa, NULL_TREE);\n-  gimple_set_location (g, location);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-  tree base_addr = gimple_assign_lhs (g);\n-\n-  tree t = NULL_TREE;\n-  if (real_size_in_bytes >= 8)\n-    {\n-      tree shadow = build_shadow_mem_access (&gsi, location, base_addr,\n-\t\t\t\t\t     shadow_ptr_type);\n-      t = shadow;\n-    }\n-  else\n-    {\n-      /* Slow path for 1, 2 and 4 byte accesses.  */\n-\n-      if (!start_instrumented)\n-\t{\n-\t  /* Test (shadow != 0)\n-\t\t  & ((base_addr & 7) + (real_size_in_bytes - 1)) >= shadow).  */\n-\t  tree shadow = build_shadow_mem_access (&gsi, location, base_addr,\n-\t\t\t\t\t\t shadow_ptr_type);\n-\t  gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n-\t  gimple_seq seq = NULL;\n-\t  gimple_seq_add_stmt (&seq, shadow_test);\n-\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, base_addr, 7));\n-\t  gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n-\t\t\t\t\t\t      gimple_seq_last (seq)));\n-\t  if (real_size_in_bytes > 1)\n-\t    gimple_seq_add_stmt (&seq,\n-\t\t\t\t build_assign (PLUS_EXPR, gimple_seq_last (seq),\n-\t\t\t\t\t       real_size_in_bytes - 1));\n-\t  gimple_seq_add_stmt (&seq, build_assign (GE_EXPR,\n-\t\t\t\t\t\t   gimple_seq_last (seq),\n-\t\t\t\t\t\t   shadow));\n-\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n-\t\t\t\t\t\t   gimple_seq_last (seq)));\n-\t  t = gimple_assign_lhs (gimple_seq_last (seq));\n-\t  gimple_seq_set_location (seq, location);\n-\t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n-\t}\n-\n-      /* For non-constant, misaligned or otherwise weird access sizes,\n-\t check first and last byte.  */\n-      if (size_in_bytes == -1 && !end_instrumented)\n-\t{\n-\t  g = gimple_build_assign_with_ops (MINUS_EXPR,\n-\t\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n-\t\t\t\t\t    len,\n-\t\t\t\t\t    build_int_cst (uintptr_type, 1));\n-\t  gimple_set_location (g, location);\n-\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\t  tree last = gimple_assign_lhs (g);\n-\t  g = gimple_build_assign_with_ops (PLUS_EXPR,\n-\t\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n-\t\t\t\t\t    base_addr,\n-\t\t\t\t\t    last);\n-\t  gimple_set_location (g, location);\n-\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\t  tree base_end_addr = gimple_assign_lhs (g);\n-\n-\t  tree shadow = build_shadow_mem_access (&gsi, location, base_end_addr,\n-\t\t\t\t\t\t shadow_ptr_type);\n-\t  gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n-\t  gimple_seq seq = NULL;\n-\t  gimple_seq_add_stmt (&seq, shadow_test);\n-\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR,\n-\t\t\t\t\t\t   base_end_addr, 7));\n-\t  gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n-\t\t\t\t\t\t      gimple_seq_last (seq)));\n-\t  gimple_seq_add_stmt (&seq, build_assign (GE_EXPR,\n-\t\t\t\t\t\t   gimple_seq_last (seq),\n-\t\t\t\t\t\t   shadow));\n-\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n-\t\t\t\t\t\t   gimple_seq_last (seq)));\n-\t  if (!start_instrumented)\n-\t    gimple_seq_add_stmt (&seq, build_assign (BIT_IOR_EXPR, t,\n-\t\t\t\t\t\t     gimple_seq_last (seq)));\n-\t  t = gimple_assign_lhs (gimple_seq_last (seq));\n-\t  gimple_seq_set_location (seq, location);\n-\t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+\t    is_scalar_access = false;\n \t}\n     }\n \n-  g = gimple_build_cond (NE_EXPR, t, build_int_cst (TREE_TYPE (t), 0),\n-\t\t\t NULL_TREE, NULL_TREE);\n-  gimple_set_location (g, location);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n-  /* Generate call to the run-time library (e.g. __asan_report_load8).  */\n-  gsi = gsi_start_bb (then_bb);\n-  int nargs;\n-  tree fun = report_error_func (is_store, is_scalar_access ? size_in_bytes : -1,\n-\t\t\t\t&nargs);\n-  if (nargs == 1)\n-      g = gimple_build_call (fun, 1, base_addr);\n+  HOST_WIDE_INT flags = 0;\n+  if (is_store)\n+    flags |= ASAN_CHECK_STORE;\n+  if (is_non_zero_len)\n+    flags |= ASAN_CHECK_NON_ZERO_LEN;\n+  if (is_scalar_access)\n+    flags |= ASAN_CHECK_SCALAR_ACCESS;\n+  if (start_instrumented)\n+    flags |= ASAN_CHECK_START_INSTRUMENTED;\n+  if (end_instrumented)\n+    flags |= ASAN_CHECK_END_INSTRUMENTED;\n+\n+  g = gimple_build_call_internal (IFN_ASAN_CHECK, 3,\n+\t\t\t\t  build_int_cst (integer_type_node, flags),\n+\t\t\t\t  base, len);\n+  gimple_set_location (g, loc);\n+  if (before_p)\n+    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n   else\n     {\n-      gcc_assert (nargs == 2);\n-      g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\tmake_ssa_name (pointer_sized_int_node,\n-\t\t\t\t\t\t       NULL),\n-\t\t\t\t\tlen, NULL_TREE);\n-      gimple_set_location (g, location);\n       gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-      tree sz_arg = gimple_assign_lhs (g);\n-      g = gimple_build_call (fun, nargs, base_addr, sz_arg);\n+      gsi_next (&gsi);\n+      *iter = gsi;\n     }\n-  gimple_set_location (g, location);\n-  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n-  *iter = gsi_start_bb (else_bb);\n }\n \n /* If T represents a memory access, add instrumentation code before ITER.\n@@ -1944,7 +1740,7 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n     {\n       unsigned int align = get_object_alignment (t);\n       build_check_stmt (location, base, NULL_TREE, size_in_bytes, iter,\n-\t\t\t/*non_zero_len_p*/size_in_bytes > 0, /*before_p=*/true,\n+\t\t\t/*is_non_zero_len*/size_in_bytes > 0, /*before_p=*/true,\n \t\t\tis_store, /*is_scalar_access*/true, align);\n       update_mem_ref_hash_table (base, size_in_bytes);\n       update_mem_ref_hash_table (t, size_in_bytes);\n@@ -1982,7 +1778,7 @@ instrument_mem_region_access (tree base, tree len,\n   HOST_WIDE_INT size_in_bytes = tree_fits_shwi_p (len) ? tree_to_shwi (len) : -1;\n \n   build_check_stmt (location, base, len, size_in_bytes, iter,\n-\t\t    /*non_zero_len_p*/size_in_bytes > 0, /*before_p*/true,\n+\t\t    /*is_non_zero_len*/size_in_bytes > 0, /*before_p*/true,\n \t\t    is_store, /*is_scalar_access*/false, /*align*/0,\n \t\t    start_instrumented, end_instrumented);\n \n@@ -2039,7 +1835,7 @@ instrument_strlen_call (gimple_stmt_iterator *iter)\n   gsi_insert_before (iter, str_arg_ssa, GSI_SAME_STMT);\n \n   build_check_stmt (loc, gimple_assign_lhs (str_arg_ssa), NULL_TREE, 1, iter,\n-\t\t    /*non_zero_len_p*/true, /*before_p=*/true,\n+\t\t    /*is_non_zero_len*/true, /*before_p=*/true,\n \t\t    /*is_store=*/false, /*is_scalar_access*/true, /*align*/0,\n \t\t    start_instrumented, start_instrumented);\n \n@@ -2052,7 +1848,7 @@ instrument_strlen_call (gimple_stmt_iterator *iter)\n   gsi_insert_after (iter, g, GSI_NEW_STMT);\n \n   build_check_stmt (loc, gimple_assign_lhs (g), NULL_TREE, 1, iter,\n-\t\t    /*non_zero_len_p*/true, /*before_p=*/false,\n+\t\t    /*is_non_zero_len*/true, /*before_p=*/false,\n \t\t    /*is_store=*/false, /*is_scalar_access*/true, /*align*/0);\n \n   return true;\n@@ -2619,14 +2415,222 @@ asan_finish_file (void)\n   flag_sanitize |= SANITIZE_ADDRESS;\n }\n \n+/* Expand the ASAN_{LOAD,STORE} builtins.  */\n+\n+static bool\n+asan_expand_check_ifn (gimple_stmt_iterator *iter, bool use_calls)\n+{\n+  gimple g = gsi_stmt (*iter);\n+  location_t loc = gimple_location (g);\n+\n+  HOST_WIDE_INT flags = tree_to_shwi (gimple_call_arg (g, 0));\n+  gcc_assert (flags < ASAN_CHECK_LAST);\n+  bool is_scalar_access = (flags & ASAN_CHECK_SCALAR_ACCESS) != 0;\n+  bool is_store = (flags & ASAN_CHECK_STORE) != 0;\n+  bool is_non_zero_len = (flags & ASAN_CHECK_NON_ZERO_LEN) != 0;\n+  bool start_instrumented = (flags & ASAN_CHECK_START_INSTRUMENTED) != 0;\n+  bool end_instrumented = (flags & ASAN_CHECK_END_INSTRUMENTED) != 0;\n+\n+  tree base = gimple_call_arg (g, 1);\n+  tree len = gimple_call_arg (g, 2);\n+\n+  HOST_WIDE_INT size_in_bytes\n+    = is_scalar_access && tree_fits_shwi_p (len) ? tree_to_shwi (len) : -1;\n+\n+  if (use_calls)\n+    {\n+      /* Instrument using callbacks.  */\n+      gimple g\n+\t= gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\tmake_ssa_name (pointer_sized_int_node,\n+\t\t\t\t\tNULL),\n+\t\t\t\t\tbase, NULL_TREE);\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (iter, g, GSI_SAME_STMT);\n+      tree base_addr = gimple_assign_lhs (g);\n+\n+      int nargs;\n+      tree fun = check_func (is_store, size_in_bytes, &nargs);\n+      if (nargs == 1)\n+\tg = gimple_build_call (fun, 1, base_addr);\n+      else\n+\t{\n+\t  gcc_assert (nargs == 2);\n+\t  g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t\t    make_ssa_name (pointer_sized_int_node,\n+\t\t\t\t\t\t\t   NULL),\n+\t\t\t\t\t    len, NULL_TREE);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (iter, g, GSI_SAME_STMT);\n+\t  tree sz_arg = gimple_assign_lhs (g);\n+\t  g = gimple_build_call (fun, nargs, base_addr, sz_arg);\n+\t}\n+      gimple_set_location (g, loc);\n+      gsi_replace (iter, g, false);\n+      return false;\n+    }\n+\n+  HOST_WIDE_INT real_size_in_bytes = size_in_bytes == -1 ? 1 : size_in_bytes;\n+\n+  tree uintptr_type\n+    = build_nonstandard_integer_type (TYPE_PRECISION (TREE_TYPE (base)), 1);\n+\n+  tree shadow_ptr_type = shadow_ptr_types[real_size_in_bytes == 16 ? 1 : 0];\n+  tree shadow_type = TREE_TYPE (shadow_ptr_type);\n+\n+  gimple_stmt_iterator gsi = *iter;\n+\n+  if (!is_non_zero_len)\n+    {\n+      /* So, the length of the memory area to asan-protect is\n+\t non-constant.  Let's guard the generated instrumentation code\n+\t like:\n+\n+\t if (len != 0)\n+\t   {\n+\t     //asan instrumentation code goes here.\n+\t   }\n+\t // falltrough instructions, starting with *ITER.  */\n+\n+      g = gimple_build_cond (NE_EXPR,\n+\t\t\t    len,\n+\t\t\t    build_int_cst (TREE_TYPE (len), 0),\n+\t\t\t    NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, loc);\n+\n+      basic_block then_bb, fallthrough_bb;\n+      insert_if_then_before_iter (g, iter, /*then_more_likely_p=*/true,\n+\t\t\t\t &then_bb, &fallthrough_bb);\n+      /* Note that fallthrough_bb starts with the statement that was\n+\tpointed to by ITER.  */\n+\n+      /* The 'then block' of the 'if (len != 0) condition is where\n+\twe'll generate the asan instrumentation code now.  */\n+      gsi = gsi_last_bb (then_bb);\n+    }\n+\n+  /* Get an iterator on the point where we can add the condition\n+     statement for the instrumentation.  */\n+  basic_block then_bb, else_bb;\n+  gsi = create_cond_insert_point (&gsi, /*before_p*/false,\n+\t\t\t\t  /*then_more_likely_p=*/false,\n+\t\t\t\t  /*create_then_fallthru_edge=*/false,\n+\t\t\t\t  &then_bb,\n+\t\t\t\t  &else_bb);\n+\n+  g = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t    make_ssa_name (pointer_sized_int_node,\n+\t\t\t\t\t\t   NULL),\n+\t\t\t\t    base, NULL_TREE);\n+  gimple_set_location (g, loc);\n+  gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+  tree base_addr = gimple_assign_lhs (g);\n+\n+  tree t = NULL_TREE;\n+  if (real_size_in_bytes >= 8)\n+    {\n+      tree shadow = build_shadow_mem_access (&gsi, loc, base_addr,\n+\t\t\t\t\t     shadow_ptr_type);\n+      t = shadow;\n+    }\n+  else\n+    {\n+      /* Slow path for 1, 2 and 4 byte accesses.  */\n+\n+      if (!start_instrumented)\n+\t{\n+\t  /* Test (shadow != 0)\n+\t     & ((base_addr & 7) + (real_size_in_bytes - 1)) >= shadow).  */\n+\t  tree shadow = build_shadow_mem_access (&gsi, loc, base_addr,\n+\t\t\t\t\t\t shadow_ptr_type);\n+\t  gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n+\t  gimple_seq seq = NULL;\n+\t  gimple_seq_add_stmt (&seq, shadow_test);\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, base_addr, 7));\n+\t  gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n+\t\t\t\t\t\t      gimple_seq_last (seq)));\n+\t  if (real_size_in_bytes > 1)\n+\t    gimple_seq_add_stmt (&seq,\n+\t\t\t\t build_assign (PLUS_EXPR, gimple_seq_last (seq),\n+\t\t\t\t\t       real_size_in_bytes - 1));\n+\t  gimple_seq_add_stmt (&seq, build_assign (GE_EXPR,\n+\t\t\t\t\t\t   gimple_seq_last (seq),\n+\t\t\t\t\t\t   shadow));\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n+\t\t\t\t\t\t   gimple_seq_last (seq)));\n+\t  t = gimple_assign_lhs (gimple_seq_last (seq));\n+\t  gimple_seq_set_location (seq, loc);\n+\t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+\t}\n+\n+      /* For non-constant, misaligned or otherwise weird access sizes,\n+\t check first and last byte.  */\n+      if (size_in_bytes == -1 && !end_instrumented)\n+\t{\n+\t  g = gimple_build_assign_with_ops (MINUS_EXPR,\n+\t\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t\t    len,\n+\t\t\t\t\t    build_int_cst (uintptr_type, 1));\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\t  tree last = gimple_assign_lhs (g);\n+\t  g = gimple_build_assign_with_ops (PLUS_EXPR,\n+\t\t\t\t\t    make_ssa_name (uintptr_type, NULL),\n+\t\t\t\t\t    base_addr,\n+\t\t\t\t\t    last);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\t  tree base_end_addr = gimple_assign_lhs (g);\n+\n+\t  tree shadow = build_shadow_mem_access (&gsi, loc, base_end_addr,\n+\t\t\t\t\t\t shadow_ptr_type);\n+\t  gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n+\t  gimple_seq seq = NULL;\n+\t  gimple_seq_add_stmt (&seq, shadow_test);\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR,\n+\t\t\t\t\t\t   base_end_addr, 7));\n+\t  gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n+\t\t\t\t\t\t      gimple_seq_last (seq)));\n+\t  gimple_seq_add_stmt (&seq, build_assign (GE_EXPR,\n+\t\t\t\t\t\t   gimple_seq_last (seq),\n+\t\t\t\t\t\t   shadow));\n+\t  gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n+\t\t\t\t\t\t   gimple_seq_last (seq)));\n+\t  if (!start_instrumented)\n+\t    gimple_seq_add_stmt (&seq, build_assign (BIT_IOR_EXPR, t,\n+\t\t\t\t\t\t     gimple_seq_last (seq)));\n+\t  t = gimple_assign_lhs (gimple_seq_last (seq));\n+\t  gimple_seq_set_location (seq, loc);\n+\t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n+\t}\n+    }\n+\n+  g = gimple_build_cond (NE_EXPR, t, build_int_cst (TREE_TYPE (t), 0),\n+\t\t\t NULL_TREE, NULL_TREE);\n+  gimple_set_location (g, loc);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+  /* Generate call to the run-time library (e.g. __asan_report_load8).  */\n+  gsi = gsi_start_bb (then_bb);\n+  int nargs;\n+  tree fun = report_error_func (is_store, size_in_bytes, &nargs);\n+  g = gimple_build_call (fun, nargs, base_addr, len);\n+  gimple_set_location (g, loc);\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+  gsi_remove (iter, true);\n+  *iter = gsi_start_bb (else_bb);\n+\n+  return true;\n+}\n+\n /* Instrument the current function.  */\n \n static unsigned int\n asan_instrument (void)\n {\n   if (shadow_ptr_types[0] == NULL_TREE)\n     asan_init_shadow_ptr_types ();\n-  asan_num_accesses = 0;\n   transform_statements ();\n   return 0;\n }\n@@ -2747,6 +2751,23 @@ pass_sanopt::execute (function *fun)\n {\n   basic_block bb;\n \n+  int asan_num_accesses = 0;\n+  if (flag_sanitize & SANITIZE_ADDRESS)\n+    {\n+      gimple_stmt_iterator gsi;\n+      FOR_EACH_BB_FN (bb, fun)\n+\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+ \t    gimple stmt = gsi_stmt (gsi);\n+\t    if (is_gimple_call (stmt) && gimple_call_internal_p (stmt)\n+\t\t&& gimple_call_internal_fn (stmt) == IFN_ASAN_CHECK)\n+\t      ++asan_num_accesses;\n+\t  }\n+    }\n+\n+  bool use_calls = ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD < INT_MAX\n+    && asan_num_accesses >= ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD;\n+\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n@@ -2762,17 +2783,25 @@ pass_sanopt::execute (function *fun)\n \t    }\n \n \t  if (gimple_call_internal_p (stmt))\n-\t    switch (gimple_call_internal_fn (stmt))\n-\t      {\n-\t      case IFN_UBSAN_NULL:\n-\t\tno_next = ubsan_expand_null_ifn (&gsi);\n-\t\tbreak;\n-\t      case IFN_UBSAN_BOUNDS:\n-\t\tno_next = ubsan_expand_bounds_ifn (&gsi);\n-\t\tbreak;\n-\t      default:\n-\t\tbreak;\n-\t      }\n+\t    {\n+\t      enum internal_fn ifn = gimple_call_internal_fn (stmt);\n+\t      switch (ifn)\n+\t\t{\n+\t\tcase IFN_UBSAN_NULL:\n+\t\t  no_next = ubsan_expand_null_ifn (&gsi);\n+\t\t  break;\n+\t\tcase IFN_UBSAN_BOUNDS:\n+\t\t  no_next = ubsan_expand_bounds_ifn (&gsi);\n+\t\t  break;\n+\t\tcase IFN_ASAN_CHECK:\n+\t\t  {\n+\t\t    no_next = asan_expand_check_ifn (&gsi, use_calls);\n+\t\t    break;\n+\t\t  }\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {"}, {"sha": "91377fa4e3edf89cf1fea41186e12abc4012198e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -10385,9 +10385,9 @@ To disable use-after-return detection use\n @option{--param asan-use-after-return=0}.\n \n @item asan-instrumentation-with-call-threshold\n-Once number of memory accesses  in function becomes greater\n-or equal than this number, use callbacks instead of\n-generating inline code.  E.g. to disable inline code use\n+If number of memory accesses in function being instrumented\n+is greater or equal to this number, use callbacks instead of inline checks.\n+E.g. to disable inline code use\n @option{--param asan-instrumentation-with-call-threshold=0}.\n \n @end table"}, {"sha": "230fefca8ae7dd16159d8ec8f4c01108164e14b8", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -181,6 +181,14 @@ expand_UBSAN_BOUNDS (gimple stmt ATTRIBUTE_UNUSED)\n   gcc_unreachable ();\n }\n \n+/* This should get expanded in the sanopt pass.  */\n+\n+static void\n+expand_ASAN_CHECK (gimple stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Add sub/add overflow checking to the statement STMT.\n    CODE says whether the operation is +, or -.  */\n "}, {"sha": "7ae60f31c62461a8b65b7edf86d76c9bd2191569", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -55,3 +55,4 @@ DEF_INTERNAL_FN (UBSAN_CHECK_SUB, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (UBSAN_CHECK_MUL, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN, NULL)\n DEF_INTERNAL_FN (BUILTIN_EXPECT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (ASAN_CHECK, ECF_TM_PURE | ECF_LEAF | ECF_NOTHROW, \".W..\")"}, {"sha": "aefdd071f7aa4be9e3dd8d4c0b3389e57e4ee848", "filename": "gcc/params.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1085,14 +1085,14 @@ DEFPARAM (PARAM_ASAN_MEMINTRIN,\n \n DEFPARAM (PARAM_ASAN_USE_AFTER_RETURN,\n          \"asan-use-after-return\",\n-         \"Enable asan builtin functions protection\",\n+         \"Enable asan detection of use-after-return bugs\",\n          1, 0, 1)\n \n DEFPARAM (PARAM_ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD,\n          \"asan-instrumentation-with-call-threshold\",\n-         \"Use callbacks instead of inline code once number of accesses \"\n-         \" in function becomes greater or equal than this threshold\",\n-         10000, 0, INT_MAX)\n+         \"Use callbacks instead of inline code if number of accesses \"\n+         \"in function becomes greater or equal to this number\",\n+         7000, 0, INT_MAX)\n \n DEFPARAM (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS,\n \t  \"uninit-control-dep-attempts\","}, {"sha": "fb45cba1f05227e2ca4057fe26c8a9175765af79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,3 +1,17 @@\n+2014-08-11  Yury Gribov  <y.gribov@samsung.com>\n+\n+\t* c-c++-common/asan/inc.c: Update test.\n+\t* c-c++-common/asan/instrument-with-calls-2.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-1.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-2.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-3.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-4.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-5.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-6.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-7.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-8.c: Likewise.\n+\t* c-c++-common/asan/no-redundant-instrumentation-9.c: Likewise.\n+\n 2014-08-10 Marek Polacek  <polacek@redhat.com>\n \n \tPR c/51849"}, {"sha": "36cc3d8d81778f6deb0346c7f8453a14ebf5ea3d", "filename": "gcc/testsuite/c-c++-common/asan/inc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finc.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -16,6 +16,6 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 1 \"asan0\" } }  */\n-/* { dg-final { scan-tree-dump \"__builtin___asan_report_load4\" \"asan0\" } }  */\n+/* { dg-final { scan-tree-dump-times \"ASAN_\" 1 \"asan0\" } }  */\n+/* { dg-final { scan-tree-dump \"ASAN_CHECK \\\\(.*, 4\\\\);\" \"asan0\" } }  */\n /* { dg-final { cleanup-tree-dump \"asan0\" } } */"}, {"sha": "04fdad09d726d921499dfa1d6a614c842d7541e4", "filename": "gcc/testsuite/c-c++-common/asan/instrument-with-calls-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Finstrument-with-calls-2.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -9,8 +9,8 @@ void f(int *a, int *b) {\n   x = *b;\n }\n \n-/* { dg-final { scan-assembler-not \"__asan_store4\" } } */\n-/* { dg-final { scan-assembler \"__asan_report_store4\" } } */\n+/* { dg-final { scan-assembler \"__asan_store4\" } } */\n+/* { dg-final { scan-assembler-not \"__asan_report_store4\" } } */\n /* { dg-final { scan-assembler \"__asan_load4\" } } */\n /* { dg-final { scan-assembler-not \"__asan_report_load4\" } } */\n /* { dg-final { cleanup-saved-temps } } */"}, {"sha": "028f8d7152dfd48c6c4467fc61a7ed40fee15da4", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -2,7 +2,7 @@\n    location in the same basic block, the second reference should not\n    be instrumented by the Address Sanitizer.  */\n \n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -62,7 +62,7 @@ main ()\n   return test0 () && test1 (0);\n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 3 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load\" 1 \"asan0\" }  } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 3 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load\" 1 \"sanopt\" }  } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "a58411c3af3ed52cf36ab53f3ff55e1e81148729", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-2.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -3,7 +3,7 @@\n    be instrumented by the Address Sanitizer.  But in case of access to\n    overlapping regions we must be precise.  */\n \n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -20,7 +20,7 @@ main ()\n   __builtin_memset (tab, 1, 3);\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 3 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 2 \"asan0\" }  } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 3 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 2 \"sanopt\" }  } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "5193ae06f46978703d12045c6c23ed08e9ca0155", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-3.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-3.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -12,7 +12,7 @@ foo (__INT32_TYPE__ *p)\n   return ret; \n }\n \n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 2 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store\" 1 \"asan0\" } } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report\" 2 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store\" 1 \"sanopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "c3632aa3d2d99437307137f86662316500bea19b", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-4.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-4.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -10,8 +10,8 @@ foo  (int *a, char *b, char *c)\n   /* For a total of 5 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"asan0\" } } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"sanopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "077ea34d028e869d1fd50cc419fc13ba9115803e", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-5.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-5.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -10,9 +10,9 @@ foo  (int *a, char *b, char *c)\n   /* For a total of 5 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"asan0\" } } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"sanopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "6d87104aac2125de3c88de4a7059d1f2c093ba7d", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-6.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-6.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -12,9 +12,9 @@ foo  (int *a, char *b, char *c)\n   /* For a total of 8 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 8 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 2 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 2 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"asan0\" } } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 8 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 2 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 2 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 2 \"sanopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "5baa10dcd7dbab0efe3589ae34732b15f4bd7cba", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-7.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-7.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -21,7 +21,7 @@ foo  (int *a, char *b, char *c)\n   return d;\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 6 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 4 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-not \"__builtin___asan_report_store\" \"asan0\" } } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 6 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 4 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-not \"__builtin___asan_report_store\" \"sanopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "2a4c0812f3924bee26c0cc020806abe2cfb737e0", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-8.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-8.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -12,9 +12,9 @@ foo  (int *a, char *b, char *c)\n   /* For a total of 5 checks.  */\n }\n \n-/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"asan0\" } } */\n-/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"asan0\" } } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"& 7\" 5 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load1\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load4\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_load_n\" 1 \"sanopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store_n\" 1 \"sanopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "9449de578847f5aad19f804825dfb08180e98c0b", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-9.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-9.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-tree-asan0\" } */\n+/* { dg-options \"-fdump-tree-sanopt\" } */\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n@@ -9,5 +9,5 @@ f (char *a)\n   return  __builtin_strlen (a);\n }\n \n-/* { dg-final { scan-tree-dump-times \"__asan_report_load1\" 1 \"asan0\" } } */\n-/* { dg-final { cleanup-tree-dump \"asan0\" } } */\n+/* { dg-final { scan-tree-dump-times \"__asan_report_load1\" 1 \"sanopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"sanopt\" } } */"}, {"sha": "a446e07b23f420724f4d1dbdeb420dbb4e4f2473", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62ccb9a0a070057ec2ab65705c22e20cac85b5a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c62ccb9a0a070057ec2ab65705c22e20cac85b5a", "patch": "@@ -9870,7 +9870,7 @@ local_define_builtin (const char *name, tree type, enum built_in_function code,\n \n /* Call this function after instantiating all builtins that the language\n    front end cares about.  This will build the rest of the builtins\n-   and internal function that are relied upon by the tree optimizers and\n+   and internal functions that are relied upon by the tree optimizers and\n    the middle-end.  */\n \n void"}]}