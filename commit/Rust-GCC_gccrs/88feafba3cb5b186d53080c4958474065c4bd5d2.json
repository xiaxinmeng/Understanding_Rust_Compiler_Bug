{"sha": "88feafba3cb5b186d53080c4958474065c4bd5d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmZWFmYmEzY2I1YjE4NmQ1MzA4MGM0OTU4NDc0MDY1YzRiZDVkMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-11-27T12:16:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-11-27T12:16:54Z"}, "message": "re PR tree-optimization/92690 (vector CTOR optimization performs invalid conversion)\n\n2019-11-27  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/92690\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Avoid\n\tconverting elements not originally converted.\n\n\t* gcc.dg/torture/pr92690.c: New testcase.\n\t* gcc.dg/tree-ssa/forwprop-35.c: Adjust.\n\nFrom-SVN: r278764", "tree": {"sha": "7298af26e95c1f2a3f422cd75c35c6b583284c5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7298af26e95c1f2a3f422cd75c35c6b583284c5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88feafba3cb5b186d53080c4958474065c4bd5d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88feafba3cb5b186d53080c4958474065c4bd5d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88feafba3cb5b186d53080c4958474065c4bd5d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88feafba3cb5b186d53080c4958474065c4bd5d2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b7b848f5d7984a9984e0a518b75ff91a0de0cb32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7b848f5d7984a9984e0a518b75ff91a0de0cb32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7b848f5d7984a9984e0a518b75ff91a0de0cb32"}], "stats": {"total": 145, "additions": 102, "deletions": 43}, "files": [{"sha": "b0385da7c8f664bc0067b765b86ceea142c26f28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88feafba3cb5b186d53080c4958474065c4bd5d2", "patch": "@@ -1,3 +1,9 @@\n+2019-11-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92690\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Avoid\n+\tconverting elements not originally converted.\n+\n 2019-11-27  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR middle-end/92463"}, {"sha": "2fd0ae744114f17b0773f8a3f628cbbfa0c41c9f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88feafba3cb5b186d53080c4958474065c4bd5d2", "patch": "@@ -1,3 +1,9 @@\n+2019-11-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/92690\n+\t* gcc.dg/torture/pr92690.c: New testcase.\n+\t* gcc.dg/tree-ssa/forwprop-35.c: Adjust.\n+\n 2019-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/91944"}, {"sha": "b49f184fc09574d5d1416f0f908fb310c76e8c44", "filename": "gcc/testsuite/gcc.dg/torture/pr92690.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92690.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92690.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr92690.c?ref=88feafba3cb5b186d53080c4958474065c4bd5d2", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target *-*-*gnu* } } */\n+/* { dg-additional-options \"-D_GNU_SOURCE\" } */\n+/* { dg-require-effective-target fenv_exceptions } */\n+\n+#include <fenv.h>\n+\n+typedef int v4si __attribute__((vector_size(16)));\n+typedef float v4sf __attribute__((vector_size(16)));\n+\n+void __attribute__((noipa))\n+foo (v4si *dstp, v4sf *srcp)\n+{\n+  v4sf src = *srcp;\n+  *dstp = (v4si) { src[0], src[1], 3, 4 };\n+}\n+\n+void __attribute__((noipa))\n+bar (v4sf *dstp, v4si *srcp)\n+{\n+  v4si src = *srcp;\n+  *dstp = (v4sf) { src[0], src[1], 3.5, 4.5 };\n+}\n+\n+int\n+main()\n+{\n+  feenableexcept (FE_INVALID|FE_INEXACT);\n+  v4sf x = (v4sf) { 1, 2, __builtin_nanf (\"\"), 3.5 };\n+  v4si y;\n+  foo (&y, &x);\n+  if (y[0] != 1 || y[1] != 2 || y[2] != 3 || y[3] != 4)\n+    __builtin_abort ();\n+  y = (v4si) { 0, 1, __INT_MAX__, -__INT_MAX__ };\n+  bar (&x, &y);\n+  if (x[0] != 0 || x[1] != 1 || x[2] != 3.5 || x[3] != 4.5)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "24e63386960285699a636862fc7619bc0c8e4814", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-35.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-35.c?ref=88feafba3cb5b186d53080c4958474065c4bd5d2", "patch": "@@ -16,4 +16,5 @@ v4sf vec_cast_perm(v4si f)\n }\n \n /* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 1 \"cddce1\" { target { i?86-*-* x86_64-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"\\\\\\(v4sf\\\\\\) \" 2 \"cddce1\" { target { i?86-*-* x86_64-*-* } } } } */\n+/* Catch (v4sf) and (vector(4) float).  */\n+/* { dg-final { scan-tree-dump-times \" = \\\\\\(v\" 2 \"cddce1\" { target { i?86-*-* x86_64-*-* } } } } */"}, {"sha": "e1bdb49e91c86e4a30581d7d3ae339f273831469", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88feafba3cb5b186d53080c4958474065c4bd5d2/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=88feafba3cb5b186d53080c4958474065c4bd5d2", "patch": "@@ -2034,7 +2034,7 @@ static bool\n simplify_vector_constructor (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n-  tree op, op2, orig[2], type, elem_type;\n+  tree op, orig[2], type, elem_type;\n   unsigned elem_size, i;\n   unsigned HOST_WIDE_INT nelts;\n   unsigned HOST_WIDE_INT refnelts;\n@@ -2175,23 +2175,10 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   else\n     {\n       tree mask_type, perm_type, conv_src_type;\n-      if (orig[1] == error_mark_node && conv_code != ERROR_MARK)\n-\t{\n-\t  /* ???  For subsetting a larger vector we need to permute the original\n-\t     but then the constants are in the converted type already which is\n-\t     why for that case we first convert and then permute.  */\n-\t  if (nelts != refnelts)\n-\t    return false;\n-\t  conv_src_type = TREE_TYPE (orig[0]);\n-\t  perm_type = type;\n-\t}\n-      else\n-\t{\n-\t  perm_type = TREE_TYPE (orig[0]);\n-\t  conv_src_type = (nelts == refnelts\n-\t\t\t   ? perm_type\n-\t\t\t   : build_vector_type (TREE_TYPE (perm_type), nelts));\n-\t}\n+      perm_type = TREE_TYPE (orig[0]);\n+      conv_src_type = (nelts == refnelts\n+\t\t       ? perm_type\n+\t\t       : build_vector_type (TREE_TYPE (perm_type), nelts));\n       tree tem;\n       if (conv_code != ERROR_MARK\n \t  && (!supportable_convert_operation (conv_code, type, conv_src_type,\n@@ -2200,7 +2187,10 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \treturn false;\n \n       /* Now that we know the number of elements of the source build the\n-\t permute vector.  */\n+\t permute vector.\n+\t ???  When the second vector has constant values we can shuffle\n+\t it and its source indexes to make the permutation supported.\n+\t For now it mimics a blend.  */\n       vec_perm_builder sel (refnelts, refnelts, 1);\n       for (i = 0; i < elts.length (); ++i)\n \tsel.quick_push (elts[i].second + elts[i].first * refnelts);\n@@ -2219,49 +2209,67 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t  || maybe_ne (GET_MODE_SIZE (TYPE_MODE (mask_type)),\n \t\t       GET_MODE_SIZE (TYPE_MODE (perm_type))))\n \treturn false;\n-      op2 = vec_perm_indices_to_tree (mask_type, indices);\n-      bool convert_orig0 = false;\n+      tree op2 = vec_perm_indices_to_tree (mask_type, indices);\n+      bool converted_orig1 = false;\n       gimple_seq stmts = NULL;\n       if (!orig[1])\n \torig[1] = orig[0];\n       else if (orig[1] == error_mark_node\n \t       && one_nonconstant)\n \t{\n \t  orig[1] = gimple_build_vector_from_val (&stmts, UNKNOWN_LOCATION,\n-\t\t\t\t\t\t  perm_type, one_nonconstant);\n-\t  convert_orig0 = conv_code != ERROR_MARK;\n+\t\t\t\t\t\t  type, one_nonconstant);\n+\t  /* ???  We can see if we can safely convert to the original\n+\t     element type.  */\n+\t  converted_orig1 = conv_code != ERROR_MARK;\n \t}\n       else if (orig[1] == error_mark_node)\n \t{\n-\t  tree_vector_builder vec (perm_type, nelts, 1);\n+\t  tree_vector_builder vec (type, nelts, 1);\n \t  for (unsigned i = 0; i < nelts; ++i)\n \t    if (constants[i])\n \t      vec.quick_push (constants[i]);\n \t    else\n \t      /* ??? Push a don't-care value.  */\n \t      vec.quick_push (one_constant);\n \t  orig[1] = vec.build ();\n-\t  convert_orig0 = conv_code != ERROR_MARK;\n+\t  /* ???  See if we can convert the vector to the original type.  */\n+\t  converted_orig1 = conv_code != ERROR_MARK;\n \t}\n-      tree res;\n-      if (convert_orig0)\n+      tree blend_op2 = NULL_TREE;\n+      if (converted_orig1)\n \t{\n-\t  gcc_assert (nelts == refnelts);\n-\t  res = gimple_build (&stmts, conv_code, type, orig[0]);\n-\t  res = gimple_build (&stmts, VEC_PERM_EXPR, perm_type,\n-\t\t\t      res, orig[1], op2);\n-\t}\n-      else\n-\t{\n-\t  res = gimple_build (&stmts, VEC_PERM_EXPR, perm_type,\n-\t\t\t      orig[0], orig[1], op2);\n-\t  if (nelts != refnelts)\n-\t    res = gimple_build (&stmts, BIT_FIELD_REF,\n-\t\t\t\tconv_code != ERROR_MARK ? conv_src_type : type,\n-\t\t\t\tres, TYPE_SIZE (type), bitsize_zero_node);\n-\t  if (conv_code != ERROR_MARK)\n-\t    res = gimple_build (&stmts, conv_code, type, res);\n+\t  /* Make sure we can do a blend in the target type.  */\n+\t  vec_perm_builder sel (nelts, nelts, 1);\n+\t  for (i = 0; i < elts.length (); ++i)\n+\t    sel.quick_push (elts[i].first\n+\t\t\t    ? elts[i].second + nelts : i);\n+\t  vec_perm_indices indices (sel, 2, nelts);\n+\t  if (!can_vec_perm_const_p (TYPE_MODE (type), indices))\n+\t    return false;\n+\t  mask_type\n+\t    = build_vector_type (build_nonstandard_integer_type (elem_size, 1),\n+\t\t\t\t nelts);\n+\t  if (GET_MODE_CLASS (TYPE_MODE (mask_type)) != MODE_VECTOR_INT\n+\t      || maybe_ne (GET_MODE_SIZE (TYPE_MODE (mask_type)),\n+\t\t\t   GET_MODE_SIZE (TYPE_MODE (type))))\n+\t    return false;\n+\t  blend_op2 = vec_perm_indices_to_tree (mask_type, indices);\n \t}\n+      tree orig1_for_perm\n+\t= converted_orig1 ? build_zero_cst (perm_type) : orig[1];\n+      tree res = gimple_build (&stmts, VEC_PERM_EXPR, perm_type,\n+\t\t\t       orig[0], orig1_for_perm, op2);\n+      if (nelts != refnelts)\n+\tres = gimple_build (&stmts, BIT_FIELD_REF,\n+\t\t\t    conv_code != ERROR_MARK ? conv_src_type : type,\n+\t\t\t    res, TYPE_SIZE (type), bitsize_zero_node);\n+      if (conv_code != ERROR_MARK)\n+\tres = gimple_build (&stmts, conv_code, type, res);\n+      /* Blend in the actual constant.  */\n+      if (converted_orig1)\n+\tres = gimple_build (&stmts, VEC_PERM_EXPR, type,\n+\t\t\t    res, orig[1], blend_op2);\n       gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n       gimple_assign_set_rhs_with_ops (gsi, SSA_NAME, res);\n     }"}]}