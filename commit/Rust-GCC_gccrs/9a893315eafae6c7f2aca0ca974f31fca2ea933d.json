{"sha": "9a893315eafae6c7f2aca0ca974f31fca2ea933d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE4OTMzMTVlYWZhZTZjN2YyYWNhMGNhOTc0ZjMxZmNhMmVhOTMzZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-04-14T18:46:37Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-04-14T18:46:37Z"}, "message": "(get_last_value_validate): New argument insn.\n\nAdd check for memory reference clobbered by later store.\n(record_value_for_reg, get_last_values): Pass in new argument.\n\nFrom-SVN: r13900", "tree": {"sha": "7e68ff83fffc11fcda2dd324a23e77fecea27369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e68ff83fffc11fcda2dd324a23e77fecea27369"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a893315eafae6c7f2aca0ca974f31fca2ea933d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a893315eafae6c7f2aca0ca974f31fca2ea933d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a893315eafae6c7f2aca0ca974f31fca2ea933d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a893315eafae6c7f2aca0ca974f31fca2ea933d/comments", "author": null, "committer": null, "parents": [{"sha": "ba325ebaef75a8f698c543eb111e7756a252d3ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba325ebaef75a8f698c543eb111e7756a252d3ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba325ebaef75a8f698c543eb111e7756a252d3ca"}], "stats": {"total": 28, "additions": 21, "deletions": 7}, "files": [{"sha": "31efa5b84b627bbd7bc374864a3a257de89706c8", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a893315eafae6c7f2aca0ca974f31fca2ea933d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a893315eafae6c7f2aca0ca974f31fca2ea933d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9a893315eafae6c7f2aca0ca974f31fca2ea933d", "patch": "@@ -445,7 +445,7 @@ static void update_table_tick\tPROTO((rtx));\n static void record_value_for_reg  PROTO((rtx, rtx, rtx));\n static void record_dead_and_set_regs_1  PROTO((rtx, rtx));\n static void record_dead_and_set_regs  PROTO((rtx));\n-static int get_last_value_validate  PROTO((rtx *, int, int));\n+static int get_last_value_validate  PROTO((rtx *, rtx, int, int));\n static rtx get_last_value\tPROTO((rtx));\n static int use_crosses_set_p\tPROTO((rtx, int));\n static void reg_dead_at_p_1\tPROTO((rtx, rtx));\n@@ -10203,11 +10203,12 @@ record_value_for_reg (reg, insn, value)\n   /* The value being assigned might refer to X (like in \"x++;\").  In that\n      case, we must replace it with (clobber (const_int 0)) to prevent\n      infinite loops.  */\n-  if (value && ! get_last_value_validate (&value,\n+  if (value && ! get_last_value_validate (&value, insn,\n \t\t\t\t\t  reg_last_set_label[regno], 0))\n     {\n       value = copy_rtx (value);\n-      if (! get_last_value_validate (&value, reg_last_set_label[regno], 1))\n+      if (! get_last_value_validate (&value, insn,\n+\t\t\t\t     reg_last_set_label[regno], 1))\n \tvalue = 0;\n     }\n \n@@ -10328,8 +10329,9 @@ record_dead_and_set_regs (insn)\n    we don't know exactly what registers it was produced from.  */\n \n static int\n-get_last_value_validate (loc, tick, replace)\n+get_last_value_validate (loc, insn, tick, replace)\n      rtx *loc;\n+     rtx insn;\n      int tick;\n      int replace;\n {\n@@ -10359,10 +10361,20 @@ get_last_value_validate (loc, tick, replace)\n \n       return 1;\n     }\n+  /* If this is a memory reference, make sure that there were\n+     no stores after it that might have clobbered the value.  We don't\n+     have alias info, so we assume any store invalidates it.  */\n+  else if (GET_CODE (x) == MEM && ! RTX_UNCHANGING_P (x)\n+\t   && INSN_CUID (insn) <= mem_last_set)\n+    {\n+      if (replace)\n+\t*loc = gen_rtx (CLOBBER, GET_MODE (x), const0_rtx);\n+      return replace;\n+    }\n \n   for (i = 0; i < len; i++)\n     if ((fmt[i] == 'e'\n-\t && get_last_value_validate (&XEXP (x, i), tick, replace) == 0)\n+\t && get_last_value_validate (&XEXP (x, i), insn, tick, replace) == 0)\n \t/* Don't bother with these.  They shouldn't occur anyway.  */\n \t|| fmt[i] == 'E')\n       return 0;\n@@ -10459,14 +10471,16 @@ get_last_value (x)\n     }\n \n   /* If the value has all its registers valid, return it.  */\n-  if (get_last_value_validate (&value, reg_last_set_label[regno], 0))\n+  if (get_last_value_validate (&value, reg_last_set[regno],\n+\t\t\t       reg_last_set_label[regno], 0))\n     return value;\n \n   /* Otherwise, make a copy and replace any invalid register with\n      (clobber (const_int 0)).  If that fails for some reason, return 0.  */\n \n   value = copy_rtx (value);\n-  if (get_last_value_validate (&value, reg_last_set_label[regno], 1))\n+  if (get_last_value_validate (&value, reg_last_set[regno],\n+\t\t\t       reg_last_set_label[regno], 1))\n     return value;\n \n   return 0;"}]}