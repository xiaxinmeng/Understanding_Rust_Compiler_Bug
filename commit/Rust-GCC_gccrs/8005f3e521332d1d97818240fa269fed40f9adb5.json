{"sha": "8005f3e521332d1d97818240fa269fed40f9adb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwNWYzZTUyMTMzMmQxZDk3ODE4MjQwZmEyNjlmZWQ0MGY5YWRiNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-10-04T14:56:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-04T14:56:04Z"}, "message": "cuintp.c, [...]: Use gcc_assert and gcc_unreachable.\n\n2004-10-04  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* cuintp.c, decl.c, utils2.c: Use gcc_assert and gcc_unreachable.\n\n\t* trans.c (assoc_to_constructor): Fix unused var warning if no checking.\n\t(gnat_gimplify_expr, case ADDR_EXPR): Fix error in last change.\n\tUse gcc_assert and gcc_unreachable.\n\n\t* decl.c (gnat_to_gnu_entity, case object): Check and process a\n\tspecified alignment before validating size.\n\t(gnat_to_gnu_entity) <E_Modular_Integer_Subtype>: Create a\n\tstripped-down declaration for the type of the inner field when making\n\ta JM type.\n\n\t* utils.c (finish_record_type): Do not compute the size in units\n\tincrementally. Instead compute it once for the rep clause case.\n\tUse gcc_assert and gcc_unreachable.\n\nFrom-SVN: r88493", "tree": {"sha": "caaf8daf4831dba7f6246040562bc08a9aa95db0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caaf8daf4831dba7f6246040562bc08a9aa95db0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8005f3e521332d1d97818240fa269fed40f9adb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8005f3e521332d1d97818240fa269fed40f9adb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8005f3e521332d1d97818240fa269fed40f9adb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8005f3e521332d1d97818240fa269fed40f9adb5/comments", "author": null, "committer": null, "parents": [{"sha": "6a294a2917ca8553c576eef28169625b9efbe9ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a294a2917ca8553c576eef28169625b9efbe9ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a294a2917ca8553c576eef28169625b9efbe9ab"}], "stats": {"total": 440, "additions": 189, "deletions": 251}, "files": [{"sha": "0931a5ce5fabb80c389a748bb2675a06a9386f69", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8005f3e521332d1d97818240fa269fed40f9adb5", "patch": "@@ -1,3 +1,21 @@\n+2004-10-04  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* cuintp.c, decl.c, utils2.c: Use gcc_assert and gcc_unreachable.\n+\n+\t* trans.c (assoc_to_constructor): Fix unused var warning if no checking.\n+\t(gnat_gimplify_expr, case ADDR_EXPR): Fix error in last change.\n+\tUse gcc_assert and gcc_unreachable.\n+\n+\t* decl.c (gnat_to_gnu_entity, case object): Check and process a\n+\tspecified alignment before validating size.\n+\t(gnat_to_gnu_entity) <E_Modular_Integer_Subtype>: Create a\n+\tstripped-down declaration for the type of the inner field when making\n+\ta JM type.\n+\n+\t* utils.c (finish_record_type): Do not compute the size in units\n+\tincrementally. Instead compute it once for the rep clause case.\n+\tUse gcc_assert and gcc_unreachable.\n+\n 2004-10-04  Vincent Celier  <celier@gnat.com>\n \n \t* a-dirval-mingw.adb (Invalid_Character): Add '\\' as invalid character"}, {"sha": "295de559931b8214f7ad4527b1af74fc38c9763d", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=8005f3e521332d1d97818240fa269fed40f9adb5", "patch": "@@ -89,9 +89,7 @@ UI_To_gnu (Uint Input, tree type)\n \t   ? type : integer_type_node);\n       tree gnu_base = build_cst_from_int (comp_type, Base);\n \n-      if (Length <= 0)\n-\tabort ();\n-\n+      gcc_assert (Length > 0);\n       gnu_ret = build_cst_from_int (comp_type, First);\n       if (First < 0)\n \tfor (Idx++, Length--; Length; Idx++, Length--)"}, {"sha": "0756a00be73000eb749ed4b97bbf291d44409cfa", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 53, "deletions": 67, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=8005f3e521332d1d97818240fa269fed40f9adb5", "patch": "@@ -117,9 +117,7 @@ gnat_to_gnu_type (Entity_Id gnat_entity)\n \n   /* Convert the ada entity type into a GCC TYPE_DECL node.  */\n   gnu_decl = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n-  if (TREE_CODE (gnu_decl) != TYPE_DECL)\n-    abort ();\n-\n+  gcc_assert (TREE_CODE (gnu_decl) == TYPE_DECL);\n   return TREE_TYPE (gnu_decl);\n }\n \f\n@@ -226,12 +224,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* This abort means the entity \"gnat_entity\" has an incorrect scope,\n \t i.e. that its scope does not correspond to the subprogram in which\n \t it is declared */\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* If this is entity 0, something went badly wrong.  */\n-  if (No (gnat_entity))\n-    abort ();\n+  gcc_assert (Present (gnat_entity));\n \n   /* If we've already processed this entity, return what we got last time.\n      If we are defining the node, we should not have already processed it.\n@@ -262,19 +259,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   /* If this is a numeric or enumeral type, or an access type, a nonzero\n      Esize must be specified unless it was specified by the programmer.  */\n-  if ((IN (kind, Numeric_Kind) || IN (kind, Enumeration_Kind)\n-       || (IN (kind, Access_Kind)\n-\t   && kind != E_Access_Protected_Subprogram_Type\n-\t   && kind != E_Access_Subtype))\n-      && Unknown_Esize (gnat_entity)\n-      && !Has_Size_Clause (gnat_entity))\n-    abort ();\n+  gcc_assert (!Unknown_Esize (gnat_entity)\n+\t      || Has_Size_Clause (gnat_entity)\n+\t      || (!IN (kind, Numeric_Kind) && !IN (kind, Enumeration_Kind)\n+\t\t  && (!IN (kind, Access_Kind)\n+\t\t      || kind == E_Access_Protected_Subprogram_Type\n+\t\t      || kind == E_Access_Subtype)));\n \n   /* Likewise, RM_Size must be specified for all discrete and fixed-point\n      types.  */\n-  if (IN (kind, Discrete_Or_Fixed_Point_Kind)\n-      && Unknown_RM_Size (gnat_entity))\n-    abort ();\n+  gcc_assert (!IN (kind, Discrete_Or_Fixed_Point_Kind)\n+\t      || !Unknown_RM_Size (gnat_entity));\n \n   /* Get the name of the entity and set up the line number and filename of\n      the original definition for use in any decl we make.  */\n@@ -284,16 +279,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   /* If we get here, it means we have not yet done anything with this\n      entity.  If we are not defining it here, it must be external,\n      otherwise we should have defined it already.  */\n-  if (!definition && ! Is_Public (gnat_entity)\n-      && !type_annotate_only\n-      && kind != E_Discriminant && kind != E_Component\n-      && kind != E_Label\n-      && !(kind == E_Constant && Present (Full_View (gnat_entity)))\n-#if 1\n-      && !IN (kind, Type_Kind)\n-#endif\n-      )\n-    abort ();\n+  gcc_assert (definition || Is_Public (gnat_entity) || type_annotate_only\n+\t      || kind == E_Discriminant || kind == E_Component\n+\t      || kind == E_Label\n+\t      || (kind == E_Constant && Present (Full_View (gnat_entity)))\n+\t      || IN (kind, Type_Kind));\n \n   /* For cases when we are not defining (i.e., we are referencing from\n      another compilation unit) Public entities, show we are at global level\n@@ -417,10 +407,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    /* A tagged record has no explicit stored discriminants. */\n \n-\t    if (First_Discriminant (gnat_record)\n-\t\t!= First_Stored_Discriminant (gnat_record))\n-\t      abort ();\n-\n+\t    gcc_assert (First_Discriminant (gnat_record)\n+\t\t       == First_Stored_Discriminant (gnat_record));\n \t    gnu_decl\n \t      = gnat_to_gnu_entity (Corresponding_Discriminant (gnat_entity),\n \t\t\t\t    gnu_expr, definition);\n@@ -438,7 +426,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse if (Present (Corresponding_Discriminant (gnat_entity))\n \t\t && (First_Discriminant (gnat_record)\n \t\t     != First_Stored_Discriminant (gnat_record)))\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \t/* Otherwise, if we are not defining this and we have no GCC type\n \t   for the containing record, make one for it.  Then we should\n@@ -475,7 +463,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  /* Here we have no GCC type and this is a reference rather than a\n \t     definition. This should never happen. Most likely the cause is a\n \t     reference before declaration in the gnat tree for gnat_entity.  */\n-\t  abort ();\n+\t  gcc_unreachable ();\n       }\n \n     case E_Loop_Parameter:\n@@ -527,10 +515,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    || TYPE_IS_DUMMY_P (gnu_type)\n \t    || TREE_CODE (gnu_type) == VOID_TYPE)\n \t  {\n-\t    if (type_annotate_only)\n-\t      return error_mark_node;\n-\t    else\n-\t      abort ();\n+\t    gcc_assert (type_annotate_only);\n+\t    return error_mark_node;\n+\t  }\n+\n+\t/* If an alignment is specified, use it if valid.   Note that\n+\t   exceptions are objects but don't have alignments.  We must do this\n+\t   before we validate the size, since the alignment can affect the \n+\t   size.  */\n+\tif (kind != E_Exception && Known_Alignment (gnat_entity))\n+\t  {\n+\t    gcc_assert (Present (Alignment (gnat_entity)));\n+\t    align = validate_alignment (Alignment (gnat_entity), gnat_entity,\n+\t\t\t\t\tTYPE_ALIGN (gnu_type));\n+\t    gnu_type = maybe_pad_type (gnu_type, NULL_TREE, align,\n+\t\t\t\t       gnat_entity, \"PAD\", 0, definition, 1);\n \t  }\n \n \t/* If we are defining the object, see if it has a Size value and\n@@ -599,17 +598,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && !Present (Address_Clause (gnat_entity)))\n \t  gnu_size = bitsize_unit_node;\n \n-\t/* If an alignment is specified, use it if valid.   Note that\n-\t   exceptions are objects but don't have alignments.  */\n-\tif (kind != E_Exception && Known_Alignment (gnat_entity))\n-\t  {\n-\t    if (No (Alignment (gnat_entity)))\n-\t      abort ();\n-\n-\t    align = validate_alignment (Alignment (gnat_entity), gnat_entity,\n-\t\t\t\t\tTYPE_ALIGN (gnu_type));\n-\t  }\n-\n \t/* If this is an atomic object with no specified size and alignment,\n \t   but where the size of the type is a constant, set the alignment to\n \t   the lowest power of two greater than the size, or to the\n@@ -1358,6 +1346,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_field_type);\n \t  TYPE_PACKED (gnu_type) = 1;\n \n+\t  /* Create a stripped-down declaration of the original type, mainly\n+\t     for debugging.  */\n+\t  create_type_decl (get_entity_name (gnat_entity), gnu_field_type,\n+\t\t\t    NULL, true, debug_info_p, gnat_entity);\n+\n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n \t     it's address and it would prevent create_field_decl from making a\n \t     bitfield.  */\n@@ -1667,9 +1660,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (No (Packed_Array_Type (gnat_entity))\n             && Known_Alignment (gnat_entity))\n \t  {\n-\t    if (No (Alignment (gnat_entity)))\n-\t      abort ();\n-\n+\t    gcc_assert (Present (Alignment (gnat_entity)));\n \t    TYPE_ALIGN (tem)\n \t      = validate_alignment (Alignment (gnat_entity), gnat_entity,\n \t\t\t\t    TYPE_ALIGN (tem));\n@@ -2173,8 +2164,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t}\n \n       /* Abort if packed array with no packed array type field set. */\n-      else if (Is_Packed (gnat_entity))\n-\tabort ();\n+      else\n+\tgcc_assert (!Is_Packed (gnat_entity));\n \n       break;\n \n@@ -2291,8 +2282,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| Present (Record_Extension_Part (record_definition)))\n \t      record_definition = Record_Extension_Part (record_definition);\n \n-\t    if (!type_annotate_only && No (Parent_Subtype (gnat_entity)))\n-\t      abort ();\n+\t    gcc_assert (type_annotate_only\n+\t\t\t|| Present (Parent_Subtype (gnat_entity)));\n \t  }\n \n \t/* Make a node for the record.  If we are not defining the record,\n@@ -3568,9 +3559,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      {\n \t\tif (!has_copy_in_out)\n \t\t  {\n-\t\t    if (TREE_CODE (gnu_return_type) != VOID_TYPE)\n-\t\t      abort ();\n-\n+\t\t    gcc_assert (TREE_CODE (gnu_return_type) == VOID_TYPE);\n \t\t    gnu_return_type = make_node (RECORD_TYPE);\n \t\t    TYPE_NAME (gnu_return_type) = get_identifier (\"RETURN\");\n \t\t    has_copy_in_out = true;\n@@ -3788,7 +3777,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* If we had a case where we evaluated another type and it might have\n@@ -4980,7 +4969,7 @@ choices_to_gnu (tree operand, Node_Id choices)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       result = build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n@@ -5147,7 +5136,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t\t   First_Bit (Component_Clause (gnat_field)), gnat_field,\n \t\t   TYPE_ALIGN (gnu_field_type));\n \t      else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \n \t      gnu_pos = NULL_TREE;\n \t    }\n@@ -5199,9 +5188,8 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t\t\t\t       \"PAD\", false, definition, true);\n     }\n \n-  if (TREE_CODE (gnu_field_type) == RECORD_TYPE\n-      && TYPE_CONTAINS_TEMPLATE_P (gnu_field_type))\n-    abort ();\n+  gcc_assert (TREE_CODE (gnu_field_type) != RECORD_TYPE\n+\t      || !TYPE_CONTAINS_TEMPLATE_P (gnu_field_type));\n \n   /* Now create the decl for the field.  */\n   gnu_field = create_field_decl (gnu_field_id, gnu_field_type, gnu_record_type,\n@@ -6271,7 +6259,7 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n     case FUNCTION_TYPE:\n     case LANG_TYPE:\n       /* Don't know how to do these yet.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case ARRAY_TYPE:\n       {\n@@ -6411,9 +6399,7 @@ gnat_substitute_in_type (tree t, tree f, tree r)\n \telse if (!changed_field)\n \t  return t;\n \n-\tif (field_has_rep)\n-\t  abort ();\n-\n+\tgcc_assert (!field_has_rep);\n \tlayout_type (new);\n \n \t/* If the size was originally a constant use it.  */"}, {"sha": "666f84e20d04e936284486183f8ba51723912047", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 71, "deletions": 98, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=8005f3e521332d1d97818240fa269fed40f9adb5", "patch": "@@ -238,9 +238,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   if (Exception_Mechanism == GCC_ZCX)\n     gnat_init_gcc_eh ();\n \n-  if (Nkind (gnat_root) != N_Compilation_Unit)\n-    abort ();\n-\n+  gcc_assert (Nkind (gnat_root) == N_Compilation_Unit);\n   Compilation_Unit_to_gnu (gnat_root);\n \n   /* Now see if we have any elaboration procedures to deal with. */\n@@ -289,8 +287,7 @@ gnat_init_stmt_group ()\n   if (!Stack_Check_Probes_On_Target)\n     set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n \n-  if (Exception_Mechanism == Front_End_ZCX)\n-    abort ();\n+  gcc_assert (Exception_Mechanism != Front_End_ZCX);\n \n   REAL_ARITHMETIC (dconstp5, RDIV_EXPR, dconst1, dconst2);\n   REAL_ARITHMETIC (dconstmp5, RDIV_EXPR, dconstm1, dconst2);\n@@ -320,23 +317,23 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t       ? gnat_node : Entity (gnat_node));\n   gnat_temp_type = Etype (gnat_temp);\n \n-  if (Etype (gnat_node) != gnat_temp_type\n-      && !(Is_Packed (gnat_temp_type)\n-\t   && Etype (gnat_node) == Packed_Array_Type (gnat_temp_type))\n-      && !(Is_Class_Wide_Type (Etype (gnat_node)))\n-      && !(IN (Ekind (gnat_temp_type), Private_Kind)\n-\t   && Present (Full_View (gnat_temp_type))\n-\t   && ((Etype (gnat_node) == Full_View (gnat_temp_type))\n-\t       || (Is_Packed (Full_View (gnat_temp_type))\n-\t\t   && (Etype (gnat_node)\n-\t\t       == Packed_Array_Type (Full_View (gnat_temp_type))))))\n-      && (!Is_Itype (Etype (gnat_node)) || !Is_Itype (gnat_temp_type))\n-      && (Ekind (gnat_temp) == E_Variable\n-\t  || Ekind (gnat_temp) == E_Component\n-\t  || Ekind (gnat_temp) == E_Constant\n-\t  || Ekind (gnat_temp) == E_Loop_Parameter\n-\t  || IN (Ekind (gnat_temp), Formal_Kind)))\n-    abort ();\n+  gcc_assert (Etype (gnat_node) == gnat_temp_type\n+\t      || (Is_Packed (gnat_temp_type)\n+\t\t  && Etype (gnat_node) == Packed_Array_Type (gnat_temp_type))\n+\t      || (Is_Class_Wide_Type (Etype (gnat_node)))\n+\t      || (IN (Ekind (gnat_temp_type), Private_Kind)\n+\t\t  && Present (Full_View (gnat_temp_type))\n+\t\t  && ((Etype (gnat_node) == Full_View (gnat_temp_type))\n+\t\t      || (Is_Packed (Full_View (gnat_temp_type))\n+\t\t\t  && (Etype (gnat_node)\n+\t\t\t      == Packed_Array_Type (Full_View\n+\t\t\t\t\t\t    (gnat_temp_type))))))\n+\t      || (Is_Itype (Etype (gnat_node)) && Is_Itype (gnat_temp_type))\n+\t      || !(Ekind (gnat_temp) == E_Variable\n+\t\t   || Ekind (gnat_temp) == E_Component\n+\t\t   || Ekind (gnat_temp) == E_Constant\n+\t\t   || Ekind (gnat_temp) == E_Loop_Parameter\n+\t\t   || IN (Ekind (gnat_temp), Formal_Kind)));\n \n   /* If this is a reference to a deferred constant whose partial view is an\n      unconstrained private type, the proper type is on the full view of the\n@@ -533,8 +530,7 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n-\t  break;\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -748,8 +744,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       else\n \tgnu_result = rm_size (gnu_type);\n \n-      if (!gnu_result)\n-\tabort ();\n+      gcc_assert (gnu_result);\n \n       /* Deal with a self-referential size by returning the maximum size for a\n \t type and by qualifying the size with the object for 'Size of an\n@@ -863,9 +858,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tfor (; Dimension > 1; Dimension--)\n \t  gnu_type = TREE_TYPE (gnu_type);\n \n-\tif (TREE_CODE (gnu_type) != ARRAY_TYPE)\n-\t  abort ();\n-\n+\tgcc_assert (TREE_CODE (gnu_type) == ARRAY_TYPE);\n \tif (attribute == Attr_First)\n \t  gnu_result\n \t    = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n@@ -933,10 +926,10 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t    break;\n \t  }\n \n-\telse if (TREE_CODE (gnu_prefix) != COMPONENT_REF\n-\t\t && !(attribute == Attr_Bit_Position\n-\t\t      && TREE_CODE (gnu_prefix) == FIELD_DECL))\n-\t  abort ();\n+\telse\n+\t  gcc_assert (TREE_CODE (gnu_prefix) == COMPONENT_REF\n+\t\t      || (attribute == Attr_Bit_Position\n+\t\t\t  && TREE_CODE (gnu_prefix) == FIELD_DECL));\n \n \tget_inner_reference (gnu_prefix, &bitsize, &bitpos, &gnu_offset,\n \t\t\t     &mode, &unsignedp, &volatilep);\n@@ -1036,8 +1029,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t     && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))\n \tgnu_type = TREE_TYPE (gnu_type);\n \n-      if (TREE_CODE (gnu_type) != ARRAY_TYPE)\n-\tabort ();\n+      gcc_assert (TREE_CODE (gnu_type) == ARRAY_TYPE);\n \n       /* Note this size cannot be self-referential.  */\n       gnu_result = TYPE_SIZE (TREE_TYPE (gnu_type));\n@@ -1194,7 +1186,7 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \n \t  add_stmt_with_node (build3 (CASE_LABEL_EXPR, void_type_node,\n@@ -1555,8 +1547,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \tEliminate_Error_Msg (gnat_node, Entity (Name (gnat_node)));\n     }\n \n-  if (TREE_CODE (gnu_subprog_type) != FUNCTION_TYPE)\n-    abort ();\n+  gcc_assert (TREE_CODE (gnu_subprog_type) == FUNCTION_TYPE);\n \n   /* If we are calling a stubbed function, make this into a raise of\n      Program_Error.  Elaborate all our args first.  */\n@@ -2268,7 +2259,7 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t    }\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       gnu_choice = build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n \t\t\t\t    gnu_choice, this_choice);\n@@ -2329,7 +2320,7 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n \t     by the personality routine.  */\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       /* The GCC interface expects NULL to be passed for catch all handlers, so\n \t it would be quite tempting to set gnu_etypes_list to NULL if gnu_etype\n@@ -2534,8 +2525,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   of the subtype, but that causes problems with subtypes whose usage\n \t   will raise Constraint_Error and with biased representation, so\n \t   we don't.  */\n-\tif (TREE_CONSTANT_OVERFLOW (gnu_result))\n-\t  abort ();\n+\tgcc_assert (!TREE_CONSTANT_OVERFLOW (gnu_result));\n       }\n       break;\n \n@@ -2563,14 +2553,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \t  gnu_result = UI_To_gnu (Corresponding_Integer_Value (gnat_node),\n \t\t\t\t  gnu_result_type);\n-\t  if (TREE_CONSTANT_OVERFLOW (gnu_result))\n-\t    abort ();\n+\t  gcc_assert (!TREE_CONSTANT_OVERFLOW (gnu_result));\n \t}\n \n       /* We should never see a Vax_Float type literal, since the front end\n          is supposed to transform these using appropriate conversions */\n       else if (Vax_Float (Underlying_Type (Etype (gnat_node))))\n-\tabort ();\n+\tgcc_unreachable ();\n \n       else\n         {\n@@ -2604,13 +2593,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t     gnu_result,\n \t\t\t\t     UI_To_gnu (Denominator (ur_realval),\n \t\t\t\t\t\tgnu_result_type));\n-\t      else if (Rbase (ur_realval) != 2)\n-\t\tabort ();\n-\n \t      else\n \t\t{\n \t\t  REAL_VALUE_TYPE tmp;\n \n+\t\t  gcc_assert (Rbase (ur_realval) == 2);\n \t\t  real_ldexp (&tmp, &TREE_REAL_CST (gnu_result),\n \t\t\t      - UI_To_Int (Denominator (ur_realval)));\n \t\t  gnu_result = build_real (gnu_result_type, tmp);\n@@ -2836,9 +2823,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \tfor (i = 0, gnu_type = TREE_TYPE (gnu_array_object);\n \t     i < ndim; i++, gnu_type = TREE_TYPE (gnu_type))\n \t  {\n-\t    if (TREE_CODE (gnu_type) != ARRAY_TYPE)\n-\t      abort ();\n-\n+\t    gcc_assert (TREE_CODE (gnu_type) == ARRAY_TYPE);\n \t    gnat_temp = gnat_expr_array[i];\n \t    gnu_expr = gnat_to_gnu (gnat_temp);\n \n@@ -2979,9 +2964,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t      == N_Attribute_Reference));\n \t  }\n \n-\tif (!gnu_result)\n-\t  abort ();\n-\n+\tgcc_assert (gnu_result);\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n       }\n       break;\n@@ -3064,7 +3047,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t    (Next\n \t\t\t     (First (Component_Associations (gnat_node))))));\n \telse\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \tgnu_result = convert (gnu_result_type, gnu_result);\n       }\n@@ -3138,7 +3121,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_high = TYPE_MAX_VALUE (gnu_range_type);\n \t  }\n \telse\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n@@ -3379,7 +3362,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      }\n \t  }\n \telse\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \treturn build_allocator (gnu_type, gnu_init, gnu_result_type,\n@@ -3758,12 +3741,11 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* If there is an At_End procedure attached to this node, and the EH\n \t mechanism is SJLJ, we must have at least a corresponding At_End\n \t handler, unless the No_Exception_Handlers restriction is set.  */\n-      if (!type_annotate_only\n-\t  && Exception_Mechanism == Setjmp_Longjmp\n-\t  && Present (At_End_Proc (gnat_node))\n-\t  && !Present (Exception_Handlers (gnat_node))\n-\t  && !No_Exception_Handlers_Set())\n-\tabort ();\n+      gcc_assert (type_annotate_only\n+\t\t  || Exception_Mechanism != Setjmp_Longjmp\n+\t\t  || No (At_End_Proc (gnat_node))\n+\t\t  || Present (Exception_Handlers (gnat_node))\n+\t\t  || No_Exception_Handlers_Set ());\n \n       gnu_result = Handled_Sequence_Of_Statements_to_gnu (gnat_node);\n       break;\n@@ -3774,7 +3756,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       else if (Exception_Mechanism == GCC_ZCX)\n \tgnu_result = Exception_Handler_to_gnu_zcx (gnat_node);\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       break;\n \n@@ -4015,9 +3997,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Component_Association:\n     case N_Task_Body:\n     default:\n-      if (!type_annotate_only)\n-\tabort ();\n-\n+      gcc_assert (type_annotate_only);\n       gnu_result = alloc_stmt_list ();\n     }\n \n@@ -4331,9 +4311,7 @@ add_cleanup (tree gnu_cleanup)\n void\n set_block_for_group (tree gnu_block)\n {\n-  if (current_stmt_group->block)\n-    abort ();\n-\n+  gcc_assert (!current_stmt_group->block);\n   current_stmt_group->block = gnu_block;\n }\n \n@@ -4458,7 +4436,7 @@ gnat_expand_stmt (tree gnu_stmt)\n #endif\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -4511,10 +4489,7 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n \t  TREE_READONLY (new_var) = 1;\n \t  TREE_STATIC (new_var) = 1;\n \t  TREE_ADDRESSABLE (new_var) = 1;\n-\n-\t  gimplify_and_add (build2 (MODIFY_EXPR, TREE_TYPE (new_var),\n-\t\t\t\t    new_var, TREE_OPERAND (expr, 0)),\n-\t\t\t    pre_p);\n+\t  DECL_INITIAL (new_var) = TREE_OPERAND (expr, 0);\n \n \t  TREE_OPERAND (expr, 0) = new_var;\n \t  return GS_ALL_DONE;\n@@ -4615,7 +4590,7 @@ gnat_gimplify_stmt (tree *stmt_p)\n       return GS_OK;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -4760,14 +4735,11 @@ process_freeze_entity (Node_Id gnat_node)\n       && !(TREE_CODE (gnu_old) == TYPE_DECL\n \t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old))))\n     {\n-      if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n-  \t  && Present (Full_View (gnat_entity))\n-  \t  && No (Freeze_Node (Full_View (gnat_entity))))\n-  \treturn;\n-      else if (Is_Concurrent_Type (gnat_entity))\n-\treturn;\n-      else\n-\tabort ();\n+      gcc_assert ((IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n+\t\t   && Present (Full_View (gnat_entity))\n+\t\t   && No (Freeze_Node (Full_View (gnat_entity))))\n+\t\t  || Is_Concurrent_Type (gnat_entity));\n+      return;\n     }\n \n   /* Reset the saved tree, if any, and elaborate the object or type for real.\n@@ -5352,19 +5324,16 @@ process_type (Entity_Id gnat_entity)\n \t  /* If this was a withed access type, this is not an error\n \t     and merely indicates we've already elaborated the type\n \t     already. */\n-\t  if (Is_Type (gnat_entity) && From_With_Type (gnat_entity))\n-\t    return;\n-\n-\t  abort ();\n+\t  gcc_assert (Is_Type (gnat_entity) && From_With_Type (gnat_entity));\n+\t  return;\n \t}\n \n       save_gnu_tree (gnat_entity, NULL_TREE, false);\n     }\n \n   /* Now fully elaborate the type.  */\n   gnu_new = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 1);\n-  if (TREE_CODE (gnu_new) != TYPE_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (gnu_new) == TYPE_DECL);\n \n   /* If we have an old type and we've made pointers to this type,\n      update those pointers.  */\n@@ -5402,7 +5371,7 @@ process_type (Entity_Id gnat_entity)\n static tree\n assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n {\n-  tree gnu_field, gnu_list, gnu_result;\n+  tree gnu_list, gnu_result;\n \n   /* We test for GNU_FIELD being empty in the case where a variant\n      was the last thing since we don't take things off GNAT_ASSOC in\n@@ -5418,8 +5387,7 @@ assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n \n       /* The expander is supposed to put a single component selector name\n \t in every record component association */\n-      if (Next (gnat_field))\n-\tabort ();\n+      gcc_assert (No (Next (gnat_field)));\n \n       /* Before assigning a value in an aggregate make sure range checks\n \t are done if required.  Then convert to the type of the field.  */\n@@ -5434,10 +5402,15 @@ assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n \n   gnu_result = extract_values (gnu_list, gnu_type);\n \n-  /* Verify every enty in GNU_LIST was used.  */\n-  for (gnu_field = gnu_list; gnu_field; gnu_field = TREE_CHAIN (gnu_field))\n-    if (!TREE_ADDRESSABLE (gnu_field))\n-      abort ();\n+#ifdef ENABLE_CHECKING\n+  {\n+    tree gnu_field;\n+\n+    /* Verify every enty in GNU_LIST was used.  */\n+    for (gnu_field = gnu_list; gnu_field; gnu_field = TREE_CHAIN (gnu_field))\n+      gcc_assert (TREE_ADDRESSABLE (gnu_field));\n+  }\n+#endif\n \n   return gnu_result;\n }\n@@ -5754,7 +5727,7 @@ gnat_stabilize_reference_1 (tree e, bool force)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   TREE_READONLY (result) = TREE_READONLY (e);"}, {"sha": "50753af5363c75abcd061f11df8206052c7b783c", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=8005f3e521332d1d97818240fa269fed40f9adb5", "patch": "@@ -154,11 +154,9 @@ save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl, bool no_check)\n      to something which is a decl.  Raise gigi 401 if not.  Usually, this\n      means GNAT_ENTITY is defined twice, but occasionally is due to some\n      Gigi problem.  */\n-  if (gnu_decl\n-      && (associate_gnat_to_gnu[gnat_entity - First_Node_Id]\n-\t  || (!no_check && !DECL_P (gnu_decl))))\n-    abort ();\n-\n+  gcc_assert (!gnu_decl\n+\t      || (!associate_gnat_to_gnu[gnat_entity - First_Node_Id]\n+\t\t  && (no_check || DECL_P (gnu_decl))));\n   associate_gnat_to_gnu[gnat_entity - First_Node_Id] = gnu_decl;\n }\n \n@@ -172,9 +170,7 @@ save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl, bool no_check)\n tree\n get_gnu_tree (Entity_Id gnat_entity)\n {\n-  if (!associate_gnat_to_gnu[gnat_entity - First_Node_Id])\n-    abort ();\n-\n+  gcc_assert (associate_gnat_to_gnu[gnat_entity - First_Node_Id]);\n   return associate_gnat_to_gnu[gnat_entity - First_Node_Id];\n }\n \n@@ -729,7 +725,6 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n   enum tree_code code = TREE_CODE (record_type);\n   tree ada_size = bitsize_zero_node;\n   tree size = bitsize_zero_node;\n-  tree size_unit = size_zero_node;\n   bool var_size = false;\n   tree field;\n \n@@ -785,7 +780,6 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \n       tree type = TREE_TYPE (field);\n       tree this_size = DECL_SIZE (field);\n-      tree this_size_unit = DECL_SIZE_UNIT (field);\n       tree this_ada_size = DECL_SIZE (field);\n \n       /* We need to make an XVE/XVU record if any field has variable size,\n@@ -826,7 +820,6 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \tcase UNION_TYPE:\n \t  ada_size = size_binop (MAX_EXPR, ada_size, this_ada_size);\n \t  size = size_binop (MAX_EXPR, size, this_size);\n-\t  size_unit = size_binop (MAX_EXPR, size_unit, this_size_unit);\n \t  break;\n \n \tcase QUAL_UNION_TYPE:\n@@ -835,9 +828,6 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \t\t\t    this_ada_size, ada_size));\n \t  size = fold (build3 (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n \t\t\t       this_size, size));\n-\t  size_unit = fold (build3 (COND_EXPR, sizetype,\n-\t\t\t\t    DECL_QUALIFIER (field),\n-\t\t\t\t    this_size_unit, size_unit));\n \t  break;\n \n \tcase RECORD_TYPE:\n@@ -854,13 +844,10 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \t\t\t   TREE_CODE (type) == QUAL_UNION_TYPE, has_rep);\n \t  size = merge_sizes (size, pos, this_size,\n \t\t\t      TREE_CODE (type) == QUAL_UNION_TYPE, has_rep);\n-\t  size_unit\n-\t    = merge_sizes (size_unit, byte_position (field), this_size_unit,\n-\t\t\t   TREE_CODE (type) == QUAL_UNION_TYPE, has_rep);\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -871,10 +858,7 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n      what was specified in it, if any.  */\n   if (TREE_CODE (record_type) == RECORD_TYPE\n       && TYPE_IS_PADDING_P (record_type) && TYPE_SIZE (record_type))\n-    {\n-      size = TYPE_SIZE (record_type);\n-      size_unit = TYPE_SIZE_UNIT (record_type);\n-    }\n+    size = TYPE_SIZE (record_type);\n \n   /* Now set any of the values we've just computed that apply.  */\n   if (!TYPE_IS_FAT_POINTER_P (record_type)\n@@ -887,6 +871,9 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \t    && TYPE_IS_PADDING_P (record_type)\n \t    && CONTAINS_PLACEHOLDER_P (size)))\n \t{\n+\t  tree size_unit\n+\t    = convert (sizetype, size_binop (CEIL_DIV_EXPR, size,\n+\t\t\t\t\t     bitsize_unit_node));\n \t  TYPE_SIZE (record_type) = round_up (size, TYPE_ALIGN (record_type));\n \t  TYPE_SIZE_UNIT (record_type)\n \t    = round_up (size_unit,\n@@ -1894,9 +1881,7 @@ float_type_for_precision (int precision, enum machine_mode mode)\n   TYPE_PRECISION (t) = precision;\n   layout_type (t);\n \n-  if (TYPE_MODE (t) != mode)\n-    abort ();\n-\n+  gcc_assert (TYPE_MODE (t) == mode);\n   if (!TYPE_NAME (t))\n     {\n       sprintf (type_name, \"FLOAT_%d\", precision);\n@@ -2076,7 +2061,7 @@ max_size (tree exp, bool max_p)\n       break;\n     }\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \f\n /* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n@@ -2125,7 +2110,7 @@ build_template (tree template_type, tree array_type, tree expr)\n \t       && DECL_BY_COMPONENT_PTR_P (expr))\n \tbounds = TREE_TYPE (field);\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       min = convert (TREE_TYPE (TREE_CHAIN (field)), TYPE_MIN_VALUE (bounds));\n       max = convert (TREE_TYPE (field), TYPE_MAX_VALUE (bounds));\n@@ -2564,7 +2549,7 @@ update_pointer_to (tree old_type, tree new_type)\n      pointers to void.  In that case, copy the field list from the\n      old type to the new one and update the fields' context. */\n   else if (TREE_CODE (ptr) != RECORD_TYPE || !TYPE_IS_FAT_POINTER_P (ptr))\n-    abort ();\n+    gcc_unreachable ();\n \n   else\n     {\n@@ -3009,7 +2994,7 @@ convert (tree type, tree expr)\n \t\t\t   convert (TREE_TYPE (tem), expr));\n \t}\n \n-      abort ();\n+      gcc_unreachable ();\n \n     case UNCONSTRAINED_ARRAY_TYPE:\n       /* If EXPR is a constrained array, take its address, convert it to a\n@@ -3037,13 +3022,13 @@ convert (tree type, tree expr)\n \t\t\t\t   build_unary_op (ADDR_EXPR,\n \t\t\t\t\t\t   NULL_TREE, expr)));\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n     case COMPLEX_TYPE:\n       return fold (convert_to_complex (type, expr));\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f"}, {"sha": "3727ce475f652af39edcde291c77e731a2efa4d1", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 30, "deletions": 52, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8005f3e521332d1d97818240fa269fed40f9adb5/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=8005f3e521332d1d97818240fa269fed40f9adb5", "patch": "@@ -734,9 +734,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t    break;\n \t}\n \n-      if (TREE_CODE (result) != INDIRECT_REF && TREE_CODE (result) != NULL_EXPR\n-\t  && !DECL_P (result))\n-\tabort ();\n+      gcc_assert (TREE_CODE (result) == INDIRECT_REF\n+\t\t  || TREE_CODE (result) == NULL_EXPR || DECL_P (result));\n \n       /* Convert the right operand to the operation type unless\n \t it is either already of the correct type or if the type\n@@ -783,8 +782,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n     case LE_EXPR:\n     case GT_EXPR:\n     case LT_EXPR:\n-      if (POINTER_TYPE_P (left_type))\n-\tabort ();\n+      gcc_assert (!POINTER_TYPE_P (left_type));\n \n       /* ... fall through ... */\n \n@@ -833,12 +831,10 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t{\n \t  result = compare_arrays (result_type, left_operand, right_operand);\n \n-\t  if (op_code == EQ_EXPR)\n-\t    ;\n-\t  else if (op_code == NE_EXPR)\n+\t  if (op_code == NE_EXPR)\n \t    result = invert_truthvalue (result);\n \t  else\n-\t    abort ();\n+\t    gcc_assert (op_code == EQ_EXPR);\n \n \t  return result;\n \t}\n@@ -857,9 +853,9 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\t Even better is if one is of fixed size.  */\n \t      best_type = NULL_TREE;\n \n-\t      if (!TYPE_NAME (left_base_type)\n-\t\t  || TYPE_NAME (left_base_type) != TYPE_NAME (right_base_type))\n-\t\tabort ();\n+\t      gcc_assert (TYPE_NAME (left_base_type)\n+\t\t\t  && (TYPE_NAME (left_base_type)\n+\t\t\t      == TYPE_NAME (right_base_type)));\n \n \t      if (TREE_CONSTANT (TYPE_SIZE (left_base_type)))\n \t\tbest_type = left_base_type;\n@@ -870,13 +866,13 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t      else if (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (right_base_type)))\n \t\tbest_type = right_base_type;\n \t      else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \n \t      left_operand = convert (best_type, left_operand);\n \t      right_operand = convert (best_type, right_operand);\n \t    }\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t}\n \n       /* If we are comparing a fat pointer against zero, we need to\n@@ -913,9 +909,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t we guarantee that no overflow can occur.  So nothing special need\n \t be done for modular types.  */\n \n-      if (left_type != result_type)\n-\tabort ();\n-\n+      gcc_assert (left_type == result_type);\n       operation_type = get_base_type (result_type);\n       left_operand = convert (operation_type, left_operand);\n       right_operand = convert (operation_type, right_operand);\n@@ -930,9 +924,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n        /* The RHS of a shift can be any type.  Also, ignore any modulus\n \t (we used to abort, but this is needed for unchecked conversion\n \t to modular types).  Otherwise, processing is the same as normal.  */\n-      if (operation_type != left_base_type)\n-\tabort ();\n-\n+      gcc_assert (operation_type == left_base_type);\n       modulus = NULL_TREE;\n       left_operand = convert (operation_type, left_operand);\n       break;\n@@ -957,10 +949,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       goto common;\n \n     case COMPLEX_EXPR:\n-      if (TREE_TYPE (result_type) != left_base_type\n-\t  || TREE_TYPE (result_type) != right_base_type)\n-\tabort ();\n-\n+      gcc_assert (TREE_TYPE (result_type) == left_base_type\n+\t\t  && TREE_TYPE (result_type) == right_base_type);\n       left_operand = convert (left_base_type, left_operand);\n       right_operand = convert (right_base_type, right_operand);\n       break;\n@@ -979,10 +969,8 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t both operands (and they should be the same).  Convert\n \t everything to the result type.  */\n \n-      if (operation_type != left_base_type\n-\t  || left_base_type != right_base_type)\n-\tabort ();\n-\n+      gcc_assert (operation_type == left_base_type\n+\t\t  && left_base_type == right_base_type);\n       left_operand = convert (operation_type, left_operand);\n       right_operand = convert (operation_type, right_operand);\n     }\n@@ -1053,16 +1041,14 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n     case IMAGPART_EXPR:\n       if (!operation_type)\n \tresult_type = operation_type = TREE_TYPE (type);\n-      else if (result_type != TREE_TYPE (type))\n-\tabort ();\n+      else\n+\tgcc_assert (result_type == TREE_TYPE (type));\n \n       result = fold (build1 (op_code, operation_type, operand));\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      if (result_type != base_type)\n-\tabort ();\n-\n+      gcc_assert (result_type == base_type);\n       result = invert_truthvalue (gnat_truthvalue_conversion (operand));\n       break;\n \n@@ -1252,9 +1238,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \n \tif (modulus)\n \t  {\n-\t    if (operation_type != base_type)\n-\t      abort ();\n-\n+\t    gcc_assert (operation_type == base_type);\n \t    operand = convert (operation_type, operand);\n \n \t    /* The fastest in the negate case for binary modulus is\n@@ -1317,9 +1301,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n       /* ... fall through ... */\n \n     default:\n-      if (operation_type != base_type)\n-\tabort ();\n-\n+      gcc_assert (operation_type == base_type);\n       result = fold (build1 (op_code, operation_type, convert (operation_type,\n \t\t\t\t\t\t\t       operand)));\n     }\n@@ -1534,12 +1516,11 @@ build_simple_component_ref (tree record_variable, tree component,\n   tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n   tree ref;\n \n-  if ((TREE_CODE (record_type) != RECORD_TYPE\n-       && TREE_CODE (record_type) != UNION_TYPE\n-       && TREE_CODE (record_type) != QUAL_UNION_TYPE)\n-      || !TYPE_SIZE (record_type)\n-      || (component != 0) == (field != 0))\n-    abort ();\n+  gcc_assert ((TREE_CODE (record_type) == RECORD_TYPE\n+\t       || TREE_CODE (record_type) == UNION_TYPE\n+\t       || TREE_CODE (record_type) == QUAL_UNION_TYPE)\n+\t      && TYPE_SIZE (record_type)\n+\t      && (component != 0) != (field != 0));\n \n   /* If no field was specified, look for a field with the specified name\n      in the current record only.  */\n@@ -1626,12 +1607,9 @@ build_component_ref (tree record_variable, tree component,\n   /* If FIELD was specified, assume this is an invalid user field so\n      raise constraint error.  Otherwise, we can't find the type to return, so\n      abort.  */\n-\n-  else if (field)\n-    return build1 (NULL_EXPR, TREE_TYPE (field),\n-\t\t   build_call_raise (CE_Discriminant_Check_Failed));\n-  else\n-    abort ();\n+  gcc_assert (field);\n+  return build1 (NULL_EXPR, TREE_TYPE (field),\n+\t\t build_call_raise (CE_Discriminant_Check_Failed));\n }\n \f\n /* Build a GCC tree to call an allocation or deallocation function.\n@@ -1750,7 +1728,7 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n \t}\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n #if 0\n \treturn build2 (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n #endif"}]}