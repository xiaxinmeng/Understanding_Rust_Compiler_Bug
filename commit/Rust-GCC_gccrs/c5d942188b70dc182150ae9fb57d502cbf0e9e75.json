{"sha": "c5d942188b70dc182150ae9fb57d502cbf0e9e75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkOTQyMTg4YjcwZGMxODIxNTBhZTlmYjU3ZDUwMmNiZjBlOWU3NQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2011-10-18T15:48:49Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2011-10-18T15:48:49Z"}, "message": "spu.c (struct machine_function): New data structure.\n\n\t* config/spu/spu.c (struct machine_function): New data structure.\n\t(spu_init_machine_status): New function.\n\t(spu_option_override): Install it.\n\t(get_pic_reg): Set and use cfun->machine->pic_reg.\n\t(spu_split_immediate): Do not set crtl->uses_pic_offset_table.\n\t(need_to_save_reg): Use cfun->machine->pic_reg instead of\n\tchecking crtl->uses_pic_offset_table.\n\t(spu_expand_prologue): Likewise.\n\nFrom-SVN: r180156", "tree": {"sha": "90df04d185814eb9b62235044b923a6558275b2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90df04d185814eb9b62235044b923a6558275b2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5d942188b70dc182150ae9fb57d502cbf0e9e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d942188b70dc182150ae9fb57d502cbf0e9e75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d942188b70dc182150ae9fb57d502cbf0e9e75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d942188b70dc182150ae9fb57d502cbf0e9e75/comments", "author": null, "committer": null, "parents": [{"sha": "d8381c04c3975a53a2fb3d32d4b39812bcdc215a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8381c04c3975a53a2fb3d32d4b39812bcdc215a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8381c04c3975a53a2fb3d32d4b39812bcdc215a"}], "stats": {"total": 59, "additions": 47, "deletions": 12}, "files": [{"sha": "40e2998f48136f0a25af9a92b0ef543d3376497d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d942188b70dc182150ae9fb57d502cbf0e9e75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d942188b70dc182150ae9fb57d502cbf0e9e75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5d942188b70dc182150ae9fb57d502cbf0e9e75", "patch": "@@ -1,3 +1,14 @@\n+2011-10-18  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/spu/spu.c (struct machine_function): New data structure.\n+\t(spu_init_machine_status): New function.\n+\t(spu_option_override): Install it.\n+\t(get_pic_reg): Set and use cfun->machine->pic_reg.\n+\t(spu_split_immediate): Do not set crtl->uses_pic_offset_table.\n+\t(need_to_save_reg): Use cfun->machine->pic_reg instead of\n+\tchecking crtl->uses_pic_offset_table.\n+\t(spu_expand_prologue): Likewise.\n+\n 2011-10-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/50735"}, {"sha": "3baa2ebc925c574c3efbbb065dae3ba1ee3a38c3", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d942188b70dc182150ae9fb57d502cbf0e9e75/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d942188b70dc182150ae9fb57d502cbf0e9e75/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=c5d942188b70dc182150ae9fb57d502cbf0e9e75", "patch": "@@ -500,10 +500,27 @@ static void spu_setup_incoming_varargs (cumulative_args_t cum,\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n+/* Define the structure for the machine field in struct function.  */\n+struct GTY(()) machine_function\n+{\n+  /* Register to use for PIC accesses.  */\n+  rtx pic_reg;\n+};\n+\n+/* How to allocate a 'struct machine_function'.  */\n+static struct machine_function *\n+spu_init_machine_status (void)\n+{\n+  return ggc_alloc_cleared_machine_function ();\n+}\n+\n /* Implement TARGET_OPTION_OVERRIDE.  */\n static void\n spu_option_override (void)\n {\n+  /* Set up function hooks.  */\n+  init_machine_status = spu_init_machine_status;\n+\n   /* Small loops will be unpeeled at -O3.  For SPU it is more important\n      to keep code small by default.  */\n   if (!flag_unroll_loops && !flag_peel_loops)\n@@ -1741,12 +1758,22 @@ print_operand (FILE * file, rtx x, int code)\n static rtx\n get_pic_reg (void)\n {\n-  rtx pic_reg = pic_offset_table_rtx;\n   if (!reload_completed && !reload_in_progress)\n     abort ();\n-  if (current_function_is_leaf && !df_regs_ever_live_p (LAST_ARG_REGNUM))\n-    pic_reg = gen_rtx_REG (SImode, LAST_ARG_REGNUM);\n-  return pic_reg;\n+\n+  /* If we've already made the decision, we need to keep with it.  Once we've\n+     decided to use LAST_ARG_REGNUM, future calls to df_regs_ever_live_p may\n+     return true since the register is now live; this should not cause us to\n+     \"switch back\" to using pic_offset_table_rtx.  */\n+  if (!cfun->machine->pic_reg)\n+    {\n+      if (current_function_is_leaf && !df_regs_ever_live_p (LAST_ARG_REGNUM))\n+\tcfun->machine->pic_reg = gen_rtx_REG (SImode, LAST_ARG_REGNUM);\n+      else\n+\tcfun->machine->pic_reg = pic_offset_table_rtx;\n+    }\n+\n+  return cfun->machine->pic_reg;\n }\n \n /* Split constant addresses to handle cases that are too large. \n@@ -1849,7 +1876,6 @@ spu_split_immediate (rtx * ops)\n \t    {\n \t      rtx pic_reg = get_pic_reg ();\n \t      emit_insn (gen_addsi3 (ops[0], ops[0], pic_reg));\n-\t      crtl->uses_pic_offset_table = 1;\n \t    }\n \t  return flag_pic || c == IC_IL2s;\n \t}\n@@ -1875,9 +1901,7 @@ need_to_save_reg (int regno, int saving)\n     return 1;\n   if (flag_pic\n       && regno == PIC_OFFSET_TABLE_REGNUM\n-      && (!saving || crtl->uses_pic_offset_table)\n-      && (!saving\n-\t  || !current_function_is_leaf || df_regs_ever_live_p (LAST_ARG_REGNUM)))\n+      && (!saving || cfun->machine->pic_reg == pic_offset_table_rtx))\n     return 1;\n   return 0;\n }\n@@ -1991,8 +2015,8 @@ spu_expand_prologue (void)\n   rtx scratch_reg_0, scratch_reg_1;\n   rtx insn, real;\n \n-  if (flag_pic && optimize == 0)\n-    crtl->uses_pic_offset_table = 1;\n+  if (flag_pic && optimize == 0 && !cfun->machine->pic_reg)\n+    cfun->machine->pic_reg = pic_offset_table_rtx;\n \n   if (spu_naked_function_p (current_function_decl))\n     return;\n@@ -2029,9 +2053,9 @@ spu_expand_prologue (void)\n \t  }\n     }\n \n-  if (flag_pic && crtl->uses_pic_offset_table)\n+  if (flag_pic && cfun->machine->pic_reg)\n     {\n-      rtx pic_reg = get_pic_reg ();\n+      rtx pic_reg = cfun->machine->pic_reg;\n       insn = emit_insn (gen_load_pic_offset (pic_reg, scratch_reg_0));\n       insn = emit_insn (gen_subsi3 (pic_reg, pic_reg, scratch_reg_0));\n     }"}]}