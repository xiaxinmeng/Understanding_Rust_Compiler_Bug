{"sha": "cdd82c1ee8d2ae036a4bfe2170b7795c17394109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RkODJjMWVlOGQyYWUwMzZhNGJmZTIxNzBiNzc5NWMxNzM5NDEwOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-03-28T14:20:10Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-03-28T14:20:10Z"}, "message": "regcprop.c (copyprop_hardreg_forward_1): Remove redundant INSN_P test.\n\n\t* regcprop.c (copyprop_hardreg_forward_1): Remove redundant INSN_P\n\ttest.\n\t(cprop_hardreg_bb, cprop_hardreg_debug): New functions.\n\t(pass_cprop_hardreg::execute): Use those.  Don't repeat bb processing\n\timmediately after first one with df_analyze in between, but rather\n\tprocess all bbs, queueing ones that need second pass in a worklist,\n\tdf_analyze, process queued debug insn changes and if second pass is\n\tneeded, process bbs from worklist, df_analyze, process queued debug\n\tinsns again.\n\nFrom-SVN: r269992", "tree": {"sha": "09e54a164e2228375675d06169f7f624fa0ee248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09e54a164e2228375675d06169f7f624fa0ee248"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdd82c1ee8d2ae036a4bfe2170b7795c17394109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdd82c1ee8d2ae036a4bfe2170b7795c17394109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdd82c1ee8d2ae036a4bfe2170b7795c17394109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdd82c1ee8d2ae036a4bfe2170b7795c17394109/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c84e2d3d18338e1644e34c01809833419c13dd3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c84e2d3d18338e1644e34c01809833419c13dd3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c84e2d3d18338e1644e34c01809833419c13dd3d"}], "stats": {"total": 162, "additions": 107, "deletions": 55}, "files": [{"sha": "50ed3df17574fd85023a82f9a244fcbddbaafcd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd82c1ee8d2ae036a4bfe2170b7795c17394109/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd82c1ee8d2ae036a4bfe2170b7795c17394109/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdd82c1ee8d2ae036a4bfe2170b7795c17394109", "patch": "@@ -1,5 +1,15 @@\n 2019-03-28  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* regcprop.c (copyprop_hardreg_forward_1): Remove redundant INSN_P\n+\ttest.\n+\t(cprop_hardreg_bb, cprop_hardreg_debug): New functions.\n+\t(pass_cprop_hardreg::execute): Use those.  Don't repeat bb processing\n+\timmediately after first one with df_analyze in between, but rather\n+\tprocess all bbs, queueing ones that need second pass in a worklist,\n+\tdf_analyze, process queued debug insn changes and if second pass is\n+\tneeded, process bbs from worklist, df_analyze, process queued debug\n+\tinsns again.\n+\n \t* rtl.h (NONDEBUG_INSN_P): Define as NONJUMP_INSN_P or JUMP_P\n \tor CALL_P instead of INSN_P && !DEBUG_INSN_P.\n \t(INSN_P): Define using NONDEBUG_INSN_P or DEBUG_INSN_P."}, {"sha": "4842ce922bc387586702fedd9cf6792bef633531", "filename": "gcc/regcprop.c", "status": "modified", "additions": 97, "deletions": 55, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdd82c1ee8d2ae036a4bfe2170b7795c17394109/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdd82c1ee8d2ae036a4bfe2170b7795c17394109/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=cdd82c1ee8d2ae036a4bfe2170b7795c17394109", "patch": "@@ -801,7 +801,6 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       /* Detect obviously dead sets (via REG_UNUSED notes) and remove them.  */\n       if (set\n \t  && !RTX_FRAME_RELATED_P (insn)\n-\t  && INSN_P (insn)\n \t  && !may_trap_p (set)\n \t  && find_reg_note (insn, REG_UNUSED, SET_DEST (set))\n \t  && !side_effects_p (SET_SRC (set))\n@@ -1282,6 +1281,76 @@ class pass_cprop_hardreg : public rtl_opt_pass\n \n }; // class pass_cprop_hardreg\n \n+static bool\n+cprop_hardreg_bb (basic_block bb, struct value_data *all_vd, sbitmap visited)\n+{\n+  bitmap_set_bit (visited, bb->index);\n+\n+  /* If a block has a single predecessor, that we've already\n+     processed, begin with the value data that was live at\n+     the end of the predecessor block.  */\n+  /* ??? Ought to use more intelligent queuing of blocks.  */\n+  if (single_pred_p (bb)\n+      && bitmap_bit_p (visited, single_pred (bb)->index)\n+      && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n+    {\n+      all_vd[bb->index] = all_vd[single_pred (bb)->index];\n+      if (all_vd[bb->index].n_debug_insn_changes)\n+\t{\n+\t  unsigned int regno;\n+\n+\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t    {\n+\t      if (all_vd[bb->index].e[regno].debug_insn_changes)\n+\t\t{\n+\t\t  struct queued_debug_insn_change *cur;\n+\t\t  for (cur = all_vd[bb->index].e[regno].debug_insn_changes;\n+\t\t       cur; cur = cur->next)\n+\t\t    --all_vd[bb->index].n_debug_insn_changes;\n+\t\t  all_vd[bb->index].e[regno].debug_insn_changes = NULL;\n+\t\t  if (all_vd[bb->index].n_debug_insn_changes == 0)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else\n+    init_value_data (all_vd + bb->index);\n+\n+  return copyprop_hardreg_forward_1 (bb, all_vd + bb->index);\n+}\n+\n+static void\n+cprop_hardreg_debug (function *fun, struct value_data *all_vd)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    if (all_vd[bb->index].n_debug_insn_changes)\n+      {\n+\tunsigned int regno;\n+\tbitmap live;\n+\n+\tlive = df_get_live_out (bb);\n+\tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t  if (all_vd[bb->index].e[regno].debug_insn_changes)\n+\t    {\n+\t      if (REGNO_REG_SET_P (live, regno))\n+\t\tapply_debug_insn_changes (all_vd + bb->index, regno);\n+\n+\t      struct queued_debug_insn_change *cur;\n+\t      for (cur = all_vd[bb->index].e[regno].debug_insn_changes;\n+\t\t   cur; cur = cur->next)\n+\t\t--all_vd[bb->index].n_debug_insn_changes;\n+\t      all_vd[bb->index].e[regno].debug_insn_changes = NULL;\n+\t      if (all_vd[bb->index].n_debug_insn_changes == 0)\n+\t\tbreak;\n+\t    }\n+      }\n+\n+  queued_debug_insn_change_pool.release ();\n+}\n+\n unsigned int\n pass_cprop_hardreg::execute (function *fun)\n {\n@@ -1293,6 +1362,9 @@ pass_cprop_hardreg::execute (function *fun)\n   auto_sbitmap visited (last_basic_block_for_fn (fun));\n   bitmap_clear (visited);\n \n+  auto_vec<int> worklist;\n+  bool any_debug_changes = false;\n+\n   /* We need accurate notes.  Earlier passes such as if-conversion may\n      leave notes in an inconsistent state.  */\n   df_note_add_problem ();\n@@ -1310,69 +1382,39 @@ pass_cprop_hardreg::execute (function *fun)\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n-      bitmap_set_bit (visited, bb->index);\n-\n-      for (int pass = 0; pass < 2; pass++)\n-\t{\n-\t  /* If a block has a single predecessor, that we've already\n-\t     processed, begin with the value data that was live at\n-\t    the end of the predecessor block.  */\n-\t  /* ??? Ought to use more intelligent queuing of blocks.  */\n-\t  if (single_pred_p (bb)\n-\t      && bitmap_bit_p (visited, single_pred (bb)->index)\n-\t      && ! (single_pred_edge (bb)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n-\t    {\n-\t      all_vd[bb->index] = all_vd[single_pred (bb)->index];\n-\t      if (all_vd[bb->index].n_debug_insn_changes)\n-\t\t{\n-\t\t  unsigned int regno;\n-\n-\t\t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\t    {\n-\t\t      if (all_vd[bb->index].e[regno].debug_insn_changes)\n-\t\t\t{\n-\t\t\t  all_vd[bb->index].e[regno].debug_insn_changes = NULL;\n-\t\t\t  if (--all_vd[bb->index].n_debug_insn_changes == 0)\n-\t\t\t    break;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    init_value_data (all_vd + bb->index);\n-\n-\t  /* If we were unable to propagate, then break the loop.  */\n-\t  if (!copyprop_hardreg_forward_1 (bb, all_vd + bb->index))\n-\t    break;\n-\t  df_analyze ();\n-\t}\n+      if (cprop_hardreg_bb (bb, all_vd, visited))\n+\tworklist.safe_push (bb->index);\n+      if (all_vd[bb->index].n_debug_insn_changes)\n+\tany_debug_changes = true;\n     }\n \n   /* We must call df_analyze here unconditionally to ensure that the\n      REG_UNUSED and REG_DEAD notes are consistent with and without -g.  */\n   df_analyze ();\n \n-  if (MAY_HAVE_DEBUG_BIND_INSNS)\n+  if (MAY_HAVE_DEBUG_BIND_INSNS && any_debug_changes)\n+    cprop_hardreg_debug (fun, all_vd);\n+\n+  /* Second pass if we've changed anything, only for the bbs where we have\n+     changed anything though.  */\n+  if (!worklist.is_empty ())\n     {\n-      FOR_EACH_BB_FN (bb, fun)\n-\tif (bitmap_bit_p (visited, bb->index)\n-\t    && all_vd[bb->index].n_debug_insn_changes)\n-\t  {\n-\t    unsigned int regno;\n-\t    bitmap live;\n+      unsigned int i;\n+      int index;\n \n-\t    live = df_get_live_out (bb);\n-\t    for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t      if (all_vd[bb->index].e[regno].debug_insn_changes)\n-\t\t{\n-\t\t  if (REGNO_REG_SET_P (live, regno))\n-\t\t    apply_debug_insn_changes (all_vd + bb->index, regno);\n-\t\t  if (all_vd[bb->index].n_debug_insn_changes == 0)\n-\t\t    break;\n-\t\t}\n-\t  }\n+      any_debug_changes = false;\n+      bitmap_clear (visited);\n+      FOR_EACH_VEC_ELT (worklist, i, index)\n+\t{\n+\t  bb = BASIC_BLOCK_FOR_FN (fun, index);\n+\t  cprop_hardreg_bb (bb, all_vd, visited);\n+\t  if (all_vd[bb->index].n_debug_insn_changes)\n+\t    any_debug_changes = true;\n+\t}\n \n-      queued_debug_insn_change_pool.release ();\n+      df_analyze ();\n+      if (MAY_HAVE_DEBUG_BIND_INSNS && any_debug_changes)\n+\tcprop_hardreg_debug (fun, all_vd);\n     }\n \n   free (all_vd);"}]}