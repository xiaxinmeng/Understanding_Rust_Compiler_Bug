{"sha": "0b89eea8926cb52d0b8c50b764a67572a9fde60d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI4OWVlYTg5MjZjYjUyZDBiOGM1MGI3NjRhNjc1NzJhOWZkZTYwZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-08T12:49:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-08T12:49:46Z"}, "message": "[multiple changes]\n\n2010-10-08  Geert Bosch  <bosch@adacore.com>\n\n\t* a-textio.adb (Get_Line): Rewrite to use fgets instead of fgetc.\n\n2010-10-08  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Relax semantic rule of\n\tJava_Constructors because in the JRE library we generate occurrences\n\tin which the \"this\" parameter is not the first formal.\n\nFrom-SVN: r165170", "tree": {"sha": "8109777924b306d91413c120981aa9df4f0606ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8109777924b306d91413c120981aa9df4f0606ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b89eea8926cb52d0b8c50b764a67572a9fde60d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b89eea8926cb52d0b8c50b764a67572a9fde60d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b89eea8926cb52d0b8c50b764a67572a9fde60d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b89eea8926cb52d0b8c50b764a67572a9fde60d/comments", "author": null, "committer": null, "parents": [{"sha": "bd622b6454b89d73f3330733ff47da406ff7c042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd622b6454b89d73f3330733ff47da406ff7c042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd622b6454b89d73f3330733ff47da406ff7c042"}], "stats": {"total": 297, "additions": 209, "deletions": 88}, "files": [{"sha": "eb440cec55acc1b80eb742303a190d47efe0d772", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b89eea8926cb52d0b8c50b764a67572a9fde60d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b89eea8926cb52d0b8c50b764a67572a9fde60d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0b89eea8926cb52d0b8c50b764a67572a9fde60d", "patch": "@@ -1,3 +1,13 @@\n+2010-10-08  Geert Bosch  <bosch@adacore.com>\n+\n+\t* a-textio.adb (Get_Line): Rewrite to use fgets instead of fgetc.\n+\n+2010-10-08  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Relax semantic rule of\n+\tJava_Constructors because in the JRE library we generate occurrences\n+\tin which the \"this\" parameter is not the first formal.\n+\n 2010-10-08  Robert Dewar  <dewar@adacore.com>\n \n \t* par-ch3.adb: Minor reformatting."}, {"sha": "27a0c3b7f74c532768decbe7eaf8286b7a05998c", "filename": "gcc/ada/a-textio.adb", "status": "modified", "additions": 138, "deletions": 59, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b89eea8926cb52d0b8c50b764a67572a9fde60d/gcc%2Fada%2Fa-textio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b89eea8926cb52d0b8c50b764a67572a9fde60d/gcc%2Fada%2Fa-textio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-textio.adb?ref=0b89eea8926cb52d0b8c50b764a67572a9fde60d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,13 +29,15 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Streams;          use Ada.Streams;\n-with Interfaces.C_Streams; use Interfaces.C_Streams;\n+with Ada.Streams;             use Ada.Streams;\n+with Interfaces.C_Streams;    use Interfaces.C_Streams;\n \n+with System;                  use System;\n+with System.Storage_Elements; use System.Storage_Elements;\n with System.File_IO;\n with System.CRTL;\n-with System.WCh_Cnv;       use System.WCh_Cnv;\n-with System.WCh_Con;       use System.WCh_Con;\n+with System.WCh_Cnv;          use System.WCh_Cnv;\n+with System.WCh_Con;          use System.WCh_Con;\n \n with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n@@ -693,20 +695,120 @@ package body Ada.Text_IO is\n       Item : out String;\n       Last : out Natural)\n    is\n+      Chunk_Size : constant := 80;\n+      --  We read into a fixed size auxiliary buffer. Because this buffer\n+      --  needs to be pre-initialized, there is a trade-off between size and\n+      --  speed. Experiments find returns are diminishing after 50 and this\n+      --  size allows most lines to be processed with a single read.\n+\n       ch : int;\n+      N  : Natural;\n+\n+      procedure memcpy (s1, s2 : chars; n : size_t);\n+      pragma Import (C, memcpy);\n+\n+      function memchr (s : chars; ch : int; n : size_t) return chars;\n+      pragma Import (C, memchr);\n+\n+      procedure memset (b : chars; ch : int; n : size_t);\n+      pragma Import (C, memset);\n+\n+      function Get_Chunk (N : Positive) return Natural;\n+      --  Reads at most N - 1 characters into Item (Last + 1 .. Item'Last),\n+      --  updating Last. Raises End_Error if nothing was read (End_Of_File).\n+      --  Returns number of characters still to read (either 0 or 1) in\n+      --  case of success.\n+\n+      ---------------\n+      -- Get_Chunk --\n+      ---------------\n+\n+      function Get_Chunk (N : Positive) return Natural is\n+         Buf : String (1 .. Chunk_Size);\n+         S   : constant chars := Buf (1)'Address;\n+         P   : chars;\n+\n+      begin\n+         if N = 1 then\n+            return N;\n+         end if;\n+\n+         memset (S, 10, size_t (N));\n+\n+         if fgets (S, N, File.Stream) = Null_Address then\n+            if ferror (File.Stream) /= 0 then\n+               raise Device_Error;\n+\n+            --  If incomplete last line, pretend we found a LM\n+\n+            elsif Last >= Item'First then\n+               return 0;\n+\n+            else\n+               raise End_Error;\n+            end if;\n+         end if;\n+\n+         P := memchr (S, LM, size_t (N));\n+\n+         --  If no LM is found, the buffer got filled without reading a new\n+         --  line. Otherwise, the LM is either one from the input, or else one\n+         --  from the initialization, which means an incomplete end-of-line was\n+         --  encountered. Only in first case the LM will be followed by a 0.\n+\n+         if P = Null_Address then\n+            pragma Assert (Buf (N) = ASCII.NUL);\n+            memcpy (Item (Item'First + Last)'Address,\n+                    Buf (1)'Address, size_t (N - 1));\n+            Last := Last + N - 1;\n+\n+            return 1;\n+\n+         else\n+            --  P points to the LM character. Set K so Buf (K) is the character\n+            --  right before.\n+\n+            declare\n+               K : Natural := Natural (P - S);\n+\n+            begin\n+               --  Now Buf (K + 2) should be 0, or otherwise Buf (K) is the 0\n+               --  put in by fgets, so compensate.\n+\n+               if K + 2 > Buf'Last or else Buf (K + 2) /= ASCII.NUL then\n+\n+                  --  Incomplete last line, so remove the extra 0\n+\n+                  pragma Assert (Buf (K) = ASCII.NUL);\n+                  K := K - 1;\n+               end if;\n+\n+               memcpy (Item (Item'First + Last)'Address,\n+                       Buf (1)'Address, size_t (K));\n+               Last := Last + K;\n+            end;\n+\n+            return 0;\n+         end if;\n+      end Get_Chunk;\n+\n+   --  Start of processing for Get_Line\n \n    begin\n       FIO.Check_Read_Status (AP (File));\n-      Last := Item'First - 1;\n \n       --  Immediate exit for null string, this is a case in which we do not\n       --  need to test for end of file and we do not skip a line mark under\n       --  any circumstances.\n \n-      if Last >= Item'Last then\n+      if Item'First > Item'Last then\n          return;\n       end if;\n \n+      N := Item'Last - Item'First + 1;\n+\n+      Last := Item'First - 1;\n+\n       --  Here we have at least one character, if we are immediately before\n       --  a line mark, then we will just skip past it storing no characters.\n \n@@ -717,67 +819,44 @@ package body Ada.Text_IO is\n       --  Otherwise we need to read some characters\n \n       else\n-         ch := Getc (File);\n-\n-         --  If we are at the end of file now, it means we are trying to\n-         --  skip a file terminator and we raise End_Error (RM A.10.7(20))\n+         while N >= Chunk_Size loop\n+            if Get_Chunk (Chunk_Size) = 0 then\n+               N := 0;\n+            else\n+               N := N - Chunk_Size + 1;\n+            end if;\n+         end loop;\n \n-         if ch = EOF then\n-            raise End_Error;\n+         if N > 1 then\n+            N := Get_Chunk (N);\n          end if;\n \n-         --  Loop through characters. Don't bother if we hit a page mark,\n-         --  since in normal files, page marks can only follow line marks\n-         --  in any case and we only promise to treat the page nonsense\n-         --  correctly in the absense of such rogue page marks.\n+         --  Almost there, only a little bit more to read\n \n-         loop\n-            --  Exit the loop if read is terminated by encountering line mark\n-\n-            exit when ch = LM;\n-\n-            --  Otherwise store the character, note that we know that ch is\n-            --  something other than LM or EOF. It could possibly be a page\n-            --  mark if there is a stray page mark in the middle of a line,\n-            --  but this is not an official page mark in any case, since\n-            --  official page marks can only follow a line mark. The whole\n-            --  page business is pretty much nonsense anyway, so we do not\n-            --  want to waste time trying to make sense out of non-standard\n-            --  page marks in the file! This means that the behavior of\n-            --  Get_Line is different from repeated Get of a character, but\n-            --  that's too bad. We only promise that page numbers etc make\n-            --  sense if the file is formatted in a standard manner.\n-\n-            --  Note: we do not adjust the column number because it is quicker\n-            --  to adjust it once at the end of the operation than incrementing\n-            --  it each time around the loop.\n-\n-            Last := Last + 1;\n-            Item (Last) := Character'Val (ch);\n-\n-            --  All done if the string is full, this is the case in which\n-            --  we do not skip the following line mark. We need to adjust\n-            --  the column number in this case.\n-\n-            if Last = Item'Last then\n-               File.Col := File.Col + Count (Item'Length);\n-               return;\n-            end if;\n+         if N = 1 then\n+            ch := Getc (File);\n \n-            --  Otherwise read next character. We also exit from the loop if\n-            --  we read an end of file. This is the case where the last line\n-            --  is not terminated with a line mark, and we consider that there\n-            --  is an implied line mark in this case (this is a non-standard\n-            --  file, but it is nice to treat it reasonably).\n+            --  If we get EOF after already reading data, this is an incomplete\n+            --  last line, in which case no End_Error should be raised.\n \n-            ch := Getc (File);\n-            exit when ch = EOF;\n-         end loop;\n+            if ch = EOF and then Last < Item'First then\n+               raise End_Error;\n+\n+            elsif ch /= LM then\n+\n+               --  Buffer really is full without having seen LM, update col\n+\n+               Last := Last + 1;\n+               Item (Last) := Character'Val (ch);\n+               File.Col := File.Col + Count (Last - Item'First + 1);\n+               return;\n+            end if;\n+         end if;\n       end if;\n \n       --  We have skipped past, but not stored, a line mark. Skip following\n-      --  page mark if one follows, but do not do this for a non-regular\n-      --  file (since otherwise we get annoying wait for an extra character)\n+      --  page mark if one follows, but do not do this for a non-regular file\n+      --  (since otherwise we get annoying wait for an extra character)\n \n       File.Line := File.Line + 1;\n       File.Col := 1;"}, {"sha": "90424cdeeb154a1e8dc29f0c8a200b5d3cc93120", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b89eea8926cb52d0b8c50b764a67572a9fde60d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b89eea8926cb52d0b8c50b764a67572a9fde60d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0b89eea8926cb52d0b8c50b764a67572a9fde60d", "patch": "@@ -2378,7 +2378,7 @@ package body Sem_Prag is\n                      --  need to force visibility for client (error will be\n                      --  output in any case, and this is the situation in which\n                      --  we do not want a client to get a warning, since the\n-                     --  warning is in the body or the spec private part.\n+                     --  warning is in the body or the spec private part).\n \n                      else\n                         if Cont = False then\n@@ -8903,10 +8903,11 @@ package body Sem_Prag is\n \n          when Pragma_CIL_Constructor | Pragma_Java_Constructor =>\n          Java_Constructor : declare\n-            Convention : Convention_Id;\n-            Def_Id     : Entity_Id;\n-            Hom_Id     : Entity_Id;\n-            Id         : Entity_Id;\n+            Convention  : Convention_Id;\n+            Def_Id      : Entity_Id;\n+            Hom_Id      : Entity_Id;\n+            Id          : Entity_Id;\n+            This_Formal : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -8997,81 +8998,112 @@ package body Sem_Prag is\n                if not Is_Value_Type (Etype (Def_Id)) then\n                   if No (First_Formal (Def_Id)) then\n                      Error_Msg_Name_1 := Pname;\n-                     Error_Msg_N\n-                       (\"first formal of % function must be named `this`\",\n-                        Def_Id);\n+                     Error_Msg_N (\"% function must have parameters\", Def_Id);\n+                     return;\n+                  end if;\n+\n+                  --  In the JRE library we have several occurrences in which\n+                  --  the \"this\" parameter is not the first formal.\n \n-                  elsif Get_Name_String (Chars (First_Formal (Def_Id)))\n-                          /= \"this\"\n+                  This_Formal := First_Formal (Def_Id);\n+\n+                  --  In the JRE library we have several occurrences in which\n+                  --  the \"this\" parameter is not the first formal. Search for\n+                  --  it.\n+\n+                  if VM_Target = JVM_Target then\n+                     while Present (This_Formal)\n+                       and then Get_Name_String (Chars (This_Formal)) /= \"this\"\n+                     loop\n+                        Next_Formal (This_Formal);\n+                     end loop;\n+\n+                     if No (This_Formal) then\n+                        This_Formal := First_Formal (Def_Id);\n+                     end if;\n+                  end if;\n+\n+                  --  Warning: The first parameter should be named \"this\".\n+                  --  We temporarily allow it because we have the following\n+                  --  case in the Java runtime (file s-osinte.ads) ???\n+\n+                  --    function new_Thread\n+                  --      (Self_Id : System.Address) return Thread_Id;\n+                  --    pragma Java_Constructor (new_Thread);\n+\n+                  if VM_Target = JVM_Target\n+                    and then Get_Name_String (Chars (First_Formal (Def_Id)))\n+                               = \"self_id\"\n+                    and then Etype (First_Formal (Def_Id)) = RTE (RE_Address)\n                   then\n+                     null;\n+\n+                  elsif Get_Name_String (Chars (This_Formal)) /= \"this\" then\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_N\n                        (\"first formal of % function must be named `this`\",\n-                        Parent (First_Formal (Def_Id)));\n+                        Parent (This_Formal));\n \n-                  elsif not Is_Access_Type (Etype (First_Formal (Def_Id))) then\n+                  elsif not Is_Access_Type (Etype (This_Formal)) then\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_N\n                        (\"first formal of % function must be an access type\",\n-                        Parameter_Type (Parent (First_Formal (Def_Id))));\n+                        Parameter_Type (Parent (This_Formal)));\n \n                   --  For delegates the type of the first formal must be a\n                   --  named access-to-subprogram type (see previous example)\n \n                   elsif Ekind (Etype (Def_Id)) = E_Access_Subprogram_Type\n-                    and then Ekind (Etype (First_Formal (Def_Id)))\n+                    and then Ekind (Etype (This_Formal))\n                                /= E_Access_Subprogram_Type\n                   then\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_N\n                        (\"first formal of % function must be a named access\" &\n                         \" to subprogram type\",\n-                        Parameter_Type (Parent (First_Formal (Def_Id))));\n+                        Parameter_Type (Parent (This_Formal)));\n \n                   --  Warning: We should reject anonymous access types because\n                   --  the constructor must not be handled as a primitive of the\n                   --  tagged type. We temporarily allow it because this profile\n                   --  is currently generated by cil2ada???\n \n                   elsif Ekind (Etype (Def_Id)) /= E_Access_Subprogram_Type\n-                    and then not Ekind_In (Etype (First_Formal (Def_Id)),\n-                                   E_Access_Type,\n-                                   E_General_Access_Type,\n-                                   E_Anonymous_Access_Type)\n+                    and then not Ekind_In (Etype (This_Formal),\n+                                             E_Access_Type,\n+                                             E_General_Access_Type,\n+                                             E_Anonymous_Access_Type)\n                   then\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_N\n                        (\"first formal of % function must be a named access\" &\n                         \" type\",\n-                        Parameter_Type (Parent (First_Formal (Def_Id))));\n+                        Parameter_Type (Parent (This_Formal)));\n \n                   elsif Atree.Convention\n-                         (Designated_Type (Etype (First_Formal (Def_Id))))\n-                           /= Convention\n+                         (Designated_Type (Etype (This_Formal))) /= Convention\n                   then\n                      Error_Msg_Name_1 := Pname;\n \n                      if Convention = Convention_Java then\n                         Error_Msg_N\n                           (\"pragma% requires convention 'Cil in designated\" &\n                            \" type\",\n-                           Parameter_Type (Parent (First_Formal (Def_Id))));\n+                           Parameter_Type (Parent (This_Formal)));\n                      else\n                         Error_Msg_N\n                           (\"pragma% requires convention 'Java in designated\" &\n                            \" type\",\n-                           Parameter_Type (Parent (First_Formal (Def_Id))));\n+                           Parameter_Type (Parent (This_Formal)));\n                      end if;\n \n-                  elsif No (Expression (Parent (First_Formal (Def_Id))))\n-                    or else\n-                      Nkind (Expression (Parent (First_Formal (Def_Id)))) /=\n-                        N_Null\n+                  elsif No (Expression (Parent (This_Formal)))\n+                    or else Nkind (Expression (Parent (This_Formal))) /= N_Null\n                   then\n                      Error_Msg_Name_1 := Pname;\n                      Error_Msg_N\n                        (\"pragma% requires first formal with default `null`\",\n-                        Parameter_Type (Parent (First_Formal (Def_Id))));\n+                        Parameter_Type (Parent (This_Formal)));\n                   end if;\n                end if;\n "}]}