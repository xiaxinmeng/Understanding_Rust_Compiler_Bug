{"sha": "2cdb31489836779b7316f60cb49c5eb83de88adb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNkYjMxNDg5ODM2Nzc5YjczMTZmNjBjYjQ5YzVlYjgzZGU4OGFkYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-05T19:14:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-05T19:14:39Z"}, "message": "re PR target/12902 (Invalid assembly generated when using SSE / xmmintrin.h)\n\n        PR target/12902\n        * config/i386/i386.md (sse_movhps, sse_movlps): Remove.\n        (sse_shufps): Change operand 3 to const_int_operand.\n        (sse2_storelps): Fix typo in template.\n        (sse_storehps, sse_loadhps, sse_storelps, sse_loadlps): New.\n        * config/i386/i386.c (ix86_expand_vector_move_misalign): Use them.\n        (ix86_expand_builtin): Likewise.\n\nFrom-SVN: r92967", "tree": {"sha": "52d655caee77394c15ebc4f8c9f7c2a69550afe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52d655caee77394c15ebc4f8c9f7c2a69550afe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cdb31489836779b7316f60cb49c5eb83de88adb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cdb31489836779b7316f60cb49c5eb83de88adb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cdb31489836779b7316f60cb49c5eb83de88adb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cdb31489836779b7316f60cb49c5eb83de88adb/comments", "author": null, "committer": null, "parents": [{"sha": "a8182d3719015766107812ceb65220dde1074f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8182d3719015766107812ceb65220dde1074f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8182d3719015766107812ceb65220dde1074f20"}], "stats": {"total": 202, "additions": 143, "deletions": 59}, "files": [{"sha": "08b41f583f3d814aeb2f89d2ad435724d3ad188b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cdb31489836779b7316f60cb49c5eb83de88adb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cdb31489836779b7316f60cb49c5eb83de88adb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2cdb31489836779b7316f60cb49c5eb83de88adb", "patch": "@@ -1,4 +1,14 @@\n-2004-01-05  Julian Brown  <julian@codesourcery.com>\n+2005-01-05  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/12902\n+\t* config/i386/i386.md (sse_movhps, sse_movlps): Remove.\n+\t(sse_shufps): Change operand 3 to const_int_operand.\n+\t(sse2_storelps): Fix typo in template.\n+\t(sse_storehps, sse_loadhps, sse_storelps, sse_loadlps): New.\n+\t* config/i386/i386.c (ix86_expand_vector_move_misalign): Use them.\n+\t(ix86_expand_builtin): Likewise.\n+\n+2005-01-05  Julian Brown  <julian@codesourcery.com>\n \n \t* config/arm/arm.c (arm_return_in_memory): Treat complex types\n \tas aggregates for AAPCS ABIs."}, {"sha": "51d36f186266dc0729b1b2b174c4e2e50467a0d1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cdb31489836779b7316f60cb49c5eb83de88adb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cdb31489836779b7316f60cb49c5eb83de88adb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2cdb31489836779b7316f60cb49c5eb83de88adb", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on IA-32.\n    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004 Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -7645,11 +7645,10 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t  else\n \t    emit_insn (gen_rtx_CLOBBER (VOIDmode, op0));\n \n-\t  op0 = gen_lowpart (V4SFmode, op0);\n-\t  m = adjust_address (op1, V4SFmode, 0);\n-\t  emit_insn (gen_sse_movlps (op0, op0, m));\n-\t  m = adjust_address (op1, V4SFmode, 8);\n-\t  emit_insn (gen_sse_movhps (op0, op0, m));\n+\t  m = adjust_address (op1, V2SFmode, 0);\n+\t  emit_insn (gen_sse_loadlps (op0, op0, m));\n+\t  m = adjust_address (op1, V2SFmode, 8);\n+\t  emit_insn (gen_sse_loadhps (op0, op0, m));\n \t}\n     }\n   else if (MEM_P (op0))\n@@ -7684,11 +7683,10 @@ ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n \t}\n       else\n \t{\n-\t  op1 = gen_lowpart (V4SFmode, op1);\n-\t  m = adjust_address (op0, V4SFmode, 0);\n-\t  emit_insn (gen_sse_movlps (m, m, op1));\n-\t  m = adjust_address (op0, V4SFmode, 8);\n-\t  emit_insn (gen_sse_movhps (m, m, op1));\n+\t  m = adjust_address (op0, V2SFmode, 0);\n+\t  emit_insn (gen_sse_storelps (m, op1));\n+\t  m = adjust_address (op0, V2SFmode, 8);\n+\t  emit_insn (gen_sse_storehps (m, op1));\n \t  return;\n \t}\n     }\n@@ -13508,8 +13506,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case IX86_BUILTIN_LOADLPS:\n     case IX86_BUILTIN_LOADHPD:\n     case IX86_BUILTIN_LOADLPD:\n-      icode = (fcode == IX86_BUILTIN_LOADHPS ? CODE_FOR_sse_movhps\n-\t       : fcode == IX86_BUILTIN_LOADLPS ? CODE_FOR_sse_movlps\n+      icode = (fcode == IX86_BUILTIN_LOADHPS ? CODE_FOR_sse_loadhps\n+\t       : fcode == IX86_BUILTIN_LOADLPS ? CODE_FOR_sse_loadlps\n \t       : fcode == IX86_BUILTIN_LOADHPD ? CODE_FOR_sse2_loadhpd\n \t       : CODE_FOR_sse2_loadlpd);\n       arg0 = TREE_VALUE (arglist);\n@@ -13535,28 +13533,11 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n     case IX86_BUILTIN_STOREHPS:\n     case IX86_BUILTIN_STORELPS:\n-      icode = (fcode == IX86_BUILTIN_STOREHPS ? CODE_FOR_sse_movhps\n-\t       : CODE_FOR_sse_movlps);\n-      arg0 = TREE_VALUE (arglist);\n-      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-      mode0 = insn_data[icode].operand[1].mode;\n-      mode1 = insn_data[icode].operand[2].mode;\n-\n-      op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n-\n-      pat = GEN_FCN (icode) (op0, op0, op1);\n-      if (! pat)\n-\treturn 0;\n-      emit_insn (pat);\n-      return const0_rtx;\n-\n     case IX86_BUILTIN_STOREHPD:\n     case IX86_BUILTIN_STORELPD:\n-      icode = (fcode == IX86_BUILTIN_STOREHPD ? CODE_FOR_sse2_storehpd\n+      icode = (fcode == IX86_BUILTIN_STOREHPS ? CODE_FOR_sse_storehps\n+\t       : fcode == IX86_BUILTIN_STORELPS ? CODE_FOR_sse_storelps\n+\t       : fcode == IX86_BUILTIN_STOREHPD ? CODE_FOR_sse2_storehpd\n \t       : CODE_FOR_sse2_storelpd);\n       arg0 = TREE_VALUE (arglist);\n       arg1 = TREE_VALUE (TREE_CHAIN (arglist));"}, {"sha": "7848579153efaf6d0209d5130cf9dbc487c22c7a", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 93, "deletions": 25, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cdb31489836779b7316f60cb49c5eb83de88adb/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cdb31489836779b7316f60cb49c5eb83de88adb/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2cdb31489836779b7316f60cb49c5eb83de88adb", "patch": "@@ -1,6 +1,6 @@\n ;; GCC machine description for IA-32 and x86-64.\n ;; Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-;; 2001, 2002, 2003, 2004\n+;; 2001, 2002, 2003, 2004, 2005\n ;; Free Software Foundation, Inc.\n ;; Mostly by William Schelter.\n ;; x86_64 support added by Jan Hubicka\n@@ -20335,29 +20335,98 @@\n   [(set_attr \"type\" \"ssecvt\")\n    (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"sse_movhps\"\n-  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(vec_merge:V4SF\n-\t (match_operand:V4SF 1 \"nonimmediate_operand\" \"0,0\")\n-\t (match_operand:V4SF 2 \"nonimmediate_operand\" \"m,x\")\n-\t (const_int 12)))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[1]) == MEM || GET_CODE (operands[2]) == MEM)\"\n-  \"movhps\\t{%2, %0|%0, %2}\"\n+;; Store the high V2SF of the source vector to the destination.\n+(define_insn \"sse_storehps\"\n+  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=m,x,x\")\n+\t(vec_select:V2SF\n+\t  (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,x,o\")\n+\t  (parallel [(const_int 2) (const_int 3)])))]\n+  \"TARGET_SSE\"\n+  \"@\n+   movhps\\t{%1, %0|%0, %1}\n+   movhlps\\t{%1, %0|%0, %1}\n+   #\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"V2SF\")])\n \n-(define_insn \"sse_movlps\"\n-  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(vec_merge:V4SF\n-\t (match_operand:V4SF 1 \"nonimmediate_operand\" \"0,0\")\n-\t (match_operand:V4SF 2 \"nonimmediate_operand\" \"m,x\")\n-\t (const_int 3)))]\n-  \"TARGET_SSE\n-   && (GET_CODE (operands[1]) == MEM || GET_CODE (operands[2]) == MEM)\"\n-  \"movlps\\t{%2, %0|%0, %2}\"\n+(define_split\n+  [(set (match_operand:V2SF 0 \"register_operand\" \"\")\n+\t(vec_select:V2SF\n+\t  (match_operand:V4SF 1 \"memory_operand\" \"\")\n+\t  (parallel [(const_int 2) (const_int 3)])))]\n+  \"TARGET_SSE && reload_completed\"\n+  [(const_int 0)]\n+{\n+  emit_move_insn (operands[0], adjust_address (operands[1], V2SFmode, 8));\n+  DONE;\n+})\n+\n+;; Load the high V2SF of the target vector from the source vector.\n+(define_insn \"sse_loadhps\"\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,x,o\")\n+\t(vec_concat:V4SF\n+\t  (vec_select:V2SF\n+\t    (match_operand:V4SF 1 \"nonimmediate_operand\" \"0,0,0\")\n+\t    (parallel [(const_int 0) (const_int 1)]))\n+\t  (match_operand:V2SF 2 \"nonimmediate_operand\" \"m,x,x\")))]\n+  \"TARGET_SSE\"\n+  \"@\n+   movhps\\t{%2, %0|%0, %2}\n+   movlhps\\t{%2, %0|%0, %2}\n+   #\"\n   [(set_attr \"type\" \"ssecvt\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"V2SF\")])\n+\n+(define_split\n+  [(set (match_operand:V4SF 0 \"memory_operand\" \"\")\n+\t(vec_concat:V4SF\n+\t  (vec_select:V2SF\n+\t    (match_dup 0)\n+\t    (parallel [(const_int 0) (const_int 1)]))\n+\t  (match_operand:V2SF 2 \"register_operand\" \"\")))]\n+  \"TARGET_SSE && reload_completed\"\n+  [(const_int 0)]\n+{\n+  emit_move_insn (adjust_address (operands[0], V2SFmode, 8), operands[1]);\n+  DONE;\n+})\n+\n+;; Store the low V2SF of the source vector to the destination.\n+(define_expand \"sse_storelps\"\n+  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"\")\n+\t(vec_select:V2SF\n+\t  (match_operand:V4SF 1 \"nonimmediate_operand\" \"\")\n+\t  (parallel [(const_int 0) (const_int 1)])))]\n+  \"TARGET_SSE\"\n+{\n+  operands[1] = gen_lowpart (V2SFmode, operands[1]);\n+  emit_move_insn (operands[0], operands[1]);\n+  DONE;\n+})\n+\n+;; Load the low V2SF of the target vector from the source vector.\n+(define_insn \"sse_loadlps\"\n+  [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=x,x,m\")\n+\t(vec_concat:V4SF\n+\t  (match_operand:V2SF 2 \"nonimmediate_operand\" \"m,0,x\")\n+\t  (vec_select:V2SF\n+\t    (match_operand:V4SF 1 \"nonimmediate_operand\" \"0,x,0\")\n+\t    (parallel [(const_int 2) (const_int 3)]))))]\n+  \"TARGET_SSE\"\n+{\n+  static const char * const alt[] = {\n+    \"movlps\\t{%2, %0|%0, %2}\",\n+    \"shufps\\t{%2, %1, %0|%0, %1, %2}\",\n+    \"movlps\\t{%2, %0|%0, %2}\"\n+  };\n+\n+  if (which_alternative == 1)\n+    operands[2] = GEN_INT (0xe4);\n+\n+  return alt[which_alternative];\n+}\n+  [(set_attr \"type\" \"ssecvt\")\n+   (set_attr \"mode\" \"V2SF\")])\n \n (define_expand \"sse_loadss\"\n   [(match_operand:V4SF 0 \"register_operand\" \"\")\n@@ -20405,10 +20474,9 @@\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n         (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"0\")\n \t\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")\n-\t\t      (match_operand:SI 3 \"immediate_operand\" \"i\")]\n+\t\t      (match_operand:SI 3 \"const_int_operand\" \"n\")]\n \t\t     UNSPEC_SHUFFLE))]\n   \"TARGET_SSE\"\n-  ;; @@@ check operand order for intel/nonintel syntax\n   \"shufps\\t{%3, %2, %0|%0, %2, %3}\"\n   [(set_attr \"type\" \"ssecvt\")\n    (set_attr \"mode\" \"V4SF\")])\n@@ -23902,15 +23970,15 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(vec_select:DF\n \t  (match_operand:V2DF 1 \"nonimmediate_operand\" \"\")\n-\t  (parallel [(const_int 1)])))]\n+\t  (parallel [(const_int 0)])))]\n   \"TARGET_SSE2\"\n {\n   operands[1] = gen_lowpart (DFmode, operands[1]);\n   emit_move_insn (operands[0], operands[1]);\n   DONE;\n })\n \n-;; Load the load double of the target vector from the source scalar.\n+;; Load the low double of the target vector from the source scalar.\n (define_insn \"sse2_loadlpd\"\n   [(set (match_operand:V2DF 0 \"nonimmediate_operand\"     \"=Y,Y,m\")\n \t(vec_concat:V2DF"}, {"sha": "afae22d3705403f1030661f40075b884625b671e", "filename": "gcc/testsuite/gcc.target/i386/sse-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cdb31489836779b7316f60cb49c5eb83de88adb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cdb31489836779b7316f60cb49c5eb83de88adb/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-1.c?ref=2cdb31489836779b7316f60cb49c5eb83de88adb", "patch": "@@ -0,0 +1,25 @@\n+/* PR 12902 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -msse\" } */\n+\n+#include <xmmintrin.h>\n+\n+typedef union\n+{\n+  int i[4];\n+  float f[4];\n+  __m128 v;\n+} vector4_t;\n+\n+void\n+swizzle (const void *a, vector4_t * b, vector4_t * c)\n+{\n+  b->v = _mm_loadl_pi (b->v, (__m64 *) a);\n+  c->v = _mm_loadl_pi (c->v, ((__m64 *) a) + 1);\n+}\n+\n+/* While one legal rendering of each statement would be movaps;movlps;movaps,\n+   we can implmenent this with just movlps;movlps.  Since we do now, anything\n+   less would be a regression.  */\n+/* { dg-final { scan-assembler-not \"movaps\" } } */\n+/* { dg-final { scan-assembler \"movlps\" } } */"}]}