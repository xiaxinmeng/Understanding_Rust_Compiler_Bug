{"sha": "d348bda453c2ec3ebe67ff3208822e040960ccb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM0OGJkYTQ1M2MyZWMzZWJlNjdmZjMyMDg4MjJlMDQwOTYwY2NiNg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-02-16T00:07:34Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-02-16T00:07:34Z"}, "message": "resolve.cc (ncode): Set args_raw_size.\n\n\t* resolve.cc (ncode): Set args_raw_size.  Compute jni_cif and\n\tjni_arg_types.\n\t(init_cif): Added `rtype_p' argument.\n\t* include/java-interp.h (class _Jv_MethodBase): Added\n\targs_raw_size.\n\t(class _Jv_InterpMethod): Removed args_raw_size.\n\t(class _Jv_JNIMethod): Added jni_cif and jni_arg_types fields.\n\t* jni.cc (call): Pass JNIEnv and (for static methods only) the\n\tclass pointer as well as the ordinary arguments.\n\nFrom-SVN: r31995", "tree": {"sha": "fd8526541777f72d0a207a77149193b5171b7e75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd8526541777f72d0a207a77149193b5171b7e75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d348bda453c2ec3ebe67ff3208822e040960ccb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d348bda453c2ec3ebe67ff3208822e040960ccb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d348bda453c2ec3ebe67ff3208822e040960ccb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d348bda453c2ec3ebe67ff3208822e040960ccb6/comments", "author": null, "committer": null, "parents": [{"sha": "f295bdb5eb37ae58628d68dd74d7067591ee29ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f295bdb5eb37ae58628d68dd74d7067591ee29ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f295bdb5eb37ae58628d68dd74d7067591ee29ee"}], "stats": {"total": 80, "additions": 71, "deletions": 9}, "files": [{"sha": "2f272248444cafb23cc75228b315c53cae68c134", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d348bda453c2ec3ebe67ff3208822e040960ccb6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d348bda453c2ec3ebe67ff3208822e040960ccb6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d348bda453c2ec3ebe67ff3208822e040960ccb6", "patch": "@@ -1,5 +1,15 @@\n 2000-02-15  Tom Tromey  <tromey@cygnus.com>\n \n+\t* resolve.cc (ncode): Set args_raw_size.  Compute jni_cif and\n+\tjni_arg_types.\n+\t(init_cif): Added `rtype_p' argument.\n+\t* include/java-interp.h (class _Jv_MethodBase): Added\n+\targs_raw_size.\n+\t(class _Jv_InterpMethod): Removed args_raw_size.\n+\t(class _Jv_JNIMethod): Added jni_cif and jni_arg_types fields.\n+\t* jni.cc (call): Pass JNIEnv and (for static methods only) the\n+\tclass pointer as well as the ordinary arguments.\n+\n \t* jni.cc (mangled_name): Skip leading `(' in signature.\n \n \t* jni.cc (add_char): Added missing `else'."}, {"sha": "a0ca3470de8ad587a854fb1d2ef01a74f2044ed1", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d348bda453c2ec3ebe67ff3208822e040960ccb6/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d348bda453c2ec3ebe67ff3208822e040960ccb6/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=d348bda453c2ec3ebe67ff3208822e040960ccb6", "patch": "@@ -76,6 +76,9 @@ class _Jv_MethodBase\n \n   // The method description.\n   _Jv_Method *self;\n+\n+  // Size of raw arguments.\n+  _Jv_ushort args_raw_size;\n };\n \n class _Jv_InterpMethod : public _Jv_MethodBase\n@@ -85,7 +88,6 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   int              code_length;\n \n   _Jv_ushort       exc_count;\n-  _Jv_ushort       args_raw_size;\n \n   unsigned char* bytecode () \n   {\n@@ -175,6 +177,12 @@ class _Jv_JNIMethod : public _Jv_MethodBase\n   // function.\n   void *function;\n \n+  // This is the CIF used by the JNI function.\n+  ffi_cif jni_cif;\n+\n+  // These are the argument types used by the JNI function.\n+  ffi_type **jni_arg_types;\n+\n   // This function is used when making a JNI call from the interpreter.\n   static void call (ffi_cif *, void *, ffi_raw *, void *);\n "}, {"sha": "26f3b049852103257cdd51197916057f08a0ae43", "filename": "libjava/jni.cc", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d348bda453c2ec3ebe67ff3208822e040960ccb6/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d348bda453c2ec3ebe67ff3208822e040960ccb6/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=d348bda453c2ec3ebe67ff3208822e040960ccb6", "patch": "@@ -1323,7 +1323,7 @@ mangled_name (jclass klass, _Jv_Utf8Const *func_name,\n // This function is the stub which is used to turn an ordinary (CNI)\n // method call into a JNI call.\n void\n-_Jv_JNIMethod::call (ffi_cif *cif, void *ret, ffi_raw *args, void *__this)\n+_Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n {\n   _Jv_JNIMethod* _this = (_Jv_JNIMethod *) __this;\n \n@@ -1372,9 +1372,24 @@ _Jv_JNIMethod::call (ffi_cif *cif, void *ret, ffi_raw *args, void *__this)\n \t}\n     }\n \n+  JvAssert (_this->args_raw_size % sizeof (ffi_raw) == 0);\n+  ffi_raw real_args[2 + _this->args_raw_size / sizeof (ffi_raw)];\n+  int offset = 0;\n+\n+  // First argument is always the environment pointer.\n+  real_args[offset++].ptr = &env;\n+\n+  // For a static method, we pass in the Class.  For non-static\n+  // methods, the `this' argument is already handled.\n+  if ((_this->self->accflags & java::lang::reflect::Modifier::STATIC))\n+    real_args[offset++].ptr = _this->defining_class;\n+\n+  // Copy over passed-in arguments.\n+  memcpy (&real_args[offset], args, _this->args_raw_size);\n+\n   // The actual call to the JNI function.\n-  // FIXME: if this is a static function we must include the class!\n-  ffi_raw_call (cif, (void (*) (...)) _this->function, ret, args);\n+  ffi_raw_call (&_this->jni_cif, (void (*) (...)) _this->function,\n+\t\tret, real_args);\n \n   do\n     {"}, {"sha": "634c08fa11ec9f022bdcc0579e9ba93b8d1853d8", "filename": "libjava/resolve.cc", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d348bda453c2ec3ebe67ff3208822e040960ccb6/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d348bda453c2ec3ebe67ff3208822e040960ccb6/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=d348bda453c2ec3ebe67ff3208822e040960ccb6", "patch": "@@ -941,7 +941,8 @@ init_cif (_Jv_Utf8Const* signature,\n \t  int arg_count,\n \t  jboolean staticp,\n \t  ffi_cif *cif,\n-\t  ffi_type **arg_types)\n+\t  ffi_type **arg_types,\n+\t  ffi_type **rtype_p)\n {\n   unsigned char *ptr = (unsigned char*) signature->data;\n \n@@ -983,6 +984,9 @@ init_cif (_Jv_Utf8Const* signature,\n \t\t    arg_count, rtype, arg_types) != FFI_OK)\n     throw_internal_error (\"ffi_prep_cif failed\");\n \n+  if (rtype_p != NULL)\n+    *rtype_p = rtype;\n+\n   return item_count;\n }\n \n@@ -1019,7 +1023,8 @@ _Jv_InterpMethod::ncode ()\n \t    arg_count,\n \t    staticp,\n \t    &closure->cif,\n-\t    &closure->arg_types[0]);\n+\t    &closure->arg_types[0],\n+\t    NULL);\n \n   ffi_closure_fun fun;\n \n@@ -1064,14 +1069,37 @@ _Jv_JNIMethod::ncode ()\n     (ncode_closure*)_Jv_AllocBytesChecked (sizeof (ncode_closure)\n \t\t\t\t\t+ arg_count * sizeof (ffi_type*));\n \n+  ffi_type *rtype;\n   init_cif (self->signature,\n \t    arg_count,\n \t    staticp,\n \t    &closure->cif,\n-\t    &closure->arg_types[0]);\n+\t    &closure->arg_types[0],\n+\t    &rtype);\n \n   ffi_closure_fun fun;\n \n+  args_raw_size = ffi_raw_size (&closure->cif);\n+\n+  // Initialize the argument types and CIF that represent the actual\n+  // underlying JNI function.\n+  int extra_args = 1;\n+  if ((self->accflags & Modifier::STATIC))\n+    ++extra_args;\n+  jni_arg_types = (ffi_type **) _Jv_Malloc ((extra_args + arg_count)\n+\t\t\t\t\t    * sizeof (ffi_type *));\n+  int offset = 0;\n+  jni_arg_types[offset++] = &ffi_type_pointer;\n+  if ((self->accflags & Modifier::STATIC))\n+    jni_arg_types[offset++] = &ffi_type_pointer;\n+  memcpy (&jni_arg_types[offset], &closure->arg_types[0],\n+\t  arg_count * sizeof (ffi_type *));\n+\n+  if (ffi_prep_cif (&jni_cif, FFI_DEFAULT_ABI,\n+\t\t    extra_args + arg_count, rtype,\n+\t\t    jni_arg_types) != FFI_OK)\n+    throw_internal_error (\"ffi_prep_cif failed for JNI function\");\n+\n   JvAssert ((self->accflags & Modifier::NATIVE) != 0);\n \n   // FIXME: for now we assume that all native methods for\n@@ -1083,7 +1111,7 @@ _Jv_JNIMethod::ncode ()\n \t\t\tfun,\n \t\t\t(void*) this);\n \n-  self->ncode = (void*)closure;\n+  self->ncode = (void *) closure;\n   return self->ncode;\n }\n \n@@ -1107,7 +1135,8 @@ _Jv_BuildResolvedMethod (_Jv_Method* method,\n \t\targ_count,\n \t\tstaticp,\n \t\t&result->cif,\n-\t\t&result->arg_types[0]);\n+\t\t&result->arg_types[0],\n+\t\tNULL);\n \n   result->vtable_index        = vtable_index;\n   result->method              = method;"}]}