{"sha": "b05ecb168f8b5a5009b23d988fba66049f93d4b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA1ZWNiMTY4ZjhiNWE1MDA5YjIzZDk4OGZiYTY2MDQ5ZjkzZDRiMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-08-05T16:20:43Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-08-05T16:20:43Z"}, "message": "Fix computation of number of iterations with unrolling\n\nFrom-SVN: r44644", "tree": {"sha": "9e444738631291cbf93ee94188a9050d2c51ebb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e444738631291cbf93ee94188a9050d2c51ebb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b05ecb168f8b5a5009b23d988fba66049f93d4b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b05ecb168f8b5a5009b23d988fba66049f93d4b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b05ecb168f8b5a5009b23d988fba66049f93d4b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b05ecb168f8b5a5009b23d988fba66049f93d4b2/comments", "author": null, "committer": null, "parents": [{"sha": "f799ab4537f1197030ed985d7adde8f53748298f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f799ab4537f1197030ed985d7adde8f53748298f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f799ab4537f1197030ed985d7adde8f53748298f"}], "stats": {"total": 84, "additions": 40, "deletions": 44}, "files": [{"sha": "892b9a9a8819e34f216a2d4315b3c47420e6f3a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05ecb168f8b5a5009b23d988fba66049f93d4b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05ecb168f8b5a5009b23d988fba66049f93d4b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b05ecb168f8b5a5009b23d988fba66049f93d4b2", "patch": "@@ -1,3 +1,8 @@\n+2001-08-05  Bernd Schmidt  <bernds@redhat.com>\n+\n+        * doloop.c (doloop_modify_runtime): Properly compute number of\n+\titerations if loop was unrolled.\n+\n 2001-08-04  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* config/sh/sh.c (sh_asm_named_section): Fix typo in align"}, {"sha": "1cd619762a61344e13b22d7960be2eabf9b67bb9", "filename": "gcc/doloop.c", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05ecb168f8b5a5009b23d988fba66049f93d4b2/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05ecb168f8b5a5009b23d988fba66049f93d4b2/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=b05ecb168f8b5a5009b23d988fba66049f93d4b2", "patch": "@@ -567,17 +567,22 @@ doloop_modify_runtime (loop, iterations_max,\n \t\t|| comparison_code == NE);\n \n   /* The number of iterations (prior to any loop unrolling) is given by:\n-     (abs (final - initial) + abs_inc - 1) / abs_inc.\n+\n+       n = (abs (final - initial) + abs_inc - 1) / abs_inc.\n \n      However, it is possible for the summation to overflow, and a\n      safer method is:\n \n-     abs (final - initial) / abs_inc + (abs (final - initial) % abs_inc) != 0\n+       n = abs (final - initial) / abs_inc;\n+       n += (abs (final - initial) % abs_inc) != 0;\n \n      If the loop has been unrolled, then the loop body has been\n-     preconditioned to iterate a multiple of unroll_number times.\n-     The number of iterations of the loop body is simply:\n-     abs (final - initial) / (abs_inc * unroll_number).\n+     preconditioned to iterate a multiple of unroll_number times.  If\n+     abs_inc is != 1, the full calculation is\n+\n+       t1 = abs_inc * unroll_number;\n+       n = abs (final - initial) / t1;\n+       n += (abs (final - initial) % t1) > t1 - abs_inc;\n \n      The division and modulo operations can be avoided by requiring\n      that the increment is a power of 2 (precondition_loop_p enforces\n@@ -591,34 +596,38 @@ doloop_modify_runtime (loop, iterations_max,\n \t\t       copy_rtx (neg_inc ? final_value : initial_value),\n \t\t       NULL_RTX, unsigned_p, OPTAB_LIB_WIDEN);\n \n-  if (loop_info->unroll_number == 1)\n+  if (abs_inc * loop_info->unroll_number != 1)\n     {\n+      int shift_count;\n+      rtx extra;\n+      rtx label;\n+      unsigned HOST_WIDE_INT limit;\n+\n+      shift_count = exact_log2 (abs_inc * loop_info->unroll_number);\n+      if (shift_count < 0)\n+\tabort ();\n+\n+      /* abs (final - initial) / (abs_inc * unroll_number)  */\n+      iterations = expand_binop (GET_MODE (diff), lshr_optab,\n+\t\t\t\t diff, GEN_INT (shift_count),\n+\t\t\t\t NULL_RTX, 1,\n+\t\t\t\t OPTAB_LIB_WIDEN);\n+\n       if (abs_inc != 1)\n \t{\n-\t  int shift_count;\n-\t  rtx extra;\n-\t  rtx label;\n-\n-\t  shift_count = exact_log2 (abs_inc);\n-\t  if (shift_count < 0)\n-\t    abort ();\n-\n-\t  /* abs (final - initial) / abs_inc  */\n-\t  iterations = expand_binop (GET_MODE (diff), lshr_optab,\n-\t\t\t\t     diff, GEN_INT (shift_count),\n-\t\t\t\t     NULL_RTX, 1,\n-\t\t\t\t     OPTAB_LIB_WIDEN);\n-\n-\t  /* abs (final - initial) % abs_inc  */\n+\t  /* abs (final - initial) % (abs_inc * unroll_number)  */\n \t  extra = expand_binop (GET_MODE (iterations), and_optab,\n-\t\t\t\tdiff, GEN_INT (abs_inc - 1),\n+\t\t\t\tdiff, GEN_INT (abs_inc * loop_info->unroll_number - 1),\n \t\t\t\tNULL_RTX, 1,\n \t\t\t\tOPTAB_LIB_WIDEN);\n \n-\t  /* If (abs (final - initial) % abs_inc == 0) jump past\n-\t     following increment instruction.  */\n+\t  /* If (abs (final - initial) % (abs_inc * unroll_number)\n+\t       <= abs_inc * (unroll - 1)),\n+\t     jump past following increment instruction.  */\n \t  label = gen_label_rtx();\n-\t  emit_cmp_and_jump_insns (extra, const0_rtx, EQ, NULL_RTX,\n+\t  limit = abs_inc * (loop_info->unroll_number - 1);\n+\t  emit_cmp_and_jump_insns (extra, GEN_INT (limit),\n+\t\t\t\t   limit == 0 ? EQ : LEU, NULL_RTX,\n \t\t\t\t   GET_MODE (extra), 0, 0, label);\n \t  JUMP_LABEL (get_last_insn ()) = label;\n \t  LABEL_NUSES (label)++;\n@@ -631,27 +640,9 @@ doloop_modify_runtime (loop, iterations_max,\n \n \t  emit_label (label);\n \t}\n-      else\n-\titerations = diff;\n     }\n   else\n-    {\n-      int shift_count;\n-\n-      /* precondition_loop_p has preconditioned the loop so that the\n-\t iteration count of the loop body is always a power of 2.\n-\t Since we won't get an overflow calculating the loop count,\n-\t the code we emit is simpler.  */\n-      shift_count = exact_log2 (loop_info->unroll_number * abs_inc);\n-      if (shift_count < 0)\n-\tabort ();\n-\n-      iterations = expand_binop (GET_MODE (diff), lshr_optab,\n-\t\t\t\t diff, GEN_INT (shift_count),\n-\t\t\t\t NULL_RTX, 1,\n-\t\t\t\t OPTAB_LIB_WIDEN);\n-    }\n-\n+    iterations = diff;\n \n   /* If there is a NOTE_INSN_LOOP_VTOP, we have a `for' or `while'\n      style loop, with a loop exit test at the start.  Thus, we can"}]}