{"sha": "6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM0NjZjN2M2ZjRiNThjN2VlMmI0NWJmNDQ4ZWMyMGJiNzE1ZjRiYw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2016-12-15T15:47:58Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2016-12-15T15:47:58Z"}, "message": "[arm] Remove insn_flags.\n\nThis patch finishes the job of removing insn_flags and moves the logic\nover to using the new data structures.  I've added a new boolean\nvariable to detect when we have ARMv7ve-like capabilities and thus\nhave 64-bit atomic operations since that would be a complex query and\nexpensive to do in full.  It might be better to add a specific bit to\nthe ISA data structures to indicate this capability directly.\n\n\t* arm-protos.h (insn_flags): Delete declaration.\n\t(arm_arch7ve): Declare.\n\t* arm.c (insn_flags): Delete.\n\t(arm_arch7ve): New variable.\n\t(arm_selected_cpu): Delete.\n\t(arm_option_check_internal): Use new ISA bitmap.\n\t(arm_option_override_internal): Likewise.\n\t(arm_configure_build_target): Declare arm_selected_cpu locally.\n\t(arm_option_override): Use new ISA bitmap.  Initialize arm_arch7ve.\n\tRearrange variable intialization by general function.\n\t* arm.h (TARGET_HAVE_LPAE): Use arm_arch7ve.\n\nFrom-SVN: r243703", "tree": {"sha": "bc3c8dffa30748f3352278e2a38bdd8de936ae2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc3c8dffa30748f3352278e2a38bdd8de936ae2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/comments", "author": null, "committer": null, "parents": [{"sha": "7d0ce9412cf8f961f4e517fef036b2d6bba2dea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0ce9412cf8f961f4e517fef036b2d6bba2dea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d0ce9412cf8f961f4e517fef036b2d6bba2dea6"}], "stats": {"total": 127, "additions": 71, "deletions": 56}, "files": [{"sha": "a40f3640e23f0a95d3da4fb6fd75920e920acebd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc", "patch": "@@ -1,3 +1,17 @@\n+2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm-protos.h (insn_flags): Delete declaration.\n+\t(arm_arch7ve): Declare.\n+\t* arm.c (insn_flags): Delete.\n+\t(arm_arch7ve): New variable.\n+\t(arm_selected_cpu): Delete.\n+\t(arm_option_check_internal): Use new ISA bitmap.\n+\t(arm_option_override_internal): Likewise.\n+\t(arm_configure_build_target): Declare arm_selected_cpu locally.\n+\t(arm_option_override): Use new ISA bitmap.  Initialize arm_arch7ve.\n+\tRearrange variable intialization by general function.\n+\t* arm.h (TARGET_HAVE_LPAE): Use arm_arch7ve.\n+\n 2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm-builtins.c: Include sbitmap.h."}, {"sha": "659959bcec117ff01d1164956d971e93e5f845b4", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc", "patch": "@@ -353,10 +353,6 @@ extern void arm_cpu_cpp_builtins (struct cpp_reader *);\n \n extern bool arm_is_constant_pool_ref (rtx);\n \n-/* The bits in this mask specify which\n-   instructions we are allowed to generate.  */\n-extern arm_feature_set insn_flags;\n-\n /* The bits in this mask specify which instruction scheduling options should\n    be used.  */\n extern unsigned int tune_flags;\n@@ -391,6 +387,9 @@ extern int arm_arch6m;\n /* Nonzero if this chip supports the ARM 7 extensions.  */\n extern int arm_arch7;\n \n+/* Nonzero if this chip supports the ARM 7ve extensions.  */\n+extern int arm_arch7ve;\n+\n /* Nonzero if instructions not present in the 'M' profile can be used.  */\n extern int arm_arch_notm;\n "}, {"sha": "0b827140e54e1529b1d678fb707833d3d4f05067", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc", "patch": "@@ -779,10 +779,6 @@ int arm_fpu_attr;\n rtx thumb_call_via_label[14];\n static int thumb_call_reg_needed;\n \n-/* The bits in this mask specify which\n-   instructions we are allowed to generate.  */\n-arm_feature_set insn_flags = ARM_FSET_EMPTY;\n-\n /* The bits in this mask specify which instruction scheduling options should\n    be used.  */\n unsigned int tune_flags = 0;\n@@ -828,6 +824,9 @@ int arm_arch6m = 0;\n /* Nonzero if this chip supports the ARM 7 extensions.  */\n int arm_arch7 = 0;\n \n+/* Nonzero if this chip supports the ARM 7ve extensions.  */\n+int arm_arch7ve = 0;\n+\n /* Nonzero if instructions not present in the 'M' profile can be used.  */\n int arm_arch_notm = 0;\n \n@@ -2316,11 +2315,6 @@ static const struct processors all_architectures[] =\n   {NULL, TARGET_CPU_arm_none, 0, NULL, BASE_ARCH_0, {isa_nobit}, ARM_FSET_EMPTY, NULL}\n };\n \n-\n-/* These are populated as commandline arguments are processed, or NULL\n-   if not specified.  */\n-static const struct processors *arm_selected_cpu;\n-\n /* The name of the preprocessor macro to define for this architecture.  PROFILE\n    is replaced by the architecture name (eg. 8A) in arm_option_override () and\n    is thus chosen to be big enough to hold the longest architecture name.  */\n@@ -2821,13 +2815,14 @@ arm_option_check_internal (struct gcc_options *opts)\n   const struct arm_fpu_desc *fpu_desc = &all_fpus[opts->x_arm_fpu_index];\n \n   /* iWMMXt and NEON are incompatible.  */\n-    if (TARGET_IWMMXT\n-\t&& ARM_FPU_FSET_HAS (fpu_desc->features, FPU_FL_NEON))\n+  if (TARGET_IWMMXT\n+      && ARM_FPU_FSET_HAS (fpu_desc->features, FPU_FL_NEON))\n     error (\"iWMMXt and NEON are incompatible\");\n \n   /* Make sure that the processor choice does not conflict with any of the\n      other command line choices.  */\n-  if (TARGET_ARM_P (flags) && !ARM_FSET_HAS_CPU1 (insn_flags, FL_NOTM))\n+  if (TARGET_ARM_P (flags)\n+      && !bitmap_bit_p (arm_active_target.isa, isa_bit_notm))\n     error (\"target CPU does not support ARM mode\");\n \n   /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done\n@@ -2949,7 +2944,7 @@ arm_option_override_internal (struct gcc_options *opts,\n {\n   arm_override_options_after_change_1 (opts);\n \n-  if (TARGET_INTERWORK && !ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB))\n+  if (TARGET_INTERWORK && !bitmap_bit_p (arm_active_target.isa, isa_bit_thumb))\n     {\n       /* The default is to enable interworking, so this warning message would\n \t be confusing to users who have just compiled with, eg, -march=armv3.  */\n@@ -2958,7 +2953,7 @@ arm_option_override_internal (struct gcc_options *opts,\n     }\n \n   if (TARGET_THUMB_P (opts->x_target_flags)\n-      && !(ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB)))\n+      && !bitmap_bit_p (arm_active_target.isa, isa_bit_thumb))\n     {\n       warning (0, \"target CPU does not support THUMB instructions\");\n       opts->x_target_flags &= ~MASK_THUMB;\n@@ -3069,8 +3064,7 @@ arm_configure_build_target (struct arm_build_target *target,\n {\n   const struct processors *arm_selected_tune = NULL;\n   const struct processors *arm_selected_arch = NULL;\n-\n-  arm_selected_cpu = NULL;\n+  const struct processors *arm_selected_cpu = NULL;\n \n   bitmap_clear (target->isa);\n   target->core_name = NULL;\n@@ -3284,7 +3278,6 @@ arm_option_override (void)\n #endif\n \n   sprintf (arm_arch_name, \"__ARM_ARCH_%s__\", arm_active_target.arch_pp_name);\n-  insn_flags = arm_selected_cpu->flags;\n   arm_base_arch = arm_active_target.base_arch;\n \n   arm_tune = arm_active_target.tune_core;\n@@ -3298,7 +3291,8 @@ arm_option_override (void)\n   /* BPABI targets use linker tricks to allow interworking on cores\n      without thumb support.  */\n   if (TARGET_INTERWORK\n-      && !(ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB) || TARGET_BPABI))\n+      && !TARGET_BPABI\n+      && !bitmap_bit_p (arm_active_target.isa, isa_bit_thumb))\n     {\n       warning (0, \"target CPU does not support interworking\" );\n       target_flags &= ~MASK_INTERWORK;\n@@ -3319,46 +3313,55 @@ arm_option_override (void)\n   if (TARGET_APCS_REENT)\n     warning (0, \"APCS reentrant code not supported.  Ignored\");\n \n-  /* Initialize boolean versions of the flags, for use in the arm.md file.  */\n-  arm_arch3m = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH3M);\n-  arm_arch4 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH4);\n-  arm_arch4t = arm_arch4 && (ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB));\n-  arm_arch5 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH5);\n-  arm_arch5e = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH5E);\n-  arm_arch6 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6);\n-  arm_arch6k = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6K);\n-  arm_arch6kz = arm_arch6k && ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH6KZ);\n-  arm_arch_notm = ARM_FSET_HAS_CPU1 (insn_flags, FL_NOTM);\n+  /* Initialize boolean versions of the architectural flags, for use\n+     in the arm.md file.  */\n+  arm_arch3m = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv3m);\n+  arm_arch4 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv4);\n+  arm_arch4t = arm_arch4 && bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n+  arm_arch5 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv5);\n+  arm_arch5e = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv5e);\n+  arm_arch6 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv6);\n+  arm_arch6k = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv6k);\n+  arm_arch_notm = bitmap_bit_p (arm_active_target.isa, isa_bit_notm);\n   arm_arch6m = arm_arch6 && !arm_arch_notm;\n-  arm_arch7 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH7);\n-  arm_arch7em = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH7EM);\n-  arm_arch8 = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARCH8);\n-  arm_arch8_1 = ARM_FSET_HAS_CPU2 (insn_flags, FL2_ARCH8_1);\n-  arm_arch8_2 = ARM_FSET_HAS_CPU2 (insn_flags, FL2_ARCH8_2);\n-  arm_arch_thumb1 = ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB);\n-  arm_arch_thumb2 = ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB2);\n-  arm_arch_xscale = ARM_FSET_HAS_CPU1 (insn_flags, FL_XSCALE);\n+  arm_arch7 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv7);\n+  arm_arch7em = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv7em);\n+  arm_arch8 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv8);\n+  arm_arch8_1 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv8_1);\n+  arm_arch8_2 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv8_2);\n+  arm_arch_thumb1 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n+  arm_arch_thumb2 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb2);\n+  arm_arch_xscale = bitmap_bit_p (arm_active_target.isa, isa_bit_xscale);\n+  arm_arch_iwmmxt = bitmap_bit_p (arm_active_target.isa, isa_bit_iwmmxt);\n+  arm_arch_iwmmxt2 = bitmap_bit_p (arm_active_target.isa, isa_bit_iwmmxt2);\n+  arm_arch_thumb_hwdiv = bitmap_bit_p (arm_active_target.isa, isa_bit_tdiv);\n+  arm_arch_arm_hwdiv = bitmap_bit_p (arm_active_target.isa, isa_bit_adiv);\n+  arm_arch_crc = bitmap_bit_p (arm_active_target.isa, isa_bit_crc32);\n+  arm_arch_cmse = bitmap_bit_p (arm_active_target.isa, isa_bit_cmse);\n+  arm_fp16_inst = bitmap_bit_p (arm_active_target.isa, isa_bit_fp16);\n+  arm_arch7ve\n+    = (arm_arch6k && arm_arch7 && arm_arch_thumb_hwdiv && arm_arch_arm_hwdiv);\n+  if (arm_fp16_inst)\n+    {\n+      if (arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n+\terror (\"selected fp16 options are incompatible.\");\n+      arm_fp16_format = ARM_FP16_FORMAT_IEEE;\n+    }\n+\n \n+  /* Set up some tuning parameters.  */\n   arm_ld_sched = (tune_flags & TF_LDSCHED) != 0;\n   arm_tune_strongarm = (tune_flags & TF_STRONG) != 0;\n   arm_tune_wbuf = (tune_flags & TF_WBUF) != 0;\n   arm_tune_xscale = (tune_flags & TF_XSCALE) != 0;\n-  arm_arch_iwmmxt = ARM_FSET_HAS_CPU1 (insn_flags, FL_IWMMXT);\n-  arm_arch_iwmmxt2 = ARM_FSET_HAS_CPU1 (insn_flags, FL_IWMMXT2);\n-  arm_arch_thumb_hwdiv = ARM_FSET_HAS_CPU1 (insn_flags, FL_THUMB_DIV);\n-  arm_arch_arm_hwdiv = ARM_FSET_HAS_CPU1 (insn_flags, FL_ARM_DIV);\n-  arm_arch_no_volatile_ce = ARM_FSET_HAS_CPU1 (insn_flags, FL_NO_VOLATILE_CE);\n   arm_tune_cortex_a9 = (arm_tune == TARGET_CPU_cortexa9) != 0;\n-  arm_arch_crc = ARM_FSET_HAS_CPU1 (insn_flags, FL_CRC32);\n-  arm_arch_cmse = ARM_FSET_HAS_CPU2 (insn_flags, FL2_CMSE);\n   arm_m_profile_small_mul = (tune_flags & TF_SMALLMUL) != 0;\n-  arm_fp16_inst = ARM_FSET_HAS_CPU2 (insn_flags, FL2_FP16INST);\n-  if (arm_fp16_inst)\n-    {\n-      if (arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n-\terror (\"selected fp16 options are incompatible.\");\n-      arm_fp16_format = ARM_FP16_FORMAT_IEEE;\n-    }\n+\n+  /* And finally, set up some quirks.  */\n+  arm_arch_no_volatile_ce\n+    = bitmap_bit_p (arm_active_target.isa, isa_quirk_no_volatile_ce);\n+  arm_arch6kz\n+    = arm_arch6k && bitmap_bit_p (arm_active_target.isa, isa_quirk_ARMv6kz);\n \n   /* V5 code we generate is completely interworking capable, so we turn off\n      TARGET_INTERWORK here to avoid many tests later on.  */"}, {"sha": "666131468e49c26b1ce778a9bf9551ed781ceecc", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6c466c7c6f4b58c7ee2b45bf448ec20bb715f4bc", "patch": "@@ -252,8 +252,7 @@ extern tree arm_fp16_type_node;\n \t\t\t\t  || (arm_arch8 && !arm_arch_notm))\n \n /* Nonzero if this chip supports LPAE.  */\n-#define TARGET_HAVE_LPAE\t\t\t\t\t\t\\\n-  (arm_arch7 && ARM_FSET_HAS_CPU1 (insn_flags, FL_FOR_ARCH7VE))\n+#define TARGET_HAVE_LPAE (arm_arch7ve)\n \n /* Nonzero if this chip supports ldrex{bh} and strex{bh}.  */\n #define TARGET_HAVE_LDREXBH ((arm_arch6k && TARGET_ARM)\t\t\\"}]}