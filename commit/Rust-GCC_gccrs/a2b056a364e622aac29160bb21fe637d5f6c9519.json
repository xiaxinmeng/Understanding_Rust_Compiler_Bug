{"sha": "a2b056a364e622aac29160bb21fe637d5f6c9519", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJiMDU2YTM2NGU2MjJhYWMyOTE2MGJiMjFmZTYzN2Q1ZjZjOTUxOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2016-04-21T09:05:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-04-21T09:05:07Z"}, "message": "re PR c++/70018 (Possible issue around IPO and C++ comdats discovered as pure/const)\n\n\n\tPR ipa/70018\n\t* cgraph.c (cgraph_set_nothrow_flag_1): Rename to ...\n\t(set_nothrow_flag_1): ... this; handle interposition correctly;\n\trecurse on aliases and thunks.\n\t(cgraph_node::set_nothrow_flag): New.\n\t* ipa-pure-const.c (ignore_edge_for_nothrow): Ignore calls to\n\tfunctions compiled with non-call exceptions that binds to current\n\tdef.\n\t(propagate_nothrow): Be safe WRT interposition.\n\t* cgraph.h (set_nothrow_flag): Update prototype.\n\n\t* g++.dg/ipa/nothrow-1.C: New testcase.\n\nFrom-SVN: r235318", "tree": {"sha": "dd1fa989c4b9cbacc321b6ccd5f44964b611f58f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd1fa989c4b9cbacc321b6ccd5f44964b611f58f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2b056a364e622aac29160bb21fe637d5f6c9519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b056a364e622aac29160bb21fe637d5f6c9519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b056a364e622aac29160bb21fe637d5f6c9519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b056a364e622aac29160bb21fe637d5f6c9519/comments", "author": null, "committer": null, "parents": [{"sha": "9b7924dd177330167865a83f5696a9ae34554972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b7924dd177330167865a83f5696a9ae34554972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b7924dd177330167865a83f5696a9ae34554972"}], "stats": {"total": 129, "additions": 110, "deletions": 19}, "files": [{"sha": "d58b38f04497c1136dce2e957ddf34a4aa005e44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2b056a364e622aac29160bb21fe637d5f6c9519", "patch": "@@ -1,3 +1,16 @@\n+2016-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR ipa/70018\n+\t* cgraph.c (cgraph_set_nothrow_flag_1): Rename to ...\n+\t(set_nothrow_flag_1): ... this; handle interposition correctly;\n+\trecurse on aliases and thunks.\n+\t(cgraph_node::set_nothrow_flag): New.\n+\t* ipa-pure-const.c (ignore_edge_for_nothrow): Ignore calls to\n+\tfunctions compiled with non-call exceptions that binds to current\n+\tdef.\n+\t(propagate_nothrow): Be safe WRT interposition.\n+\t* cgraph.h (set_nothrow_flag): Update prototype.\n+\n 2016-04-18  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-loop-unswitch.c (tree_unswitch_single_loop): Use also"}, {"sha": "d93a93988f15d2c5db06757ce86571c4a11c041a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=a2b056a364e622aac29160bb21fe637d5f6c9519", "patch": "@@ -2358,27 +2358,65 @@ cgraph_node::make_local (void)\n \n /* Worker to set nothrow flag.  */\n \n-static bool\n-cgraph_set_nothrow_flag_1 (cgraph_node *node, void *data)\n+static void\n+set_nothrow_flag_1 (cgraph_node *node, bool nothrow, bool non_call,\n+\t\t    bool *changed)\n {\n   cgraph_edge *e;\n \n-  TREE_NOTHROW (node->decl) = data != NULL;\n-\n-  if (data != NULL)\n-    for (e = node->callers; e; e = e->next_caller)\n-      e->can_throw_external = false;\n-  return false;\n+  if (nothrow && !TREE_NOTHROW (node->decl))\n+    {\n+      /* With non-call exceptions we can't say for sure if other function body\n+\t was not possibly optimized to stil throw.  */\n+      if (!non_call || node->binds_to_current_def_p ())\n+\t{\n+\t  TREE_NOTHROW (node->decl) = true;\n+\t  *changed = true;\n+\t  for (e = node->callers; e; e = e->next_caller)\n+\t    e->can_throw_external = false;\n+\t}\n+    }\n+  else if (!nothrow && TREE_NOTHROW (node->decl))\n+    {\n+      TREE_NOTHROW (node->decl) = false;\n+      *changed = true;\n+    }\n+  ipa_ref *ref;\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      if (!nothrow || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\tset_nothrow_flag_1 (alias, nothrow, non_call, changed);\n+    }\n+  for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n+    if (e->caller->thunk.thunk_p\n+\t&& (!nothrow || e->caller->get_availability () > AVAIL_INTERPOSABLE))\n+      set_nothrow_flag_1 (e->caller, nothrow, non_call, changed);\n }\n \n /* Set TREE_NOTHROW on NODE's decl and on aliases of NODE\n    if any to NOTHROW.  */\n \n-void\n+bool\n cgraph_node::set_nothrow_flag (bool nothrow)\n {\n-  call_for_symbol_thunks_and_aliases (cgraph_set_nothrow_flag_1,\n-\t\t\t\t      (void *)(size_t)nothrow, nothrow == true);\n+  bool changed = false;\n+  bool non_call = opt_for_fn (decl, flag_non_call_exceptions);\n+\n+  if (!nothrow || get_availability () > AVAIL_INTERPOSABLE)\n+    set_nothrow_flag_1 (this, nothrow, non_call, &changed);\n+  else\n+    {\n+      ipa_ref *ref;\n+\n+      FOR_EACH_ALIAS (this, ref)\n+\t{\n+\t  cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+\t  if (!nothrow || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\t    set_nothrow_flag_1 (alias, nothrow, non_call, &changed);\n+\t}\n+    }\n+  return changed;\n }\n \n /* Worker to set_const_flag.  */\n@@ -2517,8 +2555,7 @@ cgraph_node::set_const_flag (bool set_const, bool looping)\n \n /* Info used by set_pure_flag_1.  */\n \n-struct\n-set_pure_flag_info\n+struct set_pure_flag_info\n {\n   bool pure;\n   bool looping;"}, {"sha": "5ce032e1e5745ed00c2dccf621673fe8b589c938", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=a2b056a364e622aac29160bb21fe637d5f6c9519", "patch": "@@ -1111,7 +1111,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n \n   /* Set TREE_NOTHROW on cgraph_node's decl and on aliases of the node\n      if any to NOTHROW.  */\n-  void set_nothrow_flag (bool nothrow);\n+  bool set_nothrow_flag (bool nothrow);\n \n   /* If SET_CONST is true, mark function, aliases and thunks to be ECF_CONST.\n     If SET_CONST if false, clear the flag."}, {"sha": "7647a58fb26ede457aa54b4bf5a9396da711df3f", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=a2b056a364e622aac29160bb21fe637d5f6c9519", "patch": "@@ -1163,7 +1163,10 @@ ignore_edge_for_nothrow (struct cgraph_edge *e)\n   enum availability avail;\n   cgraph_node *n = e->callee->function_or_virtual_thunk_symbol (&avail,\n \t\t\t\t\t\t\t        e->caller);\n-  return (avail <= AVAIL_INTERPOSABLE || TREE_NOTHROW (n->decl));\n+  if (avail <= AVAIL_INTERPOSABLE || TREE_NOTHROW (n->decl))\n+    return true;\n+  return opt_for_fn (e->callee->decl, flag_non_call_exceptions)\n+\t && !e->callee->binds_to_current_def_p (e->caller);\n }\n \n /* Return true if NODE is self recursive function.\n@@ -1589,14 +1592,20 @@ propagate_nothrow (void)\n \t\t    continue;\n \n \t\t  struct cgraph_node *y = e->callee->\n-\t\t\t\t    function_or_virtual_thunk_symbol (&avail,\n-\t\t\t\t\t\t\t\t      e->caller);\n+\t\t\t\t   function_or_virtual_thunk_symbol (&avail,\n+\t\t\t\t\t\t\t\t     e->caller);\n \n \t\t  /* We can use info about the callee only if we know it can\n-\t\t     not be interposed.  */\n+\t\t     not be interposed.\n+\t\t     When callee is compiled with non-call exceptions we also\n+\t\t     must check that the declaration is bound to current\n+\t\t     body as other semantically equivalent body may still\n+\t\t     throw.  */\n \t\t  if (avail <= AVAIL_INTERPOSABLE\n \t\t      || (!TREE_NOTHROW (y->decl)\n-\t\t\t  && get_function_state (y)->can_throw))\n+\t\t\t  && (get_function_state (y)->can_throw\n+\t\t\t      || (opt_for_fn (y->decl, flag_non_call_exceptions)\n+\t\t\t\t  && !e->callee->binds_to_current_def_p (w)))))\n \t\t    can_throw = true;\n \t\t}\n \t      for (ie = w->indirect_calls; ie && !can_throw;"}, {"sha": "eb47876726e4ebd407c3946408c455e2b2e8f1dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a2b056a364e622aac29160bb21fe637d5f6c9519", "patch": "@@ -1,3 +1,8 @@\n+2016-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR ipa/70018\n+\t* g++.dg/ipa/nothrow-1.C: New testcase.\n+\n 2016-04-20  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/55635"}, {"sha": "df2fbae2acc5aa0e8e56dc0a37636ae46eaf2988", "filename": "gcc/testsuite/g++.dg/ipa/nothrow-1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fnothrow-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b056a364e622aac29160bb21fe637d5f6c9519/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fnothrow-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fnothrow-1.C?ref=a2b056a364e622aac29160bb21fe637d5f6c9519", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fnon-call-exceptions -fdump-tree-optimized\"  } */\n+int *ptr;\n+static int barvar;\n+\n+/* We can not detect A to be const because it may be interposed by unoptimized\n+   body.  */\n+inline\n+__attribute__ ((noinline))\n+int a(void)\n+{\n+  return *ptr == *ptr;\n+}\n+main()\n+{\n+  int aa;\n+  ptr = &barvar;\n+  try {\n+    aa=!a();\n+  } catch  (...)\n+  {\n+    return 1;\n+  }\n+  ptr = 0;\n+  return aa;\n+}\n+/* { dg-final { scan-tree-dump \"__cxa_begin_catch\"  \"optimized\"  } } */"}]}