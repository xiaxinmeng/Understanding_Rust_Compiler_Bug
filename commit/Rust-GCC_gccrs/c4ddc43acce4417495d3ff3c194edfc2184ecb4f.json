{"sha": "c4ddc43acce4417495d3ff3c194edfc2184ecb4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRkZGM0M2FjY2U0NDE3NDk1ZDNmZjNjMTk0ZWRmYzIxODRlY2I0Zg==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2016-07-25T13:36:33Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2016-07-25T13:36:33Z"}, "message": "[AArch64][2/3] Optimize aarch64_add_constant to generate better addition sequences\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_add_constant): Optimize instruction\n\tsequences.\n\nFrom-SVN: r238713", "tree": {"sha": "32a41ed4f1eba7527bae173b7e77a2962b3b2d62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32a41ed4f1eba7527bae173b7e77a2962b3b2d62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4ddc43acce4417495d3ff3c194edfc2184ecb4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ddc43acce4417495d3ff3c194edfc2184ecb4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ddc43acce4417495d3ff3c194edfc2184ecb4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ddc43acce4417495d3ff3c194edfc2184ecb4f/comments", "author": null, "committer": null, "parents": [{"sha": "f43657b49fa8836b0bc621e61ff2c113c7dc2a0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43657b49fa8836b0bc621e61ff2c113c7dc2a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f43657b49fa8836b0bc621e61ff2c113c7dc2a0e"}], "stats": {"total": 84, "additions": 46, "deletions": 38}, "files": [{"sha": "a2550d118b164210e752b35aecec943a03ea7585", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ddc43acce4417495d3ff3c194edfc2184ecb4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ddc43acce4417495d3ff3c194edfc2184ecb4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4ddc43acce4417495d3ff3c194edfc2184ecb4f", "patch": "@@ -1,3 +1,8 @@\n+2016-07-25  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_add_constant): Optimize instruction\n+\tsequences.\n+\n 2016-07-25  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_add_constant): New parameter \"mode\"."}, {"sha": "6cecb8fc47fe1c621e7c6d40c8302ad138afb514", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ddc43acce4417495d3ff3c194edfc2184ecb4f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ddc43acce4417495d3ff3c194edfc2184ecb4f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=c4ddc43acce4417495d3ff3c194edfc2184ecb4f", "patch": "@@ -1940,6 +1940,47 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n   aarch64_internal_mov_immediate (dest, imm, true, GET_MODE (dest));\n }\n \n+/* Add DELTA to REGNUM in mode MODE.  SCRATCHREG can be used to held\n+   intermediate value if necessary.  */\n+\n+static void\n+aarch64_add_constant (machine_mode mode, int regnum, int scratchreg,\n+\t\t      HOST_WIDE_INT delta)\n+{\n+  HOST_WIDE_INT mdelta = abs_hwi (delta);\n+  rtx this_rtx = gen_rtx_REG (mode, regnum);\n+\n+  /* Do nothing if mdelta is zero.  */\n+  if (!mdelta)\n+    return;\n+\n+  /* We only need single instruction if the offset fit into add/sub.  */\n+  if (aarch64_uimm12_shift (mdelta))\n+    {\n+      emit_insn (gen_add2_insn (this_rtx, GEN_INT (delta)));\n+      return;\n+    }\n+\n+  /* We need two add/sub instructions, each one performing part of the\n+     calculation.  Don't do this if the addend can be loaded into register with\n+     a single instruction, in that case we prefer a move to a scratch register\n+     following by an addition.  */\n+  if (mdelta < 0x1000000 && !aarch64_move_imm (delta, mode))\n+    {\n+      HOST_WIDE_INT low_off = mdelta & 0xfff;\n+\n+      low_off = delta < 0 ? -low_off : low_off;\n+      emit_insn (gen_add2_insn (this_rtx, GEN_INT (low_off)));\n+      emit_insn (gen_add2_insn (this_rtx, GEN_INT (delta - low_off)));\n+      return;\n+    }\n+\n+  /* Otherwise use generic function to handle all other situations.  */\n+  rtx scratch_rtx = gen_rtx_REG (mode, scratchreg);\n+  aarch64_internal_mov_immediate (scratch_rtx, GEN_INT (delta), true, mode);\n+  emit_insn (gen_add2_insn (this_rtx, scratch_rtx));\n+}\n+\n static bool\n aarch64_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n \t\t\t\t tree exp ATTRIBUTE_UNUSED)\n@@ -3412,44 +3453,6 @@ aarch64_final_eh_return_addr (void)\n \t\t\t\t       - 2 * UNITS_PER_WORD));\n }\n \n-static void\n-aarch64_add_constant (machine_mode mode, int regnum, int scratchreg,\n-\t\t      HOST_WIDE_INT delta)\n-{\n-  HOST_WIDE_INT mdelta = delta;\n-  rtx this_rtx = gen_rtx_REG (mode, regnum);\n-  rtx scratch_rtx = gen_rtx_REG (mode, scratchreg);\n-\n-  if (mdelta < 0)\n-    mdelta = -mdelta;\n-\n-  if (mdelta >= 4096 * 4096)\n-    {\n-      aarch64_internal_mov_immediate (scratch_rtx, GEN_INT (delta), true, mode);\n-      emit_insn (gen_add3_insn (this_rtx, this_rtx, scratch_rtx));\n-    }\n-  else if (mdelta > 0)\n-    {\n-      if (mdelta >= 4096)\n-\t{\n-\t  emit_insn (gen_rtx_SET (scratch_rtx, GEN_INT (mdelta / 4096)));\n-\t  rtx shift = gen_rtx_ASHIFT (mode, scratch_rtx, GEN_INT (12));\n-\t  if (delta < 0)\n-\t    emit_insn (gen_rtx_SET (this_rtx,\n-\t\t\t\t    gen_rtx_MINUS (mode, this_rtx, shift)));\n-\t  else\n-\t    emit_insn (gen_rtx_SET (this_rtx,\n-\t\t\t\t    gen_rtx_PLUS (mode, this_rtx, shift)));\n-\t}\n-      if (mdelta % 4096 != 0)\n-\t{\n-\t  scratch_rtx = GEN_INT ((delta < 0 ? -1 : 1) * (mdelta % 4096));\n-\t  emit_insn (gen_rtx_SET (this_rtx,\n-\t\t\t\t  gen_rtx_PLUS (mode, this_rtx, scratch_rtx)));\n-\t}\n-    }\n-}\n-\n /* Output code to add DELTA to the first argument, and then jump\n    to FUNCTION.  Used for C++ multiple inheritance.  */\n static void"}]}