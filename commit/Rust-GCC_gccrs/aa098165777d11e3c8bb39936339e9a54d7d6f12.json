{"sha": "aa098165777d11e3c8bb39936339e9a54d7d6f12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEwOTgxNjU3NzdkMTFlM2M4YmIzOTkzNjMzOWU5YTU0ZDdkNmYxMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-24T09:24:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-24T09:24:50Z"}, "message": "re PR tree-optimization/55334 (mgrid regression (ipa-cp disables vectorization))\n\n2014-11-24  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/55334\n\t* function.h (struct function): Add last_clique member.\n\t* tree-inline.c (remap_dependence_clique): New function.\n\t(remap_gimple_op_r): Remap dependence cliques in MEM_REFs.\n\t(copy_tree_body_r): Likewise.\n\t(copy_cfg_body): Free dependence map.\n\t(copy_gimple_seq_and_replace_locals): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Dump\n\tdependence info.\n\t* tree-ssa-alias.c (refs_may_alias_p_1): Use dependence info\n\tto answer alias query.\n\t* tree-ssa-structalias.c: Include tree-phinodes.h, ssa-iterators.h,\n\ttree-pretty-print.h and gimple-walk.h.\n\t(struct variable_info): Add is_restrict_var flag and ruid\n\tmember.\n\t(new_var_info): Initialize is_restrict_var.\n\t(make_constraint_from_restrict): Likewise.\n\t(create_variable_info_for): Exclude restricts from global vars\n\tfrom new handling.\n\t(intra_create_variable_infos): But not those from parameters.\n\t(visit_loadstore): New function.\n\t(maybe_set_dependence_info): Likewise.\n\t(compute_dependence_clique): Likewise.\n\t(compute_may_aliases): Call compute_dependence_clique.\n\t* tree-data-ref.c (dr_analyze_indices): Copy dependence info\n\tto fake MEM_REF.\n\t(dr_may_alias_p): Use recorded dependence info to answer\n\talias query.\n\t* tree-core.h (struct tree_base): Add clique, base struct in\n\tunion.\n\t* tree.h (MR_DEPENDENCE_CLIQUE): New macro.\n\t(MR_DEPENDENCE_BASE): Likewise.\n\t* tree-inline.h (dependence_hasher): New hash-map kind.\n\t(struct copy_body_data): Add dependence_map pointer.\n\t* gimple-fold.c (maybe_canonicalize_mem_ref_addr): Avoid\n\tthrowing away dependence info.\n\t* tree-streamer-in.c (unpack_value_fields): Stream dependence info.\n\t* tree-streamer-out.c (streamer_pack_tree_bitfields): Likewise.\n\n\t* gcc.dg/tree-ssa/restrict-5.c: New testcase.\n\nFrom-SVN: r218005", "tree": {"sha": "31f6330c852a890412fc66bf70d8627b50fd4733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31f6330c852a890412fc66bf70d8627b50fd4733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa098165777d11e3c8bb39936339e9a54d7d6f12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa098165777d11e3c8bb39936339e9a54d7d6f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa098165777d11e3c8bb39936339e9a54d7d6f12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa098165777d11e3c8bb39936339e9a54d7d6f12/comments", "author": null, "committer": null, "parents": [{"sha": "f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3dccf50915b31fcc3e03e82fd09ccef243b30e3"}], "stats": {"total": 203, "additions": 202, "deletions": 1}, "files": [{"sha": "69cf60b08951e3021dd4a2fc7bf170f411fcc99d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 202, "deletions": 1, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa098165777d11e3c8bb39936339e9a54d7d6f12/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa098165777d11e3c8bb39936339e9a54d7d6f12/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=aa098165777d11e3c8bb39936339e9a54d7d6f12", "patch": "@@ -64,6 +64,10 @@\n #include \"splay-tree.h\"\n #include \"params.h\"\n #include \"alias.h\"\n+#include \"tree-phinodes.h\"\n+#include \"ssa-iterators.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple-walk.h\"\n \n /* The idea behind this analyzer is to generate set constraints from the\n    program, then solve the resulting constraints in order to generate the\n@@ -284,12 +288,19 @@ struct variable_info\n   /* True if this field has only restrict qualified pointers.  */\n   unsigned int only_restrict_pointers : 1;\n \n+  /* True if this represents a heap var created for a restrict qualified\n+     pointer.  */\n+  unsigned int is_restrict_var : 1;\n+\n   /* True if this represents a global variable.  */\n   unsigned int is_global_var : 1;\n \n   /* True if this represents a IPA function info.  */\n   unsigned int is_fn_info : 1;\n \n+  /* ???  Store somewhere better.  */\n+  unsigned short ruid;\n+\n   /* The ID of the variable for the next field in this structure\n      or zero for the last field in this structure.  */\n   unsigned next;\n@@ -381,6 +392,7 @@ new_var_info (tree t, const char *name)\n   ret->is_heap_var = false;\n   ret->may_have_pointers = true;\n   ret->only_restrict_pointers = false;\n+  ret->is_restrict_var = false;\n   ret->is_global_var = (t == NULL_TREE);\n   ret->is_fn_info = false;\n   if (t && DECL_P (t))\n@@ -3785,6 +3797,7 @@ static varinfo_t\n make_constraint_from_restrict (varinfo_t lhs, const char *name)\n {\n   varinfo_t vi = make_heapvar (name);\n+  vi->is_restrict_var = 1;\n   vi->is_global_var = 1;\n   vi->may_have_pointers = 1;\n   make_constraint_from (lhs, vi->id);\n@@ -5749,7 +5762,11 @@ create_variable_info_for (tree decl, const char *name)\n \t   && TYPE_RESTRICT (TREE_TYPE (decl)))\n \t  || vi->only_restrict_pointers)\n \t{\n-\t  make_constraint_from_global_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t  varinfo_t rvi\n+\t    = make_constraint_from_global_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t  /* ???  For now exclude reads from globals as restrict sources\n+\t     if those are not (indirectly) from incoming parameters.  */\n+\t  rvi->is_restrict_var = false;\n \t  continue;\n \t}\n \n@@ -5859,6 +5876,7 @@ intra_create_variable_infos (struct function *fn)\n \t  tree heapvar = build_fake_var_decl (TREE_TYPE (TREE_TYPE (t)));\n \t  DECL_EXTERNAL (heapvar) = 1;\n \t  vi = create_variable_info_for_1 (heapvar, \"PARM_NOALIAS\");\n+\t  vi->is_restrict_var = 1;\n \t  insert_vi_for_tree (heapvar, vi);\n \t  lhsc.var = p->id;\n \t  lhsc.type = SCALAR;\n@@ -6933,6 +6951,186 @@ delete_points_to_sets (void)\n   obstack_free (&final_solutions_obstack, NULL);\n }\n \n+/* Mark \"other\" loads and stores as belonging to CLIQUE and with\n+   base zero.  */\n+\n+static bool\n+visit_loadstore (gimple, tree base, tree ref, void *clique_)\n+{\n+  unsigned short clique = (uintptr_t)clique_;\n+  if (TREE_CODE (base) == MEM_REF\n+      || TREE_CODE (base) == TARGET_MEM_REF)\n+    {\n+      tree ptr = TREE_OPERAND (base, 0);\n+      if (TREE_CODE (ptr) == SSA_NAME)\n+\t{\n+\t  /* ???  We need to make sure 'ptr' doesn't include any of\n+\t     the restrict tags in its points-to set.  */\n+\t  return false;\n+\t}\n+\n+      /* For now let decls through.  */\n+\n+      /* Do not overwrite existing cliques (that includes clique, base\n+         pairs we just set).  */\n+      if (MR_DEPENDENCE_CLIQUE (base) == 0)\n+\t{\n+\t  MR_DEPENDENCE_CLIQUE (base) = clique;\n+\t  MR_DEPENDENCE_BASE (base) = 0;\n+\t}\n+    }\n+\n+  /* For plain decl accesses see whether they are accesses to globals\n+     and rewrite them to MEM_REFs with { clique, 0 }.  */\n+  if (TREE_CODE (base) == VAR_DECL\n+      && is_global_var (base)\n+      /* ???  We can't rewrite a plain decl with the walk_stmt_load_store\n+\t ops callback.  */\n+      && base != ref)\n+    {\n+      tree *basep = &ref;\n+      while (handled_component_p (*basep))\n+\tbasep = &TREE_OPERAND (*basep, 0);\n+      gcc_assert (TREE_CODE (*basep) == VAR_DECL);\n+      tree ptr = build_fold_addr_expr (*basep);\n+      tree zero = build_int_cst (TREE_TYPE (ptr), 0);\n+      *basep = build2 (MEM_REF, TREE_TYPE (*basep), ptr, zero);\n+      MR_DEPENDENCE_CLIQUE (*basep) = clique;\n+      MR_DEPENDENCE_BASE (*basep) = 0;\n+    }\n+\n+  return false;\n+}\n+\n+/* If REF is a MEM_REF then assign a clique, base pair to it, updating\n+   CLIQUE, *RESTRICT_VAR and LAST_RUID.  Return whether dependence info\n+   was assigned to REF.  */\n+\n+static bool\n+maybe_set_dependence_info (tree ref, tree ptr,\n+\t\t\t   unsigned short &clique, varinfo_t restrict_var,\n+\t\t\t   unsigned short &last_ruid)\n+{\n+  while (handled_component_p (ref))\n+    ref = TREE_OPERAND (ref, 0);\n+  if ((TREE_CODE (ref) == MEM_REF\n+       || TREE_CODE (ref) == TARGET_MEM_REF)\n+      && TREE_OPERAND (ref, 0) == ptr)\n+    {\n+      /* Do not overwrite existing cliques.  This avoids overwriting dependence\n+\t info inlined from a function with restrict parameters inlined\n+\t into a function with restrict parameters.  This usually means we\n+\t prefer to be precise in innermost loops.  */\n+      if (MR_DEPENDENCE_CLIQUE (ref) == 0)\n+\t{\n+\t  if (clique == 0)\n+\t    clique = ++cfun->last_clique;\n+\t  if (restrict_var->ruid == 0)\n+\t    restrict_var->ruid = ++last_ruid;\n+\t  MR_DEPENDENCE_CLIQUE (ref) = clique;\n+\t  MR_DEPENDENCE_BASE (ref) = restrict_var->ruid;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Compute the set of independend memory references based on restrict\n+   tags and their conservative propagation to the points-to sets.  */\n+\n+static void\n+compute_dependence_clique (void)\n+{\n+  unsigned short clique = 0;\n+  unsigned short last_ruid = 0;\n+  for (unsigned i = 0; i < num_ssa_names; ++i)\n+    {\n+      tree ptr = ssa_name (i);\n+      if (!ptr || !POINTER_TYPE_P (TREE_TYPE (ptr)))\n+\tcontinue;\n+\n+      /* Avoid all this when ptr is not dereferenced?  */\n+      tree p = ptr;\n+      if (SSA_NAME_IS_DEFAULT_DEF (ptr)\n+\t  && (TREE_CODE (SSA_NAME_VAR (ptr)) == PARM_DECL\n+\t      || TREE_CODE (SSA_NAME_VAR (ptr)) == RESULT_DECL))\n+\tp = SSA_NAME_VAR (ptr);\n+      varinfo_t vi = lookup_vi_for_tree (p);\n+      if (!vi)\n+\tcontinue;\n+      vi = get_varinfo (find (vi->id));\n+      bitmap_iterator bi;\n+      unsigned j;\n+      varinfo_t restrict_var = NULL;\n+      EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, j, bi)\n+\t{\n+\t  varinfo_t oi = get_varinfo (j);\n+\t  if (oi->is_restrict_var)\n+\t    {\n+\t      if (restrict_var)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"found restrict pointed-to \"\n+\t\t\t       \"for \");\n+\t\t      print_generic_expr (dump_file, ptr, 0);\n+\t\t      fprintf (dump_file, \" but not exclusively\\n\");\n+\t\t    }\n+\t\t  restrict_var = NULL;\n+\t\t  break;\n+\t\t}\n+\t      restrict_var = oi;\n+\t    }\n+\t  /* NULL is the only other valid points-to entry.  */\n+\t  else if (oi->id != nothing_id)\n+\t    {\n+\t      restrict_var = NULL;\n+\t      break;\n+\t    }\n+\t}\n+      /* Ok, found that ptr must(!) point to a single(!) restrict\n+\t variable.  */\n+      /* ???  PTA isn't really a proper propagation engine to compute\n+\t this property.\n+\t ???  We could handle merging of two restricts by unifying them.  */\n+      if (restrict_var)\n+\t{\n+\t  /* Now look at possible dereferences of ptr.  */\n+\t  imm_use_iterator ui;\n+\t  gimple use_stmt;\n+\t  FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)\n+\t    {\n+\t      /* ???  Calls and asms.  */\n+\t      if (!gimple_assign_single_p (use_stmt))\n+\t\tcontinue;\n+\t      maybe_set_dependence_info (gimple_assign_lhs (use_stmt), ptr,\n+\t\t\t\t\t clique, restrict_var, last_ruid);\n+\t      maybe_set_dependence_info (gimple_assign_rhs1 (use_stmt), ptr,\n+\t\t\t\t\t clique, restrict_var, last_ruid);\n+\t    }\n+\t}\n+    }\n+\n+  if (clique == 0)\n+    return;\n+\n+  /* Assign the BASE id zero to all accesses not based on a restrict\n+     pointer.  That way they get disabiguated against restrict\n+     accesses but not against each other.  */\n+  /* ???  For restricts derived from globals (thus not incoming\n+     parameters) we can't restrict scoping properly thus the following\n+     is too aggressive there.  For now we have excluded those globals from\n+     getting into the MR_DEPENDENCE machinery.  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple stmt = gsi_stmt (gsi);\n+\twalk_stmt_load_store_ops (stmt, (void *)(uintptr_t)clique,\n+\t\t\t\t  visit_loadstore, visit_loadstore);\n+      }\n+}\n \n /* Compute points-to information for every SSA_NAME pointer in the\n    current function and compute the transitive closure of escaped\n@@ -6964,6 +7162,9 @@ compute_may_aliases (void)\n   if (dump_file)\n     dump_alias_info (dump_file);\n \n+  /* Compute restrict-based memory disambiguations.  */\n+  compute_dependence_clique ();\n+\n   /* Deallocate memory used by aliasing data structures and the internal\n      points-to solution.  */\n   delete_points_to_sets ();"}]}