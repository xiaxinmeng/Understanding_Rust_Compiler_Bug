{"sha": "47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdkM2I5MjBjZTA5YjI3ZmNhN2RjNjUwNDY0MGY2ZmU3MmZiMTZjZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T10:07:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T10:07:05Z"}, "message": "[multiple changes]\n\n2010-06-22  Robert Dewar  <dewar@adacore.com>\n\n\t* lib-writ.ads, errout.adb, einfo.adb, einfo.ads: Minor reformatting.\n\n2010-06-22  Vincent Celier  <celier@adacore.com>\n\n\t* adaint.c (__gnat_locate_regular_file): If a directory in the path is\n\tempty, make it the current working directory.\n\n2010-06-22  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch3.adb (Build_Derived_Record_Type): When deriving a tagged\n\tprivate type with discriminants, make sure the parent type is frozen.\n\n2010-06-22  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference) <Attribute_Bit>: Deal\n\twith packed array references specially.\n\t* exp_ch4.adb (Expand_N_Indexed_Component): Do not convert a reference\n\tto a component of a bit packed array if it is the prefix of 'Bit.\n\t* exp_pakd.ads (Expand_Packed_Bit_Reference): Declare.\n\t* exp_pakd.adb (Expand_Packed_Bit_Reference): New procedure.  Expand a\n\t'Bit reference, where the prefix involves a packed array reference.\n\t(Get_Base_And_Bit_Offset): New helper, extracted from...\n\t(Expand_Packed_Address_Reference): ...here.  Call above procedure to\n\tget the outer object and offset expression.\n\nFrom-SVN: r161160", "tree": {"sha": "817abe2e078de21d449193162217e6853732d04c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/817abe2e078de21d449193162217e6853732d04c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/comments", "author": null, "committer": null, "parents": [{"sha": "5c52bf3ba490639455d1ce816c2b2004bd3c65da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c52bf3ba490639455d1ce816c2b2004bd3c65da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c52bf3ba490639455d1ce816c2b2004bd3c65da"}], "stats": {"total": 479, "additions": 290, "deletions": 189}, "files": [{"sha": "2b2728cfeba11bb21d4f43dafee2a5d78c296281", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -1,3 +1,30 @@\n+2010-06-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* lib-writ.ads, errout.adb, einfo.adb, einfo.ads: Minor reformatting.\n+\n+2010-06-22  Vincent Celier  <celier@adacore.com>\n+\n+\t* adaint.c (__gnat_locate_regular_file): If a directory in the path is\n+\tempty, make it the current working directory.\n+\n+2010-06-22  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Record_Type): When deriving a tagged\n+\tprivate type with discriminants, make sure the parent type is frozen.\n+\n+2010-06-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference) <Attribute_Bit>: Deal\n+\twith packed array references specially.\n+\t* exp_ch4.adb (Expand_N_Indexed_Component): Do not convert a reference\n+\tto a component of a bit packed array if it is the prefix of 'Bit.\n+\t* exp_pakd.ads (Expand_Packed_Bit_Reference): Declare.\n+\t* exp_pakd.adb (Expand_Packed_Bit_Reference): New procedure.  Expand a\n+\t'Bit reference, where the prefix involves a packed array reference.\n+\t(Get_Base_And_Bit_Offset): New helper, extracted from...\n+\t(Expand_Packed_Address_Reference): ...here.  Call above procedure to\n+\tget the outer object and offset expression.\n+\n 2010-06-22  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_attr.adb, lib-writ.ads, bindgen.adb: Minor reformatting."}, {"sha": "9379950105792b2b4ab0fffeeaad2ac27184beb6", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -2788,12 +2788,6 @@ __gnat_locate_regular_file (char *file_name, char *path_val)\n \n     for (;;)\n       {\n-        for (; *path_val == PATH_SEPARATOR; path_val++)\n-          ;\n-\n-      if (*path_val == 0)\n-        return 0;\n-\n       /* Skip the starting quote */\n \n       if (*path_val == '\"')\n@@ -2802,7 +2796,14 @@ __gnat_locate_regular_file (char *file_name, char *path_val)\n       for (ptr = file_path; *path_val && *path_val != PATH_SEPARATOR; )\n \t*ptr++ = *path_val++;\n \n-      ptr--;\n+      /* If directory is empty, it is the current directory*/\n+\n+      if (ptr == file_path)\n+        {\n+         *ptr = '.';\n+        }\n+      else\n+        ptr--;\n \n       /* Skip the ending quote */\n \n@@ -2816,6 +2817,13 @@ __gnat_locate_regular_file (char *file_name, char *path_val)\n \n       if (__gnat_is_regular_file (file_path))\n         return xstrdup (file_path);\n+\n+      if (*path_val == 0)\n+        return 0;\n+\n+      /* Skip path separator */\n+\n+      path_val++;\n       }\n   }\n "}, {"sha": "07144c3446db888eca2161ea4832b28ae9ca8d56", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -5755,9 +5755,7 @@ package body Einfo is\n \n    function Get_Full_View (T : Entity_Id) return Entity_Id is\n    begin\n-      if Ekind (T) = E_Incomplete_Type\n-        and then Present (Full_View (T))\n-      then\n+      if Ekind (T) = E_Incomplete_Type and then Present (Full_View (T)) then\n          return Full_View (T);\n \n       elsif Is_Class_Wide_Type (T)"}, {"sha": "d5f43ae13bb131cba6a442a88b134bf47522dd73", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -6821,9 +6821,9 @@ package Einfo is\n    --  Add an entity to the list of entities declared in the scope V\n \n    function Get_Full_View (T : Entity_Id) return Entity_Id;\n-   --  If T is an incomplete type and the full declaration has been\n-   --  seen, or is the name of a class_wide type whose root is incomplete.\n-   --  return the corresponding full declaration.\n+   --  If T is an incomplete type and the full declaration has been seen, or\n+   --  is the name of a class_wide type whose root is incomplete, return the\n+   --  corresponding full declaration, else return T itself.\n \n    function Is_Entity_Name (N : Node_Id) return Boolean;\n    --  Test if the node N is the name of an entity (i.e. is an identifier,"}, {"sha": "d71ebaddfd093550f8bd2ca87c633519cb4fd4c3", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 88, "deletions": 93, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -176,25 +176,24 @@ package body Errout is\n    --  If the message should be generated (the normal case) False is returned.\n \n    procedure Unwind_Internal_Type (Ent : in out Entity_Id);\n-   --  This procedure is given an entity id for an internal type, i.e.\n-   --  a type with an internal name. It unwinds the type to try to get\n-   --  to something reasonably printable, generating prefixes like\n-   --  \"subtype of\", \"access to\", etc along the way in the buffer. The\n-   --  value in Ent on return is the final name to be printed. Hopefully\n-   --  this is not an internal name, but in some internal name cases, it\n-   --  is an internal name, and has to be printed anyway (although in this\n-   --  case the message has been killed if possible). The global variable\n-   --  Class_Flag is set to True if the resulting entity should have\n-   --  'Class appended to its name (see Add_Class procedure), and is\n-   --  otherwise unchanged.\n+   --  This procedure is given an entity id for an internal type, i.e. a type\n+   --  with an internal name. It unwinds the type to try to get to something\n+   --  reasonably printable, generating prefixes like \"subtype of\", \"access\n+   --  to\", etc along the way in the buffer. The value in Ent on return is the\n+   --  final name to be printed. Hopefully this is not an internal name, but in\n+   --  some internal name cases, it is an internal name, and has to be printed\n+   --  anyway (although in this case the message has been killed if possible).\n+   --  The global variable Class_Flag is set to True if the resulting entity\n+   --  should have 'Class appended to its name (see Add_Class procedure), and\n+   --  is otherwise unchanged.\n \n    procedure VMS_Convert;\n-   --  This procedure has no effect if called when the host is not OpenVMS.\n-   --  If the host is indeed OpenVMS, then the error message stored in\n-   --  Msg_Buffer is scanned for appearances of switch names which need\n-   --  converting to corresponding VMS qualifier names. See Gnames/Vnames\n-   --  table in Errout spec for precise definition of the conversion that\n-   --  is performed by this routine in OpenVMS mode.\n+   --  This procedure has no effect if called when the host is not OpenVMS. If\n+   --  the host is indeed OpenVMS, then the error message stored in Msg_Buffer\n+   --  is scanned for appearances of switch names which need converting to\n+   --  corresponding VMS qualifier names. See Gnames/Vnames table in Errout\n+   --  spec for precise definition of the conversion that is performed by this\n+   --  routine in OpenVMS mode.\n \n    -----------------------\n    -- Change_Error_Text --\n@@ -242,10 +241,10 @@ package body Errout is\n    ---------------\n \n    --  Error_Msg posts a flag at the given location, except that if the\n-   --  Flag_Location points within a generic template and corresponds\n-   --  to an instantiation of this generic template, then the actual\n-   --  message will be posted on the generic instantiation, along with\n-   --  additional messages referencing the generic declaration.\n+   --  Flag_Location points within a generic template and corresponds to an\n+   --  instantiation of this generic template, then the actual message will be\n+   --  posted on the generic instantiation, along with additional messages\n+   --  referencing the generic declaration.\n \n    procedure Error_Msg (Msg : String; Flag_Location : Source_Ptr) is\n       Sindex : Source_File_Index;\n@@ -256,8 +255,8 @@ package body Errout is\n       --  template in instantiation case, otherwise unchanged).\n \n    begin\n-      --  It is a fatal error to issue an error message when scanning from\n-      --  the internal source buffer (see Sinput for further documentation)\n+      --  It is a fatal error to issue an error message when scanning from the\n+      --  internal source buffer (see Sinput for further documentation)\n \n       pragma Assert (Sinput.Source /= Internal_Source_Ptr);\n \n@@ -267,8 +266,8 @@ package body Errout is\n          return;\n       end if;\n \n-      --  If we already have messages, and we are trying to place a message\n-      --  at No_Location or in package Standard, then just ignore the attempt\n+      --  If we already have messages, and we are trying to place a message at\n+      --  No_Location or in package Standard, then just ignore the attempt\n       --  since we assume that what is happening is some cascaded junk. Note\n       --  that this is safe in the sense that proceeding will surely bomb.\n \n@@ -284,24 +283,23 @@ package body Errout is\n       Test_Style_Warning_Serious_Msg (Msg);\n       Orig_Loc := Original_Location (Flag_Location);\n \n-      --  If the current location is in an instantiation, the issue arises\n-      --  of whether to post the message on the template or the instantiation.\n+      --  If the current location is in an instantiation, the issue arises of\n+      --  whether to post the message on the template or the instantiation.\n \n-      --  The way we decide is to see if we have posted the same message\n-      --  on the template when we compiled the template (the template is\n-      --  always compiled before any instantiations). For this purpose,\n-      --  we use a separate table of messages. The reason we do this is\n-      --  twofold:\n+      --  The way we decide is to see if we have posted the same message on\n+      --  the template when we compiled the template (the template is always\n+      --  compiled before any instantiations). For this purpose, we use a\n+      --  separate table of messages. The reason we do this is twofold:\n \n       --     First, the messages can get changed by various processing\n       --     including the insertion of tokens etc, making it hard to\n       --     do the comparison.\n \n-      --     Second, we will suppress a warning on a template if it is\n-      --     not in the current extended source unit. That's reasonable\n-      --     and means we don't want the warning on the instantiation\n-      --     here either, but it does mean that the main error table\n-      --     would not in any case include the message.\n+      --     Second, we will suppress a warning on a template if it is not in\n+      --     the current extended source unit. That's reasonable and means we\n+      --     don't want the warning on the instantiation here either, but it\n+      --     does mean that the main error table would not in any case include\n+      --     the message.\n \n       if Flag_Location = Orig_Loc then\n          Non_Instance_Msgs.Append ((new String'(Msg), Flag_Location));\n@@ -310,8 +308,8 @@ package body Errout is\n       --  Here we have an instance message\n \n       else\n-         --  Delete if debug flag off, and this message duplicates a\n-         --  message already posted on the corresponding template\n+         --  Delete if debug flag off, and this message duplicates a message\n+         --  already posted on the corresponding template\n \n          if not Debug_Flag_GG then\n             for J in Non_Instance_Msgs.First .. Non_Instance_Msgs.Last loop\n@@ -373,9 +371,9 @@ package body Errout is\n       --  instantiation error message can be repeated, pointing to each\n       --  of the relevant instantiations.\n \n-      --  Note: the instantiation mechanism is also shared for inlining\n-      --  of subprogram bodies when front end inlining is done. In this\n-      --  case the messages have the form:\n+      --  Note: the instantiation mechanism is also shared for inlining of\n+      --  subprogram bodies when front end inlining is done. In this case the\n+      --  messages have the form:\n \n       --     in inlined body at ...\n       --     original error message\n@@ -385,9 +383,8 @@ package body Errout is\n       --     warning: in inlined body at\n       --     warning: original warning message\n \n-      --  OK, this is the case where we have an instantiation error, and\n-      --  we need to generate the error on the instantiation, rather than\n-      --  on the template.\n+      --  OK, here we have an instantiation error, and we need to generate the\n+      --  error on the instantiation, rather than on the template.\n \n       declare\n          Actual_Error_Loc : Source_Ptr;\n@@ -396,9 +393,9 @@ package body Errout is\n          --  location where all error messages will actually be posted.\n \n          Save_Error_Msg_Sloc : constant Source_Ptr := Error_Msg_Sloc;\n-         --  Save possible location set for caller's message. We need to\n-         --  use Error_Msg_Sloc for the location of the instantiation error\n-         --  but we have to preserve a possible original value.\n+         --  Save possible location set for caller's message. We need to use\n+         --  Error_Msg_Sloc for the location of the instantiation error but we\n+         --  have to preserve a possible original value.\n \n          X : Source_File_Index;\n \n@@ -417,10 +414,9 @@ package body Errout is\n             exit when Instantiation (X) = No_Location;\n          end loop;\n \n-         --  Since we are generating the messages at the instantiation\n-         --  point in any case, we do not want the references to the\n-         --  bad lines in the instance to be annotated with the location\n-         --  of the instantiation.\n+         --  Since we are generating the messages at the instantiation point in\n+         --  any case, we do not want the references to the bad lines in the\n+         --  instance to be annotated with the location of the instantiation.\n \n          Suppress_Instance_Location := True;\n          Msg_Cont_Status := False;\n@@ -679,10 +675,10 @@ package body Errout is\n             Expander_Active := False;\n          end if;\n \n-         --  Set the fatal error flag in the unit table unless we are\n-         --  in Try_Semantics mode. This stops the semantics from being\n-         --  performed if we find a serious error. This is skipped if we\n-         --  are currently dealing with the configuration pragma file.\n+         --  Set the fatal error flag in the unit table unless we are in\n+         --  Try_Semantics mode. This stops the semantics from being performed\n+         --  if we find a serious error. This is skipped if we are currently\n+         --  dealing with the configuration pragma file.\n \n          if not Try_Semantics and then Current_Source_Unit /= No_Unit then\n             Set_Fatal_Error (Get_Source_Unit (Sptr));\n@@ -722,10 +718,10 @@ package body Errout is\n          return;\n       end if;\n \n-      --  Return without doing anything if message is killed and this\n-      --  is not the first error message. The philosophy is that if we\n-      --  get a weird error message and we already have had a message,\n-      --  then we hope the weird message is a junk cascaded message\n+      --  Return without doing anything if message is killed and this is not\n+      --  the first error message. The philosophy is that if we get a weird\n+      --  error message and we already have had a message, then we hope the\n+      --  weird message is a junk cascaded message\n \n       if Kill_Message\n         and then not All_Errors_Mode\n@@ -749,15 +745,15 @@ package body Errout is\n             return;\n          end if;\n \n-         --  If the flag location is in the main extended source unit\n-         --  then for sure we want the warning since it definitely belongs\n+         --  If the flag location is in the main extended source unit then for\n+         --  sure we want the warning since it definitely belongs\n \n          if In_Extended_Main_Source_Unit (Sptr) then\n             null;\n \n-         --  If the flag location is not in the main extended source unit,\n-         --  then we want to eliminate the warning, unless it is in the\n-         --  extended main code unit and we want warnings on the instance.\n+         --  If the flag location is not in the main extended source unit, then\n+         --  we want to eliminate the warning, unless it is in the extended\n+         --  main code unit and we want warnings on the instance.\n \n          elsif In_Extended_Main_Code_Unit (Sptr) and then Warn_On_Instance then\n             null;\n@@ -1325,13 +1321,12 @@ package body Errout is\n       S := Sloc (F);\n \n       --  The following circuit is a bit subtle. When we have parenthesized\n-      --  expressions, then the Sloc will not record the location of the\n-      --  paren, but we would like to post the flag on the paren. So what\n-      --  we do is to crawl up the tree from the First_Node, adjusting the\n-      --  Sloc value for any parentheses we know are present. Yes, we know\n-      --  this circuit is not 100% reliable (e.g. because we don't record\n-      --  all possible paren level values), but this is only for an error\n-      --  message so it is good enough.\n+      --  expressions, then the Sloc will not record the location of the paren,\n+      --  but we would like to post the flag on the paren. So what we do is to\n+      --  crawl up the tree from the First_Node, adjusting the Sloc value for\n+      --  any parentheses we know are present. Yes, we know this circuit is not\n+      --  100% reliable (e.g. because we don't record all possible paren level\n+      --  values), but this is only for an error message so it is good enough.\n \n       Node_Loop : loop\n          Paren_Loop : for J in 1 .. Paren_Count (F) loop\n@@ -1378,8 +1373,8 @@ package body Errout is\n       Cur_Msg := No_Error_Msg;\n       List_Pragmas.Init;\n \n-      --  Initialize warnings table, if all warnings are suppressed, supply\n-      --  an initial dummy entry covering all possible source locations.\n+      --  Initialize warnings table, if all warnings are suppressed, supply an\n+      --  initial dummy entry covering all possible source locations.\n \n       Warnings.Init;\n       Specific_Warnings.Init;\n@@ -2100,12 +2095,12 @@ package body Errout is\n          Flen := Flen + 1;\n       end loop;\n \n-      --  Loop through file names to find matching one. This is a bit slow,\n-      --  but we only do it in error situations so it is not so terrible.\n-      --  Note that if the loop does not exit, then the desired case will\n-      --  be left set to Mixed_Case, this can happen if the name was not\n-      --  in canonical form, and gets canonicalized on VMS. Possibly we\n-      --  could fix this by unconditinally canonicalizing these names ???\n+      --  Loop through file names to find matching one. This is a bit slow, but\n+      --  we only do it in error situations so it is not so terrible. Note that\n+      --  if the loop does not exit, then the desired case will be left set to\n+      --  Mixed_Case, this can happen if the name was not in canonical form,\n+      --  and gets canonicalized on VMS. Possibly we could fix this by\n+      --  unconditinally canonicalizing these names ???\n \n       for J in 1 .. Last_Source_File loop\n          Get_Name_String (Full_Debug_Name (J));\n@@ -2185,9 +2180,9 @@ package body Errout is\n          K := Nkind (Error_Msg_Node_1);\n \n          --  If we have operator case, skip quotes since name of operator\n-         --  itself will supply the required quotations. An operator can be\n-         --  an applied use in an expression or an explicit operator symbol,\n-         --  or an identifier whose name indicates it is an operator.\n+         --  itself will supply the required quotations. An operator can be an\n+         --  applied use in an expression or an explicit operator symbol, or an\n+         --  identifier whose name indicates it is an operator.\n \n          if K in N_Op\n            or else K = N_Operator_Symbol\n@@ -2333,8 +2328,8 @@ package body Errout is\n          Set_Msg_Node (Ent);\n          Add_Class;\n \n-         --  If Ent is an anonymous subprogram type, there is no name\n-         --  to print, so remove enclosing quotes.\n+         --  If Ent is an anonymous subprogram type, there is no name to print,\n+         --  so remove enclosing quotes.\n \n          if Buffer_Ends_With (\"\"\"\") then\n             Buffer_Remove (\"\"\"\");\n@@ -2343,8 +2338,8 @@ package body Errout is\n          end if;\n       end if;\n \n-      --  If the original type did not come from a predefined\n-      --  file, add the location where the type was defined.\n+      --  If the original type did not come from a predefined file, add the\n+      --  location where the type was defined.\n \n       if Sloc (Error_Msg_Node_1) > Standard_Location\n         and then\n@@ -2521,9 +2516,9 @@ package body Errout is\n             Set_Casing (Mixed_Case);\n \n          else\n-            --  Determine if the reference we are dealing with corresponds\n-            --  to text at the point of the error reference. This will often\n-            --  be the case for simple identifier references, and is the case\n+            --  Determine if the reference we are dealing with corresponds to\n+            --  text at the point of the error reference. This will often be\n+            --  the case for simple identifier references, and is the case\n             --  where we can copy the spelling from the source.\n \n             Sbuffer := Source_Text (Get_Source_File_Index (Src_Loc));\n@@ -2536,8 +2531,8 @@ package body Errout is\n                Src_Ptr := Src_Ptr + 1;\n             end loop;\n \n-            --  If we get through the loop without a mismatch, then output\n-            --  the name the way it is spelled in the source program\n+            --  If we get through the loop without a mismatch, then output the\n+            --  name the way it is spelled in the source program\n \n             if Ref_Ptr > Name_Len then\n                Src_Ptr := Src_Loc;"}, {"sha": "445baa0322d1bac13280dbb4a9cfe2f40c3a9a48", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -1206,6 +1206,20 @@ package body Exp_Attr is\n          Analyze_And_Resolve (N, RTE (RE_AST_Handler));\n       end AST_Entry;\n \n+      ---------\n+      -- Bit --\n+      ---------\n+\n+      --  We compute this if a packed array reference was present, otherwise we\n+      --  leave the computation up to the back end.\n+\n+      when Attribute_Bit =>\n+         if Involves_Packed_Array_Reference (Pref) then\n+            Expand_Packed_Bit_Reference (N);\n+         else\n+            Apply_Universal_Integer_Attribute_Checks (N);\n+         end if;\n+\n       ------------------\n       -- Bit_Position --\n       ------------------\n@@ -1218,8 +1232,7 @@ package body Exp_Attr is\n       --  in generated code (i.e. the prefix is an identifier that\n       --  references the component or discriminant entity).\n \n-      when Attribute_Bit_Position => Bit_Position :\n-      declare\n+      when Attribute_Bit_Position => Bit_Position : declare\n          CE : Entity_Id;\n \n       begin\n@@ -3232,9 +3245,9 @@ package body Exp_Attr is\n       --  For enumeration types with a standard representation, Pos is\n       --  handled by the back end.\n \n-      --  For enumeration types, with a non-standard representation we\n-      --  generate a call to the _Rep_To_Pos function created when the\n-      --  type was frozen. The call has the form\n+      --  For enumeration types, with a non-standard representation we generate\n+      --  a call to the _Rep_To_Pos function created when the type was frozen.\n+      --  The call has the form\n \n       --    _rep_to_pos (expr, flag)\n \n@@ -3541,6 +3554,7 @@ package body Exp_Attr is\n       ------------------\n \n       when Attribute_Range_Length => Range_Length : begin\n+\n          --  The only special processing required is for the case where\n          --  Range_Length is applied to an enumeration type with holes.\n          --  In this case we transform\n@@ -4257,8 +4271,7 @@ package body Exp_Attr is\n       --  2. For floating-point, generate call to attribute function\n       --  3. For other cases, deal with constraint checking\n \n-      when Attribute_Succ => Succ :\n-      declare\n+      when Attribute_Succ => Succ : declare\n          Etyp : constant Entity_Id := Base_Type (Ptyp);\n \n       begin\n@@ -4350,8 +4363,7 @@ package body Exp_Attr is\n \n       --  Transforms X'Tag into a direct reference to the tag of X\n \n-      when Attribute_Tag => Tag :\n-      declare\n+      when Attribute_Tag => Tag : declare\n          Ttyp           : Entity_Id;\n          Prefix_Is_Type : Boolean;\n \n@@ -4598,8 +4610,7 @@ package body Exp_Attr is\n       --  with a non-standard representation we use the _Pos_To_Rep array that\n       --  was created when the type was frozen.\n \n-      when Attribute_Val => Val :\n-      declare\n+      when Attribute_Val => Val : declare\n          Etyp : constant Entity_Id := Base_Type (Entity (Pref));\n \n       begin\n@@ -4662,8 +4673,7 @@ package body Exp_Attr is\n       --  The code for valid is dependent on the particular types involved.\n       --  See separate sections below for the generated code in each case.\n \n-      when Attribute_Valid => Valid :\n-      declare\n+      when Attribute_Valid => Valid : declare\n          Btyp : Entity_Id := Base_Type (Ptyp);\n          Tst  : Node_Id;\n \n@@ -5267,7 +5277,6 @@ package body Exp_Attr is\n       --  that the result is in range.\n \n       when Attribute_Aft                          |\n-           Attribute_Bit                          |\n            Attribute_Max_Size_In_Storage_Elements\n       =>\n          Apply_Universal_Integer_Attribute_Checks (N);"}, {"sha": "02a5ad454b97ca9c9c1ffe80d53f740cb93a63b8", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -4883,7 +4883,7 @@ package body Exp_Ch4 is\n \n       --    The second expression in a 'Read attribute reference\n \n-      --    The prefix of an address or size attribute reference\n+      --    The prefix of an address or bit or size attribute reference\n \n       --  The following circuit detects these exceptions\n \n@@ -4907,6 +4907,8 @@ package body Exp_Ch4 is\n             elsif Nkind (Parnt) = N_Attribute_Reference\n               and then (Attribute_Name (Parnt) = Name_Address\n                          or else\n+                        Attribute_Name (Parnt) = Name_Bit\n+                         or else\n                         Attribute_Name (Parnt) = Name_Size)\n               and then Prefix (Parnt) = Child\n             then"}, {"sha": "be4669ce9b8707a51686098bb2716b8e72817280", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 111, "deletions": 58, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -455,6 +455,15 @@ package body Exp_Pakd is\n    --  expression whose type is the implementation type used to represent\n    --  the packed array. Aexp is analyzed and resolved on entry and on exit.\n \n+   procedure Get_Base_And_Bit_Offset\n+     (N      : Node_Id;\n+      Base   : out Node_Id;\n+      Offset : out Node_Id);\n+   --  Given a node N for a name which involves a packed array reference,\n+   --  return the base object of the reference and build an expression of\n+   --  type Standard.Integer representing the zero-based offset in bits\n+   --  from Base'Address to the first bit of the reference.\n+\n    function Known_Aligned_Enough (Obj : Node_Id; Csiz : Nat) return Boolean;\n    --  There are two versions of the Set routines, the ones used when the\n    --  object is known to be sufficiently well aligned given the number of\n@@ -1663,87 +1672,67 @@ package body Exp_Pakd is\n \n    procedure Expand_Packed_Address_Reference (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n-      Ploc   : Source_Ptr;\n-      Pref   : Node_Id;\n-      Expr   : Node_Id;\n-      Term   : Node_Id;\n-      Atyp   : Entity_Id;\n-      Subscr : Node_Id;\n+      Base   : Node_Id;\n+      Offset : Node_Id;\n \n    begin\n-      Pref := Prefix (N);\n-      Expr := Empty;\n-\n-      --  We build up an expression serially that has the form\n+      --  We build an expression that has the form\n \n       --    outer_object'Address\n       --      + (linear-subscript * component_size  for each array reference\n       --      +  field'Bit_Position                 for each record field\n       --      +  ...\n       --      +  ...) / Storage_Unit;\n \n-      --  Some additional conversions are required to deal with the addition\n-      --  operation, which is not normally visible to generated code.\n-\n-      loop\n-         Ploc := Sloc (Pref);\n-\n-         if Nkind (Pref) = N_Indexed_Component then\n-            Convert_To_Actual_Subtype (Prefix (Pref));\n-            Atyp := Etype (Prefix (Pref));\n-            Compute_Linear_Subscript (Atyp, Pref, Subscr);\n-\n-            Term :=\n-              Make_Op_Multiply (Ploc,\n-                Left_Opnd => Subscr,\n-                Right_Opnd =>\n-                 Make_Attribute_Reference (Ploc,\n-                   Prefix         => New_Occurrence_Of (Atyp, Ploc),\n-                   Attribute_Name => Name_Component_Size));\n-\n-         elsif Nkind (Pref) = N_Selected_Component then\n-            Term :=\n-              Make_Attribute_Reference (Ploc,\n-                Prefix         => Selector_Name (Pref),\n-                Attribute_Name => Name_Bit_Position);\n-\n-         else\n-            exit;\n-         end if;\n-\n-         Term := Convert_To (RTE (RE_Integer_Address), Term);\n-\n-         if No (Expr) then\n-            Expr := Term;\n-\n-         else\n-            Expr :=\n-              Make_Op_Add (Ploc,\n-                Left_Opnd  => Expr,\n-                Right_Opnd => Term);\n-         end if;\n-\n-         Pref := Prefix (Pref);\n-      end loop;\n+      Get_Base_And_Bit_Offset (Prefix (N), Base, Offset);\n \n       Rewrite (N,\n         Unchecked_Convert_To (RTE (RE_Address),\n           Make_Op_Add (Loc,\n             Left_Opnd =>\n               Unchecked_Convert_To (RTE (RE_Integer_Address),\n                 Make_Attribute_Reference (Loc,\n-                  Prefix         => Pref,\n+                  Prefix         => Base,\n                   Attribute_Name => Name_Address)),\n \n             Right_Opnd =>\n-              Make_Op_Divide (Loc,\n-                Left_Opnd => Expr,\n-                Right_Opnd =>\n-                  Make_Integer_Literal (Loc, System_Storage_Unit)))));\n+              Unchecked_Convert_To (RTE (RE_Integer_Address),\n+                Make_Op_Divide (Loc,\n+                  Left_Opnd => Offset,\n+                  Right_Opnd =>\n+                    Make_Integer_Literal (Loc, System_Storage_Unit))))));\n \n       Analyze_And_Resolve (N, RTE (RE_Address));\n    end Expand_Packed_Address_Reference;\n \n+   ---------------------------------\n+   -- Expand_Packed_Bit_Reference --\n+   ---------------------------------\n+\n+   procedure Expand_Packed_Bit_Reference (N : Node_Id) is\n+      Loc    : constant Source_Ptr := Sloc (N);\n+      Base   : Node_Id;\n+      Offset : Node_Id;\n+\n+   begin\n+      --  We build an expression that has the form\n+\n+      --    (linear-subscript * component_size      for each array reference\n+      --      +  field'Bit_Position                 for each record field\n+      --      +  ...\n+      --      +  ...) mod Storage_Unit;\n+\n+      Get_Base_And_Bit_Offset (Prefix (N), Base, Offset);\n+\n+      Rewrite (N,\n+        Unchecked_Convert_To (Universal_Integer,\n+          Make_Op_Mod (Loc,\n+            Left_Opnd => Offset,\n+            Right_Opnd => Make_Integer_Literal (Loc, System_Storage_Unit))));\n+\n+      Analyze_And_Resolve (N, Universal_Integer);\n+   end Expand_Packed_Bit_Reference;\n+\n    ------------------------------------\n    -- Expand_Packed_Boolean_Operator --\n    ------------------------------------\n@@ -2229,6 +2218,70 @@ package body Exp_Pakd is\n \n    end Expand_Packed_Not;\n \n+   -----------------------------\n+   -- Get_Base_And_Bit_Offset --\n+   -----------------------------\n+\n+   procedure Get_Base_And_Bit_Offset\n+     (N      : Node_Id;\n+      Base   : out Node_Id;\n+      Offset : out Node_Id)\n+   is\n+      Loc    : Source_Ptr;\n+      Term   : Node_Id;\n+      Atyp   : Entity_Id;\n+      Subscr : Node_Id;\n+\n+   begin\n+      Base   := N;\n+      Offset := Empty;\n+\n+      --  We build up an expression serially that has the form\n+\n+      --    linear-subscript * component_size       for each array reference\n+      --      +  field'Bit_Position                 for each record field\n+      --      +  ...\n+\n+      loop\n+         Loc := Sloc (Base);\n+\n+         if Nkind (Base) = N_Indexed_Component then\n+            Convert_To_Actual_Subtype (Prefix (Base));\n+            Atyp := Etype (Prefix (Base));\n+            Compute_Linear_Subscript (Atyp, Base, Subscr);\n+\n+            Term :=\n+              Make_Op_Multiply (Loc,\n+                Left_Opnd => Subscr,\n+                Right_Opnd =>\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Occurrence_Of (Atyp, Loc),\n+                   Attribute_Name => Name_Component_Size));\n+\n+         elsif Nkind (Base) = N_Selected_Component then\n+            Term :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => Selector_Name (Base),\n+                Attribute_Name => Name_Bit_Position);\n+\n+         else\n+            return;\n+         end if;\n+\n+         if No (Offset) then\n+            Offset := Term;\n+\n+         else\n+            Offset :=\n+              Make_Op_Add (Loc,\n+                Left_Opnd  => Offset,\n+                Right_Opnd => Term);\n+         end if;\n+\n+         Base := Prefix (Base);\n+      end loop;\n+   end Get_Base_And_Bit_Offset;\n+\n    -------------------------------------\n    -- Involves_Packed_Array_Reference --\n    -------------------------------------"}, {"sha": "bd21a30effe05d2bb51345644219628dd7f278ad", "filename": "gcc/ada/exp_pakd.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fexp_pakd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fexp_pakd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.ads?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -272,4 +272,9 @@ package Exp_Pakd is\n    --  the prefix involves a packed array reference. This routine expands the\n    --  necessary code for performing the address reference in this case.\n \n+   procedure Expand_Packed_Bit_Reference (N : Node_Id);\n+   --  The node N is an attribute reference for the 'Bit reference, where the\n+   --  prefix involves a packed array reference. This routine expands the\n+   --  necessary code for performing the bit reference in this case.\n+\n end Exp_Pakd;"}, {"sha": "545143252294635b67894bb0712093774e93804e", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -696,14 +696,13 @@ package Lib.Writ is\n    --  reference data. See the spec of Par_SCO for full details of the format.\n \n    ----------------------\n-   -- Global variables --\n+   -- Global Variables --\n    ----------------------\n \n-   --  The table structure defined here stores one entry for each\n-   --  Interrupt_State pragma encountered either in the main source or\n-   --  in an ancillary with'ed source. Since interrupt state values\n-   --  have to be consistent across all units in a partition, we may\n-   --  as well detect inconsistencies at compile time when we can.\n+   --  The table defined here stores one entry for each Interrupt_State pragma\n+   --  encountered either in the main source or in an ancillary with'ed source.\n+   --  Since interrupt state values have to be consistent across all units in a\n+   --  partition, we detect inconsistencies at compile time when we can.\n \n    type Interrupt_State_Entry is record\n       Interrupt_Number : Pos;"}, {"sha": "6fe2d64be4510bed60869ac38f1115c52a0a3674", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d3b920ce09b27fca7dc6504640f6fe72fb16cf/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=47d3b920ce09b27fca7dc6504640f6fe72fb16cf", "patch": "@@ -6790,6 +6790,13 @@ package body Sem_Ch3 is\n          Mark_Rewrite_Insertion (New_Decl);\n          Insert_Before (N, New_Decl);\n \n+         --  In the tagged case, make sure ancestor is frozen appropriately\n+         --  (see also non-discriminated case below).\n+\n+         if not Private_Extension or else Is_Interface (Parent_Base) then\n+            Freeze_Before (New_Decl, Parent_Type);\n+         end if;\n+\n          --  Note that this call passes False for the Derive_Subps parameter\n          --  because subprogram derivation is deferred until after creating\n          --  the subtype (see below).\n@@ -6880,9 +6887,7 @@ package body Sem_Ch3 is\n          --  The declaration of a specific descendant of an interface type\n          --  freezes the interface type (RM 13.14).\n \n-         if not Private_Extension\n-           or else Is_Interface (Parent_Base)\n-         then\n+         if not Private_Extension or else Is_Interface (Parent_Base) then\n             Freeze_Before (N, Parent_Type);\n          end if;\n "}]}