{"sha": "01188446e8711717f6b0f9568340bb655b22f7b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDExODg0NDZlODcxMTcxN2Y2YjBmOTU2ODM0MGJiNjU1YjIyZjdiNw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-03-10T19:45:20Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-03-10T19:45:20Z"}, "message": "(expand_assignment): When offset is zero, make new MEM\nbefore setting MEM_VOLATILE_P.\n\nFrom-SVN: r9167", "tree": {"sha": "01cd4310b8cc05a2d189595bf494e1daa0a1f88a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01cd4310b8cc05a2d189595bf494e1daa0a1f88a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01188446e8711717f6b0f9568340bb655b22f7b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01188446e8711717f6b0f9568340bb655b22f7b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01188446e8711717f6b0f9568340bb655b22f7b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01188446e8711717f6b0f9568340bb655b22f7b7/comments", "author": null, "committer": null, "parents": [{"sha": "12357e4274a0e7cd4cf86eb8f79d5e0f21ae5a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12357e4274a0e7cd4cf86eb8f79d5e0f21ae5a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12357e4274a0e7cd4cf86eb8f79d5e0f21ae5a97"}], "stats": {"total": 9, "additions": 8, "deletions": 1}, "files": [{"sha": "76e497f4178d4830d8cea1007a4d223780d89043", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01188446e8711717f6b0f9568340bb655b22f7b7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01188446e8711717f6b0f9568340bb655b22f7b7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=01188446e8711717f6b0f9568340bb655b22f7b7", "patch": "@@ -2508,7 +2508,14 @@ expand_assignment (to, from, want_value, suggest_reg)\n       if (volatilep)\n \t{\n \t  if (GET_CODE (to_rtx) == MEM)\n-\t    MEM_VOLATILE_P (to_rtx) = 1;\n+\t    {\n+\t      /* When the offset is zero, to_rtx is the address of the\n+\t\t structure we are storing into, and hence may be shared.\n+\t\t We must make a new MEM before setting the volatile bit.  */\n+\t      if (offset == 0)\n+\t\tto_rtx = change_address (to_rtx, VOIDmode, XEXP (to_rtx, 0));\n+\t      MEM_VOLATILE_P (to_rtx) = 1;\n+\t    }\n #if 0  /* This was turned off because, when a field is volatile\n \t  in an object which is not volatile, the object may be in a register,\n \t  and then we would abort over here.  */"}]}