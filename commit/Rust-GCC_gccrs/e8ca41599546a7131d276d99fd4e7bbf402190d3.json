{"sha": "e8ca41599546a7131d276d99fd4e7bbf402190d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThjYTQxNTk5NTQ2YTcxMzFkMjc2ZDk5ZmQ0ZTdiYmY0MDIxOTBkMw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-07-10T00:28:01Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-07-10T00:28:01Z"}, "message": "Makefile.in (tree-ssa-alias.o): Depend on tree-ssa-structalias.h\n\n\n\t* Makefile.in (tree-ssa-alias.o): Depend on tree-ssa-structalias.h\n\t* tree-cfg.c (CHECK_OP): Only test for is_gimple_val.\n\t* tree-dfa.c (dump_subvars_for): New.\n\t(debug_subvars_for): New.\n\t(dump_variable): Show subvariables if VAR has them.\n\t* tree-flow-inline.h (get_subvar_at): New.\n\t(overlap_subvar): Change offset and size to unsigned HOST_WIDE_INT.\n\t* tree-flow.h (struct ptr_info_def): Remove field pt_malloc.\n\tUpdate all users.\n\t(struct subvar): Change fields offset and size to unsigned\n\tHOST_WIDE_INT.\n\t(dump_subvars_for): Declare.\n\t(debug_subvars_for): Declare.\n\t(get_subvar_at): Declare.\n\t(okay_component_ref_for_subvars): Change 2nd and 3rd argument\n\tto unsigned HOST_WIDE_INT *.\n\t(overlap_subvar): Likewise.\n\t* tree-gimple.c (is_gimple_reg): Always return false for\n\tSFTs and memory tags.\n\t* tree-pass.h (pass_build_pta, pass_del_pta): Remove.\n\tUpdate all callers.\n\t* tree-ssa-alias.c: Include tree-ssa-structalias.h.\n\t(compute_may_aliases): Call compute_points_to_sets.\n\t(collect_points_to_info_for): Remove.\n\t(compute_points_to_and_addr_escape): Remove.\n\t(delete_alias_info): Call delete_points_to_sets.\n\t(compute_flow_sensitive_aliasing): If the call to\n\tfind_what_p_points_to returns false, call set_pt_anything.\n\t(add_may_alias): Set TREE_ADDRESSABLE when adding a new alias.\n\t(set_pt_anything): Clear pi->pt_vars.\n\t(set_pt_malloc): Remove.\n\t(merge_pointed_to_info): Remove.\n\t(add_pointed_to_expr): Remove.\n\t(add_pointed_to_var): Remove.\n\t(collect_points_to_info_r): Remove.\n\t(is_escape_site): Make extern.\n\t(create_sft): New.\n\t(create_overlap_variables_for): Call it.\n\t* tree-ssa-copy.c (merge_alias_info): Never merge\n\tflow-sensitive alias information.\n\t* tree-ssa-operands.c (get_expr_operands): Adjust variables\n\toffset and size to be unsigned HOST_WIDE_INT.\n\t(add_to_addressable_set): Rename from note_addressable.\n\tSet TREE_ADDRESSABLE as the variables are added to the set.\n\tUpdate all users.\n\t(add_stmt_operand): Do not try to micro-optimize unmodifiable\n\toperands into VUSEs when adding V_MAY_DEFs for members in an\n\talias set.\n\t* tree-ssa-operands.h (add_to_addressable_set): Declare.\n\t* tree-ssa-structalias.c: Include tree-ssa-structalias.h last.\n\t(struct variable_info): Add bitfield is_heap_var.\n\t(var_anyoffset, anyoffset_tree, anyoffset_id): Declare.\n\t(new_var_info): Initialize is_heap_var.\n\t(get_constraint_for): Add HEAP variables to the symbol table.\n\tMark them with is_heap_var.\n\t(update_alias_info): New.  Taken mostly from the old\n\tcompute_points_to_and_addr_escape.\n\t(handle_ptr_arith): New.\n\t(find_func_aliases): Call update_alias_info.\n\tCall handle_ptr_info for tcc_binary expressions.\n\tCall mark_stmt_modified.\n\t(create_variable_info_for): If DECL has subvars, do not create\n\tvariables for its subvars.  Always add all the fields.\n\t(set_uids_in_ptset): If the solution includes ANYOFFSET and\n\tSFTs, then add all the SFTs of the structure.\n\tIf VI->DECL is an aggregate with subvariables, add the SFT at\n\tVI->OFFSET.\n\t(find_what_p_points_to): If VI is an artificial variable,\n\ttranslate to bitfields in SSA_NAME_PTR_INFO.\n\tIf the solution is empty, set pi->pt_vars to NULL\n\t(init_base_vars): Create ANYOFFSET.\n\t(compute_points_to_sets): Rename from create_alias_vars.\n\tMake extern.\n\t(pass_build_pta): Remove.\n\t(delete_points_to_sets): Rename from delete_alias_vars.\n\t(pass_del_pta): Remove.\n\t* tree-ssa-structalias.h (struct alias_info): Move from\n\ttree-ssa-alias.h.\n\t(NUM_REFERENCES, NUM_REFERENCES_CLEAR, NUM_REFERENCES_INC,\n\tNUM_REFERENCES_SET): Likewise.\n\t(compute_points_to_sets, delete_points_to_sets): Declare.\n\ntestsuite/ChangeLog\n\n\t* gcc.dg/tree-ssa/pta-fp.c: Use -fdump-tree-alias1.\n\nFrom-SVN: r101841", "tree": {"sha": "9008332e0b51567fbab3eeb7dddef5739f208581", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9008332e0b51567fbab3eeb7dddef5739f208581"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8ca41599546a7131d276d99fd4e7bbf402190d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ca41599546a7131d276d99fd4e7bbf402190d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ca41599546a7131d276d99fd4e7bbf402190d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ca41599546a7131d276d99fd4e7bbf402190d3/comments", "author": null, "committer": null, "parents": [{"sha": "87f8dcd06e27dbf222d8bf4564400122ec387c00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f8dcd06e27dbf222d8bf4564400122ec387c00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87f8dcd06e27dbf222d8bf4564400122ec387c00"}], "stats": {"total": 1753, "additions": 818, "deletions": 935}, "files": [{"sha": "22176257b2c3359fafca5d1c0c78194b1d6534fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -1,3 +1,87 @@\n+2005-07-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* Makefile.in (tree-ssa-alias.o): Depend on tree-ssa-structalias.h\n+\t* tree-cfg.c (CHECK_OP): Only test for is_gimple_val.\n+\t* tree-dfa.c (dump_subvars_for): New.\n+\t(debug_subvars_for): New.\n+\t(dump_variable): Show subvariables if VAR has them.\n+\t* tree-flow-inline.h (get_subvar_at): New.\n+\t(overlap_subvar): Change offset and size to unsigned HOST_WIDE_INT.\n+\t* tree-flow.h (struct ptr_info_def): Remove field pt_malloc.\n+\tUpdate all users.\n+\t(struct subvar): Change fields offset and size to unsigned\n+\tHOST_WIDE_INT.\n+\t(dump_subvars_for): Declare.\n+\t(debug_subvars_for): Declare.\n+\t(get_subvar_at): Declare.\n+\t(okay_component_ref_for_subvars): Change 2nd and 3rd argument\n+\tto unsigned HOST_WIDE_INT *.\n+\t(overlap_subvar): Likewise.\n+\t* tree-gimple.c (is_gimple_reg): Always return false for\n+\tSFTs and memory tags.\n+\t* tree-pass.h (pass_build_pta, pass_del_pta): Remove.\n+\tUpdate all callers.\n+\t* tree-ssa-alias.c: Include tree-ssa-structalias.h.\n+\t(compute_may_aliases): Call compute_points_to_sets.\n+\t(collect_points_to_info_for): Remove.\n+\t(compute_points_to_and_addr_escape): Remove.\n+\t(delete_alias_info): Call delete_points_to_sets.\n+\t(compute_flow_sensitive_aliasing): If the call to\n+\tfind_what_p_points_to returns false, call set_pt_anything.\n+\t(add_may_alias): Set TREE_ADDRESSABLE when adding a new alias.\n+\t(set_pt_anything): Clear pi->pt_vars.\n+\t(set_pt_malloc): Remove.\n+\t(merge_pointed_to_info): Remove.\n+\t(add_pointed_to_expr): Remove.\n+\t(add_pointed_to_var): Remove.\n+\t(collect_points_to_info_r): Remove.\n+\t(is_escape_site): Make extern.\n+\t(create_sft): New.\n+\t(create_overlap_variables_for): Call it.\n+\t* tree-ssa-copy.c (merge_alias_info): Never merge\n+\tflow-sensitive alias information.\n+\t* tree-ssa-operands.c (get_expr_operands): Adjust variables\n+\toffset and size to be unsigned HOST_WIDE_INT.\n+\t(add_to_addressable_set): Rename from note_addressable.\n+\tSet TREE_ADDRESSABLE as the variables are added to the set.\n+\tUpdate all users.\n+\t(add_stmt_operand): Do not try to micro-optimize unmodifiable\n+\toperands into VUSEs when adding V_MAY_DEFs for members in an\n+\talias set.\n+\t* tree-ssa-operands.h (add_to_addressable_set): Declare.\n+\t* tree-ssa-structalias.c: Include tree-ssa-structalias.h last.\n+\t(struct variable_info): Add bitfield is_heap_var.\n+\t(var_anyoffset, anyoffset_tree, anyoffset_id): Declare.\n+\t(new_var_info): Initialize is_heap_var.\n+\t(get_constraint_for): Add HEAP variables to the symbol table.\n+\tMark them with is_heap_var.\n+\t(update_alias_info): New.  Taken mostly from the old\n+\tcompute_points_to_and_addr_escape.\n+\t(handle_ptr_arith): New.\n+\t(find_func_aliases): Call update_alias_info.\n+\tCall handle_ptr_info for tcc_binary expressions.\n+\tCall mark_stmt_modified.\n+\t(create_variable_info_for): If DECL has subvars, do not create\n+\tvariables for its subvars.  Always add all the fields.\n+\t(set_uids_in_ptset): If the solution includes ANYOFFSET and\n+\tSFTs, then add all the SFTs of the structure.\n+\tIf VI->DECL is an aggregate with subvariables, add the SFT at\n+\tVI->OFFSET.\n+\t(find_what_p_points_to): If VI is an artificial variable,\n+\ttranslate to bitfields in SSA_NAME_PTR_INFO.\n+\tIf the solution is empty, set pi->pt_vars to NULL\n+\t(init_base_vars): Create ANYOFFSET.\n+\t(compute_points_to_sets): Rename from create_alias_vars.\n+\tMake extern.\n+\t(pass_build_pta): Remove.\n+\t(delete_points_to_sets): Rename from delete_alias_vars.\n+\t(pass_del_pta): Remove.\n+\t* tree-ssa-structalias.h (struct alias_info): Move from\n+\ttree-ssa-alias.h.\n+\t(NUM_REFERENCES, NUM_REFERENCES_CLEAR, NUM_REFERENCES_INC,\n+\tNUM_REFERENCES_SET): Likewise.\n+\t(compute_points_to_sets, delete_points_to_sets): Declare.\n+\n 2005-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (emit_insxl, alpha_expand_compare_and_swap_12,"}, {"sha": "1c70c7ab9b9e98219d3e08a614bb3577f1d884a3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -1895,7 +1895,7 @@ tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \\\n    function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \\\n    $(TREE_DUMP_H) tree-pass.h $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n-   hard-reg-set.h $(TREE_GIMPLE_H) vec.h\n+   hard-reg-set.h $(TREE_GIMPLE_H) vec.h tree-ssa-structalias.h\n tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\\"}, {"sha": "04c60a5b006e34a860f3ee51dbdfa68954ea1d12", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -471,10 +471,8 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_referenced_vars);\n   NEXT_PASS (pass_create_structure_vars);\n   NEXT_PASS (pass_build_ssa);\n-  NEXT_PASS (pass_build_pta);\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_return_slot);\n-  NEXT_PASS (pass_del_pta);\n   NEXT_PASS (pass_rename_ssa_copies);\n   NEXT_PASS (pass_early_warn_uninitialized);\n \n@@ -490,9 +488,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_dominator);\n \n   NEXT_PASS (pass_phiopt);\n-  NEXT_PASS (pass_build_pta);\n   NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_del_pta);\n   NEXT_PASS (pass_tail_recursion);\n   NEXT_PASS (pass_profile);\n   NEXT_PASS (pass_ch);"}, {"sha": "96d0a0badcd4eed7b593417e7ce95c2a083019db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -1,3 +1,7 @@\n+2005-07-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/pta-fp.c: Use -fdump-tree-alias1.\n+\n 2005-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* lib/target-supports.exp (check_effective_target_sync_char_short):"}, {"sha": "4cebcbb670a3b8a2995fa8335386bf77ae6e7922", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-fp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-fp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-fp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-fp.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-pta1\" } */\n+/* { dg-options \"-O2 -fdump-tree-alias1\" } */\n extern double cos (double);\n extern double sin (double);\n double f(double a)\n@@ -22,5 +22,5 @@ double f(double a)\n }\n /* The points-to set of the final function pointer should be \"sin cos\" */\n \n-/* { dg-final { scan-tree-dump-times \"sin cos\" 1 \"pta1\"} } */\n-/* { dg-final { cleanup-tree-dump \"pta1\" } } */\n+/* { dg-final { scan-tree-dump-times \"sin cos\" 1 \"alias1\"} } */\n+/* { dg-final { cleanup-tree-dump \"alias1\" } } */"}, {"sha": "dd8ad0821f0b2019eb5f248eadea998f7f72fe26", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -3083,12 +3083,9 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   if (TYPE_P (t))\n     *walk_subtrees = 0;\n   \n-  /* Check operand N for being valid GIMPLE and give error MSG if not. \n-     We check for constants explicitly since they are not considered\n-     gimple invariants if they overflowed.  */\n+  /* Check operand N for being valid GIMPLE and give error MSG if not.  */\n #define CHECK_OP(N, MSG) \\\n-  do { if (!CONSTANT_CLASS_P (TREE_OPERAND (t, N))\t\t\\\n-         && !is_gimple_val (TREE_OPERAND (t, N)))\t\t\\\n+  do { if (!is_gimple_val (TREE_OPERAND (t, N)))\t\t\\\n        { error (MSG); return TREE_OPERAND (t, N); }} while (0)\n \n   switch (TREE_CODE (t))"}, {"sha": "f065f5d3bb6413b65903cc12ed212b300c73b893", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -254,6 +254,37 @@ debug_referenced_vars (void)\n }\n \n \n+/* Dump sub-variables for VAR to FILE.  */\n+\n+void\n+dump_subvars_for (FILE *file, tree var)\n+{\n+  subvar_t sv = get_subvars_for_var (var);\n+\n+  if (!sv)\n+    return;\n+\n+  fprintf (file, \"{ \");\n+\n+  for (; sv; sv = sv->next)\n+    {\n+      print_generic_expr (file, sv->var, dump_flags);\n+      fprintf (file, \" \");\n+    }\n+\n+  fprintf (file, \"}\");\n+}\n+\n+\n+/* Dumb sub-variables for VAR to stderr.  */\n+\n+void\n+debug_subvars_for (tree var)\n+{\n+  dump_subvars_for (stderr, var);\n+}\n+\n+\n /* Dump variable VAR and its may-aliases to FILE.  */\n \n void\n@@ -316,6 +347,12 @@ dump_variable (FILE *file, tree var)\n       dump_may_aliases_for (file, var);\n     }\n \n+  if (get_subvars_for_var (var))\n+    {\n+      fprintf (file, \", sub-vars: \");\n+      dump_subvars_for (file, var);\n+    }\n+\n   fprintf (file, \"\\n\");\n }\n \n@@ -741,8 +778,8 @@ find_new_referenced_vars (tree *stmt_p)\n    size, in bits, of REF inside the return value.  */\n \n tree\n-okay_component_ref_for_subvars (tree ref, HOST_WIDE_INT *poffset,\n-\t\t\t\tHOST_WIDE_INT *psize)\n+okay_component_ref_for_subvars (tree ref, unsigned HOST_WIDE_INT *poffset,\n+\t\t\t\tunsigned HOST_WIDE_INT *psize)\n {\n   tree result = NULL;\n   HOST_WIDE_INT bitsize;"}, {"sha": "4874c77f686c3f45709dabde9f24b6b6822014d7", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -1444,6 +1444,20 @@ get_subvars_for_var (tree var)\n   return subvars;\n }\n \n+/* Return the subvariable of VAR at offset OFFSET.  */\n+\n+static inline tree\n+get_subvar_at (tree var, unsigned HOST_WIDE_INT offset)\n+{\n+  subvar_t sv;\n+\n+  for (sv = get_subvars_for_var (var); sv; sv = sv->next)\n+    if (sv->offset == offset)\n+      return sv->var;\n+\n+  return NULL_TREE;\n+}\n+\n /* Return true if V is a tree that we can have subvars for.\n    Normally, this is any aggregate type, however, due to implementation\n    limitations ATM, we exclude array types as well.  */\n@@ -1461,7 +1475,7 @@ var_can_have_subvars (tree v)\n    *EXACT will be set to true upon return. */\n \n static inline bool\n-overlap_subvar (HOST_WIDE_INT offset, HOST_WIDE_INT size,\n+overlap_subvar (unsigned HOST_WIDE_INT offset, unsigned HOST_WIDE_INT size,\n \t\tsubvar_t sv,  bool *exact)\n {\n   /* There are three possible cases of overlap."}, {"sha": "c28de1c8ab57b518cf9f22c8189d375511ceed19", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -71,9 +71,6 @@ struct ptr_info_def GTY(())\n      is pointing to.  */\n   unsigned int pt_anything : 1;\n \n-  /* Nonzero if this pointer is the result of a call to malloc.  */\n-  unsigned int pt_malloc : 1;\n-\n   /* Nonzero if the value of this pointer escapes the current function.  */\n   unsigned int value_escapes_p : 1;\n \n@@ -160,19 +157,22 @@ enum mem_tag_kind {\n   /* This variable represents a structure field.  */\n   STRUCT_FIELD\n };\n+\n struct subvar;\n typedef struct subvar *subvar_t;\n \n /* This structure represents a fake sub-variable for a structure field.  */\n-\n struct subvar GTY(())\n {\n-  /* Fake variable name */\n+  /* Fake variable.  */\n   tree var;\n+\n   /* Offset inside structure.  */\n-  HOST_WIDE_INT offset;\n-  /* Size of field.  */\n-  HOST_WIDE_INT size;\n+  unsigned HOST_WIDE_INT offset;\n+\n+  /* Size of the field.  */\n+  unsigned HOST_WIDE_INT size;\n+\n   /* Next subvar for this structure.  */\n   subvar_t next;\n };\n@@ -552,6 +552,8 @@ extern void debug_referenced_vars (void);\n extern void dump_referenced_vars (FILE *);\n extern void dump_variable (FILE *, tree);\n extern void debug_variable (tree);\n+extern void dump_subvars_for (FILE *, tree);\n+extern void debug_subvars_for (tree);\n extern tree get_virtual_var (tree);\n extern void add_referenced_tmp_var (tree);\n extern void mark_new_vars_to_rename (tree);\n@@ -578,11 +580,13 @@ extern void add_type_alias (tree, tree);\n extern void new_type_alias (tree, tree);\n extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *, bool *);\n static inline subvar_t get_subvars_for_var (tree);\n+static inline tree get_subvar_at (tree, unsigned HOST_WIDE_INT);\n static inline bool ref_contains_array_ref (tree);\n-extern tree okay_component_ref_for_subvars (tree, HOST_WIDE_INT *,\n-\t\t\t\t\t    HOST_WIDE_INT *);\n+extern tree okay_component_ref_for_subvars (tree, unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t    unsigned HOST_WIDE_INT *);\n static inline bool var_can_have_subvars (tree);\n-static inline bool overlap_subvar (HOST_WIDE_INT, HOST_WIDE_INT,\n+static inline bool overlap_subvar (unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n \t\t\t\t   subvar_t, bool *);\n \n /* Call-back function for walk_use_def_chains().  At each reaching"}, {"sha": "284f577711cfac04dea19e24b61adb50d6ee04ad", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -268,6 +268,8 @@ is_gimple_reg_type (tree type)\n bool\n is_gimple_reg (tree t)\n {\n+  var_ann_t ann;\n+\n   if (TREE_CODE (t) == SSA_NAME)\n     t = SSA_NAME_VAR (t);\n \n@@ -305,9 +307,16 @@ is_gimple_reg (tree t)\n   if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n     return DECL_COMPLEX_GIMPLE_REG_P (t);\n \n+  /* Some compiler temporaries are created to be used exclusively in\n+     virtual operands (currently memory tags and sub-variables).\n+     These variables should never be considered GIMPLE registers.  */\n+  if (DECL_ARTIFICIAL (t) && (ann = var_ann (t)) != NULL)\n+    return ann->mem_tag_kind == NOT_A_TAG;\n+\n   return true;\n }\n \n+\n /* Returns true if T is a GIMPLE formal temporary variable.  */\n \n bool"}, {"sha": "d420b1b1714a48a75d430bcb758bc4c78389a0f1", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -276,8 +276,6 @@ extern struct tree_opt_pass pass_store_ccp;\n extern struct tree_opt_pass pass_store_copy_prop;\n extern struct tree_opt_pass pass_vrp;\n extern struct tree_opt_pass pass_create_structure_vars;\n-extern struct tree_opt_pass pass_build_pta;\n-extern struct tree_opt_pass pass_del_pta;\n extern struct tree_opt_pass pass_uncprop;\n extern struct tree_opt_pass pass_return_slot;\n extern struct tree_opt_pass pass_reassoc;"}, {"sha": "f55e2d2edd5615a3e69c47fa01989d1c9d38f4d8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 59, "deletions": 633, "changes": 692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -40,19 +40,12 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-flow.h\"\n #include \"tree-inline.h\"\n #include \"tree-pass.h\"\n+#include \"tree-ssa-structalias.h\"\n #include \"convert.h\"\n #include \"params.h\"\n #include \"vec.h\"\n #include \"bitmap.h\"\n \n-/* Keep track of how many times each pointer has been dereferenced in\n-   the program using the aux variable.  This is used by the alias\n-   grouping heuristic in compute_flow_insensitive_aliasing.  */\n-#define NUM_REFERENCES(ANN) ((size_t)((ANN)->common.aux))\n-#define NUM_REFERENCES_CLEAR(ANN) ((ANN)->common.aux) = 0\n-#define NUM_REFERENCES_INC(ANN) (ANN)->common.aux = (void*) (((size_t)((ANN)->common.aux)) + 1)\n-#define NUM_REFERENCES_SET(ANN, VAL) (ANN)->common.aux = (void*) ((void *)(VAL))\n-\n /* Obstack used to hold grouping bitmaps and other temporary bitmaps used by\n    aliasing  */\n static bitmap_obstack alias_obstack;\n@@ -83,51 +76,6 @@ struct alias_map_d\n };\n \n \n-/* Alias information used by compute_may_aliases and its helpers.  */\n-struct alias_info\n-{\n-  /* SSA names visited while collecting points-to information.  If bit I\n-     is set, it means that SSA variable with version I has already been\n-     visited.  */\n-  sbitmap ssa_names_visited;\n-\n-  /* Array of SSA_NAME pointers processed by the points-to collector.  */\n-  varray_type processed_ptrs;\n-\n-  /* Variables whose address is still needed.  */\n-  bitmap addresses_needed;\n-\n-  /* ADDRESSABLE_VARS contains all the global variables and locals that\n-     have had their address taken.  */\n-  struct alias_map_d **addressable_vars;\n-  size_t num_addressable_vars;\n-\n-  /* POINTERS contains all the _DECL pointers with unique memory tags\n-     that have been referenced in the program.  */\n-  struct alias_map_d **pointers;\n-  size_t num_pointers;\n-\n-  /* Number of function calls found in the program.  */\n-  size_t num_calls_found;\n-\n-  /* Number of const/pure function calls found in the program.  */\n-  size_t num_pure_const_calls_found;\n-\n-  /* Total number of virtual operands that will be needed to represent\n-     all the aliases of all the pointers found in the program.  */\n-  long total_alias_vops;\n-\n-  /* Variables that have been written to.  */\n-  bitmap written_vars;\n-\n-  /* Pointers that have been used in an indirect store operation.  */\n-  bitmap dereferenced_ptrs_store;\n-\n-  /* Pointers that have been used in an indirect load operation.  */\n-  bitmap dereferenced_ptrs_load;\n-};\n-\n-\n /* Counters used to display statistics on alias analysis.  */\n struct alias_stats_d\n {\n@@ -155,18 +103,12 @@ static void add_may_alias (tree, tree);\n static void replace_may_alias (tree, size_t, tree);\n static struct alias_info *init_alias_info (void);\n static void delete_alias_info (struct alias_info *);\n-static void compute_points_to_and_addr_escape (struct alias_info *);\n static void compute_flow_sensitive_aliasing (struct alias_info *);\n static void setup_pointers_and_addressables (struct alias_info *);\n-static bool collect_points_to_info_r (tree, tree, void *);\n-static bool is_escape_site (tree, struct alias_info *);\n-static void add_pointed_to_var (struct alias_info *, tree, tree);\n static void create_global_var (void);\n-static void collect_points_to_info_for (struct alias_info *, tree);\n static void maybe_create_global_var (struct alias_info *ai);\n static void group_aliases (struct alias_info *);\n static void set_pt_anything (tree ptr);\n-static void set_pt_malloc (tree ptr);\n \n /* Global declarations.  */\n \n@@ -315,7 +257,7 @@ compute_may_aliases (void)\n      address of V escapes the current function, making V call-clobbered\n      (i.e., whether &V is stored in a global variable or if its passed as a\n      function call argument).  */\n-  compute_points_to_and_addr_escape (ai);\n+  compute_points_to_sets (ai);\n \n   /* Collect all pointers and addressable variables, compute alias sets,\n      create memory tags for pointers and promote variables whose address is\n@@ -506,7 +448,6 @@ init_alias_info (void)\n   ai->ssa_names_visited = sbitmap_alloc (num_ssa_names);\n   sbitmap_zero (ai->ssa_names_visited);\n   VARRAY_TREE_INIT (ai->processed_ptrs, 50, \"processed_ptrs\");\n-  ai->addresses_needed = BITMAP_ALLOC (&alias_obstack);\n   ai->written_vars = BITMAP_ALLOC (&alias_obstack);\n   ai->dereferenced_ptrs_store = BITMAP_ALLOC (&alias_obstack);\n   ai->dereferenced_ptrs_load = BITMAP_ALLOC (&alias_obstack);\n@@ -564,7 +505,6 @@ init_alias_info (void)\n \t\t superset of its former points-to set, then a new\n \t\t tag will need to be created in create_name_tags.  */\n \t      pi->pt_anything = 0;\n-\t      pi->pt_malloc = 0;\n \t      pi->pt_null = 0;\n \t      pi->value_escapes_p = 0;\n \t      pi->is_dereferenced = 0;\n@@ -592,7 +532,6 @@ delete_alias_info (struct alias_info *ai)\n \n   sbitmap_free (ai->ssa_names_visited);\n   ai->processed_ptrs = NULL;\n-  BITMAP_FREE (ai->addresses_needed);\n \n   for (i = 0; i < ai->num_addressable_vars; i++)\n     free (ai->addressable_vars[i]);\n@@ -613,171 +552,9 @@ delete_alias_info (struct alias_info *ai)\n   BITMAP_FREE (ai->dereferenced_ptrs_store);\n   BITMAP_FREE (ai->dereferenced_ptrs_load);\n   bitmap_obstack_release (&alias_obstack);\n-\n   free (ai);\n-}\n \n-\n-/* Walk use-def chains for pointer PTR to determine what variables is PTR\n-   pointing to.  */\n-\n-static void\n-collect_points_to_info_for (struct alias_info *ai, tree ptr)\n-{\n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (ptr)));\n-\n-  if (!TEST_BIT (ai->ssa_names_visited, SSA_NAME_VERSION (ptr)))\n-    {\n-      SET_BIT (ai->ssa_names_visited, SSA_NAME_VERSION (ptr));\n-      walk_use_def_chains (ptr, collect_points_to_info_r, ai, true);\n-      VARRAY_PUSH_TREE (ai->processed_ptrs, ptr);\n-    }\n-}\n-\n-/* Traverse use-def links for all the pointers in the program to collect\n-   address escape and points-to information.\n-   \n-   This is loosely based on the same idea described in R. Hasti and S.\n-   Horwitz, ``Using static single assignment form to improve\n-   flow-insensitive pointer analysis,'' in SIGPLAN Conference on\n-   Programming Language Design and Implementation, pp. 97-105, 1998.  */\n-\n-static void\n-compute_points_to_and_addr_escape (struct alias_info *ai)\n-{\n-  basic_block bb;\n-  unsigned i;\n-  tree op;\n-  ssa_op_iter iter;\n-\n-  timevar_push (TV_TREE_PTA);\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator si;\n-\n-      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-\t{\n-\t  bitmap addr_taken;\n-\t  tree stmt = bsi_stmt (si);\n-\t  bool stmt_escapes_p = is_escape_site (stmt, ai);\n-\t  bitmap_iterator bi;\n-\n-\t  /* Mark all the variables whose address are taken by the\n-\t     statement.  Note that this will miss all the addresses taken\n-\t     in PHI nodes (those are discovered while following the use-def\n-\t     chains).  */\n-\t  addr_taken = addresses_taken (stmt);\n-\t  if (addr_taken)\n-\t    EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi) \n-\t      {\n-\t\ttree var = referenced_var (i);\n-\t\tbitmap_set_bit (ai->addresses_needed, DECL_UID (var));\n-\t\tif (stmt_escapes_p)\n-\t\t  mark_call_clobbered (var);\n-\t      }\n-\n-\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n-\t    {\n-\t      tree var = SSA_NAME_VAR (op);\n-\t      var_ann_t v_ann = var_ann (var);\n-\t      struct ptr_info_def *pi;\n-\t      bool is_store;\n-\t      unsigned num_uses, num_derefs;\n-\n-\t      /* If the operand's variable may be aliased, keep track\n-\t\t of how many times we've referenced it.  This is used\n-\t\t for alias grouping in compute_flow_sensitive_aliasing.\n-\t\t Note that we don't need to grow AI->NUM_REFERENCES\n-\t\t because we are processing regular variables, not\n-\t\t memory tags (the array's initial size is set to\n-\t\t NUM_REFERENCED_VARS).  */\n-\t      if (may_be_aliased (var))\n-\t\tNUM_REFERENCES_INC (v_ann);\n-\n-\t      if (!POINTER_TYPE_P (TREE_TYPE (op)))\n-\t\tcontinue;\n-\n-\t      collect_points_to_info_for (ai, op);\n-\n-\t      pi = SSA_NAME_PTR_INFO (op);\n-\t      count_uses_and_derefs (op, stmt, &num_uses, &num_derefs,\n-\t\t\t\t     &is_store);\n-\n-\t      if (num_derefs > 0)\n-\t\t{\n-\t\t  /* Mark OP as dereferenced.  In a subsequent pass,\n-\t\t     dereferenced pointers that point to a set of\n-\t\t     variables will be assigned a name tag to alias\n-\t\t     all the variables OP points to.  */\n-\t\t  pi->is_dereferenced = 1;\n-\n-\t\t  /* Keep track of how many time we've dereferenced each\n-\t\t     pointer.  */\n-\t\t  NUM_REFERENCES_INC (v_ann);\n-\n-\t\t  /* If this is a store operation, mark OP as being\n-\t\t     dereferenced to store, otherwise mark it as being\n-\t\t     dereferenced to load.  */\n-\t\t  if (is_store)\n-\t\t    bitmap_set_bit (ai->dereferenced_ptrs_store, \n-\t\t\t\t    DECL_UID (var));\n-\t\t  else\n-\t\t    bitmap_set_bit (ai->dereferenced_ptrs_load, \n-\t\t\t\t    DECL_UID (var));\n-\t\t}\n-\n-\t      if (stmt_escapes_p && num_derefs < num_uses)\n-\t\t{\n-\t\t  /* If STMT is an escape point and STMT contains at\n-\t\t     least one direct use of OP, then the value of OP\n-\t\t     escapes and so the pointed-to variables need to\n-\t\t     be marked call-clobbered.  */\n-\t\t  pi->value_escapes_p = 1;\n-\n-\t\t  /* If the statement makes a function call, assume\n-\t\t     that pointer OP will be dereferenced in a store\n-\t\t     operation inside the called function.  */\n-\t\t  if (get_call_expr_in (stmt))\n-\t\t    {\n-\t\t      bitmap_set_bit (ai->dereferenced_ptrs_store, \n-\t\t\t\t      DECL_UID (var));\n-\t\t      pi->is_dereferenced = 1;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* Update reference counter for definitions to any\n-\t     potentially aliased variable.  This is used in the alias\n-\t     grouping heuristics.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n-\t    {\n-\t      tree var = SSA_NAME_VAR (op);\n-\t      var_ann_t ann = var_ann (var);\n-\t      bitmap_set_bit (ai->written_vars, DECL_UID (var));\n-\t      if (may_be_aliased (var))\n-\t\tNUM_REFERENCES_INC (ann);\n-\n-\t      if (POINTER_TYPE_P (TREE_TYPE (op)))\n-\t\tcollect_points_to_info_for (ai, op);\n-\t    }\n-\n-\t  /* Mark variables in V_MAY_DEF operands as being written to.  */\n-\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_VIRTUAL_DEFS)\n-\t    {\n-\t      tree var = DECL_P (op) ? op : SSA_NAME_VAR (op);\n-\t      bitmap_set_bit (ai->written_vars, DECL_UID (var));\n-\t    }\n-\t    \n-\t  /* After promoting variables and computing aliasing we will\n-\t     need to re-scan most statements.  FIXME: Try to minimize the\n-\t     number of statements re-scanned.  It's not really necessary to\n-\t     re-scan *all* statements.  */\n-\t  mark_stmt_modified (stmt);\n-\t}\n-    }\n-\n-  timevar_pop (TV_TREE_PTA);\n+  delete_points_to_sets ();\n }\n \n \n@@ -863,16 +640,10 @@ create_name_tags (void)\n \t  if (old_name_tag && old_name_tag != pi->name_mem_tag)\n \t    mark_sym_for_renaming (old_name_tag);\n \t}\n-      else if (pi->pt_malloc)\n-\t{\n-\t  /* Otherwise, create a unique name tag for this pointer.  */\n-\t  pi->name_mem_tag = get_nmt_for (ptr);\n-\t}\n       else\n \t{\n-\t  /* Only pointers that may point to malloc or other variables\n-\t     may receive a name tag.  If the pointer does not point to\n-\t     a known spot, we should use type tags.  */\n+\t  /* If the pointer does not point to a known spot, we should\n+\t     use type tags.  */\n \t  set_pt_anything (ptr);\n \t  continue;\n \t}\n@@ -902,11 +673,8 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (ai->processed_ptrs); i++)\n     {\n       tree ptr = VARRAY_TREE (ai->processed_ptrs, i);\n-      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n-      if (pi->pt_anything || pi->pt_vars == NULL)\n-\t{\n-\t  find_what_p_points_to (ptr);\n-\t}\n+      if (!find_what_p_points_to (ptr))\n+\tset_pt_anything (ptr);\n     }\n \n   create_name_tags ();\n@@ -931,9 +699,7 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n \n \t  if (pi->pt_vars)\n \t    EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n-\t      {\n-\t\tmark_call_clobbered (referenced_var (j));\n-\t      }\n+\t      mark_call_clobbered (referenced_var (j));\n \t}\n \n       /* Set up aliasing information for PTR's name memory tag (if it has\n@@ -1009,9 +775,9 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t     So we first check the call_clobbered status of the\n \t     tag and variable before querying the bitmap.  */\n \t  tag_stored_p = is_call_clobbered (tag)\n-\t    || bitmap_bit_p (ai->written_vars, DECL_UID (tag));\n+\t                 || bitmap_bit_p (ai->written_vars, DECL_UID (tag));\n \t  var_stored_p = is_call_clobbered (var)\n-\t    || bitmap_bit_p (ai->written_vars, DECL_UID (var));\n+\t                 || bitmap_bit_p (ai->written_vars, DECL_UID (var));\n \t  if (!tag_stored_p && !var_stored_p)\n \t    continue;\n \n@@ -1126,7 +892,7 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n     }\n   \n   if (dump_file)\n-    fprintf (dump_file, \"%s: Total number of aliased vops: %ld\\n\",\n+    fprintf (dump_file, \"\\n%s: Total number of aliased vops: %ld\\n\",\n \t     get_name (current_function_decl),\n \t     ai->total_alias_vops);\n \n@@ -1458,9 +1224,9 @@ setup_pointers_and_addressables (struct alias_info *ai)\n          of ADDR_EXPR constants into INDIRECT_REF expressions and the\n          removal of dead pointer assignments done by the early scalar\n          cleanup passes.  */\n-      if (TREE_ADDRESSABLE (var) && v_ann->mem_tag_kind != STRUCT_FIELD)\n+      if (TREE_ADDRESSABLE (var))\n \t{\n-\t  if (!bitmap_bit_p (ai->addresses_needed, DECL_UID (var))\n+\t  if (!bitmap_bit_p (addressable_vars, DECL_UID (var))\n \t      && TREE_CODE (var) != RESULT_DECL\n \t      && !is_global_var (var))\n \t    {\n@@ -1470,15 +1236,17 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t\t to rename VAR into SSA afterwards.  */\n \t      mark_sym_for_renaming (var);\n \n+\t      /* If VAR can have sub-variables, and any of its\n+\t\t sub-variables has its address taken, then we cannot\n+\t\t remove the addressable flag from VAR.  */\n \t      if (var_can_have_subvars (var)\n \t\t  && (svars = get_subvars_for_var (var)))\n \t\t{\n \t\t  subvar_t sv;\n \n \t\t  for (sv = svars; sv; sv = sv->next)\n \t\t    {\t      \n-\t\t      if (bitmap_bit_p (ai->addresses_needed, \n-\t\t\t\t\tDECL_UID (sv->var)))\n+\t\t      if (bitmap_bit_p (addressable_vars, DECL_UID (sv->var)))\n \t\t\tokay_to_mark = false;\n \t\t      mark_sym_for_renaming (sv->var);\n \t\t    }\n@@ -1490,22 +1258,6 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t      if (okay_to_mark)\n \t\tmark_non_addressable (var);\n \t    }\n-\t  else\n-\t    {\n-\t      /* Add the variable to the set of addressables.  Mostly\n-\t\t used when scanning operands for ASM_EXPRs that\n-\t\t clobber memory.  In those cases, we need to clobber\n-\t\t all call-clobbered variables and all addressables.  */\n-\t      bitmap_set_bit (addressable_vars, DECL_UID (var));\n-\t      if (var_can_have_subvars (var)\n-\t\t  && (svars = get_subvars_for_var (var)))\n-\t\t{\n-\t\t  subvar_t sv;\n-\t\t  for (sv = svars; sv; sv = sv->next)\n-\t\t    bitmap_set_bit (addressable_vars, DECL_UID (sv->var));\n-\t\t}\n-\n-\t    }\n \t}\n \n       /* Global variables and addressable locals may be aliased.  Create an\n@@ -1562,10 +1314,9 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t\t references of TAG.  Since TAG can be associated with\n \t\t several pointers, add the dereferences of VAR to the\n \t\t TAG.  */\n-\n \t      NUM_REFERENCES_SET (t_ann, \n-\t\t\t\t  NUM_REFERENCES (t_ann) + \n-\t\t\t\t  NUM_REFERENCES (v_ann));\n+\t\t\t\t  NUM_REFERENCES (t_ann)\n+\t\t\t\t  + NUM_REFERENCES (v_ann));\n \t    }\n \t  else\n \t    {\n@@ -1783,8 +1534,16 @@ add_may_alias (tree var, tree alias)\n   var_ann_t v_ann = get_var_ann (var);\n   var_ann_t a_ann = get_var_ann (alias);\n \n+  /* Don't allow self-referential aliases.  */\n   gcc_assert (var != alias);\n \n+  /* ALIAS must be addressable if it's being added to an alias set.  */\n+#if 1\n+  TREE_ADDRESSABLE (alias) = 1;\n+#else\n+  gcc_assert (may_be_aliased (alias));\n+#endif\n+\n   if (v_ann->may_aliases == NULL)\n     VARRAY_TREE_INIT (v_ann->may_aliases, 2, \"aliases\");\n \n@@ -1836,7 +1595,7 @@ set_pt_anything (tree ptr)\n   struct ptr_info_def *pi = get_ptr_info (ptr);\n \n   pi->pt_anything = 1;\n-  pi->pt_malloc = 0;\n+  pi->pt_vars = NULL;\n \n   /* The pointer used to have a name tag, but we now found it pointing\n      to an arbitrary location.  The name tag needs to be renamed and\n@@ -1849,341 +1608,6 @@ set_pt_anything (tree ptr)\n }\n \n \n-/* Mark pointer PTR as pointing to a malloc'd memory area.  */\n-\n-static void\n-set_pt_malloc (tree ptr)\n-{\n-  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n-\n-  /* If the pointer has already been found to point to arbitrary\n-     memory locations, it is unsafe to mark it as pointing to malloc.  */\n-  if (pi->pt_anything)\n-    return;\n-\n-  pi->pt_malloc = 1;\n-}\n-\n-\n-/* Given two different pointers DEST and ORIG.  Merge the points-to\n-   information in ORIG into DEST.  AI contains all the alias\n-   information collected up to this point.  */\n-\n-static void\n-merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n-{\n-  struct ptr_info_def *dest_pi, *orig_pi;\n-\n-  gcc_assert (dest != orig);\n-\n-  /* Make sure we have points-to information for ORIG.  */\n-  collect_points_to_info_for (ai, orig);\n-\n-  dest_pi = get_ptr_info (dest);\n-  orig_pi = SSA_NAME_PTR_INFO (orig);\n-\n-  if (orig_pi)\n-    {\n-      gcc_assert (orig_pi != dest_pi);\n-\n-      /* Notice that we never merge PT_MALLOC.  This attribute is only\n-\t true if the pointer is the result of a malloc() call.\n-\t Otherwise, we can end up in this situation:\n-\n-\t P_i = malloc ();\n-\t ...\n-\t P_j = P_i + X;\n-\n-\t P_j would be marked as PT_MALLOC, however we currently do not\n-\t handle cases of more than one pointer pointing to the same\n-\t malloc'd area.\n-\n-\t FIXME: If the merging comes from an expression that preserves\n-\t the PT_MALLOC attribute (copy assignment, address\n-\t arithmetic), we ought to merge PT_MALLOC, but then both\n-\t pointers would end up getting different name tags because\n-\t create_name_tags is not smart enough to determine that the\n-\t two come from the same malloc call.  Copy propagation before\n-\t aliasing should cure this.  */\n-      dest_pi->pt_malloc = 0;\n-      if (orig_pi->pt_malloc || orig_pi->pt_anything)\n-\tset_pt_anything (dest);\n-\n-      dest_pi->pt_null |= orig_pi->pt_null;\n-\n-      if (!dest_pi->pt_anything\n-\t  && orig_pi->pt_vars\n-\t  && !bitmap_empty_p (orig_pi->pt_vars))\n-\t{\n-\t  if (dest_pi->pt_vars == NULL)\n-\t    {\n-\t      dest_pi->pt_vars = BITMAP_GGC_ALLOC ();\n-\t      bitmap_copy (dest_pi->pt_vars, orig_pi->pt_vars);\n-\t    }\n-\t  else\n-\t    bitmap_ior_into (dest_pi->pt_vars, orig_pi->pt_vars);\n-\t}\n-    }\n-  else\n-    set_pt_anything (dest);\n-}\n-\n-\n-/* Add EXPR to the list of expressions pointed-to by PTR.  */\n-\n-static void\n-add_pointed_to_expr (struct alias_info *ai, tree ptr, tree expr)\n-{\n-  if (TREE_CODE (expr) == WITH_SIZE_EXPR)\n-    expr = TREE_OPERAND (expr, 0);\n-\n-  get_ptr_info (ptr);\n-\n-  if (TREE_CODE (expr) == CALL_EXPR\n-      && (call_expr_flags (expr) & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n-    {\n-      /* If EXPR is a malloc-like call, then the area pointed to PTR\n-\t is guaranteed to not alias with anything else.  */\n-      set_pt_malloc (ptr);\n-    }\n-  else if (TREE_CODE (expr) == ADDR_EXPR)\n-    {\n-      /* Found P_i = ADDR_EXPR  */\n-      add_pointed_to_var (ai, ptr, expr);\n-    }\n-  else if (TREE_CODE (expr) == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (expr)))\n-    {\n-      /* Found P_i = Q_j.  */\n-      merge_pointed_to_info (ai, ptr, expr);\n-    }\n-  else if (TREE_CODE (expr) == PLUS_EXPR || TREE_CODE (expr) == MINUS_EXPR)\n-    {\n-      /* Found P_i = PLUS_EXPR or P_i = MINUS_EXPR  */\n-      tree op0 = TREE_OPERAND (expr, 0);\n-      tree op1 = TREE_OPERAND (expr, 1);\n-\n-      /* Both operands may be of pointer type.  FIXME: Shouldn't\n-\t we just expect PTR + OFFSET always?  */\n-      if (POINTER_TYPE_P (TREE_TYPE (op0))\n-\t  && TREE_CODE (op0) != INTEGER_CST)\n-\t{\n-\t  if (TREE_CODE (op0) == SSA_NAME)\n-\t    merge_pointed_to_info (ai, ptr, op0);\n-\t  else if (TREE_CODE (op0) == ADDR_EXPR)\n-\t    add_pointed_to_var (ai, ptr, op0);\n-\t  else\n-\t    set_pt_anything (ptr);\n-\t}\n-\n-      if (POINTER_TYPE_P (TREE_TYPE (op1))\n-\t  && TREE_CODE (op1) != INTEGER_CST)\n-\t{\n-\t  if (TREE_CODE (op1) == SSA_NAME)\n-\t    merge_pointed_to_info (ai, ptr, op1);\n-\t  else if (TREE_CODE (op1) == ADDR_EXPR)\n-\t    add_pointed_to_var (ai, ptr, op1);\n-\t  else\n-\t    set_pt_anything (ptr);\n-\t}\n-\n-      /* Neither operand is a pointer?  VAR can be pointing anywhere.\n-\t FIXME: Shouldn't we asserting here?  If we get here, we found\n-\t PTR = INT_CST + INT_CST, which should not be a valid pointer\n-\t expression.  */\n-      if (!(POINTER_TYPE_P (TREE_TYPE (op0))\n-\t    && TREE_CODE (op0) != INTEGER_CST)\n-\t  && !(POINTER_TYPE_P (TREE_TYPE (op1))\n-\t       && TREE_CODE (op1) != INTEGER_CST))\n-\tset_pt_anything (ptr);\n-    }\n-  else if (integer_zerop (expr))\n-    {\n-      /* EXPR is the NULL pointer.  Mark PTR as pointing to NULL.  */\n-      SSA_NAME_PTR_INFO (ptr)->pt_null = 1;\n-    }\n-  else\n-    {\n-      /* If we can't recognize the expression, assume that PTR may\n-\t point anywhere.  */\n-      set_pt_anything (ptr);\n-    }\n-}\n-\n-\n-/* If VALUE is of the form &DECL, add DECL to the set of variables\n-   pointed-to by PTR.  Otherwise, add VALUE as a pointed-to expression by\n-   PTR.  AI points to the collected alias information.  */\n-\n-static void\n-add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n-{\n-  struct ptr_info_def *pi = get_ptr_info (ptr);\n-  tree pt_var = NULL_TREE;\n-  HOST_WIDE_INT offset, size;\n-  tree addrop;\n-  size_t uid;\n-  tree ref;\n-  subvar_t svars;\n-\n-  gcc_assert (TREE_CODE (value) == ADDR_EXPR);\n-\n-  addrop = TREE_OPERAND (value, 0);\n-  if (REFERENCE_CLASS_P (addrop))\n-    pt_var = get_base_address (addrop);\n-  else \n-    pt_var = addrop;\n-\n-  /* If this is a component_ref, see if we can get a smaller number of\n-     variables to take the address of.  */\n-  if (TREE_CODE (addrop) == COMPONENT_REF\n-      && (ref = okay_component_ref_for_subvars (addrop, &offset ,&size)))\n-    {    \n-      subvar_t sv;\n-      svars = get_subvars_for_var (ref);\n-\n-      uid = DECL_UID (pt_var);\n-      \n-      if (pi->pt_vars == NULL)\n-\tpi->pt_vars = BITMAP_GGC_ALLOC ();\n-       /* If the variable is a global, mark the pointer as pointing to\n-\t global memory (which will make its tag a global variable).  */\n-      if (is_global_var (pt_var))\n-\tpi->pt_global_mem = 1;     \n-\n-      for (sv = svars; sv; sv = sv->next)\n-\t{\n-\t  if (overlap_subvar (offset, size, sv, NULL))\n-\t    {\n-\t      bitmap_set_bit (pi->pt_vars, DECL_UID (sv->var));\n-\t      bitmap_set_bit (ai->addresses_needed, DECL_UID (sv->var));\n-\t    }\n-\t}\n-    }\n-  else if (pt_var && SSA_VAR_P (pt_var))\n-    {\n-    \n-      uid = DECL_UID (pt_var);\n-      \n-      if (pi->pt_vars == NULL)\n-\tpi->pt_vars = BITMAP_GGC_ALLOC ();\n-\n-      /* If this is an aggregate, we may have subvariables for it that need\n-\t to be pointed to.  */\n-      if (var_can_have_subvars (pt_var)\n-\t  && (svars = get_subvars_for_var (pt_var)))\n-\t{\n-\t  subvar_t sv;\n-\t  for (sv = svars; sv; sv = sv->next)\n-\t    {\n-\t      uid = DECL_UID (sv->var);\n-\t      bitmap_set_bit (ai->addresses_needed, uid);\t      \n-\t      bitmap_set_bit (pi->pt_vars, uid);\n-\t    }\n-\t}\n-      else\t\n-\t{\n-\t  bitmap_set_bit (ai->addresses_needed, uid);\n-\t  bitmap_set_bit (pi->pt_vars, uid);\t  \n-\t}\n-\n-      /* If the variable is a global, mark the pointer as pointing to\n-\t global memory (which will make its tag a global variable).  */\n-      if (is_global_var (pt_var))\n-\tpi->pt_global_mem = 1;\n-    }\n-}\n-\n-\n-/* Callback for walk_use_def_chains to gather points-to information from the\n-   SSA web.\n-   \n-   VAR is an SSA variable or a GIMPLE expression.\n-   \n-   STMT is the statement that generates the SSA variable or, if STMT is a\n-      PHI_NODE, VAR is one of the PHI arguments.\n-\n-   DATA is a pointer to a structure of type ALIAS_INFO.  */\n-\n-static bool\n-collect_points_to_info_r (tree var, tree stmt, void *data)\n-{\n-  struct alias_info *ai = (struct alias_info *) data;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Visiting use-def links for \");\n-      print_generic_expr (dump_file, var, dump_flags);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  switch (TREE_CODE (stmt))\n-    {\n-    case RETURN_EXPR:\n-      gcc_assert (TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR);\n-      stmt = TREE_OPERAND (stmt, 0);\n-      /* FALLTHRU  */\n-\n-    case MODIFY_EXPR:\n-      {\n-\ttree rhs = TREE_OPERAND (stmt, 1);\n-\tSTRIP_NOPS (rhs);\n-\tadd_pointed_to_expr (ai, var, rhs);\n-\tbreak;\n-      }\n-\n-    case ASM_EXPR:\n-      /* Pointers defined by __asm__ statements can point anywhere.  */\n-      set_pt_anything (var);\n-      break;\n-\n-    case NOP_EXPR:\n-      if (IS_EMPTY_STMT (stmt))\n-\t{\n-\t  tree decl = SSA_NAME_VAR (var);\n-\t  \n-\t  if (TREE_CODE (decl) == PARM_DECL)\n-\t    add_pointed_to_expr (ai, var, decl);\n-\t  else if (DECL_INITIAL (decl))\n-\t    add_pointed_to_expr (ai, var, DECL_INITIAL (decl));\n-\t  else\n-\t    add_pointed_to_expr (ai, var, decl);\n-\t}\n-      break;\n-\n-    case PHI_NODE:\n-      {\n-        /* It STMT is a PHI node, then VAR is one of its arguments.  The\n-\t   variable that we are analyzing is the LHS of the PHI node.  */\n-\ttree lhs = PHI_RESULT (stmt);\n-\n-\tswitch (TREE_CODE (var))\n-\t  {\n-\t  case ADDR_EXPR:\n-\t    add_pointed_to_var (ai, lhs, var);\n-\t    break;\n-\t    \n-\t  case SSA_NAME:\n-\t    /* Avoid unnecessary merges.  */\n-\t    if (lhs != var)\n-\t      merge_pointed_to_info (ai, lhs, var);\n-\t    break;\n-\t    \n-\t  default:\n-\t    gcc_assert (is_gimple_min_invariant (var));\n-\t    add_pointed_to_expr (ai, lhs, var);\n-\t    break;\n-\t  }\n-\tbreak;\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-  \n-  return false;\n-}\n-\n-\n /* Return true if STMT is an \"escape\" site from the current function.  Escape\n    sites those statements which might expose the address of a variable\n    outside the current function.  STMT is an escape site iff:\n@@ -2195,7 +1619,7 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n \n    AI points to the alias information collected so far.  */\n \n-static bool\n+bool\n is_escape_site (tree stmt, struct alias_info *ai)\n {\n   tree call = get_call_expr_in (stmt);\n@@ -2271,9 +1695,7 @@ create_memory_tag (tree type, bool is_type_tag)\n      determine whether they should be considered globals.  */\n   DECL_CONTEXT (tag) = current_function_decl;\n \n-  /* Memory tags are by definition addressable.  This also prevents\n-     is_gimple_ref frome confusing memory tags with optimizable\n-     variables.  */\n+  /* Memory tags are by definition addressable.  */\n   TREE_ADDRESSABLE (tag) = 1;\n \n   ann = get_var_ann (tag);\n@@ -2304,7 +1726,6 @@ get_nmt_for (tree ptr)\n   /* If PTR is a PARM_DECL, it points to a global variable or malloc,\n      then its name tag should be considered a global variable.  */\n   if (TREE_CODE (SSA_NAME_VAR (ptr)) == PARM_DECL\n-      || pi->pt_malloc\n       || pi->pt_global_mem)\n     mark_call_clobbered (tag);\n \n@@ -2560,9 +1981,6 @@ dump_points_to_info_for (FILE *file, tree ptr)\n       if (pi->pt_anything)\n \tfprintf (file, \", points-to anything\");\n \n-      if (pi->pt_malloc)\n-\tfprintf (file, \", points-to malloc\");\n-\n       if (pi->pt_null)\n \tfprintf (file, \", points-to NULL\");\n \n@@ -2978,6 +2396,33 @@ get_or_create_used_part_for (size_t uid)\n }\n \n \n+/* Create and return a structure sub-variable for field FIELD of\n+   variable VAR.  */\n+\n+static tree\n+create_sft (tree var, tree field)\n+{\n+  var_ann_t ann;\n+  tree subvar = create_tmp_var_raw (TREE_TYPE (field), \"SFT\");\n+\n+  /* We need to copy the various flags from VAR to SUBVAR, so that\n+     they are is_global_var iff the original variable was.  */\n+  DECL_CONTEXT (subvar) = DECL_CONTEXT (var);\n+  DECL_EXTERNAL (subvar) = DECL_EXTERNAL (var);\n+  TREE_PUBLIC  (subvar) = TREE_PUBLIC (var);\n+  TREE_STATIC (subvar) = TREE_STATIC (var);\n+  TREE_READONLY (subvar) = TREE_READONLY (var);\n+\n+  /* Add the new variable to REFERENCED_VARS.  */\n+  ann = get_var_ann (subvar);\n+  ann->mem_tag_kind = STRUCT_FIELD; \n+  ann->type_mem_tag = NULL;  \t\n+  add_referenced_tmp_var (subvar);\n+\n+  return subvar;\n+}\n+\n+\n /* Given an aggregate VAR, create the subvariables that represent its\n    fields.  */\n \n@@ -3067,7 +2512,6 @@ create_overlap_variables_for (tree var)\n \t{\n \t  subvar_t sv;\n \t  HOST_WIDE_INT fosize;\n-\t  var_ann_t ann;\n \t  tree currfotype;\n \n \t  fosize = TREE_INT_CST_LOW (DECL_SIZE (fo->field));\n@@ -3088,7 +2532,8 @@ create_overlap_variables_for (tree var)\n \t  sv->offset = fo->offset;\n \t  sv->size = fosize;\n \t  sv->next = *subvars;\n-\t  sv->var = create_tmp_var_raw (TREE_TYPE (fo->field), \"SFT\");\n+\t  sv->var = create_sft (var, fo->field);\n+\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"structure field tag %s created for var %s\",\n@@ -3100,25 +2545,6 @@ create_overlap_variables_for (tree var)\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  \n-\t  /* We need to copy the various flags from var to sv->var, so that\n-\t     they are is_global_var iff the original variable was.  */\n-\n-\t  DECL_EXTERNAL (sv->var) = DECL_EXTERNAL (var);\n-\t  TREE_PUBLIC  (sv->var) = TREE_PUBLIC (var);\n-\t  TREE_STATIC (sv->var) = TREE_STATIC (var);\n-\t  TREE_READONLY (sv->var) = TREE_READONLY (var);\n-\n-\t  /* Like other memory tags, these need to be marked addressable to\n-\t     keep is_gimple_reg from thinking they are real.  */\n-\t  TREE_ADDRESSABLE (sv->var) = 1;\n-\n-\t  DECL_CONTEXT (sv->var) = DECL_CONTEXT (var);\n-\n-\t  ann = get_var_ann (sv->var);\n-\t  ann->mem_tag_kind = STRUCT_FIELD; \n-\t  ann->type_mem_tag = NULL;  \t\n-\t  add_referenced_tmp_var (sv->var);\n-\t  \n \t  lastfotype = currfotype;\n \t  lastfooffset = fo->offset;\n \t  lastfosize = fosize;"}, {"sha": "28b19d945e48e8dbe947a4a0fb214fd610b3e88c", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -188,40 +188,51 @@ merge_alias_info (tree orig, tree new)\n #endif\n \n   /* Synchronize the type tags.  If both pointers had a tag and they\n-     are different, then something has gone wrong.  */\n+     are different, then something has gone wrong.  Type tags can\n+     always be merged because they are flow insensitive, all the SSA\n+     names of the same base DECL share the same type tag.  */\n   if (new_ann->type_mem_tag == NULL_TREE)\n     new_ann->type_mem_tag = orig_ann->type_mem_tag;\n   else if (orig_ann->type_mem_tag == NULL_TREE)\n     orig_ann->type_mem_tag = new_ann->type_mem_tag;\n   else\n     gcc_assert (new_ann->type_mem_tag == orig_ann->type_mem_tag);\n \n-  /* Synchronize the name tags.  If NEW did not have a name tag, get\n-     it from ORIG.  This happens when NEW is a compiler generated\n-     temporary which still hasn't had its points-to information filled\n-     in.  */\n-  if (SSA_NAME_PTR_INFO (orig))\n+  /* Check that flow-sensitive information is compatible.  Notice that\n+     we may not merge flow-sensitive information here.  This function\n+     is called when propagating equivalences dictated by the IL, like\n+     a copy operation P_i = Q_j, and from equivalences dictated by\n+     control-flow, like if (P_i == Q_j).\n+     \n+     In the former case, P_i and Q_j are equivalent in every block\n+     dominated by the assignment, so their flow-sensitive information\n+     is always the same.  However, in the latter case, the pointers\n+     P_i and Q_j are only equivalent in one of the sub-graphs out of\n+     the predicate, so their flow-sensitive information is not the\n+     same in every block dominated by the predicate.\n+\n+     Since we cannot distinguish one case from another in this\n+     function, we can only make sure that if P_i and Q_j have\n+     flow-sensitive information, they should be compatible.  */\n+  if (SSA_NAME_PTR_INFO (orig) && SSA_NAME_PTR_INFO (new))\n     {\n       struct ptr_info_def *orig_ptr_info = SSA_NAME_PTR_INFO (orig);\n       struct ptr_info_def *new_ptr_info = SSA_NAME_PTR_INFO (new);\n \n-      if (new_ptr_info == NULL)\n-\tduplicate_ssa_name_ptr_info (new, orig_ptr_info);\n-      else if (orig_ptr_info->name_mem_tag\n-\t       && new_ptr_info->name_mem_tag\n-\t       && orig_ptr_info->pt_vars\n-\t       && new_ptr_info->pt_vars)\n-\t{\n-\t  /* Note that pointer NEW may actually have a different set\n-\t     of pointed-to variables.  However, since NEW is being\n-\t     copy-propagated into ORIG, it must always be true that\n-\t     the pointed-to set for pointer NEW is the same, or a\n-\t     subset, of the pointed-to set for pointer ORIG.  If this\n-\t     isn't the case, we shouldn't have been able to do the\n-\t     propagation of NEW into ORIG.  */\n-\t  gcc_assert (bitmap_intersect_p (new_ptr_info->pt_vars,\n-\t\torig_ptr_info->pt_vars));\n-\t}\n+      /* Note that pointer NEW and ORIG may actually have different\n+\t pointed-to variables (e.g., PR 18291 represented in\n+\t testsuite/gcc.c-torture/compile/pr18291.c).  However, since\n+\t NEW is being copy-propagated into ORIG, it must always be\n+\t true that the pointed-to set for pointer NEW is the same, or\n+\t a subset, of the pointed-to set for pointer ORIG.  If this\n+\t isn't the case, we shouldn't have been able to do the\n+\t propagation of NEW into ORIG.  */\n+      if (orig_ptr_info->name_mem_tag\n+\t  && new_ptr_info->name_mem_tag\n+\t  && orig_ptr_info->pt_vars\n+\t  && new_ptr_info->pt_vars)\n+\tgcc_assert (bitmap_intersect_p (new_ptr_info->pt_vars,\n+\t\t\t\t\torig_ptr_info->pt_vars));\n     }\n }   \n "}, {"sha": "34c09925174a4e5dac0822a04697aa7fcbf6cea1", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -32,7 +32,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"ggc.h\"\n #include \"timevar.h\"\n #include \"toplev.h\"\n-\n #include \"langhooks.h\"\n \n /* This file contains the code required to manage the operands cache of the \n@@ -148,7 +147,6 @@ static bool ops_active = false;\n static GTY (()) struct ssa_operand_memory_d *operand_memory = NULL;\n static unsigned operand_memory_index;\n \n-static void note_addressable (tree, stmt_ann_t);\n static void get_expr_operands (tree, tree *, int);\n static void get_asm_expr_operands (tree);\n static void get_indirect_ref_operands (tree, tree, int);\n@@ -1310,7 +1308,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case IMAGPART_EXPR:\n       {\n \ttree ref;\n-\tHOST_WIDE_INT offset, size;\n+\tunsigned HOST_WIDE_INT offset, size;\n  \t/* This component ref becomes an access to all of the subvariables\n \t   it can touch,  if we can determine that, but *NOT* the real one.\n \t   If we can't determine which fields we could touch, the recursion\n@@ -1515,8 +1513,8 @@ get_asm_expr_operands (tree stmt)\n       if (!allows_reg && allows_mem)\n \t{\n \t  tree t = get_base_address (TREE_VALUE (link));\n-\t  if (t && DECL_P (t))\n-\t    note_addressable (t, s_ann);\n+\t  if (t && DECL_P (t) && s_ann)\n+\t    add_to_addressable_set (t, &s_ann->addresses_taken);\n \t}\n \n       get_expr_operands (stmt, &TREE_VALUE (link), opf_is_def);\n@@ -1534,8 +1532,8 @@ get_asm_expr_operands (tree stmt)\n       if (!allows_reg && allows_mem)\n \t{\n \t  tree t = get_base_address (TREE_VALUE (link));\n-\t  if (t && DECL_P (t))\n-\t    note_addressable (t, s_ann);\n+\t  if (t && DECL_P (t) && s_ann)\n+\t    add_to_addressable_set (t, &s_ann->addresses_taken);\n \t}\n \n       get_expr_operands (stmt, &TREE_VALUE (link), 0);\n@@ -1688,7 +1686,10 @@ get_tmr_operands (tree stmt, tree expr, int flags)\n   flags &= ~opf_kill_def;\n \n   if (TMR_SYMBOL (expr))\n-    note_addressable (TMR_SYMBOL (expr), stmt_ann (stmt));\n+    {\n+      stmt_ann_t ann = stmt_ann (stmt);\n+      add_to_addressable_set (TMR_SYMBOL (expr), &ann->addresses_taken);\n+    }\n \n   if (tag)\n     add_stmt_operand (&tag, stmt_ann (stmt), flags);\n@@ -1757,9 +1758,9 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \n   /* If the operand is an ADDR_EXPR, add its operand to the list of\n      variables that have had their address taken in this statement.  */\n-  if (TREE_CODE (var) == ADDR_EXPR)\n+  if (TREE_CODE (var) == ADDR_EXPR && s_ann)\n     {\n-      note_addressable (TREE_OPERAND (var, 0), s_ann);\n+      add_to_addressable_set (TREE_OPERAND (var, 0), &s_ann->addresses_taken);\n       return;\n     }\n \n@@ -1861,35 +1862,17 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \n \t  if (flags & opf_is_def)\n \t    {\n-\t      bool added_may_defs_p = false;\n-\n \t      /* If the variable is also an alias tag, add a virtual\n \t\t operand for it, otherwise we will miss representing\n \t\t references to the members of the variable's alias set.\n \t\t This fixes the bug in gcc.c-torture/execute/20020503-1.c.  */\n \t      if (v_ann->is_alias_tag)\n-\t\t{\n-\t\t  added_may_defs_p = true;\n-\t\t  append_v_may_def (var);\n-\t\t}\n+\t\tappend_v_may_def (var);\n \n \t      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t\t{\n-\t\t  /* While VAR may be modifiable, some of its aliases\n-\t\t     may not be.  If that's the case, we don't really\n-\t\t     need to add them a V_MAY_DEF for them.  */\n-\t\t  tree alias = VARRAY_TREE (aliases, i);\n-\n-\t\t  if (unmodifiable_var_p (alias))\n-\t\t    append_vuse (alias);\n-\t\t  else\n-\t\t    {\n-\t\t      append_v_may_def (alias);\n-\t\t      added_may_defs_p = true;\n-\t\t    }\n-\t\t}\n+\t\tappend_v_may_def (VARRAY_TREE (aliases, i));\n \n-\t      if (s_ann && added_may_defs_p)\n+\t      if (s_ann)\n \t\ts_ann->makes_aliased_stores = 1;\n \t    }\n \t  else\n@@ -1910,40 +1893,51 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n }\n \n   \n-/* Record that VAR had its address taken in the statement with annotations\n-   S_ANN.  */\n+/* Add the base address of REF to the set *ADDRESSES_TAKEN.  If\n+   *ADDRESSES_TAKEN is NULL, a new set is created.  REF may be\n+   a single variable whose address has been taken or any other valid\n+   GIMPLE memory reference (structure reference, array, etc).  If the\n+   base address of REF is a decl that has sub-variables, also add all\n+   of its sub-variables.  */\n \n-static void\n-note_addressable (tree var, stmt_ann_t s_ann)\n+void\n+add_to_addressable_set (tree ref, bitmap *addresses_taken)\n {\n+  tree var;\n   subvar_t svars;\n \n-  if (!s_ann)\n-    return;\n-  \n+  gcc_assert (addresses_taken);\n+\n   /* Note that it is *NOT OKAY* to use the target of a COMPONENT_REF\n-     as the only thing we take the address of.\n-     See PR 21407 and the ensuing mailing list discussion.  */\n-  \n-  var = get_base_address (var);\n+     as the only thing we take the address of.  If VAR is a structure,\n+     taking the address of a field means that the whole structure may\n+     be referenced using pointer arithmetic.  See PR 21407 and the\n+     ensuing mailing list discussion.  */\n+  var = get_base_address (ref);\n   if (var && SSA_VAR_P (var))\n     {\n-      if (s_ann->addresses_taken == NULL)\n-\ts_ann->addresses_taken = BITMAP_GGC_ALLOC ();      \n+      if (*addresses_taken == NULL)\n+\t*addresses_taken = BITMAP_GGC_ALLOC ();      \n       \n-\n       if (var_can_have_subvars (var)\n \t  && (svars = get_subvars_for_var (var)))\n \t{\n \t  subvar_t sv;\n \t  for (sv = svars; sv; sv = sv->next)\n-\t    bitmap_set_bit (s_ann->addresses_taken, DECL_UID (sv->var));\n+\t    {\n+\t      bitmap_set_bit (*addresses_taken, DECL_UID (sv->var));\n+\t      TREE_ADDRESSABLE (sv->var) = 1;\n+\t    }\n \t}\n       else\n-\tbitmap_set_bit (s_ann->addresses_taken, DECL_UID (var));\n+\t{\n+\t  bitmap_set_bit (*addresses_taken, DECL_UID (var));\n+\t  TREE_ADDRESSABLE (var) = 1;\n+\t}\n     }\n }\n \n+\n /* Add clobbering definitions for .GLOBAL_VAR or for each of the call\n    clobbered variables in the function.  */\n "}, {"sha": "c1ec3650ee100aca26577add5c06025e31070f10", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -170,6 +170,8 @@ extern bool ssa_ro_call_cache_valid;\n \n extern bool ssa_operands_active (void);\n \n+extern void add_to_addressable_set (tree, bitmap *);\n+\n enum ssa_op_iter_type {\n   ssa_op_iter_none = 0,\n   ssa_op_iter_tree,"}, {"sha": "7ec5270ad7734941ba1a9f18ac86f7e196400f0e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 449, "deletions": 201, "changes": 650, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -26,7 +26,6 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n #include \"ggc.h\"\n #include \"obstack.h\"\n #include \"bitmap.h\"\n-#include \"tree-ssa-structalias.h\"\n #include \"flags.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n@@ -49,6 +48,7 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n #include \"timevar.h\"\n #include \"alloc-pool.h\"\n #include \"splay-tree.h\"\n+#include \"tree-ssa-structalias.h\"\n \n /* The idea behind this analyzer is to generate set constraints from the\n    program, then solve the resulting constraints in order to generate the\n@@ -223,6 +223,9 @@ struct variable_info\n   /* True for variables that have unions somewhere in them.  */\n   unsigned int has_union:1;\n \n+  /* True if this is a heap variable.  */\n+  unsigned int is_heap_var:1;\n+\n   /* Points-to set for this variable.  */\n   bitmap solution;\n \n@@ -270,6 +273,12 @@ static varinfo_t var_integer;\n static tree integer_tree;\n static unsigned int integer_id;\n \n+/* Variable that represents arbitrary offsets into an object.  Used to\n+   represent pointer arithmetic, which may not legally escape the\n+   bounds of an object.  */\n+static varinfo_t var_anyoffset;\n+static tree anyoffset_tree;\n+static unsigned int anyoffset_id;\n \n /* Return a new variable info structure consisting for a variable\n    named NAME, and using constraint graph node NODE.  */\n@@ -286,6 +295,7 @@ new_var_info (tree t, unsigned int id, const char *name, unsigned int node)\n   ret->address_taken = false;\n   ret->indirect_target = false;\n   ret->is_artificial_var = false;\n+  ret->is_heap_var = false;\n   ret->is_unknown_size_var = false;\n   ret->solution = BITMAP_ALLOC (&ptabitmap_obstack);\n   bitmap_clear (ret->solution);\n@@ -941,8 +951,11 @@ build_constraint_graph (void)\n   constraint_t c;\n \n   graph = ggc_alloc (sizeof (struct constraint_graph));\n-  graph->succs = ggc_alloc_cleared (VEC_length (varinfo_t, varmap) * sizeof (*graph->succs));\n-  graph->preds = ggc_alloc_cleared (VEC_length (varinfo_t, varmap) * sizeof (*graph->preds));\n+  graph->succs = ggc_alloc_cleared (VEC_length (varinfo_t, varmap)\n+                                    * sizeof (*graph->succs));\n+  graph->preds = ggc_alloc_cleared (VEC_length (varinfo_t, varmap)\n+                                    * sizeof (*graph->preds));\n+\n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n     {\n       struct constraint_expr lhs = c->lhs;\n@@ -983,6 +996,8 @@ build_constraint_graph (void)\n \t}\n     }\n }\n+\n+\n /* Changed variables on the last iteration.  */\n static unsigned int changed_count;\n static sbitmap changed;\n@@ -2137,11 +2152,18 @@ get_constraint_for (tree t)\n \t       &ANYTHING added.  */\n \t    if (call_expr_flags (t) & (ECF_MALLOC | ECF_MAY_BE_ALLOCA))\n \t      {\n-\t\ttree heapvar = create_tmp_var_raw (ptr_type_node, \"HEAP\");\n+\t\tvarinfo_t vi;\n+\t\ttree heapvar;\n+\t\t\n+\t\theapvar = create_tmp_var_raw (ptr_type_node, \"HEAP\");\n+\t\tDECL_EXTERNAL (heapvar) = 1;\n+\t\tadd_referenced_tmp_var (heapvar);\n \t\ttemp.var = create_variable_info_for (heapvar,\n \t\t\t\t\t\t     alias_get_name (heapvar));\n \t\t\n-\t\tget_varinfo (temp.var)->is_artificial_var = 1;\n+\t\tvi = get_varinfo (temp.var);\n+\t\tvi->is_artificial_var = 1;\n+\t\tvi->is_heap_var = 1;\n \t\ttemp.type = ADDRESSOF;\n \t\ttemp.offset = 0;\n \t\treturn temp;\n@@ -2191,9 +2213,11 @@ get_constraint_for (tree t)\n \t      \n \t      /* Cast from non-pointer to pointers are bad news for us.\n \t\t Anything else, we see through */\n-\t      if (!(POINTER_TYPE_P (TREE_TYPE (t))  &&\n-\t\t    ! POINTER_TYPE_P (TREE_TYPE (op))))\n+\t      if (!(POINTER_TYPE_P (TREE_TYPE (t))\n+\t\t    && ! POINTER_TYPE_P (TREE_TYPE (op))))\n \t\treturn get_constraint_for (op);\n+\n+\t      /* FALLTHRU  */\n \t    }\n \t  default:\n \t    {\n@@ -2467,97 +2491,317 @@ ref_contains_indirect_ref (tree ref)\n }\n \n \n-/*  Tree walker that is the heart of the aliasing infrastructure.\n-    TP is a pointer to the current tree.\n-    WALK_SUBTREES specifies whether to continue traversing subtrees or\n-    not.\n-    Returns NULL_TREE when we should stop.\n-    \n-    This function is the main part of the constraint builder. It\n-    walks the trees, calling the appropriate building functions\n-    to process various statements.  */\n+/* Update related alias information kept in AI.  This is used when\n+   building name tags, alias sets and deciding grouping heuristics.\n+   STMT is the statement to process.  This function also updates\n+   ADDRESSABLE_VARS.  */\n+\n+static void\n+update_alias_info (tree stmt, struct alias_info *ai)\n+{\n+  bitmap addr_taken;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n+  bool stmt_escapes_p = is_escape_site (stmt, ai);\n+\n+  /* Mark all the variables whose address are taken by the statement.  */\n+  addr_taken = addresses_taken (stmt);\n+  if (addr_taken)\n+    {\n+      bitmap_ior_into (addressable_vars, addr_taken);\n+\n+      /* If STMT is an escape point, all the addresses taken by it are\n+\t call-clobbered.  */\n+      if (stmt_escapes_p)\n+\t{\n+\t  bitmap_iterator bi;\n+\t  unsigned i;\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP (addr_taken, 0, i, bi)\n+\t    mark_call_clobbered (referenced_var (i));\n+\t}\n+    }\n+\n+  /* Process each operand use.  If an operand may be aliased, keep\n+     track of how many times it's being used.  For pointers, determine\n+     whether they are dereferenced by the statement, or whether their\n+     value escapes, etc.  */\n+  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n+    {\n+      tree op, var;\n+      var_ann_t v_ann;\n+      struct ptr_info_def *pi;\n+      bool is_store;\n+      unsigned num_uses, num_derefs;\n+\n+      op = USE_FROM_PTR (use_p);\n+\n+      /* If STMT is a PHI node, OP may be an ADDR_EXPR.  If so, add it\n+\t to the set of addressable variables.  */\n+      if (TREE_CODE (op) == ADDR_EXPR)\n+\t{\n+\t  gcc_assert (TREE_CODE (stmt) == PHI_NODE);\n+\n+\t  /* PHI nodes don't have annotations for pinning the set\n+\t     of addresses taken, so we collect them here.\n+\n+\t     FIXME, should we allow PHI nodes to have annotations\n+\t     so that they can be treated like regular statements?\n+\t     Currently, they are treated as second-class\n+\t     statements.  */\n+\t  add_to_addressable_set (TREE_OPERAND (op, 0), &addressable_vars);\n+\t  continue;\n+\t}\n+\n+      /* Ignore constants.  */\n+      if (TREE_CODE (op) != SSA_NAME)\n+\tcontinue;\n+\n+      var = SSA_NAME_VAR (op);\n+      v_ann = var_ann (var);\n+\n+      /* If the operand's variable may be aliased, keep track of how\n+\t many times we've referenced it.  This is used for alias\n+\t grouping in compute_flow_insensitive_aliasing.  */\n+      if (may_be_aliased (var))\n+\tNUM_REFERENCES_INC (v_ann);\n+\n+      /* We are only interested in pointers.  */\n+      if (!POINTER_TYPE_P (TREE_TYPE (op)))\n+\tcontinue;\n+\n+      pi = get_ptr_info (op);\n+\n+      /* Add OP to AI->PROCESSED_PTRS, if it's not there already.  */\n+      if (!TEST_BIT (ai->ssa_names_visited, SSA_NAME_VERSION (op)))\n+\t{\n+\t  SET_BIT (ai->ssa_names_visited, SSA_NAME_VERSION (op));\n+\t  VARRAY_PUSH_TREE (ai->processed_ptrs, op);\n+\t}\n+\n+      /* If STMT is a PHI node, then it will not have pointer\n+\t dereferences and it will not be an escape point.  */\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\tcontinue;\n+\n+      /* Determine whether OP is a dereferenced pointer, and if STMT\n+\t is an escape point, whether OP escapes.  */\n+      count_uses_and_derefs (op, stmt, &num_uses, &num_derefs, &is_store);\n+\n+      if (num_derefs > 0)\n+\t{\n+\t  /* Mark OP as dereferenced.  In a subsequent pass,\n+\t     dereferenced pointers that point to a set of\n+\t     variables will be assigned a name tag to alias\n+\t     all the variables OP points to.  */\n+\t  pi->is_dereferenced = 1;\n+\n+\t  /* Keep track of how many time we've dereferenced each\n+\t     pointer.  */\n+\t  NUM_REFERENCES_INC (v_ann);\n+\n+\t  /* If this is a store operation, mark OP as being\n+\t     dereferenced to store, otherwise mark it as being\n+\t     dereferenced to load.  */\n+\t  if (is_store)\n+\t    bitmap_set_bit (ai->dereferenced_ptrs_store, DECL_UID (var));\n+\t  else\n+\t    bitmap_set_bit (ai->dereferenced_ptrs_load, DECL_UID (var));\n+\t}\n+\n+      if (stmt_escapes_p && num_derefs < num_uses)\n+\t{\n+\t  /* If STMT is an escape point and STMT contains at\n+\t     least one direct use of OP, then the value of OP\n+\t     escapes and so the pointed-to variables need to\n+\t     be marked call-clobbered.  */\n+\t  pi->value_escapes_p = 1;\n+\n+\t  /* If the statement makes a function call, assume\n+\t     that pointer OP will be dereferenced in a store\n+\t     operation inside the called function.  */\n+\t  if (get_call_expr_in (stmt))\n+\t    {\n+\t      bitmap_set_bit (ai->dereferenced_ptrs_store, DECL_UID (var));\n+\t      pi->is_dereferenced = 1;\n+\t    }\n+\t}\n+    }\n+\n+  /* Update reference counter for definitions to any potentially\n+     aliased variable.  This is used in the alias grouping heuristics.  */\n+  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt, iter, SSA_OP_ALL_DEFS)\n+    {\n+      tree op = DEF_FROM_PTR (def_p);\n+      tree var = SSA_NAME_VAR (op);\n+      var_ann_t ann = var_ann (var);\n+      bitmap_set_bit (ai->written_vars, DECL_UID (var));\n+      if (may_be_aliased (var))\n+\tNUM_REFERENCES_INC (ann);\n+    }\n+}\n+\n+\n+/* Handle pointer arithmetic EXPR when creating aliasing constraints.\n+   Expressions of the type PTR + CST can be handled in two ways:\n+\n+   1- If the constraint for PTR is ADDRESSOF for a non-structure\n+      variable, then we can use it directly because adding or\n+      subtracting a constant may not alter the original ADDRESSOF\n+      constraing (i.e., pointer arithmetic may not legally go outside\n+      an object's boundaries).\n+\n+   2- If the constraint for PTR is ADDRESSOF for a structure variable,\n+      then if CST is a compile-time constant that can be used as an\n+      offset, we can determine which sub-variable will be pointed-to\n+      by the expression.\n+\n+   Return true if the expression is handled.  For any other kind of\n+   expression, return false so that each operand can be added as a\n+   separate constraint by the caller.  */\n+\n+static bool\n+handle_ptr_arith (struct constraint_expr lhs, tree expr)\n+{\n+  tree op0, op1;\n+  struct constraint_expr base, offset;\n+\n+  if (TREE_CODE (expr) != PLUS_EXPR)\n+    return false;\n+\n+  op0 = TREE_OPERAND (expr, 0);\n+  op1 = TREE_OPERAND (expr, 1);\n+\n+  base = get_constraint_for (op0);\n+\n+  offset.var = anyoffset_id;\n+  offset.type = ADDRESSOF;\n+  offset.offset = 0;\n+\n+  process_constraint (new_constraint (lhs, base));\n+  process_constraint (new_constraint (lhs, offset));\n+\n+  return true;\n+}\n+\n+\n+/* Walk statement T setting up aliasing constraints according to the\n+   references found in T.  This function is the main part of the\n+   constraint builder.  AI points to auxiliary alias information used\n+   when building alias sets and computing alias grouping heuristics.  */\n \n static void\n-find_func_aliases (tree t)\n+find_func_aliases (tree t, struct alias_info *ai)\n {\n   struct constraint_expr lhs, rhs;\n-  switch (TREE_CODE (t))\n-    {      \n-    case PHI_NODE:\n-      {\n-\tint i;\n \n-\t/* Only care about pointers and structures containing\n-\t   pointers.  */\n-\tif (POINTER_TYPE_P (TREE_TYPE (PHI_RESULT (t)))\n-\t    || AGGREGATE_TYPE_P (TREE_TYPE (PHI_RESULT (t))))\n-\t  {\n-\t    lhs = get_constraint_for (PHI_RESULT (t));\n-\t    for (i = 0; i < PHI_NUM_ARGS (t); i++)\n-\t      {\n-\t\trhs = get_constraint_for (PHI_ARG_DEF (t, i));\n-\t\tprocess_constraint (new_constraint (lhs, rhs));\n-\t      }\n-\t  }\n-      }\n-      break;\n+  /* Update various related attributes like escaped addresses, pointer\n+     dereferences for loads and stores.  This is used when creating\n+     name tags and alias sets.  */\n+  update_alias_info (t, ai);\n \n-    case MODIFY_EXPR:\n-      {\n-\ttree lhsop = TREE_OPERAND (t, 0);\n-\ttree rhsop = TREE_OPERAND (t, 1);\n-\tint i;\t\n+  /* Now build constraints expressions.  */\n+  if (TREE_CODE (t) == PHI_NODE)\n+    {\n+      /* Only care about pointers and structures containing\n+\t pointers.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (PHI_RESULT (t)))\n+\t  || AGGREGATE_TYPE_P (TREE_TYPE (PHI_RESULT (t))))\n+\t{\n+\t  int i;\n \n-\tif (AGGREGATE_TYPE_P (TREE_TYPE (lhsop)) \n-\t    && AGGREGATE_TYPE_P (TREE_TYPE (rhsop)))\n-\t  {\n-\t    do_structure_copy (lhsop, rhsop);\n-\t  }\n-\telse\n-\t  {\n-\t    /* Only care about operations with pointers, structures\n-\t       containing pointers, dereferences, and call\n-\t       expressions.  */\n-\t    if (POINTER_TYPE_P (TREE_TYPE (lhsop))\n-\t\t|| AGGREGATE_TYPE_P (TREE_TYPE (lhsop))\n-\t\t|| ref_contains_indirect_ref (lhsop)\n-\t\t|| TREE_CODE (rhsop) == CALL_EXPR)\n-\t      {\n-\t\tlhs = get_constraint_for (lhsop);\n-\t\tswitch (TREE_CODE_CLASS (TREE_CODE (rhsop)))\n-\t\t  {\n-\t\t    /* RHS that consist of unary operations,\n-\t\t       exceptional types, or bare decls/constants, get\n-\t\t       handled directly by get_constraint_for.  */ \n+\t  lhs = get_constraint_for (PHI_RESULT (t));\n+\t  for (i = 0; i < PHI_NUM_ARGS (t); i++)\n+\t    {\n+\t      rhs = get_constraint_for (PHI_ARG_DEF (t, i));\n+\t      process_constraint (new_constraint (lhs, rhs));\n+\t    }\n+\t}\n+    }\n+  else if (TREE_CODE (t) == MODIFY_EXPR)\n+    {\n+      tree lhsop = TREE_OPERAND (t, 0);\n+      tree rhsop = TREE_OPERAND (t, 1);\n+      int i;\t\n+\n+      if (AGGREGATE_TYPE_P (TREE_TYPE (lhsop)) \n+\t  && AGGREGATE_TYPE_P (TREE_TYPE (rhsop)))\n+\t{\n+\t  do_structure_copy (lhsop, rhsop);\n+\t}\n+      else\n+\t{\n+\t  /* Only care about operations with pointers, structures\n+\t     containing pointers, dereferences, and call expressions.  */\n+\t  if (POINTER_TYPE_P (TREE_TYPE (lhsop))\n+\t      || AGGREGATE_TYPE_P (TREE_TYPE (lhsop))\n+\t      || ref_contains_indirect_ref (lhsop)\n+\t      || TREE_CODE (rhsop) == CALL_EXPR)\n+\t    {\n+\t      lhs = get_constraint_for (lhsop);\n+\t      switch (TREE_CODE_CLASS (TREE_CODE (rhsop)))\n+\t\t{\n+\t\t  /* RHS that consist of unary operations,\n+\t\t     exceptional types, or bare decls/constants, get\n+\t\t     handled directly by get_constraint_for.  */ \n \t\t  case tcc_reference:\n \t\t  case tcc_declaration:\n \t\t  case tcc_constant:\n \t\t  case tcc_exceptional:\n \t\t  case tcc_expression:\n \t\t  case tcc_unary:\n-\t\t    {\n-\t\t      rhs = get_constraint_for (rhsop);\n-\t\t      process_constraint (new_constraint (lhs, rhs));\n-\t\t    }\n+\t\t      {\n+\t\t\trhs = get_constraint_for (rhsop);\n+\t\t\tprocess_constraint (new_constraint (lhs, rhs));\n+\n+\t\t\t/* When taking the address of an aggregate\n+\t\t\t   type, from the LHS we can access any field\n+\t\t\t   of the RHS.  */\n+\t\t\tif (rhs.type == ADDRESSOF\n+\t\t\t    && rhs.var > anything_id\n+\t\t\t    && AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (rhsop))))\n+\t\t\t  {\n+\t\t\t    rhs.var = anyoffset_id;\n+\t\t\t    rhs.type = ADDRESSOF;\n+\t\t\t    rhs.offset = 0;\n+\t\t\t    process_constraint (new_constraint (lhs, rhs));\n+\t\t\t  }\n+\t\t      }\n \t\t    break;\n \n-\t\t    /* Otherwise, walk each operand.  */\n+\t\t  case tcc_binary:\n+\t\t      {\n+\t\t\t/* For pointer arithmetic of the form\n+\t\t\t   PTR + CST, we can simply use PTR's\n+\t\t\t   constraint because pointer arithmetic is\n+\t\t\t   not allowed to go out of bounds.  */\n+\t\t\tif (handle_ptr_arith (lhs, rhsop))\n+\t\t\t  break;\n+\t\t      }\n+\t\t    /* FALLTHRU  */\n+\n+\t\t  /* Otherwise, walk each operand.  Notice that we\n+\t\t     can't use the operand interface because we need\n+\t\t     to process expressions other than simple operands\n+\t\t     (e.g. INDIRECT_REF, ADDR_EXPR, CALL_EXPR).  */\n \t\t  default:\n \t\t    for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (rhsop)); i++)\n \t\t      {\n \t\t\ttree op = TREE_OPERAND (rhsop, i);\n \t\t\trhs = get_constraint_for (op);\n \t\t\tprocess_constraint (new_constraint (lhs, rhs));\n \t\t      }\n-\t\t  }      \n-\t      }\n-\t  }\n-      }\n-      break;\n-\n-    default:\n-      break;\n+\t\t}      \n+\t    }\n+\t}\n     }\n+\n+  /* After promoting variables and computing aliasing we will\n+     need to re-scan most statements.  FIXME: Try to minimize the\n+     number of statements re-scanned.  It's not really necessary to\n+     re-scan *all* statements.  */\n+  mark_stmt_modified (t);\n }\n \n \n@@ -2718,12 +2962,12 @@ create_variable_info_for (tree decl, const char *name)\n   tree decltype = TREE_TYPE (decl);\n   bool notokay = false;\n   bool hasunion;\n-  subvar_t svars;\n   bool is_global = DECL_P (decl) ? is_global_var (decl) : false;\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n   \n \n-  hasunion = TREE_CODE (decltype) == UNION_TYPE || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n+  hasunion = TREE_CODE (decltype) == UNION_TYPE\n+             || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n   if (var_can_have_subvars (decl) && use_field_sensitive && !hasunion)\n     {\n       push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion);\n@@ -2733,62 +2977,6 @@ create_variable_info_for (tree decl, const char *name)\n \t  notokay = true;\n \t}\t \n     }\n-\n-  /* If this variable already has subvars, just create the variables for the\n-     subvars and we are done.\n-     NOTE: This assumes things haven't generated uses of previously\n-     unused structure fields.  */\n-  if (use_field_sensitive \n-      && !notokay \n-      && var_can_have_subvars (decl) \n-      && var_ann (decl)      \n-      && (svars = get_subvars_for_var (decl)))\n-    {\n-      subvar_t sv;\n-      varinfo_t base = NULL;\n-      unsigned int firstindex = index;\n-\n-      for (sv = svars; sv; sv = sv->next)\n-\t{\n-\t  /* For debugging purposes, this will print the names of the\n-\t     fields as \"<var>.<offset>.<size>\"\n-\t     This is only for debugging purposes.  */\n-#define PRINT_LONG_NAMES\n-#ifdef PRINT_LONG_NAMES\n-\t  char *tempname;\n-\t  const char *newname;\n-\n-\t  asprintf (&tempname,\n-\t            \"%s.\" HOST_WIDE_INT_PRINT_DEC \".\" HOST_WIDE_INT_PRINT_DEC,\n-\t\t    alias_get_name (decl), sv->offset, sv->size);\n-\t  newname = ggc_strdup (tempname);\n-\t  free (tempname);\n-\t  vi = new_var_info (sv->var, index, newname, index);\n-#else\n-\t  vi = new_var_info (sv->var, index, alias_get_name (sv->var), index);\n-#endif\n-\t  vi->decl = sv->var;\n-\t  vi->fullsize = TREE_INT_CST_LOW (TYPE_SIZE (decltype));\n-\t  vi->size = sv->size;\n-\t  vi->offset = sv->offset;\n-\t  if (!base)\n-\t    {\n-\t      base = vi;\n-\t      insert_id_for_tree (decl, index);\n-\t    }\n-\t  else\n-\t    {\n-\t      insert_into_field_list (base, vi);\n-\t    }\n-\t  insert_id_for_tree (sv->var, index);  \n-\t  VEC_safe_push (varinfo_t, gc, varmap, vi);\n-\t  if (is_global)\n-\t    make_constraint_to_anything (vi);\n-\t  index++;\n-\t  \n-\t}\n-      return firstindex;\n-    }\n   \n \n   /* If the variable doesn't have subvars, we may end up needing to\n@@ -2935,7 +3123,6 @@ intra_create_variable_infos (void)\n       lhs.type = SCALAR;\n       lhs.var  = create_variable_info_for (t, alias_get_name (t));\n       \n-      get_varinfo (lhs.var)->is_artificial_var = true;\n       rhs.var = anything_id;\n       rhs.type = ADDRESSOF;\n       rhs.offset = 0;\n@@ -2958,30 +3145,67 @@ set_uids_in_ptset (bitmap into, bitmap from)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n+  bool found_anyoffset = false;\n+  subvar_t sv;\n \n   EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n       varinfo_t vi = get_varinfo (i);\n+\n+      /* If we find ANYOFFSET in the solution and the solution\n+\t includes SFTs for some structure, then all the SFTs in that\n+\t structure will need to be added to the alias set.  */\n+      if (vi->id == anyoffset_id)\n+\t{\n+\t  found_anyoffset = true;\n+\t  continue;\n+\t}\n+\n+      /* The only artificial variables that are allowed in a may-alias\n+\t set are heap variables.  */\n+      if (vi->is_artificial_var && !vi->is_heap_var)\n+\tcontinue;\n       \n-      /* Variables containing unions may need to be converted to their \n-\t SFT's, because SFT's can have unions and we cannot.  */\n       if (vi->has_union && get_subvars_for_var (vi->decl) != NULL)\n \t{\n-\t  subvar_t svars = get_subvars_for_var (vi->decl);\n-\t  subvar_t sv;\n-\t  for (sv = svars; sv; sv = sv->next)\n+\t  /* Variables containing unions may need to be converted to\n+\t     their SFT's, because SFT's can have unions and we cannot.  */\n+\t  for (sv = get_subvars_for_var (vi->decl); sv; sv = sv->next)\n \t    bitmap_set_bit (into, DECL_UID (sv->var));\n \t}\n-      /* We may end up with labels in the points-to set because people\n-\t take their address, and they are _DECL's.  */\n       else if (TREE_CODE (vi->decl) == VAR_DECL \n-\t  || TREE_CODE (vi->decl) == PARM_DECL)\n-\tbitmap_set_bit (into, DECL_UID (vi->decl));\n-\n-\t  \n+\t       || TREE_CODE (vi->decl) == PARM_DECL)\n+\t{\n+\t  if (found_anyoffset\n+\t      && var_can_have_subvars (vi->decl)\n+\t      && get_subvars_for_var (vi->decl))\n+\t    {\n+\t      /* If ANYOFFSET is in the solution set and VI->DECL is\n+\t\t an aggregate variable with sub-variables, then any of\n+\t\t the SFTs inside VI->DECL may have been accessed.  Add\n+\t\t all the sub-vars for VI->DECL.  */\n+\t      for (sv = get_subvars_for_var (vi->decl); sv; sv = sv->next)\n+\t\tbitmap_set_bit (into, DECL_UID (sv->var));\n+\t    }\n+\t  else if (var_can_have_subvars (vi->decl)\n+\t\t   && get_subvars_for_var (vi->decl))\n+\t    {\n+\t      /* If VI->DECL is an aggregate for which we created\n+\t\t SFTs, add the SFT corresponding to VI->OFFSET.  */\n+\t      tree sft = get_subvar_at (vi->decl, vi->offset);\n+\t      bitmap_set_bit (into, DECL_UID (sft));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, just add VI->DECL to the alias set.  */\n+\t      bitmap_set_bit (into, DECL_UID (vi->decl));\n+\t    }\n+\t}\n     }\n }\n-static int have_alias_info = false;\n+\n+\n+static bool have_alias_info = false;\n \n /* Given a pointer variable P, fill in its points-to set, or return\n    false if we can't.  */\n@@ -2990,23 +3214,26 @@ bool\n find_what_p_points_to (tree p)\n {\n   unsigned int id = 0;\n+\n   if (!have_alias_info)\n     return false;\n+\n   if (lookup_id_for_tree (p, &id))\n     {\n       varinfo_t vi = get_varinfo (id);\n       \n       if (vi->is_artificial_var)\n \treturn false;\n \n-      /* See if this is a field or a structure */\n+      /* See if this is a field or a structure.  */\n       if (vi->size != vi->fullsize)\n \t{\n+\t  /* Nothing currently asks about structure fields directly,\n+\t     but when they do, we need code here to hand back the\n+\t     points-to set.  */\n \t  if (!var_can_have_subvars (vi->decl)\n \t      || get_subvars_for_var (vi->decl) == NULL)\n \t    return false;\n-\t  /* Nothing currently asks about structure fields directly, but when\n-\t     they do, we need code here to hand back the points-to set.  */\n \t} \n       else\n \t{\n@@ -3018,21 +3245,45 @@ find_what_p_points_to (tree p)\n \t     variable.  */\n \t  vi = get_varinfo (vi->node);\n \t  \n-\t  /* Make sure there aren't any artificial vars in the points to set.\n-             XXX: Note that we need to translate our heap variables to\n-             something.  */\n+\t  /* Translate artificial variables into SSA_NAME_PTR_INFO\n+\t     attributes.  */\n \t  EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, i, bi)\n \t    {\n-\t      if (get_varinfo (i)->is_artificial_var)\n-\t\treturn false;\n+\t      varinfo_t vi = get_varinfo (i);\n+\n+\t      if (vi->is_artificial_var)\n+\t\t{\n+\t\t  /* FIXME.  READONLY should be handled better so that\n+\t\t     flow insensitive aliasing can disregard writeable\n+\t\t     aliases.  */\n+\t\t  if (vi->id == nothing_id)\n+\t\t    pi->pt_null = 1;\n+\t\t  else if (vi->id == anything_id)\n+\t\t    pi->pt_anything = 1;\n+\t\t  else if (vi->id == readonly_id)\n+\t\t    pi->pt_anything = 1;\n+\t\t  else if (vi->id == integer_id)\n+\t\t    pi->pt_anything = 1;\n+\t\t  else if (vi->is_heap_var)\n+\t\t    pi->pt_global_mem = 1;\n+\t\t}\n \t    }\n-\t  pi->pt_anything = false;\n+\n+\t  if (pi->pt_anything)\n+\t    return false;\n+\n \t  if (!pi->pt_vars)\n \t    pi->pt_vars = BITMAP_GGC_ALLOC ();\n+\n \t  set_uids_in_ptset (pi->pt_vars, vi->solution);\n+\n+\t  if (bitmap_empty_p (pi->pt_vars))\n+\t    pi->pt_vars = NULL;\n+\n \t  return true;\n \t}\n     }\n+\n   return false;\n }\n \n@@ -3053,7 +3304,7 @@ dump_sa_points_to_info (FILE *outfile)\n {\n   unsigned int i;\n \n-  fprintf (outfile, \"\\nPoints-to information\\n\\n\");\n+  fprintf (outfile, \"\\nPoints-to sets\\n\\n\");\n \n   if (dump_flags & TDF_STATS)\n     {\n@@ -3124,6 +3375,7 @@ init_base_vars (void)\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   var_anything->address_taken = true;\n+\n   /* This specifically does not use process_constraint because\n      process_constraint ignores all anything = anything constraints, since all\n      but this one are redundant.  */\n@@ -3177,17 +3429,44 @@ init_base_vars (void)\n   rhs.var = anything_id;\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n+\n+  /* Create the ANYOFFSET variable, used to represent an arbitrary offset\n+     inside an object.  This is similar to ANYTHING, but less drastic.\n+     It means that the pointer can point anywhere inside an object,\n+     but not outside of it.  */\n+  anyoffset_tree = create_tmp_var_raw (void_type_node, \"ANYOFFSET\");\n+  anyoffset_id = 4;\n+  var_anyoffset = new_var_info (anyoffset_tree, anyoffset_id, \"ANYOFFSET\",\n+                                anyoffset_id); \n+  insert_id_for_tree (anyoffset_tree, anyoffset_id);\n+  var_anyoffset->is_artificial_var = 1;\n+  var_anyoffset->size = ~0;\n+  var_anyoffset->offset = 0;\n+  var_anyoffset->next = NULL;\n+  var_anyoffset->fullsize = ~0;\n+  VEC_safe_push (varinfo_t, gc, varmap, var_anyoffset);\n+\n+  /* ANYOFFSET points to ANYOFFSET.  */\n+  lhs.type = SCALAR;\n+  lhs.var = anyoffset_id;\n+  lhs.offset = 0;\n+  rhs.type = ADDRESSOF;\n+  rhs.var = anyoffset_id;\n+  rhs.offset = 0;\n+  process_constraint (new_constraint (lhs, rhs));\n }  \n \n \n /* Create points-to sets for the current function.  See the comments\n    at the start of the file for an algorithmic overview.  */\n \n-static void\n-create_alias_vars (void)\n+void\n+compute_points_to_sets (struct alias_info *ai)\n {\n   basic_block bb;\n-  \n+\n+  timevar_push (TV_TREE_PTA);\n+\n   init_alias_vars ();\n \n   constraint_pool = create_alloc_pool (\"Constraint pool\", \n@@ -3201,7 +3480,7 @@ create_alias_vars (void)\n   varmap = VEC_alloc (varinfo_t, gc, 8);\n   id_for_tree = htab_create (10, tree_id_hash, tree_id_eq, free);\n   memset (&stats, 0, sizeof (stats));\n-  \n+\n   init_base_vars ();\n \n   intra_create_variable_infos ();\n@@ -3214,59 +3493,45 @@ create_alias_vars (void)\n \n       for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n \tif (is_gimple_reg (PHI_RESULT (phi)))\n-\t  find_func_aliases (phi);\n+\t  find_func_aliases (phi, ai);\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tfind_func_aliases (bsi_stmt (bsi));\n+\tfind_func_aliases (bsi_stmt (bsi), ai);\n     }\n \n   build_constraint_graph ();\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"Constraints:\\n\");\n+      fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n       dump_constraints (dump_file);\n     }\n \n   if (dump_file)\n-    fprintf (dump_file, \"Collapsing static cycles and doing variable substitution:\\n\");\n+    fprintf (dump_file, \"\\nCollapsing static cycles and doing variable \"\n+\t                \"substitution:\\n\");\n \n   find_and_collapse_graph_cycles (graph, false);\n   perform_var_substitution (graph);\n \n   if (dump_file)\n-    fprintf (dump_file, \"Solving graph:\\n\");\n+    fprintf (dump_file, \"\\nSolving graph:\\n\");\n \n   solve_graph (graph);\n \n   if (dump_file)\n     dump_sa_points_to_info (dump_file);\n   \n   have_alias_info = true;\n+\n+  timevar_pop (TV_TREE_PTA);\n }\n \n-struct tree_opt_pass pass_build_pta = \n-{\n-  \"pta\",\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  create_alias_vars,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PTA,\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  PROP_pta,\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};\n- \n \n /* Delete created points-to sets.  */\n \n-static void\n-delete_alias_vars (void)\n+void\n+delete_points_to_sets (void)\n {\n   htab_delete (id_for_tree);\n   free_alloc_pool (variable_info_pool);\n@@ -3275,20 +3540,3 @@ delete_alias_vars (void)\n   bitmap_obstack_release (&ptabitmap_obstack);\n   have_alias_info = false;\n }\n-\n-struct tree_opt_pass pass_del_pta = \n-{\n-  NULL,                                 /* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  delete_alias_vars,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_PTA,\t\t\t\t/* tv_id */\n-  PROP_pta,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  PROP_pta,\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n-  0\t\t\t\t\t/* letter */\n-};"}, {"sha": "ddabd6d17996fcd325d1ea7377447cf1ba870ecb", "filename": "gcc/tree-ssa-structalias.h", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-structalias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa-structalias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.h?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -25,6 +25,66 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n struct constraint;\n typedef struct constraint *constraint_t;\n \n+/* Alias information used by compute_may_aliases and its helpers.  */\n+struct alias_info\n+{\n+  /* SSA names visited while collecting points-to information.  If bit I\n+     is set, it means that SSA variable with version I has already been\n+     visited.  */\n+  sbitmap ssa_names_visited;\n+\n+  /* Array of SSA_NAME pointers processed by the points-to collector.  */\n+  varray_type processed_ptrs;\n+\n+  /* ADDRESSABLE_VARS contains all the global variables and locals that\n+     have had their address taken.  */\n+  struct alias_map_d **addressable_vars;\n+  size_t num_addressable_vars;\n+\n+  /* POINTERS contains all the _DECL pointers with unique memory tags\n+     that have been referenced in the program.  */\n+  struct alias_map_d **pointers;\n+  size_t num_pointers;\n+\n+  /* Number of function calls found in the program.  */\n+  size_t num_calls_found;\n+\n+  /* Number of const/pure function calls found in the program.  */\n+  size_t num_pure_const_calls_found;\n+\n+  /* Array of counters to keep track of how many times each pointer has\n+     been dereferenced in the program.  This is used by the alias grouping\n+     heuristic in compute_flow_insensitive_aliasing.  */\n+  varray_type num_references;\n+\n+  /* Total number of virtual operands that will be needed to represent\n+     all the aliases of all the pointers found in the program.  */\n+  long total_alias_vops;\n+\n+  /* Variables that have been written to.  */\n+  bitmap written_vars;\n+\n+  /* Pointers that have been used in an indirect store operation.  */\n+  bitmap dereferenced_ptrs_store;\n+\n+  /* Pointers that have been used in an indirect load operation.  */\n+  bitmap dereferenced_ptrs_load;\n+};\n+\n+/* Keep track of how many times each pointer has been dereferenced in\n+   the program using the aux variable.  This is used by the alias\n+   grouping heuristic in compute_flow_insensitive_aliasing.  */\n+#define NUM_REFERENCES(ANN) ((size_t)((ANN)->common.aux))\n+#define NUM_REFERENCES_CLEAR(ANN) ((ANN)->common.aux) = 0\n+#define NUM_REFERENCES_INC(ANN) (ANN)->common.aux = (void*) (((size_t)((ANN)->common.aux)) + 1)\n+#define NUM_REFERENCES_SET(ANN, VAL) (ANN)->common.aux = (void*) ((void *)(VAL))\n+\n+/* In tree-ssa-alias.c.  */\n+bool is_escape_site (tree, struct alias_info *);\n+\n+/* In tree-ssa-structalias.c.  */\n+extern void compute_points_to_sets (struct alias_info *);\n+extern void delete_points_to_sets (void);\n extern void dump_constraint (FILE *, constraint_t);\n extern void dump_constraints (FILE *);\n extern void debug_constraint (constraint_t);"}, {"sha": "ef892b57dd6b59e86efb088ccb592e04e1ef3091", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ca41599546a7131d276d99fd4e7bbf402190d3/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=e8ca41599546a7131d276d99fd4e7bbf402190d3", "patch": "@@ -467,10 +467,9 @@ verify_flow_sensitive_alias_info (void)\n \t}\n \n       if (pi->name_mem_tag\n-\t  && !pi->pt_malloc\n \t  && (pi->pt_vars == NULL || bitmap_empty_p (pi->pt_vars)))\n \t{\n-\t  error (\"pointers with a memory tag, should have points-to sets or point to malloc\");\n+\t  error (\"pointers with a memory tag, should have points-to sets\");\n \t  goto err;\n \t}\n "}]}