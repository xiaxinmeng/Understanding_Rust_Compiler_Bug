{"sha": "cf99f196e2e18b62becbb660761fc2a586b85d78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y5OWYxOTZlMmUxOGI2MmJlY2JiNjYwNzYxZmMyYTU4NmI4NWQ3OA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2005-01-05T14:41:30Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2005-01-05T14:41:30Z"}, "message": "re PR target/16482 (gcc.c-torture/unsorted/SFset.c fails with \"-O2 -m4\")\n\n\tPR target/16482\n\t* lcm.c (create_pre_exit): New.\n\t(optimize_mode_switching): In MODE_ENTRY / MODE_EXIT case, set\n\tENTRY_EXIT_EXTRA to 3.  Use create_pre_exit.\n\nCo-Authored-By: Kaz Kojima <kkojima@gcc.gnu.org>\n\nFrom-SVN: r92950", "tree": {"sha": "c7a3da5cc0402ce4ccc2afb12d8e5ace1eb26ebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7a3da5cc0402ce4ccc2afb12d8e5ace1eb26ebb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf99f196e2e18b62becbb660761fc2a586b85d78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf99f196e2e18b62becbb660761fc2a586b85d78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf99f196e2e18b62becbb660761fc2a586b85d78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf99f196e2e18b62becbb660761fc2a586b85d78/comments", "author": null, "committer": null, "parents": [{"sha": "712ecf4dfb9c7f3b48bc6c9fb1f749bab9e3e9ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712ecf4dfb9c7f3b48bc6c9fb1f749bab9e3e9ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/712ecf4dfb9c7f3b48bc6c9fb1f749bab9e3e9ae"}], "stats": {"total": 210, "additions": 187, "deletions": 23}, "files": [{"sha": "fb4d6f99216df54176e7ec4c85602f0cc550a1e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf99f196e2e18b62becbb660761fc2a586b85d78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf99f196e2e18b62becbb660761fc2a586b85d78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf99f196e2e18b62becbb660761fc2a586b85d78", "patch": "@@ -1,3 +1,11 @@\n+2005-01-05  J\"orn Rennecke <joern.rennecke@st.com>\n+\t    Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/16482\n+\t* lcm.c (create_pre_exit): New.\n+\t(optimize_mode_switching): In MODE_ENTRY / MODE_EXIT case, set\n+\tENTRY_EXIT_EXTRA to 3.  Use create_pre_exit.\n+\n 2004-01-05  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.h (TARGET_OPTIONS): Correctly record -mhard-float and"}, {"sha": "f4300e2d8e95c956d9196d181ea8ff0bcb68a530", "filename": "gcc/lcm.c", "status": "modified", "additions": 179, "deletions": 23, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf99f196e2e18b62becbb660761fc2a586b85d78/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf99f196e2e18b62becbb660761fc2a586b85d78/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=cf99f196e2e18b62becbb660761fc2a586b85d78", "patch": "@@ -972,6 +972,180 @@ reg_becomes_live (rtx reg, rtx setter ATTRIBUTE_UNUSED, void *live)\n  #error \"Both MODE_ENTRY and MODE_EXIT must be defined\"\n #endif\n \n+#if defined (MODE_ENTRY) && defined (MODE_EXIT)\n+/* Split the fallthrough edge to the exit block, so that we can note\n+   that there NORMAL_MODE is required.  Return the new block if it's\n+   inserted before the exit block.  Otherwise return null.  */\n+\n+static basic_block\n+create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n+{\n+  edge eg;\n+  edge_iterator ei;\n+  basic_block pre_exit;\n+\n+  /* The only non-call predecessor at this stage is a block with a\n+     fallthrough edge; there can be at most one, but there could be\n+     none at all, e.g. when exit is called.  */\n+  pre_exit = 0;\n+  FOR_EACH_EDGE (eg, ei, EXIT_BLOCK_PTR->preds)\n+    if (eg->flags & EDGE_FALLTHRU)\n+      {\n+\tbasic_block src_bb = eg->src;\n+\tregset live_at_end = src_bb->global_live_at_end;\n+\trtx last_insn, ret_reg;\n+\n+\tgcc_assert (!pre_exit);\n+\t/* If this function returns a value at the end, we have to\n+\t   insert the final mode switch before the return value copy\n+\t   to its hard register.  */\n+\tif (EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 1\n+\t    && GET_CODE ((last_insn = BB_END (src_bb))) == INSN\n+\t    && GET_CODE (PATTERN (last_insn)) == USE\n+\t    && GET_CODE ((ret_reg = XEXP (PATTERN (last_insn), 0))) == REG)\n+\t  {\n+\t    int ret_start = REGNO (ret_reg);\n+\t    int nregs = hard_regno_nregs[ret_start][GET_MODE (ret_reg)];\n+\t    int ret_end = ret_start + nregs;\n+\t    int short_block = 0;\n+\t    int maybe_builtin_apply = 0;\n+\t    int forced_late_switch = 0;\n+\t    rtx before_return_copy;\n+\n+\t    do\n+\t      {\n+\t\trtx return_copy = PREV_INSN (last_insn);\n+\t\trtx return_copy_pat, copy_reg;\n+\t\tint copy_start, copy_num;\n+\t\tint j;\n+\n+\t\tif (INSN_P (return_copy))\n+\t\t  {\n+\t\t    if (GET_CODE (PATTERN (return_copy)) == USE\n+\t\t\t&& GET_CODE (XEXP (PATTERN (return_copy), 0)) == REG\n+\t\t\t&& (FUNCTION_VALUE_REGNO_P\n+\t\t\t    (REGNO (XEXP (PATTERN (return_copy), 0)))))\n+\t\t      {\n+\t\t\tmaybe_builtin_apply = 1;\n+\t\t\tlast_insn = return_copy;\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t    /* If the return register is not (in its entirety)\n+\t\t       likely spilled, the return copy might be\n+\t\t       partially or completely optimized away.  */\n+\t\t    return_copy_pat = single_set (return_copy);\n+\t\t    if (!return_copy_pat)\n+\t\t      {\n+\t\t\treturn_copy_pat = PATTERN (return_copy);\n+\t\t\tif (GET_CODE (return_copy_pat) != CLOBBER)\n+\t\t\t  break;\n+\t\t      }\n+\t\t    copy_reg = SET_DEST (return_copy_pat);\n+\t\t    if (GET_CODE (copy_reg) == REG)\n+\t\t      copy_start = REGNO (copy_reg);\n+\t\t    else if (GET_CODE (copy_reg) == SUBREG\n+\t\t\t     && GET_CODE (SUBREG_REG (copy_reg)) == REG)\n+\t\t      copy_start = REGNO (SUBREG_REG (copy_reg));\n+\t\t    else\n+\t\t      break;\n+\t\t    if (copy_start >= FIRST_PSEUDO_REGISTER)\n+\t\t      break;\n+\t\t    copy_num\n+\t\t      = hard_regno_nregs[copy_start][GET_MODE (copy_reg)];\n+\n+\t\t    /* If the return register is not likely spilled, - as is\n+\t\t       the case for floating point on SH4 - then it might\n+\t\t       be set by an arithmetic operation that needs a\n+\t\t       different mode than the exit block.  */\n+\t\t    for (j = n_entities - 1; j >= 0; j--)\n+\t\t      {\n+\t\t\tint e = entity_map[j];\n+\t\t\tint mode = MODE_NEEDED (e, return_copy);\n+\n+\t\t\tif (mode != num_modes[e] && mode != MODE_EXIT (e))\n+\t\t\t  break;\n+\t\t      }\n+\t\t    if (j >= 0)\n+\t\t      {\n+\t\t\t/* For the SH4, floating point loads depend on fpscr,\n+\t\t\t   thus we might need to put the final mode switch\n+\t\t\t   after the return value copy.  That is still OK,\n+\t\t\t   because a floating point return value does not\n+\t\t\t   conflict with address reloads.  */\n+\t\t\tif (copy_start >= ret_start\n+\t\t\t    && copy_start + copy_num <= ret_end\n+\t\t\t    && OBJECT_P (SET_SRC (return_copy_pat)))\n+\t\t\t  forced_late_switch = 1;\n+\t\t\tbreak;\n+\t\t      }\n+\n+\t\t    if (copy_start >= ret_start\n+\t\t\t&& copy_start + copy_num <= ret_end)\n+\t\t      nregs -= copy_num;\n+\t\t    else if (!maybe_builtin_apply\n+\t\t\t     || !FUNCTION_VALUE_REGNO_P (copy_start))\n+\t\t      break;\n+\t\t    last_insn = return_copy;\n+\t\t  }\n+\t\t/* ??? Exception handling can lead to the return value\n+\t\t   copy being already separated from the return value use,\n+\t\t   as in  unwind-dw2.c .\n+\t\t   Similarly, conditionally returning without a value,\n+\t\t   and conditionally using builtin_return can lead to an\n+\t\t   isolated use.  */\n+\t\tif (return_copy == BB_HEAD (src_bb))\n+\t\t  {\n+\t\t    short_block = 1;\n+\t\t    break;\n+\t\t  }\n+\t\tlast_insn = return_copy;\n+\t      }\n+\t    while (nregs);\n+\t    /* If we didn't see a full return value copy, verify that there\n+\t       is a plausible reason for this.  If some, but not all of the\n+\t       return register is likely spilled, we can expect that there\n+\t       is a copy for the likely spilled part.  */\n+\t    if (nregs\n+\t\t&& ! forced_late_switch\n+\t\t&& ! short_block\n+\t\t&& CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (ret_start))\n+\t\t&& nregs == hard_regno_nregs[ret_start][GET_MODE (ret_reg)]\n+\t\t/* For multi-hard-register floating point values,\n+\t\t   sometimes the likely-spilled part is ordinarily copied\n+\t\t   first, then the other part is set with an arithmetic\n+\t\t   operation.  This doesn't actually cause reload failures,\n+\t\t   so let it pass.  */\n+\t\t&& (GET_MODE_CLASS (GET_MODE (ret_reg)) == MODE_INT\n+\t\t    || nregs == 1))\n+\t      abort ();\n+\t    if (INSN_P (last_insn))\n+\t      {\n+\t\tbefore_return_copy\n+\t\t  = emit_note_before (NOTE_INSN_DELETED, last_insn);\n+\t\t/* Instructions preceding LAST_INSN in the same block might\n+\t\t   require a different mode than MODE_EXIT, so if we might\n+\t\t   have such instructions, keep them in a separate block\n+\t\t   from pre_exit.  */\n+\t\tif (last_insn != BB_HEAD (src_bb))\n+\t\t  src_bb = split_block (src_bb,\n+\t\t\t\t\tPREV_INSN (before_return_copy))->dest;\n+\t      }\n+\t    else\n+\t      before_return_copy = last_insn;\n+\t    pre_exit = split_block (src_bb, before_return_copy)->src;\n+\t  }\n+\telse\n+\t  {\n+\t    pre_exit = split_edge (eg);\n+\t    COPY_REG_SET (pre_exit->global_live_at_start, live_at_end);\n+\t    COPY_REG_SET (pre_exit->global_live_at_end, live_at_end);\n+\t  }\n+      }\n+\n+  return pre_exit;\n+}\n+#endif\n+\n /* Find all insns that need a particular mode setting, and insert the\n    necessary mode switches.  Return true if we did work.  */\n \n@@ -1005,7 +1179,7 @@ optimize_mode_switching (FILE *file)\n \t   If NORMAL_MODE is defined, allow for two extra\n \t   blocks split from the entry and exit block.  */\n #if defined (MODE_ENTRY) && defined (MODE_EXIT)\n-\tentry_exit_extra = 2;\n+\tentry_exit_extra = 3;\n #endif\n \tbb_info[n_entities]\n \t  = xcalloc (last_basic_block + entry_exit_extra, sizeof **bb_info);\n@@ -1018,28 +1192,10 @@ optimize_mode_switching (FILE *file)\n     return 0;\n \n #if defined (MODE_ENTRY) && defined (MODE_EXIT)\n-  {\n-    /* Split the edge from the entry block and the fallthrough edge to the\n-       exit block, so that we can note that there NORMAL_MODE is supplied /\n-       required.  */\n-    edge eg;\n-    edge_iterator ei;\n-    post_entry = split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n-    /* The only non-call predecessor at this stage is a block with a\n-       fallthrough edge; there can be at most one, but there could be\n-       none at all, e.g. when exit is called.  */\n-    pre_exit = 0;\n-    FOR_EACH_EDGE (eg, ei, EXIT_BLOCK_PTR->preds)\n-      if (eg->flags & EDGE_FALLTHRU)\n-\t{\n-\t  regset live_at_end = eg->src->global_live_at_end;\n-\n-\t  gcc_assert (!pre_exit);\n-\t  pre_exit = split_edge (eg);\n-\t  COPY_REG_SET (pre_exit->global_live_at_start, live_at_end);\n-\t  COPY_REG_SET (pre_exit->global_live_at_end, live_at_end);\n-\t}\n-  }\n+  /* Split the edge from the entry block, so that we can note that\n+     there NORMAL_MODE is supplied.  */\n+  post_entry = split_edge (EDGE_SUCC (ENTRY_BLOCK_PTR, 0));\n+  pre_exit = create_pre_exit (n_entities, entity_map, num_modes);\n #endif\n \n   /* Create the bitmap vectors.  */"}]}