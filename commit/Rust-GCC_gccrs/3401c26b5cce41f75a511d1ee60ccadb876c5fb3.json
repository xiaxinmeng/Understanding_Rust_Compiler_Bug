{"sha": "3401c26b5cce41f75a511d1ee60ccadb876c5fb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQwMWMyNmI1Y2NlNDFmNzVhNTExZDFlZTYwY2NhZGI4NzZjNWZiMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-11-14T17:58:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-11-14T17:58:01Z"}, "message": "tree.c (get_unwidened): Use host_integerp and tree_low_cst.\n\n\t* tree.c (get_unwidened): Use host_integerp and tree_low_cst.\n\t(int_fits_type_p): For variable bounds, call force_fit_type.\n\nFrom-SVN: r37460", "tree": {"sha": "bc239a82c689dfcc3bdc873efab8db9073102de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc239a82c689dfcc3bdc873efab8db9073102de3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3401c26b5cce41f75a511d1ee60ccadb876c5fb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3401c26b5cce41f75a511d1ee60ccadb876c5fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3401c26b5cce41f75a511d1ee60ccadb876c5fb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3401c26b5cce41f75a511d1ee60ccadb876c5fb3/comments", "author": null, "committer": null, "parents": [{"sha": "bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd7cf17efd38b94f26bcf0c309c6b9053c0a21dd"}], "stats": {"total": 49, "additions": 32, "deletions": 17}, "files": [{"sha": "613a7b2894230bd6af264b2466895955ff2d2811", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3401c26b5cce41f75a511d1ee60ccadb876c5fb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3401c26b5cce41f75a511d1ee60ccadb876c5fb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3401c26b5cce41f75a511d1ee60ccadb876c5fb3", "patch": "@@ -1,3 +1,8 @@\n+Tue Nov 14 12:34:56 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree.c (get_unwidened): Use host_integerp and tree_low_cst.\n+\t(int_fits_type_p): For variable bounds, call force_fit_type.\n+\n 2000-11-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* varasm.c (struct deferred_string): New structure."}, {"sha": "4b3e9300efcc6f79607abd641101ef4251d1ecb2", "filename": "gcc/tree.c", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3401c26b5cce41f75a511d1ee60ccadb876c5fb3/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3401c26b5cce41f75a511d1ee60ccadb876c5fb3/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3401c26b5cce41f75a511d1ee60ccadb876c5fb3", "patch": "@@ -4210,10 +4210,11 @@ get_unwidened (op, for_type)\n       /* Since type_for_size always gives an integer type.  */\n       && TREE_CODE (type) != REAL_TYPE\n       /* Don't crash if field not laid out yet.  */\n-      && DECL_SIZE (TREE_OPERAND (op, 1)) != 0)\n+      && DECL_SIZE (TREE_OPERAND (op, 1)) != 0\n+      && host_integerp (DECL_SIZE (TREE_OPERAND (op, 1)), 1))\n     {\n       unsigned int innerprec\n-\t= TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));\n+\t= tree_low_cst (DECL_SIZE (TREE_OPERAND (op, 1)), 1);\n \n       type = type_for_size (innerprec, TREE_UNSIGNED (TREE_OPERAND (op, 1)));\n \n@@ -4235,6 +4236,7 @@ get_unwidened (op, for_type)\n \t  TREE_THIS_VOLATILE (win) = TREE_THIS_VOLATILE (op);\n \t}\n     }\n+\n   return win;\n }\n \f\n@@ -4333,22 +4335,30 @@ int\n int_fits_type_p (c, type)\n      tree c, type;\n {\n-  if (TREE_UNSIGNED (type))\n-    return (! (TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n-\t       && INT_CST_LT_UNSIGNED (TYPE_MAX_VALUE (type), c))\n-\t    && ! (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n-\t\t  && INT_CST_LT_UNSIGNED (c, TYPE_MIN_VALUE (type)))\n-\t    /* Negative ints never fit unsigned types.  */\n-\t    && ! (TREE_INT_CST_HIGH (c) < 0\n-\t\t  && ! TREE_UNSIGNED (TREE_TYPE (c))));\n+  /* If the bounds of the type are integers, we can check ourselves.\n+     Otherwise,. use force_fit_type, which checks against the precision.  */\n+  if (TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n+      && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST)\n+    {\n+      if (TREE_UNSIGNED (type))\n+\treturn (! INT_CST_LT_UNSIGNED (TYPE_MAX_VALUE (type), c)\n+\t\t&& ! INT_CST_LT_UNSIGNED (c, TYPE_MIN_VALUE (type))\n+\t\t/* Negative ints never fit unsigned types.  */\n+\t\t&& ! (TREE_INT_CST_HIGH (c) < 0\n+\t\t      && ! TREE_UNSIGNED (TREE_TYPE (c))));\n+      else\n+\treturn (! INT_CST_LT (TYPE_MAX_VALUE (type), c)\n+\t\t&& ! INT_CST_LT (c, TYPE_MIN_VALUE (type))\n+\t\t/* Unsigned ints with top bit set never fit signed types.  */\n+\t\t&& ! (TREE_INT_CST_HIGH (c) < 0\n+\t\t      && TREE_UNSIGNED (TREE_TYPE (c))));\n+    }\n   else\n-    return (! (TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n-\t       && INT_CST_LT (TYPE_MAX_VALUE (type), c))\n-\t    && ! (TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n-\t\t  && INT_CST_LT (c, TYPE_MIN_VALUE (type)))\n-\t    /* Unsigned ints with top bit set never fit signed types.  */\n-\t    && ! (TREE_INT_CST_HIGH (c) < 0\n-\t\t  && TREE_UNSIGNED (TREE_TYPE (c))));\n+    {\n+      c = copy_node (c);\n+      TREE_TYPE (c) = type;\n+      return !force_fit_type (c, 0);\n+    }\n }\n \n /* Given a DECL or TYPE, return the scope in which it was declared, or"}]}