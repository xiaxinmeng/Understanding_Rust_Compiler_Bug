{"sha": "43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNhNjhhOWRmNWI5N2VmYWU4NmIzZThhYjQ3Nzc2ZGM5ZDdmYTcwMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-02-06T18:15:01Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-02-06T18:15:01Z"}, "message": "re PR fortran/63205 ([OOP] Wrongly rejects  type = class (for identical declared type))\n\n2015-02-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/63205\n\t* gfortran.h: Add 'must finalize' field to gfc_expr and\n\tprototypes for gfc_is_alloc_class_scalar_function and for\n\tgfc_is_alloc_class_array_function.\n\t* expr.c (gfc_is_alloc_class_scalar_function,\n\tgfc_is_alloc_class_array_function): New functions.\n\t* trans-array.c (gfc_add_loop_ss_code): Do not move the\n\texpression for allocatable class scalar functions outside the\n\tloop.\n\t(conv_array_index_offset): Cope with deltas being NULL_TREE.\n\t(build_class_array_ref): Do not return with allocatable class\n\tarray functions. Add code to pick out the returned class array.\n\tDereference if necessary and return if not a class object.\n\t(gfc_conv_scalarized_array_ref): Cope with offsets being NULL.\n\t(gfc_walk_function_expr): Return an array ss for the result of\n\tan allocatable class array function.\n\t* trans-expr.c (gfc_conv_subref_array_arg): Remove the assert\n\tthat the argument should be a variable. If an allocatable class\n\tarray function, set the offset to zero and skip the write-out\n\tloop in this case.\n\t(gfc_conv_procedure_call): Add allocatable class array function\n\tto the assert. Call gfc_conv_subref_array_arg for allocatable\n\tclass array function arguments with derived type formal arg..\n\tAdd the code for handling allocatable class functions, including\n\tfinalization calls to prevent memory leaks.\n\t(arrayfunc_assign_needs_temporary): Return if an allocatable\n\tclass array function.\n\t(gfc_trans_assignment_1): Set must_finalize to rhs expression\n\tfor allocatable class functions. Set scalar_to_array as needed\n\tfor scalar class allocatable functions assigned to an array.\n\tNullify the allocatable components corresponding the the lhs\n\tderived type so that the finalization does not free them.\n\n2015-02-06  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/63205\n\t* gfortran.dg/class_to_type_4.f90: New test\n\nFrom-SVN: r220482", "tree": {"sha": "c47511952bfacc8f9531ab1e507074197c8f3071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c47511952bfacc8f9531ab1e507074197c8f3071"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/comments", "author": null, "committer": null, "parents": [{"sha": "898c81f8312dedffeed01aac035324a698c249c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898c81f8312dedffeed01aac035324a698c249c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/898c81f8312dedffeed01aac035324a698c249c7"}], "stats": {"total": 414, "additions": 395, "deletions": 19}, "files": [{"sha": "36772ab51151d55140d55480a57b4435ccbe0928", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "patch": "@@ -1,16 +1,47 @@\n+2015-02-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/63205\n+\t* gfortran.h: Add 'must finalize' field to gfc_expr and\n+\tprototypes for gfc_is_alloc_class_scalar_function and for\n+\tgfc_is_alloc_class_array_function.\n+\t* expr.c (gfc_is_alloc_class_scalar_function,\n+\tgfc_is_alloc_class_array_function): New functions.\n+\t* trans-array.c (gfc_add_loop_ss_code): Do not move the\n+\texpression for allocatable class scalar functions outside the\n+\tloop.\n+\t(conv_array_index_offset): Cope with deltas being NULL_TREE.\n+\t(build_class_array_ref): Do not return with allocatable class\n+\tarray functions. Add code to pick out the returned class array.\n+\tDereference if necessary and return if not a class object.\n+\t(gfc_conv_scalarized_array_ref): Cope with offsets being NULL.\n+\t(gfc_walk_function_expr): Return an array ss for the result of\n+\tan allocatable class array function.\n+\t* trans-expr.c (gfc_conv_subref_array_arg): Remove the assert\n+\tthat the argument should be a variable. If an allocatable class\n+\tarray function, set the offset to zero and skip the write-out\n+\tloop in this case.\n+\t(gfc_conv_procedure_call): Add allocatable class array function\n+\tto the assert. Call gfc_conv_subref_array_arg for allocatable\n+\tclass array function arguments with derived type formal arg..\n+\tAdd the code for handling allocatable class functions, including\n+\tfinalization calls to prevent memory leaks.\n+\t(arrayfunc_assign_needs_temporary): Return if an allocatable\n+\tclass array function.\n+\t(gfc_trans_assignment_1): Set must_finalize to rhs expression\n+\tfor allocatable class functions. Set scalar_to_array as needed\n+\tfor scalar class allocatable functions assigned to an array.\n+\tNullify the allocatable components corresponding the the lhs\n+\tderived type so that the finalization does not free them.\n \n-2015-01-29  Andre Vehreschild  <vehre@gmx.de>, Janus Weil  <janus@gcc.gnu.org>\n+2015-01-29  Andre Vehreschild  <vehre@gmx.de>\n+\t    Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/60289\n \tInitial patch by Janus Weil\n-\t* resolve.c (resolve_allocate_expr): Add check for comp. only when \n-\ttarget is not unlimited polymorphic.\n-\t* trans-stmt.c (gfc_trans_allocate): Assign correct value to _len\n-\tcomponent of unlimited polymorphic entities.\n-\n-2015-01-29  Andre Vehreschild  <vehre@gmx.de>\n-\n-\t* gfortran.dg/unlimited_polymorphic_22.f90: New test.\n+\t* resolve.c (resolve_allocate_expr): Add check for comp. only\n+\twhen target is not unlimited polymorphic.\n+\t* trans-stmt.c (gfc_trans_allocate): Assign correct value to\n+\t_len component of unlimited polymorphic entities.\n \n 2015-02-05  Tobias Burnus  <burnus@net-b.de>\n "}, {"sha": "ab6f7a522054c15d307d0dccf7197f028003a50e", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "patch": "@@ -4304,6 +4304,40 @@ gfc_is_proc_ptr_comp (gfc_expr *expr)\n }\n \n \n+/* Determine if an expression is a function with an allocatable class scalar\n+   result.  */\n+bool\n+gfc_is_alloc_class_scalar_function (gfc_expr *expr)\n+{\n+  if (expr->expr_type == EXPR_FUNCTION\n+      && expr->value.function.esym\n+      && expr->value.function.esym->result\n+      && expr->value.function.esym->result->ts.type == BT_CLASS\n+      && !CLASS_DATA (expr->value.function.esym->result)->attr.dimension\n+      && CLASS_DATA (expr->value.function.esym->result)->attr.allocatable)\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Determine if an expression is a function with an allocatable class array\n+   result.  */\n+bool\n+gfc_is_alloc_class_array_function (gfc_expr *expr)\n+{\n+  if (expr->expr_type == EXPR_FUNCTION\n+      && expr->value.function.esym\n+      && expr->value.function.esym->result\n+      && expr->value.function.esym->result->ts.type == BT_CLASS\n+      && CLASS_DATA (expr->value.function.esym->result)->attr.dimension\n+      && CLASS_DATA (expr->value.function.esym->result)->attr.allocatable)\n+    return true;\n+\n+  return false;\n+}\n+\n+\n /* Walk an expression tree and check each variable encountered for being typed.\n    If strict is not set, a top-level variable is tolerated untyped in -std=gnu\n    mode as is a basic arithmetic expression using those; this is for things in"}, {"sha": "ff0054e70290c4a7084288c3e248e402dfeaaf74", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "patch": "@@ -1969,6 +1969,9 @@ typedef struct gfc_expr\n   /* Mark an expression as being a MOLD argument of ALLOCATE.  */\n   unsigned int mold : 1;\n \n+  /* Will require finalization after use.  */\n+  unsigned int must_finalize : 1;\n+\n   /* If an expression comes from a Hollerith constant or compile-time\n      evaluation of a transfer statement, it may have a prescribed target-\n      memory representation, and these cannot always be backformed from\n@@ -2988,6 +2991,8 @@ bool gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n \n gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);\n bool gfc_is_proc_ptr_comp (gfc_expr *);\n+bool gfc_is_alloc_class_scalar_function (gfc_expr *);\n+bool gfc_is_alloc_class_array_function (gfc_expr *);\n \n bool gfc_ref_this_image (gfc_ref *ref);\n bool gfc_is_coindexed (gfc_expr *);"}, {"sha": "642110dc41f9876636c19db33d861f69e8e48251", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "patch": "@@ -2474,7 +2474,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n \n-\t  if (expr->ts.type != BT_CHARACTER)\n+\t  if (expr->ts.type != BT_CHARACTER\n+\t      && !gfc_is_alloc_class_scalar_function (expr))\n \t    {\n \t      /* Move the evaluation of scalar expressions outside the\n \t\t scalarization loop, except for WHERE assignments.  */\n@@ -2955,7 +2956,7 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n \tstride = gfc_conv_descriptor_stride_get (info->descriptor,\n \t\t\t\t\t\t gfc_rank_cst[dim]);\n \n-      if (!integer_zerop (info->delta[dim]))\n+      if (info->delta[dim] && !integer_zerop (info->delta[dim]))\n \tindex = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t gfc_array_index_type, index, info->delta[dim]);\n     }\n@@ -2984,7 +2985,9 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n   gfc_ref *class_ref;\n   gfc_typespec *ts;\n \n-  if (expr == NULL || expr->ts.type != BT_CLASS)\n+  if (expr == NULL\n+      || (expr->ts.type != BT_CLASS\n+\t  && !gfc_is_alloc_class_array_function (expr)))\n     return false;\n \n   if (expr->symtree && expr->symtree->n.sym->ts.type == BT_CLASS)\n@@ -3018,6 +3021,30 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n       gcc_assert (expr->symtree->n.sym->backend_decl == current_function_decl);\n       decl = gfc_get_fake_result_decl (expr->symtree->n.sym, 0);\n     }\n+  else if (gfc_is_alloc_class_array_function (expr))\n+    {\n+      size = NULL_TREE;\n+      decl = NULL_TREE;\n+      for (tmp = base; tmp; tmp = TREE_OPERAND (tmp, 0))\n+\t{\n+\t  tree type;\n+\t  type = TREE_TYPE (tmp);\n+\t  while (type)\n+\t    {\n+\t      if (GFC_CLASS_TYPE_P (type))\n+\t\tdecl = tmp;\n+\t      if (type != TYPE_CANONICAL (type))\n+\t\ttype = TYPE_CANONICAL (type);\n+\t      else\n+\t\ttype = NULL_TREE;\n+\t    }\n+\t  if (TREE_CODE (tmp) == VAR_DECL)\n+\t    break;\n+\t}\n+\n+      if (decl == NULL_TREE)\n+\treturn false;\n+    }\n   else if (class_ref == NULL)\n     decl = expr->symtree->n.sym->backend_decl;\n   else\n@@ -3033,6 +3060,12 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n       class_ref->next = ref;\n     }\n \n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    decl = build_fold_indirect_ref_loc (input_location, decl);\n+\n+  if (!GFC_CLASS_TYPE_P (TREE_TYPE (decl)))\n+    return false;\n+\n   size = gfc_vtable_size_get (decl);\n \n   /* Build the address of the element.  */\n@@ -3075,7 +3108,7 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n   index = conv_array_index_offset (se, ss, ss->dim[n], n, ar, info->stride0);\n   /* Add the offset for this dimension to the stored offset for all other\n      dimensions.  */\n-  if (!integer_zerop (info->offset))\n+  if (info->offset && !integer_zerop (info->offset))\n     index = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n \t\t\t     index, info->offset);\n \n@@ -9049,6 +9082,11 @@ gfc_walk_function_expr (gfc_ss * ss, gfc_expr * expr)\n   if (!sym)\n     sym = expr->symtree->n.sym;\n \n+  if (gfc_is_alloc_class_array_function (expr))\n+    return gfc_get_array_ss (ss, expr,\n+\t\t\t     CLASS_DATA (expr->value.function.esym->result)->as->rank,\n+\t\t\t     GFC_SS_FUNCTION);\n+\n   /* A function that returns arrays.  */\n   comp = gfc_get_proc_ptr_comp (expr);\n   if ((!comp && gfc_return_by_reference (sym) && sym->result->attr.dimension)"}, {"sha": "d6f84ff04def738e255edcb52cc3bc4c8c7f0052", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 146, "deletions": 6, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "patch": "@@ -3875,8 +3875,6 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n   int n;\n   int dimen;\n \n-  gcc_assert (expr->expr_type == EXPR_VARIABLE);\n-\n   gfc_init_se (&lse, NULL);\n   gfc_init_se (&rse, NULL);\n \n@@ -3936,6 +3934,16 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n   /* Translate the expression.  */\n   gfc_conv_expr (&rse, expr);\n \n+  /* Reset the offset for the function call since the loop\n+     is zero based on the data pointer.  Note that the temp\n+     comes first in the loop chain since it is added second.  */\n+  if (gfc_is_alloc_class_array_function (expr))\n+    {\n+      tmp = loop.ss->loop_chain->info->data.array.descriptor;\n+      gfc_conv_descriptor_offset_set (&loop.pre, tmp,\n+\t\t\t\t      gfc_index_zero_node);\n+    }\n+\n   gfc_conv_tmp_array_ref (&lse);\n \n   if (intent != INTENT_OUT)\n@@ -3975,6 +3983,12 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n   gfc_init_loopinfo (&loop2);\n   gfc_add_ss_to_loop (&loop2, lss);\n \n+  dimen = rse.ss->dimen;\n+\n+  /* Skip the write-out loop for this case.  */\n+  if (gfc_is_alloc_class_array_function (expr))\n+    goto class_array_fcn;\n+\n   /* Calculate the bounds of the scalarization.  */\n   gfc_conv_ss_startstride (&loop2);\n \n@@ -3998,7 +4012,6 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n      outside the innermost loop, so the overall transfer could be\n      optimized further.  */\n   info = &rse.ss->info->data.array;\n-  dimen = rse.ss->dimen;\n \n   tmp_index = gfc_index_zero_node;\n   for (n = dimen - 1; n > 0; n--)\n@@ -4057,6 +4070,8 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n       gfc_add_block_to_block (&parmse->post, &loop2.post);\n     }\n \n+class_array_fcn:\n+\n   gfc_add_block_to_block (&parmse->post, &loop.post);\n \n   gfc_cleanup_loop (&loop);\n@@ -4199,9 +4214,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    {\n \t      gcc_assert ((!comp && gfc_return_by_reference (sym)\n \t\t\t   && sym->result->attr.dimension)\n-\t\t\t  || (comp && comp->attr.dimension));\n+\t\t\t  || (comp && comp->attr.dimension)\n+\t\t\t  || gfc_is_alloc_class_array_function (expr));\n \t      gcc_assert (se->loop != NULL);\n-\n \t      /* Access the previously obtained result.  */\n \t      gfc_conv_tmp_array_ref (se);\n \t      return 0;\n@@ -4839,6 +4854,18 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tgfc_conv_subref_array_arg (&parmse, e, f,\n \t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n \t\t\t\tfsym && fsym->attr.pointer);\n+\n+\t      else if (gfc_is_alloc_class_array_function (e)\n+\t\t\t && fsym && fsym->ts.type == BT_DERIVED)\n+\t\t/* See previous comment.  For function actual argument,\n+\t\t   the write out is not needed so the intent is set as\n+\t\t   intent in.  */\n+\t\t{\n+\t\t  e->must_finalize = 1;\n+\t\t  gfc_conv_subref_array_arg (&parmse, e, f,\n+\t\t\t\t\t     INTENT_IN,\n+\t\t\t\t\t     fsym && fsym->attr.pointer);\n+\t\t}\n \t      else\n \t        gfc_conv_array_parameter (&parmse, e, f, fsym, sym->name, NULL);\n \n@@ -5576,7 +5603,80 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t}\n     }\n   else\n-    gfc_add_block_to_block (&se->post, &post);\n+    {\n+      /* For a function with a class array result, save the result as\n+\t a temporary, set the info fields needed by the scalarizer and\n+\t call the finalization function of the temporary. Note that the\n+\t nullification of allocatable components needed by the result\n+\t is done in gfc_trans_assignment_1.  */\n+      if (expr && ((gfc_is_alloc_class_array_function (expr)\n+\t\t    && se->ss && se->ss->loop)\n+\t\t   || gfc_is_alloc_class_scalar_function (expr))\n+\t  && se->expr && GFC_CLASS_TYPE_P (TREE_TYPE (se->expr))\n+\t  && expr->must_finalize)\n+\t{\n+\t  tree final_fndecl;\n+\t  tree is_final;\n+\t  int n;\n+\t  if (se->ss && se->ss->loop)\n+\t    {\n+\t      se->expr = gfc_evaluate_now (se->expr, &se->ss->loop->pre);\n+\t      tmp = gfc_class_data_get (se->expr);\n+\t      info->descriptor = tmp;\n+\t      info->data = gfc_conv_descriptor_data_get (tmp);\n+\t      info->offset = gfc_conv_descriptor_offset_get (tmp);\n+\t      for (n = 0; n < se->ss->loop->dimen; n++)\n+\t\t{\n+\t\t  tree dim = gfc_rank_cst[n];\n+\t\t  se->ss->loop->to[n] = gfc_conv_descriptor_ubound_get (tmp, dim);\n+\t\t  se->ss->loop->from[n] = gfc_conv_descriptor_lbound_get (tmp, dim);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* TODO Eliminate the doubling of temporaries. This\n+\t\t one is necessary to ensure no memory leakage.  */\n+\t      se->expr = gfc_evaluate_now (se->expr, &se->pre);\n+\t      tmp = gfc_class_data_get (se->expr);\n+\t      tmp = gfc_conv_scalar_to_descriptor (se, tmp,\n+\t\t\tCLASS_DATA (expr->value.function.esym->result)->attr);\n+\t    }\n+\n+\t  final_fndecl = gfc_vtable_final_get (se->expr);\n+\t  is_final = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t      boolean_type_node,\n+ \t\t\t    \t      final_fndecl,\n+\t\t\t\t      fold_convert (TREE_TYPE (final_fndecl),\n+\t\t\t\t\t   \t    null_pointer_node));\n+\t  final_fndecl = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t      final_fndecl);\n+ \t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t     final_fndecl, 3,\n+\t\t\t\t     gfc_build_addr_expr (NULL, tmp),\n+\t\t\t\t     gfc_vtable_size_get (se->expr),\n+\t\t\t\t     boolean_false_node);\n+ \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t void_type_node, is_final, tmp,\n+\t\t\t\t build_empty_stmt (input_location));\n+\n+\t  if (se->ss && se->ss->loop)\n+\t    {\n+\t      gfc_add_expr_to_block (&se->ss->loop->post, tmp);\n+\t      tmp = gfc_call_free (convert (pvoid_type_node, info->data));\n+\t      gfc_add_expr_to_block (&se->ss->loop->post, tmp);\n+\t    }\n+\t  else\n+\t    {\n+\t      gfc_add_expr_to_block (&se->post, tmp);\n+\t      tmp = gfc_class_data_get (se->expr);\n+\t      tmp = gfc_call_free (convert (pvoid_type_node, tmp));\n+\t      gfc_add_expr_to_block (&se->post, tmp);\n+\t    }\n+\t  expr->must_finalize = 0;\n+\t}\n+\n+      gfc_add_block_to_block (&se->post, &post);\n+    }\n \n   return has_alternate_specifier;\n }\n@@ -7661,6 +7761,11 @@ arrayfunc_assign_needs_temporary (gfc_expr * expr1, gfc_expr * expr2)\n   bool c = false;\n   gfc_symbol *sym = expr1->symtree->n.sym;\n \n+  /* Play it safe with class functions assigned to a derived type.  */\n+  if (gfc_is_alloc_class_array_function (expr2)\n+      && expr1->ts.type == BT_DERIVED)\n+    return true;\n+\n   /* The caller has already checked rank>0 and expr_type == EXPR_FUNCTION.  */\n   if (expr2->value.function.isym && !gfc_is_intrinsic_libcall (expr2))\n     return true;\n@@ -8530,6 +8635,12 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t     && expr2->value.function.isym != NULL))\n     lss->is_alloc_lhs = 1;\n   rss = NULL;\n+\n+  if ((expr1->ts.type == BT_DERIVED)\n+      && (gfc_is_alloc_class_array_function (expr2)\n+\t  || gfc_is_alloc_class_scalar_function (expr2)))\n+    expr2->must_finalize = 1;\n+\n   if (lss != gfc_ss_terminator)\n     {\n       /* The assignment needs scalarization.  */\n@@ -8598,6 +8709,14 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   /* Translate the expression.  */\n   gfc_conv_expr (&rse, expr2);\n \n+  /* Deal with the case of a scalar class function assigned to a derived type.  */\n+  if (gfc_is_alloc_class_scalar_function (expr2)\n+      && expr1->ts.type == BT_DERIVED)\n+    {\n+      rse.expr = gfc_class_data_get (rse.expr);\n+      rse.expr = build_fold_indirect_ref_loc (input_location, rse.expr);\n+    }\n+\n   /* Stabilize a string length for temporaries.  */\n   if (expr2->ts.type == BT_CHARACTER)\n     string_length = gfc_evaluate_now (rse.string_length, &rse.pre);\n@@ -8621,6 +8740,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t\t       && !expr_is_variable (expr2)\n \t\t       && !gfc_is_constant_expr (expr2)\n \t\t       && expr1->rank && !expr2->rank);\n+  scalar_to_array |= (expr1->ts.type == BT_DERIVED\n+\t\t\t\t    && expr1->rank\n+\t\t\t\t    && expr1->ts.u.derived->attr.alloc_comp\n+\t\t\t\t    && gfc_is_alloc_class_scalar_function (expr2));\n   if (scalar_to_array && dealloc)\n     {\n       tmp = gfc_deallocate_alloc_comp_no_caf (expr2->ts.u.derived, rse.expr, 0);\n@@ -8635,6 +8758,23 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   if (flag_realloc_lhs && expr2->ts.type == BT_CHARACTER && expr1->ts.deferred)\n     gfc_add_block_to_block (&block, &rse.pre);\n \n+  /* Nullify the allocatable components corresponding to those of the lhs\n+     derived type, so that the finalization of the function result does not\n+     affect the lhs of the assignment. Prepend is used to ensure that the\n+     nullification occurs before the call to the finalizer. In the case of\n+     a scalar to array assignment, this is done in gfc_trans_scalar_assign\n+     as part of the deep copy.  */\n+  if (!scalar_to_array && (expr1->ts.type == BT_DERIVED)\n+\t\t\t\t\t      && (gfc_is_alloc_class_array_function (expr2)\n+\t\t\t\t\t\t      || gfc_is_alloc_class_scalar_function (expr2)))\n+    {\n+      tmp = rse.expr;\n+      tmp = gfc_nullify_alloc_comp (expr1->ts.u.derived, rse.expr, 0);\n+      gfc_prepend_expr_to_block (&rse.post, tmp);\n+      if (lss != gfc_ss_terminator && rss == gfc_ss_terminator)\n+\tgfc_add_block_to_block (&loop.post, &rse.post);\n+    }\n+\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n \t\t\t\t l_is_temp || init_flag,\n \t\t\t\t expr_is_variable (expr2) || scalar_to_array"}, {"sha": "921478ec5c727fcf047b3b544af6bd6052f5ab47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "patch": "@@ -1,3 +1,12 @@\n+2015-02-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/63205\n+\t* gfortran.dg/class_to_type_4.f90: New test\n+\n+2015-01-29  Andre Vehreschild  <vehre@gmx.de>\n+\n+\t* gfortran.dg/unlimited_polymorphic_22.f90: New test.\n+\n 2015-02-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/64957"}, {"sha": "cfa6d26339c6dc6d74992d78587c050cb5812dec", "filename": "gcc/testsuite/gfortran.dg/class_to_type_4.f90", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_to_type_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a68a9df5b97efae86b3e8ab47776dc9d7fa702/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_to_type_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_to_type_4.f90?ref=43a68a9df5b97efae86b3e8ab47776dc9d7fa702", "patch": "@@ -0,0 +1,119 @@\n+! { dg-do run }\n+!\n+! PR fortran/63205\n+!\n+! Check that passing a CLASS function result to a derived TYPE works\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+\n+program test\n+  implicit none\n+  type t\n+    integer :: ii\n+  end type t\n+  type, extends(t) :: u\n+    real :: rr\n+  end type u\n+  type, extends(t) :: v\n+    real, allocatable :: rr(:)\n+  end type v\n+  type, extends(v) :: w\n+    real, allocatable :: rrr(:)\n+  end type w\n+\n+  type(t) :: x, y(3)\n+  type(v) :: a, b(3)\n+\n+  x = func1() ! scalar to scalar - no alloc comps\n+  if (x%ii .ne. 77) call abort\n+\n+  y = func2() ! array to array - no alloc comps\n+  if (any (y%ii .ne. [1,2,3])) call abort\n+\n+  y = func1() ! scalar to array - no alloc comps\n+  if (any (y%ii .ne. 77)) call abort\n+\n+  x = func3() ! scalar daughter type to scalar - no alloc comps\n+  if (x%ii .ne. 99) call abort\n+\n+  y = func4() ! array daughter type to array - no alloc comps\n+  if (any (y%ii .ne. [3,4,5])) call abort\n+\n+  y = func3() ! scalar daughter type to array - no alloc comps\n+  if (any (y%ii .ne. [99,99,99])) call abort\n+\n+  a = func5() ! scalar to scalar - alloc comps in parent type\n+  if (any (a%rr .ne. [10.0,20.0])) call abort\n+\n+  b = func6() ! array to array - alloc comps in parent type\n+  if (any (b(3)%rr .ne. [3.0,4.0])) call abort\n+\n+  a = func7() ! scalar daughter type to scalar - alloc comps in parent type\n+  if (any (a%rr .ne. [10.0,20.0])) call abort\n+\n+  b = func8() ! array daughter type to array - alloc comps in parent type\n+  if (any (b(3)%rr .ne. [3.0,4.0])) call abort\n+\n+  b = func7() ! scalar daughter type to array - alloc comps in parent type\n+  if (any (b(2)%rr .ne. [10.0,20.0])) call abort\n+\n+! This is an extension of class_to_type_2.f90's test using a daughter type\n+! instead of the declared type.\n+  if (subpr2_array (g ()) .ne. 99 ) call abort\n+contains\n+\n+  function func1() result(res)\n+    class(t), allocatable :: res\n+    allocate (res, source = t(77))\n+  end function func1\n+\n+  function func2() result(res)\n+    class(t), allocatable :: res(:)\n+    allocate (res(3), source = [u(1,1.0),u(2,2.0),u(3,3.0)])\n+  end function func2\n+\n+  function func3() result(res)\n+    class(t), allocatable :: res\n+    allocate (res, source = v(99,[99.0,99.0,99.0]))\n+  end function func3\n+\n+  function func4() result(res)\n+    class(t), allocatable :: res(:)\n+    allocate (res(3), source = [v(3,[1.0,2.0]),v(4,[2.0,3.0]),v(5,[3.0,4.0])])\n+  end function func4\n+\n+  function func5() result(res)\n+    class(v), allocatable :: res\n+    allocate (res, source = v(3,[10.0,20.0]))\n+  end function func5\n+\n+  function func6() result(res)\n+    class(v), allocatable :: res(:)\n+    allocate (res(3), source = [v(3,[1.0,2.0]),v(4,[2.0,3.0]),v(5,[3.0,4.0])])\n+  end function func6\n+\n+  function func7() result(res)\n+    class(v), allocatable :: res\n+    allocate (res, source = w(3,[10.0,20.0],[100,200]))\n+  end function func7\n+\n+  function func8() result(res)\n+    class(v), allocatable :: res(:)\n+    allocate (res(3), source = [w(3,[1.0,2.0],[0.0]),w(4,[2.0,3.0],[0.0]),w(5,[3.0,4.0],[0.0])])\n+  end function func8\n+\n+\n+  integer function subpr2_array (x)\n+    type(t) :: x(:)\n+    if (any(x(:)%ii /= 55)) call abort\n+    subpr2_array = 99\n+  end function\n+\n+  function g () result(res)\n+    integer i\n+    class(t), allocatable :: res(:)\n+    allocate (res(3), source = [(v (1, [1.0,2.0]), i = 1, 3)])\n+    res(:)%ii = 55\n+  end function g\n+end program test"}]}