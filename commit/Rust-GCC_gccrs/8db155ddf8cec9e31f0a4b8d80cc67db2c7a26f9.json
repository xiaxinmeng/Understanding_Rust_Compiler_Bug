{"sha": "8db155ddf8cec9e31f0a4b8d80cc67db2c7a26f9", "node_id": "C_kwDOANBUbNoAKDhkYjE1NWRkZjhjZWM5ZTMxZjBhNGI4ZDgwY2M2N2RiMmM3YTI2Zjk", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-03-17T14:52:10Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-03-17T20:43:21Z"}, "message": "Always use dominators in the cache when available.\n\nThis patch adjusts range_from_dom to follow the dominator tree through the\ncache until value is found, then apply any outgoing ranges encountered\nalong the way.  This reduces the amount of cache storage required.\n\n\tPR tree-optimization/102943\n\t* gimple-range-cache.cc (ranger_cache::range_from_dom): Find range via\n\tdominators and apply intermediary outgoing edge ranges.", "tree": {"sha": "8f9cf5ab457a7f7cf05830a25745306a909f61d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f9cf5ab457a7f7cf05830a25745306a909f61d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8db155ddf8cec9e31f0a4b8d80cc67db2c7a26f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db155ddf8cec9e31f0a4b8d80cc67db2c7a26f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8db155ddf8cec9e31f0a4b8d80cc67db2c7a26f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db155ddf8cec9e31f0a4b8d80cc67db2c7a26f9/comments", "author": null, "committer": null, "parents": [{"sha": "00df7ee4474faca91d3460fe78a88e280c6c1126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00df7ee4474faca91d3460fe78a88e280c6c1126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00df7ee4474faca91d3460fe78a88e280c6c1126"}], "stats": {"total": 103, "additions": 75, "deletions": 28}, "files": [{"sha": "421ea1a20ef9c3d4cbfb92156c986468a8ed0790", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 75, "deletions": 28, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db155ddf8cec9e31f0a4b8d80cc67db2c7a26f9/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db155ddf8cec9e31f0a4b8d80cc67db2c7a26f9/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=8db155ddf8cec9e31f0a4b8d80cc67db2c7a26f9", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"gimple-iterator.h\"\n #include \"gimple-walk.h\"\n+#include \"cfganal.h\"\n \n #define DEBUG_RANGE_CACHE (dump_file\t\t\t\t\t\\\n \t\t\t   && (param_ranger_debug & RANGER_DEBUG_CACHE))\n@@ -1398,62 +1399,108 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n }\n \n \n-// Check to see if we can simply get the range from the dominator.\n+// Get the range of NAME from dominators of BB and return it in R.\n \n bool\n-ranger_cache::range_from_dom (irange &r, tree name, basic_block bb)\n+ranger_cache::range_from_dom (irange &r, tree name, basic_block start_bb)\n {\n-  gcc_checking_assert (dom_info_available_p (CDI_DOMINATORS));\n+  if (!dom_info_available_p (CDI_DOMINATORS))\n+    return false;\n \n   // Search back to the definition block or entry block.\n   basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (name));\n   if (def_bb == NULL)\n     def_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n \n+  basic_block bb;\n+  basic_block prev_bb = start_bb;\n   // Flag if we encounter a block with non-null set.\n   bool non_null = false;\n-  for (bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n-       bb && bb != def_bb;\n-       bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+\n+  // Range on entry to the DEF block should not be queried.\n+  gcc_checking_assert (start_bb != def_bb);\n+  m_workback.truncate (0);\n+\n+  // Default value is global range.\n+  get_global_range (r, name);\n+\n+  // Search until a value is found, pushing outgoing edges encountered.\n+  for (bb = get_immediate_dominator (CDI_DOMINATORS, start_bb);\n+       bb;\n+       prev_bb = bb, bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n-      // If there is an outgoing range, the on-entry value won't work.\n+      if (!non_null)\n+\tnon_null |= m_non_null.non_null_deref_p (name, bb, false);\n+\n+      // This block has an outgoing range.\n       if (m_gori.has_edge_range_p (name, bb))\n \t{\n-\t  // Check if we can seed this block with a dominator value. THis will\n-\t  // prevent the ache from being filled back further than this.\n-\t  if (bb != def_bb && range_from_dom (r, name, bb))\n-\t    m_on_entry.set_bb_range (name, bb, r);\n-\t  return false;\n+\t  // Only outgoing ranges to single_pred blocks are dominated by\n+\t  // outgoing edge ranges, so only those need to be considered.\n+\t  edge e = find_edge (bb, prev_bb);\n+\t  if (e && single_pred_p (prev_bb))\n+\t    m_workback.quick_push (prev_bb);\n \t}\n \n-      // Flag if we see a non-null reference during this walk.\n-      if (m_non_null.non_null_deref_p (name, bb, false))\n-\tnon_null = true;\n+      if (def_bb == bb)\n+\tbreak;\n \n-      // If range-on-entry is set in this block, it can be used.\n       if (m_on_entry.get_bb_range (r, name, bb))\n+\tbreak;\n+    }\n+\n+  if (DEBUG_RANGE_CACHE)\n+    {\n+      fprintf (dump_file, \"CACHE: BB %d DOM query, found \", start_bb->index);\n+      r.dump (dump_file);\n+      if (bb)\n+\tfprintf (dump_file, \" at BB%d\\n\", bb->index);\n+      else\n+\tfprintf (dump_file, \" at function top\\n\");\n+    }\n+\n+  // Now process any outgoing edges that we seen along the way.\n+  while (m_workback.length () > 0)\n+    {\n+      int_range_max edge_range;\n+      prev_bb = m_workback.pop ();\n+      edge e = single_pred_edge (prev_bb);\n+      bb = e->src;\n+\n+      if (m_gori.outgoing_edge_range_p (edge_range, e, name, *this))\n \t{\n-\t  // Apply non-null if appropriate.\n-\t  if (r.varying_p () && non_null)\n+\t  r.intersect (edge_range);\n+\t  if (r.varying_p () && ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0))\n \t    {\n-\t      gcc_checking_assert (POINTER_TYPE_P (TREE_TYPE (name)));\n-\t      r.set_nonzero (TREE_TYPE (name));\n+\t      if (m_non_null.non_null_deref_p (name, bb, false))\n+\t\t{\n+\t\t  gcc_checking_assert (POINTER_TYPE_P (TREE_TYPE (name)));\n+\t\t  r.set_nonzero (TREE_TYPE (name));\n+\t\t}\n+\t    }\n+\t  if (DEBUG_RANGE_CACHE)\n+\t    {\n+\t      fprintf (dump_file, \"CACHE: Adjusted edge range for %d->%d : \",\n+\t\t       bb->index, prev_bb->index);\n+\t      r.dump (dump_file);\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n-\t  return true;\n \t}\n     }\n-  // If this is the def block, and NAME is an export, then this value\n-  // cannot be used.\n-  if (bb == def_bb && m_gori.has_edge_range_p (name, bb))\n-    return false;\n \n-  // Otherwise choose the global value and use it.\n-  get_global_range (r, name);\n-  if (r.varying_p () && non_null)\n+  // Apply non-null if appropriate.\n+  if (non_null && r.varying_p ()\n+      && !has_abnormal_call_or_eh_pred_edge_p (start_bb))\n     {\n       gcc_checking_assert (POINTER_TYPE_P (TREE_TYPE (name)));\n       r.set_nonzero (TREE_TYPE (name));\n     }\n+  if (DEBUG_RANGE_CACHE)\n+    {\n+      fprintf (dump_file, \"CACHE: Range for DOM returns : \");\n+      r.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n   return true;\n }\n "}]}