{"sha": "cba9c7897755fe9f7343d5428b12eea53c98b94e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JhOWM3ODk3NzU1ZmU5ZjczNDNkNTQyOGIxMmVlYTUzYzk4Yjk0ZQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-10-07T17:42:09Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-10-07T17:42:09Z"}, "message": "re PR target/66697 (Feature request: -mstackrealign and force_align_arg_pointer for x86_64)\n\n\tPR target/66697\n\t* config/i386/i386.c (ix86_option_override_internal): Always use\n\t8-byte minimum stack boundary in 64-bit mode.\n\t(ix86_compute_frame_layout): Remove assert on INCOMING_STACK_BOUNDARY.\n\t(ix86_emit_save_reg_using_mov): Support unaligned SSE store.\n\tAdd a REG_CFA_EXPRESSION note if needed.\n\t(ix86_emit_restore_sse_regs_using_mov): Support unaligned SSE load.\n\t(ix86_handle_force_align_arg_pointer_attribute): New.\n\t(ix86_minimum_incoming_stack_boundary): Remove TARGET_64BIT check.\n\t(ix86_attribute_table): Set ix86_force_align_arg_pointer_string\n\twith ix86_handle_force_align_arg_pointer_attribute.\n\t* config/i386/i386.h (MIN_STACK_BOUNDARY): Set to BITS_PER_WORD.\n\ntestsuite/ChangeLog:\n\n\tPR target/66697\n\t* gcc.target/i386/20060512-1.c: Remove ia32 requirement.\n\t(PUSH, POP): New defines.\n\t(sse2_test): Use PUSH and POP to misalign runtime stack.\n\t* gcc.target/i386/20060512-2.c: Remove ia32 requirement.\n\nFrom-SVN: r228577", "tree": {"sha": "3e395fd8afb8c4fb10c9236ec9c0e860b1e8081b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e395fd8afb8c4fb10c9236ec9c0e860b1e8081b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cba9c7897755fe9f7343d5428b12eea53c98b94e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba9c7897755fe9f7343d5428b12eea53c98b94e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba9c7897755fe9f7343d5428b12eea53c98b94e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba9c7897755fe9f7343d5428b12eea53c98b94e/comments", "author": null, "committer": null, "parents": [{"sha": "0786e1fe8688691332e6c4f9aab82956546073c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0786e1fe8688691332e6c4f9aab82956546073c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0786e1fe8688691332e6c4f9aab82956546073c5"}], "stats": {"total": 118, "additions": 97, "deletions": 21}, "files": [{"sha": "7504c567124074ca29b2608a2a76bceca2775130", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cba9c7897755fe9f7343d5428b12eea53c98b94e", "patch": "@@ -1,3 +1,18 @@\n+2015-10-07  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/66697\n+\t* config/i386/i386.c (ix86_option_override_internal): Always use\n+\t8-byte minimum stack boundary in 64-bit mode.\n+\t(ix86_compute_frame_layout): Remove assert on INCOMING_STACK_BOUNDARY.\n+\t(ix86_emit_save_reg_using_mov): Support unaligned SSE store.\n+\tAdd a REG_CFA_EXPRESSION note if needed.\n+\t(ix86_emit_restore_sse_regs_using_mov): Support unaligned SSE load.\n+\t(ix86_handle_force_align_arg_pointer_attribute): New.\n+\t(ix86_minimum_incoming_stack_boundary): Remove TARGET_64BIT check.\n+\t(ix86_attribute_table): Set ix86_force_align_arg_pointer_string\n+\twith ix86_handle_force_align_arg_pointer_attribute.\n+\t* config/i386/i386.h (MIN_STACK_BOUNDARY): Set to BITS_PER_WORD.\n+\n 2015-10-07  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n \n@@ -287,7 +302,8 @@\n \t* graphite-sese-to-poly.c (build_loop_iteration_domains): Only loops\n \twhich are in this region are passed so gcc_assert and remove redundant\n \tcomputation.\n-\t* sese.c (sese_build_liveouts): Pass only those bbs which are not in region.\n+\t* sese.c (sese_build_liveouts): Pass only those bbs which are not\n+\tin region.\n \t(sese_bad_liveouts_use): Only BBs which are not in region are passed so\n \tgcc_assert on that and remove unnecessary computation.\n \t(sese_build_liveouts_use): Same.\n@@ -500,7 +516,7 @@\n 2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n \n-        * params.def (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS): Increase to 7.\n+\t* params.def (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS): Increase to 7.\n \n 2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n@@ -1111,7 +1127,8 @@\n \t* graphite-poly.c (new_poly_bb): Same.\n \t* graphite-poly.h (gbb_from_bb): Same.\n \t* sese.h: Same.\n-\t* graphite-sese-to-poly.c (new_gimple_bb): gimple_bb_p -> gimple_poly_bb_p\n+\t* graphite-sese-to-poly.c (new_gimple_bb):\n+\tgimple_bb_p -> gimple_poly_bb_p\n \t(build_scop_scattering): Same.\n \t(find_params_in_bb): Same.\n \t(add_conditions_to_domain): Same."}, {"sha": "a24bd26c96a05d8e5aae4049cab4901943b78d59", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cba9c7897755fe9f7343d5428b12eea53c98b94e", "patch": "@@ -5209,8 +5209,7 @@ ix86_option_override_internal (bool main_args_p,\n   ix86_incoming_stack_boundary = ix86_default_incoming_stack_boundary;\n   if (opts_set->x_ix86_incoming_stack_boundary_arg)\n     {\n-      int min = (TARGET_64BIT_P (opts->x_ix86_isa_flags)\n-\t\t ? (TARGET_SSE_P (opts->x_ix86_isa_flags) ? 4 : 3) : 2);\n+      int min = TARGET_64BIT_P (opts->x_ix86_isa_flags) ? 3 : 2;\n \n       if (opts->x_ix86_incoming_stack_boundary_arg < min\n \t  || opts->x_ix86_incoming_stack_boundary_arg > 12)\n@@ -11386,7 +11385,6 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n       /* The only ABI that has saved SSE registers (Win64) also has a\n          16-byte aligned default stack, and thus we don't need to be\n \t within the re-aligned local stack frame to save them.  */\n-      gcc_assert (INCOMING_STACK_BOUNDARY >= 128);\n       offset = ROUND_UP (offset, 16);\n       offset += frame->nsseregs * 16;\n     }\n@@ -11611,14 +11609,26 @@ ix86_emit_save_reg_using_mov (machine_mode mode, unsigned int regno,\n   struct machine_function *m = cfun->machine;\n   rtx reg = gen_rtx_REG (mode, regno);\n   rtx mem, addr, base, insn;\n+  unsigned int align;\n \n   addr = choose_baseaddr (cfa_offset);\n   mem = gen_frame_mem (mode, addr);\n \n-  /* For SSE saves, we need to indicate the 128-bit alignment.  */\n-  set_mem_align (mem, GET_MODE_ALIGNMENT (mode));\n+  /* The location is aligned up to INCOMING_STACK_BOUNDARY.  */\n+  align = MIN (GET_MODE_ALIGNMENT (mode), INCOMING_STACK_BOUNDARY);\n+  set_mem_align (mem, align);\n+\n+  /* SSE saves are not within re-aligned local stack frame.\n+     In case INCOMING_STACK_BOUNDARY is misaligned, we have\n+     to emit unaligned store.  */\n+  if (mode == V4SFmode && align < 128)\n+    {\n+      rtx unspec = gen_rtx_UNSPEC (mode, gen_rtvec (1, reg), UNSPEC_STOREU);\n+      insn = emit_insn (gen_rtx_SET (mem, unspec));\n+    }\n+  else\n+    insn = emit_insn (gen_rtx_SET (mem, reg));\n \n-  insn = emit_move_insn (mem, reg);\n   RTX_FRAME_RELATED_P (insn) = 1;\n \n   base = addr;\n@@ -11665,6 +11675,8 @@ ix86_emit_save_reg_using_mov (machine_mode mode, unsigned int regno,\n       mem = gen_rtx_MEM (mode, addr);\n       add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (mem, reg));\n     }\n+  else\n+    add_reg_note (insn, REG_CFA_EXPRESSION, gen_rtx_SET (mem, reg));\n }\n \n /* Emit code to save registers using MOV insns.\n@@ -11881,6 +11893,25 @@ find_drap_reg (void)\n     }\n }\n \n+/* Handle a \"force_align_arg_pointer\" attribute.  */\n+\n+static tree\n+ix86_handle_force_align_arg_pointer_attribute (tree *node, tree name,\n+\t\t\t\t\t       tree, int, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_TYPE\n+      && TREE_CODE (*node) != METHOD_TYPE\n+      && TREE_CODE (*node) != FIELD_DECL\n+      && TREE_CODE (*node) != TYPE_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute only applies to functions\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Return minimum incoming stack alignment.  */\n \n static unsigned int\n@@ -11895,7 +11926,6 @@ ix86_minimum_incoming_stack_boundary (bool sibcall)\n      if -mstackrealign is used, it isn't used for sibcall check and\n      estimated stack alignment is 128bit.  */\n   else if (!sibcall\n-\t   && !TARGET_64BIT\n \t   && ix86_force_align_arg_pointer\n \t   && crtl->stack_alignment_estimated == 128)\n     incoming_stack_boundary = MIN_STACK_BOUNDARY;\n@@ -13179,11 +13209,26 @@ ix86_emit_restore_sse_regs_using_mov (HOST_WIDE_INT cfa_offset,\n       {\n \trtx reg = gen_rtx_REG (V4SFmode, regno);\n \trtx mem;\n+\tunsigned int align;\n \n \tmem = choose_baseaddr (cfa_offset);\n \tmem = gen_rtx_MEM (V4SFmode, mem);\n-\tset_mem_align (mem, 128);\n-\temit_move_insn (reg, mem);\n+\n+\t/* The location is aligned up to INCOMING_STACK_BOUNDARY.  */\n+\talign = MIN (GET_MODE_ALIGNMENT (V4SFmode), INCOMING_STACK_BOUNDARY);\n+\tset_mem_align (mem, align);\n+\n+\t/* SSE saves are not within re-aligned local stack frame.\n+\t   In case INCOMING_STACK_BOUNDARY is misaligned, we have\n+\t   to emit unaligned load.  */\n+\tif (align < 128)\n+\t  {\n+\t    rtx unspec = gen_rtx_UNSPEC (V4SFmode, gen_rtvec (1, mem),\n+\t\t\t\t\t UNSPEC_LOADU);\n+\t    emit_insn (gen_rtx_SET (reg, unspec));\n+\t  }\n+\telse\n+\t  emit_insn (gen_rtx_SET (reg, mem));\n \n \tix86_add_cfa_restore_note (NULL, reg, cfa_offset);\n \n@@ -48154,7 +48199,7 @@ static const struct attribute_spec ix86_attribute_table[] =\n     true },\n   /* force_align_arg_pointer says this function realigns the stack at entry.  */\n   { (const char *)&ix86_force_align_arg_pointer_string, 0, 0,\n-    false, true,  true, ix86_handle_cconv_attribute, false },\n+    false, true,  true, ix86_handle_force_align_arg_pointer_attribute, false },\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n   { \"dllimport\", 0, 0, false, false, false, handle_dll_attribute, false },\n   { \"dllexport\", 0, 0, false, false, false, handle_dll_attribute, false },"}, {"sha": "4a84fb972d12c6df94cf177bb91282f66a91bd68", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=cba9c7897755fe9f7343d5428b12eea53c98b94e", "patch": "@@ -755,7 +755,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define MAIN_STACK_BOUNDARY (TARGET_64BIT ? 128 : 32)\n \n /* Minimum stack boundary.  */\n-#define MIN_STACK_BOUNDARY (TARGET_64BIT ? (TARGET_SSE ? 128 : 64) : 32)\n+#define MIN_STACK_BOUNDARY BITS_PER_WORD\n \n /* Boundary (in *bits*) on which the stack pointer prefers to be\n    aligned; the compiler cannot rely on having this alignment.  */"}, {"sha": "cc3cd6b4f74b0a52641956bade7320c8f8d25b9d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cba9c7897755fe9f7343d5428b12eea53c98b94e", "patch": "@@ -1,6 +1,14 @@\n+2015-10-07  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/66697\n+\t* gcc.target/i386/20060512-1.c: Remove ia32 requirement.\n+\t(PUSH, POP): New defines.\n+\t(sse2_test): Use PUSH and POP to misalign runtime stack.\n+\t* gcc.target/i386/20060512-2.c: Remove ia32 requirement.\n+\n 2015-10-07  James Norris  <jnorris@codesourcery.com>\n \n-\t* testsuite/lib/atomic-dg.exp (atomic_link_flags): Move flag setting\n+\t* lib/atomic-dg.exp (atomic_link_flags): Move flag setting\n \tto atomic_init. (atomic_init): Restrict flags usage.\n \n 2015-10-07  Andre Vehreschild  <vehre@gcc.gnu.org>\n@@ -62,12 +70,12 @@\n 2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n \n-        * gcc.dg/graphite/scop-sor.c: Un-xfail.\n+\t* gcc.dg/graphite/scop-sor.c: Un-xfail.\n \n 2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n \n-        * gcc.dg/graphite/scop-sor.c: Xfail.\n+\t* gcc.dg/graphite/scop-sor.c: Xfail.\n \n 2015-10-05  Martin Jambor  <mjambor@suse.cz>\n \t    Jan Hubicka  <hubicka@ucw.cz>"}, {"sha": "ec163a9bc51e9ffd51a9052dc7856d891eb367bf", "filename": "gcc/testsuite/gcc.target/i386/20060512-1.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c?ref=cba9c7897755fe9f7343d5428b12eea53c98b94e", "patch": "@@ -1,12 +1,19 @@\n /* { dg-do run } */\n-/* { dg-require-effective-target ia32 } */\n /* { dg-options \"-std=gnu99 -msse2 -mpreferred-stack-boundary=4\" } */\n /* { dg-require-effective-target sse2 } */\n \n #include \"sse2-check.h\"\n \n #include <emmintrin.h>\n \n+#ifdef __x86_64__\n+# define PUSH \"pushq %rsi\"\n+# define POP \"popq %rsi\"\n+#else\n+# define PUSH \"pushl %esi\"\n+# define POP \"popl %esi\"\n+#endif\n+\n __m128i __attribute__ ((__noinline__))\n vector_using_function ()\n {\n@@ -27,9 +34,9 @@ static void\n sse2_test (void)\n {\n   int result;\n-  asm (\"pushl %esi\");\t\t/* Disalign runtime stack.  */\n+  asm (PUSH);                  /* Misalign runtime stack.  */\n   result = self_aligning_function (g_1, g_2);\n   if (result != 42)\n     abort ();\n-  asm (\"popl %esi\");\n+  asm (POP);\n }"}, {"sha": "8ce4bd7f8be501ebdbf839445df164bd46ae6212", "filename": "gcc/testsuite/gcc.target/i386/20060512-2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9c7897755fe9f7343d5428b12eea53c98b94e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-2.c?ref=cba9c7897755fe9f7343d5428b12eea53c98b94e", "patch": "@@ -1,5 +1,4 @@\n /* { dg-do compile } */\n-/* { dg-require-effective-target ia32 } */\n /* { dg-options \"-std=gnu99 -mpreferred-stack-boundary=4\" } */\n int\n outer_function (int x, int y)"}]}