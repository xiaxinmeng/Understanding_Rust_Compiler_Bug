{"sha": "de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU2YWE5MzM3MGI2OGE5ZmJjZjg3NGRlOGE5N2M1ZDE0NjliN2Q0Ng==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-11-28T21:41:41Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-11-28T21:41:41Z"}, "message": "PR middle-end/78521 - [7 Regression] incorrect byte count in -Wformat-length...\n\nPR middle-end/78521 - [7 Regression] incorrect byte count in -Wformat-length warning with non-constant width or precision\nPR middle-end/78520 - missing warning for snprintf with size greater than INT_MAX\n\ngcc/ChangeLog:\n\n\tPR middle-end/78520\n\t* gimple-ssa-sprintf.c (target_max_value): Remove.\n\t(target_int_max, target_size_max): Use TYPE_MAX_VALUE.\n\t(get_width_and_precision): New function.\n\t(format_integer, format_floating, get_string_length, format_string):\n\tCorrect handling of width and precision with unknown value.\n\t(format_directive): Add warning.\n\t(pass_sprintf_length::compute_format_length): Allow for precision\n\tto consist of a sole period with no asterisk or digits after it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/78520\n\t* gcc.dg/tree-ssa/builtin-sprintf-5.c: Add test cases.\n\t* gcc.dg/tree-ssa/builtin-sprintf-6.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Add test cases.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Add test cases.\n\nFrom-SVN: r242935", "tree": {"sha": "40efd43f50949c76463ec5e2f1c7e062a2449dc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40efd43f50949c76463ec5e2f1c7e062a2449dc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3a5bff4d709c8b8c6492747ef8104fb88a481b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a5bff4d709c8b8c6492747ef8104fb88a481b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3a5bff4d709c8b8c6492747ef8104fb88a481b3"}], "stats": {"total": 819, "additions": 655, "deletions": 164}, "files": [{"sha": "12a717ea7f897bf8cbbfe19a949801a17e5cae0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "patch": "@@ -1,3 +1,15 @@\n+2016-11-28  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78520\n+\t* gimple-ssa-sprintf.c (target_max_value): Remove.\n+\t(target_int_max, target_size_max): Use TYPE_MAX_VALUE.\n+\t(get_width_and_precision): New function.\n+\t(format_integer, format_floating, get_string_length, format_string):\n+\tCorrect handling of width and precision with unknown value.\n+\t(format_directive): Add warning.\n+\t(pass_sprintf_length::compute_format_length): Allow for precision\n+\tto consist of a sole period with no asterisk or digits after it.\n+\n 2016-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/78546"}, {"sha": "43bc560665dba8a962c428c11425c3b2ef5efa66", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 229, "deletions": 124, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "patch": "@@ -226,40 +226,26 @@ struct format_result\n \n /* Return the value of INT_MIN for the target.  */\n \n-static HOST_WIDE_INT\n+static inline HOST_WIDE_INT\n target_int_min ()\n {\n-  const unsigned HOST_WIDE_INT int_min\n-    = HOST_WIDE_INT_M1U << (TYPE_PRECISION (integer_type_node) - 1);\n-\n-  return int_min;\n-}\n-\n-/* Return the largest value for TYPE on the target.  */\n-\n-static unsigned HOST_WIDE_INT\n-target_max_value (tree type)\n-{\n-  const unsigned HOST_WIDE_INT max_value\n-    = HOST_WIDE_INT_M1U >> (HOST_BITS_PER_WIDE_INT\n-\t\t\t    - TYPE_PRECISION (type) + 1);\n-  return max_value;\n+  return tree_to_shwi (TYPE_MIN_VALUE (integer_type_node));\n }\n \n /* Return the value of INT_MAX for the target.  */\n \n static inline unsigned HOST_WIDE_INT\n target_int_max ()\n {\n-  return target_max_value (integer_type_node);\n+  return tree_to_uhwi (TYPE_MAX_VALUE (integer_type_node));\n }\n \n /* Return the value of SIZE_MAX for the target.  */\n \n static inline unsigned HOST_WIDE_INT\n target_size_max ()\n {\n-  return target_max_value (size_type_node);\n+  return tree_to_uhwi (TYPE_MAX_VALUE (size_type_node));\n }\n \n /* Return the constant initial value of DECL if available or DECL\n@@ -845,6 +831,43 @@ format_pointer (const conversion_spec &spec, tree arg)\n   return res;\n }\n \n+/* Set *PWIDTH and *PPREC according to the width and precision specified\n+   in SPEC.  Each is set to HOST_WIDE_INT_MIN when the corresponding\n+   field is specified but unknown, to zero for width and -1 for precision,\n+   respectively when it's not specified, or to a non-negative value\n+   corresponding to the known value.  */\n+static void\n+get_width_and_precision (const conversion_spec &spec,\n+\t\t\t HOST_WIDE_INT *pwidth, HOST_WIDE_INT *pprec)\n+{\n+  HOST_WIDE_INT width = spec.have_width ? spec.width : 0;\n+  HOST_WIDE_INT prec = spec.have_precision ? spec.precision : -1;\n+\n+  if (spec.star_width)\n+    {\n+      if (TREE_CODE (spec.star_width) == INTEGER_CST)\n+\twidth = abs (tree_to_shwi (spec.star_width));\n+      else\n+\twidth = HOST_WIDE_INT_MIN;\n+    }\n+\n+  if (spec.star_precision)\n+    {\n+      if (TREE_CODE (spec.star_precision) == INTEGER_CST)\n+\t{\n+\t  prec = tree_to_shwi (spec.star_precision);\n+\t  if (prec < 0)\n+\t    prec = 0;\n+\t}\n+      else\n+\tprec = HOST_WIDE_INT_MIN;\n+    }\n+\n+  *pwidth = width;\n+  *pprec = prec;\n+}\n+\n+\n /* Return a range representing the minimum and maximum number of bytes\n    that the conversion specification SPEC will write on output for the\n    integer argument ARG when non-null.  ARG may be null (for vararg\n@@ -855,18 +878,11 @@ format_integer (const conversion_spec &spec, tree arg)\n {\n   tree intmax_type_node;\n   tree uintmax_type_node;\n-  /* Set WIDTH and PRECISION to either the values in the format\n-     specification or to zero.  */\n-  int width = spec.have_width ? spec.width : 0;\n-  int prec = spec.have_precision ? spec.precision : 0;\n \n-  if (spec.star_width)\n-    width = (TREE_CODE (spec.star_width) == INTEGER_CST\n-\t     ? tree_to_shwi (spec.star_width) : 0);\n-\n-  if (spec.star_precision)\n-    prec = (TREE_CODE (spec.star_precision) == INTEGER_CST\n-\t    ? tree_to_shwi (spec.star_precision) : 0);\n+  /* Set WIDTH and PRECISION based on the specification.  */\n+  HOST_WIDE_INT width;\n+  HOST_WIDE_INT prec;\n+  get_width_and_precision (spec, &width, &prec);\n \n   bool sign = spec.specifier == 'd' || spec.specifier == 'i';\n \n@@ -936,15 +952,8 @@ format_integer (const conversion_spec &spec, tree arg)\n     }\n   else if (TREE_CODE (arg) == INTEGER_CST)\n     {\n-      /* The minimum and maximum number of bytes produced by\n-\t the directive.  */\n-      fmtresult res;\n-\n       /* When a constant argument has been provided use its value\n \t rather than type to determine the length of the output.  */\n-      res.bounded = true;\n-      res.constant = true;\n-      res.knownrange = true;\n \n       /* Base to format the number in.  */\n       int base;\n@@ -977,25 +986,56 @@ format_integer (const conversion_spec &spec, tree arg)\n \t  gcc_unreachable ();\n \t}\n \n-      /* Convert the argument to the type of the directive.  */\n-      arg = fold_convert (dirtype, arg);\n+      int len;\n+\n+      if ((prec == HOST_WIDE_INT_MIN || prec == 0) && integer_zerop (arg))\n+\t{\n+\t  /* As a special case, a precision of zero with an argument\n+\t     of zero results in zero bytes regardless of flags (with\n+\t     width having the normal effect).  This must extend to\n+\t     the case of a specified precision with an unknown value\n+\t     because it can be zero.  */\n+\t  len = 0;\n+\t}\n+      else\n+\t{\n+\t  /* Convert the argument to the type of the directive.  */\n+\t  arg = fold_convert (dirtype, arg);\n \n-      maybesign |= spec.get_flag ('+');\n+\t  maybesign |= spec.get_flag ('+');\n \n-      /* True when a conversion is preceded by a prefix indicating the base\n-\t of the argument (octal or hexadecimal).  */\n-      bool maybebase = spec.get_flag ('#');\n-      int len = tree_digits (arg, base, maybesign, maybebase);\n+\t  /* True when a conversion is preceded by a prefix indicating the base\n+\t     of the argument (octal or hexadecimal).  */\n+\t  bool maybebase = spec.get_flag ('#');\n+\t  len = tree_digits (arg, base, maybesign, maybebase);\n \n-      if (len < prec)\n-\tlen = prec;\n+\t  if (len < prec)\n+\t    len = prec;\n+\t}\n \n       if (len < width)\n \tlen = width;\n \n-      res.range.max = len;\n-      res.range.min = res.range.max;\n-      res.bounded = true;\n+      /* The minimum and maximum number of bytes produced by the directive.  */\n+      fmtresult res;\n+\n+      res.range.min = len;\n+\n+      /* The upper bound of the number of bytes is unlimited when either\n+\t width or precision is specified but its value is unknown, and\n+\t the same as the lower bound otherwise.  */\n+      if (width == HOST_WIDE_INT_MIN || prec == HOST_WIDE_INT_MIN)\n+\t{\n+\t  res.range.max = HOST_WIDE_INT_MAX;\n+\t}\n+      else\n+\t{\n+\t  res.range.max = len;\n+\t  res.bounded = true;\n+\t  res.constant = true;\n+\t  res.knownrange = true;\n+\t  res.bounded = true;\n+\t}\n \n       return res;\n     }\n@@ -1106,8 +1146,10 @@ format_integer (const conversion_spec &spec, tree arg)\n \t or one whose value range cannot be determined, create a T_MIN\n \t constant if the argument's type is signed and T_MAX otherwise,\n \t and use those to compute the range of bytes that the directive\n-\t can output.  */\n-      argmin = build_int_cst (argtype, 1);\n+\t can output.  When precision is specified but unknown, use zero\n+\t as the minimum since it results in no bytes on output (unless\n+\t width is specified to be greater than 0).  */\n+      argmin = build_int_cst (argtype, prec != HOST_WIDE_INT_MIN);\n \n       int typeprec = TYPE_PRECISION (dirtype);\n       int argprec = TYPE_PRECISION (argtype);\n@@ -1257,11 +1299,13 @@ format_floating (const conversion_spec &spec, int width, int prec)\n       {\n \t/* The minimum output is \"0x.p+0\".  */\n \tres.range.min = 6 + (prec > 0 ? prec : 0);\n-\tres.range.max = format_floating_max (type, 'a', prec);\n+\tres.range.max = (width == INT_MIN\n+\t\t\t ? HOST_WIDE_INT_MAX\n+\t\t\t : format_floating_max (type, 'a', prec));\n \n \t/* The output of \"%a\" is fully specified only when precision\n-\t   is explicitly specified.  */\n-\tres.bounded = -1 < prec;\n+\t   is explicitly specified and width isn't unknown.  */\n+\tres.bounded = INT_MIN != width && -1 < prec;\n \tbreak;\n       }\n \n@@ -1274,13 +1318,16 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \tres.range.min = (sign\n \t\t\t + 1 /* unit */ + (prec < 0 ? 7 : prec ? prec + 1 : 0)\n \t\t\t + 2 /* e+ */ + 2);\n-\t/* The maximum output is the minimum plus sign (unless already\n-\t   included), plus the difference between the minimum exponent\n-\t   of 2 and the maximum exponent for the type.  */\n-\tres.range.max = res.range.min + !sign + logexpdigs - 2;\n-\n-\t/* \"%e\" is fully specified and the range of bytes is bounded.  */\n-\tres.bounded = true;\n+\t/* Unless width is uknown the maximum output is the minimum plus\n+\t   sign (unless already included), plus the difference between\n+\t   the minimum exponent of 2 and the maximum exponent for the type.  */\n+\tres.range.max = (width == INT_MIN\n+\t\t\t ? HOST_WIDE_INT_M1U\n+\t\t\t : res.range.min + !sign + logexpdigs - 2);\n+\n+\t/* \"%e\" is fully specified and the range of bytes is bounded\n+\t   unless width is unknown.  */\n+\tres.bounded = INT_MIN != width;\n \tbreak;\n       }\n \n@@ -1296,10 +1343,11 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \t  format_floating_max (double_type_node, 'f'),\n \t  format_floating_max (long_double_type_node, 'f')\n \t};\n-\tres.range.max = f_max [ldbl];\n+\tres.range.max = width == INT_MIN ? HOST_WIDE_INT_MAX : f_max [ldbl];\n \n-\t/* \"%f\" is fully specified and the range of bytes is bounded.  */\n-\tres.bounded = true;\n+\t/* \"%f\" is fully specified and the range of bytes is bounded\n+\t   unless width is unknown.  */\n+\tres.bounded = INT_MIN != width;\n \tbreak;\n       }\n     case 'G':\n@@ -1313,10 +1361,11 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \t  format_floating_max (double_type_node, 'g'),\n \t  format_floating_max (long_double_type_node, 'g')\n \t};\n-\tres.range.max = g_max [ldbl];\n+\tres.range.max = width == INT_MIN ? HOST_WIDE_INT_MAX : g_max [ldbl];\n \n-\t/* \"%g\" is fully specified and the range of bytes is bounded.  */\n-\tres.bounded = true;\n+\t/* \"%g\" is fully specified and the range of bytes is bounded\n+\t   unless width is unknown.  */\n+\tres.bounded = INT_MIN != width;\n \tbreak;\n       }\n \n@@ -1342,6 +1391,9 @@ format_floating (const conversion_spec &spec, int width, int prec)\n static fmtresult\n format_floating (const conversion_spec &spec, tree arg)\n {\n+  /* Set WIDTH to -1 when it's not specified, to INT_MIN when it is\n+     specified by the asterisk to an unknown value, and otherwise to\n+     a non-negative value corresponding to the specified width.  */\n   int width = -1;\n   int prec = -1;\n \n@@ -1354,12 +1406,13 @@ format_floating (const conversion_spec &spec, tree arg)\n   else if (spec.star_width)\n     {\n       if (TREE_CODE (spec.star_width) == INTEGER_CST)\n-\twidth = tree_to_shwi (spec.star_width);\n-      else\n \t{\n-\t  res.range.min = res.range.max = HOST_WIDE_INT_M1U;\n-\t  return res;\n+\t  width = tree_to_shwi (spec.star_width);\n+\t  if (width < 0)\n+\t    width = -width;\n \t}\n+      else\n+\twidth = INT_MIN;\n     }\n \n   if (spec.have_precision)\n@@ -1370,6 +1423,7 @@ format_floating (const conversion_spec &spec, tree arg)\n \tprec = tree_to_shwi (spec.star_precision);\n       else\n \t{\n+\t  /* FIXME: Handle non-constant precision.  */\n \t  res.range.min = res.range.max = HOST_WIDE_INT_M1U;\n \t  return res;\n \t}\n@@ -1409,9 +1463,9 @@ format_floating (const conversion_spec &spec, tree arg)\n \t  *pfmt++ = *pf;\n \n       /* Append width when specified and precision.  */\n-      if (width != -1)\n+      if (-1 < width)\n \tpfmt += sprintf (pfmt, \"%i\", width);\n-      if (prec != -1)\n+      if (-1 < prec)\n \tpfmt += sprintf (pfmt, \".%i\", prec);\n \n       /* Append the MPFR 'R' floating type specifier (no length modifier\n@@ -1438,16 +1492,24 @@ format_floating (const conversion_spec &spec, tree arg)\n \t  *minmax[i] = mpfr_snprintf (NULL, 0, fmtstr, mpfrval);\n \t}\n \n+      /* The range of output is known even if the result isn't bounded.  */\n+      if (width == INT_MIN)\n+\t{\n+\t  res.knownrange = false;\n+\t  res.range.max = HOST_WIDE_INT_MAX;\n+\t}\n+      else\n+\tres.knownrange = true;\n+\n       /* The output of all directives except \"%a\" is fully specified\n \t and so the result is bounded unless it exceeds INT_MAX.\n \t For \"%a\" the output is fully specified only when precision\n \t is explicitly specified.  */\n-      res.bounded = ((TOUPPER (spec.specifier) != 'A'\n-\t\t      || (0 <= prec && (unsigned) prec < target_int_max ()))\n+      res.bounded = (res.knownrange\n+\t\t     && (TOUPPER (spec.specifier) != 'A'\n+\t\t\t || (0 <= prec && (unsigned) prec < target_int_max ()))\n \t\t     && res.range.min < target_int_max ());\n \n-      /* The range of output is known even if the result isn't bounded.  */\n-      res.knownrange = true;\n       return res;\n     }\n \n@@ -1517,20 +1579,10 @@ get_string_length (tree str)\n static fmtresult\n format_string (const conversion_spec &spec, tree arg)\n {\n-  unsigned width = spec.have_width && spec.width > 0 ? spec.width : 0;\n-  int prec = spec.have_precision ? spec.precision : -1;\n-\n-  if (spec.star_width)\n-    {\n-      width = (TREE_CODE (spec.star_width) == INTEGER_CST\n-\t       ? tree_to_shwi (spec.star_width) : 0);\n-      if (width > INT_MAX)\n-\twidth = 0;\n-    }\n-\n-  if (spec.star_precision)\n-    prec = (TREE_CODE (spec.star_precision) == INTEGER_CST\n-\t    ? tree_to_shwi (spec.star_precision) : -1);\n+  /* Set WIDTH and PRECISION based on the specification.  */\n+  HOST_WIDE_INT width;\n+  HOST_WIDE_INT prec;\n+  get_width_and_precision (spec, &width, &prec);\n \n   fmtresult res;\n \n@@ -1590,11 +1642,12 @@ format_string (const conversion_spec &spec, tree arg)\n \t  res.range = slen.range;\n \n \t  /* The output of \"%s\" and \"%ls\" directives with a constant\n-\t     string is in a known range.  For \"%s\" it is the length\n-\t     of the string.  For \"%ls\" it is in the range [length,\n-\t     length * MB_LEN_MAX].  (The final range can be further\n-\t     constrained by width and precision but it's always known.)  */\n-\t  res.knownrange = true;\n+\t     string is in a known range unless width of an unknown value\n+\t     is specified.  For \"%s\" it is the length of the string.  For\n+\t     \"%ls\" it is in the range [length, length * MB_LEN_MAX].\n+\t     (The final range can be further constrained by width and\n+\t     precision but it's always known.)  */\n+\t  res.knownrange = -1 < width;\n \n \t  if (spec.modifier == FMT_LEN_l)\n \t    {\n@@ -1622,19 +1675,32 @@ format_string (const conversion_spec &spec, tree arg)\n \t      if (0 <= prec)\n \t\tres.range.max = prec;\n \t    }\n-\t  else\n+\t  else if (0 <= width)\n \t    {\n-\t      /* The output od a \"%s\" directive with a constant argument\n-\t\t is bounded, constant, and obviously in a known range.  */\n+\t      /* The output of a \"%s\" directive with a constant argument\n+\t\t and constant or no width is bounded.  It is constant if\n+\t\t precision is either not specified or it is specified and\n+\t\t its value is known.  */\n \t      res.bounded = true;\n-\t      res.constant = true;\n+\t      res.constant = prec != HOST_WIDE_INT_MIN;\n+\t    }\n+\t  else if (width == HOST_WIDE_INT_MIN)\n+\t    {\n+\t      /* Specified but unknown width makes the output unbounded.  */\n+\t      res.range.max = HOST_WIDE_INT_MAX;\n \t    }\n \n-\t  if (0 <= prec && (unsigned)prec < res.range.min)\n+\t  if (0 <= prec && (unsigned HOST_WIDE_INT)prec < res.range.min)\n \t    {\n \t      res.range.min = prec;\n \t      res.range.max = prec;\n \t    }\n+\t  else if (prec == HOST_WIDE_INT_MIN)\n+\t    {\n+\t      /* When precision is specified but not known the lower\n+\t\t bound is assumed to be as low as zero.  */\n+\t      res.range.min = 0;\n+\t    }\n \t}\n       else\n \t{\n@@ -1648,10 +1714,10 @@ format_string (const conversion_spec &spec, tree arg)\n \t    {\n \t      if (slen.range.min >= target_int_max ())\n \t\tslen.range.min = 0;\n-\t      else if ((unsigned)prec < slen.range.min)\n+\t      else if ((unsigned HOST_WIDE_INT)prec < slen.range.min)\n \t\tslen.range.min = prec;\n \n-\t      if ((unsigned)prec < slen.range.max\n+\t      if ((unsigned HOST_WIDE_INT)prec < slen.range.max\n \t\t  || slen.range.max >= target_int_max ())\n \t\tslen.range.max = prec;\n \t    }\n@@ -1674,20 +1740,23 @@ format_string (const conversion_spec &spec, tree arg)\n     }\n \n   /* Adjust the lengths for field width.  */\n-  if (res.range.min < width)\n-    res.range.min = width;\n+  if (0 < width)\n+    {\n+      if (res.range.min < (unsigned HOST_WIDE_INT)width)\n+\tres.range.min = width;\n \n-  if (res.range.max < width)\n-    res.range.max = width;\n+      if (res.range.max < (unsigned HOST_WIDE_INT)width)\n+\tres.range.max = width;\n \n-  /* Adjust BOUNDED if width happens to make them equal.  */\n-  if (res.range.min == res.range.max && res.range.min < target_int_max ()\n-      && bounded)\n-    res.bounded = true;\n+      /* Adjust BOUNDED if width happens to make them equal.  */\n+      if (res.range.min == res.range.max && res.range.min < target_int_max ()\n+\t  && bounded)\n+\tres.bounded = true;\n+    }\n \n   /* When precision is specified the range of characters on output\n      is known to be bounded by it.  */\n-  if (-1 < prec)\n+  if (-1 < width && -1 < prec)\n     res.knownrange = true;\n \n   return res;\n@@ -1803,7 +1872,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t\t\t    (int)cvtlen, cvtbeg, fmtres.range.min,\n \t\t\t\t    navail);\n \t\t}\n-\t      else\n+\t      else if (fmtres.range.max < HOST_WIDE_INT_MAX)\n \t\t{\n \t\t  const char* fmtstr\n \t\t    = (info.bounded\n@@ -1817,6 +1886,19 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t\t\t    (int)cvtlen, cvtbeg,\n \t\t\t\t    fmtres.range.min, fmtres.range.max, navail);\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  const char* fmtstr\n+\t\t    = (info.bounded\n+\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t\t    \"%wu or more bytes into a region of size %wu\")\n+\t\t       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n+\t\t\t    \"into a region of size %wu\"));\n+\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t\t    OPT_Wformat_length_, fmtstr,\n+\t\t\t\t    (int)cvtlen, cvtbeg,\n+\t\t\t\t    fmtres.range.min, navail);\n+\t\t}\n \t    }\n \t  else if (navail < fmtres.range.max\n \t\t   && (((spec.specifier == 's'\n@@ -2273,13 +2355,22 @@ pass_sprintf_length::compute_format_length (const call_info &info,\n \n       if (dollar || !spec.star_width)\n \t{\n-\t  if (spec.have_width && spec.width == 0)\n+\t  if (spec.have_width)\n \t    {\n-\t      /* The '0' that has been interpreted as a width above is\n-\t\t actually a flag.  Reset HAVE_WIDTH, set the '0' flag,\n-\t\t and continue processing other flags.  */\n-\t      spec.have_width = false;\n-\t      spec.set_flag ('0');\n+\t      if (spec.width == 0)\n+\t\t{\n+\t\t  /* The '0' that has been interpreted as a width above is\n+\t\t     actually a flag.  Reset HAVE_WIDTH, set the '0' flag,\n+\t\t     and continue processing other flags.  */\n+\t\t  spec.have_width = false;\n+\t\t  spec.set_flag ('0');\n+\t\t}\n+\t      else if (!dollar)\n+\t\t{\n+\t\t  /* (Non-zero) width has been seen.  The next character\n+\t\t     is either a period or a digit.  */\n+\t\t  goto start_precision;\n+\t\t}\n \t    }\n \t  /* When either '$' has been seen, or width has not been seen,\n \t     the next field is the optional flags followed by an optional\n@@ -2324,6 +2415,7 @@ pass_sprintf_length::compute_format_length (const call_info &info,\n \t    }\n \t}\n \n+    start_precision:\n       if ('.' == *pf)\n \t{\n \t  ++pf;\n@@ -2341,7 +2433,12 @@ pass_sprintf_length::compute_format_length (const call_info &info,\n \t      ++pf;\n \t    }\n \t  else\n-\t    return;\n+\t    {\n+\t      /* The decimal precision or the asterisk are optional.\n+\t\t When neither is specified it's taken to be zero.  */\n+\t      spec.precision = 0;\n+\t      spec.have_precision = true;\n+\t    }\n \t}\n \n       switch (*pf)\n@@ -2701,9 +2798,9 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n \n   if (idx_dstsize == HOST_WIDE_INT_M1U)\n     {\n-      // For non-bounded functions like sprintf, to determine\n-      // the size of the destination from the object or pointer\n-      // passed to it as the first argument.\n+      /* For non-bounded functions like sprintf, determine the size\n+\t of the destination from the object or pointer passed to it\n+\t as the first argument.  */\n       dstsize = get_destination_size (gimple_call_arg (info.callstmt, 0));\n     }\n   else if (tree size = gimple_call_arg (info.callstmt, idx_dstsize))\n@@ -2715,10 +2812,18 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator *gsi)\n \t  dstsize = tree_to_uhwi (size);\n \t  /* No object can be larger than SIZE_MAX bytes (half the address\n \t     space) on the target.  This imposes a limit that's one byte\n-\t     less than that.  */\n+\t     less than that.\n+\t     The functions are defined only for output of at most INT_MAX\n+\t     bytes.  Specifying a bound in excess of that limit effectively\n+\t     defeats the bounds checking (and on some implementations such\n+\t     as Solaris cause the function to fail with EINVAL).  */\n \t  if (dstsize >= target_size_max () / 2)\n \t    warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n-\t\t\t\"specified destination size %wu too large\",\n+\t\t\t\"specified destination size %wu is too large\",\n+\t\t\tdstsize);\n+\t  else if (dstsize > target_int_max ())\n+\t    warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n+\t\t\t\"specified destination size %wu exceeds %<INT_MAX %>\",\n \t\t\tdstsize);\n \t}\n       else if (TREE_CODE (size) == SSA_NAME)"}, {"sha": "e4dff3c3e0961a6fb8382ce91c9449ae5543e95d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "patch": "@@ -1,3 +1,11 @@\n+2016-11-28  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78520\n+\t* gcc.dg/tree-ssa/builtin-sprintf-5.c: Add test cases.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-6.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Add test cases.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Add test cases.\n+\n 2016-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/72808"}, {"sha": "dbb0dd9b958698cfbe204de5503b0f7c50d2f229", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-5.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c?ref=de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "patch": "@@ -44,6 +44,26 @@ void test_arg_int (int i, int n)\n \n   for (i = -n; i != n; ++i)\n     T (8, \"%08x\", i);\n+\n+  /*  As a special case, a precision of zero with an argument of zero\n+      results in zero bytes (unless modified by width).  */\n+  T (0, \"%.0d\", ival (0));\n+  T (0, \"%.0i\", ival (0));\n+  T (0, \"%.0o\", ival (0));\n+  T (0, \"%.0u\", ival (0));\n+  T (0, \"%.0x\", ival (0));\n+\n+  T (0, \"%.*d\", 0, ival (0));\n+  T (0, \"%.*i\", 0, ival (0));\n+  T (0, \"%.*o\", 0, ival (0));\n+  T (0, \"%.*u\", 0, ival (0));\n+  T (0, \"%.*x\", 0, ival (0));\n+\n+  T (1, \"%1.0d\", ival (0));\n+  T (1, \"%1.0i\", ival (0));\n+  T (1, \"%1.0o\", ival (0));\n+  T (1, \"%1.0u\", ival (0));\n+  T (1, \"%1.0x\", ival (0));\n }\n \n void test_arg_string (const char *s)"}, {"sha": "375fc094bcf83d43520c4f6767dac2c547f87c8f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-6.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-6.c?ref=de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "patch": "@@ -0,0 +1,73 @@\n+/* PR middle-end/78476 - snprintf(0, 0, ...) with known arguments not\n+   optimized away\n+   A negative test complementing builtin-sprintf-5.c to verify that calls\n+   to the function that do not return a constant are not optimized away.\n+   { dg-compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" }\n+   { dg-require-effective-target int32plus } */\n+\n+#define CONCAT(a, b) a ## b\n+#define CAT(a, b)    CONCAT (a, b)\n+\n+#define T(...)\t\t\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    int CAT (n, __LINE__) = __builtin_snprintf (0, 0, __VA_ARGS__);\t\\\n+    sink (CAT (n, __LINE__));\t\t\t\t\t\t\\\n+  } while (0)\n+\n+void sink (int);\n+\n+static int\n+int_range (int min, int max)\n+{\n+  extern int int_value (void);\n+  int val = int_value ();\n+  if (val < min || max < val)\n+    val = min;\n+  return val;\n+}\n+\n+#define R(min, max) int_range (min, max)\n+\n+void test_arg_int (int width, int prec, int i, int n)\n+{\n+  T (\"%i\", i);\n+  T (\"%1i\", i);\n+  T (\"%2i\", i);\n+  T (\"%3i\", i);\n+  T (\"%4i\", i);\n+\n+  T (\"%*i\", width, 0);\n+  T (\"%*i\", width, 1);\n+  T (\"%*i\", width, i);\n+\n+  T (\"%.*i\", prec, 0);\n+  T (\"%.*i\", prec, 1);\n+  T (\"%.*i\", prec, i);\n+  T (\"%.*i\", 0,    i);\n+\n+  T (\"%i\", R (1, 10));\n+\n+  for (i = -n; i != n; ++i)\n+    T (\"%*x\", n, i);\n+}\n+\n+void test_arg_string (int width, int prec, const char *s)\n+{\n+  T (\"%-s\", s);\n+  T (\"%1s\", s);\n+  T (\"%.1s\", s);\n+  T (\"%*s\", width, s);\n+  T (\"%.*s\", prec, s);\n+  T (\"%1.*s\", prec, s);\n+  T (\"%*.1s\", width, s);\n+  T (\"%*.*s\", width, prec, s);\n+  T (\"%*s\", width, \"123\");\n+  T (\"%.*s\", prec, \"123\");\n+  T (\"%1.*s\", prec, \"123\");\n+  T (\"%*.1s\", width, \"123\");\n+  T (\"%*.*s\", width, prec, \"123\");\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"snprintf\" 27 \"optimized\"} } */"}, {"sha": "7937149cf36b2ef2bdda187117d3949679d6e0e3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 266, "deletions": 40, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "patch": "@@ -233,6 +233,8 @@ void test_sprintf_chk_s_const (void)\n   T ( 1, \"%*s\",  1, s0);        /* { dg-warning \"nul past the end\" } */\n   T (-1, \"%*s\",  1, s0);        /* No warning for unknown destination size.  */\n \n+  T (1, \"%.s\",     \"\");\n+  T (1, \"%.s\",     \"123\");\n   T (1, \"%.0s\",    \"123\");\n   T (1, \"%.0s\",    s3);\n   T (1, \"%.*s\", 0, \"123\");\n@@ -450,6 +452,24 @@ void test_sprintf_chk_hh_const (void)\n   T (4, \"%hhi %hhi\", 10,  1);   /* { dg-warning \"nul past the end\" } */\n   T (4, \"%hhi %hhi\", 11, 12);   /* { dg-warning \"into a region\" } */\n \n+  /*  As a special case, a precision of zero with an argument of zero\n+      results in zero bytes (unless modified by width).  */\n+  T (1, \"%.0hhd\",   0);\n+  T (1, \"%+.0hhd\",  0);\n+  T (1, \"%-.0hhd\",  0);\n+  T (1, \"% .0hhd\",  0);\n+  T (1, \"%0.0hhd\",  0);         /* { dg-warning \".0. flag ignored with precision\" } */\n+  T (1, \"%00.0hhd\", 0);         /* { dg-warning \"repeated .0. flag in format\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%-0.0hhd\", 0);         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%.0hhi\",   0);\n+  T (1, \"%.0hho\",   0);\n+  T (1, \"%#.0hho\",  0);\n+  T (1, \"%.0hhx\",   0);\n+  T (1, \"%.0hhX\",   0);\n+  T (1, \"%#.0hhX\",  0);\n+\n   T (5, \"%0*hhd %0*hhi\", 0,  7, 0,   9);\n   T (5, \"%0*hhd %0*hhi\", 1,  7, 1,   9);\n   T (5, \"%0*hhd %0*hhi\", 1,  7, 2,   9);\n@@ -546,14 +566,32 @@ void test_sprintf_chk_h_const (void)\n   T (4, \"%#hx\",     0x100);     /* { dg-warning \"into a region\" } */\n   T (4, \"%#hx\",        -1);     /* { dg-warning \"into a region\" } */\n \n+  /*  As a special case, a precision of zero with an argument of zero\n+      results in zero bytes (unless modified by width).  */\n+  T (1, \"%.0hd\",        0);\n+  T (1, \"%+.0hd\",       0);\n+  T (1, \"%-.0hd\",       0);\n+  T (1, \"% .0hd\",       0);\n+  T (1, \"%0.0hd\",       0);         /* { dg-warning \".0. flag ignored with precision\" } */\n+  T (1, \"%00.0hd\",      0);         /* { dg-warning \"repeated .0. flag in format\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%-0.0hd\",      0);         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%.0hi\",        0);\n+  T (1, \"%.0ho\",        0);\n+  T (1, \"%#.0ho\",       0);\n+  T (1, \"%.0hx\",        0);\n+  T (1, \"%.0hX\",        0);\n+  T (1, \"%#.0hX\",       0);\n+\n #undef MAX\n #define MAX   65535\n \n-  T (1, \"%hhu\",         0);     /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%hhu\",         1);     /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%hhu\",        -1);     /* { dg-warning \"into a region\" } */\n-  T (1, \"%hhu\",       MAX);     /* { dg-warning \"into a region\" } */\n-  T (1, \"%hhu\",  MAX +  1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hu\",          0);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hu\",          1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hu\",         -1);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%hu\",        MAX);     /* { dg-warning \"into a region\" } */\n+  T (1, \"%hu\",   MAX +  1);     /* { dg-warning \"nul past the end\" } */\n }\n \n /* Exercise the \"%d\", \"%i\", \"%o\", \"%u\", and \"%x\" directives with\n@@ -611,6 +649,24 @@ void test_sprintf_chk_integer_const (void)\n   T ( 8, \"%8u\",         1);        /* { dg-warning \"nul past the end\" } */\n   T ( 9, \"%8u\",         1);\n \n+  /*  As a special case, a precision of zero with an argument of zero\n+      results in zero bytes (unless modified by width).  */\n+  T (1, \"%.0d\",         0);\n+  T (1, \"%+.0d\",        0);\n+  T (1, \"%-.0d\",        0);\n+  T (1, \"% .0d\",        0);\n+  T (1, \"%0.0d\",        0);         /* { dg-warning \".0. flag ignored with precision\" } */\n+  T (1, \"%00.0d\",       0);         /* { dg-warning \"repeated .0. flag in format\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%-0.0d\",       0);         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%.0i\",         0);\n+  T (1, \"%.0o\",         0);\n+  T (1, \"%#.0o\",        0);\n+  T (1, \"%.0x\",         0);\n+  T (1, \"%.0X\",         0);\n+  T (1, \"%#.0X\",        0);\n+\n   T ( 7, \"%1$i%2$i%3$i\",     1, 23, 456);\n   T ( 8, \"%1$i%2$i%3$i%1$i\", 1, 23, 456);\n   T ( 8, \"%1$i%2$i%3$i%2$i\", 1, 23, 456);   /* { dg-warning \"nul past the end\" } */\n@@ -691,6 +747,24 @@ void test_sprintf_chk_j_const (void)\n \n   T ( 8, \"%8ju\",     I (1));      /* { dg-warning \"nul past the end\" } */\n   T ( 9, \"%8ju\",     I (1));\n+\n+  /*  As a special case, a precision of zero with an argument of zero\n+      results in zero bytes (unless modified by width).  */\n+  T (1, \"%.0jd\",     I (0));\n+  T (1, \"%+.0jd\",    I (0));\n+  T (1, \"%-.0jd\",    I (0));\n+  T (1, \"% .0jd\",    I (0));\n+  T (1, \"%0.0jd\",    I (0));         /* { dg-warning \".0. flag ignored with precision\" } */\n+  T (1, \"%00.0jd\",   I (0));         /* { dg-warning \"repeated .0. flag in format\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%-0.0jd\",   I (0));         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%.0ji\",     I (0));\n+  T (1, \"%.0jo\",     I (0));\n+  T (1, \"%#.0jo\",    I (0));\n+  T (1, \"%.0jx\",     I (0));\n+  T (1, \"%.0jX\",     I (0));\n+  T (1, \"%#.0jX\",    I (0));\n }\n \n /* Exercise the \"%ld\", \"%li\", \"%lo\", \"%lu\", and \"%lx\" directives\n@@ -747,6 +821,24 @@ void test_sprintf_chk_l_const (void)\n \n   T ( 8, \"%8lu\",     1L);         /* { dg-warning \"nul past the end\" } */\n   T ( 9, \"%8lu\",     1L);\n+\n+  /*  As a special case, a precision of zero with an argument of zero\n+      results in zero bytes (unless modified by width).  */\n+  T (1, \"%.0ld\",     0L);\n+  T (1, \"%+.0ld\",    0L);\n+  T (1, \"%-.0ld\",    0L);\n+  T (1, \"% .0ld\",    0L);\n+  T (1, \"%0.0ld\",    0L);         /* { dg-warning \".0. flag ignored with precision\" } */\n+  T (1, \"%00.0ld\",   0L);         /* { dg-warning \"repeated .0. flag in format\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%-0.0ld\",   0L);         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n+  /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n+  T (1, \"%.0li\",     0L);\n+  T (1, \"%.0lo\",     0L);\n+  T (1, \"%#.0lo\",    0L);\n+  T (1, \"%.0lx\",     0L);\n+  T (1, \"%.0lX\",     0L);\n+  T (1, \"%#.0lX\",    0L);\n }\n \n /* Exercise the \"%lld\", \"%lli\", \"%llo\", \"%llu\", and \"%llx\" directives\n@@ -858,37 +950,56 @@ void test_sprintf_chk_z_const (void)\n \n void test_sprintf_chk_a_const (void)\n {\n-  T (-1, \"%a\",  0.0);\n-  T (-1, \"%la\", 0.0);\n+  T (-1, \"%a\",         0.0);\n+  T (-1, \"%la\",        0.0);\n+  T (-1, \"%.a\",        0.0);\n+  T (-1, \"%.la\",       0.0);\n+  T (-1, \"%123.a\",     0.0);\n+  T (-1, \"%234.la\",    0.0);\n+  T (-1, \"%.345a\",     0.0);\n+  T (-1, \"%456.567la\", 0.0);\n \n   /* The least number of bytes on output is 6 for \"0x0p+0\".  When precision\n      is missing the number of digits after the decimal point isn't fully\n      specified by C (it seems like a defect).  */\n-  T (0, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (0, \"%la\",  0.0);          /* { dg-warning \"into a region\" } */\n-  T (1, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (2, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (3, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (4, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (5, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (6, \"%a\",   0.0);          /* { dg-warning \"writing a terminating nul\" } */\n+  T (0, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n+  T (0, \"%la\",  0.0);         /* { dg-warning \"into a region\" } */\n+  T (1, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n+  T (2, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n+  T (3, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n+  T (4, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n+  T (5, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n+  T (6, \"%a\",   0.0);         /* { dg-warning \"writing a terminating nul\" } */\n   T (7, \"%a\",   0.0);\n \n-  T (0, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (0, \"%.0la\",  0.0);          /* { dg-warning \"into a region\" } */\n-  T (1, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (2, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (3, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (4, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (5, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n-  T (6, \"%.0a\",   0.0);          /* { dg-warning \"writing a terminating nul\" } */\n+  T (0, \"%.a\",    0.0);       /* { dg-warning \"into a region\" } */\n+  T (0, \"%.0a\",   0.0);       /* { dg-warning \"into a region\" } */\n+  T (0, \"%.0la\",  0.0);       /* { dg-warning \"into a region\" } */\n+  T (1, \"%.0a\",   0.0);       /* { dg-warning \"into a region\" } */\n+  T (2, \"%.0a\",   0.0);       /* { dg-warning \"into a region\" } */\n+  T (3, \"%.0a\",   0.0);       /* { dg-warning \"into a region\" } */\n+  T (4, \"%.0a\",   0.0);       /* { dg-warning \"into a region\" } */\n+  T (5, \"%.0a\",   0.0);       /* { dg-warning \"into a region\" } */\n+  T (6, \"%.0a\",   0.0);       /* { dg-warning \"writing a terminating nul\" } */\n+\n+  T (7, \"%6.a\",   0.0);\n+  T (7, \"%7.a\",   0.0);       /* { dg-warning \"writing a terminating nul\" } */\n+  T (7, \"%7.1a\",  0.0);       /* { dg-warning \"writing 8 bytes into a region of size 7\" } */\n+\n+  T (7, \"%.a\",    0.0);\n   T (7, \"%.0a\",   0.0);\n }\n \n void test_sprintf_chk_e_const (void)\n {\n-  T (-1, \"%E\",   0.0);\n-  T (-1, \"%lE\",  0.0);\n+  T (-1, \"%E\",      0.0);\n+  T (-1, \"%lE\",     0.0);\n+  T (-1, \"%.E\",     0.0);\n+  T (-1, \"%.lE\",    0.0);\n+  T (-1, \"%123.E\",  0.0);\n+  T (-1, \"%234.lE\", 0.0);\n+  T (-1, \"%.345E\",  0.0);\n+  T (-1, \"%.456lE\", 0.0);\n \n   T ( 0, \"%E\",   0.0);          /* { dg-warning \"into a region\" } */\n   T ( 0, \"%e\",   0.0);          /* { dg-warning \"into a region\" } */\n@@ -910,8 +1021,10 @@ void test_sprintf_chk_e_const (void)\n   T (16, \"%.8e\", -1.9e+104);    /* { dg-warning \"nul past the end\" } */\n   T (17, \"%.8e\", -2.0e+105);    /* -2.00000000e+105 */\n \n+  T ( 5, \"%.e\",  0.0);          /* { dg-warning \"nul past the end\" } */\n   T ( 5, \"%.0e\", 0.0);          /* { dg-warning \"nul past the end\" } */\n   T ( 5, \"%.0e\", 1.0);          /* { dg-warning \"nul past the end\" } */\n+  T ( 6, \"%.e\",  1.0);\n   T ( 6, \"%.0e\", 1.0);\n \n   /* The actual output of the following directives depends on the rounding\n@@ -938,14 +1051,27 @@ void test_sprintf_chk_e_const (void)\n    the value one, and unknown strings are assumed to have a zero\n    length.  */\n \n-void test_sprintf_chk_s_nonconst (int i, const char *s)\n+void test_sprintf_chk_s_nonconst (int w, int p, const char *s)\n {\n   T (-1, \"%s\",   s);\n   T ( 0, \"%s\",   s);            /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%s\",   s);\n   T ( 1, \"%.0s\", s);\n   T ( 1, \"%.1s\", s);            /* { dg-warning \"nul past the end\" } */\n \n+  /* The string argument is constant but the width and/or precision\n+     is not.  */\n+  T ( 1, \"%*s\",  w, \"\");\n+  T ( 1, \"%*s\",  w, \"1\");       /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%.*s\", w, \"\");\n+  T ( 1, \"%.*s\", w, \"1\");       /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*s\", w, \"123\");     /* { dg-warning \"writing between 0 and 3 bytes into a region of size 1\" } */\n+\n+  T ( 1, \"%*s\", w, \"123\");      /* { dg-warning \"writing 3 or more bytes into a region of size 1\" } */\n+  T ( 2, \"%*s\", w, \"123\");      /* { dg-warning \"writing 3 or more bytes into a region of size 2\" } */\n+  T ( 3, \"%*s\", w, \"123\");      /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T ( 4, \"%*s\", w, \"123\");\n+\n   /* The following will definitely write past the end of the buffer,\n      but since at level 1 the length of an unknown string argument\n      is assumed to be zero, it will write the terminating nul past\n@@ -957,7 +1083,7 @@ void test_sprintf_chk_s_nonconst (int i, const char *s)\n /* Exercise the hh length modifier with all integer specifiers and\n    a non-constant argument.  */\n \n-void test_sprintf_chk_hh_nonconst (int a)\n+void test_sprintf_chk_hh_nonconst (int w, int p, int a)\n {\n   T (-1, \"%hhd\",        a);\n \n@@ -999,11 +1125,48 @@ void test_sprintf_chk_hh_nonconst (int a)\n   T (2, \"%#hho\",        a);     /* { dg-warning \"nul past the end\" } */\n   T (2, \"%#hhx\",        a);     /* { dg-warning \".%#hhx. directive writing between 3 and . bytes into a region of size 2\" } */\n \n+  T (3, \"%0hhd\",        a);\n+  T (3, \"%1hhd\",        a);\n   T (3, \"%2hhd\",        a);\n   T (3, \"%2hhi\",        a);\n   T (3, \"%2hho\",        a);\n   T (3, \"%2hhu\",        a);\n   T (3, \"%2hhx\",        a);\n+  T (3, \"%2.hhx\",       a);\n+\n+  T (3, \"%3hhd\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%3hhi\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%3hho\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%3hhu\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%3hhx\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%3.hhx\",       a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (4, \"%5hhd\",        a);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%6hhi\",        a);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%7hho\",        a);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%8hhu\",        a);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%9hhx\",        a);     /* { dg-warning \"into a region\" } */\n+\n+  T (3, \"%.hhd\",        a);\n+  T (3, \"%.0hhd\",       a);\n+  T (3, \"%.1hhd\",       a);\n+  T (3, \"%.2hhd\",       a);\n+  T (3, \"%.2hhi\",       a);\n+  T (3, \"%.2hho\",       a);\n+  T (3, \"%.2hhu\",       a);\n+  T (3, \"%.2hhx\",       a);\n+\n+  T (3, \"%.3hhd\",       a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%.3hhi\",       a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%.3hho\",       a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%.3hhu\",       a);     /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%.3hhx\",       a);     /* { dg-warning \"nul past the end\" } */\n+\n+  T (4, \"%.5hhd\",       a);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%.6hhi\",       a);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%.7hho\",       a);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%.8hhu\",       a);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%.9hhx\",       a);     /* { dg-warning \"into a region\" } */\n \n   /* Exercise cases where the type of the actual argument (whose value\n      and range are unknown) constrain the size of the output and so\n@@ -1012,6 +1175,55 @@ void test_sprintf_chk_hh_nonconst (int a)\n   T (2, \"%hhd\", (UChar)a);\n   T (2, \"%hhi\", (UChar)a);\n   T (2, \"%-hhi\", (UChar)a);\n+\n+  /* Exercise cases where the argument is known but width isn't.  */\n+  T (0, \"%*hhi\", w,   0);       /* { dg-warning \"into a region\" } */\n+  T (1, \"%*hhi\", w,   0);       /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%*hhi\", w,   0);\n+  T (2, \"%*hhi\", w,  12);       /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%*hhi\", w, 123);       /* { dg-warning \"into a region\" } */\n+\n+  /* The argument is known but precision isn't.  When the argument\n+     is zero only the first call can be diagnosed since a zero\n+     precision would result in no bytes on output.  */\n+  T (0, \"%.*hhi\", p,   0);      /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%.*hhi\", p,   0);\n+  T (2, \"%.*hhi\", p,   0);\n+  T (2, \"%.*hhi\", p,  12);      /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%.*hhi\", p, 123);      /* { dg-warning \"into a region\" } */\n+\n+  /* The argument is known but neither width nor precision is.  */\n+  T (0, \"%*.*hhi\", w, p,   0);  /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%*.*hhi\", w, p,   0);\n+  T (2, \"%*.*hhi\", w, p,   0);\n+  T (2, \"%*.*hhi\", w, p,  12);  /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%*.*hhi\", w, p, 123);  /* { dg-warning \"into a region\" } */\n+\n+  /* The argument and width are known but precision isn't.  */\n+  T (0, \"%1.*hhi\",  p,   0);    /* { dg-warning \"into a region\" } */\n+  T (0, \"%-1.*hhi\", p,   0);    /* { dg-warning \"into a region\" } */\n+  T (1, \"%1.*hhi\",  p,   0);    /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%1.*hhi\",  p,   0);\n+  T (2, \"%2.*hhi\",  p,   0);    /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%1.*hhi\",  p,  12);    /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%2.*hhi\",  p,  12);    /* { dg-warning \"nul past the end\" } */\n+\n+  T (2, \"%1.*hhi\",  p, 123);    /* { dg-warning \"into a region\" } */\n+  T (2, \"%2.*hhi\",  p, 123);    /* { dg-warning \"into a region\" } */\n+  T (2, \"%3.*hhi\",  p, 123);    /* { dg-warning \"into a region\" } */\n+\n+  /* The argument and precision are known but width isn't.  */\n+  T (0, \"%*.1hhi\",  w,   0);    /* { dg-warning \"into a region\" } */\n+  T (1, \"%*.1hhi\",  w,   0);    /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%*.1hhi\",  w,   0);\n+  T (2, \"%*.2hhi\",  w,   0);    /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%*.1hhi\",  w,  12);    /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%*.2hhi\",  w,  12);    /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%*.3hhi\",  w,  12);    /* { dg-warning \"into a region\" } */\n+\n+  T (2, \"%*.1hhi\",  w, 123);    /* { dg-warning \"into a region\" } */\n+  T (2, \"%*.2hhi\",  w, 123);    /* { dg-warning \"into a region\" } */\n+  T (2, \"%*.3hhi\",  w, 123);    /* { dg-warning \"into a region\" } */\n }\n \n /* Exercise the h length modifier with all integer specifiers and\n@@ -1063,7 +1275,7 @@ void test_sprintf_chk_h_nonconst (int a)\n /* Exercise all integer specifiers with no modifier and a non-constant\n    argument.  */\n \n-void test_sprintf_chk_int_nonconst (int a)\n+void test_sprintf_chk_int_nonconst (int w, int p, int a)\n {\n   T (-1, \"%d\",          a);\n \n@@ -1104,12 +1316,22 @@ void test_sprintf_chk_int_nonconst (int a)\n   T (3, \"%2o\",          a);\n   T (3, \"%2u\",          a);\n   T (3, \"%2x\",          a);\n+\n+  T (1, \"%.*d\",      p, a);\n }\n \n-void test_sprintf_chk_e_nonconst (double d)\n+void test_sprintf_chk_e_nonconst (int w, int p, double d)\n {\n-  T (-1, \"%E\",          d);\n-  T (-1, \"%lE\",         d);\n+  T (-1, \"%E\",           d);\n+  T (-1, \"%lE\",          d);\n+  T (-1, \"%.E\",          d);\n+  T (-1, \"%.lE\",         d);\n+  T (-1, \"%*E\",    w,    d);\n+  T (-1, \"%*lE\",   w,    d);\n+  T (-1, \"%.*E\",      p, d);\n+  T (-1, \"%.*lE\",     p, d);\n+  T (-1, \"%*.*E\",  w, p, d);\n+  T (-1, \"%*.*lE\", w, p, d);\n \n   T ( 0, \"%E\",          d);           /* { dg-warning \"writing between 12 and 14 bytes into a region of size 0\" } */\n   T ( 0, \"%e\",          d);           /* { dg-warning \"into a region\" } */\n@@ -1123,9 +1345,9 @@ void test_sprintf_chk_e_nonconst (double d)\n   T (14, \"%E\",          d);\n   T (14, \"%e\",          d);\n \n-  T  (0, \"%+E\",         d);           /* { dg-warning \"writing between 13 and 14 bytes into a region of size 0\" } */\n-  T  (0, \"%-e\",         d);           /* { dg-warning \"writing between 12 and 14 bytes into a region of size 0\" } */\n-  T  (0, \"% E\",         d);           /* { dg-warning \"writing between 13 and 14 bytes into a region of size 0\" } */\n+  T ( 0, \"%+E\",         d);           /* { dg-warning \"writing between 13 and 14 bytes into a region of size 0\" } */\n+  T ( 0, \"%-e\",         d);           /* { dg-warning \"writing between 12 and 14 bytes into a region of size 0\" } */\n+  T ( 0, \"% E\",         d);           /* { dg-warning \"writing between 13 and 14 bytes into a region of size 0\" } */\n \n   /* The range of output of \"%.0e\" is between 5 and 7 bytes (not counting\n      the terminating NUL.  */\n@@ -1136,6 +1358,9 @@ void test_sprintf_chk_e_nonconst (double d)\n      the terminating NUL.  */\n   T ( 7, \"%.1e\",        d);           /* { dg-warning \"writing a terminating nul past the end\" } */\n   T ( 8, \"%.1e\",        d);\n+\n+  T ( 0, \"%*e\",      0, d);           /* { dg-warning \"writing between 12 and 14 bytes into a region of size 0\" } */\n+  T ( 0, \"%*e\",      w, d);           /* { dg-warning \"writing 12 or more bytes into a region of size 0\" } */\n }\n \n void test_sprintf_chk_f_nonconst (double d)\n@@ -1204,7 +1429,6 @@ void test_vsprintf_chk_c (__builtin_va_list va)\n   /* Here in the best case each argument will format as single character,\n      causing the terminating NUL to be written past the end.  */\n   T (3, \"%lc%c%c\");\n-\n }\n \n void test_vsprintf_chk_int (__builtin_va_list va)\n@@ -1254,9 +1478,11 @@ void test_vsprintf_chk_int (__builtin_va_list va)\n #define T(size, fmt, ...)\t\t\t\t\t\t\\\n   __builtin_snprintf (buffer (size), objsize (size), fmt, __VA_ARGS__)\n \n-void test_snprintf_c_const (void)\n+void test_snprintf_c_const (char *d)\n {\n-  T (-1, \"%c\",    0);            /* { dg-warning \"specified destination size \\[0-9\\]+ too large\" } */\n+  T (-1, \"%c\",    0);            /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+\n+  __builtin_snprintf (d, INT_MAX, \"%c\", 0);\n \n   /* Verify the full text of the diagnostic for just the distinct messages\n      and use abbreviations in subsequent test cases.  */\n@@ -1306,7 +1532,7 @@ void test_snprintf_chk_c_const (void)\n      the function by __builtin_object_size) is diagnosed.  */\n   __builtin___snprintf_chk (buffer, 3, 0, 2, \" \");   /* { dg-warning \"always overflow|specified size 3 exceeds the size 2 of the destination\" } */\n \n-  T (-1, \"%c\",    0);           /* { dg-warning \"specified destination size \\[^ \\]* too large\" } */\n+  T (-1, \"%c\",    0);           /* { dg-warning \"specified destination size \\[^ \\]* is too large\" } */\n \n   T (0, \"%c\",     0);\n   T (0, \"%c%c\",   0, 0);\n@@ -1417,7 +1643,7 @@ void test_vsprintf_int (__builtin_va_list va)\n \n void test_vsnprintf_s (__builtin_va_list va)\n {\n-  T (-1, \"%s\");             /* { dg-warning \"specified destination size \\[^ \\]* too large\" } */\n+  T (-1, \"%s\");             /* { dg-warning \"specified destination size \\[^ \\]* is too large\" } */\n \n   T (0, \"%s\");\n   T (1, \"%s\");\n@@ -1442,7 +1668,7 @@ void test_vsnprintf_chk_s (__builtin_va_list va)\n      the function by __builtin_object_size) is diagnosed.  */\n   __builtin___vsnprintf_chk (buffer, 123, 0, 122, \"%-s\", va);   /* { dg-warning \"always overflow|specified size 123 exceeds the size 122 of the destination object\" } */\n \n-  __builtin___vsnprintf_chk (buffer, __SIZE_MAX__, 0, 2, \"%-s\", va);   /* { dg-warning \"always overflow|destination size .\\[0-9\\]+. too large\" } */\n+  __builtin___vsnprintf_chk (buffer, __SIZE_MAX__, 0, 2, \"%-s\", va);   /* { dg-warning \"always overflow|destination size .\\[0-9\\]+. is too large\" } */\n \n   T (0, \"%s\");\n   T (1, \"%s\");"}, {"sha": "f4550ba7dbc17d82c2a5554e4498868f36fa5a53", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de6aa93370b68a9fbcf874de8a97c5d1469b7d46/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c?ref=de6aa93370b68a9fbcf874de8a97c5d1469b7d46", "patch": "@@ -1,6 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-std=c99 -O2 -Wformat -Wformat-length=1 -ftrack-macro-expansion=0\" } */\n \n+typedef __SIZE_TYPE__ size_t;\n+\n #ifndef LINE\n #  define LINE 0\n #endif\n@@ -232,3 +234,48 @@ void test_sprintf_chk_range_sshort (signed short *a, signed short *b)\n   T ( 4, \"%i\",  Ra (998,  999));\n   T ( 4, \"%i\",  Ra (999, 1000)); /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n }\n+\n+/* Verify that destination size in excess of INT_MAX (and, separately,\n+   in excess of the largest object) is diagnosed.  The former because\n+   the functions are defined only for output of at most INT_MAX and\n+   specifying a large upper bound defeats the bounds checking (and,\n+   on some implementations such as Solaris, causes the function to\n+   fail.  The latter because due to the limit of ptrdiff_t no object\n+   can be larger than PTRDIFF_MAX bytes.  */\n+\n+void test_too_large (char *d, int x, __builtin_va_list va)\n+{\n+  const size_t imax = __INT_MAX__;\n+  const size_t imax_p1 = imax + 1;\n+\n+  __builtin_snprintf (d, imax,    \"%c\", x);\n+  __builtin_snprintf (d, imax_p1, \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"\" { target lp64 } } */\n+  /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"\" { target { ilp32 } } .-1 } */\n+\n+  __builtin_vsnprintf (d, imax,    \"%c\", va);\n+  __builtin_vsnprintf (d, imax_p1, \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" { target lp64 } } */\n+  /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"\" { target { ilp32 } } .-1 } */\n+\n+  __builtin___snprintf_chk (d, imax,    0, imax,    \"%c\", x);\n+  __builtin___snprintf_chk (d, imax_p1, 0, imax_p1, \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" { target lp64 } } */\n+  /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"\" { target { ilp32 } } .-1 } */\n+\n+  __builtin___vsnprintf_chk (d, imax,    0, imax,    \"%c\", va);\n+  __builtin___vsnprintf_chk (d, imax_p1, 0, imax_p1, \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" { target lp64 } } */\n+  /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" \"\" { target { ilp32 } } .-1 } */\n+\n+  const size_t ptrmax = __PTRDIFF_MAX__;\n+  const size_t ptrmax_m1 = ptrmax - 1;\n+\n+  __builtin_snprintf (d, ptrmax_m1, \"%c\", x);  /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"\" { target lp64 } } */\n+  __builtin_snprintf (d, ptrmax, \"  %c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+\n+  __builtin_vsnprintf (d, ptrmax_m1, \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"\" { target lp64 } } */\n+  __builtin_vsnprintf (d, ptrmax,    \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+\n+  __builtin___snprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"\" { target lp64 } } */\n+  __builtin___snprintf_chk (d, ptrmax,    0, ptrmax,    \"%c\", x);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+\n+  __builtin___vsnprintf_chk (d, ptrmax_m1, 0, ptrmax_m1, \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ exceeds .INT_MAX.\" \"\" { target lp64 } } */\n+  __builtin___vsnprintf_chk (d, ptrmax,    0, ptrmax,    \"%c\", va);   /* { dg-warning \"specified destination size \\[0-9\\]+ is too large\" } */\n+}"}]}