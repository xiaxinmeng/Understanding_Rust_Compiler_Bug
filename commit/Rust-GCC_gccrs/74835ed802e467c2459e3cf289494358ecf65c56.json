{"sha": "74835ed802e467c2459e3cf289494358ecf65c56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ4MzVlZDgwMmU0NjdjMjQ1OWUzY2YyODk0OTQzNThlY2Y2NWM1Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-10-16T01:16:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1997-10-16T01:16:42Z"}, "message": "alpha.h (ISSUE_RATE): Define.\n\n        * alpha.h (ISSUE_RATE): Define.\n        * alpha.c (alpha_adjust_cost): Handle EV5 mult delay; don't apply\n        EV4 adjustments to EV5.\n        * alpha.md: Remove all scaling from function unit delays.  Rework\n        EV5 function units to match the CPU.\n        (umuldi3_highpart): EV5 added the IMULH insn class.\n\nFrom-SVN: r15916", "tree": {"sha": "673cbc20dc9e2db308511baa4edf325001c58a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/673cbc20dc9e2db308511baa4edf325001c58a07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74835ed802e467c2459e3cf289494358ecf65c56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74835ed802e467c2459e3cf289494358ecf65c56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74835ed802e467c2459e3cf289494358ecf65c56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74835ed802e467c2459e3cf289494358ecf65c56/comments", "author": null, "committer": null, "parents": [{"sha": "ee80685a3bc496c7a5cf71cac95fc0bc69a2f417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee80685a3bc496c7a5cf71cac95fc0bc69a2f417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee80685a3bc496c7a5cf71cac95fc0bc69a2f417"}], "stats": {"total": 311, "additions": 183, "deletions": 128}, "files": [{"sha": "e20e7c3cfcd99cb8d7602d6b7669a85fb3d2d55d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74835ed802e467c2459e3cf289494358ecf65c56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74835ed802e467c2459e3cf289494358ecf65c56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74835ed802e467c2459e3cf289494358ecf65c56", "patch": "@@ -1,3 +1,13 @@\n+Wed Oct 15 18:16:05 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\tTune Haifa scheduler for Alpha:\n+\t* alpha.h (ISSUE_RATE): Define.\n+\t* alpha.c (alpha_adjust_cost): Handle EV5 mult delay; don't apply\n+\tEV4 adjustments to EV5.\n+\t* alpha.md: Remove all scaling from function unit delays.  Rework\n+\tEV5 function units to match the CPU.\n+\t(umuldi3_highpart): EV5 added the IMULH insn class.\n+\n Wed Oct 15 17:42:41 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* pa.c (following_call): Fail if the CALL_INSN is an indirect"}, {"sha": "8990c5b437ee398ee4c33daf03b9f510eaa16df4", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 95, "deletions": 58, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74835ed802e467c2459e3cf289494358ecf65c56/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74835ed802e467c2459e3cf289494358ecf65c56/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=74835ed802e467c2459e3cf289494358ecf65c56", "patch": "@@ -1150,7 +1150,7 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n      rtx dep_insn;\n      int cost;\n {\n-  rtx set;\n+  rtx set, set_src;\n \n   /* If the dependence is an anti-dependence, there is no cost.  For an\n      output dependence, there is sometimes a cost, but it doesn't seem\n@@ -1159,12 +1159,12 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n   if (REG_NOTE_KIND (link) != 0)\n     return 0;\n \n-  /* EV5 costs are as given in alpha.md; exceptions are given here. */\n   if (alpha_cpu == PROCESSOR_EV5)\n     {\n-      /* And the lord DEC sayeth:  \"A special bypass provides an effective\n-\t latency of 0 cycles for an ICMP or ILOG insn producing the test\n-\t operand of an IBR or CMOV insn.\" */\n+      /* On EV5, \"A special bypass provides an effective latency of 0\n+\t cycles for an ICMP or ILOG insn producing the test operand of an\n+\t IBR or CMOV insn.\" */\n+\n       if (recog_memoized (dep_insn) >= 0\n \t  && (get_attr_type (dep_insn) == TYPE_ICMP\n \t      || get_attr_type (dep_insn) == TYPE_ILOG)\n@@ -1173,67 +1173,104 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n \t      || (get_attr_type (insn) == TYPE_CMOV\n \t\t  && !((set = single_set (dep_insn)) != 0\n \t\t       && GET_CODE (PATTERN (insn)) == SET\n-\t\t       && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE\n-\t\t       && (rtx_equal_p (SET_DEST (set),\n-\t\t\t\t\tXEXP (SET_SRC (PATTERN (insn)), 1))\n-\t\t\t   || rtx_equal_p (SET_DEST (set),\n-\t\t\t\t\t   XEXP (SET_SRC (PATTERN (insn)), 2)))))))\n-\treturn 1;\n-      return cost;\n-    } \n-\n-  /* If INSN is a store insn and DEP_INSN is setting the data being stored,\n-     we can sometimes lower the cost.  */\n-\n-  if (recog_memoized (insn) >= 0 && get_attr_type (insn) == TYPE_ST\n-      && (set = single_set (dep_insn)) != 0\n-      && GET_CODE (PATTERN (insn)) == SET\n-      && rtx_equal_p (SET_DEST (set), SET_SRC (PATTERN (insn))))\n-    switch (get_attr_type (dep_insn))\n-      {\n-      case TYPE_LD:\n-\t/* No savings here.  */\n-\treturn cost;\n-\n-      case TYPE_IMULL:\n-      case TYPE_IMULQ:\n-\t/* In these cases, we save one cycle.  */\n-\treturn cost - 2;\n+\t\t       && (set_src = SET_SRC (PATTERN (insn)),\n+\t\t\t   GET_CODE (set_src) == IF_THEN_ELSE)\n+\t\t       && (set = SET_DEST (set),\n+\t\t\t   rtx_equal_p (set, XEXP (set_src, 1))\n+\t\t\t   || rtx_equal_p (set, XEXP (set_src, 2)))))))\n+\treturn 0;\n \n-      default:\n-\t/* In all other cases, we save two cycles.  */\n-\treturn MAX (0, cost - 4);\n-      }\n+      /* On EV5 it takes longer to get data to the multiplier than to\n+\t anywhere else, so increase costs.  */\n+\n+      if (recog_memoized (insn) >= 0\n+\t  && recog_memoized (dep_insn) >= 0\n+\t  && (get_attr_type (insn) == TYPE_IMULL\n+\t      || get_attr_type (insn) == TYPE_IMULQ\n+\t      || get_attr_type (insn) == TYPE_IMULH)\n+\t  && (set = single_set (dep_insn)) != 0\n+\t  && GET_CODE (PATTERN (insn)) == SET\n+\t  && (set_src = SET_SRC (PATTERN (insn)),\n+\t      GET_CODE (set_src) == MULT)\n+\t  && (set = SET_DEST (set),\n+\t      rtx_equal_p (set, XEXP (set_src, 0))\n+\t      || rtx_equal_p (set, XEXP (set_src, 1))))\n+\t{\n+\t  switch (get_attr_type (insn))\n+\t    {\n+\t    case TYPE_LD:\n+\t    case TYPE_CMOV:\n+\t    case TYPE_IMULL:\n+\t    case TYPE_IMULQ:\n+\t    case TYPE_IMULH:\n+\t      return cost + 1;\n+\t    case TYPE_JSR:\n+\t    case TYPE_IADD:\n+\t    case TYPE_ILOG:\n+\t    case TYPE_SHIFT:\n+\t    case TYPE_ICMP:\n+\t      return cost + 2;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* On EV4, if INSN is a store insn and DEP_INSN is setting the data\n+\t being stored, we can sometimes lower the cost.  */\n \n-  /* Another case that needs adjustment is an arithmetic or logical\n-     operation.  It's cost is usually one cycle, but we default it to\n-     two in the MD file.  The only case that it is actually two is\n-     for the address in loads and stores.  */\n+      if (recog_memoized (insn) >= 0 && get_attr_type (insn) == TYPE_ST\n+\t  && (set = single_set (dep_insn)) != 0\n+\t  && GET_CODE (PATTERN (insn)) == SET\n+\t  && rtx_equal_p (SET_DEST (set), SET_SRC (PATTERN (insn))))\n+\t{\n+\t  switch (get_attr_type (dep_insn))\n+\t    {\n+\t    case TYPE_LD:\n+\t      /* No savings here.  */\n+\t      return cost;\n+\n+\t    case TYPE_IMULL:\n+\t    case TYPE_IMULQ:\n+\t    case TYPE_IMULH:\n+\t      /* In these cases, we save one cycle.  */\n+\t      return cost - 1;\n+\n+\t    default:\n+\t      /* In all other cases, we save two cycles.  */\n+\t      return MAX (0, cost - 2);\n+\t    }\n+\t}\n \n-  if (recog_memoized (dep_insn) >= 0\n-      && (get_attr_type (dep_insn) == TYPE_IADD\n-\t  || get_attr_type (dep_insn) == TYPE_ILOG))\n-    switch (get_attr_type (insn))\n-      {\n-      case TYPE_LD:\n-      case TYPE_ST:\n-\treturn cost;\n+      /* Another case that needs adjustment is an arithmetic or logical\n+\t operation.  It's cost is usually one cycle, but we default it to\n+\t two in the MD file.  The only case that it is actually two is\n+\t for the address in loads and stores.  */\n \n-      default:\n-\treturn 2;\n-      }\n+      if (recog_memoized (dep_insn) >= 0\n+\t  && (get_attr_type (dep_insn) == TYPE_IADD\n+\t      || get_attr_type (dep_insn) == TYPE_ILOG))\n+\t{\n+\t  switch (get_attr_type (insn))\n+\t    {\n+\t    case TYPE_LD:\n+\t    case TYPE_ST:\n+\t      return cost;\n+\t    default:\n+\t      return 1;\n+\t    }\n+\t}\n \n-  /* The final case is when a compare feeds into an integer branch.  The cost\n-     is only one cycle in that case.  */\n+      /* The final case is when a compare feeds into an integer branch;\n+\t the cost is only one cycle in that case.  */\n \n-  if (recog_memoized (dep_insn) >= 0\n-      && get_attr_type (dep_insn) == TYPE_ICMP\n-      && recog_memoized (insn) >= 0\n-      && get_attr_type (insn) == TYPE_IBR)\n-    return 2;\n+      if (recog_memoized (dep_insn) >= 0\n+\t  && get_attr_type (dep_insn) == TYPE_ICMP\n+\t  && recog_memoized (insn) >= 0\n+\t  && get_attr_type (insn) == TYPE_IBR)\n+\treturn 1;\n+    }\n \n   /* Otherwise, return the default cost. */\n-\n   return cost;\n }\n \f"}, {"sha": "0829c079aecd4db280d9ed4eb6d7f44e309bb983", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74835ed802e467c2459e3cf289494358ecf65c56/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74835ed802e467c2459e3cf289494358ecf65c56/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=74835ed802e467c2459e3cf289494358ecf65c56", "patch": "@@ -1595,6 +1595,9 @@ extern void final_prescan_insn ();\n    our own exit function.  */\n #define HAVE_ATEXIT\n \n+/* The EV4 is dual issue; EV5 is quad issue.  */\n+#define ISSUE_RATE  (alpha_cpu == PROCESSOR_EV4 ? 2 : 4)\n+\n /* Compute the cost of computing a constant rtl expression RTX\n    whose rtx-code is CODE.  The body of this macro is a portion\n    of a switch statement.  If the code is computed here,"}, {"sha": "5f760a563a20b75f92c8bf019f93990d21bf0788", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 75, "deletions": 70, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74835ed802e467c2459e3cf289494358ecf65c56/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74835ed802e467c2459e3cf289494358ecf65c56/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=74835ed802e467c2459e3cf289494358ecf65c56", "patch": "@@ -33,179 +33,184 @@\n ;; separately.\n \n (define_attr \"type\"\n-  \"ld,st,ibr,fbr,jsr,iadd,ilog,shift,cmov,icmp,imull,imulq,fadd,fmul,fcpys,fdivs,fdivt,ldsym,isubr\"\n+  \"ld,st,ibr,fbr,jsr,iadd,ilog,shift,cmov,icmp,imull,imulq,imulh,fadd,fmul,fcpys,fdivs,fdivt,ldsym,isubr,misc\"\n   (const_string \"iadd\"))\n \n ;; The TRAP_TYPE attribute marks instructions that may generate traps\n ;; (which are imprecise and may need a trapb if software complention\n ;; is desired).\n (define_attr \"trap\" \"yes,no\" (const_string \"no\"))\n \n-;; For the EV4 we include four function units: ABOX, which computes the address,\n-;; BBOX, used for branches, EBOX, used for integer operations, and FBOX,\n-;; used for FP operations.\n-;;\n-;; We assume that we have been successful in getting double issues and\n-;; hence multiply all costs by two insns per cycle.  The minimum time in\n-;; a function unit is 2 cycle, which will tend to produce the double\n-;; issues.\n+;; For the EV4 we include four function units: ABOX, which computes\n+;; the address, BBOX, used for branches, EBOX, used for integer\n+;; operations, and FBOX, used for FP operations.\n \n ;; Memory delivers its result in three cycles.\n (define_function_unit \"ev4_abox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"ld,st\"))\n-  6 2)\n+       (eq_attr \"type\" \"ld,ldsym,st\"))\n+  3 1)\n \n ;; Branches have no delay cost, but do tie up the unit for two cycles.\n (define_function_unit \"ev4_bbox\" 1 1\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"ibr,fbr,jsr\"))\n-  4 4)\n+  2 2)\n \n-;; Arithmetic insns are normally have their results available after two\n-;; cycles.  There are a number of exceptions.  They are encoded in\n+;; Arithmetic insns are normally have their results available after\n+;; two cycles.  There are a number of exceptions.  They are encoded in\n ;; ADJUST_COST.  Some of the other insns have similar exceptions.\n \n (define_function_unit \"ev4_ebox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"iadd,ilog,ldsym,shift,cmov,icmp\"))\n-  4 2)\n+       (eq_attr \"type\" \"iadd,ilog,shift,cmov,icmp\"))\n+  2 1)\n \n ;; These really don't take up the integer pipeline, but they do occupy\n ;; IBOX1; we approximate here.\n \n (define_function_unit \"ev4_ebox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"imull\"))\n-  42 2)\n+  21 1)\n \n (define_function_unit \"ev4_ebox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"imulq\"))\n-  46 2)\n+       (eq_attr \"type\" \"imulq,imulh\"))\n+  23 1)\n \n (define_function_unit \"ev4_imult\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"imull\"))\n-  42 38)\n+  21 19)\n \n (define_function_unit \"ev4_imult\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"imulq\"))\n-  46 42)\n+       (eq_attr \"type\" \"imulq,imulh\"))\n+  23 21)\n \n (define_function_unit \"ev4_fbox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"fadd,fmul,fcpys\"))\n-  12 2)\n+  6 1)\n \n (define_function_unit \"ev4_fbox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"fdivs\"))\n-  68 0)\n+  34 0)\n \n (define_function_unit \"ev4_fbox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"fdivt\"))\n-  126 0)\n+  63 0)\n \n (define_function_unit \"ev4_divider\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"fdivs\"))\n-  68 60)\n+  34 30)\n \n (define_function_unit \"ev4_divider\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"fdivt\"))\n-  126 118)\n+  64 59)\n \f\n ;; EV5 scheduling.  EV5 can issue 4 insns per clock.\n-;; Multiply all costs by 4.\n \n-;; EV5 has two integer units.\n+;; EV5 has two asymetric integer units.  Model this with ebox,e0,e1.\n+;; Everything uses ebox, and those that require particular pipes grab\n+;; those as well.\n+\n (define_function_unit \"ev5_ebox\" 2 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"iadd,ilog,icmp,ldsym\"))\n-  4 4)\n+       (eq_attr \"type\" \"iadd,ilog,icmp,st,shift,imull,imulq,imulh\"))\n+  1 1)\n \n-;; Memory takes at least 2 clocks.\n-;; Conditional moves always take 2 ticks.\n+;; Memory takes at least 2 clocks, and load cannot dual issue with stores.\n (define_function_unit \"ev5_ebox\" 2 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"ld,cmov\"))\n-  8 4)\n+       (eq_attr \"type\" \"ld,ldsym\"))\n+  2 1)\n+\n+(define_function_unit \"ev5_e0\" 1 0\n+  (and (eq_attr \"cpu\" \"ev5\")\n+       (eq_attr \"type\" \"ld,ldsym\"))\n+  0 1\n+  [(eq_attr \"type\" \"st\")])\n \n-;; Loads can dual issue.  Store cannot; nor can loads + stores.\n-;; Model this with a mythical load/store unit.\n-(define_function_unit \"ev5_ldst\" 1 0\n+;; Conditional moves always take 2 ticks.\n+(define_function_unit \"ev5_ebox\" 2 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"ld\"))\n-  8 4 [(eq_attr \"type\" \"st\")])\n+       (eq_attr \"type\" \"cmov\"))\n+  2 1)\n \n-(define_function_unit \"ev5_ldst\" 1 0\n+;; Stores, shifts, and multiplies can only issue to E0\n+(define_function_unit \"ev5_e0\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"st\"))\n-  4 4)\n+  1 1)\n \n-(define_function_unit \"ev5_ebox\" 2 0\n+;; But shifts and multiplies don't conflict with loads.\n+(define_function_unit \"ev5_e0\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"imull\"))\n-  32 4)\n+       (eq_attr \"type\" \"shift,imull,imulq,imulh\"))\n+  1 1\n+  [(eq_attr \"type\" \"st,shift,imull,imulq,imulh\")])\n \n-(define_function_unit \"ev5_ebox\" 2 0\n+;; Branches can only issue to E1\n+(define_function_unit \"ev5_e1\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"imulq\"))\n-  48 4)\n+       (eq_attr \"type\" \"ibr,jsr\"))\n+  1 1)\n \n ;; Multiplies also use the integer multiplier.\n (define_function_unit \"ev5_imult\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"imull\"))\n-  16 8)\n+  8 4)\n \n (define_function_unit \"ev5_imult\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"imulq\"))\n-  48 32)\n+  12 8)\n \n-;; There is only 1 shifter/zapper.\n-(define_function_unit \"ev5_shift\" 1 0\n+(define_function_unit \"ev5_imult\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"shift\"))\n-  4 4)\n+       (eq_attr \"type\" \"imulh\"))\n+  14 8)\n+\n+;; Similarly for the FPU we have two asymetric units.  But fcpys can issue\n+;; on either so we have to play the game again.\n \n-;; We pretend EV5 has symmetrical 2 fpus,\n-;; even though cpys is the only insn that can issue on either unit.\n (define_function_unit \"ev5_fpu\" 2 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fadd,fmul,fcpys\"))\n-  16 4)\n+       (eq_attr \"type\" \"fadd,fmul,fcpys,fbr,fdivs,fdivt\"))\n+  4 1)\n   \n ;; Multiplies (resp. adds) also use the fmul (resp. fadd) units.\n-(define_function_unit \"ev5_fpmul\" 1 0\n+(define_function_unit \"ev5_fm\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fmul\"))\n-  16 4)\n+  4 1)\n \n-(define_function_unit \"ev5_fpadd\" 1 0\n+(define_function_unit \"ev5_fa\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fadd\"))\n-  16 4)\n+  4 1)\n \n-(define_function_unit \"ev5_fpadd\" 1 0\n+(define_function_unit \"ev5_fa\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fbr\"))\n-  4 4)\n+  1 1)\n \n-(define_function_unit \"ev5_fpadd\" 1 0\n+(define_function_unit \"ev5_fa\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fdivs\"))\n-  60 4)\n+  15 1)\n \n-(define_function_unit \"ev5_fpadd\" 1 0\n+(define_function_unit \"ev5_fa\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fdivt\"))\n-  88 4)\n+  22 1)\n \f\n ;; First define the arithmetic insns.  Note that the 32-bit forms also\n ;; sign-extend.\n@@ -607,7 +612,7 @@\n \t  (const_int 64))))]\n   \"\"\n   \"umulh %1,%2,%0\"\n-  [(set_attr \"type\" \"imulq\")])\n+  [(set_attr \"type\" \"imulh\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -618,7 +623,7 @@\n \t  (const_int 64))))]\n   \"\"\n   \"umulh %1,%2,%0\"\n-  [(set_attr \"type\" \"imulq\")])\n+  [(set_attr \"type\" \"imulh\")])\n \f\n ;; The divide and remainder operations always take their inputs from\n ;; r24 and r25, put their output in r27, and clobber r23 and r28."}]}