{"sha": "0009eff2ef256211d6f4bf0126159ec77425e34d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAwOWVmZjJlZjI1NjIxMWQ2ZjRiZjAxMjYxNTllYzc3NDI1ZTM0ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-30T23:39:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-03-30T23:39:59Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r641", "tree": {"sha": "67e7fcfb003380a7dfcfdaaaeeb204792b4e52dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67e7fcfb003380a7dfcfdaaaeeb204792b4e52dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0009eff2ef256211d6f4bf0126159ec77425e34d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0009eff2ef256211d6f4bf0126159ec77425e34d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0009eff2ef256211d6f4bf0126159ec77425e34d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0009eff2ef256211d6f4bf0126159ec77425e34d/comments", "author": null, "committer": null, "parents": [{"sha": "4e09f580c0d716163936a63de594ca5d80cdfffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e09f580c0d716163936a63de594ca5d80cdfffb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e09f580c0d716163936a63de594ca5d80cdfffb"}], "stats": {"total": 137, "additions": 67, "deletions": 70}, "files": [{"sha": "fea5758eacb72a56f149d6dca0897652051ed918", "filename": "gcc/reload1.c", "status": "modified", "additions": 67, "deletions": 70, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0009eff2ef256211d6f4bf0126159ec77425e34d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0009eff2ef256211d6f4bf0126159ec77425e34d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0009eff2ef256211d6f4bf0126159ec77425e34d", "patch": "@@ -5424,9 +5424,9 @@ gen_input_reload (reloadreg, in, before_insn)\n \t is recognized and matches its constraints.  If so, it can be used.\n \n \t It might be better not to actually emit the insn unless it is valid,\n-\t but we need to pass the insn as an operand to `recog' and it is\n-\t simpler to emit and then delete the insn if not valid than to\n-\t dummy things up.  */\n+\t but we need to pass the insn as an operand to `recog' and\n+\t `insn_extract'and it is simpler to emit and then delete the insn if\n+\t not valid than to dummy things up.  */\n \n       rtx move_operand, other_operand, insn;\n       int code;\n@@ -5621,6 +5621,10 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n   rtx incloc = XEXP (value, 0);\n   /* Nonzero if increment after copying.  */\n   int post = (GET_CODE (value) == POST_DEC || GET_CODE (value) == POST_INC);\n+  rtx prev = PREV_INSN (insn);\n+  rtx inc;\n+  rtx add_insn;\n+  int code;\n \n   /* No hard register is equivalent to this register after\n      inc/dec operation.  If REG_LAST_RELOAD_REG were non-zero,\n@@ -5632,78 +5636,71 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n   if (GET_CODE (value) == PRE_DEC || GET_CODE (value) == POST_DEC)\n     inc_amount = - inc_amount;\n \n-  /* First handle preincrement, which is simpler.  */\n-  if (! post)\n+  inc = gen_rtx (CONST_INT, VOIDmode, inc_amount);\n+\n+  /* If this is post-increment, first copy the location to the reload reg.  */\n+  if (post)\n+    emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n+\n+  /* See if we can directly increment INCLOC.  Use a method similar to that\n+     in gen_input_reload.  */\n+\n+  add_insn = emit_insn_before (gen_rtx (SET, VOIDmode, incloc,\n+\t\t\t\t\tgen_rtx (PLUS, GET_MODE (incloc),\n+\t\t\t\t\t\t incloc, inc)), insn);\n+\t\t\t\t\t\t\t  \n+  code = recog_memoized (add_insn);\n+  if (code >= 0)\n     {\n-      /* If incrementing a register, assume we can\n-\t output an insn to increment it directly.  */\n-      if (GET_CODE (incloc) == REG\n-\t  && (REGNO (incloc) < FIRST_PSEUDO_REGISTER\n-\t      || reg_renumber[REGNO (incloc)] >= 0))\n-\t{\n-\t  rtx first_new\n-\t    = emit_insn_before (gen_add2_insn (incloc,\n-\t\t\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t\tinc_amount)),\n-\t\t\t\tinsn);\n-\t  emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n-\t  return first_new;\n-\t}\n-      else\n-\t/* Else we must not assume we can increment the location directly\n-\t   (even though on many target machines we can);\n-\t   copy it to the reload register, increment there, then save back.  */\n+      insn_extract (add_insn);\n+      if (constrain_operands (code, 1))\n \t{\n-\t  rtx first_new\n-\t    = emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n-\t  emit_insn_before (gen_add2_insn (reloadreg,\n-\t\t\t\t\t   gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t    inc_amount)),\n-\t\t\t    insn);\n-\t  emit_insn_before (gen_move_insn (incloc, reloadreg), insn);\n-\t  return first_new;\n+\t  /* If this is a pre-increment and we have incremented the value\n+\t     where it lives, copy the incremented value to RELOADREG to\n+\t     be used as an address.  */\n+\n+\t  if (! post)\n+\t    emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n+\t  return NEXT_INSN (prev);\n \t}\n     }\n-  /* Postincrement.\n-     Because this might be a jump insn or a compare, and because RELOADREG\n-     may not be available after the insn in an input reload,\n-     we must do the incrementation before the insn being reloaded for.  */\n+\n+  if (PREV_INSN (add_insn))\n+    NEXT_INSN (PREV_INSN (add_insn)) = NEXT_INSN (add_insn);\n+  if (NEXT_INSN (add_insn))\n+    PREV_INSN (NEXT_INSN (add_insn)) = PREV_INSN (add_insn);\n+\n+  /* If couldn't do the increment directly, must increment in RELOADREG.\n+     The way we do this depends on whether this is pre- or post-increment.\n+     For pre-increment, copy INCLOC to the reload register, increment it\n+     there, then save back.  */\n+\n+  if (! post)\n+    {\n+      emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n+      emit_insn_before (gen_add2_insn (reloadreg, inc), insn);\n+      emit_insn_before (gen_move_insn (incloc, reloadreg), insn);\n+    }\n   else\n     {\n-      /* Copy the value, then increment it.  */\n-      rtx first_new\n-\t= emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n-\n-      /* If incrementing a register, assume we can\n-\t output an insn to increment it directly.  */\n-      if (GET_CODE (incloc) == REG\n-\t  && (REGNO (incloc) < FIRST_PSEUDO_REGISTER\n-\t      || reg_renumber[REGNO (incloc)] >= 0))\n-\t{\n-\t  emit_insn_before (gen_add2_insn (incloc,\n-\t\t\t\t\t   gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t    inc_amount)),\n-\t\t\t    insn);\n-\t}\n-      else\n-\t/* Else we must not assume we can increment INCLOC\n-\t   (even though on many target machines we can);\n-\t   increment the copy in the reload register,\n-\t   save that back, then decrement the reload register\n-\t   so it has the original value.  */\n-\t{\n-\t  emit_insn_before (gen_add2_insn (reloadreg,\n-\t\t\t\t\t   gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t    inc_amount)),\n-\t\t\t    insn);\n-\t  emit_insn_before (gen_move_insn (incloc, reloadreg), insn);\n-\t  emit_insn_before (gen_add2_insn (reloadreg,\n-\t\t\t\t\t   gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t\t    -inc_amount)),\n-\t\t\t    insn);\n-\t}\n-      return first_new;\n+      /* Postincrement.\n+\t Because this might be a jump insn or a compare, and because RELOADREG\n+\t may not be available after the insn in an input reload, we must do\n+\t the incrementation before the insn being reloaded for.\n+\n+\t We have already copied INCLOC to RELOADREG.  Increment the copy in\n+\t RELOADREG, save that back, then decrement RELOADREG so it has\n+\t the original value.  */\n+\n+      emit_insn_before (gen_add2_insn (reloadreg, inc), insn);\n+      emit_insn_before (gen_move_insn (incloc, reloadreg), insn);\n+      emit_insn_before (gen_add2_insn (reloadreg,\n+\t\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t\t-inc_amount)),\n+\t\t\tinsn);\n     }\n+\n+  return NEXT_INSN (prev);\n }\n \f\n /* Return 1 if we are certain that the constraint-string STRING allows\n@@ -5743,9 +5740,9 @@ constraint_accepts_reg_p (string, reg)\n       default:\n \t/* Any reg in specified class wins for this alternative.  */\n \t{\n-\t  int class = REG_CLASS_FROM_LETTER (c);\n+\t  enum reg_class class = REG_CLASS_FROM_LETTER (c);\n \n-\t  if (TEST_HARD_REG_BIT (reg_class_contents[class], regno))\n+\t  if (TEST_HARD_REG_BIT (reg_class_contents[(int) class], regno))\n \t    value = 1;\n \t}\n       }"}]}