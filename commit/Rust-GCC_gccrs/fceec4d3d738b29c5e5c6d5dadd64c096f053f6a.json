{"sha": "fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNlZWM0ZDNkNzM4YjI5YzVlNWM2ZDVkYWRkNjRjMDk2ZjA1M2Y2YQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-11-22T16:19:21Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-11-22T16:19:21Z"}, "message": "hooks.h (hook_uint_mode_0): Add Prototype.\n\n\n\t\n\t* hooks.h (hook_uint_mode_0): Add Prototype.\n\t* hooks.c (hook_uint_mode_0): New default function.\n\t* target.def (atomic_align_for_mode): New target hook.\n\t* tree.c (build_atomic_base): Add alignment override parameter.\n\t(build_common_tree_nodes): Use atomic alignment override.\n\t* doc/tm.texi.in (TARGET_ATOMIC_ALIGN_FOR_MODE): Define.\n\t* doc/tm.texi (TARGET_ATOMIC_ALIGN_FOR_MODE): Add description.\n\nFrom-SVN: r205273", "tree": {"sha": "6046b2c41ea50ac794232280ab4a1997a352faa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6046b2c41ea50ac794232280ab4a1997a352faa9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/comments", "author": null, "committer": null, "parents": [{"sha": "2fb9a547b4c0a5abb0dedb0ffd8848cd7f86bd82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fb9a547b4c0a5abb0dedb0ffd8848cd7f86bd82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fb9a547b4c0a5abb0dedb0ffd8848cd7f86bd82"}], "stats": {"total": 66, "additions": 56, "deletions": 10}, "files": [{"sha": "4a5c9a1dc248728d56793e0d22e9da5c97640dc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "patch": "@@ -1,3 +1,13 @@\n+2013-11-22 Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* hooks.h (hook_uint_mode_0): Add Prototype.\n+\t* hooks.c (hook_uint_mode_0): New default function.\n+\t* target.def (atomic_align_for_mode): New target hook.\n+\t* tree.c (build_atomic_base): Add alignment override parameter.\n+\t(build_common_tree_nodes): Use atomic alignment override.\n+\t* doc/tm.texi.in (TARGET_ATOMIC_ALIGN_FOR_MODE): Define.\n+\t* doc/tm.texi (TARGET_ATOMIC_ALIGN_FOR_MODE): Add description.\n+\n 2013-11-22 Andrew MacLeod  <amacleod@redhat.com>\n \n \t* gimple.h: Remove all includes."}, {"sha": "925d93f6c261331521c58d6421992ae8a76ecfef", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "patch": "@@ -11500,6 +11500,10 @@ The support includes the assembler, linker and dynamic linker.\n The default value of this hook is based on target's libc.\n @end deftypefn\n \n+@deftypefn {Target Hook} {unsigned int} TARGET_ATOMIC_ALIGN_FOR_MODE (enum machine_mode @var{mode})\n+If defined, this function returns an appropriate alignment in bits for an atomic object of machine_mode @var{mode}.  If 0 is returned then the default alignment for the specified mode is used. \n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_ATOMIC_ASSIGN_EXPAND_FENV (tree *@var{hold}, tree *@var{clear}, tree *@var{update})\n ISO C11 requires atomic compound assignments that may raise floating-point exceptions to raise exceptions corresponding to the arithmetic operation whose result was successfully stored in a compare-and-exchange sequence.  This requires code equivalent to calls to @code{feholdexcept}, @code{feclearexcept} and @code{feupdateenv} to be generated at appropriate points in the compare-and-exchange sequence.  This hook should set @code{*@var{hold}} to an expression equivalent to the call to @code{feholdexcept}, @code{*@var{clear}} to an expression equivalent to the call to @code{feclearexcept} and @code{*@var{update}} to an expression equivalent to the call to @code{feupdateenv}.  The three expressions are @code{NULL_TREE} on entry to the hook and may be left as @code{NULL_TREE} if no code is required in a particular place.  The default implementation leaves all three expressions as @code{NULL_TREE}.  The @code{__atomic_feraiseexcept} function from @code{libatomic} may be of use as part of the code generated in @code{*@var{update}}.\n @end deftypefn"}, {"sha": "edca60089c2279edc5ad8593dab86f9b78b4e637", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "patch": "@@ -8407,4 +8407,6 @@ and the associated definitions of those functions.\n \n @hook TARGET_HAS_IFUNC_P\n \n+@hook TARGET_ATOMIC_ALIGN_FOR_MODE\n+\n @hook TARGET_ATOMIC_ASSIGN_EXPAND_FENV"}, {"sha": "ce59503cc07f85f9e98d5879f3f1c28ce1441bb3", "filename": "gcc/hooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "patch": "@@ -358,6 +358,13 @@ hook_rtx_tree_int_null (tree a ATTRIBUTE_UNUSED, int b ATTRIBUTE_UNUSED)\n   return NULL;\n }\n \n+/* Generic hook that takes a machine mode and returns an unsigned int 0.  */\n+unsigned int\n+hook_uint_mode_0 (enum machine_mode m ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n /* Generic hook that takes three trees and returns the last one as is.  */\n tree\n hook_tree_tree_tree_tree_3rd_identity (tree a ATTRIBUTE_UNUSED,"}, {"sha": "43191c0ac72a3f348c91ada679851b88384db615", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "patch": "@@ -92,6 +92,7 @@ extern tree hook_tree_tree_tree_tree_3rd_identity (tree, tree, tree);\n extern tree hook_tree_tree_int_treep_bool_null (tree, int, tree *, bool);\n \n extern unsigned hook_uint_void_0 (void);\n+extern unsigned int hook_uint_mode_0 (enum machine_mode);\n \n extern bool default_can_output_mi_thunk_no_vcall (const_tree, HOST_WIDE_INT,\n \t\t\t\t\t\t  HOST_WIDE_INT, const_tree);"}, {"sha": "cde4fb49a07cf6f76b8f20ae0fe4a1b3607aaede", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "patch": "@@ -5297,6 +5297,17 @@ DEFHOOKPOD\n  @code{bool} @code{true}.\",\n  unsigned char, 1)\n \n+/* Return an unsigned int representing the alignment (in bits) of the atomic\n+   type which maps to machine MODE.  This allows alignment to be overridden\n+   as needed.  */\n+DEFHOOK\n+(atomic_align_for_mode,\n+\"If defined, this function returns an appropriate alignment in bits for an\\\n+ atomic object of machine_mode @var{mode}.  If 0 is returned then the\\\n+ default alignment for the specified mode is used. \",\n+ unsigned int, (enum machine_mode mode),\n+ hook_uint_mode_0)\n+\n DEFHOOK\n (atomic_assign_expand_fenv,\n \"ISO C11 requires atomic compound assignments that may raise floating-point\\"}, {"sha": "d363cfcee6eeacde6adf739d0828f923f6035c6c", "filename": "gcc/tree.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceec4d3d738b29c5e5c6d5dadd64c096f053f6a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fceec4d3d738b29c5e5c6d5dadd64c096f053f6a", "patch": "@@ -9550,10 +9550,11 @@ make_or_reuse_accum_type (unsigned size, int unsignedp, int satp)\n    during initialization of data types to create the 5 basic atomic\n    types. The generic build_variant_type function requires these to\n    already be set up in order to function properly, so cannot be\n-   called from there.  */\n+   called from there.  If ALIGN is non-zero, then ensure alignment is\n+   overridden to this value.  */\n \n static tree\n-build_atomic_base (tree type)\n+build_atomic_base (tree type, unsigned int align)\n {\n   tree t;\n \n@@ -9564,6 +9565,9 @@ build_atomic_base (tree type)\n   t = build_variant_type_copy (type);\n   set_type_quals (t, TYPE_QUAL_ATOMIC);\n \n+  if (align)\n+    TYPE_ALIGN (t) = align;\n+\n   return t;\n }\n \n@@ -9651,14 +9655,21 @@ build_common_tree_nodes (bool signed_char, bool short_double)\n \n   /* Don't call build_qualified type for atomics.  That routine does\n      special processing for atomics, and until they are initialized\n-     it's better not to make that call.  */\n-\n-  atomicQI_type_node = build_atomic_base (unsigned_intQI_type_node);\n-  atomicHI_type_node = build_atomic_base (unsigned_intHI_type_node);\n-  atomicSI_type_node = build_atomic_base (unsigned_intSI_type_node);\n-  atomicDI_type_node = build_atomic_base (unsigned_intDI_type_node);\n-  atomicTI_type_node = build_atomic_base (unsigned_intTI_type_node);\n-\n+     it's better not to make that call.\n+     \n+     Check to see if there is a target override for atomic types.  */\n+\n+  atomicQI_type_node = build_atomic_base (unsigned_intQI_type_node,\n+\t\t\t\t\ttargetm.atomic_align_for_mode (QImode));\n+  atomicHI_type_node = build_atomic_base (unsigned_intHI_type_node,\n+\t\t\t\t\ttargetm.atomic_align_for_mode (HImode));\n+  atomicSI_type_node = build_atomic_base (unsigned_intSI_type_node,\n+\t\t\t\t\ttargetm.atomic_align_for_mode (SImode));\n+  atomicDI_type_node = build_atomic_base (unsigned_intDI_type_node,\n+\t\t\t\t\ttargetm.atomic_align_for_mode (DImode));\n+  atomicTI_type_node = build_atomic_base (unsigned_intTI_type_node,\n+\t\t\t\t\ttargetm.atomic_align_for_mode (TImode));\n+  \t\n   access_public_node = get_identifier (\"public\");\n   access_protected_node = get_identifier (\"protected\");\n   access_private_node = get_identifier (\"private\");"}]}