{"sha": "a2b7026c2e31369f7b1d63f4ba3b71cefed64268", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJiNzAyNmMyZTMxMzY5ZjdiMWQ2M2Y0YmEzYjcxY2VmZWQ2NDI2OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-08-28T06:24:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-08-28T06:24:27Z"}, "message": "rtl.h (replace_label_data): Delete.\n\ngcc/\n\t* rtl.h (replace_label_data): Delete.\n\t(replace_label): Take the old label, new label and update-nuses flag\n\tas direct arguments.  Return void.\n\t* cfgcleanup.c (outgoing_edges_match): Update accordingly.\n\t* rtlanal.c (replace_label): Update interface as above.  Handle\n\tJUMP_TABLE_DATA as a special case.  Handle JUMPs outside the\n\titerator.  Use FOR_EACH_SUBRTX_PTR.\n\nFrom-SVN: r214655", "tree": {"sha": "09debe30d0cb53a1873133e0ac379d655e8affcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09debe30d0cb53a1873133e0ac379d655e8affcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2b7026c2e31369f7b1d63f4ba3b71cefed64268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b7026c2e31369f7b1d63f4ba3b71cefed64268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b7026c2e31369f7b1d63f4ba3b71cefed64268", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e08cf836163a847ddfa4ffb8514a16be6d747dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08cf836163a847ddfa4ffb8514a16be6d747dff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e08cf836163a847ddfa4ffb8514a16be6d747dff"}], "stats": {"total": 148, "additions": 82, "deletions": 66}, "files": [{"sha": "57a30853dc49db4df88ccd5e9185698039bb3dc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2b7026c2e31369f7b1d63f4ba3b71cefed64268", "patch": "@@ -1,3 +1,13 @@\n+2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* rtl.h (replace_label_data): Delete.\n+\t(replace_label): Take the old label, new label and update-nuses flag\n+\tas direct arguments.  Return void.\n+\t* cfgcleanup.c (outgoing_edges_match): Update accordingly.\n+\t* rtlanal.c (replace_label): Update interface as above.  Handle\n+\tJUMP_TABLE_DATA as a special case.  Handle JUMPs outside the\n+\titerator.  Use FOR_EACH_SUBRTX_PTR.\n+\n 2014-08-28  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* rtl.h (get_pool_constant, rtx_referenced_p): Replace rtx parameters"}, {"sha": "a00816887535fc338816506c252e0f55379d7f26", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=a2b7026c2e31369f7b1d63f4ba3b71cefed64268", "patch": "@@ -1719,15 +1719,11 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \n \t      if (identical)\n \t\t{\n-\t\t  replace_label_data rr;\n \t\t  bool match;\n \n \t\t  /* Temporarily replace references to LABEL1 with LABEL2\n \t\t     in BB1->END so that we could compare the instructions.  */\n-\t\t  rr.r1 = label1;\n-\t\t  rr.r2 = label2;\n-\t\t  rr.update_label_nuses = false;\n-\t\t  for_each_rtx_in_insn (&BB_END (bb1), replace_label, &rr);\n+\t\t  replace_label_in_insn (BB_END (bb1), label1, label2, false);\n \n \t\t  match = (old_insns_match_p (mode, BB_END (bb1), BB_END (bb2))\n \t\t\t   == dir_both);\n@@ -1739,9 +1735,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t\t  /* Set the original label in BB1->END because when deleting\n \t\t     a block whose end is a tablejump, the tablejump referenced\n \t\t     from the instruction is deleted too.  */\n-\t\t  rr.r1 = label2;\n-\t\t  rr.r2 = label1;\n-\t\t  for_each_rtx_in_insn (&BB_END (bb1), replace_label, &rr);\n+\t\t  replace_label_in_insn (BB_END (bb1), label2, label1, false);\n \n \t\t  return match;\n \t\t}\n@@ -1988,20 +1982,16 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n \t  && tablejump_p (BB_END (osrc2), &label2, &table2)\n \t  && label1 != label2)\n \t{\n-\t  replace_label_data rr;\n \t  rtx_insn *insn;\n \n \t  /* Replace references to LABEL1 with LABEL2.  */\n-\t  rr.r1 = label1;\n-\t  rr.r2 = label2;\n-\t  rr.update_label_nuses = true;\n \t  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t    {\n \t      /* Do not replace the label in SRC1->END because when deleting\n \t\t a block whose end is a tablejump, the tablejump referenced\n \t\t from the instruction is deleted too.  */\n \t      if (insn != BB_END (osrc1))\n-\t\tfor_each_rtx_in_insn (&insn, replace_label, &rr);\n+\t\treplace_label_in_insn (insn, label1, label2, true);\n \t    }\n \t}\n     }"}, {"sha": "9d27256f42c31548744c55577e6f10492417b0c7", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a2b7026c2e31369f7b1d63f4ba3b71cefed64268", "patch": "@@ -2723,14 +2723,6 @@ extern void set_insn_deleted (rtx);\n \t\t       : NULL_RTX)\n #define single_set_1(I) single_set_2 (I, PATTERN (I))\n \n-/* Structure used for passing data to REPLACE_LABEL.  */\n-struct replace_label_data\n-{\n-  rtx r1;\n-  rtx r2;\n-  bool update_label_nuses;\n-};\n-\n extern enum machine_mode get_address_mode (rtx mem);\n extern int rtx_addr_can_trap_p (const_rtx);\n extern bool nonzero_address_p (const_rtx);\n@@ -2799,7 +2791,8 @@ extern void copy_reg_eh_region_note_forward (rtx, rtx, rtx);\n extern void copy_reg_eh_region_note_backward (rtx, rtx, rtx);\n extern int inequality_comparisons_p (const_rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);\n-extern int replace_label (rtx *, void *);\n+extern void replace_label (rtx *, rtx, rtx, bool);\n+extern void replace_label_in_insn (rtx_insn *, rtx, rtx, bool);\n extern bool rtx_referenced_p (const_rtx, const_rtx);\n extern bool tablejump_p (const_rtx, rtx *, rtx_jump_table_data **);\n extern int computed_jump_p (const_rtx);"}, {"sha": "f1cb2246d7d7bbfce4eb21bbadd9db7fa6baba09", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 67, "deletions": 44, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2b7026c2e31369f7b1d63f4ba3b71cefed64268/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=a2b7026c2e31369f7b1d63f4ba3b71cefed64268", "patch": "@@ -2770,65 +2770,88 @@ replace_rtx (rtx x, rtx from, rtx to)\n   return x;\n }\n \f\n-/* Replace occurrences of the old label in *X with the new one.\n-   DATA is a REPLACE_LABEL_DATA containing the old and new labels.  */\n+/* Replace occurrences of the OLD_LABEL in *LOC with NEW_LABEL.  Also track\n+   the change in LABEL_NUSES if UPDATE_LABEL_NUSES.  */\n \n-int\n-replace_label (rtx *x, void *data)\n+void\n+replace_label (rtx *loc, rtx old_label, rtx new_label, bool update_label_nuses)\n {\n-  rtx l = *x;\n-  rtx old_label = ((replace_label_data *) data)->r1;\n-  rtx new_label = ((replace_label_data *) data)->r2;\n-  bool update_label_nuses = ((replace_label_data *) data)->update_label_nuses;\n-\n-  if (l == NULL_RTX)\n-    return 0;\n-\n-  if (GET_CODE (l) == SYMBOL_REF\n-      && CONSTANT_POOL_ADDRESS_P (l))\n+  /* Handle jump tables specially, since ADDR_{DIFF_,}VECs can be long.  */\n+  rtx x = *loc;\n+  if (JUMP_TABLE_DATA_P (x))\n     {\n-      rtx c = get_pool_constant (l);\n-      if (rtx_referenced_p (old_label, c))\n+      x = PATTERN (x);\n+      rtvec vec = XVEC (x, GET_CODE (x) == ADDR_DIFF_VEC);\n+      int len = GET_NUM_ELEM (vec);\n+      for (int i = 0; i < len; ++i)\n \t{\n-\t  rtx new_c, new_l;\n-\t  replace_label_data *d = (replace_label_data *) data;\n-\n-\t  /* Create a copy of constant C; replace the label inside\n-\t     but do not update LABEL_NUSES because uses in constant pool\n-\t     are not counted.  */\n-\t  new_c = copy_rtx (c);\n-\t  d->update_label_nuses = false;\n-\t  for_each_rtx (&new_c, replace_label, data);\n-\t  d->update_label_nuses = update_label_nuses;\n-\n-\t  /* Add the new constant NEW_C to constant pool and replace\n-\t     the old reference to constant by new reference.  */\n-\t  new_l = XEXP (force_const_mem (get_pool_mode (l), new_c), 0);\n-\t  *x = replace_rtx (l, l, new_l);\n+\t  rtx ref = RTVEC_ELT (vec, i);\n+\t  if (XEXP (ref, 0) == old_label)\n+\t    {\n+\t      XEXP (ref, 0) = new_label;\n+\t      if (update_label_nuses)\n+\t\t{\n+\t\t  ++LABEL_NUSES (new_label);\n+\t\t  --LABEL_NUSES (old_label);\n+\t\t}\n+\t    }\n \t}\n-      return 0;\n+      return;\n     }\n \n   /* If this is a JUMP_INSN, then we also need to fix the JUMP_LABEL\n-     field.  This is not handled by for_each_rtx because it doesn't\n+     field.  This is not handled by the iterator because it doesn't\n      handle unprinted ('0') fields.  */\n-  if (JUMP_P (l) && JUMP_LABEL (l) == old_label)\n-    JUMP_LABEL (l) = new_label;\n+  if (JUMP_P (x) && JUMP_LABEL (x) == old_label)\n+    JUMP_LABEL (x) = new_label;\n \n-  if ((GET_CODE (l) == LABEL_REF\n-       || GET_CODE (l) == INSN_LIST)\n-      && XEXP (l, 0) == old_label)\n+  subrtx_ptr_iterator::array_type array;\n+  FOR_EACH_SUBRTX_PTR (iter, array, loc, ALL)\n     {\n-      XEXP (l, 0) = new_label;\n-      if (update_label_nuses)\n+      rtx *loc = *iter;\n+      if (rtx x = *loc)\n \t{\n-\t  ++LABEL_NUSES (new_label);\n-\t  --LABEL_NUSES (old_label);\n+\t  if (GET_CODE (x) == SYMBOL_REF\n+\t      && CONSTANT_POOL_ADDRESS_P (x))\n+\t    {\n+\t      rtx c = get_pool_constant (x);\n+\t      if (rtx_referenced_p (old_label, c))\n+\t\t{\n+\t\t  /* Create a copy of constant C; replace the label inside\n+\t\t     but do not update LABEL_NUSES because uses in constant pool\n+\t\t     are not counted.  */\n+\t\t  rtx new_c = copy_rtx (c);\n+\t\t  replace_label (&new_c, old_label, new_label, false);\n+\n+\t\t  /* Add the new constant NEW_C to constant pool and replace\n+\t\t     the old reference to constant by new reference.  */\n+\t\t  rtx new_mem = force_const_mem (get_pool_mode (x), new_c);\n+\t\t  *loc = replace_rtx (x, x, XEXP (new_mem, 0));\n+\t\t}\n+\t    }\n+\n+\t  if ((GET_CODE (x) == LABEL_REF\n+\t       || GET_CODE (x) == INSN_LIST)\n+\t      && XEXP (x, 0) == old_label)\n+\t    {\n+\t      XEXP (x, 0) = new_label;\n+\t      if (update_label_nuses)\n+\t\t{\n+\t\t  ++LABEL_NUSES (new_label);\n+\t\t  --LABEL_NUSES (old_label);\n+\t\t}\n+\t    }\n \t}\n-      return 0;\n     }\n+}\n \n-  return 0;\n+void\n+replace_label_in_insn (rtx_insn *insn, rtx old_label, rtx new_label,\n+\t\t       bool update_label_nuses)\n+{\n+  rtx insn_as_rtx = insn;\n+  replace_label (&insn_as_rtx, old_label, new_label, update_label_nuses);\n+  gcc_checking_assert (insn_as_rtx == insn);\n }\n \n /* Return true if X is referenced in BODY.  */"}]}