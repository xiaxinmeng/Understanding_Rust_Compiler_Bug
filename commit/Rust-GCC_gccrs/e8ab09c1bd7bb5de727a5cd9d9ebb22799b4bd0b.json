{"sha": "e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThhYjA5YzFiZDdiYjVkZTcyN2E1Y2Q5ZDllYmIyMjc5OWI0YmQwYg==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-05-08T12:44:21Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-05-08T12:44:21Z"}, "message": "mips.h (MAX_FPRS_PER_FMT): Renamed from FP_INC.\n\n2007-05-08  Sandra Loosemore  <sandra@codesourcery.com>\n            Nigel Stephens  <nigel@mips.com>\n\n\tgcc/\n\t* config/mips/mips.h (MAX_FPRS_PER_FMT): Renamed from FP_INC.\n\tUpdate comments and all uses.\n\t(MIN_FPRS_PER_FMT): Define.\n\t* config/mips/mips.c (function_arg): Fix to correctly handle\n\tthe -mips32r2 -mfp64 -mabi=32 case.\n\t(override_options): Enable use of odd-numbered registers for\n\tSFmode values on MIPS32.\n\t(mips_save_reg_p): Save whole floating-point register pair if\n\teither half is used.\n\t(compute_frame_size): Fix comment.\n\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\n\nFrom-SVN: r124545", "tree": {"sha": "d1deb2c00ec7de2f2463d60fd323a3611f6c49c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1deb2c00ec7de2f2463d60fd323a3611f6c49c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28f601ff8ae7fe32f4d11b5cb7489d399bbcc24c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28f601ff8ae7fe32f4d11b5cb7489d399bbcc24c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28f601ff8ae7fe32f4d11b5cb7489d399bbcc24c"}], "stats": {"total": 82, "additions": 58, "deletions": 24}, "files": [{"sha": "d0753beaa78aeec8a2a5d9e784f44c78170b6adc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b", "patch": "@@ -1,3 +1,17 @@\n+2007-05-08  Sandra Loosemore  <sandra@codesourcery.com>\n+            Nigel Stephens  <nigel@mips.com>\n+\n+\t* config/mips/mips.h (MAX_FPRS_PER_FMT): Renamed from FP_INC.\n+\tUpdate comments and all uses.\n+\t(MIN_FPRS_PER_FMT): Define.\n+\t* config/mips/mips.c (function_arg): Fix to correctly handle\n+\tthe -mips32r2 -mfp64 -mabi=32 case.\n+\t(override_options): Enable use of odd-numbered registers for\n+\tSFmode values on MIPS32.\n+\t(mips_save_reg_p): Save whole floating-point register pair if\n+\teither half is used.\n+\t(compute_frame_size): Fix comment.\n+\n 2007-05-08  Jie Zhang  <jie.zhang@analog.com>\n \n \t* config/bfin/bfin-protos.h (bfin_expand_epilogue): Add a third"}, {"sha": "a719a1020dd59586ed1c2f34f47fc8c1b5f9bee3", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b", "patch": "@@ -3528,7 +3528,7 @@ mips_emit_fcc_reload (rtx dest, rtx src, rtx scratch)\n     src = gen_rtx_REG (SFmode, true_regnum (src));\n \n   fp1 = gen_rtx_REG (SFmode, REGNO (scratch));\n-  fp2 = gen_rtx_REG (SFmode, REGNO (scratch) + FP_INC);\n+  fp2 = gen_rtx_REG (SFmode, REGNO (scratch) + MAX_FPRS_PER_FMT);\n \n   emit_move_insn (copy_rtx (fp1), src);\n   emit_move_insn (copy_rtx (fp2), CONST0_RTX (SFmode));\n@@ -3872,7 +3872,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (mips_abi != ABI_EABI || !info.fpr_p)\n     cum->num_gprs = info.reg_offset + info.reg_words;\n   else if (info.reg_words > 0)\n-    cum->num_fprs += FP_INC;\n+    cum->num_fprs += MAX_FPRS_PER_FMT;\n \n   if (info.stack_words > 0)\n     cum->stack_words = info.stack_offset + info.stack_words;\n@@ -4006,10 +4006,11 @@ function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   if (!info.fpr_p)\n     return gen_rtx_REG (mode, GP_ARG_FIRST + info.reg_offset);\n-  else if (info.reg_offset == 1)\n-    /* This code handles the special o32 case in which the second word\n-       of the argument structure is passed in floating-point registers.  */\n-    return gen_rtx_REG (mode, FP_ARG_FIRST + FP_INC);\n+  else if (mips_abi == ABI_32 && TARGET_DOUBLE_FLOAT && info.reg_offset > 0)\n+    /* In o32, the second argument is always passed in $f14\n+       for TARGET_DOUBLE_FLOAT, regardless of whether the\n+       first argument was a word or doubleword.  */\n+    return gen_rtx_REG (mode, FP_ARG_FIRST + 2);\n   else\n     return gen_rtx_REG (mode, FP_ARG_FIRST + info.reg_offset);\n }\n@@ -4150,7 +4151,8 @@ mips_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n \t  mode = TARGET_SINGLE_FLOAT ? SFmode : DFmode;\n \n-\t  for (i = local_cum.num_fprs; i < MAX_ARGS_IN_REGISTERS; i += FP_INC)\n+\t  for (i = local_cum.num_fprs; i < MAX_ARGS_IN_REGISTERS;\n+\t       i += MAX_FPRS_PER_FMT)\n \t    {\n \t      rtx ptr, mem;\n \n@@ -5098,7 +5100,9 @@ override_options (void)\n \t    temp = ((regno & 1) == 0 || size <= UNITS_PER_WORD);\n \n \t  else if (FP_REG_P (regno))\n-\t    temp = ((regno % FP_INC) == 0)\n+\t    temp = ((((regno % MAX_FPRS_PER_FMT) == 0)\n+\t\t     || (MIN_FPRS_PER_FMT == 1\n+\t\t\t && size <= UNITS_PER_FPREG))\n \t\t    && (((class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT\n \t\t\t  || class == MODE_VECTOR_FLOAT)\n \t\t\t && size <= UNITS_PER_FPVALUE)\n@@ -5112,7 +5116,7 @@ override_options (void)\n \t\t\t    && size >= MIN_UNITS_PER_WORD\n \t\t\t    && size <= UNITS_PER_FPREG)\n \t\t\t/* Allow TFmode for CCmode reloads.  */\n-\t\t\t|| (ISA_HAS_8CC && mode == TFmode));\n+\t\t\t|| (ISA_HAS_8CC && mode == TFmode)));\n \n           else if (ACC_REG_P (regno))\n \t    temp = (INTEGRAL_MODE_P (mode)\n@@ -6285,6 +6289,15 @@ mips_save_reg_p (unsigned int regno)\n   if (regs_ever_live[regno] && !call_used_regs[regno])\n     return true;\n \n+ /* Save both registers in an FPR pair if either one is used.  This is\n+    needed for the case when MIN_FPRS_PER_FMT == 1, which allows the odd\n+    register to be used without the even register.  */\n+ if (FP_REG_P (regno)\n+     && MAX_FPRS_PER_FMT == 2 \n+     && regs_ever_live[regno + 1]\n+     && !call_used_regs[regno + 1])\n+   return true;\n+\n   /* We need to save the old frame pointer before setting up a new one.  */\n   if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n     return true;\n@@ -6437,15 +6450,15 @@ compute_frame_size (HOST_WIDE_INT size)\n     }\n \n   /* This loop must iterate over the same space as its companion in\n-     save_restore_insns.  */\n-  for (regno = (FP_REG_LAST - FP_INC + 1);\n+     mips_for_each_saved_reg.  */\n+  for (regno = (FP_REG_LAST - MAX_FPRS_PER_FMT + 1);\n        regno >= FP_REG_FIRST;\n-       regno -= FP_INC)\n+       regno -= MAX_FPRS_PER_FMT)\n     {\n       if (mips_save_reg_p (regno))\n \t{\n-\t  fp_reg_size += FP_INC * UNITS_PER_FPREG;\n-\t  fmask |= ((1 << FP_INC) - 1) << (regno - FP_REG_FIRST);\n+\t  fp_reg_size += MAX_FPRS_PER_FMT * UNITS_PER_FPREG;\n+\t  fmask |= ((1 << MAX_FPRS_PER_FMT) - 1) << (regno - FP_REG_FIRST);\n \t}\n     }\n \n@@ -6467,7 +6480,8 @@ compute_frame_size (HOST_WIDE_INT size)\n   cfun->machine->frame.fmask = fmask;\n   cfun->machine->frame.initialized = reload_completed;\n   cfun->machine->frame.num_gp = gp_reg_size / UNITS_PER_WORD;\n-  cfun->machine->frame.num_fp = fp_reg_size / (FP_INC * UNITS_PER_FPREG);\n+  cfun->machine->frame.num_fp = (fp_reg_size\n+\t\t\t\t / (MAX_FPRS_PER_FMT * UNITS_PER_FPREG));\n \n   if (mask)\n     {\n@@ -6490,7 +6504,7 @@ compute_frame_size (HOST_WIDE_INT size)\n \n       offset = (args_size + cprestore_size + var_size\n \t\t+ gp_reg_rounded + fp_reg_size\n-\t\t- FP_INC * UNITS_PER_FPREG);\n+\t\t- MAX_FPRS_PER_FMT * UNITS_PER_FPREG);\n       cfun->machine->frame.fp_sp_offset = offset;\n       cfun->machine->frame.fp_save_offset = offset - total_size;\n     }\n@@ -6593,9 +6607,9 @@ mips_for_each_saved_reg (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n      compute_frame_size.  */\n   offset = cfun->machine->frame.fp_sp_offset - sp_offset;\n   fpr_mode = (TARGET_SINGLE_FLOAT ? SFmode : DFmode);\n-  for (regno = (FP_REG_LAST - FP_INC + 1);\n+  for (regno = (FP_REG_LAST - MAX_FPRS_PER_FMT + 1);\n        regno >= FP_REG_FIRST;\n-       regno -= FP_INC)\n+       regno -= MAX_FPRS_PER_FMT)\n     if (BITSET_P (cfun->machine->frame.fmask, regno - FP_REG_FIRST))\n       {\n \tmips_save_restore_reg (fpr_mode, regno, offset, fn);\n@@ -7507,7 +7521,7 @@ mips_return_fpr_pair (enum machine_mode mode,\n {\n   int inc;\n \n-  inc = (TARGET_NEWABI ? 2 : FP_INC);\n+  inc = (TARGET_NEWABI ? 2 : MAX_FPRS_PER_FMT);\n   return gen_rtx_PARALLEL\n     (mode,\n      gen_rtvec (2,\n@@ -7645,7 +7659,7 @@ mips_cannot_change_mode_class (enum machine_mode from,\n \t     registers, the first register always holds the low word.\n \t     We therefore can't allow FPRs to change between single-word\n \t     and multi-word modes.  */\n-\t  if (FP_INC > 1 && reg_classes_intersect_p (FP_REGS, class))\n+\t  if (MAX_FPRS_PER_FMT > 1 && reg_classes_intersect_p (FP_REGS, class))\n \t    return true;\n \t}\n       else"}, {"sha": "fff2e660400639b9ac403d11f8685f8e269c1ca9", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=e8ab09c1bd7bb5de727a5cd9d9ebb22799b4bd0b", "patch": "@@ -1021,13 +1021,19 @@ extern const struct mips_rtx_cost_data *mips_cost;\n /* For MIPS, width of a floating point register.  */\n #define UNITS_PER_FPREG (TARGET_FLOAT64 ? 8 : 4)\n \n-/* If register $f0 holds a floating-point value, $f(0 + FP_INC) is\n-   the next available register.  */\n-#define FP_INC (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT ? 1 : 2)\n+/* The number of consecutive floating-point registers needed to store the\n+   largest format supported by the FPU.  */\n+#define MAX_FPRS_PER_FMT (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT ? 1 : 2)\n+\n+/* The number of consecutive floating-point registers needed to store the\n+   smallest format supported by the FPU.  */\n+#define MIN_FPRS_PER_FMT \\\n+  (ISA_MIPS32 || ISA_MIPS32R2 || ISA_MIPS64 ? 1 : MAX_FPRS_PER_FMT) \n \n /* The largest size of value that can be held in floating-point\n    registers and moved with a single instruction.  */\n-#define UNITS_PER_HWFPVALUE (TARGET_SOFT_FLOAT ? 0 : FP_INC * UNITS_PER_FPREG)\n+#define UNITS_PER_HWFPVALUE \\\n+  (TARGET_SOFT_FLOAT ? 0 : MAX_FPRS_PER_FMT * UNITS_PER_FPREG)\n \n /* The largest size of value that can be held in floating-point\n    registers.  */"}]}