{"sha": "ab0e5308484abccb6c21d3a6593ab653a02784a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIwZTUzMDg0ODRhYmNjYjZjMjFkM2E2NTkzYWI2NTNhMDI3ODRhMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-09-22T07:31:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-09-22T07:31:32Z"}, "message": "graphite-isl-ast-to-gimple.c (translate_pending_phi_nodes): Verify both BBs contain loop PHI nodes before dispatching to copy_loop_phi_args.\n\n2017-09-21  Richard Biener  <rguenther@suse.de>\n\n\t* graphite-isl-ast-to-gimple.c (translate_pending_phi_nodes):\n\tVerify both BBs contain loop PHI nodes before dispatching to\n\tcopy_loop_phi_args.\n\t(graphite_regenerate_ast_isl): Do not recompute dominators,\n\tdo not verify three times.  Restructure for clarity.\n\t* graphite-scop-detection.c (same_close_phi_node,\n\tremove_duplicate_close_phi, make_close_phi_nodes_unique,\n\tdefined_in_loop_p, canonicalize_loop_closed_ssa,\n\tcanonicalize_loop_closed_ssa_form): Simplify, remove excess\n\tchecking and SSA rewrite, move to ...\n\t* graphite.c: ... here.  Include ssa.h and tree-ssa-loop-manip.h.\n\t(graphite_initialize): Do not pass in ctx, do not reset the\n\tSCEV cache, compute only dominators.\n\t(graphite_transform_loops): Allocate ISL ctx after\n\tgraphite_initialize.  Call canonicalize_loop_closed_ssa_form.\n\tMaintain post-dominators only around build_scops.\n\t* sese.c (if_region_set_false_region): Make static.  Free\n\tand recompute dominators.\n\t(move_sese_in_condition): Assert we don't get called with\n\tpost-dominators computed.\n\t* sese.h (if_region_set_false_region): Remove.\n\nFrom-SVN: r253090", "tree": {"sha": "021bf36f1ccc132d37c48e39b7cde0e5b57beba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/021bf36f1ccc132d37c48e39b7cde0e5b57beba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab0e5308484abccb6c21d3a6593ab653a02784a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0e5308484abccb6c21d3a6593ab653a02784a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab0e5308484abccb6c21d3a6593ab653a02784a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0e5308484abccb6c21d3a6593ab653a02784a2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e7ba6a6041df85d7027a4e776f144a2f21204fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7ba6a6041df85d7027a4e776f144a2f21204fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7ba6a6041df85d7027a4e776f144a2f21204fdf"}], "stats": {"total": 453, "additions": 222, "deletions": 231}, "files": [{"sha": "bcb5a2a9dc45572b40e313bfa8d4105143a29a9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab0e5308484abccb6c21d3a6593ab653a02784a2", "patch": "@@ -1,3 +1,27 @@\n+2017-09-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* graphite-isl-ast-to-gimple.c (translate_pending_phi_nodes):\n+\tVerify both BBs contain loop PHI nodes before dispatching to\n+\tcopy_loop_phi_args.\n+\t(graphite_regenerate_ast_isl): Do not recompute dominators,\n+\tdo not verify three times.  Restructure for clarity.\n+\t* graphite-scop-detection.c (same_close_phi_node,\n+\tremove_duplicate_close_phi, make_close_phi_nodes_unique,\n+\tdefined_in_loop_p, canonicalize_loop_closed_ssa,\n+\tcanonicalize_loop_closed_ssa_form): Simplify, remove excess\n+\tchecking and SSA rewrite, move to ...\n+\t* graphite.c: ... here.  Include ssa.h and tree-ssa-loop-manip.h.\n+\t(graphite_initialize): Do not pass in ctx, do not reset the\n+\tSCEV cache, compute only dominators.\n+\t(graphite_transform_loops): Allocate ISL ctx after\n+\tgraphite_initialize.  Call canonicalize_loop_closed_ssa_form.\n+\tMaintain post-dominators only around build_scops.\n+\t* sese.c (if_region_set_false_region): Make static.  Free\n+\tand recompute dominators.\n+\t(move_sese_in_condition): Assert we don't get called with\n+\tpost-dominators computed.\n+\t* sese.h (if_region_set_false_region): Remove.\n+\n 2017-09-22  Sergey Shalnov  <sergey.shalnov@intel.com>\n \n         * config/i386/sse.md (\"mov<mode>_internal\"): Use <sseinsnmode>"}, {"sha": "1fb1bbd036a4162b17d3e8ac3981caa3272cbc14", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=ab0e5308484abccb6c21d3a6593ab653a02784a2", "patch": "@@ -2759,7 +2759,8 @@ translate_pending_phi_nodes ()\n \t}\n \n       auto_vec <tree, 1> iv_map;\n-      if (bb_contains_loop_phi_nodes (new_bb))\n+      if (bb_contains_loop_phi_nodes (new_bb)\n+\t  && bb_contains_loop_phi_nodes (old_bb))\n \tcodegen_error = !copy_loop_phi_args (old_phi, ibp_old_bb, new_phi,\n \t\t\t\t\t    ibp_new_bb, false);\n       else if (bb_contains_loop_close_phi_nodes (new_bb))\n@@ -2941,12 +2942,8 @@ graphite_regenerate_ast_isl (scop_p scop)\n       print_isl_ast (dump_file, root_node);\n     }\n \n-  recompute_all_dominators ();\n-  graphite_verify ();\n-\n   if_region = move_sese_in_condition (region);\n   region->if_region = if_region;\n-  recompute_all_dominators ();\n \n   loop_p context_loop = region->region.entry->src->loop_father;\n \n@@ -2960,45 +2957,28 @@ graphite_regenerate_ast_isl (scop_p scop)\n   region->if_region->true_region->region.exit = single_succ_edge (bb);\n \n   t.translate_isl_ast (context_loop, root_node, e, ip);\n+  if (! t.codegen_error_p ())\n+    t.translate_pending_phi_nodes ();\n+  if (! t.codegen_error_p ())\n+    {\n+      sese_insert_phis_for_liveouts (region,\n+\t\t\t\t     if_region->region->region.exit->src,\n+\t\t\t\t     if_region->false_region->region.exit,\n+\t\t\t\t     if_region->true_region->region.exit);\n+      if (dump_file)\n+\tfprintf (dump_file, \"[codegen] isl AST to Gimple succeeded.\\n\");\n+\n+      mark_virtual_operands_for_renaming (cfun);\n+      update_ssa (TODO_update_ssa);\n+    }\n+\n   if (t.codegen_error_p ())\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"codegen error: \"\n \t\t \"reverting back to the original code.\\n\");\n       set_ifsese_condition (if_region, integer_zero_node);\n-    }\n-  else\n-    {\n-      t.translate_pending_phi_nodes ();\n-      if (!t.codegen_error_p ())\n-\t{\n-\t  sese_insert_phis_for_liveouts (region,\n-\t\t\t\t\t if_region->region->region.exit->src,\n-\t\t\t\t\t if_region->false_region->region.exit,\n-\t\t\t\t\t if_region->true_region->region.exit);\n-\t  mark_virtual_operands_for_renaming (cfun);\n-\t  update_ssa (TODO_update_ssa);\n-\n-\n-\t  graphite_verify ();\n-\t  scev_reset ();\n-\t  recompute_all_dominators ();\n-\t  graphite_verify ();\n \n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"[codegen] isl AST to Gimple succeeded.\\n\");\n-\t}\n-      else\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"[codegen] unsuccessful in translating\"\n-\t\t     \" pending phis, reverting back to the original code.\\n\");\n-\t  set_ifsese_condition (if_region, integer_zero_node);\n-\t}\n-    }\n-\n-  if (t.codegen_error_p ())\n-    {\n       /* We registered new names, scrap that.  */\n       if (need_ssa_update_p (cfun))\n \tdelete_update_ssa ();\n@@ -3017,6 +2997,9 @@ graphite_regenerate_ast_isl (scop_p scop)\n \t  delete_loop (loop);\n     }\n \n+  graphite_verify ();\n+  scev_reset ();\n+\n   free (if_region->true_region);\n   free (if_region->region);\n   free (if_region);"}, {"sha": "594cf89c0907eb4220dc00df2685e43c09232fef", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=ab0e5308484abccb6c21d3a6593ab653a02784a2", "patch": "@@ -268,187 +268,6 @@ trivially_empty_bb_p (basic_block bb)\n   return true;\n }\n \n-/* Returns true when P1 and P2 are close phis with the same\n-   argument.  */\n-\n-static inline bool\n-same_close_phi_node (gphi *p1, gphi *p2)\n-{\n-  return (types_compatible_p (TREE_TYPE (gimple_phi_result (p1)),\n-\t\t\t      TREE_TYPE (gimple_phi_result (p2)))\n-\t  && operand_equal_p (gimple_phi_arg_def (p1, 0),\n-\t\t\t      gimple_phi_arg_def (p2, 0), 0));\n-}\n-\n-static void make_close_phi_nodes_unique (basic_block bb);\n-\n-/* Remove the close phi node at GSI and replace its rhs with the rhs\n-   of PHI.  */\n-\n-static void\n-remove_duplicate_close_phi (gphi *phi, gphi_iterator *gsi)\n-{\n-  gimple *use_stmt;\n-  use_operand_p use_p;\n-  imm_use_iterator imm_iter;\n-  tree res = gimple_phi_result (phi);\n-  tree def = gimple_phi_result (gsi->phi ());\n-\n-  gcc_assert (same_close_phi_node (phi, gsi->phi ()));\n-\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n-    {\n-      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\tSET_USE (use_p, res);\n-\n-      update_stmt (use_stmt);\n-\n-      /* It is possible that we just created a duplicate close-phi\n-\t for an already-processed containing loop.  Check for this\n-\t case and clean it up.  */\n-      if (gimple_code (use_stmt) == GIMPLE_PHI\n-\t  && gimple_phi_num_args (use_stmt) == 1)\n-\tmake_close_phi_nodes_unique (gimple_bb (use_stmt));\n-    }\n-\n-  remove_phi_node (gsi, true);\n-}\n-\n-/* Removes all the close phi duplicates from BB.  */\n-\n-static void\n-make_close_phi_nodes_unique (basic_block bb)\n-{\n-  gphi_iterator psi;\n-\n-  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-    {\n-      gphi_iterator gsi = psi;\n-      gphi *phi = psi.phi ();\n-\n-      /* At this point, PHI should be a close phi in normal form.  */\n-      gcc_assert (gimple_phi_num_args (phi) == 1);\n-\n-      /* Iterate over the next phis and remove duplicates.  */\n-      gsi_next (&gsi);\n-      while (!gsi_end_p (gsi))\n-\tif (same_close_phi_node (phi, gsi.phi ()))\n-\t  remove_duplicate_close_phi (phi, &gsi);\n-\telse\n-\t  gsi_next (&gsi);\n-    }\n-}\n-\n-/* Return true when NAME is defined in LOOP.  */\n-\n-static bool\n-defined_in_loop_p (tree name, loop_p loop)\n-{\n-  gcc_assert (TREE_CODE (name) == SSA_NAME);\n-  return loop == loop_containing_stmt (SSA_NAME_DEF_STMT (name));\n-}\n-\n-/* Transforms LOOP to the canonical loop closed SSA form.  */\n-\n-static void\n-canonicalize_loop_closed_ssa (loop_p loop)\n-{\n-  edge e = single_exit (loop);\n-  basic_block bb;\n-\n-  if (!e || (e->flags & EDGE_COMPLEX))\n-    return;\n-\n-  bb = e->dest;\n-\n-  if (single_pred_p (bb))\n-    {\n-      e = split_block_after_labels (bb);\n-      DEBUG_PRINT (dp << \"Splitting bb_\" << bb->index << \".\\n\");\n-      make_close_phi_nodes_unique (e->src);\n-    }\n-  else\n-    {\n-      gphi_iterator psi;\n-      basic_block close = split_edge (e);\n-\n-      e = single_succ_edge (close);\n-      DEBUG_PRINT (dp << \"Splitting edge (\" << e->src->index << \",\"\n-\t\t      << e->dest->index << \")\\n\");\n-\n-      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-\t{\n-\t  gphi *phi = psi.phi ();\n-\t  unsigned i;\n-\n-\t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-\t    if (gimple_phi_arg_edge (phi, i) == e)\n-\t      {\n-\t\ttree res, arg = gimple_phi_arg_def (phi, i);\n-\t\tuse_operand_p use_p;\n-\t\tgphi *close_phi;\n-\n-\t\t/* Only add close phi nodes for SSA_NAMEs defined in LOOP.  */\n-\t\tif (TREE_CODE (arg) != SSA_NAME\n-\t\t    || !defined_in_loop_p (arg, loop))\n-\t\t  continue;\n-\n-\t\tclose_phi = create_phi_node (NULL_TREE, close);\n-\t\tres = create_new_def_for (arg, close_phi,\n-\t\t\t\t\t  gimple_phi_result_ptr (close_phi));\n-\t\tadd_phi_arg (close_phi, arg,\n-\t\t\t     gimple_phi_arg_edge (close_phi, 0),\n-\t\t\t     UNKNOWN_LOCATION);\n-\t\tuse_p = gimple_phi_arg_imm_use_ptr (phi, i);\n-\t\treplace_exp (use_p, res);\n-\t\tupdate_stmt (phi);\n-\t      }\n-\t}\n-\n-      make_close_phi_nodes_unique (close);\n-    }\n-\n-  /* The code above does not properly handle changes in the post dominance\n-     information (yet).  */\n-  recompute_all_dominators ();\n-}\n-\n-/* Converts the current loop closed SSA form to a canonical form\n-   expected by the Graphite code generation.\n-\n-   The loop closed SSA form has the following invariant: a variable\n-   defined in a loop that is used outside the loop appears only in the\n-   phi nodes in the destination of the loop exit.  These phi nodes are\n-   called close phi nodes.\n-\n-   The canonical loop closed SSA form contains the extra invariants:\n-\n-   - when the loop contains only one exit, the close phi nodes contain\n-   only one argument.  That implies that the basic block that contains\n-   the close phi nodes has only one predecessor, that is a basic block\n-   in the loop.\n-\n-   - the basic block containing the close phi nodes does not contain\n-   other statements.\n-\n-   - there exist only one phi node per definition in the loop.\n-*/\n-\n-static void\n-canonicalize_loop_closed_ssa_form (void)\n-{\n-  checking_verify_loop_closed_ssa (true);\n-\n-  loop_p loop;\n-  FOR_EACH_LOOP (loop, 0)\n-    canonicalize_loop_closed_ssa (loop);\n-\n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n-  update_ssa (TODO_update_ssa);\n-\n-  checking_verify_loop_closed_ssa (true);\n-}\n-\n /* Can all ivs be represented by a signed integer?\n    As isl might generate negative values in its expressions, signed loop ivs\n    are required in the backend.  */\n@@ -2038,8 +1857,6 @@ build_scops (vec<scop_p> *scops)\n   if (dump_file)\n     dp.set_dump_file (dump_file);\n \n-  canonicalize_loop_closed_ssa_form ();\n-\n   /* ???  We walk the loop tree assuming loop->next is ordered.\n      This is not so but we'd be free to order it here.  */\n   scop_detection sb;"}, {"sha": "bce324092dd7e928dfb7c91818fdc1089757c62b", "filename": "gcc/graphite.c", "status": "modified", "additions": 168, "deletions": 8, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=ab0e5308484abccb6c21d3a6593ab653a02784a2", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfghooks.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n+#include \"ssa.h\"\n #include \"fold-const.h\"\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n@@ -53,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-parloops.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"tree-vectorizer.h\"\n+#include \"tree-ssa-loop-manip.h\"\n #include \"graphite.h\"\n \n /* Print global statistics to FILE.  */\n@@ -213,7 +215,7 @@ print_graphite_statistics (FILE* file, vec<scop_p> scops)\n /* Initialize graphite: when there are no loops returns false.  */\n \n static bool\n-graphite_initialize (isl_ctx *ctx)\n+graphite_initialize (void)\n {\n   int min_loops = PARAM_VALUE (PARAM_GRAPHITE_MIN_LOOPS_PER_FUNCTION);\n   int max_bbs = PARAM_VALUE (PARAM_GRAPHITE_MAX_BBS_PER_FUNCTION);\n@@ -240,12 +242,10 @@ graphite_initialize (isl_ctx *ctx)\n \t  print_global_statistics (dump_file);\n \t}\n \n-      isl_ctx_free (ctx);\n       return false;\n     }\n \n-  scev_reset ();\n-  recompute_all_dominators ();\n+  calculate_dominance_info (CDI_DOMINATORS);\n   initialize_original_copy_tables ();\n \n   if (dump_file && dump_flags)\n@@ -263,7 +263,6 @@ graphite_initialize (isl_ctx *ctx)\n static void\n graphite_finalize (bool need_cfg_cleanup_p)\n {\n-  free_dominance_info (CDI_POST_DOMINATORS);\n   if (need_cfg_cleanup_p)\n     {\n       free_dominance_info (CDI_DOMINATORS);\n@@ -294,6 +293,162 @@ free_scops (vec<scop_p> scops)\n   scops.release ();\n }\n \n+/* Returns true when P1 and P2 are close phis with the same\n+   argument.  */\n+\n+static inline bool\n+same_close_phi_node (gphi *p1, gphi *p2)\n+{\n+  return (types_compatible_p (TREE_TYPE (gimple_phi_result (p1)),\n+\t\t\t      TREE_TYPE (gimple_phi_result (p2)))\n+\t  && operand_equal_p (gimple_phi_arg_def (p1, 0),\n+\t\t\t      gimple_phi_arg_def (p2, 0), 0));\n+}\n+\n+static void make_close_phi_nodes_unique (basic_block bb);\n+\n+/* Remove the close phi node at GSI and replace its rhs with the rhs\n+   of PHI.  */\n+\n+static void\n+remove_duplicate_close_phi (gphi *phi, gphi_iterator *gsi)\n+{\n+  gimple *use_stmt;\n+  use_operand_p use_p;\n+  imm_use_iterator imm_iter;\n+  tree res = gimple_phi_result (phi);\n+  tree def = gimple_phi_result (gsi->phi ());\n+\n+  gcc_assert (same_close_phi_node (phi, gsi->phi ()));\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n+    {\n+      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\tSET_USE (use_p, res);\n+\n+      update_stmt (use_stmt);\n+\n+      /* It is possible that we just created a duplicate close-phi\n+\t for an already-processed containing loop.  Check for this\n+\t case and clean it up.  */\n+      if (gimple_code (use_stmt) == GIMPLE_PHI\n+\t  && gimple_phi_num_args (use_stmt) == 1)\n+\tmake_close_phi_nodes_unique (gimple_bb (use_stmt));\n+    }\n+\n+  remove_phi_node (gsi, true);\n+}\n+\n+/* Removes all the close phi duplicates from BB.  */\n+\n+static void\n+make_close_phi_nodes_unique (basic_block bb)\n+{\n+  gphi_iterator psi;\n+\n+  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+    {\n+      gphi_iterator gsi = psi;\n+      gphi *phi = psi.phi ();\n+\n+      /* At this point, PHI should be a close phi in normal form.  */\n+      gcc_assert (gimple_phi_num_args (phi) == 1);\n+\n+      /* Iterate over the next phis and remove duplicates.  */\n+      gsi_next (&gsi);\n+      while (!gsi_end_p (gsi))\n+\tif (same_close_phi_node (phi, gsi.phi ()))\n+\t  remove_duplicate_close_phi (phi, &gsi);\n+\telse\n+\t  gsi_next (&gsi);\n+    }\n+}\n+\n+/* Return true when NAME is defined in LOOP.  */\n+\n+static bool\n+defined_in_loop_p (tree name, loop_p loop)\n+{\n+  gcc_assert (TREE_CODE (name) == SSA_NAME);\n+  return loop == loop_containing_stmt (SSA_NAME_DEF_STMT (name));\n+}\n+\n+/* Transforms LOOP to the canonical loop closed SSA form.  */\n+\n+static void\n+canonicalize_loop_closed_ssa (loop_p loop)\n+{\n+  edge e = single_exit (loop);\n+  basic_block bb;\n+\n+  if (!e || (e->flags & EDGE_COMPLEX))\n+    return;\n+\n+  bb = e->dest;\n+\n+  if (single_pred_p (bb))\n+    {\n+      e = split_block_after_labels (bb);\n+      make_close_phi_nodes_unique (e->src);\n+    }\n+  else\n+    {\n+      gphi_iterator psi;\n+      basic_block close = split_edge (e);\n+      e = single_succ_edge (close);\n+      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+\t{\n+\t  gphi *phi = psi.phi ();\n+\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t  tree arg = USE_FROM_PTR (use_p);\n+\n+\t  /* Only add close phi nodes for SSA_NAMEs defined in LOOP.  */\n+\t  if (TREE_CODE (arg) != SSA_NAME\n+\t      || !defined_in_loop_p (arg, loop))\n+\t    continue;\n+\n+\t  tree res = copy_ssa_name (arg);\n+\t  gphi *close_phi = create_phi_node (res, close);\n+\t  add_phi_arg (close_phi, arg, gimple_phi_arg_edge (close_phi, 0),\n+\t\t       UNKNOWN_LOCATION);\n+\t  SET_USE (use_p, res);\n+\t}\n+\n+      make_close_phi_nodes_unique (close);\n+    }\n+}\n+\n+/* Converts the current loop closed SSA form to a canonical form\n+   expected by the Graphite code generation.\n+\n+   The loop closed SSA form has the following invariant: a variable\n+   defined in a loop that is used outside the loop appears only in the\n+   phi nodes in the destination of the loop exit.  These phi nodes are\n+   called close phi nodes.\n+\n+   The canonical loop closed SSA form contains the extra invariants:\n+\n+   - when the loop contains only one exit, the close phi nodes contain\n+   only one argument.  That implies that the basic block that contains\n+   the close phi nodes has only one predecessor, that is a basic block\n+   in the loop.\n+\n+   - the basic block containing the close phi nodes does not contain\n+   other statements.\n+\n+   - there exist only one phi node per definition in the loop.\n+*/\n+\n+static void\n+canonicalize_loop_closed_ssa_form (void)\n+{\n+  loop_p loop;\n+  FOR_EACH_LOOP (loop, 0)\n+    canonicalize_loop_closed_ssa (loop);\n+\n+  checking_verify_loop_closed_ssa (true);\n+}\n+\n isl_ctx *the_isl_ctx;\n \n /* Perform a set of linear transforms on the loops of the current\n@@ -313,13 +468,18 @@ graphite_transform_loops (void)\n   if (parallelized_function_p (cfun->decl))\n     return;\n \n-  ctx = isl_ctx_alloc ();\n-  isl_options_set_on_error (ctx, ISL_ON_ERROR_ABORT);\n-  if (!graphite_initialize (ctx))\n+  if (!graphite_initialize ())\n     return;\n \n+  ctx = isl_ctx_alloc ();\n+  isl_options_set_on_error (ctx, ISL_ON_ERROR_ABORT);\n   the_isl_ctx = ctx;\n+\n+  canonicalize_loop_closed_ssa_form ();\n+\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n   build_scops (&scops);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}, {"sha": "4be7d34e246c6bacc6270a5900f710dbd6d5817b", "filename": "gcc/sese.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=ab0e5308484abccb6c21d3a6593ab653a02784a2", "patch": "@@ -335,9 +335,11 @@ get_false_edge_from_guard_bb (basic_block bb)\n \n /* Sets the false region of an IF_REGION to REGION.  */\n \n-void\n+static void\n if_region_set_false_region (ifsese if_region, sese_info_p region)\n {\n+  free_dominance_info (CDI_DOMINATORS);\n+\n   basic_block condition = if_region_get_condition_block (if_region);\n   edge false_edge = get_false_edge_from_guard_bb (condition);\n   basic_block dummy = false_edge->dest;\n@@ -348,6 +350,8 @@ if_region_set_false_region (ifsese if_region, sese_info_p region)\n   hashval_t hash = htab_hash_pointer (exit_region);\n   loop_exit **slot\n     = current_loops->exits->find_slot_with_hash (exit_region, hash, NO_INSERT);\n+  bool latch_p\n+    = exit_region->dest->loop_father->latch == exit_region->src;\n \n   entry_region->flags = false_edge->flags;\n   false_edge->flags = exit_region->flags;\n@@ -359,7 +363,6 @@ if_region_set_false_region (ifsese if_region, sese_info_p region)\n   delete_basic_block (dummy);\n \n   exit_region->flags = EDGE_FALLTHRU;\n-  recompute_all_dominators ();\n \n   region->region.exit = false_edge;\n \n@@ -381,6 +384,10 @@ if_region_set_false_region (ifsese if_region, sese_info_p region)\n       *slot = loop_exit;\n       false_edge->src->loop_father->exits->next = loop_exit;\n     }\n+  if (latch_p)\n+    exit_region->dest->loop_father->latch = before_region;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n }\n \n /* Creates an IFSESE with CONDITION on edge ENTRY.  */\n@@ -429,6 +436,7 @@ create_if_region_on_edge (edge entry, tree condition)\n ifsese\n move_sese_in_condition (sese_info_p region)\n {\n+  gcc_assert (! dom_info_available_p (cfun, CDI_POST_DOMINATORS));\n   basic_block pred_block = split_edge (region->region.entry);\n   ifsese if_region;\n "}, {"sha": "025e733476c9404189212fd504a791fb9ef3fd44", "filename": "gcc/sese.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0e5308484abccb6c21d3a6593ab653a02784a2/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=ab0e5308484abccb6c21d3a6593ab653a02784a2", "patch": "@@ -233,7 +233,6 @@ typedef struct ifsese_s {\n   sese_info_p false_region;\n } *ifsese;\n \n-extern void if_region_set_false_region (ifsese, sese_info_p);\n extern ifsese move_sese_in_condition (sese_info_p);\n extern void set_ifsese_condition (ifsese, tree);\n extern edge get_true_edge_from_guard_bb (basic_block);"}]}