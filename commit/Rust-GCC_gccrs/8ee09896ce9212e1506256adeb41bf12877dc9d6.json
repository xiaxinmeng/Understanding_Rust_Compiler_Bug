{"sha": "8ee09896ce9212e1506256adeb41bf12877dc9d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVlMDk4OTZjZTkyMTJlMTUwNjI1NmFkZWI0MWJmMTI4NzdkYzlkNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-06-15T18:33:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-06-15T18:33:26Z"}, "message": "alias-access-path-2.c: New testcase.\n\n\n\t* gcc.dg/tree-ssa/alias-access-path-2.c: New testcase.\n\n\t* tree-ssa-alias.c (alias_stats): Add\n\tnonoverlapping_component_refs_p_may_alias,\n\tnonoverlapping_component_refs_p_no_alias,\n\tnonoverlapping_component_refs_of_decl_p_may_alias,\n\tnonoverlapping_component_refs_of_decl_p_no_alias.\n\t(dump_alias_stats): Dump them.\n\t(nonoverlapping_component_refs_of_decl_p): Add stats.\n\t(nonoverlapping_component_refs_p): Add stats; do not stop on first\n\tARRAY_REF.\n\nFrom-SVN: r272329", "tree": {"sha": "49ad0fdf44f5e4f8572d4679b80920c1c03c0e74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49ad0fdf44f5e4f8572d4679b80920c1c03c0e74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ee09896ce9212e1506256adeb41bf12877dc9d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee09896ce9212e1506256adeb41bf12877dc9d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ee09896ce9212e1506256adeb41bf12877dc9d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee09896ce9212e1506256adeb41bf12877dc9d6/comments", "author": null, "committer": null, "parents": [{"sha": "9f0ad06b9a8ca2a13df3e7088c0195921ccff727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f0ad06b9a8ca2a13df3e7088c0195921ccff727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f0ad06b9a8ca2a13df3e7088c0195921ccff727"}], "stats": {"total": 173, "additions": 144, "deletions": 29}, "files": [{"sha": "e3799aec817e77eacb5909bc3f2afeef62d9e0fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee09896ce9212e1506256adeb41bf12877dc9d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee09896ce9212e1506256adeb41bf12877dc9d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ee09896ce9212e1506256adeb41bf12877dc9d6", "patch": "@@ -1,3 +1,15 @@\n+2019-06-15  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (alias_stats): Add\n+\tnonoverlapping_component_refs_p_may_alias,\n+\tnonoverlapping_component_refs_p_no_alias,\n+\tnonoverlapping_component_refs_of_decl_p_may_alias,\n+\tnonoverlapping_component_refs_of_decl_p_no_alias.\n+\t(dump_alias_stats): Dump them.\n+\t(nonoverlapping_component_refs_of_decl_p): Add stats.\n+\t(nonoverlapping_component_refs_p): Add stats; do not stop on first\n+\tARRAY_REF.\n+\n 2019-06-15  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (and<mode>3): Generate zero-extends for"}, {"sha": "411d4966765fad8be694b1073f2f71f9df50708a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee09896ce9212e1506256adeb41bf12877dc9d6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee09896ce9212e1506256adeb41bf12877dc9d6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ee09896ce9212e1506256adeb41bf12877dc9d6", "patch": "@@ -1,3 +1,7 @@\n+2019-06-15  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/tree-ssa/alias-access-path-2.c: New testcase.\n+\n 2019-06-15  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.dg/ieee/ieee_4.f90: Un-xfail on i?86-*-freebsd."}, {"sha": "974cdb0ee00641156eac46c77693eca1e54a3014", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee09896ce9212e1506256adeb41bf12877dc9d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee09896ce9212e1506256adeb41bf12877dc9d6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-2.c?ref=8ee09896ce9212e1506256adeb41bf12877dc9d6", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fre3\" } */\n+struct a {\n+  int val;\n+};\n+struct b {\n+  struct a a[10],a2[10];\n+};\n+struct c {\n+  struct b b[10];\n+} *cptr;\n+\n+struct d {struct c c;} *dptr;\n+\n+int\n+test (int i, int j, int k, int l)\n+{\n+  cptr->b[i].a[j].val=123;\n+  dptr->c.b[k].a2[l].val=2;\n+  return cptr->b[i].a[j].val;\n+}\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"fre3\"} } */"}, {"sha": "42f02765824f6045099e8b1baba4d54ba1975795", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 106, "deletions": 29, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee09896ce9212e1506256adeb41bf12877dc9d6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee09896ce9212e1506256adeb41bf12877dc9d6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=8ee09896ce9212e1506256adeb41bf12877dc9d6", "patch": "@@ -100,6 +100,10 @@ static struct {\n   unsigned HOST_WIDE_INT call_may_clobber_ref_p_no_alias;\n   unsigned HOST_WIDE_INT aliasing_component_refs_p_may_alias;\n   unsigned HOST_WIDE_INT aliasing_component_refs_p_no_alias;\n+  unsigned HOST_WIDE_INT nonoverlapping_component_refs_p_may_alias;\n+  unsigned HOST_WIDE_INT nonoverlapping_component_refs_p_no_alias;\n+  unsigned HOST_WIDE_INT nonoverlapping_component_refs_of_decl_p_may_alias;\n+  unsigned HOST_WIDE_INT nonoverlapping_component_refs_of_decl_p_no_alias;\n } alias_stats;\n \n void\n@@ -124,7 +128,19 @@ dump_alias_stats (FILE *s)\n \t   alias_stats.call_may_clobber_ref_p_no_alias,\n \t   alias_stats.call_may_clobber_ref_p_no_alias\n \t   + alias_stats.call_may_clobber_ref_p_may_alias);\n-  fprintf (s, \"  aliasing_component_ref_p: \"\n+  fprintf (s, \"  nonoverlapping_component_refs_p: \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n+\t   alias_stats.nonoverlapping_component_refs_p_no_alias,\n+\t   alias_stats.nonoverlapping_component_refs_p_no_alias\n+\t   + alias_stats.nonoverlapping_component_refs_p_may_alias);\n+  fprintf (s, \"  nonoverlapping_component_refs_of_decl_p: \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n+\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n+\t   alias_stats.nonoverlapping_component_refs_of_decl_p_no_alias,\n+\t   alias_stats.nonoverlapping_component_refs_of_decl_p_no_alias\n+\t   + alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias);\n+  fprintf (s, \"  aliasing_component_refs_p: \"\n \t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n \t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n \t   alias_stats.aliasing_component_refs_p_no_alias,\n@@ -1047,7 +1063,10 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n   if (TREE_CODE (ref1) == MEM_REF)\n     {\n       if (!integer_zerop (TREE_OPERAND (ref1, 1)))\n-\treturn false;\n+\t{\n+\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n+\t  return false;\n+\t}\n       ref1 = TREE_OPERAND (TREE_OPERAND (ref1, 0), 0);\n     }\n \n@@ -1060,7 +1079,10 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n   if (TREE_CODE (ref2) == MEM_REF)\n     {\n       if (!integer_zerop (TREE_OPERAND (ref2, 1)))\n-\treturn false;\n+\t{\n+\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n+\t  return false;\n+\t}\n       ref2 = TREE_OPERAND (TREE_OPERAND (ref2, 0), 0);\n     }\n \n@@ -1080,23 +1102,32 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n       do\n \t{\n \t  if (component_refs1.is_empty ())\n-\t    return false;\n+\t    {\n+\t      ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n+\t      return false;\n+\t    }\n \t  ref1 = component_refs1.pop ();\n \t}\n       while (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (ref1, 0))));\n \n       do\n \t{\n \t  if (component_refs2.is_empty ())\n-\t     return false;\n+\t    {\n+\t      ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n+\t      return false;\n+\t    }\n \t  ref2 = component_refs2.pop ();\n \t}\n       while (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (ref2, 0))));\n \n       /* Beware of BIT_FIELD_REF.  */\n       if (TREE_CODE (ref1) != COMPONENT_REF\n \t  || TREE_CODE (ref2) != COMPONENT_REF)\n-\treturn false;\n+\t{\n+\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n+\t  return false;\n+\t}\n \n       tree field1 = TREE_OPERAND (ref1, 1);\n       tree field2 = TREE_OPERAND (ref2, 1);\n@@ -1109,23 +1140,34 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n \n       /* We cannot disambiguate fields in a union or qualified union.  */\n       if (type1 != type2 || TREE_CODE (type1) != RECORD_TYPE)\n-\t return false;\n+\t{\n+\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n+\t  return false;\n+\t}\n \n       if (field1 != field2)\n \t{\n \t  /* A field and its representative need to be considered the\n \t     same.  */\n \t  if (DECL_BIT_FIELD_REPRESENTATIVE (field1) == field2\n \t      || DECL_BIT_FIELD_REPRESENTATIVE (field2) == field1)\n-\t    return false;\n+\t    {\n+\t      ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n+\t      return false;\n+\t    }\n \t  /* Different fields of the same record type cannot overlap.\n \t     ??? Bitfields can overlap at RTL level so punt on them.  */\n \t  if (DECL_BIT_FIELD (field1) && DECL_BIT_FIELD (field2))\n-\t    return false;\n+\t    {\n+\t      ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n+\t      return false;\n+\t    }\n+\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_no_alias;\n \t  return true;\n \t}\n     }\n \n+  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n   return false;\n }\n \n@@ -1154,40 +1196,67 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n {\n   if (!flag_strict_aliasing\n       || !x || !y\n-      || TREE_CODE (x) != COMPONENT_REF\n-      || TREE_CODE (y) != COMPONENT_REF)\n-    return false;\n+      || !handled_component_p (x)\n+      || !handled_component_p (y))\n+    {\n+      ++alias_stats.nonoverlapping_component_refs_p_may_alias;\n+      return false;\n+    }\n \n   auto_vec<const_tree, 16> fieldsx;\n-  while (TREE_CODE (x) == COMPONENT_REF)\n+  while (handled_component_p (x))\n     {\n-      tree field = TREE_OPERAND (x, 1);\n-      tree type = DECL_FIELD_CONTEXT (field);\n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\tfieldsx.safe_push (field);\n+      if (TREE_CODE (x) == COMPONENT_REF)\n+\t{\n+\t  tree field = TREE_OPERAND (x, 1);\n+\t  tree type = DECL_FIELD_CONTEXT (field);\n+\t  if (TREE_CODE (type) == RECORD_TYPE)\n+\t    fieldsx.safe_push (field);\n+\t}\n+      else if (TREE_CODE (x) == VIEW_CONVERT_EXPR)\n+\tfieldsx.truncate (0);\n       x = TREE_OPERAND (x, 0);\n     }\n   if (fieldsx.length () == 0)\n     return false;\n   auto_vec<const_tree, 16> fieldsy;\n-  while (TREE_CODE (y) == COMPONENT_REF)\n+  while (handled_component_p (y))\n     {\n-      tree field = TREE_OPERAND (y, 1);\n-      tree type = DECL_FIELD_CONTEXT (field);\n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\tfieldsy.safe_push (TREE_OPERAND (y, 1));\n+      if (TREE_CODE (y) == COMPONENT_REF)\n+\t{\n+\t  tree field = TREE_OPERAND (y, 1);\n+\t  tree type = DECL_FIELD_CONTEXT (field);\n+\t  if (TREE_CODE (type) == RECORD_TYPE)\n+\t    fieldsy.safe_push (TREE_OPERAND (y, 1));\n+\t}\n+      else if (TREE_CODE (y) == VIEW_CONVERT_EXPR)\n+\tfieldsx.truncate (0);\n       y = TREE_OPERAND (y, 0);\n     }\n   if (fieldsy.length () == 0)\n-    return false;\n+    {\n+      ++alias_stats.nonoverlapping_component_refs_p_may_alias;\n+      return false;\n+    }\n \n   /* Most common case first.  */\n   if (fieldsx.length () == 1\n       && fieldsy.length () == 1)\n-    return ((DECL_FIELD_CONTEXT (fieldsx[0])\n-\t     == DECL_FIELD_CONTEXT (fieldsy[0]))\n-\t    && fieldsx[0] != fieldsy[0]\n-\t    && !(DECL_BIT_FIELD (fieldsx[0]) && DECL_BIT_FIELD (fieldsy[0])));\n+   {\n+     if ((DECL_FIELD_CONTEXT (fieldsx[0])\n+         == DECL_FIELD_CONTEXT (fieldsy[0]))\n+        && fieldsx[0] != fieldsy[0]\n+        && !(DECL_BIT_FIELD (fieldsx[0]) && DECL_BIT_FIELD (fieldsy[0])))\n+      {\n+         ++alias_stats.nonoverlapping_component_refs_p_no_alias;\n+         return true;\n+      }\n+     else\n+      {\n+         ++alias_stats.nonoverlapping_component_refs_p_may_alias;\n+         return false;\n+      }\n+   }\n \n   if (fieldsx.length () == 2)\n     {\n@@ -1222,11 +1291,18 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n \t\t same.  */\n \t      if (DECL_BIT_FIELD_REPRESENTATIVE (fieldx) == fieldy\n \t\t  || DECL_BIT_FIELD_REPRESENTATIVE (fieldy) == fieldx)\n-\t\treturn false;\n+\t\t{\n+\t\t   ++alias_stats.nonoverlapping_component_refs_p_may_alias;\n+\t\t   return false;\n+\t\t}\n \t      /* Different fields of the same record type cannot overlap.\n \t\t ??? Bitfields can overlap at RTL level so punt on them.  */\n \t      if (DECL_BIT_FIELD (fieldx) && DECL_BIT_FIELD (fieldy))\n-\t\treturn false;\n+\t\t{\n+\t\t   ++alias_stats.nonoverlapping_component_refs_p_may_alias;\n+\t\t   return false;\n+\t\t}\n+\t      ++alias_stats.nonoverlapping_component_refs_p_no_alias;\n \t      return true;\n \t    }\n \t}\n@@ -1245,6 +1321,7 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n     }\n   while (1);\n \n+  ++alias_stats.nonoverlapping_component_refs_p_may_alias;\n   return false;\n }\n "}]}