{"sha": "c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU5ZGFiYmU0NmY3ZmIzNTFjZjFlZWFkYWRjM2M3ZmM2NTVhNTdmNg==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2005-09-26T18:44:16Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2005-09-26T18:44:16Z"}, "message": "re PR tree-optimization/23942 (loop problem / testcase takes very long time to compile)\n\n\tPR tree-optimization/23942\n\t* Makefile.in (SCEV_H): Depends on PARAMS_H.\n\t* tree-scalar-evolution.c: Include params.h.\n\t(t_bool): New enum.\n\t(follow_ssa_edge, follow_ssa_edge_in_rhs,\n\tfollow_ssa_edge_in_condition_phi_branch,\n\tfollow_ssa_edge_in_condition_phi, follow_ssa_edge_inner_loop_phi):\n\tChange return type to t_bool.  Use a parameter to limit the size of\n\ttrees that are walked before stopping\n\t(analyze_evolution_in_loop): Initialize the limit to 0.\n\t(follow_ssa_edge): Give up by returning t_dont_know if the limit\n\texceeds PARAM_SCEV_MAX_EXPR_SIZE.\n\nFrom-SVN: r104653", "tree": {"sha": "ce0308e7c928b4cd0931b0d737e65c3428d59513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce0308e7c928b4cd0931b0d737e65c3428d59513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f9284bf83143fbc2682b831121553c85e4b14f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9284bf83143fbc2682b831121553c85e4b14f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f9284bf83143fbc2682b831121553c85e4b14f2"}], "stats": {"total": 204, "additions": 122, "deletions": 82}, "files": [{"sha": "8499938c80b7b561b8272de70e7d2453c9f1634c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6", "patch": "@@ -1,3 +1,18 @@\n+2005-09-26  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\tPR tree-optimization/23942\n+\t* Makefile.in (SCEV_H): Depends on PARAMS_H.\n+\t* tree-scalar-evolution.c: Include params.h.\n+\t(t_bool): New enum.\n+\t(follow_ssa_edge, follow_ssa_edge_in_rhs,\n+\tfollow_ssa_edge_in_condition_phi_branch,\n+\tfollow_ssa_edge_in_condition_phi, follow_ssa_edge_inner_loop_phi): \n+\tChange return type to t_bool.  Use a parameter to limit the size of\n+\ttrees that are walked before stopping \n+\t(analyze_evolution_in_loop): Initialize the limit to 0.\n+\t(follow_ssa_edge): Give up by returning t_dont_know if the limit \n+\texceeds PARAM_SCEV_MAX_EXPR_SIZE.\n+\n 2005-09-26  Uros Bizjak  <uros@kss-loka.si>\n \n \tPR middle-end/23831"}, {"sha": "33056ee17aafbf05341246d3a90f280e85f6a1be", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6", "patch": "@@ -767,7 +767,7 @@ TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H)\n PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)\n DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H)\n C_PRETTY_PRINT_H = c-pretty-print.h $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)\n-SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h\n+SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n LAMBDA_H = lambda.h tree.h vec.h $(GGC_H)\n TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H)\n VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)"}, {"sha": "b13cac134c0f3e8421d51a9c793b54d406d6f667", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 106, "deletions": 81, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=c59dabbe46f7fb351cf1eeadadc3c7fc655a57f6", "patch": "@@ -251,6 +251,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n #include \"flags.h\"\n+#include \"params.h\"\n \n static tree analyze_scalar_evolution_1 (struct loop *, tree, tree);\n static tree resolve_mixers (struct loop *, tree);\n@@ -1022,19 +1023,23 @@ select_loops_exit_conditions (struct loops *loops,\n \f\n /* Depth first search algorithm.  */\n \n-static bool follow_ssa_edge (struct loop *loop, tree, tree, tree *);\n+typedef enum t_bool {\n+  t_false,\n+  t_true,\n+  t_dont_know\n+} t_bool;\n+\n+\n+static t_bool follow_ssa_edge (struct loop *loop, tree, tree, tree *, int);\n \n /* Follow the ssa edge into the right hand side RHS of an assignment.\n    Return true if the strongly connected component has been found.  */\n \n-static bool\n-follow_ssa_edge_in_rhs (struct loop *loop,\n-\t\t\ttree at_stmt,\n-\t\t\ttree rhs, \n-\t\t\ttree halting_phi, \n-\t\t\ttree *evolution_of_loop)\n+static t_bool\n+follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs, \n+\t\t\ttree halting_phi, tree *evolution_of_loop, int limit)\n {\n-  bool res = false;\n+  t_bool res = t_false;\n   tree rhs0, rhs1;\n   tree type_rhs = TREE_TYPE (rhs);\n   \n@@ -1050,20 +1055,20 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n     case NOP_EXPR:\n       /* This assignment is under the form \"a_1 = (cast) rhs.  */\n       res = follow_ssa_edge_in_rhs (loop, at_stmt, TREE_OPERAND (rhs, 0),\n-\t\t\t\t    halting_phi, evolution_of_loop);\n+\t\t\t\t    halting_phi, evolution_of_loop, limit);\n       *evolution_of_loop = chrec_convert (TREE_TYPE (rhs),\n \t\t\t\t\t  *evolution_of_loop, at_stmt);\n       break;\n \n     case INTEGER_CST:\n       /* This assignment is under the form \"a_1 = 7\".  */\n-      res = false;\n+      res = t_false;\n       break;\n       \n     case SSA_NAME:\n       /* This assignment is under the form: \"a_1 = b_2\".  */\n       res = follow_ssa_edge \n-\t(loop, SSA_NAME_DEF_STMT (rhs), halting_phi, evolution_of_loop);\n+\t(loop, SSA_NAME_DEF_STMT (rhs), halting_phi, evolution_of_loop, limit);\n       break;\n       \n     case PLUS_EXPR:\n@@ -1081,26 +1086,32 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t\t \"a = b + c\".  */\n \t      res = follow_ssa_edge \n \t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n-\t\t evolution_of_loop);\n+\t\t evolution_of_loop, limit);\n \t      \n-\t      if (res)\n+\t      if (res == t_true)\n \t\t*evolution_of_loop = add_to_evolution \n \t\t  (loop->num, \n \t\t   chrec_convert (type_rhs, *evolution_of_loop, at_stmt), \n \t\t   PLUS_EXPR, rhs1);\n \t      \n-\t      else\n+\t      else if (res == t_false)\n \t\t{\n \t\t  res = follow_ssa_edge \n \t\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n-\t\t     evolution_of_loop);\n+\t\t     evolution_of_loop, limit);\n \t\t  \n-\t\t  if (res)\n+\t\t  if (res == t_true)\n \t\t    *evolution_of_loop = add_to_evolution \n \t\t      (loop->num, \n \t\t       chrec_convert (type_rhs, *evolution_of_loop, at_stmt), \n \t\t       PLUS_EXPR, rhs0);\n+\n+\t\t  else if (res == t_dont_know)\n+\t\t    *evolution_of_loop = chrec_dont_know;\n \t\t}\n+\n+\t      else if (res == t_dont_know)\n+\t\t*evolution_of_loop = chrec_dont_know;\n \t    }\n \t  \n \t  else\n@@ -1109,12 +1120,15 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t\t \"a = b + ...\".  */\n \t      res = follow_ssa_edge \n \t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n-\t\t evolution_of_loop);\n-\t      if (res)\n+\t\t evolution_of_loop, limit);\n+\t      if (res == t_true)\n \t\t*evolution_of_loop = add_to_evolution \n \t\t  (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n \t\t\t\t\t     at_stmt),\n \t\t   PLUS_EXPR, rhs1);\n+\n+\t      else if (res == t_dont_know)\n+\t\t*evolution_of_loop = chrec_dont_know;\n \t    }\n \t}\n       \n@@ -1124,19 +1138,22 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t     \"a = ... + c\".  */\n \t  res = follow_ssa_edge \n \t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n-\t     evolution_of_loop);\n-\t  if (res)\n+\t     evolution_of_loop, limit);\n+\t  if (res == t_true)\n \t    *evolution_of_loop = add_to_evolution \n \t      (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n \t\t\t\t\t at_stmt),\n \t       PLUS_EXPR, rhs0);\n+\n+\t  else if (res == t_dont_know)\n+\t    *evolution_of_loop = chrec_dont_know;\n \t}\n \n       else\n \t/* Otherwise, match an assignment under the form: \n \t   \"a = ... + ...\".  */\n \t/* And there is nothing to do.  */\n-\tres = false;\n+\tres = t_false;\n       \n       break;\n       \n@@ -1152,18 +1169,20 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t  /* Match an assignment under the form: \n \t     \"a = b - ...\".  */\n \t  res = follow_ssa_edge (loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n-\t\t\t\t evolution_of_loop);\n-\t  if (res)\n+\t\t\t\t evolution_of_loop, limit);\n+\t  if (res == t_true)\n \t    *evolution_of_loop = add_to_evolution \n-\t\t    (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n-\t\t\t\t\t       at_stmt),\n-\t\t     MINUS_EXPR, rhs1);\n+\t      (loop->num, chrec_convert (type_rhs, *evolution_of_loop, at_stmt),\n+\t       MINUS_EXPR, rhs1);\n+\n+\t  else if (res == t_dont_know)\n+\t    *evolution_of_loop = chrec_dont_know;\n \t}\n       else\n \t/* Otherwise, match an assignment under the form: \n \t   \"a = ... - ...\".  */\n \t/* And there is nothing to do.  */\n-\tres = false;\n+\tres = t_false;\n       \n       break;\n     \n@@ -1182,18 +1201,18 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t\t \"a = b * c\".  */\n \t      res = follow_ssa_edge \n \t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n-\t\t evolution_of_loop);\n+\t\t evolution_of_loop, limit);\n \t      \n-\t      if (res)\n+\t      if (res == t_true || res == t_dont_know)\n \t\t*evolution_of_loop = chrec_dont_know;\n \t      \n-\t      else\n+\t      else if (res == t_false)\n \t\t{\n \t\t  res = follow_ssa_edge \n \t\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n-\t\t     evolution_of_loop);\n+\t\t     evolution_of_loop, limit);\n \t\t  \n-\t\t  if (res)\n+\t\t  if (res == t_true || res == t_dont_know)\n \t\t    *evolution_of_loop = chrec_dont_know;\n \t\t}\n \t    }\n@@ -1204,8 +1223,8 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t\t \"a = b * ...\".  */\n \t      res = follow_ssa_edge \n \t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n-\t\t evolution_of_loop);\n-\t      if (res)\n+\t\t evolution_of_loop, limit);\n+\t      if (res == t_true || res == t_dont_know)\n \t\t*evolution_of_loop = chrec_dont_know;\n \t    }\n \t}\n@@ -1216,16 +1235,16 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t     \"a = ... * c\".  */\n \t  res = follow_ssa_edge \n \t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n-\t     evolution_of_loop);\n-\t  if (res)\n+\t     evolution_of_loop, limit);\n+\t  if (res == t_true || res == t_dont_know)\n \t    *evolution_of_loop = chrec_dont_know;\n \t}\n       \n       else\n \t/* Otherwise, match an assignment under the form: \n \t   \"a = ... * ...\".  */\n \t/* And there is nothing to do.  */\n-\tres = false;\n+\tres = t_false;\n       \n       break;\n \n@@ -1236,15 +1255,15 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \ttree op0 = ASSERT_EXPR_VAR (rhs);\n \tif (TREE_CODE (op0) == SSA_NAME)\n \t  res = follow_ssa_edge (loop, SSA_NAME_DEF_STMT (op0),\n-\t\t\t\t halting_phi, evolution_of_loop);\n+\t\t\t\t halting_phi, evolution_of_loop, limit);\n \telse\n-\t  res = false;\n+\t  res = t_false;\n \tbreak;\n       }\n \n \n     default:\n-      res = false;\n+      res = t_false;\n       break;\n     }\n   \n@@ -1271,27 +1290,27 @@ backedge_phi_arg_p (tree phi, int i)\n    true if the strongly connected component has been found following\n    this path.  */\n \n-static inline bool\n+static inline t_bool\n follow_ssa_edge_in_condition_phi_branch (int i,\n \t\t\t\t\t struct loop *loop, \n \t\t\t\t\t tree condition_phi, \n \t\t\t\t\t tree halting_phi,\n \t\t\t\t\t tree *evolution_of_branch,\n-\t\t\t\t\t tree init_cond)\n+\t\t\t\t\t tree init_cond, int limit)\n {\n   tree branch = PHI_ARG_DEF (condition_phi, i);\n   *evolution_of_branch = chrec_dont_know;\n \n   /* Do not follow back edges (they must belong to an irreducible loop, which\n      we really do not want to worry about).  */\n   if (backedge_phi_arg_p (condition_phi, i))\n-    return false;\n+    return t_false;\n \n   if (TREE_CODE (branch) == SSA_NAME)\n     {\n       *evolution_of_branch = init_cond;\n       return follow_ssa_edge (loop, SSA_NAME_DEF_STMT (branch), halting_phi, \n-\t\t\t      evolution_of_branch);\n+\t\t\t      evolution_of_branch, limit);\n     }\n \n   /* This case occurs when one of the condition branches sets \n@@ -1301,59 +1320,61 @@ follow_ssa_edge_in_condition_phi_branch (int i,\n      FIXME:  This case have to be refined correctly: \n      in some cases it is possible to say something better than\n      chrec_dont_know, for example using a wrap-around notation.  */\n-  return false;\n+  return t_false;\n }\n \n /* This function merges the branches of a condition-phi-node in a\n    loop.  */\n \n-static bool\n+static t_bool\n follow_ssa_edge_in_condition_phi (struct loop *loop,\n \t\t\t\t  tree condition_phi, \n \t\t\t\t  tree halting_phi, \n-\t\t\t\t  tree *evolution_of_loop)\n+\t\t\t\t  tree *evolution_of_loop, int limit)\n {\n   int i;\n   tree init = *evolution_of_loop;\n   tree evolution_of_branch;\n+  t_bool res = follow_ssa_edge_in_condition_phi_branch (0, loop, condition_phi,\n+\t\t\t\t\t\t\thalting_phi,\n+\t\t\t\t\t\t\t&evolution_of_branch,\n+\t\t\t\t\t\t\tinit, limit);\n+  if (res == t_false || res == t_dont_know)\n+    return res;\n \n-  if (!follow_ssa_edge_in_condition_phi_branch (0, loop, condition_phi,\n-\t\t\t\t\t\thalting_phi,\n-\t\t\t\t\t\t&evolution_of_branch,\n-\t\t\t\t\t\tinit))\n-    return false;\n   *evolution_of_loop = evolution_of_branch;\n \n   for (i = 1; i < PHI_NUM_ARGS (condition_phi); i++)\n     {\n       /* Quickly give up when the evolution of one of the branches is\n \t not known.  */\n       if (*evolution_of_loop == chrec_dont_know)\n-\treturn true;\n+\treturn t_true;\n \n-      if (!follow_ssa_edge_in_condition_phi_branch (i, loop, condition_phi,\n-\t\t\t\t\t\t    halting_phi,\n-\t\t\t\t\t\t    &evolution_of_branch,\n-\t\t\t\t\t\t    init))\n-\treturn false;\n+      res = follow_ssa_edge_in_condition_phi_branch (i, loop, condition_phi,\n+\t\t\t\t\t\t     halting_phi,\n+\t\t\t\t\t\t     &evolution_of_branch,\n+\t\t\t\t\t\t     init, limit);\n+      if (res == t_false || res == t_dont_know)\n+\treturn res;\n \n       *evolution_of_loop = chrec_merge (*evolution_of_loop,\n \t\t\t\t\tevolution_of_branch);\n     }\n   \n-  return true;\n+  return t_true;\n }\n \n /* Follow an SSA edge in an inner loop.  It computes the overall\n    effect of the loop, and following the symbolic initial conditions,\n    it follows the edges in the parent loop.  The inner loop is\n    considered as a single statement.  */\n \n-static bool\n+static t_bool\n follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n \t\t\t\ttree loop_phi_node, \n \t\t\t\ttree halting_phi,\n-\t\t\t\ttree *evolution_of_loop)\n+\t\t\t\ttree *evolution_of_loop, int limit)\n {\n   struct loop *loop = loop_containing_stmt (loop_phi_node);\n   tree ev = analyze_scalar_evolution (loop, PHI_RESULT (loop_phi_node));\n@@ -1362,7 +1383,7 @@ follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n      result of the analysis is a symbolic parameter.  */\n   if (ev == PHI_RESULT (loop_phi_node))\n     {\n-      bool res = false;\n+      t_bool res = t_false;\n       int i;\n \n       for (i = 0; i < PHI_NUM_ARGS (loop_phi_node); i++)\n@@ -1373,13 +1394,15 @@ follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n \t  /* Follow the edges that exit the inner loop.  */\n \t  bb = PHI_ARG_EDGE (loop_phi_node, i)->src;\n \t  if (!flow_bb_inside_loop_p (loop, bb))\n-\t    res = res || follow_ssa_edge_in_rhs (outer_loop, loop_phi_node,\n-\t\t\t\t\t\t arg, halting_phi,\n-\t\t\t\t\t\t evolution_of_loop);\n+\t    res = follow_ssa_edge_in_rhs (outer_loop, loop_phi_node,\n+\t\t\t\t\t  arg, halting_phi,\n+\t\t\t\t\t  evolution_of_loop, limit);\n+\t  if (res == t_true)\n+\t    break;\n \t}\n \n       /* If the path crosses this loop-phi, give up.  */\n-      if (res == true)\n+      if (res == t_true)\n \t*evolution_of_loop = chrec_dont_know;\n \n       return res;\n@@ -1388,22 +1411,24 @@ follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n   /* Otherwise, compute the overall effect of the inner loop.  */\n   ev = compute_overall_effect_of_inner_loop (loop, ev);\n   return follow_ssa_edge_in_rhs (outer_loop, loop_phi_node, ev, halting_phi,\n-\t\t\t\t evolution_of_loop);\n+\t\t\t\t evolution_of_loop, limit);\n }\n \n /* Follow an SSA edge from a loop-phi-node to itself, constructing a\n    path that is analyzed on the return walk.  */\n \n-static bool\n-follow_ssa_edge (struct loop *loop, \n-\t\t tree def, \n-\t\t tree halting_phi,\n-\t\t tree *evolution_of_loop)\n+static t_bool\n+follow_ssa_edge (struct loop *loop, tree def, tree halting_phi,\n+\t\t tree *evolution_of_loop, int limit)\n {\n   struct loop *def_loop;\n   \n   if (TREE_CODE (def) == NOP_EXPR)\n-    return false;\n+    return t_false;\n+  \n+  /* Give up if the path is longer than the MAX that we allow.  */\n+  if (limit++ > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n+    return t_dont_know;\n   \n   def_loop = loop_containing_stmt (def);\n   \n@@ -1416,39 +1441,39 @@ follow_ssa_edge (struct loop *loop,\n \t   information and set the approximation to the main\n \t   variable.  */\n \treturn follow_ssa_edge_in_condition_phi \n-\t  (loop, def, halting_phi, evolution_of_loop);\n+\t  (loop, def, halting_phi, evolution_of_loop, limit);\n \n       /* When the analyzed phi is the halting_phi, the\n \t depth-first search is over: we have found a path from\n \t the halting_phi to itself in the loop.  */\n       if (def == halting_phi)\n-\treturn true;\n+\treturn t_true;\n \t  \n       /* Otherwise, the evolution of the HALTING_PHI depends\n \t on the evolution of another loop-phi-node, i.e. the\n \t evolution function is a higher degree polynomial.  */\n       if (def_loop == loop)\n-\treturn false;\n+\treturn t_false;\n \t  \n       /* Inner loop.  */\n       if (flow_loop_nested_p (loop, def_loop))\n \treturn follow_ssa_edge_inner_loop_phi \n-\t  (loop, def, halting_phi, evolution_of_loop);\n+\t  (loop, def, halting_phi, evolution_of_loop, limit);\n \n       /* Outer loop.  */\n-      return false;\n+      return t_false;\n \n     case MODIFY_EXPR:\n       return follow_ssa_edge_in_rhs (loop, def,\n \t\t\t\t     TREE_OPERAND (def, 1), \n \t\t\t\t     halting_phi, \n-\t\t\t\t     evolution_of_loop);\n+\t\t\t\t     evolution_of_loop, limit);\n       \n     default:\n       /* At this level of abstraction, the program is just a set\n \t of MODIFY_EXPRs and PHI_NODEs.  In principle there is no\n \t other node to be handled.  */\n-      return false;\n+      return t_false;\n     }\n }\n \n@@ -1491,7 +1516,7 @@ analyze_evolution_in_loop (tree loop_phi_node,\n \n \t  /* Pass in the initial condition to the follow edge function.  */\n \t  ev_fn = init_cond;\n-\t  res = follow_ssa_edge (loop, ssa_chain, loop_phi_node, &ev_fn);\n+\t  res = follow_ssa_edge (loop, ssa_chain, loop_phi_node, &ev_fn, 0);\n \t}\n       else\n \tres = false;"}]}