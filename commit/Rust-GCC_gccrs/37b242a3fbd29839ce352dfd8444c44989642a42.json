{"sha": "37b242a3fbd29839ce352dfd8444c44989642a42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiMjQyYTNmYmQyOTgzOWNlMzUyZGZkODQ0NGM0NDk4OTY0MmE0Mg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-10T21:05:44Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-11T14:44:26Z"}, "message": "c++: name lookup API for modules\n\nThis adds a set of calls to name lookup that are needed by modules.\nGenerally installing imported bindings, or walking the current TU's\nbindings.  One note about template instantiations though.  When we're\nabout to instantiate a template we have to know about all the\nmaybe-partial specializations that exist.  These can be in any\nimported module -- not necesarily the module defining the template.\nThus we key such foreign templates to the innermost namespace and\nidentifier of the containing entitity -- that's the only thing we have\na handle on.  That's why we note and load pending specializations here.\n\n\tgcc/cp/\n\t* module.cc (lazy_specializations_p): Stub.\n\t* name-lookup.h (append_imported_binding_slot)\n\t(mergeable_namespacE_slots, lookup_class_binding)\n\t(walk_module_binding, import_module_binding, set_module_binding)\n\t(note_pending_specializations, load_pending_specializations)\n\t(add_module_decl, add_imported_namespace): Declare.\n\t(get_cxx_dialect_name): Declare.\n\t(enum WMB_flags): New.\n\t* name-lookup.c (append_imported_binding_slot)\n\t(mergeable_namespacE_slots, lookup_class_binding)\n\t(walk_module_binding, import_module_binding, set_module_binding)\n\t(note_pending_specializations, load_pending_specializations)\n\t(add_module_decl, add_imported_namespace): New.\n\t(get_cxx_dialect_name): Make extern.", "tree": {"sha": "d8acaa8e1d03759a1906997123e728720c9ba309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8acaa8e1d03759a1906997123e728720c9ba309"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37b242a3fbd29839ce352dfd8444c44989642a42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b242a3fbd29839ce352dfd8444c44989642a42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b242a3fbd29839ce352dfd8444c44989642a42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b242a3fbd29839ce352dfd8444c44989642a42/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "958d42abdf1a1936d290aab126cebd6bb4a52361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/958d42abdf1a1936d290aab126cebd6bb4a52361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/958d42abdf1a1936d290aab126cebd6bb4a52361"}], "stats": {"total": 444, "additions": 443, "deletions": 1}, "files": [{"sha": "11eb6dabb04188dfb8d61ee1f7fa02cf0300de5a", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b242a3fbd29839ce352dfd8444c44989642a42/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b242a3fbd29839ce352dfd8444c44989642a42/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=37b242a3fbd29839ce352dfd8444c44989642a42", "patch": "@@ -156,6 +156,12 @@ lazy_load_members (tree)\n {\n }\n \n+bool\n+lazy_specializations_p (unsigned, bool, bool)\n+{\n+  return false;\n+}\n+\n bitmap\n visible_instantiation_path (bitmap *)\n {"}, {"sha": "03d2bc5984b164e874cf80c28f10272dd8d377a2", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 410, "deletions": 1, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b242a3fbd29839ce352dfd8444c44989642a42/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b242a3fbd29839ce352dfd8444c44989642a42/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=37b242a3fbd29839ce352dfd8444c44989642a42", "patch": "@@ -324,6 +324,55 @@ get_fixed_binding_slot (tree *slot, tree name, unsigned ix, int create)\n   return reinterpret_cast<tree *> (&cluster.slots[off]);\n }\n \n+/* *SLOT is a namespace binding slot.  Append a slot for imported\n+   module IX.  */\n+\n+static binding_slot *\n+append_imported_binding_slot (tree *slot, tree name, unsigned ix)\n+{\n+  gcc_checking_assert (ix);\n+\n+  if (!*slot ||  TREE_CODE (*slot) != BINDING_VECTOR)\n+    /* Make an initial module vector.  */\n+    get_fixed_binding_slot (slot, name, BINDING_SLOT_GLOBAL, -1);\n+  else if (!BINDING_VECTOR_CLUSTER_LAST (*slot)\n+\t   ->indices[BINDING_VECTOR_SLOTS_PER_CLUSTER - 1].span)\n+    /* There is space in the last cluster.  */;\n+  else if (BINDING_VECTOR_NUM_CLUSTERS (*slot)\n+\t   != BINDING_VECTOR_ALLOC_CLUSTERS (*slot))\n+    /* There is space in the vector.  */\n+    BINDING_VECTOR_NUM_CLUSTERS (*slot)++;\n+  else\n+    {\n+      /* Extend the vector.  */\n+      unsigned have = BINDING_VECTOR_NUM_CLUSTERS (*slot);\n+      unsigned want = (have * 3 + 1) / 2;\n+\n+      if (want > (unsigned short)~0)\n+\twant = (unsigned short)~0;\n+\n+      tree new_vec = make_binding_vec (name, want);\n+      BINDING_VECTOR_NUM_CLUSTERS (new_vec) = have + 1;\n+      memcpy (BINDING_VECTOR_CLUSTER_BASE (new_vec),\n+\t      BINDING_VECTOR_CLUSTER_BASE (*slot),\n+\t      have * sizeof (binding_cluster));\n+      *slot = new_vec;\n+    }\n+\n+  binding_cluster *last = BINDING_VECTOR_CLUSTER_LAST (*slot);\n+  for (unsigned off = 0; off != BINDING_VECTOR_SLOTS_PER_CLUSTER; off++)\n+    if (!last->indices[off].span)\n+      {\n+\t/* Fill the free slot of the cluster.  */\n+\tlast->indices[off].base = ix;\n+\tlast->indices[off].span = 1;\n+\tlast->slots[off] = NULL_TREE;\n+\treturn &last->slots[off];\n+      }\n+\n+  gcc_unreachable ();\n+}\n+\n /* Add DECL to the list of things declared in binding level B.  */\n \n static void\n@@ -3835,6 +3884,23 @@ pushdecl (tree x, bool hiding)\n   return ret;\n }\n \n+/* A mergeable entity is being loaded into namespace NS slot NAME.\n+   Create and return the appropriate vector slot for that.  Either a\n+   GMF slot or a module-specific one.  */\n+\n+tree *\n+mergeable_namespace_slots (tree ns, tree name, bool is_global, tree *vec)\n+{\n+  tree *mslot = find_namespace_slot (ns, name, true);\n+  tree *vslot = get_fixed_binding_slot\n+    (mslot, name, is_global ? BINDING_SLOT_GLOBAL : BINDING_SLOT_PARTITION, true);\n+\n+  gcc_checking_assert (TREE_CODE (*mslot) == BINDING_VECTOR);\n+  *vec = *mslot;\n+\n+  return vslot;\n+}\n+\n /* DECL is a new mergeable namespace-scope decl.  Add it to the\n    mergeable entities on GSLOT.  */\n \n@@ -3844,6 +3910,286 @@ add_mergeable_namespace_entity (tree *gslot, tree decl)\n   *gslot = ovl_make (decl, *gslot);\n }\n \n+/* A mergeable entity of KLASS called NAME is being loaded.  Return\n+   the set of things it could be.  All such non-as_base classes have\n+   been given a member vec.  */\n+\n+tree\n+lookup_class_binding (tree klass, tree name)\n+{\n+  tree found = NULL_TREE;\n+\n+  if (!COMPLETE_TYPE_P (klass))\n+    ;\n+  else if (TYPE_LANG_SPECIFIC (klass))\n+    {\n+      vec<tree, va_gc> *member_vec = CLASSTYPE_MEMBER_VEC (klass);\n+\n+      found = member_vec_binary_search (member_vec, name);\n+      if (IDENTIFIER_CONV_OP_P (name))\n+\t{\n+\t  gcc_checking_assert (name == conv_op_identifier);\n+\t  if (found)\n+\t    found = OVL_CHAIN (found);\n+\t}\n+    }\n+  else\n+    {\n+      gcc_checking_assert (IS_FAKE_BASE_TYPE (klass)\n+\t\t\t   || TYPE_PTRMEMFUNC_P (klass));\n+      found = fields_linear_search (klass, name, false);\n+    }\n+\n+  return found;\n+}\n+\n+/* Given a namespace-level binding BINDING, walk it, calling CALLBACK\n+   for all decls of the current module.  When partitions are involved,\n+   decls might be mentioned more than once.   */\n+\n+unsigned\n+walk_module_binding (tree binding, bitmap partitions,\n+\t\t     bool (*callback) (tree decl, WMB_Flags, void *data),\n+\t\t     void *data)\n+{\n+  // FIXME: We don't quite deal with using decls naming stat hack\n+  // type.  Also using decls exporting something from the same scope.\n+  tree current = binding;\n+  unsigned count = 0;\n+\n+  if (TREE_CODE (binding) == BINDING_VECTOR)\n+    current = BINDING_VECTOR_CLUSTER (binding, 0).slots[BINDING_SLOT_CURRENT];\n+\n+  bool decl_hidden = false;\n+  if (tree type = MAYBE_STAT_TYPE (current))\n+    {\n+      WMB_Flags flags = WMB_None;\n+      if (STAT_TYPE_HIDDEN_P (current))\n+\tflags = WMB_Flags (flags | WMB_Hidden);\n+      count += callback (type, flags, data);\n+      decl_hidden = STAT_DECL_HIDDEN_P (current);\n+    }\n+\n+  for (ovl_iterator iter (MAYBE_STAT_DECL (current)); iter; ++iter)\n+    {\n+      if (iter.hidden_p ())\n+\tdecl_hidden = true;\n+      if (!(decl_hidden && DECL_IS_UNDECLARED_BUILTIN (*iter)))\n+\t{\n+\t  WMB_Flags flags = WMB_None;\n+\t  if (decl_hidden)\n+\t    flags = WMB_Flags (flags | WMB_Hidden);\n+\t  if (iter.using_p ())\n+\t    {\n+\t      flags = WMB_Flags (flags | WMB_Using);\n+\t      if (iter.exporting_p ())\n+\t\tflags = WMB_Flags (flags | WMB_Export);\n+\t    }\n+\t  count += callback (*iter, flags, data);\n+\t}\n+      decl_hidden = false;\n+    }\n+\n+  if (partitions && TREE_CODE (binding) == BINDING_VECTOR)\n+    {\n+      /* Process partition slots.  */\n+      binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (binding);\n+      unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (binding);\n+      if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+\t{\n+\t  ix--;\n+\t  cluster++;\n+\t}\n+\n+      bool maybe_dups = BINDING_VECTOR_PARTITION_DUPS_P (binding);\n+\n+      for (; ix--; cluster++)\n+\tfor (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n+\t  if (!cluster->slots[jx].is_lazy ())\n+\t    if (tree bind = cluster->slots[jx])\n+\t      {\n+\t\tif (TREE_CODE (bind) == NAMESPACE_DECL\n+\t\t    && !DECL_NAMESPACE_ALIAS (bind))\n+\t\t  {\n+\t\t    if (unsigned base = cluster->indices[jx].base)\n+\t\t      if (unsigned span = cluster->indices[jx].span)\n+\t\t\tdo\n+\t\t\t  if (bitmap_bit_p (partitions, base))\n+\t\t\t    goto found;\n+\t\t\twhile (++base, --span);\n+\t\t    /* Not a partition's namespace.  */\n+\t\t    continue;\n+\t\t  found:\n+\n+\t\t    WMB_Flags flags = WMB_None;\n+\t\t    if (maybe_dups)\n+\t\t      flags = WMB_Flags (flags | WMB_Dups);\n+\t\t    count += callback (bind, flags, data);\n+\t\t  }\n+\t\telse if (STAT_HACK_P (bind) && MODULE_BINDING_PARTITION_P (bind))\n+\t\t  {\n+\t\t    if (tree btype = STAT_TYPE (bind))\n+\t\t      {\n+\t\t\tWMB_Flags flags = WMB_None;\n+\t\t\tif (maybe_dups)\n+\t\t\t  flags = WMB_Flags (flags | WMB_Dups);\n+\t\t\tif (STAT_TYPE_HIDDEN_P (bind))\n+\t\t\t  flags = WMB_Flags (flags | WMB_Hidden);\n+\n+\t\t\tcount += callback (btype, flags, data);\n+\t\t      }\n+\t\t    bool hidden = STAT_DECL_HIDDEN_P (bind);\n+\t\t    for (ovl_iterator iter (MAYBE_STAT_DECL (STAT_DECL (bind)));\n+\t\t\t iter; ++iter)\n+\t\t      {\n+\t\t\tif (iter.hidden_p ())\n+\t\t\t  hidden = true;\n+\t\t\tgcc_checking_assert\n+\t\t\t  (!(hidden && DECL_IS_UNDECLARED_BUILTIN (*iter)));\n+\n+\t\t\tWMB_Flags flags = WMB_None;\n+\t\t\tif (maybe_dups)\n+\t\t\t  flags = WMB_Flags (flags | WMB_Dups);\n+\t\t\tif (decl_hidden)\n+\t\t\t  flags = WMB_Flags (flags | WMB_Hidden);\n+\t\t\tif (iter.using_p ())\n+\t\t\t  {\n+\t\t\t    flags = WMB_Flags (flags | WMB_Using);\n+\t\t\t    if (iter.exporting_p ())\n+\t\t\t      flags = WMB_Flags (flags | WMB_Export);\n+\t\t\t  }\n+\t\t\tcount += callback (*iter, flags, data);\n+\t\t\thidden = false;\n+\t\t      }\n+\t\t  }\n+\t      }\n+    }\n+\n+  return count;\n+}\n+\n+/* Imported module MOD has a binding to NS::NAME, stored in section\n+   SNUM.  */\n+\n+bool\n+import_module_binding  (tree ns, tree name, unsigned mod, unsigned snum)\n+{\n+  tree *slot = find_namespace_slot (ns, name, true);\n+  binding_slot *mslot = append_imported_binding_slot (slot, name, mod);\n+\n+  if (mslot->is_lazy () || *mslot)\n+    /* Oops, something was already there.  */\n+    return false;\n+\n+  mslot->set_lazy (snum);\n+  return true;\n+}\n+\n+/* An import of MODULE is binding NS::NAME.  There should be no\n+   existing binding for >= MODULE.  MOD_GLOB indicates whether MODULE\n+   is a header_unit (-1) or part of the current module (+1).  VALUE\n+   and TYPE are the value and type bindings. VISIBLE are the value\n+   bindings being exported.  */\n+\n+bool\n+set_module_binding (tree ns, tree name, unsigned mod, int mod_glob,\n+\t\t    tree value, tree type, tree visible)\n+{\n+  if (!value)\n+    /* Bogus BMIs could give rise to nothing to bind.  */\n+    return false;\n+\n+  gcc_assert (TREE_CODE (value) != NAMESPACE_DECL\n+\t      || DECL_NAMESPACE_ALIAS (value));\n+  gcc_checking_assert (mod);\n+\n+  tree *slot = find_namespace_slot (ns, name, true);\n+  binding_slot *mslot = search_imported_binding_slot (slot, mod);\n+\n+  if (!mslot || !mslot->is_lazy ())\n+    /* Again, bogus BMI could give find to missing or already loaded slot.  */\n+    return false;\n+\n+  tree bind = value;\n+  if (type || visible != bind || mod_glob)\n+    {\n+      bind = stat_hack (bind, type);\n+      STAT_VISIBLE (bind) = visible;\n+      if ((mod_glob > 0 && TREE_PUBLIC (ns))\n+\t  || (type && DECL_MODULE_EXPORT_P (type)))\n+\tSTAT_TYPE_VISIBLE_P (bind) = true;\n+    }\n+\n+  /* Note if this is this-module or global binding.  */\n+  if (mod_glob > 0)\n+    MODULE_BINDING_PARTITION_P (bind) = true;\n+  else if (mod_glob < 0)\n+    MODULE_BINDING_GLOBAL_P (bind) = true;\n+\n+  *mslot = bind;\n+\n+  return true;\n+}\n+\n+void\n+note_pending_specializations (tree ns, tree name, bool is_header)\n+{\n+  if (tree *slot = find_namespace_slot (ns, name, false))\n+    if (TREE_CODE (*slot) == BINDING_VECTOR)\n+      {\n+\ttree vec = *slot;\n+\tBINDING_VECTOR_PENDING_SPECIALIZATIONS_P (vec) = true;\n+\tif (is_header)\n+\t  BINDING_VECTOR_PENDING_IS_HEADER_P (vec) = true;\n+\telse\n+\t  BINDING_VECTOR_PENDING_IS_PARTITION_P (vec) = true;\n+      }\n+}\n+\n+void\n+load_pending_specializations (tree ns, tree name)\n+{\n+  tree *slot = find_namespace_slot (ns, name, false);\n+\n+  if (!slot || TREE_CODE (*slot) != BINDING_VECTOR\n+      || !BINDING_VECTOR_PENDING_SPECIALIZATIONS_P (*slot))\n+    return;\n+\n+  tree vec = *slot;\n+  BINDING_VECTOR_PENDING_SPECIALIZATIONS_P (vec) = false;\n+\n+  bool do_header = BINDING_VECTOR_PENDING_IS_HEADER_P (vec);\n+  bool do_partition = BINDING_VECTOR_PENDING_IS_PARTITION_P (vec);\n+  BINDING_VECTOR_PENDING_IS_HEADER_P (vec) = false;\n+  BINDING_VECTOR_PENDING_IS_PARTITION_P (vec) = false;\n+\n+  gcc_checking_assert (do_header | do_partition);\n+  binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (vec);\n+  unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (vec);\n+  if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n+    {\n+      ix--;\n+      cluster++;\n+    }\n+\n+  for (; ix--; cluster++)\n+    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n+      if (cluster->indices[jx].span\n+\t  && cluster->slots[jx].is_lazy ()\n+\t  && lazy_specializations_p (cluster->indices[jx].base,\n+\t\t\t\t     do_header, do_partition))\n+\tlazy_load_binding (cluster->indices[jx].base, ns, name,\n+\t\t\t   &cluster->slots[jx]);\n+}\n+\n+void\n+add_module_decl (tree ns, tree name, tree decl)\n+{\n+  gcc_assert (!DECL_CHAIN (decl));\n+  add_decl_to_level (NAMESPACE_LEVEL (ns), decl);\n+  newbinding_bookkeeping (name, decl, NAMESPACE_LEVEL (ns));\n+}\n+\n /* Enter DECL into the symbol table, if that's appropriate.  Returns\n    DECL, or a modified version thereof.  */\n \n@@ -6714,7 +7060,7 @@ get_std_name_hint (const char *name)\n \n /* Describe DIALECT.  */\n \n-static const char *\n+const char *\n get_cxx_dialect_name (enum cxx_dialect dialect)\n {\n   switch (dialect)\n@@ -8662,6 +9008,69 @@ pop_namespace (void)\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n+/* An import is defining namespace NAME inside CTX.  Find or create\n+   that namespace and add it to the container's binding-vector.  */\n+\n+tree\n+add_imported_namespace (tree ctx, tree name, unsigned origin, location_t loc,\n+\t\t\tbool visible_p, bool inline_p)\n+{\n+  // FIXME: Something is not correct about the VISIBLE_P handling.  We\n+  // need to insert this namespace into\n+  // (a) the GLOBAL or PARTITION slot, if it is TREE_PUBLIC\n+  // (b) The importing module's slot (always)\n+  // (c) Do we need to put it in the CURRENT slot?  This is the\n+  // confused piece.\n+\n+  gcc_checking_assert (origin);\n+  tree *slot = find_namespace_slot (ctx, name, true);\n+  tree decl = reuse_namespace (slot, ctx, name);\n+  if (!decl)\n+    {\n+      decl = make_namespace (ctx, name, loc, inline_p);\n+      DECL_MODULE_IMPORT_P (decl) = true;\n+      make_namespace_finish (decl, slot, true);\n+    }\n+  else if (DECL_NAMESPACE_INLINE_P (decl) != inline_p)\n+    {\n+      error_at (loc, \"%s namespace %qD conflicts with reachable definition\",\n+\t\tinline_p ? \"inline\" : \"non-inline\", decl);\n+      inform (DECL_SOURCE_LOCATION (decl), \"reachable %s definition here\",\n+\t      inline_p ? \"non-inline\" : \"inline\");\n+    }\n+\n+  if (TREE_PUBLIC (decl) && TREE_CODE (*slot) == BINDING_VECTOR)\n+    {\n+      /* See if we can extend the final slot.  */\n+      binding_cluster *last = BINDING_VECTOR_CLUSTER_LAST (*slot);\n+      gcc_checking_assert (last->indices[0].span);\n+      unsigned jx = BINDING_VECTOR_SLOTS_PER_CLUSTER;\n+\n+      while (--jx)\n+\tif (last->indices[jx].span)\n+\t  break;\n+      tree final = last->slots[jx];\n+      if (visible_p == !STAT_HACK_P (final)\n+\t  && MAYBE_STAT_DECL (final) == decl\n+\t  && last->indices[jx].base + last->indices[jx].span == origin\n+\t  && (BINDING_VECTOR_NUM_CLUSTERS (*slot) > 1\n+\t      || (BINDING_VECTOR_SLOTS_PER_CLUSTER > BINDING_SLOTS_FIXED\n+\t\t  && jx >= BINDING_SLOTS_FIXED)))\n+\t{\n+\t  last->indices[jx].span++;\n+\t  return decl;\n+\t}\n+    }\n+\n+  /* Append a new slot.  */\n+  tree *mslot = &(tree &)*append_imported_binding_slot (slot, name, origin);\n+\n+  gcc_assert (!*mslot);\n+  *mslot = visible_p ? decl : stat_hack (decl, NULL_TREE);\n+\n+  return decl;\n+}\n+\n /* External entry points for do_{push_to/pop_from}_top_level.  */\n \n void"}, {"sha": "66fc351b2bc597f3bd1f650ddc910539d2e88d10", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b242a3fbd29839ce352dfd8444c44989642a42/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b242a3fbd29839ce352dfd8444c44989642a42/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=37b242a3fbd29839ce352dfd8444c44989642a42", "patch": "@@ -481,6 +481,33 @@ extern void push_operator_bindings (void);\n extern void discard_operator_bindings (tree);\n \n /* Lower level interface for modules. */\n+extern tree *mergeable_namespace_slots (tree ns, tree name, bool is_global,\n+\t\t\t\t\ttree *mvec);\n extern void add_mergeable_namespace_entity (tree *slot, tree decl);\n+extern tree lookup_class_binding (tree ctx, tree name);\n+extern bool import_module_binding (tree ctx, tree name, unsigned mod,\n+\t\t\t\t   unsigned snum);\n+extern bool set_module_binding (tree ctx, tree name, unsigned mod,\n+\t\t\t\tint mod_glob_flag,\n+\t\t\t\ttree value, tree type, tree visible);\n+extern void add_module_decl (tree ctx, tree name, tree decl);\n+\n+enum WMB_Flags\n+{\n+  WMB_None = 0,\n+  WMB_Dups = 1 << 0,\n+  WMB_Export = 1 << 1,\n+  WMB_Using = 1 << 2,\n+  WMB_Hidden = 1 << 3,\n+};\n+\n+extern unsigned walk_module_binding (tree binding, bitmap partitions,\n+\t\t\t\t     bool (*)(tree decl, WMB_Flags, void *data),\n+\t\t\t\t     void *data);\n+extern tree add_imported_namespace (tree ctx, tree name, unsigned module,\n+\t\t\t\t    location_t, bool visible_p, bool inline_p);\n+extern void note_pending_specializations (tree ns, tree name, bool is_header);\n+extern void load_pending_specializations (tree ns, tree name);\n+extern const char *get_cxx_dialect_name (enum cxx_dialect dialect);\n \n #endif /* GCC_CP_NAME_LOOKUP_H */"}]}