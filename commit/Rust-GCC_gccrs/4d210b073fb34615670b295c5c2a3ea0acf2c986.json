{"sha": "4d210b073fb34615670b295c5c2a3ea0acf2c986", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQyMTBiMDczZmIzNDYxNTY3MGIyOTVjNWMyYTNlYTBhY2YyYzk4Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-09-06T08:13:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-09-06T08:13:09Z"}, "message": "2008-xx-xx Richard Sandiford <rdsandiford@goolemail.com> Peter Fuerst <post@pfrst.de>\n\ngcc/\n2008-xx-xx  Richard Sandiford  <rdsandiford@goolemail.com>\n\t    Peter Fuerst  <post@pfrst.de>\n\n\t* doc/invoke.texi: Document -mr10k-cache-barrier=.\n\t* doc/extend.texi: Document __builtin_mips_cache.\n\t* config/mips/mips-ftypes.def: Add a (VOID, SI, CVPOINTER) entry.\n\t* config/mips/mips.opt (mr10k-cache-barrier=): New option.\n\t* config/mips/mips.h (TARGET_CPU_CPP_BUILTINS): Define\n\t__GCC_HAVE_BUILTIN_MIPS_CACHE.\n\t(TARGET_CACHE_BUILTIN, ISA_HAS_CACHE): New macros.\n\t* config/mips/mips.c (mips_r10k_cache_barrier_setting): New enum.\n\t(set_push_mips_isas): New variable.\n\t(mips_r10k_cache_barrier): New variable.\n\t(cache): New availability predicate.\n\t(mips_builtins): Add an entry for __builtin_mips_cache.\n\t(mips_build_cvpointer_type): New function.\n\t(MIPS_ATYPE_CVPOINTER): New macro.\n\t(mips_prepare_builtin_arg): Only use the insn's mode if the rtx's\n\tmode is VOIDmode.\n\t(r10k_simplified_address_p, r10k_simplify_address)\n\t(r10k_uncached_address_p, r10k_safe_address_p)\n\t(r10k_needs_protection_p_1, r10k_needs_protection_p_store)\n\t(r10k_needs_protection_p_call, r10k_needs_protection_p)\n\t(r10k_insert_cache_barriers): New functions.\n\t(mips_reorg_process_insns): Delete cache barriers after a\n\tbranch-likely instruction.\n\t(mips_reorg): Call r10k_insert_cache_barriers.\n\t(mips_handle_option): Handle OPT_mr10k_cache_barrier_.\n\t* config/mips/mips.md (UNSPEC_MIPS_CACHE): New constant.\n\t(UNSPEC_R10K_CACHE_BARRIER): Likewise.\n\t(mips_cache, r10k_cache_barrier): New define_insns.\n\ngcc/testsuite/\n\t* gcc.target/mips/mips.exp (dg-mips-options): Make\n\t-mr10k-cache-barrier=* imply -mips3 or above.\n\t* gcc.target/mips/cache-1.c: New test.\n\t* gcc.target/mips/r10k-cache-barrier-1.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-2.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-3.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-4.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-5.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-6.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-7.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-8.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-9.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-10.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-11.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-12.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-13.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-14.c: Likewise.\n\t* gcc.target/mips/r10k-cache-barrier-15.c: Likewise.\n\nFrom-SVN: r140055", "tree": {"sha": "69d3ad291660fd69dde909d9ee0d72a37de78ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69d3ad291660fd69dde909d9ee0d72a37de78ec4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d210b073fb34615670b295c5c2a3ea0acf2c986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d210b073fb34615670b295c5c2a3ea0acf2c986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d210b073fb34615670b295c5c2a3ea0acf2c986", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d210b073fb34615670b295c5c2a3ea0acf2c986/comments", "author": null, "committer": null, "parents": [{"sha": "4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f341ea0680f6477f8f4f4b8b3ef4232cbf9ae46"}], "stats": {"total": 930, "additions": 928, "deletions": 2}, "files": [{"sha": "280b57170a45f0c66df184081c8df56f71045126", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -1,3 +1,35 @@\n+2008-09-06  Richard Sandiford  <rdsandiford@goolemail.com>\n+\t    Peter Fuerst  <post@pfrst.de>\n+\n+\t* doc/invoke.texi: Document -mr10k-cache-barrier=.\n+\t* doc/extend.texi: Document __builtin_mips_cache.\n+\t* config/mips/mips-ftypes.def: Add a (VOID, SI, CVPOINTER) entry.\n+\t* config/mips/mips.opt (mr10k-cache-barrier=): New option.\n+\t* config/mips/mips.h (TARGET_CPU_CPP_BUILTINS): Define\n+\t__GCC_HAVE_BUILTIN_MIPS_CACHE.\n+\t(TARGET_CACHE_BUILTIN, ISA_HAS_CACHE): New macros.\n+\t* config/mips/mips.c (mips_r10k_cache_barrier_setting): New enum.\n+\t(set_push_mips_isas): New variable.\n+\t(mips_r10k_cache_barrier): New variable.\n+\t(cache): New availability predicate.\n+\t(mips_builtins): Add an entry for __builtin_mips_cache.\n+\t(mips_build_cvpointer_type): New function.\n+\t(MIPS_ATYPE_CVPOINTER): New macro.\n+\t(mips_prepare_builtin_arg): Only use the insn's mode if the rtx's\n+\tmode is VOIDmode.\n+\t(r10k_simplified_address_p, r10k_simplify_address)\n+\t(r10k_uncached_address_p, r10k_safe_address_p)\n+\t(r10k_needs_protection_p_1, r10k_needs_protection_p_store)\n+\t(r10k_needs_protection_p_call, r10k_needs_protection_p)\n+\t(r10k_insert_cache_barriers): New functions.\n+\t(mips_reorg_process_insns): Delete cache barriers after a\n+\tbranch-likely instruction.\n+\t(mips_reorg): Call r10k_insert_cache_barriers.\n+\t(mips_handle_option): Handle OPT_mr10k_cache_barrier_.\n+\t* config/mips/mips.md (UNSPEC_MIPS_CACHE): New constant.\n+\t(UNSPEC_R10K_CACHE_BARRIER): Likewise.\n+\t(mips_cache, r10k_cache_barrier): New define_insns.\n+\n 2008-09-06  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* ira-int.h (ira_zero_hard_reg_set, ira_one_hard_reg_set): Delete."}, {"sha": "df0d9ff2aa3606150b9581ab0f05e5462994f26a", "filename": "gcc/config/mips/mips-ftypes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ftypes.def?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -120,6 +120,7 @@ DEF_MIPS_FTYPE (2, (V8QI, V4HI, V4HI))\n DEF_MIPS_FTYPE (1, (V8QI, V8QI))\n DEF_MIPS_FTYPE (2, (V8QI, V8QI, V8QI))\n \n+DEF_MIPS_FTYPE (2, (VOID, SI, CVPOINTER))\n DEF_MIPS_FTYPE (2, (VOID, SI, SI))\n DEF_MIPS_FTYPE (2, (VOID, V2HI, V2HI))\n DEF_MIPS_FTYPE (2, (VOID, V4QI, V4QI))"}, {"sha": "9187991c763407d7511dc9fdef20c5584d453f39", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 437, "deletions": 2, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -148,6 +148,13 @@ enum mips_address_type {\n   ADDRESS_SYMBOLIC\n };\n \n+/* Enumerates the setting of the -mr10k-cache-barrier option.  */\n+enum mips_r10k_cache_barrier_setting {\n+  R10K_CACHE_BARRIER_NONE,\n+  R10K_CACHE_BARRIER_STORE,\n+  R10K_CACHE_BARRIER_LOAD_STORE\n+};\n+\n /* Macros to create an enumeration identifier for a function prototype.  */\n #define MIPS_FTYPE_NAME1(A, B) MIPS_##A##_FTYPE_##B\n #define MIPS_FTYPE_NAME2(A, B, C) MIPS_##A##_FTYPE_##B##_##C\n@@ -456,6 +463,9 @@ static int mips_base_align_functions; /* align_functions */\n /* The -mcode-readable setting.  */\n enum mips_code_readable_setting mips_code_readable = CODE_READABLE_YES;\n \n+/* The -mr10k-cache-barrier setting.  */\n+static enum mips_r10k_cache_barrier_setting mips_r10k_cache_barrier;\n+\n /* Index [M][R] is true if register R is allowed to hold a value of mode M.  */\n bool mips_hard_regno_mode_ok[(int) MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n \n@@ -10922,6 +10932,7 @@ AVAIL_NON_MIPS16 (dspr2, TARGET_DSPR2)\n AVAIL_NON_MIPS16 (dsp_32, !TARGET_64BIT && TARGET_DSP)\n AVAIL_NON_MIPS16 (dspr2_32, !TARGET_64BIT && TARGET_DSPR2)\n AVAIL_NON_MIPS16 (loongson, TARGET_LOONGSON_VECTORS)\n+AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)\n \n /* Construct a mips_builtin_description from the given arguments.\n \n@@ -11352,7 +11363,10 @@ static const struct mips_builtin_description mips_builtins[] = {\n   LOONGSON_BUILTIN_SUFFIX (punpcklwd, u, MIPS_UV2SI_FTYPE_UV2SI_UV2SI),\n   LOONGSON_BUILTIN_SUFFIX (punpcklbh, s, MIPS_V8QI_FTYPE_V8QI_V8QI),\n   LOONGSON_BUILTIN_SUFFIX (punpcklhw, s, MIPS_V4HI_FTYPE_V4HI_V4HI),\n-  LOONGSON_BUILTIN_SUFFIX (punpcklwd, s, MIPS_V2SI_FTYPE_V2SI_V2SI)\n+  LOONGSON_BUILTIN_SUFFIX (punpcklwd, s, MIPS_V2SI_FTYPE_V2SI_V2SI),\n+\n+  /* Sundry other built-in functions.  */\n+  DIRECT_NO_TARGET_BUILTIN (cache, MIPS_VOID_FTYPE_SI_CVPOINTER, cache)\n };\n \n /* MODE is a vector mode whose elements have type TYPE.  Return the type\n@@ -11374,10 +11388,25 @@ mips_builtin_vector_type (tree type, enum machine_mode mode)\n   return types[mode_index];\n }\n \n+/* Return a type for 'const volatile void *'.  */\n+\n+static tree\n+mips_build_cvpointer_type (void)\n+{\n+  static tree cache;\n+\n+  if (cache == NULL_TREE)\n+    cache = build_pointer_type (build_qualified_type\n+\t\t\t\t(void_type_node,\n+\t\t\t\t TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE));\n+  return cache;\n+}\n+\n /* Source-level argument types.  */\n #define MIPS_ATYPE_VOID void_type_node\n #define MIPS_ATYPE_INT integer_type_node\n #define MIPS_ATYPE_POINTER ptr_type_node\n+#define MIPS_ATYPE_CVPOINTER mips_build_cvpointer_type ()\n \n /* Standard mode-based argument types.  */\n #define MIPS_ATYPE_UQI unsigned_intQI_type_node\n@@ -11477,7 +11506,13 @@ mips_prepare_builtin_arg (enum insn_code icode,\n   mode = insn_data[icode].operand[opno].mode;\n   if (!insn_data[icode].operand[opno].predicate (value, mode))\n     {\n-      value = copy_to_mode_reg (mode, value);\n+      /* Cope with address operands, where MODE is not the mode of\n+\t VALUE itself.  */\n+      if (GET_MODE (value) == VOIDmode)\n+\tvalue = copy_to_mode_reg (mode, value);\n+      else\n+\tvalue = copy_to_reg (value);\n+\n       /* Check the predicate again.  */\n       if (!insn_data[icode].operand[opno].predicate (value, mode))\n \t{\n@@ -12024,6 +12059,378 @@ mips16_lay_out_constants (void)\n   mips16_emit_constants (pool.first, get_last_insn ());\n }\n \f\n+/* Return true if it is worth r10k_simplify_address's while replacing\n+   an address with X.  We are looking for constants, and for addresses\n+   at a known offset from the incoming stack pointer.  */\n+\n+static bool\n+r10k_simplified_address_p (rtx x)\n+{\n+  if (GET_CODE (x) == PLUS && CONST_INT_P (XEXP (x, 1)))\n+    x = XEXP (x, 0);\n+  return x == virtual_incoming_args_rtx || CONSTANT_P (x);\n+}\n+\n+/* X is an expression that appears in INSN.  Try to use the UD chains\n+   to simplify it, returning the simplified form on success and the\n+   original form otherwise.  Replace the incoming value of $sp with\n+   virtual_incoming_args_rtx (which should never occur in X otherwise).  */\n+\n+static rtx\n+r10k_simplify_address (rtx x, rtx insn)\n+{\n+  rtx newx, op0, op1, set, def_insn, note;\n+  struct df_ref *use, *def;\n+  struct df_link *defs;\n+\n+  newx = NULL_RTX;\n+  if (UNARY_P (x))\n+    {\n+      op0 = r10k_simplify_address (XEXP (x, 0), insn);\n+      if (op0 != XEXP (x, 0))\n+\tnewx = simplify_gen_unary (GET_CODE (x), GET_MODE (x),\n+\t\t\t\t   op0, GET_MODE (XEXP (x, 0)));\n+    }\n+  else if (BINARY_P (x))\n+    {\n+      op0 = r10k_simplify_address (XEXP (x, 0), insn);\n+      op1 = r10k_simplify_address (XEXP (x, 1), insn);\n+      if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n+\tnewx = simplify_gen_binary (GET_CODE (x), GET_MODE (x), op0, op1);\n+    }\n+  else if (GET_CODE (x) == LO_SUM)\n+    {\n+      /* LO_SUMs can be offset from HIGHs, if we know they won't\n+\t overflow.  See mips_classify_address for the rationale behind\n+\t the lax check.  */\n+      op0 = r10k_simplify_address (XEXP (x, 0), insn);\n+      if (GET_CODE (op0) == HIGH)\n+\tnewx = XEXP (x, 1);\n+    }\n+  else if (REG_P (x))\n+    {\n+      /* Uses are recorded by regno_reg_rtx, not X itself.  */\n+      use = df_find_use (insn, regno_reg_rtx[REGNO (x)]);\n+      gcc_assert (use);\n+      defs = DF_REF_CHAIN (use);\n+\n+      /* Require a single definition.  */\n+      if (defs && defs->next == NULL)\n+\t{\n+\t  def = defs->ref;\n+\t  if (DF_REF_IS_ARTIFICIAL (def))\n+\t    {\n+\t      /* Replace the incoming value of $sp with\n+\t\t virtual_incoming_args_rtx.  */\n+\t      if (x == stack_pointer_rtx\n+\t\t  && DF_REF_BB (def) == ENTRY_BLOCK_PTR)\n+\t\tnewx = virtual_incoming_args_rtx;\n+\t    }\n+\t  else if (dominated_by_p (CDI_DOMINATORS, DF_REF_BB (use),\n+\t\t\t\t   DF_REF_BB (def)))\n+\t    {\n+\t      /* Make sure that DEF_INSN is a single set of REG.  */\n+\t      def_insn = DF_REF_INSN (def);\n+\t      if (NONJUMP_INSN_P (def_insn))\n+\t\t{\n+\t\t  set = single_set (def_insn);\n+\t\t  if (set && rtx_equal_p (SET_DEST (set), x))\n+\t\t    {\n+\t\t      /* Prefer to use notes, since the def-use chains\n+\t\t\t are often shorter.  */\n+\t\t      note = find_reg_equal_equiv_note (def_insn);\n+\t\t      if (note)\n+\t\t\tnewx = XEXP (note, 0);\n+\t\t      else\n+\t\t\tnewx = SET_SRC (set);\n+\t\t      newx = r10k_simplify_address (newx, def_insn);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (newx && r10k_simplified_address_p (newx))\n+    return newx;\n+  return x;\n+}\n+\n+/* Return true if ADDRESS is known to be an uncached address\n+   on R10K systems.  */\n+\n+static bool\n+r10k_uncached_address_p (unsigned HOST_WIDE_INT address)\n+{\n+  unsigned HOST_WIDE_INT upper;\n+\n+  /* Check for KSEG1.  */\n+  if (address + 0x60000000 < 0x20000000)\n+    return true;\n+\n+  /* Check for uncached XKPHYS addresses.  */\n+  if (Pmode == DImode)\n+    {\n+      upper = (address >> 40) & 0xf9ffff;\n+      if (upper == 0x900000 || upper == 0xb80000)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if we can prove that an access to address X in instruction\n+   INSN would be safe from R10K speculation.  This X is a general\n+   expression; it might not be a legitimate address.  */\n+\n+static bool\n+r10k_safe_address_p (rtx x, rtx insn)\n+{\n+  rtx base, offset;\n+  HOST_WIDE_INT offset_val;\n+\n+  x = r10k_simplify_address (x, insn);\n+\n+  /* Check for references to the stack frame.  It doesn't really matter\n+     how much of the frame has been allocated at INSN; -mr10k-cache-barrier\n+     allows us to assume that accesses to any part of the eventual frame\n+     is safe from speculation at any point in the function.  */\n+  mips_split_plus (x, &base, &offset_val);\n+  if (base == virtual_incoming_args_rtx\n+      && offset_val >= -cfun->machine->frame.total_size\n+      && offset_val < cfun->machine->frame.args_size)\n+    return true;\n+\n+  /* Check for uncached addresses.  */\n+  if (CONST_INT_P (x))\n+    return r10k_uncached_address_p (INTVAL (x));\n+\n+  /* Check for accesses to a static object.  */\n+  split_const (x, &base, &offset);\n+  return offset_within_block_p (base, INTVAL (offset));\n+}\n+\n+/* Return true if a MEM with MEM_EXPR EXPR and MEM_OFFSET OFFSET is\n+   an in-range access to an automatic variable, or to an object with\n+   a link-time-constant address.  */\n+\n+static bool\n+r10k_safe_mem_expr_p (tree expr, rtx offset)\n+{\n+  if (expr == NULL_TREE\n+      || offset == NULL_RTX\n+      || !CONST_INT_P (offset)\n+      || INTVAL (offset) < 0\n+      || INTVAL (offset) >= int_size_in_bytes (TREE_TYPE (expr)))\n+    return false;\n+\n+  while (TREE_CODE (expr) == COMPONENT_REF)\n+    {\n+      expr = TREE_OPERAND (expr, 0);\n+      if (expr == NULL_TREE)\n+\treturn false;\n+    }\n+\n+  return DECL_P (expr);\n+}\n+\n+/* A for_each_rtx callback for which DATA points to the instruction\n+   containing *X.  Stop the search if we find a MEM that is not safe\n+   from R10K speculation.  */\n+\n+static int\n+r10k_needs_protection_p_1 (rtx *loc, void *data)\n+{\n+  rtx mem;\n+\n+  mem = *loc;\n+  if (!MEM_P (mem))\n+    return 0;\n+\n+  if (r10k_safe_mem_expr_p (MEM_EXPR (mem), MEM_OFFSET (mem)))\n+    return -1;\n+\n+  if (r10k_safe_address_p (XEXP (mem, 0), (rtx) data))\n+    return -1;\n+\n+  return 1;\n+}\n+\n+/* A note_stores callback for which DATA points to an instruction pointer.\n+   If *DATA is nonnull, make it null if it X contains a MEM that is not\n+   safe from R10K speculation.  */\n+\n+static void\n+r10k_needs_protection_p_store (rtx x, const_rtx pat ATTRIBUTE_UNUSED,\n+\t\t\t       void *data)\n+{\n+  rtx *insn_ptr;\n+\n+  insn_ptr = (rtx *) data;\n+  if (*insn_ptr && for_each_rtx (&x, r10k_needs_protection_p_1, *insn_ptr))\n+    *insn_ptr = NULL_RTX;\n+}\n+\n+/* A for_each_rtx callback that iterates over the pattern of a CALL_INSN.\n+   Return nonzero if the call is not to a declared function.  */\n+\n+static int\n+r10k_needs_protection_p_call (rtx *loc, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x;\n+\n+  x = *loc;\n+  if (!MEM_P (x))\n+    return 0;\n+\n+  x = XEXP (x, 0);\n+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_DECL (x))\n+    return -1;\n+\n+  return 1;\n+}\n+\n+/* Return true if instruction INSN needs to be protected by an R10K\n+   cache barrier.  */\n+\n+static bool\n+r10k_needs_protection_p (rtx insn)\n+{\n+  if (CALL_P (insn))\n+    return for_each_rtx (&PATTERN (insn), r10k_needs_protection_p_call, NULL);\n+\n+  if (mips_r10k_cache_barrier == R10K_CACHE_BARRIER_STORE)\n+    {\n+      note_stores (PATTERN (insn), r10k_needs_protection_p_store, &insn);\n+      return insn == NULL_RTX;\n+    }\n+\n+  return for_each_rtx (&PATTERN (insn), r10k_needs_protection_p_1, insn);\n+}\n+\n+/* Return true if BB is only reached by blocks in PROTECTED_BBS and if every\n+   edge is unconditional.  */\n+\n+static bool\n+r10k_protected_bb_p (basic_block bb, sbitmap protected_bbs)\n+{\n+  edge_iterator ei;\n+  edge e;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (!single_succ_p (e->src)\n+\t|| !TEST_BIT (protected_bbs, e->src->index)\n+\t|| (e->flags & EDGE_COMPLEX) != 0)\n+      return false;\n+  return true;\n+}\n+\n+/* Implement -mr10k-cache-barrier= for the current function.  */\n+\n+static void\n+r10k_insert_cache_barriers (void)\n+{\n+  int *rev_post_order;\n+  unsigned int i, n;\n+  basic_block bb;\n+  sbitmap protected_bbs;\n+  rtx insn, end, unprotected_region;\n+\n+  if (TARGET_MIPS16)\n+    {\n+      sorry (\"%qs does not support MIPS16 code\", \"-mr10k-cache-barrier\");\n+      return;\n+    }\n+\n+  /* Restore the BLOCK_FOR_INSN pointers, which are needed by DF.  */\n+  compute_bb_for_insn ();\n+\n+  /* Create def-use chains.  */\n+  df_set_flags (DF_EQ_NOTES);\n+  df_chain_add_problem (DF_UD_CHAIN);\n+  df_analyze ();\n+\n+  /* Calculate dominators.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* Bit X of PROTECTED_BBS is set if the last operation in basic block\n+     X is protected by a cache barrier.  */\n+  protected_bbs = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (protected_bbs);\n+\n+  /* Iterate over the basic blocks in reverse post-order.  */\n+  rev_post_order = XNEWVEC (int, last_basic_block);\n+  n = pre_and_rev_post_order_compute (NULL, rev_post_order, false);\n+  for (i = 0; i < n; i++)\n+    {\n+      bb = BASIC_BLOCK (rev_post_order[i]);\n+\n+      /* If this block is only reached by unconditional edges, and if the\n+\t source of every edge is protected, the beginning of the block is\n+\t also protected.  */\n+      if (r10k_protected_bb_p (bb, protected_bbs))\n+\tunprotected_region = NULL_RTX;\n+      else\n+\tunprotected_region = pc_rtx;\n+      end = NEXT_INSN (BB_END (bb));\n+\n+      /* UNPROTECTED_REGION is:\n+\n+\t - null if we are processing a protected region,\n+\t - pc_rtx if we are processing an unprotected region but have\n+\t   not yet found the first instruction in it\n+\t - the first instruction in an unprotected region otherwise.  */\n+      for (insn = BB_HEAD (bb); insn != end; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (unprotected_region && INSN_P (insn))\n+\t    {\n+\t      if (recog_memoized (insn) == CODE_FOR_mips_cache)\n+\t\t/* This CACHE instruction protects the following code.  */\n+\t\tunprotected_region = NULL_RTX;\n+\t      else\n+\t\t{\n+\t\t  /* See if INSN is the first instruction in this\n+\t\t     unprotected region.  */\n+\t\t  if (unprotected_region == pc_rtx)\n+\t\t    unprotected_region = insn;\n+\n+\t\t  /* See if INSN needs to be protected.  If so,\n+\t\t     we must insert a cache barrier somewhere between\n+\t\t     PREV_INSN (UNPROTECTED_REGION) and INSN.  It isn't\n+\t\t     clear which position is better performance-wise,\n+\t\t     but as a tie-breaker, we assume that it is better\n+\t\t     to allow delay slots to be back-filled where\n+\t\t     possible, and that it is better not to insert\n+\t\t     barriers in the middle of already-scheduled code.\n+\t\t     We therefore insert the barrier at the beginning\n+\t\t     of the region.  */\n+\t\t  if (r10k_needs_protection_p (insn))\n+\t\t    {\n+\t\t      emit_insn_before (gen_r10k_cache_barrier (),\n+\t\t\t\t\tunprotected_region);\n+\t\t      unprotected_region = NULL_RTX;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (CALL_P (insn))\n+\t    /* The called function is not required to protect the exit path.\n+\t       The code that follows a call is therefore unprotected.  */\n+\t    unprotected_region = pc_rtx;\n+\t}\n+\n+      /* Record whether the end of this block is protected.  */\n+      if (unprotected_region == NULL_RTX)\n+\tSET_BIT (protected_bbs, bb->index);\n+    }\n+  XDELETEVEC (rev_post_order);\n+\n+  sbitmap_free (protected_bbs);\n+\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  df_finish_pass (false);\n+\n+  free_bb_for_insn ();\n+}\n+\f\n /* A temporary variable used by for_each_rtx callbacks, etc.  */\n static rtx mips_sim_insn;\n \n@@ -12675,6 +13082,13 @@ mips_reorg_process_insns (void)\n \t\t orphaned high-part relocation.  */\n \t      if (mips_orphaned_high_part_p (htab, insn))\n \t\tdelete_insn (insn);\n+\t      /* Also delete cache barriers if the last instruction\n+\t\t was an annulled branch.  INSN will not be speculatively\n+\t\t executed.  */\n+\t      else if (recog_memoized (insn) == CODE_FOR_r10k_cache_barrier\n+\t\t       && last_insn\n+\t\t       && INSN_ANNULLED_BRANCH_P (SEQ_BEGIN (last_insn)))\n+\t\tdelete_insn (insn);\n \t      else\n \t\t{\n \t\t  mips_avoid_hazard (last_insn, insn, &hilo_delay,\n@@ -12694,6 +13108,8 @@ static void\n mips_reorg (void)\n {\n   mips16_lay_out_constants ();\n+  if (mips_r10k_cache_barrier != R10K_CACHE_BARRIER_NONE)\n+    r10k_insert_cache_barriers ();\n   if (mips_base_delayed_branch)\n     dbr_schedule (get_insns ());\n   mips_reorg_process_insns ();\n@@ -13123,6 +13539,17 @@ mips_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n \treturn false;\n       return true;\n \n+    case OPT_mr10k_cache_barrier_:\n+      if (strcmp (arg, \"load-store\") == 0)\n+\tmips_r10k_cache_barrier = R10K_CACHE_BARRIER_LOAD_STORE;\n+      else if (strcmp (arg, \"store\") == 0)\n+\tmips_r10k_cache_barrier = R10K_CACHE_BARRIER_STORE;\n+      else if (strcmp (arg, \"none\") == 0)\n+\tmips_r10k_cache_barrier = R10K_CACHE_BARRIER_NONE;\n+      else\n+\treturn false;\n+      return true;\n+\n     default:\n       return true;\n     }\n@@ -13358,6 +13785,14 @@ mips_override_options (void)\n     warning (0, \"the %qs architecture does not support paired-single\"\n \t     \" instructions\", mips_arch_info->name);\n \n+  if (mips_r10k_cache_barrier != R10K_CACHE_BARRIER_NONE\n+      && !TARGET_CACHE_BUILTIN)\n+    {\n+      error (\"%qs requires a target that provides the %qs instruction\",\n+\t     \"-mr10k-cache-barrier\", \"cache\");\n+      mips_r10k_cache_barrier = R10K_CACHE_BARRIER_NONE;\n+    }\n+\n   /* If TARGET_DSPR2, enable MASK_DSP.  */\n   if (TARGET_DSPR2)\n     target_flags |= MASK_DSP;"}, {"sha": "effa34ba26108859f72727e087c2b6be42b4ba2c", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -563,6 +563,9 @@ enum mips_code_readable_setting {\n \t\t\t\t\t\t\t\t\t\\\n       if (mips_abi == ABI_EABI)\t\t\t\t\t\t\\\n \tbuiltin_define (\"__mips_eabi\");\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_CACHE_BUILTIN)\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__GCC_HAVE_BUILTIN_MIPS_CACHE\");\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -1020,6 +1023,12 @@ enum mips_code_readable_setting {\n \n /* ISA includes the pop instruction.  */\n #define ISA_HAS_POP\t\tTARGET_OCTEON\n+\n+/* The CACHE instruction is available in non-MIPS16 code.  */\n+#define TARGET_CACHE_BUILTIN (mips_isa >= 3)\n+\n+/* The CACHE instruction is available.  */\n+#define ISA_HAS_CACHE (TARGET_CACHE_BUILTIN && !TARGET_MIPS16)\n \f\n /* Add -G xx support.  */\n "}, {"sha": "593fae30ba60452f560bfc10c7831f4dd2678e38", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -247,6 +247,9 @@\n    (UNSPEC_LOONGSON_ALU2_TURN_ENABLED_INSN   531)\n    (UNSPEC_LOONGSON_FALU1_TURN_ENABLED_INSN  532)\n    (UNSPEC_LOONGSON_FALU2_TURN_ENABLED_INSN  533)\n+\n+   (UNSPEC_MIPS_CACHE\t\t600)\n+   (UNSPEC_R10K_CACHE_BARRIER\t601)\n   ]\n )\n \n@@ -4722,6 +4725,25 @@\n }\n   [(set_attr \"length\" \"20\")])\n \n+;; Cache operations for R4000-style caches.\n+(define_insn \"mips_cache\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK [(match_operand:SI 0 \"const_int_operand\")\n+\t\t     (match_operand:QI 1 \"address_operand\" \"p\")]\n+\t\t    UNSPEC_MIPS_CACHE))]\n+  \"ISA_HAS_CACHE\"\n+  \"cache\\t%X0,%a1\")\n+\n+;; Similar, but with the operands hard-coded to an R10K cache barrier\n+;; operation.  We keep the pattern distinct so that we can identify\n+;; cache operations inserted by -mr10k-cache-barrier=, and so that\n+;; the operation is never inserted into a delay slot.\n+(define_insn \"r10k_cache_barrier\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK [(const_int 0)] UNSPEC_R10K_CACHE_BARRIER))]\n+  \"ISA_HAS_CACHE\"\n+  \"cache\\t0x14,0(%$)\"\n+  [(set_attr \"can_delay\" \"no\")])\n \f\n ;; Block moves, see mips.c for more details.\n ;; Argument 0 is the destination"}, {"sha": "56c99ac16f86a4c3d108a0cf0200f17929c04915", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -236,6 +236,10 @@ mpaired-single\n Target Report Mask(PAIRED_SINGLE_FLOAT)\n Use paired-single floating-point instructions\n \n+mr10k-cache-barrier=\n+Target Joined RejectNegative\n+-mr10k-cache-barrier=SETTING\tSpecify when r10k cache barriers should be inserted\n+\n mshared\n Target Report Var(TARGET_SHARED) Init(1)\n When generating -mabicalls code, make the code suitable for use in shared libraries"}, {"sha": "32ca1f0b3b0272fa6c3ea72341155257cf834c73", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -6985,6 +6985,7 @@ instructions, but allow the compiler to schedule those calls.\n * MIPS DSP Built-in Functions::\n * MIPS Paired-Single Support::\n * MIPS Loongson Built-in Functions::\n+* Other MIPS Built-in Functions::\n * picoChip Built-in Functions::\n * PowerPC AltiVec Built-in Functions::\n * SPARC VIS Built-in Functions::\n@@ -9440,6 +9441,18 @@ implementing assertions.\n \n @end table\n \n+@node Other MIPS Built-in Functions\n+@subsection Other MIPS Built-in Functions\n+\n+GCC provides other MIPS-specific built-in functions:\n+\n+@table @code\n+@item void __builtin_mips_cache (int @var{op}, const volatile void *@var{addr})\n+Insert a @samp{cache} instruction with operands @var{op} and @var{addr}.\n+GCC defines the preprocessor macro @code{___GCC_HAVE_BUILTIN_MIPS_CACHE}\n+when this function is available.\n+@end table\n+\n @node PowerPC AltiVec Built-in Functions\n @subsection PowerPC AltiVec Built-in Functions\n "}, {"sha": "d96d4ab78c95d5d263b89d93a0a29bbb7455ba87", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -12808,6 +12808,73 @@ Work around certain SB-1 CPU core errata.\n (This flag currently works around the SB-1 revision 2\n ``F1'' and ``F2'' floating point errata.)\n \n+@item -mr10k-cache-barrier=@var{setting}\n+@opindex mr10k-cache-barrier\n+Specify whether GCC should insert cache barriers to avoid the\n+side-effects of speculation on R10K processors.\n+\n+In common with many processors, the R10K tries to predict the outcome\n+of a conditional branch and speculatively executes instructions from\n+the ``taken'' branch.  It later aborts these instructions if the\n+predicted outcome was wrong.  However, on the R10K, even aborted\n+instructions can have side effects.\n+\n+This problem only affects kernel stores and, depending on the system,\n+kernel loads.  As an example, a speculatively-executed store may load\n+the target memory into cache and mark the cache line as dirty, even if\n+the store itself is later aborted.  If a DMA operation writes to the\n+same area of memory before the ``dirty'' line is flushed, the cached\n+data will overwrite the DMA-ed data.  See the R10K processor manual\n+for a full description, including other potential problems.\n+\n+One workaround is to insert cache barrier instructions before every memory\n+access that might be speculatively executed and that might have side\n+effects even if aborted.  @option{-mr10k-cache-barrier=@var{setting}}\n+controls GCC's implementation of this workaround.  It assumes that\n+aborted accesses to any byte in the following regions will not have\n+side effects:\n+\n+@enumerate\n+@item\n+the memory occupied by the current function's stack frame;\n+\n+@item\n+the memory occupied by an incoming stack argument;\n+\n+@item\n+the memory occupied by an object with a link-time-constant address.\n+@end enumerate\n+\n+It is the kernel's responsibility to ensure that speculative\n+accesses to these regions are indeed safe.\n+\n+If the input program contains a function declaration such as:\n+\n+@smallexample\n+void foo (void);\n+@end smallexample\n+\n+then the implementation of @code{foo} must allow @code{j foo} and\n+@code{jal foo} to be executed speculatively.  GCC honors this\n+restriction for functions it compiles itself.  It expects non-GCC\n+functions (such as hand-written assembly code) to do the same.\n+\n+The option has three forms:\n+\n+@table @gcctabopt\n+@item -mr10k-cache-barrier=load-store\n+Insert a cache barrier before a load or store that might be\n+speculatively executed and that might have side effects even\n+if aborted.\n+\n+@item -mr10k-cache-barrier=store\n+Insert a cache barrier before a store that might be speculatively\n+executed and that might have side effects even if aborted.\n+\n+@item -mr10k-cache-barrier=none\n+Disable the insertion of cache barriers.  This is the default setting.\n+@end table\n+\n @item -mflush-func=@var{func}\n @itemx -mno-flush-func\n @opindex mflush-func"}, {"sha": "9ea373a98f340b01103cb960cf668a89fdc163c9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -1,3 +1,24 @@\n+2008-09-06  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gcc.target/mips/mips.exp (dg-mips-options): Make\n+\t-mr10k-cache-barrier=* imply -mips3 or above.\n+\t* gcc.target/mips/cache-1.c: New test.\n+\t* gcc.target/mips/r10k-cache-barrier-1.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-2.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-3.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-4.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-5.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-6.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-7.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-8.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-9.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-10.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-11.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-12.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-13.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-14.c: Likewise.\n+\t* gcc.target/mips/r10k-cache-barrier-15.c: Likewise.\n+\n 2008-09-05  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/35837"}, {"sha": "40c22e08cdce052b911d6197b200f116423d4cee", "filename": "gcc/testsuite/gcc.target/mips/cache-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcache-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcache-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcache-1.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-mips-options \"-O2\" } */\n+\n+void\n+f1 (int *area)\n+{\n+  __builtin_mips_cache (20, area);\n+}\n+\n+void\n+f2 (const short *area)\n+{\n+  __builtin_mips_cache (24, area + 10);\n+}\n+\n+void\n+f3 (volatile unsigned int *area, int offset)\n+{\n+  __builtin_mips_cache (0, area + offset);\n+}\n+\n+void\n+f4 (const volatile unsigned char *area)\n+{\n+  __builtin_mips_cache (4, area - 80);\n+}\n+\n+/* { dg-final { scan-assembler \"\\tcache\\t0x14,0\\\\(\\\\\\$4\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tcache\\t0x18,20\\\\(\\\\\\$4\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tcache\\t0x0,0\\\\(\\\\\\$.\\\\)\" } } */\n+/* { dg-final { scan-assembler \"\\tcache\\t0x4,-80\\\\(\\\\\\$4\\\\)\" } } */"}, {"sha": "832633900c9467b06e2ec3e70a90120ef88a62c0", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -238,6 +238,10 @@ proc dg-mips-options {args} {\n \t    } else {\n \t\tappend flags \" -msoft-float\"\n \t    }\n+\t} elseif {[regexp -- {^-mr10k-cache-barrier=(load|store)} $flag]\n+\t\t  && $mips_isa < 3\n+\t\t  && [lsearch -regexp $flags {^(-mips|-march)}] < 0} {\n+\t    append flags \" -mips3\"\n \t}\n     }\n     foreach flag $flags {"}, {"sha": "fd13d8ac876359b3513485e31e6e035f82ef6163", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-1.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-mips-options \"-O2 -mabi=64 -mr10k-cache-barrier=store\" } */\n+\n+/* Test that stores to uncached addresses do not get unnecessary\n+   cache barriers.  */\n+\n+#define TEST(ADDR)\t\t\t\t\t\\\n+  NOMIPS16 void\t\t\t\t\t\t\\\n+  test_##ADDR (int n)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    while (n--)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\t*(volatile char *) (0x##ADDR##UL) = 1;\t\t\\\n+\t*(volatile short *) (0x##ADDR##UL + 2) = 2;\t\\\n+\t*(volatile int *) (0x##ADDR##UL + 4) = 0;\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+TEST (9000000000000000)\n+TEST (900000fffffffff8)\n+\n+TEST (9200000000000000)\n+TEST (920000fffffffff8)\n+\n+TEST (9400000000000000)\n+TEST (940000fffffffff8)\n+\n+TEST (9600000000000000)\n+TEST (960000fffffffff8)\n+\n+TEST (b800000000000000)\n+TEST (b80000fffffffff8)\n+\n+TEST (ba00000000000000)\n+TEST (ba0000fffffffff8)\n+\n+TEST (bc00000000000000)\n+TEST (bc0000fffffffff8)\n+\n+TEST (be00000000000000)\n+TEST (be0000fffffffff8)\n+\n+TEST (ffffffffa0000000)\n+TEST (ffffffffbffffff8)\n+\n+/* { dg-final { scan-assembler-not \"\\tcache\\t\" } } */"}, {"sha": "405d7fcf033196ab1c12bde2e1d90793bb8640a2", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-10.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-10.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -mips4 -mbranch-likely -mno-abicalls\" } */\n+int bar (int);\n+\n+/* Test that code after a branch-likely does not get an unnecessary\n+   cache barrier.  */\n+\n+NOMIPS16 void\n+foo (int n, int *x)\n+{\n+  do\n+    n = bar (n * 4 + 1);\n+  while (n);\n+  /* The preceding branch should be a branch likely, with the shift as\n+     its delay slot.  We therefore don't need a cache barrier here.  */\n+  x[0] = 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tcache\\t\" } } */"}, {"sha": "be6816fda9be972e6c5c649e5a03d6b5d1e4b2d4", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-11.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-11.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -mno-abicalls\" } */\n+\n+/* Test that loads are not unnecessarily protected.  */\n+\n+int bar (int);\n+\n+NOMIPS16 void\n+foo (int *ptr)\n+{\n+  *ptr = bar (*ptr);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcache\\t\" 1 } } */"}, {"sha": "7e8026f1e5f7b8c359d9d66f531ab291298f2475", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-12.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-12.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=load-store -mno-abicalls\" } */\n+\n+/* Test that loads are correctly protected.  */\n+\n+int bar (int);\n+\n+NOMIPS16 void\n+foo (int *ptr)\n+{\n+  *ptr = bar (*ptr);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcache\\t\" 2 } } */"}, {"sha": "fa5a416ce200537191dd21673655f487711d18c7", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-13.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-13.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store\" } */\n+\n+/* Test that indirect calls are protected.  */\n+\n+int bar (int);\n+\n+NOMIPS16 void\n+foo (void (*fn) (void), int x)\n+{\n+  if (x)\n+    (*fn) ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcache\\t\" 1 } } */"}, {"sha": "4d807833abb4bb9e24f47255f87939d864091405", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-14.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-14.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile { target mips16_attribute } } */\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store\" } */\n+/* { dg-add-options mips16_attribute } */\n+\n+/* Test that indirect calls are protected.  */\n+\n+MIPS16 void foo (void) { } /* { dg-message \"sorry, unimplemented\" } */"}, {"sha": "5b03838ca2c0b6272884c1b8d1dfff20d0704b2c", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-15.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-15.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,2 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -mips2\" } */\n+/* { dg-error \"requires.*cache.*instruction\" \"\" { target *-*-* } 0 } */"}, {"sha": "ed439b143f5b7042ad48ed5ad7870f69e41a8df4", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-2.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-mips-options \"-O2 -mabi=64 -mr10k-cache-barrier=store\" } */\n+\n+/* Test that stores to constant cached addresses are protected\n+   by cache barriers.  */\n+\n+#define TEST(ADDR)\t\t\t\t\t\\\n+  NOMIPS16 void\t\t\t\t\t\t\\\n+  test_##ADDR (int n)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    *(volatile int *) (0x##ADDR##UL) = 1;\t\t\\\n+  }\n+\n+TEST (8ffffffffffffffc)\n+TEST (9000010000000000)\n+\n+TEST (91fffffffffffffc)\n+TEST (9200010000000000)\n+\n+TEST (93fffffffffffffc)\n+TEST (9500010000000000)\n+\n+TEST (95fffffffffffffc)\n+TEST (9600010000000000)\n+\n+TEST (b7fffffffffffffc)\n+TEST (b800010000000000)\n+\n+TEST (b9fffffffffffffc)\n+TEST (ba00010000000000)\n+\n+TEST (bbfffffffffffffc)\n+TEST (bc00010000000000)\n+\n+TEST (bdfffffffffffffc)\n+TEST (be00010000000000)\n+\n+TEST (ffffffff9ffffffc)\n+TEST (ffffffffc0000000)\n+\n+/* { dg-final { scan-assembler-times \"\\tcache\\t\" 18 } } */"}, {"sha": "8238f39b04c9af593385b6a08f4a647f12ad7372", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-3.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -mno-abicalls\" } */\n+\n+/* Test that in-range stores to the frame are not protected by\n+   cache barriers.  */\n+\n+void bar (int *x);\n+\n+NOMIPS16 void\n+foo (int v)\n+{\n+  int x[0x100000];\n+  bar (x);\n+  x[0x20] = v;\n+  bar (x);\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tcache\\t\" } } */"}, {"sha": "e8280e8af273b25714060a0783e160ef1b5c1e63", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-4.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -mno-abicalls\" } */\n+\n+void bar (int *x);\n+\n+/* Test that out-of-range stores to the frame are protected by cache\n+   barriers.  */\n+\n+NOMIPS16 void\n+foo (int v)\n+{\n+  int x[8];\n+  bar (x);\n+  if (v & 1)\n+    x[0x100] = 0;\n+  if (v & 2)\n+    x[-0x100] = 0;\n+  bar (x);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcache\\t\" 2 } } */"}, {"sha": "6e21ec3e3938ad80145caceed4ff725c7e41a072", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-5.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-5.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -mno-abicalls -mabi=64\" } */\n+\n+/* Test that in-range stores to static objects do not get an unnecessary\n+   cache barrier.  */\n+\n+int x[4];\n+void bar (void);\n+\n+NOMIPS16 void\n+foo (int n)\n+{\n+  while (n--)\n+    {\n+      x[3] = 1;\n+      bar ();\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tcache\\t\" } } */"}, {"sha": "f014aa0dcdcbc2a270468c05f432764ea4556756", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-6.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-6.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -mabi=64\" } */\n+\n+int x[4];\n+void bar (void);\n+\n+/* Test that out-of-range stores to static objects are protected by a\n+   cache barrier.  */\n+\n+NOMIPS16 void\n+foo (int n)\n+{\n+  while (n--)\n+    {\n+      x[4] = 1;\n+      bar ();\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tcache\\t\" } } */"}, {"sha": "c98b4a8a0fe3ae1efb4687fbf5f12aa796737d53", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-7.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-7.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -mno-abicalls\" } */\n+\n+void bar1 (void);\n+void bar2 (void);\n+void bar3 (void);\n+\n+NOMIPS16 void\n+foo (int *x, int sel, int n)\n+{\n+  if (sel)\n+    {\n+      bar1 ();\n+      x[0] = 1;\n+    }\n+  else\n+    {\n+      bar2 ();\n+      x[1] = 0;\n+    }\n+  /* If there is one copy of this code, reached by two unconditional edges,\n+     then it shouldn't need a third cache barrier.  */\n+  x[2] = 2;\n+  while (n--)\n+    bar3 ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcache\\t\" 2 } } */"}, {"sha": "5394ae8067ee8c306f960b0df34c0daec1596df2", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-8.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-8.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -G8\" } */\n+\n+/* Test that in-range stores to components of static objects\n+   do not get an unnecessary cache barrier.  */\n+\n+struct { struct { char i[4]; } a; struct { char j[4]; } b; } s;\n+\n+NOMIPS16 void\n+foo (int sel)\n+{\n+  s.a.i[0] = 1;\n+  s.b.j[3] = 100;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tcache\\t\" } } */"}, {"sha": "cf795b6e7326d8f878f0762ad5051c228a25572e", "filename": "gcc/testsuite/gcc.target/mips/r10k-cache-barrier-9.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d210b073fb34615670b295c5c2a3ea0acf2c986/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fr10k-cache-barrier-9.c?ref=4d210b073fb34615670b295c5c2a3ea0acf2c986", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-mips-options \"-O2 -mr10k-cache-barrier=store -G8\" } */\n+\n+/* Test that out-of-range stores to components of static objects\n+   are protected by a cache barrier.  */\n+\n+struct { struct { char i[4]; } a; struct { char j[4]; } b; } s;\n+\n+NOMIPS16 void\n+foo (int sel1, int sel2, int sel3)\n+{\n+  if (sel1)\n+    s.a.i[8] = 1;\n+  if (sel2)\n+    s.b.j[4] = 100;\n+  if (sel3)\n+    s.a.i[-1] = 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tcache\\t\" 3 } } */"}]}