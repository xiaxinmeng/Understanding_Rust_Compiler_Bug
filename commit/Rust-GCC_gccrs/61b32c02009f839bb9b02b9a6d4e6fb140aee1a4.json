{"sha": "61b32c02009f839bb9b02b9a6d4e6fb140aee1a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFiMzJjMDIwMDlmODM5YmI5YjAyYjlhNmQ0ZTZmYjE0MGFlZTFhNA==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-14T18:18:57Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-14T18:18:57Z"}, "message": "inheritance\n\nFrom-SVN: r12959", "tree": {"sha": "69fbb95e30796c28eac91a72392889c4cbe2bff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69fbb95e30796c28eac91a72392889c4cbe2bff4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61b32c02009f839bb9b02b9a6d4e6fb140aee1a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b32c02009f839bb9b02b9a6d4e6fb140aee1a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b32c02009f839bb9b02b9a6d4e6fb140aee1a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b32c02009f839bb9b02b9a6d4e6fb140aee1a4/comments", "author": null, "committer": null, "parents": [{"sha": "5e918f1d5d5b1b8fa9ffc85a1ba7fdd079dbf390", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e918f1d5d5b1b8fa9ffc85a1ba7fdd079dbf390", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e918f1d5d5b1b8fa9ffc85a1ba7fdd079dbf390"}], "stats": {"total": 94, "additions": 69, "deletions": 25}, "files": [{"sha": "e999426ce65a3db75a8240522011c2fb07a271c3", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 69, "deletions": 25, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61b32c02009f839bb9b02b9a6d4e6fb140aee1a4/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61b32c02009f839bb9b02b9a6d4e6fb140aee1a4/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=61b32c02009f839bb9b02b9a6d4e6fb140aee1a4", "patch": "@@ -4985,7 +4985,9 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t{\n \t  mod_type_die = new_die (DW_TAG_pointer_type, context_die);\n \t  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n+#if 0\n \t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n+#endif\n \t  item_type = TREE_TYPE (type);\n \t  sub_die = modified_type_die (item_type,\n \t\t\t\t       TYPE_READONLY (item_type),\n@@ -4996,7 +4998,9 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t{\n \t  mod_type_die = new_die (DW_TAG_reference_type, context_die);\n \t  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n+#if 0\n \t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n+#endif \n \t  item_type = TREE_TYPE (type);\n \t  sub_die = modified_type_die (item_type,\n \t\t\t\t       TYPE_READONLY (item_type),\n@@ -5479,10 +5483,15 @@ add_data_member_location_attribute (die, decl)\n      register dw_die_ref die;\n      register tree decl;\n {\n-  register unsigned long offset = field_byte_offset (decl);\n+  register unsigned long offset;\n   register dw_loc_descr_ref loc_descr;\n   register enum dwarf_location_atom op;\n \n+  if (TREE_CODE (decl) == TREE_VEC)\n+    offset = TREE_INT_CST_LOW (BINFO_OFFSET (decl));\n+  else\n+    offset = field_byte_offset (decl);\n+\n   /* The DWARF2 standard says that we should assume that the structure address\n      is already on the stack, so we can specify a structure field address\n      by using DW_OP_plus_uconst.  */\n@@ -5687,12 +5696,11 @@ add_location_or_const_value_attribute (die, decl)\n \t\t    }\n \t\t}\n \t    }\n-\t  if (rtl == NULL_RTX)\n-\t    {\n-\t      return;\n-\t    }\n \t}\n     }\n+  if (rtl == NULL_RTX)\n+    return;\n+\n   switch (GET_CODE (rtl))\n     {\n     case CONST_INT:\n@@ -6025,6 +6033,8 @@ add_pure_or_virtual_attribute (die, func_decl)\n   if (DECL_VIRTUAL_P (func_decl))\n     {\n       add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n+      add_AT_loc (die, DW_AT_vtable_elem_location, new_loc_descr\n+\t\t  (DW_OP_constu, TREE_INT_CST_LOW (DECL_VINDEX (func_decl))));\n     }\n }\n \f\n@@ -6037,8 +6047,13 @@ add_name_and_src_coords_attributes (die, decl)\n      register dw_die_ref die;\n      register tree decl;\n {\n-  register tree decl_name = DECL_ASSEMBLER_NAME (decl);\n+  register tree decl_name;\n   register unsigned file_index;\n+  if (staticp (decl))\n+    decl_name = DECL_ASSEMBLER_NAME (decl);\n+  else\n+    decl_name = DECL_NAME (decl); \n+\n   if (decl_name && IDENTIFIER_POINTER (decl_name))\n     {\n       add_name_attribute (die, IDENTIFIER_POINTER (decl_name));\n@@ -6590,10 +6605,6 @@ gen_subprogram_die (decl, context_die)\n \t  add_AT_flag (subr_die, DW_AT_external, 1);\n \t}\n       add_name_and_src_coords_attributes (subr_die, decl);\n-      if (DECL_INLINE (decl))\n-\t{\n-\t  add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n-\t}\n       type = TREE_TYPE (decl);\n       add_prototyped_attribute (subr_die, type);\n       add_type_attribute (subr_die, TREE_TYPE (type), 0, 0, context_die);\n@@ -6606,10 +6617,25 @@ gen_subprogram_die (decl, context_die)\n       if (! DECL_INITIAL (decl))\n \tadd_AT_flag (subr_die, DW_AT_declaration, 1);\n     }\n-  if (DECL_ABSTRACT (decl) || ! DECL_INITIAL (decl))\n+  if (DECL_ABSTRACT (decl))\n     {\n+      if (DECL_DEFER_OUTPUT (decl))\n+\t{\n+\t  if (DECL_INLINE (decl))\n+\t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_inlined);\n+\t  else\n+\t    add_AT_unsigned (subr_die, DW_AT_inline,\n+\t\t\t     DW_INL_declared_not_inlined);\n+\t}\n+      else if (DECL_INLINE (decl))\n+\tadd_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n+      else\n+\tabort ();\n+\n       equate_decl_number_to_die (decl, subr_die);\n     }\n+  else if (!DECL_INITIAL (decl))\n+    equate_decl_number_to_die (decl, subr_die);\n   else if (!DECL_EXTERNAL (decl))\n     {\n       if (origin == NULL)\n@@ -7044,15 +7070,30 @@ gen_string_type_die (type, context_die)\n \t\t\t      bound_representation (upper_bound, 0, 'u'); */\n }\n \n+/* Generate the DIE for a base class.  */\n+static void\n+gen_inheritance_die (binfo, context_die)\n+     register tree binfo;\n+     register dw_die_ref context_die;\n+{\n+  dw_die_ref die = new_die (DW_TAG_inheritance, context_die);\n+  add_type_attribute (die, BINFO_TYPE (binfo), 0, 0, context_die);\n+  add_data_member_location_attribute (die, binfo);\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    add_AT_unsigned (die, DW_AT_virtuality, DW_VIRTUALITY_virtual);\n+  if (TREE_VIA_PUBLIC (binfo))\n+    add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_public);\n+  else if (TREE_VIA_PROTECTED (binfo))\n+    add_AT_unsigned (die, DW_AT_accessibility, DW_ACCESS_protected);\n+}\n+\n /* Genearate a DIE for a class member.  */\n static void\n gen_member_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register tree normal_member;\n-  register tree first_func_member;\n-  register tree func_member;\n+  register tree member;\n   /* If this is not an incomplete type, output descriptions of each of its\n      members. Note that as we output the DIEs necessary to represent the\n      members of this record or union type, we will also be trying to output\n@@ -7066,21 +7107,24 @@ gen_member_die (type, context_die)\n      to point to the TREE node representing the appropriate (containing)\n      type.  */\n \n-  /* First output info about the data members and type members.  */\n-  for (normal_member = TYPE_FIELDS (type);\n-       normal_member;\n-       normal_member = TREE_CHAIN (normal_member))\n+  /* First output info about the base classes.  */\n+  if (TYPE_BINFO (type) && TYPE_BINFO_BASETYPES (type))\n     {\n-      gen_decl_die (normal_member, context_die);\n+      register tree bases = TYPE_BINFO_BASETYPES (type);\n+      register int n_bases = TREE_VEC_LENGTH (bases);\n+      register int i;\n+\n+      for (i = 0; i < n_bases; i++)\n+\tgen_inheritance_die (TREE_VEC_ELT (bases, i), context_die);\n     }\n \n+  /* Now output info about the data members and type members.  */\n+  for (member = TYPE_FIELDS (type); member; member = TREE_CHAIN (member))\n+    gen_decl_die (member, context_die);\n+\n   /* Now output info about the function members (if any).  */\n-  for (func_member = TYPE_METHODS (type);\n-       func_member;\n-       func_member = TREE_CHAIN (func_member))\n-    {\n-      gen_decl_die (func_member, context_die);\n-    }\n+  for (member = TYPE_METHODS (type); member; member = TREE_CHAIN (member))\n+    gen_decl_die (member, context_die);\n }\n \n /* Generate a DIE for a structure or union type.  */"}]}