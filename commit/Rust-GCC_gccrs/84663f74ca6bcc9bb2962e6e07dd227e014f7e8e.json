{"sha": "84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ2NjNmNzRjYTZiY2M5YmIyOTYyZTZlMDdkZDIyN2UwMTRmN2U4ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-31T12:54:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-31T12:54:18Z"}, "message": "cp-tree.h, decl2.c: Remove support for -fall-virtual, -fenum-int-equivalence and -fno-nonnull-objects.\n\n\t* cp-tree.h, decl2.c: Remove support for -fall-virtual,\n\t-fenum-int-equivalence and -fno-nonnull-objects.\n\t* class.c (check_for_override): Remove support for -fall-virtual.\n\t(finish_struct_1): Likewise.\n\t* call.c (build_new_op): Remove support for -fenum-int-equivalence.\n\t* typeck.c (build_binary_op_nodefault): Likewise.\n\t* cvt.c (ocp_convert): Likewise.\n\t* call.c (build_vfield_ref): Remove support for -fno-nonnull-objects.\n\t* class.c (build_vbase_path): Likewise.\n\nFrom-SVN: r22131", "tree": {"sha": "065cb3f79e79c9e98619d6b06cad730a6f8fe744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/065cb3f79e79c9e98619d6b06cad730a6f8fe744"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/comments", "author": null, "committer": null, "parents": [{"sha": "058ebd7ee688d8efe6f3d7c2b299a514cda225c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058ebd7ee688d8efe6f3d7c2b299a514cda225c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058ebd7ee688d8efe6f3d7c2b299a514cda225c2"}], "stats": {"total": 139, "additions": 34, "deletions": 105}, "files": [{"sha": "0ccaeba11697f7f2fecd6b9d74dd0e4d7e8ec37e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "patch": "@@ -1,3 +1,15 @@\n+1998-08-31  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h, decl2.c: Remove support for -fall-virtual,\n+\t-fenum-int-equivalence and -fno-nonnull-objects.\n+\t* class.c (check_for_override): Remove support for -fall-virtual.\n+\t(finish_struct_1): Likewise.\n+\t* call.c (build_new_op): Remove support for -fenum-int-equivalence.\n+\t* typeck.c (build_binary_op_nodefault): Likewise.\n+\t* cvt.c (ocp_convert): Likewise.\n+\t* call.c (build_vfield_ref): Remove support for -fno-nonnull-objects.\n+\t* class.c (build_vbase_path): Likewise.\n+\n Sun Aug 30 22:16:31 1998  H.J. Lu  (hjl@gnu.org)\n \n \t* Makefile.in (INTERFACE): New, set to 1.\n@@ -47,7 +59,7 @@ Sun Aug 30 22:16:31 1998  H.J. Lu  (hjl@gnu.org)\n \t* decl.c (finish_enum): Don't set the TREE_TYPE for the\n \tenumeration constant values if we're processing_template_decls.\n \tDon't set the type for the CONST_DECLs either; that's done in\n-\tbuild_enumerator. \n+\tbuild_enumerator.\n \t(build_enumerator): Take the enumeration type as a\n \tparameter. \n \t* lex.c (do_identifier): Don't resolve enumeration constants while"}, {"sha": "d27d61614542ac404489e7ca54a8f425a950e21d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "patch": "@@ -96,13 +96,10 @@ build_vfield_ref (datum, type)\n      tree datum, type;\n {\n   tree rval;\n-  int old_assume_nonnull_objects = flag_assume_nonnull_objects;\n \n   if (datum == error_mark_node)\n     return error_mark_node;\n \n-  /* Vtable references are always made from non-null objects.  */\n-  flag_assume_nonnull_objects = 1;\n   if (TREE_CODE (TREE_TYPE (datum)) == REFERENCE_TYPE)\n     datum = convert_from_reference (datum);\n \n@@ -111,7 +108,6 @@ build_vfield_ref (datum, type)\n \t\t  datum, CLASSTYPE_VFIELD (type));\n   else\n     rval = build_component_ref (datum, DECL_NAME (CLASSTYPE_VFIELD (type)), NULL_TREE, 0);\n-  flag_assume_nonnull_objects = old_assume_nonnull_objects;\n \n   return rval;\n }\n@@ -2795,8 +2791,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     case LE_EXPR:\n     case EQ_EXPR:\n     case NE_EXPR:\n-      if (flag_int_enum_equivalence == 0 \n-\t  && TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE \n+      if (TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE \n \t  && TREE_CODE (TREE_TYPE (arg2)) == ENUMERAL_TYPE \n \t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n \t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))"}, {"sha": "75ae6e3c13bc82c959050352fa9e47bfcc59bbb8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "patch": "@@ -267,8 +267,7 @@ build_vbase_path (code, type, expr, path, nonnull)\n \t\t  ind = build_indirect_ref (nonnull_expr, NULL_PTR);\n \t\t  nonnull_expr = build_vbase_pointer (ind, last_virtual);\n \t\t  if (nonnull == 0\n-\t\t      && (TREE_CODE (type) == POINTER_TYPE\n-\t\t\t  || !flag_assume_nonnull_objects)\n+\t\t      && TREE_CODE (type) == POINTER_TYPE\n \t\t      && null_expr == NULL_TREE)\n \t\t    {\n \t\t      null_expr = build1 (NOP_EXPR, build_pointer_type (last_virtual), integer_zero_node);\n@@ -2812,8 +2811,7 @@ check_for_override (decl, ctype)\n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      if (TYPE_VIRTUAL_P (BINFO_TYPE (base_binfo))\n-\t  || flag_all_virtual == 1)\n+      if (TYPE_VIRTUAL_P (BINFO_TYPE (base_binfo)))\n \t{\n \t  tree tmp = get_matching_virtual\n \t    (base_binfo, decl,\n@@ -3012,37 +3010,7 @@ extern int interface_only, interface_unknown;\n    TREE_LIST elements, whose TREE_PURPOSE field tells what access\n    the list has, and the TREE_VALUE slot gives the actual fields.\n \n-   ATTRIBUTES is the set of decl attributes to be applied, if any.\n-\n-   If flag_all_virtual == 1, then we lay all functions into\n-   the virtual function table, as though they were declared\n-   virtual.  Constructors do not lay down in the virtual function table.\n-\n-   If flag_all_virtual == 2, then we lay all functions into\n-   the virtual function table, such that virtual functions\n-   occupy a space by themselves, and then all functions\n-   of the class occupy a space by themselves.  This is illustrated\n-   in the following diagram:\n-\n-   class A; class B : A;\n-\n-\tClass A's vtbl:\t\t\tClass B's vtbl:\n-    --------------------------------------------------------------------\n-   | A's virtual functions|\t\t| B's virtual functions\t\t|\n-   |\t\t\t  |\t\t| (may inherit some from A).\t|\n-    --------------------------------------------------------------------\n-   | All of A's functions |\t\t| All of A's functions\t\t|\n-   | (such as a->A::f).\t  |\t\t| (such as b->A::f)\t\t|\n-    --------------------------------------------------------------------\n-\t\t\t\t\t| B's new virtual functions\t|\n-\t\t\t\t\t| (not defined in A.)\t\t|\n-\t\t\t\t\t -------------------------------\n-\t\t\t\t\t| All of B's functions\t\t|\n-\t\t\t\t\t| (such as b->B::f)\t\t|\n-\t\t\t\t\t -------------------------------\n-\n-   this allows the program to make references to any function, virtual\n-   or otherwise in a type-consistent manner.  */\n+   ATTRIBUTES is the set of decl attributes to be applied, if any.  */\n \n tree\n finish_struct_1 (t, warn_anon)\n@@ -3055,7 +3023,6 @@ finish_struct_1 (t, warn_anon)\n   tree fields = TYPE_FIELDS (t);\n   tree fn_fields = TYPE_METHODS (t);\n   tree x, last_x, method_vec;\n-  int all_virtual;\n   int has_virtual;\n   int max_has_virtual;\n   tree pending_virtuals = NULL_TREE;\n@@ -3173,13 +3140,6 @@ finish_struct_1 (t, warn_anon)\n   CLASSTYPE_VFIELDS (t) = vfields;\n   CLASSTYPE_VFIELD (t) = vfield;\n \n-  if (IS_SIGNATURE (t))\n-    all_virtual = 0;\n-  else if (flag_all_virtual == 1)\n-    all_virtual = 1;\n-  else\n-    all_virtual = 0;\n-\n   for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n       GNU_xref_member (current_class_name, x);\n@@ -3205,8 +3165,7 @@ finish_struct_1 (t, warn_anon)\n \n       /* The name of the field is the original field name\n \t Save this in auxiliary field for later overloading.  */\n-      if (DECL_VINDEX (x)\n-\t  || (all_virtual == 1 && ! DECL_CONSTRUCTOR_P (x)))\n+      if (DECL_VINDEX (x))\n \t{\n \t  add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n \t\t\t\t&has_virtual, x, t);"}, {"sha": "e4b07be0ad996660df74975a029a8c30a09b17f3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "patch": "@@ -2186,24 +2186,11 @@ struct pending_inline\n /* in method.c */\n extern struct pending_inline *pending_inlines;\n \n-/* 1 for -fall-virtual: make every member function (except\n-   constructors) lay down in the virtual function table.\n-   Calls can then either go through the virtual function table or not,\n-   depending on whether we know what function will actually be called.  */\n-\n-extern int flag_all_virtual;\n-\n /* Positive values means that we cannot make optimizing assumptions about\n    `this'.  Negative values means we know `this' to be of static type.  */\n \n extern int flag_this_is_variable;\n \n-/* Controls whether enums and ints freely convert.\n-   1 means with complete freedom.\n-   0 means enums can convert to ints, but not vice-versa.  */\n-\n-extern int flag_int_enum_equivalence;\n-\n /* Nonzero means generate 'rtti' that give run-time type information.  */\n \n extern int flag_rtti;\n@@ -2564,7 +2551,6 @@ extern void cat_namespace_levels                PROTO((void));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree, tree));\n-extern int flag_assume_nonnull_objects;\n extern int lang_decode_option\t\t\tPROTO((int, char **));\n extern tree grok_method_quals\t\t\tPROTO((tree, tree, tree));\n extern void warn_if_unknown_interface\t\tPROTO((tree));\n@@ -2879,6 +2865,7 @@ extern void reinit_search_statistics\t\tPROTO((void));\n extern tree current_scope\t\t\tPROTO((void));\n extern tree lookup_conversions\t\t\tPROTO((tree));\n extern tree get_template_base\t\t\tPROTO((tree, tree));\n+extern tree binfo_for_vtable\t\t\tPROTO((tree));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PROTO((tree));"}, {"sha": "7a07282a423680c47e16b566658f3ca526283c4f", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "patch": "@@ -700,8 +700,7 @@ ocp_convert (type, expr, convtype, flags)\n       tree intype = TREE_TYPE (e);\n       /* enum = enum, enum = int, enum = float, (enum)pointer are all\n          errors.  */\n-      if (flag_int_enum_equivalence == 0\n-\t  && TREE_CODE (type) == ENUMERAL_TYPE\n+      if (TREE_CODE (type) == ENUMERAL_TYPE\n \t  && ((ARITHMETIC_TYPE_P (intype) && ! (convtype & CONV_STATIC))\n \t      || (TREE_CODE (intype) == POINTER_TYPE)))\n \t{"}, {"sha": "3345b83a69dd7282358061584b3191a22168e338", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "patch": "@@ -330,13 +330,6 @@ int flag_labels_ok;\n int flag_detailed_statistics;\n \n /* C++ specific flags.  */   \n-/* Nonzero for -fall-virtual: make every member function (except\n-   constructors) lay down in the virtual function table.  Calls\n-   can then either go through the virtual function table or not,\n-   depending.  */\n-\n-int flag_all_virtual;\n-\n /* Zero means that `this' is a *const.  This gives nice behavior in the\n    2.0 world.  1 gives 1.2-compatible behavior.  2 gives Spring behavior.\n    -2 means we're constructing an object and it has fixed type.  */\n@@ -363,11 +356,6 @@ int flag_handle_signatures;\n \n int flag_default_inline = 1;\n \n-/* Controls whether enums and ints freely convert.\n-   1 means with complete freedom.\n-   0 means enums can convert to ints, but not vice-versa.  */\n-int flag_int_enum_equivalence;\n-\n /* Controls whether compiler generates 'type descriptor' that give\n    run-time type information.  */\n int flag_rtti = 1;\n@@ -376,18 +364,6 @@ int flag_rtti = 1;\n    for the GNU class browser.  */\n extern int flag_gnu_xref;\n \n-/* Nonzero if compiler can make `reasonable' assumptions about\n-   references and objects.  For example, the compiler must be\n-   conservative about the following and not assume that `a' is nonnull:\n-\n-   obj &a = g ();\n-   a.f (2);\n-\n-   In general, it is `reasonable' to assume that for many programs,\n-   and better code can be generated in that case.  */\n-\n-int flag_assume_nonnull_objects = 1;\n-\n /* Nonzero if we want to support huge (> 2^(sizeof(short)*8-1) bytes)\n    objects.  */\n \n@@ -482,17 +458,14 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"stats\", &flag_detailed_statistics, 1},\n   {\"this-is-variable\", &flag_this_is_variable, 1},\n   {\"strict-prototype\", &flag_strict_prototype, 1},\n-  {\"all-virtual\", &flag_all_virtual, 1},\n   {\"elide-constructors\", &flag_elide_constructors, 1},\n   {\"handle-exceptions\", &flag_exceptions, 1},\n   {\"handle-signatures\", &flag_handle_signatures, 1},\n   {\"default-inline\", &flag_default_inline, 1},\n   {\"dollars-in-identifiers\", &dollars_in_ident, 1},\n-  {\"enum-int-equiv\", &flag_int_enum_equivalence, 1},\n   {\"honor-std\", &flag_honor_std, 1},\n   {\"rtti\", &flag_rtti, 1},\n   {\"xref\", &flag_gnu_xref, 1},\n-  {\"nonnull-objects\", &flag_assume_nonnull_objects, 1},\n   {\"implement-inlines\", &flag_implement_inlines, 1},\n   {\"external-templates\", &flag_external_templates, 1},\n   {\"implicit-templates\", &flag_implicit_templates, 1},\n@@ -557,11 +530,23 @@ lang_decode_option (argc, argv)\n       if (!strcmp (p, \"memoize-lookups\")\n \t  || !strcmp (p, \"no-memoize-lookups\")\n \t  || !strcmp (p, \"save-memoized\")\n-\t  || !strcmp (p, \"no-save-memoized\"))\n+\t  || !strcmp (p, \"no-save-memoized\")\n+\t  || !strcmp (p, \"no-all-virtual\")\n+\t  || !strcmp (p, \"no-enum-int-equiv\")\n+\t  || !strcmp (p, \"nonnull-objects\")\n+          || !strcmp (p, \"ansi-overloading\"))\n \t{\n \t  /* ignore */\n \t  found = 1;\n \t}\n+      else if (!strcmp (p, \"all-virtual\")\n+\t       || !strcmp (p, \"enum-int-equiv\")\n+\t       || !strcmp (p, \"no-nonnull-objects\")\n+\t       || !strcmp (p, \"no-ansi-overloading\"))\n+\t{\n+\t  warning (\"-f%s is no longer supported\", p);\n+\t  found = 1;\n+\t}\n       else if (! strcmp (p, \"alt-external-templates\"))\n \t{\n \t  flag_external_templates = 1;\n@@ -590,13 +575,6 @@ lang_decode_option (argc, argv)\n \t  flag_guiding_decls = 0;\n \t  found = 1;\n \t}\n-      else if (!strcmp (p, \"ansi-overloading\"))\n-\tfound = 1;\n-      else if (!strcmp (p, \"no-ansi-overloading\"))\n-\t{\n-\t  error (\"-fno-ansi-overloading is no longer supported\");\n-\t  found = 1;\n-\t}\n       else if (!strcmp (p, \"new-abi\"))\n \t{\n \t  flag_new_abi = 1;"}, {"sha": "50ab3e6d14403a777a548f4130c36055d6e2fe74", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84663f74ca6bcc9bb2962e6e07dd227e014f7e8e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=84663f74ca6bcc9bb2962e6e07dd227e014f7e8e", "patch": "@@ -3904,8 +3904,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  tree primop1 = get_narrower (op1, &unsignedp1);\n \n \t  /* Check for comparison of different enum types.  */\n-\t  if (flag_int_enum_equivalence == 0 \n-\t      && TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE \n+\t  if (TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE \n \t      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE \n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n \t         != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))"}]}