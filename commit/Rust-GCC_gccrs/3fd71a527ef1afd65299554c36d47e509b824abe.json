{"sha": "3fd71a527ef1afd65299554c36d47e509b824abe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkNzFhNTI3ZWYxYWZkNjUyOTk1NTRjMzZkNDdlNTA5YjgyNGFiZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-02-17T18:58:59Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-02-17T18:58:59Z"}, "message": "decl.c (xref_basetypes): Comment.\n\n\t* decl.c (xref_basetypes): Comment.\n\t* pt.c (instantiate_class_template): Use xref_basetypes.\n\nFrom-SVN: r25272", "tree": {"sha": "69172dce38299462c22bab09dc1cd5670fa31869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69172dce38299462c22bab09dc1cd5670fa31869"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fd71a527ef1afd65299554c36d47e509b824abe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd71a527ef1afd65299554c36d47e509b824abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd71a527ef1afd65299554c36d47e509b824abe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd71a527ef1afd65299554c36d47e509b824abe/comments", "author": null, "committer": null, "parents": [{"sha": "176c720e2ca8694601e36568f5b8baa60848cdb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/176c720e2ca8694601e36568f5b8baa60848cdb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/176c720e2ca8694601e36568f5b8baa60848cdb3"}], "stats": {"total": 127, "additions": 87, "deletions": 40}, "files": [{"sha": "d7dc23563cdd8149a1a3d9a88a6c45493b156bff", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd71a527ef1afd65299554c36d47e509b824abe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd71a527ef1afd65299554c36d47e509b824abe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3fd71a527ef1afd65299554c36d47e509b824abe", "patch": "@@ -1,3 +1,8 @@\n+1999-02-17  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* decl.c (xref_basetypes): Comment.\n+\t* pt.c (instantiate_class_template): Use xref_basetypes.\n+\n 1999-02-16  Mark Mitchell  <mark@markmitchell.com>\n \n \t* cp-tree.h (tsubst): Change prototype."}, {"sha": "c5ffd2b8cf18322cd9aa9e705a2f0da1bf8ed45a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd71a527ef1afd65299554c36d47e509b824abe/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd71a527ef1afd65299554c36d47e509b824abe/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3fd71a527ef1afd65299554c36d47e509b824abe", "patch": "@@ -12357,6 +12357,12 @@ xref_tag_from_type (old, id, globalize)\n   return xref_tag (code_type_node, id, globalize);\n }\n \n+/* REF is a type (named NAME), for which we have just seen some\n+   baseclasses.  BINFO is a list of those baseclasses; the\n+   TREE_PURPOSE is an access_* node, and the TREE_VALUE is the type of\n+   the base-class.  CODE_TYPE_NODE indicates whether REF is a class,\n+   struct, or union.  */\n+\n void\n xref_basetypes (code_type_node, name, ref, binfo)\n      tree code_type_node;"}, {"sha": "49d948c68be2a4de29163b055e12af12aa7da019", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd71a527ef1afd65299554c36d47e509b824abe/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd71a527ef1afd65299554c36d47e509b824abe/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3fd71a527ef1afd65299554c36d47e509b824abe", "patch": "@@ -4688,53 +4688,64 @@ instantiate_class_template (type)\n      DECL_TI_ARGS of some instantiated member template.  */\n   args = copy_to_permanent (args);\n \n-  {\n-    tree binfo = TYPE_BINFO (type);\n-    tree pbases = TYPE_BINFO_BASETYPES (pattern);\n+  if (TYPE_BINFO_BASETYPES (pattern))\n+    {\n+      tree base_list = NULL_TREE;\n+      tree pbases = TYPE_BINFO_BASETYPES (pattern);\n+      int i;\n \n-    if (pbases)\n-      {\n-\ttree bases;\n-\tint i;\n-\tint len = TREE_VEC_LENGTH (pbases);\n-\tbases = make_tree_vec (len);\n-\tfor (i = 0; i < len; ++i)\n-\t  {\n-\t    tree elt, basetype;\n+      /* Substitute into each of the bases to determine the actual\n+\t basetypes.  */\n+      for (i = 0; i < TREE_VEC_LENGTH (pbases); ++i)\n+\t{\n+\t  tree base;\n+\t  tree access;\n+\t  tree pbase;\n \n-\t    TREE_VEC_ELT (bases, i) = elt\n-\t      = tsubst (TREE_VEC_ELT (pbases, i), args,\n-\t\t\t/*complain=*/1, NULL_TREE);\n-\t    BINFO_INHERITANCE_CHAIN (elt) = binfo;\n+\t  pbase = TREE_VEC_ELT (pbases, i);\n \n-\t    basetype = TREE_TYPE (elt);\n+\t  /* Substitue to figure out the base class.  */\n+\t  base = tsubst (BINFO_TYPE (pbase), args, \n+\t\t\t /*complain=*/1, NULL_TREE);\n+\t  if (base == error_mark_node)\n+\t    continue;\n \n-\t    if (! IS_AGGR_TYPE (basetype))\n-\t      cp_error\n-\t\t(\"base type `%T' of `%T' fails to be a struct or class type\",\n-\t\t basetype, type);\n-\t    else if (TYPE_SIZE (complete_type (basetype)) == NULL_TREE)\n-\t      cp_error (\"base class `%T' of `%T' has incomplete type\",\n-\t\t\tbasetype, type);\n+\t  /* Calculate the correct access node.  */\n+\t  if (TREE_VIA_VIRTUAL (pbase)) \n+\t    {\n+\t      if (TREE_VIA_PUBLIC (pbase))\n+\t\taccess = access_public_virtual_node;\n+\t      else if (TREE_VIA_PROTECTED (pbase))\n+\t\taccess = access_protected_virtual_node;\n+\t      else if (TREE_VIA_PRIVATE (pbase))\n+\t\taccess = access_private_virtual_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (TREE_VIA_PUBLIC (pbase))\n+\t\taccess = access_public_node;\n+\t      else if (TREE_VIA_PROTECTED (pbase))\n+\t\taccess = access_protected_node;\n+\t      else if (TREE_VIA_PRIVATE (pbase))\n+\t\taccess = access_private_node;\n+\t    }\n \n-\t    /* These are set up in xref_basetypes for normal classes, so\n-\t       we have to handle them here for template bases.  */\n+\t  base_list = tree_cons (access, base, base_list);\n+\t}\n \n-\t    unshare_base_binfos (elt);\n+      /* The list is now in reverse order; correct that.  */\n+      base_list = nreverse (base_list);\n \n-\t    if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-\t      {\n-\t\tTYPE_USES_VIRTUAL_BASECLASSES (type) = 1;\n-\t\tTYPE_USES_COMPLEX_INHERITANCE (type) = 1;\n-\t      }\n-\t    TYPE_GETS_NEW (type) |= TYPE_GETS_NEW (basetype);\n-\t    TYPE_GETS_DELETE (type) |= TYPE_GETS_DELETE (basetype);\n-\t  }\n-\t/* Don't initialize this until the vector is filled out, or\n-\t   lookups will crash.  */\n-\tBINFO_BASETYPES (binfo) = bases;\n-      }\n-  }\n+      /* Now call xref_basetypes to set up all the base-class\n+\t information.  */\n+      xref_basetypes (TREE_CODE (pattern) == RECORD_TYPE\n+\t\t      ? (CLASSTYPE_DECLARED_CLASS (pattern)\n+\t\t\t ? class_type_node : record_type_node)\n+\t\t      : union_type_node,\n+\t\t      DECL_NAME (TYPE_NAME (pattern)),\n+\t\t      type,\n+\t\t      base_list);\n+    }\n \n   for (t = CLASSTYPE_TAGS (pattern); t; t = TREE_CHAIN (t))\n     {"}, {"sha": "6ae70c1bb9e3374c14c6c0bc2912b2456f95204d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/inherit1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd71a527ef1afd65299554c36d47e509b824abe/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finherit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd71a527ef1afd65299554c36d47e509b824abe/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finherit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finherit1.C?ref=3fd71a527ef1afd65299554c36d47e509b824abe", "patch": "@@ -0,0 +1,25 @@\n+// Origin: Wolfgang Bangerth <wolf@gaia.iwr.uni-heidelberg.de>\n+\n+int i = 1;\n+\n+struct Base1 {  int local1;  };\n+struct Base2 {  int local2;  };\n+\n+template <int dim> class Derived;\n+\n+template <>\n+class Derived<1> : public Base1, public Base2 {};\n+\n+template <int dim>\n+class FinalClass :  public Derived<dim> {\n+public:\n+  FinalClass () {\n+    if (&local1 != &local2)\n+      i = 0;\n+  }\n+};\n+\n+int main () {\n+  FinalClass<1> a1;\n+  return i;\n+}"}]}