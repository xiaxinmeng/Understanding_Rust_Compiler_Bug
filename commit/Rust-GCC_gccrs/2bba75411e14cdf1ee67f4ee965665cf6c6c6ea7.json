{"sha": "2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJiYTc1NDExZTE0Y2RmMWVlNjdmNGVlOTY1NjY1Y2Y2YzZjNmVhNw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-05-02T12:49:55Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-05-02T12:49:55Z"}, "message": "[PR 78687] Set SRA grp_write lazily \n\n2017-05-02  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/78687\n\t* tree-sra.c (access): New field parent.\n\t(process_subtree_disqualification): New function.\n\t(disqualify_candidate): Call it.\n\t(build_accesses_from_assign): Reset write flag if creating an\n\tassighnment link.\n\t(build_access_subtree): Fill in parent field and also prpagate\n\tdown grp_write flag.\n\t(create_artificial_child_access): New parameter set_grp_write, set\n\tgrp_write to its value.\n\t(propagate_subaccesses_across_link): Also propagate grp_write flag\n\tvalues.\n\t(propagate_all_subaccesses): Push the closest parent back to work\n\tqueue if add_access_to_work_queue returned true.\n\ntestsuite/\n\t* g++.dg/tree-ssa/pr78687.C: New test.\n\nFrom-SVN: r247497", "tree": {"sha": "daaf9a73b62e3430dc79e23fa0d3062bcf282693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daaf9a73b62e3430dc79e23fa0d3062bcf282693"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2bf54d93f159210d0c05a07c655eb847c069365c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf54d93f159210d0c05a07c655eb847c069365c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf54d93f159210d0c05a07c655eb847c069365c"}], "stats": {"total": 596, "additions": 583, "deletions": 13}, "files": [{"sha": "22c7c61e1f562cd36e81e3d707000868287c8c39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7", "patch": "@@ -1,3 +1,20 @@\n+2017-05-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/78687\n+\t* tree-sra.c (access): New field parent.\n+\t(process_subtree_disqualification): New function.\n+\t(disqualify_candidate): Call it.\n+\t(build_accesses_from_assign): Reset write flag if creating an\n+\tassighnment link.\n+\t(build_access_subtree): Fill in parent field and also prpagate\n+\tdown grp_write flag.\n+\t(create_artificial_child_access): New parameter set_grp_write, set\n+\tgrp_write to its value.\n+\t(propagate_subaccesses_across_link): Also propagate grp_write flag\n+\tvalues.\n+\t(propagate_all_subaccesses): Push the closest parent back to work\n+\tqueue if add_access_to_work_queue returned true.\n+\n 2017-05-02  Richard Biener  <rguenther@suse.de>\n \n \t* common.opt (fstrict-overflow): Alias negative to fwrapv."}, {"sha": "81ecd07d6de282bdf2a7a40ac7d3c3095a2e447c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7", "patch": "@@ -1,3 +1,8 @@\n+2017-05-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/78687\n+\t* g++.dg/tree-ssa/pr78687.C: New test.\n+\n 2017-05-02  Richard Biener  <rguenther@suse.de>\n \n \t* c-c++-common/Wlogical-op-1.c: Add -fwrapv to restore previous"}, {"sha": "698458f0e9a5f1f9a92601027075bc5b330a2699", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr78687.C", "status": "added", "additions": 483, "deletions": 0, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr78687.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr78687.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr78687.C?ref=2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7", "patch": "@@ -0,0 +1,483 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -std=gnu++14 -fdump-tree-sra\" } */\n+\n+#include <utility>\n+\n+#define EGGS_CXX11_CONSTEXPR constexpr\n+#define EGGS_CXX11_STATIC_CONSTEXPR static constexpr\n+#define EGGS_CXX14_CONSTEXPR constexpr\n+#define EGGS_CXX11_NOEXCEPT noexcept\n+\n+namespace eggs { namespace variants { namespace detail\n+{\n+    struct empty\n+    {\n+        EGGS_CXX11_CONSTEXPR bool operator==(empty) const { return true; }\n+        EGGS_CXX11_CONSTEXPR bool operator<(empty) const { return false; }\n+    };\n+\n+    template <typename T>\n+    struct identity\n+    {\n+        using type = T;\n+    };\n+\n+    template <std::size_t I>\n+    struct index\n+    {\n+        EGGS_CXX11_STATIC_CONSTEXPR std::size_t value = I;\n+    };\n+\n+    template <typename ...Ts>\n+    struct pack\n+    {\n+        using type = pack;\n+        EGGS_CXX11_STATIC_CONSTEXPR std::size_t size = sizeof...(Ts);\n+    };\n+\n+    template <typename T, T ...Vs>\n+    struct pack_c\n+    {\n+        using type = pack_c;\n+        EGGS_CXX11_STATIC_CONSTEXPR std::size_t size = sizeof...(Vs);\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    template <typename Is, bool Odd>\n+    struct _make_index_pack_twice;\n+\n+    template <std::size_t ...Is>\n+    struct _make_index_pack_twice<\n+        pack_c<std::size_t, Is...>\n+      , false\n+    > : pack_c<std::size_t, Is..., (sizeof...(Is) + Is)...>\n+    {};\n+\n+    template <std::size_t ...Is>\n+    struct _make_index_pack_twice<\n+        pack_c<std::size_t, Is...>\n+      , true\n+    > : pack_c<std::size_t, Is..., (sizeof...(Is) + Is)..., sizeof...(Is) * 2>\n+    {};\n+\n+    template <std::size_t N>\n+    struct _make_index_pack\n+      : _make_index_pack_twice<\n+            typename _make_index_pack<N / 2>::type\n+          , N % 2 != 0\n+        >\n+    {};\n+\n+    template <>\n+    struct _make_index_pack<1>\n+      : pack_c<std::size_t, 0>\n+    {};\n+\n+    template <>\n+    struct _make_index_pack<0>\n+      : pack_c<std::size_t>\n+    {};\n+\n+    template <std::size_t N>\n+    using make_index_pack = typename _make_index_pack<N>::type;\n+\n+    template <typename Ts>\n+    struct _index_pack;\n+\n+    template <typename ...Ts>\n+    struct _index_pack<pack<Ts...>>\n+      : _make_index_pack<sizeof...(Ts)>\n+    {};\n+\n+    template <typename Ts>\n+    using index_pack = typename _index_pack<Ts>::type;\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    template <typename Vs>\n+    struct all_of;\n+\n+    template <bool ...Vs>\n+    struct all_of<pack_c<bool, Vs...>>\n+      : std::integral_constant<\n+            bool\n+          , std::is_same<\n+                pack_c<bool, Vs...>\n+              , pack_c<bool, (Vs || true)...> // true...\n+            >::value\n+        >\n+    {};\n+\n+    template <typename ...Ts>\n+    struct all_of<pack<Ts...>>\n+      : all_of<pack_c<bool, (Ts::value)...>>\n+    {};\n+\n+    template <typename ...Vs>\n+    struct any_of;\n+\n+    template <bool ...Vs>\n+    struct any_of<pack_c<bool, Vs...>>\n+      : std::integral_constant<\n+            bool\n+          , !all_of<pack_c<bool, !Vs...>>::value\n+        >\n+    {};\n+\n+    template <typename ...Ts>\n+    struct any_of<pack<Ts...>>\n+      : any_of<pack_c<bool, (Ts::value)...>>\n+    {};\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    template <std::size_t I, typename T>\n+    struct _indexed {};\n+\n+    template <typename Ts, typename Is = index_pack<Ts>>\n+    struct _indexer;\n+\n+    template <typename ...Ts, std::size_t ...Is>\n+    struct _indexer<pack<Ts...>, pack_c<std::size_t, Is...>>\n+      : _indexed<Is, Ts>...\n+    {};\n+\n+    empty _at_index(...);\n+\n+    template <std::size_t I, typename T>\n+    identity<T> _at_index(_indexed<I, T> const&);\n+\n+    template <std::size_t I, typename Ts>\n+    struct at_index\n+      : decltype(_at_index<I>(_indexer<Ts>{}))\n+    {};\n+\n+    empty _index_of(...);\n+\n+    template <typename T, std::size_t I>\n+    index<I> _index_of(_indexed<I, T> const&);\n+\n+    template <typename T, typename Ts>\n+    struct index_of\n+      : decltype(_index_of<T>(_indexer<Ts>{}))\n+    {};\n+}}}\n+\n+namespace eggs { namespace variants { namespace detail\n+{\n+    template <typename Ts, bool IsTriviallyDestructible>\n+    struct _union;\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    template <bool IsTriviallyDestructible>\n+    struct _union<pack<>, IsTriviallyDestructible>\n+    {};\n+\n+    template <typename T, typename ...Ts>\n+    struct _union<pack<T, Ts...>, true>\n+    {\n+        EGGS_CXX11_STATIC_CONSTEXPR std::size_t size = 1 + sizeof...(Ts);\n+\n+        template <typename ...Args>\n+        EGGS_CXX11_CONSTEXPR _union(index<0>, Args&&... args)\n+          : _head(std::forward<Args>(args)...)\n+        {}\n+\n+        template <std::size_t I, typename ...Args>\n+        EGGS_CXX11_CONSTEXPR _union(index<I>, Args&&... args)\n+          : _tail(index<I - 1>{}, std::forward<Args>(args)...)\n+        {}\n+\n+        EGGS_CXX14_CONSTEXPR void* target() EGGS_CXX11_NOEXCEPT\n+        {\n+            return &_target;\n+        }\n+\n+        EGGS_CXX11_CONSTEXPR void const* target() const EGGS_CXX11_NOEXCEPT\n+        {\n+            return &_target;\n+        }\n+\n+        EGGS_CXX14_CONSTEXPR T& get(index<0>) EGGS_CXX11_NOEXCEPT\n+        {\n+            return this->_head;\n+        }\n+\n+        EGGS_CXX11_CONSTEXPR T const& get(index<0>) const EGGS_CXX11_NOEXCEPT\n+        {\n+            return this->_head;\n+        }\n+\n+        template <\n+            std::size_t I\n+          , typename U = typename at_index<I, pack<T, Ts...>>::type\n+        >\n+        EGGS_CXX14_CONSTEXPR U& get(index<I>) EGGS_CXX11_NOEXCEPT\n+        {\n+            return this->_tail.get(index<I - 1>{});\n+        }\n+\n+        template <\n+            std::size_t I\n+          , typename U = typename at_index<I, pack<T, Ts...>>::type\n+        >\n+        EGGS_CXX11_CONSTEXPR U const& get(index<I>) const EGGS_CXX11_NOEXCEPT\n+        {\n+            return this->_tail.get(index<I - 1>{});\n+        }\n+\n+    private:\n+        union\n+        {\n+            char _target;\n+            T _head;\n+            _union<pack<Ts...>, true> _tail;\n+        };\n+    };\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    template <typename Ts, bool TriviallyCopyable, bool TriviallyDestructible>\n+    struct _storage;\n+\n+    template <typename ...Ts>\n+    struct _storage<pack<Ts...>, true, true>\n+      : _union<\n+            pack<Ts...>\n+          , all_of<pack<std::is_trivially_destructible<Ts>...>>::value\n+        >\n+    {\n+        using base_type = _union<\n+            pack<Ts...>\n+          , all_of<pack<std::is_trivially_destructible<Ts>...>>::value\n+        >;\n+\n+        EGGS_CXX11_CONSTEXPR _storage() EGGS_CXX11_NOEXCEPT\n+          : base_type{index<0>{}}\n+          , _which{0}\n+        {}\n+\n+        _storage(_storage const& rhs) = default;\n+        _storage(_storage&& rhs) = default;\n+\n+        template <std::size_t I, typename ...Args>\n+        EGGS_CXX11_CONSTEXPR _storage(index<I> which, Args&&... args)\n+          : base_type{which, std::forward<Args>(args)...}\n+          , _which{I}\n+        {}\n+\n+        _storage& operator=(_storage const& rhs) = default;\n+        _storage& operator=(_storage&& rhs) = default;\n+\n+        EGGS_CXX11_CONSTEXPR std::size_t which() const\n+        {\n+            return _which;\n+        }\n+\n+        using base_type::target;\n+        using base_type::get;\n+\n+    protected:\n+        std::size_t _which;\n+    };\n+\n+    template <typename ...Ts>\n+    using storage = _storage<\n+        pack<empty, Ts...>\n+      , all_of<pack<std::is_trivially_copyable<Ts>...>>::value\n+      , all_of<pack<std::is_trivially_destructible<Ts>...>>::value\n+    >;\n+}}}\n+\n+namespace eggs { namespace variants\n+{\n+    template <typename ...Ts>\n+    class variant;\n+\n+    namespace detail\n+    {\n+        ///////////////////////////////////////////////////////////////////////\n+        namespace _best_match\n+        {\n+            template <typename Ts, std::size_t I = 0>\n+            struct overloads\n+            {};\n+\n+            template <typename T, typename ...Ts, std::size_t I>\n+            struct overloads<pack<T, Ts...>, I>\n+              : overloads<pack<Ts...>, I + 1>\n+            {\n+                using fun_ptr = index<I>(*)(T);\n+                operator fun_ptr();\n+            };\n+\n+            template <typename F, typename T>\n+            auto _invoke(F&&, T&&)\n+             -> decltype(std::declval<F>()(std::declval<T>()));\n+\n+            struct _fallback {};\n+\n+            _fallback _invoke(...);\n+\n+            template <\n+                typename T, typename U\n+              , typename R = decltype(_best_match::_invoke(\n+                    std::declval<T>(), std::declval<U>()))\n+            >\n+            struct result_of : R\n+            {};\n+\n+            template <typename T, typename U>\n+            struct result_of<T, U, _fallback>\n+            {};\n+        }\n+\n+        template <typename U, typename ...Ts>\n+        struct index_of_best_match\n+          : _best_match::result_of<_best_match::overloads<Ts...>, U>\n+        {};\n+\n+    }\n+\n+    template <typename ...Ts>\n+    class variant\n+    {\n+\n+    public:\n+        EGGS_CXX11_CONSTEXPR variant() EGGS_CXX11_NOEXCEPT = delete;\n+\n+        variant(variant const& rhs) = default;\n+\n+        variant(variant&& rhs) = default;\n+\n+        template <\n+            typename U\n+          , typename Enable = typename std::enable_if<!std::is_same<\n+                typename std::decay<U>::type, variant\n+            >::value>::type\n+          , std::size_t I = detail::index_of_best_match<\n+                U&&, detail::pack<Ts...>>::value\n+          , typename T = typename detail::at_index<\n+                I, detail::pack<Ts...>>::type\n+        >\n+        EGGS_CXX11_CONSTEXPR variant(U&& v)\n+            noexcept(\n+                std::is_nothrow_constructible<T, U&&>::value)\n+          : _storage{detail::index<I + 1>{}, std::forward<U>(v)}\n+        {}\n+\n+        ~variant() = default;\n+        variant& operator=(variant const& rhs) = delete;\n+\n+    private:\n+        detail::storage<Ts...> _storage;\n+    };\n+}}\n+\n+template <class T, class Base>\n+struct ref_proxy : Base\n+{\n+    using Base::Base;\n+\n+    ref_proxy()\n+        : Base()\n+    {\n+    }\n+\n+    ref_proxy(Base ptr)\n+        : Base(std::move(ptr))\n+    {\n+    }\n+};\n+\n+template <class T>\n+struct inplace_ref\n+{\n+    explicit inplace_ref(T inner)\n+        : inner_(inner)\n+    {\n+    }\n+\n+    T inner_;\n+};\n+\n+template <class ...Variants>\n+struct variant_ref\n+{\n+    variant_ref() = delete;\n+\n+    explicit variant_ref(eggs::variants::variant<Variants...> t)\n+        : inner_storage_(t)\n+    {\n+    }\n+\n+    template <class Source>\n+    variant_ref(ref_proxy<Source, variant_ref> ptr)\n+        : inner_storage_(ptr.inner_storage_)\n+    {}\n+\n+private:\n+    eggs::variants::variant<Variants...> inner_storage_;\n+};\n+\n+struct option_1\n+{\n+    void *a, *b, *c, *d, *e;\n+};\n+\n+struct option_2\n+{\n+};\n+\n+using option_ref = variant_ref<option_1, option_2>;\n+\n+\n+struct qual_option\n+{\n+    qual_option(ref_proxy<void, option_ref > type, int quals)\n+        : type_(type)\n+        , quals_(quals)\n+    {\n+    }\n+\n+    explicit qual_option(ref_proxy<void, option_ref > type)\n+        : qual_option(type, 0)\n+    {\n+    }\n+\n+    ref_proxy<void, option_ref > type_;\n+    int quals_;\n+};\n+\n+inline ref_proxy<option_2, option_ref > make_object_1()\n+{\n+    return ref_proxy<option_2, option_ref >(option_2());\n+}\n+\n+inline ref_proxy<option_2, option_ref > make_object_2()\n+{\n+    return make_object_1();\n+}\n+\n+inline inplace_ref<qual_option> make_object_3(ref_proxy<option_2, option_ref>&& a0)\n+{\n+    return inplace_ref<qual_option>(qual_option(a0));\n+}\n+\n+inline ref_proxy<qual_option, inplace_ref<qual_option> > make_object_4(ref_proxy<option_2, option_ref>&& a0)\n+{\n+    return make_object_3(std::move(a0));\n+}\n+\n+\n+ref_proxy<qual_option, inplace_ref<qual_option> > f() __attribute__((noinline));\n+\n+ref_proxy<qual_option, inplace_ref<qual_option> > f()\n+{\n+    return make_object_4(make_object_2());\n+}\n+\n+int main(int argc, char* argv[])\n+{\n+    for (;;)\n+        f();\n+}\n+\n+/* { dg-final { scan-tree-dump \"Removing load:.*ptr;\" \"sra\" } } */"}, {"sha": "1606573aeadcf3d3901493d39b5ba4c3d37aa35e", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 78, "deletions": 13, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=2bba75411e14cdf1ee67f4ee965665cf6c6c6ea7", "patch": "@@ -158,6 +158,10 @@ struct access\n      the representative.  */\n   struct access *group_representative;\n \n+  /* After access tree has been constructed, this points to the parent of the\n+     current access, if there is one.  NULL for roots.  */\n+  struct access *parent;\n+\n   /* If this access has any children (in terms of the definition above), this\n      points to the first one.  */\n   struct access *first_child;\n@@ -690,6 +694,19 @@ static bool constant_decl_p (tree decl)\n   return VAR_P (decl) && DECL_IN_CONSTANT_POOL (decl);\n }\n \n+\n+/* Mark LHS of assign links out of ACCESS and its children as written to.  */\n+\n+static void\n+process_subtree_disqualification (struct access *access)\n+{\n+  struct access *child;\n+  for (struct assign_link *link = access->first_link; link; link = link->next)\n+    link->lacc->grp_write = true;\n+  for (child = access->first_child; child; child = child->next_sibling)\n+    process_subtree_disqualification (child);\n+}\n+\n /* Remove DECL from candidates for SRA and write REASON to the dump file if\n    there is one.  */\n static void\n@@ -706,6 +723,13 @@ disqualify_candidate (tree decl, const char *reason)\n       print_generic_expr (dump_file, decl, 0);\n       fprintf (dump_file, \" - %s\\n\", reason);\n     }\n+\n+  struct access *access = get_first_repr_for_decl (decl);\n+  while (access)\n+    {\n+      process_subtree_disqualification (access);\n+      access = access->next_grp;\n+    }\n }\n \n /* Return true iff the type contains a field or an element which does not allow\n@@ -1338,8 +1362,10 @@ build_accesses_from_assign (gimple *stmt)\n \n       link->lacc = lacc;\n       link->racc = racc;\n-\n       add_link_to_rhs (racc, link);\n+      /* Let's delay marking the areas as written until propagation of accesses\n+\t across link.  */\n+      lacc->write = false;\n     }\n \n   return lacc || racc;\n@@ -2252,6 +2278,8 @@ build_access_subtree (struct access **access)\n       else\n \tlast_child->next_sibling = *access;\n       last_child = *access;\n+      (*access)->parent = root;\n+      (*access)->grp_write |= root->grp_write;\n \n       if (!build_access_subtree (access))\n \treturn false;\n@@ -2495,13 +2523,15 @@ child_would_conflict_in_lacc (struct access *lacc, HOST_WIDE_INT norm_offset,\n \n /* Create a new child access of PARENT, with all properties just like MODEL\n    except for its offset and with its grp_write false and grp_read true.\n-   Return the new access or NULL if it cannot be created.  Note that this access\n-   is created long after all splicing and sorting, it's not located in any\n-   access vector and is automatically a representative of its group.  */\n+   Return the new access or NULL if it cannot be created.  Note that this\n+   access is created long after all splicing and sorting, it's not located in\n+   any access vector and is automatically a representative of its group.  Set\n+   the gpr_write flag of the new accesss if SET_GRP_WRITE is true.  */\n \n static struct access *\n create_artificial_child_access (struct access *parent, struct access *model,\n-\t\t\t\tHOST_WIDE_INT new_offset)\n+\t\t\t\tHOST_WIDE_INT new_offset,\n+\t\t\t\tbool set_grp_write)\n {\n   struct access **child;\n   tree expr = parent->base;\n@@ -2523,7 +2553,7 @@ create_artificial_child_access (struct access *parent, struct access *model,\n   access->offset = new_offset;\n   access->size = model->size;\n   access->type = model->type;\n-  access->grp_write = true;\n+  access->grp_write = set_grp_write;\n   access->grp_read = false;\n   access->reverse = model->reverse;\n \n@@ -2549,10 +2579,23 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n   HOST_WIDE_INT norm_delta = lacc->offset - racc->offset;\n   bool ret = false;\n \n+  /* IF the LHS is still not marked as being written to, we only need to do so\n+     if the RHS at this level actually was.  */\n+  if (!lacc->grp_write &&\n+      (racc->grp_write || TREE_CODE (racc->base) == PARM_DECL))\n+    {\n+      lacc->grp_write = true;\n+      ret = true;\n+    }\n+\n   if (is_gimple_reg_type (lacc->type)\n       || lacc->grp_unscalarizable_region\n       || racc->grp_unscalarizable_region)\n-    return false;\n+    {\n+      ret |= !lacc->grp_write;\n+      lacc->grp_write = true;\n+      return ret;\n+    }\n \n   if (is_gimple_reg_type (racc->type))\n     {\n@@ -2572,7 +2615,7 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n \t      lacc->grp_no_warning = true;\n \t    }\n \t}\n-      return false;\n+      return ret;\n     }\n \n   for (rchild = racc->first_child; rchild; rchild = rchild->next_sibling)\n@@ -2581,23 +2624,37 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n       HOST_WIDE_INT norm_offset = rchild->offset + norm_delta;\n \n       if (rchild->grp_unscalarizable_region)\n-\tcontinue;\n+\t{\n+\t  lacc->grp_write = true;\n+\t  continue;\n+\t}\n \n       if (child_would_conflict_in_lacc (lacc, norm_offset, rchild->size,\n \t\t\t\t\t&new_acc))\n \t{\n \t  if (new_acc)\n \t    {\n+\t      if (!new_acc->grp_write\n+\t\t  && (lacc->grp_write || rchild->grp_write))\n+\t\t{\n+\t\t  new_acc ->grp_write = true;\n+\t\t  ret = true;\n+\t\t}\n+\n \t      rchild->grp_hint = 1;\n \t      new_acc->grp_hint |= new_acc->grp_read;\n \t      if (rchild->first_child)\n \t\tret |= propagate_subaccesses_across_link (new_acc, rchild);\n \t    }\n+\t  else\n+\t    lacc->grp_write = true;\n \t  continue;\n \t}\n \n       rchild->grp_hint = 1;\n-      new_acc = create_artificial_child_access (lacc, rchild, norm_offset);\n+      new_acc = create_artificial_child_access (lacc, rchild, norm_offset,\n+\t\t\t\t\t\tlacc->grp_write\n+\t\t\t\t\t\t|| rchild->grp_write);\n       if (new_acc)\n \t{\n \t  ret = true;\n@@ -2628,9 +2685,17 @@ propagate_all_subaccesses (void)\n \t  if (!bitmap_bit_p (candidate_bitmap, DECL_UID (lacc->base)))\n \t    continue;\n \t  lacc = lacc->group_representative;\n-\t  if (propagate_subaccesses_across_link (lacc, racc)\n-\t      && lacc->first_link)\n-\t    add_access_to_work_queue (lacc);\n+\t  if (propagate_subaccesses_across_link (lacc, racc))\n+\t    do\n+\t      {\n+\t\tif (lacc->first_link)\n+\t\t  {\n+\t\t    add_access_to_work_queue (lacc);\n+\t\t    break;\n+\t\t  }\n+\t\tlacc = lacc->parent;\n+\t      }\n+\t    while (lacc);\n \t}\n     }\n }"}]}