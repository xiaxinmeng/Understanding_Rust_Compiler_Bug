{"sha": "d0268b37f87359ebf5d6f8bd95fe9829b520749a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAyNjhiMzdmODczNTllYmY1ZDZmOGJkOTVmZTk4MjliNTIwNzQ5YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-02-01T22:39:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-02-01T22:39:31Z"}, "message": "re PR rtl-optimization/69592 (Compile-time and memory-use hog in combine)\n\n\tPR rtl-optimization/69592\n\t* rtlanal.c (nonzero_bits_binary_arith_p): New inline function.\n\t(cached_nonzero_bits): Use it instead of ARITHMETIC_P.\n\t(num_sign_bit_copies_binary_arith_p): New inline function.\n\t(cached_num_sign_bit_copies): Use it instead of ARITHMETIC_P.\n\n\t* gcc.dg/pr69592.c: New test.\n\nFrom-SVN: r233059", "tree": {"sha": "6d20c4dc8d9379e506a9c5f4d19e1a1aa2108f84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d20c4dc8d9379e506a9c5f4d19e1a1aa2108f84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0268b37f87359ebf5d6f8bd95fe9829b520749a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0268b37f87359ebf5d6f8bd95fe9829b520749a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0268b37f87359ebf5d6f8bd95fe9829b520749a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0268b37f87359ebf5d6f8bd95fe9829b520749a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1b81f2ba000a61a3d845f0d3bb038b62d43673f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b81f2ba000a61a3d845f0d3bb038b62d43673f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b81f2ba000a61a3d845f0d3bb038b62d43673f"}], "stats": {"total": 99, "additions": 93, "deletions": 6}, "files": [{"sha": "24939468c76a0634fa6f95e863ad269994faf7b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0268b37f87359ebf5d6f8bd95fe9829b520749a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0268b37f87359ebf5d6f8bd95fe9829b520749a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0268b37f87359ebf5d6f8bd95fe9829b520749a", "patch": "@@ -1,3 +1,11 @@\n+2016-02-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/69592\n+\t* rtlanal.c (nonzero_bits_binary_arith_p): New inline function.\n+\t(cached_nonzero_bits): Use it instead of ARITHMETIC_P.\n+\t(num_sign_bit_copies_binary_arith_p): New inline function.\n+\t(cached_num_sign_bit_copies): Use it instead of ARITHMETIC_P.\n+\n 2016-02-01  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/69580"}, {"sha": "642611fa91abb7659e0d967609ef9590ca924f80", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0268b37f87359ebf5d6f8bd95fe9829b520749a/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0268b37f87359ebf5d6f8bd95fe9829b520749a/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=d0268b37f87359ebf5d6f8bd95fe9829b520749a", "patch": "@@ -4163,6 +4163,36 @@ num_sign_bit_copies (const_rtx x, machine_mode mode)\n   return cached_num_sign_bit_copies (x, mode, NULL_RTX, VOIDmode, 0);\n }\n \n+/* Return true if nonzero_bits1 might recurse into both operands\n+   of X.  */\n+\n+static inline bool\n+nonzero_bits_binary_arith_p (const_rtx x)\n+{\n+  if (!ARITHMETIC_P (x))\n+    return false;\n+  switch (GET_CODE (x))\n+    {\n+    case AND:\n+    case XOR:\n+    case IOR:\n+    case UMIN:\n+    case UMAX:\n+    case SMIN:\n+    case SMAX:\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* The function cached_nonzero_bits is a wrapper around nonzero_bits1.\n    It avoids exponential behavior in nonzero_bits1 when X has\n    identical subexpressions on the first or the second level.  */\n@@ -4179,7 +4209,7 @@ cached_nonzero_bits (const_rtx x, machine_mode mode, const_rtx known_x,\n      nonzero_bits1 on X with the subexpressions as KNOWN_X and the\n      precomputed value for the subexpression as KNOWN_RET.  */\n \n-  if (ARITHMETIC_P (x))\n+  if (nonzero_bits_binary_arith_p (x))\n     {\n       rtx x0 = XEXP (x, 0);\n       rtx x1 = XEXP (x, 1);\n@@ -4191,13 +4221,13 @@ cached_nonzero_bits (const_rtx x, machine_mode mode, const_rtx known_x,\n \t\t\t\t\t\t   known_mode, known_ret));\n \n       /* Check the second level.  */\n-      if (ARITHMETIC_P (x0)\n+      if (nonzero_bits_binary_arith_p (x0)\n \t  && (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n \treturn nonzero_bits1 (x, mode, x1, mode,\n \t\t\t      cached_nonzero_bits (x1, mode, known_x,\n \t\t\t\t\t\t   known_mode, known_ret));\n \n-      if (ARITHMETIC_P (x1)\n+      if (nonzero_bits_binary_arith_p (x1)\n \t  && (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n \treturn nonzero_bits1 (x, mode, x0, mode,\n \t\t\t      cached_nonzero_bits (x0, mode, known_x,\n@@ -4269,6 +4299,8 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       return nonzero;\n     }\n \n+  /* Please keep nonzero_bits_binary_arith_p above in sync with\n+     the code in the switch below.  */\n   code = GET_CODE (x);\n   switch (code)\n     {\n@@ -4672,6 +4704,32 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n #undef cached_num_sign_bit_copies\n \n \f\n+/* Return true if num_sign_bit_copies1 might recurse into both operands\n+   of X.  */\n+\n+static inline bool\n+num_sign_bit_copies_binary_arith_p (const_rtx x)\n+{\n+  if (!ARITHMETIC_P (x))\n+    return false;\n+  switch (GET_CODE (x))\n+    {\n+    case IOR:\n+    case AND:\n+    case XOR:\n+    case SMIN:\n+    case SMAX:\n+    case UMIN:\n+    case UMAX:\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* The function cached_num_sign_bit_copies is a wrapper around\n    num_sign_bit_copies1.  It avoids exponential behavior in\n    num_sign_bit_copies1 when X has identical subexpressions on the\n@@ -4689,7 +4747,7 @@ cached_num_sign_bit_copies (const_rtx x, machine_mode mode, const_rtx known_x,\n      num_sign_bit_copies1 on X with the subexpressions as KNOWN_X and\n      the precomputed value for the subexpression as KNOWN_RET.  */\n \n-  if (ARITHMETIC_P (x))\n+  if (num_sign_bit_copies_binary_arith_p (x))\n     {\n       rtx x0 = XEXP (x, 0);\n       rtx x1 = XEXP (x, 1);\n@@ -4703,15 +4761,15 @@ cached_num_sign_bit_copies (const_rtx x, machine_mode mode, const_rtx known_x,\n \t\t\t\t\t\t\t    known_ret));\n \n       /* Check the second level.  */\n-      if (ARITHMETIC_P (x0)\n+      if (num_sign_bit_copies_binary_arith_p (x0)\n \t  && (x1 == XEXP (x0, 0) || x1 == XEXP (x0, 1)))\n \treturn\n \t  num_sign_bit_copies1 (x, mode, x1, mode,\n \t\t\t\tcached_num_sign_bit_copies (x1, mode, known_x,\n \t\t\t\t\t\t\t    known_mode,\n \t\t\t\t\t\t\t    known_ret));\n \n-      if (ARITHMETIC_P (x1)\n+      if (num_sign_bit_copies_binary_arith_p (x1)\n \t  && (x0 == XEXP (x1, 0) || x0 == XEXP (x1, 1)))\n \treturn\n \t  num_sign_bit_copies1 (x, mode, x0, mode,\n@@ -4777,6 +4835,8 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \treturn 1;\n     }\n \n+  /* Please keep num_sign_bit_copies_binary_arith_p above in sync with\n+     the code in the switch below.  */\n   switch (code)\n     {\n     case REG:"}, {"sha": "1f8ddd096882c9c131bb1389ec4afa25214e20f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0268b37f87359ebf5d6f8bd95fe9829b520749a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0268b37f87359ebf5d6f8bd95fe9829b520749a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0268b37f87359ebf5d6f8bd95fe9829b520749a", "patch": "@@ -1,5 +1,8 @@\n 2016-02-01  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR rtl-optimization/69592\n+\t* gcc.dg/pr69592.c: New test.\n+\n \tPR preprocessor/69543\n \tPR c/69558\n \t* gcc.dg/pr69543.c: New test."}, {"sha": "c791fe9fd2045578e7c1ad49e7a8a3ef3c879351", "filename": "gcc/testsuite/gcc.dg/pr69592.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0268b37f87359ebf5d6f8bd95fe9829b520749a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69592.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0268b37f87359ebf5d6f8bd95fe9829b520749a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69592.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69592.c?ref=d0268b37f87359ebf5d6f8bd95fe9829b520749a", "patch": "@@ -0,0 +1,16 @@\n+/* PR rtl-optimization/69592 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+unsigned int\n+foo (unsigned int a, unsigned int *b, unsigned int c)\n+{\n+  unsigned int d;\n+#define A(n) d = a + b[n]; if (d < a) c++; a = d;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3) A(n##4) A(n##5) A(n##6) A(n##7) A(n##8) A(n##9)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3) B(n##4) B(n##5) B(n##6) B(n##7) B(n##8) B(n##9)\n+#define D(n) C(n##0) C(n##1) C(n##2) C(n##3) C(n##4) C(n##5) C(n##6) C(n##7) C(n##8) C(n##9)\n+#define E(n) D(n##0) D(n##1) D(n##2) D(n##3) D(n##4) D(n##5) D(n##6) D(n##7) D(n##8) D(n##9)\n+  C(1) C(2) C(3) C(4) C(5) C(6)\n+  return d + c;\n+}"}]}