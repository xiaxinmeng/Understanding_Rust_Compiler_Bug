{"sha": "d436bff8d6709d083432a14b8c7ff2fb753d6b2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQzNmJmZjhkNjcwOWQwODM0MzJhMTRiOGM3ZmYyZmI3NTNkNmIyYQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2002-08-16T10:29:45Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2002-08-16T10:29:45Z"}, "message": "tree-inline.c: Add includes for Java inliner.\n\n2002-07-30  Andrew Haley  <aph@redhat.com>\n\n        * tree-inline.c: Add includes for Java inliner.\n        (remap_decl): Don't handle anonymous types for Java.\n        (remap_block): Add handling for Java trees.\n        (copy_scope_stmt): Conditionalize for non-Java use only.\n        (copy_body_r): Handle Java trees.  Add handling for\n        LABELED_BLOCK_EXPR, EXIT_BLOCK_EXPR, Java blocks.\n        (initialize_inlined_parameters):  Handle Java trees.\n        (declare_return_variable): Likewise.\n        (expand_call_inline): Handle Java trees.\n        (walk_tree): Likewise.\n        (copy_tree_r): Don't handle SCOPE_STMTs for Java.\n        (add_stmt_to_compound): New function.\n\nFrom-SVN: r56376", "tree": {"sha": "ee4e20c96750dd04be6188ae0241adeb35d0b8eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee4e20c96750dd04be6188ae0241adeb35d0b8eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d436bff8d6709d083432a14b8c7ff2fb753d6b2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d436bff8d6709d083432a14b8c7ff2fb753d6b2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d436bff8d6709d083432a14b8c7ff2fb753d6b2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d436bff8d6709d083432a14b8c7ff2fb753d6b2a/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "408caa3aa223d94b80127ec275bbb8e0a7131518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408caa3aa223d94b80127ec275bbb8e0a7131518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408caa3aa223d94b80127ec275bbb8e0a7131518"}], "stats": {"total": 333, "additions": 328, "deletions": 5}, "files": [{"sha": "c011e1563631e44ffb1e9ba4146ded1d9eed19ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436bff8d6709d083432a14b8c7ff2fb753d6b2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436bff8d6709d083432a14b8c7ff2fb753d6b2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d436bff8d6709d083432a14b8c7ff2fb753d6b2a", "patch": "@@ -1,3 +1,18 @@\n+2002-07-30  Andrew Haley  <aph@redhat.com>\n+\n+\t* tree-inline.c: Add includes for Java inliner.\n+\t(remap_decl): Don't handle anonymous types for Java.\n+\t(remap_block): Add handling for Java trees.\n+\t(copy_scope_stmt): Conditionalize for non-Java use only.\n+\t(copy_body_r): Handle Java trees.  Add handling for\n+\tLABELED_BLOCK_EXPR, EXIT_BLOCK_EXPR, Java blocks.\n+\t(initialize_inlined_parameters):  Handle Java trees.\n+\t(declare_return_variable): Likewise.\n+\t(expand_call_inline): Handle Java trees.\n+\t(walk_tree): Likewise.\n+\t(copy_tree_r): Don't handle SCOPE_STMTs for Java.\n+\t(add_stmt_to_compound): New function.\n+\n 2002-08-15  Richard Henderson  <rth@redhat.com>\n \n \t* Makefile.in (LOOSE_WARN): Remove -fno-common."}, {"sha": "ad4865bafd02c1c6f652001c910933fcbd34a0a4", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 313, "deletions": 5, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d436bff8d6709d083432a14b8c7ff2fb753d6b2a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d436bff8d6709d083432a14b8c7ff2fb753d6b2a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d436bff8d6709d083432a14b8c7ff2fb753d6b2a", "patch": "@@ -38,7 +38,12 @@ Boston, MA 02111-1307, USA.  */\n \n /* This should be eventually be generalized to other languages, but\n    this would require a shared function-as-trees infrastructure.  */\n+#ifndef INLINER_FOR_JAVA\n #include \"c-common.h\"\n+#else /* INLINER_FOR_JAVA */\n+#include \"parse.h\"\n+#include \"java-tree.h\"\n+#endif /* INLINER_FOR_JAVA */\n \n /* 0 if we should not perform inlining.\n    1 if we should expand functions calls inline at the tree level.\n@@ -102,16 +107,22 @@ typedef struct inline_data\n \n /* Prototypes.  */\n \n-static tree initialize_inlined_parameters PARAMS ((inline_data *, tree, tree));\n static tree declare_return_variable PARAMS ((inline_data *, tree *));\n static tree copy_body_r PARAMS ((tree *, int *, void *));\n static tree copy_body PARAMS ((inline_data *));\n static tree expand_call_inline PARAMS ((tree *, int *, void *));\n static void expand_calls_inline PARAMS ((tree *, inline_data *));\n static int inlinable_function_p PARAMS ((tree, inline_data *));\n static tree remap_decl PARAMS ((tree, inline_data *));\n+#ifndef INLINER_FOR_JAVA\n+static tree initialize_inlined_parameters PARAMS ((inline_data *, tree, tree));\n static void remap_block PARAMS ((tree, tree, inline_data *));\n static void copy_scope_stmt PARAMS ((tree *, int *, inline_data *));\n+#else /* INLINER_FOR_JAVA */\n+static tree initialize_inlined_parameters PARAMS ((inline_data *, tree, tree, tree));\n+static void remap_block PARAMS ((tree *, tree, inline_data *));\n+static tree add_stmt_to_compound PARAMS ((tree, tree, tree));\n+#endif /* INLINER_FOR_JAVA */\n \n /* The approximate number of instructions per statement.  This number\n    need not be particularly accurate; it is used only to make\n@@ -158,6 +169,7 @@ remap_decl (decl, id)\n \t\t     copy_body_r, id, NULL);\n \t}\n \n+#ifndef INLINER_FOR_JAVA\n       if (! DECL_NAME (t) && TREE_TYPE (t)\n \t  && (*lang_hooks.tree_inlining.anon_aggr_type_p) (TREE_TYPE (t)))\n \t{\n@@ -178,6 +190,7 @@ remap_decl (decl, id)\n \t    }\n \t  DECL_ANON_UNION_ELEMS (t) = nreverse (members);\n \t}\n+#endif /* not INLINER_FOR_JAVA */\n \n       /* Remember it, so that if we encounter this local entity\n \t again we can reuse this copy.  */\n@@ -189,17 +202,28 @@ remap_decl (decl, id)\n   return (tree) n->value;\n }\n \n+#ifndef INLINER_FOR_JAVA\n /* Copy the SCOPE_STMT_BLOCK associated with SCOPE_STMT to contain\n    remapped versions of the variables therein.  And hook the new block\n    into the block-tree.  If non-NULL, the DECLS are declarations to\n    add to use instead of the BLOCK_VARS in the old block.  */\n+#else /* INLINER_FOR_JAVA */\n+/* Copy the BLOCK to contain remapped versions of the variables\n+   therein.  And hook the new block into the block-tree.  */\n+#endif /* INLINER_FOR_JAVA */\n \n static void\n+#ifndef INLINER_FOR_JAVA\n remap_block (scope_stmt, decls, id)\n      tree scope_stmt;\n+#else /* INLINER_FOR_JAVA */\n+remap_block (block, decls, id)\n+     tree *block;\n+#endif /* INLINER_FOR_JAVA */\n      tree decls;\n      inline_data *id;\n {\n+#ifndef INLINER_FOR_JAVA\n   /* We cannot do this in the cleanup for a TARGET_EXPR since we do\n      not know whether or not expand_expr will actually write out the\n      code we put there.  If it does not, then we'll have more BLOCKs\n@@ -289,8 +313,55 @@ remap_block (scope_stmt, decls, id)\n \tabort ();\n       SCOPE_STMT_BLOCK (scope_stmt) = (tree) n->value;\n     }\n+#else /* INLINER_FOR_JAVA */\n+  tree old_block;\n+  tree new_block;\n+  tree old_var;\n+  tree fn;\n+\n+  /* Make the new block.  */\n+  old_block = *block;\n+  new_block = make_node (BLOCK);\n+  TREE_USED (new_block) = TREE_USED (old_block);\n+  BLOCK_ABSTRACT_ORIGIN (new_block) = old_block;\n+  BLOCK_SUBBLOCKS (new_block) = BLOCK_SUBBLOCKS (old_block);\n+  TREE_SIDE_EFFECTS (new_block) = TREE_SIDE_EFFECTS (old_block);\n+  TREE_TYPE (new_block) = TREE_TYPE (old_block);\n+  *block = new_block;\n+\n+  /* Remap its variables.  */\n+  for (old_var = decls ? decls : BLOCK_VARS (old_block);\n+       old_var;\n+       old_var = TREE_CHAIN (old_var))\n+    {\n+      tree new_var;\n+\n+      /* Remap the variable.  */\n+      new_var = remap_decl (old_var, id);\n+      /* If we didn't remap this variable, so we can't mess with\n+\t its TREE_CHAIN.  If we remapped this variable to\n+\t something other than a declaration (say, if we mapped it\n+\t to a constant), then we must similarly omit any mention\n+\t of it here.  */\n+      if (!new_var || !DECL_P (new_var))\n+\t;\n+      else\n+\t{\n+\t  TREE_CHAIN (new_var) = BLOCK_VARS (new_block);\n+\t  BLOCK_VARS (new_block) = new_var;\n+\t}\n+    }\n+  /* We put the BLOCK_VARS in reverse order; fix that now.  */\n+  BLOCK_VARS (new_block) = nreverse (BLOCK_VARS (new_block));\n+  fn = VARRAY_TREE (id->fns, 0);\n+  /* Remember the remapped block.  */\n+  splay_tree_insert (id->decl_map,\n+\t\t     (splay_tree_key) old_block,\n+\t\t     (splay_tree_value) new_block);\n+#endif /* INLINER_FOR_JAVA */\n }\n \n+#ifndef INLINER_FOR_JAVA\n /* Copy the SCOPE_STMT pointed to by TP.  */\n \n static void\n@@ -314,10 +385,10 @@ copy_scope_stmt (tp, walk_subtrees, id)\n   /* Remap the associated block.  */\n   remap_block (*tp, NULL_TREE, id);\n }\n+#endif /* not INLINER_FOR_JAVA */\n \n /* Called from copy_body via walk_tree.  DATA is really an\n    `inline_data *'.  */\n-\n static tree\n copy_body_r (tp, walk_subtrees, data)\n      tree *tp;\n@@ -340,21 +411,37 @@ copy_body_r (tp, walk_subtrees, data)\n       abort ();\n #endif\n \n+#ifdef INLINER_FOR_JAVA\n+  if (TREE_CODE (*tp) == BLOCK)\n+    remap_block (tp, NULL_TREE, id);\n+#endif\n+\n   /* If this is a RETURN_STMT, change it into an EXPR_STMT and a\n      GOTO_STMT with the RET_LABEL as its target.  */\n+#ifndef INLINER_FOR_JAVA\n   if (TREE_CODE (*tp) == RETURN_STMT && id->ret_label)\n+#else /* INLINER_FOR_JAVA */\n+  if (TREE_CODE (*tp) == RETURN_EXPR && id->ret_label)\n+#endif /* INLINER_FOR_JAVA */\n     {\n       tree return_stmt = *tp;\n       tree goto_stmt;\n \n       /* Build the GOTO_STMT.  */\n+#ifndef INLINER_FOR_JAVA\n       goto_stmt = build_stmt (GOTO_STMT, id->ret_label);\n       TREE_CHAIN (goto_stmt) = TREE_CHAIN (return_stmt);\n       GOTO_FAKE_P (goto_stmt) = 1;\n+#else /* INLINER_FOR_JAVA */\n+      tree assignment = TREE_OPERAND (return_stmt, 0);\n+      goto_stmt = build1 (GOTO_EXPR, void_type_node, id->ret_label);\n+      TREE_SIDE_EFFECTS (goto_stmt) = 1;\n+#endif /* INLINER_FOR_JAVA */\n \n       /* If we're returning something, just turn that into an\n \t assignment into the equivalent of the original\n \t RESULT_DECL.  */\n+#ifndef INLINER_FOR_JAVA\n       if (RETURN_EXPR (return_stmt))\n \t{\n \t  *tp = build_stmt (EXPR_STMT,\n@@ -363,6 +450,14 @@ copy_body_r (tp, walk_subtrees, data)\n \t  /* And then jump to the end of the function.  */\n \t  TREE_CHAIN (*tp) = goto_stmt;\n \t}\n+#else /* INLINER_FOR_JAVA */\n+      if (assignment)\n+\t{\n+\t  copy_body_r (&assignment, walk_subtrees, data);\n+\t  *tp = build (COMPOUND_EXPR, void_type_node, assignment, goto_stmt);\n+\t  TREE_SIDE_EFFECTS (*tp) = 1;\t    \n+\t}\n+#endif /* INLINER_FOR_JAVA */\n       /* If we're not returning anything just do the jump.  */\n       else\n \t*tp = goto_stmt;\n@@ -394,10 +489,35 @@ copy_body_r (tp, walk_subtrees, data)\n   else if (TREE_CODE (*tp) == UNSAVE_EXPR)\n     /* UNSAVE_EXPRs should not be generated until expansion time.  */\n     abort ();\n+#ifndef INLINER_FOR_JAVA\n   /* For a SCOPE_STMT, we must copy the associated block so that we\n      can write out debugging information for the inlined variables.  */\n   else if (TREE_CODE (*tp) == SCOPE_STMT && !id->in_target_cleanup_p)\n     copy_scope_stmt (tp, walk_subtrees, id);\n+#else /* INLINER_FOR_JAVA */\n+  else if (TREE_CODE (*tp) == LABELED_BLOCK_EXPR)\n+    {\n+      /* We need a new copy of this labeled block; the EXIT_BLOCK_EXPR\n+         will refer to it, so save a copy ready for remapping.  We\n+         save it in the decl_map, although it isn't a decl.  */\n+      tree new_block = copy_node (*tp);\n+      splay_tree_insert (id->decl_map,\n+\t\t\t (splay_tree_key) *tp,\n+\t\t\t (splay_tree_value) new_block);\n+      *tp = new_block;\n+    }\n+  else if (TREE_CODE (*tp) == EXIT_BLOCK_EXPR)\n+    {\n+      splay_tree_node n \n+\t= splay_tree_lookup (id->decl_map, \n+\t\t\t     (splay_tree_key) TREE_OPERAND (*tp, 0));\n+      /* We _must_ have seen the enclosing LABELED_BLOCK_EXPR.  */\n+      if (! n)\n+\tabort ();\n+      *tp = copy_node (*tp);\n+      TREE_OPERAND (*tp, 0) = (tree) n->value;\n+    }\n+#endif /* INLINER_FOR_JAVA */\n   /* Otherwise, just copy the node.  Note that copy_tree_r already\n      knows not to copy VAR_DECLs, etc., so this is safe.  */\n   else\n@@ -456,15 +576,25 @@ copy_body (id)\n    top of the stack in ID from the ARGS (presented as a TREE_LIST).  */\n \n static tree\n+#ifndef INLINER_FOR_JAVA\n initialize_inlined_parameters (id, args, fn)\n+#else /* INLINER_FOR_JAVA */\n+initialize_inlined_parameters (id, args, fn, block)\n+#endif /* INLINER_FOR_JAVA */\n      inline_data *id;\n      tree args;\n      tree fn;\n+#ifdef INLINER_FOR_JAVA\n+     tree block;\n+#endif /* INLINER_FOR_JAVA */\n {\n   tree init_stmts;\n   tree parms;\n   tree a;\n   tree p;\n+#ifdef INLINER_FOR_JAVA\n+  tree vars = NULL_TREE;\n+#endif /* INLINER_FOR_JAVA */\n \n   /* Figure out what the parameters are.  */\n   parms = DECL_ARGUMENTS (fn);\n@@ -477,7 +607,9 @@ initialize_inlined_parameters (id, args, fn)\n   for (p = parms, a = args; p;\n        a = a ? TREE_CHAIN (a) : a, p = TREE_CHAIN (p))\n     {\n+#ifndef INLINER_FOR_JAVA\n       tree init_stmt;\n+#endif /* not INLINER_FOR_JAVA */\n       tree var;\n       tree value;\n       tree cleanup;\n@@ -526,16 +658,22 @@ initialize_inlined_parameters (id, args, fn)\n \t\t\t (splay_tree_value) var);\n \n       /* Declare this new variable.  */\n+#ifndef INLINER_FOR_JAVA\n       init_stmt = build_stmt (DECL_STMT, var);\n       TREE_CHAIN (init_stmt) = init_stmts;\n       init_stmts = init_stmt;\n+#else /* INLINER_FOR_JAVA */\n+      TREE_CHAIN (var) = vars;\n+      vars = var;\n+#endif /* INLINER_FOR_JAVA */\n \n       /* Initialize this VAR_DECL from the equivalent argument.  If\n \t the argument is an object, created via a constructor or copy,\n \t this will not result in an extra copy: the TARGET_EXPR\n \t representing the argument will be bound to VAR, and the\n \t object will be constructed in VAR.  */\n       if (! TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (p)))\n+#ifndef INLINER_FOR_JAVA\n \tDECL_INITIAL (var) = value;\n       else\n \t{\n@@ -573,8 +711,23 @@ initialize_inlined_parameters (id, args, fn)\n \t  TREE_CHAIN (cleanup_stmt) = init_stmts;\n \t  init_stmts = cleanup_stmt;\n \t}\n+#else /* INLINER_FOR_JAVA */\n+\t{\n+\t  tree assignment = build (MODIFY_EXPR, TREE_TYPE (p), var, value);\n+\t  init_stmts = add_stmt_to_compound (init_stmts, TREE_TYPE (p), \n+\t\t\t\t\t     assignment);\n+\t}\n+      else\n+\t{\n+\t  /* Java objects don't ever need constructing when being\n+             passed as arguments because only call by reference is\n+             supported.  */\n+\t  abort ();\n+\t}\n+#endif /* INLINER_FOR_JAVA */\n     }\n \n+#ifndef INLINER_FOR_JAVA\n   /* Evaluate trailing arguments.  */\n   for (; a; a = TREE_CHAIN (a))\n     {\n@@ -592,31 +745,49 @@ initialize_inlined_parameters (id, args, fn)\n   /* The initialization statements have been built up in reverse\n      order.  Straighten them out now.  */\n   return nreverse (init_stmts);\n+#else /* INLINER_FOR_JAVA */\n+  BLOCK_VARS (block) = nreverse (vars);\n+  return init_stmts;\n+#endif /* INLINER_FOR_JAVA */\n }\n \n /* Declare a return variable to replace the RESULT_DECL for the\n    function we are calling.  An appropriate DECL_STMT is returned.\n    The USE_STMT is filled in to contain a use of the declaration to\n    indicate the return value of the function.  */\n \n+#ifndef INLINER_FOR_JAVA\n static tree\n declare_return_variable (id, use_stmt)\n      struct inline_data *id;\n      tree *use_stmt;\n+#else /* INLINER_FOR_JAVA */\n+static tree\n+declare_return_variable (id, var)\n+     struct inline_data *id;\n+     tree *var;\n+#endif /* INLINER_FOR_JAVA */\n {\n   tree fn = VARRAY_TOP_TREE (id->fns);\n   tree result = DECL_RESULT (fn);\n+#ifndef INLINER_FOR_JAVA\n   tree var;\n+#endif /* not INLINER_FOR_JAVA */\n   int need_return_decl = 1;\n \n   /* We don't need to do anything for functions that don't return\n      anything.  */\n   if (!result || VOID_TYPE_P (TREE_TYPE (result)))\n     {\n+#ifndef INLINER_FOR_JAVA\n       *use_stmt = NULL_TREE;\n+#else /* INLINER_FOR_JAVA */\n+      *var = NULL_TREE;\n+#endif /* INLINER_FOR_JAVA */\n       return NULL_TREE;\n     }\n \n+#ifndef INLINER_FOR_JAVA\n   var = ((*lang_hooks.tree_inlining.copy_res_decl_for_inlining)\n \t (result, fn, VARRAY_TREE (id->fns, 0), id->decl_map,\n \t  &need_return_decl, &id->target_exprs));\n@@ -636,13 +807,24 @@ declare_return_variable (id, use_stmt)\n     *use_stmt = build_stmt (EXPR_STMT,\n \t\t\t    build1 (NOP_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n \t\t\t\t    var));\n-\n   TREE_ADDRESSABLE (*use_stmt) = 1;\n \n   /* Build the declaration statement if FN does not return an\n      aggregate.  */\n   if (need_return_decl)\n     return build_stmt (DECL_STMT, var);\n+#else /* INLINER_FOR_JAVA */\n+  *var = ((*lang_hooks.tree_inlining.copy_res_decl_for_inlining)\n+\t (result, fn, VARRAY_TREE (id->fns, 0), id->decl_map,\n+\t  &need_return_decl, NULL_TREE));\n+\n+  splay_tree_insert (id->decl_map,\n+\t\t     (splay_tree_key) result,\n+\t\t     (splay_tree_value) *var);\n+  DECL_IGNORED_P (*var) = 1;\n+  if (need_return_decl)\n+    return *var;\n+#endif /* INLINER_FOR_JAVA */\n   /* If FN does return an aggregate, there's no need to declare the\n      return variable; we're using a variable in our caller's frame.  */\n   else\n@@ -783,10 +965,14 @@ expand_call_inline (tp, walk_subtrees, data)\n   tree t;\n   tree expr;\n   tree stmt;\n+#ifndef INLINER_FOR_JAVA\n   tree chain;\n-  tree fn;\n   tree scope_stmt;\n   tree use_stmt;\n+#else /* INLINER_FOR_JAVA */\n+  tree retvar;\n+#endif /* INLINER_FOR_JAVA */\n+  tree fn;\n   tree arg_inits;\n   tree *inlined_body;\n   splay_tree st;\n@@ -799,6 +985,7 @@ expand_call_inline (tp, walk_subtrees, data)\n      inside the body of a TARGET_EXPR.  */\n   if (TREE_CODE (*tp) == TARGET_EXPR)\n     {\n+#ifndef INLINER_FOR_JAVA\n       int i, len = first_rtl_op (TARGET_EXPR);\n \n       /* We're walking our own subtrees.  */\n@@ -824,6 +1011,9 @@ expand_call_inline (tp, walk_subtrees, data)\n       VARRAY_POP (id->target_exprs);\n \n       return NULL_TREE;\n+#else /* INLINER_FOR_JAVA */\n+      abort ();\n+#endif /* INLINER_FOR_JAVA */\n     }\n \n   if (TYPE_P (t))\n@@ -869,6 +1059,7 @@ expand_call_inline (tp, walk_subtrees, data)\n      because individual statements don't record the filename.  */\n   push_srcloc (DECL_SOURCE_FILE (fn), DECL_SOURCE_LINE (fn));\n \n+#ifndef INLINER_FOR_JAVA\n   /* Build a statement-expression containing code to initialize the\n      arguments, the actual inline expansion of the body, and a label\n      for the return statements within the function to jump to.  The\n@@ -878,13 +1069,23 @@ expand_call_inline (tp, walk_subtrees, data)\n   /* There is no scope associated with the statement-expression.  */\n   STMT_EXPR_NO_SCOPE (expr) = 1;\n   stmt = STMT_EXPR_STMT (expr);\n+#else /* INLINER_FOR_JAVA */\n+  /* Build a block containing code to initialize the arguments, the\n+     actual inline expansion of the body, and a label for the return\n+     statements within the function to jump to.  The type of the\n+     statement expression is the return type of the function call.  */\n+  stmt = NULL;\n+  expr = build (BLOCK, TREE_TYPE (TREE_TYPE (fn)), stmt);\n+#endif /* INLINER_FOR_JAVA */\n+\n   /* Local declarations will be replaced by their equivalents in this\n      map.  */\n   st = id->decl_map;\n   id->decl_map = splay_tree_new (splay_tree_compare_pointers,\n \t\t\t\t NULL, NULL);\n \n   /* Initialize the parameters.  */\n+#ifndef INLINER_FOR_JAVA\n   arg_inits = initialize_inlined_parameters (id, TREE_OPERAND (t, 1), fn);\n   /* Expand any inlined calls in the initializers.  Do this before we\n      push FN on the stack of functions we are inlining; we want to\n@@ -893,6 +1094,22 @@ expand_call_inline (tp, walk_subtrees, data)\n   expand_calls_inline (&arg_inits, id);\n   /* And add them to the tree.  */\n   COMPOUND_BODY (stmt) = chainon (COMPOUND_BODY (stmt), arg_inits);\n+#else /* INLINER_FOR_JAVA */\n+  arg_inits = initialize_inlined_parameters (id, TREE_OPERAND (t, 1), fn, expr);\n+  if (arg_inits)\n+    {\n+      /* Expand any inlined calls in the initializers.  Do this before we\n+\t push FN on the stack of functions we are inlining; we want to\n+\t inline calls to FN that appear in the initializers for the\n+\t parameters.  */\n+      expand_calls_inline (&arg_inits, id);\n+      \n+      /* And add them to the tree.  */\n+      BLOCK_EXPR_BODY (expr) = add_stmt_to_compound (BLOCK_EXPR_BODY (expr), \n+\t\t\t\t\t\t     TREE_TYPE (arg_inits), \n+\t\t\t\t\t\t     arg_inits);\n+    }\n+#endif /* INLINER_FOR_JAVA */\n \n   /* Record the function we are about to inline so that we can avoid\n      recursing into it.  */\n@@ -920,6 +1137,7 @@ expand_call_inline (tp, walk_subtrees, data)\n       || TREE_CODE (DECL_INITIAL (fn)) != BLOCK)\n     abort ();\n \n+#ifndef INLINER_FOR_JAVA\n   /* Create a block to put the parameters in.  We have to do this\n      after the parameters have been remapped because remapping\n      parameters is different from remapping ordinary variables.  */\n@@ -939,23 +1157,57 @@ expand_call_inline (tp, walk_subtrees, data)\n   COMPOUND_BODY (stmt)\n     = chainon (COMPOUND_BODY (stmt),\n \t       declare_return_variable (id, &use_stmt));\n+#else /* INLINER_FOR_JAVA */\n+  {\n+    /* Declare the return variable for the function.  */\n+    tree decl = declare_return_variable (id, &retvar);\n+    if (retvar)\n+      {\n+\ttree *next = &BLOCK_VARS (expr);\n+\twhile (*next)\n+\t  next = &TREE_CHAIN (*next);\t\n+\t*next = decl;\n+      }\n+  }\n+#endif /* INLINER_FOR_JAVA */\n \n   /* After we've initialized the parameters, we insert the body of the\n      function itself.  */\n+#ifndef INLINER_FOR_JAVA\n   inlined_body = &COMPOUND_BODY (stmt);\n   while (*inlined_body)\n     inlined_body = &TREE_CHAIN (*inlined_body);\n   *inlined_body = copy_body (id);\n+#else /* INLINER_FOR_JAVA */\n+  {\n+    tree new_body = copy_body (id);\n+    TREE_TYPE (new_body) = TREE_TYPE (TREE_TYPE (fn));\n+    BLOCK_EXPR_BODY (expr)\n+      = add_stmt_to_compound (BLOCK_EXPR_BODY (expr), \n+\t\t\t      TREE_TYPE (new_body), new_body);\n+    inlined_body = &BLOCK_EXPR_BODY (expr);\n+  }\n+#endif /* INLINER_FOR_JAVA */\n \n   /* After the body of the function comes the RET_LABEL.  This must come\n      before we evaluate the returned value below, because that evalulation\n      may cause RTL to be generated.  */\n+#ifndef INLINER_FOR_JAVA\n   COMPOUND_BODY (stmt)\n     = chainon (COMPOUND_BODY (stmt),\n \t       build_stmt (LABEL_STMT, id->ret_label));\n+#else /* INLINER_FOR_JAVA */\n+  {\n+    tree label = build1 (LABEL_EXPR, void_type_node, id->ret_label);\n+    BLOCK_EXPR_BODY (expr)\n+      = add_stmt_to_compound (BLOCK_EXPR_BODY (expr), void_type_node, label);\n+    TREE_SIDE_EFFECTS (label) = TREE_SIDE_EFFECTS (t);\n+  }\n+#endif /* INLINER_FOR_JAVA */\n \n   /* Finally, mention the returned value so that the value of the\n      statement-expression is the returned value of the function.  */\n+#ifndef INLINER_FOR_JAVA\n   COMPOUND_BODY (stmt) = chainon (COMPOUND_BODY (stmt), use_stmt);\n   \n   /* Close the block for the parameters.  */\n@@ -964,6 +1216,12 @@ expand_call_inline (tp, walk_subtrees, data)\n   remap_block (scope_stmt, NULL_TREE, id);\n   COMPOUND_BODY (stmt)\n     = chainon (COMPOUND_BODY (stmt), scope_stmt);\n+#else /* INLINER_FOR_JAVA */\n+  if (retvar)\n+    BLOCK_EXPR_BODY (expr) \n+      = add_stmt_to_compound (BLOCK_EXPR_BODY (expr), \n+\t\t\t      TREE_TYPE (retvar), retvar);\n+#endif /* INLINER_FOR_JAVA */\n \n   /* Clean up.  */\n   splay_tree_delete (id->decl_map);\n@@ -975,11 +1233,19 @@ expand_call_inline (tp, walk_subtrees, data)\n   /* Replace the call by the inlined body.  Wrap it in an\n      EXPR_WITH_FILE_LOCATION so that we'll get debugging line notes\n      pointing to the right place.  */\n+#ifndef INLINER_FOR_JAVA\n   chain = TREE_CHAIN (*tp);\n   *tp = build_expr_wfl (expr, DECL_SOURCE_FILE (fn), DECL_SOURCE_LINE (fn),\n \t\t\t/*col=*/0);\n+#else /* INLINER_FOR_JAVA */\n+  *tp = build_expr_wfl (expr, DECL_SOURCE_FILE (fn), \n+\t\t\tDECL_SOURCE_LINE_FIRST(fn),\n+\t\t\t/*col=*/0);\n+#endif /* INLINER_FOR_JAVA */\n   EXPR_WFL_EMIT_LINE_NOTE (*tp) = 1;\n+#ifndef INLINER_FOR_JAVA\n   TREE_CHAIN (*tp) = chain;\n+#endif /* not INLINER_FOR_JAVA */\n   pop_srcloc ();\n \n   /* If the value of the new expression is ignored, that's OK.  We\n@@ -1009,7 +1275,6 @@ expand_call_inline (tp, walk_subtrees, data)\n   /* Keep iterating.  */\n   return NULL_TREE;\n }\n-\n /* Walk over the entire tree *TP, replacing CALL_EXPRs with inline\n    expansions as appropriate.  */\n \n@@ -1174,6 +1439,7 @@ walk_tree (tp, func, data, htab_)\n \n   code = TREE_CODE (*tp);\n \n+#ifndef INLINER_FOR_JAVA\n   /* Even if we didn't, FUNC may have decided that there was nothing\n      interesting below this point in the tree.  */\n   if (!walk_subtrees)\n@@ -1190,13 +1456,22 @@ walk_tree (tp, func, data, htab_)\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n       || TREE_CODE_CLASS (code) == 'r'\n       || TREE_CODE_CLASS (code) == 's')\n+#else /* INLINER_FOR_JAVA */\n+  if (code != EXIT_BLOCK_EXPR\n+      && code != SAVE_EXPR\n+      && (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n+\t  || TREE_CODE_CLASS (code) == 'r'\n+\t  || TREE_CODE_CLASS (code) == 's'))\n+#endif /* INLINER_FOR_JAVA */\n     {\n       int i, len;\n \n+#ifndef INLINER_FOR_JAVA\n       /* Set lineno here so we get the right instantiation context\n \t if we call instantiate_decl from inlinable_function_p.  */\n       if (statement_code_p (code) && !STMT_LINENO_FOR_FN_P (*tp))\n \tlineno = STMT_LINENO (*tp);\n+#endif /* not INLINER_FOR_JAVA */\n \n       /* Walk over all the sub-trees of this operand.  */\n       len = first_rtl_op (code);\n@@ -1210,6 +1485,7 @@ walk_tree (tp, func, data, htab_)\n       for (i = 0; i < len; ++i)\n \tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n \n+#ifndef INLINER_FOR_JAVA\n       /* For statements, we also walk the chain so that we cover the\n \t entire statement tree.  */\n       if (statement_code_p (code))\n@@ -1232,6 +1508,7 @@ walk_tree (tp, func, data, htab_)\n \t  WALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n \t}\n \n+#endif /* not INLINER_FOR_JAVA */\n       /* We didn't find what we were looking for.  */\n       return NULL_TREE;\n     }\n@@ -1327,6 +1604,14 @@ walk_tree (tp, func, data, htab_)\n       WALK_SUBTREE (TREE_TYPE (*tp));\n       WALK_SUBTREE_TAIL (TYPE_OFFSET_BASETYPE (*tp));\n \n+#ifdef INLINER_FOR_JAVA\n+    case EXIT_BLOCK_EXPR:\n+      WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 1));\n+\n+    case SAVE_EXPR:\n+      WALK_SUBTREE_TAIL (TREE_OPERAND (*tp, 0));\n+#endif /* INLINER_FOR_JAVA */\n+\n     default:\n       abort ();\n     }\n@@ -1384,6 +1669,7 @@ copy_tree_r (tp, walk_subtrees, data)\n       /* Now, restore the chain, if appropriate.  That will cause\n \t walk_tree to walk into the chain as well.  */\n       if (code == PARM_DECL || code == TREE_LIST\n+#ifndef INLINER_FOR_JAVA\n \t  || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp)\n \t  || statement_code_p (code))\n \tTREE_CHAIN (*tp) = chain;\n@@ -1392,6 +1678,10 @@ copy_tree_r (tp, walk_subtrees, data)\n \t have to nullify all scope-statements.  */\n       if (TREE_CODE (*tp) == SCOPE_STMT)\n \tSCOPE_STMT_BLOCK (*tp) = NULL_TREE;\n+#else /* INLINER_FOR_JAVA */\n+\t  || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp))\n+\tTREE_CHAIN (*tp) = chain;\n+#endif /* INLINER_FOR_JAVA */\n     }\n   else if (TREE_CODE_CLASS (code) == 't')\n     /* There's no need to copy types, or anything beneath them.  */\n@@ -1444,3 +1734,21 @@ remap_save_expr (tp, st_, fn, walk_subtrees)\n   /* Replace this SAVE_EXPR with the copy.  */\n   *tp = (tree) n->value;\n }\n+\n+#ifdef INLINER_FOR_JAVA\n+/* Add STMT to EXISTING if possible, otherwise create a new\n+   COMPOUND_EXPR and add STMT to it. */\n+\n+static tree\n+add_stmt_to_compound (existing, type, stmt)\n+     tree existing, type, stmt;\n+{\n+  if (!stmt)\n+    return existing;\n+  else if (existing)\n+    return build (COMPOUND_EXPR, type, existing, stmt);\n+  else\n+    return stmt;\n+}\n+\n+#endif /* INLINER_FOR_JAVA */"}]}