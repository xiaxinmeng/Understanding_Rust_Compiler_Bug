{"sha": "d15364ce85d30212914ad79f624e9d2236a9be64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1MzY0Y2U4NWQzMDIxMjkxNGFkNzlmNjI0ZTlkMjIzNmE5YmU2NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-06-26T20:33:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-06-26T20:33:41Z"}, "message": "re PR c++/66067 (tree check ICE: accessed elt 1 of tree_vec with 0 elts in write_template_args, at cp/mangle.c:2574)\n\n\tPR c++/66067\n\t* mangle.c (write_nested_name): Limit TYPENAME_TYPE handling to\n\tTYPE_DECLs.\n\t* mangle.c (write_template_args): Handle 0 length TREE_VEC.\n\nFrom-SVN: r225083", "tree": {"sha": "e95d665c543b8b6186eed2d1e94cc2f44fa8c0b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e95d665c543b8b6186eed2d1e94cc2f44fa8c0b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d15364ce85d30212914ad79f624e9d2236a9be64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15364ce85d30212914ad79f624e9d2236a9be64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15364ce85d30212914ad79f624e9d2236a9be64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15364ce85d30212914ad79f624e9d2236a9be64/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7457279bae2d1ba50848d95f5b927a599e194646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7457279bae2d1ba50848d95f5b927a599e194646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7457279bae2d1ba50848d95f5b927a599e194646"}], "stats": {"total": 245, "additions": 243, "deletions": 2}, "files": [{"sha": "452a6d9055adc28673f9fecc045e750d8bff825e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15364ce85d30212914ad79f624e9d2236a9be64/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15364ce85d30212914ad79f624e9d2236a9be64/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d15364ce85d30212914ad79f624e9d2236a9be64", "patch": "@@ -1,5 +1,10 @@\n 2015-06-26  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/66067\n+\t* mangle.c (write_nested_name): Limit TYPENAME_TYPE handling to\n+\tTYPE_DECLs.\n+\t* mangle.c (write_template_args): Handle 0 length TREE_VEC.\n+\n \tPR c++/66654\n \t* typeck2.c (digest_init_r): Only expect reshaping if the class is\n \taggregate."}, {"sha": "f4947c484d308eea5955dca435c1224c46565e92", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15364ce85d30212914ad79f624e9d2236a9be64/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15364ce85d30212914ad79f624e9d2236a9be64/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=d15364ce85d30212914ad79f624e9d2236a9be64", "patch": "@@ -984,7 +984,8 @@ write_nested_name (const tree decl)\n       write_template_prefix (decl);\n       write_template_args (TI_ARGS (template_info));\n     }\n-  else if (TREE_CODE (TREE_TYPE (decl)) == TYPENAME_TYPE)\n+  else if ((!abi_version_at_least (9) || TREE_CODE (decl) == TYPE_DECL)\n+\t   && TREE_CODE (TREE_TYPE (decl)) == TYPENAME_TYPE)\n     {\n       tree name = TYPENAME_TYPE_FULLNAME (TREE_TYPE (decl));\n       if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n@@ -2621,7 +2622,7 @@ write_template_args (tree args)\n   if (args)\n     length = TREE_VEC_LENGTH (args);\n \n-  if (args && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+  if (args && length && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n     {\n       /* We have nested template args.  We want the innermost template\n \t argument list.  */"}, {"sha": "94ac08e30ce8b92c3300cd731b54435d090acc79", "filename": "gcc/testsuite/g++.dg/abi/mangle66.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15364ce85d30212914ad79f624e9d2236a9be64/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle66.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15364ce85d30212914ad79f624e9d2236a9be64/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle66.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle66.C?ref=d15364ce85d30212914ad79f624e9d2236a9be64", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++11 } }\n+\n+namespace N {\n+  template <class T> using A = typename T::template X<int>;\n+}\n+\n+template<template<class> class TT> struct B { };\n+\n+// { dg-final { scan-assembler \"_Z1f1BIN1N1AEE\" } }\n+void f(B<N::A>) {}"}, {"sha": "6839d343e8a1128845a174120f7bfbc6d57fa62e", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-50.C", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15364ce85d30212914ad79f624e9d2236a9be64/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-50.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15364ce85d30212914ad79f624e9d2236a9be64/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-50.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-50.C?ref=d15364ce85d30212914ad79f624e9d2236a9be64", "patch": "@@ -0,0 +1,225 @@\n+// PR c++/66067\n+// { dg-do compile { target c++11 } }\n+\n+namespace std\n+{\n+  typedef int size_t;\n+    template < typename _Tp, _Tp > struct integral_constant\n+  {\n+    static constexpr _Tp value = 0;\n+    typedef integral_constant type;\n+  };\n+  typedef integral_constant < int, 0 > true_type;\n+  typedef integral_constant < int, 0 > false_type;\n+    template < typename _Tp > struct enable_if\n+  {\n+    typedef _Tp type;\n+  };\n+}\n+namespace meta\n+{\n+  inline namespace v1\n+  {\n+    template < template < typename ... >class, typename ... >struct defer;\n+      template < typename T > T * _nullptr_v (  );\n+      template < int N > using size_t = std::integral_constant < int, N >;\n+      template < int B > using bool_ = std::integral_constant < int, B >;\n+      template < typename T > using dec =\n+      std::integral_constant < decltype ( T::value ), 0 >;\n+      template < typename T > using eval = typename T::type;\n+      template < typename F, typename ... Args > using apply =\n+      typename F::template apply < Args ... >;\n+    namespace detail\n+    {\n+      template < typename > struct has_type_;\n+    }\n+    template < typename T > using has_type = eval < detail::has_type_ < T >>;\n+      template < typename T > struct id\n+    {\n+      using type = T;\n+    };\n+      template < template < typename ... >class > struct quote;\n+      template < typename > struct Trans_NS_extension_apply_list;\n+      template < typename, typename List > using apply_list =\n+      eval < Trans_NS_extension_apply_list < List >>;\n+    namespace detail\n+    {\n+      template < typename ... >struct _if_;\n+        template < typename If, typename Then > struct _if_ <If,\n+\tThen >:std::enable_if < Then >\n+      {\n+      };\n+    }\n+    template < typename ... Args > using if_ =\n+      eval < detail::_if_ < Args ... >>;\n+      template < int If, typename ... Args > using if_c =\n+      eval < detail::_if_ < bool_ < If >, Args ... >>;\n+    namespace detail\n+    {\n+      template < typename ... >struct _and_:std::true_type\n+      {\n+      };\n+        template < typename ... >struct _or_:std::false_type\n+      {\n+      };\n+    }\n+    template < int >using not_c = bool_ < 0 >;\n+      template < typename Bool > using not_ = not_c < Bool::value >;\n+      template < typename ... >using and_ = eval < detail::_and_ <>>;\n+      template < typename > using or_ = eval < detail::_or_ <>>;\n+    namespace lazy\n+    {\n+      template < typename ... Bools > using and_ = defer < and_, Bools ... >;\n+    }\n+    template < typename ... Ts > struct list\n+    {\n+      static constexpr std::size_t size (  )\n+      {\n+\treturn sizeof ... ( Ts );\n+      }\n+    };\n+      template < typename List > using size = size_t < List::size (  ) >;\n+    namespace detail\n+    {\n+      template < typename > struct concat_;\n+    }\n+    template < typename ... Lists > using concat =\n+      eval < detail::concat_ < Lists ... >>;\n+      template < typename ListOfLists > using join =\n+      apply_list < quote < concat >, ListOfLists >;\n+    namespace detail\n+    {\n+      template < int >struct repeat_n_c_\n+      {\n+\tusing type = list <>;\n+      };\n+    }\n+    template < typename > using repeat_n = eval < detail::repeat_n_c_ < 0 >>;\n+      template < std::size_t N > using repeat_n_c =\n+      eval < detail::repeat_n_c_ < N >>;\n+    namespace detail\n+    {\n+      template < typename > struct at_impl_\n+      {\n+\ttemplate < typename T > static T eval ( T * );\n+      };\n+        template < typename, typename > struct at_;\n+        template < typename ... Ts, typename N > struct at_ <list < Ts ... >,\n+\tN >:decltype ( at_impl_ < repeat_n <\n+\t\t       N >>::eval ( _nullptr_v < id < Ts >> (  )... ) )\n+      {\n+      };\n+    }\n+    template < typename List, typename N > using at =\n+      eval < detail::at_ < List, N >>;\n+    template < typename List, std::size_t > using at_c =\n+      at < List, size_t < 0 >>;\n+    namespace detail\n+    {\n+      template < typename > struct back_;\n+        template < typename Head,\n+\ttypename ... List > struct back_ <list < Head, List ... >>\n+      {\n+\tusing type = at_c < list < Head >, sizeof ... ( List ) >;\n+      };\n+    }\n+    template < typename List > using back = eval < detail::back_ < List >>;\n+    namespace detail\n+    {\n+      template < typename, typename > struct push_front_;\n+        template < typename ... List,\n+\ttypename T > struct push_front_ <list < List ... >, T >\n+      {\n+\tusing type = list < T >;\n+      };\n+    }\n+    template < typename List, typename T > using push_front =\n+      eval < detail::push_front_ < List, T >>;\n+    namespace detail\n+    {\n+      template < typename > struct push_back_;\n+    }\n+    template < typename, typename T > using push_back =\n+      eval < detail::push_back_ < T >>;\n+    namespace detail\n+    {\n+      template < typename > struct transform_;\n+    }\n+    template < typename ... Args > using transform =\n+      eval < detail::transform_ < Args ... >>;\n+    namespace detail\n+    {\n+      template < typename > struct is_valid_;\n+        template < typename As, typename Ts > using substitutions_ =\n+\tpush_back < join < transform < concat < repeat_n_c < size < Ts >\n+      {\n+      }\n+      >>>>, list < back < As >>>;\n+      template < typename Ts > using substitutions =\n+\tapply < if_c < size < Ts >\n+      {\n+      }\n+      , quote < substitutions_ >>>;\n+      template < typename > struct is_vararg_:std::false_type\n+      {\n+      };\n+      template < typename Tags > using is_variadic_ =\n+\tis_vararg_ < at < push_front < Tags, void >, dec < size < Tags >>>>;\n+      template < typename Tags, int =\n+\tis_variadic_ < Tags >::value > struct lambda_;\n+      template < typename ... As > struct lambda_ <list < As ... >, false >\n+      {\n+\tusing Tags = list < As ... >;\n+\tusing F = back < Tags >;\n+\t  template < typename, typename > struct impl;\n+\t  template < typename, typename > struct subst_;\n+\t  template < template < typename ... >class C, typename ... Ts,\n+\t  typename Args > struct subst_ <defer < C, Ts ... >, Args >\n+\t{\n+\t  using type = C < eval < impl < Ts, Args >> ... >;\n+\t};\n+\t  template < template < typename ... >class C, typename ... Ts,\n+\t  typename Args > struct impl <defer < C, Ts ... >,\n+\t  Args >:subst_ < defer < C >, Args >\n+\t{\n+\t};\n+\t  template < typename ... Ts > using apply =\n+\t  eval < if_c < sizeof ... ( Ts ), impl < F, list <>>>>;\n+      };\n+    }\n+    template < typename ... Ts > using lambda =\n+      if_c < sizeof ... ( Ts ), detail::lambda_ < list < Ts ... >>>;\n+    template < typename T > using is_valid = detail::is_valid_ < T >;\n+    namespace detail\n+    {\n+      template < typename ... >struct let_;\n+        template < typename Fn > struct let_ <Fn >\n+      {\n+\tusing type = apply < lambda < Fn >>;\n+      };\n+    }\n+    template < typename ... As > using let = eval < detail::let_ < As ... >>;\n+    template < typename > struct common_reference_base;\n+    template < typename ... >struct common_reference;\n+    namespace detail\n+    {\n+      template < typename > struct builtin_common_impl;\n+        template < typename U > using builtin_common_t =\n+\tmeta::apply < builtin_common_impl < U >>;\n+        template < typename, typename > using lazy_builtin_common_t =\n+\tmeta::defer < builtin_common_t >;\n+        template < typename > struct transform_reference;\n+        template < typename, typename U > using common_reference_base_ =\n+\tcommon_reference_base < meta::eval < transform_reference < U >>>;\n+    }\n+    template < typename T, typename U > struct common_reference <T,\n+      U >:meta::if_ < meta::let < meta::lazy::and_ < meta::is_valid <\n+      detail::lazy_builtin_common_t < T, U >>,\n+      meta::or_ < meta::not_ < meta::has_type <\n+      detail::common_reference_base_ < T, U >>>>>>,\n+      detail::lazy_builtin_common_t < T, U >,\n+      detail::common_reference_base_ < T, U >>\n+    {\n+    };\n+  }\n+}"}]}