{"sha": "2fedcc18cb4a3c2dec2c658a975deb30cc821537", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZlZGNjMThjYjRhM2MyZGVjMmM2NThhOTc1ZGViMzBjYzgyMTUzNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-05-04T17:56:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-06T11:34:52Z"}, "message": "[Ada] Improve run-time performance for large initialized allocators\n\ngcc/ada/\n\n\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): Move to library\n\tlevel and use a new predicate Is_OK_Aggregate to recognize the\n\taggregates suitable for direct assignment by the back-end.\n\t(Convert_Array_Aggr_In_Allocator): If neither in CodePeer mode nor\n\tgenerating C code, generate a direct assignment instead of further\n\texpanding if Aggr_Assignment_OK_For_Backend returns true.", "tree": {"sha": "e41691de80af1df11bb6247b6170cef19f54e7fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e41691de80af1df11bb6247b6170cef19f54e7fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fedcc18cb4a3c2dec2c658a975deb30cc821537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fedcc18cb4a3c2dec2c658a975deb30cc821537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fedcc18cb4a3c2dec2c658a975deb30cc821537", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fedcc18cb4a3c2dec2c658a975deb30cc821537/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60e010e7f39b10bbc8e8b5d8a956335c5b42b39e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60e010e7f39b10bbc8e8b5d8a956335c5b42b39e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60e010e7f39b10bbc8e8b5d8a956335c5b42b39e"}], "stats": {"total": 495, "additions": 273, "deletions": 222}, "files": [{"sha": "6832d401eb6066caf52ced6f916e04eeedd16f05", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 273, "deletions": 222, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fedcc18cb4a3c2dec2c658a975deb30cc821537/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fedcc18cb4a3c2dec2c658a975deb30cc821537/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=2fedcc18cb4a3c2dec2c658a975deb30cc821537", "patch": "@@ -246,6 +246,9 @@ package body Exp_Aggr is\n    -- Local Subprograms for Array Aggregate Expansion --\n    -----------------------------------------------------\n \n+   function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean;\n+   --  Returns true if an aggregate assignment can be done by the back end\n+\n    function Aggr_Size_OK (N : Node_Id; Typ : Entity_Id) return Boolean;\n    --  Very large static aggregates present problems to the back-end, and are\n    --  transformed into assignments and loops. This function verifies that the\n@@ -343,6 +346,246 @@ package body Exp_Aggr is\n    --  false if this transformation cannot be performed. THis is similar to,\n    --  and reuses part of the machinery in Packed_Array_Aggregate_Handled.\n \n+   ------------------------------------\n+   -- Aggr_Assignment_OK_For_Backend --\n+   ------------------------------------\n+\n+   --  Back-end processing by Gigi/gcc is possible only if all the following\n+   --  conditions are met:\n+\n+   --    1. N consists of a single OTHERS choice, possibly recursively, or\n+   --       of a single choice, possibly recursively, if it is surrounded by\n+   --       a qualified expression whose subtype mark is unconstrained.\n+\n+   --    2. The array type has no null ranges (the purpose of this is to\n+   --       avoid a bogus warning for an out-of-range value).\n+\n+   --    3. The array type has no atomic components\n+\n+   --    4. The component type is elementary\n+\n+   --    5. The component size is a multiple of Storage_Unit\n+\n+   --    6. The component size is Storage_Unit or the value is of the form\n+   --       M * (1 + A**1 + A**2 + .. A**(K-1)) where A = 2**(Storage_Unit)\n+   --       and M in 0 .. A-1. This can also be viewed as K occurrences of\n+   --       the Storage_Unit value M, concatenated together.\n+\n+   --  The ultimate goal is to generate a call to a fast memset routine\n+   --  specifically optimized for the target.\n+\n+   function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean is\n+      Csiz      : Uint := No_Uint;\n+      Ctyp      : Entity_Id;\n+      Expr      : Node_Id;\n+      High      : Node_Id;\n+      Index     : Entity_Id;\n+      Low       : Node_Id;\n+      Nunits    : Int;\n+      Remainder : Uint;\n+      Value     : Uint;\n+\n+      function Is_OK_Aggregate (Aggr : Node_Id) return Boolean;\n+      --  Return true if Aggr is suitable for back-end assignment\n+\n+      ---------------------\n+      -- Is_OK_Aggregate --\n+      ---------------------\n+\n+      function Is_OK_Aggregate (Aggr : Node_Id) return Boolean is\n+         Assoc : constant List_Id := Component_Associations (Aggr);\n+\n+      begin\n+         --  An \"others\" aggregate is most likely OK, but see below\n+\n+         if Is_Others_Aggregate (Aggr) then\n+            null;\n+\n+         --  An aggregate with a single choice requires a qualified expression\n+         --  whose subtype mark is an unconstrained type because we need it to\n+         --  have the semantics of an \"others\" aggregate.\n+\n+         elsif Nkind (Parent (N)) = N_Qualified_Expression\n+           and then not Is_Constrained (Entity (Subtype_Mark (Parent (N))))\n+           and then Is_Single_Aggregate (Aggr)\n+         then\n+            null;\n+\n+         --  The other cases are not OK\n+\n+         else\n+            return False;\n+         end if;\n+\n+         --  In any case we do not support an iterated association\n+\n+         return Nkind (First (Assoc)) /= N_Iterated_Component_Association;\n+      end Is_OK_Aggregate;\n+\n+   begin\n+      --  Back end doesn't know about <>\n+\n+      if Has_Default_Init_Comps (N) then\n+         return False;\n+      end if;\n+\n+      --  Recurse as far as possible to find the innermost component type\n+\n+      Ctyp := Etype (N);\n+      Expr := N;\n+      while Is_Array_Type (Ctyp) loop\n+         if Nkind (Expr) /= N_Aggregate\n+           or else not Is_OK_Aggregate (Expr)\n+         then\n+            return False;\n+         end if;\n+\n+         Index := First_Index (Ctyp);\n+         while Present (Index) loop\n+            Get_Index_Bounds (Index, Low, High);\n+\n+            if Is_Null_Range (Low, High) then\n+               return False;\n+            end if;\n+\n+            Next_Index (Index);\n+         end loop;\n+\n+         Expr := Expression (First (Component_Associations (Expr)));\n+\n+         for J in 1 .. Number_Dimensions (Ctyp) - 1 loop\n+            if Nkind (Expr) /= N_Aggregate\n+              or else not Is_OK_Aggregate (Expr)\n+            then\n+               return False;\n+            end if;\n+\n+            Expr := Expression (First (Component_Associations (Expr)));\n+         end loop;\n+\n+         if Has_Atomic_Components (Ctyp) then\n+            return False;\n+         end if;\n+\n+         Csiz := Component_Size (Ctyp);\n+         Ctyp := Component_Type (Ctyp);\n+\n+         if Is_Atomic_Or_VFA (Ctyp) then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      --  Access types need to be dealt with specially\n+\n+      if Is_Access_Type (Ctyp) then\n+\n+         --  Component_Size is not set by Layout_Type if the component\n+         --  type is an access type ???\n+\n+         Csiz := Esize (Ctyp);\n+\n+         --  Fat pointers are rejected as they are not really elementary\n+         --  for the backend.\n+\n+         if Csiz /= System_Address_Size then\n+            return False;\n+         end if;\n+\n+         --  The supported expressions are NULL and constants, others are\n+         --  rejected upfront to avoid being analyzed below, which can be\n+         --  problematic for some of them, for example allocators.\n+\n+         if Nkind (Expr) /= N_Null and then not Is_Entity_Name (Expr) then\n+            return False;\n+         end if;\n+\n+      --  Scalar types are OK if their size is a multiple of Storage_Unit\n+\n+      elsif Is_Scalar_Type (Ctyp) then\n+         pragma Assert (Csiz /= No_Uint);\n+\n+         if Csiz mod System_Storage_Unit /= 0 then\n+            return False;\n+         end if;\n+\n+      --  Composite types are rejected\n+\n+      else\n+         return False;\n+      end if;\n+\n+      --  If the expression has side effects (e.g. contains calls with\n+      --  potential side effects) reject as well. We only preanalyze the\n+      --  expression to prevent the removal of intended side effects.\n+\n+      Preanalyze_And_Resolve (Expr, Ctyp);\n+\n+      if not Side_Effect_Free (Expr) then\n+         return False;\n+      end if;\n+\n+      --  The expression needs to be analyzed if True is returned\n+\n+      Analyze_And_Resolve (Expr, Ctyp);\n+\n+      --  Strip away any conversions from the expression as they simply\n+      --  qualify the real expression.\n+\n+      while Nkind_In (Expr, N_Unchecked_Type_Conversion, N_Type_Conversion)\n+      loop\n+         Expr := Expression (Expr);\n+      end loop;\n+\n+      Nunits := UI_To_Int (Csiz) / System_Storage_Unit;\n+\n+      if Nunits = 1 then\n+         return True;\n+      end if;\n+\n+      if not Compile_Time_Known_Value (Expr) then\n+         return False;\n+      end if;\n+\n+      --  The only supported value for floating point is 0.0\n+\n+      if Is_Floating_Point_Type (Ctyp) then\n+         return Expr_Value_R (Expr) = Ureal_0;\n+      end if;\n+\n+      --  For other types, we can look into the value as an integer, which\n+      --  means the representation value for enumeration literals.\n+\n+      Value := Expr_Rep_Value (Expr);\n+\n+      if Has_Biased_Representation (Ctyp) then\n+         Value := Value - Expr_Value (Type_Low_Bound (Ctyp));\n+      end if;\n+\n+      --  Values 0 and -1 immediately satisfy the last check\n+\n+      if Value = Uint_0 or else Value = Uint_Minus_1 then\n+         return True;\n+      end if;\n+\n+      --  We need to work with an unsigned value\n+\n+      if Value < 0 then\n+         Value := Value + 2**(System_Storage_Unit * Nunits);\n+      end if;\n+\n+      Remainder := Value rem 2**System_Storage_Unit;\n+\n+      for J in 1 .. Nunits - 1 loop\n+         Value := Value / 2**System_Storage_Unit;\n+\n+         if Value rem 2**System_Storage_Unit /= Remainder then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Aggr_Assignment_OK_For_Backend;\n+\n    ------------------\n    -- Aggr_Size_OK --\n    ------------------\n@@ -4107,21 +4350,41 @@ package body Exp_Aggr is\n       Aggr   : Node_Id;\n       Target : Node_Id)\n    is\n-      Aggr_Code : List_Id;\n       Typ       : constant Entity_Id := Etype (Aggr);\n       Ctyp      : constant Entity_Id := Component_Type (Typ);\n+      Aggr_Code : List_Id;\n+      New_Aggr  : Node_Id;\n \n    begin\n-      --  The target is an explicit dereference of the allocated object.\n-      --  Generate component assignments to it, as for an aggregate that\n-      --  appears on the right-hand side of an assignment statement.\n+      --  The target is an explicit dereference of the allocated object\n+\n+      --  If the assignment can be done directly by the back end, then\n+      --  reset Set_Expansion_Delayed and do not expand further.\n+\n+      if not CodePeer_Mode\n+        and then not Modify_Tree_For_C\n+        and then Aggr_Assignment_OK_For_Backend (Aggr)\n+      then\n+         New_Aggr := New_Copy_Tree (Aggr);\n+         Set_Expansion_Delayed (New_Aggr, False);\n+\n+         Aggr_Code :=\n+           New_List (\n+             Make_OK_Assignment_Statement (Sloc (New_Aggr),\n+               Name       => Target,\n+               Expression => New_Aggr));\n+\n+      --  Or else, generate component assignments to it, as for an aggregate\n+      --  that appears on the right-hand side of an assignment statement.\n \n-      Aggr_Code :=\n-        Build_Array_Aggr_Code (Aggr,\n-          Ctype       => Ctyp,\n-          Index       => First_Index (Typ),\n-          Into        => Target,\n-          Scalar_Comp => Is_Scalar_Type (Ctyp));\n+      else\n+         Aggr_Code :=\n+           Build_Array_Aggr_Code (Aggr,\n+             Ctype       => Ctyp,\n+             Index       => First_Index (Typ),\n+             Into        => Target,\n+             Scalar_Comp => Is_Scalar_Type (Ctyp));\n+      end if;\n \n       Insert_Actions_After (Decl, Aggr_Code);\n    end Convert_Array_Aggr_In_Allocator;\n@@ -5299,9 +5562,6 @@ package body Exp_Aggr is\n       --  If Others_Present (J) is True, then there is an others choice in one\n       --  of the subaggregates of N at dimension J.\n \n-      function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean;\n-      --  Returns true if an aggregate assignment can be done by the back end\n-\n       procedure Build_Constrained_Type (Positional : Boolean);\n       --  If the subtype is not static or unconstrained, build a constrained\n       --  type using the computable sizes of the aggregate and its sub-\n@@ -5333,215 +5593,6 @@ package body Exp_Aggr is\n       --  built directly into the target of the assignment it must be free\n       --  of side effects.\n \n-      ------------------------------------\n-      -- Aggr_Assignment_OK_For_Backend --\n-      ------------------------------------\n-\n-      --  Backend processing by Gigi/gcc is possible only if all the following\n-      --  conditions are met:\n-\n-      --    1. N consists of a single OTHERS choice, possibly recursively\n-\n-      --    2. The array type has no null ranges (the purpose of this is to\n-      --       avoid a bogus warning for an out-of-range value).\n-\n-      --    3. The array type has no atomic components\n-\n-      --    4. The component type is elementary\n-\n-      --    5. The component size is a multiple of Storage_Unit\n-\n-      --    6. The component size is Storage_Unit or the value is of the form\n-      --       M * (1 + A**1 + A**2 + .. A**(K-1)) where A = 2**(Storage_Unit)\n-      --       and M in 1 .. A-1. This can also be viewed as K occurrences of\n-      --       the 8-bit value M, concatenated together.\n-\n-      --  The ultimate goal is to generate a call to a fast memset routine\n-      --  specifically optimized for the target.\n-\n-      function Aggr_Assignment_OK_For_Backend (N : Node_Id) return Boolean is\n-         Csiz      : Uint := No_Uint;\n-         Ctyp      : Entity_Id;\n-         Expr      : Node_Id;\n-         High      : Node_Id;\n-         Index     : Entity_Id;\n-         Low       : Node_Id;\n-         Nunits    : Int;\n-         Remainder : Uint;\n-         Value     : Uint;\n-\n-      begin\n-         --  Back end doesn't know about <>\n-\n-         if Has_Default_Init_Comps (N) then\n-            return False;\n-         end if;\n-\n-         --  Recurse as far as possible to find the innermost component type\n-\n-         Ctyp := Etype (N);\n-         Expr := N;\n-         while Is_Array_Type (Ctyp) loop\n-            if Nkind (Expr) /= N_Aggregate\n-              or else not Is_Others_Aggregate (Expr)\n-            then\n-               return False;\n-            end if;\n-\n-            Index := First_Index (Ctyp);\n-            while Present (Index) loop\n-               Get_Index_Bounds (Index, Low, High);\n-\n-               if Is_Null_Range (Low, High) then\n-                  return False;\n-               end if;\n-\n-               Next_Index (Index);\n-            end loop;\n-\n-            Expr := Expression (First (Component_Associations (Expr)));\n-\n-            for J in 1 .. Number_Dimensions (Ctyp) - 1 loop\n-               if Nkind (Expr) /= N_Aggregate\n-                 or else not Is_Others_Aggregate (Expr)\n-               then\n-                  return False;\n-               end if;\n-\n-               Expr := Expression (First (Component_Associations (Expr)));\n-            end loop;\n-\n-            if Has_Atomic_Components (Ctyp) then\n-               return False;\n-            end if;\n-\n-            Csiz := Component_Size (Ctyp);\n-            Ctyp := Component_Type (Ctyp);\n-\n-            if Is_Atomic_Or_VFA (Ctyp) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         --  An Iterated_Component_Association involves a loop (in most cases)\n-         --  and is never static.\n-\n-         if Nkind (Parent (Expr)) = N_Iterated_Component_Association then\n-            return False;\n-         end if;\n-\n-         --  Access types need to be dealt with specially\n-\n-         if Is_Access_Type (Ctyp) then\n-\n-            --  Component_Size is not set by Layout_Type if the component\n-            --  type is an access type ???\n-\n-            Csiz := Esize (Ctyp);\n-\n-            --  Fat pointers are rejected as they are not really elementary\n-            --  for the backend.\n-\n-            if Csiz /= System_Address_Size then\n-               return False;\n-            end if;\n-\n-            --  The supported expressions are NULL and constants, others are\n-            --  rejected upfront to avoid being analyzed below, which can be\n-            --  problematic for some of them, for example allocators.\n-\n-            if Nkind (Expr) /= N_Null and then not Is_Entity_Name (Expr) then\n-               return False;\n-            end if;\n-\n-         --  Scalar types are OK if their size is a multiple of Storage_Unit\n-\n-         elsif Is_Scalar_Type (Ctyp) then\n-            pragma Assert (Csiz /= No_Uint);\n-\n-            if Csiz mod System_Storage_Unit /= 0 then\n-               return False;\n-            end if;\n-\n-         --  Composite types are rejected\n-\n-         else\n-            return False;\n-         end if;\n-\n-         --  If the expression has side effects (e.g. contains calls with\n-         --  potential side effects) reject as well. We only preanalyze the\n-         --  expression to prevent the removal of intended side effects.\n-\n-         Preanalyze_And_Resolve (Expr, Ctyp);\n-\n-         if not Side_Effect_Free (Expr) then\n-            return False;\n-         end if;\n-\n-         --  The expression needs to be analyzed if True is returned\n-\n-         Analyze_And_Resolve (Expr, Ctyp);\n-\n-         --  Strip away any conversions from the expression as they simply\n-         --  qualify the real expression.\n-\n-         while Nkind_In (Expr, N_Unchecked_Type_Conversion,\n-                               N_Type_Conversion)\n-         loop\n-            Expr := Expression (Expr);\n-         end loop;\n-\n-         Nunits := UI_To_Int (Csiz) / System_Storage_Unit;\n-\n-         if Nunits = 1 then\n-            return True;\n-         end if;\n-\n-         if not Compile_Time_Known_Value (Expr) then\n-            return False;\n-         end if;\n-\n-         --  The only supported value for floating point is 0.0\n-\n-         if Is_Floating_Point_Type (Ctyp) then\n-            return Expr_Value_R (Expr) = Ureal_0;\n-         end if;\n-\n-         --  For other types, we can look into the value as an integer, which\n-         --  means the representation value for enumeration literals.\n-\n-         Value := Expr_Rep_Value (Expr);\n-\n-         if Has_Biased_Representation (Ctyp) then\n-            Value := Value - Expr_Value (Type_Low_Bound (Ctyp));\n-         end if;\n-\n-         --  Values 0 and -1 immediately satisfy the last check\n-\n-         if Value = Uint_0 or else Value = Uint_Minus_1 then\n-            return True;\n-         end if;\n-\n-         --  We need to work with an unsigned value\n-\n-         if Value < 0 then\n-            Value := Value + 2**(System_Storage_Unit * Nunits);\n-         end if;\n-\n-         Remainder := Value rem 2**System_Storage_Unit;\n-\n-         for J in 1 .. Nunits - 1 loop\n-            Value := Value / 2**System_Storage_Unit;\n-\n-            if Value rem 2**System_Storage_Unit /= Remainder then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Aggr_Assignment_OK_For_Backend;\n-\n       ----------------------------\n       -- Build_Constrained_Type --\n       ----------------------------"}]}