{"sha": "e2c879a1333c185ffac0e8c4da749ac1a09ca6ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjODc5YTEzMzNjMTg1ZmZhYzBlOGM0ZGE3NDlhYzFhMDljYTZjZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-02-22T15:42:25Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-02-22T15:42:25Z"}, "message": "cfg.c (cached_make_edge): Call make_edge if edge cache is not available.\n\n\t* cfg.c (cached_make_edge): Call make_edge if edge cache is\n\tnot available.  Use tail calls wherever possible.\n\t(make_edge): Call unchecked_make_edge to create an edge.\n\nFrom-SVN: r95396", "tree": {"sha": "d3f550f669389b94a6ae1c48cf11123e7ac1e744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3f550f669389b94a6ae1c48cf11123e7ac1e744"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce/comments", "author": null, "committer": null, "parents": [{"sha": "554beb3a44a24e429ea64b3b77bd7c95990b4849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554beb3a44a24e429ea64b3b77bd7c95990b4849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/554beb3a44a24e429ea64b3b77bd7c95990b4849"}], "stats": {"total": 67, "additions": 34, "deletions": 33}, "files": [{"sha": "a7274af6a63b344b68fa4a5d9c9118db879ce613", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2c879a1333c185ffac0e8c4da749ac1a09ca6ce", "patch": "@@ -1,3 +1,9 @@\n+2005-02-22  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cfg.c (cached_make_edge): Call make_edge if edge cache is\n+\tnot available.  Use tail calls wherever possible.\n+\t(make_edge): Call unchecked_make_edge to create an edge.\n+\n 2005-02-22  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-into-ssa.c (rewrite_blocks): Move debug dumps from ..."}, {"sha": "6737003e60cfe6dd5a7053757e16a2ad991be300", "filename": "gcc/cfg.c", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c879a1333c185ffac0e8c4da749ac1a09ca6ce/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=e2c879a1333c185ffac0e8c4da749ac1a09ca6ce", "patch": "@@ -273,43 +273,29 @@ unchecked_make_edge (basic_block src, basic_block dst, int flags)\n edge\n cached_make_edge (sbitmap *edge_cache, basic_block src, basic_block dst, int flags)\n {\n-  int use_edge_cache;\n-  edge e;\n-\n-  /* Don't bother with edge cache for ENTRY or EXIT, if there aren't that\n-     many edges to them, or we didn't allocate memory for it.  */\n-  use_edge_cache = (edge_cache\n-\t\t    && src != ENTRY_BLOCK_PTR && dst != EXIT_BLOCK_PTR);\n+  if (edge_cache == NULL\n+      || src == ENTRY_BLOCK_PTR\n+      || dst == EXIT_BLOCK_PTR)\n+    return make_edge (src, dst, flags);\n \n-  /* Make sure we don't add duplicate edges.  */\n-  switch (use_edge_cache)\n+  /* Does the requested edge already exist?  */\n+  if (! TEST_BIT (edge_cache[src->index], dst->index))\n     {\n-    default:\n-      /* Quick test for non-existence of the edge.  */\n-      if (! TEST_BIT (edge_cache[src->index], dst->index))\n-\tbreak;\n-\n-      /* The edge exists; early exit if no work to do.  */\n-      if (flags == 0)\n-\treturn NULL;\n-\n-      /* Fall through.  */\n-    case 0:\n-      e = find_edge (src, dst);\n-      if (e)\n-\t{\n-\t  e->flags |= flags;\n-\t  return NULL;\n-\t}\n-      break;\n+      /* The edge does not exist.  Create one and update the\n+\t cache.  */\n+      SET_BIT (edge_cache[src->index], dst->index);\n+      return unchecked_make_edge (src, dst, flags);\n     }\n \n-  e = unchecked_make_edge (src, dst, flags);\n-\n-  if (use_edge_cache)\n-    SET_BIT (edge_cache[src->index], dst->index);\n+  /* At this point, we know that the requested edge exists.  Adjust\n+     flags if necessary.  */\n+  if (flags)\n+    {\n+      edge e = find_edge (src, dst);\n+      e->flags |= flags;\n+    }\n \n-  return e;\n+  return NULL;\n }\n \n /* Create an edge connecting SRC and DEST with flags FLAGS.  Return newly\n@@ -318,7 +304,16 @@ cached_make_edge (sbitmap *edge_cache, basic_block src, basic_block dst, int fla\n edge\n make_edge (basic_block src, basic_block dest, int flags)\n {\n-  return cached_make_edge (NULL, src, dest, flags);\n+  edge e = find_edge (src, dest);\n+\n+  /* Make sure we don't add duplicate edges.  */\n+  if (e)\n+    {\n+      e->flags |= flags;\n+      return NULL;\n+    }\n+\n+  return unchecked_make_edge (src, dest, flags);\n }\n \n /* Create an edge connecting SRC to DEST and set probability by knowing"}]}