{"sha": "f961ec70ee07768f87e9e2ce2b3cac4160fd065e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk2MWVjNzBlZTA3NzY4Zjg3ZTllMmNlMmIzY2FjNDE2MGZkMDY1ZQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2018-12-14T11:49:28Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2018-12-14T11:49:28Z"}, "message": "Fix LRA bug\n\nThis patch fixes an ICE building libgfortran/random.c.\n\nThe problem was an adddi3 instruction that had an eliminable frame pointer.\nGCN adddi3 includes a match_scratch, which LRA substitutes with a REG, and\nchecks if it can be converted back to a scratch afterwards.  In the meantime,\nthe add was converted to a move, meaning that the instruction pattern\ncompletely changed, thus causing a segfault when the instruction is revisited\nin restore_scratches.\n\n2018-12-14  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* gcc/lra-int.h (lra_register_new_scratch_op): Add third parameter.\n\t* gcc/lra-remat.c (update_scratch_ops): Pass icode to\n\tlra_register_new_scratch_op.\n\t* gcc/lra.c (struct sloc): Add icode field.\n\t(lra_register_new_scratch_op): Add icode parameter.\n\tUse icode to skip insns that have changed beyond recognition.\n\nFrom-SVN: r267132", "tree": {"sha": "126a1387fed88b90136c7fc4ca7555804788d726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/126a1387fed88b90136c7fc4ca7555804788d726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f961ec70ee07768f87e9e2ce2b3cac4160fd065e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f961ec70ee07768f87e9e2ce2b3cac4160fd065e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f961ec70ee07768f87e9e2ce2b3cac4160fd065e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65e0a92b2353927e50a26a3a0628a36aebc85b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e0a92b2353927e50a26a3a0628a36aebc85b40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65e0a92b2353927e50a26a3a0628a36aebc85b40"}], "stats": {"total": 25, "additions": 21, "deletions": 4}, "files": [{"sha": "3d4a9e5f8ba307cca7421afaf0e6e079d7e14b8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f961ec70ee07768f87e9e2ce2b3cac4160fd065e", "patch": "@@ -1,3 +1,12 @@\n+2018-12-14  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* gcc/lra-int.h (lra_register_new_scratch_op): Add third parameter.\n+\t* gcc/lra-remat.c (update_scratch_ops): Pass icode to\n+\tlra_register_new_scratch_op.\n+\t* gcc/lra.c (struct sloc): Add icode field.\n+\t(lra_register_new_scratch_op): Add icode parameter.\n+\tUse icode to skip insns that have changed beyond recognition.\n+\n 2018-12-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* dwarf2out.c (analyze_discr_in_predicate): Simplify."}, {"sha": "6e0eb96ddf53d8d6a2f08b938665771660d036ed", "filename": "gcc/lra-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=f961ec70ee07768f87e9e2ce2b3cac4160fd065e", "patch": "@@ -336,7 +336,7 @@ extern void lra_create_copy (int, int, int);\n extern lra_copy_t lra_get_copy (int);\n extern bool lra_former_scratch_p (int);\n extern bool lra_former_scratch_operand_p (rtx_insn *, int);\n-extern void lra_register_new_scratch_op (rtx_insn *, int);\n+extern void lra_register_new_scratch_op (rtx_insn *, int, int);\n \n extern int lra_new_regno_start;\n extern int lra_constraint_new_regno_start;"}, {"sha": "627a248cf032f3f5b1b86a60ba64e38021363bf0", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=f961ec70ee07768f87e9e2ce2b3cac4160fd065e", "patch": "@@ -1042,7 +1042,7 @@ update_scratch_ops (rtx_insn *remat_insn)\n \t    fprintf (lra_dump_file, \"\t Assigning the same %d to r%d\\n\",\n \t\t     REGNO (*loc), hard_regno);\n \t}\n-      lra_register_new_scratch_op (remat_insn, i);\n+      lra_register_new_scratch_op (remat_insn, i, id->icode);\n     }\n   \n }"}, {"sha": "ae82b608d8c012de80fee4927b0f5a99148acc6d", "filename": "gcc/lra.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f961ec70ee07768f87e9e2ce2b3cac4160fd065e/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=f961ec70ee07768f87e9e2ce2b3cac4160fd065e", "patch": "@@ -2026,6 +2026,7 @@ struct sloc\n {\n   rtx_insn *insn; /* Insn where the scratch was.  */\n   int nop;  /* Number of the operand which was a scratch.  */\n+  int icode;  /* Original icode from which scratch was removed.  */\n };\n \n typedef struct sloc *sloc_t;\n@@ -2057,14 +2058,15 @@ lra_former_scratch_operand_p (rtx_insn *insn, int nop)\n /* Register operand NOP in INSN as a former scratch.  It will be\n    changed to scratch back, if it is necessary, at the LRA end.  */\n void\n-lra_register_new_scratch_op (rtx_insn *insn, int nop)\n+lra_register_new_scratch_op (rtx_insn *insn, int nop, int icode)\n {\n   lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n   rtx op = *id->operand_loc[nop];\n   sloc_t loc = XNEW (struct sloc);\n   lra_assert (REG_P (op));\n   loc->insn = insn;\n   loc->nop = nop;\n+  loc->icode = icode;\n   scratches.safe_push (loc);\n   bitmap_set_bit (&scratch_bitmap, REGNO (op));\n   bitmap_set_bit (&scratch_operand_bitmap,\n@@ -2102,7 +2104,7 @@ remove_scratches (void)\n \t      *id->operand_loc[i] = reg\n \t\t= lra_create_new_reg (static_id->operand[i].mode,\n \t\t\t\t      *id->operand_loc[i], ALL_REGS, NULL);\n-\t      lra_register_new_scratch_op (insn, i);\n+\t      lra_register_new_scratch_op (insn, i, id->icode);\n \t      if (lra_dump_file != NULL)\n \t\tfprintf (lra_dump_file,\n \t\t\t \"Removing SCRATCH in insn #%u (nop %d)\\n\",\n@@ -2136,6 +2138,12 @@ restore_scratches (void)\n \t  last = loc->insn;\n \t  id = lra_get_insn_recog_data (last);\n \t}\n+      if (loc->icode != id->icode)\n+\t{\n+\t  /* The icode doesn't match, which means the insn has been modified\n+\t     (e.g. register elimination).  The scratch cannot be restored.  */\n+\t  continue;\n+\t}\n       if (REG_P (*id->operand_loc[loc->nop])\n \t  && ((regno = REGNO (*id->operand_loc[loc->nop]))\n \t      >= FIRST_PSEUDO_REGISTER)"}]}