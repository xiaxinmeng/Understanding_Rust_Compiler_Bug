{"sha": "6f88307147ac7b63c315aab2e81811e985a867a7", "node_id": "C_kwDOANBUbNoAKDZmODgzMDcxNDdhYzdiNjNjMzE1YWFiMmU4MTgxMWU5ODVhODY3YTc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-04T11:18:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-04T15:52:29Z"}, "message": "Refactor type resolution of method call expression\n\nThis simply moves the implementation of this into a cc file to help with\ncompilation times.", "tree": {"sha": "6a2c2ea1e1b4ecff50417af71704dc4467855ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a2c2ea1e1b4ecff50417af71704dc4467855ab5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f88307147ac7b63c315aab2e81811e985a867a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f88307147ac7b63c315aab2e81811e985a867a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f88307147ac7b63c315aab2e81811e985a867a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f88307147ac7b63c315aab2e81811e985a867a7/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da31b651da678fb8ed784191b9dc1ab3e75bd08e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da31b651da678fb8ed784191b9dc1ab3e75bd08e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da31b651da678fb8ed784191b9dc1ab3e75bd08e"}], "stats": {"total": 303, "additions": 152, "deletions": 151}, "files": [{"sha": "c328f410c6c615cf0f699bab8755ee9cfb658809", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f88307147ac7b63c315aab2e81811e985a867a7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f88307147ac7b63c315aab2e81811e985a867a7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=6f88307147ac7b63c315aab2e81811e985a867a7", "patch": "@@ -295,6 +295,157 @@ TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n   infered = array_type->get_element_type ()->clone ();\n }\n \n+void\n+TypeCheckExpr::visit (HIR::MethodCallExpr &expr)\n+{\n+  auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n+  if (receiver_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_receiver ()->get_locus (),\n+\t\t     \"failed to resolve receiver in MethodCallExpr\");\n+      return;\n+    }\n+\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n+\n+  auto candidate\n+    = MethodResolver::Probe (receiver_tyty,\n+\t\t\t     expr.get_method_name ().get_segment ());\n+  if (candidate.is_error ())\n+    {\n+      rust_error_at (\n+\texpr.get_method_name ().get_locus (),\n+\t\"failed to resolve method for %<%s%>\",\n+\texpr.get_method_name ().get_segment ().as_string ().c_str ());\n+      return;\n+    }\n+\n+  // Get the adjusted self\n+  Adjuster adj (receiver_tyty);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // store the adjustments for code-generation to know what to do\n+  context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t      std::move (candidate.adjustments));\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      RichLocation r (expr.get_method_name ().get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated impl item is not a method\");\n+      return;\n+    }\n+\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  if (!fn->is_method ())\n+    {\n+      RichLocation r (expr.get_method_name ().get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated function is not a method\");\n+      return;\n+    }\n+\n+  auto root = receiver_tyty->get_root ();\n+  if (root->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+      if (adt->has_substitutions () && fn->needs_substitution ())\n+\t{\n+\t  // consider the case where we have:\n+\t  //\n+\t  // struct Foo<X,Y>(X,Y);\n+\t  //\n+\t  // impl<T> Foo<T, i32> {\n+\t  //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t  // }\n+\t  //\n+\t  // In this case we end up with an fn type of:\n+\t  //\n+\t  // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t  //\n+\t  // This means the instance or self we are calling this method for\n+\t  // will be substituted such that we can get the inherited type\n+\t  // arguments but then need to use the turbo fish if available or\n+\t  // infer the remaining arguments. Luckily rust does not allow for\n+\t  // default types GenericParams on impl blocks since these must\n+\t  // always be at the end of the list\n+\n+\t  auto s = fn->get_self_type ()->get_root ();\n+\t  rust_assert (s->can_eq (adt, false));\n+\t  rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t  const TyTy::ADTType *self_adt\n+\t    = static_cast<const TyTy::ADTType *> (s);\n+\n+\t  // we need to grab the Self substitutions as the inherit type\n+\t  // parameters for this\n+\t  if (self_adt->needs_substitution ())\n+\t    {\n+\t      rust_assert (adt->was_substituted ());\n+\n+\t      TyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (adt);\n+\n+\t      TyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t= self_adt->solve_mappings_from_receiver_for_self (\n+\t\t  used_args_in_prev_segment);\n+\n+\t      // there may or may not be inherited type arguments\n+\t      if (!inherit_type_args.is_error ())\n+\t\t{\n+\t\t  // need to apply the inherited type arguments to the\n+\t\t  // function\n+\t\t  lookup = fn->handle_substitions (inherit_type_args);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // apply any remaining generic arguments\n+  if (expr.get_method_name ().has_generic_args ())\n+    {\n+      HIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+      lookup\n+\t= SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n+\t\t\t\t&args);\n+      if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+  else if (lookup->needs_generic_substitutions ())\n+    {\n+      lookup = SubstMapper::InferSubst (lookup,\n+\t\t\t\t\texpr.get_method_name ().get_locus ());\n+    }\n+\n+  TyTy::BaseType *function_ret_tyty\n+    = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self, context);\n+  if (function_ret_tyty == nullptr\n+      || function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed to lookup type to MethodCallExpr\");\n+      return;\n+    }\n+\n+  // store the expected fntype\n+  context->insert_type (expr.get_method_name ().get_mappings (), lookup);\n+\n+  // set up the resolved name on the path\n+  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t  resolved_node_id);\n+\n+  // return the result of the function back\n+  infered = function_ret_tyty;\n+}\n+\n bool\n TypeCheckExpr::resolve_operator_overload (\n   Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExprMeta expr,"}, {"sha": "8a0c3054cd7dd79b56b786fa9921963ea4169660", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 1, "deletions": 151, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f88307147ac7b63c315aab2e81811e985a867a7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f88307147ac7b63c315aab2e81811e985a867a7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=6f88307147ac7b63c315aab2e81811e985a867a7", "patch": "@@ -220,157 +220,7 @@ class TypeCheckExpr : public TypeCheckBase\n       = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n   }\n \n-  void visit (HIR::MethodCallExpr &expr) override\n-  {\n-    auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n-    if (receiver_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (expr.get_receiver ()->get_locus (),\n-\t\t       \"failed to resolve receiver in MethodCallExpr\");\n-\treturn;\n-      }\n-\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n-\n-    auto candidate\n-      = MethodResolver::Probe (receiver_tyty,\n-\t\t\t       expr.get_method_name ().get_segment ());\n-    if (candidate.is_error ())\n-      {\n-\trust_error_at (\n-\t  expr.get_method_name ().get_locus (),\n-\t  \"failed to resolve method for %<%s%>\",\n-\t  expr.get_method_name ().get_segment ().as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // Get the adjusted self\n-    Adjuster adj (receiver_tyty);\n-    TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n-\n-    // store the adjustments for code-generation to know what to do\n-    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\tstd::move (candidate.adjustments));\n-\n-    PathProbeCandidate &resolved_candidate = candidate.candidate;\n-    TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n-    NodeId resolved_node_id\n-      = resolved_candidate.is_impl_candidate ()\n-\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n-\t      .get_nodeid ()\n-\t  : resolved_candidate.item.trait.item_ref->get_mappings ()\n-\t      .get_nodeid ();\n-\n-    if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_candidate.locus);\n-\trust_error_at (r, \"associated impl item is not a method\");\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *lookup = lookup_tyty;\n-    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-    if (!fn->is_method ())\n-      {\n-\tRichLocation r (expr.get_method_name ().get_locus ());\n-\tr.add_range (resolved_candidate.locus);\n-\trust_error_at (r, \"associated function is not a method\");\n-\treturn;\n-      }\n-\n-    auto root = receiver_tyty->get_root ();\n-    if (root->get_kind () == TyTy::TypeKind::ADT)\n-      {\n-\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n-\tif (adt->has_substitutions () && fn->needs_substitution ())\n-\t  {\n-\t    // consider the case where we have:\n-\t    //\n-\t    // struct Foo<X,Y>(X,Y);\n-\t    //\n-\t    // impl<T> Foo<T, i32> {\n-\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n-\t    // }\n-\t    //\n-\t    // In this case we end up with an fn type of:\n-\t    //\n-\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n-\t    //\n-\t    // This means the instance or self we are calling this method for\n-\t    // will be substituted such that we can get the inherited type\n-\t    // arguments but then need to use the turbo fish if available or\n-\t    // infer the remaining arguments. Luckily rust does not allow for\n-\t    // default types GenericParams on impl blocks since these must\n-\t    // always be at the end of the list\n-\n-\t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false));\n-\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n-\t    const TyTy::ADTType *self_adt\n-\t      = static_cast<const TyTy::ADTType *> (s);\n-\n-\t    // we need to grab the Self substitutions as the inherit type\n-\t    // parameters for this\n-\t    if (self_adt->needs_substitution ())\n-\t      {\n-\t\trust_assert (adt->was_substituted ());\n-\n-\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n-\t\t  = GetUsedSubstArgs::From (adt);\n-\n-\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n-\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n-\t\t    used_args_in_prev_segment);\n-\n-\t\t// there may or may not be inherited type arguments\n-\t\tif (!inherit_type_args.is_error ())\n-\t\t  {\n-\t\t    // need to apply the inherited type arguments to the\n-\t\t    // function\n-\t\t    lookup = fn->handle_substitions (inherit_type_args);\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n-    // apply any remaining generic arguments\n-    if (expr.get_method_name ().has_generic_args ())\n-      {\n-\tHIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-\tlookup\n-\t  = SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n-\t\t\t\t  &args);\n-\tif (lookup->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n-    else if (lookup->needs_generic_substitutions ())\n-      {\n-\tlookup = SubstMapper::InferSubst (lookup,\n-\t\t\t\t\t  expr.get_method_name ().get_locus ());\n-      }\n-\n-    TyTy::BaseType *function_ret_tyty\n-      = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self,\n-\t\t\t\t\t   context);\n-    if (function_ret_tyty == nullptr\n-\t|| function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to lookup type to MethodCallExpr\");\n-\treturn;\n-      }\n-\n-    // store the expected fntype\n-    context->insert_type (expr.get_method_name ().get_mappings (), lookup);\n-\n-    // set up the resolved name on the path\n-    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t    resolved_node_id);\n-\n-    // return the result of the function back\n-    infered = function_ret_tyty;\n-  }\n+  void visit (HIR::MethodCallExpr &expr) override;\n \n   void visit (HIR::AssignmentExpr &expr) override\n   {"}]}