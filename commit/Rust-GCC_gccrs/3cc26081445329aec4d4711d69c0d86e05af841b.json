{"sha": "3cc26081445329aec4d4711d69c0d86e05af841b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjMjYwODE0NDUzMjlhZWM0ZDQ3MTFkNjljMGQ4NmUwNWFmODQxYg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-04-26T15:34:44Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-26T15:34:44Z"}, "message": "GregorianCalendar.java (setDefaultTime): New method.\n\n\t* java/util/GregorianCalendar.java (setDefaultTime): New method.\n\t(GregorianCalendar): Use it in all constructors.\n\t* java/util/Calendar.java (Calendar): Changed argument name to\n\t`zone' to match code.\n\t* gnu/gcj/text/LocaleData_en.java: Added collatorRule element.\n\t* java/text/CollationKey.java: New file.\n\t* java/text/CollationElementIterator.java: New file.\n\t* java/text/Collator.java: New file.\n\t* java/text/RuleBasedCollator.java: New file.\n\nFrom-SVN: r26654", "tree": {"sha": "a49553afea7d22437a2921c9b7915e6152eb4206", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a49553afea7d22437a2921c9b7915e6152eb4206"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cc26081445329aec4d4711d69c0d86e05af841b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc26081445329aec4d4711d69c0d86e05af841b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cc26081445329aec4d4711d69c0d86e05af841b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc26081445329aec4d4711d69c0d86e05af841b/comments", "author": null, "committer": null, "parents": [{"sha": "d5d9a8b6c3dce9425129aa7ee9bd5ab69ae27c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d9a8b6c3dce9425129aa7ee9bd5ab69ae27c2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5d9a8b6c3dce9425129aa7ee9bd5ab69ae27c2a"}], "stats": {"total": 700, "additions": 698, "deletions": 2}, "files": [{"sha": "af7aa2e1148b44b3127db0391eb4450d1a25d0d1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3cc26081445329aec4d4711d69c0d86e05af841b", "patch": "@@ -1,5 +1,16 @@\n 1999-04-26  Tom Tromey  <tromey@cygnus.com>\n \n+\t* java/util/GregorianCalendar.java (setDefaultTime): New method.\n+\t(GregorianCalendar): Use it in all constructors.\n+\t* java/util/Calendar.java (Calendar): Changed argument name to\n+\t`zone' to match code.\n+\n+\t* gnu/gcj/text/LocaleData_en.java: Added collatorRule element.\n+\t* java/text/CollationKey.java: New file.\n+\t* java/text/CollationElementIterator.java: New file.\n+\t* java/text/Collator.java: New file.\n+\t* java/text/RuleBasedCollator.java: New file.\n+\n \t* Makefile.in: Rebuilt.\n \t* Makefile.am (jv_convert_LDFLAGS): Added -nodefaultlibs.\n \t(jv_convert_LDADD): Explicltly add -lm -lc."}, {"sha": "1286e8af3ef2fd95288b119de8d8b0abc9abeba8", "filename": "libjava/gnu/gcj/text/LocaleData_en.java", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftext%2FLocaleData_en.java?ref=3cc26081445329aec4d4711d69c0d86e05af841b", "patch": "@@ -65,7 +65,13 @@ public final class LocaleData_en extends ListResourceBundle\n     { \"months\", monthsDefault },\n     { \"shortMonths\", shortMonthsDefault },\n     { \"shortWeekdays\", shortWeekdaysDefault },\n-    { \"weekdays\", weekdaysDefault }\n+    { \"weekdays\", weekdaysDefault },\n+\n+    // For RuleBasedCollator.\n+    // FIXME: this is nowhere near complete.\n+    // In particular we must mark accents as ignorable,\n+    // and probably other things as well.\n+    { \"collatorRule\", \"0 < 1 < 2 < 3 < 4 < 5 < 6 < 7 < 8 < 9 < a,A < b,B < c,C < d,D < e,E < f,F < g,G < h,H < i,I < j,J < k,K < l,L < m,M < n,N < o,O < p,P < q,Q < r,R < s,S < t,T < u,U < v,V < w,W < x,X < y,Y < z,Z\" }\n   };\n \n   protected Object[][] getContents ()"}, {"sha": "a6546294b871397b235beb8c3f5709938609aebc", "filename": "libjava/java/text/CollationElementIterator.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Ftext%2FCollationElementIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Ftext%2FCollationElementIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCollationElementIterator.java?ref=3cc26081445329aec4d4711d69c0d86e05af841b", "patch": "@@ -0,0 +1,75 @@\n+// CollationElementIterator.java - Iterate over decomposed characters.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.text;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 25, 1999\n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 from http://www.javasoft.com.\n+ * Status: Believed complete and correct to JDK 1.1.\n+ */\n+\n+public final class CollationElementIterator\n+{\n+  public static final int NULLORDER = 0xffffffff;\n+\n+  public int next ()\n+  {\n+    if (index == text.length())\n+      return NULLORDER;\n+    return RuleBasedCollator.ceiNext(this);\n+  }\n+\n+  // This one returns int while the others return short.\n+  public static final int primaryOrder (int order)\n+  {\n+    // From the JDK 1.2 spec.\n+    return order >>> 16;\n+  }\n+\n+  public void reset ()\n+  {\n+    index = 0;\n+  }\n+\n+  public static final short secondaryOrder (int order)\n+  {\n+    // From the JDK 1.2 spec.\n+    return (order >>> 8) & 255;\n+  }\n+\n+  public static final short tertiaryOrder (int order)\n+  {\n+    // From the JDK 1.2 spec.\n+    return order & 255;\n+  }\n+\n+  // Non-public constructor.\n+  CollationElementIterator (String text)\n+  {\n+    this.text = text;\n+    this.index = 0;\n+    this.lookahead_set = false;\n+    this.lookahead = 0;\n+  }\n+\n+  // Text over which we iterate.\n+  String text;\n+\n+  // Index of next character to examine in TEXT.\n+  int index;\n+\n+  // A piece of lookahead.\n+  boolean lookahead_set;\n+  int lookahead;\n+}"}, {"sha": "05a9932206f36fda32fb744ba2f26f1dc4ed3633", "filename": "libjava/java/text/CollationKey.java", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Ftext%2FCollationKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Ftext%2FCollationKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCollationKey.java?ref=3cc26081445329aec4d4711d69c0d86e05af841b", "patch": "@@ -0,0 +1,104 @@\n+// CollationKey.java - Sort key for locale-sensitive String.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.text;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 25, 1999\n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 from http://www.javasoft.com.\n+ * Status: Believed complete and correct.\n+ */\n+\n+public final class CollationKey\n+{\n+  public int compareTo (CollationKey target)\n+  {\n+    int max = Math.min(key.length, target.key.length);\n+\n+    for (int i = 0; i < max; ++i)\n+      {\n+\tif (key[i] != target.key[i])\n+\t  return key[i] - target.key[i];\n+      }\n+\n+    return key.length - target.key.length;\n+  }\n+\n+  public boolean equals (Object obj)\n+  {\n+    if (! (obj instanceof CollationKey))\n+      return false;\n+\n+    CollationKey ck = (CollationKey) obj;\n+\n+    if (key.length != ck.key.length)\n+      return false;\n+\n+    for (int i = 0; i < key.length; ++i)\n+      if (key[i] != ck.key[i])\n+\treturn false;\n+\n+    return true;\n+  }\n+\n+  public String getSourceString ()\n+  {\n+    return originalText;\n+  }\n+\n+  public int hashCode ()\n+  {\n+    // We just follow BitSet instead of thinking up something new.\n+    long h = originalText.hashCode();\n+    for (int i = key.length - 1; i >= 0; --i)\n+      h ^= key[i] * (i + 1);\n+    return (int) ((h >> 32) ^ h);\n+  }\n+\n+  public byte[] toByteArray ()\n+  {\n+    byte[] r = new byte[4 * key.length];\n+    int off = 0;\n+    for (int i = 0; i < key.length; ++i)\n+      {\n+\tr[off++] = (byte) ((key[i] >>> 24) & 255);\n+\tr[off++] = (byte) ((key[i] >>> 16) & 255);\n+\tr[off++] = (byte) ((key[i] >>>  8) & 255);\n+\tr[off++] = (byte) ((key[i]       ) & 255);\n+      }\n+    return r;\n+  }\n+\n+  CollationKey (CollationElementIterator iter, String originalText,\n+\t\tint strength)\n+  {\n+    this.originalText = originalText;\n+\n+    // Compute size of required array.\n+    int size = 0;\n+    while (RuleBasedCollator.next(iter, strength)\n+\t   != CollationElementIterator.NULLORDER)\n+      ++size;\n+\n+    iter.reset();\n+    key = new int[size];\n+    for (int i = 0; i < size; i++)\n+      key[i] = RuleBasedCollator.next(iter, strength);\n+  }\n+\n+  // Original string.\n+  private String originalText;\n+\n+  // Collation key.\n+  private int[] key;\n+}"}, {"sha": "ad7a5ca30c14c4435ff1eb51c3b9bde6ea093368", "filename": "libjava/java/text/Collator.java", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Ftext%2FCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Ftext%2FCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCollator.java?ref=3cc26081445329aec4d4711d69c0d86e05af841b", "patch": "@@ -0,0 +1,130 @@\n+// Collator.java - Locale-sensitive string comparison.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.text;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 18, 1999\n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 from http://www.javasoft.com.\n+ * Status: Mostly complete, but parts stubbed out.  Look for FIXME.\n+ */\n+\n+public abstract class Collator implements Cloneable, Serializable\n+{\n+  public static final int NO_DECOMPOSITION = 0;\n+  public static final int CANONCIAL_DECOMPOSITION = 1;\n+  public static final int FULL_DECOMPOSITION = 2;\n+\n+  public static final int PRIMARY = 0;\n+  public static final int SECONDARY = 1;\n+  public static final int TERTIARY = 2;\n+  public static final int IDENTICAL = 3;\n+\n+  protected Collator ()\n+  {\n+    strength = TERTIARY;\n+    decmp = CANONCIAL_DECOMPOSITION;\n+  }\n+\n+  public abstract int compare (String source, String target);\n+\n+  public boolean equals (Object obj)\n+  {\n+    if (! (obj instanceof Collator))\n+      return false;\n+    Collator c = (Collator) obj;\n+    return decmp == c.decmp && strength == c.strength;\n+  }\n+\n+  public boolean equals (String source, String target)\n+  {\n+    return compare (source, target) == 0;\n+  }\n+\n+  public static synchronized Locale[] getAvailableLocales ()\n+  {\n+    // FIXME.\n+    return null;\n+  }\n+\n+  public abstract CollationKey getCollationKey (String source);\n+\n+  public synchronized int getDecomposition ()\n+  {\n+    return decmp;\n+  }\n+\n+  public static Collator getInstance ()\n+  {\n+    return getInstance (Locale.getDefault());\n+  }\n+\n+  public static Collator getInstance (Locale loc)\n+  {\n+    ResourceBundle res;\n+    String pattern;\n+    try\n+      {\n+\tres = ResourceBundle.getBundle(\"gnu.gcj.text.LocaleData\", loc);\n+\tpattern = res.getString(\"collatorRule\");\n+      }\n+    catch (MissingResourceException x)\n+      {\n+\treturn null;\n+      }\n+    try\n+      {\n+\treturn new RuleBasedCollator (pattern);\n+      }\n+    catch (ParseException x)\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  public synchronized int getStrength ()\n+  {\n+    return strength;\n+  }\n+\n+  public abstract int hashCode ();\n+\n+  public synchronized void setDecomposition (int mode)\n+  {\n+    if (mode != NO_DECOMPOSITION\n+\t&& mode != CANONCIAL_DECOMPOSITION\n+\t&& mode != FULL_DECOMPOSITION)\n+      throw new IllegalArgumentException ();\n+    decmp = mode;\n+  }\n+\n+  public synchronized void setStrength (int strength)\n+  {\n+    if (strength != PRIMARY && strength != SECONDARY\n+\t&& strength != TERTIARY && strength != IDENTICAL)\n+      throw new IllegalArgumentException ();\n+    this.strength = strength;\n+  }\n+\n+  // Decompose a single character and append results to the buffer.\n+  protected native final void decomposeCharacter (char c, StringBuffer buf);\n+\n+  // These names are fixed by the serialization spec.\n+  protected int decmp;\n+  protected int strength;\n+}"}, {"sha": "18046adf9e539d1cfa531e0b5534fda204addcb8", "filename": "libjava/java/text/RuleBasedCollator.java", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java?ref=3cc26081445329aec4d4711d69c0d86e05af841b", "patch": "@@ -0,0 +1,361 @@\n+// RuleBasedCollator.java - Concrete class for locale-based string compare.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package java.text;\n+\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date March 25, 1999\n+ */\n+/* Written using \"Java Class Libraries\", 2nd edition, plus online\n+ * API docs for JDK 1.2 from http://www.javasoft.com.\n+ * Status: Believed complete and correct\n+ */\n+\n+class RBCElement\n+{\n+  String key;\n+  char relation;\n+\n+  RBCElement (String key, char relation)\n+  {\n+    this.key = key;\n+    this.relation = relation;\n+  }\n+}\n+\n+public class RuleBasedCollator extends Collator\n+{\n+  public Object clone ()\n+  {\n+    return new RuleBasedCollator (this);\n+  }\n+\n+  // A helper for CollationElementIterator.next().\n+  static int ceiNext (CollationElementIterator cei)\n+  {\n+    if (cei.lookahead_set)\n+      {\n+\tcei.lookahead_set = false;\n+\treturn cei.lookahead;\n+      }\n+\n+    int save = cei.index;\n+    int max = cei.text.length();\n+    String s = null;\n+\n+    // It is possible to have a case where `abc' has a mapping, but\n+    // neither `ab' nor `abd' do.  In this case we must treat `abd' as\n+    // nothing special.\n+    boolean found = false;\n+\n+    int i;\n+    for (i = save; i < max; ++i)\n+      {\n+\ts = cei.text.substring(save, i);\n+\tif (prefixes.get(s) == null)\n+\t  break;\n+\tfound = true;\n+      }\n+    // Assume s != null.\n+\n+    Object obj = map.get(s);\n+    // The special case.\n+    while (found && obj == null && s.length() > 1)\n+      {\n+\t--i;\n+\ts = cei.text.substring(save, i);\n+\tobj = map.get(s);\n+      }\n+\n+    // Update state.\n+    cei.index = i;\n+\n+    if (obj == null)\n+      {\n+\t// This idea, and the values, come from JDK.\n+\t// assert (s.length() == 1)\n+\tcei.lookahead_set = true;\n+\tcei.lookahead = s.charAt(0) << 8;\n+\treturn 0x7fff << 16;\n+      }\n+\n+    return ((Integer) obj).intValue();\n+  }\n+\n+  // A helper for compareTo() that returns the next character that has\n+  // a nonzero ordering at the indicated strength.  This is also used\n+  // in CollationKey.\n+  static final int next (CollationElementIterator iter, int strength)\n+  {\n+    while (true)\n+      {\n+\tint os = iter.next();\n+\tif (os == CollationElementIterator.NULLORDER)\n+\t  return os;\n+\tint c = 0;\n+\tswitch (strength)\n+\t  {\n+\t  case PRIMARY:\n+\t    c |= CollationElementIterator.primaryOrder(os);\n+\t    /* Fall through.  */\n+\t  case SECONDARY:\n+\t    c |= CollationElementIterator.secondaryOrder(os);\n+\t    /* Fall through.  */\n+\t  case TERTIARY:\n+\t    c |= CollationElementIterator.tertiaryOrder(os);\n+\t    break;\n+\t  case IDENTICAL:\n+\t    c = os;\n+\t  }\n+\tif (c != 0)\n+\t  return c;\n+      }\n+  }\n+\n+  public int compare (String source, String target)\n+  {\n+    CollationElementIterator cs, ct;\n+\n+    cs = new CollationElementIterator (source);\n+    ct = new CollationElementIterator (target);\n+\n+    while (true)\n+      {\n+\tint os = next (cs, strength);\n+\tint ot = next (ct, strength);\n+\n+\tif (os == CollationElementIterator.NULLORDER\n+\t    && ot == CollationElementIterator.NULLORDER)\n+\t  break;\n+\telse if (os == CollationElementIterator.NULLORDER)\n+\t  return 1;\n+\telse if (ot == CollationElementIterator.NULLORDER)\n+\t  return -1;\n+\n+\tif (os != ot)\n+\t  return os - ot;\n+      }\n+\n+    return 0;\n+  }\n+\n+  public boolean equals (Object obj)\n+  {\n+    if (! (obj instanceof RuleBasedCollator) || ! super.equals(obj))\n+      return false;\n+    RuleBasedCollator rbc = (RuleBasedCollator) obj;\n+    // FIXME: this is probably wrong.  Instead we should compare maps\n+    // directly.\n+    return (frenchAccents == rbc.frenchAccents\n+\t    && rules.equals(rbc.rules));\n+  }\n+\n+  public CollationElementIterator getCollationElementIterator (String source)\n+  {\n+    StringBuffer expand = new StringBuffer (source.length());\n+    int max = source.length();\n+    for (int i = 0; i < max; ++i)\n+      decomposeCharacter (source.charAt(i), expand);\n+    return new CollationElementIterator (expand.toString());\n+  }\n+\n+  public CollationKey getCollationKey (String source)\n+  {\n+    return new CollationKey (getCollationElementIterator (source), source,\n+\t\t\t     strength);\n+  }\n+\n+  public String getRules ()\n+  {\n+    return rules;\n+  }\n+\n+  public int hashCode ()\n+  {\n+    return (frenchAccents ? 1231 : 1237\n+\t    ^ rules.hashCode()\n+\t    ^ map.hashCode()\n+\t    ^ prefixes.hashCode());\n+  }\n+\n+  private final boolean is_special (char c)\n+  {\n+    // Rules from JCL book.\n+    return ((c >= 0x0009 && c <= 0x000d)\n+\t    || (c >= 0x0020 && c <= 0x002f)\n+\t    || (c >= 0x003a && c <= 0x0040)\n+\t    || (c >= 0x005b && c <= 0x0060)\n+\t    || (c >= 0x007b && c <= 0x007e));\n+  }\n+\n+  private final int text_argument (String rules, int index,\n+\t\t\t\t   StringBuffer result)\n+  {\n+    result.setLength(0);\n+    int len = rules.length();\n+    while (index < len)\n+      {\n+\tchar c = rules.charAt(index);\n+\tif (c == '\\'' && index + 2 < len\n+\t    && rules.charAt(index + 2) == '\\''\n+\t    && is_special (rules.charAt(index + 1)))\n+\t  index += 2;\n+\telse if (is_special (c) || Character.isWhitespace(c))\n+\t  return index;\n+\tresult.append(c);\n+\t++index;\n+      }\n+    return index;\n+  }\n+\n+  public RuleBasedCollator (String rules) throws ParseException\n+  {\n+    this.rules = rules;\n+    this.frenchAccents = false;\n+\n+    // We keep each rule in order in a vector.  At the end we traverse\n+    // the vector and compute collation values from it.\n+    int insertion_index = 0;\n+    Vector vec = new Vector ();\n+\n+    StringBuffer argument = new StringBuffer ();\n+\n+    int len = rules.length();\n+    for (int index = 0; index < len; ++index)\n+      {\n+\tchar c = rules.charAt(index);\n+\n+\t// Just skip whitespace.\n+\tif (Character.isWhitespace(c))\n+\t  continue;\n+\n+\t// Modifier.\n+\tif (c == '@')\n+\t  {\n+\t    frenchAccents = true;\n+\t    continue;\n+\t  }\n+\n+\t// Check for relation or reset operator.\n+\tif (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))\n+\t  throw new ParseException (\"invalid character\", index);\n+\n+\t++index;\n+\twhile (index < len)\n+\t  {\n+\t    if (! Character.isWhitespace(rules.charAt(index)))\n+\t      break;\n+\t    ++index;\n+\t  }\n+\tif (index == len)\n+\t  throw new ParseException (\"missing argument\", index);\n+\n+\tint save = index;\n+\tindex = text_argument (rules, index, argument);\n+\tif (argument.length() == 0)\n+\t  throw new ParseException (\"invalid character\", save);\n+\tString arg = argument.toString();\n+\tint item_index = vec.indexOf(arg);\n+\tif (c != '&')\n+\t  {\n+\t    // If the argument already appears in the vector, then we\n+\t    // must remove it in order to re-order.\n+\t    if (item_index != -1)\n+\t      {\n+\t\tvec.removeElementAt(item_index);\n+\t\tif (insertion_index >= item_index)\n+\t\t  --insertion_index;\n+\t      }\n+\t    RBCElement r = new RBCElement (arg, c);\n+\t    vec.insertElementAt(r, insertion_index);\n+\t    ++insertion_index;\n+\t  }\n+\telse\n+\t  {\n+\t    // Reset.\n+\t    if (item_index == -1)\n+\t      throw\n+\t\tnew ParseException (\"argument to reset not previously seen\",\n+\t\t\t\t    save);\n+\t    insertion_index = item_index + 1;\n+\t  }\n+\n+\t// Ugly: in this case the resulting INDEX comes from\n+\t// text_argument, which returns the index of the next\n+\t// character we should examine.\n+\t--index;\n+      }\n+\n+    // Now construct a hash table that maps strings onto their\n+    // collation values.\n+    int primary = 0;\n+    int secondary = 0;\n+    int tertiary = 0;\n+    this.map = new Hashtable ();\n+    this.prefixes = new Hashtable ();\n+    Enumeration e = vec.elements();\n+    while (e.hasMoreElements())\n+      {\n+\tRBCElement r = (RBCElement) e.nextElement();\n+\tswitch (r.relation)\n+\t  {\n+\t  case '<':\n+\t    ++primary;\n+\t    secondary = 0;\n+\t    tertiary = 0;\n+\t    break;\n+\t  case ';':\n+\t    ++secondary;\n+\t    tertiary = 0;\n+\t    break;\n+\t  case ',':\n+\t    ++tertiary;\n+\t    break;\n+\t  case '=':\n+\t    break;\n+\t  }\n+\t// This must match CollationElementIterator.\n+\tmap.put(r.key, new Integer (primary << 16\n+\t\t\t\t    | secondary << 8 | tertiary));\n+\n+\t// Make a map of all lookaheads we might need.\n+\tfor (int i = r.key.length() - 1; i >= 1; --i)\n+\t  prefixes.put(r.key.substring(0, i), Boolean.TRUE);\n+      }\n+  }\n+\n+  // This is a helper for clone.\n+  private RuleBasedCollator (RuleBasedCollator other)\n+  {\n+    frenchAccents = other.frenchAccents;\n+    rules = other.rules;\n+    decmp = other.decmp;\n+    strength = other.strength;\n+    map = other.map;\n+    prefixes = other.prefixes;\n+  }\n+\n+  // True if we are using French-style accent ordering.\n+  private boolean frenchAccents;\n+\n+  // It's easier to just save the rules than to try to recreate them.\n+  private String rules;\n+\n+  // This maps strings onto collation values.\n+  private Hashtable map;\n+  // An entry in this hash means that more lookahead is required for\n+  // the prefix string.\n+  private Hashtable prefixes;\n+}"}, {"sha": "f4806a35bdc2e1335244d615eb7cd45b8588567e", "filename": "libjava/java/util/Calendar.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Futil%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Futil%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCalendar.java?ref=3cc26081445329aec4d4711d69c0d86e05af841b", "patch": "@@ -88,7 +88,7 @@ protected Calendar ()\n     this (null, null);\n   }\n \n-  protected Calendar (TimeZone tx, Locale loc)\n+  protected Calendar (TimeZone zone, Locale loc)\n   {\n     fields = new int[FIELD_COUNT];\n     isSet = new boolean[FIELD_COUNT];"}, {"sha": "26a9814fc8cb8ac7befefb464cc20a591378d349", "filename": "libjava/java/util/GregorianCalendar.java", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cc26081445329aec4d4711d69c0d86e05af841b/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=3cc26081445329aec4d4711d69c0d86e05af841b", "patch": "@@ -107,28 +107,37 @@ public GregorianCalendar (Locale locale)\n   public GregorianCalendar (TimeZone zone, Locale locale)\n   {\n     super (zone, locale);\n+    setDefaultTime ();\n   }\n \n   public GregorianCalendar (int year, int month, int date)\n   {\n     this((TimeZone) null);\n+    setDefaultTime ();\n     set (year, month, date);\n   }\n \n   public GregorianCalendar (int year, int month, int date,\n \t\t\t    int hour, int minute)\n   {\n     this((TimeZone) null);\n+    setDefaultTime ();\n     set (year, month, date, hour, minute);\n   }\n \n   public GregorianCalendar (int year, int month, int date,\n \t\t\t    int hour, int minute, int second)\n   {\n     this((TimeZone) null);\n+    setDefaultTime ();\n     set (year, month, date, hour, minute, second);\n   }\n \n+  private final void setDefaultTime ()\n+  {\n+    setTimeInMillis (System.currentTimeMillis());\n+  }\n+\n   public int getMinimum(int calfield) { return mins[calfield]; }\n   public int getGreatestMinimum(int calfield) { return mins[calfield]; }\n   public int getMaximum(int calfield) { return maxs[calfield]; }"}]}