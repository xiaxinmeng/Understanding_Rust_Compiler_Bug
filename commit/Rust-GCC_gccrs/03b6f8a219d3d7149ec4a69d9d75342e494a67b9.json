{"sha": "03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiNmY4YTIxOWQzZDcxNDllYzRhNjlkOWQ3NTM0MmU0OTRhNjdiOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-09-26T11:25:23Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-09-26T11:25:23Z"}, "message": "decl.c (gnat_to_gnu_entity): Filter out negative size for the array dimensions like in the constrained case.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Filter out\n\tnegative size for the array dimensions like in the constrained case.\n\t<E_Array_Subtype>: Do not create an artificially non-constant high\n\tbound if the low bound is non-constant.  Minor tweaks.\n\n\t* gcc-interface/trans.c (lvalue_required_p): Add CONSTANT parameter\n\tand turn ALIASED into a boolean parameter.  Adjust calls to self.\n\t<N_Attribute_Reference>: Return 1 for more attributes.\n\t<N_Object_Renaming_Declaration>: Return 1 for non-constant objects.\n\t<N_Assignment_Statement>: Return 1 for the LHS.\n\t(Identifier_to_gnu): Adjust calls to lvalue_required_p.\n\t(call_to_gnu): Be prepared for wrapped boolean rvalues.\n\nFrom-SVN: r152201", "tree": {"sha": "67569ab9ab216cac9149ef9e9867fe4340750fc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67569ab9ab216cac9149ef9e9867fe4340750fc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/comments", "author": null, "committer": null, "parents": [{"sha": "6191ca81314cf337a6f4577195b91f685f6bef3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6191ca81314cf337a6f4577195b91f685f6bef3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6191ca81314cf337a6f4577195b91f685f6bef3f"}], "stats": {"total": 154, "additions": 118, "deletions": 36}, "files": [{"sha": "b0112a15162f78ca7d950b8e40c3e8397e1283e2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "patch": "@@ -1,3 +1,18 @@\n+2009-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Filter out\n+\tnegative size for the array dimensions like in the constrained case.\n+\t<E_Array_Subtype>: Do not create an artificially non-constant high\n+\tbound if the low bound is non-constant.  Minor tweaks.\n+\n+\t* gcc-interface/trans.c (lvalue_required_p): Add CONSTANT parameter\n+\tand turn ALIASED into a boolean parameter.  Adjust calls to self.\n+\t<N_Attribute_Reference>: Return 1 for more attributes.\n+\t<N_Object_Renaming_Declaration>: Return 1 for non-constant objects.\n+\t<N_Assignment_Statement>: Return 1 for the LHS.\n+\t(Identifier_to_gnu): Adjust calls to lvalue_required_p.\n+\t(call_to_gnu): Be prepared for wrapped boolean rvalues.\n+\n 2009-09-25  Olivier Hainquqe  <hainque@adacore.com>\n             Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "12d57bcd88faa8d0c6b744ccd44a83a6521bf0e3", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "patch": "@@ -1852,7 +1852,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    char field_name[16];\n \t    tree gnu_index_base_type\n \t      = get_unpadded_type (Base_Type (Etype (gnat_index)));\n-\t    tree gnu_low_field, gnu_high_field, gnu_low, gnu_high;\n+\t    tree gnu_low_field, gnu_high_field, gnu_low, gnu_high, gnu_max;\n \n \t    /* Make the FIELD_DECLs for the low and high bounds of this\n \t       type and then make extractions of these fields from the\n@@ -1885,11 +1885,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t       NULL_TREE);\n \t    TREE_READONLY (gnu_low) = TREE_READONLY (gnu_high) = 1;\n \n+\t    /* Compute the size of this dimension.  */\n+\t    gnu_max\n+\t      = build3 (COND_EXPR, gnu_index_base_type,\n+\t\t\tbuild2 (GE_EXPR, integer_type_node, gnu_high, gnu_low),\n+\t\t\tgnu_high,\n+\t\t\tbuild2 (MINUS_EXPR, gnu_index_base_type,\n+\t\t\t\tgnu_low, fold_convert (gnu_index_base_type,\n+\t\t\t\t\t\t       integer_one_node)));\n+\n \t    /* Make a range type with the new range in the Ada base type.\n-\t       Then make an index type with the new range in sizetype.  */\n+\t       Then make an index type with the size range in sizetype.  */\n \t    gnu_index_types[index]\n \t      = create_index_type (convert (sizetype, gnu_low),\n-\t\t\t\t   convert (sizetype, gnu_high),\n+\t\t\t\t   convert (sizetype, gnu_max),\n \t\t\t\t   create_range_type (gnu_index_base_type,\n \t\t\t\t\t\t      gnu_low, gnu_high),\n \t\t\t\t   gnat_entity);\n@@ -2130,12 +2139,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       gnat_base_index = Next_Index (gnat_base_index))\n \t    {\n \t      tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n-\t      tree prec = TYPE_RM_SIZE (gnu_index_type);\n-\t      const bool wider_p\n-\t\t= (compare_tree_int (prec, TYPE_PRECISION (sizetype)) > 0\n-\t\t   || (compare_tree_int (prec, TYPE_PRECISION (sizetype)) == 0\n-\t\t       && TYPE_UNSIGNED (gnu_index_type)\n-\t\t\t  != TYPE_UNSIGNED (sizetype)));\n+\t      const int prec_comp\n+\t\t= compare_tree_int (TYPE_RM_SIZE (gnu_index_type),\n+\t\t\t\t    TYPE_PRECISION (sizetype));\n+\t      const bool subrange_p = (prec_comp < 0)\n+\t\t\t\t      || (prec_comp == 0\n+\t\t\t\t\t  && TYPE_UNSIGNED (gnu_index_type)\n+\t\t\t\t\t     == TYPE_UNSIGNED (sizetype));\n+\t      const bool wider_p = (prec_comp > 0);\n \t      tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n \t      tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n \t      tree gnu_min = convert (sizetype, gnu_orig_min);\n@@ -2144,7 +2155,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t= get_unpadded_type (Etype (gnat_base_index));\n \t      tree gnu_base_orig_min = TYPE_MIN_VALUE (gnu_base_index_type);\n \t      tree gnu_base_orig_max = TYPE_MAX_VALUE (gnu_base_index_type);\n-\t      tree gnu_high;\n+\t      tree gnu_high, gnu_low;\n \n \t      /* See if the base array type is already flat.  If it is, we\n \t\t are probably compiling an ACATS test but it will cause the\n@@ -2160,7 +2171,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* Similarly, if one of the values overflows in sizetype and the\n \t\t range is null, use 1..0 for the sizetype bounds.  */\n-\t      else if (wider_p\n+\t      else if (!subrange_p\n \t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && (TREE_OVERFLOW (gnu_min) || TREE_OVERFLOW (gnu_max))\n@@ -2174,7 +2185,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      /* If the minimum and maximum values both overflow in sizetype,\n \t\t but the difference in the original type does not overflow in\n \t\t sizetype, ignore the overflow indication.  */\n-\t      else if (wider_p\n+\t      else if (!subrange_p\n \t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n@@ -2200,25 +2211,41 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* Otherwise, if we can prove that the low bound minus one and\n \t\t the high bound cannot overflow, we can just use the expression\n-\t\t MAX (hb, lb - 1).  Otherwise, we have to use the most general\n-\t\t expression (hb >= lb) ? hb : lb - 1.  Note that the comparison\n-\t\t must be done in the original index type, to avoid any overflow\n-\t\t during the conversion.  */\n+\t\t MAX (hb, lb - 1).  Similarly, if we can prove that the high\n+\t\t bound plus one and the low bound cannot overflow, we can use\n+\t\t the high bound as-is and MIN (hb + 1, lb) for the low bound.\n+\t\t Otherwise, we have to fall back to the most general expression\n+\t\t (hb >= lb) ? hb : lb - 1.  Note that the comparison must be\n+\t\t done in the original index type, to avoid any overflow during\n+\t\t the conversion.  */\n \t      else\n \t\t{\n \t\t  gnu_high = size_binop (MINUS_EXPR, gnu_min, size_one_node);\n-\n-\t\t  /* If gnu_high is a constant that has overflowed, the bound\n-\t\t     is the smallest integer so cannot be the maximum.  */\n-\t\t  if (TREE_CODE (gnu_high) == INTEGER_CST\n-\t\t      && TREE_OVERFLOW (gnu_high))\n+\t\t  gnu_low = size_binop (PLUS_EXPR, gnu_max, size_one_node);\n+\n+\t\t  /* If gnu_high is a constant that has overflowed, the low\n+\t\t     bound is the smallest integer so cannot be the maximum.\n+\t\t     If gnu_low is a constant that has overflowed, the high\n+\t\t     bound is the highest integer so cannot be the minimum.  */\n+\t\t  if ((TREE_CODE (gnu_high) == INTEGER_CST\n+\t\t       && TREE_OVERFLOW (gnu_high))\n+\t\t      || (TREE_CODE (gnu_low) == INTEGER_CST\n+\t\t\t   && TREE_OVERFLOW (gnu_low)))\n \t\t    gnu_high = gnu_max;\n \n-\t\t  /* If the index type is not wider and gnu_high is a constant\n+\t\t  /* If the index type is a subrange and gnu_high a constant\n \t\t     that hasn't overflowed, we can use the maximum.  */\n-\t\t  else if (!wider_p && TREE_CODE (gnu_high) == INTEGER_CST)\n+\t\t  else if (subrange_p && TREE_CODE (gnu_high) == INTEGER_CST)\n \t\t    gnu_high = size_binop (MAX_EXPR, gnu_max, gnu_high);\n \n+\t\t  /* If the index type is a subrange and gnu_low a constant\n+\t\t     that hasn't overflowed, we can use the minimum.  */\n+\t\t  else if (subrange_p && TREE_CODE (gnu_low) == INTEGER_CST)\n+\t\t    {\n+\t\t      gnu_high = gnu_max;\n+\t\t      gnu_min = size_binop (MIN_EXPR, gnu_min, gnu_low);\n+\t\t    }\n+\n \t\t  else\n \t\t    gnu_high\n \t\t      = build_cond_expr (sizetype,\n@@ -2298,7 +2325,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      && TREE_CODE (TREE_TYPE (gnu_index_type))\n \t\t\t != INTEGER_TYPE)\n \t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_index_type)\n-\t\t  || compare_tree_int (prec, TYPE_PRECISION (sizetype)) > 0)\n+\t\t  || wider_p)\n \t\tneed_index_type_struct = true;\n \t    }\n "}, {"sha": "d94d1f45bfc17142e51b21eb86f5a9ec7810dd88", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "patch": "@@ -217,7 +217,7 @@ static tree maybe_implicit_deref (tree);\n static tree gnat_stabilize_reference (tree, bool);\n static tree gnat_stabilize_reference_1 (tree, bool);\n static void set_expr_location_from_node (tree, Node_Id);\n-static int lvalue_required_p (Node_Id, tree, int);\n+static int lvalue_required_p (Node_Id, tree, bool, bool);\n \n /* Hooks for debug info back-ends, only supported and used in a restricted set\n    of configurations.  */\n@@ -659,16 +659,19 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n \f\n /* Return a positive value if an lvalue is required for GNAT_NODE.\n    GNU_TYPE is the type that will be used for GNAT_NODE in the\n-   translated GNU tree.  ALIASED indicates whether the underlying\n-   object represented by GNAT_NODE is aliased in the Ada sense.\n+   translated GNU tree.  CONSTANT indicates whether the underlying\n+   object represented by GNAT_NODE is constant in the Ada sense,\n+   ALIASED whether it is aliased (but the latter doesn't affect\n+   the outcome if CONSTANT is not true).\n \n    The function climbs up the GNAT tree starting from the node and\n    returns 1 upon encountering a node that effectively requires an\n    lvalue downstream.  It returns int instead of bool to facilitate\n    usage in non purely binary logic contexts.  */\n \n static int\n-lvalue_required_p (Node_Id gnat_node, tree gnu_type, int aliased)\n+lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n+\t\t   bool aliased)\n {\n   Node_Id gnat_parent = Parent (gnat_node), gnat_temp;\n \n@@ -683,7 +686,12 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, int aliased)\n \treturn id == Attr_Address\n \t       || id == Attr_Access\n \t       || id == Attr_Unchecked_Access\n-\t       || id == Attr_Unrestricted_Access;\n+\t       || id == Attr_Unrestricted_Access\n+\t       || id == Attr_Bit_Position\n+\t       || id == Attr_Position\n+\t       || id == Attr_First_Bit\n+\t       || id == Attr_Last_Bit\n+\t       || id == Attr_Bit;\n       }\n \n     case N_Parameter_Association:\n@@ -714,19 +722,20 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, int aliased)\n \treturn 0;\n \n       aliased |= Has_Aliased_Components (Etype (gnat_node));\n-      return lvalue_required_p (gnat_parent, gnu_type, aliased);\n+      return lvalue_required_p (gnat_parent, gnu_type, constant, aliased);\n \n     case N_Selected_Component:\n       aliased |= Is_Aliased (Entity (Selector_Name (gnat_parent)));\n-      return lvalue_required_p (gnat_parent, gnu_type, aliased);\n+      return lvalue_required_p (gnat_parent, gnu_type, constant, aliased);\n \n     case N_Object_Renaming_Declaration:\n       /* We need to make a real renaming only if the constant object is\n \t aliased or if we may use a renaming pointer; otherwise we can\n \t optimize and return the rvalue.  We make an exception if the object\n \t is an identifier since in this case the rvalue can be propagated\n \t attached to the CONST_DECL.  */\n-      return (aliased != 0\n+      return (!constant\n+\t      || aliased\n \t      /* This should match the constant case of the renaming code.  */\n \t      || Is_Composite_Type\n \t\t (Underlying_Type (Etype (Name (gnat_parent))))\n@@ -741,8 +750,9 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, int aliased)\n     case N_Assignment_Statement:\n       /* We cannot use a constructor if the LHS is an atomic object because\n \t the actual assignment might end up being done component-wise.  */\n-      return Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n-\t     && Is_Atomic (Entity (Name (gnat_parent)));\n+      return (Name (gnat_parent) == gnat_node\n+\t      || (Is_Composite_Type (Underlying_Type (Etype (gnat_node)))\n+\t\t  && Is_Atomic (Entity (Name (gnat_parent)))));\n \n     default:\n       return 0;\n@@ -851,7 +861,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       && !Is_Imported (gnat_temp)\n       && Present (Address_Clause (gnat_temp)))\n     {\n-      require_lvalue = lvalue_required_p (gnat_node, gnu_result_type,\n+      require_lvalue = lvalue_required_p (gnat_node, gnu_result_type, true,\n \t\t\t\t\t  Is_Aliased (gnat_temp));\n       use_constant_initializer = !require_lvalue;\n     }\n@@ -957,7 +967,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t the CST value if an lvalue is not required.  Evaluate this\n \t now if we have not already done so.  */\n       if (object && require_lvalue < 0)\n-\trequire_lvalue = lvalue_required_p (gnat_node, gnu_result_type,\n+\trequire_lvalue = lvalue_required_p (gnat_node, gnu_result_type, true,\n \t\t\t\t\t    Is_Aliased (gnat_temp));\n \n       if (!object || !require_lvalue)\n@@ -2931,6 +2941,12 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t  gnu_result = convert (TREE_TYPE (gnu_actual), gnu_result);\n \t      }\n \n+\t    /* Undo wrapping of boolean rvalues.  */\n+\t    if (TREE_CODE (gnu_actual) == NE_EXPR\n+\t\t&& TREE_CODE (get_base_type (TREE_TYPE (gnu_actual)))\n+\t\t   == BOOLEAN_TYPE\n+\t\t&& integer_zerop (TREE_OPERAND (gnu_actual, 1)))\n+\t      gnu_actual = TREE_OPERAND (gnu_actual, 0);\n \t    gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t\t\t  gnu_actual, gnu_result);\n \t    set_expr_location_from_node (gnu_result, gnat_node);"}, {"sha": "2bfffbe834074aa85a6c770a78d07fe26fc1cbeb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "patch": "@@ -1,3 +1,7 @@\n+2009-09-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/array9.adb: New test.\n+\n 2009-09-26  Michael Matz  <matz@suse.de>\n \n \tPR tree-optimization/41454"}, {"sha": "4a13876187241ab86a5f11e4622575d5217b11d2", "filename": "gcc/testsuite/gnat.dg/array9.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Ftestsuite%2Fgnat.dg%2Farray9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b6f8a219d3d7149ec4a69d9d75342e494a67b9/gcc%2Ftestsuite%2Fgnat.dg%2Farray9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray9.adb?ref=03b6f8a219d3d7149ec4a69d9d75342e494a67b9", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do run }\n+\n+procedure Array9 is\n+\n+  V1 : String(1..10) := \"1234567890\";\n+  V2 : String(1..-1) := \"\";\n+\n+  procedure Compare (S : String) is\n+  begin\n+    if S'Size /= 8*S'Length then\n+      raise Program_Error;\n+    end if;\n+  end;\n+\n+begin\n+  Compare (\"\");\n+  Compare (\"1234\");\n+  Compare (V1);\n+  Compare (V2);\n+end;"}]}