{"sha": "b086d5308de0d25444243f482f2f3d1dfd3a9a62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA4NmQ1MzA4ZGUwZDI1NDQ0MjQzZjQ4MmYyZjNkMWRmZDNhOWE2Mg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-09-02T22:46:00Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-09-02T22:46:00Z"}, "message": "support ggc hash_map  and hash_set\n\ngcc/ChangeLog:\n\n\t* alloc-pool.c: Include coretypes.h.\n\t* cgraph.h, dbxout.c, dwarf2out.c, except.c, except.h, function.c,\n\tfunction.h, symtab.c, tree-cfg.c, tree-eh.c: Use hash_map and\n\thash_set instead of htab.\n\t* ggc-page.c (in_gc): New variable.\n\t(ggc_free): Do nothing if a collection is taking place.\n\t(ggc_collect): Set in_gc appropriately.\n\t* ggc.h (gt_ggc_mx(const char *)): New function.\n\t(gt_pch_nx(const char *)): Likewise.\n\t(gt_ggc_mx(int)): Likewise.\n\t(gt_pch_nx(int)): Likewise.\n\t* hash-map.h (hash_map::hash_entry::ggc_mx): Likewise.\n\t(hash_map::hash_entry::pch_nx): Likewise.\n\t(hash_map::hash_entry::pch_nx_helper): Likewise.\n(hash_map::hash_map): Adjust.\n(hash_map::create_ggc): New function.\n(gt_ggc_mx): Likewise.\n(gt_pch_nx): Likewise.\n\t* hash-set.h (default_hashset_traits::ggc_mx): Likewise.\n(default_hashset_traits::pch_nx): Likewise.\n(hash_set::hash_entry::ggc_mx): Likewise.\n(hash_set::hash_entry::pch_nx): Likewise.\n(hash_set::hash_entry::pch_nx_helper): Likewise.\n(hash_set::hash_set): Adjust.\n(hash_set::create_ggc): New function.\n(hash_set::elements): Likewise.\n(gt_ggc_mx): Likewise.\n(gt_pch_nx): Likewise.\n\t* hash-table.h (hash_table::hash_table): Adjust.\n(hash_table::m_ggc): New member.\n\t(hash_table::~hash_table): Adjust.\n\t(hash_table::expand): Likewise.\n\t(hash_table::empty): Likewise.\n(gt_ggc_mx): New function.\n\t(hashtab_entry_note_pointers): Likewise.\n(gt_pch_nx): Likewise.\n\nFrom-SVN: r214834", "tree": {"sha": "cb4aa8d407cf40f28ef0fcd771f1109d53f44f3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb4aa8d407cf40f28ef0fcd771f1109d53f44f3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b086d5308de0d25444243f482f2f3d1dfd3a9a62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b086d5308de0d25444243f482f2f3d1dfd3a9a62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b086d5308de0d25444243f482f2f3d1dfd3a9a62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b086d5308de0d25444243f482f2f3d1dfd3a9a62/comments", "author": null, "committer": null, "parents": [{"sha": "70f0f8b2b1c9bf53b9158e4264bc1e93b963c31e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f0f8b2b1c9bf53b9158e4264bc1e93b963c31e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f0f8b2b1c9bf53b9158e4264bc1e93b963c31e"}], "stats": {"total": 576, "additions": 402, "deletions": 174}, "files": [{"sha": "22e69c0e7db0eb95003e1e3a5ed172bda1aef4eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -1,3 +1,42 @@\n+2014-09-02  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* alloc-pool.c: Include coretypes.h.\n+\t* cgraph.h, dbxout.c, dwarf2out.c, except.c, except.h, function.c,\n+\tfunction.h, symtab.c, tree-cfg.c, tree-eh.c: Use hash_map and\n+\thash_set instead of htab.\n+\t* ggc-page.c (in_gc): New variable.\n+\t(ggc_free): Do nothing if a collection is taking place.\n+\t(ggc_collect): Set in_gc appropriately.\n+\t* ggc.h (gt_ggc_mx(const char *)): New function.\n+\t(gt_pch_nx(const char *)): Likewise.\n+\t(gt_ggc_mx(int)): Likewise.\n+\t(gt_pch_nx(int)): Likewise.\n+\t* hash-map.h (hash_map::hash_entry::ggc_mx): Likewise.\n+\t(hash_map::hash_entry::pch_nx): Likewise.\n+\t(hash_map::hash_entry::pch_nx_helper): Likewise.\n+(hash_map::hash_map): Adjust.\n+(hash_map::create_ggc): New function.\n+(gt_ggc_mx): Likewise.\n+(gt_pch_nx): Likewise.\n+\t* hash-set.h (default_hashset_traits::ggc_mx): Likewise.\n+(default_hashset_traits::pch_nx): Likewise.\n+(hash_set::hash_entry::ggc_mx): Likewise.\n+(hash_set::hash_entry::pch_nx): Likewise.\n+(hash_set::hash_entry::pch_nx_helper): Likewise.\n+(hash_set::hash_set): Adjust.\n+(hash_set::create_ggc): New function.\n+(hash_set::elements): Likewise.\n+(gt_ggc_mx): Likewise.\n+(gt_pch_nx): Likewise.\n+\t* hash-table.h (hash_table::hash_table): Adjust.\n+(hash_table::m_ggc): New member.\n+\t(hash_table::~hash_table): Adjust.\n+\t(hash_table::expand): Likewise.\n+\t(hash_table::empty): Likewise.\n+(gt_ggc_mx): New function.\n+\t(hashtab_entry_note_pointers): Likewise.\n+(gt_pch_nx): Likewise.\n+\n 2014-09-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000-builtin.def (XVCVSXDDP_SCALE):  New"}, {"sha": "bfaa0e4662f77821ab266cb83415af8625ca814f", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"coretypes.h\"\n #include \"alloc-pool.h\"\n #include \"hash-table.h\"\n #include \"hash-map.h\""}, {"sha": "030a1c771b7c72741146ec7d3d6a2fa6c7289dcd", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -1604,7 +1604,6 @@ struct cgraph_2node_hook_list;\n \n /* Map from a symbol to initialization/finalization priorities.  */\n struct GTY(()) symbol_priority_map {\n-  symtab_node *symbol;\n   priority_type init;\n   priority_type fini;\n };\n@@ -1872,7 +1871,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   htab_t GTY((param_is (symtab_node))) assembler_name_hash;\n \n   /* Hash table used to hold init priorities.  */\n-  htab_t GTY ((param_is (symbol_priority_map))) init_priority_hash;\n+  hash_map<symtab_node *, symbol_priority_map> *init_priority_hash;\n \n   FILE* GTY ((skip)) dump_file;\n "}, {"sha": "d856bddc115d8fa4f3bdb1d0bbece8a587ba0dfd", "filename": "gcc/dbxout.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -2484,12 +2484,9 @@ dbxout_expand_expr (tree expr)\n /* Helper function for output_used_types.  Queue one entry from the\n    used types hash to be output.  */\n \n-static int\n-output_used_types_helper (void **slot, void *data)\n+bool\n+output_used_types_helper (tree const &type, vec<tree> *types_p)\n {\n-  tree type = (tree) *slot;\n-  vec<tree> *types_p = (vec<tree> *) data;\n-\n   if ((TREE_CODE (type) == RECORD_TYPE\n        || TREE_CODE (type) == UNION_TYPE\n        || TREE_CODE (type) == QUAL_UNION_TYPE\n@@ -2502,7 +2499,7 @@ output_used_types_helper (void **slot, void *data)\n \t   && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n     types_p->quick_push (TYPE_NAME (type));\n \n-  return 1;\n+  return true;\n }\n \n /* This is a qsort callback which sorts types and declarations into a\n@@ -2544,8 +2541,9 @@ output_used_types (void)\n       int i;\n       tree type;\n \n-      types.create (htab_elements (cfun->used_types_hash));\n-      htab_traverse (cfun->used_types_hash, output_used_types_helper, &types);\n+      types.create (cfun->used_types_hash->elements ());\n+      cfun->used_types_hash->traverse<vec<tree> *, output_used_types_helper>\n+       \t(&types);\n \n       /* Sort by UID to prevent dependence on hash table ordering.  */\n       types.qsort (output_types_sort);"}, {"sha": "21afc3fe21ea4123e8703b4e0ba8ead899169198", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -18013,17 +18013,15 @@ dwarf2out_abstract_function (tree decl)\n    Marks the DIE of a given type in *SLOT as perennial, so it never gets\n    marked as unused by prune_unused_types.  */\n \n-static int\n-premark_used_types_helper (void **slot, void *data ATTRIBUTE_UNUSED)\n+bool\n+premark_used_types_helper (tree const &type, void *)\n {\n-  tree type;\n   dw_die_ref die;\n \n-  type = (tree) *slot;\n   die = lookup_type_die (type);\n   if (die != NULL)\n     die->die_perennial_p = 1;\n-  return 1;\n+  return true;\n }\n \n /* Helper function of premark_types_used_by_global_vars which gets called\n@@ -18066,7 +18064,7 @@ static void\n premark_used_types (struct function *fun)\n {\n   if (fun && fun->used_types_hash)\n-    htab_traverse (fun->used_types_hash, premark_used_types_helper, NULL);\n+    fun->used_types_hash->traverse<void *, premark_used_types_helper> (NULL);\n }\n \n /* Mark all members of types_used_by_vars_entry as perennial.  */"}, {"sha": "fecc06046a231f32efa41018646a07ad7bc8f1f0", "filename": "gcc/except.c", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -149,8 +149,13 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n static GTY(()) int call_site_base;\n-static GTY ((param_is (union tree_node)))\n-  htab_t type_to_runtime_map;\n+\n+struct tree_hash_traits : default_hashmap_traits\n+{\n+  static hashval_t hash (tree t) { return TREE_HASH (t); }\n+};\n+\n+static GTY (()) hash_map<tree, tree, tree_hash_traits> *type_to_runtime_map;\n \n /* Describe the SjLj_Function_Context structure.  */\n static GTY(()) tree sjlj_fc_type_node;\n@@ -213,9 +218,6 @@ typedef hash_table<action_record_hasher> action_hash_type;\n static bool get_eh_region_and_lp_from_rtx (const_rtx, eh_region *,\n \t\t\t\t\t   eh_landing_pad *);\n \n-static int t2r_eq (const void *, const void *);\n-static hashval_t t2r_hash (const void *);\n-\n static void dw2_build_landing_pads (void);\n \n static int collect_one_action_chain (action_hash_type *, eh_region);\n@@ -237,7 +239,8 @@ init_eh (void)\n   if (! flag_exceptions)\n     return;\n \n-  type_to_runtime_map = htab_create_ggc (31, t2r_hash, t2r_eq, NULL);\n+  type_to_runtime_map\n+    = hash_map<tree, tree, tree_hash_traits>::create_ggc (31);\n \n   /* Create the SjLj_Function_Context structure.  This should match\n      the definition in unwind-sjlj.c.  */\n@@ -671,54 +674,28 @@ eh_region_outermost (struct function *ifun, eh_region region_a,\n   return region_a;\n }\n \f\n-static int\n-t2r_eq (const void *pentry, const void *pdata)\n-{\n-  const_tree const entry = (const_tree) pentry;\n-  const_tree const data = (const_tree) pdata;\n-\n-  return TREE_PURPOSE (entry) == data;\n-}\n-\n-static hashval_t\n-t2r_hash (const void *pentry)\n-{\n-  const_tree const entry = (const_tree) pentry;\n-  return TREE_HASH (TREE_PURPOSE (entry));\n-}\n-\n void\n add_type_for_runtime (tree type)\n {\n-  tree *slot;\n-\n   /* If TYPE is NOP_EXPR, it means that it already is a runtime type.  */\n   if (TREE_CODE (type) == NOP_EXPR)\n     return;\n \n-  slot = (tree *) htab_find_slot_with_hash (type_to_runtime_map, type,\n-\t\t\t\t\t    TREE_HASH (type), INSERT);\n-  if (*slot == NULL)\n-    {\n-      tree runtime = lang_hooks.eh_runtime_type (type);\n-      *slot = tree_cons (type, runtime, NULL_TREE);\n-    }\n+  bool existed = false;\n+  tree *slot = &type_to_runtime_map->get_or_insert (type, &existed);\n+  if (!existed)\n+    *slot = lang_hooks.eh_runtime_type (type);\n }\n \n tree\n lookup_type_for_runtime (tree type)\n {\n-  tree *slot;\n-\n   /* If TYPE is NOP_EXPR, it means that it already is a runtime type.  */\n   if (TREE_CODE (type) == NOP_EXPR)\n     return type;\n \n-  slot = (tree *) htab_find_slot_with_hash (type_to_runtime_map, type,\n-\t\t\t\t\t    TREE_HASH (type), NO_INSERT);\n-\n   /* We should have always inserted the data earlier.  */\n-  return TREE_VALUE (*slot);\n+  return *type_to_runtime_map->get (type);\n }\n \n \f\n@@ -3150,12 +3127,12 @@ output_function_exception_table (const char *fnname)\n }\n \n void\n-set_eh_throw_stmt_table (struct function *fun, struct htab *table)\n+set_eh_throw_stmt_table (function *fun, hash_map<gimple, int> *table)\n {\n   fun->eh->throw_stmt_table = table;\n }\n \n-htab_t\n+hash_map<gimple, int> *\n get_eh_throw_stmt_table (struct function *fun)\n {\n   return fun->eh->throw_stmt_table;"}, {"sha": "325915132048cd22a54b2468a8b24655ac0fb2c4", "filename": "gcc/except.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -204,7 +204,7 @@ struct GTY(()) eh_status\n \n   /* At the gimple level, a mapping from gimple statement to landing pad\n      or must-not-throw region.  See record_stmt_eh_region.  */\n-  htab_t GTY((param_is (struct throw_stmt_node))) throw_stmt_table;\n+  hash_map<gimple, int> *GTY(()) throw_stmt_table;\n \n   /* All of the runtime type data used by the function.  These objects\n      are emitted to the lang-specific-data-area for the function.  */\n@@ -291,8 +291,8 @@ struct GTY(()) throw_stmt_node {\n   int lp_nr;\n };\n \n-extern struct htab *get_eh_throw_stmt_table (struct function *);\n-extern void set_eh_throw_stmt_table (struct function *, struct htab *);\n+extern hash_map<gimple, int> *get_eh_throw_stmt_table (struct function *);\n+extern void set_eh_throw_stmt_table (function *, hash_map<gimple, int> *);\n \n enum eh_personality_kind {\n   eh_personality_none,"}, {"sha": "2e46799f751076d7d88591b015cd0b1609c87e3c", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -6093,14 +6093,10 @@ used_types_insert_helper (tree type, struct function *func)\n {\n   if (type != NULL && func != NULL)\n     {\n-      void **slot;\n-\n       if (func->used_types_hash == NULL)\n-\tfunc->used_types_hash = htab_create_ggc (37, htab_hash_pointer,\n-\t\t\t\t\t\t htab_eq_pointer, NULL);\n-      slot = htab_find_slot (func->used_types_hash, type, INSERT);\n-      if (*slot == NULL)\n-\t*slot = type;\n+\tfunc->used_types_hash = hash_set<tree>::create_ggc (37);\n+\n+      func->used_types_hash->add (type);\n     }\n }\n "}, {"sha": "e71210df350acf0bc3721fcab70aa306dbb83b40", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_FUNCTION_H\n \n #include \"hashtab.h\"\n+#include \"hash-set.h\"\n #include \"vec.h\"\n #include \"machmode.h\"\n #include \"tm.h\"\t\t\t/* For CUMULATIVE_ARGS.  */\n@@ -564,7 +565,7 @@ struct GTY(()) function {\n   struct language_function * language;\n \n   /* Used types hash table.  */\n-  htab_t GTY ((param_is (union tree_node))) used_types_hash;\n+  hash_set<tree> *GTY (()) used_types_hash;\n \n   /* Dwarf2 Frame Description Entry, containing the Call Frame Instructions\n      used for unwinding.  Only set when either dwarf2 unwinding or dwarf2"}, {"sha": "2a9b2d9e7fa4d7cc2aa148f134433dd5098dfdf3", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -500,6 +500,10 @@ static struct globals\n   } stats;\n } G;\n \n+/* True if a gc is currently taking place.  */\n+\n+static bool in_gc = false;\n+\n /* The size in bytes required to maintain a bitmap for the objects\n    on a page-entry.  */\n #define BITMAP_SIZE(Num_objects) \\\n@@ -1574,6 +1578,9 @@ ggc_get_size (const void *p)\n void\n ggc_free (void *p)\n {\n+  if (in_gc)\n+    return;\n+\n   page_entry *pe = lookup_page_table_entry (p);\n   size_t order = pe->order;\n   size_t size = OBJECT_SIZE (order);\n@@ -2139,7 +2146,6 @@ ggc_collect (void)\n     MAX (G.allocated_last_gc, (size_t)PARAM_VALUE (GGC_MIN_HEAPSIZE) * 1024);\n \n   float min_expand = allocated_last_gc * PARAM_VALUE (GGC_MIN_EXPAND) / 100;\n-\n   if (G.allocated < allocated_last_gc + min_expand && !ggc_force_collect)\n     return;\n \n@@ -2162,6 +2168,7 @@ ggc_collect (void)\n \n   invoke_plugin_callbacks (PLUGIN_GGC_START, NULL);\n \n+  in_gc = true;\n   clear_marks ();\n   ggc_mark_roots ();\n   ggc_handle_finalizers ();\n@@ -2173,6 +2180,7 @@ ggc_collect (void)\n   validate_free_objects ();\n   sweep_pages ();\n \n+  in_gc = false;\n   G.allocated_last_gc = G.allocated;\n \n   invoke_plugin_callbacks (PLUGIN_GGC_END, NULL);"}, {"sha": "6280c433809944d57d38ff271d6616941c8f6628", "filename": "gcc/ggc.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -337,4 +337,25 @@ ggc_alloc_cleared_gimple_statement_stat (size_t s CXX_MEM_STAT_INFO)\n     ggc_internal_cleared_alloc (s PASS_MEM_STAT);\n }\n \n+static inline void\n+gt_ggc_mx (const char *s)\n+{\n+  ggc_test_and_set_mark (const_cast<char *> (s));\n+}\n+\n+static inline void\n+gt_pch_nx (const char *)\n+{\n+}\n+\n+static inline void\n+gt_ggc_mx (int)\n+{\n+}\n+\n+static inline void\n+gt_pch_nx (int)\n+{\n+}\n+\n #endif"}, {"sha": "c65e1e57999776d818ecc390e6afe6b7bc86d08a", "filename": "gcc/hash-map.h", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef hash_map_h\n #define hash_map_h\n \n+#include <new>\n #include \"hash-table.h\"\n \n /* implement default behavior for traits when types allow it.  */\n@@ -103,7 +104,7 @@ struct default_hashmap_traits\n \n template<typename Key, typename Value,\n \t typename Traits = default_hashmap_traits>\n-class hash_map\n+class GTY((user)) hash_map\n {\n   struct hash_entry\n   {\n@@ -135,10 +136,56 @@ class hash_map\n \n     static void mark_empty (hash_entry &e) { Traits::mark_empty (e); }\n     static bool is_empty (const hash_entry &e) { return Traits::is_empty (e); }\n+\n+    static void ggc_mx (hash_entry &e)\n+      {\n+\tgt_ggc_mx (e.m_key);\n+\tgt_ggc_mx (e.m_value);\n+      }\n+\n+    static void pch_nx (hash_entry &e)\n+      {\n+\tgt_pch_nx (e.m_key);\n+\tgt_pch_nx (e.m_value);\n+      }\n+\n+    static void pch_nx (hash_entry &e, gt_pointer_operator op, void *c)\n+      {\n+\tpch_nx_helper (e.m_key, op, c);\n+\tpch_nx_helper (e.m_value, op, c);\n+      }\n+\n+  private:\n+    template<typename T>\n+    static void\n+      pch_nx_helper (T &x, gt_pointer_operator op, void *cookie)\n+\t{\n+\t  gt_pch_nx (&x, op, cookie);\n+\t}\n+\n+    static void\n+      pch_nx_helper (int, gt_pointer_operator, void *)\n+\t{\n+\t}\n+\n+    template<typename T>\n+      static void\n+      pch_nx_helper (T *&x, gt_pointer_operator op, void *cookie)\n+\t{\n+\t  op (&x, cookie);\n+\t}\n   };\n \n public:\n-  explicit hash_map (size_t n = 13) : m_table (n) {}\n+  explicit hash_map (size_t n = 13, bool ggc = false) : m_table (n, ggc) {}\n+\n+  /* Create a hash_map in ggc memory.  */\n+  static hash_map *create_ggc (size_t size)\n+    {\n+      hash_map *map = ggc_alloc<hash_map> ();\n+      new (map) hash_map (size, true);\n+      return map;\n+    }\n \n   /* If key k isn't already in the map add key k with value v to the map, and\n      return false.  Otherwise set the value of the entry for key k to be v and\n@@ -208,7 +255,35 @@ class hash_map\n     }\n \n private:\n+\n+  template<typename T, typename U, typename V> friend void gt_ggc_mx (hash_map<T, U, V> *);\n+  template<typename T, typename U, typename V> friend void gt_pch_nx (hash_map<T, U, V> *);\n+      template<typename T, typename U, typename V> friend void gt_pch_nx (hash_map<T, U, V> *, gt_pointer_operator, void *);\n+\n   hash_table<hash_entry> m_table;\n };\n \n+/* ggc marking routines.  */\n+\n+template<typename K, typename V, typename H>\n+static inline void\n+gt_ggc_mx (hash_map<K, V, H> *h)\n+{\n+  gt_ggc_mx (&h->m_table);\n+}\n+\n+template<typename K, typename V, typename H>\n+static inline void\n+gt_pch_nx (hash_map<K, V, H> *h)\n+{\n+  gt_pch_nx (&h->m_table);\n+}\n+\n+template<typename K, typename V, typename H>\n+static inline void\n+gt_pch_nx (hash_map<K, V, H> *h, gt_pointer_operator op, void *cookie)\n+{\n+  op (&h->m_table.m_entries, cookie);\n+}\n+\n #endif"}, {"sha": "0a500cb441ab3fe3565442bba0655259bfffa418", "filename": "gcc/hash-set.h", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -81,6 +81,26 @@ struct default_hashset_traits\n   /* Return true if the passed in entry is marked as empty.  */\n \n   template<typename T> static bool is_empty (T *e) { return e == NULL; }\n+\n+  /* ggc walking routine, mark all objects refered to by this one.  */\n+\n+  template<typename T>\n+  static void\n+  ggc_mx (T &x)\n+    {\n+      extern void gt_ggc_mx (T &);\n+      gt_ggc_mx (x);\n+    }\n+\n+  /* pch walking routine, note all objects refered to by this element.  */\n+\n+  template<typename T>\n+  static void\n+  pch_nx (T &x)\n+    {\n+      extern void gt_pch_nx (T &);\n+      gt_pch_nx (x);\n+    }\n };\n \n template<typename Key, typename Traits = default_hashset_traits>\n@@ -128,10 +148,50 @@ class hash_set\n       {\n \treturn Traits::is_empty (e.m_key);\n       }\n+\n+    static void ggc_mx (hash_entry &e)\n+      {\n+\tTraits::ggc_mx (e.m_key);\n+      }\n+\n+    static void pch_nx (hash_entry &e)\n+      {\n+\tTraits::pch_nx (e.m_key);\n+      }\n+\n+    static void pch_nx (hash_entry &e, gt_pointer_operator op, void *c)\n+      {\n+\tpch_nx_helper (e.m_key, op, c);\n+      }\n+\n+  private:\n+    template<typename T>\n+    static void\n+      pch_nx_helper (T &x, gt_pointer_operator op, void *cookie)\n+\t{\n+\t  gt_pch_nx (&x, op, cookie);\n+\t}\n+\n+    template<typename T>\n+      static void\n+      pch_nx_helper (T *&x, gt_pointer_operator op, void *cookie)\n+\t{\n+\t  op (&x, cookie);\n+\t}\n   };\n \n public:\n-  explicit hash_set (size_t n = 13) : m_table (n) {}\n+  explicit hash_set (size_t n = 13, bool ggc = false) : m_table (n, ggc) {}\n+\n+  /* Create a hash_set in gc memory with space for at least n elements.  */\n+\n+  static hash_set *\n+    create_ggc (size_t n)\n+      {\n+\thash_set *set = ggc_alloc<hash_set> ();\n+\tnew (set) hash_set (n, true);\n+\treturn set;\n+      }\n \n   /* If key k isn't already in the map add it to the map, and\n      return false.  Otherwise return true.  */\n@@ -166,8 +226,40 @@ class hash_set\n \tf ((*iter).m_key, a);\n     }\n \n+  /* Return the number of elements in the set.  */\n+\n+  size_t elements () const { return m_table.elements (); }\n+\n private:\n+\n+  template<typename T, typename U> friend void gt_ggc_mx (hash_set<T, U> *);\n+  template<typename T, typename U> friend void gt_pch_nx (hash_set<T, U> *);\n+      template<typename T, typename U> friend void gt_pch_nx (hash_set<T, U> *, gt_pointer_operator, void *);\n+\n   hash_table<hash_entry> m_table;\n };\n \n+/* ggc marking routines.  */\n+\n+template<typename K, typename H>\n+static inline void\n+gt_ggc_mx (hash_set<K, H> *h)\n+{\n+  gt_ggc_mx (&h->m_table);\n+}\n+\n+template<typename K, typename H>\n+static inline void\n+gt_pch_nx (hash_set<K, H> *h)\n+{\n+  gt_pch_nx (&h->m_table);\n+}\n+\n+template<typename K, typename H>\n+static inline void\n+gt_pch_nx (hash_set<K, H> *h, gt_pointer_operator op, void *cookie)\n+{\n+  op (&h->m_table.m_entries, cookie);\n+}\n+\n #endif"}, {"sha": "c2a68fd23a2bc7ebd54cb0cde6c4593b4fcf6766", "filename": "gcc/hash-table.h", "status": "modified", "additions": 100, "deletions": 9, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -196,8 +196,11 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef TYPED_HASHTAB_H\n #define TYPED_HASHTAB_H\n \n+#include \"ggc.h\"\n #include \"hashtab.h\"\n \n+template<typename, typename, typename> class hash_map;\n+template<typename, typename> class hash_set;\n \n /* The ordinary memory allocator.  */\n /* FIXME (crowl): This allocator may be extracted for wider sharing later.  */\n@@ -998,7 +1001,7 @@ class hash_table<Descriptor, Allocator, true>\n   typedef typename Descriptor::compare_type compare_type;\n \n public:\n-  hash_table (size_t);\n+  explicit hash_table (size_t, bool ggc = false);\n   ~hash_table ();\n \n   /* Current size (in entries) of the hash table.  */\n@@ -1105,6 +1108,11 @@ class hash_table<Descriptor, Allocator, true>\n     }\n \n private:\n+  template<typename T> friend void gt_ggc_mx (hash_table<T> *);\n+  template<typename T> friend void gt_pch_nx (hash_table<T> *);\n+  template<typename T> friend void hashtab_entry_note_pointers (void *, void *, gt_pointer_operator, void *);\n+  template<typename T, typename U, typename V> friend void gt_pch_nx (hash_map<T, U, V> *, gt_pointer_operator, void *);\n+  template<typename T, typename U> friend void gt_pch_nx (hash_set<T, U> *, gt_pointer_operator, void *);\n \n   value_type *find_empty_slot_for_expand (hashval_t);\n   void expand ();\n@@ -1149,18 +1157,26 @@ class hash_table<Descriptor, Allocator, true>\n   /* Current size (in entries) of the hash table, as an index into the\n      table of primes.  */\n   unsigned int m_size_prime_index;\n+\n+  /* if m_entries is stored in ggc memory.  */\n+  bool m_ggc;\n };\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator, true>::hash_table (size_t size) :\n-  m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0)\n+hash_table<Descriptor, Allocator, true>::hash_table (size_t size, bool ggc) :\n+  m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0),\n+  m_ggc (ggc)\n {\n   unsigned int size_prime_index;\n \n   size_prime_index = hash_table_higher_prime_index (size);\n   size = prime_tab[size_prime_index].prime;\n \n-  m_entries = Allocator <value_type> ::data_alloc (size);\n+  if (!m_ggc)\n+    m_entries = Allocator <value_type> ::data_alloc (size);\n+  else\n+    m_entries = ggc_cleared_vec_alloc<value_type> (size);\n+\n   gcc_assert (m_entries != NULL);\n   m_size = size;\n   m_size_prime_index = size_prime_index;\n@@ -1173,7 +1189,10 @@ hash_table<Descriptor, Allocator, true>::~hash_table ()\n     if (!is_empty (m_entries[i]) && !is_deleted (m_entries[i]))\n       Descriptor::remove (m_entries[i]);\n \n-  Allocator <value_type> ::data_free (m_entries);\n+  if (!m_ggc)\n+    Allocator <value_type> ::data_free (m_entries);\n+  else\n+    ggc_free (m_entries);\n }\n \n /* Similar to find_slot, but without several unwanted side effects:\n@@ -1245,7 +1264,12 @@ hash_table<Descriptor, Allocator, true>::expand ()\n       nsize = osize;\n     }\n \n-  value_type *nentries = Allocator <value_type> ::data_alloc (nsize);\n+  value_type *nentries;\n+  if (!m_ggc)\n+    nentries = Allocator <value_type> ::data_alloc (nsize);\n+  else\n+    nentries = ggc_cleared_vec_alloc<value_type> (nsize);\n+\n   gcc_assert (nentries != NULL);\n   m_entries = nentries;\n   m_size = nsize;\n@@ -1269,7 +1293,10 @@ hash_table<Descriptor, Allocator, true>::expand ()\n     }\n   while (p < olimit);\n \n-  Allocator <value_type> ::data_free (oentries);\n+  if (!m_ggc)\n+    Allocator <value_type> ::data_free (oentries);\n+  else\n+    ggc_free (oentries);\n }\n \n template<typename Descriptor, template<typename Type> class Allocator>\n@@ -1290,8 +1317,17 @@ hash_table<Descriptor, Allocator, true>::empty ()\n       int nindex = hash_table_higher_prime_index (1024 / sizeof (PTR));\n       int nsize = prime_tab[nindex].prime;\n \n-      Allocator <value_type> ::data_free (m_entries);\n-      m_entries = Allocator <value_type> ::data_alloc (nsize);\n+      if (!m_ggc)\n+\t{\n+\t  Allocator <value_type> ::data_free (m_entries);\n+\t  m_entries = Allocator <value_type> ::data_alloc (nsize);\n+\t}\n+      else\n+\t{\n+\t  ggc_free (m_entries);\n+\t  m_entries = ggc_cleared_vec_alloc<value_type> (nsize);\n+\t}\n+\n       m_size = nsize;\n       m_size_prime_index = nindex;\n     }\n@@ -1519,4 +1555,59 @@ hash_table<Descriptor, Allocator, true>::iterator::operator ++ ()\n        (ITER) != (HTAB).end () ? (RESULT = *(ITER) , true) : false; \\\n        ++(ITER))\n \n+/* ggc walking routines.  */\n+\n+template<typename E>\n+static inline void\n+gt_ggc_mx (hash_table<E> *h)\n+{\n+  typedef hash_table<E> table;\n+\n+  if (!ggc_test_and_set_mark (h->m_entries))\n+    return;\n+\n+  for (size_t i = 0; i < h->m_size; i++)\n+    {\n+      if (table::is_empty (h->m_entries[i])\n+\t  || table::is_deleted (h->m_entries[i]))\n+\tcontinue;\n+\n+      E::ggc_mx (h->m_entries[i]);\n+    }\n+}\n+\n+template<typename D>\n+static inline void\n+hashtab_entry_note_pointers (void *obj, void *h, gt_pointer_operator op,\n+\t\t\t     void *cookie)\n+{\n+  hash_table<D> *map = static_cast<hash_table<D> *> (h);\n+  gcc_checking_assert (map->m_entries == obj);\n+  for (size_t i = 0; i < map->m_size; i++)\n+    {\n+      typedef hash_table<D> table;\n+      if (table::is_empty (map->m_entries[i])\n+\t  || table::is_deleted (map->m_entries[i]))\n+\tcontinue;\n+\n+      D::pch_nx (map->m_entries[i], op, cookie);\n+    }\n+}\n+\n+template<typename D>\n+static void\n+gt_pch_nx (hash_table<D> *h)\n+{\n+  gcc_checking_assert (gt_pch_note_object (h->m_entries, h,\n+\t\t\t\t\t   hashtab_entry_note_pointers<D>));\n+  for (size_t i = 0; i < h->m_size; i++)\n+    {\n+      if (hash_table<D>::is_empty (h->m_entries[i])\n+\t  || hash_table<D>::is_deleted (h->m_entries[i]))\n+\tcontinue;\n+\n+      D::pch_nx (h->m_entries[i]);\n+    }\n+}\n+\n #endif /* TYPED_HASHTAB_H */"}, {"sha": "792b3b50ea6a04bf1ea228a6201475df825c3c45", "filename": "gcc/symtab.c", "status": "modified", "additions": 9, "deletions": 53, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -407,15 +407,7 @@ symtab_node::unregister (void)\n   if (!is_a <varpool_node *> (this) || !DECL_HARD_REGISTER (decl))\n     symtab->unlink_from_assembler_name_hash (this, false);\n   if (in_init_priority_hash)\n-    {\n-      symbol_priority_map in;\n-      void **slot;\n-      in.symbol = this;\n-\n-      slot = htab_find_slot (symtab->init_priority_hash, &in, NO_INSERT);\n-      if (slot)\n-\thtab_clear_slot (symtab->init_priority_hash, slot);\n-    }\n+    symtab->init_priority_hash->remove (this);\n }\n \n \n@@ -1455,14 +1447,10 @@ symtab_node::set_section (const char *section)\n priority_type\n symtab_node::get_init_priority ()\n {\n-  symbol_priority_map *h;\n-  symbol_priority_map in;\n-\n   if (!this->in_init_priority_hash)\n     return DEFAULT_INIT_PRIORITY;\n-  in.symbol = this;\n-  h = (symbol_priority_map *) htab_find (symtab->init_priority_hash,\n-\t\t\t\t\t\t&in);\n+\n+  symbol_priority_map *h = symtab->init_priority_hash->get (this);\n   return h ? h->init : DEFAULT_INIT_PRIORITY;\n }\n \n@@ -1481,59 +1469,27 @@ enum availability symtab_node::get_availability (void)\n priority_type\n cgraph_node::get_fini_priority ()\n {\n-  symbol_priority_map *h;\n-  symbol_priority_map in;\n-\n   if (!this->in_init_priority_hash)\n     return DEFAULT_INIT_PRIORITY;\n-  in.symbol = this;\n-  h = (symbol_priority_map *) htab_find (symtab->init_priority_hash,\n-\t\t\t\t\t\t&in);\n+  symbol_priority_map *h = symtab->init_priority_hash->get (this);\n   return h ? h->fini : DEFAULT_INIT_PRIORITY;\n }\n \n-/* Return true if the from tree in both priority maps are equal.  */\n-\n-int\n-symbol_priority_map_eq (const void *va, const void *vb)\n-{\n-  const symbol_priority_map *const a = (const symbol_priority_map *) va,\n-    *const b = (const symbol_priority_map *) vb;\n-  return (a->symbol == b->symbol);\n-}\n-\n-/* Hash a from symbol in a symbol_priority_map.  */\n-\n-unsigned int\n-symbol_priority_map_hash (const void *item)\n-{\n-  return htab_hash_pointer (((const symbol_priority_map *)item)->symbol);\n-}\n-\n /* Return the initialization and finalization priority information for\n    DECL.  If there is no previous priority information, a freshly\n    allocated structure is returned.  */\n \n symbol_priority_map *\n symtab_node::priority_info (void)\n {\n-  symbol_priority_map in;\n-  symbol_priority_map *h;\n-  void **loc;\n-\n-  in.symbol = this;\n   if (!symtab->init_priority_hash)\n-    symtab->init_priority_hash = htab_create_ggc (512,\n-\t\t\t\t\t\t  symbol_priority_map_hash,\n-\t\t\t\t\t\t  symbol_priority_map_eq, 0);\n+    symtab->init_priority_hash = hash_map<symtab_node *, symbol_priority_map>::create_ggc (13);\n \n-  loc = htab_find_slot (symtab->init_priority_hash, &in, INSERT);\n-  h = (symbol_priority_map *) *loc;\n-  if (!h)\n+  bool existed;\n+  symbol_priority_map *h\n+    = &symtab->init_priority_hash->get_or_insert (this, &existed);\n+  if (!existed)\n     {\n-      h = ggc_cleared_alloc<symbol_priority_map> ();\n-      *loc = h;\n-      h->symbol = this;\n       h->init = DEFAULT_INIT_PRIORITY;\n       h->fini = DEFAULT_INIT_PRIORITY;\n       in_init_priority_hash = true;"}, {"sha": "e89d76a015aaf4e8e4bacec3cbcef1b9b03620d6", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -4723,19 +4723,17 @@ verify_node_sharing (tree *tp, int *walk_subtrees, void *data)\n }\n \n static bool eh_error_found;\n-static int\n-verify_eh_throw_stmt_node (void **slot, void *data)\n+bool\n+verify_eh_throw_stmt_node (const gimple &stmt, const int &,\n+\t\t\t   hash_set<gimple> *visited)\n {\n-  struct throw_stmt_node *node = (struct throw_stmt_node *)*slot;\n-  hash_set<void *> *visited = (hash_set<void *> *) data;\n-\n-  if (!visited->contains (node->stmt))\n+  if (!visited->contains (stmt))\n     {\n       error (\"dead STMT in EH table\");\n-      debug_gimple_stmt (node->stmt);\n+      debug_gimple_stmt (stmt);\n       eh_error_found = true;\n     }\n-  return 1;\n+  return true;\n }\n \n /* Verify if the location LOCs block is in BLOCKS.  */\n@@ -4996,10 +4994,10 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n     }\n \n   eh_error_found = false;\n-  if (get_eh_throw_stmt_table (cfun))\n-    htab_traverse (get_eh_throw_stmt_table (cfun),\n-\t\t   verify_eh_throw_stmt_node,\n-\t\t   &visited_stmts);\n+  hash_map<gimple, int> *eh_table = get_eh_throw_stmt_table (cfun);\n+  if (eh_table)\n+    eh_table->traverse<hash_set<gimple> *, verify_eh_throw_stmt_node>\n+      (&visited_stmts);\n \n   if (err || eh_error_found)\n     internal_error (\"verify_gimple failed\");"}, {"sha": "9da8da28b3656e1d774441dfb9dd8972f77d3600", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b086d5308de0d25444243f482f2f3d1dfd3a9a62/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=b086d5308de0d25444243f482f2f3d1dfd3a9a62", "patch": "@@ -77,23 +77,12 @@ typedef union {tree *tp; tree t; gimple g;} treemple;\n static void\n add_stmt_to_eh_lp_fn (struct function *ifun, gimple t, int num)\n {\n-  struct throw_stmt_node *n;\n-  void **slot;\n-\n   gcc_assert (num != 0);\n \n-  n = ggc_alloc<throw_stmt_node> ();\n-  n->stmt = t;\n-  n->lp_nr = num;\n-\n   if (!get_eh_throw_stmt_table (ifun))\n-    set_eh_throw_stmt_table (ifun, htab_create_ggc (31, struct_ptr_hash,\n-\t\t\t\t\t\t    struct_ptr_eq,\n-\t\t\t\t\t\t    ggc_free));\n+    set_eh_throw_stmt_table (ifun, hash_map<gimple, int>::create_ggc (31));\n \n-  slot = htab_find_slot (get_eh_throw_stmt_table (ifun), n, INSERT);\n-  gcc_assert (!*slot);\n-  *slot = n;\n+  gcc_assert (!get_eh_throw_stmt_table (ifun)->put (t, num));\n }\n \n /* Add statement T in the current function (cfun) to EH landing pad NUM.  */\n@@ -130,22 +119,14 @@ record_stmt_eh_region (eh_region region, gimple t)\n bool\n remove_stmt_from_eh_lp_fn (struct function *ifun, gimple t)\n {\n-  struct throw_stmt_node dummy;\n-  void **slot;\n-\n   if (!get_eh_throw_stmt_table (ifun))\n     return false;\n \n-  dummy.stmt = t;\n-  slot = htab_find_slot (get_eh_throw_stmt_table (ifun), &dummy,\n-                        NO_INSERT);\n-  if (slot)\n-    {\n-      htab_clear_slot (get_eh_throw_stmt_table (ifun), slot);\n-      return true;\n-    }\n-  else\n+  if (!get_eh_throw_stmt_table (ifun)->get (t))\n     return false;\n+\n+  get_eh_throw_stmt_table (ifun)->remove (t);\n+      return true;\n }\n \n \n@@ -166,14 +147,11 @@ remove_stmt_from_eh_lp (gimple t)\n int\n lookup_stmt_eh_lp_fn (struct function *ifun, gimple t)\n {\n-  struct throw_stmt_node *p, n;\n-\n   if (ifun->eh->throw_stmt_table == NULL)\n     return 0;\n \n-  n.stmt = t;\n-  p = (struct throw_stmt_node *) htab_find (ifun->eh->throw_stmt_table, &n);\n-  return p ? p->lp_nr : 0;\n+  int *lp_nr = ifun->eh->throw_stmt_table->get (t);\n+  return lp_nr ? *lp_nr : 0;\n }\n \n /* Likewise, but always use the current function.  */"}]}