{"sha": "0e91429a56d8c737cd6b6f2e60c62a21de0a31d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU5MTQyOWE1NmQ4YzczN2NkNmI2ZjJlNjBjNjJhMjFkZTBhMzFkNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-19T19:50:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-19T19:50:23Z"}, "message": "(find_splittable_regs): If any BIV update isn't simple, don't split it.\n\n(final_giv_value): Look for biv updates by matching insns; don't try to\nreparse the insn.\n\nFrom-SVN: r2181", "tree": {"sha": "26bc4d6f408bff72a4efd7284f84e6bdeb86e3fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26bc4d6f408bff72a4efd7284f84e6bdeb86e3fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e91429a56d8c737cd6b6f2e60c62a21de0a31d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e91429a56d8c737cd6b6f2e60c62a21de0a31d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e91429a56d8c737cd6b6f2e60c62a21de0a31d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e91429a56d8c737cd6b6f2e60c62a21de0a31d6/comments", "author": null, "committer": null, "parents": [{"sha": "98f3b471109aa20dc29832bd8698fe1ef9b410b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f3b471109aa20dc29832bd8698fe1ef9b410b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f3b471109aa20dc29832bd8698fe1ef9b410b8"}], "stats": {"total": 80, "additions": 49, "deletions": 31}, "files": [{"sha": "aa8db729a8cddabea22c8d81601b92258df03e37", "filename": "gcc/unroll.c", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e91429a56d8c737cd6b6f2e60c62a21de0a31d6/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e91429a56d8c737cd6b6f2e60c62a21de0a31d6/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=0e91429a56d8c737cd6b6f2e60c62a21de0a31d6", "patch": "@@ -2179,6 +2179,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n      int unroll_number;\n {\n   struct iv_class *bl;\n+  struct induction *v;\n   rtx increment, tem;\n   rtx biv_final_value;\n   int biv_splittable;\n@@ -2216,6 +2217,15 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t  && ! (biv_final_value = final_biv_value (bl, loop_start, loop_end)))\n \tbiv_splittable = 0;\n \n+      /* If any of the insns setting the BIV don't do so with a simple\n+\t PLUS, we don't know how to split it.  */\n+      for (v = bl->biv; biv_splittable && v; v = v->next_iv)\n+\tif ((tem = single_set (v->insn)) == 0\n+\t    || GET_CODE (SET_DEST (tem)) != REG\n+\t    || REGNO (SET_DEST (tem)) != bl->regno\n+\t    || GET_CODE (SET_SRC (tem)) != PLUS)\n+\t  biv_splittable = 0;\n+\n       /* If final value is non-zero, then must emit an instruction which sets\n \t the value of the biv to the proper value.  This is done after\n \t handling all of the givs, since some of them may need to use the\n@@ -2415,11 +2425,31 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t giv's initial value.  Otherwise, save the constant zero for it.  */\n \n       if (unroll_type == UNROLL_COMPLETELY)\n-\t/* It is not safe to use bl->initial_value here, because it may not\n-\t   be invariant.  It is safe to use the initial value stored in\n-\t   the splittable_regs array.  */\n-\tvalue = fold_rtx_mult_add (v->mult_val, splittable_regs[bl->regno],\n-\t\t\t\t   v->add_val, v->mode);\n+\t{\n+\t  /* It is not safe to use bl->initial_value here, because it may not\n+\t     be invariant.  It is safe to use the initial value stored in\n+\t     the splittable_regs array if it is set.  In rare cases, it won't\n+\t     be set, so then we do exactly the same thing as\n+\t     find_splittable_regs does to get a safe value.  */\n+\t  rtx biv_initial_value;\n+\n+\t  if (splittable_regs[bl->regno])\n+\t    biv_initial_value = splittable_regs[bl->regno];\n+\t  else if (GET_CODE (bl->initial_value) != REG\n+\t\t   || (REGNO (bl->initial_value) != bl->regno\n+\t\t       && REGNO (bl->initial_value) >= FIRST_PSEUDO_REGISTER))\n+\t    biv_initial_value = bl->initial_value;\n+\t  else\n+\t    {\n+\t      rtx tem = gen_reg_rtx (bl->biv->mode);\n+\n+\t      emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n+\t\t\t\tloop_start);\n+\t      biv_initial_value = tem;\n+\t    }\n+\t  value = fold_rtx_mult_add (v->mult_val, biv_initial_value,\n+\t\t\t\t     v->add_val, v->mode);\n+\t}\n       else\n \tvalue = const0_rtx;\n \n@@ -2804,7 +2834,7 @@ final_giv_value (v, loop_start, loop_end)\n      rtx loop_start, loop_end;\n {\n   struct iv_class *bl;\n-  rtx reg, insn, pattern;\n+  rtx insn;\n   rtx increment, tem;\n   enum rtx_code code;\n   rtx insert_before, seq;\n@@ -2868,31 +2898,19 @@ final_giv_value (v, loop_start, loop_end)\n \t  for (insn = NEXT_INSN (v->insn); insn != loop_end;\n \t       insn = NEXT_INSN (insn))\n \t    {\n-\t      if (GET_CODE (insn) == INSN\n-\t\t  && GET_CODE (PATTERN (insn)) == SET\n-\t\t  && SET_DEST (PATTERN (insn)) == v->src_reg)\n-\t\t{\n-\t\t  pattern = PATTERN (insn);\n-\t\t  if (GET_CODE (SET_SRC (pattern)) != PLUS)\n-\t\t    {\n-\t\t      /* Sometimes a biv is computed in a temp reg,\n-\t\t\t and then copied into the biv reg.  */\n-\t\t      pattern = PATTERN (PREV_INSN (insn));\n-\t\t      if (GET_CODE (SET_SRC (pattern)) != PLUS)\n-\t\t\tabort ();\n-\t\t    }\n-\t\t  if (GET_CODE (XEXP (SET_SRC (pattern), 0)) != REG\n-\t\t      || REGNO (XEXP (SET_SRC (pattern), 0)) != bl->regno)\n-\t\t    abort ();\n-\t\t  \n-\t\t  start_sequence ();\n-\t\t  tem = expand_binop (GET_MODE (tem), sub_optab, tem,\n-\t\t\t\t      XEXP (SET_SRC (pattern), 1), NULL_RTX, 0,\n-\t\t\t\t      OPTAB_LIB_WIDEN);\n-\t\t  seq = gen_sequence ();\n-\t\t  end_sequence ();\n-\t\t  emit_insn_before (seq, insert_before);\n-\t\t}\n+\t      struct induction *biv;\n+\n+\t      for (biv = bl->biv; biv; biv = biv->next_iv)\n+\t\tif (biv->insn == insn)\n+\t\t  {\n+\t\t    start_sequence ();\n+\t\t    tem = expand_binop (GET_MODE (tem), sub_optab, tem,\n+\t\t\t\t\tbiv->add_val, NULL_RTX, 0,\n+\t\t\t\t\tOPTAB_LIB_WIDEN);\n+\t\t    seq = gen_sequence ();\n+\t\t    end_sequence ();\n+\t\t    emit_insn_before (seq, insert_before);\n+\t\t  }\n \t    }\n \t  \n \t  /* Now calculate the giv's final value.  */"}]}