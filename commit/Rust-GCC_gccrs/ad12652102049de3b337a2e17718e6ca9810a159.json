{"sha": "ad12652102049de3b337a2e17718e6ca9810a159", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQxMjY1MjEwMjA0OWRlM2IzMzdhMmUxNzcxOGU2Y2E5ODEwYTE1OQ==", "commit": {"author": {"name": "Kazuhiro Inaoka", "email": "inaoka.kazuhiro@renesas.com", "date": "2003-12-31T10:33:02Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2003-12-31T10:33:02Z"}, "message": "Add support for m32r-linux target.\n\nFrom-SVN: r75263", "tree": {"sha": "7a7665a0fcdb8294179c40f5b2418efd4aa141dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a7665a0fcdb8294179c40f5b2418efd4aa141dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad12652102049de3b337a2e17718e6ca9810a159", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad12652102049de3b337a2e17718e6ca9810a159", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad12652102049de3b337a2e17718e6ca9810a159", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad12652102049de3b337a2e17718e6ca9810a159/comments", "author": null, "committer": null, "parents": [{"sha": "04d1e6e212868d75be10537dba11d3a019dc93e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04d1e6e212868d75be10537dba11d3a019dc93e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04d1e6e212868d75be10537dba11d3a019dc93e1"}], "stats": {"total": 1290, "additions": 1009, "deletions": 281}, "files": [{"sha": "1aa9d98ee613a24259662c4c793d6f65d2e9993e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -1,3 +1,41 @@\n+2003-12-31  Kazuhiro Inaoka  <inaoka.kazuhiro@renesas.com>\n+\n+\t* config.gcc: Added m32r-linux m32rle-elf and m32le-linux targets.\n+\t* doc/invoke.texi: Document -mflush-func, -mflush-trap options.\n+\tAlso add documentation for -mdebug, -malign-loops, -missue-rate,\n+\tand -mbranch-cost options.\n+\t* config/m32r/t-linux: New file: m32r-linux support.\n+\t* config/m32r/xm-linux.h: Likewise.\n+\t* config/m32r/xm-m32r.h: Likewise.\n+\t* config/m32r/linux.h: Likewise.\n+\t* config/m32r/little.h: New file: Little endian code generation\n+\tsupport.\n+\t* config/m32r/m32r-protos.h (m32r_legitimize_pic_address,\n+\tm32r_legitimate_pic_operand_p, load_pic_register): Add\n+\tprototypes.\n+\t* config/m32r/m32r.c (m32r_init): Add options for cache-flush.\n+\t(addr24_operand): Changes for PIC code generation.\n+\t* config/m32r/m32r.h (LABEL_ALIGN): Define to calculate PNOP\n+\tlength at labels.\n+\t(ASM_SPEC): Add PIC support.\n+\t(FUNCTION_PROFILER): New define.\n+\t(TRAMPOLINE_SIZE, INITIALIZE_TRAMPOLINE): Changed to support\n+\ttrampoline.\n+\t(CONDITIONAL_REGISTER_USAGE, CONSTANT_ADDRESS_P,\n+\t LEGITIMIZE_ADDRESS, JUMP_TABLES_IN_TEXT_SECTION,\n+\t PIC_OFFSET_TABLE_REGNUM, FINALIZE_PIC, LEGITIMATE_PIC_OPERAND_P,\n+\t ASM_OUTPUT_ADDR_DIFF_ELT, CASE_VECTOR_MODE): Define for PIC.\n+\t(move_src_operand, m32r_compute_frame_size, m32r_expand_prologue,\n+\t m32r_finalize_pic): Changes for PIC and profile support.\n+\t(global_offset_table, load_pic_register, m32r_legitimate_pic_operand_p,\n+\t m32r_legitimize_pic_address): Add for PIC support.\n+\t(m32r_file_start): Changed for little-endian-target.\n+\t* config/m32r/m32r.md (mvqi, movhi, movsi, movdi, movsf, movdf,\n+\ttablejump, tablejump_insn, call, call_value, call_value_via_label):\n+\tChanges for PIC.\n+\t(pic_load_addr, get_pc, builtin_setjmp_receiver): Added for PIC.\n+\t(flush_icache): Changes for cache-flush trap.\n+\n 2003-12-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/i386/i386.h: Remove an unnecessary #undef."}, {"sha": "b4e750a5d0a21e31d2009a4afb6d499c9b17549a", "filename": "gcc/config.gcc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -279,6 +279,9 @@ ia64-*-*)\n hppa*-*-* | parisc*-*-*)\n \tcpu_type=pa\n \t;;\n+m32r*-*-*)\n+        cpu_type=m32r\n+        ;;\n m680[012]0-*-*)\n \tcpu_type=m68k\n \textra_headers=math-68881.h\n@@ -1279,6 +1282,31 @@ m32r-*-elf*)\n \textra_parts=\"crtinit.o crtfini.o\"\n \tuse_fixproto=yes\n  \t;;\n+m32rle-*-elf*)\n+\ttm_file=\"dbxelf.h elfos.h svr4.h m32r/little.h ${tm_file}\"\n+\textra_parts=\"crtinit.o crtfini.o m32rx/crtinit.o m32rx/crtfini.o\"\n+\tuse_fixproto=yes\n+\t;;\n+m32r-*-linux*)\n+\ttm_file=\"dbxelf.h elfos.h svr4.h linux.h ${tm_file} m32r/linux.h\"\n+\textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n+\ttmake_file=\"m32r/t-linux\"\n+\tgnu_ld=yes\n+\tuse_fixproto=yes\n+\tif test x$enable_threads = xyes; then\n+\t\tthread_file='posix'\n+\tfi\n+ \t;;\n+m32rle-*-linux*)\n+\ttm_file=\"dbxelf.h elfos.h svr4.h linux.h m32r/little.h ${tm_file} m32r/linux.h\"\n+\textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n+\ttmake_file=\"m32r/t-linux\"\n+\tgnu_ld=yes\n+\tuse_fixproto=yes\n+\tif test x$enable_threads = xyes; then\n+\t\tthread_file='posix'\n+\tfi\n+\t;;\n # m68hc11 and m68hc12 share the same machine description.\n m68hc11-*-*|m6811-*-*)\n \ttm_file=\"dbxelf.h elfos.h m68hc11/m68hc11.h\""}, {"sha": "b7da5bf8ce5d11f8ff82d86806aa6fff0a80c6f1", "filename": "gcc/config/m32r/linux.h", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Flinux.h?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -0,0 +1,104 @@\n+/* Definitions for Renesas M32R running Linux-based GNU systems using ELF.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+#define LINUX_DEFAULT_ELF\n+\n+/* A lie, I guess, but the general idea behind linux/ELF is that we are\n+   supposed to be outputting something that will assemble under SVr4.\n+   This gets us pretty close.  */\n+\n+#define HANDLE_SYSV_PRAGMA\n+\n+#undef  HANDLE_PRAGMA_PACK\n+\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (M32R GNU/Linux with ELF)\");\n+\n+#undef  SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+ \n+#undef  PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+  \n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+   \n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+    \n+/* Provide a LINK_SPEC appropriate for Linux.  Here we provide support\n+   for the special GCC options -static and -shared, which allow us to\n+   link things in one of these three modes by applying the appropriate\n+   combinations of options at link-time. We like to support here for\n+   as many of the other GNU linker options as possible. But I don't\n+   have the time to search for those flags. I am sure how to add\n+   support for -soname shared_object_name. H.J.\n+\n+   I took out %{v:%{!V:-V}}. It is too much :-(. They can use\n+   -Wl,-V.\n+\n+   When the -shared link option is used a final link is not being\n+   done.  */\n+\n+/* If ELF is the default format, we should not use /lib/elf. */\n+\n+#undef\tLINK_SPEC\n+#if TARGET_LITTLE_ENDIAN\n+#define LINK_SPEC \"%(link_cpu) -m m32rlelf_linux %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!ibcs: \\\n+      %{!static: \\\n+\t%{rdynamic:-export-dynamic} \\\n+\t%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \\\n+\t%{static:-static}}}\"\n+#else\n+#define LINK_SPEC \"%(link_cpu) -m m32relf_linux %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!ibcs: \\\n+      %{!static: \\\n+\t%{rdynamic:-export-dynamic} \\\n+\t%{!dynamic-linker:-dynamic-linker /lib/ld-linux.so.2}} \\\n+\t%{static:-static}}}\"\n+#endif\n+\n+#undef\tLIB_SPEC\n+#define LIB_SPEC \\\n+  \"%{shared: -lc} \\\n+    %{!shared: %{mieee-fp:-lieee} %{pthread:-lpthread} \\\n+    %{profile:-lc_p} %{!profile: -lc}}\"\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"%{!shared: \\\n+     %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}}\\\n+   crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \\\n+  \"%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s\"\n+\n+#undef  SUBTARGET_CPP_SPEC\n+#define SUBTARGET_CPP_SPEC \"\\\n+   %{posix:-D_POSIX_SOURCE} \\\n+   %{pthread:-D_REENTRANT -D_PTHREADS} \\\n+\"\n+                                                                                \n+#define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()\n+"}, {"sha": "793cf24386324008e6b20949d446e3c1e01232e5", "filename": "gcc/config/m32r/little.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Flittle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Flittle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Flittle.h?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -0,0 +1,34 @@\n+/* Definitions for Renesas little endian M32R cpu.\n+   Copyright (C) 2003\n+   Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+#define TARGET_LITTLE_ENDIAN (!TARGET_BIG_ENDIAN)\n+\n+#define CPP_ENDIAN_SPEC \\\n+  \" %{mbe:-D__BIG_ENDIAN__} %{mbig-endian:-D__BIG_ENDIAN__}\" \\\n+  \" %{!mbe: %{!mbig-endian:-D__LITTLE_ENDIAN__}}\"\n+                                                                                \n+#define CC1_ENDIAN_SPEC \" %{!mbe: %{!mbig-endian:-mle}}\"\n+\n+#define ASM_ENDIAN_SPEC \\\n+  \" %{!mbe: %{!mbig-endian:-EL}} %{mbe:-EB} %{mbig-endian:-EB}\"\n+\n+#define LINK_ENDIAN_SPEC \" %{!mbe: %{!mbig-endian:-EL}}\"\n+"}, {"sha": "603c0bd51f8e127739e01b7f204957274a4ea939", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -1,22 +1,22 @@\n /* Prototypes for m32r.c functions used in the md file & elsewhere.\n-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+   This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n \n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n \n /* Function prototypes that cannot exist in v850.h due to dependency\n    complications.  */\n@@ -31,6 +31,8 @@ extern int    m32r_first_insn_address (void);\n extern void   m32r_expand_prologue (void);\n extern void   m32r_finalize_pic (void);\n extern int    direct_return (void);\n+extern void   m32r_load_pic_register (void);\n+\n #ifdef TREE_CODE\n extern enum m32r_function_type m32r_compute_function_type (tree);\n \n@@ -55,6 +57,8 @@ extern void   m32r_print_operand (FILE *, rtx, int);\n extern void   m32r_print_operand_address (FILE *, rtx);\n extern int    m32r_not_same_reg (rtx, rtx);\n extern int    m32r_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern int    m32r_legitimate_pic_operand_p (rtx);\n+extern rtx    m32r_legitimize_pic_address (rtx, rtx);\n \n #ifdef HAVE_MACHINE_MODES\n extern int    call_address_operand (rtx, Mmode);"}, {"sha": "244264b5a53a06f20f6b80bd39c5e1e7ee7f1810", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 173, "deletions": 7, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -68,6 +68,19 @@ static int m32r_sched_odd_word_p;\n /* For string literals, etc.  */\n #define LIT_NAME_P(NAME) ((NAME)[0] == '*' && (NAME)[1] == '.')\n \n+/* Cache-flush support. Cache-flush is used at trampoline.\n+   Default cache-flush is \"trap 12\".\n+    default cache-flush function is \"_flush_cache\"  (CACHE_FLUSH_FUNC)\n+    default cache-flush trap-interrupt number is \"12\". (CACHE_FLUSH_TRAP)\n+   You can change how to generate code of cache-flush with following options.\n+   -flush-func=FLUSH-FUNC-NAME\n+   -no-flush-func\n+   -fluch-trap=TRAP-NUMBER\n+   -no-flush-trap.  */\n+const char *m32r_cache_flush_func = CACHE_FLUSH_FUNC;\n+const char *m32r_cache_flush_trap_string = CACHE_FLUSH_TRAP;\n+int m32r_cache_flush_trap = 12;\n+\n /* Forward declaration.  */\n static void  init_reg_tables (void);\n static void  block_move_call (rtx, rtx, rtx);\n@@ -166,6 +179,15 @@ m32r_init (void)\n     m32r_sdata = M32R_SDATA_USE;\n   else\n     error (\"bad value (%s) for -msdata switch\", m32r_sdata_string);\n+\n+  if (m32r_cache_flush_trap_string)\n+    {\n+      /* Change trap-number (12) for cache-flush to the others (0 - 15).  */\n+      m32r_cache_flush_trap = atoi (m32r_cache_flush_trap_string);\n+      if (m32r_cache_flush_trap < 0 || m32r_cache_flush_trap > 15)\n+        error (\"bad value (%s) for -flush-trap=n (0=<n<=15)\",\n+               m32r_cache_flush_trap_string);\n+    }\n }\n \n /* Vectors to keep interesting information about registers where it can easily\n@@ -509,6 +531,9 @@ addr24_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   rtx sym;\n \n+  if (flag_pic)\n+    return 0;\n+\n   if (GET_CODE (op) == LABEL_REF)\n     return TARGET_ADDR24;\n \n@@ -549,7 +574,8 @@ addr32_operand (rtx op, enum machine_mode mode)\n   else if (GET_CODE (op) == CONST\n \t   && GET_CODE (XEXP (op, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-\t   && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+\t   && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+\t   && ! flag_pic)\n     sym = XEXP (XEXP (op, 0), 0);\n   else\n     return 0;\n@@ -563,6 +589,9 @@ addr32_operand (rtx op, enum machine_mode mode)\n int\n call26_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n+  if (flag_pic)\n+    return 0;\n+\n   if (GET_CODE (op) == SYMBOL_REF)\n     return SYMBOL_REF_MODEL (op) != M32R_MODEL_LARGE;\n \n@@ -574,6 +603,9 @@ call26_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n seth_add3_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n+  if (flag_pic)\n+    return 0;\n+\n   if (GET_CODE (op) == SYMBOL_REF\n       || GET_CODE (op) == LABEL_REF)\n     return 1;\n@@ -711,6 +743,7 @@ move_src_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n+    case LABEL_REF :\n     case SYMBOL_REF :\n     case CONST :\n       return addr24_operand (op, mode);\n@@ -726,8 +759,8 @@ move_src_operand (rtx op, enum machine_mode mode)\n \t}\n       else\n \treturn 1;\n-    case LABEL_REF :\n-      return TARGET_ADDR24;\n+    case CONSTANT_P_RTX:\n+\treturn 1;\n     case CONST_DOUBLE :\n       if (mode == SFmode)\n \treturn 1;\n@@ -1801,6 +1834,7 @@ m32r_compute_frame_size (int size)\t/* # of var. bytes allocated.  */\n   unsigned int gmask;\n   enum m32r_function_type fn_type;\n   int interrupt_p;\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table);\n \n   var_size\t= M32R_STACK_ALIGN (size);\n   args_size\t= M32R_STACK_ALIGN (current_function_outgoing_args_size);\n@@ -1818,15 +1852,16 @@ m32r_compute_frame_size (int size)\t/* # of var. bytes allocated.  */\n   /* Calculate space needed for registers.  */\n   for (regno = 0; regno < M32R_MAX_INT_REGS; regno++)\n     {\n-      if (MUST_SAVE_REGISTER (regno, interrupt_p))\n+      if (MUST_SAVE_REGISTER (regno, interrupt_p)\n+          || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n \t{\n \t  reg_size += UNITS_PER_WORD;\n \t  gmask |= 1 << regno;\n \t}\n     }\n \n   current_frame_info.save_fp = MUST_SAVE_FRAME_POINTER;\n-  current_frame_info.save_lr = MUST_SAVE_RETURN_ADDR;\n+  current_frame_info.save_lr = MUST_SAVE_RETURN_ADDR || pic_reg_used;\n \n   reg_size += ((current_frame_info.save_fp + current_frame_info.save_lr)\n \t       * UNITS_PER_WORD);\n@@ -1865,6 +1900,21 @@ m32r_first_insn_address (void)\n   return 0;\n }\n \f\n+/* The table we use to reference PIC data.  */\n+static rtx global_offset_table;\n+                                                                                \n+void\n+m32r_load_pic_register (void)\n+{\n+  global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+  emit_insn (gen_get_pc (pic_offset_table_rtx, global_offset_table,\n+                         gen_rtx_CONST_INT(SImode, TARGET_MODEL_SMALL)));\n+                                                                                \n+  /* Need to emit this whether or not we obey regdecls,\n+     since setjmp/longjmp can cause life info to screw up.  */\n+  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+}\n+\n /* Expand the m32r prologue as a series of insns.  */\n \n void\n@@ -1873,6 +1923,7 @@ m32r_expand_prologue (void)\n   int regno;\n   int frame_size;\n   unsigned int gmask;\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table);\n \n   if (! current_frame_info.initialized)\n     m32r_compute_frame_size (get_frame_size ());\n@@ -1935,6 +1986,14 @@ m32r_expand_prologue (void)\n     emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n \n   if (current_function_profile)\n+    /* Push lr for mcount (form_pc, x).  */\n+    emit_insn (gen_movsi_push (stack_pointer_rtx,\n+                               gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM)));\n+                                                                                \n+  if (pic_reg_used)\n+    m32r_load_pic_register ();\n+\n+  if (current_function_profile && !pic_reg_used)\n     emit_insn (gen_blockage ());\n }\n \n@@ -2084,18 +2143,122 @@ direct_return (void)\n   if (! current_frame_info.initialized)\n     m32r_compute_frame_size (get_frame_size ());\n \n-  return current_frame_info.total_size == 0;\n+   return current_frame_info.total_size == 0;\n }\n \n \f\n /* PIC.  */\n \n+int\n+m32r_legitimate_pic_operand_p (rtx x)\n+{\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+    return 0;\n+                                                                                \n+  if (GET_CODE (x) == CONST\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+          || GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)\n+      && (GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT))\n+    return 0;\n+                                                                                \n+  return 1;\n+}\n+\n+rtx\n+m32r_legitimize_pic_address (rtx orig, rtx reg)\n+{\n+#ifdef DEBUG_PIC\n+  printf(\"m32r_legitimize_pic_address()\\n\");\n+#endif\n+\n+  if (GET_CODE (orig) == SYMBOL_REF || GET_CODE (orig) == LABEL_REF)\n+    {\n+      rtx pic_ref, address;\n+      rtx insn;\n+      int subregs = 0;\n+\n+      if (reg == 0)\n+        {\n+          if (reload_in_progress || reload_completed)\n+            abort ();\n+          else\n+            reg = gen_reg_rtx (Pmode);\n+\n+          subregs = 1;\n+        }\n+\n+      if (subregs)\n+        address = gen_reg_rtx (Pmode);\n+      else\n+        address = reg;\n+\n+      emit_insn (gen_pic_load_addr (address, orig));\n+\n+      emit_insn (gen_addsi3 (address, address, pic_offset_table_rtx));\n+      pic_ref = gen_rtx (MEM, Pmode, address);\n+\n+      RTX_UNCHANGING_P (pic_ref) = 1;\n+      insn = emit_move_insn (reg, pic_ref);\n+      current_function_uses_pic_offset_table = 1;\n+#if 0\n+      /* Put a REG_EQUAL note on this insn, so that it can be optimized\n+         by loop.  */\n+      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n+                  REG_NOTES (insn));\n+#endif\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      rtx base, offset;\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+          && XEXP (XEXP (orig, 0), 1) == pic_offset_table_rtx)\n+        return orig;\n+\n+      if (reg == 0)\n+        {\n+          if (reload_in_progress || reload_completed)\n+            abort ();\n+          else\n+            reg = gen_reg_rtx (Pmode);\n+        }\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n+        {\n+          base = m32r_legitimize_pic_address (XEXP (XEXP (orig, 0), 0), reg);\n+          if (base == reg)\n+            offset = m32r_legitimize_pic_address (XEXP (XEXP (orig, 0), 1), NULL_RTX);\n+          else\n+            offset = m32r_legitimize_pic_address (XEXP (XEXP (orig, 0), 1), reg);\n+        }\n+      else\n+        return orig;\n+\n+      if (GET_CODE (offset) == CONST_INT)\n+        {\n+          if (INT16_P (INTVAL (offset)))\n+            return plus_constant (base, INTVAL (offset));\n+          else if (! reload_in_progress && ! reload_completed)\n+            offset = force_reg (Pmode, offset);\n+          else\n+            /* If we reach here, then something is seriously wrong.  */\n+            abort ();\n+        }\n+\n+      return gen_rtx (PLUS, Pmode, base, offset);\n+    }\n+\n+  return orig;\n+}\n+\n /* Emit special PIC prologues and epilogues.  */\n \n void\n m32r_finalize_pic (void)\n {\n-  /* Nothing to do.  */\n+  current_function_uses_pic_offset_table |= current_function_profile;\n }\n \f\n /* Nested function support.  */\n@@ -2120,6 +2283,9 @@ m32r_file_start (void)\n     fprintf (asm_out_file,\n \t     \"%s M32R/D special options: -G \" HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n \t     ASM_COMMENT_START, g_switch_value);\n+\n+  if (TARGET_LITTLE_ENDIAN)\n+    fprintf (asm_out_file, \"\\t.little\\n\");\n }\n \f\n /* Print operand X (an rtx) in assembler syntax to file FILE."}, {"sha": "0c7ce06a593a290bee63490040526a484f28cfca", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 291, "deletions": 245, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -38,6 +38,9 @@\n #undef STARTFILE_SPEC\n #undef ENDFILE_SPEC\n #undef SUBTARGET_SWITCHES\n+\n+#undef ASM_APP_ON\n+#undef ASM_APP_OFF\n \f\n \n /* M32R/X overrides.  */\n@@ -50,7 +53,6 @@\n %{m32r:-U__M32RX__  -U__m32rx__ -U__M32R2__ -U__m32r2__} \\\n  \"\n \n-\n /* Assembler switches.  */\n #define ASM_CPU_SPEC \\\n \"%{m32r} %{m32rx} %{m32r2} %{!O0: %{O*: -O}} --no-warn-explicit-parallel-conflicts\"\n@@ -101,7 +103,7 @@\n #define TARGET_VERSION fprintf (stderr, \" (m32r)\")\n #endif\n \n-/* Switch  Recognition by gcc.c.  Add -G xx support */\n+/* Switch  Recognition by gcc.c.  Add -G xx support.  */\n \n #undef  SWITCH_TAKES_ARG\n #define SWITCH_TAKES_ARG(CHAR) \\\n@@ -115,6 +117,13 @@\n       builtin_define (\"__M32R__\");\t\t\\\n       builtin_assert (\"cpu=m32r\");\t\t\\\n       builtin_assert (\"machine=m32r\");\t\t\\\n+      builtin_define (TARGET_BIG_ENDIAN\t\t\\\n+                      ? \"__BIG_ENDIAN__\" : \"__LITTLE_ENDIAN__\"); \\\n+      if (flag_pic)\t\t\t\t\\\n+        {\t\t\t\t\t\\\n+          builtin_define (\"__pic__\");\t\t\\\n+          builtin_define (\"__PIC__\");\t\t\\\n+        }\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n@@ -157,7 +166,7 @@\n #endif\n \n #ifndef RELAX_SPEC\n-#if 0 /* not supported yet */\n+#if 0 /* Not supported yet.  */\n #define RELAX_SPEC \"%{mrelax:-relax}\"\n #else\n #define RELAX_SPEC \"\"\n@@ -174,11 +183,12 @@\n   { \"relax\",\t\t\tRELAX_SPEC },\t\t\t\t\\\n   SUBTARGET_EXTRA_SPECS\n \n+#undef  CC1_SPEC\n #define CC1_SPEC \"%{G*} %(cc1_cpu)\"\n \n /* Options to pass on to the assembler.  */\n #undef  ASM_SPEC\n-#define ASM_SPEC \"%{v} %(asm_cpu) %(relax)\"\n+#define ASM_SPEC \"%{v} %(asm_cpu) %(relax) %{fpic:-K PIC} %{fPIC:-K PIC}\"\n \n #define LINK_SPEC \"%{v} %(link_cpu) %(relax)\"\n \n@@ -234,6 +244,16 @@ extern int target_flags;\n #undef  TARGET_M32R\n #define TARGET_M32R             (! TARGET_M32RX && ! TARGET_M32R2)\n \n+/* Big Endian Flag.  */\n+#define BIG_ENDIAN_BIT \t\t(1 << 7)\n+#define TARGET_BIG_ENDIAN       (target_flags & BIG_ENDIAN_BIT)\n+\n+/* Little Endian Flag.  */\n+#define LITTLE_ENDIAN_BIT \t(1 <<  8)\n+#ifndef TARGET_LITTLE_ENDIAN \t/* See little.h */\n+#define TARGET_LITTLE_ENDIAN    (target_flags & LITTLE_ENDIAN_BIT)\n+#endif\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -270,6 +290,11 @@ extern int target_flags;\n extern const char * m32r_model_string;\n extern const char * m32r_sdata_string;\n \n+/* Cache-flush support.  */\n+extern const char * m32r_cache_flush_func;\n+extern const char * m32r_cache_flush_trap_string;\n+extern int m32r_cache_flush_trap;\n+\n #ifndef SUBTARGET_OPTIONS\n #define SUBTARGET_OPTIONS\n #endif\n@@ -279,7 +304,15 @@ extern const char * m32r_sdata_string;\n   { \"model=\", & m32r_model_string,\t\t\t\t\t\\\n     N_(\"Code size: small, medium or large\"), 0},\t\t\t\\\n   { \"sdata=\", & m32r_sdata_string,\t\t\t\t\t\\\n-    N_(\"Small data area: none, sdata, use\"), 0}\t\t\t\t\\\n+    N_(\"Small data area: none, sdata, use\"), 0},\t\t\t\\\n+  { \"no-flush-func\", & m32r_cache_flush_func,\t\t\t\t\\\n+    N_(\"Don't call any cache flush functions\") },\t\t\t\\\n+  { \"flush-func=\", & m32r_cache_flush_func,\t\t\t\t\\\n+    N_(\"Specify cache flush function\") },\t\t\t\t\\\n+  { \"no-flush-trap\", & m32r_cache_flush_trap_string,\t\t\t\\\n+    N_(\"Don't call any cache flush trap\") },\t\t\t\t\\\n+  { \"flush-trap=\", & m32r_cache_flush_trap_string,\t\t\t\\\n+    N_(\"Specify cache flush trap number\") }\t\t\t\t\\\n   SUBTARGET_OPTIONS\t\t\t\t\t\t\t\\\n }\n \n@@ -307,13 +340,13 @@ extern const char * m32r_sdata_string;\n enum m32r_model { M32R_MODEL_SMALL, M32R_MODEL_MEDIUM, M32R_MODEL_LARGE };\n \n extern enum m32r_model m32r_model;\n-#define TARGET_MODEL_SMALL (m32r_model == M32R_MODEL_SMALL)\n+#define TARGET_MODEL_SMALL  (m32r_model == M32R_MODEL_SMALL)\n #define TARGET_MODEL_MEDIUM (m32r_model == M32R_MODEL_MEDIUM)\n-#define TARGET_MODEL_LARGE (m32r_model == M32R_MODEL_LARGE)\n-#define TARGET_ADDR24 (m32r_model == M32R_MODEL_SMALL)\n-#define TARGET_ADDR32 (! TARGET_ADDR24)\n-#define TARGET_CALL26 (! TARGET_CALL32)\n-#define TARGET_CALL32 (m32r_model == M32R_MODEL_LARGE)\n+#define TARGET_MODEL_LARGE  (m32r_model == M32R_MODEL_LARGE)\n+#define TARGET_ADDR24       (m32r_model == M32R_MODEL_SMALL)\n+#define TARGET_ADDR32       (! TARGET_ADDR24)\n+#define TARGET_CALL26       (! TARGET_CALL32)\n+#define TARGET_CALL32       (m32r_model == M32R_MODEL_LARGE)\n \n /* The default is the small model.  */\n #ifndef M32R_MODEL_DEFAULT\n@@ -349,8 +382,7 @@ extern enum m32r_model m32r_model;\n    .data).  ??? There can be a problem if the user passes a -G value greater\n    than the default and a library object in a header file is that size.\n    The default is 8 so this should be rare - if it occurs the user\n-   is required to rebuild the libraries or use a smaller value for -G.\n-*/\n+   is required to rebuild the libraries or use a smaller value for -G.  */\n \n /* Maximum size of variables that go in .sdata/.sbss.\n    The -msdata=foo switch also controls how small variables are handled.  */\n@@ -361,9 +393,9 @@ extern enum m32r_model m32r_model;\n enum m32r_sdata { M32R_SDATA_NONE, M32R_SDATA_SDATA, M32R_SDATA_USE };\n \n extern enum m32r_sdata m32r_sdata;\n-#define TARGET_SDATA_NONE (m32r_sdata == M32R_SDATA_NONE)\n+#define TARGET_SDATA_NONE  (m32r_sdata == M32R_SDATA_NONE)\n #define TARGET_SDATA_SDATA (m32r_sdata == M32R_SDATA_SDATA)\n-#define TARGET_SDATA_USE (m32r_sdata == M32R_SDATA_USE)\n+#define TARGET_SDATA_USE   (m32r_sdata == M32R_SDATA_USE)\n \n /* Default is to disable the SDA\n    [for upward compatibility with previous toolchains].  */\n@@ -438,11 +470,11 @@ extern enum m32r_sdata m32r_sdata;\n #define BITS_BIG_ENDIAN 1\n \n /* Define this if most significant byte of a word is the lowest numbered.  */\n-#define BYTES_BIG_ENDIAN 1\n+#define BYTES_BIG_ENDIAN (TARGET_LITTLE_ENDIAN == 0)\n \n /* Define this if most significant word of a multiword number is the lowest\n    numbered.  */\n-#define WORDS_BIG_ENDIAN 1\n+#define WORDS_BIG_ENDIAN (TARGET_LITTLE_ENDIAN == 0)\n \n /* Define this macro if WORDS_BIG_ENDIAN is not constant.  This must\n    be a constant value with the same meaning as WORDS_BIG_ENDIAN,\n@@ -481,7 +513,7 @@ extern enum m32r_sdata m32r_sdata;\n #define STACK_BOUNDARY 32\n \n /* ALIGN FRAMES on word boundaries */\n-#define M32R_STACK_ALIGN(LOC) (((LOC)+3) & ~3)\n+#define M32R_STACK_ALIGN(LOC) (((LOC) + 3) & ~ 3)\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 32\n@@ -516,6 +548,9 @@ extern enum m32r_sdata m32r_sdata;\n /* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n+\n+/* Define LAVEL_ALIGN to calculate code length of PNOP at labels.  */\n+#define LABEL_ALIGN(insn) 2\n \f\n /* Layout of source language data types.  */\n \n@@ -611,6 +646,14 @@ extern enum m32r_sdata m32r_sdata;\n \n #ifdef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n #define CONDITIONAL_REGISTER_USAGE SUBTARGET_CONDITIONAL_REGISTER_USAGE\n+#else\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t \\\n+  do\t\t\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t \\\n+      if (flag_pic)\t\t\t\t\t \\\n+          fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t \\\n+    }\t\t\t\t\t\t\t \\\n+  while (0)\n #endif\n \n /* If defined, an initializer for a vector of integers, containing the\n@@ -621,15 +664,15 @@ extern enum m32r_sdata m32r_sdata;\n #define SUBTARGET_REG_ALLOC_ORDER\n #endif\n \n-#if 1 /* better for int code */\n+#if 1 /* Better for int code.  */\n #define REG_ALLOC_ORDER\t\t\t\t\\\n {\t\t\t\t\t\t\\\n   4,  5,  6,  7,  2,  3,  8,  9, 10,\t\t\\\n   11, 12, 13, 14,  0,  1, 15, 16, 17, 18\t\\\n   SUBTARGET_REG_ALLOC_ORDER\t\t\t\\\n }\n \n-#else /* better for fp code at expense of int code */\n+#else /* Better for fp code at expense of int code.  */\n #define REG_ALLOC_ORDER\t\t\t\t\\\n {\t\t\t\t\t\t\\\n    0,  1,  2,  3,  4,  5,  6,  7,  8,\t\t\\\n@@ -643,13 +686,13 @@ extern enum m32r_sdata m32r_sdata;\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.  */\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n-((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n extern const unsigned int m32r_hard_regno_mode_ok[FIRST_PSEUDO_REGISTER];\n extern unsigned int m32r_mode_class[];\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-((m32r_hard_regno_mode_ok[REGNO] & m32r_mode_class[MODE]) != 0)\n+  ((m32r_hard_regno_mode_ok[REGNO] & m32r_mode_class[MODE]) != 0)\n \n /* A C expression that is nonzero if it is desirable to choose\n    register allocation so as to avoid move instructions between a\n@@ -660,11 +703,11 @@ extern unsigned int m32r_mode_class[];\n    MODE2)' must be zero.  */\n \n /* Tie QI/HI/SI modes together.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-(GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n- && GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\\n- && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n- && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n+#define MODES_TIEABLE_P(MODE1, MODE2) \t\t\\\n+  (   GET_MODE_CLASS (MODE1) == MODE_INT\t\\\n+   && GET_MODE_CLASS (MODE2) == MODE_INT\t\\\n+   && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n+   && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n \n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   m32r_hard_regno_rename_ok (OLD_REG, NEW_REG)\n@@ -745,33 +788,33 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n-#define REG_CLASS_FROM_LETTER(C)\t\t\t\t\t\\\n-((C) == 'c'\t? CARRY_REG\t\t\t\t\t\t\\\n- : (C) == 'a'\t? ACCUM_REGS\t\t\t\t\t\t\\\n- :\t\t  NO_REGS)\n+#define REG_CLASS_FROM_LETTER(C)\t\t\t\\\n+  (  (C) == 'c'\t? CARRY_REG\t\t\t\t\\\n+   : (C) == 'a'\t? ACCUM_REGS\t\t\t\t\\\n+   :\t\t  NO_REGS)\n \n /* These assume that REGNO is a hard or pseudo reg number.\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n-((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\\\n- ? GPR_P (REGNO) || (REGNO) == ARG_POINTER_REGNUM\t\\\n- : GPR_P (reg_renumber[REGNO]))\n+  ((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\\\n+   ? GPR_P (REGNO) || (REGNO) == ARG_POINTER_REGNUM\t\\\n+   : GPR_P (reg_renumber[REGNO]))\n+\n #define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n-(CLASS)\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n-((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* The letters I, J, K, L, M, N, O, P in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n@@ -794,37 +837,37 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    <= ((unsigned HOST_WIDE_INT)((HIGH) - (LOW))))\n \n /* Local to this file.  */\n-#define INT8_P(X) ((X) >= -0x80 && (X) <= 0x7f)\n-#define INT16_P(X) ((X) >= -0x8000 && (X) <= 0x7fff)\n-#define CMP_INT16_P(X) ((X) >= -0x7fff && (X) <= 0x8000)\n-#define UPPER16_P(X) (((X) & 0xffff) == 0\t\t\t\t\\\n-\t\t      && ((X) >> 16) >= -0x8000\t\t\t\t\\\n-\t\t      && ((X) >> 16) <= 0x7fff)\n-#define UINT16_P(X) (((unsigned HOST_WIDE_INT) (X)) <= 0x0000ffff)\n-#define UINT24_P(X) (((unsigned HOST_WIDE_INT) (X)) <= 0x00ffffff)\n-#define UINT32_P(X) (((unsigned HOST_WIDE_INT) (X)) <= 0xffffffff)\n-#define UINT5_P(X)  ((X) >= 0 && (X) < 32)\n+#define INT8_P(X)      ((X) >= -   0x80 && (X) <= 0x7f)\n+#define INT16_P(X)     ((X) >= - 0x8000 && (X) <= 0x7fff)\n+#define CMP_INT16_P(X) ((X) >= - 0x7fff && (X) <= 0x8000)\n+#define UPPER16_P(X)  (((X) & 0xffff) == 0\t\t\t\t\\\n+\t\t        && ((X) >> 16) >= - 0x8000\t\t\t\\\n+\t\t        && ((X) >> 16) <= 0x7fff)\n+#define UINT16_P(X)   (((unsigned HOST_WIDE_INT) (X)) <= 0x0000ffff)\n+#define UINT24_P(X)   (((unsigned HOST_WIDE_INT) (X)) <= 0x00ffffff)\n+#define UINT32_P(X)   (((unsigned HOST_WIDE_INT) (X)) <= 0xffffffff)\n+#define UINT5_P(X)    ((X) >= 0 && (X) < 32)\n #define INVERTED_SIGNED_8BIT(VAL) ((VAL) >= -127 && (VAL) <= 128)\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-((C) == 'I' ? INT8_P (VALUE)\t\t\t\t\t\t\\\n- : (C) == 'J' ? INT16_P (VALUE)\t\t\t\t\t\t\\\n- : (C) == 'K' ? UINT16_P (VALUE)\t\t\t\t\t\\\n- : (C) == 'L' ? UPPER16_P (VALUE)\t\t\t\t\t\\\n- : (C) == 'M' ? UINT24_P (VALUE)\t\t\t\t\t\\\n- : (C) == 'N' ? INVERTED_SIGNED_8BIT (VALUE)\t\t\t\t\\\n- : (C) == 'O' ? UINT5_P (VALUE)\t\t\t\t\t\t\\\n- : (C) == 'P' ? CMP_INT16_P (VALUE)\t\t\t\t\t\\\n- : 0)\n+  (  (C) == 'I' ? INT8_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'J' ? INT16_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'K' ? UINT16_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'L' ? UPPER16_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'M' ? UINT24_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'N' ? INVERTED_SIGNED_8BIT (VALUE)\t\t\t\t\\\n+   : (C) == 'O' ? UINT5_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'P' ? CMP_INT16_P (VALUE)\t\t\t\t\t\\\n+   : 0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself.\n    For the m32r, handle a few constants inline.\n    ??? We needn't treat DI and DF modes differently, but for now we do.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-((C) == 'G' ? easy_di_const (VALUE)\t\t\t\t\t\\\n- : (C) == 'H' ? easy_df_const (VALUE)\t\t\t\t\t\\\n- : 0)\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  (  (C) == 'G' ? easy_di_const (VALUE)\t\t\t\t\t\\\n+   : (C) == 'H' ? easy_df_const (VALUE)\t\t\t\t\t\\\n+   : 0)\n \n /* A C expression that defines the optional machine-dependent constraint\n    letters that can be used to segregate specific types of operands,\n@@ -839,40 +882,34 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    U is for loads with post increment.  */\n \n #define EXTRA_CONSTRAINT(VALUE, C)\t\t\t\t\t\\\n-(  (C) == 'Q' ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF)\t\\\n+  (  (C) == 'Q' ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF)\t\\\n \t\t || addr24_operand (VALUE, VOIDmode))\t\t\t\\\n- : (C) == 'R' ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF)\t\\\n+   : (C) == 'R' ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF)\t\\\n \t\t || addr32_operand (VALUE, VOIDmode))\t\t\t\\\n- : (C) == 'S' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n+   : (C) == 'S' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n \t\t && STORE_PREINC_PREDEC_P (GET_MODE (VALUE),\t\t\\\n \t\t\t\t\t   XEXP (VALUE, 0)))\t\t\\\n- : (C) == 'T' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n+   : (C) == 'T' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n \t\t && memreg_operand (VALUE, GET_MODE (VALUE)))\t\t\\\n- : (C) == 'U' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n+   : (C) == 'U' ? (GET_CODE (VALUE) == MEM\t\t\t\t\\\n \t\t && LOAD_POSTINC_P (GET_MODE (VALUE),\t\t\t\\\n \t\t\t\t    XEXP (VALUE, 0)))\t\t\t\\\n- : 0)\n+   : 0)\n \f\n /* Stack layout and stack pointer usage.  */\n \n /* Define this macro if pushing a word onto the stack moves the stack\n    pointer to a smaller address.  */\n #define STACK_GROWS_DOWNWARD\n \n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset from the frame pointer.  */\n-/*#define FRAME_GROWS_DOWNWARD*/\n-\n /* Offset from frame pointer to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n    first local allocated.  Otherwise, it is the offset to the BEGINNING\n    of the first local allocated.  */\n /* The frame pointer points at the same place as the stack pointer, except if\n    alloca has been called.  */\n #define STARTING_FRAME_OFFSET \\\n-M32R_STACK_ALIGN (current_function_outgoing_args_size)\n+  M32R_STACK_ALIGN (current_function_outgoing_args_size)\n \n /* Offset from the stack pointer register to the first location at which\n    outgoing arguments are placed.  */\n@@ -881,32 +918,6 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n /* Offset of first parameter from the argument pointer register value.  */\n #define FIRST_PARM_OFFSET(FNDECL) 0\n \n-/* A C expression whose value is RTL representing the address in a\n-   stack frame where the pointer to the caller's frame is stored.\n-   Assume that FRAMEADDR is an RTL expression for the address of the\n-   stack frame itself.\n-\n-   If you don't define this macro, the default is to return the value\n-   of FRAMEADDR--that is, the stack frame address is also the address\n-   of the stack word that points to the previous frame.  */\n-/*define DYNAMIC_CHAIN_ADDRESS (FRAMEADDR)*/\n-\n-/* A C expression whose value is RTL representing the value of the\n-   return address for the frame COUNT steps up from the current frame.\n-   FRAMEADDR is the frame pointer of the COUNT frame, or the frame\n-   pointer of the COUNT - 1 frame if `RETURN_ADDR_IN_PREVIOUS_FRAME'\n-   is defined.  */\n-/* The current return address is in r14.  */\n-#if 0 /* The default value should work.  */\n-#define RETURN_ADDR_RTX(COUNT, FRAME) \\\n-(((COUNT) == -1)\t\t\t\t\t\t\t\\\n- ? gen_rtx_REG (Pmode, 14)\t\t\t\t\t\t\\\n- : copy_to_reg (gen_rtx_MEM (Pmode,\t\t\t\t\t\\\n-\t\t\t     memory_address (Pmode,\t\t\t\\\n-\t\t\t\t\t     plus_constant ((FRAME),\t\\\n-\t\t\t\t\t\t\t    UNITS_PER_WORD)))))\n-#endif\n-\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM 15\n \n@@ -916,30 +927,17 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM 16\n \n-/* The register number of the return address pointer register, which\n-   is used to access the current function's return address from the\n-   stack.  On some machines, the return address is not at a fixed\n-   offset from the frame pointer or stack pointer or argument\n-   pointer.  This register can be defined to point to the return\n-   address on the stack, and then be converted by `ELIMINABLE_REGS'\n-   into either the frame pointer or stack pointer.\n-\n-   Do not define this macro unless there is no other way to get the\n-   return address from the stack.  */\n-/* ??? revisit */\n-/* #define RETURN_ADDRESS_POINTER_REGNUM */\n-\n-/* Register in which static-chain is passed to a function.  This must\n-   not be a register used by the prologue.  */\n-#define STATIC_CHAIN_REGNUM 7\n+/* Register in which static-chain is passed to a function.\n+   This must not be a register used by the prologue.  */\n+#define STATIC_CHAIN_REGNUM  7\n \n /* These aren't official macros.  */\n-#define PROLOGUE_TMP_REGNUM 4\n-#define RETURN_ADDR_REGNUM 14\n-/* #define GP_REGNUM 12 */\n-#define CARRY_REGNUM 17\n-#define ACCUM_REGNUM 18\n-#define M32R_MAX_INT_REGS 16\n+#define PROLOGUE_TMP_REGNUM  4\n+#define RETURN_ADDR_REGNUM  14\n+/* #define GP_REGNUM        12 */\n+#define CARRY_REGNUM        17\n+#define ACCUM_REGNUM        18\n+#define M32R_MAX_INT_REGS   16\n \n #ifndef SUBTARGET_GPR_P\n #define SUBTARGET_GPR_P(REGNO) 0\n@@ -1004,19 +1002,21 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    registers.  This macro must be defined if `ELIMINABLE_REGS' is\n    defined.  */\n \n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int size = m32r_compute_frame_size (get_frame_size ());\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n- if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n-   (OFFSET) = 0;\t\t\t\t\t\t\t\\\n- else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n-   (OFFSET) = size - current_function_pretend_args_size;\t\t\\\n- else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n-   (OFFSET) = size - current_function_pretend_args_size;\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-}\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\\\n+      int size = m32r_compute_frame_size (get_frame_size ());\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\t\\\n+      if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+\t(OFFSET) = 0;\t\t\t\t\t\t\t\t\\\n+      else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n+\t(OFFSET) = size - current_function_pretend_args_size;\t\t\t\\\n+      else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+\t(OFFSET) = size - current_function_pretend_args_size;\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* Function argument passing.  */\n \n@@ -1030,22 +1030,6 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    increase the stack frame size by this amount.  */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n-/* Define this macro if functions should assume that stack space has\n-   been allocated for arguments even when their values are passed in\n-   registers.\n-\n-   The value of this macro is the size, in bytes, of the area\n-   reserved for arguments passed in registers for the function\n-   represented by FNDECL.\n-\n-   This space can be allocated by the caller, or be a part of the\n-   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE' says\n-   which.  */\n-#if 0\n-#define REG_PARM_STACK_SPACE(FNDECL) \\\n-  (M32R_MAX_PARM_REGS * UNITS_PER_WORD)\n-#endif\n-\n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call.\n    FUNDECL is the declaration node of the function (as a tree),\n@@ -1159,9 +1143,8 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n #if 0\n /* We assume PARM_BOUNDARY == UNITS_PER_WORD here.  */\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n-(((TYPE) ? TYPE_ALIGN (TYPE) : GET_MODE_BITSIZE (MODE)) <= PARM_BOUNDARY \\\n- ? PARM_BOUNDARY \\\n- : 2 * PARM_BOUNDARY)\n+  (((TYPE) ? TYPE_ALIGN (TYPE) : GET_MODE_BITSIZE (MODE)) <= PARM_BOUNDARY \\\n+   ? PARM_BOUNDARY : 2 * PARM_BOUNDARY)\n #endif\n \n /* This macro offers an alternative\n@@ -1192,7 +1175,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    this case.  */\n \n #define SETUP_INCOMING_VARARGS(ARGS_SO_FAR, MODE, TYPE, PRETEND_SIZE, NO_RTL) \\\n- m32r_setup_incoming_varargs (&ARGS_SO_FAR, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n+  m32r_setup_incoming_varargs (& ARGS_SO_FAR, MODE, TYPE, & PRETEND_SIZE, NO_RTL)\n \n /* Implement `va_arg'.  */\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n@@ -1243,36 +1226,85 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n-#define FUNCTION_PROFILER(FILE, LABELNO) abort ()\n+#undef  FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (flag_pic)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\tld24 r14,#mcount\\n\");\t\t\\\n+\t  fprintf (FILE, \"\\tadd r14,r12\\n\");\t\t\t\\\n+\t  fprintf (FILE, \"\\tld r14,@r14\\n\");\t\t\t\\\n+\t  fprintf (FILE, \"\\tjl r14\\n\");\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (TARGET_ADDR24)\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tbl mcount\\n\");\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      fprintf (FILE, \"\\tseth r14,#high(mcount)\\n\");\t\\\n+\t      fprintf (FILE, \"\\tor3 r14,r14,#low(mcount)\\n\");\t\\\n+\t      fprintf (FILE, \"\\tjl r14\\n\");\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\taddi sp,#4\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* Trampolines.  */\n \n-/* On the M32R, the trampoline is\n+/* On the M32R, the trampoline is:\n \n-\tld24 r7,STATIC\n-\tld24 r6,FUNCTION\n-\tjmp r6\n-\tnop\n+        mv      r7, lr   -> bl L1        ; 178e 7e01\n+L1:     add3    r6, lr, #L2-L1           ; 86ae 000c (L2 - L1 = 12)\n+        mv      lr, r7   -> ld r7,@r6+   ; 1e87 27e6\n+        ld      r6, @r6  -> jmp r6       ; 26c6 1fc6\n+L2:     .word STATIC\n+        .word FUNCTION  */\n \n-   ??? Need addr32 support.\n-*/\n+#ifndef CACHE_FLUSH_FUNC\n+#define CACHE_FLUSH_FUNC \"_flush_cache\"\n+#endif\n+#ifndef CACHE_FLUSH_TRAP\n+#define CACHE_FLUSH_TRAP \"12\"\n+#endif\n \n /* Length in bytes of the trampoline for entering a nested function.  */\n #define TRAMPOLINE_SIZE 12\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n    CXT is an RTX for the static chain value for the function.  */\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n-do { \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 0)), \\\n-\t\t  plus_constant ((CXT), 0xe7000000)); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 4)), \\\n-\t\t  plus_constant ((FNADDR), 0xe6000000)); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 8)), \\\n-\t\t  GEN_INT (0x1fc67000)); \\\n-  emit_insn (gen_flush_icache (validize_mem (gen_rtx_MEM (SImode, TRAMP)))); \\\n-} while (0)\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 0)),\t\t\\\n+\t\t      GEN_INT\t\t\t\t\t\t\t\\\n+\t\t      (TARGET_LITTLE_ENDIAN ? 0x017e8e17 : 0x178e7e01));\t\\\n+      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 4)),\t\t\\\n+\t\t      GEN_INT\t\t\t\t\t\t\t\\\n+\t\t      (TARGET_LITTLE_ENDIAN ? 0x0c00ae86 : 0x86ae000c));\t\\\n+      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 8)),\t\t\\\n+\t\t      GEN_INT\t\t\t\t\t\t\t\\\n+\t\t      (TARGET_LITTLE_ENDIAN ? 0xe627871e : 0x1e8727e6));\t\\\n+      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)),\t\t\\\n+\t\t      GEN_INT\t\t\t\t\t\t\t\\\n+\t\t      (TARGET_LITTLE_ENDIAN ? 0xc616c626 : 0x26c61fc6));\t\\\n+      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 16)),\t\t\\\n+\t\t      (CXT));\t\t\t\t\t\t\t\\\n+      emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 20)),\t\t\\\n+\t\t      (FNADDR));\t\t\t\t\t\t\\\n+      if (m32r_cache_flush_trap_string && m32r_cache_flush_trap_string[0])\t\\\n+\temit_insn (gen_flush_icache (validize_mem (gen_rtx_MEM (SImode, TRAMP)),\\\n+\t\t\t\t     GEN_INT (m32r_cache_flush_trap) ));\t\\\n+      else if (m32r_cache_flush_func && m32r_cache_flush_func[0])\t\t\\\n+\temit_library_call (gen_rtx_SYMBOL_REF (Pmode, m32r_cache_flush_func), \t\\\n+\t\t\t   0, VOIDmode, 3, TRAMP, Pmode,\t\t\t\\\n+\t\t\t   GEN_INT (TRAMPOLINE_SIZE), SImode,\t\t\t\\\n+\t\t\t   GEN_INT (3), SImode);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* Library calls.  */\n \n@@ -1286,14 +1318,17 @@ do { \\\n \n /* We have post-inc load and pre-dec,pre-inc store,\n    but only for 4 byte vals.  */\n-#define HAVE_PRE_DECREMENT 1\n-#define HAVE_PRE_INCREMENT 1\n+#define HAVE_PRE_DECREMENT  1\n+#define HAVE_PRE_INCREMENT  1\n #define HAVE_POST_INCREMENT 1\n \n /* Recognize any constant value that is a valid address.  */\n-#define CONSTANT_ADDRESS_P(X) \\\n-(GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n- || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n+#define CONSTANT_ADDRESS_P(X)   \\\n+  (    GET_CODE (X) == LABEL_REF  \\\n+   ||  GET_CODE (X) == SYMBOL_REF \\\n+   ||  GET_CODE (X) == CONST_INT  \\\n+   || (GET_CODE (X) == CONST      \\\n+       && ! (flag_pic && ! m32r_legitimate_pic_operand_p (X))))\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    We don't allow (plus symbol large-constant) as the relocations can't\n@@ -1302,11 +1337,11 @@ do { \\\n    constant to memory if they can't handle them.  */\n \n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\t\\\n-(! (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-    && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n-    && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\t\\\n-    && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n-    && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (X, 0), 1)) > 32767))\n+  (! (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n+      && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\t\\\n+      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n+      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (X, 0), 1)) > 32767))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -1333,9 +1368,9 @@ do { \\\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X)\t\t\\\n-(GPR_P (REGNO (X))\t\t\t\\\n- || (REGNO (X)) == ARG_POINTER_REGNUM\t\\\n- || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  (GPR_P (REGNO (X))\t\t\t\\\n+   || (REGNO (X)) == ARG_POINTER_REGNUM\t\\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n@@ -1352,51 +1387,54 @@ do { \\\n \n /* Local to this file.  */\n #define RTX_OK_FOR_OFFSET_P(X) \\\n-(GET_CODE (X) == CONST_INT && INT16_P (INTVAL (X)))\n+  (GET_CODE (X) == CONST_INT && INT16_P (INTVAL (X)))\n \n /* Local to this file.  */\n-#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X)\t\t\t\t\\\n-(GET_CODE (X) == PLUS\t\t\t\t\t\t\t\\\n- && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\t\\\n- && RTX_OK_FOR_OFFSET_P (XEXP (X, 1)))\n+#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X)\t\t\t\\\n+  (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+   && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+   && RTX_OK_FOR_OFFSET_P (XEXP (X, 1)))\n \n /* Local to this file.  */\n /* For LO_SUM addresses, do not allow them if the MODE is > 1 word,\n    since more than one instruction will be required.  */\n-#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X)\t\t\t\t\\\n-(GET_CODE (X) == LO_SUM\t\t\t\t\t\t\t\\\n- && (MODE != BLKmode && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\t\t\\\n- && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\t\\\n- && CONSTANT_P (XEXP (X, 1)))\n+#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X)\t\t\t\\\n+  (GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n+   && (MODE != BLKmode && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\\\n+   && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+   && CONSTANT_P (XEXP (X, 1)))\n \n /* Local to this file.  */\n /* Is this a load and increment operation.  */\n-#define LOAD_POSTINC_P(MODE, X)\t\t\t\t\t\t\\\n-(((MODE) == SImode || (MODE) == SFmode)\t\t\t\t\t\\\n- && GET_CODE (X) == POST_INC\t\t\t\t\t\t\\\n- && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n- && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n+#define LOAD_POSTINC_P(MODE, X)\t\t\t\t\t\\\n+  (((MODE) == SImode || (MODE) == SFmode)\t\t\t\\\n+   && GET_CODE (X) == POST_INC\t\t\t\t\t\\\n+   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+   && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n \n /* Local to this file.  */\n /* Is this an increment/decrement and store operation.  */\n-#define STORE_PREINC_PREDEC_P(MODE, X)\t\t\t\t\t\\\n-(((MODE) == SImode || (MODE) == SFmode)\t\t\t\t\t\\\n- && (GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC)\t\t\\\n- && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n- && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{ if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (LEGITIMATE_OFFSET_ADDRESS_P ((MODE), (X)))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (LEGITIMATE_LO_SUM_ADDRESS_P ((MODE), (X)))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (LOAD_POSTINC_P ((MODE), (X)))\t\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (STORE_PREINC_PREDEC_P ((MODE), (X)))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-}\n+#define STORE_PREINC_PREDEC_P(MODE, X)\t\t\t\t\\\n+  (((MODE) == SImode || (MODE) == SFmode)\t\t\t\\\n+   && (GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC)\t\\\n+   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+   && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\\\n+      if (LEGITIMATE_OFFSET_ADDRESS_P ((MODE), (X)))\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\\\n+      if (LEGITIMATE_LO_SUM_ADDRESS_P ((MODE), (X)))\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\\\n+      if (LOAD_POSTINC_P ((MODE), (X)))\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\\\n+      if (STORE_PREINC_PREDEC_P ((MODE), (X)))\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n@@ -1409,22 +1447,30 @@ do { \\\n    GO_IF_LEGITIMATE_ADDRESS.\n \n    It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   ??? Is there anything useful we can do here for the M32R?  */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n+   opportunities to optimize the output.  */\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t \\\n+  do\t\t\t\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t \\\n+      if (flag_pic)\t\t\t\t\t\t \\\n+\t(X) = m32r_legitimize_pic_address (X, NULL_RTX);\t \\\n+      if (memory_address_p (MODE, X))\t\t\t\t \\\n+\tgoto WIN;\t\t\t\t\t\t \\\n+    }\t\t\t\t\t\t\t\t \\\n+  while (0)\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (ADDR) == PRE_DEC\t\t\t\t\t\\\n-      || GET_CODE (ADDR) == PRE_INC\t\t\t\t\t\\\n-      || GET_CODE (ADDR) == POST_INC\t\t\t\t\t\\\n-      || GET_CODE (ADDR) == LO_SUM)\t\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-} while (0)\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t \t\t\\\n+      if (   GET_CODE (ADDR) == PRE_DEC\t\t \t\t\\\n+\t  || GET_CODE (ADDR) == PRE_INC\t\t \t\t\\\n+\t  || GET_CODE (ADDR) == POST_INC\t\t \t\\\n+\t  || GET_CODE (ADDR) == LO_SUM)\t\t \t\t\\\n+\tgoto LABEL;\t\t\t\t\t \t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \f\n /* Condition code usage.  */\n \n@@ -1481,9 +1527,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n    output in the text section, along with the assembler instructions.\n    Otherwise, the readonly data section is used.\n    This macro is irrelevant if there is no separate readonly data section.  */\n-/*#define JUMP_TABLES_IN_TEXT_SECTION*/\n+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n \f\n-/* PIC */\n+/* Position Independent Code.  */\n \n /* The register number of the register used to address a table of static\n    data addresses in memory.  In some cases this register is defined by a\n@@ -1492,7 +1538,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    pointer and frame pointer registers.  If this macro is not defined, it\n    is up to the machine-dependent files to allocate such a register (if\n    necessary).  */\n-/*#define PIC_OFFSET_TABLE_REGNUM 12*/\n+#define PIC_OFFSET_TABLE_REGNUM 12\n \n /* Define this macro if the register defined by PIC_OFFSET_TABLE_REGNUM is\n    clobbered by calls.  Do not define this macro if PIC_OFFSET_TABLE_REGNUM\n@@ -1514,7 +1560,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    included in functions which used inline functions and were compiled to\n    assembly language.)  */\n \n-/*#define FINALIZE_PIC m32r_finalize_pic ()*/\n+#define FINALIZE_PIC m32r_finalize_pic ()\n \n /* A C expression that is nonzero if X is a legitimate immediate\n    operand on the target machine when generating position independent code.\n@@ -1523,7 +1569,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    check it either.  You need not define this macro if all constants\n    (including SYMBOL_REF) can be immediate operands when generating\n    position independent code.  */\n-/*#define LEGITIMATE_PIC_OPERAND_P(X)*/\n+#define LEGITIMATE_PIC_OPERAND_P(X) m32r_legitimate_pic_operand_p (X)\n \f\n /* Control the assembler format that we output.  */\n \n@@ -1620,10 +1666,10 @@ extern char m32r_punct_chars[256];\n    are useful when a single `md' file must support multiple assembler\n    formats.  In that case, the various `tm.h' files can define these\n    macros differently.  */\n-#define REGISTER_PREFIX \"\"\n-#define LOCAL_LABEL_PREFIX \".L\"\n-#define USER_LABEL_PREFIX \"\"\n-#define IMMEDIATE_PREFIX \"#\"\n+#define REGISTER_PREFIX\t\t\"\"\n+#define LOCAL_LABEL_PREFIX\t\".L\"\n+#define USER_LABEL_PREFIX\t\"\"\n+#define IMMEDIATE_PREFIX\t\"#\"\n \n /* This is how to output an element of a case-vector that is absolute.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\\\n@@ -1648,7 +1694,7 @@ extern char m32r_punct_chars[256];\n       fprintf (FILE, \"-\");\t\t\t\t\\\n       ASM_GENERATE_INTERNAL_LABEL (label, \"L\", REL);\t\\\n       assemble_name (FILE, label);\t\t\t\\\n-      fprintf (FILE, \")\\n\");\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -1720,7 +1766,7 @@ extern char m32r_punct_chars[256];\n /* Debugging information.  */\n \n /* Generate DBX and DWARF debugging information.  */\n-#define DBX_DEBUGGING_INFO 1\n+#define DBX_DEBUGGING_INFO    1\n #define DWARF2_DEBUGGING_INFO 1\n \n /* Prefer STABS (for now).  */\n@@ -1734,7 +1780,7 @@ extern char m32r_punct_chars[256];\n \n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE Pmode\n+#define CASE_VECTOR_MODE (flag_pic ? SImode : Pmode)\n \n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n@@ -1755,8 +1801,8 @@ extern char m32r_punct_chars[256];\n    done, NIL if none.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n \n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n+/* Max number of bytes we can move from memory\n+   to memory in one reasonably fast instruction.  */\n #define MOVE_MAX 4\n \n /* Define this to be nonzero if shift instructions ignore all but the low-order"}, {"sha": "5e562a7f5c08fc96568d3d628b8fa6ac80e51196", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 153, "deletions": 7, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -297,6 +297,18 @@\n   \"\"\n   \"\n {\n+  /* Fixup PIC cases.  */\n+  if (flag_pic)\n+    {\n+      if (symbolic_operand (operands[1], QImode))\n+        {\n+          if (reload_in_progress || reload_completed)\n+            operands[1] = m32r_legitimize_pic_address (operands[1], operands[0]);\n+          else\n+            operands[1] = m32r_legitimize_pic_address (operands[1], NULL_RTX);\n+        }\n+    }\n+\n   /* Everything except mem = const or mem = mem can be done easily.\n      Objects in the small data area are handled too.  */\n \n@@ -325,6 +337,18 @@\n   \"\"\n   \"\n {\n+  /* Fixup PIC cases.  */\n+  if (flag_pic)\n+    {\n+      if (symbolic_operand (operands[1], HImode))\n+        {\n+          if (reload_in_progress || reload_completed)\n+            operands[1] = m32r_legitimize_pic_address (operands[1], operands[0]);\n+          else\n+            operands[1] = m32r_legitimize_pic_address (operands[1], NULL_RTX);\n+        }\n+    }\n+\n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n   if (GET_CODE (operands[0]) == MEM)\n@@ -365,6 +389,18 @@\n   \"\"\n   \"\n {\n+  /* Fixup PIC cases.  */\n+  if (flag_pic)\n+    {\n+      if (symbolic_operand (operands[1], SImode))\n+        {\n+          if (reload_in_progress || reload_completed)\n+            operands[1] = m32r_legitimize_pic_address (operands[1], operands[0]);\n+          else\n+            operands[1] = m32r_legitimize_pic_address (operands[1], NULL_RTX);\n+        }\n+    }\n+\n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n   if (GET_CODE (operands[0]) == MEM)\n@@ -590,6 +626,18 @@\n   \"\"\n   \"\n {\n+  /* Fixup PIC cases.  */\n+  if (flag_pic)\n+    {\n+      if (symbolic_operand (operands[1], DImode))\n+        {\n+          if (reload_in_progress || reload_completed)\n+            operands[1] = m32r_legitimize_pic_address (operands[1], operands[0]);\n+          else\n+            operands[1] = m32r_legitimize_pic_address (operands[1], NULL_RTX);\n+        }\n+    }\n+\n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n   if (GET_CODE (operands[0]) == MEM)\n@@ -619,6 +667,18 @@\n   \"\"\n   \"\n {\n+  /* Fixup PIC cases.  */\n+  if (flag_pic)\n+    {\n+      if (symbolic_operand (operands[1], SFmode))\n+        {\n+          if (reload_in_progress || reload_completed)\n+            operands[1] = m32r_legitimize_pic_address (operands[1], operands[0]);\n+          else\n+            operands[1] = m32r_legitimize_pic_address (operands[1], NULL_RTX);\n+        }\n+    }\n+\n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n   if (GET_CODE (operands[0]) == MEM)\n@@ -659,6 +719,18 @@\n   \"\"\n   \"\n {\n+  /* Fixup PIC cases.  */\n+  if (flag_pic)\n+    {\n+      if (symbolic_operand (operands[1], DFmode))\n+        {\n+          if (reload_in_progress || reload_completed)\n+            operands[1] = m32r_legitimize_pic_address (operands[1], operands[0]);\n+          else\n+            operands[1] = m32r_legitimize_pic_address (operands[1], NULL_RTX);\n+        }\n+    }\n+\n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n   if (GET_CODE (operands[0]) == MEM)\n@@ -2269,7 +2341,27 @@\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"length\" \"2\")])\n  \n-(define_insn \"tablejump\"\n+(define_expand \"tablejump\"\n+  [(parallel [(set (pc) (match_operand 0 \"register_operand\" \"r\"))\n+              (use (label_ref (match_operand 1 \"\" \"\")))])]\n+  \"\"\n+  \"\n+{\n+  /* In pic mode, our address differences are against the base of the\n+     table.  Add that base value back in; CSE ought to be able to combine\n+     the two address loads.  */\n+  if (flag_pic)\n+    {\n+      rtx tmp, tmp2;\n+\n+      tmp = gen_rtx_LABEL_REF (Pmode, operands[1]);\n+      tmp2 = operands[0];\n+      tmp = gen_rtx_PLUS (Pmode, tmp2, tmp);\n+      operands[0] = memory_address (Pmode, tmp);\n+    }\n+}\")\n+\n+(define_insn \"*tablejump_insn\"\n   [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n@@ -2284,7 +2376,11 @@\n \t\t    (match_operand 1 \"\" \"\"))\n \t     (clobber (reg:SI 14))])]\n   \"\"\n-  \"\")\n+  \"\n+{\n+  if (flag_pic)\n+    current_function_uses_pic_offset_table = 1;\n+}\")\n \n (define_insn \"*call_via_reg\"\n   [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n@@ -2335,7 +2431,11 @@\n \t\t\t (match_operand 2 \"\" \"\")))\n \t     (clobber (reg:SI 14))])]\n   \"\"\n-  \"\")\n+  \"                                                                             \n+{\n+  if (flag_pic)\n+    current_function_uses_pic_offset_table = 1;\n+}\")\n \n (define_insn \"*call_value_via_reg\"\n   [(set (match_operand 0 \"register_operand\" \"=r\")\n@@ -2357,6 +2457,9 @@\n {\n   int call26_p = call26_operand (operands[1], FUNCTION_MODE);\n \n+  if (flag_pic)\n+    current_function_uses_pic_offset_table = 1;\n+\n   if (! call26_p)\n     {\n       /* We may not be able to reach with a `bl' insn so punt and leave it to\n@@ -2398,11 +2501,13 @@\n ;; Special pattern to flush the icache.\n \n (define_insn \"flush_icache\"\n-  [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")] 0)]\n+  [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")] 0)\n+   (match_operand 1 \"\" \"\")\n+   (clobber (reg:SI 17))]\n   \"\"\n-  \"* return \\\"nop ; flush-icache\\\";\"\n-  [(set_attr \"type\" \"int2\")\n-   (set_attr \"length\" \"2\")])\n+  \"* return \\\"trap %#%1 ; flush-icache\\\";\"\n+  [(set_attr \"type\" \"int4\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;; Speed up fabs and provide correct sign handling for -0\n \n@@ -2581,3 +2686,44 @@\n   \"* m32r_output_block_move (insn, operands); return \\\"\\\"; \"\n   [(set_attr \"type\"\t\"store8\")\n    (set_attr \"length\"\t\"72\")]) ;; Maximum\n+\n+;; PIC\n+\n+/* When generating pic, we need to load the symbol offset into a register.\n+   So that the optimizer does not confuse this with a normal symbol load\n+   we use an unspec.  The offset will be loaded from a constant pool entry,\n+   since that is the only type of relocation we can use.  */\n+\n+(define_insn \"pic_load_addr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (unspec:SI [(match_operand 1 \"\" \"\")] 4))]\n+  \"flag_pic\"\n+  \"ld24 %0,%#%1\"\n+  [(set_attr \"type\" \"int4\")])\n+\n+;; Load program counter insns.\n+\n+(define_insn \"get_pc\"\n+  [(clobber (reg:SI 14))\n+   (set (match_operand 0 \"register_operand\" \"=r\")\n+        (unspec [(match_operand 1 \"\" \"\")] 5))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"\"))]\n+  \"flag_pic\"\n+  \"*\n+{\n+  if (INTVAL(operands[2]))\n+    return \\\"bl.s .+4\\;ld24 %0,%#%1\\;add %0,lr\\\";\n+  else\n+    return \\\"bl.s .+4\\;seth %0,%#shigh(%1)\\;add3 %0,%0,%#low(%1+4)\\;add %0,lr\\\";}\"\n+  [(set (attr \"length\") (if_then_else (ne (match_dup 2) (const_int 0))\n+                                      (const_int 8)\n+                                      (const_int 12)))])\n+\n+(define_expand \"builtin_setjmp_receiver\"\n+  [(label_ref (match_operand 0 \"\" \"\"))]\n+  \"flag_pic\"\n+  \"\n+{\n+  m32r_load_pic_register ();\n+  DONE;\n+}\")"}, {"sha": "030465790948b8878d97d41d4535741316d1d32c", "filename": "gcc/config/m32r/t-linux", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Ft-linux?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -0,0 +1,42 @@\n+# lib1funcs.asm is currently empty.\n+CROSS_LIBGCC1 =\n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so...\n+\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+# Turn off the SDA while compiling libgcc2.  There are no headers for it\n+# and we want maximal upward compatibility here.\n+\n+TARGET_LIBGCC2_CFLAGS = -G 0 -fPIC\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+# We need to use -fpic when we are using gcc to compile the routines in\n+# initfini.c.  This is only really needed when we are going to use gcc/g++\n+# to produce a shared library, but since we don't know ahead of time when\n+# we will be doing that, we just always use -fpic when compiling the\n+# routines in initfini.c.\n+# -fpic currently isn't supported for the m32r.\n+\n+CRTSTUFF_T_CFLAGS_S = -fPIC\n+\n+\n+# Don't run fixproto\n+STMP_FIXPROTO =\n+ \n+# Don't install \"assert.h\" in gcc. We use the one in glibc.\n+INSTALL_ASSERT_H =\n+ \n+# Do not build libgcc1. Let gcc generate those functions. The GNU/Linux\n+# C library can handle them.\n+LIBGCC1 = \n+CROSS_LIBGCC1 =\n+LIBGCC1_TEST =\n+"}, {"sha": "1c6f46297989e3f9b0b794d7fe500741da65235b", "filename": "gcc/config/m32r/xm-linux.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fxm-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fxm-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fxm-linux.h?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -0,0 +1,26 @@\n+/* Configuration for GCC for Renesas M32R running Linux-based GNU systems.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+#include <m32r/xm-m32r.h>\n+#include <xm-linux.h>\n+\n+/* Doubles are stored in memory with the high order word first.\n+   This matters when cross-compiling.  */\n+#undef HOST_WORDS_BIG_ENDIAN"}, {"sha": "5859449839f91be81d7745e76e46d9d9f661bd0a", "filename": "gcc/config/m32r/xm-m32r.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fxm-m32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fconfig%2Fm32r%2Fxm-m32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fxm-m32r.h?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -0,0 +1,43 @@\n+/* Configuration for GNU C-compiler for the M32R processor.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR       8\n+#define HOST_BITS_PER_SHORT     16\n+#define HOST_BITS_PER_INT       32\n+#define HOST_BITS_PER_LONG      32\n+#define HOST_BITS_PER_LONGLONG  64\n+\n+/* Doubles are stored in memory with the high order word first.\n+   This matters when cross-compiling.  */\n+#define HOST_WORDS_BIG_ENDIAN    1\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE\t 0\n+#define FATAL_EXIT_CODE\t\t33\n+\n+/* If compiled with Sun CC, the use of alloca requires this #include.  */\n+#ifndef __GNUC__\n+#include \"alloca.h\"\n+#endif"}, {"sha": "d634362fadc5845c36f1427dc59c0c95767576e8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad12652102049de3b337a2e17718e6ca9810a159/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ad12652102049de3b337a2e17718e6ca9810a159", "patch": "@@ -400,8 +400,16 @@ in the following sections.\n -mno-crt0  -mrelax}\n \n @emph{M32R/D Options}\n-@gccoptlist{-m32r2 -m32rx -m32r -mcode-model=@var{model-type} @gol\n--msdata=@var{sdata-type}  -G @var{num}}\n+@gccoptlist{-m32r2 -m32rx -m32r @gol\n+-mdebug @gol\n+-malign-loops -mno-align-loops @gol\n+-missue-rate=@var{number} @gol\n+-mbranch-cost=@var{number} @gol\n+-mmodel=@var{code-size-model-type} @gol\n+-msdata=@var{sdata-type} @gol\n+-mno-flush-func -mflush-func=@var{name} @gol\n+-mno-flush-trap -mflush-trap=@var{number} @gol\n+-G @var{num}}\n \n @emph{M88K Options}\n @gccoptlist{-m88000  -m88100  -m88110  -mbig-pic @gol\n@@ -6834,8 +6842,8 @@ Generate code for the M32R/X@.\n @opindex m32r\n Generate code for the M32R@.  This is the default.\n \n-@item -mcode-model=small\n-@opindex mcode-model=small\n+@item -mmodel=small\n+@opindex mmodel=small\n Assume all objects live in the lower 16MB of memory (so that their addresses\n can be loaded with the @code{ld24} instruction), and assume all subroutines\n are reachable with the @code{bl} instruction.\n@@ -6844,14 +6852,14 @@ This is the default.\n The addressability of a particular object can be set with the\n @code{model} attribute.\n \n-@item -mcode-model=medium\n-@opindex mcode-model=medium\n+@item -mmodel=medium\n+@opindex mmodel=medium\n Assume objects may be anywhere in the 32-bit address space (the compiler\n will generate @code{seth/add3} instructions to load their addresses), and\n assume all subroutines are reachable with the @code{bl} instruction.\n \n-@item -mcode-model=large\n-@opindex mcode-model=large\n+@item -mmodel=large\n+@opindex mmodel=large\n Assume objects may be anywhere in the 32-bit address space (the compiler\n will generate @code{seth/add3} instructions to load their addresses), and\n assume subroutines may not be reachable with the @code{bl} instruction\n@@ -6893,6 +6901,49 @@ Compiling with different values of @var{num} may or may not work; if it\n doesn't the linker will give an error message---incorrect code will not be\n generated.\n \n+@item -mdebug\n+@opindex -mdebug\n+Makes the M32R specific code in the compiler display some statistics\n+that might help in debugging programs.\n+\n+@item -malign-loops\n+@opindex\n+Align all loops to a 32-byte boundary.\n+\n+@item -mno-align-loops\n+@opindex\n+Do not enforce a 32-byte alignment for loops.  This is the default.\n+\n+@item -missue-rate=@var{number}\n+@opindex\n+Issue @var{number} instructions per cycle.  @var{number} can only be 1\n+or 2.\n+\n+@item -mbranch-cost=@var{number}\n+@opindex\n+@var{number} can only be 1 or 2.  If it is 1 then branches will be\n+prefered over conditional code, if it is 2, then the opposite will\n+apply.\n+\n+@item -mflush-trap=@var{number}\n+@opindex\n+Specifies the trap number to use to flush the cache.  The default is\n+12.  Valid numbers are between 0 and 15 inclusive.\n+\n+@item -mno-flush-trap\n+@opindex\n+Specifies that the cache cannot be flushed by using a trap.\n+\n+@item -mflush-func=@var{name}\n+@opindex\n+Specifies the name of the operating system function to call to flush\n+the cache.  The default is @emph{_flush_cache}, but a function call\n+will only be used if a trap is not available.\n+\n+@item -mno-flush-func\n+@opindex\n+Indicates that there is no OS function for flushing the cache.\n+\n @end table\n \n @node M88K Options"}]}