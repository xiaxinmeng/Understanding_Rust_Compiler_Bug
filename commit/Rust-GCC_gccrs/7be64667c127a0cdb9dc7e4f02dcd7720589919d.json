{"sha": "7be64667c127a0cdb9dc7e4f02dcd7720589919d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JlNjQ2NjdjMTI3YTBjZGI5ZGM3ZTRmMDJkY2Q3NzIwNTg5OTE5ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-01-17T10:47:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-01-17T10:47:59Z"}, "message": "re PR rtl-optimization/38518 (Excessive compile time with -O3)\n\n2014-01-17  Richard Biener  <rguenther@suse.de>\n\n\tPR rtl-optimization/38518\n\t* df.h (df_analyze_loop): Declare.\n\t* df-core.c: Include cfgloop.h.\n\t(df_analyze_1): Split out main part of df_analyze.\n\t(df_analyze): Adjust.\n\t(loop_inverted_post_order_compute): New function.\n\t(loop_post_order_compute): Likewise.\n\t(df_analyze_loop): New function avoiding whole-function\n\tpostorder computes.\n\t* loop-invariant.c (find_defs): Use df_analyze_loop.\n\t(find_invariants): Adjust.\n\t* loop-iv.c (iv_analysis_loop_init): Use df_analyze_loop.\n\nFrom-SVN: r206702", "tree": {"sha": "87501164890f5046ea55327b6647afe5ac2c9e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87501164890f5046ea55327b6647afe5ac2c9e28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7be64667c127a0cdb9dc7e4f02dcd7720589919d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7be64667c127a0cdb9dc7e4f02dcd7720589919d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7be64667c127a0cdb9dc7e4f02dcd7720589919d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7be64667c127a0cdb9dc7e4f02dcd7720589919d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc3a9f0d477d52982b504c954da0d87d48e6c1f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc3a9f0d477d52982b504c954da0d87d48e6c1f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc3a9f0d477d52982b504c954da0d87d48e6c1f7"}], "stats": {"total": 288, "additions": 223, "deletions": 65}, "files": [{"sha": "76a37e9b3688b6b37bc6ab74c199acb9ed341c5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7be64667c127a0cdb9dc7e4f02dcd7720589919d", "patch": "@@ -1,3 +1,18 @@\n+2014-01-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR rtl-optimization/38518\n+\t* df.h (df_analyze_loop): Declare.\n+\t* df-core.c: Include cfgloop.h.\n+\t(df_analyze_1): Split out main part of df_analyze.\n+\t(df_analyze): Adjust.\n+\t(loop_inverted_post_order_compute): New function.\n+\t(loop_post_order_compute): Likewise.\n+\t(df_analyze_loop): New function avoiding whole-function\n+\tpostorder computes.\n+\t* loop-invariant.c (find_defs): Use df_analyze_loop.\n+\t(find_invariants): Adjust.\n+\t* loop-iv.c (iv_analysis_loop_init): Use df_analyze_loop.\n+\n 2014-01-17  Zhenqiang Chen  <zhenqiang.chen@arm.com>\n \n \t* config/arm/arm.c (arm_v7m_tune): Set max_insns_skipped to 2."}, {"sha": "edb3b25727a61c7276d8c96126bf8727199d0ab2", "filename": "gcc/df-core.c", "status": "modified", "additions": 202, "deletions": 39, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=7be64667c127a0cdb9dc7e4f02dcd7720589919d", "patch": "@@ -393,6 +393,7 @@ are write-only operations.\n #include \"df.h\"\n #include \"tree-pass.h\"\n #include \"params.h\"\n+#include \"cfgloop.h\"\n \n static void *df_get_bb_info (struct dataflow *, unsigned int);\n static void df_set_bb_info (struct dataflow *, unsigned int, void *);\n@@ -1225,23 +1226,13 @@ df_analyze_problem (struct dataflow *dflow,\n }\n \n \n-/* Analyze dataflow info for the basic blocks specified by the bitmap\n-   BLOCKS, or for the whole CFG if BLOCKS is zero.  */\n+/* Analyze dataflow info.  */\n \n-void\n-df_analyze (void)\n+static void\n+df_analyze_1 (void)\n {\n-  bitmap current_all_blocks = BITMAP_ALLOC (&df_bitmap_obstack);\n-  bool everything;\n   int i;\n \n-  free (df->postorder);\n-  free (df->postorder_inverted);\n-  df->postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  df->postorder_inverted = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  df->n_blocks = post_order_compute (df->postorder, true, true);\n-  df->n_blocks_inverted = inverted_post_order_compute (df->postorder_inverted);\n-\n   /* These should be the same.  */\n   gcc_assert (df->n_blocks == df->n_blocks_inverted);\n \n@@ -1258,6 +1249,51 @@ df_analyze (void)\n #endif\n     df_verify ();\n \n+  /* Skip over the DF_SCAN problem. */\n+  for (i = 1; i < df->num_problems_defined; i++)\n+    {\n+      struct dataflow *dflow = df->problems_in_order[i];\n+      if (dflow->solutions_dirty)\n+        {\n+          if (dflow->problem->dir == DF_FORWARD)\n+            df_analyze_problem (dflow,\n+                                df->blocks_to_analyze,\n+                                df->postorder_inverted,\n+                                df->n_blocks_inverted);\n+          else\n+            df_analyze_problem (dflow,\n+                                df->blocks_to_analyze,\n+                                df->postorder,\n+                                df->n_blocks);\n+        }\n+    }\n+\n+  if (!df->analyze_subset)\n+    {\n+      BITMAP_FREE (df->blocks_to_analyze);\n+      df->blocks_to_analyze = NULL;\n+    }\n+\n+#ifdef DF_DEBUG_CFG\n+  df_set_clean_cfg ();\n+#endif\n+}\n+\n+/* Analyze dataflow info.  */\n+\n+void\n+df_analyze (void)\n+{\n+  bitmap current_all_blocks = BITMAP_ALLOC (&df_bitmap_obstack);\n+  int i;\n+\n+  free (df->postorder);\n+  free (df->postorder_inverted);\n+  df->postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  df->postorder_inverted = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  df->n_blocks = post_order_compute (df->postorder, true, true);\n+  df->n_blocks_inverted = inverted_post_order_compute (df->postorder_inverted);\n+\n   for (i = 0; i < df->n_blocks; i++)\n     bitmap_set_bit (current_all_blocks, df->postorder[i]);\n \n@@ -1272,50 +1308,177 @@ df_analyze (void)\n      sets.  */\n   if (df->analyze_subset)\n     {\n-      everything = false;\n       bitmap_and_into (df->blocks_to_analyze, current_all_blocks);\n       df->n_blocks = df_prune_to_subcfg (df->postorder,\n \t\t\t\t\t df->n_blocks, df->blocks_to_analyze);\n       df->n_blocks_inverted = df_prune_to_subcfg (df->postorder_inverted,\n-\t\t\t                          df->n_blocks_inverted,\n-                                                  df->blocks_to_analyze);\n+\t\t\t\t\t\t  df->n_blocks_inverted,\n+\t\t\t\t\t\t  df->blocks_to_analyze);\n       BITMAP_FREE (current_all_blocks);\n     }\n   else\n     {\n-      everything = true;\n       df->blocks_to_analyze = current_all_blocks;\n       current_all_blocks = NULL;\n     }\n \n-  /* Skip over the DF_SCAN problem. */\n-  for (i = 1; i < df->num_problems_defined; i++)\n+  df_analyze_1 ();\n+}\n+\n+/* Compute the reverse top sort order of the sub-CFG specified by LOOP.\n+   Returns the number of blocks which is always loop->num_nodes.  */\n+\n+static int\n+loop_post_order_compute (int *post_order, struct loop *loop)\n+{\n+  edge_iterator *stack;\n+  int sp;\n+  int post_order_num = 0;\n+  bitmap visited;\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = XNEWVEC (edge_iterator, loop->num_nodes + 1);\n+  sp = 0;\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  visited = BITMAP_ALLOC (NULL);\n+\n+  /* Push the first edge on to the stack.  */\n+  stack[sp++] = ei_start (loop_preheader_edge (loop)->src->succs);\n+\n+  while (sp)\n     {\n-      struct dataflow *dflow = df->problems_in_order[i];\n-      if (dflow->solutions_dirty)\n-        {\n-          if (dflow->problem->dir == DF_FORWARD)\n-            df_analyze_problem (dflow,\n-                                df->blocks_to_analyze,\n-                                df->postorder_inverted,\n-                                df->n_blocks_inverted);\n-          else\n-            df_analyze_problem (dflow,\n-                                df->blocks_to_analyze,\n-                                df->postorder,\n-                                df->n_blocks);\n-        }\n+      edge_iterator ei;\n+      basic_block src;\n+      basic_block dest;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      ei = stack[sp - 1];\n+      src = ei_edge (ei)->src;\n+      dest = ei_edge (ei)->dest;\n+\n+      /* Check if the edge destination has been visited yet and mark it\n+         if not so.  */\n+      if (flow_bb_inside_loop_p (loop, dest)\n+\t  && bitmap_set_bit (visited, dest->index))\n+\t{\n+\t  if (EDGE_COUNT (dest->succs) > 0)\n+\t    /* Since the DEST node has been visited for the first\n+\t       time, check its successors.  */\n+\t    stack[sp++] = ei_start (dest->succs);\n+\t  else\n+\t    post_order[post_order_num++] = dest->index;\n+\t}\n+      else\n+\t{\n+\t  if (ei_one_before_end_p (ei)\n+\t      && src != loop_preheader_edge (loop)->src)\n+\t    post_order[post_order_num++] = src->index;\n+\n+\t  if (!ei_one_before_end_p (ei))\n+\t    ei_next (&stack[sp - 1]);\n+\t  else\n+\t    sp--;\n+\t}\n     }\n \n-  if (everything)\n+  free (stack);\n+  BITMAP_FREE (visited);\n+\n+  return post_order_num;\n+}\n+\n+/* Compute the reverse top sort order of the inverted sub-CFG specified\n+   by LOOP.  Returns the number of blocks which is always loop->num_nodes.  */\n+\n+static int\n+loop_inverted_post_order_compute (int *post_order, struct loop *loop)\n+{\n+  basic_block bb;\n+  edge_iterator *stack;\n+  int sp;\n+  int post_order_num = 0;\n+  bitmap visited;\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = XNEWVEC (edge_iterator, loop->num_nodes + 1);\n+  sp = 0;\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  visited = BITMAP_ALLOC (NULL);\n+\n+  /* Put all latches into the initial work list.  In theory we'd want\n+     to start from loop exits but then we'd have the special case of\n+     endless loops.  It doesn't really matter for DF iteration order and\n+     handling latches last is probably even better.  */\n+  stack[sp++] = ei_start (loop->header->preds);\n+  bitmap_set_bit (visited, loop->header->index);\n+\n+  /* The inverted traversal loop. */\n+  while (sp)\n     {\n-      BITMAP_FREE (df->blocks_to_analyze);\n-      df->blocks_to_analyze = NULL;\n+      edge_iterator ei;\n+      basic_block pred;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      ei = stack[sp - 1];\n+      bb = ei_edge (ei)->dest;\n+      pred = ei_edge (ei)->src;\n+\n+      /* Check if the predecessor has been visited yet and mark it\n+\t if not so.  */\n+      if (flow_bb_inside_loop_p (loop, pred)\n+\t  && bitmap_set_bit (visited, pred->index))\n+\t{\n+\t  if (EDGE_COUNT (pred->preds) > 0)\n+\t    /* Since the predecessor node has been visited for the first\n+\t       time, check its predecessors.  */\n+\t    stack[sp++] = ei_start (pred->preds);\n+\t  else\n+\t    post_order[post_order_num++] = pred->index;\n+\t}\n+      else\n+\t{\n+\t  if (flow_bb_inside_loop_p (loop, bb)\n+\t      && ei_one_before_end_p (ei))\n+\t    post_order[post_order_num++] = bb->index;\n+\n+\t  if (!ei_one_before_end_p (ei))\n+\t    ei_next (&stack[sp - 1]);\n+\t  else\n+\t    sp--;\n+\t}\n     }\n \n-#ifdef DF_DEBUG_CFG\n-  df_set_clean_cfg ();\n-#endif\n+  free (stack);\n+  BITMAP_FREE (visited);\n+  return post_order_num;\n+}\n+\n+\n+/* Analyze dataflow info for the basic blocks contained in LOOP.  */\n+\n+void\n+df_analyze_loop (struct loop *loop)\n+{\n+  free (df->postorder);\n+  free (df->postorder_inverted);\n+\n+  df->postorder = XNEWVEC (int, loop->num_nodes);\n+  df->postorder_inverted = XNEWVEC (int, loop->num_nodes);\n+  df->n_blocks = loop_post_order_compute (df->postorder, loop);\n+  df->n_blocks_inverted\n+    = loop_inverted_post_order_compute (df->postorder_inverted, loop);\n+  gcc_assert ((unsigned) df->n_blocks == loop->num_nodes);\n+  gcc_assert ((unsigned) df->n_blocks_inverted == loop->num_nodes);\n+\n+  bitmap blocks = BITMAP_ALLOC (&df_bitmap_obstack);\n+  for (int i = 0; i < df->n_blocks; ++i)\n+    bitmap_set_bit (blocks, df->postorder[i]);\n+  df_set_blocks (blocks);\n+  BITMAP_FREE (blocks);\n+\n+  df_analyze_1 ();\n }\n \n "}, {"sha": "878f507698f65dbe6bb09ca89c2c0fb7a88d8f64", "filename": "gcc/df.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=7be64667c127a0cdb9dc7e4f02dcd7720589919d", "patch": "@@ -900,7 +900,8 @@ extern void df_set_blocks (bitmap);\n extern void df_remove_problem (struct dataflow *);\n extern void df_finish_pass (bool);\n extern void df_analyze_problem (struct dataflow *, bitmap, int *, int);\n-extern void df_analyze (void);\n+extern void df_analyze ();\n+extern void df_analyze_loop (struct loop *);\n extern int df_get_n_blocks (enum df_flow_dir);\n extern int *df_get_postorder (enum df_flow_dir);\n extern void df_simple_dataflow (enum df_flow_dir, df_init_function,"}, {"sha": "100a2c1b7ff55c9e0875ddfb77d8cd91649408b3", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=7be64667c127a0cdb9dc7e4f02dcd7720589919d", "patch": "@@ -652,14 +652,8 @@ may_assign_reg_p (rtx x)\n    BODY.  */\n \n static void\n-find_defs (struct loop *loop, basic_block *body)\n+find_defs (struct loop *loop)\n {\n-  unsigned i;\n-  bitmap blocks = BITMAP_ALLOC (NULL);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    bitmap_set_bit (blocks, body[i]->index);\n-\n   if (dump_file)\n     {\n       fprintf (dump_file,\n@@ -670,9 +664,8 @@ find_defs (struct loop *loop, basic_block *body)\n   df_remove_problem (df_chain);\n   df_process_deferred_rescans ();\n   df_chain_add_problem (DF_UD_CHAIN);\n-  df_set_blocks (blocks);\n   df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n-  df_analyze ();\n+  df_analyze_loop (loop);\n   check_invariant_table_size ();\n \n   if (dump_file)\n@@ -682,8 +675,6 @@ find_defs (struct loop *loop, basic_block *body)\n \t       \"*****ending processing of loop %d ******\\n\",\n \t       loop->num);\n     }\n-\n-  BITMAP_FREE (blocks);\n }\n \n /* Creates a new invariant for definition DEF in INSN, depending on invariants\n@@ -1005,7 +996,7 @@ find_invariants (struct loop *loop)\n   compute_always_reached (loop, body, may_exit, always_reached);\n   compute_always_reached (loop, body, has_exit, always_executed);\n \n-  find_defs (loop, body);\n+  find_defs (loop);\n   find_invariants_body (loop, body, always_reached, always_executed);\n   merge_identical_invariants ();\n "}, {"sha": "9091220642ccda3ac559bec063c2d5028815a26a", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7be64667c127a0cdb9dc7e4f02dcd7720589919d/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=7be64667c127a0cdb9dc7e4f02dcd7720589919d", "patch": "@@ -278,10 +278,6 @@ clear_iv_info (void)\n void\n iv_analysis_loop_init (struct loop *loop)\n {\n-  basic_block *body = get_loop_body_in_dom_order (loop), bb;\n-  bitmap blocks = BITMAP_ALLOC (NULL);\n-  unsigned i;\n-\n   current_loop = loop;\n \n   /* Clear the information from the analysis of the previous loop.  */\n@@ -294,26 +290,18 @@ iv_analysis_loop_init (struct loop *loop)\n   else\n     clear_iv_info ();\n \n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      bb = body[i];\n-      bitmap_set_bit (blocks, bb->index);\n-    }\n   /* Get rid of the ud chains before processing the rescans.  Then add\n      the problem back.  */\n   df_remove_problem (df_chain);\n   df_process_deferred_rescans ();\n   df_set_flags (DF_RD_PRUNE_DEAD_DEFS);\n   df_chain_add_problem (DF_UD_CHAIN);\n   df_note_add_problem ();\n-  df_set_blocks (blocks);\n-  df_analyze ();\n+  df_analyze_loop (loop);\n   if (dump_file)\n     df_dump_region (dump_file);\n \n   check_iv_ref_table_size ();\n-  BITMAP_FREE (blocks);\n-  free (body);\n }\n \n /* Finds the definition of REG that dominates loop latch and stores"}]}