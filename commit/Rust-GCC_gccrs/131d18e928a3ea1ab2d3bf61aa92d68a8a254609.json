{"sha": "131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "node_id": "C_kwDOANBUbNoAKDEzMWQxOGU5MjhhM2VhMWFiMmQzYmY2MWFhOTJkNjhhOGEyNTQ2MDk", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-10-24T14:58:43Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-10-24T15:04:08Z"}, "message": "libgomp/nvptx: Prepare for reverse-offload callback handling\n\nThis patch adds a stub 'gomp_target_rev' in the host's target.c, which will\nlater handle the reverse offload.\nFor nvptx, it adds support for forwarding the offload gomp_target_ext call\nto the host by setting values in a struct on the device and querying it on\nthe host - invoking gomp_target_rev on the result.\n\ninclude/ChangeLog:\n\n\t* cuda/cuda.h (enum CUdevice_attribute): Add\n\tCU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING.\n\t(CU_MEMHOSTALLOC_DEVICEMAP): Define.\n\t(cuMemHostAlloc): Add prototype.\n\nlibgomp/ChangeLog:\n\n\t* config/nvptx/icv-device.c (GOMP_DEVICE_NUM_VAR): Remove\n\t'static' for this variable.\n\t* config/nvptx/libgomp-nvptx.h: New file.\n\t* config/nvptx/target.c: Include it.\n\t(GOMP_ADDITIONAL_ICVS): Declare extern var.\n\t(GOMP_REV_OFFLOAD_VAR): Declare var.\n\t(GOMP_target_ext): Handle reverse offload.\n\t* libgomp-plugin.h (GOMP_PLUGIN_target_rev): New prototype.\n\t* libgomp-plugin.c (GOMP_PLUGIN_target_rev): New, call ...\n\t* target.c (gomp_target_rev): ... this new stub function.\n\t* libgomp.h (gomp_target_rev): Declare.\n\t* libgomp.map (GOMP_PLUGIN_1.4): New; add GOMP_PLUGIN_target_rev.\n\t* plugin/cuda-lib.def (cuMemHostAlloc): Add.\n\t* plugin/plugin-nvptx.c: Include libgomp-nvptx.h.\n\t(struct ptx_device): Add rev_data member.\n\t(nvptx_open_device): Remove async_engines query, last used in\n\tr10-304-g1f4c5b9b; add unified-address assert check.\n\t(GOMP_OFFLOAD_get_num_devices): Claim unified address\n\tsupport.\n\t(GOMP_OFFLOAD_load_image): Free rev_fn_table if no\n\toffload functions exist. Make offload var available\n\ton host and device.\n\t(rev_off_dev_to_host_cpy, rev_off_host_to_dev_cpy): New.\n\t(GOMP_OFFLOAD_run): Handle reverse offload.", "tree": {"sha": "9c379ef9c639a56d0b1146aada7cef937328a89e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c379ef9c639a56d0b1146aada7cef937328a89e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "html_url": "https://github.com/Rust-GCC/gccrs/commit/131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a096036589d82175a0f729c2dab73c9a527d075d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a096036589d82175a0f729c2dab73c9a527d075d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a096036589d82175a0f729c2dab73c9a527d075d"}], "stats": {"total": 266, "additions": 248, "deletions": 18}, "files": [{"sha": "e081f04a6db28e88b2db92710daa977ccbe34d4c", "filename": "include/cuda/cuda.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/include%2Fcuda%2Fcuda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/include%2Fcuda%2Fcuda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fcuda%2Fcuda.h?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -77,6 +77,7 @@ typedef enum {\n   CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31,\n   CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39,\n   CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40,\n+  CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41,\n   CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82\n } CUdevice_attribute;\n \n@@ -113,6 +114,7 @@ enum {\n #define CU_LAUNCH_PARAM_END ((void *) 0)\n #define CU_LAUNCH_PARAM_BUFFER_POINTER ((void *) 1)\n #define CU_LAUNCH_PARAM_BUFFER_SIZE ((void *) 2)\n+#define CU_MEMHOSTALLOC_DEVICEMAP 0x02U\n \n enum {\n   CU_STREAM_DEFAULT = 0,\n@@ -169,6 +171,7 @@ CUresult cuMemGetInfo (size_t *, size_t *);\n CUresult cuMemAlloc (CUdeviceptr *, size_t);\n #define cuMemAllocHost cuMemAllocHost_v2\n CUresult cuMemAllocHost (void **, size_t);\n+CUresult cuMemHostAlloc (void **, size_t, unsigned int);\n CUresult cuMemcpy (CUdeviceptr, CUdeviceptr, size_t);\n #define cuMemcpyDtoDAsync cuMemcpyDtoDAsync_v2\n CUresult cuMemcpyDtoDAsync (CUdeviceptr, CUdeviceptr, size_t, CUstream);"}, {"sha": "eef151c23c7ae000592922bf3304cfbc566d3fca", "filename": "libgomp/config/nvptx/icv-device.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ficv-device.c?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -30,7 +30,7 @@\n \n /* This is set to the ICV values of current GPU during device initialization,\n    when the offload image containing this libgomp portion is loaded.  */\n-static volatile struct gomp_offload_icvs GOMP_ADDITIONAL_ICVS;\n+volatile struct gomp_offload_icvs GOMP_ADDITIONAL_ICVS;\n \n void\n omp_set_default_device (int device_num __attribute__((unused)))"}, {"sha": "5da9aae2531e674f6c0c409fecfc8d05780c0fb2", "filename": "libgomp/config/nvptx/libgomp-nvptx.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fconfig%2Fnvptx%2Flibgomp-nvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fconfig%2Fnvptx%2Flibgomp-nvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Flibgomp-nvptx.h?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -0,0 +1,51 @@\n+/* Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <tobias@codesourcery.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains defines and type definitions shared between the\n+   nvptx target's libgomp.a and the plugin-nvptx.c, but that is only\n+   needef for this target.  */\n+\n+#ifndef LIBGOMP_NVPTX_H\n+#define LIBGOMP_NVPTX_H 1\n+\n+#define GOMP_REV_OFFLOAD_VAR __gomp_rev_offload_var\n+\n+struct rev_offload {\n+  uint64_t fn;\n+  uint64_t mapnum;\n+  uint64_t addrs;\n+  uint64_t sizes;\n+  uint64_t kinds;\n+  int32_t dev_num;\n+};\n+\n+#if (__SIZEOF_SHORT__ != 2 \\\n+     || __SIZEOF_SIZE_T__ != 8 \\\n+     || __SIZEOF_POINTER__ != 8)\n+#error \"Data-type conversion required for rev_offload\"\n+#endif\n+\n+#endif  /* LIBGOMP_NVPTX_H */\n+"}, {"sha": "0e79388fbbab075813e0488d44d548447f8edf63", "filename": "libgomp/config/nvptx/target.c", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fconfig%2Fnvptx%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fconfig%2Fnvptx%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Ftarget.c?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -24,9 +24,12 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #include \"libgomp.h\"\n+#include \"libgomp-nvptx.h\"  /* For struct rev_offload + GOMP_REV_OFFLOAD_VAR. */\n #include <limits.h>\n \n extern int __gomp_team_num __attribute__((shared));\n+extern volatile struct gomp_offload_icvs GOMP_ADDITIONAL_ICVS;\n+volatile struct rev_offload *GOMP_REV_OFFLOAD_VAR;\n \n bool\n GOMP_teams4 (unsigned int num_teams_lower, unsigned int num_teams_upper,\n@@ -88,16 +91,53 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \t\t void **hostaddrs, size_t *sizes, unsigned short *kinds,\n \t\t unsigned int flags, void **depend, void **args)\n {\n-  (void) device;\n-  (void) fn;\n-  (void) mapnum;\n-  (void) hostaddrs;\n-  (void) sizes;\n-  (void) kinds;\n+  static int lock = 0;  /* == gomp_mutex_t lock; gomp_mutex_init (&lock); */\n   (void) flags;\n   (void) depend;\n   (void) args;\n-  __builtin_unreachable ();\n+\n+  if (device != GOMP_DEVICE_HOST_FALLBACK\n+      || fn == NULL\n+      || GOMP_REV_OFFLOAD_VAR == NULL)\n+    return;\n+\n+  gomp_mutex_lock (&lock);\n+\n+  GOMP_REV_OFFLOAD_VAR->mapnum = mapnum;\n+  GOMP_REV_OFFLOAD_VAR->addrs = (uint64_t) hostaddrs;\n+  GOMP_REV_OFFLOAD_VAR->sizes = (uint64_t) sizes;\n+  GOMP_REV_OFFLOAD_VAR->kinds = (uint64_t) kinds;\n+  GOMP_REV_OFFLOAD_VAR->dev_num = GOMP_ADDITIONAL_ICVS.device_num;\n+\n+  /* Set 'fn' to trigger processing on the host; wait for completion,\n+     which is flagged by setting 'fn' back to 0 on the host.  */\n+  uint64_t addr_struct_fn = (uint64_t) &GOMP_REV_OFFLOAD_VAR->fn;\n+#if __PTX_SM__ >= 700\n+  asm volatile (\"st.global.release.sys.u64 [%0], %1;\"\n+\t\t: : \"r\"(addr_struct_fn), \"r\" (fn) : \"memory\");\n+#else\n+  __sync_synchronize ();  /* membar.sys */\n+  asm volatile (\"st.volatile.global.u64 [%0], %1;\"\n+\t\t: : \"r\"(addr_struct_fn), \"r\" (fn) : \"memory\");\n+#endif\n+\n+#if __PTX_SM__ >= 700\n+  uint64_t fn2;\n+  do\n+    {\n+      asm volatile (\"ld.acquire.sys.global.u64 %0, [%1];\"\n+\t\t    : \"=r\" (fn2) : \"r\" (addr_struct_fn) : \"memory\");\n+    }\n+  while (fn2 != 0);\n+#else\n+  /* ld.global.u64 %r64,[__gomp_rev_offload_var];\n+     ld.u64 %r36,[%r64];\n+     membar.sys;  */\n+  while (__atomic_load_n (&GOMP_REV_OFFLOAD_VAR->fn, __ATOMIC_ACQUIRE) != 0)\n+    ;  /* spin  */\n+#endif\n+\n+  gomp_mutex_unlock (&lock);\n }\n \n void"}, {"sha": "316de749f696ce06cd8d7457fe6e983948f1d329", "filename": "libgomp/libgomp-plugin.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Flibgomp-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Flibgomp-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.c?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -78,3 +78,15 @@ GOMP_PLUGIN_fatal (const char *msg, ...)\n   gomp_vfatal (msg, ap);\n   va_end (ap);\n }\n+\n+void\n+GOMP_PLUGIN_target_rev (uint64_t fn_ptr, uint64_t mapnum, uint64_t devaddrs_ptr,\n+\t\t\tuint64_t sizes_ptr, uint64_t kinds_ptr, int dev_num,\n+\t\t\tvoid (*dev_to_host_cpy) (void *, const void *, size_t,\n+\t\t\t\t\t\t void *),\n+\t\t\tvoid (*host_to_dev_cpy) (void *, const void *, size_t,\n+\t\t\t\t\t\t void *), void *token)\n+{\n+  gomp_target_rev (fn_ptr, mapnum, devaddrs_ptr, sizes_ptr, kinds_ptr, dev_num,\n+\t\t   dev_to_host_cpy, host_to_dev_cpy, token);\n+}"}, {"sha": "875f9670479c84428cb82447ebb0e031e35c29ab", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -121,6 +121,13 @@ extern void GOMP_PLUGIN_error (const char *, ...)\n extern void GOMP_PLUGIN_fatal (const char *, ...)\n \t__attribute__ ((noreturn, format (printf, 1, 2)));\n \n+extern void GOMP_PLUGIN_target_rev (uint64_t, uint64_t, uint64_t, uint64_t,\n+\t\t\t\t    uint64_t, int,\n+\t\t\t\t    void (*) (void *, const void *, size_t,\n+\t\t\t\t\t      void *),\n+\t\t\t\t    void (*) (void *, const void *, size_t,\n+\t\t\t\t\t      void *), void *);\n+\n /* Prototypes for functions implemented by libgomp plugins.  */\n extern const char *GOMP_OFFLOAD_get_name (void);\n extern unsigned int GOMP_OFFLOAD_get_caps (void);"}, {"sha": "5803683afc4fe3406a5118cb7331ae4643b6cfae", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -1128,6 +1128,11 @@ extern int gomp_pause_host (void);\n extern void gomp_init_targets_once (void);\n extern int gomp_get_num_devices (void);\n extern bool gomp_target_task_fn (void *);\n+extern void gomp_target_rev (uint64_t, uint64_t, uint64_t, uint64_t, uint64_t,\n+\t\t\t     int,\n+\t\t\t     void (*) (void *, const void *, size_t, void *),\n+\t\t\t     void (*) (void *, const void *, size_t, void *),\n+\t\t\t     void *);\n \n /* Splay tree definitions.  */\n typedef struct splay_tree_node_s *splay_tree_node;"}, {"sha": "ce6b719a57fd62d416e01ef7649f0b9101623a68", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -628,3 +628,8 @@ GOMP_PLUGIN_1.3 {\n \tGOMP_PLUGIN_goacc_profiling_dispatch;\n \tGOMP_PLUGIN_goacc_thread;\n } GOMP_PLUGIN_1.2;\n+\n+GOMP_PLUGIN_1.4 {\n+  global:\n+\tGOMP_PLUGIN_target_rev;\n+} GOMP_PLUGIN_1.3;"}, {"sha": "dff42d6a9ac2954e82bd112ddff10615e185d5cf", "filename": "libgomp/plugin/cuda-lib.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fplugin%2Fcuda-lib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fplugin%2Fcuda-lib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fcuda-lib.def?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -29,6 +29,7 @@ CUDA_ONE_CALL_MAYBE_NULL (cuLinkCreate_v2)\n CUDA_ONE_CALL (cuLinkDestroy)\n CUDA_ONE_CALL (cuMemAlloc)\n CUDA_ONE_CALL (cuMemAllocHost)\n+CUDA_ONE_CALL (cuMemHostAlloc)\n CUDA_ONE_CALL (cuMemcpy)\n CUDA_ONE_CALL (cuMemcpyDtoDAsync)\n CUDA_ONE_CALL (cuMemcpyDtoH)"}, {"sha": "ad057edabece95aa1282179573efc63c555bb393", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 97, "deletions": 10, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -40,6 +40,9 @@\n #include \"gomp-constants.h\"\n #include \"oacc-int.h\"\n \n+/* For struct rev_offload + GOMP_REV_OFFLOAD_VAR. */\n+#include \"config/nvptx/libgomp-nvptx.h\"\n+\n #include <pthread.h>\n #ifndef PLUGIN_NVPTX_INCLUDE_SYSTEM_CUDA_H\n # include \"cuda/cuda.h\"\n@@ -329,6 +332,7 @@ struct ptx_device\n       pthread_mutex_t lock;\n     } omp_stacks;\n \n+  struct rev_offload *rev_data;\n   struct ptx_device *next;\n };\n \n@@ -423,7 +427,7 @@ nvptx_open_device (int n)\n   struct ptx_device *ptx_dev;\n   CUdevice dev, ctx_dev;\n   CUresult r;\n-  int async_engines, pi;\n+  int pi;\n \n   CUDA_CALL_ERET (NULL, cuDeviceGet, &dev, n);\n \n@@ -519,10 +523,12 @@ nvptx_open_device (int n)\n \t\t  CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR, dev);\n   ptx_dev->max_threads_per_multiprocessor = pi;\n \n-  r = CUDA_CALL_NOCHECK (cuDeviceGetAttribute, &async_engines,\n-\t\t\t CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT, dev);\n-  if (r != CUDA_SUCCESS)\n-    async_engines = 1;\n+  /* Required below for reverse offload as implemented, but with compute\n+     capability >= 2.0 and 64bit device processes, this should be universally be\n+     the case; hence, an assert.  */\n+  r = CUDA_CALL_NOCHECK (cuDeviceGetAttribute, &pi,\n+\t\t\t CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING, dev);\n+  assert (r == CUDA_SUCCESS && pi);\n \n   for (int i = 0; i != GOMP_DIM_MAX; i++)\n     ptx_dev->default_dims[i] = 0;\n@@ -1179,8 +1185,10 @@ GOMP_OFFLOAD_get_num_devices (unsigned int omp_requires_mask)\n {\n   int num_devices = nvptx_get_num_devices ();\n   /* Return -1 if no omp_requires_mask cannot be fulfilled but\n-     devices were present.  */\n-  if (num_devices > 0 && omp_requires_mask != 0)\n+     devices were present.  Unified-shared address: see comment in\n+     nvptx_open_device for CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING.  */\n+  if (num_devices > 0\n+      && (omp_requires_mask & ~GOMP_REQUIRES_UNIFIED_ADDRESS) != 0)\n     return -1;\n   return num_devices;\n }\n@@ -1380,7 +1388,7 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   else if (rev_fn_table)\n     {\n       CUdeviceptr var;\n-      size_t bytes;\n+      size_t bytes, i;\n       r = CUDA_CALL_NOCHECK (cuModuleGetGlobal, &var, &bytes, module,\n \t\t\t     \"$offload_func_table\");\n       if (r != CUDA_SUCCESS)\n@@ -1390,6 +1398,37 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n       r = CUDA_CALL_NOCHECK (cuMemcpyDtoH, *rev_fn_table, var, bytes);\n       if (r != CUDA_SUCCESS)\n \tGOMP_PLUGIN_fatal (\"cuMemcpyDtoH error: %s\", cuda_error (r));\n+      /* Free if only NULL entries.  */\n+      for (i = 0; i < fn_entries; ++i)\n+\tif ((*rev_fn_table)[i] != 0)\n+\t  break;\n+      if (i == fn_entries)\n+\t{\n+\t  free (*rev_fn_table);\n+\t  *rev_fn_table = NULL;\n+\t}\n+    }\n+\n+  if (rev_fn_table && *rev_fn_table && dev->rev_data == NULL)\n+    {\n+      /* cuMemHostAlloc memory is accessible on the device, if unified-shared\n+\t address is supported; this is assumed - see comment in\n+\t nvptx_open_device for CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING.   */\n+      CUDA_CALL_ASSERT (cuMemHostAlloc, (void **) &dev->rev_data,\n+\t\t\tsizeof (*dev->rev_data), CU_MEMHOSTALLOC_DEVICEMAP);\n+      CUdeviceptr dp = (CUdeviceptr) dev->rev_data;\n+      CUdeviceptr device_rev_offload_var;\n+      size_t device_rev_offload_size;\n+      CUresult r = CUDA_CALL_NOCHECK (cuModuleGetGlobal,\n+\t\t\t\t      &device_rev_offload_var,\n+\t\t\t\t      &device_rev_offload_size, module,\n+\t\t\t\t      XSTRING (GOMP_REV_OFFLOAD_VAR));\n+      if (r != CUDA_SUCCESS)\n+\tGOMP_PLUGIN_fatal (\"cuModuleGetGlobal error - GOMP_REV_OFFLOAD_VAR: %s\", cuda_error (r));\n+      r = CUDA_CALL_NOCHECK (cuMemcpyHtoD, device_rev_offload_var, &dp,\n+\t\t\t     sizeof (dp));\n+      if (r != CUDA_SUCCESS)\n+\tGOMP_PLUGIN_fatal (\"cuMemcpyHtoD error: %s\", cuda_error (r));\n     }\n \n   nvptx_set_clocktick (module, dev);\n@@ -2001,6 +2040,23 @@ nvptx_stacks_acquire (struct ptx_device *ptx_dev, size_t size, int num)\n   return (void *) ptx_dev->omp_stacks.ptr;\n }\n \n+\n+void\n+rev_off_dev_to_host_cpy (void *dest, const void *src, size_t size,\n+\t\t\t CUstream stream)\n+{\n+  CUDA_CALL_ASSERT (cuMemcpyDtoHAsync, dest, (CUdeviceptr) src, size, stream);\n+  CUDA_CALL_ASSERT (cuStreamSynchronize, stream);\n+}\n+\n+void\n+rev_off_host_to_dev_cpy (void *dest, const void *src, size_t size,\n+\t\t\t CUstream stream)\n+{\n+  CUDA_CALL_ASSERT (cuMemcpyHtoDAsync, (CUdeviceptr) dest, src, size, stream);\n+  CUDA_CALL_ASSERT (cuStreamSynchronize, stream);\n+}\n+\n void\n GOMP_OFFLOAD_run (int ord, void *tgt_fn, void *tgt_vars, void **args)\n {\n@@ -2035,6 +2091,8 @@ GOMP_OFFLOAD_run (int ord, void *tgt_fn, void *tgt_vars, void **args)\n   nvptx_adjust_launch_bounds (tgt_fn, ptx_dev, &teams, &threads);\n \n   size_t stack_size = nvptx_stacks_size ();\n+  bool reverse_offload = ptx_dev->rev_data != NULL;\n+  CUstream copy_stream = NULL;\n \n   pthread_mutex_lock (&ptx_dev->omp_stacks.lock);\n   void *stacks = nvptx_stacks_acquire (ptx_dev, stack_size, teams * threads);\n@@ -2048,12 +2106,41 @@ GOMP_OFFLOAD_run (int ord, void *tgt_fn, void *tgt_vars, void **args)\n   GOMP_PLUGIN_debug (0, \"  %s: kernel %s: launch\"\n \t\t     \" [(teams: %u), 1, 1] [(lanes: 32), (threads: %u), 1]\\n\",\n \t\t     __FUNCTION__, fn_name, teams, threads);\n+  if (reverse_offload)\n+    CUDA_CALL_ASSERT (cuStreamCreate, &copy_stream, CU_STREAM_NON_BLOCKING);\n   r = CUDA_CALL_NOCHECK (cuLaunchKernel, function, teams, 1, 1,\n \t\t\t 32, threads, 1, 0, NULL, NULL, config);\n   if (r != CUDA_SUCCESS)\n     GOMP_PLUGIN_fatal (\"cuLaunchKernel error: %s\", cuda_error (r));\n-\n-  r = CUDA_CALL_NOCHECK (cuCtxSynchronize, );\n+  if (reverse_offload)\n+    while (true)\n+      {\n+\tr = CUDA_CALL_NOCHECK (cuStreamQuery, NULL);\n+\tif (r == CUDA_SUCCESS)\n+\t  break;\n+\tif (r == CUDA_ERROR_LAUNCH_FAILED)\n+\t  GOMP_PLUGIN_fatal (\"cuStreamQuery error: %s %s\\n\", cuda_error (r),\n+\t\t\t     maybe_abort_msg);\n+\telse if (r != CUDA_ERROR_NOT_READY)\n+\t  GOMP_PLUGIN_fatal (\"cuStreamQuery error: %s\", cuda_error (r));\n+\n+\tif (__atomic_load_n (&ptx_dev->rev_data->fn, __ATOMIC_ACQUIRE) != 0)\n+\t  {\n+\t    struct rev_offload *rev_data = ptx_dev->rev_data;\n+\t    GOMP_PLUGIN_target_rev (rev_data->fn, rev_data->mapnum,\n+\t\t\t\t    rev_data->addrs, rev_data->sizes,\n+\t\t\t\t    rev_data->kinds, rev_data->dev_num,\n+\t\t\t\t    rev_off_dev_to_host_cpy,\n+\t\t\t\t    rev_off_host_to_dev_cpy, copy_stream);\n+\t    CUDA_CALL_ASSERT (cuStreamSynchronize, copy_stream);\n+\t    __atomic_store_n (&rev_data->fn, 0, __ATOMIC_RELEASE);\n+\t  }\n+\tusleep (1);\n+      }\n+  else\n+    r = CUDA_CALL_NOCHECK (cuCtxSynchronize, );\n+  if (reverse_offload)\n+    CUDA_CALL_ASSERT (cuStreamDestroy, copy_stream);\n   if (r == CUDA_ERROR_LAUNCH_FAILED)\n     GOMP_PLUGIN_fatal (\"cuCtxSynchronize error: %s %s\\n\", cuda_error (r),\n \t\t       maybe_abort_msg);"}, {"sha": "189b201e34496d19260754f25ed1f70d9d7a598b", "filename": "libgomp/target.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/131d18e928a3ea1ab2d3bf61aa92d68a8a254609/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=131d18e928a3ea1ab2d3bf61aa92d68a8a254609", "patch": "@@ -2934,6 +2934,25 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n     htab_free (refcount_set);\n }\n \n+/* Handle reverse offload.  This is called by the device plugins for a\n+   reverse offload; it is not called if the outer target runs on the host.  */\n+\n+void\n+gomp_target_rev (uint64_t fn_ptr __attribute__ ((unused)),\n+\t\t uint64_t mapnum __attribute__ ((unused)),\n+\t\t uint64_t devaddrs_ptr __attribute__ ((unused)),\n+\t\t uint64_t sizes_ptr __attribute__ ((unused)),\n+\t\t uint64_t kinds_ptr __attribute__ ((unused)),\n+\t\t int dev_num __attribute__ ((unused)),\n+\t\t void (*dev_to_host_cpy) (void *, const void *, size_t,\n+\t\t\t\t\t  void *) __attribute__ ((unused)),\n+\t\t void (*host_to_dev_cpy) (void *, const void *, size_t,\n+\t\t\t\t\t  void *) __attribute__ ((unused)),\n+\t\t void *token __attribute__ ((unused)))\n+{\n+  __builtin_unreachable ();\n+}\n+\n /* Host fallback for GOMP_target_data{,_ext} routines.  */\n \n static void"}]}