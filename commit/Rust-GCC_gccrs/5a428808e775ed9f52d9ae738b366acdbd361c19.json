{"sha": "5a428808e775ed9f52d9ae738b366acdbd361c19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE0Mjg4MDhlNzc1ZWQ5ZjUyZDlhZTczOGIzNjZhY2RiZDM2MWMxOQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-01T13:34:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-01T13:34:40Z"}, "message": "[Ada] Implement GNAT.Graphs\n\nThis patch introduces new unit GNAT.Graphs which currently provides a\ndirected graph abstraction.\n\n------------\n-- Source --\n------------\n\n--  operations.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith GNAT;        use GNAT;\nwith GNAT.Graphs; use GNAT.Graphs;\nwith GNAT.Sets;   use GNAT.Sets;\n\nprocedure Operations is\n   type Vertex_Id is\n     (No_V, VA, VB, VC, VD, VE, VF, VG, VH, VX, VY, VZ);\n   No_Vertex_Id : constant Vertex_Id := No_V;\n\n   function Hash_Vertex (V : Vertex_Id) return Bucket_Range_Type;\n\n   type Edge_Id is\n    (No_E, E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E97, E98, E99);\n   No_Edge_Id : constant Edge_Id := No_E;\n\n   function Hash_Edge (E : Edge_Id) return Bucket_Range_Type;\n\n   package ES is new Membership_Set\n     (Element_Type => Edge_Id,\n      \"=\"          => \"=\",\n      Hash         => Hash_Edge);\n\n   package DG is new Directed_Graph\n     (Vertex_Id   => Vertex_Id,\n      No_Vertex   => No_Vertex_Id,\n      Hash_Vertex => Hash_Vertex,\n      Same_Vertex => \"=\",\n      Edge_Id     => Edge_Id,\n      No_Edge     => No_Edge_Id,\n      Hash_Edge   => Hash_Edge,\n      Same_Edge   => \"=\");\n   use DG;\n\n   package VS is new Membership_Set\n     (Element_Type => Vertex_Id,\n      \"=\"          => \"=\",\n      Hash         => Hash_Vertex);\n\n   -----------------------\n   -- Local subprograms --\n   -----------------------\n\n   procedure Check_Belongs_To_Component\n     (R        : String;\n      G        : Instance;\n      V        : Vertex_Id;\n      Exp_Comp : Component_Id);\n   --  Verify that vertex V of graph G belongs to component Exp_Comp. R is the\n   --  calling routine.\n\n   procedure Check_Belongs_To_Some_Component\n     (R : String;\n      G : Instance;\n      V : Vertex_Id);\n   --  Verify that vertex V of graph G belongs to some component. R is the\n   --  calling routine.\n\n   procedure Check_Destination_Vertex\n     (R     : String;\n      G     : Instance;\n      E     : Edge_Id;\n      Exp_V : Vertex_Id);\n   --  Vertify that the destination vertex of edge E of grah G is Exp_V. R is\n   --  the calling routine.\n\n   procedure Check_Distinct_Components\n     (R      : String;\n      Comp_1 : Component_Id;\n      Comp_2 : Component_Id);\n   --  Verify that components Comp_1 and Comp_2 are distinct (not the same)\n\n   procedure Check_Has_Component\n     (R      : String;\n      G      : Instance;\n      G_Name : String;\n      Comp   : Component_Id);\n   --  Verify that graph G with name G_Name contains component Comp. R is the\n   --  calling routine.\n\n   procedure Check_Has_Edge\n     (R : String;\n      G : Instance;\n      E : Edge_Id);\n   --  Verify that graph G contains edge E. R is the calling routine.\n\n   procedure Check_Has_Vertex\n     (R : String;\n      G : Instance;\n      V : Vertex_Id);\n   --  Verify that graph G contains vertex V. R is the calling routine.\n\n   procedure Check_No_Component\n     (R : String;\n      G : Instance;\n      V : Vertex_Id);\n   --  Verify that vertex V does not belong to some component. R is the calling\n   --  routine.\n\n   procedure Check_No_Component\n     (R      : String;\n      G      : Instance;\n      G_Name : String;\n      Comp   : Component_Id);\n   --  Verify that graph G with name G_Name does not contain component Comp. R\n   --  is the calling routine.\n\n   procedure Check_No_Edge\n     (R : String;\n      G : Instance;\n      E : Edge_Id);\n   --  Verify that graph G does not contain edge E. R is the calling routine.\n\n   procedure Check_No_Vertex\n     (R : String;\n      G : Instance;\n      V : Vertex_Id);\n   --  Verify that graph G does not contain vertex V. R is the calling routine.\n\n   procedure Check_Number_Of_Components\n     (R       : String;\n      G       : Instance;\n      Exp_Num : Natural);\n   --  Verify that graph G has exactly Exp_Num components. R is the calling\n   --  routine.\n\n   procedure Check_Number_Of_Edges\n     (R       : String;\n      G       : Instance;\n      Exp_Num : Natural);\n   --  Verify that graph G has exactly Exp_Num edges. R is the calling routine.\n\n   procedure Check_Number_Of_Vertices\n     (R       : String;\n      G       : Instance;\n      Exp_Num : Natural);\n   --  Verify that graph G has exactly Exp_Num vertices. R is the calling\n   --  routine.\n\n   procedure Check_Outgoing_Edge_Iterator\n     (R   : String;\n      G   : Instance;\n      V   : Vertex_Id;\n      Set : ES.Instance);\n   --  Verify that all outgoing edges of vertex V of graph G can be iterated\n   --  and appear in set Set. R is the calling routine.\n\n   procedure Check_Source_Vertex\n     (R     : String;\n      G     : Instance;\n      E     : Edge_Id;\n      Exp_V : Vertex_Id);\n   --  Vertify that the source vertex of edge E of grah G is Exp_V. R is the\n   --  calling routine.\n\n   procedure Check_Vertex_Iterator\n     (R    : String;\n      G    : Instance;\n      Comp : Component_Id;\n      Set  : VS.Instance);\n   --  Verify that all vertices of component Comp of graph G can be iterated\n   --  and appear in set Set. R is the calling routine.\n\n   function Create_And_Populate return Instance;\n   --  Create a brand new graph (see body for the shape of the graph)\n\n   procedure Error (R : String; Msg : String);\n   --  Output an error message with text Msg within the context of routine R\n\n   procedure Test_Add_Edge;\n   --  Verify the semantics of routine Add_Edge\n\n   procedure Test_Add_Vertex;\n   --  Verify the semantics of routine Add_Vertex\n\n   procedure Test_All_Edge_Iterator;\n   --  Verify the semantics of All_Edge_Iterator\n\n   procedure Test_All_Vertex_Iterator;\n   --  Verify the semantics of All_Vertex_Iterator\n\n   procedure Test_Component;\n   --  Verify the semantics of routine Component\n\n   procedure Test_Component_Iterator;\n   --  Verify the semantics of Component_Iterator\n\n   procedure Test_Contains_Component;\n   --  Verify the semantics of routine Contains_Component\n\n   procedure Test_Contains_Edge;\n   --  Verify the semantics of routine Contains_Edge\n\n   procedure Test_Contains_Vertex;\n   --  Verify the semantics of routine Contains_Vertex\n\n   procedure Test_Delete_Edge;\n   --  Verify the semantics of routine Delete_Edge\n\n   procedure Test_Destination_Vertex;\n   --  Verify the semantics of routine Destination_Vertex\n\n   procedure Test_Find_Components;\n   --  Verify the semantics of routine Find_Components\n\n   procedure Test_Is_Empty;\n   --  Verify the semantics of routine Is_Empty\n\n   procedure Test_Number_Of_Components;\n   --  Verify the semantics of routine Number_Of_Components\n\n   procedure Test_Number_Of_Edges;\n   --  Verify the semantics of routine Number_Of_Edges\n\n   procedure Test_Number_Of_Vertices;\n   --  Verify the semantics of routine Number_Of_Vertices\n\n   procedure Test_Outgoing_Edge_Iterator;\n   --  Verify the semantics of Outgoing_Edge_Iterator\n\n   procedure Test_Present;\n   --  Verify the semantics of routine Present\n\n   procedure Test_Source_Vertex;\n   --  Verify the semantics of routine Source_Vertex\n\n   procedure Test_Vertex_Iterator;\n   --  Verify the semantics of Vertex_Iterator;\n\n   procedure Unexpected_Exception (R : String);\n   --  Output an error message concerning an unexpected exception within\n   --  routine R.\n\n   --------------------------------\n   -- Check_Belongs_To_Component --\n   --------------------------------\n\n   procedure Check_Belongs_To_Component\n     (R        : String;\n      G        : Instance;\n      V        : Vertex_Id;\n      Exp_Comp : Component_Id)\n   is\n      Act_Comp : constant Component_Id := Component (G, V);\n\n   begin\n      if Act_Comp /= Exp_Comp then\n         Error (R, \"inconsistent component for vertex \" & V'Img);\n         Error (R, \"  expected: \" & Exp_Comp'Img);\n         Error (R, \"  got     : \" & Act_Comp'Img);\n      end if;\n   end Check_Belongs_To_Component;\n\n   -------------------------------------\n   -- Check_Belongs_To_Some_Component --\n   -------------------------------------\n\n   procedure Check_Belongs_To_Some_Component\n     (R : String;\n      G : Instance;\n      V : Vertex_Id)\n   is\n   begin\n      if not Present (Component (G, V)) then\n         Error (R, \"vertex \" & V'Img & \" does not belong to a component\");\n      end if;\n   end Check_Belongs_To_Some_Component;\n\n   ------------------------------\n   -- Check_Destination_Vertex --\n   ------------------------------\n\n   procedure Check_Destination_Vertex\n     (R     : String;\n      G     : Instance;\n      E     : Edge_Id;\n      Exp_V : Vertex_Id)\n   is\n      Act_V : constant Vertex_Id := Destination_Vertex (G, E);\n\n   begin\n      if Act_V /= Exp_V then\n         Error (R, \"inconsistent destination vertex for edge \" & E'Img);\n         Error (R, \"  expected: \" & Exp_V'Img);\n         Error (R, \"  got     : \" & Act_V'Img);\n      end if;\n   end Check_Destination_Vertex;\n\n   -------------------------------\n   -- Check_Distinct_Components --\n   -------------------------------\n\n   procedure Check_Distinct_Components\n     (R      : String;\n      Comp_1 : Component_Id;\n      Comp_2 : Component_Id)\n   is\n   begin\n      if Comp_1 = Comp_2 then\n         Error (R, \"components are not distinct\");\n      end if;\n   end Check_Distinct_Components;\n\n   -------------------------\n   -- Check_Has_Component --\n   -------------------------\n\n   procedure Check_Has_Component\n     (R      : String;\n      G      : Instance;\n      G_Name : String;\n      Comp   : Component_Id)\n   is\n   begin\n      if not Contains_Component (G, Comp) then\n         Error (R, \"graph \" & G_Name & \" lacks component\");\n      end if;\n   end Check_Has_Component;\n\n   --------------------\n   -- Check_Has_Edge --\n   --------------------\n\n   procedure Check_Has_Edge\n     (R : String;\n      G : Instance;\n      E : Edge_Id)\n   is\n   begin\n      if not Contains_Edge (G, E) then\n         Error (R, \"graph lacks edge \" & E'Img);\n      end if;\n   end Check_Has_Edge;\n\n   ----------------------\n   -- Check_Has_Vertex --\n   ----------------------\n\n   procedure Check_Has_Vertex\n     (R : String;\n      G : Instance;\n      V : Vertex_Id)\n   is\n   begin\n      if not Contains_Vertex (G, V) then\n         Error (R, \"graph lacks vertex \" & V'Img);\n      end if;\n   end Check_Has_Vertex;\n\n   ------------------------\n   -- Check_No_Component --\n   ------------------------\n\n   procedure Check_No_Component\n     (R : String;\n      G : Instance;\n      V : Vertex_Id)\n   is\n   begin\n      if Present (Component (G, V)) then\n         Error (R, \"vertex \" & V'Img & \" belongs to a component\");\n      end if;\n   end Check_No_Component;\n\n   procedure Check_No_Component\n     (R      : String;\n      G      : Instance;\n      G_Name : String;\n      Comp   : Component_Id)\n   is\n   begin\n      if Contains_Component (G, Comp) then\n         Error (R, \"graph \" & G_Name & \" contains component\");\n      end if;\n   end Check_No_Component;\n\n   -------------------\n   -- Check_No_Edge --\n   -------------------\n\n   procedure Check_No_Edge\n     (R : String;\n      G : Instance;\n      E : Edge_Id)\n   is\n   begin\n      if Contains_Edge (G, E) then\n         Error (R, \"graph contains edge \" & E'Img);\n      end if;\n   end Check_No_Edge;\n\n   ---------------------\n   -- Check_No_Vertex --\n   ---------------------\n\n   procedure Check_No_Vertex\n     (R : String;\n      G : Instance;\n      V : Vertex_Id)\n   is\n   begin\n      if Contains_Vertex (G, V) then\n         Error (R, \"graph contains vertex \" & V'Img);\n      end if;\n   end Check_No_Vertex;\n\n   --------------------------------\n   -- Check_Number_Of_Components --\n   --------------------------------\n\n   procedure Check_Number_Of_Components\n     (R       : String;\n      G       : Instance;\n      Exp_Num : Natural)\n   is\n      Act_Num : constant Natural := Number_Of_Components (G);\n\n   begin\n      if Act_Num /= Exp_Num then\n         Error (R, \"inconsistent number of components\");\n         Error (R, \"  expected: \" & Exp_Num'Img);\n         Error (R, \"  got     : \" & Act_Num'Img);\n      end if;\n   end Check_Number_Of_Components;\n\n   ---------------------------\n   -- Check_Number_Of_Edges --\n   ---------------------------\n\n   procedure Check_Number_Of_Edges\n     (R       : String;\n      G       : Instance;\n      Exp_Num : Natural)\n   is\n      Act_Num : constant Natural := Number_Of_Edges (G);\n\n   begin\n      if Act_Num /= Exp_Num then\n         Error (R, \"inconsistent number of edges\");\n         Error (R, \"  expected: \" & Exp_Num'Img);\n         Error (R, \"  got     : \" & Act_Num'Img);\n      end if;\n   end Check_Number_Of_Edges;\n\n   ------------------------------\n   -- Check_Number_Of_Vertices --\n   ------------------------------\n\n   procedure Check_Number_Of_Vertices\n     (R       : String;\n      G       : Instance;\n      Exp_Num : Natural)\n   is\n      Act_Num : constant Natural := Number_Of_Vertices (G);\n\n   begin\n      if Act_Num /= Exp_Num then\n         Error (R, \"inconsistent number of vertices\");\n         Error (R, \"  expected: \" & Exp_Num'Img);\n         Error (R, \"  got     : \" & Act_Num'Img);\n      end if;\n   end Check_Number_Of_Vertices;\n\n   ----------------------------------\n   -- Check_Outgoing_Edge_Iterator --\n   ----------------------------------\n\n   procedure Check_Outgoing_Edge_Iterator\n     (R   : String;\n      G   : Instance;\n      V   : Vertex_Id;\n      Set : ES.Instance)\n   is\n      E : Edge_Id;\n\n      Out_E_Iter : Outgoing_Edge_Iterator;\n\n   begin\n      --  Iterate over all outgoing edges of vertex V while removing edges seen\n      --  from the set.\n\n      Out_E_Iter := Iterate_Outgoing_Edges (G, V);\n      while Has_Next (Out_E_Iter) loop\n         Next (Out_E_Iter, E);\n\n         if ES.Contains (Set, E) then\n            ES.Delete (Set, E);\n         else\n            Error (R, \"outgoing edge \" & E'Img & \" is not iterated\");\n         end if;\n      end loop;\n\n      --  At this point the set of edges should be empty\n\n      if not ES.Is_Empty (Set) then\n         Error (R, \"not all outgoing edges were iterated\");\n      end if;\n   end Check_Outgoing_Edge_Iterator;\n\n   -------------------------\n   -- Check_Source_Vertex --\n   -------------------------\n\n   procedure Check_Source_Vertex\n     (R     : String;\n      G     : Instance;\n      E     : Edge_Id;\n      Exp_V : Vertex_Id)\n   is\n      Act_V : constant Vertex_Id := Source_Vertex (G, E);\n\n   begin\n      if Act_V /= Exp_V then\n         Error (R, \"inconsistent source vertex\");\n         Error (R, \"  expected: \" & Exp_V'Img);\n         Error (R, \"  got     : \" & Act_V'Img);\n      end if;\n   end Check_Source_Vertex;\n\n   ---------------------------\n   -- Check_Vertex_Iterator --\n   ---------------------------\n\n   procedure Check_Vertex_Iterator\n     (R    : String;\n      G    : Instance;\n      Comp : Component_Id;\n      Set  : VS.Instance)\n   is\n      V : Vertex_Id;\n\n      V_Iter : Vertex_Iterator;\n\n   begin\n      --  Iterate over all vertices of component Comp while removing vertices\n      --  seen from the set.\n\n      V_Iter := Iterate_Vertices (G, Comp);\n      while Has_Next (V_Iter) loop\n         Next (V_Iter, V);\n\n         if VS.Contains (Set, V) then\n            VS.Delete (Set, V);\n         else\n            Error (R, \"vertex \" & V'Img & \" is not iterated\");\n         end if;\n      end loop;\n\n      --  At this point the set of vertices should be empty\n\n      if not VS.Is_Empty (Set) then\n         Error (R, \"not all vertices were iterated\");\n      end if;\n   end Check_Vertex_Iterator;\n\n   -------------------------\n   -- Create_And_Populate --\n   -------------------------\n\n   function Create_And_Populate return Instance is\n      G : constant Instance :=\n            Create (Initial_Vertices => Vertex_Id'Size,\n                    Initial_Edges    => Edge_Id'Size);\n\n   begin\n      --       9         8           1        2\n      --  G <------ F <------  A  ------> B -------> C\n      --  |                  ^ | |        ^          ^\n      --  +------------------+ | +-------------------+\n      --       10              |          |   3\n      --                    4  |        5 |\n      --                       v          |\n      --            H          D ---------+\n      --                      | ^\n      --                      | |\n      --                    6 | | 7\n      --                      | |\n      --                      v |\n      --                       E\n      --\n      --  Components:\n      --\n      --    [A, F, G]\n      --    [B]\n      --    [C]\n      --    [D, E]\n      --    [H]\n\n      Add_Vertex (G, VA);\n      Add_Vertex (G, VB);\n      Add_Vertex (G, VC);\n      Add_Vertex (G, VD);\n      Add_Vertex (G, VE);\n      Add_Vertex (G, VF);\n      Add_Vertex (G, VG);\n      Add_Vertex (G, VH);\n\n      Add_Edge (G, E1,  Source => VA, Destination => VB);\n      Add_Edge (G, E2,  Source => VB, Destination => VC);\n      Add_Edge (G, E3,  Source => VA, Destination => VC);\n      Add_Edge (G, E4,  Source => VA, Destination => VD);\n      Add_Edge (G, E5,  Source => VD, Destination => VB);\n      Add_Edge (G, E6,  Source => VD, Destination => VE);\n      Add_Edge (G, E7,  Source => VE, Destination => VD);\n      Add_Edge (G, E8,  Source => VA, Destination => VF);\n      Add_Edge (G, E9,  Source => VF, Destination => VG);\n      Add_Edge (G, E10, Source => VG, Destination => VA);\n\n      return G;\n   end Create_And_Populate;\n\n   -----------\n   -- Error --\n   -----------\n\n   procedure Error (R : String; Msg : String) is\n   begin\n      Put_Line (\"ERROR: \" & R & \": \" & Msg);\n   end Error;\n\n   ---------------\n   -- Hash_Edge --\n   ---------------\n\n   function Hash_Edge (E : Edge_Id) return Bucket_Range_Type is\n   begin\n      return Bucket_Range_Type (Edge_Id'Pos (E));\n   end Hash_Edge;\n\n   -----------------\n   -- Hash_Vertex --\n   -----------------\n\n   function Hash_Vertex (V : Vertex_Id) return Bucket_Range_Type is\n   begin\n      return Bucket_Range_Type (Vertex_Id'Pos (V));\n   end Hash_Vertex;\n\n   -------------------\n   -- Test_Add_Edge --\n   -------------------\n\n   procedure Test_Add_Edge is\n      R : constant String := \"Test_Add_Edge\";\n\n      E : Edge_Id;\n      G : Instance := Create_And_Populate;\n\n      All_E_Iter : All_Edge_Iterator;\n      Out_E_Iter : Outgoing_Edge_Iterator;\n\n   begin\n      --  Try to add the same edge twice\n\n      begin\n         Add_Edge (G, E1, VB, VH);\n         Error (R, \"duplicate edge not detected\");\n      exception\n         when Duplicate_Edge => null;\n         when others         => Unexpected_Exception (R);\n      end;\n\n      --  Try to add an edge with a bogus source\n\n      begin\n         Add_Edge (G, E97, Source => VX, Destination => VC);\n         Error (R, \"missing vertex not detected\");\n      exception\n         when Missing_Vertex => null;\n         when others         => Unexpected_Exception (R);\n      end;\n\n      --  Try to add an edge with a bogus destination\n\n      begin\n         Add_Edge (G, E97, Source => VF, Destination => VY);\n         Error (R, \"missing vertex not detected\");\n      exception\n         when Missing_Vertex => null;\n         when others         => Unexpected_Exception (R);\n      end;\n\n      --  Delete edge E1 between vertices VA and VB\n\n      begin\n         Delete_Edge (G, E1);\n      exception\n         when others => Unexpected_Exception (R);\n      end;\n\n      --  Try to re-add edge E1\n\n      begin\n         Add_Edge (G, E1, Source => VA, Destination => VB);\n      exception\n         when others => Unexpected_Exception (R);\n      end;\n\n      --  Lock all edges in the graph\n\n      All_E_Iter := Iterate_All_Edges (G);\n\n      --  Try to add an edge given that all edges are locked\n\n      begin\n         Add_Edge (G, E97, Source => VG, Destination => VH);\n         Error (R, \"all edges not locked\");\n      exception\n         when Iterated => null;\n         when others   => Unexpected_Exception (R);\n      end;\n\n      --  Unlock all edges by iterating over them\n\n      while Has_Next (All_E_Iter) loop Next (All_E_Iter, E); end loop;\n\n      --  Lock all outgoing edges of vertex VD\n\n      Out_E_Iter := Iterate_Outgoing_Edges (G, VD);\n\n      --  Try to add an edge with source VD given that all edges of VD are\n      --  locked.\n\n      begin\n         Add_Edge (G, E97, Source => VD, Destination => VG);\n         Error (R, \"outgoing edges of VD not locked\");\n      exception\n         when Iterated => null;\n         when others   => Unexpected_Exception (R);\n      end;\n\n      --  Unlock the edges of vertex VD by iterating over them\n\n      while Has_Next (Out_E_Iter) loop Next (Out_E_Iter, E); end loop;\n\n      Destroy (G);\n   end Test_Add_Edge;\n\n   ---------------------\n   -- Test_Add_Vertex --\n   ---------------------\n\n   procedure Test_Add_Vertex is\n      R : constant String := \"Test_Add_Vertex\";\n\n      G : Instance := Create_And_Populate;\n      V : Vertex_Id;\n\n      All_V_Iter : All_Vertex_Iterator;\n\n   begin\n      --  Try to add the same vertex twice\n\n      begin\n         Add_Vertex (G, VD);\n         Error (R, \"duplicate vertex not detected\");\n      exception\n         when Duplicate_Vertex => null;\n         when others           => Unexpected_Exception (R);\n      end;\n\n      --  Lock all vertices in the graph\n\n      All_V_Iter := Iterate_All_Vertices (G);\n\n      --  Try to add a vertex given that all vertices are locked\n\n      begin\n         Add_Vertex (G, VZ);\n         Error (R, \"all vertices not locked\");\n      exception\n         when Iterated => null;\n         when others   => Unexpected_Exception (R);\n      end;\n\n      --  Unlock all vertices by iterating over them\n\n      while Has_Next (All_V_Iter) loop Next (All_V_Iter, V); end loop;\n\n      Destroy (G);\n   end Test_Add_Vertex;\n\n   ----------------------------\n   -- Test_All_Edge_Iterator --\n   ----------------------------\n\n   procedure Test_All_Edge_Iterator is\n      R : constant String := \"Test_All_Edge_Iterator\";\n\n      E : Edge_Id;\n      G : Instance := Create_And_Populate;\n\n      All_E_Iter : All_Edge_Iterator;\n      All_Edges  : ES.Instance;\n\n   begin\n      --  Collect all expected edges in a set\n\n      All_Edges := ES.Create (Number_Of_Edges (G));\n\n      for Curr_E in E1 .. E10 loop\n         ES.Insert (All_Edges, Curr_E);\n      end loop;\n\n      --  Iterate over all edges while removing encountered edges from the set\n\n      All_E_Iter := Iterate_All_Edges (G);\n      while Has_Next (All_E_Iter) loop\n         Next (All_E_Iter, E);\n\n         if ES.Contains (All_Edges, E) then\n            ES.Delete (All_Edges, E);\n         else\n            Error (R, \"edge \" & E'Img & \" is not iterated\");\n         end if;\n      end loop;\n\n      --  At this point the set of edges should be empty\n\n      if not ES.Is_Empty (All_Edges) then\n         Error (R, \"not all edges were iterated\");\n      end if;\n\n      ES.Destroy (All_Edges);\n      Destroy (G);\n   end Test_All_Edge_Iterator;\n\n   ------------------------------\n   -- Test_All_Vertex_Iterator --\n   ------------------------------\n\n   procedure Test_All_Vertex_Iterator is\n      R : constant String := \"Test_All_Vertex_Iterator\";\n\n      G : Instance := Create_And_Populate;\n      V : Vertex_Id;\n\n      All_V_Iter   : All_Vertex_Iterator;\n      All_Vertices : VS.Instance;\n\n   begin\n      --  Collect all expected vertices in a set\n\n      All_Vertices := VS.Create (Number_Of_Vertices (G));\n\n      for Curr_V in VA .. VH loop\n         VS.Insert (All_Vertices, Curr_V);\n      end loop;\n\n      --  Iterate over all vertices while removing encountered vertices from\n      --  the set.\n\n      All_V_Iter := Iterate_All_Vertices (G);\n      while Has_Next (All_V_Iter) loop\n         Next (All_V_Iter, V);\n\n         if VS.Contains (All_Vertices, V) then\n            VS.Delete (All_Vertices, V);\n         else\n            Error (R, \"vertex \" & V'Img & \" is not iterated\");\n         end if;\n      end loop;\n\n      --  At this point the set of vertices should be empty\n\n      if not VS.Is_Empty (All_Vertices) then\n         Error (R, \"not all vertices were iterated\");\n      end if;\n\n      VS.Destroy (All_Vertices);\n      Destroy (G);\n   end Test_All_Vertex_Iterator;\n\n   --------------------\n   -- Test_Component --\n   --------------------\n\n   procedure Test_Component is\n      R : constant String := \"Test_Component\";\n\n      G : Instance := Create (Initial_Vertices => 3, Initial_Edges => 2);\n\n   begin\n      --      E1\n      --    ----->\n      --  VA       VB     VC\n      --    <-----\n      --      E2\n      --\n      --  Components:\n      --\n      --    [VA, VB]\n      --    [VC]\n\n      Add_Vertex (G, VA);\n      Add_Vertex (G, VB);\n      Add_Vertex (G, VC);\n\n      Add_Edge (G, E1, Source => VA, Destination => VB);\n      Add_Edge (G, E2, Source => VB, Destination => VA);\n\n      --  None of the vertices should belong to a component\n\n      Check_No_Component (R, G, VA);\n      Check_No_Component (R, G, VB);\n      Check_No_Component (R, G, VC);\n\n      --  Find the strongly connected components in the graph\n\n      Find_Components (G);\n\n      --  Vertices should belong to a component\n\n      Check_Belongs_To_Some_Component (R, G, VA);\n      Check_Belongs_To_Some_Component (R, G, VB);\n      Check_Belongs_To_Some_Component (R, G, VC);\n\n      Destroy (G);\n   end Test_Component;\n\n   -----------------------------\n   -- Test_Component_Iterator --\n   -----------------------------\n\n   procedure Test_Component_Iterator is\n      R : constant String := \"Test_Component_Iterator\";\n\n      G : Instance := Create_And_Populate;\n\n      Comp       : Component_Id;\n      Comp_Count : Natural;\n      Comp_Iter  : Component_Iterator;\n\n   begin\n      Find_Components (G);\n      Check_Number_Of_Components (R, G, 5);\n\n      Comp_Count := Number_Of_Components (G);\n\n      --  Iterate over all components while decrementing their number\n\n      Comp_Iter := Iterate_Components (G);\n      while Has_Next (Comp_Iter) loop\n         Next (Comp_Iter, Comp);\n\n         Comp_Count := Comp_Count - 1;\n      end loop;\n\n      --  At this point all components should have been accounted for\n\n      if Comp_Count /= 0 then\n         Error (R, \"not all components were iterated\");\n      end if;\n\n      Destroy (G);\n   end Test_Component_Iterator;\n\n   -----------------------------\n   -- Test_Contains_Component --\n   -----------------------------\n\n   procedure Test_Contains_Component is\n      R : constant String := \"Test_Contains_Component\";\n\n      G1 : Instance := Create (Initial_Vertices => 2, Initial_Edges => 2);\n      G2 : Instance := Create (Initial_Vertices => 2, Initial_Edges => 2);\n\n   begin\n      --      E1\n      --    ----->\n      --  VA       VB\n      --    <-----\n      --      E2\n      --\n      --  Components:\n      --\n      --    [VA, VB]\n\n      Add_Vertex (G1, VA);\n      Add_Vertex (G1, VB);\n\n      Add_Edge (G1, E1, Source => VA, Destination => VB);\n      Add_Edge (G1, E2, Source => VB, Destination => VA);\n\n      --      E97\n      --    ----->\n      --  VX       VY\n      --    <-----\n      --      E98\n      --\n      --  Components:\n      --\n      --    [VX, VY]\n\n      Add_Vertex (G2, VX);\n      Add_Vertex (G2, VY);\n\n      Add_Edge (G2, E97, Source => VX, Destination => VY);\n      Add_Edge (G2, E98, Source => VY, Destination => VX);\n\n      --  Find the strongly connected components in both graphs\n\n      Find_Components (G1);\n      Find_Components (G2);\n\n      --  Vertices should belong to a component\n\n      Check_Belongs_To_Some_Component (R, G1, VA);\n      Check_Belongs_To_Some_Component (R, G1, VB);\n      Check_Belongs_To_Some_Component (R, G2, VX);\n      Check_Belongs_To_Some_Component (R, G2, VY);\n\n      --  Verify that each graph contains the correct component\n\n      Check_Has_Component (R, G1, \"G1\", Component (G1, VA));\n      Check_Has_Component (R, G1, \"G1\", Component (G1, VB));\n      Check_Has_Component (R, G2, \"G2\", Component (G2, VX));\n      Check_Has_Component (R, G2, \"G2\", Component (G2, VY));\n\n      --  Verify that each graph does not contain components from the other\n      --  graph.\n\n      Check_No_Component (R, G1, \"G1\", Component (G2, VX));\n      Check_No_Component (R, G1, \"G1\", Component (G2, VY));\n      Check_No_Component (R, G2, \"G2\", Component (G1, VA));\n      Check_No_Component (R, G2, \"G2\", Component (G1, VB));\n\n      Destroy (G1);\n      Destroy (G2);\n   end Test_Contains_Component;\n\n   ------------------------\n   -- Test_Contains_Edge --\n   ------------------------\n\n   procedure Test_Contains_Edge is\n      R : constant String := \"Test_Contains_Edge\";\n\n      G : Instance := Create_And_Populate;\n\n   begin\n      --  Verify that all edges in the range E1 .. E10 exist\n\n      for Curr_E in E1 .. E10 loop\n         Check_Has_Edge (R, G, Curr_E);\n      end loop;\n\n      --  Verify that no extra edges are present\n\n      for Curr_E in E97 .. E99 loop\n         Check_No_Edge (R, G, Curr_E);\n      end loop;\n\n      --  Add new edges E97, E98, and E99\n\n      Add_Edge (G, E97, Source => VG, Destination => VF);\n      Add_Edge (G, E98, Source => VH, Destination => VE);\n      Add_Edge (G, E99, Source => VD, Destination => VC);\n\n      --  Verify that all edges in the range E1 .. E99 exist\n\n      for Curr_E in E1 .. E99 loop\n         Check_Has_Edge (R, G, Curr_E);\n      end loop;\n\n      --  Delete each edge that corresponds to an even position in Edge_Id\n\n      for Curr_E in E1 .. E99 loop\n         if Edge_Id'Pos (Curr_E) mod 2 = 0 then\n            Delete_Edge (G, Curr_E);\n         end if;\n      end loop;\n\n      --  Verify that all \"even\" edges are missing, and all \"odd\" edges are\n      --  present.\n\n      for Curr_E in E1 .. E99 loop\n         if Edge_Id'Pos (Curr_E) mod 2 = 0 then\n            Check_No_Edge (R, G, Curr_E);\n         else\n            Check_Has_Edge (R, G, Curr_E);\n         end if;\n      end loop;\n\n      Destroy (G);\n   end Test_Contains_Edge;\n\n   --------------------------\n   -- Test_Contains_Vertex --\n   --------------------------\n\n   procedure Test_Contains_Vertex is\n      R : constant String := \"Test_Contains_Vertex\";\n\n      G : Instance := Create_And_Populate;\n\n   begin\n      --  Verify that all vertices in the range VA .. VH exist\n\n      for Curr_V in VA .. VH loop\n         Check_Has_Vertex (R, G, Curr_V);\n      end loop;\n\n      --  Verify that no extra vertices are present\n\n      for Curr_V in VX .. VZ loop\n         Check_No_Vertex (R, G, Curr_V);\n      end loop;\n\n      --  Add new vertices VX, VY, and VZ\n\n      Add_Vertex (G, VX);\n      Add_Vertex (G, VY);\n      Add_Vertex (G, VZ);\n\n      --  Verify that all vertices in the range VA .. VZ exist\n\n      for Curr_V in VA .. VZ loop\n         Check_Has_Vertex (R, G, Curr_V);\n      end loop;\n\n      Destroy (G);\n   end Test_Contains_Vertex;\n\n   ----------------------\n   -- Test_Delete_Edge --\n   ----------------------\n\n   procedure Test_Delete_Edge is\n      R : constant String := \"Test_Delete_Edge\";\n\n      E : Edge_Id;\n      G : Instance := Create_And_Populate;\n      V : Vertex_Id;\n\n      All_E_Iter : All_Edge_Iterator;\n      All_V_Iter : All_Vertex_Iterator;\n      Out_E_Iter : Outgoing_Edge_Iterator;\n\n   begin\n      --  Try to delete a bogus edge\n\n      begin\n         Delete_Edge (G, E97);\n         Error (R, \"missing vertex deleted\");\n      exception\n         when Missing_Edge => null;\n         when others       => Unexpected_Exception (R);\n      end;\n\n      --  Delete edge E1 between vertices VA and VB\n\n      begin\n         Delete_Edge (G, E1);\n      exception\n         when others => Unexpected_Exception (R);\n      end;\n\n      --  Verify that edge E1 is gone from all edges in the graph\n\n      All_E_Iter := Iterate_All_Edges (G);\n      while Has_Next (All_E_Iter) loop\n         Next (All_E_Iter, E);\n\n         if E = E1 then\n            Error (R, \"edge \" & E'Img & \" not removed from all edges\");\n         end if;\n      end loop;\n\n      --  Verify that edge E1 is gone from the outgoing edges of vertex VA\n\n      Out_E_Iter := Iterate_Outgoing_Edges (G, VA);\n      while Has_Next (Out_E_Iter) loop\n         Next (Out_E_Iter, E);\n\n         if E = E1 then\n            Error\n              (R, \"edge \" & E'Img & \"not removed from outgoing edges of VA\");\n         end if;\n      end loop;\n\n      --  Delete all edges in the range E2 .. E10\n\n      for Curr_E in E2 .. E10 loop\n         Delete_Edge (G, Curr_E);\n      end loop;\n\n      --  Verify that all edges are gone from the graph\n\n      All_E_Iter := Iterate_All_Edges (G);\n      while Has_Next (All_E_Iter) loop\n         Next (All_E_Iter, E);\n\n         Error (R, \"edge \" & E'Img & \" not removed from all edges\");\n      end loop;\n\n      --  Verify that all edges are gone from the respective source vertices\n\n      All_V_Iter := Iterate_All_Vertices (G);\n      while Has_Next (All_V_Iter) loop\n         Next (All_V_Iter, V);\n\n         Out_E_Iter := Iterate_Outgoing_Edges (G, V);\n         while Has_Next (Out_E_Iter) loop\n            Next (Out_E_Iter, E);\n\n            Error (R, \"edge \" & E'Img & \" not removed from vertex \" & V'Img);\n         end loop;\n      end loop;\n\n      Destroy (G);\n   end Test_Delete_Edge;\n\n   -----------------------------\n   -- Test_Destination_Vertex --\n   -----------------------------\n\n   procedure Test_Destination_Vertex is\n      R : constant String := \"Test_Destination_Vertex\";\n\n      G : Instance := Create_And_Populate;\n\n   begin\n      --  Verify the destination vertices of all edges in the graph\n\n      Check_Destination_Vertex (R, G, E1,  VB);\n      Check_Destination_Vertex (R, G, E2,  VC);\n      Check_Destination_Vertex (R, G, E3,  VC);\n      Check_Destination_Vertex (R, G, E4,  VD);\n      Check_Destination_Vertex (R, G, E5,  VB);\n      Check_Destination_Vertex (R, G, E6,  VE);\n      Check_Destination_Vertex (R, G, E7,  VD);\n      Check_Destination_Vertex (R, G, E8,  VF);\n      Check_Destination_Vertex (R, G, E9,  VG);\n      Check_Destination_Vertex (R, G, E10, VA);\n\n      Destroy (G);\n   end Test_Destination_Vertex;\n\n   --------------------------\n   -- Test_Find_Components --\n   --------------------------\n\n   procedure Test_Find_Components is\n      R : constant String := \"Test_Find_Components\";\n\n      G : Instance := Create_And_Populate;\n\n      Comp_1 : Component_Id;  --  [A, F, G]\n      Comp_2 : Component_Id;  --  [B]\n      Comp_3 : Component_Id;  --  [C]\n      Comp_4 : Component_Id;  --  [D, E]\n      Comp_5 : Component_Id;  --  [H]\n\n   begin\n      Find_Components (G);\n\n      --  Vertices should belong to a component\n\n      Check_Belongs_To_Some_Component (R, G, VA);\n      Check_Belongs_To_Some_Component (R, G, VB);\n      Check_Belongs_To_Some_Component (R, G, VC);\n      Check_Belongs_To_Some_Component (R, G, VD);\n      Check_Belongs_To_Some_Component (R, G, VH);\n\n      --  Extract the ids of the components from the first vertices in each\n      --  component.\n\n      Comp_1 := Component (G, VA);\n      Comp_2 := Component (G, VB);\n      Comp_3 := Component (G, VC);\n      Comp_4 := Component (G, VD);\n      Comp_5 := Component (G, VH);\n\n      --  Verify that the components are distinct\n\n      Check_Distinct_Components (R, Comp_1, Comp_2);\n      Check_Distinct_Components (R, Comp_1, Comp_3);\n      Check_Distinct_Components (R, Comp_1, Comp_4);\n      Check_Distinct_Components (R, Comp_1, Comp_5);\n\n      Check_Distinct_Components (R, Comp_2, Comp_3);\n      Check_Distinct_Components (R, Comp_2, Comp_4);\n      Check_Distinct_Components (R, Comp_2, Comp_5);\n\n      Check_Distinct_Components (R, Comp_3, Comp_4);\n      Check_Distinct_Components (R, Comp_3, Comp_5);\n\n      Check_Distinct_Components (R, Comp_4, Comp_5);\n\n      --  Verify that the remaining nodes belong to the proper component\n\n      Check_Belongs_To_Component (R, G, VF, Comp_1);\n      Check_Belongs_To_Component (R, G, VG, Comp_1);\n      Check_Belongs_To_Component (R, G, VE, Comp_4);\n\n      Destroy (G);\n   end Test_Find_Components;\n\n   -------------------\n   -- Test_Is_Empty --\n   -------------------\n\n   procedure Test_Is_Empty is\n      R : constant String := \"Test_Is_Empty\";\n\n      G : Instance := Create (Initial_Vertices => 3, Initial_Edges => 2);\n\n   begin\n      --  Verify that a graph without vertices and edges is empty\n\n      if not Is_Empty (G) then\n         Error (R, \"graph is empty\");\n      end if;\n\n      --  Add vertices\n\n      Add_Vertex (G, VA);\n      Add_Vertex (G, VB);\n\n      --  Verify that a graph with vertices and no edges is not empty\n\n      if Is_Empty (G) then\n         Error (R, \"graph is not empty\");\n      end if;\n\n      --  Add edges\n\n      Add_Edge (G, E1, Source => VA, Destination => VB);\n\n      --  Verify that a graph with vertices and edges is not empty\n\n      if Is_Empty (G) then\n         Error (R, \"graph is not empty\");\n      end if;\n\n      Destroy (G);\n   end Test_Is_Empty;\n\n   -------------------------------\n   -- Test_Number_Of_Components --\n   -------------------------------\n\n   procedure Test_Number_Of_Components is\n      R : constant String := \"Test_Number_Of_Components\";\n\n      G : Instance := Create (Initial_Vertices => 3, Initial_Edges => 2);\n\n   begin\n      --  Verify that an empty graph has exactly 0 components\n\n      Check_Number_Of_Components (R, G, 0);\n\n      --      E1\n      --    ----->\n      --  VA       VB     VC\n      --    <-----\n      --      E2\n      --\n      --  Components:\n      --\n      --    [VA, VB]\n      --    [VC]\n\n      Add_Vertex (G, VA);\n      Add_Vertex (G, VB);\n      Add_Vertex (G, VC);\n\n      Add_Edge (G, E1, Source => VA, Destination => VB);\n      Add_Edge (G, E2, Source => VB, Destination => VA);\n\n      --  Verify that the graph has exact 0 components even though it contains\n      --  vertices and edges.\n\n      Check_Number_Of_Components (R, G, 0);\n\n      Find_Components (G);\n\n      --  Verify that the graph has exactly 2 components\n\n      Check_Number_Of_Components (R, G, 2);\n\n      Destroy (G);\n   end Test_Number_Of_Components;\n\n   --------------------------\n   -- Test_Number_Of_Edges --\n   --------------------------\n\n   procedure Test_Number_Of_Edges is\n      R : constant String := \"Test_Number_Of_Edges\";\n\n      G : Instance := Create_And_Populate;\n\n   begin\n      --  Verify that the graph has exactly 10 edges\n\n      Check_Number_Of_Edges (R, G, 10);\n\n      --  Delete two edges\n\n      Delete_Edge (G, E1);\n      Delete_Edge (G, E2);\n\n      --  Verify that the graph has exactly 8 edges\n\n      Check_Number_Of_Edges (R, G, 8);\n\n      --  Delete the remaining edge\n\n      for Curr_E in E3 .. E10 loop\n         Delete_Edge (G, Curr_E);\n      end loop;\n\n      --  Verify that the graph has exactly 0 edges\n\n      Check_Number_Of_Edges (R, G, 0);\n\n      --  Add two edges\n\n      Add_Edge (G, E1, Source => VF, Destination => VA);\n      Add_Edge (G, E2, Source => VC, Destination => VH);\n\n      --  Verify that the graph has exactly 2 edges\n\n      Check_Number_Of_Edges (R, G, 2);\n\n      Destroy (G);\n   end Test_Number_Of_Edges;\n\n   -----------------------------\n   -- Test_Number_Of_Vertices --\n   -----------------------------\n\n   procedure Test_Number_Of_Vertices is\n      R : constant String := \"Test_Number_Of_Vertices\";\n\n      G : Instance := Create (Initial_Vertices => 4, Initial_Edges => 12);\n\n   begin\n      --  Verify that an empty graph has exactly 0 vertices\n\n      Check_Number_Of_Vertices (R, G, 0);\n\n      --  Add three vertices\n\n      Add_Vertex (G, VC);\n      Add_Vertex (G, VG);\n      Add_Vertex (G, VX);\n\n      --  Verify that the graph has exactly 3 vertices\n\n      Check_Number_Of_Vertices (R, G, 3);\n\n      --  Add one edge\n\n      Add_Edge (G, E8, Source => VX, Destination => VG);\n\n      --  Verify that the graph has exactly 3 vertices\n\n      Check_Number_Of_Vertices (R, G, 3);\n\n      Destroy (G);\n   end Test_Number_Of_Vertices;\n\n   ---------------------------------\n   -- Test_Outgoing_Edge_Iterator --\n   ---------------------------------\n\n   procedure Test_Outgoing_Edge_Iterator is\n      R : constant String := \"Test_Outgoing_Edge_Iterator\";\n\n      G   : Instance := Create_And_Populate;\n      Set : ES.Instance;\n\n   begin\n      Set := ES.Create (4);\n\n      ES.Insert (Set, E1);\n      ES.Insert (Set, E3);\n      ES.Insert (Set, E4);\n      ES.Insert (Set, E8);\n      Check_Outgoing_Edge_Iterator (R, G, VA, Set);\n\n      ES.Insert (Set, E2);\n      Check_Outgoing_Edge_Iterator (R, G, VB, Set);\n\n      Check_Outgoing_Edge_Iterator (R, G, VC, Set);\n\n      ES.Insert (Set, E5);\n      ES.Insert (Set, E6);\n      Check_Outgoing_Edge_Iterator (R, G, VD, Set);\n\n      ES.Insert (Set, E7);\n      Check_Outgoing_Edge_Iterator (R, G, VE, Set);\n\n      ES.Insert (Set, E9);\n      Check_Outgoing_Edge_Iterator (R, G, VF, Set);\n\n      ES.Insert (Set, E10);\n      Check_Outgoing_Edge_Iterator (R, G, VG, Set);\n\n      Check_Outgoing_Edge_Iterator (R, G, VH, Set);\n\n      ES.Destroy (Set);\n      Destroy (G);\n   end Test_Outgoing_Edge_Iterator;\n\n   ------------------\n   -- Test_Present --\n   ------------------\n\n   procedure Test_Present is\n      R : constant String := \"Test_Present\";\n\n      G : Instance := Nil;\n\n   begin\n      --  Verify that a non-existent graph is not present\n\n      if Present (G) then\n         Error (R, \"graph is not present\");\n      end if;\n\n      G := Create_And_Populate;\n\n      --  Verify that an existing graph is present\n\n      if not Present (G) then\n         Error (R, \"graph is present\");\n      end if;\n\n      Destroy (G);\n\n      --  Verify that a destroyed graph is not present\n\n      if Present (G) then\n         Error (R, \"graph is not present\");\n      end if;\n   end Test_Present;\n\n   ------------------------\n   -- Test_Source_Vertex --\n   ------------------------\n\n   procedure Test_Source_Vertex is\n      R : constant String := \"Test_Source_Vertex\";\n\n      G : Instance := Create_And_Populate;\n\n   begin\n      --  Verify the source vertices of all edges in the graph\n\n      Check_Source_Vertex (R, G, E1,  VA);\n      Check_Source_Vertex (R, G, E2,  VB);\n      Check_Source_Vertex (R, G, E3,  VA);\n      Check_Source_Vertex (R, G, E4,  VA);\n      Check_Source_Vertex (R, G, E5,  VD);\n      Check_Source_Vertex (R, G, E6,  VD);\n      Check_Source_Vertex (R, G, E7,  VE);\n      Check_Source_Vertex (R, G, E8,  VA);\n      Check_Source_Vertex (R, G, E9,  VF);\n      Check_Source_Vertex (R, G, E10, VG);\n\n      Destroy (G);\n   end Test_Source_Vertex;\n\n   --------------------------\n   -- Test_Vertex_Iterator --\n   --------------------------\n\n   procedure Test_Vertex_Iterator is\n      R : constant String := \"Test_Vertex_Iterator\";\n\n      G   : Instance := Create_And_Populate;\n      Set : VS.Instance;\n\n   begin\n      Find_Components (G);\n\n      Set := VS.Create (3);\n\n      VS.Insert (Set, VA);\n      VS.Insert (Set, VF);\n      VS.Insert (Set, VG);\n      Check_Vertex_Iterator (R, G, Component (G, VA), Set);\n\n      VS.Insert (Set, VB);\n      Check_Vertex_Iterator (R, G, Component (G, VB), Set);\n\n      VS.Insert (Set, VC);\n      Check_Vertex_Iterator (R, G, Component (G, VC), Set);\n\n      VS.Insert (Set, VD);\n      VS.Insert (Set, VE);\n      Check_Vertex_Iterator (R, G, Component (G, VD), Set);\n\n      VS.Insert (Set, VH);\n      Check_Vertex_Iterator (R, G, Component (G, VH), Set);\n\n      VS.Destroy (Set);\n      Destroy (G);\n   end Test_Vertex_Iterator;\n\n   --------------------------\n   -- Unexpected_Exception --\n   --------------------------\n\n   procedure Unexpected_Exception (R : String) is\n   begin\n      Error (R, \"unexpected exception\");\n   end Unexpected_Exception;\n\n--  Start of processing for Operations\n\nbegin\n   Test_Add_Edge;\n   Test_Add_Vertex;\n   Test_All_Edge_Iterator;\n   Test_All_Vertex_Iterator;\n   Test_Component;\n   Test_Component_Iterator;\n   Test_Contains_Component;\n   Test_Contains_Edge;\n   Test_Contains_Vertex;\n   Test_Delete_Edge;\n   Test_Destination_Vertex;\n   Test_Find_Components;\n   Test_Is_Empty;\n   Test_Number_Of_Components;\n   Test_Number_Of_Edges;\n   Test_Number_Of_Vertices;\n   Test_Outgoing_Edge_Iterator;\n   Test_Present;\n   Test_Source_Vertex;\n   Test_Vertex_Iterator;\n\nend Operations;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q operations.adb -largs -lgmem\n$ ./operations\n$ gnatmem operations > leaks.txt\n$ grep -c \"non freed allocations\" leaks.txt\n0\n\n2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* impunit.adb: Add GNAT.Graphs to list Non_Imp_File_Names_95.\n\t* Makefile.rtl, gcc-interface/Make-lang.in: Register unit\n\tGNAT.Graphs.\n\t* libgnat/g-dynhta.adb: Various minor cleanups (use Present\n\trather than direct comparisons).\n\t(Delete): Reimplement to use Delete_Node.\n\t(Delete_Node): New routine.\n\t(Destroy_Bucket): Invoke the provided destructor.\n\t(Present): New routines.\n\t* libgnat/g-dynhta.ads: Add new generic formal Destroy_Value.\n\tUse better names for the components of iterators.\n\t* libgnat/g-graphs.adb, libgnat/g-graphs.ads: New unit.\n\t* libgnat/g-lists.adb: Various minor cleanups (use Present\n\trather than direct comparisons).\n\t(Delete_Node): Invoke the provided destructor.\n\t(Present): New routine.\n\t* libgnat/g-lists.ads: Add new generic formal Destroy_Element.\n\tUse better names for the components of iterators.\n\t(Present): New routine.\n\t* libgnat/g-sets.adb, libgnat/g-sets.ads (Destroy, Preset,\n\tReset): New routines.\n\nFrom-SVN: r272857", "tree": {"sha": "4515e15e148c69b7c611e4bc92607be829955126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4515e15e148c69b7c611e4bc92607be829955126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a428808e775ed9f52d9ae738b366acdbd361c19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a428808e775ed9f52d9ae738b366acdbd361c19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a428808e775ed9f52d9ae738b366acdbd361c19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a428808e775ed9f52d9ae738b366acdbd361c19/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c46e926fa592e2df23d260791cde72162bfc10c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c46e926fa592e2df23d260791cde72162bfc10c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c46e926fa592e2df23d260791cde72162bfc10c"}], "stats": {"total": 2371, "additions": 2258, "deletions": 113}, "files": [{"sha": "31fecb6c1d32de420ed7ca0f9de4953ac4915abd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -1,3 +1,27 @@\n+2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* impunit.adb: Add GNAT.Graphs to list Non_Imp_File_Names_95.\n+\t* Makefile.rtl, gcc-interface/Make-lang.in: Register unit\n+\tGNAT.Graphs.\n+\t* libgnat/g-dynhta.adb: Various minor cleanups (use Present\n+\trather than direct comparisons).\n+\t(Delete): Reimplement to use Delete_Node.\n+\t(Delete_Node): New routine.\n+\t(Destroy_Bucket): Invoke the provided destructor.\n+\t(Present): New routines.\n+\t* libgnat/g-dynhta.ads: Add new generic formal Destroy_Value.\n+\tUse better names for the components of iterators.\n+\t* libgnat/g-graphs.adb, libgnat/g-graphs.ads: New unit.\n+\t* libgnat/g-lists.adb: Various minor cleanups (use Present\n+\trather than direct comparisons).\n+\t(Delete_Node): Invoke the provided destructor.\n+\t(Present): New routine.\n+\t* libgnat/g-lists.ads: Add new generic formal Destroy_Element.\n+\tUse better names for the components of iterators.\n+\t(Present): New routine.\n+\t* libgnat/g-sets.adb, libgnat/g-sets.ads (Destroy, Preset,\n+\tReset): New routines.\n+\n 2019-07-01  Dmitriy Anisimkov  <anisimko@adacore.com>\n \n \t* libgnat/g-sothco.adb (Get_Address): Fix the case when AF_INET6"}, {"sha": "916ae3ead0c1d6525397670b0d12b716bd66cfc3", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -421,6 +421,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-exptty$(objext) \\\n   g-flocon$(objext) \\\n   g-forstr$(objext) \\\n+  g-graphs$(objext) \\\n   g-heasor$(objext) \\\n   g-hesora$(objext) \\\n   g-hesorg$(objext) \\"}, {"sha": "104b214a8798d60526723a743720584aac4f4603", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -317,6 +317,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/frontend.o\t\\\n  ada/libgnat/g-byorma.o\t\\\n  ada/libgnat/g-dynhta.o\t\\\n+ ada/libgnat/g-graphs.o \\\n  ada/libgnat/g-hesora.o\t\\\n  ada/libgnat/g-htable.o\t\\\n  ada/libgnat/g-lists.o \\"}, {"sha": "80857b36096c5e10d1dfdc44e4922813578d8e7a", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -275,6 +275,7 @@ package body Impunit is\n     (\"g-exptty\", F),  -- GNAT.Expect.TTY\n     (\"g-flocon\", F),  -- GNAT.Float_Control\n     (\"g-forstr\", F),  -- GNAT.Formatted_String\n+    (\"g-graphs\", F),  -- GNAT.Graphs\n     (\"g-heasor\", F),  -- GNAT.Heap_Sort\n     (\"g-hesora\", F),  -- GNAT.Heap_Sort_A\n     (\"g-hesorg\", F),  -- GNAT.Heap_Sort_G"}, {"sha": "31b77de11eb9ce30ce4e4932f40df9f902d3c9ce", "filename": "gcc/ada/libgnat/g-dynhta.adb", "status": "modified", "additions": 128, "deletions": 71, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -382,6 +382,10 @@ package body GNAT.Dynamic_HTables is\n       --  Maximum safe size for hash table expansion. Beyond this size, an\n       --  expansion will overflow the buckets.\n \n+      procedure Delete_Node (T : Instance; Nod : Node_Ptr);\n+      pragma Inline (Delete_Node);\n+      --  Detach and delete node Nod from table T\n+\n       procedure Destroy_Buckets (Bkts : Bucket_Table_Ptr);\n       pragma Inline (Destroy_Buckets);\n       --  Destroy all nodes within buckets Bkts\n@@ -464,6 +468,14 @@ package body GNAT.Dynamic_HTables is\n       pragma Inline (Prepend);\n       --  Insert node Nod immediately after dummy head Head\n \n+      function Present (Bkts : Bucket_Table_Ptr) return Boolean;\n+      pragma Inline (Present);\n+      --  Determine whether buckets Bkts exist\n+\n+      function Present (Nod : Node_Ptr) return Boolean;\n+      pragma Inline (Present);\n+      --  Determine whether node Nod exists\n+\n       procedure Unlock (T : Instance);\n       pragma Inline (Unlock);\n       --  Unlock all mutation functionality of hash table T\n@@ -492,6 +504,34 @@ package body GNAT.Dynamic_HTables is\n       ------------\n \n       procedure Delete (T : Instance; Key : Key_Type) is\n+         Head : Node_Ptr;\n+         Nod  : Node_Ptr;\n+\n+      begin\n+         Ensure_Created  (T);\n+         Ensure_Unlocked (T);\n+\n+         --  Obtain the dummy head of the bucket which should house the\n+         --  key-value pair.\n+\n+         Head := Find_Bucket (T.Buckets, Key);\n+\n+         --  Try to find a node in the bucket which matches the key\n+\n+         Nod := Find_Node (Head, Key);\n+\n+         --  If such a node exists, remove it from the bucket and deallocate it\n+\n+         if Is_Valid (Nod, Head) then\n+            Delete_Node (T, Nod);\n+         end if;\n+      end Delete;\n+\n+      -----------------\n+      -- Delete_Node --\n+      -----------------\n+\n+      procedure Delete_Node (T : Instance; Nod : Node_Ptr) is\n          procedure Compress;\n          pragma Inline (Compress);\n          --  Determine whether hash table T requires compression, and if so,\n@@ -502,8 +542,8 @@ package body GNAT.Dynamic_HTables is\n          --------------\n \n          procedure Compress is\n-            pragma Assert (T /= null);\n-            pragma Assert (T.Buckets /= null);\n+            pragma Assert (Present (T));\n+            pragma Assert (Present (T.Buckets));\n \n             Old_Size : constant Bucket_Range_Type := T.Buckets'Length;\n \n@@ -520,41 +560,27 @@ package body GNAT.Dynamic_HTables is\n \n          --  Local variables\n \n-         Head : Node_Ptr;\n-         Nod  : Node_Ptr;\n+         Ref : Node_Ptr := Nod;\n \n-      --  Start of processing for Delete\n+      --  Start of processing for Delete_Node\n \n       begin\n-         Ensure_Created  (T);\n-         Ensure_Unlocked (T);\n+         pragma Assert (Present (Ref));\n+         pragma Assert (Present (T));\n \n-         --  Obtain the dummy head of the bucket which should house the\n-         --  key-value pair.\n-\n-         Head := Find_Bucket (T.Buckets, Key);\n-\n-         --  Try to find a node in the bucket which matches the key\n-\n-         Nod := Find_Node (Head, Key);\n+         Detach (Ref);\n+         Free   (Ref);\n \n-         --  If such a node exists, remove it from the bucket and deallocate it\n-\n-         if Is_Valid (Nod, Head) then\n-            Detach (Nod);\n-            Free   (Nod);\n-\n-            --  The number of key-value pairs is updated when the hash table\n-            --  contains a valid node which represents the pair.\n+         --  The number of key-value pairs is updated when the hash table\n+         --  contains a valid node which represents the pair.\n \n-            T.Pairs := T.Pairs - 1;\n+         T.Pairs := T.Pairs - 1;\n \n-            --  Compress the hash table if the load factor drops below\n-            --  Compression_Threshold.\n+         --  Compress the hash table if the load factor drops below the value\n+         --  of Compression_Threshold.\n \n-            Compress;\n-         end if;\n-      end Delete;\n+         Compress;\n+      end Delete_Node;\n \n       -------------\n       -- Destroy --\n@@ -594,6 +620,10 @@ package body GNAT.Dynamic_HTables is\n             while Is_Valid (Head.Next, Head) loop\n                Nod := Head.Next;\n \n+               --  Invoke the value destructor before deallocating the node\n+\n+               Destroy_Value (Nod.Value);\n+\n                Detach (Nod);\n                Free   (Nod);\n             end loop;\n@@ -602,7 +632,7 @@ package body GNAT.Dynamic_HTables is\n       --  Start of processing for Destroy_Buckets\n \n       begin\n-         pragma Assert (Bkts /= null);\n+         pragma Assert (Present (Bkts));\n \n          for Scan_Idx in Bkts'Range loop\n             Destroy_Bucket (Bkts (Scan_Idx)'Access);\n@@ -614,17 +644,17 @@ package body GNAT.Dynamic_HTables is\n       ------------\n \n       procedure Detach (Nod : Node_Ptr) is\n-         pragma Assert (Nod /= null);\n+         pragma Assert (Present (Nod));\n \n          Next : constant Node_Ptr := Nod.Next;\n          Prev : constant Node_Ptr := Nod.Prev;\n \n       begin\n-         pragma Assert (Next /= null);\n-         pragma Assert (Prev /= null);\n+         pragma Assert (Present (Next));\n+         pragma Assert (Present (Prev));\n \n-         Prev.Next := Next;\n-         Next.Prev := Prev;\n+         Prev.Next := Next;  --  Prev ---> Next\n+         Next.Prev := Prev;  --  Prev <--> Next\n \n          Nod.Next := null;\n          Nod.Prev := null;\n@@ -635,10 +665,10 @@ package body GNAT.Dynamic_HTables is\n       ---------------------\n \n       procedure Ensure_Circular (Head : Node_Ptr) is\n-         pragma Assert (Head /= null);\n+         pragma Assert (Present (Head));\n \n       begin\n-         if Head.Next = null and then Head.Prev = null then\n+         if not Present (Head.Next) and then not Present (Head.Prev) then\n             Head.Next := Head;\n             Head.Prev := Head;\n          end if;\n@@ -650,7 +680,7 @@ package body GNAT.Dynamic_HTables is\n \n       procedure Ensure_Created (T : Instance) is\n       begin\n-         if T = null then\n+         if not Present (T) then\n             raise Not_Created;\n          end if;\n       end Ensure_Created;\n@@ -661,7 +691,7 @@ package body GNAT.Dynamic_HTables is\n \n       procedure Ensure_Unlocked (T : Instance) is\n       begin\n-         pragma Assert (T /= null);\n+         pragma Assert (Present (T));\n \n          --  The hash table has at least one outstanding iterator\n \n@@ -678,7 +708,7 @@ package body GNAT.Dynamic_HTables is\n         (Bkts : Bucket_Table_Ptr;\n          Key  : Key_Type) return Node_Ptr\n       is\n-         pragma Assert (Bkts /= null);\n+         pragma Assert (Present (Bkts));\n \n          Idx : constant Bucket_Range_Type := Hash (Key) mod Bkts'Length;\n \n@@ -691,7 +721,7 @@ package body GNAT.Dynamic_HTables is\n       ---------------\n \n       function Find_Node (Head : Node_Ptr; Key : Key_Type) return Node_Ptr is\n-         pragma Assert (Head /= null);\n+         pragma Assert (Present (Head));\n \n          Nod : Node_Ptr;\n \n@@ -725,8 +755,8 @@ package body GNAT.Dynamic_HTables is\n          Head : Node_Ptr;\n \n       begin\n-         pragma Assert (T /= null);\n-         pragma Assert (T.Buckets /= null);\n+         pragma Assert (Present (T));\n+         pragma Assert (Present (T.Buckets));\n \n          --  Assume that no valid node exists\n \n@@ -788,7 +818,7 @@ package body GNAT.Dynamic_HTables is\n          T     : constant Instance := Iter.Table;\n \n       begin\n-         pragma Assert (T /= null);\n+         pragma Assert (Present (T));\n \n          --  The iterator is no longer valid which indicates that it has been\n          --  exhausted. Unlock all mutation functionality of the hash table\n@@ -821,7 +851,7 @@ package body GNAT.Dynamic_HTables is\n          --  The invariant of Iterate and Next ensures that the iterator always\n          --  refers to a valid node if there exists one.\n \n-         return Iter.Nod /= null;\n+         return Present (Iter.Curr_Nod);\n       end Is_Valid;\n \n       --------------\n@@ -833,7 +863,7 @@ package body GNAT.Dynamic_HTables is\n          --  A node is valid if it is non-null, and does not refer to the dummy\n          --  head of some bucket.\n \n-         return Nod /= null and then Nod /= Head;\n+         return Present (Nod) and then Nod /= Head;\n       end Is_Valid;\n \n       -------------\n@@ -845,7 +875,7 @@ package body GNAT.Dynamic_HTables is\n \n       begin\n          Ensure_Created (T);\n-         pragma Assert (T.Buckets /= null);\n+         pragma Assert (Present (T.Buckets));\n \n          --  Initialize the iterator to reference the first valid node in\n          --  the full range of hash table buckets. If no such node exists,\n@@ -856,8 +886,8 @@ package body GNAT.Dynamic_HTables is\n            (T        => T,\n             Low_Bkt  => T.Buckets'First,\n             High_Bkt => T.Buckets'Last,\n-            Idx      => Iter.Idx,\n-            Nod      => Iter.Nod);\n+            Idx      => Iter.Curr_Idx,\n+            Nod      => Iter.Curr_Nod);\n \n          --  Associate the iterator with the hash table to allow for future\n          --  mutation functionality unlocking.\n@@ -877,8 +907,8 @@ package body GNAT.Dynamic_HTables is\n       -----------------\n \n       function Load_Factor (T : Instance) return Threshold_Type is\n-         pragma Assert (T /= null);\n-         pragma Assert (T.Buckets /= null);\n+         pragma Assert (Present (T));\n+         pragma Assert (Present (T.Buckets));\n \n       begin\n          --  The load factor is the ratio of key-value pairs to buckets\n@@ -922,8 +952,8 @@ package body GNAT.Dynamic_HTables is\n \n          procedure Rehash (From : Bucket_Table_Ptr; To : Bucket_Table_Ptr) is\n          begin\n-            pragma Assert (From /= null);\n-            pragma Assert (To /= null);\n+            pragma Assert (Present (From));\n+            pragma Assert (Present (To));\n \n             for Scan_Idx in From'Range loop\n                Rehash_Bucket (From (Scan_Idx)'Access, To);\n@@ -935,7 +965,7 @@ package body GNAT.Dynamic_HTables is\n          -------------------\n \n          procedure Rehash_Bucket (Head : Node_Ptr; To : Bucket_Table_Ptr) is\n-            pragma Assert (Head /= null);\n+            pragma Assert (Present (Head));\n \n             Nod : Node_Ptr;\n \n@@ -955,7 +985,7 @@ package body GNAT.Dynamic_HTables is\n          -----------------\n \n          procedure Rehash_Node (Nod : Node_Ptr; To : Bucket_Table_Ptr) is\n-            pragma Assert (Nod /= null);\n+            pragma Assert (Present (Nod));\n \n             Head : Node_Ptr;\n \n@@ -982,7 +1012,7 @@ package body GNAT.Dynamic_HTables is\n       --  Start of processing for Mutate_And_Rehash\n \n       begin\n-         pragma Assert (T /= null);\n+         pragma Assert (Present (T));\n \n          Old_Bkts  := T.Buckets;\n          T.Buckets := new Bucket_Table (0 .. Size - 1);\n@@ -1000,13 +1030,13 @@ package body GNAT.Dynamic_HTables is\n \n       procedure Next (Iter : in out Iterator; Key : out Key_Type) is\n          Is_OK : constant Boolean  := Is_Valid (Iter);\n-         Saved : constant Node_Ptr := Iter.Nod;\n+         Saved : constant Node_Ptr := Iter.Curr_Nod;\n          T     : constant Instance := Iter.Table;\n          Head  : Node_Ptr;\n \n       begin\n-         pragma Assert (T /= null);\n-         pragma Assert (T.Buckets /= null);\n+         pragma Assert (Present (T));\n+         pragma Assert (Present (T.Buckets));\n \n          --  The iterator is no longer valid which indicates that it has been\n          --  exhausted. Unlock all mutation functionality of the hash table as\n@@ -1019,21 +1049,21 @@ package body GNAT.Dynamic_HTables is\n \n          --  Advance to the next node along the same bucket\n \n-         Iter.Nod := Iter.Nod.Next;\n-         Head     := T.Buckets (Iter.Idx)'Access;\n+         Iter.Curr_Nod := Iter.Curr_Nod.Next;\n+         Head := T.Buckets (Iter.Curr_Idx)'Access;\n \n          --  If the new node is no longer valid, then this indicates that the\n          --  current bucket has been exhausted. Advance to the next valid node\n          --  within the remaining range of buckets. If no such node exists, the\n          --  iterator is left in a state which does not allow it to advance.\n \n-         if not Is_Valid (Iter.Nod, Head) then\n+         if not Is_Valid (Iter.Curr_Nod, Head) then\n             First_Valid_Node\n-              (T      => T,\n-               Low_Bkt  => Iter.Idx + 1,\n+              (T        => T,\n+               Low_Bkt  => Iter.Curr_Idx + 1,\n                High_Bkt => T.Buckets'Last,\n-               Idx      => Iter.Idx,\n-               Nod      => Iter.Nod);\n+               Idx      => Iter.Curr_Idx,\n+               Nod      => Iter.Curr_Nod);\n          end if;\n \n          Key := Saved.Key;\n@@ -1044,8 +1074,8 @@ package body GNAT.Dynamic_HTables is\n       -------------\n \n       procedure Prepend (Nod : Node_Ptr; Head : Node_Ptr) is\n-         pragma Assert (Nod /= null);\n-         pragma Assert (Head /= null);\n+         pragma Assert (Present (Nod));\n+         pragma Assert (Present (Head));\n \n          Next : constant Node_Ptr := Head.Next;\n \n@@ -1057,6 +1087,33 @@ package body GNAT.Dynamic_HTables is\n          Nod.Prev := Head;\n       end Prepend;\n \n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (Bkts : Bucket_Table_Ptr) return Boolean is\n+      begin\n+         return Bkts /= null;\n+      end Present;\n+\n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (Nod : Node_Ptr) return Boolean is\n+      begin\n+         return Nod /= null;\n+      end Present;\n+\n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (T : Instance) return Boolean is\n+      begin\n+         return T /= Nil;\n+      end Present;\n+\n       ---------\n       -- Put --\n       ---------\n@@ -1078,8 +1135,8 @@ package body GNAT.Dynamic_HTables is\n          ------------\n \n          procedure Expand is\n-            pragma Assert (T /= null);\n-            pragma Assert (T.Buckets /= null);\n+            pragma Assert (Present (T));\n+            pragma Assert (Present (T.Buckets));\n \n             Old_Size : constant Bucket_Range_Type := T.Buckets'Length;\n \n@@ -1099,7 +1156,7 @@ package body GNAT.Dynamic_HTables is\n          ------------------------\n \n          procedure Prepend_Or_Replace (Head : Node_Ptr) is\n-            pragma Assert (Head /= null);\n+            pragma Assert (Present (Head));\n \n             Nod : Node_Ptr;\n "}, {"sha": "7b8d1d840875a2dd80e73e831f78552203cd5e29", "filename": "gcc/ada/libgnat/g-dynhta.ads", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -265,9 +265,9 @@ package GNAT.Dynamic_HTables is\n    --  The following package offers a hash table abstraction with the following\n    --  characteristics:\n    --\n-   --    * Dynamic resizing based on load factor.\n-   --    * Creation of multiple instances, of different sizes.\n-   --    * Iterable keys.\n+   --    * Dynamic resizing based on load factor\n+   --    * Creation of multiple instances, of different sizes\n+   --    * Iterable keys\n    --\n    --  This type of hash table is best used in scenarios where the size of the\n    --  key set is not known. The dynamic resizing aspect allows for performance\n@@ -327,6 +327,9 @@ package GNAT.Dynamic_HTables is\n              (Left  : Key_Type;\n               Right : Key_Type) return Boolean;\n \n+      with procedure Destroy_Value (Val : in out Value_Type);\n+      --  Value destructor\n+\n       with function Hash (Key : Key_Type) return Bucket_Range_Type;\n       --  Map an arbitrary key into the range of buckets\n \n@@ -366,6 +369,9 @@ package GNAT.Dynamic_HTables is\n       function Is_Empty (T : Instance) return Boolean;\n       --  Determine whether hash table T is empty\n \n+      function Present (T : Instance) return Boolean;\n+      --  Determine whether hash table T exists\n+\n       procedure Put (T : Instance; Key : Key_Type; Value : Value_Type);\n       --  Associate value Value with key Key in hash table T. If the table\n       --  already contains a mapping of the same key to a previous value, the\n@@ -401,15 +407,15 @@ package GNAT.Dynamic_HTables is\n \n       type Iterator is private;\n \n-      function Iterate (T : Instance) return Iterator;\n-      --  Obtain an iterator over the keys of hash table T. This action locks\n-      --  all mutation functionality of the associated hash table.\n-\n       function Has_Next (Iter : Iterator) return Boolean;\n       --  Determine whether iterator Iter has more keys to examine. If the\n       --  iterator has been exhausted, restore all mutation functionality of\n       --  the associated hash table.\n \n+      function Iterate (T : Instance) return Iterator;\n+      --  Obtain an iterator over the keys of hash table T. This action locks\n+      --  all mutation functionality of the associated hash table.\n+\n       procedure Next (Iter : in out Iterator; Key : out Key_Type);\n       --  Return the current key referenced by iterator Iter and advance to\n       --  the next available key. If the iterator has been exhausted and\n@@ -475,11 +481,11 @@ package GNAT.Dynamic_HTables is\n       --  The following type represents a key iterator\n \n       type Iterator is record\n-         Idx : Bucket_Range_Type := 0;\n+         Curr_Idx : Bucket_Range_Type := 0;\n          --  Index of the current bucket being examined. This index is always\n          --  kept within the range of the buckets.\n \n-         Nod : Node_Ptr := null;\n+         Curr_Nod : Node_Ptr := null;\n          --  Reference to the current node being examined within the current\n          --  bucket. The invariant of the iterator requires that this field\n          --  always point to a valid node. A value of null indicates that the"}, {"sha": "a763efb2a81d69b012f91e7109eb13f8bda0b29f", "filename": "gcc/ada/libgnat/g-graphs.adb", "status": "added", "additions": 1453, "deletions": 0, "changes": 1453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-graphs.adb?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -0,0 +1,1453 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                           G N A T . G R A P H S                          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2018-2019, Free Software Foundation, Inc.      --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Deallocation;\n+\n+package body GNAT.Graphs is\n+\n+   -----------------------\n+   -- Local subprograms --\n+   -----------------------\n+\n+   function Sequence_Next_Component return Component_Id;\n+   --  Produce the next handle for a component. The handle is guaranteed to be\n+   --  unique across all graphs.\n+\n+   --------------------\n+   -- Directed_Graph --\n+   --------------------\n+\n+   package body Directed_Graph is\n+\n+      -----------------------\n+      -- Local subprograms --\n+      -----------------------\n+\n+      procedure Add_Component\n+        (G        : Instance;\n+         Comp     : Component_Id;\n+         Vertices : Vertex_List.Instance);\n+      pragma Inline (Add_Component);\n+      --  Add component Comp which houses vertices Vertices to graph G\n+\n+      procedure Ensure_Created (G : Instance);\n+      pragma Inline (Ensure_Created);\n+      --  Verify that graph G is created. Raise Not_Created if this is not the\n+      --  case.\n+\n+      procedure Ensure_Not_Present\n+        (G : Instance;\n+         E : Edge_Id);\n+      pragma Inline (Ensure_Not_Present);\n+      --  Verify that graph G lacks edge E. Raise Duplicate_Edge if this is not\n+      --  the case.\n+\n+      procedure Ensure_Not_Present\n+        (G : Instance;\n+         V : Vertex_Id);\n+      pragma Inline (Ensure_Not_Present);\n+      --  Verify that graph G lacks vertex V. Raise Duplicate_Vertex if this is\n+      --  not the case.\n+\n+      procedure Ensure_Present\n+        (G    : Instance;\n+         Comp : Component_Id);\n+      pragma Inline (Ensure_Present);\n+      --  Verify that component Comp exists in graph G. Raise Missing_Component\n+      --  if this is not the case.\n+\n+      procedure Ensure_Present\n+        (G : Instance;\n+         E : Edge_Id);\n+      pragma Inline (Ensure_Present);\n+      --  Verify that edge E is present in graph G. Raise Missing_Edge if this\n+      --  is not the case.\n+\n+      procedure Ensure_Present\n+        (G : Instance;\n+         V : Vertex_Id);\n+      pragma Inline (Ensure_Present);\n+      --  Verify that vertex V is present in graph G. Raise Missing_Vertex if\n+      --  this is not the case.\n+\n+      procedure Free is new Ada.Unchecked_Deallocation (Graph, Instance);\n+\n+      function Get_Component_Attributes\n+        (G    : Instance;\n+         Comp : Component_Id) return Component_Attributes;\n+      pragma Inline (Get_Component_Attributes);\n+      --  Obtain the attributes of component Comp of graph G\n+\n+      function Get_Edge_Attributes\n+        (G : Instance;\n+         E : Edge_Id) return Edge_Attributes;\n+      pragma Inline (Get_Edge_Attributes);\n+      --  Obtain the attributes of edge E of graph G\n+\n+      function Get_Vertex_Attributes\n+        (G : Instance;\n+         V : Vertex_Id) return Vertex_Attributes;\n+      pragma Inline (Get_Vertex_Attributes);\n+      --  Obtain the attributes of vertex V of graph G\n+\n+      function Get_Outgoing_Edges\n+        (G : Instance;\n+         V : Vertex_Id) return Edge_Set.Instance;\n+      pragma Inline (Get_Outgoing_Edges);\n+      --  Obtain the Outgoing_Edges attribute of vertex V of graph G\n+\n+      function Get_Vertices\n+        (G    : Instance;\n+         Comp : Component_Id) return Vertex_List.Instance;\n+      pragma Inline (Get_Vertices);\n+      --  Obtain the Vertices attribute of component Comp of graph G\n+\n+      procedure Set_Component\n+        (G   : Instance;\n+         V   : Vertex_Id;\n+         Val : Component_Id);\n+      pragma Inline (Set_Component);\n+      --  Set attribute Component of vertex V of graph G to value Val\n+\n+      procedure Set_Outgoing_Edges\n+        (G   : Instance;\n+         V   : Vertex_Id;\n+         Val : Edge_Set.Instance);\n+      pragma Inline (Set_Outgoing_Edges);\n+      --  Set attribute Outgoing_Edges of vertex V of graph G to value Val\n+\n+      procedure Set_Vertex_Attributes\n+        (G   : Instance;\n+         V   : Vertex_Id;\n+         Val : Vertex_Attributes);\n+      pragma Inline (Set_Vertex_Attributes);\n+      --  Set the attributes of vertex V of graph G to value Val\n+\n+      -------------------\n+      -- Add_Component --\n+      -------------------\n+\n+      procedure Add_Component\n+        (G        : Instance;\n+         Comp     : Component_Id;\n+         Vertices : Vertex_List.Instance)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Add the component to the set of all components in the graph\n+\n+         Component_Map.Put\n+           (T     => G.Components,\n+            Key   => Comp,\n+            Value => (Vertices => Vertices));\n+      end Add_Component;\n+\n+      --------------\n+      -- Add_Edge --\n+      --------------\n+\n+      procedure Add_Edge\n+        (G           : Instance;\n+         E           : Edge_Id;\n+         Source      : Vertex_Id;\n+         Destination : Vertex_Id)\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Not_Present (G, E);\n+         Ensure_Present (G, Source);\n+         Ensure_Present (G, Destination);\n+\n+         --  Add the edge to the set of all edges in the graph\n+\n+         Edge_Map.Put\n+           (T     => G.All_Edges,\n+            Key   => E,\n+            Value =>\n+              (Destination => Destination,\n+               Source      => Source));\n+\n+         --  Associate the edge with its source vertex which effectively \"owns\"\n+         --  the edge.\n+\n+         Edge_Set.Insert\n+           (S    => Get_Outgoing_Edges (G, Source),\n+            Elem => E);\n+      end Add_Edge;\n+\n+      ----------------\n+      -- Add_Vertex --\n+      ----------------\n+\n+      procedure Add_Vertex\n+        (G : Instance;\n+         V : Vertex_Id)\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Not_Present (G, V);\n+\n+         --  Add the vertex to the set of all vertices in the graph\n+\n+         Vertex_Map.Put\n+           (T     => G.All_Vertices,\n+            Key   => V,\n+            Value =>\n+              (Component      => No_Component,\n+               Outgoing_Edges => Edge_Set.Nil));\n+\n+         --  It is assumed that the vertex will have at least one outgoing\n+         --  edge. It is important not to create the set of edges above as\n+         --  the call to Put may fail in case the vertices are iterated.\n+         --  This would lead to a memory leak because the set would not be\n+         --  reclaimed.\n+\n+         Set_Outgoing_Edges (G, V, Edge_Set.Create (1));\n+      end Add_Vertex;\n+\n+      ---------------\n+      -- Component --\n+      ---------------\n+\n+      function Component\n+        (G : Instance;\n+         V : Vertex_Id) return Component_Id\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, V);\n+\n+         return Get_Vertex_Attributes (G, V).Component;\n+      end Component;\n+\n+      ------------------------\n+      -- Contains_Component --\n+      ------------------------\n+\n+      function Contains_Component\n+        (G    : Instance;\n+         Comp : Component_Id) return Boolean\n+      is\n+      begin\n+         Ensure_Created (G);\n+\n+         return Get_Component_Attributes (G, Comp) /= No_Component_Attributes;\n+      end Contains_Component;\n+\n+      -------------------\n+      -- Contains_Edge --\n+      -------------------\n+\n+      function Contains_Edge\n+        (G : Instance;\n+         E : Edge_Id) return Boolean\n+      is\n+      begin\n+         Ensure_Created (G);\n+\n+         return Get_Edge_Attributes (G, E) /= No_Edge_Attributes;\n+      end Contains_Edge;\n+\n+      ---------------------\n+      -- Contains_Vertex --\n+      ---------------------\n+\n+      function Contains_Vertex\n+        (G : Instance;\n+         V : Vertex_Id) return Boolean\n+      is\n+      begin\n+         Ensure_Created (G);\n+\n+         return Get_Vertex_Attributes (G, V) /= No_Vertex_Attributes;\n+      end Contains_Vertex;\n+\n+      ------------\n+      -- Create --\n+      ------------\n+\n+      function Create\n+        (Initial_Vertices : Positive;\n+         Initial_Edges    : Positive) return Instance\n+      is\n+         G : constant Instance := new Graph;\n+\n+      begin\n+         G.All_Edges    := Edge_Map.Create      (Initial_Edges);\n+         G.All_Vertices := Vertex_Map.Create    (Initial_Vertices);\n+         G.Components   := Component_Map.Create (Initial_Vertices);\n+\n+         return G;\n+      end Create;\n+\n+      -----------------\n+      -- Delete_Edge --\n+      -----------------\n+\n+      procedure Delete_Edge\n+        (G : Instance;\n+         E : Edge_Id)\n+      is\n+         Source : Vertex_Id;\n+\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, E);\n+\n+         Source := Source_Vertex (G, E);\n+         Ensure_Present (G, Source);\n+\n+         --  Delete the edge from its source vertex which effectively \"owns\"\n+         --  the edge.\n+\n+         Edge_Set.Delete (Get_Outgoing_Edges (G, Source), E);\n+\n+         --  Delete the edge from the set of all edges\n+\n+         Edge_Map.Delete (G.All_Edges, E);\n+      end Delete_Edge;\n+\n+      ------------------------\n+      -- Destination_Vertex --\n+      ------------------------\n+\n+      function Destination_Vertex\n+        (G : Instance;\n+         E : Edge_Id) return Vertex_Id\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, E);\n+\n+         return Get_Edge_Attributes (G, E).Destination;\n+      end Destination_Vertex;\n+\n+      -------------\n+      -- Destroy --\n+      -------------\n+\n+      procedure Destroy (G : in out Instance) is\n+      begin\n+         Ensure_Created (G);\n+\n+         Edge_Map.Destroy      (G.All_Edges);\n+         Vertex_Map.Destroy    (G.All_Vertices);\n+         Component_Map.Destroy (G.Components);\n+\n+         Free (G);\n+      end Destroy;\n+\n+      ----------------------------------\n+      -- Destroy_Component_Attributes --\n+      ----------------------------------\n+\n+      procedure Destroy_Component_Attributes\n+        (Attrs : in out Component_Attributes)\n+      is\n+      begin\n+         Vertex_List.Destroy (Attrs.Vertices);\n+      end Destroy_Component_Attributes;\n+\n+      -----------------------------\n+      -- Destroy_Edge_Attributes --\n+      -----------------------------\n+\n+      procedure Destroy_Edge_Attributes (Attrs : in out Edge_Attributes) is\n+         pragma Unreferenced (Attrs);\n+      begin\n+         null;\n+      end Destroy_Edge_Attributes;\n+\n+      --------------------\n+      -- Destroy_Vertex --\n+      --------------------\n+\n+      procedure Destroy_Vertex (V : in out Vertex_Id) is\n+         pragma Unreferenced (V);\n+      begin\n+         null;\n+      end Destroy_Vertex;\n+\n+      -------------------------------\n+      -- Destroy_Vertex_Attributes --\n+      -------------------------------\n+\n+      procedure Destroy_Vertex_Attributes (Attrs : in out Vertex_Attributes) is\n+      begin\n+         Edge_Set.Destroy (Attrs.Outgoing_Edges);\n+      end Destroy_Vertex_Attributes;\n+\n+      --------------------\n+      -- Ensure_Created --\n+      --------------------\n+\n+      procedure Ensure_Created (G : Instance) is\n+      begin\n+         if not Present (G) then\n+            raise Not_Created;\n+         end if;\n+      end Ensure_Created;\n+\n+      ------------------------\n+      -- Ensure_Not_Present --\n+      ------------------------\n+\n+      procedure Ensure_Not_Present\n+        (G : Instance;\n+         E : Edge_Id)\n+      is\n+      begin\n+         if Contains_Edge (G, E) then\n+            raise Duplicate_Edge;\n+         end if;\n+      end Ensure_Not_Present;\n+\n+      ------------------------\n+      -- Ensure_Not_Present --\n+      ------------------------\n+\n+      procedure Ensure_Not_Present\n+        (G : Instance;\n+         V : Vertex_Id)\n+      is\n+      begin\n+         if Contains_Vertex (G, V) then\n+            raise Duplicate_Vertex;\n+         end if;\n+      end Ensure_Not_Present;\n+\n+      --------------------\n+      -- Ensure_Present --\n+      --------------------\n+\n+      procedure Ensure_Present\n+        (G    : Instance;\n+         Comp : Component_Id)\n+      is\n+      begin\n+         if not Contains_Component (G, Comp) then\n+            raise Missing_Component;\n+         end if;\n+      end Ensure_Present;\n+\n+      --------------------\n+      -- Ensure_Present --\n+      --------------------\n+\n+      procedure Ensure_Present\n+        (G : Instance;\n+         E : Edge_Id)\n+      is\n+      begin\n+         if not Contains_Edge (G, E) then\n+            raise Missing_Edge;\n+         end if;\n+      end Ensure_Present;\n+\n+      --------------------\n+      -- Ensure_Present --\n+      --------------------\n+\n+      procedure Ensure_Present\n+        (G : Instance;\n+         V : Vertex_Id)\n+      is\n+      begin\n+         if not Contains_Vertex (G, V) then\n+            raise Missing_Vertex;\n+         end if;\n+      end Ensure_Present;\n+\n+      ---------------------\n+      -- Find_Components --\n+      ---------------------\n+\n+      procedure Find_Components (G : Instance) is\n+\n+         --  The components of graph G are discovered using Tarjan's strongly\n+         --  connected component algorithm. Do not modify this code unless you\n+         --  intimately understand the algorithm.\n+\n+         ----------------\n+         -- Tarjan_Map --\n+         ----------------\n+\n+         type Visitation_Number is new Natural;\n+         No_Visitation_Number    : constant Visitation_Number :=\n+                                      Visitation_Number'First;\n+         First_Visitation_Number : constant Visitation_Number :=\n+                                     No_Visitation_Number + 1;\n+\n+         type Tarjan_Attributes is record\n+            Index : Visitation_Number := No_Visitation_Number;\n+            --  Visitation number\n+\n+            Low_Link : Visitation_Number := No_Visitation_Number;\n+            --  Lowest visitation number\n+\n+            On_Stack : Boolean := False;\n+            --  Set when the library item appears in Stack\n+         end record;\n+\n+         No_Tarjan_Attributes : constant Tarjan_Attributes :=\n+           (Index    => No_Visitation_Number,\n+            Low_Link => No_Visitation_Number,\n+            On_Stack => False);\n+\n+         procedure Destroy_Tarjan_Attributes\n+           (Attrs : in out Tarjan_Attributes);\n+         --  Destroy the contents of attributes Attrs\n+\n+         package Tarjan_Map is new Dynamic_HTable\n+           (Key_Type              => Vertex_Id,\n+            Value_Type            => Tarjan_Attributes,\n+            No_Value              => No_Tarjan_Attributes,\n+            Expansion_Threshold   => 1.5,\n+            Expansion_Factor      => 2,\n+            Compression_Threshold => 0.3,\n+            Compression_Factor    => 2,\n+            \"=\"                   => Same_Vertex,\n+            Destroy_Value         => Destroy_Tarjan_Attributes,\n+            Hash                  => Hash_Vertex);\n+\n+         ------------------\n+         -- Tarjan_Stack --\n+         ------------------\n+\n+         package Tarjan_Stack is new Doubly_Linked_List\n+           (Element_Type    => Vertex_Id,\n+            \"=\"             => Same_Vertex,\n+            Destroy_Element => Destroy_Vertex);\n+\n+         -----------------\n+         -- Global data --\n+         -----------------\n+\n+         Attrs : Tarjan_Map.Instance   := Tarjan_Map.Nil;\n+         Stack : Tarjan_Stack.Instance := Tarjan_Stack.Nil;\n+\n+         -----------------------\n+         -- Local subprograms --\n+         -----------------------\n+\n+         procedure Associate_All_Vertices;\n+         pragma Inline (Associate_All_Vertices);\n+         --  Associate all vertices in the graph with the corresponding\n+         --  components that house them.\n+\n+         procedure Associate_Vertices (Comp : Component_Id);\n+         pragma Inline (Associate_Vertices);\n+         --  Associate all vertices of component Comp with the component\n+\n+         procedure Create_Component (V : Vertex_Id);\n+         pragma Inline (Create_Component);\n+         --  Create a new component with root vertex V\n+\n+         function Get_Tarjan_Attributes\n+           (V : Vertex_Id) return Tarjan_Attributes;\n+         pragma Inline (Get_Tarjan_Attributes);\n+         --  Obtain the Tarjan attributes of vertex V\n+\n+         function Index (V : Vertex_Id) return Visitation_Number;\n+         pragma Inline (Index);\n+         --  Obtain the Index attribute of vertex V\n+\n+         procedure Initialize_Components;\n+         pragma Inline (Initialize_Components);\n+         --  Initialize or reinitialize the components of the graph\n+\n+         function Is_Visited (V : Vertex_Id) return Boolean;\n+         pragma Inline (Is_Visited);\n+         --  Determine whether vertex V has been visited\n+\n+         function Low_Link (V : Vertex_Id) return Visitation_Number;\n+         pragma Inline (Low_Link);\n+         --  Obtain the Low_Link attribute of vertex V\n+\n+         function On_Stack (V : Vertex_Id) return Boolean;\n+         pragma Inline (On_Stack);\n+         --  Obtain the On_Stack attribute of vertex V\n+\n+         function Pop return Vertex_Id;\n+         pragma Inline (Pop);\n+         --  Pop a vertex off Stack\n+\n+         procedure Push (V : Vertex_Id);\n+         pragma Inline (Push);\n+         --  Push vertex V on Stack\n+\n+         procedure Record_Visit (V : Vertex_Id);\n+         pragma Inline (Record_Visit);\n+         --  Save the visitation of vertex V by setting relevant attributes\n+\n+         function Sequence_Next_Index return Visitation_Number;\n+         pragma Inline (Sequence_Next_Index);\n+         --  Procedure the next visitation number of the DFS traversal\n+\n+         procedure Set_Index\n+           (V   : Vertex_Id;\n+            Val : Visitation_Number);\n+         pragma Inline (Set_Index);\n+         --  Set attribute Index of vertex V to value Val\n+\n+         procedure Set_Low_Link\n+           (V   : Vertex_Id;\n+            Val : Visitation_Number);\n+         pragma Inline (Set_Low_Link);\n+         --  Set attribute Low_Link of vertex V to value Val\n+\n+         procedure Set_On_Stack\n+           (V   : Vertex_Id;\n+            Val : Boolean);\n+         pragma Inline (Set_On_Stack);\n+         --  Set attribute On_Stack of vertex V to value Val\n+\n+         procedure Set_Tarjan_Attributes\n+           (V   : Vertex_Id;\n+            Val : Tarjan_Attributes);\n+         pragma Inline (Set_Tarjan_Attributes);\n+         --  Set the attributes of vertex V to value Val\n+\n+         procedure Visit_Successors (V : Vertex_Id);\n+         pragma Inline (Visit_Successors);\n+         --  Visit the successors of vertex V\n+\n+         procedure Visit_Vertex (V : Vertex_Id);\n+         pragma Inline (Visit_Vertex);\n+         --  Visit single vertex V\n+\n+         procedure Visit_Vertices;\n+         pragma Inline (Visit_Vertices);\n+         --  Visit all vertices in the graph\n+\n+         ----------------------------\n+         -- Associate_All_Vertices --\n+         ----------------------------\n+\n+         procedure Associate_All_Vertices is\n+            Comp : Component_Id;\n+            Iter : Component_Iterator;\n+\n+         begin\n+            Iter := Iterate_Components (G);\n+            while Has_Next (Iter) loop\n+               Next (Iter, Comp);\n+\n+               Associate_Vertices (Comp);\n+            end loop;\n+         end Associate_All_Vertices;\n+\n+         ------------------------\n+         -- Associate_Vertices --\n+         ------------------------\n+\n+         procedure Associate_Vertices (Comp : Component_Id) is\n+            Iter : Vertex_Iterator;\n+            V    : Vertex_Id;\n+\n+         begin\n+            Iter := Iterate_Vertices (G, Comp);\n+            while Has_Next (Iter) loop\n+               Next (Iter, V);\n+\n+               Set_Component (G, V, Comp);\n+            end loop;\n+         end Associate_Vertices;\n+\n+         ----------------------\n+         -- Create_Component --\n+         ----------------------\n+\n+         procedure Create_Component (V : Vertex_Id) is\n+            Curr_V   : Vertex_Id;\n+            Vertices : Vertex_List.Instance;\n+\n+         begin\n+            Vertices := Vertex_List.Create;\n+\n+            --  Collect all vertices that comprise the current component by\n+            --  popping the stack until reaching the root vertex V.\n+\n+            loop\n+               Curr_V := Pop;\n+               Vertex_List.Append (Vertices, Curr_V);\n+\n+               exit when Same_Vertex (Curr_V, V);\n+            end loop;\n+\n+            Add_Component\n+              (G        => G,\n+               Comp     => Sequence_Next_Component,\n+               Vertices => Vertices);\n+         end Create_Component;\n+\n+         -------------------------------\n+         -- Destroy_Tarjan_Attributes --\n+         -------------------------------\n+\n+         procedure Destroy_Tarjan_Attributes\n+           (Attrs : in out Tarjan_Attributes)\n+         is\n+            pragma Unreferenced (Attrs);\n+         begin\n+            null;\n+         end Destroy_Tarjan_Attributes;\n+\n+         ---------------------------\n+         -- Get_Tarjan_Attributes --\n+         ---------------------------\n+\n+         function Get_Tarjan_Attributes\n+           (V : Vertex_Id) return Tarjan_Attributes\n+         is\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            return Tarjan_Map.Get (Attrs, V);\n+         end Get_Tarjan_Attributes;\n+\n+         -----------\n+         -- Index --\n+         -----------\n+\n+         function Index (V : Vertex_Id) return Visitation_Number is\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            return Get_Tarjan_Attributes (V).Index;\n+         end Index;\n+\n+         ---------------------------\n+         -- Initialize_Components --\n+         ---------------------------\n+\n+         procedure Initialize_Components is\n+         begin\n+            pragma Assert (Present (G));\n+\n+            --  The graph already contains a set of components. Reinitialize\n+            --  them in order to accommodate the new set of components about to\n+            --  be computed.\n+\n+            if Number_Of_Components (G) > 0 then\n+               Component_Map.Destroy (G.Components);\n+               G.Components := Component_Map.Create (Number_Of_Vertices (G));\n+            end if;\n+         end Initialize_Components;\n+\n+         ----------------\n+         -- Is_Visited --\n+         ----------------\n+\n+         function Is_Visited (V : Vertex_Id) return Boolean is\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            return Index (V) /= No_Visitation_Number;\n+         end Is_Visited;\n+\n+         --------------\n+         -- Low_Link --\n+         --------------\n+\n+         function Low_Link (V : Vertex_Id) return Visitation_Number is\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            return Get_Tarjan_Attributes (V).Low_Link;\n+         end Low_Link;\n+\n+         --------------\n+         -- On_Stack --\n+         --------------\n+\n+         function On_Stack (V : Vertex_Id) return Boolean is\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            return Get_Tarjan_Attributes (V).On_Stack;\n+         end On_Stack;\n+\n+         ---------\n+         -- Pop --\n+         ---------\n+\n+         function Pop return Vertex_Id is\n+            V : Vertex_Id;\n+\n+         begin\n+            V := Tarjan_Stack.Last (Stack);\n+            Tarjan_Stack.Delete_Last (Stack);\n+            Set_On_Stack (V, False);\n+\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            return V;\n+         end Pop;\n+\n+         ----------\n+         -- Push --\n+         ----------\n+\n+         procedure Push (V : Vertex_Id) is\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            Tarjan_Stack.Append (Stack, V);\n+            Set_On_Stack (V, True);\n+         end Push;\n+\n+         ------------------\n+         -- Record_Visit --\n+         ------------------\n+\n+         procedure Record_Visit (V : Vertex_Id) is\n+            Index : constant Visitation_Number := Sequence_Next_Index;\n+\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            Set_Index    (V, Index);\n+            Set_Low_Link (V, Index);\n+         end Record_Visit;\n+\n+         -------------------------\n+         -- Sequence_Next_Index --\n+         -------------------------\n+\n+         Index_Sequencer : Visitation_Number := First_Visitation_Number;\n+         --  The counter for visitation numbers. Do not directly manipulate its\n+         --  value because this will destroy the Index and Low_Link invariants\n+         --  of the algorithm.\n+\n+         function Sequence_Next_Index return Visitation_Number is\n+            Index : constant Visitation_Number := Index_Sequencer;\n+\n+         begin\n+            Index_Sequencer := Index_Sequencer + 1;\n+            return Index;\n+         end Sequence_Next_Index;\n+\n+         ---------------\n+         -- Set_Index --\n+         ---------------\n+\n+         procedure Set_Index\n+           (V   : Vertex_Id;\n+            Val : Visitation_Number)\n+         is\n+            TA : Tarjan_Attributes;\n+\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            TA := Get_Tarjan_Attributes (V);\n+            TA.Index := Val;\n+            Set_Tarjan_Attributes (V, TA);\n+         end Set_Index;\n+\n+         ------------------\n+         -- Set_Low_Link --\n+         ------------------\n+\n+         procedure Set_Low_Link\n+           (V   : Vertex_Id;\n+            Val : Visitation_Number)\n+         is\n+            TA : Tarjan_Attributes;\n+\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            TA := Get_Tarjan_Attributes (V);\n+            TA.Low_Link := Val;\n+            Set_Tarjan_Attributes (V, TA);\n+         end Set_Low_Link;\n+\n+         ------------------\n+         -- Set_On_Stack --\n+         ------------------\n+\n+         procedure Set_On_Stack\n+           (V   : Vertex_Id;\n+            Val : Boolean)\n+         is\n+            TA : Tarjan_Attributes;\n+\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            TA := Get_Tarjan_Attributes (V);\n+            TA.On_Stack := Val;\n+            Set_Tarjan_Attributes (V, TA);\n+         end Set_On_Stack;\n+\n+         ---------------------------\n+         -- Set_Tarjan_Attributes --\n+         ---------------------------\n+\n+         procedure Set_Tarjan_Attributes\n+           (V   : Vertex_Id;\n+            Val : Tarjan_Attributes)\n+         is\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            Tarjan_Map.Put (Attrs, V, Val);\n+         end Set_Tarjan_Attributes;\n+\n+         ----------------------\n+         -- Visit_Successors --\n+         ----------------------\n+\n+         procedure Visit_Successors (V : Vertex_Id) is\n+            E    : Edge_Id;\n+            Iter : Outgoing_Edge_Iterator;\n+            Succ : Vertex_Id;\n+\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            Iter := Iterate_Outgoing_Edges (G, V);\n+            while Has_Next (Iter) loop\n+               Next (Iter, E);\n+\n+               Succ := Destination_Vertex (G, E);\n+               pragma Assert (Contains_Vertex (G, Succ));\n+\n+               --  The current successor has not been visited yet. Extend the\n+               --  DFS traversal into it.\n+\n+               if not Is_Visited (Succ) then\n+                  Visit_Vertex (Succ);\n+\n+                  Set_Low_Link (V,\n+                    Visitation_Number'Min (Low_Link (V), Low_Link (Succ)));\n+\n+               --  The current successor has been visited, and still remains on\n+               --  the stack which indicates that it does not participate in a\n+               --  component yet.\n+\n+               elsif On_Stack (Succ) then\n+                  Set_Low_Link (V,\n+                    Visitation_Number'Min (Low_Link (V), Index (Succ)));\n+               end if;\n+            end loop;\n+         end Visit_Successors;\n+\n+         ------------------\n+         -- Visit_Vertex --\n+         ------------------\n+\n+         procedure Visit_Vertex (V : Vertex_Id) is\n+         begin\n+            pragma Assert (Present (G));\n+            pragma Assert (Contains_Vertex (G, V));\n+\n+            if not Is_Visited (V) then\n+               Record_Visit     (V);\n+               Push             (V);\n+               Visit_Successors (V);\n+\n+               --  The current vertex is the root of a component\n+\n+               if Low_Link (V) = Index (V) then\n+                  Create_Component (V);\n+               end if;\n+            end if;\n+         end Visit_Vertex;\n+\n+         --------------------\n+         -- Visit_Vertices --\n+         --------------------\n+\n+         procedure Visit_Vertices is\n+            Iter : All_Vertex_Iterator;\n+            V    : Vertex_Id;\n+\n+         begin\n+            Iter := Iterate_All_Vertices (G);\n+            while Has_Next (Iter) loop\n+               Next (Iter, V);\n+\n+               Visit_Vertex (V);\n+            end loop;\n+         end Visit_Vertices;\n+\n+      --  Start of processing for Find_Components\n+\n+      begin\n+         --  Initialize or reinitialize the components of the graph\n+\n+         Initialize_Components;\n+\n+         --  Prepare the extra attributes needed for each vertex, global\n+         --  visitation number, and the stack where examined vertices are\n+         --  placed.\n+\n+         Attrs := Tarjan_Map.Create (Number_Of_Vertices (G));\n+         Stack := Tarjan_Stack.Create;\n+\n+         --  Start the DFS traversal of Tarjan's SCC algorithm\n+\n+         Visit_Vertices;\n+\n+         Tarjan_Map.Destroy   (Attrs);\n+         Tarjan_Stack.Destroy (Stack);\n+\n+         --  Associate each vertex with the component it belongs to\n+\n+         Associate_All_Vertices;\n+      end Find_Components;\n+\n+      ------------------------------\n+      -- Get_Component_Attributes --\n+      ------------------------------\n+\n+      function Get_Component_Attributes\n+        (G    : Instance;\n+         Comp : Component_Id) return Component_Attributes\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Contains_Component (G, Comp));\n+\n+         return Component_Map.Get (G.Components, Comp);\n+      end Get_Component_Attributes;\n+\n+      -------------------------\n+      -- Get_Edge_Attributes --\n+      -------------------------\n+\n+      function Get_Edge_Attributes\n+        (G : Instance;\n+         E : Edge_Id) return Edge_Attributes\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Contains_Edge (G, E));\n+\n+         return Edge_Map.Get (G.All_Edges, E);\n+      end Get_Edge_Attributes;\n+\n+      ---------------------------\n+      -- Get_Vertex_Attributes --\n+      ---------------------------\n+\n+      function Get_Vertex_Attributes\n+        (G : Instance;\n+         V : Vertex_Id) return Vertex_Attributes\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Contains_Vertex (G, V));\n+\n+         return Vertex_Map.Get (G.All_Vertices, V);\n+      end Get_Vertex_Attributes;\n+\n+      ------------------------\n+      -- Get_Outgoing_Edges --\n+      ------------------------\n+\n+      function Get_Outgoing_Edges\n+        (G : Instance;\n+         V : Vertex_Id) return Edge_Set.Instance\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Contains_Vertex (G, V));\n+\n+         return Get_Vertex_Attributes (G, V).Outgoing_Edges;\n+      end Get_Outgoing_Edges;\n+\n+      ------------------\n+      -- Get_Vertices --\n+      ------------------\n+\n+      function Get_Vertices\n+        (G    : Instance;\n+         Comp : Component_Id) return Vertex_List.Instance\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Contains_Component (G, Comp));\n+\n+         return Get_Component_Attributes (G, Comp).Vertices;\n+      end Get_Vertices;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : All_Edge_Iterator) return Boolean is\n+      begin\n+         return Edge_Map.Has_Next (Edge_Map.Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : All_Vertex_Iterator) return Boolean is\n+      begin\n+         return Vertex_Map.Has_Next (Vertex_Map.Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Component_Iterator) return Boolean is\n+      begin\n+         return Component_Map.Has_Next (Component_Map.Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Outgoing_Edge_Iterator) return Boolean is\n+      begin\n+         return Edge_Set.Has_Next (Edge_Set.Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Vertex_Iterator) return Boolean is\n+      begin\n+         return Vertex_List.Has_Next (Vertex_List.Iterator (Iter));\n+      end Has_Next;\n+\n+      --------------\n+      -- Is_Empty --\n+      --------------\n+\n+      function Is_Empty (G : Instance) return Boolean is\n+      begin\n+         Ensure_Created (G);\n+\n+         return\n+           Edge_Map.Is_Empty (G.All_Edges)\n+             and then Vertex_Map.Is_Empty (G.All_Vertices);\n+      end Is_Empty;\n+\n+      -----------------------\n+      -- Iterate_All_Edges --\n+      -----------------------\n+\n+      function Iterate_All_Edges (G : Instance) return All_Edge_Iterator is\n+      begin\n+         Ensure_Created (G);\n+\n+         return All_Edge_Iterator (Edge_Map.Iterate (G.All_Edges));\n+      end Iterate_All_Edges;\n+\n+      --------------------------\n+      -- Iterate_All_Vertices --\n+      --------------------------\n+\n+      function Iterate_All_Vertices\n+        (G : Instance) return All_Vertex_Iterator\n+      is\n+      begin\n+         Ensure_Created (G);\n+\n+         return All_Vertex_Iterator (Vertex_Map.Iterate (G.All_Vertices));\n+      end Iterate_All_Vertices;\n+\n+      ------------------------\n+      -- Iterate_Components --\n+      ------------------------\n+\n+      function Iterate_Components (G : Instance) return Component_Iterator is\n+      begin\n+         Ensure_Created (G);\n+\n+         return Component_Iterator (Component_Map.Iterate (G.Components));\n+      end Iterate_Components;\n+\n+      ----------------------------\n+      -- Iterate_Outgoing_Edges --\n+      ----------------------------\n+\n+      function Iterate_Outgoing_Edges\n+        (G : Instance;\n+         V : Vertex_Id) return Outgoing_Edge_Iterator\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, V);\n+\n+         return\n+           Outgoing_Edge_Iterator\n+             (Edge_Set.Iterate (Get_Outgoing_Edges (G, V)));\n+      end Iterate_Outgoing_Edges;\n+\n+      ----------------------\n+      -- Iterate_Vertices --\n+      ----------------------\n+\n+      function Iterate_Vertices\n+        (G    : Instance;\n+         Comp : Component_Id) return Vertex_Iterator\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, Comp);\n+\n+         return Vertex_Iterator (Vertex_List.Iterate (Get_Vertices (G, Comp)));\n+      end Iterate_Vertices;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter : in out All_Edge_Iterator;\n+         E    : out Edge_Id)\n+      is\n+      begin\n+         Edge_Map.Next (Edge_Map.Iterator (Iter), E);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter : in out All_Vertex_Iterator;\n+         V    : out Vertex_Id)\n+      is\n+      begin\n+         Vertex_Map.Next (Vertex_Map.Iterator (Iter), V);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter : in out Component_Iterator;\n+         Comp : out Component_Id)\n+      is\n+      begin\n+         Component_Map.Next (Component_Map.Iterator (Iter), Comp);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter : in out Outgoing_Edge_Iterator;\n+         E    : out Edge_Id)\n+      is\n+      begin\n+         Edge_Set.Next (Edge_Set.Iterator (Iter), E);\n+      end Next;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next\n+        (Iter : in out Vertex_Iterator;\n+         V    : out Vertex_Id)\n+      is\n+      begin\n+         Vertex_List.Next (Vertex_List.Iterator (Iter), V);\n+      end Next;\n+\n+      --------------------------\n+      -- Number_Of_Components --\n+      --------------------------\n+\n+      function Number_Of_Components (G : Instance) return Natural is\n+      begin\n+         Ensure_Created (G);\n+\n+         return Component_Map.Size (G.Components);\n+      end Number_Of_Components;\n+\n+      ---------------------\n+      -- Number_Of_Edges --\n+      ---------------------\n+\n+      function Number_Of_Edges (G : Instance) return Natural is\n+      begin\n+         Ensure_Created (G);\n+\n+         return Edge_Map.Size (G.All_Edges);\n+      end Number_Of_Edges;\n+\n+      ------------------------\n+      -- Number_Of_Vertices --\n+      ------------------------\n+\n+      function Number_Of_Vertices (G : Instance) return Natural is\n+      begin\n+         Ensure_Created (G);\n+\n+         return Vertex_Map.Size (G.All_Vertices);\n+      end Number_Of_Vertices;\n+\n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (G : Instance) return Boolean is\n+      begin\n+         return G /= Nil;\n+      end Present;\n+\n+      -------------------\n+      -- Set_Component --\n+      -------------------\n+\n+      procedure Set_Component\n+        (G   : Instance;\n+         V   : Vertex_Id;\n+         Val : Component_Id)\n+      is\n+         VA : Vertex_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Contains_Vertex (G, V));\n+\n+         VA := Get_Vertex_Attributes (G, V);\n+         VA.Component := Val;\n+         Set_Vertex_Attributes (G, V, VA);\n+      end Set_Component;\n+\n+      ------------------------\n+      -- Set_Outgoing_Edges --\n+      ------------------------\n+\n+      procedure Set_Outgoing_Edges\n+        (G   : Instance;\n+         V   : Vertex_Id;\n+         Val : Edge_Set.Instance)\n+      is\n+         VA : Vertex_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Contains_Vertex (G, V));\n+\n+         VA := Get_Vertex_Attributes (G, V);\n+         VA.Outgoing_Edges := Val;\n+         Set_Vertex_Attributes (G, V, VA);\n+      end Set_Outgoing_Edges;\n+\n+      ---------------------------\n+      -- Set_Vertex_Attributes --\n+      ---------------------------\n+\n+      procedure Set_Vertex_Attributes\n+        (G   : Instance;\n+         V   : Vertex_Id;\n+         Val : Vertex_Attributes)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Contains_Vertex (G, V));\n+\n+         Vertex_Map.Put (G.All_Vertices, V, Val);\n+      end Set_Vertex_Attributes;\n+\n+      -------------------\n+      -- Source_Vertex --\n+      -------------------\n+\n+      function Source_Vertex\n+        (G : Instance;\n+         E : Edge_Id) return Vertex_Id\n+      is\n+      begin\n+         Ensure_Created (G);\n+         Ensure_Present (G, E);\n+\n+         return Get_Edge_Attributes (G, E).Source;\n+      end Source_Vertex;\n+   end Directed_Graph;\n+\n+   --------------------\n+   -- Hash_Component --\n+   --------------------\n+\n+   function Hash_Component (Comp : Component_Id) return Bucket_Range_Type is\n+   begin\n+      return Bucket_Range_Type (Comp);\n+   end Hash_Component;\n+\n+   -------------\n+   -- Present --\n+   -------------\n+\n+   function Present (Comp : Component_Id) return Boolean is\n+   begin\n+      return Comp /= No_Component;\n+   end Present;\n+\n+   -----------------------------\n+   -- Sequence_Next_Component --\n+   -----------------------------\n+\n+   Component_Sequencer : Component_Id := First_Component;\n+   --  The counter for component handles. Do not directly manipulate its value\n+   --  because this will destroy the invariant of the handles.\n+\n+   function Sequence_Next_Component return Component_Id is\n+      Component : constant Component_Id := Component_Sequencer;\n+\n+   begin\n+      Component_Sequencer := Component_Sequencer + 1;\n+      return Component;\n+   end Sequence_Next_Component;\n+\n+end GNAT.Graphs;"}, {"sha": "7926a1b8f354ed5afafd53bf45245e651bfb5bda", "filename": "gcc/ada/libgnat/g-graphs.ads", "status": "added", "additions": 529, "deletions": 0, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-graphs.ads?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -0,0 +1,529 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                           G N A T . G R A P H S                          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2018-2019, Free Software Foundation, Inc.      --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Compiler_Unit_Warning;\n+\n+with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n+with GNAT.Lists;           use GNAT.Lists;\n+with GNAT.Sets;            use GNAT.Sets;\n+\n+package GNAT.Graphs is\n+\n+   ---------------\n+   -- Componant --\n+   ---------------\n+\n+   --  The following type denotes a strongly connected component handle\n+   --  (referred to as simply \"component\") in a graph.\n+\n+   type Component_Id is new Natural;\n+   No_Component : constant Component_Id;\n+\n+   function Hash_Component (Comp : Component_Id) return Bucket_Range_Type;\n+   --  Map component Comp into the range of buckets\n+\n+   function Present (Comp : Component_Id) return Boolean;\n+   --  Determine whether component Comp exists\n+\n+   --------------------\n+   -- Directed_Graph --\n+   --------------------\n+\n+   --  The following package offers a directed graph abstraction with the\n+   --  following characteristics:\n+   --\n+   --    * Dynamic resizing based on number of vertices and edges\n+   --    * Creation of multiple instances, of different sizes\n+   --    * Discovery of strongly connected components\n+   --    * Iterable attributes\n+   --\n+   --  The following use pattern must be employed when operating this graph:\n+   --\n+   --    Graph : Instance := Create (<some size>, <some size>);\n+   --\n+   --    <various operations>\n+   --\n+   --    Destroy (Graph);\n+   --\n+   --  The destruction of the graph reclaims all storage occupied by it.\n+\n+   generic\n+\n+      --------------\n+      -- Vertices --\n+      --------------\n+\n+      type Vertex_Id is private;\n+      --  The handle of a vertex\n+\n+      No_Vertex : Vertex_Id;\n+      --  An indicator for a nonexistent vertex\n+\n+      with function Hash_Vertex (V : Vertex_Id) return Bucket_Range_Type;\n+      --  Map vertex V into the range of buckets\n+\n+      with function Same_Vertex\n+             (Left  : Vertex_Id;\n+              Right : Vertex_Id) return Boolean;\n+      --  Compare vertex Left to vertex Right for identity\n+\n+      -----------\n+      -- Edges --\n+      -----------\n+\n+      type Edge_Id is private;\n+      --  The handle of an edge\n+\n+      No_Edge : Edge_Id;\n+      --  An indicator for a nonexistent edge\n+\n+      with function Hash_Edge (E : Edge_Id) return Bucket_Range_Type;\n+      --  Map edge E into the range of buckets\n+\n+      with function Same_Edge\n+             (Left  : Edge_Id;\n+              Right : Edge_Id) return Boolean;\n+      --  Compare edge Left to edge Right for identity\n+\n+   package Directed_Graph is\n+\n+      --  The following exceptions are raised when an attempt is made to add\n+      --  the same edge or vertex in a graph.\n+\n+      Duplicate_Edge   : exception;\n+      Duplicate_Vertex : exception;\n+\n+      --  The following exceptions are raised when an attempt is made to delete\n+      --  or reference a nonexistent component, edge, or vertex in a graph.\n+\n+      Missing_Component : exception;\n+      Missing_Edge      : exception;\n+      Missing_Vertex    : exception;\n+\n+      ----------------------\n+      -- Graph operations --\n+      ----------------------\n+\n+      --  The following type denotes a graph handle. Each instance must be\n+      --  created using routine Create.\n+\n+      type Instance is private;\n+      Nil : constant Instance;\n+\n+      procedure Add_Edge\n+        (G           : Instance;\n+         E           : Edge_Id;\n+         Source      : Vertex_Id;\n+         Destination : Vertex_Id);\n+      --  Add edge E to graph G which links vertex source Source and desination\n+      --  vertex Destination. The edge is \"owned\" by vertex Source. This action\n+      --  raises the following exceptions:\n+      --\n+      --    * Duplicate_Edge, when the edge is already present in the graph\n+      --\n+      --    * Iterated, when the graph has an outstanding edge iterator\n+      --\n+      --    * Missing_Vertex, when either the source or desination are not\n+      --      present in the graph.\n+\n+      procedure Add_Vertex\n+        (G : Instance;\n+         V : Vertex_Id);\n+      --  Add vertex V to graph G. This action raises the following exceptions:\n+      --\n+      --    * Duplicate_Vertex, when the vertex is already present in the graph\n+      --\n+      --    * Iterated, when the graph has an outstanding vertex iterator\n+\n+      function Component\n+        (G : Instance;\n+         V : Vertex_Id) return Component_Id;\n+      --  Obtain the component where vertex V of graph G resides. This action\n+      --  raises the following exceptions:\n+      --\n+      --    * Missing_Vertex, when the vertex is not present in the graph\n+\n+      function Contains_Component\n+        (G    : Instance;\n+         Comp : Component_Id) return Boolean;\n+      --  Determine whether graph G contains component Comp\n+\n+      function Contains_Edge\n+        (G : Instance;\n+         E : Edge_Id) return Boolean;\n+      --  Determine whether graph G contains edge E\n+\n+      function Contains_Vertex\n+        (G : Instance;\n+         V : Vertex_Id) return Boolean;\n+      --  Determine whether graph G contains vertex V\n+\n+      function Create\n+        (Initial_Vertices : Positive;\n+         Initial_Edges    : Positive) return Instance;\n+      --  Create a new graph with vertex capacity Initial_Vertices and edge\n+      --  capacity Initial_Edges. This routine must be called at the start of\n+      --  a graph's lifetime.\n+\n+      procedure Delete_Edge\n+        (G : Instance;\n+         E : Edge_Id);\n+      --  Delete edge E from graph G. This action raises these exceptions:\n+      --\n+      --    * Iterated, when the graph has an outstanding edge iterator\n+      --\n+      --    * Missing_Edge, when the edge is not present in the graph\n+      --\n+      --    * Missing_Vertex, when the source vertex that \"owns\" the edge is\n+      --      not present in the graph.\n+\n+      function Destination_Vertex\n+        (G : Instance;\n+         E : Edge_Id) return Vertex_Id;\n+      --  Obtain the destination vertex of edge E of graph G. This action\n+      --  raises the following exceptions:\n+      --\n+      --    * Missing_Edge, when the edge is not present in the graph\n+\n+      procedure Destroy (G : in out Instance);\n+      --  Destroy the contents of graph G, rendering it unusable. This routine\n+      --  must be called at the end of a graph's lifetime. This action raises\n+      --  the following exceptions:\n+      --\n+      --    * Iterated, if the graph has any outstanding iterator\n+\n+      procedure Find_Components (G : Instance);\n+      --  Find all components of graph G. This action raises the following\n+      --  exceptions:\n+      --\n+      --    * Iterated, when the components or vertices of the graph have an\n+      --      outstanding iterator.\n+\n+      function Is_Empty (G : Instance) return Boolean;\n+      --  Determine whether graph G is empty\n+\n+      function Number_Of_Components (G : Instance) return Natural;\n+      --  Obtain the total number of components of graph G\n+\n+      function Number_Of_Edges (G : Instance) return Natural;\n+      --  Obtain the total number of edges of graph G\n+\n+      function Number_Of_Vertices (G : Instance) return Natural;\n+      --  Obtain the total number of vertices of graph G\n+\n+      function Present (G : Instance) return Boolean;\n+      --  Determine whether graph G exists\n+\n+      function Source_Vertex\n+        (G : Instance;\n+         E : Edge_Id) return Vertex_Id;\n+      --  Obtain the source vertex that \"owns\" edge E of graph G. This action\n+      --  raises the following exceptions:\n+      --\n+      --    * Missing_Edge, when the edge is not present in the graph\n+\n+      -------------------------\n+      -- Iterator operations --\n+      -------------------------\n+\n+      --  The following types represent iterators over various attributes of a\n+      --  graph. Each iterator locks all mutation operations of its associated\n+      --  attribute, and unlocks them once it is exhausted. The iterators must\n+      --  be used with the following pattern:\n+      --\n+      --    Iter : Iterate_XXX (Graph);\n+      --    while Has_Next (Iter) loop\n+      --       Next (Iter, Element);\n+      --    end loop;\n+      --\n+      --  It is possible to advance the iterators by using Next only, however\n+      --  this risks raising Iterator_Exhausted.\n+\n+      --  The following type represents an iterator over all edges of a graph\n+\n+      type All_Edge_Iterator is private;\n+\n+      function Has_Next (Iter : All_Edge_Iterator) return Boolean;\n+      --  Determine whether iterator Iter has more edges to examine\n+\n+      function Iterate_All_Edges (G : Instance) return All_Edge_Iterator;\n+      --  Obtain an iterator over all edges of graph G\n+\n+      procedure Next\n+        (Iter : in out All_Edge_Iterator;\n+         E    : out Edge_Id);\n+      --  Return the current edge referenced by iterator Iter and advance to\n+      --  the next available edge. This action raises the following exceptions:\n+      --\n+      --    * Iterator_Exhausted, when the iterator has been exhausted and\n+      --      further attempts are made to advance it.\n+\n+      --  The following type represents an iterator over all vertices of a\n+      --  graph.\n+\n+      type All_Vertex_Iterator is private;\n+\n+      function Has_Next (Iter : All_Vertex_Iterator) return Boolean;\n+      --  Determine whether iterator Iter has more vertices to examine\n+\n+      function Iterate_All_Vertices (G : Instance) return All_Vertex_Iterator;\n+      --  Obtain an iterator over all vertices of graph G\n+\n+      procedure Next\n+        (Iter : in out All_Vertex_Iterator;\n+         V    : out Vertex_Id);\n+      --  Return the current vertex referenced by iterator Iter and advance\n+      --  to the next available vertex. This action raises the following\n+      --  exceptions:\n+      --\n+      --    * Iterator_Exhausted, when the iterator has been exhausted and\n+      --      further attempts are made to advance it.\n+\n+      --  The following type represents an iterator over all components of a\n+      --  graph.\n+\n+      type Component_Iterator is private;\n+\n+      function Has_Next (Iter : Component_Iterator) return Boolean;\n+      --  Determine whether iterator Iter has more components to examine\n+\n+      function Iterate_Components (G : Instance) return Component_Iterator;\n+      --  Obtain an iterator over all components of graph G\n+\n+      procedure Next\n+        (Iter : in out Component_Iterator;\n+         Comp : out Component_Id);\n+      --  Return the current component referenced by iterator Iter and advance\n+      --  to the next component. This action raises the following exceptions:\n+      --\n+      --    * Iterator_Exhausted, when the iterator has been exhausted and\n+      --      further attempts are made to advance it.\n+\n+      --  The following type represents an iterator over all outgoing edges of\n+      --  a vertex.\n+\n+      type Outgoing_Edge_Iterator is private;\n+\n+      function Has_Next (Iter : Outgoing_Edge_Iterator) return Boolean;\n+      --  Determine whether iterator Iter has more outgoing edges to examine\n+\n+      function Iterate_Outgoing_Edges\n+        (G : Instance;\n+         V : Vertex_Id) return Outgoing_Edge_Iterator;\n+      --  Obtain an iterator over all the outgoing edges \"owned\" by vertex V of\n+      --  graph G.\n+\n+      procedure Next\n+        (Iter : in out Outgoing_Edge_Iterator;\n+         E    : out Edge_Id);\n+      --  Return the current outgoing edge referenced by iterator Iter and\n+      --  advance to the next available outgoing edge. This action raises the\n+      --  following exceptions:\n+      --\n+      --    * Iterator_Exhausted, when the iterator has been exhausted and\n+      --      further attempts are made to advance it.\n+\n+      --  The following type prepresents an iterator over all vertices of a\n+      --  component.\n+\n+      type Vertex_Iterator is private;\n+\n+      function Has_Next (Iter : Vertex_Iterator) return Boolean;\n+      --  Determine whether iterator Iter has more vertices to examine\n+\n+      function Iterate_Vertices\n+        (G    : Instance;\n+         Comp : Component_Id) return Vertex_Iterator;\n+      --  Obtain an iterator over all vertices that comprise component Comp of\n+      --  graph G.\n+\n+      procedure Next\n+        (Iter : in out Vertex_Iterator;\n+         V    : out Vertex_Id);\n+      --  Return the current vertex referenced by iterator Iter and advance to\n+      --  the next vertex. This action raises the following exceptions:\n+      --\n+      --    * Iterator_Exhausted, when the iterator has been exhausted and\n+      --      further attempts are made to advance it.\n+\n+   private\n+      pragma Unreferenced (No_Edge);\n+\n+      --------------\n+      -- Edge_Map --\n+      --------------\n+\n+      type Edge_Attributes is record\n+         Destination : Vertex_Id := No_Vertex;\n+         --  The target of a directed edge\n+\n+         Source : Vertex_Id := No_Vertex;\n+         --  The origin of a directed edge. The source vertex \"owns\" the edge.\n+      end record;\n+\n+      No_Edge_Attributes : constant Edge_Attributes :=\n+        (Destination => No_Vertex,\n+         Source      => No_Vertex);\n+\n+      procedure Destroy_Edge_Attributes (Attrs : in out Edge_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      package Edge_Map is new Dynamic_HTable\n+        (Key_Type              => Edge_Id,\n+         Value_Type            => Edge_Attributes,\n+         No_Value              => No_Edge_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => Same_Edge,\n+         Destroy_Value         => Destroy_Edge_Attributes,\n+         Hash                  => Hash_Edge);\n+\n+      --------------\n+      -- Edge_Set --\n+      --------------\n+\n+      package Edge_Set is new Membership_Set\n+        (Element_Type => Edge_Id,\n+         \"=\"          => \"=\",\n+         Hash         => Hash_Edge);\n+\n+      -----------------\n+      -- Vertex_List --\n+      -----------------\n+\n+      procedure Destroy_Vertex (V : in out Vertex_Id);\n+      --  Destroy the contents of a vertex\n+\n+      package Vertex_List is new Doubly_Linked_List\n+        (Element_Type    => Vertex_Id,\n+         \"=\"             => Same_Vertex,\n+         Destroy_Element => Destroy_Vertex);\n+\n+      ----------------\n+      -- Vertex_Map --\n+      ----------------\n+\n+      type Vertex_Attributes is record\n+         Component : Component_Id := No_Component;\n+         --  The component where a vertex lives\n+\n+         Outgoing_Edges : Edge_Set.Instance := Edge_Set.Nil;\n+         --  The set of edges that extend out from a vertex\n+      end record;\n+\n+      No_Vertex_Attributes : constant Vertex_Attributes :=\n+        (Component      => No_Component,\n+         Outgoing_Edges => Edge_Set.Nil);\n+\n+      procedure Destroy_Vertex_Attributes (Attrs : in out Vertex_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      package Vertex_Map is new Dynamic_HTable\n+        (Key_Type              => Vertex_Id,\n+         Value_Type            => Vertex_Attributes,\n+         No_Value              => No_Vertex_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => Same_Vertex,\n+         Destroy_Value         => Destroy_Vertex_Attributes,\n+         Hash                  => Hash_Vertex);\n+\n+      -------------------\n+      -- Component_Map --\n+      -------------------\n+\n+      type Component_Attributes is record\n+         Vertices : Vertex_List.Instance := Vertex_List.Nil;\n+      end record;\n+\n+      No_Component_Attributes : constant Component_Attributes :=\n+        (Vertices => Vertex_List.Nil);\n+\n+      procedure Destroy_Component_Attributes\n+        (Attrs : in out Component_Attributes);\n+      --  Destroy the contents of attributes Attrs\n+\n+      package Component_Map is new Dynamic_HTable\n+        (Key_Type              => Component_Id,\n+         Value_Type            => Component_Attributes,\n+         No_Value              => No_Component_Attributes,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy_Component_Attributes,\n+         Hash                  => Hash_Component);\n+\n+      -----------\n+      -- Graph --\n+      -----------\n+\n+      type Graph is record\n+         All_Edges : Edge_Map.Instance := Edge_Map.Nil;\n+         --  The map of edge -> edge attributes for all edges in the graph\n+\n+         All_Vertices : Vertex_Map.Instance := Vertex_Map.Nil;\n+         --  The map of vertex -> vertex attributes for all vertices in the\n+         --  graph.\n+\n+         Components : Component_Map.Instance := Component_Map.Nil;\n+         --  The map of component -> component attributes for all components\n+         --  in the graph.\n+      end record;\n+\n+      --------------\n+      -- Instance --\n+      --------------\n+\n+      type Instance is access Graph;\n+      Nil : constant Instance := null;\n+\n+      ---------------\n+      -- Iterators --\n+      ---------------\n+\n+      type All_Edge_Iterator      is new Edge_Map.Iterator;\n+      type All_Vertex_Iterator    is new Vertex_Map.Iterator;\n+      type Component_Iterator     is new Component_Map.Iterator;\n+      type Outgoing_Edge_Iterator is new Edge_Set.Iterator;\n+      type Vertex_Iterator        is new Vertex_List.Iterator;\n+   end Directed_Graph;\n+\n+private\n+   No_Component    : constant Component_Id := Component_Id'First;\n+   First_Component : constant Component_Id := No_Component + 1;\n+\n+end GNAT.Graphs;"}, {"sha": "d1a8616b2e6e13ebd742770ca4e61ad10d94c973", "filename": "gcc/ada/libgnat/g-lists.adb", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.adb?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -90,6 +90,10 @@ package body GNAT.Lists is\n       pragma Inline (Lock);\n       --  Lock all mutation functionality of list L\n \n+      function Present (Nod : Node_Ptr) return Boolean;\n+      pragma Inline (Present);\n+      --  Determine whether node Nod exists\n+\n       procedure Unlock (L : Instance);\n       pragma Inline (Unlock);\n       --  Unlock all mutation functionality of list L\n@@ -217,15 +221,15 @@ package body GNAT.Lists is\n       procedure Delete_Node (L : Instance; Nod : Node_Ptr) is\n          Ref : Node_Ptr := Nod;\n \n-         pragma Assert (Ref /= null);\n+         pragma Assert (Present (Ref));\n \n          Next : constant Node_Ptr := Ref.Next;\n          Prev : constant Node_Ptr := Ref.Prev;\n \n       begin\n-         pragma Assert (L    /= null);\n-         pragma Assert (Next /= null);\n-         pragma Assert (Prev /= null);\n+         pragma Assert (Present (L));\n+         pragma Assert (Present (Next));\n+         pragma Assert (Present (Prev));\n \n          Prev.Next := Next;  --  Prev ---> Next\n          Next.Prev := Prev;  --  Prev <--> Next\n@@ -235,6 +239,10 @@ package body GNAT.Lists is\n \n          L.Elements := L.Elements - 1;\n \n+         --  Invoke the element destructor before deallocating the node\n+\n+         Destroy_Element (Nod.Elem);\n+\n          Free (Ref);\n       end Delete_Node;\n \n@@ -263,10 +271,10 @@ package body GNAT.Lists is\n       ---------------------\n \n       procedure Ensure_Circular (Head : Node_Ptr) is\n-         pragma Assert (Head /= null);\n+         pragma Assert (Present (Head));\n \n       begin\n-         if Head.Next = null and then Head.Prev = null then\n+         if not Present (Head.Next) and then not Present (Head.Prev) then\n             Head.Next := Head;\n             Head.Prev := Head;\n          end if;\n@@ -278,7 +286,7 @@ package body GNAT.Lists is\n \n       procedure Ensure_Created (L : Instance) is\n       begin\n-         if L = null then\n+         if not Present (L) then\n             raise Not_Created;\n          end if;\n       end Ensure_Created;\n@@ -289,7 +297,7 @@ package body GNAT.Lists is\n \n       procedure Ensure_Full (L : Instance) is\n       begin\n-         pragma Assert (L /= null);\n+         pragma Assert (Present (L));\n \n          if L.Elements = 0 then\n             raise List_Empty;\n@@ -302,7 +310,7 @@ package body GNAT.Lists is\n \n       procedure Ensure_Unlocked (L : Instance) is\n       begin\n-         pragma Assert (L /= null);\n+         pragma Assert (Present (L));\n \n          --  The list has at least one outstanding iterator\n \n@@ -319,7 +327,7 @@ package body GNAT.Lists is\n         (Head : Node_Ptr;\n          Elem : Element_Type) return Node_Ptr\n       is\n-         pragma Assert (Head /= null);\n+         pragma Assert (Present (Head));\n \n          Nod : Node_Ptr;\n \n@@ -435,9 +443,9 @@ package body GNAT.Lists is\n          Left  : Node_Ptr;\n          Right : Node_Ptr)\n       is\n-         pragma Assert (L     /= null);\n-         pragma Assert (Left  /= null);\n-         pragma Assert (Right /= null);\n+         pragma Assert (Present (L));\n+         pragma Assert (Present (Left));\n+         pragma Assert (Present (Right));\n \n          Nod : constant Node_Ptr :=\n                  new Node'(Elem => Elem,\n@@ -471,7 +479,7 @@ package body GNAT.Lists is\n          --  The invariant of Iterate and Next ensures that the iterator always\n          --  refers to a valid node if there exists one.\n \n-         return Is_Valid (Iter.Nod, Iter.List.Nodes'Access);\n+         return Is_Valid (Iter.Curr_Nod, Iter.List.Nodes'Access);\n       end Is_Valid;\n \n       --------------\n@@ -483,7 +491,7 @@ package body GNAT.Lists is\n          --  A node is valid if it is non-null, and does not refer to the dummy\n          --  head of some list.\n \n-         return Nod /= null and then Nod /= Head;\n+         return Present (Nod) and then Nod /= Head;\n       end Is_Valid;\n \n       -------------\n@@ -499,7 +507,7 @@ package body GNAT.Lists is\n \n          Lock (L);\n \n-         return (List => L, Nod => L.Nodes.Next);\n+         return (List => L, Curr_Nod => L.Nodes.Next);\n       end Iterate;\n \n       ----------\n@@ -520,7 +528,7 @@ package body GNAT.Lists is\n \n       procedure Lock (L : Instance) is\n       begin\n-         pragma Assert (L /= null);\n+         pragma Assert (Present (L));\n \n          --  The list may be locked multiple times if multiple iterators are\n          --  operating over it.\n@@ -534,7 +542,7 @@ package body GNAT.Lists is\n \n       procedure Next (Iter : in out Iterator; Elem : out Element_Type) is\n          Is_OK : constant Boolean  := Is_Valid (Iter);\n-         Saved : constant Node_Ptr := Iter.Nod;\n+         Saved : constant Node_Ptr := Iter.Curr_Nod;\n \n       begin\n          --  The iterator is no linger valid which indicates that it has been\n@@ -548,8 +556,9 @@ package body GNAT.Lists is\n \n          --  Advance to the next node along the list\n \n-         Iter.Nod := Iter.Nod.Next;\n-         Elem     := Saved.Elem;\n+         Iter.Curr_Nod := Iter.Curr_Nod.Next;\n+\n+         Elem := Saved.Elem;\n       end Next;\n \n       -------------\n@@ -579,6 +588,24 @@ package body GNAT.Lists is\n             Right => Head.Next);\n       end Prepend;\n \n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (L : Instance) return Boolean is\n+      begin\n+         return L /= Nil;\n+      end Present;\n+\n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (Nod : Node_Ptr) return Boolean is\n+      begin\n+         return Nod /= null;\n+      end Present;\n+\n       -------------\n       -- Replace --\n       -------------\n@@ -620,7 +647,7 @@ package body GNAT.Lists is\n \n       procedure Unlock (L : Instance) is\n       begin\n-         pragma Assert (L /= null);\n+         pragma Assert (Present (L));\n \n          --  The list may be locked multiple times if multiple iterators are\n          --  operating over it."}, {"sha": "911b85f8969d4f749bbf21930f73086693a742bd", "filename": "gcc/ada/libgnat/g-lists.ads", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.ads?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -40,8 +40,8 @@ package GNAT.Lists is\n    --  The following package offers a doubly linked list abstraction with the\n    --  following characteristics:\n    --\n-   --    * Creation of multiple instances, of different sizes.\n-   --    * Iterable elements.\n+   --    * Creation of multiple instances, of different sizes\n+   --    * Iterable elements\n    --\n    --  The following use pattern must be employed with this list:\n    --\n@@ -60,6 +60,9 @@ package GNAT.Lists is\n         (Left  : Element_Type;\n          Right : Element_Type) return Boolean;\n \n+      with procedure Destroy_Element (Elem : in out Element_Type);\n+      --  Element destructor\n+\n    package Doubly_Linked_List is\n \n       ---------------------\n@@ -139,6 +142,9 @@ package GNAT.Lists is\n       --  Insert element Elem at the start of list L. This action will raise\n       --  Iterated if the list has outstanding iterators.\n \n+      function Present (L : Instance) return Boolean;\n+      --  Determine whether list L exists\n+\n       procedure Replace\n         (L        : Instance;\n          Old_Elem : Element_Type;\n@@ -168,15 +174,15 @@ package GNAT.Lists is\n \n       type Iterator is private;\n \n-      function Iterate (L : Instance) return Iterator;\n-      --  Obtain an iterator over the elements of list L. This action locks all\n-      --  mutation functionality of the associated list.\n-\n       function Has_Next (Iter : Iterator) return Boolean;\n       --  Determine whether iterator Iter has more elements to examine. If the\n       --  iterator has been exhausted, restore all mutation functionality of\n       --  the associated list.\n \n+      function Iterate (L : Instance) return Iterator;\n+      --  Obtain an iterator over the elements of list L. This action locks all\n+      --  mutation functionality of the associated list.\n+\n       procedure Next (Iter : in out Iterator; Elem : out Element_Type);\n       --  Return the current element referenced by iterator Iter and advance\n       --  to the next available element. If the iterator has been exhausted\n@@ -215,13 +221,13 @@ package GNAT.Lists is\n       --  The following type represents an element iterator\n \n       type Iterator is record\n-         List : Instance := null;\n-         --  Reference to the associated list\n-\n-         Nod : Node_Ptr := null;\n+         Curr_Nod : Node_Ptr := null;\n          --  Reference to the current node being examined. The invariant of the\n          --  iterator requires that this field always points to a valid node. A\n          --  value of null indicates that the iterator is exhausted.\n+\n+         List : Instance := null;\n+         --  Reference to the associated list\n       end record;\n    end Doubly_Linked_List;\n "}, {"sha": "f9e92134e32db8c7ff358852173b6bb4b55b51d6", "filename": "gcc/ada/libgnat/g-sets.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-sets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-sets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sets.adb?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -68,6 +68,16 @@ package body GNAT.Sets is\n       -- Destroy --\n       -------------\n \n+      procedure Destroy (B : in out Boolean) is\n+         pragma Unreferenced (B);\n+      begin\n+         null;\n+      end Destroy;\n+\n+      -------------\n+      -- Destroy --\n+      -------------\n+\n       procedure Destroy (S : in out Instance) is\n       begin\n          Hashed_Set.Destroy (Hashed_Set.Instance (S));\n@@ -118,6 +128,24 @@ package body GNAT.Sets is\n          Hashed_Set.Next (Hashed_Set.Iterator (Iter), Elem);\n       end Next;\n \n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (S : Instance) return Boolean is\n+      begin\n+         return Hashed_Set.Present (Hashed_Set.Instance (S));\n+      end Present;\n+\n+      -----------\n+      -- Reset --\n+      -----------\n+\n+      procedure Reset (S : Instance) is\n+      begin\n+         Hashed_Set.Reset (Hashed_Set.Instance (S));\n+      end Reset;\n+\n       ----------\n       -- Size --\n       ----------"}, {"sha": "43610af2e403a814379052a7b9bb66fc084718f8", "filename": "gcc/ada/libgnat/g-sets.ads", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-sets.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a428808e775ed9f52d9ae738b366acdbd361c19/gcc%2Fada%2Flibgnat%2Fg-sets.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sets.ads?ref=5a428808e775ed9f52d9ae738b366acdbd361c19", "patch": "@@ -42,8 +42,8 @@ package GNAT.Sets is\n    --  The following package offers a membership set abstraction with the\n    --  following characteristics:\n    --\n-   --    * Creation of multiple instances, of different sizes.\n-   --    * Iterable elements.\n+   --    * Creation of multiple instances, of different sizes\n+   --    * Iterable elements\n    --\n    --  The following use pattern must be employed with this set:\n    --\n@@ -103,6 +103,14 @@ package GNAT.Sets is\n       function Is_Empty (S : Instance) return Boolean;\n       --  Determine whether set S is empty\n \n+      function Present (S : Instance) return Boolean;\n+      --  Determine whether set S exists\n+\n+      procedure Reset (S : Instance);\n+      --  Destroy the contents of membership set S, and reset it to its initial\n+      --  created state. This action will raise Iterated if the membership set\n+      --  has outstanding iterators.\n+\n       function Size (S : Instance) return Natural;\n       --  Obtain the number of elements in membership set S\n \n@@ -141,6 +149,9 @@ package GNAT.Sets is\n       --  raises Iterator_Exhausted.\n \n    private\n+      procedure Destroy (B : in out Boolean);\n+      --  Destroy boolean B\n+\n       package Hashed_Set is new Dynamic_HTable\n         (Key_Type              => Element_Type,\n          Value_Type            => Boolean,\n@@ -150,6 +161,7 @@ package GNAT.Sets is\n          Compression_Threshold => 0.3,\n          Compression_Factor    => 2,\n          \"=\"                   => \"=\",\n+         Destroy_Value         => Destroy,\n          Hash                  => Hash);\n \n       type Instance is new Hashed_Set.Instance;"}]}