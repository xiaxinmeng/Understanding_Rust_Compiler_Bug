{"sha": "9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE2MzFlOGU5NGZhNTFlMTMyZjdjNmM2ZDZjMjA5OGNjNjhjNTUxOA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-25T01:51:43Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-25T01:51:43Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r832", "tree": {"sha": "a934b7089f99f5698e0d2c77ab9e66938e5679e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a934b7089f99f5698e0d2c77ab9e66938e5679e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/comments", "author": null, "committer": null, "parents": [{"sha": "c53a8ab63a01bb24b6139345144f93a8abd5b05b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53a8ab63a01bb24b6139345144f93a8abd5b05b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c53a8ab63a01bb24b6139345144f93a8abd5b05b"}], "stats": {"total": 1393, "additions": 847, "deletions": 546}, "files": [{"sha": "a59a2260d724989f9aa65ad5a172065cb216df33", "filename": "gcc/c-common.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "patch": "@@ -165,8 +165,7 @@ decl_attributes (decl, attributes)\n \t  if (!strcmp (specified_name, GET_MODE_NAME (i)))\n \t    {\n \t      tree type\n-\t\t= type_for_size (GET_MODE_BITSIZE (i),\n-\t\t\t\t TREE_UNSIGNED (TREE_TYPE (decl)));\n+\t\t= type_for_mode (i, TREE_UNSIGNED (TREE_TYPE (decl)));\n \t      if (type != 0)\n \t\t{\n \t\t  TREE_TYPE (decl) = type;\n@@ -175,6 +174,7 @@ decl_attributes (decl, attributes)\n \t\t}\n \t      else\n \t\terror (\"no data type for mode `%s'\", specified_name);\n+\t      break;\n \t    }\n \tif (i == NUM_MACHINE_MODES)\n \t  error (\"unknown machine mode `%s'\", specified_name);\n@@ -187,12 +187,12 @@ decl_attributes (decl, attributes)\n \t\t    * BITS_PER_UNIT;\n \t\n \tif (exact_log2 (align) == -1)\n-\t  warning_with_decl (decl,\n-\t\t\t\"requested alignment of `%s' is not a power of 2\");\n+\t  error_with_decl (decl,\n+\t\t\t   \"requested alignment of `%s' is not a power of 2\");\n \telse if (TREE_CODE (decl) != VAR_DECL\n \t\t && TREE_CODE (decl) != FIELD_DECL)\n-\t  warning_with_decl (decl,\n-\t\t\"alignment specified for `%s' which is not a variable\");\n+\t  error_with_decl (decl,\n+\t\t\t   \"alignment specified for `%s', not a variable\");\n \telse\n \t  DECL_ALIGN (decl) = align;\n       }\n@@ -208,8 +208,8 @@ decl_attributes (decl, attributes)\n \t\n \tif (TREE_CODE (decl) != FUNCTION_DECL)\n \t  {\n-\t    warning_with_decl (decl,\n-\t\t\"argument format specified for non-function `%s'\");\n+\t    error_with_decl (decl,\n+\t\t\t     \"argument format specified for non-function `%s'\");\n \t    return;\n \t  }\n \t\n@@ -219,13 +219,13 @@ decl_attributes (decl, attributes)\n \t  is_scan = 1;\n \telse\n \t  {\n-\t    warning_with_decl (decl,\"unrecognized format specifier for `%s'\");\n+\t    error_with_decl (decl, \"unrecognized format specifier for `%s'\");\n \t    return;\n \t  }\n \t\n \tif (first_arg_num != 0 && first_arg_num <= format_num)\n \t  {\n-\t    warning_with_decl (decl,\n+\t    error_with_decl (decl,\n \t\t\"format string arg follows the args to be formatted, for `%s'\");\n \t    return;\n \t  }"}, {"sha": "3ff0f82efd6e11ef568b5b77b894b31ba503df6e", "filename": "gcc/dwarf.h", "status": "modified", "additions": 291, "deletions": 237, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fdwarf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fdwarf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf.h?ref=9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "patch": "@@ -1,227 +1,277 @@\n-/* Dwarf definitions.\n+/* Declarations and definitions of codes relating to the DWARF symbolic\n+   debugging information format.\n \n-   This file is derived from the DWARF specification, Draft #5 by the UNIX\n-   International Programming Languages Special Interest Group dated 10/21/91.\n-*/\n+   Written by Ron Guilmette (rfg@ncd.com)\n \n-/* Tag names and codes: Figure 9.  */\n-\n-#define TAG_padding\t\t\t0x0000\n-#define TAG_array_type\t\t\t0x0001\n-#define TAG_class_type\t\t\t0x0002\n-#define TAG_entry_point\t\t\t0x0003\n-#define TAG_enumeration_type\t\t0x0004\n-#define TAG_formal_parameter\t\t0x0005\n-#define TAG_global_subroutine\t\t0x0006\n-#define TAG_global_variable\t\t0x0007\n-#define TAG_imported_declaration\t0x0008\n-\n-#define TAG_label\t\t\t0x000a\n-#define TAG_lexical_block\t\t0x000b\n-#define TAG_local_variable\t\t0x000c\n-#define TAG_member\t\t\t0x000d\n-\n-#define TAG_pointer_type\t\t0x000f\n-#define TAG_reference_type\t\t0x0010\n-#define TAG_compile_unit\t\t0x0011\n-#define TAG_source_file\t\t\t0x0011\n-#define TAG_string_type\t\t\t0x0012\n-#define TAG_structure_type\t\t0x0013\n-#define TAG_subroutine\t\t\t0x0014\n-#define TAG_subroutine_type\t\t0x0015\n-#define TAG_typedef\t\t\t0x0016\n-#define TAG_union_type\t\t\t0x0017\n-#define TAG_unspecified_parameters\t0x0018\n-#define TAG_variant\t\t\t0x0019\n-#define TAG_common_block\t\t0x001a\n-#define TAG_common_inclusion\t\t0x001b\n-#define TAG_format\t\t\t0x001c\n-#define TAG_inheritance\t\t\t0x001d\n-#define TAG_inlined_subroutine\t\t0x001e\n-#define TAG_module\t\t\t0x001f\n-#define TAG_ptr_to_member_type\t\t0x0020\n-#define TAG_set_type\t\t\t0x0021\n-#define TAG_subrange_type\t\t0x0022\n-#define TAG_with_stmt\t\t\t0x0023\n-\n-#define TAG_lo_user\t\t\t0x8000\n-#define TAG_hi_user\t\t\t0xffff\n-\n-/* Form names and codes: Figure 10.  */\n-\n-#define FORM_ADDR\t0x1\n-#define FORM_REF\t0x2\n-#define FORM_BLOCK2\t0x3\n-#define FORM_BLOCK4\t0x4\n-#define FORM_DATA2\t0x5\n-#define FORM_DATA4\t0x6\n-#define FORM_DATA8\t0x7\n-#define FORM_STRING\t0x8\n-\n-/* Attribute names and codes: Figure 11.  */\n-\n-#define AT_sibling\t\t/* reference */\t(0x0010|FORM_REF)\n-#define AT_location\t\t/* block2 */\t(0x0020|FORM_BLOCK2)\n-#define AT_name\t\t\t/* string */\t(0x0030|FORM_STRING)\n-#define AT_fund_type\t\t/* halfword */\t(0x0050|FORM_DATA2)\n-#define AT_mod_fund_type\t/* block2 */\t(0x0060|FORM_BLOCK2)\n-#define AT_user_def_type\t/* reference */\t(0x0070|FORM_REF)\n-#define AT_mod_u_d_type\t\t/* block2 */\t(0x0080|FORM_BLOCK2)\n-#define AT_ordering\t\t/* halfword */\t(0x0090|FORM_DATA2)\n-#define AT_subscr_data\t\t/* block2 */\t(0x00a0|FORM_BLOCK2)\n-#define AT_byte_size\t\t/* word */\t(0x00b0|FORM_DATA4)\n-#define AT_bit_offset\t\t/* halfword */\t(0x00c0|FORM_DATA2)\n-#define AT_bit_size\t\t/* word */\t(0x00d0|FORM_DATA4)\n-\n-#define AT_element_list\t\t/* block4 */\t(0x00f0|FORM_BLOCK4)\n-#define AT_stmt_list\t\t/* word */\t(0x0100|FORM_DATA4)\n-#define AT_low_pc\t\t/* address */\t(0x0110|FORM_ADDR)\n-#define AT_high_pc\t\t/* address */\t(0x0120|FORM_ADDR)\n-#define AT_language\t\t/* word */\t(0x0130|FORM_DATA4)\n-#define AT_member\t\t/* reference */\t(0x0140|FORM_REF)\n-#define AT_discr\t\t/* reference */\t(0x0150|FORM_REF)\n-#define AT_discr_value\t\t/* block2 */\t(0x0160|FORM_BLOCK2)\n-#define AT_visibility\t\t/* halfword */\t(0x0170|FORM_DATA2)\n-#define AT_import\t\t/* reference */\t(0x0180|FORM_REF)\n-#define AT_string_length\t/* block2 */\t(0x0190|FORM_BLOCK2)\n-#define AT_common_reference\t/* reference */\t(0x01a0|FORM_REF)\n-#define AT_comp_dir\t\t/* string */\t(0x01b0|FORM_STRING)\n-\n-#define AT_const_value_string\t/* string */\t(0x01c0|FORM_STRING)\n-#define AT_const_value_data2\t/* halfword */\t(0x01c0|FORM_DATA2)\n-#define AT_const_value_data4\t/* word */\t(0x01c0|FORM_DATA4)\n-#define AT_const_value_data8\t/* doubleword */(0x01c0|FORM_DATA8)\n-#define AT_const_value_block2\t/* block2 */\t(0x01c0|FORM_BLOCK2)\n-#define AT_const_value_block4\t/* block4 */\t(0x01c0|FORM_BLOCK4)\n-\n-#define AT_containing_type\t/* reference */\t(0x01d0|FORM_REF)\n-\n-#define AT_default_value_addr\t/* address */\t(0x01e0|FORM_ADDR)\n-#define AT_default_value_data2\t/* halfword */\t(0x01e0|FORM_DATA2)\n-#define AT_default_value_data4\t/* word */\t(0x01e0|FORM_DATA4)\n-#define AT_default_value_data8\t/* doubleword */(0x01e0|FORM_DATA8)\n-#define AT_default_value_string\t/* string */\t(0x01e0|FORM_STRING)\n-\n-#define AT_friends\t\t/* block2 */\t(0x01f0|FORM_BLOCK2)\n-#define AT_inline\t\t/* string */\t(0x0200|FORM_STRING)\n-#define AT_is_optional\t\t/* string */\t(0x0210|FORM_STRING)\n-\n-#define AT_lower_bound_ref\t/* reference */\t(0x0220|FORM_REF)\n-#define AT_lower_bound_data2\t/* halfword */\t(0x0220|FORM_DATA2)\n-#define AT_lower_bound_data4\t/* word */\t(0x0220|FORM_DATA4)\n-#define AT_lower_bound_data8\t/* doubleword */(0x0220|FORM_DATA8)\n-\n-#define AT_main_program\t\t/* string */\t(0x0230|FORM_STRING)\n-#define AT_private\t\t/* string */\t(0x0240|FORM_STRING)\n-#define AT_producer\t\t/* string */\t(0x0250|FORM_STRING)\n-#define AT_protected\t\t/* string */\t(0x0260|FORM_STRING)\n-#define AT_prototyped\t\t/* string */\t(0x0270|FORM_STRING)\n-#define AT_public\t\t/* string */\t(0x0280|FORM_STRING)\n-#define AT_pure_virtual\t\t/* string */\t(0x0290|FORM_STRING)\n-#define AT_return_addr_loc\t/* block2 */\t(0x02a0|FORM_BLOCK2)\n-#define AT_specification\t/* reference */\t(0x02b0|FORM_REF)\n-#define AT_start_scope\t\t/* word */\t(0x02c0|FORM_DATA4)\n-#define AT_static_link_loc\t/* block2 */\t(0x02d0|FORM_BLOCK2)\n-#define AT_stride_size\t\t/* word */\t(0x02e0|FORM_DATA4)\n-\n-#define AT_upper_bound_ref\t/* reference */\t(0x02f0|FORM_REF)\n-#define AT_upper_bound_data2\t/* halfword */\t(0x02f0|FORM_DATA2)\n-#define AT_upper_bound_data4\t/* word */\t(0x02f0|FORM_DATA4)\n-#define AT_upper_bound_data8\t/* doubleword */(0x02f0|FORM_DATA8)\n-\n-#define AT_virtual\t\t/* string */\t(0x0300|FORM_STRING)\n-#define AT_frame_base\t\t/* block2 */\t(0x0310|FORM_BLOCK2)\n-\n-/* GNU attribute extensions.  */\n-\n-#define AT_sf_names\t\t/* word */\t(0x8000|FORM_DATA4)\n-#define AT_src_info\t\t/* word */\t(0x8010|FORM_DATA4)\n-#define AT_mac_info\t\t/* word */\t(0x8020|FORM_DATA4)\n-\n-#define AT_lo_user\t\t/* - */\t\t0x8000\n-#define AT_hi_user\t\t/* - */\t\t0xffff\n-\n-/* Location atom names and codes: Figure 13.  */\n-\n-#define OP_REG\t\t0x01\n-#define OP_BASEREG\t0x02\n-#define OP_ADDR\t\t0x03\n-#define OP_CONST\t0x04\n-#define OP_DEREF2\t0x05\n-#define OP_DEREF4\t0x06\n-#define OP_ADD\t\t0x07\n-   \n-#define OP_LO_USER\t0x80\n-#define OP_HI_USER\t0xff\n-\n-/* Fundamental type names and codes: figure 14.  */\n-\n-#define FT_char\t\t\t0x0001\n-#define FT_signed_char\t\t0x0002\n-#define FT_unsigned_char\t0x0003\n-#define FT_short\t\t0x0004\n-#define FT_signed_short\t\t0x0005\n-#define FT_unsigned_short\t0x0006\n-#define FT_integer\t\t0x0007\n-#define FT_signed_integer\t0x0008\n-#define FT_unsigned_integer\t0x0009\n-#define FT_long\t\t\t0x000a\n-#define FT_signed_long\t\t0x000b\n-#define FT_unsigned_long\t0x000c\n-#define FT_pointer\t\t0x000d\n-#define FT_float\t\t0x000e\n-#define FT_dbl_prec_float\t0x000f\n-#define FT_ext_prec_float\t0x0010\t/* not accepted by \"classic\" svr4 SDB */\n-#define FT_complex\t\t0x0011\t/* not accepted by \"classic\" svr4 SDB */\n-#define FT_dbl_prec_complex\t0x0012\t/* not accepted by \"classic\" svr4 SDB */\n-\n-#define FT_void\t\t\t0x0014\n-#define FT_boolean\t\t0x0015\t/* not accepted by \"classic\" svr4 SDB */\n-#define FT_ext_prec_complex\t0x0016\t/* not accepted by \"classic\" svr4 SDB */\n-  \n-/* GNU-specific fundamental type codes - not accepted by \"classic\" svr4 SDB */\n+Copyright (C) 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This file is derived from the DWARF specification (a public document)\n+   Revision 1.0.1 (April 8, 1992) developed by the UNIX International\n+   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n+   by UNIX International.  Copies of this specification are available from\n+   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n+*/\n \n-#define FT_long_long\t\t0x8000\n-#define FT_signed_long_long\t0x8001\n-#define FT_unsigned_long_long\t0x8002\n+/* Tag names and codes.  */\n+\n+enum dwarf_tag {\n+    TAG_padding\t\t\t= 0x0000,\n+    TAG_array_type\t\t= 0x0001,\n+    TAG_class_type\t\t= 0x0002,\n+    TAG_entry_point\t\t= 0x0003,\n+    TAG_enumeration_type\t= 0x0004,\n+    TAG_formal_parameter\t= 0x0005,\n+    TAG_global_subroutine\t= 0x0006,\n+    TAG_global_variable\t\t= 0x0007,\n+    \t\t\t\t/* 0x0008 -- reserved */\n+\t\t\t\t/* 0x0009 -- reserved */\n+    TAG_label\t\t\t= 0x000a,\n+    TAG_lexical_block\t\t= 0x000b,\n+    TAG_local_variable\t\t= 0x000c,\n+    TAG_member\t\t\t= 0x000d,\n+\t\t\t\t/* 0x000e -- reserved */\n+    TAG_pointer_type\t\t= 0x000f,\n+    TAG_reference_type\t\t= 0x0010,\n+    TAG_compile_unit\t\t= 0x0011,\n+    TAG_string_type\t\t= 0x0012,\n+    TAG_structure_type\t\t= 0x0013,\n+    TAG_subroutine\t\t= 0x0014,\n+    TAG_subroutine_type\t\t= 0x0015,\n+    TAG_typedef\t\t\t= 0x0016,\n+    TAG_union_type\t\t= 0x0017,\n+    TAG_unspecified_parameters\t= 0x0018,\n+    TAG_variant\t\t\t= 0x0019,\n+    TAG_common_block\t\t= 0x001a,\n+    TAG_common_inclusion\t= 0x001b,\n+    TAG_inheritance\t\t= 0x001c,\n+    TAG_inlined_subroutine\t= 0x001d,\n+    TAG_module\t\t\t= 0x001e,\n+    TAG_ptr_to_member_type\t= 0x001f,\n+    TAG_set_type\t\t= 0x0020,\n+    TAG_subrange_type\t\t= 0x0021,\n+    TAG_with_stmt\t\t= 0x0022,\n+\n+    /* GNU extensions */\n+\n+    TAG_format_label\t\t= 0x8000,  /* for FORTRAN 77 and Fortran 90 */\n+    TAG_namelist\t\t= 0x8001,  /* For Fortran 90 */\n+    TAG_function_template\t= 0x8002,  /* for C++ */\n+    TAG_class_template\t\t= 0x8003   /* for C++ */\n+};\n+\n+#define TAG_lo_user\t0x8000  /* implementation-defined range start */\n+#define TAG_hi_user\t0xffff  /* implementation-defined range end */\n+#define TAG_source_file TAG_compile_unit  /* for backward compatability */\n+\n+/* Form names and codes.  */\n+\n+enum dwarf_form {\n+    FORM_ADDR\t= 0x1,\n+    FORM_REF\t= 0x2,\n+    FORM_BLOCK2\t= 0x3,\n+    FORM_BLOCK4\t= 0x4,\n+    FORM_DATA2\t= 0x5,\n+    FORM_DATA4\t= 0x6,\n+    FORM_DATA8\t= 0x7,\n+    FORM_STRING\t= 0x8\n+};\n+\n+/* Attribute names and codes.  */\n+\n+enum dwarf_attribute {\n+    AT_sibling\t\t\t= (0x0010|FORM_REF),\n+    AT_location\t\t\t= (0x0020|FORM_BLOCK2),\n+    AT_name\t\t\t= (0x0030|FORM_STRING),\n+    AT_fund_type\t\t= (0x0050|FORM_DATA2),\n+    AT_mod_fund_type\t\t= (0x0060|FORM_BLOCK2),\n+    AT_user_def_type\t\t= (0x0070|FORM_REF),\n+    AT_mod_u_d_type\t\t= (0x0080|FORM_BLOCK2),\n+    AT_ordering\t\t\t= (0x0090|FORM_DATA2),\n+    AT_subscr_data\t\t= (0x00a0|FORM_BLOCK2),\n+    AT_byte_size\t\t= (0x00b0|FORM_DATA4),\n+    AT_bit_offset\t\t= (0x00c0|FORM_DATA2),\n+    AT_bit_size\t\t\t= (0x00d0|FORM_DATA4),\n+\t\t\t\t/* (0x00e0|FORM_xxxx) -- reserved */\n+    AT_element_list\t\t= (0x00f0|FORM_BLOCK4),\n+    AT_stmt_list\t\t= (0x0100|FORM_DATA4),\n+    AT_low_pc\t\t\t= (0x0110|FORM_ADDR),\n+    AT_high_pc\t\t\t= (0x0120|FORM_ADDR),\n+    AT_language\t\t\t= (0x0130|FORM_DATA4),\n+    AT_member\t\t\t= (0x0140|FORM_REF),\n+    AT_discr\t\t\t= (0x0150|FORM_REF),\n+    AT_discr_value\t\t= (0x0160|FORM_BLOCK2),\n+\t\t\t\t/* (0x0170|FORM_xxxx) -- reserved */\n+\t\t\t\t/* (0x0180|FORM_xxxx) -- reserved */\n+    AT_string_length\t\t= (0x0190|FORM_BLOCK2),\n+    AT_common_reference\t\t= (0x01a0|FORM_REF),\n+    AT_comp_dir\t\t\t= (0x01b0|FORM_STRING),\n+        AT_const_value_string\t= (0x01c0|FORM_STRING),\n+        AT_const_value_data2\t= (0x01c0|FORM_DATA2),\n+        AT_const_value_data4\t= (0x01c0|FORM_DATA4),\n+        AT_const_value_data8\t= (0x01c0|FORM_DATA8),\n+        AT_const_value_block2\t= (0x01c0|FORM_BLOCK2),\n+        AT_const_value_block4\t= (0x01c0|FORM_BLOCK4),\n+    AT_containing_type\t\t= (0x01d0|FORM_REF),\n+        AT_default_value_addr\t= (0x01e0|FORM_ADDR),\n+        AT_default_value_data2\t= (0x01e0|FORM_DATA2),\n+        AT_default_value_data4\t= (0x01e0|FORM_DATA4),\n+        AT_default_value_data8\t= (0x01e0|FORM_DATA8),\n+        AT_default_value_string\t= (0x01e0|FORM_STRING),\n+    AT_friends\t\t\t= (0x01f0|FORM_BLOCK2),\n+    AT_inline\t\t\t= (0x0200|FORM_STRING),\n+    AT_is_optional\t\t= (0x0210|FORM_STRING),\n+        AT_lower_bound_ref\t= (0x0220|FORM_REF),\n+        AT_lower_bound_data2\t= (0x0220|FORM_DATA2),\n+        AT_lower_bound_data4\t= (0x0220|FORM_DATA4),\n+        AT_lower_bound_data8\t= (0x0220|FORM_DATA8),\n+    AT_private\t\t\t= (0x0230|FORM_STRING),\n+    AT_producer\t\t\t= (0x0240|FORM_STRING),\n+    AT_program\t\t\t= (0x0250|FORM_STRING),\n+    AT_protected\t\t= (0x0260|FORM_STRING),\n+    AT_prototyped\t\t= (0x0270|FORM_STRING),\n+    AT_public\t\t\t= (0x0280|FORM_STRING),\n+    AT_pure_virtual\t\t= (0x0290|FORM_STRING),\n+    AT_return_addr\t\t= (0x02a0|FORM_BLOCK2),\n+    AT_specification\t\t= (0x02b0|FORM_REF),\n+    AT_start_scope\t\t= (0x02c0|FORM_DATA4),\n+    AT_stride_size\t\t= (0x02d0|FORM_DATA4),\n+        AT_upper_bound_ref\t= (0x02e0|FORM_REF),\n+        AT_upper_bound_data2\t= (0x02e0|FORM_DATA2),\n+        AT_upper_bound_data4\t= (0x02e0|FORM_DATA4),\n+        AT_upper_bound_data8\t= (0x02e0|FORM_DATA8),\n+    AT_virtual\t\t\t= (0x02f0|FORM_STRING),\n+\n+    /* GNU extensions.  */\n+\n+    AT_sf_names\t\t\t= (0x8000|FORM_DATA4),\n+    AT_src_info\t\t\t= (0x8010|FORM_DATA4),\n+    AT_mac_info\t\t\t= (0x8020|FORM_DATA4),\n+    AT_src_coords\t\t= (0x8030|FORM_DATA4)\n+};\n+\n+#define AT_lo_user\t0x8000  /* implementation-defined range start */\n+#define AT_hi_user\t0xffff  /* implementation-defined range end */\n+\n+/* Location atom names and codes.  */\n+\n+enum dwarf_location_atom {\n+    OP_REG\t= 0x01,\n+    OP_BASEREG\t= 0x02,\n+    OP_ADDR\t= 0x03,\n+    OP_CONST\t= 0x04,\n+    OP_DEREF2\t= 0x05,\n+    OP_DEREF4\t= 0x06,\n+    OP_ADD\t= 0x07\n+};\n+\n+#define OP_LO_USER\t0x80  /* implementation-defined range start */\n+#define OP_HI_USER\t0xff  /* implementation-defined range end */\n+\n+/* Fundamental type names and codes.  */\n+\n+enum dwarf_fundamental_type {\n+    FT_char\t\t= 0x0001,\n+    FT_signed_char\t= 0x0002,\n+    FT_unsigned_char\t= 0x0003,\n+    FT_short\t\t= 0x0004,\n+    FT_signed_short\t= 0x0005,\n+    FT_unsigned_short\t= 0x0006,\n+    FT_integer\t\t= 0x0007,\n+    FT_signed_integer\t= 0x0008,\n+    FT_unsigned_integer\t= 0x0009,\n+    FT_long\t\t= 0x000a,\n+    FT_signed_long\t= 0x000b,\n+    FT_unsigned_long\t= 0x000c,\n+    FT_pointer\t\t= 0x000d,  /* an alias for (void *) */\n+    FT_float\t\t= 0x000e,\n+    FT_dbl_prec_float\t= 0x000f,\n+    FT_ext_prec_float\t= 0x0010,  /* breaks \"classic\" svr4 SDB */\n+    FT_complex\t\t= 0x0011,  /* breaks \"classic\" svr4 SDB */\n+    FT_dbl_prec_complex\t= 0x0012,  /* breaks \"classic\" svr4 SDB */\n+\t\t\t/* 0x0013 -- reserved */\n+    FT_void\t\t= 0x0014,\n+    FT_boolean\t\t= 0x0015,  /* breaks \"classic\" svr4 SDB */\n+    FT_ext_prec_complex\t= 0x0016,  /* breaks \"classic\" svr4 SDB */\n+    FT_label\t\t= 0x0017,\n   \n-#define FT_lo_user\t\t0x8000\n-#define FT_hi_user\t\t0xffff\n-\n-/* Type modifier names and codes: Figure 15.  */\n-\n-#define MOD_pointer_to\t\t0x01\n-#define MOD_reference_to\t0x02\n-#define MOD_const\t\t0x03\n-#define MOD_volatile\t\t0x04\n-     \n-#define MOD_lo_user\t\t0x80\n-#define MOD_hi_user\t\t0xff\n-     \n-/* Visibility names and codes: Figure 16.  */\n-     \n-#define VIS_local\t\t0x00\n-#define VIS_exported\t\t0x01\n-     \n-#define VIS_lo_user\t\t0x80\n-#define VIS_hi_user\t\t0xff\n-\n-/* Array ordering names and codes: Figure 18.  */\n-\n-#define ORD_row_major\t0\n-#define ORD_col_major\t1\n-\n-/* Array subscript format names and codes: Figure 19.  */\n-\n-#define FMT_FT_C_C\t0x0\n-#define FMT_FT_C_X\t0x1\n-#define FMT_FT_X_C\t0x2\n-#define FMT_FT_X_X\t0x3\n-#define FMT_UT_C_C\t0x4\n-#define FMT_UT_C_X\t0x5\n-#define FMT_UT_X_C\t0x6\n-#define FMT_UT_X_X\t0x7\n-#define FMT_ET\t\t0x8\n+    /* GNU extensions\n+       The low order byte must indicate the size (in bytes) for the type.\n+       All of these types will probably break \"classic\" svr4 SDB */\n+\n+    FT_long_long\t= 0x8008,\n+    FT_signed_long_long\t= 0x8108,\n+    FT_unsigned_long_long = 0x8208,\n+\n+    FT_int8\t\t= 0x9001,\n+    FT_signed_int8\t= 0x9101,\n+    FT_unsigned_int8\t= 0x9201,\n+    FT_int16\t\t= 0x9302,\n+    FT_signed_int16\t= 0x9402,\n+    FT_unsigned_int16\t= 0x9502,\n+    FT_int32\t\t= 0x9604,\n+    FT_signed_int32\t= 0x9704,\n+    FT_unsigned_int32\t= 0x9804,\n+    FT_int64\t\t= 0x9908,\n+    FT_signed_int64\t= 0x9a08,\n+    FT_unsigned_int64\t= 0x9b08,\n+\n+    FT_real32\t\t= 0xa004,\n+    FT_real64\t\t= 0xa108,\n+    FT_real96\t\t= 0xa20c,\n+    FT_real128\t\t= 0xa310\n+};\n+\n+#define FT_lo_user\t0x8000  /* implementation-defined range start */\n+#define FT_hi_user\t0xffff  /* implementation defined range end */\n+\n+/* Type modifier names and codes.  */\n+\n+enum dwarf_type_modifier {\n+    MOD_pointer_to\t= 0x01,\n+    MOD_reference_to\t= 0x02,\n+    MOD_const\t\t= 0x03,\n+    MOD_volatile\t= 0x04\n+};\n+\n+#define MOD_lo_user\t0x80  /* implementation-defined range start */\n+#define MOD_hi_user\t0xff  /* implementation-defined range end */\n+\n+/* Array ordering names and codes.  */\n+\n+enum dwarf_array_dim_ordering {\n+    ORD_row_major\t= 0,\n+    ORD_col_major\t= 1\n+};\n+\n+/* Array subscript format names and codes.  */\n+\n+enum dwarf_subscr_data_formats {\n+    FMT_FT_C_C\t= 0x0,\n+    FMT_FT_C_X\t= 0x1,\n+    FMT_FT_X_C\t= 0x2,\n+    FMT_FT_X_X\t= 0x3,\n+    FMT_UT_C_C\t= 0x4,\n+    FMT_UT_C_X\t= 0x5,\n+    FMT_UT_X_C\t= 0x6,\n+    FMT_UT_X_X\t= 0x7,\n+    FMT_ET\t= 0x8\n+};\n \n /* Derived from above for ease of use.  */\n \n@@ -230,25 +280,29 @@\n   | ((_UB_CONST_P) ? 0 : 2)\t\t\\\n   | ((_LB_CONST_P) ? 0 : 1))\n \n-/* Source language names and codes: Figure 17.  */\n+/* Source language names and codes.  */\n \n-#define LANG_C89\t\t0x0001\n-#define LANG_C\t\t\t0x0002\n-#define LANG_ADA83\t\t0x0003\n-#define LANG_C_PLUS_PLUS\t0x0004\n-#define LANG_COBOL74\t\t0x0005\n-#define LANG_COBOL85\t\t0x0006\n-#define LANG_FORTRAN77\t\t0x0007\n-#define LANG_FORTRAN90\t\t0x0008\n-#define LANG_PASCAL83\t\t0x0009\n-#define LANG_MODULA2\t\t0x000a\n+enum dwarf_source_language {\n+    LANG_C89\t\t= 0x00000001,\n+    LANG_C\t\t= 0x00000002,\n+    LANG_ADA83\t\t= 0x00000003,\n+    LANG_C_PLUS_PLUS\t= 0x00000004,\n+    LANG_COBOL74\t= 0x00000005,\n+    LANG_COBOL85\t= 0x00000006,\n+    LANG_FORTRAN77\t= 0x00000007,\n+    LANG_FORTRAN90\t= 0x00000008,\n+    LANG_PASCAL83\t= 0x00000009,\n+    LANG_MODULA2\t= 0x0000000a\n+};\n \n-#define LANG_LO_USER\t\t0x8000\n-#define LANG_HI_USER\t\t0xffff\n+#define LANG_lo_user\t0x00008000  /* implementation-defined range start */\n+#define LANG_hi_user\t0x0000ffff  /* implementation-defined range end */\n \n /* Names and codes for GNU \"macinfo\" extension.  */\n \n-#define MACINFO_start\t\t's'\n-#define MACINFO_resume\t\t'r'\n-#define MACINFO_define\t\t'd'\n-#define MACINFO_undef\t\t'u'\n+enum dwarf_macinfo_record_type {\n+    MACINFO_start\t= 's',\n+    MACINFO_resume\t= 'r',\n+    MACINFO_define\t= 'd',\n+    MACINFO_undef\t= 'u'\n+};"}, {"sha": "ad6750c5b056b0cf91558a755c0c31b057a631fd", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 530, "deletions": 273, "changes": 803, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "patch": "@@ -31,6 +31,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-config.h\"\n #include \"reload.h\"\n #include \"output.h\"\n+#include \"defaults.h\"\n \n /* #define NDEBUG 1 */\n #include <assert.h>\n@@ -55,8 +56,7 @@ extern time_t time ();\n #define strrchr rindex\n #endif\n \n-char *getpwd ();\n-\n+extern char *getpwd ();\n \n /* IMPORTANT NOTE: Please see the file README.DWARF for important details\n    regarding the GNU implementation of Dwarf.  */\n@@ -104,13 +104,6 @@ char *getpwd ();\n \n #define TYPE_USED_FOR_FUNCTION(tagged_type) (TYPE_SIZE (tagged_type) == 0)\n \n-#define BITFIELD_OFFSET_BITS(DECL) \\\n-  ((unsigned) TREE_INT_CST_LOW (DECL_FIELD_BITPOS (DECL)))\n-#define BITFIELD_OFFSET_UNITS(DECL) \\\n-  (BITFIELD_OFFSET_BITS(DECL) / (unsigned) BITS_PER_UNIT)\n-#define BITFIELD_OFFSET_WORDS_IN_UNITS(DECL) \\\n-  ((BITFIELD_OFFSET_BITS(DECL) / (unsigned) BITS_PER_WORD) * UNITS_PER_WORD)\n-\n extern int flag_traditional;\n extern char *version_string;\n extern char *language_string;\n@@ -318,12 +311,12 @@ static unsigned lookup_filename ();\n #ifndef UNALIGNED_INT_ASM_OP\n #define UNALIGNED_INT_ASM_OP\t\".4byte\"\n #endif\n+#ifndef ASM_BYTE_OP\n+#define ASM_BYTE_OP\t\t\".byte\"\n+#endif\n #ifndef DEF_ASM_OP\n #define DEF_ASM_OP\t\t\".set\"\n #endif\n-#ifndef ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\t\"\\t.byte\"\n-#endif\n \n /* Pseudo-ops for pushing the current section onto the section stack (and\n    simultaneously changing to a new section) and for poping back to the\n@@ -334,10 +327,10 @@ static unsigned lookup_filename ();\n    OK because we only use at most one level of the section stack herein.  */\n \n #ifndef PUSHSECTION_ASM_OP\n-#define PUSHSECTION_ASM_OP\t\"\\t.section\"\n+#define PUSHSECTION_ASM_OP\t\".section\"\n #endif\n #ifndef POPSECTION_ASM_OP\n-#define POPSECTION_ASM_OP\t\"\\t.previous\"\n+#define POPSECTION_ASM_OP\t\".previous\"\n #endif\n \n /* The default format used by the ASM_OUTPUT_PUSH_SECTION macro (see below)\n@@ -394,147 +387,157 @@ static unsigned lookup_filename ();\n    the -g options is used and DWARF_DEBUGGING_INFO is in effect.\n \n    If necessary, these may be overridden from within your tm.h file,\n-   but typically, you should never need to override these.  */\n+   but typically, you should never need to override these.\n+\n+   These labels have been hacked (temporarily) so that they all begin with\n+   a `.L' sequence so as to appease the sparc/svr4 assmebler (which needs\n+   to see .L at the start of a label in order to prevent that label from\n+   going into the linker symbol table).  When I get time, I'll have to\n+   fix this the right way so that we use ASM_GENERATE_INTERNAL_LABEL and\n+   ASM_OUTPUT_INTERNAL_LABEL throughout dwarfout.c, but that will require\n+   a rather massive set of changes.  For the moment, the following definitions\n+   out to produce the right results for all svr4 and svr3 assemblers. -- rfg\n+*/\n \n #ifndef TEXT_BEGIN_LABEL\n-#define TEXT_BEGIN_LABEL\t\"._text_b\"\n+#define TEXT_BEGIN_LABEL\t\".L_text_b\"\n #endif\n #ifndef TEXT_END_LABEL\n-#define TEXT_END_LABEL\t\t\"._text_e\"\n+#define TEXT_END_LABEL\t\t\".L_text_e\"\n #endif\n \n #ifndef DATA_BEGIN_LABEL\n-#define DATA_BEGIN_LABEL\t\"._data_b\"\n+#define DATA_BEGIN_LABEL\t\".L_data_b\"\n #endif\n #ifndef DATA_END_LABEL\n-#define DATA_END_LABEL\t\t\"._data_e\"\n+#define DATA_END_LABEL\t\t\".L_data_e\"\n #endif\n \n #ifndef DATA1_BEGIN_LABEL\n-#define DATA1_BEGIN_LABEL\t\"._data1_b\"\n+#define DATA1_BEGIN_LABEL\t\".L_data1_b\"\n #endif\n #ifndef DATA1_END_LABEL\n-#define DATA1_END_LABEL\t\t\"._data1_e\"\n+#define DATA1_END_LABEL\t\t\".L_data1_e\"\n #endif\n \n #ifndef RODATA_BEGIN_LABEL\n-#define RODATA_BEGIN_LABEL\t\"._rodata_b\"\n+#define RODATA_BEGIN_LABEL\t\".L_rodata_b\"\n #endif\n #ifndef RODATA_END_LABEL\n-#define RODATA_END_LABEL\t\"._rodata_e\"\n+#define RODATA_END_LABEL\t\".L_rodata_e\"\n #endif\n \n #ifndef RODATA1_BEGIN_LABEL\n-#define RODATA1_BEGIN_LABEL\t\"._rodata1_b\"\n+#define RODATA1_BEGIN_LABEL\t\".L_rodata1_b\"\n #endif\n #ifndef RODATA1_END_LABEL\n-#define RODATA1_END_LABEL\t\"._rodata1_e\"\n+#define RODATA1_END_LABEL\t\".L_rodata1_e\"\n #endif\n \n #ifndef BSS_BEGIN_LABEL\n-#define BSS_BEGIN_LABEL\t\t\"._bss_b\"\n+#define BSS_BEGIN_LABEL\t\t\".L_bss_b\"\n #endif\n #ifndef BSS_END_LABEL\n-#define BSS_END_LABEL\t\t\"._bss_e\"\n+#define BSS_END_LABEL\t\t\".L_bss_e\"\n #endif\n \n #ifndef LINE_BEGIN_LABEL\n-#define LINE_BEGIN_LABEL\t\"._line_b\"\n+#define LINE_BEGIN_LABEL\t\".L_line_b\"\n #endif\n #ifndef LINE_LAST_ENTRY_LABEL\n-#define LINE_LAST_ENTRY_LABEL\t\"._line_last\"\n+#define LINE_LAST_ENTRY_LABEL\t\".L_line_last\"\n #endif\n #ifndef LINE_END_LABEL\n-#define LINE_END_LABEL\t\t\"._line_e\"\n+#define LINE_END_LABEL\t\t\".L_line_e\"\n #endif\n \n #ifndef DEBUG_BEGIN_LABEL\n-#define DEBUG_BEGIN_LABEL\t\"._debug_b\"\n+#define DEBUG_BEGIN_LABEL\t\".L_debug_b\"\n #endif\n #ifndef SFNAMES_BEGIN_LABEL\n-#define SFNAMES_BEGIN_LABEL\t\"._sfnames_b\"\n+#define SFNAMES_BEGIN_LABEL\t\".L_sfnames_b\"\n #endif\n #ifndef SRCINFO_BEGIN_LABEL\n-#define SRCINFO_BEGIN_LABEL\t\"._srcinfo_b\"\n+#define SRCINFO_BEGIN_LABEL\t\".L_srcinfo_b\"\n #endif\n #ifndef MACINFO_BEGIN_LABEL\n-#define MACINFO_BEGIN_LABEL\t\"._macinfo_b\"\n+#define MACINFO_BEGIN_LABEL\t\".L_macinfo_b\"\n #endif\n \n #ifndef DIE_BEGIN_LABEL_FMT\n-#define DIE_BEGIN_LABEL_FMT\t\"._D%u\"\n+#define DIE_BEGIN_LABEL_FMT\t\".L_D%u\"\n #endif\n #ifndef DIE_END_LABEL_FMT\n-#define DIE_END_LABEL_FMT\t\"._D%u_e\"\n+#define DIE_END_LABEL_FMT\t\".L_D%u_e\"\n #endif\n #ifndef PUB_DIE_LABEL_FMT\n-#define PUB_DIE_LABEL_FMT\t\"._P%u\"\n+#define PUB_DIE_LABEL_FMT\t\".L_P%u\"\n #endif\n #ifndef INSN_LABEL_FMT\n-#define INSN_LABEL_FMT\t\t\"._I%u_%u\"\n+#define INSN_LABEL_FMT\t\t\".L_I%u_%u\"\n #endif\n #ifndef BLOCK_BEGIN_LABEL_FMT\n-#define BLOCK_BEGIN_LABEL_FMT\t\"._B%u\"\n+#define BLOCK_BEGIN_LABEL_FMT\t\".L_B%u\"\n #endif\n #ifndef BLOCK_END_LABEL_FMT\n-#define BLOCK_END_LABEL_FMT\t\"._B%u_e\"\n+#define BLOCK_END_LABEL_FMT\t\".L_B%u_e\"\n #endif\n #ifndef SS_BEGIN_LABEL_FMT\n-#define SS_BEGIN_LABEL_FMT\t\"._s%u\"\n+#define SS_BEGIN_LABEL_FMT\t\".L_s%u\"\n #endif\n #ifndef SS_END_LABEL_FMT\n-#define SS_END_LABEL_FMT\t\"._s%u_e\"\n+#define SS_END_LABEL_FMT\t\".L_s%u_e\"\n #endif\n #ifndef EE_BEGIN_LABEL_FMT\n-#define EE_BEGIN_LABEL_FMT\t\"._e%u\"\n+#define EE_BEGIN_LABEL_FMT\t\".L_e%u\"\n #endif\n #ifndef EE_END_LABEL_FMT\n-#define EE_END_LABEL_FMT\t\"._e%u_e\"\n+#define EE_END_LABEL_FMT\t\".L_e%u_e\"\n #endif\n #ifndef MT_BEGIN_LABEL_FMT\n-#define MT_BEGIN_LABEL_FMT\t\"._t%u\"\n+#define MT_BEGIN_LABEL_FMT\t\".L_t%u\"\n #endif\n #ifndef MT_END_LABEL_FMT\n-#define MT_END_LABEL_FMT\t\"._t%u_e\"\n+#define MT_END_LABEL_FMT\t\".L_t%u_e\"\n #endif\n #ifndef LOC_BEGIN_LABEL_FMT\n-#define LOC_BEGIN_LABEL_FMT\t\"._l%u\"\n+#define LOC_BEGIN_LABEL_FMT\t\".L_l%u\"\n #endif\n #ifndef LOC_END_LABEL_FMT\n-#define LOC_END_LABEL_FMT\t\"._l%u_e\"\n+#define LOC_END_LABEL_FMT\t\".L_l%u_e\"\n #endif\n #ifndef BOUND_BEGIN_LABEL_FMT\n-#define BOUND_BEGIN_LABEL_FMT\t\"._b%u_%u_%c\"\n+#define BOUND_BEGIN_LABEL_FMT\t\".L_b%u_%u_%c\"\n #endif\n #ifndef BOUND_END_LABEL_FMT\n-#define BOUND_END_LABEL_FMT\t\"._b%u_%u_%c_e\"\n+#define BOUND_END_LABEL_FMT\t\".L_b%u_%u_%c_e\"\n #endif\n #ifndef DERIV_BEGIN_LABEL_FMT\n-#define DERIV_BEGIN_LABEL_FMT\t\"._d%u\"\n+#define DERIV_BEGIN_LABEL_FMT\t\".L_d%u\"\n #endif\n #ifndef DERIV_END_LABEL_FMT\n-#define DERIV_END_LABEL_FMT\t\"._d%u_e\"\n+#define DERIV_END_LABEL_FMT\t\".L_d%u_e\"\n #endif\n #ifndef SL_BEGIN_LABEL_FMT\n-#define SL_BEGIN_LABEL_FMT\t\"._sl%u\"\n+#define SL_BEGIN_LABEL_FMT\t\".L_sl%u\"\n #endif\n #ifndef SL_END_LABEL_FMT\n-#define SL_END_LABEL_FMT\t\"._sl%u_e\"\n+#define SL_END_LABEL_FMT\t\".L_sl%u_e\"\n #endif\n #ifndef FUNC_END_LABEL_FMT\n-#define FUNC_END_LABEL_FMT\t\"._f%u_e\"\n+#define FUNC_END_LABEL_FMT\t\".L_f%u_e\"\n #endif\n #ifndef TYPE_NAME_FMT\n-#define TYPE_NAME_FMT\t\t\"._T%u\"\n+#define TYPE_NAME_FMT\t\t\".L_T%u\"\n #endif\n #ifndef LINE_CODE_LABEL_FMT\n-#define LINE_CODE_LABEL_FMT\t\"._LC%u\"\n+#define LINE_CODE_LABEL_FMT\t\".L_LC%u\"\n #endif\n #ifndef SFNAMES_ENTRY_LABEL_FMT\n-#define SFNAMES_ENTRY_LABEL_FMT\t\"._F%u\"\n+#define SFNAMES_ENTRY_LABEL_FMT\t\".L_F%u\"\n #endif\n #ifndef LINE_ENTRY_LABEL_FMT\n-#define LINE_ENTRY_LABEL_FMT\t\"._LE%u\"\n+#define LINE_ENTRY_LABEL_FMT\t\".L_LE%u\"\n #endif\n \f\n /* Definitions of defaults for various types of primitive assembly language\n@@ -553,7 +556,7 @@ static unsigned lookup_filename ();\n \n #ifndef ASM_OUTPUT_POP_SECTION\n #define ASM_OUTPUT_POP_SECTION(FILE) \\\n-  fprintf ((FILE), \"%s\\n\", POPSECTION_ASM_OP)\n+  fprintf ((FILE), \"\\t%s\\n\", POPSECTION_ASM_OP)\n #endif\n \n #ifndef ASM_OUTPUT_SOURCE_FILENAME\n@@ -593,38 +596,71 @@ static unsigned lookup_filename ();\n \n #ifndef ASM_OUTPUT_DWARF_TAG\n #define ASM_OUTPUT_DWARF_TAG(FILE,TAG)\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t0x%x\\t%s %s\\n\", UNALIGNED_SHORT_ASM_OP,\t\\\n-\t(unsigned) TAG, ASM_COMMENT_START, tag_name (TAG))\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t0x%x\",\t\t\t\t\t\\\n+\t\t     UNALIGNED_SHORT_ASM_OP, (unsigned) TAG);\t\t\\\n+    if (flag_verbose_asm)\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n+\t\t       ASM_COMMENT_START, dwarf_tag_name (TAG));\t\\\n+    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_ATTRIBUTE\n-#define ASM_OUTPUT_DWARF_ATTRIBUTE(FILE,ATTRIBUTE)\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t0x%x\\t%s %s\\n\", UNALIGNED_SHORT_ASM_OP,\t\\\n-\t(unsigned) ATTRIBUTE, ASM_COMMENT_START, attribute_name (ATTRIBUTE))\n+#define ASM_OUTPUT_DWARF_ATTRIBUTE(FILE,ATTR)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t0x%x\",\t\t\t\t\t\\\n+\t\t     UNALIGNED_SHORT_ASM_OP, (unsigned) ATTR);\t\t\\\n+    if (flag_verbose_asm)\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n+\t\t       ASM_COMMENT_START, dwarf_attr_name (ATTR));\t\\\n+    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_STACK_OP\n #define ASM_OUTPUT_DWARF_STACK_OP(FILE,OP)\t\t\t\t\\\n-  fprintf ((FILE), \"%s\\t0x%x\\t%s %s\\n\", ASM_BYTE_OP,\t\t\t\\\n-\t(unsigned) OP, ASM_COMMENT_START, stack_op_name (OP))\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"%s\\t0x%x\", ASM_BYTE_OP, (unsigned) OP);\t\t\\\n+    if (flag_verbose_asm)\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n+\t\t       ASM_COMMENT_START, dwarf_stack_op_name (OP));\t\\\n+    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_FUND_TYPE\n #define ASM_OUTPUT_DWARF_FUND_TYPE(FILE,FT)\t\t\t\t\\\n-  fprintf ((FILE), \"\\t%s\\t0x%x\\t%s %s\\n\", UNALIGNED_SHORT_ASM_OP,\t\\\n-\t(unsigned) FT, ASM_COMMENT_START, fundamental_type_name (FT))\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"\\t%s\\t0x%x\",\t\t\t\t\t\\\n+\t\t     UNALIGNED_SHORT_ASM_OP, (unsigned) FT);\t\t\\\n+    if (flag_verbose_asm)\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n+\t\t       ASM_COMMENT_START, dwarf_fund_type_name (FT));\t\\\n+    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_FMT_BYTE\n #define ASM_OUTPUT_DWARF_FMT_BYTE(FILE,FMT)\t\t\t\t\\\n-  fprintf ((FILE), \"%s\\t0x%x\\t%s %s\\n\", ASM_BYTE_OP,\t\t\t\\\n-\t(unsigned) FMT, ASM_COMMENT_START, format_byte_name (FMT))\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"%s\\t0x%x\", ASM_BYTE_OP, (unsigned) FMT);\t\t\\\n+    if (flag_verbose_asm)\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n+\t\t       ASM_COMMENT_START, dwarf_fmt_byte_name (FMT));\t\\\n+    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \n #ifndef ASM_OUTPUT_DWARF_TYPE_MODIFIER\n #define ASM_OUTPUT_DWARF_TYPE_MODIFIER(FILE,MOD)\t\t\t\\\n-  fprintf ((FILE), \"%s\\t0x%x\\t%s %s\\n\", ASM_BYTE_OP,\t\t\t\\\n-\t(unsigned) MOD, ASM_COMMENT_START, modifier_name (MOD))\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf ((FILE), \"%s\\t0x%x\", ASM_BYTE_OP, (unsigned) MOD);\t\t\\\n+    if (flag_verbose_asm)\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\t%s %s\",\t\t\t\t\t\\\n+\t\t       ASM_COMMENT_START, dwarf_typemod_name (MOD));\t\\\n+    fputc ('\\n', (FILE));\t\t\t\t\t\t\\\n+  } while (0)\n #endif\n \f\n #ifndef ASM_OUTPUT_DWARF_ADDR\n@@ -681,49 +717,6 @@ static unsigned lookup_filename ();\n   } while (0)\n #endif\n \n-/* choose a reasonable default for ASM_OUTPUT_ASCII, as that is what\n-   varasm.c does.  If the below is changed, please also change\n-   definition in varasm.c Both of these should be factored out, into a\n-   higher layer.  */\n-#ifndef ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    FILE *_hide_asm_out_file = MYFILE;\t\t\t\t\t      \\\n-    char *_hide_p = MYSTRING;\t\t\t\t\t\t      \\\n-    int _hide_thissize = MYLENGTH;\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      FILE *asm_out_file = _hide_asm_out_file;\t\t\t\t      \\\n-      char *p = _hide_p;\t\t\t\t\t\t      \\\n-      int thissize = _hide_thissize;\t\t\t\t\t      \\\n-      int i;\t\t\t\t\t\t\t\t      \\\n-      fprintf (asm_out_file, \"\\t.ascii \\\"\");\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-      for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n-\t{\t\t\t\t\t\t\t\t      \\\n-\t  register int c = p[i];\t\t\t\t\t      \\\n-\t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n-\t    putc ('\\\\', asm_out_file);\t\t\t\t\t      \\\n-\t  if (c >= ' ' && c < 0177)\t\t\t\t\t      \\\n-\t    putc (c, asm_out_file);\t\t\t\t\t      \\\n-\t  else\t\t\t\t\t\t\t\t      \\\n-\t    {\t\t\t\t\t\t\t\t      \\\n-\t      fprintf (asm_out_file, \"\\\\%o\", c);\t\t\t      \\\n-\t      /* After an octal-escape, if a digit follows,\t\t      \\\n-\t\t terminate one string constant and start another.\t      \\\n-\t\t The Vax assembler fails to stop reading the escape\t      \\\n-\t\t after three digits, so this is the only way we\t\t      \\\n-\t\t can get it to parse the data properly.  */\t\t      \\\n-\t      if (i < thissize - 1\t\t\t\t\t      \\\n-\t\t  && p[i + 1] >= '0' && p[i + 1] <= '9')\t\t      \\\n-\t\tfprintf (asm_out_file, \"\\\"\\n\\t.ascii \\\"\");\t\t      \\\n-\t  }\t\t\t\t\t\t\t\t      \\\n-\t}\t\t\t\t\t\t\t\t      \\\n-      fprintf (asm_out_file, \"\\\"\\n\");\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-  }\t\t\t\t\t\t\t\t\t      \\\n-  while (0)\n-#endif\n-\n #ifndef ASM_OUTPUT_DWARF_STRING\n #define ASM_OUTPUT_DWARF_STRING(FILE,P) \\\n   ASM_OUTPUT_ASCII ((FILE), P, strlen (P)+1)\n@@ -742,87 +735,133 @@ xstrdup (s)\n }\n \n static char *\n-tag_name (tag)\n+dwarf_tag_name (tag)\n      register unsigned tag;\n {\n   switch (tag)\n     {\n-    case TAG_padding:\t\treturn \"TAG_padding\";\n-    case TAG_array_type:\treturn \"TAG_array_type\";\n-    case TAG_class_type:\treturn \"TAG_class_type\";\n-    case TAG_entry_point:\treturn \"TAG_entry_point\";\n-    case TAG_enumeration_type:\treturn \"TAG_enumeration_type\";\n-    case TAG_formal_parameter:\treturn \"TAG_formal_parameter\";\n-    case TAG_global_subroutine:\treturn \"TAG_global_subroutine\";\n-    case TAG_global_variable:\treturn \"TAG_global_variable\";\n-    case TAG_imported_declaration:\treturn \"TAG_imported_declaration\";\n-    case TAG_label:\t\treturn \"TAG_label\";\n-    case TAG_lexical_block:\treturn \"TAG_lexical_block\";\n-    case TAG_local_variable:\treturn \"TAG_local_variable\";\n-    case TAG_member:\t\treturn \"TAG_member\";\n-    case TAG_pointer_type:\treturn \"TAG_pointer_type\";\n-    case TAG_reference_type:\treturn \"TAG_reference_type\";\n-    case TAG_compile_unit:\treturn \"TAG_compile_unit\";\n-    case TAG_string_type:\treturn \"TAG_string_type\";\n-    case TAG_structure_type:\treturn \"TAG_structure_type\";\n-    case TAG_subroutine:\treturn \"TAG_subroutine\";\n-    case TAG_subroutine_type:\treturn \"TAG_subroutine_type\";\n-    case TAG_typedef:\t\treturn \"TAG_typedef\";\n-    case TAG_union_type:\treturn \"TAG_union_type\";\n+    case TAG_padding:\t\t\treturn \"TAG_padding\";\n+    case TAG_array_type:\t\treturn \"TAG_array_type\";\n+    case TAG_class_type:\t\treturn \"TAG_class_type\";\n+    case TAG_entry_point:\t\treturn \"TAG_entry_point\";\n+    case TAG_enumeration_type:\t\treturn \"TAG_enumeration_type\";\n+    case TAG_formal_parameter:\t\treturn \"TAG_formal_parameter\";\n+    case TAG_global_subroutine:\t\treturn \"TAG_global_subroutine\";\n+    case TAG_global_variable:\t\treturn \"TAG_global_variable\";\n+    case TAG_label:\t\t\treturn \"TAG_label\";\n+    case TAG_lexical_block:\t\treturn \"TAG_lexical_block\";\n+    case TAG_local_variable:\t\treturn \"TAG_local_variable\";\n+    case TAG_member:\t\t\treturn \"TAG_member\";\n+    case TAG_pointer_type:\t\treturn \"TAG_pointer_type\";\n+    case TAG_reference_type:\t\treturn \"TAG_reference_type\";\n+    case TAG_compile_unit:\t\treturn \"TAG_compile_unit\";\n+    case TAG_string_type:\t\treturn \"TAG_string_type\";\n+    case TAG_structure_type:\t\treturn \"TAG_structure_type\";\n+    case TAG_subroutine:\t\treturn \"TAG_subroutine\";\n+    case TAG_subroutine_type:\t\treturn \"TAG_subroutine_type\";\n+    case TAG_typedef:\t\t\treturn \"TAG_typedef\";\n+    case TAG_union_type:\t\treturn \"TAG_union_type\";\n     case TAG_unspecified_parameters:\treturn \"TAG_unspecified_parameters\";\n-    case TAG_variant:\t\treturn \"TAG_variant\";\n-    case TAG_format:\t\treturn \"TAG_format\";\n-    case TAG_with_stmt:\t\treturn \"TAG_with_stmt\";\n-    case TAG_set_type:\t\treturn \"TAG_set_type\";\n-    default:\t\t\treturn \"<unknown tag>\";\n+    case TAG_variant:\t\t\treturn \"TAG_variant\";\n+    case TAG_common_block:\t\treturn \"TAG_common_block\";\n+    case TAG_common_inclusion:\t\treturn \"TAG_common_inclusion\";\n+    case TAG_inheritance:\t\treturn \"TAG_inheritance\";\n+    case TAG_inlined_subroutine:\treturn \"TAG_inlined_subroutine\";\n+    case TAG_module:\t\t\treturn \"TAG_module\";\n+    case TAG_ptr_to_member_type:\treturn \"TAG_ptr_to_member_type\";\n+    case TAG_set_type:\t\t\treturn \"TAG_set_type\";\n+    case TAG_subrange_type:\t\treturn \"TAG_subrange_type\";\n+    case TAG_with_stmt:\t\t\treturn \"TAG_with_stmt\";\n+\n+    /* GNU extensions.  */\n+\n+    case TAG_format_label:\t\treturn \"TAG_format_label\";\n+    case TAG_namelist:\t\t\treturn \"TAG_namelist\";\n+    case TAG_function_template:\t\treturn \"TAG_function_template\";\n+    case TAG_class_template:\t\treturn \"TAG_class_template\";\n+\n+    default:\t\t\t\treturn \"<unknown tag>\";\n     }\n }\n \n static char *\n-attribute_name (attr)\n+dwarf_attr_name (attr)\n      register unsigned attr;\n {\n   switch (attr)\n     {\n-    case AT_sibling:\t\treturn \"AT_sibling\";\n-    case AT_location:\t\treturn \"AT_location\";\n-    case AT_name:\t\treturn \"AT_name\";\n-    case AT_fund_type:\t\treturn \"AT_fund_type\";\n-    case AT_mod_fund_type:\treturn \"AT_mod_fund_type\";\n-    case AT_user_def_type:\treturn \"AT_user_def_type\";\n-    case AT_mod_u_d_type:\treturn \"AT_mod_u_d_type\";\n-    case AT_ordering:\t\treturn \"AT_ordering\";\n-    case AT_subscr_data:\treturn \"AT_subscr_data\";\n-    case AT_byte_size:\t\treturn \"AT_byte_size\";\n-    case AT_bit_offset:\t\treturn \"AT_bit_offset\";\n-    case AT_bit_size:\t\treturn \"AT_bit_size\";\n-    case AT_element_list:\treturn \"AT_element_list\";\n-    case AT_stmt_list:\t\treturn \"AT_stmt_list\";\n-    case AT_low_pc:\t\treturn \"AT_low_pc\";\n-    case AT_high_pc:\t\treturn \"AT_high_pc\";\n-    case AT_language:\t\treturn \"AT_language\";\n-    case AT_member:\t\treturn \"AT_member\";\n-    case AT_discr:\t\treturn \"AT_discr\";\n-    case AT_discr_value:\treturn \"AT_discr_value\";\n-    case AT_visibility:\t\treturn \"AT_visibility\";\n-    case AT_import:\t\treturn \"AT_import\";\n-    case AT_string_length:\treturn \"AT_string_length\";\n-    case AT_comp_dir:\t\treturn \"AT_comp_dir\";\n-    case AT_producer:\t\treturn \"AT_producer\";\n-    case AT_frame_base:\t\treturn \"AT_frame_base\";\n-    case AT_start_scope:\treturn \"AT_start_scope\";\n-    case AT_stride_size:\treturn \"AT_stride_size\";\n-    case AT_src_info:\t\treturn \"AT_src_info\";\n-    case AT_prototyped:\t\treturn \"AT_prototyped\";\n+    case AT_sibling:\t\t\treturn \"AT_sibling\";\n+    case AT_location:\t\t\treturn \"AT_location\";\n+    case AT_name:\t\t\treturn \"AT_name\";\n+    case AT_fund_type:\t\t\treturn \"AT_fund_type\";\n+    case AT_mod_fund_type:\t\treturn \"AT_mod_fund_type\";\n+    case AT_user_def_type:\t\treturn \"AT_user_def_type\";\n+    case AT_mod_u_d_type:\t\treturn \"AT_mod_u_d_type\";\n+    case AT_ordering:\t\t\treturn \"AT_ordering\";\n+    case AT_subscr_data:\t\treturn \"AT_subscr_data\";\n+    case AT_byte_size:\t\t\treturn \"AT_byte_size\";\n+    case AT_bit_offset:\t\t\treturn \"AT_bit_offset\";\n+    case AT_bit_size:\t\t\treturn \"AT_bit_size\";\n+    case AT_element_list:\t\treturn \"AT_element_list\";\n+    case AT_stmt_list:\t\t\treturn \"AT_stmt_list\";\n+    case AT_low_pc:\t\t\treturn \"AT_low_pc\";\n+    case AT_high_pc:\t\t\treturn \"AT_high_pc\";\n+    case AT_language:\t\t\treturn \"AT_language\";\n+    case AT_member:\t\t\treturn \"AT_member\";\n+    case AT_discr:\t\t\treturn \"AT_discr\";\n+    case AT_discr_value:\t\treturn \"AT_discr_value\";\n+    case AT_string_length:\t\treturn \"AT_string_length\";\n+    case AT_common_reference:\t\treturn \"AT_common_reference\";\n+    case AT_comp_dir:\t\t\treturn \"AT_comp_dir\";\n+    case AT_const_value_string:\t\treturn \"AT_const_value_string\";\n+    case AT_const_value_data2:\t\treturn \"AT_const_value_data2\";\n+    case AT_const_value_data4:\t\treturn \"AT_const_value_data4\";\n+    case AT_const_value_data8:\t\treturn \"AT_const_value_data8\";\n+    case AT_const_value_block2:\t\treturn \"AT_const_value_block2\";\n     case AT_const_value_block4:\t\treturn \"AT_const_value_block4\";\n-    case AT_sf_names:\t\treturn \"AT_sf_names\";\n-    case AT_mac_info:\t\treturn \"AT_mac_info\";\n-    default:\t\t\treturn \"<unknown attribute>\";\n+    case AT_containing_type:\t\treturn \"AT_containing_type\";\n+    case AT_default_value_addr:\t\treturn \"AT_default_value_addr\";\n+    case AT_default_value_data2:\treturn \"AT_default_value_data2\";\n+    case AT_default_value_data4:\treturn \"AT_default_value_data4\";\n+    case AT_default_value_data8:\treturn \"AT_default_value_data8\";\n+    case AT_default_value_string:\treturn \"AT_default_value_string\";\n+    case AT_friends:\t\t\treturn \"AT_friends\";\n+    case AT_inline:\t\t\treturn \"AT_inline\";\n+    case AT_is_optional:\t\treturn \"AT_is_optional\";\n+    case AT_lower_bound_ref:\t\treturn \"AT_lower_bound_ref\";\n+    case AT_lower_bound_data2:\t\treturn \"AT_lower_bound_data2\";\n+    case AT_lower_bound_data4:\t\treturn \"AT_lower_bound_data4\";\n+    case AT_lower_bound_data8:\t\treturn \"AT_lower_bound_data8\";\n+    case AT_private:\t\t\treturn \"AT_private\";\n+    case AT_producer:\t\t\treturn \"AT_producer\";\n+    case AT_program:\t\t\treturn \"AT_program\";\n+    case AT_protected:\t\t\treturn \"AT_protected\";\n+    case AT_prototyped:\t\t\treturn \"AT_prototyped\";\n+    case AT_public:\t\t\treturn \"AT_public\";\n+    case AT_pure_virtual:\t\treturn \"AT_pure_virtual\";\n+    case AT_return_addr:\t\treturn \"AT_return_addr\";\n+    case AT_specification:\t\treturn \"AT_specification\";\n+    case AT_start_scope:\t\treturn \"AT_start_scope\";\n+    case AT_stride_size:\t\treturn \"AT_stride_size\";\n+    case AT_upper_bound_ref:\t\treturn \"AT_upper_bound_ref\";\n+    case AT_upper_bound_data2:\t\treturn \"AT_upper_bound_data2\";\n+    case AT_upper_bound_data4:\t\treturn \"AT_upper_bound_data4\";\n+    case AT_upper_bound_data8:\t\treturn \"AT_upper_bound_data8\";\n+    case AT_virtual:\t\t\treturn \"AT_virtual\";\n+\n+    /* GNU extensions */\n+\n+    case AT_sf_names:\t\t\treturn \"AT_sf_names\";\n+    case AT_src_info:\t\t\treturn \"AT_src_info\";\n+    case AT_mac_info:\t\t\treturn \"AT_mac_info\";\n+    case AT_src_coords:\t\t\treturn \"AT_src_coords\";\n+\n+    default:\t\t\t\treturn \"<unknown attribute>\";\n     }\n }\n \n static char *\n-stack_op_name (op)\n+dwarf_stack_op_name (op)\n      register unsigned op;\n {\n   switch (op)\n@@ -839,7 +878,7 @@ stack_op_name (op)\n }\n \n static char *\n-modifier_name (mod)\n+dwarf_typemod_name (mod)\n      register unsigned mod;\n {\n   switch (mod)\n@@ -853,7 +892,7 @@ modifier_name (mod)\n }\n \n static char *\n-format_byte_name (fmt)\n+dwarf_fmt_byte_name (fmt)\n      register unsigned fmt;\n {\n   switch (fmt)\n@@ -871,7 +910,7 @@ format_byte_name (fmt)\n     }\n }\n static char *\n-fundamental_type_name (ft)\n+dwarf_fund_type_name (ft)\n      register unsigned ft;\n {\n   switch (ft)\n@@ -896,9 +935,33 @@ fundamental_type_name (ft)\n     case FT_dbl_prec_complex:\treturn \"FT_dbl_prec_complex\";\n     case FT_void:\t\treturn \"FT_void\";\n     case FT_boolean:\t\treturn \"FT_boolean\";\n+    case FT_ext_prec_complex:\treturn \"FT_ext_prec_complex\";\n+    case FT_label:\t\treturn \"FT_label\";\n+\n+    /* GNU extensions.  */\n+\n     case FT_long_long:\t\treturn \"FT_long_long\";\n     case FT_signed_long_long:\treturn \"FT_signed_long_long\";\n     case FT_unsigned_long_long: return \"FT_unsigned_long_long\";\n+\n+    case FT_int8:\t\treturn \"FT_int8\";\n+    case FT_signed_int8:\treturn \"FT_signed_int8\";\n+    case FT_unsigned_int8:\treturn \"FT_unsigned_int8\";\n+    case FT_int16:\t\treturn \"FT_int16\";\n+    case FT_signed_int16:\treturn \"FT_signed_int16\";\n+    case FT_unsigned_int16:\treturn \"FT_unsigned_int16\";\n+    case FT_int32:\t\treturn \"FT_int32\";\n+    case FT_signed_int32:\treturn \"FT_signed_int32\";\n+    case FT_unsigned_int32:\treturn \"FT_unsigned_int32\";\n+    case FT_int64:\t\treturn \"FT_int64\";\n+    case FT_signed_int64:\treturn \"FT_signed_int64\";\n+    case FT_unsigned_int64:\treturn \"FT_signed_int64\";\n+\n+    case FT_real32:\t\treturn \"FT_real32\";\n+    case FT_real64:\t\treturn \"FT_real64\";\n+    case FT_real96:\t\treturn \"FT_real96\";\n+    case FT_real128:\t\treturn \"FT_real128\";\n+\n     default:\t\t\treturn \"<unknown fundamental type>\";\n     }\n }\n@@ -1452,41 +1515,110 @@ location_attribute (rtl)\n }\n \n /* Output the specialized form of location attribute used for data members\n-   of struct types.  */\n+   of struct types.\n+\n+   In the special case of a FIELD_DECL node which represents a bit-field,\n+   the \"offset\" part of this special location descriptor must indicate the\n+   distance in bytes from the lowest-addressed byte of the containing\n+   struct or union type to the lowest-addressed byte of the \"containing\n+   object\" for the bit-field.\n+\n+   For any given bit-field, the \"containing object\" is a hypothetical\n+   object (of some integral or enum type) within which the given bit-field\n+   lives.  The type of this hypothetical \"containing object\" is always the\n+   same as the declared type of the individual bit-field itself.\n+\n+   Note that it is the size (in bytes) of the hypothetical \"containing\n+   object\" which will be given in the AT_byte_size attribute for this\n+   bit-field.  (See the `byte_size_attribute' function below.)\n+*/\n+\n \n static void\n data_member_location_attribute (decl)\n      register tree decl;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  register unsigned containing_object_size_in_bytes;\n+  register unsigned containing_object_size_in_bits;\n+  register unsigned member_offset_in_objects;\n+  register unsigned member_offset_in_bytes;\n+  register tree type;\n+  register tree bitpos = DECL_FIELD_BITPOS (decl);\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n \n   if (TREE_CODE (decl) != FIELD_DECL)\n     abort ();\n \n+  /* The bit position given by DECL_FIELD_BITPOS could be non-constant\n+     in the case where one or more variable sized members preceeded this\n+     member in the containing struct type.  We could probably correctly\n+     handle this case someday, by it's too complicated to deal with at\n+     the moment (and probably too rare to worry about), so just punt on\n+     the whole AT_location attribute for now.  Eventually, we'll have\n+     to analyze the expression given as the DECL_FIELD_BITPOS and turn\n+     it into a member-style AT_location descriptor, but that'll be\n+     tough to do.  -- rfg  */\n+\n+  if (TREE_CODE (bitpos) != CONST_INT)\n+    return;\n+\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_location);\n   sprintf (begin_label, LOC_BEGIN_LABEL_FMT, current_dienum);\n   sprintf (end_label, LOC_END_LABEL_FMT, current_dienum);\n   ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, end_label, begin_label);\n   ASM_OUTPUT_LABEL (asm_out_file, begin_label);\n   ASM_OUTPUT_DWARF_STACK_OP (asm_out_file, OP_CONST);\n \n-  /* This is pretty strange, but existing compilers producing DWARF\n-     apparently calculate the byte offset of a field differently\n-     depending upon whether or not it is a bit-field.  If the given\n-     field is *not* a bit-field, then the offset is simply the\n-     the byte offset of the given field from the beginning of the\n-     struct.  For bit-fields however, the offset is the offset (in\n-     bytes) of the beginning of the *containing word* from the\n-     beginning of the whole struct.  */\n+  type = DECL_BIT_FIELD_TYPE (decl);\n+  if (type == NULL)\n+    type = TREE_TYPE (decl);\n \n-  ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n-\t\t\t  (DECL_BIT_FIELD_TYPE (decl))\n-\t\t\t\t? BITFIELD_OFFSET_WORDS_IN_UNITS (decl)\n-\t\t\t\t: BITFIELD_OFFSET_UNITS (decl));\n+  containing_object_size_in_bytes = int_size_in_bytes (type);\n+  containing_object_size_in_bits\n+    = containing_object_size_in_bytes * BITS_PER_UNIT;\n+\n+  /* WARNING!  Note that the GCC front-end doesn't make any attempt to\n+     keep track of the starting bit offset (relative to the start of\n+     the containing structure type) of the hypothetical \"containing\n+     object\" for a bit-field.  (See the comments at the start of this\n+     function.)  Thus, when computing the  byte offset value for a\n+     bit-field, all we can do is to divide the starting bit offset of\n+     the bit-field by the size of the hypothetical \"containing object\"\n+     (which we can easily find).\n+\n+     This solution only works right as long as the alignment used by the\n+     compiler for the declared type of the bit-field is the same as the\n+     size of that type.\n+\n+     Since GCC allows type `long long' to be the declared type for a\n+     bit-field, and since some target configurations only align\n+     `long longs' to 4-byte boundaries, we have to check here to see\n+     that the alignment of the containing object is the same as the\n+     size of that object.  If it isn't, and if the field in question\n+     is a bit-field, then we may be about to generate bogus Dwarf\n+     output, so we need to warn the user about that.\n+\n+     Of course it would be nice to actually solve this problem, but\n+     that would require a lot of changes elsewhere in the compiler\n+     which could be quite painful, so for now we'll just live with\n+     this minor annoyance.\n+  */\n+\n+  if ((GET_MODE_ALIGNMENT (mode_for_size (containing_object_size_in_bits))\n+       != containing_object_size_in_bits)\n+      && (DECL_BIT_FIELD_TYPE (type) != NULL))\n+    warning_with_decl (decl, \"debugging info won't necessarily be reliable\");\n+\n+  member_offset_in_objects\n+    = (unsigned) TREE_INT_CST_LOW (bitpos) / containing_object_size_in_bits;\n+  member_offset_in_bytes\n+    = member_offset_in_objects * containing_object_size_in_bytes;\n+\n+  ASM_OUTPUT_DWARF_DATA4 (asm_out_file, member_offset_in_bytes);\n   ASM_OUTPUT_DWARF_STACK_OP (asm_out_file, OP_ADD);\n   ASM_OUTPUT_LABEL (asm_out_file, end_label);\n }\n@@ -1591,27 +1723,22 @@ location_or_const_value_attribute (decl)\n   if ((TREE_CODE (decl) != VAR_DECL) && (TREE_CODE (decl) != PARM_DECL))\n     abort ();\n \n-  /* It's not really clear what existing Dwarf debuggers need or expect\n-     as regards to location information for formal parameters.  A later\n-     version of the Dwarf specification should resolve such issues, but\n-     for the time being, we assume here that debuggers want information\n-     about the location where the parameter was passed into the function.\n-     That seems to be what USL's CI5 compiler generates.  Note that this\n-     will probably be different from the place where the parameter actual\n-     resides during function execution.  Dwarf Version 2 will provide us\n-     with a means to describe that location also, but for now we can only\n-     describe the \"passing\" location.  */\n-\n-#if 1 /* This is probably right, but it leads to a lot of trouble.\n-\t Fixing one problem has been exposing another,\n-\t all of which seemed to have no ill effects before.\n-\t Let's try it again for now.  */\n+  /* Existing Dwarf debuggers need and expect the location descriptors for\n+     formal parameters to reflect the place where the parameter are passed,\n+     as opposed to the places where they might reside during the execution\n+     of the function.  This isn't clearly spelled out in the current Dwarf\n+     version 1 specification, but it's obvious if you look at the output of\n+     the CI5 compiler, or if you try to use the svr4 SDB debugger.  Hopefully,\n+     a later version of the Dwarf specification will clarify this.  For now,\n+     we just need to generate the right thing.  Note that Dwarf version 2\n+     will provide us with a means to describe *all* of the locations in which\n+     a given variable or parameter resides (and the PC ranges over which it\n+     occupies each one), but for now we can only describe the \"passing\"\n+     location.  */\n+\n   rtl = (TREE_CODE (decl) == PARM_DECL)\n \t ? DECL_INCOMING_RTL (decl)\n \t : DECL_RTL (decl);\n-#else\n-  rtl = DECL_RTL (decl);\n-#endif\n \n   if (rtl == NULL)\n     return;\n@@ -1640,17 +1767,14 @@ location_or_const_value_attribute (decl)\n }\n \n /* Generate an AT_name attribute given some string value to be included as\n-   the value of the attribute.\tIf the name is null, don't do anything.\t */\n+   the value of the attribute.\t*/\n \n inline void\n name_attribute (name_string)\n      register char *name_string;\n {\n-  if (name_string && *name_string)\n-    {\n-      ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_name);\n-      ASM_OUTPUT_DWARF_STRING (asm_out_file, name_string);\n-    }\n+  ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_name);\n+  ASM_OUTPUT_DWARF_STRING (asm_out_file, name_string);\n }\n \n inline void\n@@ -1846,36 +1970,127 @@ byte_size_attribute (tree_node)\n \tbreak;\n \n       case FIELD_DECL:\n-\t{\n-\t  register unsigned words;\n-\t  register unsigned bits;\n-\n-\t  bits = TREE_INT_CST_LOW (DECL_SIZE (tree_node));\n-\t  words = (bits + (BITS_PER_WORD-1)) / BITS_PER_WORD;\n-\t  size = words * (BITS_PER_WORD / BITS_PER_UNIT);\n-\t}\n+\t/* For a data member of a struct or union, the AT_byte_size is\n+\t   always given as the number of bytes normally allocated for\n+\t   an object of the *declared* type of the member itself.  This\n+\t   is true even for bit-fields.  */\n+\tsize = int_size_in_bytes (DECL_BIT_FIELD_TYPE (tree_node)\n+\t\t\t\t  ? DECL_BIT_FIELD_TYPE (tree_node)\n+\t\t\t\t  : TREE_TYPE (tree_node));\n \tbreak;\n \n       default:\n \tabort ();\n     }\n+\n+  /* Note that `size' might be -1 when we get to this point.  If it\n+     is, that indicates that the byte size of the entity in question\n+     is variable.  We have no good way of expressing this fact in Dwarf\n+     at the present time, so just let the -1 pass on through.  */\n+\n   ASM_OUTPUT_DWARF_DATA4 (asm_out_file, size);\n }\n \n-/* For a FIELD_DECL node which represents a bit field, output an attribute\n-   which specifies the distance in bits from the start of the *word*\n-   containing the given field to the first bit of the field.  */\n+/* For a FIELD_DECL node which represents a bit-field, output an attribute\n+   which specifies the distance in bits from the highest order bit of the\n+   \"containing object\" for the bit-field to the highest order bit of the\n+   bit-field itself.\n+\n+   For any given bit-field, the \"containing object\" is a hypothetical\n+   object (of some integral or enum type) within which the given bit-field\n+   lives.  The type of this hypothetical \"containing object\" is always the\n+   same as the declared type of the individual bit-field itself.\n+\n+   Note that it is the size (in bytes) of the hypothetical \"containing\n+   object\" which will be given in the AT_byte_size attribute for this\n+   bit-field.  (See `byte_size_attribute' above.)\n+*/\n \n inline void\n bit_offset_attribute (decl)\n     register tree decl;\n {\n+  register tree type = DECL_BIT_FIELD_TYPE (decl);\n+  register unsigned containing_object_size_in_bits;\n+  register unsigned dwarf_bit_offset;\n+  register tree bitpos_tree = DECL_FIELD_BITPOS (decl);\n+  register unsigned bitpos;\n+\n   assert (TREE_CODE (decl) == FIELD_DECL);\t/* Must be a field.  */\n-  assert (DECL_BIT_FIELD_TYPE (decl));\t\t/* Must be a bit field.\t */\n+  assert (type);\t\t\t\t/* Must be a bit field.\t */\n+\n+  /* The bit position given by DECL_FIELD_BITPOS could be non-constant\n+     in the case where one or more variable sized members preceeded this\n+     member in the containing struct type.  We could probably correctly\n+     handle this case someday, by it's too complicated to deal with at\n+     the moment, so just punt on the whole AT_bit_offset attribute for\n+     now.  Eventually, we'll have to analyze the (variable) expression\n+     given as the DECL_FIELD_BITPOS and see if we can factor out just\n+     the (constant) bit offset part of that expression.  -- rfg  */\n+\n+  if (TREE_CODE (bitpos_tree) != CONST_INT)\n+    return;\n+\n+  containing_object_size_in_bits = int_size_in_bytes (type) * BITS_PER_UNIT;\n+\n+  /* WARNING!  Note that the GCC front-end doesn't make any attempt to\n+     keep track of the starting bit offset (relative to the start of\n+     the containing structure type) of the hypothetical \"containing\n+     object\" for a bit-field.  (See the comments at the start of this\n+     function.)  Thus, when computing the AT_bit_offset value for a\n+     bit-field, all we can do is to divide the starting bit offset of\n+     the bit-field by the size of the hypothetical \"containing object\"\n+     (which we can easily find) and then get the remainder.\n+\n+     This solution only works right as long as the alignment used by the\n+     compiler for the declared type of the bit-field is the same as the\n+     size of that type.\n+\n+     Since GCC allows type `long long' to be the declared type for a\n+     bit-field, and since some target configurations only align\n+     `long longs' to 4-byte boundaries, we really should check here\n+     to see that the alignment of the containing object is the same\n+     as the size of that object and issue a warning if it isn't but\n+     since we will also be generating an AT_location attribute for\n+     the bit-field, and sinec it will generat a warning for this\n+     condition we do not need to do it again here.  That would just\n+     cause the user to see two redundant warnings for the same single\n+     bit-field declaration.\n+\n+     Of course it would be nice to actually solve this problem, but\n+     that would require a lot of changes elsewhere in the compiler\n+     which could be quite painful, so for now we'll just live with\n+     this minor annoyance.\n+  */\n+\n+#if 0\n+  if (GET_MODE_ALIGNMENT (mode_for_size (containing_object_size_in_bits))\n+       != containing_object_size_in_bits)\n+    warning_with_decl (decl, \"debugging info won't necessarily be reliable\");\n+#endif\n+\n+  bitpos = (unsigned) TREE_INT_CST_LOW (bitpos_tree);\n+\n+#if (BYTES_BIG_ENDIAN == 1)\n+  {\n+    register unsigned high_order_bitpos = bitpos;\n+\n+    dwarf_bit_offset = high_order_bitpos % containing_object_size_in_bits;\n+  }\n+#else\n+  {\n+    register unsigned low_order_bitpos = bitpos;\n+    register unsigned field_width\n+      = (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl));\n+    register unsigned high_order_bitpos = low_order_bitpos + field_width;\n+\n+    dwarf_bit_offset = containing_object_size_in_bits\n+\t\t\t- (high_order_bitpos % containing_object_size_in_bits);\n+  }\n+#endif\n \n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_bit_offset);\n-  ASM_OUTPUT_DWARF_DATA2 (asm_out_file,\n-\tBITFIELD_OFFSET_BITS (decl) % (unsigned) BITS_PER_WORD);\n+  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, dwarf_bit_offset);\n }\n \n /* For a FIELD_DECL node which represents a bit field, output an attribute\n@@ -2077,10 +2292,39 @@ containing_type_attribute (containing_type)\n   ASM_OUTPUT_DWARF_REF (asm_out_file, label);\n }\n \n+inline void\n+src_coords_attribute (src_fileno, src_lineno)\n+     register unsigned src_fileno;\n+     register unsigned src_lineno;\n+{\n+#ifdef DWARF_DECL_COORDINATES\n+  ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_src_coords);\n+  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, src_fileno);\n+  ASM_OUTPUT_DWARF_DATA2 (asm_out_file, src_lineno);\n+#endif\n+}\n+\n /************************* end of attributes *****************************/\n \n /********************* utility routines for DIEs *************************/\n \n+/* Output an AT_name attribute and an AT_src_coords attribute for the\n+   given decl, but only if it actually has a name.  */\n+\n+inline void\n+name_and_src_coords_attributes (decl)\n+    register tree decl;\n+{\n+  register tree decl_name = DECL_NAME (decl);\n+\n+  if (decl_name && IDENTIFIER_POINTER (decl_name))\n+    {\n+      name_attribute (IDENTIFIER_POINTER (decl_name));\n+      src_coords_attribute (lookup_filename (DECL_SOURCE_FILE (decl)),\n+\t\t\t    DECL_SOURCE_LINE (decl));\n+    }\n+}\n+\n /* Many forms of DIEs contain a \"type description\" part.  The following\n    routine writes out these \"type descriptor\" parts.  */\n \n@@ -2219,10 +2463,11 @@ output_array_type_die (arg)\n   /* I believe that we can default the array ordering.  SDB will probably\n      do the right things even if AT_ordering is not present.  It's not\n      even an issue until we start to get into multidimensional arrays\n-     anyway.  If SDB is shown to do the wrong thing in those cases, then\n-     we'll have to put the AT_ordering attribute back in, but only for\n-     multidimensional array.  (After all, we don't want to waste space\n-     in the .debug section now do we?)  */\n+     anyway.  If SDB is ever caught doing the Wrong Thing for multi-\n+     dimensional arrays, then we'll have to put the AT_ordering attribute\n+     back in.  (But if and when we find out that we need to put these in,\n+     we will only do so for multidimensional arrays.  After all, we don't\n+     want to waste space in the .debug section now do we?)  */\n \n #if 0\n   ordering_attribute (ORD_row_major);\n@@ -2257,8 +2502,7 @@ output_entry_point_die (arg)\n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_entry_point);\n   sibling_attribute ();\n   dienum_push ();\n-  if (DECL_NAME (decl))\n-    name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n   member_attribute (DECL_CONTEXT (decl));\n   type_attribute (return_type, 0, 0);\n }\n@@ -2321,8 +2565,7 @@ output_formal_parameter_die (arg)\n   sibling_attribute ();\n   if (decl)\n     {\n-      if (DECL_NAME (decl))\n-        name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      name_and_src_coords_attributes (decl);\n       type_attribute (type, TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n       location_or_const_value_attribute (decl);\n     }\n@@ -2344,8 +2587,7 @@ output_global_subroutine_die (arg)\n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_global_subroutine);\n   sibling_attribute ();\n   dienum_push ();\n-  if (DECL_NAME (decl))\n-    name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n   inline_attribute (decl);\n   prototyped_attribute (type);\n   member_attribute (DECL_CONTEXT (decl));\n@@ -2354,7 +2596,7 @@ output_global_subroutine_die (arg)\n     {\n       char func_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-      low_pc_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n       sprintf (func_end_label, FUNC_END_LABEL_FMT, current_funcdef_number);\n       high_pc_attribute (func_end_label);\n     }\n@@ -2372,8 +2614,7 @@ output_global_variable_die (arg)\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_global_variable);\n   sibling_attribute ();\n-  if (DECL_NAME (decl))\n-    name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n   member_attribute (DECL_CONTEXT (decl));\n   type_attribute (type, TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n   if (!TREE_EXTERNAL (decl))\n@@ -2397,8 +2638,7 @@ output_inline_subroutine_die (arg)\n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_inline_subroutine);\n   sibling_attribute ();\n   dienum_push ();\n-  if (DECL_NAME (decl))\n-    name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n   prototyped_attribute (type);\n   member_attribute (DECL_CONTEXT (decl));\n   type_attribute (return_type, 0, 0);\n@@ -2427,7 +2667,7 @@ output_inline_subroutine_die (arg)\n         {\n           char func_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-          low_pc_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+          low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n           sprintf (func_end_label, FUNC_END_LABEL_FMT, current_funcdef_number);\n           high_pc_attribute (func_end_label);\n         }\n@@ -2444,7 +2684,7 @@ output_label_die (arg)\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_label);\n   sibling_attribute ();\n-  name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n \n   /* When optimization is enabled (with -O) the code in jump.c and in flow.c\n      may cause insns representing one of more of the user's own labels to\n@@ -2516,8 +2756,7 @@ output_local_variable_die (arg)\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_local_variable);\n   sibling_attribute ();\n-  if (DECL_NAME (decl))\n-    name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n   member_attribute (DECL_CONTEXT (decl));\n   type_attribute (type, TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n   location_or_const_value_attribute (decl);\n@@ -2531,8 +2770,7 @@ output_member_die (arg)\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_member);\n   sibling_attribute ();\n-  if (DECL_NAME (decl))\n-    name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n   member_attribute (DECL_CONTEXT (decl));\n   type_attribute (member_declared_type (decl),\n \t\t  TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n@@ -2699,8 +2937,7 @@ output_local_subroutine_die (arg)\n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_subroutine);\n   sibling_attribute ();\n   dienum_push ();\n-  if (DECL_NAME (decl))\n-    name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n   inline_attribute (decl);\n   prototyped_attribute (type);\n   member_attribute (DECL_CONTEXT (decl));\n@@ -2711,7 +2948,7 @@ output_local_subroutine_die (arg)\n \n   if (TREE_ASM_WRITTEN (decl))\n     {\n-      low_pc_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      low_pc_attribute (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n       sprintf (func_end_label, FUNC_END_LABEL_FMT, current_funcdef_number);\n       high_pc_attribute (func_end_label);\n     }\n@@ -2742,8 +2979,7 @@ output_typedef_die (arg)\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_typedef);\n   sibling_attribute ();\n-  if (DECL_NAME (decl))\n-    name_attribute (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+  name_and_src_coords_attributes (decl);\n   member_attribute (DECL_CONTEXT (decl));\n   type_attribute (type, TREE_READONLY (decl), TREE_THIS_VOLATILE (decl));\n }\n@@ -3236,22 +3472,43 @@ output_type (type, containing_scope)\n \n \tif (TYPE_SIZE (type))\n \t  {\n-\t    register tree member;\n-\n-\t    /* First output info about the data members and type members.  */\n+\t    {\n+\t      register tree normal_member;\n \n-\t    for (member = TYPE_FIELDS (type);\n-\t\t member;\n-\t\t member = TREE_CHAIN (member))\n-\t      output_decl (member, type);\n+\t      /* First output info about the data members and type members.  */\n \n-\t    /* Now output info about the function members (if any).  */\n+\t      for (normal_member = TYPE_FIELDS (type);\n+\t\t   normal_member;\n+\t\t   normal_member = TREE_CHAIN (normal_member))\n+\t        output_decl (normal_member, type);\n+\t    }\n \n-\t    if (TYPE_METHODS (type))\n-\t      for (member = TREE_VEC_ELT (TYPE_METHODS (type), 0);\n-\t\t   member;\n-\t\t   member = TREE_CHAIN (member))\n-\t\toutput_decl (member, type);\n+\t    {\n+\t      register tree vec_base;\n+\n+\t      /* Now output info about the function members (if any).  */\n+\n+\t      vec_base = TYPE_METHODS (type);\n+\t      if (vec_base)\n+\t\t{\n+\t\t  register tree first_func_member = TREE_VEC_ELT (vec_base, 0);\n+\t\t  register tree func_member;\n+\n+\t\t  /* This isn't documented, but the first element of the\n+\t\t     vector of member functions can be NULL in cases where\n+\t\t     the class type in question didn't have either a\n+\t\t     constructor or a destructor declared for it.  We have\n+\t\t     to make allowances for that here.  */\n+\n+\t\t  if (first_func_member == NULL)\n+\t\t    first_func_member = TREE_VEC_ELT (vec_base, 1);\n+\n+\t\t  for (func_member = first_func_member;\n+\t\t       func_member;\n+\t\t       func_member = TREE_CHAIN (func_member))\n+\t\t    output_decl (func_member, type);\n+\t\t}\n+\t    }\n \n \t    end_sibling_chain ();\t/* Terminate member chain.  */\n \t  }\n@@ -3794,7 +4051,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \t      fputc ('\\n', asm_out_file);\n \t      ASM_OUTPUT_PUSH_SECTION (asm_out_file, ARANGES_SECTION);\n \t      ASM_OUTPUT_DWARF_ADDR (asm_out_file,\n-\t\t\t\t     IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t\t\t      IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n \t      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, \n \t\t\t(unsigned) int_size_in_bytes (TREE_TYPE (decl)));\n \t      ASM_OUTPUT_POP_SECTION (asm_out_file);"}, {"sha": "eb5c2956c39319b7f1ae4c0c826e07d2e211dd0f", "filename": "gcc/flags.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "patch": "@@ -301,6 +301,13 @@ extern int flag_no_common;\n    needed for crtstuff.c on other systems.  */\n extern int flag_inhibit_size_directive;\n \n+/* -fverbose-asm causes extra commentary information to be produced in\n+   the generated assembly code (to make it more readable).  This option\n+   is generally only of use to those who actually need to read the\n+   generated assembly code (perhaps while debugging the compiler itself).  */\n+\n+extern int flag_verbose_asm;\n+\n /* -fgnu-linker specifies use of the GNU linker for initializations.\n    -fno-gnu-linker says that collect will be used.  */\n extern int flag_gnu_linker;"}, {"sha": "be93945f595debee3a2b4238527551111ed9d502", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "patch": "@@ -433,6 +433,13 @@ int flag_schedule_insns_after_reload = 0;\n    needed for crtstuff.c on other systems.  */\n int flag_inhibit_size_directive = 0;\n \n+/* -fverbose-asm causes extra commentary information to be produced in\n+   the generated assembly code (to make it more readable).  This option\n+   is generally only of use to those who actually need to read the\n+   generated assembly code (perhaps while debugging the compiler itself).  */\n+\n+int flag_verbose_asm = 0;\n+\n /* -fgnu-linker specifies use of the GNU linker for initializations.\n    (Or, more generally, a linker that handles initializations.)\n    -fno-gnu-linker says that collect2 will be used.  */\n@@ -483,6 +490,7 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"fast-math\", &flag_fast_math, 1},\n   {\"common\", &flag_no_common, 0},\n   {\"inhibit-size-directive\", &flag_inhibit_size_directive, 1},\n+  {\"verbose-asm\", &flag_verbose_asm, 1},\n   {\"gnu-linker\", &flag_gnu_linker, 1}\n };\n \f"}, {"sha": "fad48642dbc0acf64c17d7a06be6b08b1cc061b7", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a631e8e94fa51e132f7c6c6d6c2098cc68c5518/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9a631e8e94fa51e132f7c6c6d6c2098cc68c5518", "patch": "@@ -35,6 +35,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"expr.h\"\n #include \"hard-reg-set.h\"\n #include \"regs.h\"\n+#include \"defaults.h\"\n \n #include \"obstack.h\"\n \n@@ -615,33 +616,7 @@ assemble_string (p, size)\n       if (thissize > maximum)\n \tthissize = maximum;\n \n-#ifdef ASM_OUTPUT_ASCII\n       ASM_OUTPUT_ASCII (asm_out_file, p, thissize);\n-#else\n-      fprintf (asm_out_file, \"\\t.ascii \\\"\");\n-\n-      for (i = 0; i < thissize; i++)\n-\t{\n-\t  register int c = p[i];\n-\t  if (c == '\\\"' || c == '\\\\')\n-\t    putc ('\\\\', asm_out_file);\n-\t  if (c >= ' ' && c < 0177)\n-\t    putc (c, asm_out_file);\n-\t  else\n-\t    {\n-\t      fprintf (asm_out_file, \"\\\\%o\", c);\n-\t      /* After an octal-escape, if a digit follows,\n-\t\t terminate one string constant and start another.\n-\t\t The Vax assembler fails to stop reading the escape\n-\t\t after three digits, so this is the only way we\n-\t\t can get it to parse the data properly.  */\n-\t      if (i < thissize - 1\n-\t\t  && p[i + 1] >= '0' && p[i + 1] <= '9')\n-\t\tfprintf (asm_out_file, \"\\\"\\n\\t.ascii \\\"\");\n-\t    }\n-\t}\n-      fprintf (asm_out_file, \"\\\"\\n\");\n-#endif /* no ASM_OUTPUT_ASCII */\n \n       pos += thissize;\n       p += thissize;"}]}