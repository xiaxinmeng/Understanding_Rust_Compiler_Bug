{"sha": "c10bc6e9a0f720a8e8db03c90960017218fe9879", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEwYmM2ZTlhMGY3MjBhOGU4ZGIwM2M5MDk2MDAxNzIxOGZlOTg3OQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-03-01T14:40:28Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-03-01T14:40:28Z"}, "message": "dependency.c (gfc_is_same_range): Compare the stride...\n\n\n\t* dependency.c (gfc_is_same_range): Compare the stride, lower and\n\tupper bounds when testing array reference ranges for equality.\n\n\t(gfc_check_dependency): Fix indentation whitespace.\n\t(gfc_check_element_vs_element): Likewise.\n\t(gfc_dep_resolver): Likewise.\n\nFrom-SVN: r111601", "tree": {"sha": "6f7332e67bcab8cb1604dc9e16c929b3c5613197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f7332e67bcab8cb1604dc9e16c929b3c5613197"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c10bc6e9a0f720a8e8db03c90960017218fe9879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10bc6e9a0f720a8e8db03c90960017218fe9879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c10bc6e9a0f720a8e8db03c90960017218fe9879", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10bc6e9a0f720a8e8db03c90960017218fe9879/comments", "author": null, "committer": null, "parents": [{"sha": "6578c101b5225a13cb0ab326fd5246eaea01962b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6578c101b5225a13cb0ab326fd5246eaea01962b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6578c101b5225a13cb0ab326fd5246eaea01962b"}], "stats": {"total": 76, "additions": 53, "deletions": 23}, "files": [{"sha": "d9b2abee66b233d34b0aa9b3a0a7b05d957a9094", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10bc6e9a0f720a8e8db03c90960017218fe9879/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10bc6e9a0f720a8e8db03c90960017218fe9879/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c10bc6e9a0f720a8e8db03c90960017218fe9879", "patch": "@@ -1,3 +1,11 @@\n+2006-03-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* dependency.c (gfc_is_same_range): Compare the stride, lower and\n+\tupper bounds when testing array reference ranges for equality.\n+\t(gfc_check_dependency): Fix indentation whitespace.\n+\t(gfc_check_element_vs_element): Likewise.\n+\t(gfc_dep_resolver): Likewise.\n+\n 2006-02-28  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \t* trans-intrinsic.c (gfc_conv_intrinsic_minmaxloc):"}, {"sha": "96da3c31e4bc29f7aa7811097fa9217a3dd49de2", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10bc6e9a0f720a8e8db03c90960017218fe9879/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10bc6e9a0f720a8e8db03c90960017218fe9879/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=c10bc6e9a0f720a8e8db03c90960017218fe9879", "patch": "@@ -150,28 +150,50 @@ gfc_is_same_range (gfc_array_ref * ar1, gfc_array_ref * ar2, int n, int def)\n   /* Check the range start.  */\n   e1 = ar1->start[n];\n   e2 = ar2->start[n];\n+  if (e1 || e2)\n+    {\n+      /* Use the bound of the array if no bound is specified.  */\n+      if (ar1->as && !e1)\n+\te1 = ar1->as->lower[n];\n \n-  if (!(e1 || e2))\n-    return 1;\n+      if (ar2->as && !e2)\n+\te2 = ar2->as->lower[n];\n \n-  /* Use the bound of the array if no bound is specified.  */\n-  if (ar1->as && !e1)\n-    e1 = ar1->as->lower[n];\n+      /* Check we have values for both.  */\n+      if (!(e1 && e2))\n+\treturn def;\n \n-  if (ar2->as && !e2)\n-    e2 = ar2->as->lower[n];\n+      i = gfc_dep_compare_expr (e1, e2);\n+      if (i == -2)\n+\treturn def;\n+      else if (i != 0)\n+\treturn 0;\n+    }\n \n-  /* Check we have values for both.  */\n-  if (!(e1 && e2))\n-    return def;\n+  /* Check the range end.  */\n+  e1 = ar1->end[n];\n+  e2 = ar2->end[n];\n+  if (e1 || e2)\n+    {\n+      /* Use the bound of the array if no bound is specified.  */\n+      if (ar1->as && !e1)\n+\te1 = ar1->as->upper[n];\n \n-  i = gfc_dep_compare_expr (e1, e2);\n+      if (ar2->as && !e2)\n+\te2 = ar2->as->upper[n];\n \n-  if (i == -2)\n-    return def;\n-  else if (i == 0)\n-    return 1;\n-  return 0;\n+      /* Check we have values for both.  */\n+      if (!(e1 && e2))\n+\treturn def;\n+\n+      i = gfc_dep_compare_expr (e1, e2);\n+      if (i == -2)\n+\treturn def;\n+      else if (i != 0)\n+\treturn 0;\n+    }\n+\n+  return 1;\n }\n \n \n@@ -406,8 +428,8 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, bool identical)\n       if (expr2->inline_noncopying_intrinsic)\n \tidentical = 1;\n       /* Remember possible differences between elemental and\n-         transformational functions.  All functions inside a FORALL\n-         will be pure.  */\n+\t transformational functions.  All functions inside a FORALL\n+\t will be pure.  */\n       for (actual = expr2->value.function.actual;\n \t   actual; actual = actual->next)\n \t{\n@@ -673,7 +695,7 @@ gfc_check_element_vs_element (gfc_ref * lref, gfc_ref * rref, int n)\n       l_start = l_ar.start[n] ;\n       r_start = r_ar.start[n] ;\n       if (gfc_dep_compare_expr (r_start, l_start) == 0)\n-        nIsDep = GFC_DEP_EQUAL;\n+\tnIsDep = GFC_DEP_EQUAL;\n       else\n \tnIsDep = GFC_DEP_NODEP;\n   }\n@@ -704,7 +726,7 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n   while (lref && rref)\n     {\n       /* We're resolving from the same base symbol, so both refs should be\n-         the same type.  We traverse the reference chain intil we find ranges\n+\t the same type.  We traverse the reference chain intil we find ranges\n \t that are not equal.  */\n       gcc_assert (lref->type == rref->type);\n       switch (lref->type)\n@@ -725,7 +747,7 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n \t  for (n=0; n < lref->u.ar.dimen; n++)\n \t    {\n \t      /* Assume dependency when either of array reference is vector\n-\t         subscript.  */\n+\t\t subscript.  */\n \t      if (lref->u.ar.dimen_type[n] == DIMEN_VECTOR\n \t\t  || rref->u.ar.dimen_type[n] == DIMEN_VECTOR)\n \t\treturn 1;\n@@ -741,7 +763,7 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n \t      else \n \t\t{\n \t\t  gcc_assert (rref->u.ar.dimen_type[n] == DIMEN_ELEMENT\n-\t\t          && lref->u.ar.dimen_type[n] == DIMEN_ELEMENT);\n+\t\t\t      && lref->u.ar.dimen_type[n] == DIMEN_ELEMENT);\n \t\t  this_dep = gfc_check_element_vs_element (rref, lref, n);\n \t\t}\n \n@@ -750,7 +772,7 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n \t\treturn 0;\n \n \t      /* Overlap codes are in order of priority.  We only need to\n-\t         know the worst one.*/\n+\t\t know the worst one.*/\n \t      if (this_dep > fin_dep)\n \t\tfin_dep = this_dep;\n \t    }"}]}