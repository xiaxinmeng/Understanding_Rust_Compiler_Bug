{"sha": "c1e2610ec1742ce29883a54dc2dca0080c37bc09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlMjYxMGVjMTc0MmNlMjk4ODNhNTRkYzJkY2EwMDgwYzM3YmMwOQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-05T19:49:52Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-05T19:49:52Z"}, "message": "cprop.c (struct reg_use): Remove.\n\n\t* cprop.c (struct reg_use): Remove.\n\t(reg_use_table): Make an array of RTX.\n\t(find_used_regs, constprop_register, local_cprop_pass,\n\tbypass_block): Simplify users of reg_use_table.\n\t(cprop_insn): Likewise.  Iterate if copy propagation succeeded\n\ton one of the uses found by find_used_regs.\n\nFrom-SVN: r171999", "tree": {"sha": "272ae71b3837e4001689c9bc5a94f30b630aadc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/272ae71b3837e4001689c9bc5a94f30b630aadc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1e2610ec1742ce29883a54dc2dca0080c37bc09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e2610ec1742ce29883a54dc2dca0080c37bc09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1e2610ec1742ce29883a54dc2dca0080c37bc09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e2610ec1742ce29883a54dc2dca0080c37bc09/comments", "author": null, "committer": null, "parents": [{"sha": "e532f586e21184719c66dcedeae98c55d2c62410", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e532f586e21184719c66dcedeae98c55d2c62410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e532f586e21184719c66dcedeae98c55d2c62410"}], "stats": {"total": 67, "additions": 40, "deletions": 27}, "files": [{"sha": "85485ce3047a81f40692a3b752dfd61eb78cbdf6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e2610ec1742ce29883a54dc2dca0080c37bc09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e2610ec1742ce29883a54dc2dca0080c37bc09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1e2610ec1742ce29883a54dc2dca0080c37bc09", "patch": "@@ -1,3 +1,12 @@\n+2011-04-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cprop.c (struct reg_use): Remove.\n+\t(reg_use_table): Make an array of RTX.\n+\t(find_used_regs, constprop_register, local_cprop_pass,\n+\tbypass_block): Simplify users of reg_use_table.\n+\t(cprop_insn): Likewise.  Iterate if copy propagation succeeded\n+\ton one of the uses found by find_used_regs.\n+\n 2011-04-05  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR bootstrap/48469"}, {"sha": "24f4a84d561f74546980133f46f53315f2e72309", "filename": "gcc/cprop.c", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1e2610ec1742ce29883a54dc2dca0080c37bc09/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1e2610ec1742ce29883a54dc2dca0080c37bc09/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=c1e2610ec1742ce29883a54dc2dca0080c37bc09", "patch": "@@ -53,8 +53,6 @@ along with GCC; see the file COPYING3.  If not see\n /* An obstack for our working variables.  */\n static struct obstack cprop_obstack;\n \n-struct reg_use {rtx reg_rtx; };\n-\n /* Occurrence of an expression.\n    There is one per basic block.  If a pattern appears more than once the\n    last appearance is used.  */\n@@ -653,12 +651,12 @@ compute_cprop_data (void)\n /* Maximum number of register uses in an insn that we handle.  */\n #define MAX_USES 8\n \n-/* Table of uses found in an insn.\n+/* Table of uses (registers, both hard and pseudo) found in an insn.\n    Allocated statically to avoid alloc/free complexity and overhead.  */\n-static struct reg_use reg_use_table[MAX_USES];\n+static rtx reg_use_table[MAX_USES];\n \n /* Index into `reg_use_table' while building it.  */\n-static int reg_use_count;\n+static unsigned reg_use_count;\n \n /* Set up a list of register numbers used in INSN.  The found uses are stored\n    in `reg_use_table'.  `reg_use_count' is initialized to zero before entry,\n@@ -687,7 +685,7 @@ find_used_regs (rtx *xptr, void *data ATTRIBUTE_UNUSED)\n       if (reg_use_count == MAX_USES)\n \treturn;\n \n-      reg_use_table[reg_use_count].reg_rtx = x;\n+      reg_use_table[reg_use_count] = x;\n       reg_use_count++;\n     }\n \n@@ -997,10 +995,12 @@ constprop_register (rtx insn, rtx from, rtx to)\n static int\n cprop_insn (rtx insn)\n {\n-  struct reg_use *reg_used;\n-  int changed = 0;\n+  unsigned i;\n+  int changed = 0, changed_this_round;\n   rtx note;\n \n+retry:\n+  changed_this_round = 0;\n   reg_use_count = 0;\n   note_uses (&PATTERN (insn), find_used_regs, NULL);\n \n@@ -1009,16 +1009,16 @@ cprop_insn (rtx insn)\n   if (note)\n     find_used_regs (&XEXP (note, 0), NULL);\n \n-  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n-       reg_used++, reg_use_count--)\n+  for (i = 0; i < reg_use_count; i++)\n     {\n-      unsigned int regno = REGNO (reg_used->reg_rtx);\n+      rtx reg_used = reg_use_table[i];\n+      unsigned int regno = REGNO (reg_used);\n       rtx src;\n       struct expr *set;\n \n       /* If the register has already been set in this block, there's\n \t nothing we can do.  */\n-      if (! reg_not_set_p (reg_used->reg_rtx, insn))\n+      if (! reg_not_set_p (reg_used, insn))\n \tcontinue;\n \n       /* Find an assignment that sets reg_used and is available\n@@ -1032,9 +1032,9 @@ cprop_insn (rtx insn)\n       /* Constant propagation.  */\n       if (cprop_constant_p (src))\n \t{\n-          if (constprop_register (insn, reg_used->reg_rtx, src))\n+          if (constprop_register (insn, reg_used, src))\n \t    {\n-\t      changed = 1;\n+\t      changed_this_round = changed = 1;\n \t      global_const_prop_count++;\n \t      if (dump_file != NULL)\n \t\t{\n@@ -1051,9 +1051,9 @@ cprop_insn (rtx insn)\n \t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t       && REGNO (src) != regno)\n \t{\n-\t  if (try_replace_reg (reg_used->reg_rtx, src, insn))\n+\t  if (try_replace_reg (reg_used, src, insn))\n \t    {\n-\t      changed = 1;\n+\t      changed_this_round = changed = 1;\n \t      global_copy_prop_count++;\n \t      if (dump_file != NULL)\n \t\t{\n@@ -1069,6 +1069,11 @@ cprop_insn (rtx insn)\n \t\t and made things worse.  */\n \t    }\n \t}\n+\n+      /* If try_replace_reg simplified the insn, the regs found\n+\t by find_used_regs may not be valid anymore.  Start over.  */\n+      if (changed_this_round)\n+\tgoto retry;\n     }\n \n   if (changed && DEBUG_INSN_P (insn))\n@@ -1195,8 +1200,8 @@ local_cprop_pass (void)\n {\n   basic_block bb;\n   rtx insn;\n-  struct reg_use *reg_used;\n   bool changed = false;\n+  unsigned i;\n \n   cselib_init (0);\n   FOR_EACH_BB (bb)\n@@ -1214,10 +1219,9 @@ local_cprop_pass (void)\n \t\t  if (note)\n \t\t    local_cprop_find_used_regs (&XEXP (note, 0), NULL);\n \n-\t\t  for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n-\t\t       reg_used++, reg_use_count--)\n+\t\t  for (i = 0; i < reg_use_count; i++)\n \t\t    {\n-\t\t      if (do_local_cprop (reg_used->reg_rtx, insn))\n+\t\t      if (do_local_cprop (reg_use_table[i], insn))\n \t\t\t{\n \t\t\t  changed = true;\n \t\t\t  break;\n@@ -1226,7 +1230,7 @@ local_cprop_pass (void)\n \t\t  if (INSN_DELETED_P (insn))\n \t\t    break;\n \t\t}\n-\t      while (reg_use_count);\n+\t      while (i < reg_use_count);\n \t    }\n \t  cselib_process_insn (insn);\n \t}\n@@ -1461,9 +1465,10 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n {\n   rtx insn, note;\n   edge e, edest;\n-  int i, change;\n+  int change;\n   int may_be_loop_header;\n   unsigned removed_p;\n+  unsigned i;\n   edge_iterator ei;\n \n   insn = (setcc != NULL) ? setcc : jump;\n@@ -1513,8 +1518,8 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \n       for (i = 0; i < reg_use_count; i++)\n \t{\n-\t  struct reg_use *reg_used = &reg_use_table[i];\n-\t  unsigned int regno = REGNO (reg_used->reg_rtx);\n+\t  rtx reg_used = reg_use_table[i];\n+\t  unsigned int regno = REGNO (reg_used);\n \t  basic_block dest, old_dest;\n \t  struct expr *set;\n \t  rtx src, new_rtx;\n@@ -1525,7 +1530,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t    continue;\n \n \t  /* Check the data flow is valid after edge insertions.  */\n-\t  if (e->insns.r && reg_killed_on_edge (reg_used->reg_rtx, e))\n+\t  if (e->insns.r && reg_killed_on_edge (reg_used, e))\n \t    continue;\n \n \t  src = SET_SRC (pc_set (jump));\n@@ -1535,8 +1540,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t\t\t\t\tSET_DEST (PATTERN (setcc)),\n \t\t\t\t\tSET_SRC (PATTERN (setcc)));\n \n-\t  new_rtx = simplify_replace_rtx (src, reg_used->reg_rtx,\n-\t\t\t\t\t  set->src);\n+\t  new_rtx = simplify_replace_rtx (src, reg_used, set->src);\n \n \t  /* Jump bypassing may have already placed instructions on\n \t     edges of the CFG.  We can't bypass an outgoing edge that"}]}