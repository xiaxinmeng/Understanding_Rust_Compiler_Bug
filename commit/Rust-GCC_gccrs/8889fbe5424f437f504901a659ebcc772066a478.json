{"sha": "8889fbe5424f437f504901a659ebcc772066a478", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg4OWZiZTU0MjRmNDM3ZjUwNDkwMWE2NTllYmNjNzcyMDY2YTQ3OA==", "commit": {"author": {"name": "Monk Chiang", "email": "sh.chiang04@gmail.com", "date": "2018-05-27T16:18:24Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-05-27T16:18:24Z"}, "message": "[NDS32] Optimize movmem and setmem operations.\n\ngcc/\n\t* config/nds32/nds32-intrinsic.md (unaligned_storedi): Modify patterns\n\timplementation.\n\t(unaligned_store_dw): Ditto.\n\t* config/nds32/nds32-memory-manipulation.c\n\t(nds32_expand_movmemsi_loop_known_size): Refactoring implementation.\n\t(nds32_gen_dup_4_byte_to_word_value): Rename to ...\n\t(nds32_gen_dup_4_byte_to_word_value_aux): ... this.\n\t(emit_setmem_word_loop): Rename to ...\n\t(emit_setmem_doubleword_loop): ... this.\n\t(nds32_gen_dup_4_byte_to_word_value): New function.\n\t(nds32_gen_dup_8_byte_to_double_word_value): New function.\n\t(nds32_expand_setmem_loop): Refine implementation.\n\t(nds32_expand_setmem_loop_v3m): Ditto.\n\t* config/nds32/nds32-multiple.md (unaligned_store_update_base_dw): New\n\tpattern.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r260805", "tree": {"sha": "7a29d461fbb70054bce48b789e09a4a04a4a3a53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a29d461fbb70054bce48b789e09a4a04a4a3a53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8889fbe5424f437f504901a659ebcc772066a478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8889fbe5424f437f504901a659ebcc772066a478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8889fbe5424f437f504901a659ebcc772066a478", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8889fbe5424f437f504901a659ebcc772066a478/comments", "author": {"login": "monkchiang", "id": 62004175, "node_id": "MDQ6VXNlcjYyMDA0MTc1", "avatar_url": "https://avatars.githubusercontent.com/u/62004175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/monkchiang", "html_url": "https://github.com/monkchiang", "followers_url": "https://api.github.com/users/monkchiang/followers", "following_url": "https://api.github.com/users/monkchiang/following{/other_user}", "gists_url": "https://api.github.com/users/monkchiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/monkchiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/monkchiang/subscriptions", "organizations_url": "https://api.github.com/users/monkchiang/orgs", "repos_url": "https://api.github.com/users/monkchiang/repos", "events_url": "https://api.github.com/users/monkchiang/events{/privacy}", "received_events_url": "https://api.github.com/users/monkchiang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0be3bad7054256f009a066cce34b4cca12f3b86f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be3bad7054256f009a066cce34b4cca12f3b86f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be3bad7054256f009a066cce34b4cca12f3b86f"}], "stats": {"total": 239, "additions": 205, "deletions": 34}, "files": [{"sha": "cddfeb7ddbd7acec3322ab1ae25f91bc298b912b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8889fbe5424f437f504901a659ebcc772066a478/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8889fbe5424f437f504901a659ebcc772066a478/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8889fbe5424f437f504901a659ebcc772066a478", "patch": "@@ -1,3 +1,22 @@\n+2018-05-27  Monk Chiang  <sh.chiang04@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32-intrinsic.md (unaligned_storedi): Modify patterns\n+\timplementation.\n+\t(unaligned_store_dw): Ditto.\n+\t* config/nds32/nds32-memory-manipulation.c\n+\t(nds32_expand_movmemsi_loop_known_size): Refactoring implementation.\n+\t(nds32_gen_dup_4_byte_to_word_value): Rename to ...\n+\t(nds32_gen_dup_4_byte_to_word_value_aux): ... this.\n+\t(emit_setmem_word_loop): Rename to ...\n+\t(emit_setmem_doubleword_loop): ... this.\n+\t(nds32_gen_dup_4_byte_to_word_value): New function.\n+\t(nds32_gen_dup_8_byte_to_double_word_value): New function.\n+\t(nds32_expand_setmem_loop): Refine implementation.\n+\t(nds32_expand_setmem_loop_v3m): Ditto.\n+\t* config/nds32/nds32-multiple.md (unaligned_store_update_base_dw): New\n+\tpattern.\n+\n 2018-05-27  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32.md (bswapsi2, bswaphi2): New patterns."}, {"sha": "c70a6fcc99b9a008039eaad77d6ad07da2f99e46", "filename": "gcc/config/nds32/nds32-intrinsic.md", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8889fbe5424f437f504901a659ebcc772066a478/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8889fbe5424f437f504901a659ebcc772066a478/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.md?ref=8889fbe5424f437f504901a659ebcc772066a478", "patch": "@@ -1596,22 +1596,17 @@\n   if (TARGET_ISA_V3M)\n     nds32_expand_unaligned_store (operands, DImode);\n   else\n-    emit_insn (gen_unaligned_store_dw (operands[0], operands[1]));\n+    emit_insn (gen_unaligned_store_dw (gen_rtx_MEM (DImode, operands[0]),\n+\t\t\t\t       operands[1]));\n   DONE;\n })\n \n (define_insn \"unaligned_store_dw\"\n-  [(set (mem:DI (match_operand:SI 0 \"register_operand\" \"r\"))\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")] UNSPEC_UASTORE_DW))]\n+  [(set (match_operand:DI 0 \"nds32_lmw_smw_base_operand\"   \"=Umw\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"   r\")] UNSPEC_UASTORE_DW))]\n   \"\"\n {\n-  rtx otherops[3];\n-  otherops[0] = gen_rtx_REG (SImode, REGNO (operands[1]));\n-  otherops[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  otherops[2] = operands[0];\n-\n-  output_asm_insn (\"smw.bi\\t%0, [%2], %1, 0\", otherops);\n-  return \"\";\n+  return nds32_output_smw_double_word (operands);\n }\n   [(set_attr \"type\"   \"store\")\n    (set_attr \"length\"     \"4\")]"}, {"sha": "f6140e6513068b47afdcfd6345e7af67b8421804", "filename": "gcc/config/nds32/nds32-memory-manipulation.c", "status": "modified", "additions": 162, "deletions": 24, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8889fbe5424f437f504901a659ebcc772066a478/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8889fbe5424f437f504901a659ebcc772066a478/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c?ref=8889fbe5424f437f504901a659ebcc772066a478", "patch": "@@ -257,8 +257,124 @@ static bool\n nds32_expand_movmemsi_loop_known_size (rtx dstmem, rtx srcmem,\n \t\t\t\t       rtx size, rtx alignment)\n {\n-  return nds32_expand_movmemsi_loop_unknown_size (dstmem, srcmem,\n-\t\t\t\t\t\t  size, alignment);\n+  rtx dst_base_reg, src_base_reg;\n+  rtx dst_itr, src_itr;\n+  rtx dstmem_m, srcmem_m, dst_itr_m, src_itr_m;\n+  rtx dst_end;\n+  rtx double_word_mode_loop, byte_mode_loop;\n+  rtx tmp;\n+  int start_regno;\n+  bool align_to_4_bytes = (INTVAL (alignment) & 3) == 0;\n+  unsigned HOST_WIDE_INT total_bytes = UINTVAL (size);\n+\n+  if (TARGET_ISA_V3M && !align_to_4_bytes)\n+    return 0;\n+\n+  if (TARGET_REDUCED_REGS)\n+    start_regno = 2;\n+  else\n+    start_regno = 16;\n+\n+  dst_itr = gen_reg_rtx (Pmode);\n+  src_itr = gen_reg_rtx (Pmode);\n+  dst_end = gen_reg_rtx (Pmode);\n+  tmp = gen_reg_rtx (QImode);\n+\n+  double_word_mode_loop = gen_label_rtx ();\n+  byte_mode_loop = gen_label_rtx ();\n+\n+  dst_base_reg = copy_to_mode_reg (Pmode, XEXP (dstmem, 0));\n+  src_base_reg = copy_to_mode_reg (Pmode, XEXP (srcmem, 0));\n+\n+  if (total_bytes < 8)\n+    {\n+      /* Emit total_bytes less than 8 loop version of movmem.\n+\tadd     $dst_end, $dst, $size\n+\tmove    $dst_itr, $dst\n+\t.Lbyte_mode_loop:\n+\tlbi.bi  $tmp, [$src_itr], #1\n+\tsbi.bi  $tmp, [$dst_itr], #1\n+\t! Not readch upper bound. Loop.\n+\tbne     $dst_itr, $dst_end, .Lbyte_mode_loop */\n+\n+      /* add     $dst_end, $dst, $size */\n+      dst_end = expand_binop (Pmode, add_optab, dst_base_reg, size,\n+\t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n+      /* move    $dst_itr, $dst\n+\t move    $src_itr, $src */\n+      emit_move_insn (dst_itr, dst_base_reg);\n+      emit_move_insn (src_itr, src_base_reg);\n+\n+      /* .Lbyte_mode_loop: */\n+      emit_label (byte_mode_loop);\n+\n+      /* lbi.bi  $tmp, [$src_itr], #1 */\n+      nds32_emit_post_inc_load_store (tmp, src_itr, QImode, true);\n+\n+      /* sbi.bi  $tmp, [$dst_itr], #1 */\n+      nds32_emit_post_inc_load_store (tmp, dst_itr, QImode, false);\n+      /* ! Not readch upper bound. Loop.\n+\t bne     $dst_itr, $dst_end, .Lbyte_mode_loop */\n+      emit_cmp_and_jump_insns (dst_itr, dst_end, NE, NULL,\n+\t\t\t       SImode, 1, byte_mode_loop);\n+      return true;\n+    }\n+  else if (total_bytes % 8 == 0)\n+    {\n+      /* Emit multiple of 8 loop version of movmem.\n+\n+\t add     $dst_end, $dst, $size\n+\t move    $dst_itr, $dst\n+\t move    $src_itr, $src\n+\n+\t.Ldouble_word_mode_loop:\n+\tlmw.bim $tmp-begin, [$src_itr], $tmp-end, #0 ! $src_itr' = $src_itr\n+\tsmw.bim $tmp-begin, [$dst_itr], $tmp-end, #0 ! $dst_itr' = $dst_itr\n+\t! move will delete after register allocation\n+\tmove    $src_itr, $src_itr'\n+\tmove    $dst_itr, $dst_itr'\n+\t! Not readch upper bound. Loop.\n+\tbne     $double_word_end, $dst_itr, .Ldouble_word_mode_loop */\n+\n+      /* add     $dst_end, $dst, $size */\n+      dst_end = expand_binop (Pmode, add_optab, dst_base_reg, size,\n+\t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n+\n+      /* move    $dst_itr, $dst\n+\t move    $src_itr, $src */\n+      emit_move_insn (dst_itr, dst_base_reg);\n+      emit_move_insn (src_itr, src_base_reg);\n+\n+      /* .Ldouble_word_mode_loop: */\n+      emit_label (double_word_mode_loop);\n+      /* lmw.bim $tmp-begin, [$src_itr], $tmp-end, #0 ! $src_itr' = $src_itr\n+\t smw.bim $tmp-begin, [$dst_itr], $tmp-end, #0 ! $dst_itr' = $dst_itr */\n+      src_itr_m = src_itr;\n+      dst_itr_m = dst_itr;\n+      srcmem_m = srcmem;\n+      dstmem_m = dstmem;\n+      nds32_emit_mem_move_block (start_regno, 2,\n+\t\t\t\t &dst_itr_m, &dstmem_m,\n+\t\t\t\t &src_itr_m, &srcmem_m,\n+\t\t\t\t true);\n+      /* move    $src_itr, $src_itr'\n+\t move    $dst_itr, $dst_itr' */\n+      emit_move_insn (dst_itr, dst_itr_m);\n+      emit_move_insn (src_itr, src_itr_m);\n+\n+      /* ! Not readch upper bound. Loop.\n+\t bne     $double_word_end, $dst_itr, .Ldouble_word_mode_loop */\n+      emit_cmp_and_jump_insns (dst_end, dst_itr, NE, NULL,\n+\t\t\t       Pmode, 1, double_word_mode_loop);\n+    }\n+  else\n+    {\n+      /* Handle size greater than 8, and not a multiple of 8.  */\n+      return nds32_expand_movmemsi_loop_unknown_size (dstmem, srcmem,\n+\t\t\t\t\t\t      size, alignment);\n+    }\n+\n+  return true;\n }\n \n static bool\n@@ -433,10 +549,8 @@ nds32_expand_movmemsi (rtx dstmem, rtx srcmem, rtx total_bytes, rtx alignment)\n /* Auxiliary function for expand setmem pattern.  */\n \n static rtx\n-nds32_gen_dup_4_byte_to_word_value (rtx value)\n+nds32_gen_dup_4_byte_to_word_value_aux (rtx value, rtx value4word)\n {\n-  rtx value4word = gen_reg_rtx (SImode);\n-\n   gcc_assert (GET_MODE (value) == QImode || CONST_INT_P (value));\n \n   if (CONST_INT_P (value))\n@@ -493,7 +607,30 @@ nds32_gen_dup_4_byte_to_word_value (rtx value)\n }\n \n static rtx\n-emit_setmem_word_loop (rtx itr, rtx size, rtx value)\n+nds32_gen_dup_4_byte_to_word_value (rtx value)\n+{\n+  rtx value4word = gen_reg_rtx (SImode);\n+  nds32_gen_dup_4_byte_to_word_value_aux (value, value4word);\n+\n+  return value4word;\n+}\n+\n+static rtx\n+nds32_gen_dup_8_byte_to_double_word_value (rtx value)\n+{\n+  rtx value4doubleword = gen_reg_rtx (DImode);\n+\n+  nds32_gen_dup_4_byte_to_word_value_aux (\n+    value, nds32_di_low_part_subreg(value4doubleword));\n+\n+  emit_move_insn (nds32_di_high_part_subreg(value4doubleword),\n+\t\t  nds32_di_low_part_subreg(value4doubleword));\n+  return value4doubleword;\n+}\n+\n+\n+static rtx\n+emit_setmem_doubleword_loop (rtx itr, rtx size, rtx value)\n {\n   rtx word_mode_label = gen_label_rtx ();\n   rtx word_mode_end_label = gen_label_rtx ();\n@@ -502,9 +639,9 @@ emit_setmem_word_loop (rtx itr, rtx size, rtx value)\n   rtx word_mode_end = gen_reg_rtx (SImode);\n   rtx size_for_word = gen_reg_rtx (SImode);\n \n-  /* and     $size_for_word, $size, #~3  */\n+  /* and     $size_for_word, $size, #~0x7  */\n   size_for_word = expand_binop (SImode, and_optab, size,\n-\t\t\t\tgen_int_mode (~3, SImode),\n+\t\t\t\tgen_int_mode (~0x7, SImode),\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \n   emit_move_insn (byte_mode_size, size);\n@@ -516,8 +653,8 @@ emit_setmem_word_loop (rtx itr, rtx size, rtx value)\n   word_mode_end = expand_binop (Pmode, add_optab, itr, size_for_word,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \n-  /* andi    $byte_mode_size, $size, 3  */\n-  byte_mode_size_tmp = expand_binop (SImode, and_optab, size, GEN_INT (3),\n+  /* andi    $byte_mode_size, $size, 0x7  */\n+  byte_mode_size_tmp = expand_binop (SImode, and_optab, size, GEN_INT (0x7),\n \t\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n \n   emit_move_insn (byte_mode_size, byte_mode_size_tmp);\n@@ -527,9 +664,9 @@ emit_setmem_word_loop (rtx itr, rtx size, rtx value)\n   /*   ! word-mode set loop\n        smw.bim $value4word, [$dst_itr], $value4word, 0\n        bne     $word_mode_end, $dst_itr, .Lword_mode  */\n-  emit_insn (gen_unaligned_store_update_base_w (itr,\n-\t\t\t\t\t\titr,\n-\t\t\t\t\t\tvalue));\n+  emit_insn (gen_unaligned_store_update_base_dw (itr,\n+\t\t\t\t\t\t itr,\n+\t\t\t\t\t\t value));\n   emit_cmp_and_jump_insns (word_mode_end, itr, NE, NULL,\n \t\t\t   Pmode, 1, word_mode_label);\n \n@@ -581,7 +718,7 @@ emit_setmem_byte_loop (rtx itr, rtx size, rtx value, bool need_end)\n static bool\n nds32_expand_setmem_loop (rtx dstmem, rtx size, rtx value)\n {\n-  rtx value4word;\n+  rtx value4doubleword;\n   rtx value4byte;\n   rtx dst;\n   rtx byte_mode_size;\n@@ -624,7 +761,7 @@ nds32_expand_setmem_loop (rtx dstmem, rtx size, rtx value)\n      or      $tmp3, $tmp1, $tmp2             ! $tmp3  <- 0x0000abab\n      slli    $tmp4, $tmp3, 16                ! $tmp4  <- 0xabab0000\n      or      $val4word, $tmp3, $tmp4         ! $value4word  <- 0xabababab  */\n-  value4word = nds32_gen_dup_4_byte_to_word_value (value);\n+  value4doubleword = nds32_gen_dup_8_byte_to_double_word_value (value);\n \n   /*   and     $size_for_word, $size, #-4\n        beqz    $size_for_word, .Lword_mode_end\n@@ -637,7 +774,7 @@ nds32_expand_setmem_loop (rtx dstmem, rtx size, rtx value)\n        smw.bim $value4word, [$dst], $value4word, 0\n        bne     $word_mode_end, $dst, .Lword_mode\n      .Lword_mode_end:  */\n-  byte_mode_size = emit_setmem_word_loop (dst, size, value4word);\n+  byte_mode_size = emit_setmem_doubleword_loop (dst, size, value4doubleword);\n \n   /*   beqz    $byte_mode_size, .Lend\n        add     $byte_mode_end, $dst, $byte_mode_size\n@@ -648,8 +785,8 @@ nds32_expand_setmem_loop (rtx dstmem, rtx size, rtx value)\n        bne     $byte_mode_end, $dst, .Lbyte_mode\n      .Lend: */\n \n-  value4byte = simplify_gen_subreg (QImode, value4word, SImode,\n-\t\t\t\t    subreg_lowpart_offset (QImode, SImode));\n+  value4byte = simplify_gen_subreg (QImode, value4doubleword, DImode,\n+\t\t\t\t    subreg_lowpart_offset (QImode, DImode));\n \n   emit_setmem_byte_loop (dst, byte_mode_size, value4byte, false);\n \n@@ -666,14 +803,15 @@ nds32_expand_setmem_loop_v3m (rtx dstmem, rtx size, rtx value)\n   rtx byte_loop_size = gen_reg_rtx (SImode);\n   rtx remain_size = gen_reg_rtx (SImode);\n   rtx new_base_reg;\n-  rtx value4byte, value4word;\n+  rtx value4byte, value4doubleword;\n   rtx byte_mode_size;\n   rtx last_byte_loop_label = gen_label_rtx ();\n \n   size = force_reg (SImode, size);\n \n-  value4word = nds32_gen_dup_4_byte_to_word_value (value);\n-  value4byte = simplify_gen_subreg (QImode, value4word, SImode, 0);\n+  value4doubleword = nds32_gen_dup_8_byte_to_double_word_value (value);\n+  value4byte = simplify_gen_subreg (QImode, value4doubleword, DImode,\n+\t\t\t\t    subreg_lowpart_offset (QImode, DImode));\n \n   emit_move_insn (byte_loop_size, size);\n   emit_move_insn (byte_loop_base, base_reg);\n@@ -701,9 +839,9 @@ nds32_expand_setmem_loop_v3m (rtx dstmem, rtx size, rtx value)\n   emit_insn (gen_subsi3 (remain_size, size, need_align_bytes));\n \n   /* Set memory word by word. */\n-  byte_mode_size = emit_setmem_word_loop (new_base_reg,\n-\t\t\t\t\t  remain_size,\n-\t\t\t\t\t  value4word);\n+  byte_mode_size = emit_setmem_doubleword_loop (new_base_reg,\n+\t\t\t\t\t\tremain_size,\n+\t\t\t\t\t\tvalue4doubleword);\n \n   emit_move_insn (byte_loop_base, new_base_reg);\n   emit_move_insn (byte_loop_size, byte_mode_size);"}, {"sha": "80746b19323d6dd87fc34525a0a6cfa0e0c7214c", "filename": "gcc/config/nds32/nds32-multiple.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8889fbe5424f437f504901a659ebcc772066a478/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8889fbe5424f437f504901a659ebcc772066a478/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md?ref=8889fbe5424f437f504901a659ebcc772066a478", "patch": "@@ -2854,6 +2854,25 @@\n    (set_attr \"length\"              \"4\")]\n )\n \n+(define_expand \"unaligned_store_update_base_dw\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t   (plus:SI (match_operand:SI 1 \"register_operand\" \"0\") (const_int 8)))\n+\t      (set (mem:DI (match_dup 1))\n+\t\t   (unspec:DI [(match_operand:DI 2 \"register_operand\" \"r\")] UNSPEC_UASTORE_DW))])]\n+  \"\"\n+{\n+  /* DO NOT emit unaligned_store_w_m immediately since web pass don't\n+     recognize post_inc, try it again after GCC 5.0.\n+     REF: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63156  */\n+  emit_insn (gen_unaligned_store_dw (gen_rtx_MEM (DImode, operands[1]), operands[2]));\n+  emit_insn (gen_addsi3 (operands[0], operands[1], gen_int_mode (8, Pmode)));\n+  DONE;\n+}\n+  [(set_attr \"type\"   \"store_multiple\")\n+   (set_attr \"combo\"               \"2\")\n+   (set_attr \"length\"              \"4\")]\n+)\n+\n (define_insn \"*stmsi25\"\n   [(match_parallel 0 \"nds32_store_multiple_operation\"\n     [(set (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))"}]}