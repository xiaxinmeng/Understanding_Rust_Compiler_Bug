{"sha": "abd535b681d7bba79c3f8bc85451822fe7e4f8d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkNTM1YjY4MWQ3YmJhNzljM2Y4YmM4NTQ1MTgyMmZlN2U0ZjhkMA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-08-25T03:30:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-25T03:30:45Z"}, "message": "gcse.c (cprop_jump): New function, broken out of cprop_insn.\n\n        * gcse.c (cprop_jump): New function, broken out of cprop_insn.\n        (cprop_cc0_jump): New function.\n        (cprop_insn): Break out new function cprop_jump and use it.\n        Also use cprop_cc0_jump for machines with CC0.\n        (cprop): Don't crash if cprop_insn turned the insn into a NOTE.\n\nFrom-SVN: r28834", "tree": {"sha": "8b7837f542b26655996939408963aac7b9617fee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b7837f542b26655996939408963aac7b9617fee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abd535b681d7bba79c3f8bc85451822fe7e4f8d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd535b681d7bba79c3f8bc85451822fe7e4f8d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd535b681d7bba79c3f8bc85451822fe7e4f8d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd535b681d7bba79c3f8bc85451822fe7e4f8d0/comments", "author": null, "committer": null, "parents": [{"sha": "b6c8689d9b5bf1e163efaca313dd491c8dca50e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6c8689d9b5bf1e163efaca313dd491c8dca50e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6c8689d9b5bf1e163efaca313dd491c8dca50e0"}], "stats": {"total": 213, "additions": 137, "deletions": 76}, "files": [{"sha": "cb72d95662752823eac4ad71db7198540066c4ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd535b681d7bba79c3f8bc85451822fe7e4f8d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd535b681d7bba79c3f8bc85451822fe7e4f8d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abd535b681d7bba79c3f8bc85451822fe7e4f8d0", "patch": "@@ -110,6 +110,12 @@ Tue Aug 24 09:32:07 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n Tue Aug 24 12:35:20 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n+\t* gcse.c (cprop_jump): New function, broken out of cprop_insn.\n+\t(cprop_cc0_jump): New function.\n+\t(cprop_insn): Break out new function cprop_jump and use it.\n+\tAlso use cprop_cc0_jump for machines with CC0.\n+\t(cprop): Don't crash if cprop_insn turned the insn into a NOTE.\n+\n \t* tree.h (current_function_calls_setjmp,\n  \tcurrent_function_calls_longjmp): Delete declarations.\n \t* dsp16xx.c: Include \"function.h\"."}, {"sha": "36b376b68670a639ad9764143723c78f055a951e", "filename": "gcc/gcse.c", "status": "modified", "additions": 131, "deletions": 76, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd535b681d7bba79c3f8bc85451822fe7e4f8d0/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd535b681d7bba79c3f8bc85451822fe7e4f8d0/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=abd535b681d7bba79c3f8bc85451822fe7e4f8d0", "patch": "@@ -310,6 +310,10 @@ static char can_copy_p[(int) NUM_MACHINE_MODES];\n /* Non-zero if can_copy_p has been initialized.  */\n static int can_copy_init_p;\n \n+struct reg_use {\n+  rtx reg_rtx;\n+};\n+\n /* Hash table of expressions.  */\n \n struct expr\n@@ -572,6 +576,8 @@ static void compute_cprop_data\tPROTO ((void));\n static void find_used_regs\t    PROTO ((rtx));\n static int try_replace_reg\t    PROTO ((rtx, rtx, rtx));\n static struct expr *find_avail_set    PROTO ((int, rtx));\n+static int cprop_jump\t\t\tPROTO((rtx, rtx, struct reg_use *, rtx));\n+static int cprop_cc0_jump\t\tPROTO((rtx, struct reg_use *, rtx));\n static int cprop_insn\t\t PROTO ((rtx, int));\n static int cprop\t\t      PROTO ((int));\n static int one_cprop_pass\t     PROTO ((int, int));\n@@ -3532,10 +3538,6 @@ compute_cprop_data ()\n \f\n /* Copy/constant propagation.  */\n \n-struct reg_use {\n-  rtx reg_rtx;\n-};\n-\n /* Maximum number of register uses in an insn that we handle.  */\n #define MAX_USES 8\n \n@@ -3666,6 +3668,114 @@ find_avail_set (regno, insn)\n   return set;\n }\n \n+/* Subroutine of cprop_insn that tries to propagate constants into\n+   JUMP_INSNS.  INSN must be a conditional jump; COPY is a copy of it\n+   that we can use for substitutions.\n+   REG_USED is the use we will try to replace, SRC is the constant we\n+   will try to substitute for it.\n+   Returns nonzero if a change was made.  */\n+static int\n+cprop_jump (insn, copy, reg_used, src)\n+     rtx insn, copy;\n+     struct reg_use *reg_used;\n+     rtx src;\n+{\n+  rtx set = PATTERN (copy);\n+  rtx temp;\n+\n+  /* Replace the register with the appropriate constant.  */\n+  replace_rtx (SET_SRC (set), reg_used->reg_rtx, src);\n+\n+  temp = simplify_ternary_operation (GET_CODE (SET_SRC (set)),\n+\t\t\t\t     GET_MODE (SET_SRC (set)),\n+\t\t\t\t     GET_MODE (XEXP (SET_SRC (set), 0)),\n+\t\t\t\t     XEXP (SET_SRC (set), 0),\n+\t\t\t\t     XEXP (SET_SRC (set), 1),\n+\t\t\t\t     XEXP (SET_SRC (set), 2));\n+\n+  /* If no simplification can be made, then try the next\n+     register.  */\n+  if (temp == 0)\n+    return 0;\n+ \n+  SET_SRC (set) = temp;\n+\n+  /* That may have changed the structure of TEMP, so\n+     force it to be rerecognized if it has not turned\n+     into a nop or unconditional jump.  */\n+\t\t\n+  INSN_CODE (copy) = -1;\n+  if ((SET_DEST (set) == pc_rtx\n+       && (SET_SRC (set) == pc_rtx\n+\t   || GET_CODE (SET_SRC (set)) == LABEL_REF))\n+      || recog (PATTERN (copy), copy, NULL) >= 0)\n+    {\n+      /* This has either become an unconditional jump\n+\t or a nop-jump.  We'd like to delete nop jumps\n+\t here, but doing so confuses gcse.  So we just\n+\t make the replacement and let later passes\n+\t sort things out.  */\n+      PATTERN (insn) = set;\n+      INSN_CODE (insn) = -1;\n+\n+      /* One less use of the label this insn used to jump to\n+\t if we turned this into a NOP jump.  */\n+      if (SET_SRC (set) == pc_rtx && JUMP_LABEL (insn) != 0)\n+\t--LABEL_NUSES (JUMP_LABEL (insn));\n+\n+      /* If this has turned into an unconditional jump,\n+\t then put a barrier after it so that the unreachable\n+\t code will be deleted.  */\n+      if (GET_CODE (SET_SRC (set)) == LABEL_REF)\n+\temit_barrier_after (insn);\n+\n+      run_jump_opt_after_gcse = 1;\n+\n+      const_prop_count++;\n+      if (gcse_file != NULL)\n+\t{\n+\t  int regno = REGNO (reg_used->reg_rtx);\n+\t  fprintf (gcse_file, \"CONST-PROP: Replacing reg %d in insn %d with constant \",\n+\t\t   regno, INSN_UID (insn));\n+\t  print_rtl (gcse_file, src);\n+\t  fprintf (gcse_file, \"\\n\");\n+\t}\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+#ifdef HAVE_cc0\n+/* Subroutine of cprop_insn that tries to propagate constants into\n+   JUMP_INSNS for machines that have CC0.  INSN is a single set that\n+   stores into CC0; the insn following it is a conditional jump.\n+   REG_USED is the use we will try to replace, SRC is the constant we\n+   will try to substitute for it.\n+   Returns nonzero if a change was made.  */\n+static int\n+cprop_cc0_jump (insn, reg_used, src)\n+     rtx insn;\n+     struct reg_use *reg_used;\n+     rtx src;\n+{\n+  rtx jump = NEXT_INSN (insn);\n+  rtx copy = copy_rtx (jump);\n+  rtx set = PATTERN (copy);\n+\n+  /* We need to copy the source of the cc0 setter, as cprop_jump is going to\n+     substitute into it.  */\n+  replace_rtx (SET_SRC (set), cc0_rtx, copy_rtx (SET_SRC (PATTERN (insn))));\n+  if (! cprop_jump (jump, copy, reg_used, src))\n+    return 0;\n+\n+  /* If we succeeded, delete the cc0 setter.  */\n+  PUT_CODE (insn, NOTE);\n+  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+  NOTE_SOURCE_FILE (insn) = 0;\n+  return 1;\n+ }\n+#endif\n+ \n /* Perform constant and copy propagation on INSN.\n    The result is non-zero if a change was made.  */\n \n@@ -3743,80 +3853,23 @@ cprop_insn (insn, alter_jumps)\n \t     code, we can extend this as necessary over time.\n \n \t     Right now the insn in question must look like\n-\n-\t     (set (pc) (if_then_else ...))\n-\n-\t     Note this does not currently handle machines which use cc0.  */\n+\t     (set (pc) (if_then_else ...))  */\n \t  else if (alter_jumps\n \t\t   && GET_CODE (insn) == JUMP_INSN\n \t\t   && condjump_p (insn)\n \t\t   && ! simplejump_p (insn))\n-\t    {\n-\t      /* We want a copy of the JUMP_INSN so we can modify it\n-\t\t in-place as needed without effecting the original.  */\n-\t      rtx copy = copy_rtx (insn);\n-\t      rtx set = PATTERN (copy);\n-\t      rtx temp;\n-\n-\t      /* Replace the register with the appropriate constant.  */\n-\t      replace_rtx (SET_SRC (set), reg_used->reg_rtx, src);\n-\n-\t      temp = simplify_ternary_operation (GET_CODE (SET_SRC (set)),\n-\t\t\t\t\t\t GET_MODE (SET_SRC (set)),\n-\t\t\t\t\t\t GET_MODE (XEXP (SET_SRC (set), 0)),\n-\t\t\t\t\t\t XEXP (SET_SRC (set), 0),\n-\t\t\t\t\t\t XEXP (SET_SRC (set), 1),\n-\t\t\t\t\t\t XEXP (SET_SRC (set), 2));\n-\n-\t      /* If no simplification can be made, then try the next\n-\t\t register.  */\n-\t      if (temp)\n-\t\tSET_SRC (set) = temp;\n-\t      else\n-\t\tcontinue;\n-\n-\t      /* That may have changed the structure of TEMP, so\n-\t\t force it to be rerecognized if it has not turned\n-\t\t into a nop or unconditional jump.  */\n-\t\t\n-\t      INSN_CODE (copy) = -1;\n-\t      if ((SET_DEST (set) == pc_rtx\n-\t\t   && (SET_SRC (set) == pc_rtx\n-\t\t       || GET_CODE (SET_SRC (set)) == LABEL_REF))\n-\t\t  || recog (PATTERN (copy), copy, NULL) >= 0)\n-\t\t{\n-\t\t  /* This has either become an unconditional jump\n-\t\t     or a nop-jump.  We'd like to delete nop jumps\n-\t\t     here, but doing so confuses gcse.  So we just\n-\t\t     make the replacement and let later passes\n-\t\t     sort things out.  */\n-\t\t  PATTERN (insn) = set;\n-\t\t  INSN_CODE (insn) = -1;\n-\n-\t\t  /* One less use of the label this insn used to jump to\n-\t\t     if we turned this into a NOP jump.  */\n-\t\t  if (SET_SRC (set) == pc_rtx && JUMP_LABEL (insn) != 0)\n-\t\t    --LABEL_NUSES (JUMP_LABEL (insn));\n-\n-\t\t  /* If this has turned into an unconditional jump,\n-\t\t     then put a barrier after it so that the unreachable\n-\t\t     code will be deleted.  */\n-\t\t  if (GET_CODE (SET_SRC (set)) == LABEL_REF)\n-\t\t    emit_barrier_after (insn);\n-\n-\t\t  run_jump_opt_after_gcse = 1;\n-\n-\t\t  changed = 1;\n-\t\t  const_prop_count++;\n-\t\t  if (gcse_file != NULL)\n-\t\t    {\n-\t\t      fprintf (gcse_file, \"CONST-PROP: Replacing reg %d in insn %d with constant \",\n-\t\t\t       regno, INSN_UID (insn));\n-\t\t      print_rtl (gcse_file, src);\n-\t\t      fprintf (gcse_file, \"\\n\");\n-\t\t    }\n-\t\t}\n-\t    }\n+\t    changed |= cprop_jump (insn, copy_rtx (insn), reg_used, src);\n+#ifdef HAVE_cc0\n+\t  /* Similar code for machines that use a pair of CC0 setter and\n+\t     conditional jump insn.  */\n+\t  else if (alter_jumps\n+\t\t   && GET_CODE (PATTERN (insn)) == SET\n+\t\t   && SET_DEST (PATTERN (insn)) == cc0_rtx\n+\t\t   && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t\t   && condjump_p (NEXT_INSN (insn))\n+\t\t   && ! simplejump_p (NEXT_INSN (insn)))\n+\t    changed |= cprop_cc0_jump (insn, reg_used, src);\n+#endif\n \t}\n       else if (GET_CODE (src) == REG\n \t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n@@ -3879,8 +3932,10 @@ cprop (alter_jumps)\n \t      changed |= cprop_insn (insn, alter_jumps);\n \n \t      /* Keep track of everything modified by this insn.  */\n-\t      /* ??? Need to be careful w.r.t. mods done to INSN.  */\n-\t      mark_oprs_set (insn);\n+\t      /* ??? Need to be careful w.r.t. mods done to INSN.  Don't\n+\t         call mark_oprs_set if we turned the insn into a NOTE.  */\n+\t      if (GET_CODE (insn) != NOTE)\n+\t\tmark_oprs_set (insn);\n \t    }\n \t}\n     }"}]}