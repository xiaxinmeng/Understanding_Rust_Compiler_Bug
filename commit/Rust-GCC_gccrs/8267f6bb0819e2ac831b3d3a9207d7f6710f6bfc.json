{"sha": "8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI2N2Y2YmIwODE5ZTJhYzgzMWIzZDNhOTIwN2Q3ZjY3MTBmNmJmYw==", "commit": {"author": {"name": "David Edelsohn", "email": "dje.gcc@gmail.com", "date": "2014-04-09T19:53:39Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2014-04-09T19:53:39Z"}, "message": "Revert\n        2014-04-08  Pat Haugen  <pthaugen@us.ibm.com>\n\n        * config/rs6000/sync.md (AINT mode_iterator): Move definition.\n        (loadsync_<mode>): Change mode.\n        (load_quadpti, store_quadpti): New.\n        (atomic_load<mode>, atomic_store<mode>): Add support for TI mode.\n        * config/rs6000/rs6000.md (unspec enum): Add UNSPEC_LSQ.\n        * config/rs6000/predicates.md (quad_memory_operand): !TARGET_SYNC_TI.\n\nFrom-SVN: r209253", "tree": {"sha": "7e8d6b1a2885cc33be6ab56c93dab6bbaf99757c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e8d6b1a2885cc33be6ab56c93dab6bbaf99757c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/comments", "author": {"login": "edelsohn", "id": 667700, "node_id": "MDQ6VXNlcjY2NzcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/667700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edelsohn", "html_url": "https://github.com/edelsohn", "followers_url": "https://api.github.com/users/edelsohn/followers", "following_url": "https://api.github.com/users/edelsohn/following{/other_user}", "gists_url": "https://api.github.com/users/edelsohn/gists{/gist_id}", "starred_url": "https://api.github.com/users/edelsohn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edelsohn/subscriptions", "organizations_url": "https://api.github.com/users/edelsohn/orgs", "repos_url": "https://api.github.com/users/edelsohn/repos", "events_url": "https://api.github.com/users/edelsohn/events{/privacy}", "received_events_url": "https://api.github.com/users/edelsohn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "51970b3e3331087ad597ccd3c5df9f788e9fe3e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51970b3e3331087ad597ccd3c5df9f788e9fe3e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51970b3e3331087ad597ccd3c5df9f788e9fe3e5"}], "stats": {"total": 122, "additions": 29, "deletions": 93}, "files": [{"sha": "d55168e56916b99233cf5a3523a668a8d3efb57b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc", "patch": "@@ -1,3 +1,15 @@\n+2014-04-09  David Edelsohn  <dje.gcc@gmail.com>\n+\n+\tRevert\n+\t2014-04-08  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* config/rs6000/sync.md (AINT mode_iterator): Move definition.\n+\t(loadsync_<mode>): Change mode.\n+\t(load_quadpti, store_quadpti): New.\n+\t(atomic_load<mode>, atomic_store<mode>): Add support for TI mode.\n+\t* config/rs6000/rs6000.md (unspec enum): Add UNSPEC_LSQ.\n+\t* config/rs6000/predicates.md (quad_memory_operand): !TARGET_SYNC_TI.\n+\n 2014-04-09  Cong Hou  <congh@google.com>\n \n \tPR testsuite/60773"}, {"sha": "28f4f5d98b1e0ef95c7720c013ab5218072a9df7", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc", "patch": "@@ -624,14 +624,14 @@\n        (match_test \"offsettable_nonstrict_memref_p (op)\")))\n \n ;; Return 1 if the operand is suitable for load/store quad memory.\n-;; This predicate only checks for non-atomic loads/stores (not lqarx/stqcx).\n+;; This predicate only checks for non-atomic loads/stores.\n (define_predicate \"quad_memory_operand\"\n   (match_code \"mem\")\n {\n   rtx addr, op0, op1;\n   int ret;\n \n-  if (!TARGET_QUAD_MEMORY && !TARGET_SYNC_TI)\n+  if (!TARGET_QUAD_MEMORY)\n     ret = 0;\n \n   else if (!memory_operand (op, mode))"}, {"sha": "738011c93c9666b0f0266b0f4da4f2e6cec50eb4", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc", "patch": "@@ -125,7 +125,6 @@\n    UNSPEC_P8V_MTVSRD\n    UNSPEC_P8V_XXPERMDI\n    UNSPEC_P8V_RELOAD_FROM_VSX\n-   UNSPEC_LSQ\n   ])\n \n ;;"}, {"sha": "7db439074cd0cba75e7dcb658a3aefd155f5a9db", "filename": "gcc/config/rs6000/sync.md", "status": "modified", "additions": 15, "deletions": 90, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/gcc%2Fconfig%2Frs6000%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc/gcc%2Fconfig%2Frs6000%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsync.md?ref=8267f6bb0819e2ac831b3d3a9207d7f6710f6bfc", "patch": "@@ -107,74 +107,29 @@\n   \"isync\"\n   [(set_attr \"type\" \"isync\")])\n \n-;; Types that we should provide atomic instructions for.\n-(define_mode_iterator AINT [QI\n-\t\t\t    HI\n-\t\t\t    SI\n-\t\t\t    (DI \"TARGET_POWERPC64\")\n-\t\t\t    (TI \"TARGET_SYNC_TI\")])\n-\n ;; The control dependency used for load dependency described\n ;; in B.2.3 of the Power ISA 2.06B.\n (define_insn \"loadsync_<mode>\"\n-  [(unspec_volatile:BLK [(match_operand:AINT 0 \"register_operand\" \"r\")]\n+  [(unspec_volatile:BLK [(match_operand:INT1 0 \"register_operand\" \"r\")]\n \t\t\tUNSPECV_ISYNC)\n    (clobber (match_scratch:CC 1 \"=y\"))]\n   \"\"\n   \"cmpw %1,%0,%0\\;bne- %1,$+4\\;isync\"\n   [(set_attr \"type\" \"isync\")\n    (set_attr \"length\" \"12\")])\n \n-(define_insn \"load_quadpti\"\n-  [(set (match_operand:PTI 0 \"quad_int_reg_operand\" \"=&r\")\n-\t(unspec:PTI\n-\t [(match_operand:TI 1 \"quad_memory_operand\" \"wQ\")] UNSPEC_LSQ))]\n-  \"TARGET_SYNC_TI\n-   && !reg_mentioned_p (operands[0], operands[1])\"\n-  \"lq %0,%1\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"4\")])\n-\n (define_expand \"atomic_load<mode>\"\n-  [(set (match_operand:AINT 0 \"register_operand\" \"\")\t\t;; output\n-\t(match_operand:AINT 1 \"memory_operand\" \"\"))\t\t;; memory\n+  [(set (match_operand:INT1 0 \"register_operand\" \"\")\t\t;; output\n+\t(match_operand:INT1 1 \"memory_operand\" \"\"))\t\t;; memory\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\t\t;; model\n   \"\"\n {\n-  if (<MODE>mode == TImode && !TARGET_SYNC_TI)\n-    FAIL;\n-\n   enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n \n   if (model == MEMMODEL_SEQ_CST)\n     emit_insn (gen_hwsync ());\n \n-  if (<MODE>mode != TImode)\n-    emit_move_insn (operands[0], operands[1]);\n-  else\n-    {\n-      rtx op0 = operands[0];\n-      rtx op1 = operands[1];\n-      rtx pti_reg = gen_reg_rtx (PTImode);\n-\n-      // Can't have indexed address for 'lq'\n-      if (indexed_address (XEXP (op1, 0), TImode))\n-\t{\n-\t  rtx old_addr = XEXP (op1, 0);\n-\t  rtx new_addr = force_reg (Pmode, old_addr);\n-\t  operands[1] = op1 = replace_equiv_address (op1, new_addr);\n-\t}\n-\n-      emit_insn (gen_load_quadpti (pti_reg, op1));\n-\n-      if (WORDS_BIG_ENDIAN)\n-\temit_move_insn (op0, gen_lowpart (TImode, pti_reg));\n-      else\n-\t{\n-\t  emit_move_insn (gen_lowpart (DImode, op0), gen_highpart (DImode, pti_reg));\n-\t  emit_move_insn (gen_highpart (DImode, op0), gen_lowpart (DImode, pti_reg));\n-\t}\n-    }\n+  emit_move_insn (operands[0], operands[1]);\n \n   switch (model)\n     {\n@@ -191,24 +146,12 @@\n   DONE;\n })\n \n-(define_insn \"store_quadpti\"\n-  [(set (match_operand:PTI 0 \"quad_memory_operand\" \"=wQ\")\n-\t(unspec:PTI\n-\t [(match_operand:PTI 1 \"quad_int_reg_operand\" \"r\")] UNSPEC_LSQ))]\n-  \"TARGET_SYNC_TI\"\n-  \"stq %1,%0\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"4\")])\n-\n (define_expand \"atomic_store<mode>\"\n-  [(set (match_operand:AINT 0 \"memory_operand\" \"\")\t\t;; memory\n-\t(match_operand:AINT 1 \"register_operand\" \"\"))\t\t;; input\n+  [(set (match_operand:INT1 0 \"memory_operand\" \"\")\t\t;; memory\n+\t(match_operand:INT1 1 \"register_operand\" \"\"))\t\t;; input\n    (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\t\t;; model\n   \"\"\n {\n-  if (<MODE>mode == TImode && !TARGET_SYNC_TI)\n-    FAIL;\n-\n   enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n   switch (model)\n     {\n@@ -223,33 +166,7 @@\n     default:\n       gcc_unreachable ();\n     }\n-  if (<MODE>mode != TImode)\n-    emit_move_insn (operands[0], operands[1]);\n-  else\n-    {\n-      rtx op0 = operands[0];\n-      rtx op1 = operands[1];\n-      rtx pti_reg = gen_reg_rtx (PTImode);\n-\n-      // Can't have indexed address for 'stq'\n-      if (indexed_address (XEXP (op0, 0), TImode))\n-\t{\n-\t  rtx old_addr = XEXP (op0, 0);\n-\t  rtx new_addr = force_reg (Pmode, old_addr);\n-\t  operands[0] = op0 = replace_equiv_address (op0, new_addr);\n-\t}\n-\n-      if (WORDS_BIG_ENDIAN)\n-\temit_move_insn (pti_reg, gen_lowpart (PTImode, op1));\n-      else\n-\t{\n-\t  emit_move_insn (gen_lowpart (DImode, pti_reg), gen_highpart (DImode, op1));\n-\t  emit_move_insn (gen_highpart (DImode, pti_reg), gen_lowpart (DImode, op1));\n-\t}\n-\n-      emit_insn (gen_store_quadpti (gen_lowpart (PTImode, op0), pti_reg));\n-    }\n-\n+  emit_move_insn (operands[0], operands[1]);\n   DONE;\n })\n \n@@ -263,6 +180,14 @@\n \t\t\t      SI\n \t\t\t      (DI \"TARGET_POWERPC64\")])\n \n+;; Types that we should provide atomic instructions for.\n+\n+(define_mode_iterator AINT [QI\n+\t\t\t    HI\n+\t\t\t    SI\n+\t\t\t    (DI \"TARGET_POWERPC64\")\n+\t\t\t    (TI \"TARGET_SYNC_TI\")])\n+\n (define_insn \"load_locked<mode>\"\n   [(set (match_operand:ATOMIC 0 \"int_reg_operand\" \"=r\")\n \t(unspec_volatile:ATOMIC"}]}