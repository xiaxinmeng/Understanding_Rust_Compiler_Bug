{"sha": "a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwYzU3MTRjNjg5YmYxYzBjN2EyZDI1ODliNGRmMGVhYTQ2MzVmYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:01:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:01:00Z"}, "message": "poly_int: argument sizes\n\nThis patch changes various bits of state related to argument sizes so\nthat they have type poly_int64 rather than HOST_WIDE_INT.  This includes:\n\n- incoming_args::pops_args and incoming_args::size\n- rtl_data::outgoing_args_size\n- pending_stack_adjust\n- stack_pointer_delta\n- stack_usage::pushed_stack_size\n- args_size::constant\n\nIt also changes TARGET_RETURN_POPS_ARGS so that the size of the\narguments passed in and the size returned by the hook are both\npoly_int64s.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (return_pops_args): Treat both the input and output\n\tsizes as poly_int64s rather than HOST_WIDE_INTS.\n\t* targhooks.h (default_return_pops_args): Update accordingly.\n\t* targhooks.c (default_return_pops_args): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* emit-rtl.h (incoming_args): Change pops_args, size and\n\toutgoing_args_size from int to poly_int64_pod.\n\t* function.h (expr_status): Change x_pending_stack_adjust and\n\tx_stack_pointer_delta from int to poly_int64.\n\t(args_size::constant): Change from HOST_WIDE_INT to poly_int64.\n\t(ARGS_SIZE_RTX): Update accordingly.\n\t* calls.c (highest_outgoing_arg_in_use): Change from int to\n\tunsigned int.\n\t(stack_usage_watermark, stored_args_watermark): New variables.\n\t(stack_region_maybe_used_p, mark_stack_region_used): New functions.\n\t(emit_call_1): Change the stack_size and rounded_stack_size\n\tparameters from HOST_WIDE_INT to poly_int64.  Track n_popped\n\tas a poly_int64.\n\t(save_fixed_argument_area): Check stack_usage_watermark.\n\t(initialize_argument_information): Change old_pending_adj from\n\ta HOST_WIDE_INT * to a poly_int64_pod *.\n\t(compute_argument_block_size): Return the size as a poly_int64\n\trather than an int.\n\t(finalize_must_preallocate): Track polynomial argument sizes.\n\t(compute_argument_addresses): Likewise.\n\t(internal_arg_pointer_based_exp): Track polynomial offsets.\n\t(mem_overlaps_already_clobbered_arg_p): Rename to...\n\t(mem_might_overlap_already_clobbered_arg_p): ...this and take the\n\tsize as a poly_uint64 rather than an unsigned HOST_WIDE_INT.\n\tCheck stored_args_used_watermark.\n\t(load_register_parameters): Update accordingly.\n\t(check_sibcall_argument_overlap_1): Likewise.\n\t(combine_pending_stack_adjustment_and_call): Take the unadjusted\n\targs size as a poly_int64 rather than an int.  Return a bool\n\tindicating whether the optimization was possible and return\n\tthe new adjustment by reference.\n\t(check_sibcall_argument_overlap): Track polynomail argument sizes.\n\tUpdate stored_args_watermark.\n\t(can_implement_as_sibling_call_p): Handle polynomial argument sizes.\n\t(expand_call): Likewise.  Maintain stack_usage_watermark and\n\tstored_args_watermark.  Update calls to\n\tcombine_pending_stack_adjustment_and_call.\n\t(emit_library_call_value_1): Handle polynomial argument sizes.\n\tCall stack_region_maybe_used_p and mark_stack_region_used.\n\tMaintain stack_usage_watermark.\n\t(store_one_arg): Likewise.  Update call to\n\tmem_overlaps_already_clobbered_arg_p.\n\t* config/arm/arm.c (arm_output_function_prologue): Add a cast to\n\tHOST_WIDE_INT.\n\t* config/avr/avr.c (avr_outgoing_args_size): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_function_prologue):\n\tLikewise.\n\t* config/cr16/cr16.c (cr16_return_pops_args): Update for new\n\tTARGET_RETURN_POPS_ARGS interface.\n\t(cr16_compute_frame, cr16_initial_elimination_offset): Add casts\n\tto HOST_WIDE_INT.\n\t* config/ft32/ft32.c (ft32_compute_frame): Likewise.\n\t* config/i386/i386.c (ix86_return_pops_args): Update for new\n\tTARGET_RETURN_POPS_ARGS interface.\n\t(ix86_expand_split_stack_prologue): Add a cast to HOST_WIDE_INT.\n\t* config/moxie/moxie.c (moxie_compute_frame): Likewise.\n\t* config/m68k/m68k.c (m68k_return_pops_args): Update for new\n\tTARGET_RETURN_POPS_ARGS interface.\n\t* config/vax/vax.c (vax_return_pops_args): Likewise.\n\t* config/pa/pa.h (STACK_POINTER_OFFSET): Add a cast to poly_int64.\n\t(EXIT_IGNORE_STACK): Update reference to crtl->outgoing_args_size.\n\t* config/arm/arm.h (CALLER_INTERWORKING_SLOT_SIZE): Likewise.\n\t* config/powerpcspe/aix.h (STACK_DYNAMIC_OFFSET): Likewise.\n\t* config/powerpcspe/darwin.h (STACK_DYNAMIC_OFFSET): Likewise.\n\t* config/powerpcspe/powerpcspe.h (STACK_DYNAMIC_OFFSET): Likewise.\n\t* config/rs6000/aix.h (STACK_DYNAMIC_OFFSET): Likewise.\n\t* config/rs6000/darwin.h (STACK_DYNAMIC_OFFSET): Likewise.\n\t* config/rs6000/rs6000.h (STACK_DYNAMIC_OFFSET): Likewise.\n\t* dojump.h (saved_pending_stack_adjust): Change x_pending_stack_adjust\n\tand x_stack_pointer_delta from int to poly_int64.\n\t* dojump.c (do_pending_stack_adjust): Update accordingly.\n\t* explow.c (allocate_dynamic_stack_space): Handle polynomial\n\tstack_pointer_deltas.\n\t* function.c (STACK_DYNAMIC_OFFSET): Add a cast to poly_int64.\n\t(pad_to_arg_alignment): Track polynomial offsets.\n\t(assign_parm_find_stack_rtl): Likewise.\n\t(assign_parms, locate_and_pad_parm): Handle polynomial argument sizes.\n\t* toplev.c (output_stack_usage): Update reference to\n\tcurrent_function_pushed_stack_size.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255921", "tree": {"sha": "69d2a02e7942089893a7b94124db1ea69c6816a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69d2a02e7942089893a7b94124db1ea69c6816a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/comments", "author": null, "committer": null, "parents": [{"sha": "e6715081eddeb808bc2c8f2fa84b2f436d86a0e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6715081eddeb808bc2c8f2fa84b2f436d86a0e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6715081eddeb808bc2c8f2fa84b2f436d86a0e5"}], "stats": {"total": 860, "additions": 535, "deletions": 325}, "files": [{"sha": "729ce4eaf03d8b916756efce3392db6fda97dfe0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -1,3 +1,92 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (return_pops_args): Treat both the input and output\n+\tsizes as poly_int64s rather than HOST_WIDE_INTS.\n+\t* targhooks.h (default_return_pops_args): Update accordingly.\n+\t* targhooks.c (default_return_pops_args): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* emit-rtl.h (incoming_args): Change pops_args, size and\n+\toutgoing_args_size from int to poly_int64_pod.\n+\t* function.h (expr_status): Change x_pending_stack_adjust and\n+\tx_stack_pointer_delta from int to poly_int64.\n+\t(args_size::constant): Change from HOST_WIDE_INT to poly_int64.\n+\t(ARGS_SIZE_RTX): Update accordingly.\n+\t* calls.c (highest_outgoing_arg_in_use): Change from int to\n+\tunsigned int.\n+\t(stack_usage_watermark, stored_args_watermark): New variables.\n+\t(stack_region_maybe_used_p, mark_stack_region_used): New functions.\n+\t(emit_call_1): Change the stack_size and rounded_stack_size\n+\tparameters from HOST_WIDE_INT to poly_int64.  Track n_popped\n+\tas a poly_int64.\n+\t(save_fixed_argument_area): Check stack_usage_watermark.\n+\t(initialize_argument_information): Change old_pending_adj from\n+\ta HOST_WIDE_INT * to a poly_int64_pod *.\n+\t(compute_argument_block_size): Return the size as a poly_int64\n+\trather than an int.\n+\t(finalize_must_preallocate): Track polynomial argument sizes.\n+\t(compute_argument_addresses): Likewise.\n+\t(internal_arg_pointer_based_exp): Track polynomial offsets.\n+\t(mem_overlaps_already_clobbered_arg_p): Rename to...\n+\t(mem_might_overlap_already_clobbered_arg_p): ...this and take the\n+\tsize as a poly_uint64 rather than an unsigned HOST_WIDE_INT.\n+\tCheck stored_args_used_watermark.\n+\t(load_register_parameters): Update accordingly.\n+\t(check_sibcall_argument_overlap_1): Likewise.\n+\t(combine_pending_stack_adjustment_and_call): Take the unadjusted\n+\targs size as a poly_int64 rather than an int.  Return a bool\n+\tindicating whether the optimization was possible and return\n+\tthe new adjustment by reference.\n+\t(check_sibcall_argument_overlap): Track polynomail argument sizes.\n+\tUpdate stored_args_watermark.\n+\t(can_implement_as_sibling_call_p): Handle polynomial argument sizes.\n+\t(expand_call): Likewise.  Maintain stack_usage_watermark and\n+\tstored_args_watermark.  Update calls to\n+\tcombine_pending_stack_adjustment_and_call.\n+\t(emit_library_call_value_1): Handle polynomial argument sizes.\n+\tCall stack_region_maybe_used_p and mark_stack_region_used.\n+\tMaintain stack_usage_watermark.\n+\t(store_one_arg): Likewise.  Update call to\n+\tmem_overlaps_already_clobbered_arg_p.\n+\t* config/arm/arm.c (arm_output_function_prologue): Add a cast to\n+\tHOST_WIDE_INT.\n+\t* config/avr/avr.c (avr_outgoing_args_size): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_function_prologue):\n+\tLikewise.\n+\t* config/cr16/cr16.c (cr16_return_pops_args): Update for new\n+\tTARGET_RETURN_POPS_ARGS interface.\n+\t(cr16_compute_frame, cr16_initial_elimination_offset): Add casts\n+\tto HOST_WIDE_INT.\n+\t* config/ft32/ft32.c (ft32_compute_frame): Likewise.\n+\t* config/i386/i386.c (ix86_return_pops_args): Update for new\n+\tTARGET_RETURN_POPS_ARGS interface.\n+\t(ix86_expand_split_stack_prologue): Add a cast to HOST_WIDE_INT.\n+\t* config/moxie/moxie.c (moxie_compute_frame): Likewise.\n+\t* config/m68k/m68k.c (m68k_return_pops_args): Update for new\n+\tTARGET_RETURN_POPS_ARGS interface.\n+\t* config/vax/vax.c (vax_return_pops_args): Likewise.\n+\t* config/pa/pa.h (STACK_POINTER_OFFSET): Add a cast to poly_int64.\n+\t(EXIT_IGNORE_STACK): Update reference to crtl->outgoing_args_size.\n+\t* config/arm/arm.h (CALLER_INTERWORKING_SLOT_SIZE): Likewise.\n+\t* config/powerpcspe/aix.h (STACK_DYNAMIC_OFFSET): Likewise.\n+\t* config/powerpcspe/darwin.h (STACK_DYNAMIC_OFFSET): Likewise.\n+\t* config/powerpcspe/powerpcspe.h (STACK_DYNAMIC_OFFSET): Likewise.\n+\t* config/rs6000/aix.h (STACK_DYNAMIC_OFFSET): Likewise.\n+\t* config/rs6000/darwin.h (STACK_DYNAMIC_OFFSET): Likewise.\n+\t* config/rs6000/rs6000.h (STACK_DYNAMIC_OFFSET): Likewise.\n+\t* dojump.h (saved_pending_stack_adjust): Change x_pending_stack_adjust\n+\tand x_stack_pointer_delta from int to poly_int64.\n+\t* dojump.c (do_pending_stack_adjust): Update accordingly.\n+\t* explow.c (allocate_dynamic_stack_space): Handle polynomial\n+\tstack_pointer_deltas.\n+\t* function.c (STACK_DYNAMIC_OFFSET): Add a cast to poly_int64.\n+\t(pad_to_arg_alignment): Track polynomial offsets.\n+\t(assign_parm_find_stack_rtl): Likewise.\n+\t(assign_parms, locate_and_pad_parm): Handle polynomial argument sizes.\n+\t* toplev.c (output_stack_usage): Update reference to\n+\tcurrent_function_pushed_stack_size.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "9b7e1189918eeb35d1fdf47ba90108bf46d1610a", "filename": "gcc/calls.c", "status": "modified", "additions": 329, "deletions": 239, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -128,7 +128,11 @@ struct arg_data\n static char *stack_usage_map;\n \n /* Size of STACK_USAGE_MAP.  */\n-static int highest_outgoing_arg_in_use;\n+static unsigned int highest_outgoing_arg_in_use;\n+\n+/* Assume that any stack location at this byte index is used,\n+   without checking the contents of stack_usage_map.  */\n+static unsigned HOST_WIDE_INT stack_usage_watermark = HOST_WIDE_INT_M1U;\n \n /* A bitmap of virtual-incoming stack space.  Bit is set if the corresponding\n    stack location's tail call argument has been already stored into the stack.\n@@ -137,30 +141,24 @@ static int highest_outgoing_arg_in_use;\n    overwritten with tail call arguments.  */\n static sbitmap stored_args_map;\n \n+/* Assume that any virtual-incoming location at this byte index has been\n+   stored, without checking the contents of stored_args_map.  */\n+static unsigned HOST_WIDE_INT stored_args_watermark;\n+\n /* stack_arg_under_construction is nonzero when an argument may be\n    initialized with a constructor call (including a C function that\n    returns a BLKmode struct) and expand_call must take special action\n    to make sure the object being constructed does not overlap the\n    argument list for the constructor call.  */\n static int stack_arg_under_construction;\n \n-static void emit_call_1 (rtx, tree, tree, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t HOST_WIDE_INT, rtx, rtx, int, rtx, int,\n-\t\t\t cumulative_args_t);\n static void precompute_register_parameters (int, struct arg_data *, int *);\n static void store_bounds (struct arg_data *, struct arg_data *);\n static int store_one_arg (struct arg_data *, rtx, int, int, int);\n static void store_unaligned_arguments_into_pseudos (struct arg_data *, int);\n static int finalize_must_preallocate (int, int, struct arg_data *,\n \t\t\t\t      struct args_size *);\n static void precompute_arguments (int, struct arg_data *);\n-static int compute_argument_block_size (int, struct args_size *, tree, tree, int);\n-static void initialize_argument_information (int, struct arg_data *,\n-\t\t\t\t\t     struct args_size *, int,\n-\t\t\t\t\t     tree, tree,\n-\t\t\t\t\t     tree, tree, cumulative_args_t, int,\n-\t\t\t\t\t     rtx *, int *, int *, int *,\n-\t\t\t\t\t     bool *, bool);\n static void compute_argument_addresses (struct arg_data *, rtx, int);\n static rtx rtx_for_function_call (tree, tree);\n static void load_register_parameters (struct arg_data *, int, rtx *, int,\n@@ -169,15 +167,53 @@ static int special_function_p (const_tree, int);\n static int check_sibcall_argument_overlap_1 (rtx);\n static int check_sibcall_argument_overlap (rtx_insn *, struct arg_data *, int);\n \n-static int combine_pending_stack_adjustment_and_call (int, struct args_size *,\n-\t\t\t\t\t\t      unsigned int);\n static tree split_complex_types (tree);\n \n #ifdef REG_PARM_STACK_SPACE\n static rtx save_fixed_argument_area (int, rtx, int *, int *);\n static void restore_fixed_argument_area (rtx, rtx, int, int);\n #endif\n \f\n+/* Return true if bytes [LOWER_BOUND, UPPER_BOUND) of the outgoing\n+   stack region might already be in use.  */\n+\n+static bool\n+stack_region_maybe_used_p (poly_uint64 lower_bound, poly_uint64 upper_bound,\n+\t\t\t   unsigned int reg_parm_stack_space)\n+{\n+  unsigned HOST_WIDE_INT const_lower, const_upper;\n+  const_lower = constant_lower_bound (lower_bound);\n+  if (!upper_bound.is_constant (&const_upper))\n+    const_upper = HOST_WIDE_INT_M1U;\n+\n+  if (const_upper > stack_usage_watermark)\n+    return true;\n+\n+  /* Don't worry about things in the fixed argument area;\n+     it has already been saved.  */\n+  const_lower = MAX (const_lower, reg_parm_stack_space);\n+  const_upper = MIN (const_upper, highest_outgoing_arg_in_use);\n+  for (unsigned HOST_WIDE_INT i = const_lower; i < const_upper; ++i)\n+    if (stack_usage_map[i])\n+      return true;\n+  return false;\n+}\n+\n+/* Record that bytes [LOWER_BOUND, UPPER_BOUND) of the outgoing\n+   stack region are now in use.  */\n+\n+static void\n+mark_stack_region_used (poly_uint64 lower_bound, poly_uint64 upper_bound)\n+{\n+  unsigned HOST_WIDE_INT const_lower, const_upper;\n+  const_lower = constant_lower_bound (lower_bound);\n+  if (upper_bound.is_constant (&const_upper))\n+    for (unsigned HOST_WIDE_INT i = const_lower; i < const_upper; ++i)\n+      stack_usage_map[i] = 1;\n+  else\n+    stack_usage_watermark = MIN (stack_usage_watermark, const_lower);\n+}\n+\n /* Force FUNEXP into a form suitable for the address of a CALL,\n    and return that as an rtx.  Also load the static chain register\n    if FNDECL is a nested function.\n@@ -340,17 +376,17 @@ prepare_call_address (tree fndecl_or_type, rtx funexp, rtx static_chain_value,\n static void\n emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNUSED,\n \t     tree funtype ATTRIBUTE_UNUSED,\n-\t     HOST_WIDE_INT stack_size ATTRIBUTE_UNUSED,\n-\t     HOST_WIDE_INT rounded_stack_size,\n+\t     poly_int64 stack_size ATTRIBUTE_UNUSED,\n+\t     poly_int64 rounded_stack_size,\n \t     HOST_WIDE_INT struct_value_size ATTRIBUTE_UNUSED,\n \t     rtx next_arg_reg ATTRIBUTE_UNUSED, rtx valreg,\n \t     int old_inhibit_defer_pop, rtx call_fusage, int ecf_flags,\n \t     cumulative_args_t args_so_far ATTRIBUTE_UNUSED)\n {\n-  rtx rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n+  rtx rounded_stack_size_rtx = gen_int_mode (rounded_stack_size, Pmode);\n   rtx call, funmem, pat;\n   int already_popped = 0;\n-  HOST_WIDE_INT n_popped = 0;\n+  poly_int64 n_popped = 0;\n \n   /* Sibling call patterns never pop arguments (no sibcall(_value)_pop\n      patterns exist).  Any popping that the callee does on return will\n@@ -408,12 +444,12 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n      if no arguments are actually popped.  If the target does not have\n      \"call\" or \"call_value\" insns, then we must use the popping versions\n      even if the call has no arguments to pop.  */\n-  else if (n_popped > 0\n+  else if (maybe_ne (n_popped, 0)\n \t   || !(valreg\n \t\t? targetm.have_call_value ()\n \t\t: targetm.have_call ()))\n     {\n-      rtx n_pop = GEN_INT (n_popped);\n+      rtx n_pop = gen_int_mode (n_popped, Pmode);\n \n       /* If this subroutine pops its own args, record that in the call insn\n \t if possible, for the sake of frame pointer elimination.  */\n@@ -487,15 +523,15 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n      if the context of the call as a whole permits.  */\n   inhibit_defer_pop = old_inhibit_defer_pop;\n \n-  if (n_popped > 0)\n+  if (maybe_ne (n_popped, 0))\n     {\n       if (!already_popped)\n \tCALL_INSN_FUNCTION_USAGE (call_insn)\n \t  = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t       gen_rtx_CLOBBER (VOIDmode, stack_pointer_rtx),\n \t\t\t       CALL_INSN_FUNCTION_USAGE (call_insn));\n       rounded_stack_size -= n_popped;\n-      rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n+      rounded_stack_size_rtx = gen_int_mode (rounded_stack_size, Pmode);\n       stack_pointer_delta -= n_popped;\n \n       add_args_size_note (call_insn, stack_pointer_delta);\n@@ -519,7 +555,7 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \t If returning from the subroutine does pop the args, indicate that the\n \t stack pointer will be changed.  */\n \n-      if (rounded_stack_size != 0)\n+      if (maybe_ne (rounded_stack_size, 0))\n \t{\n \t  if (ecf_flags & ECF_NORETURN)\n \t    /* Just pretend we did the pop.  */\n@@ -542,8 +578,8 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \n      ??? It will be worthwhile to enable combine_stack_adjustments even for\n      such machines.  */\n-  else if (n_popped)\n-    anti_adjust_stack (GEN_INT (n_popped));\n+  else if (maybe_ne (n_popped, 0))\n+    anti_adjust_stack (gen_int_mode (n_popped, Pmode));\n }\n \n /* Determine if the function identified by FNDECL is one with\n@@ -1009,8 +1045,8 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,\n static rtx\n save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_save, int *high_to_save)\n {\n-  int low;\n-  int high;\n+  unsigned int low;\n+  unsigned int high;\n \n   /* Compute the boundary of the area that needs to be saved, if any.  */\n   high = reg_parm_stack_space;\n@@ -1021,7 +1057,7 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n     high = highest_outgoing_arg_in_use;\n \n   for (low = 0; low < high; low++)\n-    if (stack_usage_map[low] != 0)\n+    if (stack_usage_map[low] != 0 || low >= stack_usage_watermark)\n       {\n \tint num_to_save;\n \tmachine_mode save_mode;\n@@ -1722,7 +1758,8 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t\t\t tree fndecl, tree fntype,\n \t\t\t\t cumulative_args_t args_so_far,\n \t\t\t\t int reg_parm_stack_space,\n-\t\t\t\t rtx *old_stack_level, int *old_pending_adj,\n+\t\t\t\t rtx *old_stack_level,\n+\t\t\t\t poly_int64_pod *old_pending_adj,\n \t\t\t\t int *must_preallocate, int *ecf_flags,\n \t\t\t\t bool *may_tailcall, bool call_from_thunk_p)\n {\n@@ -2133,14 +2170,14 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n    REG_PARM_STACK_SPACE holds the number of bytes of stack space reserved\n    for arguments passed in registers.  */\n \n-static int\n+static poly_int64\n compute_argument_block_size (int reg_parm_stack_space,\n \t\t\t     struct args_size *args_size,\n \t\t\t     tree fndecl ATTRIBUTE_UNUSED,\n \t\t\t     tree fntype ATTRIBUTE_UNUSED,\n \t\t\t     int preferred_stack_boundary ATTRIBUTE_UNUSED)\n {\n-  int unadjusted_args_size = args_size->constant;\n+  poly_int64 unadjusted_args_size = args_size->constant;\n \n   /* For accumulate outgoing args mode we don't need to align, since the frame\n      will be already aligned.  Align to STACK_BOUNDARY in order to prevent\n@@ -2163,7 +2200,8 @@ compute_argument_block_size (int reg_parm_stack_space,\n \t  /* We don't handle this case yet.  To handle it correctly we have\n \t     to add the delta, round and subtract the delta.\n \t     Currently no machine description requires this support.  */\n-\t  gcc_assert (!(stack_pointer_delta & (preferred_stack_boundary - 1)));\n+\t  gcc_assert (multiple_p (stack_pointer_delta,\n+\t\t\t\t  preferred_stack_boundary));\n \t  args_size->var = round_up (args_size->var, preferred_stack_boundary);\n \t}\n \n@@ -2186,15 +2224,13 @@ compute_argument_block_size (int reg_parm_stack_space,\n       preferred_stack_boundary /= BITS_PER_UNIT;\n       if (preferred_stack_boundary < 1)\n \tpreferred_stack_boundary = 1;\n-      args_size->constant = (((args_size->constant\n-\t\t\t       + stack_pointer_delta\n-\t\t\t       + preferred_stack_boundary - 1)\n-\t\t\t      / preferred_stack_boundary\n-\t\t\t      * preferred_stack_boundary)\n+      args_size->constant = (aligned_upper_bound (args_size->constant\n+\t\t\t\t\t\t  + stack_pointer_delta,\n+\t\t\t\t\t\t  preferred_stack_boundary)\n \t\t\t     - stack_pointer_delta);\n \n-      args_size->constant = MAX (args_size->constant,\n-\t\t\t\t reg_parm_stack_space);\n+      args_size->constant = upper_bound (args_size->constant,\n+\t\t\t\t\t reg_parm_stack_space);\n \n       if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \targs_size->constant -= reg_parm_stack_space;\n@@ -2299,7 +2335,7 @@ finalize_must_preallocate (int must_preallocate, int num_actuals,\n   if (! must_preallocate)\n     {\n       int partial_seen = 0;\n-      int copy_to_evaluate_size = 0;\n+      poly_int64 copy_to_evaluate_size = 0;\n       int i;\n \n       for (i = 0; i < num_actuals && ! must_preallocate; i++)\n@@ -2324,8 +2360,8 @@ finalize_must_preallocate (int must_preallocate, int num_actuals,\n \t      += int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n \t}\n \n-      if (copy_to_evaluate_size * 2 >= args_size->constant\n-\t  && args_size->constant > 0)\n+      if (maybe_ne (args_size->constant, 0)\n+\t  && maybe_ge (copy_to_evaluate_size * 2, args_size->constant))\n \tmust_preallocate = 1;\n     }\n   return must_preallocate;\n@@ -2345,18 +2381,22 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n   if (argblock)\n     {\n       rtx arg_reg = argblock;\n-      int i, arg_offset = 0;\n+      int i;\n+      poly_int64 arg_offset = 0;\n \n       if (GET_CODE (argblock) == PLUS)\n-\targ_reg = XEXP (argblock, 0), arg_offset = INTVAL (XEXP (argblock, 1));\n+\t{\n+\t  arg_reg = XEXP (argblock, 0);\n+\t  arg_offset = rtx_to_poly_int64 (XEXP (argblock, 1));\n+\t}\n \n       for (i = 0; i < num_actuals; i++)\n \t{\n \t  rtx offset = ARGS_SIZE_RTX (args[i].locate.offset);\n \t  rtx slot_offset = ARGS_SIZE_RTX (args[i].locate.slot_offset);\n \t  rtx addr;\n \t  unsigned int align, boundary;\n-\t  unsigned int units_on_stack = 0;\n+\t  poly_uint64 units_on_stack = 0;\n \t  machine_mode partial_mode = VOIDmode;\n \n \t  /* Skip this parm if it will not be passed on the stack.  */\n@@ -2380,7 +2420,7 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t      /* Only part of the parameter is being passed on the stack.\n \t\t Generate a simple memory reference of the correct size.  */\n \t      units_on_stack = args[i].locate.size.constant;\n-\t      unsigned int bits_on_stack = units_on_stack * BITS_PER_UNIT;\n+\t      poly_uint64 bits_on_stack = units_on_stack * BITS_PER_UNIT;\n \t      partial_mode = int_mode_for_size (bits_on_stack, 1).else_blk ();\n \t      args[i].stack = gen_rtx_MEM (partial_mode, addr);\n \t      set_mem_size (args[i].stack, units_on_stack);\n@@ -2393,12 +2433,16 @@ compute_argument_addresses (struct arg_data *args, rtx argblock, int num_actuals\n \t    }\n \t  align = BITS_PER_UNIT;\n \t  boundary = args[i].locate.boundary;\n+\t  poly_int64 offset_val;\n \t  if (args[i].locate.where_pad != PAD_DOWNWARD)\n \t    align = boundary;\n-\t  else if (CONST_INT_P (offset))\n+\t  else if (poly_int_rtx_p (offset, &offset_val))\n \t    {\n-\t      align = INTVAL (offset) * BITS_PER_UNIT | boundary;\n-\t      align = least_bit_hwi (align);\n+\t      align = least_bit_hwi (boundary);\n+\t      unsigned int offset_align\n+\t\t= known_alignment (offset_val) * BITS_PER_UNIT;\n+\t      if (offset_align != 0)\n+\t\talign = MIN (align, offset_align);\n \t    }\n \t  set_mem_align (args[i].stack, align);\n \n@@ -2552,12 +2596,13 @@ internal_arg_pointer_based_exp (const_rtx rtl, bool toplevel)\n   if (REG_P (rtl) && HARD_REGISTER_P (rtl))\n     return NULL_RTX;\n \n-  if (GET_CODE (rtl) == PLUS && CONST_INT_P (XEXP (rtl, 1)))\n+  poly_int64 offset;\n+  if (GET_CODE (rtl) == PLUS && poly_int_rtx_p (XEXP (rtl, 1), &offset))\n     {\n       rtx val = internal_arg_pointer_based_exp (XEXP (rtl, 0), toplevel);\n       if (val == NULL_RTX || val == pc_rtx)\n \treturn val;\n-      return plus_constant (Pmode, val, INTVAL (XEXP (rtl, 1)));\n+      return plus_constant (Pmode, val, offset);\n     }\n \n   /* When called at the topmost level, scan pseudo assignments in between the\n@@ -2588,45 +2633,53 @@ internal_arg_pointer_based_exp (const_rtx rtl, bool toplevel)\n   return NULL_RTX;\n }\n \n-/* Return true if and only if SIZE storage units (usually bytes)\n-   starting from address ADDR overlap with already clobbered argument\n-   area.  This function is used to determine if we should give up a\n-   sibcall.  */\n+/* Return true if SIZE bytes starting from address ADDR might overlap an\n+   already-clobbered argument area.  This function is used to determine\n+   if we should give up a sibcall.  */\n \n static bool\n-mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n+mem_might_overlap_already_clobbered_arg_p (rtx addr, poly_uint64 size)\n {\n-  HOST_WIDE_INT i;\n+  poly_int64 i;\n+  unsigned HOST_WIDE_INT start, end;\n   rtx val;\n \n-  if (bitmap_empty_p (stored_args_map))\n+  if (bitmap_empty_p (stored_args_map)\n+      && stored_args_watermark == HOST_WIDE_INT_M1U)\n     return false;\n   val = internal_arg_pointer_based_exp (addr, true);\n   if (val == NULL_RTX)\n     return false;\n-  else if (val == pc_rtx)\n+  else if (!poly_int_rtx_p (val, &i))\n     return true;\n-  else\n-    i = INTVAL (val);\n+\n+  if (known_eq (size, 0U))\n+    return false;\n \n   if (STACK_GROWS_DOWNWARD)\n     i -= crtl->args.pretend_args_size;\n   else\n     i += crtl->args.pretend_args_size;\n \n-\n   if (ARGS_GROW_DOWNWARD)\n     i = -i - size;\n \n-  if (size > 0)\n-    {\n-      unsigned HOST_WIDE_INT k;\n+  /* We can ignore any references to the function's pretend args,\n+     which at this point would manifest as negative values of I.  */\n+  if (known_le (i, 0) && known_le (size, poly_uint64 (-i)))\n+    return false;\n \n-      for (k = 0; k < size; k++)\n-\tif (i + k < SBITMAP_SIZE (stored_args_map)\n-\t    && bitmap_bit_p (stored_args_map, i + k))\n-\t  return true;\n-    }\n+  start = maybe_lt (i, 0) ? 0 : constant_lower_bound (i);\n+  if (!(i + size).is_constant (&end))\n+    end = HOST_WIDE_INT_M1U;\n+\n+  if (end > stored_args_watermark)\n+    return true;\n+\n+  end = MIN (end, SBITMAP_SIZE (stored_args_map));\n+  for (unsigned HOST_WIDE_INT k = start; k < end; ++k)\n+    if (bitmap_bit_p (stored_args_map, k))\n+      return true;\n \n   return false;\n }\n@@ -2730,7 +2783,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t         providing that this has non-zero size.  */\n \t      if (is_sibcall\n \t\t  && size != 0\n-\t\t  && (mem_overlaps_already_clobbered_arg_p\n+\t\t  && (mem_might_overlap_already_clobbered_arg_p\n \t\t      (XEXP (args[i].value, 0), size)))\n \t\t*sibcall_failure = 1;\n \n@@ -2799,27 +2852,32 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n /* We need to pop PENDING_STACK_ADJUST bytes.  But, if the arguments\n    wouldn't fill up an even multiple of PREFERRED_UNIT_STACK_BOUNDARY\n    bytes, then we would need to push some additional bytes to pad the\n-   arguments.  So, we compute an adjust to the stack pointer for an\n+   arguments.  So, we try to compute an adjust to the stack pointer for an\n    amount that will leave the stack under-aligned by UNADJUSTED_ARGS_SIZE\n    bytes.  Then, when the arguments are pushed the stack will be perfectly\n-   aligned.  ARGS_SIZE->CONSTANT is set to the number of bytes that should\n-   be popped after the call.  Returns the adjustment.  */\n+   aligned.\n \n-static int\n-combine_pending_stack_adjustment_and_call (int unadjusted_args_size,\n+   Return true if this optimization is possible, storing the adjustment\n+   in ADJUSTMENT_OUT and setting ARGS_SIZE->CONSTANT to the number of\n+   bytes that should be popped after the call.  */\n+\n+static bool\n+combine_pending_stack_adjustment_and_call (poly_int64_pod *adjustment_out,\n+\t\t\t\t\t   poly_int64 unadjusted_args_size,\n \t\t\t\t\t   struct args_size *args_size,\n \t\t\t\t\t   unsigned int preferred_unit_stack_boundary)\n {\n   /* The number of bytes to pop so that the stack will be\n      under-aligned by UNADJUSTED_ARGS_SIZE bytes.  */\n-  HOST_WIDE_INT adjustment;\n+  poly_int64 adjustment;\n   /* The alignment of the stack after the arguments are pushed, if we\n      just pushed the arguments without adjust the stack here.  */\n   unsigned HOST_WIDE_INT unadjusted_alignment;\n \n-  unadjusted_alignment\n-    = ((stack_pointer_delta + unadjusted_args_size)\n-       % preferred_unit_stack_boundary);\n+  if (!known_misalignment (stack_pointer_delta + unadjusted_args_size,\n+\t\t\t   preferred_unit_stack_boundary,\n+\t\t\t   &unadjusted_alignment))\n+    return false;\n \n   /* We want to get rid of as many of the PENDING_STACK_ADJUST bytes\n      as possible -- leaving just enough left to cancel out the\n@@ -2828,23 +2886,33 @@ combine_pending_stack_adjustment_and_call (int unadjusted_args_size,\n      -UNADJUSTED_ALIGNMENT modulo the PREFERRED_UNIT_STACK_BOUNDARY.  */\n \n   /* Begin by trying to pop all the bytes.  */\n-  unadjusted_alignment\n-    = (unadjusted_alignment\n-       - (pending_stack_adjust % preferred_unit_stack_boundary));\n+  unsigned HOST_WIDE_INT tmp_misalignment;\n+  if (!known_misalignment (pending_stack_adjust,\n+\t\t\t   preferred_unit_stack_boundary,\n+\t\t\t   &tmp_misalignment))\n+    return false;\n+  unadjusted_alignment -= tmp_misalignment;\n   adjustment = pending_stack_adjust;\n   /* Push enough additional bytes that the stack will be aligned\n      after the arguments are pushed.  */\n   if (preferred_unit_stack_boundary > 1 && unadjusted_alignment)\n     adjustment -= preferred_unit_stack_boundary - unadjusted_alignment;\n \n+  /* We need to know whether the adjusted argument size\n+     (UNADJUSTED_ARGS_SIZE - ADJUSTMENT) constitutes an allocation\n+     or a deallocation.  */\n+  if (!ordered_p (adjustment, unadjusted_args_size))\n+    return false;\n+\n   /* Now, sets ARGS_SIZE->CONSTANT so that we pop the right number of\n      bytes after the call.  The right number is the entire\n      PENDING_STACK_ADJUST less our ADJUSTMENT plus the amount required\n      by the arguments in the first place.  */\n   args_size->constant\n     = pending_stack_adjust - adjustment + unadjusted_args_size;\n \n-  return adjustment;\n+  *adjustment_out = adjustment;\n+  return true;\n }\n \n /* Scan X expression if it does not dereference any argument slots\n@@ -2870,8 +2938,8 @@ check_sibcall_argument_overlap_1 (rtx x)\n     return 0;\n \n   if (code == MEM)\n-    return mem_overlaps_already_clobbered_arg_p (XEXP (x, 0),\n-\t\t\t\t\t\t GET_MODE_SIZE (GET_MODE (x)));\n+    return (mem_might_overlap_already_clobbered_arg_p\n+\t    (XEXP (x, 0), GET_MODE_SIZE (GET_MODE (x))));\n \n   /* Scan all subexpressions.  */\n   fmt = GET_RTX_FORMAT (code);\n@@ -2903,7 +2971,8 @@ static int\n check_sibcall_argument_overlap (rtx_insn *insn, struct arg_data *arg,\n \t\t\t\tint mark_stored_args_map)\n {\n-  int low, high;\n+  poly_uint64 low, high;\n+  unsigned HOST_WIDE_INT const_low, const_high;\n \n   if (insn == NULL_RTX)\n     insn = get_insns ();\n@@ -2921,9 +2990,14 @@ check_sibcall_argument_overlap (rtx_insn *insn, struct arg_data *arg,\n \tlow = -arg->locate.slot_offset.constant - arg->locate.size.constant;\n       else\n \tlow = arg->locate.slot_offset.constant;\n+      high = low + arg->locate.size.constant;\n \n-      for (high = low + arg->locate.size.constant; low < high; low++)\n-\tbitmap_set_bit (stored_args_map, low);\n+      const_low = constant_lower_bound (low);\n+      if (high.is_constant (&const_high))\n+\tfor (unsigned HOST_WIDE_INT i = const_low; i < const_high; ++i)\n+\t  bitmap_set_bit (stored_args_map, i);\n+      else\n+\tstored_args_watermark = MIN (stored_args_watermark, const_low);\n     }\n   return insn != NULL_RTX;\n }\n@@ -3066,7 +3140,8 @@ can_implement_as_sibling_call_p (tree exp,\n      function, we cannot change it into a sibling call.\n      crtl->args.pretend_args_size is not part of the\n      stack allocated by our caller.  */\n-  if (args_size.constant > (crtl->args.size - crtl->args.pretend_args_size))\n+  if (maybe_gt (args_size.constant,\n+\t\tcrtl->args.size - crtl->args.pretend_args_size))\n     {\n       maybe_complain_about_tail_call (exp,\n \t\t\t\t      \"callee required more stack slots\"\n@@ -3076,10 +3151,12 @@ can_implement_as_sibling_call_p (tree exp,\n \n   /* If the callee pops its own arguments, then it must pop exactly\n      the same number of arguments as the current function.  */\n-  if (targetm.calls.return_pops_args (fndecl, funtype, args_size.constant)\n-      != targetm.calls.return_pops_args (current_function_decl,\n-\t\t\t\t\t TREE_TYPE (current_function_decl),\n-\t\t\t\t\t crtl->args.size))\n+  if (maybe_ne (targetm.calls.return_pops_args (fndecl, funtype,\n+\t\t\t\t\t\targs_size.constant),\n+\t\ttargetm.calls.return_pops_args (current_function_decl,\n+\t\t\t\t\t\tTREE_TYPE\n+\t\t\t\t\t\t(current_function_decl),\n+\t\t\t\t\t\tcrtl->args.size)))\n     {\n       maybe_complain_about_tail_call (exp,\n \t\t\t\t      \"inconsistent number of\"\n@@ -3169,7 +3246,7 @@ expand_call (tree exp, rtx target, int ignore)\n   struct args_size args_size;\n   struct args_size adjusted_args_size;\n   /* Size of arguments before any adjustments (such as rounding).  */\n-  int unadjusted_args_size;\n+  poly_int64 unadjusted_args_size;\n   /* Data on reg parms scanned so far.  */\n   CUMULATIVE_ARGS args_so_far_v;\n   cumulative_args_t args_so_far;\n@@ -3202,22 +3279,23 @@ expand_call (tree exp, rtx target, int ignore)\n   rtx save_area = 0;\t\t/* Place that it is saved */\n #endif\n \n-  int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n+  unsigned int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n   char *initial_stack_usage_map = stack_usage_map;\n+  unsigned HOST_WIDE_INT initial_stack_usage_watermark = stack_usage_watermark;\n   char *stack_usage_map_buf = NULL;\n \n-  int old_stack_allocated;\n+  poly_int64 old_stack_allocated;\n \n   /* State variables to track stack modifications.  */\n   rtx old_stack_level = 0;\n   int old_stack_arg_under_construction = 0;\n-  int old_pending_adj = 0;\n+  poly_int64 old_pending_adj = 0;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n \n   /* Some stack pointer alterations we make are performed via\n      allocate_dynamic_stack_space. This modifies the stack_pointer_delta,\n      which we then also need to save/restore along the way.  */\n-  int old_stack_pointer_delta = 0;\n+  poly_int64 old_stack_pointer_delta = 0;\n \n   rtx call_fusage;\n   tree addr = CALL_EXPR_FN (exp);\n@@ -3481,7 +3559,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t  || reg_mentioned_p (virtual_outgoing_args_rtx,\n \t\t\t      structure_value_addr))\n       && (args_size.var\n-\t  || (!ACCUMULATE_OUTGOING_ARGS && args_size.constant)))\n+\t  || (!ACCUMULATE_OUTGOING_ARGS\n+\t      && maybe_ne (args_size.constant, 0))))\n     structure_value_addr = copy_to_reg (structure_value_addr);\n \n   /* Tail calls can make things harder to debug, and we've traditionally\n@@ -3597,10 +3676,10 @@ expand_call (tree exp, rtx target, int ignore)\n \t call sequence.\n \t Also do the adjustments before a throwing call, otherwise\n \t exception handling can fail; PR 19225. */\n-      if (pending_stack_adjust >= 32\n-\t  || (pending_stack_adjust > 0\n+      if (maybe_ge (pending_stack_adjust, 32)\n+\t  || (maybe_ne (pending_stack_adjust, 0)\n \t      && (flags & ECF_MAY_BE_ALLOCA))\n-\t  || (pending_stack_adjust > 0\n+\t  || (maybe_ne (pending_stack_adjust, 0)\n \t      && flag_exceptions && !(flags & ECF_NOTHROW))\n \t  || pass == 0)\n \tdo_pending_stack_adjust ();\n@@ -3646,8 +3725,10 @@ expand_call (tree exp, rtx target, int ignore)\n \t    argblock\n \t      = plus_constant (Pmode, argblock, -crtl->args.pretend_args_size);\n \n-\t  stored_args_map = sbitmap_alloc (args_size.constant);\n+\t  HOST_WIDE_INT map_size = constant_lower_bound (args_size.constant);\n+\t  stored_args_map = sbitmap_alloc (map_size);\n \t  bitmap_clear (stored_args_map);\n+\t  stored_args_watermark = HOST_WIDE_INT_M1U;\n \t}\n \n       /* If we have no actual push instructions, or shouldn't use them,\n@@ -3677,14 +3758,14 @@ expand_call (tree exp, rtx target, int ignore)\n \t     in the area reserved for register arguments, which may be part of\n \t     the stack frame.  */\n \n-\t  int needed = adjusted_args_size.constant;\n+\t  poly_int64 needed = adjusted_args_size.constant;\n \n \t  /* Store the maximum argument space used.  It will be pushed by\n \t     the prologue (if ACCUMULATE_OUTGOING_ARGS, or stack overflow\n \t     checking).  */\n \n-\t  if (needed > crtl->outgoing_args_size)\n-\t    crtl->outgoing_args_size = needed;\n+\t  crtl->outgoing_args_size = upper_bound (crtl->outgoing_args_size,\n+\t\t\t\t\t\t  needed);\n \n \t  if (must_preallocate)\n \t    {\n@@ -3710,12 +3791,16 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \t\t    needed += reg_parm_stack_space;\n \n+\t\t  poly_int64 limit = needed;\n \t\t  if (ARGS_GROW_DOWNWARD)\n-\t\t    highest_outgoing_arg_in_use\n-\t\t      = MAX (initial_highest_arg_in_use, needed + 1);\n-\t\t  else\n-\t\t    highest_outgoing_arg_in_use\n-\t\t      = MAX (initial_highest_arg_in_use, needed);\n+\t\t    limit += 1;\n+\n+\t\t  /* For polynomial sizes, this is the maximum possible\n+\t\t     size needed for arguments with a constant size\n+\t\t     and offset.  */\n+\t\t  HOST_WIDE_INT const_limit = constant_lower_bound (limit);\n+\t\t  highest_outgoing_arg_in_use\n+\t\t    = MAX (initial_highest_arg_in_use, const_limit);\n \n \t\t  free (stack_usage_map_buf);\n \t\t  stack_usage_map_buf = XNEWVEC (char, highest_outgoing_arg_in_use);\n@@ -3740,23 +3825,25 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (inhibit_defer_pop == 0)\n+\t\t  /* Try to reuse some or all of the pending_stack_adjust\n+\t\t     to get this space.  */\n+\t\t  if (inhibit_defer_pop == 0\n+\t\t      && (combine_pending_stack_adjustment_and_call\n+\t\t\t  (&needed,\n+\t\t\t   unadjusted_args_size,\n+\t\t\t   &adjusted_args_size,\n+\t\t\t   preferred_unit_stack_boundary)))\n \t\t    {\n-\t\t      /* Try to reuse some or all of the pending_stack_adjust\n-\t\t\t to get this space.  */\n-\t\t      needed\n-\t\t\t= (combine_pending_stack_adjustment_and_call\n-\t\t\t   (unadjusted_args_size,\n-\t\t\t    &adjusted_args_size,\n-\t\t\t    preferred_unit_stack_boundary));\n-\n \t\t      /* combine_pending_stack_adjustment_and_call computes\n \t\t\t an adjustment before the arguments are allocated.\n \t\t\t Account for them and see whether or not the stack\n \t\t\t needs to go up or down.  */\n \t\t      needed = unadjusted_args_size - needed;\n \n-\t\t      if (needed < 0)\n+\t\t      /* Checked by\n+\t\t\t combine_pending_stack_adjustment_and_call.  */\n+\t\t      gcc_checking_assert (ordered_p (needed, 0));\n+\t\t      if (maybe_lt (needed, 0))\n \t\t\t{\n \t\t\t  /* We're releasing stack space.  */\n \t\t\t  /* ??? We can avoid any adjustment at all if we're\n@@ -3773,11 +3860,12 @@ expand_call (tree exp, rtx target, int ignore)\n \n \t\t  /* Special case this because overhead of `push_block' in\n \t\t     this case is non-trivial.  */\n-\t\t  if (needed == 0)\n+\t\t  if (known_eq (needed, 0))\n \t\t    argblock = virtual_outgoing_args_rtx;\n \t\t  else\n \t\t    {\n-\t\t      argblock = push_block (GEN_INT (needed), 0, 0);\n+\t\t      rtx needed_rtx = gen_int_mode (needed, Pmode);\n+\t\t      argblock = push_block (needed_rtx, 0, 0);\n \t\t      if (ARGS_GROW_DOWNWARD)\n \t\t\targblock = plus_constant (Pmode, argblock, needed);\n \t\t    }\n@@ -3803,10 +3891,11 @@ expand_call (tree exp, rtx target, int ignore)\n \t  if (stack_arg_under_construction)\n \t    {\n \t      rtx push_size\n-\t\t= GEN_INT (adjusted_args_size.constant\n-\t\t\t   + (OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype\n-\t\t\t   \t\t\t\t\t      : TREE_TYPE (fndecl))) ? 0\n-\t\t\t      : reg_parm_stack_space));\n+\t\t= (gen_int_mode\n+\t\t   (adjusted_args_size.constant\n+\t\t    + (OUTGOING_REG_PARM_STACK_SPACE (!fndecl ? fntype\n+\t\t\t\t\t\t      : TREE_TYPE (fndecl))\n+\t\t       ? 0 : reg_parm_stack_space), Pmode));\n \t      if (old_stack_level == 0)\n \t\t{\n \t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level);\n@@ -3825,6 +3914,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  stack_usage_map_buf = XCNEWVEC (char, highest_outgoing_arg_in_use);\n \t\t  stack_usage_map = stack_usage_map_buf;\n \t\t  highest_outgoing_arg_in_use = 0;\n+\t\t  stack_usage_watermark = HOST_WIDE_INT_M1U;\n \t\t}\n \t      /* We can pass TRUE as the 4th argument because we just\n \t\t saved the stack pointer and will restore it right after\n@@ -3860,24 +3950,23 @@ expand_call (tree exp, rtx target, int ignore)\n \n       /* Perform stack alignment before the first push (the last arg).  */\n       if (argblock == 0\n-          && adjusted_args_size.constant > reg_parm_stack_space\n-\t  && adjusted_args_size.constant != unadjusted_args_size)\n+\t  && maybe_gt (adjusted_args_size.constant, reg_parm_stack_space)\n+\t  && maybe_ne (adjusted_args_size.constant, unadjusted_args_size))\n \t{\n \t  /* When the stack adjustment is pending, we get better code\n \t     by combining the adjustments.  */\n-\t  if (pending_stack_adjust\n-\t      && ! inhibit_defer_pop)\n-\t    {\n-\t      pending_stack_adjust\n-\t\t= (combine_pending_stack_adjustment_and_call\n-\t\t   (unadjusted_args_size,\n-\t\t    &adjusted_args_size,\n-\t\t    preferred_unit_stack_boundary));\n-\t      do_pending_stack_adjust ();\n-\t    }\n+\t  if (maybe_ne (pending_stack_adjust, 0)\n+\t      && ! inhibit_defer_pop\n+\t      && (combine_pending_stack_adjustment_and_call\n+\t\t  (&pending_stack_adjust,\n+\t\t   unadjusted_args_size,\n+\t\t   &adjusted_args_size,\n+\t\t   preferred_unit_stack_boundary)))\n+\t    do_pending_stack_adjust ();\n \t  else if (argblock == 0)\n-\t    anti_adjust_stack (GEN_INT (adjusted_args_size.constant\n-\t\t\t\t\t- unadjusted_args_size));\n+\t    anti_adjust_stack (gen_int_mode (adjusted_args_size.constant\n+\t\t\t\t\t     - unadjusted_args_size,\n+\t\t\t\t\t     Pmode));\n \t}\n       /* Now that the stack is properly aligned, pops can't safely\n \t be deferred during the evaluation of the arguments.  */\n@@ -3891,9 +3980,10 @@ expand_call (tree exp, rtx target, int ignore)\n \t  && pass\n \t  && adjusted_args_size.var == 0)\n \t{\n-\t  int pushed = adjusted_args_size.constant + pending_stack_adjust;\n-\t  if (pushed > current_function_pushed_stack_size)\n-\t    current_function_pushed_stack_size = pushed;\n+\t  poly_int64 pushed = (adjusted_args_size.constant\n+\t\t\t       + pending_stack_adjust);\n+\t  current_function_pushed_stack_size\n+\t    = upper_bound (current_function_pushed_stack_size, pushed);\n \t}\n \n       funexp = rtx_for_function_call (fndecl, addr);\n@@ -3928,7 +4018,7 @@ expand_call (tree exp, rtx target, int ignore)\n \n \t      /* We don't allow passing huge (> 2^30 B) arguments\n \t         by value.  It would cause an overflow later on.  */\n-\t      if (adjusted_args_size.constant\n+\t      if (constant_lower_bound (adjusted_args_size.constant)\n \t\t  >= (1 << (HOST_BITS_PER_INT - 2)))\n \t        {\n \t          sorry (\"passing too large argument on stack\");\n@@ -4111,7 +4201,8 @@ expand_call (tree exp, rtx target, int ignore)\n \n       /* Stack must be properly aligned now.  */\n       gcc_assert (!pass\n-\t\t  || !(stack_pointer_delta % preferred_unit_stack_boundary));\n+\t\t  || multiple_p (stack_pointer_delta,\n+\t\t\t\t preferred_unit_stack_boundary));\n \n       /* Generate the actual call instruction.  */\n       emit_call_1 (funexp, exp, fndecl, funtype, unadjusted_args_size,\n@@ -4339,6 +4430,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  stack_arg_under_construction = old_stack_arg_under_construction;\n \t  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n \t  stack_usage_map = initial_stack_usage_map;\n+\t  stack_usage_watermark = initial_stack_usage_watermark;\n \t  sibcall_failure = 1;\n \t}\n       else if (ACCUMULATE_OUTGOING_ARGS && pass)\n@@ -4363,12 +4455,14 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  emit_move_insn (stack_area, args[i].save_area);\n \t\telse\n \t\t  emit_block_move (stack_area, args[i].save_area,\n-\t\t\t\t   GEN_INT (args[i].locate.size.constant),\n+\t\t\t\t   (gen_int_mode\n+\t\t\t\t    (args[i].locate.size.constant, Pmode)),\n \t\t\t\t   BLOCK_OP_CALL_PARM);\n \t      }\n \n \t  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n \t  stack_usage_map = initial_stack_usage_map;\n+\t  stack_usage_watermark = initial_stack_usage_watermark;\n \t}\n \n       /* If this was alloca, record the new stack level.  */\n@@ -4411,8 +4505,9 @@ expand_call (tree exp, rtx target, int ignore)\n \n \t  /* Verify that we've deallocated all the stack we used.  */\n \t  gcc_assert ((flags & ECF_NORETURN)\n-\t\t      || (old_stack_allocated\n-\t\t\t  == stack_pointer_delta - pending_stack_adjust));\n+\t\t      || known_eq (old_stack_allocated,\n+\t\t\t\t   stack_pointer_delta\n+\t\t\t\t   - pending_stack_adjust));\n \t}\n \n       /* If something prevents making this a sibling call,\n@@ -4579,7 +4674,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   int struct_value_size = 0;\n   int flags;\n   int reg_parm_stack_space = 0;\n-  int needed;\n+  poly_int64 needed;\n   rtx_insn *before_call;\n   bool have_push_fusage;\n   tree tfom;\t\t\t/* type_for_mode (outmode, 0) */\n@@ -4592,8 +4687,9 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n #endif\n \n   /* Size of the stack reserved for parameter registers.  */\n-  int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n+  unsigned int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n   char *initial_stack_usage_map = stack_usage_map;\n+  unsigned HOST_WIDE_INT initial_stack_usage_watermark = stack_usage_watermark;\n   char *stack_usage_map_buf = NULL;\n \n   rtx struct_value = targetm.calls.struct_value_rtx (0, 0);\n@@ -4825,27 +4921,25 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   assemble_external_libcall (fun);\n \n   original_args_size = args_size;\n-  args_size.constant = (((args_size.constant\n-\t\t\t  + stack_pointer_delta\n-\t\t\t  + STACK_BYTES - 1)\n-\t\t\t  / STACK_BYTES\n-\t\t\t  * STACK_BYTES)\n-\t\t\t - stack_pointer_delta);\n+  args_size.constant = (aligned_upper_bound (args_size.constant\n+\t\t\t\t\t     + stack_pointer_delta,\n+\t\t\t\t\t     STACK_BYTES)\n+\t\t\t- stack_pointer_delta);\n \n-  args_size.constant = MAX (args_size.constant,\n-\t\t\t    reg_parm_stack_space);\n+  args_size.constant = upper_bound (args_size.constant,\n+\t\t\t\t    reg_parm_stack_space);\n \n   if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n     args_size.constant -= reg_parm_stack_space;\n \n-  if (args_size.constant > crtl->outgoing_args_size)\n-    crtl->outgoing_args_size = args_size.constant;\n+  crtl->outgoing_args_size = upper_bound (crtl->outgoing_args_size,\n+\t\t\t\t\t  args_size.constant);\n \n   if (flag_stack_usage_info && !ACCUMULATE_OUTGOING_ARGS)\n     {\n-      int pushed = args_size.constant + pending_stack_adjust;\n-      if (pushed > current_function_pushed_stack_size)\n-\tcurrent_function_pushed_stack_size = pushed;\n+      poly_int64 pushed = args_size.constant + pending_stack_adjust;\n+      current_function_pushed_stack_size\n+\t= upper_bound (current_function_pushed_stack_size, pushed);\n     }\n \n   if (ACCUMULATE_OUTGOING_ARGS)\n@@ -4870,11 +4964,15 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \tneeded += reg_parm_stack_space;\n \n+      poly_int64 limit = needed;\n       if (ARGS_GROW_DOWNWARD)\n-\thighest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t\t   needed + 1);\n-      else\n-\thighest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use, needed);\n+\tlimit += 1;\n+\n+      /* For polynomial sizes, this is the maximum possible size needed\n+\t for arguments with a constant size and offset.  */\n+      HOST_WIDE_INT const_limit = constant_lower_bound (limit);\n+      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t const_limit);\n \n       stack_usage_map_buf = XNEWVEC (char, highest_outgoing_arg_in_use);\n       stack_usage_map = stack_usage_map_buf;\n@@ -4902,14 +5000,15 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   else\n     {\n       if (!PUSH_ARGS)\n-\targblock = push_block (GEN_INT (args_size.constant), 0, 0);\n+\targblock = push_block (gen_int_mode (args_size.constant, Pmode), 0, 0);\n     }\n \n   /* We push args individually in reverse order, perform stack alignment\n      before the first push (the last arg).  */\n   if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n+    anti_adjust_stack (gen_int_mode (args_size.constant\n+\t\t\t\t     - original_args_size.constant,\n+\t\t\t\t     Pmode));\n \n   argnum = nargs - 1;\n \n@@ -4949,7 +5048,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n       unsigned int parm_align = argvec[argnum].locate.boundary;\n-      int lower_bound = 0, upper_bound = 0, i;\n+      poly_int64 lower_bound = 0, upper_bound = 0;\n \n       if (! (reg != 0 && partial == 0))\n \t{\n@@ -4973,18 +5072,11 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t  upper_bound = lower_bound + argvec[argnum].locate.size.constant;\n \t\t}\n \n-\t      i = lower_bound;\n-\t      /* Don't worry about things in the fixed argument area;\n-\t\t it has already been saved.  */\n-\t      if (i < reg_parm_stack_space)\n-\t\ti = reg_parm_stack_space;\n-\t      while (i < upper_bound && stack_usage_map[i] == 0)\n-\t\ti++;\n-\n-\t      if (i < upper_bound)\n+\t      if (stack_region_maybe_used_p (lower_bound, upper_bound,\n+\t\t\t\t\t     reg_parm_stack_space))\n \t\t{\n \t\t  /* We need to make a save area.  */\n-\t\t  unsigned int size\n+\t\t  poly_uint64 size\n \t\t    = argvec[argnum].locate.size.constant * BITS_PER_UNIT;\n \t\t  machine_mode save_mode\n \t\t    = int_mode_for_size (size, 1).else_blk ();\n@@ -5004,7 +5096,9 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t      emit_block_move (validize_mem\n \t\t\t\t         (copy_rtx (argvec[argnum].save_area)),\n \t\t\t\t       stack_area,\n-\t\t\t\t       GEN_INT (argvec[argnum].locate.size.constant),\n+\t\t\t\t       (gen_int_mode\n+\t\t\t\t\t(argvec[argnum].locate.size.constant,\n+\t\t\t\t\t Pmode)),\n \t\t\t\t       BLOCK_OP_CALL_PARM);\n \t\t    }\n \t\t  else\n@@ -5018,14 +5112,14 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, parm_align,\n \t\t\t  partial, reg, 0, argblock,\n-\t\t\t  GEN_INT (argvec[argnum].locate.offset.constant),\n+\t\t\t  (gen_int_mode\n+\t\t\t   (argvec[argnum].locate.offset.constant, Pmode)),\n \t\t\t  reg_parm_stack_space,\n \t\t\t  ARGS_SIZE_RTX (argvec[argnum].locate.alignment_pad), false);\n \n \t  /* Now mark the segment we just used.  */\n \t  if (ACCUMULATE_OUTGOING_ARGS)\n-\t    for (i = lower_bound; i < upper_bound; i++)\n-\t      stack_usage_map[i] = 1;\n+\t    mark_stack_region_used (lower_bound, upper_bound);\n \n \t  NO_DEFER_POP;\n \n@@ -5147,8 +5241,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t    ? hard_libcall_value (outmode, orgfun) : NULL_RTX);\n \n   /* Stack must be properly aligned now.  */\n-  gcc_assert (!(stack_pointer_delta\n-\t\t& (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1)));\n+  gcc_assert (multiple_p (stack_pointer_delta,\n+\t\t\t  PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT));\n \n   before_call = get_last_insn ();\n \n@@ -5286,14 +5380,16 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t      emit_block_move (stack_area,\n \t\t\t       validize_mem\n \t\t\t         (copy_rtx (argvec[count].save_area)),\n-\t\t\t       GEN_INT (argvec[count].locate.size.constant),\n+\t\t\t       (gen_int_mode\n+\t\t\t\t(argvec[count].locate.size.constant, Pmode)),\n \t\t\t       BLOCK_OP_CALL_PARM);\n \t    else\n \t      emit_move_insn (stack_area, argvec[count].save_area);\n \t  }\n \n       highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n       stack_usage_map = initial_stack_usage_map;\n+      stack_usage_watermark = initial_stack_usage_watermark;\n     }\n \n   free (stack_usage_map_buf);\n@@ -5390,8 +5486,8 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n   tree pval = arg->tree_value;\n   rtx reg = 0;\n   int partial = 0;\n-  int used = 0;\n-  int i, lower_bound = 0, upper_bound = 0;\n+  poly_int64 used = 0;\n+  poly_int64 lower_bound = 0, upper_bound = 0;\n   int sibcall_failure = 0;\n \n   if (TREE_CODE (pval) == ERROR_MARK)\n@@ -5412,7 +5508,10 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t      /* stack_slot is negative, but we want to index stack_usage_map\n \t\t with positive values.  */\n \t      if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n-\t\tupper_bound = -INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1)) + 1;\n+\t\t{\n+\t\t  rtx offset = XEXP (XEXP (arg->stack_slot, 0), 1);\n+\t\t  upper_bound = -rtx_to_poly_int64 (offset) + 1;\n+\t\t}\n \t      else\n \t\tupper_bound = 0;\n \n@@ -5421,25 +5520,21 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t  else\n \t    {\n \t      if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n-\t\tlower_bound = INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1));\n+\t\t{\n+\t\t  rtx offset = XEXP (XEXP (arg->stack_slot, 0), 1);\n+\t\t  lower_bound = rtx_to_poly_int64 (offset);\n+\t\t}\n \t      else\n \t\tlower_bound = 0;\n \n \t      upper_bound = lower_bound + arg->locate.size.constant;\n \t    }\n \n-\t  i = lower_bound;\n-\t  /* Don't worry about things in the fixed argument area;\n-\t     it has already been saved.  */\n-\t  if (i < reg_parm_stack_space)\n-\t    i = reg_parm_stack_space;\n-\t  while (i < upper_bound && stack_usage_map[i] == 0)\n-\t    i++;\n-\n-\t  if (i < upper_bound)\n+\t  if (stack_region_maybe_used_p (lower_bound, upper_bound,\n+\t\t\t\t\t reg_parm_stack_space))\n \t    {\n \t      /* We need to make a save area.  */\n-\t      unsigned int size = arg->locate.size.constant * BITS_PER_UNIT;\n+\t      poly_uint64 size = arg->locate.size.constant * BITS_PER_UNIT;\n \t      machine_mode save_mode\n \t\t= int_mode_for_size (size, 1).else_blk ();\n \t      rtx adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));\n@@ -5452,7 +5547,8 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t\t  preserve_temp_slots (arg->save_area);\n \t\t  emit_block_move (validize_mem (copy_rtx (arg->save_area)),\n \t\t\t\t   stack_area,\n-\t\t\t\t   GEN_INT (arg->locate.size.constant),\n+\t\t\t\t   (gen_int_mode\n+\t\t\t\t    (arg->locate.size.constant, Pmode)),\n \t\t\t\t   BLOCK_OP_CALL_PARM);\n \t\t}\n \t      else\n@@ -5529,8 +5625,8 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n   /* Check for overlap with already clobbered argument area.  */\n   if ((flags & ECF_SIBCALL)\n       && MEM_P (arg->value)\n-      && mem_overlaps_already_clobbered_arg_p (XEXP (arg->value, 0),\n-\t\t\t\t\t       arg->locate.size.constant))\n+      && mem_might_overlap_already_clobbered_arg_p (XEXP (arg->value, 0),\n+\t\t\t\t\t\t    arg->locate.size.constant))\n     sibcall_failure = 1;\n \n   /* Don't allow anything left on stack from computation\n@@ -5582,17 +5678,15 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n       if (targetm.calls.function_arg_padding (arg->mode, TREE_TYPE (pval))\n \t  == PAD_DOWNWARD)\n \t{\n-\t  int pad = used - size;\n-\t  if (pad)\n-\t    {\n-\t      unsigned int pad_align = least_bit_hwi (pad) * BITS_PER_UNIT;\n-\t      parm_align = MIN (parm_align, pad_align);\n-\t    }\n+\t  poly_int64 pad = used - size;\n+\t  unsigned int pad_align = known_alignment (pad) * BITS_PER_UNIT;\n+\t  if (pad_align != 0)\n+\t    parm_align = MIN (parm_align, pad_align);\n \t}\n \n       /* This isn't already where we want it on the stack, so put it there.\n \t This can either be done with push or copy insns.  */\n-      if (used\n+      if (maybe_ne (used, 0)\n \t  && !emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval),\n \t\t\t      NULL_RTX, parm_align, partial, reg, used - size,\n \t\t\t      argblock, ARGS_SIZE_RTX (arg->locate.offset),\n@@ -5610,7 +5704,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n       /* BLKmode, at least partly to be pushed.  */\n \n       unsigned int parm_align;\n-      int excess;\n+      poly_int64 excess;\n       rtx size_rtx;\n \n       /* Pushing a nonscalar.\n@@ -5646,10 +5740,12 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t{\n \t  if (arg->locate.size.var)\n \t    parm_align = BITS_PER_UNIT;\n-\t  else if (excess)\n+\t  else\n \t    {\n-\t      unsigned int excess_align = least_bit_hwi (excess) * BITS_PER_UNIT;\n-\t      parm_align = MIN (parm_align, excess_align);\n+\t      unsigned int excess_align\n+\t\t= known_alignment (excess) * BITS_PER_UNIT;\n+\t      if (excess_align != 0)\n+\t\tparm_align = MIN (parm_align, excess_align);\n \t    }\n \t}\n \n@@ -5658,7 +5754,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t  /* emit_push_insn might not work properly if arg->value and\n \t     argblock + arg->locate.offset areas overlap.  */\n \t  rtx x = arg->value;\n-\t  int i = 0;\n+\t  poly_int64 i = 0;\n \n \t  if (XEXP (x, 0) == crtl->args.internal_arg_pointer\n \t      || (GET_CODE (XEXP (x, 0)) == PLUS\n@@ -5667,7 +5763,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))))\n \t    {\n \t      if (XEXP (x, 0) != crtl->args.internal_arg_pointer)\n-\t\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n+\t\ti = rtx_to_poly_int64 (XEXP (XEXP (x, 0), 1));\n \n \t      /* arg.locate doesn't contain the pretend_args_size offset,\n \t\t it's part of argblock.  Ensure we don't count it in I.  */\n@@ -5678,33 +5774,28 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \n \t      /* expand_call should ensure this.  */\n \t      gcc_assert (!arg->locate.offset.var\n-\t\t\t  && arg->locate.size.var == 0\n-\t\t\t  && CONST_INT_P (size_rtx));\n+\t\t\t  && arg->locate.size.var == 0);\n+\t      poly_int64 size_val = rtx_to_poly_int64 (size_rtx);\n \n-\t      if (arg->locate.offset.constant > i)\n-\t\t{\n-\t\t  if (arg->locate.offset.constant < i + INTVAL (size_rtx))\n-\t\t    sibcall_failure = 1;\n-\t\t}\n-\t      else if (arg->locate.offset.constant < i)\n-\t\t{\n-\t\t  /* Use arg->locate.size.constant instead of size_rtx\n-\t\t     because we only care about the part of the argument\n-\t\t     on the stack.  */\n-\t\t  if (i < (arg->locate.offset.constant\n-\t\t\t   + arg->locate.size.constant))\n-\t\t    sibcall_failure = 1;\n-\t\t}\n-\t      else\n+\t      if (known_eq (arg->locate.offset.constant, i))\n \t\t{\n \t\t  /* Even though they appear to be at the same location,\n \t\t     if part of the outgoing argument is in registers,\n \t\t     they aren't really at the same location.  Check for\n \t\t     this by making sure that the incoming size is the\n \t\t     same as the outgoing size.  */\n-\t\t  if (arg->locate.size.constant != INTVAL (size_rtx))\n+\t\t  if (maybe_ne (arg->locate.size.constant, size_val))\n \t\t    sibcall_failure = 1;\n \t\t}\n+\t      else if (maybe_in_range_p (arg->locate.offset.constant,\n+\t\t\t\t\t i, size_val))\n+\t\tsibcall_failure = 1;\n+\t      /* Use arg->locate.size.constant instead of size_rtx\n+\t\t because we only care about the part of the argument\n+\t\t on the stack.  */\n+\t      else if (maybe_in_range_p (i, arg->locate.offset.constant,\n+\t\t\t\t\t arg->locate.size.constant))\n+\t\tsibcall_failure = 1;\n \t    }\n \t}\n \n@@ -5738,8 +5829,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n   /* Mark all slots this store used.  */\n   if (ACCUMULATE_OUTGOING_ARGS && !(flags & ECF_SIBCALL)\n       && argblock && ! variable_size && arg->stack)\n-    for (i = lower_bound; i < upper_bound; i++)\n-      stack_usage_map[i] = 1;\n+    mark_stack_region_used (lower_bound, upper_bound);\n \n   /* Once we have pushed something, pops can't safely\n      be deferred during the rest of the arguments.  */"}, {"sha": "2aa64917e4cc0b6b1fcb148269c3b5f9d501cd4b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -19993,8 +19993,8 @@ arm_output_function_prologue (FILE *f)\n   if (IS_CMSE_ENTRY (func_type))\n     asm_fprintf (f, \"\\t%@ Non-secure entry function: called from non-secure code.\\n\");\n \n-  asm_fprintf (f, \"\\t%@ args = %d, pretend = %d, frame = %wd\\n\",\n-\t       crtl->args.size,\n+  asm_fprintf (f, \"\\t%@ args = %wd, pretend = %d, frame = %wd\\n\",\n+\t       (HOST_WIDE_INT) crtl->args.size,\n \t       crtl->args.pretend_args_size,\n \t       (HOST_WIDE_INT) get_frame_size ());\n "}, {"sha": "410bfb998419dd3b10d47cc143def5cfdc1b02a0", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -1254,7 +1254,7 @@ enum reg_class\n    couldn't convert a direct call into an indirect one.  */\n #define CALLER_INTERWORKING_SLOT_SIZE\t\t\t\\\n   (TARGET_CALLER_INTERWORKING\t\t\t\t\\\n-   && crtl->outgoing_args_size != 0\t\t\\\n+   && maybe_ne (crtl->outgoing_args_size, 0)\t\t\\\n    ? UNITS_PER_WORD : 0)\n \n /* If we generate an insn to push BYTES bytes,"}, {"sha": "b69d42e34a6bd0fbc1305932ddd5dc7241691314", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -1151,7 +1151,8 @@ avr_accumulate_outgoing_args (void)\n static inline int\n avr_outgoing_args_size (void)\n {\n-  return ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0;\n+  return (ACCUMULATE_OUTGOING_ARGS\n+\t  ? (HOST_WIDE_INT) crtl->outgoing_args_size : 0);\n }\n \n "}, {"sha": "ddadab2ca7b98a3d128a477ec6843437817022ad", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -253,10 +253,8 @@ cr16_class_likely_spilled_p (reg_class_t rclass)\n   return false;\n }\n \n-static int\n-cr16_return_pops_args (tree fundecl ATTRIBUTE_UNUSED,\n-                       tree funtype ATTRIBUTE_UNUSED, \n-\t\t       int size ATTRIBUTE_UNUSED)\n+static poly_int64\n+cr16_return_pops_args (tree, tree, poly_int64)\n {\n   return 0;\n }\n@@ -433,9 +431,10 @@ cr16_compute_frame (void)\n     padding_locals = stack_alignment - padding_locals;\n \n   current_frame_info.var_size += padding_locals;\n-  current_frame_info.total_size = current_frame_info.var_size \n-\t\t\t          + (ACCUMULATE_OUTGOING_ARGS\n-\t\t\t             ? crtl->outgoing_args_size : 0);\n+  current_frame_info.total_size\n+    = (current_frame_info.var_size\n+       + (ACCUMULATE_OUTGOING_ARGS\n+\t  ? (HOST_WIDE_INT) crtl->outgoing_args_size : 0));\n }\n \n /* Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET.  */\n@@ -449,12 +448,14 @@ cr16_initial_elimination_offset (int from, int to)\n   cr16_compute_frame ();\n \n   if (((from) == FRAME_POINTER_REGNUM) && ((to) == STACK_POINTER_REGNUM))\n-    return (ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0);\n+    return (ACCUMULATE_OUTGOING_ARGS\n+\t    ? (HOST_WIDE_INT) crtl->outgoing_args_size : 0);\n   else if (((from) == ARG_POINTER_REGNUM) && ((to) == FRAME_POINTER_REGNUM))\n     return (current_frame_info.reg_size + current_frame_info.var_size);\n   else if (((from) == ARG_POINTER_REGNUM) && ((to) == STACK_POINTER_REGNUM))\n     return (current_frame_info.reg_size + current_frame_info.var_size \n-\t    + (ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0));\n+\t    + (ACCUMULATE_OUTGOING_ARGS\n+\t       ? (HOST_WIDE_INT) crtl->outgoing_args_size : 0));\n   else\n     gcc_unreachable ();\n }"}, {"sha": "a298e64510f71d50068be214bb1eea49f171bdfd", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -417,7 +417,8 @@ ft32_compute_frame (void)\n   cfun->machine->size_for_adjusting_sp =\n     0 // crtl->args.pretend_args_size\n     + cfun->machine->local_vars_size\n-    + (ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0);\n+    + (ACCUMULATE_OUTGOING_ARGS\n+       ? (HOST_WIDE_INT) crtl->outgoing_args_size : 0);\n }\n \n // Must use LINK/UNLINK when..."}, {"sha": "5e3a2cdcd79b634152ee5c4fb257cba5df93f0d7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -6735,8 +6735,8 @@ ix86_keep_aggregate_return_pointer (tree fntype)\n \n    The attribute stdcall is equivalent to RTD on a per module basis.  */\n \n-static int\n-ix86_return_pops_args (tree fundecl, tree funtype, int size)\n+static poly_int64\n+ix86_return_pops_args (tree fundecl, tree funtype, poly_int64 size)\n {\n   unsigned int ccvt;\n \n@@ -14507,7 +14507,7 @@ ix86_expand_split_stack_prologue (void)\n      anyhow.  In 64-bit mode we pass the parameters in r10 and\n      r11.  */\n   allocate_rtx = GEN_INT (allocate);\n-  args_size = crtl->args.size >= 0 ? crtl->args.size : 0;\n+  args_size = crtl->args.size >= 0 ? (HOST_WIDE_INT) crtl->args.size : 0;\n   call_fusage = NULL_RTX;\n   rtx pop = NULL_RTX;\n   if (TARGET_64BIT)"}, {"sha": "10c78153e642a00ffc5391f696d1796178b8e913", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -178,7 +178,7 @@ static bool m68k_return_in_memory (const_tree, const_tree);\n #endif\n static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static void m68k_trampoline_init (rtx, tree, rtx);\n-static int m68k_return_pops_args (tree, tree, int);\n+static poly_int64 m68k_return_pops_args (tree, tree, poly_int64);\n static rtx m68k_delegitimize_address (rtx);\n static void m68k_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n@@ -6531,14 +6531,14 @@ m68k_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n    standard Unix calling sequences.  If the option is not selected,\n    the caller must always pop the args.  */\n \n-static int\n-m68k_return_pops_args (tree fundecl, tree funtype, int size)\n+static poly_int64\n+m68k_return_pops_args (tree fundecl, tree funtype, poly_int64 size)\n {\n   return ((TARGET_RTD\n \t   && (!fundecl\n \t       || TREE_CODE (fundecl) != IDENTIFIER_NODE)\n \t   && (!stdarg_p (funtype)))\n-\t  ? size : 0);\n+\t  ? (HOST_WIDE_INT) size : 0);\n }\n \n /* Make sure everything's fine if we *don't* have a given processor."}, {"sha": "8d7ca3c52a967bd6b6cd4b2ae80223af12333a38", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -2723,7 +2723,7 @@ microblaze_function_prologue (FILE * file)\n \t\t\t  STACK_POINTER_REGNUM]), fsiz,\n \t       reg_names[MB_ABI_SUB_RETURN_ADDR_REGNUM + GP_REG_FIRST],\n \t       current_frame_info.var_size, current_frame_info.num_gp,\n-\t       crtl->outgoing_args_size);\n+\t       (int) crtl->outgoing_args_size);\n       fprintf (file, \"\\t.mask\\t0x%08lx\\n\", current_frame_info.mask);\n     }\n }"}, {"sha": "4c9c5818fc970f46de0c3116d74c79c3fd24e2d1", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -270,7 +270,8 @@ moxie_compute_frame (void)\n   cfun->machine->size_for_adjusting_sp = \n     crtl->args.pretend_args_size\n     + cfun->machine->local_vars_size \n-    + (ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0);\n+    + (ACCUMULATE_OUTGOING_ARGS\n+       ? (HOST_WIDE_INT) crtl->outgoing_args_size : 0);\n }\n \n void"}, {"sha": "757dc890553a631b6f792967ec43aee86ed1d7a9", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -535,7 +535,7 @@ extern rtx hppa_pic_save_rtx (void);\n    marker, although the runtime documentation only describes a 16\n    byte marker.  For compatibility, we allocate 48 bytes.  */\n #define STACK_POINTER_OFFSET \\\n-  (TARGET_64BIT ? -(crtl->outgoing_args_size + 48): -32)\n+  (TARGET_64BIT ? -(crtl->outgoing_args_size + 48) : poly_int64 (-32))\n \n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n   (TARGET_64BIT\t\t\t\t\\\n@@ -692,7 +692,7 @@ extern int may_call_alloca;\n \n #define EXIT_IGNORE_STACK\t\\\n  (maybe_ne (get_frame_size (), 0)\t\\\n-  || cfun->calls_alloca || crtl->outgoing_args_size)\n+  || cfun->calls_alloca || maybe_ne (crtl->outgoing_args_size, 0))\n \n /* Length in units of the trampoline for entering a nested function.  */\n "}, {"sha": "dc7fc44b04410f7591a8840003f6a9264c574236", "filename": "gcc/config/powerpcspe/aix.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fpowerpcspe%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fpowerpcspe%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Faix.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -71,7 +71,8 @@\n    `emit-rtl.c').  */\n #undef STACK_DYNAMIC_OFFSET\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-   RS6000_ALIGN (crtl->outgoing_args_size + STACK_POINTER_OFFSET, 16)\n+  RS6000_ALIGN (crtl->outgoing_args_size.to_constant () \\\n+\t\t+ STACK_POINTER_OFFSET, 16)\n \n #undef  TARGET_IEEEQUAD\n #define TARGET_IEEEQUAD 0"}, {"sha": "a454049c130924c4d59f0f69a9299a093a49a4f4", "filename": "gcc/config/powerpcspe/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fpowerpcspe%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fpowerpcspe%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fdarwin.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -155,7 +155,7 @@ extern int darwin_emit_branch_islands;\n \n #undef STACK_DYNAMIC_OFFSET\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  (RS6000_ALIGN (crtl->outgoing_args_size, 16)\t\t\\\n+  (RS6000_ALIGN (crtl->outgoing_args_size.to_constant (), 16)\t\t\\\n    + (STACK_POINTER_OFFSET))\n \n /* Darwin uses a function call if everything needs to be saved/restored.  */"}, {"sha": "45edc35f39a6577bd574f63332197681f15a8277", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -1666,7 +1666,8 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n    This value must be a multiple of STACK_BOUNDARY (hard coded in\n    `emit-rtl.c').  */\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  RS6000_ALIGN (crtl->outgoing_args_size + STACK_POINTER_OFFSET,\t\\\n+  RS6000_ALIGN (crtl->outgoing_args_size.to_constant ()\t\t\t\\\n+\t\t+ STACK_POINTER_OFFSET,\t\t\t\t\t\\\n \t\t(TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8)\n \n /* If we generate an insn to push BYTES bytes,"}, {"sha": "31fda583c2c8ba7cc4c68d1cf2666be12c4f4d6d", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -71,7 +71,8 @@\n    `emit-rtl.c').  */\n #undef STACK_DYNAMIC_OFFSET\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-   RS6000_ALIGN (crtl->outgoing_args_size + STACK_POINTER_OFFSET, 16)\n+   RS6000_ALIGN (crtl->outgoing_args_size.to_constant ()\t\t\\\n+\t\t + STACK_POINTER_OFFSET, 16)\n \n #undef  TARGET_IEEEQUAD\n #define TARGET_IEEEQUAD 0"}, {"sha": "5f03fa5f206b88ae7cc1492e3ae000c181754dff", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -155,7 +155,7 @@ extern int darwin_emit_branch_islands;\n \n #undef STACK_DYNAMIC_OFFSET\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  (RS6000_ALIGN (crtl->outgoing_args_size, 16)\t\t\\\n+  (RS6000_ALIGN (crtl->outgoing_args_size.to_constant (), 16)\t\t\\\n    + (STACK_POINTER_OFFSET))\n \n /* Darwin uses a function call if everything needs to be saved/restored.  */"}, {"sha": "658c6e0bcd29ba92d749b7d3a8b187bb3389cc2a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -1565,7 +1565,8 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n    This value must be a multiple of STACK_BOUNDARY (hard coded in\n    `emit-rtl.c').  */\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  RS6000_ALIGN (crtl->outgoing_args_size + STACK_POINTER_OFFSET,\t\\\n+  RS6000_ALIGN (crtl->outgoing_args_size.to_constant ()\t\t\t\\\n+\t\t+ STACK_POINTER_OFFSET,\t\t\t\t\t\\\n \t\t(TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8)\n \n /* If we generate an insn to push BYTES bytes,"}, {"sha": "c08460a0ef3a0cacdac070289f1b8ad0ba9c3720", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -62,7 +62,7 @@ static rtx vax_struct_value_rtx (tree, int);\n static rtx vax_builtin_setjmp_frame_value (void);\n static void vax_asm_trampoline_template (FILE *);\n static void vax_trampoline_init (rtx, tree, rtx);\n-static int vax_return_pops_args (tree, tree, int);\n+static poly_int64 vax_return_pops_args (tree, tree, poly_int64);\n static bool vax_mode_dependent_address_p (const_rtx, addr_space_t);\n static HOST_WIDE_INT vax_starting_frame_offset (void);\n \f\n@@ -2140,11 +2140,11 @@ vax_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n \n    On the VAX, the RET insn pops a maximum of 255 args for any function.  */\n \n-static int\n+static poly_int64\n vax_return_pops_args (tree fundecl ATTRIBUTE_UNUSED,\n-\t\t      tree funtype ATTRIBUTE_UNUSED, int size)\n+\t\t      tree funtype ATTRIBUTE_UNUSED, poly_int64 size)\n {\n-  return size > 255 * 4 ? 0 : size;\n+  return size > 255 * 4 ? 0 : (HOST_WIDE_INT) size;\n }\n \n /* Define where to put the arguments to a function."}, {"sha": "3a4229f3c6f5c03c87c7d5b1294d902ff149bac7", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -3819,7 +3819,7 @@ suppresses this behavior and causes the parameter to be passed on the\n stack in its natural location.\n @end defmac\n \n-@deftypefn {Target Hook} int TARGET_RETURN_POPS_ARGS (tree @var{fundecl}, tree @var{funtype}, int @var{size})\n+@deftypefn {Target Hook} poly_int64 TARGET_RETURN_POPS_ARGS (tree @var{fundecl}, tree @var{funtype}, poly_int64 @var{size})\n This target hook returns the number of bytes of its own arguments that\n a function pops on returning, or 0 if the function pops no arguments\n and the caller must therefore pop them all after the function returns."}, {"sha": "261e13bd56a8055388ffe181f4c971369e50cc3d", "filename": "gcc/dojump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -89,8 +89,8 @@ do_pending_stack_adjust (void)\n {\n   if (inhibit_defer_pop == 0)\n     {\n-      if (pending_stack_adjust != 0)\n-        adjust_stack (GEN_INT (pending_stack_adjust));\n+      if (maybe_ne (pending_stack_adjust, 0))\n+\tadjust_stack (gen_int_mode (pending_stack_adjust, Pmode));\n       pending_stack_adjust = 0;\n     }\n }"}, {"sha": "ba404024be2183b4afeac5bb88a718d045cb6dcc", "filename": "gcc/dojump.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fdojump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fdojump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -40,10 +40,10 @@ extern void do_pending_stack_adjust (void);\n struct saved_pending_stack_adjust\n {\n   /* Saved value of pending_stack_adjust.  */\n-  int x_pending_stack_adjust;\n+  poly_int64 x_pending_stack_adjust;\n \n   /* Saved value of stack_pointer_delta.  */\n-  int x_stack_pointer_delta;\n+  poly_int64 x_stack_pointer_delta;\n };\n \n /* Remember pending_stack_adjust/stack_pointer_delta."}, {"sha": "b219762d2790efdbcb7ee773900a14bceb7de783", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -28,12 +28,12 @@ struct GTY(()) incoming_args {\n   /* Number of bytes of args popped by function being compiled on its return.\n      Zero if no bytes are to be popped.\n      May affect compilation of return insn or of function epilogue.  */\n-  int pops_args;\n+  poly_int64_pod pops_args;\n \n   /* If function's args have a fixed size, this is that size, in bytes.\n      Otherwise, it is -1.\n      May affect compilation of return insn or of function epilogue.  */\n-  int size;\n+  poly_int64_pod size;\n \n   /* # bytes the prologue should push and pretend that the caller pushed them.\n      The prologue must do this, but only if parms can be passed in\n@@ -68,7 +68,7 @@ struct GTY(()) rtl_data {\n \n   /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is\n      defined, the needed space is pushed by the prologue.  */\n-  int outgoing_args_size;\n+  poly_int64_pod outgoing_args_size;\n \n   /* If nonzero, an RTL expression for the location at which the current\n      function returns its result.  If the current function returns its"}, {"sha": "dce61374cfd7e8597d7bad9c59f17e944802c5d9", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -1475,8 +1475,8 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \n  /* We ought to be called always on the toplevel and stack ought to be aligned\n     properly.  */\n-  gcc_assert (!(stack_pointer_delta\n-\t\t% (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)));\n+  gcc_assert (multiple_p (stack_pointer_delta,\n+\t\t\t  PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT));\n \n   /* If needed, check that we have the required amount of stack.  Take into\n      account what has already been checked.  */\n@@ -1506,7 +1506,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n     }\n   else\n     {\n-      int saved_stack_pointer_delta;\n+      poly_int64 saved_stack_pointer_delta;\n \n       if (!STACK_GROWS_DOWNWARD)\n \temit_move_insn (target, virtual_stack_dynamic_rtx);"}, {"sha": "c752062b5797c29e2f9a6632cc84dd916297ce0b", "filename": "gcc/function.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -1407,7 +1407,7 @@ static poly_int64 cfa_offset;\n   : 0) + (STACK_POINTER_OFFSET))\n #else\n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n-((ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0)\t      \\\n+  ((ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : poly_int64 (0)) \\\n  + (STACK_POINTER_OFFSET))\n #endif\n #endif\n@@ -2727,12 +2727,15 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n      is TARGET_FUNCTION_ARG_BOUNDARY.  If we're using slot_offset, we're\n      intentionally forcing upward padding.  Otherwise we have to come\n      up with a guess at the alignment based on OFFSET_RTX.  */\n+  poly_int64 offset;\n   if (data->locate.where_pad != PAD_DOWNWARD || data->entry_parm)\n     align = boundary;\n-  else if (CONST_INT_P (offset_rtx))\n+  else if (poly_int_rtx_p (offset_rtx, &offset))\n     {\n-      align = INTVAL (offset_rtx) * BITS_PER_UNIT | boundary;\n-      align = least_bit_hwi (align);\n+      align = least_bit_hwi (boundary);\n+      unsigned int offset_align = known_alignment (offset) * BITS_PER_UNIT;\n+      if (offset_align != 0)\n+\talign = MIN (align, offset_align);\n     }\n   set_mem_align (stack_parm, align);\n \n@@ -3894,14 +3897,15 @@ assign_parms (tree fndecl)\n   /* Adjust function incoming argument size for alignment and\n      minimum length.  */\n \n-  crtl->args.size = MAX (crtl->args.size, all.reg_parm_stack_space);\n-  crtl->args.size = CEIL_ROUND (crtl->args.size,\n-\t\t\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+  crtl->args.size = upper_bound (crtl->args.size, all.reg_parm_stack_space);\n+  crtl->args.size = aligned_upper_bound (crtl->args.size,\n+\t\t\t\t\t PARM_BOUNDARY / BITS_PER_UNIT);\n \n   if (ARGS_GROW_DOWNWARD)\n     {\n       crtl->args.arg_offset_rtx\n-\t= (all.stack_args_size.var == 0 ? GEN_INT (-all.stack_args_size.constant)\n+\t= (all.stack_args_size.var == 0\n+\t   ? gen_int_mode (-all.stack_args_size.constant, Pmode)\n \t   : expand_expr (size_diffop (all.stack_args_size.var,\n \t\t\t\t       size_int (-all.stack_args_size.constant)),\n \t\t\t  NULL_RTX, VOIDmode, EXPAND_NORMAL));\n@@ -4141,15 +4145,19 @@ locate_and_pad_parm (machine_mode passed_mode, tree type, int in_regs,\n     {\n       if (reg_parm_stack_space > 0)\n \t{\n-\t  if (initial_offset_ptr->var)\n+\t  if (initial_offset_ptr->var\n+\t      || !ordered_p (initial_offset_ptr->constant,\n+\t\t\t     reg_parm_stack_space))\n \t    {\n \t      initial_offset_ptr->var\n \t\t= size_binop (MAX_EXPR, ARGS_SIZE_TREE (*initial_offset_ptr),\n \t\t\t      ssize_int (reg_parm_stack_space));\n \t      initial_offset_ptr->constant = 0;\n \t    }\n-\t  else if (initial_offset_ptr->constant < reg_parm_stack_space)\n-\t    initial_offset_ptr->constant = reg_parm_stack_space;\n+\t  else\n+\t    initial_offset_ptr->constant\n+\t      = ordered_max (initial_offset_ptr->constant,\n+\t\t\t     reg_parm_stack_space);\n \t}\n     }\n \n@@ -4276,9 +4284,9 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n \t\t      struct args_size *alignment_pad)\n {\n   tree save_var = NULL_TREE;\n-  HOST_WIDE_INT save_constant = 0;\n+  poly_int64 save_constant = 0;\n   int boundary_in_bytes = boundary / BITS_PER_UNIT;\n-  HOST_WIDE_INT sp_offset = STACK_POINTER_OFFSET;\n+  poly_int64 sp_offset = STACK_POINTER_OFFSET;\n \n #ifdef SPARC_STACK_BOUNDARY_HACK\n   /* ??? The SPARC port may claim a STACK_BOUNDARY higher than\n@@ -4299,7 +4307,10 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n \n   if (boundary > BITS_PER_UNIT)\n     {\n-      if (offset_ptr->var)\n+      int misalign;\n+      if (offset_ptr->var\n+\t  || !known_misalignment (offset_ptr->constant + sp_offset,\n+\t\t\t\t  boundary_in_bytes, &misalign))\n \t{\n \t  tree sp_offset_tree = ssize_int (sp_offset);\n \t  tree offset = size_binop (PLUS_EXPR,\n@@ -4320,13 +4331,13 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n \t}\n       else\n \t{\n-\t  offset_ptr->constant = -sp_offset +\n-\t    (ARGS_GROW_DOWNWARD\n-\t    ? FLOOR_ROUND (offset_ptr->constant + sp_offset, boundary_in_bytes)\n-\t    : CEIL_ROUND (offset_ptr->constant + sp_offset, boundary_in_bytes));\n+\t  if (ARGS_GROW_DOWNWARD)\n+\t    offset_ptr->constant -= misalign;\n+\t  else\n+\t    offset_ptr->constant += -misalign & (boundary_in_bytes - 1);\n \n-\t    if (boundary > PARM_BOUNDARY)\n-\t      alignment_pad->constant = offset_ptr->constant - save_constant;\n+\t  if (boundary > PARM_BOUNDARY)\n+\t    alignment_pad->constant = offset_ptr->constant - save_constant;\n \t}\n     }\n }"}, {"sha": "b64f28e526abd9ef2e522cf897c6cbc4ea6f7a07", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -94,7 +94,7 @@ extern GTY ((length (\"crtl->emit.x_reg_rtx_no\"))) rtx * regno_reg_rtx;\n struct GTY(()) expr_status {\n   /* Number of units that we should eventually pop off the stack.\n      These are the arguments to function calls that have already returned.  */\n-  int x_pending_stack_adjust;\n+  poly_int64_pod x_pending_stack_adjust;\n \n   /* Under some ABIs, it is the caller's responsibility to pop arguments\n      pushed for function calls.  A naive implementation would simply pop\n@@ -117,7 +117,7 @@ struct GTY(()) expr_status {\n      boundary can be momentarily unaligned while pushing the arguments.\n      Record the delta since last aligned boundary here in order to get\n      stack alignment in the nested function calls working right.  */\n-  int x_stack_pointer_delta;\n+  poly_int64_pod x_stack_pointer_delta;\n \n   /* Nonzero means __builtin_saveregs has already been done in this function.\n      The value is the pseudoreg containing the value __builtin_saveregs\n@@ -200,9 +200,10 @@ struct GTY(()) stack_usage\n      meaningful only if has_unbounded_dynamic_stack_size is zero.  */\n   HOST_WIDE_INT dynamic_stack_size;\n \n-  /* # of bytes of space pushed onto the stack after the prologue.  If\n-     !ACCUMULATE_OUTGOING_ARGS, it contains the outgoing arguments.  */\n-  int pushed_stack_size;\n+  /* Upper bound on the number of bytes pushed onto the stack after the\n+     prologue.  If !ACCUMULATE_OUTGOING_ARGS, it contains the outgoing\n+     arguments.  */\n+  poly_int64 pushed_stack_size;\n \n   /* Nonzero if the amount of stack space allocated dynamically cannot\n      be bounded at compile-time.  */\n@@ -480,7 +481,7 @@ extern struct machine_function * (*init_machine_status) (void);\n \n struct args_size\n {\n-  HOST_WIDE_INT constant;\n+  poly_int64_pod constant;\n   tree var;\n };\n \n@@ -542,7 +543,7 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* Convert the implicit sum in a `struct args_size' into an rtx.  */\n #define ARGS_SIZE_RTX(SIZE)\t\t\t\t\t\\\n-((SIZE).var == 0 ? GEN_INT ((SIZE).constant)\t\t\t\\\n+((SIZE).var == 0 ? gen_int_mode ((SIZE).constant, Pmode)\t\\\n  : expand_normal (ARGS_SIZE_TREE (SIZE)))\n \n #define ASLK_REDUCE_ALIGN 1"}, {"sha": "27bfcfc070f9833d86389d81c2a39ff264413328", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -5055,7 +5055,7 @@ arguments pop them but other functions (such as @code{printf}) pop\\n\\\n nothing (the caller pops all).  When this convention is in use,\\n\\\n @var{funtype} is examined to determine whether a function takes a fixed\\n\\\n number of arguments.\",\n- int, (tree fundecl, tree funtype, int size),\n+ poly_int64, (tree fundecl, tree funtype, poly_int64 size),\n  default_return_pops_args)\n \n /* Return a mode wide enough to copy any function value that might be"}, {"sha": "653567cab3e536482dcffc987403730b9a233555", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -1045,10 +1045,8 @@ default_trampoline_init (rtx ARG_UNUSED (m_tramp), tree ARG_UNUSED (t_func),\n   sorry (\"nested function trampolines not supported on this target\");\n }\n \n-int\n-default_return_pops_args (tree fundecl ATTRIBUTE_UNUSED,\n-\t\t\t  tree funtype ATTRIBUTE_UNUSED,\n-\t\t\t  int size ATTRIBUTE_UNUSED)\n+poly_int64\n+default_return_pops_args (tree, tree, poly_int64)\n {\n   return 0;\n }"}, {"sha": "e753e58f3d29a96353afbf2a81a7b2efbb342bfe", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -158,7 +158,7 @@ extern bool default_function_value_regno_p (const unsigned int);\n extern rtx default_internal_arg_pointer (void);\n extern rtx default_static_chain (const_tree, bool);\n extern void default_trampoline_init (rtx, tree, rtx);\n-extern int default_return_pops_args (tree, tree, int);\n+extern poly_int64 default_return_pops_args (tree, tree, poly_int64);\n extern reg_class_t default_branch_target_register_class (void);\n extern reg_class_t default_ira_change_pseudo_allocno_class (int, reg_class_t,\n \t\t\t\t\t\t\t    reg_class_t);"}, {"sha": "95d3f194942b4647043b0d7f7ee44725060ff513", "filename": "gcc/toplev.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a20c5714c689bf1c0c7a2d2589b4df0eaa4635fb", "patch": "@@ -956,19 +956,32 @@ output_stack_usage (void)\n   stack_usage_kind = STATIC;\n \n   /* Add the maximum amount of space pushed onto the stack.  */\n-  if (current_function_pushed_stack_size > 0)\n+  if (maybe_ne (current_function_pushed_stack_size, 0))\n     {\n-      stack_usage += current_function_pushed_stack_size;\n-      stack_usage_kind = DYNAMIC_BOUNDED;\n+      HOST_WIDE_INT extra;\n+      if (current_function_pushed_stack_size.is_constant (&extra))\n+\t{\n+\t  stack_usage += extra;\n+\t  stack_usage_kind = DYNAMIC_BOUNDED;\n+\t}\n+      else\n+\t{\n+\t  extra = constant_lower_bound (current_function_pushed_stack_size);\n+\t  stack_usage += extra;\n+\t  stack_usage_kind = DYNAMIC;\n+\t}\n     }\n \n   /* Now on to the tricky part: dynamic stack allocation.  */\n   if (current_function_allocates_dynamic_stack_space)\n     {\n-      if (current_function_has_unbounded_dynamic_stack_size)\n-\tstack_usage_kind = DYNAMIC;\n-      else\n-\tstack_usage_kind = DYNAMIC_BOUNDED;\n+      if (stack_usage_kind != DYNAMIC)\n+\t{\n+\t  if (current_function_has_unbounded_dynamic_stack_size)\n+\t    stack_usage_kind = DYNAMIC;\n+\t  else\n+\t    stack_usage_kind = DYNAMIC_BOUNDED;\n+\t}\n \n       /* Add the size even in the unbounded case, this can't hurt.  */\n       stack_usage += current_function_dynamic_stack_size;"}]}