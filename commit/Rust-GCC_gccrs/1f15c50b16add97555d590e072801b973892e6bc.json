{"sha": "1f15c50b16add97555d590e072801b973892e6bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYxNWM1MGIxNmFkZDk3NTU1ZDU5MGUwNzI4MDFiOTczODkyZTZiYw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2011-09-13T14:39:15Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-09-13T14:39:15Z"}, "message": "c++/48320 - Template parameter packs cannot be expanded in default template arguments\n\ngcc/cp/\n\n\tPR c++/48320\n\t* pt.c (template_parameter_pack_p):  Support TEMPLATE_PARM_INDEX\n\tnodes.  Add a comment.\n\t(arg_from_parm_pack_p):  New static function, factorized out from\n\ttsubst_pack_expansion and extended to support non-type parameter\n\tpacks represented with TEMPLATE_PARM_INDEX nodes.\n\t(tsubst_pack_expansion): Use arg_from_parm_pack_p.\n\ngcc/testsuite/\n\n\tPR c++/48320\n\t* g++.dg/cpp0x/variadic116.C: New test case.\n\nFrom-SVN: r178811", "tree": {"sha": "4bbac53fbb932d32a31e8816e87d08008b2b6757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bbac53fbb932d32a31e8816e87d08008b2b6757"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f15c50b16add97555d590e072801b973892e6bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f15c50b16add97555d590e072801b973892e6bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f15c50b16add97555d590e072801b973892e6bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f15c50b16add97555d590e072801b973892e6bc/comments", "author": null, "committer": null, "parents": [{"sha": "42f833bc5f567f1e4da1964ebbd177a5a1c697a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f833bc5f567f1e4da1964ebbd177a5a1c697a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f833bc5f567f1e4da1964ebbd177a5a1c697a1"}], "stats": {"total": 162, "additions": 115, "deletions": 47}, "files": [{"sha": "aa4a31d1ca472f183c788484f0678ef720b17933", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f15c50b16add97555d590e072801b973892e6bc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f15c50b16add97555d590e072801b973892e6bc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f15c50b16add97555d590e072801b973892e6bc", "patch": "@@ -1,3 +1,13 @@\n+2011-09-13  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/48320\n+\t* pt.c (template_parameter_pack_p): Support TEMPLATE_PARM_INDEX\n+\tnodes.  Add a comment.\n+\t(arg_from_parm_pack_p):  New static function, factorized out from\n+\ttsubst_pack_expansion and extended to support non-type parameter\n+\tpacks represented with TEMPLATE_PARM_INDEX nodes.\n+\t(tsubst_pack_expansion): Use arg_from_parm_pack_p.\n+\n 2011-09-12  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (type_unification_real): Fix handling of DEDUCE_CONV"}, {"sha": "14073646a73df242fea12e7e5157d21edbdea8cf", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 68, "deletions": 47, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f15c50b16add97555d590e072801b973892e6bc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f15c50b16add97555d590e072801b973892e6bc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1f15c50b16add97555d590e072801b973892e6bc", "patch": "@@ -203,6 +203,7 @@ static void append_type_to_template_for_access_check_1 (tree, tree, tree,\n static tree listify (tree);\n static tree listify_autos (tree, tree);\n static tree template_parm_to_arg (tree t);\n+static bool arg_from_parm_pack_p (tree, tree);\n static tree current_template_args (void);\n static tree fixup_template_type_parm_type (tree, int);\n static tree fixup_template_parm_index (tree, tree, int);\n@@ -2741,12 +2742,15 @@ template_parameter_pack_p (const_tree parm)\n   if (TREE_CODE (parm) == PARM_DECL)\n     return (DECL_TEMPLATE_PARM_P (parm) \n             && TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)));\n+  if (TREE_CODE (parm) == TEMPLATE_PARM_INDEX)\n+    return TEMPLATE_PARM_PARAMETER_PACK (parm);\n \n   /* If this is a list of template parameters, we could get a\n      TYPE_DECL or a TEMPLATE_DECL.  */ \n   if (TREE_CODE (parm) == TYPE_DECL || TREE_CODE (parm) == TEMPLATE_DECL)\n     parm = TREE_TYPE (parm);\n \n+  /* Otherwise it must be a type template parameter.  */\n   return ((TREE_CODE (parm) == TEMPLATE_TYPE_PARM\n \t   || TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM)\n \t  && TEMPLATE_TYPE_PARAMETER_PACK (parm));\n@@ -4005,6 +4009,63 @@ template_parm_to_arg (tree t)\n   return t;\n }\n \n+/* This function returns TRUE if PARM_PACK is a template parameter\n+   pack and if ARG_PACK is what template_parm_to_arg returned when\n+   passed PARM_PACK.  */\n+\n+static bool\n+arg_from_parm_pack_p (tree arg_pack, tree parm_pack)\n+{\n+  /* For clarity in the comments below let's use the representation\n+     argument_pack<elements>' to denote an argument pack and its\n+     elements.\n+\n+     In the 'if' block below, we want to detect cases where\n+     ARG_PACK is argument_pack<PARM_PACK...>.  I.e, we want to\n+     check if ARG_PACK is an argument pack which sole element is\n+     the expansion of PARM_PACK.  That argument pack is typically\n+     created by template_parm_to_arg when passed a parameter\n+     pack.  */\n+\n+  if (arg_pack\n+      && TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg_pack)) == 1\n+      && PACK_EXPANSION_P (TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0)))\n+    {\n+      tree expansion = TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0);\n+      tree pattern = PACK_EXPANSION_PATTERN (expansion);\n+      /* So we have an argument_pack<P...>.  We want to test if P\n+\t is actually PARM_PACK.  We will not use cp_tree_equal to\n+\t test P and PARM_PACK because during type fixup (by\n+\t fixup_template_parm) P can be a pre-fixup version of a\n+\t type and PARM_PACK be its post-fixup version.\n+\t cp_tree_equal would consider them as different even\n+\t though we would want to consider them compatible for our\n+\t precise purpose here.\n+\n+\t Thus we are going to consider that P and PARM_PACK are\n+\t compatible if they have the same DECL.  */\n+      if ((/* If ARG_PACK is a type parameter pack named by the\n+\t      same DECL as parm_pack ...  */\n+\t   (TYPE_P (pattern)\n+\t    && TYPE_P (parm_pack)\n+\t    && TYPE_NAME (pattern) == TYPE_NAME (parm_pack))\n+\t   /* ... or if PARM_PACK is a non-type parameter named by the\n+\t      same DECL as ARG_PACK.  Note that PARM_PACK being a\n+\t      non-type parameter means it's either a PARM_DECL or a\n+\t      TEMPLATE_PARM_INDEX.  */\n+\t   || (TREE_CODE (pattern) == TEMPLATE_PARM_INDEX\n+\t       && ((TREE_CODE (parm_pack) == PARM_DECL\n+\t\t    && (TEMPLATE_PARM_DECL (pattern)\n+\t\t\t== TEMPLATE_PARM_DECL (DECL_INITIAL (parm_pack))))\n+\t\t   || (TREE_CODE (parm_pack) == TEMPLATE_PARM_INDEX\n+\t\t       && (TEMPLATE_PARM_DECL (pattern)\n+\t\t\t   == TEMPLATE_PARM_DECL (parm_pack))))))\n+\t  && template_parameter_pack_p (pattern))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Within the declaration of a template, return all levels of template\n    parameters that apply.  The template parameters are represented as\n    a TREE_VEC, in the form documented in cp-tree.h for template\n@@ -9105,53 +9166,13 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t  return result;\n \t}\n \n-      /* For clarity in the comments below let's use the\n-\t representation 'argument_pack<elements>' to denote an\n-\t argument pack and its elements.\n-\n-\t In the 'if' block below, we want to detect cases where\n-\t ARG_PACK is argument_pack<PARM_PACK...>.  I.e, we want to\n-\t check if ARG_PACK is an argument pack which sole element is\n-\t the expansion of PARM_PACK.  That argument pack is typically\n-\t created by template_parm_to_arg when passed a parameter\n-\t pack.  */\n-      if (arg_pack\n-          && TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg_pack)) == 1\n-          && PACK_EXPANSION_P (TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0)))\n-        {\n-          tree expansion = TREE_VEC_ELT (ARGUMENT_PACK_ARGS (arg_pack), 0);\n-          tree pattern = PACK_EXPANSION_PATTERN (expansion);\n-\t  /* So we have an argument_pack<P...>.  We want to test if P\n-\t     is actually PARM_PACK.  We will not use cp_tree_equal to\n-\t     test P and PARM_PACK because during type fixup (by\n-\t     fixup_template_parm) P can be a pre-fixup version of a\n-\t     type and PARM_PACK be its post-fixup version.\n-\t     cp_tree_equal would consider them as different even\n-\t     though we would want to consider them compatible for our\n-\t     precise purpose here.\n-\n-\t     Thus we are going to consider that P and PARM_PACK are\n-\t     compatible if they have the same DECL.  */\n-\t  if ((/* If ARG_PACK is a type parameter pack named by the\n-\t\t  same DECL as parm_pack ...  */\n-\t       (TYPE_P (pattern)\n-\t\t&& TYPE_P (parm_pack)\n-\t\t&& TYPE_NAME (pattern) == TYPE_NAME (parm_pack))\n-\t       /* ... or if ARG_PACK is a non-type parameter\n-\t\t  named by the same DECL as parm_pack ...  */\n-\t       || (TREE_CODE (pattern) == TEMPLATE_PARM_INDEX\n-\t\t   && TREE_CODE (parm_pack) == PARM_DECL\n-\t\t   && TEMPLATE_PARM_DECL (pattern)\n-\t\t   == TEMPLATE_PARM_DECL (DECL_INITIAL (parm_pack))))\n-\t      && template_parameter_pack_p (pattern))\n-            /* ... then the argument pack that the parameter maps to\n-               is just an expansion of the parameter itself, such as\n-               one would find in the implicit typedef of a class\n-               inside the class itself.  Consider this parameter\n-               \"unsubstituted\", so that we will maintain the outer\n-               pack expansion.  */\n-            arg_pack = NULL_TREE;\n-        }\n+      if (arg_from_parm_pack_p (arg_pack, parm_pack))\n+\t/* The argument pack that the parameter maps to is just an\n+\t   expansion of the parameter itself, such as one would find\n+\t   in the implicit typedef of a class inside the class itself.\n+\t   Consider this parameter \"unsubstituted\", so that we will\n+\t   maintain the outer pack expansion.  */\n+\targ_pack = NULL_TREE;\n           \n       if (arg_pack)\n         {"}, {"sha": "65af046e5a485563fb155becf6510fe1bc58b479", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f15c50b16add97555d590e072801b973892e6bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f15c50b16add97555d590e072801b973892e6bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f15c50b16add97555d590e072801b973892e6bc", "patch": "@@ -1,3 +1,8 @@\n+2011-09-13  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/48320\n+\t* g++.dg/cpp0x/variadic116.C: New test case.\n+\n 2011-09-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.target/mips/mips.exp (mips_option_groups): Add debug options."}, {"sha": "079d751cb46fcf42ae6e3d51ee29640a42ddb52f", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic116.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f15c50b16add97555d590e072801b973892e6bc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic116.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f15c50b16add97555d590e072801b973892e6bc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic116.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic116.C?ref=1f15c50b16add97555d590e072801b973892e6bc", "patch": "@@ -0,0 +1,32 @@\n+// Origin: PR c++/48320\n+// { dg-options -std=c++0x }\n+\n+template<class... T>\n+struct tuple\n+{\n+    typedef int type;\n+};\n+\n+template<int... Indices>\n+struct indices\n+{\n+};\n+\n+template<unsigned i, class Tuple>\n+struct tuple_element\n+{\n+    typedef Tuple type;\n+};\n+\n+template<class Tuple,\n+         int... Indices,\n+         class Result = tuple<typename tuple_element<Indices, Tuple>::type...> >\n+Result\n+f(Tuple&&, indices<Indices...>);\n+\n+\n+void\n+foo()\n+{\n+    f(tuple<int, char, unsigned> (), indices<2, 1, 0> ());\n+}"}]}