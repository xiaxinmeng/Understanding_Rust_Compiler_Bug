{"sha": "25ef215abb1aa701db7ab173b9f2ac653cecf634", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlZjIxNWFiYjFhYTcwMWRiN2FiMTczYjlmMmFjNjUzY2VjZjYzNA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-28T14:10:38Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-09T20:59:32Z"}, "message": "analyzer: eliminate sm_context::warn_for_state in favor of a new 'warn' vfunc\n\nThis patch is yet more preliminary work towards generalizing sm-malloc.cc\nbeyond just malloc/free.\n\nIt eliminates sm_context::warn_for_state in terms of a new sm_context::warn\nvfunc, guarded by sm_context::get_state calls.\n\ngcc/analyzer/ChangeLog:\n\t* diagnostic-manager.cc\n\t(null_assignment_sm_context::warn_for_state): Replace with...\n\t(null_assignment_sm_context::warn): ...this.\n\t* engine.cc (impl_sm_context::warn_for_state): Replace with...\n\t(impl_sm_context::warn): ...this.\n\t* sm-file.cc (fileptr_state_machine::on_stmt): Replace\n\twarn_for_state and on_transition calls with a get_state\n\ttest guarding warn and set_next_state calls.\n\t* sm-malloc.cc (malloc_state_machine::on_stmt): Likewise.\n\t* sm-pattern-test.cc (pattern_test_state_machine::on_condition):\n\tReplace warn_for_state call with warn call.\n\t* sm-sensitive.cc\n\t(sensitive_state_machine::warn_for_any_exposure): Replace\n\twarn_for_state call with a get_state test guarding a warn call.\n\t* sm-signal.cc (signal_state_machine::on_stmt): Likewise.\n\t* sm-taint.cc (taint_state_machine::on_stmt):  Replace\n\twarn_for_state and on_transition calls with a get_state\n\ttest guarding warn and set_next_state calls.\n\t* sm.h (sm_context::warn_for_state): Replace with...\n\t(sm_context::warn): ...this.", "tree": {"sha": "32bb13109b66be13aa99258314770b33ac8f0fde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32bb13109b66be13aa99258314770b33ac8f0fde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25ef215abb1aa701db7ab173b9f2ac653cecf634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25ef215abb1aa701db7ab173b9f2ac653cecf634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25ef215abb1aa701db7ab173b9f2ac653cecf634", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25ef215abb1aa701db7ab173b9f2ac653cecf634/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d9ca8c8604e2e7c2403794baf691b260cc71fb9"}], "stats": {"total": 196, "additions": 108, "deletions": 88}, "files": [{"sha": "4a95d4c569e360d92d6dbfea522e2451ae17bdb9", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -808,9 +808,8 @@ struct null_assignment_sm_context : public sm_context\n \t\t\t\t\t\t\t*m_new_state));\n   }\n \n-  void warn_for_state (const supernode *, const gimple *,\n-\t\t       tree, state_machine::state_t,\n-\t\t       pending_diagnostic *d) FINAL OVERRIDE\n+  void warn (const supernode *, const gimple *,\n+\t     tree, pending_diagnostic *d) FINAL OVERRIDE\n   {\n     delete d;\n   }"}, {"sha": "49701b74fd402d7f1ca90ee27b5fd82f8cf6ef61", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -254,35 +254,23 @@ class impl_sm_context : public sm_context\n \t\t\t   to, origin_new_sval, m_eg.get_ext_state ());\n   }\n \n-  void warn_for_state (const supernode *snode, const gimple *stmt,\n-\t\t       tree var, state_machine::state_t state,\n-\t\t       pending_diagnostic *d) FINAL OVERRIDE\n+  void warn (const supernode *snode, const gimple *stmt,\n+\t     tree var, pending_diagnostic *d) FINAL OVERRIDE\n   {\n     LOG_FUNC (get_logger ());\n     gcc_assert (d); // take ownership\n-\n     impl_region_model_context old_ctxt\n       (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL);\n-    state_machine::state_t current;\n-    if (var)\n-      {\n-\tconst svalue *var_old_sval\n-\t  = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n-\tcurrent = m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ());\n-      }\n-    else\n-      current = m_old_smap->get_global_state ();\n \n-    if (state == current)\n-      {\n-\tconst svalue *var_old_sval\n-\t  = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n-\tm_eg.get_diagnostic_manager ().add_diagnostic\n-\t  (&m_sm, m_enode_for_diag, snode, stmt, m_stmt_finder,\n-\t   var, var_old_sval, state, d);\n-      }\n-    else\n-      delete d;\n+    const svalue *var_old_sval\n+      = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n+    state_machine::state_t current\n+      = (var\n+\t ? m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ())\n+\t : m_old_smap->get_global_state ());\n+    m_eg.get_diagnostic_manager ().add_diagnostic\n+      (&m_sm, m_enode_for_diag, snode, stmt, m_stmt_finder,\n+       var, var_old_sval, current, d);\n   }\n \n   /* Hook for picking more readable trees for SSA names of temporaries,"}, {"sha": "58a0fd461fa57c88906c4aa0923e6a7efec48a76", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -344,9 +344,12 @@ fileptr_state_machine::on_stmt (sm_context *sm_ctxt,\n \n \t    sm_ctxt->on_transition (node, stmt , arg, m_nonnull, m_closed);\n \n-\t    sm_ctxt->warn_for_state (node, stmt, arg, m_closed,\n-\t\t\t\t     new double_fclose (*this, diag_arg));\n-\t    sm_ctxt->on_transition (node, stmt, arg, m_closed, m_stop);\n+\t    if (sm_ctxt->get_state (stmt, arg) == m_closed)\n+\t      {\n+\t\tsm_ctxt->warn (node, stmt, arg,\n+\t\t\t       new double_fclose (*this, diag_arg));\n+\t\tsm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t      }\n \t    return true;\n \t  }\n "}, {"sha": "2f7db924b946ff341078693371955e11d9f90d12", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 49, "deletions": 28, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -716,14 +716,20 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t       we don't want to complain about double-free of NULL.  */\n \n \t    /* freed -> stop, with warning.  */\n-\t    sm_ctxt->warn_for_state (node, stmt, arg, m_freed,\n-\t\t\t\t     new double_free (*this, diag_arg));\n-\t    sm_ctxt->on_transition (node, stmt, arg, m_freed, m_stop);\n+\t    if (sm_ctxt->get_state (stmt, arg) == m_freed)\n+\t      {\n+\t\tsm_ctxt->warn (node, stmt, arg,\n+\t\t\t       new double_free (*this, diag_arg));\n+\t\tsm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t      }\n \n \t    /* non-heap -> stop, with warning.  */\n-\t    sm_ctxt->warn_for_state (node, stmt, arg, m_non_heap,\n-\t\t\t\t     new free_of_non_heap (*this, diag_arg));\n-\t    sm_ctxt->on_transition (node, stmt, arg, m_non_heap, m_stop);\n+\t    if (sm_ctxt->get_state (stmt, arg) == m_non_heap)\n+\t      {\n+\t\tsm_ctxt->warn (node, stmt, arg,\n+\t\t\t       new free_of_non_heap (*this, diag_arg));\n+\t\tsm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t      }\n \t    return true;\n \t  }\n \n@@ -744,17 +750,23 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t\t      || bitmap_bit_p (nonnull_args, i))\n \t\t    {\n \t\t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-\t\t      sm_ctxt->warn_for_state\n-\t\t\t(node, stmt, arg, m_unchecked,\n-\t\t\t new possible_null_arg (*this, diag_arg, callee_fndecl,\n-\t\t\t\t\t\ti));\n-\t\t      sm_ctxt->on_transition (node, stmt, arg, m_unchecked,\n-\t\t\t\t\t      m_nonnull);\n-\n-\t\t      sm_ctxt->warn_for_state\n-\t\t\t(node, stmt, arg, m_null,\n-\t\t\t new null_arg (*this, diag_arg, callee_fndecl, i));\n-\t\t      sm_ctxt->on_transition (node, stmt, arg, m_null, m_stop);\n+\t\t      state_t state = sm_ctxt->get_state (stmt, arg);\n+\t\t      /* Can't use a switch as the states are non-const.  */\n+\t\t      if (state == m_unchecked)\n+\t\t\t{\n+\t\t\t  sm_ctxt->warn (node, stmt, arg,\n+\t\t\t\t\t new possible_null_arg (*this, diag_arg,\n+\t\t\t\t\t\t\t\tcallee_fndecl,\n+\t\t\t\t\t\t\t\ti));\n+\t\t\t  sm_ctxt->set_next_state (stmt, arg, m_nonnull);\n+\t\t\t}\n+\t\t      else if (state == m_null)\n+\t\t\t{\n+\t\t\t  sm_ctxt->warn (node, stmt, arg,\n+\t\t\t\t\t new null_arg (*this, diag_arg,\n+\t\t\t\t\t\t       callee_fndecl, i));\n+\t\t\t  sm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t\t\t}\n \t\t    }\n \t\t}\n \t      BITMAP_FREE (nonnull_args);\n@@ -800,17 +812,26 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  tree arg = TREE_OPERAND (op, 0);\n \t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \n-\t  sm_ctxt->warn_for_state (node, stmt, arg, m_unchecked,\n-\t\t\t\t   new possible_null_deref (*this, diag_arg));\n-\t  sm_ctxt->on_transition (node, stmt, arg, m_unchecked, m_nonnull);\n-\n-\t  sm_ctxt->warn_for_state (node, stmt, arg, m_null,\n-\t\t\t\t   new null_deref (*this, diag_arg));\n-\t  sm_ctxt->on_transition (node, stmt, arg, m_null, m_stop);\n-\n-\t  sm_ctxt->warn_for_state (node, stmt, arg, m_freed,\n-\t\t\t\t   new use_after_free (*this, diag_arg));\n-\t  sm_ctxt->on_transition (node, stmt, arg, m_freed, m_stop);\n+\t  state_t state = sm_ctxt->get_state (stmt, arg);\n+\t  /* Can't use a switch as the states are non-const.  */\n+\t  if (state == m_unchecked)\n+\t    {\n+\t      sm_ctxt->warn (node, stmt, arg,\n+\t\t\t     new possible_null_deref (*this, diag_arg));\n+\t      sm_ctxt->set_next_state (stmt, arg, m_nonnull);\n+\t    }\n+\t  else if (state == m_null)\n+\t    {\n+\t      sm_ctxt->warn (node, stmt, arg,\n+\t\t\t     new null_deref (*this, diag_arg));\n+\t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t    }\n+\t  else if (state == m_freed)\n+\t    {\n+\t      sm_ctxt->warn (node, stmt, arg,\n+\t\t\t     new use_after_free (*this, diag_arg));\n+\t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t    }\n \t}\n     }\n   return false;"}, {"sha": "bb6d3b1e719687594cbff937726e774bbfd8b574", "filename": "gcc/analyzer/sm-pattern-test.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-pattern-test.cc?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -128,7 +128,7 @@ pattern_test_state_machine::on_condition (sm_context *sm_ctxt,\n     return;\n \n   pending_diagnostic *diag = new pattern_match (lhs, op, rhs);\n-  sm_ctxt->warn_for_state (node, stmt, lhs, m_start, diag);\n+  sm_ctxt->warn (node, stmt, lhs, diag);\n }\n \n bool"}, {"sha": "49f9eb387b19a6377ae4e7e8aea678bc54b8d110", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -174,8 +174,9 @@ sensitive_state_machine::warn_for_any_exposure (sm_context *sm_ctxt,\n \t\t\t\t\t\ttree arg) const\n {\n   tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-  sm_ctxt->warn_for_state (node, stmt, arg, m_sensitive,\n-\t\t\t   new exposure_through_output_file (*this, diag_arg));\n+  if (sm_ctxt->get_state (stmt, arg) == m_sensitive)\n+    sm_ctxt->warn (node, stmt, arg,\n+\t\t   new exposure_through_output_file (*this, diag_arg));\n }\n \n /* Implementation of state_machine::on_stmt vfunc for"}, {"sha": "bf6ea4804238388963a75136287c36bba4f1bf63", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -346,9 +346,10 @@ signal_state_machine::on_stmt (sm_context *sm_ctxt,\n       if (const gcall *call = dyn_cast <const gcall *> (stmt))\n \tif (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n \t  if (signal_unsafe_p (callee_fndecl))\n-\t    sm_ctxt->warn_for_state (node, stmt, NULL_TREE, m_in_signal_handler,\n-\t\t\t\t     new signal_unsafe_call (*this, call,\n-\t\t\t\t\t\t\t     callee_fndecl));\n+\t    if (sm_ctxt->get_global_state () == m_in_signal_handler)\n+\t      sm_ctxt->warn (node, stmt, NULL_TREE,\n+\t\t\t     new signal_unsafe_call (*this, call,\n+\t\t\t\t\t\t     callee_fndecl));\n     }\n \n   return false;"}, {"sha": "49bbd6dfb131c01390da51f1036f94e5e60ce005", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -233,27 +233,36 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (arg)))\n \t    is_unsigned = TYPE_UNSIGNED (TREE_TYPE (arg));\n \n-\t  /* Complain about missing bounds.  */\n-\t  sm_ctxt->warn_for_state\n-\t    (node, stmt, arg, m_tainted,\n-\t     new tainted_array_index (*this, diag_arg,\n-\t\t\t\t      is_unsigned\n-\t\t\t\t      ? BOUNDS_LOWER : BOUNDS_NONE));\n-\t  sm_ctxt->on_transition (node, stmt, arg, m_tainted, m_stop);\n-\n-\t  /* Complain about missing upper bound.  */\n-\t  sm_ctxt->warn_for_state  (node, stmt, arg, m_has_lb,\n-\t\t\t\t    new tainted_array_index (*this, diag_arg,\n-\t\t\t\t\t\t\t     BOUNDS_LOWER));\n-\t  sm_ctxt->on_transition (node, stmt, arg, m_has_lb, m_stop);\n-\n-\t  /* Complain about missing lower bound.  */\n-\t  if (!is_unsigned)\n+\t  state_t state = sm_ctxt->get_state (stmt, arg);\n+\t  /* Can't use a switch as the states are non-const.  */\n+\t  if (state == m_tainted)\n \t    {\n-\t      sm_ctxt->warn_for_state  (node, stmt, arg, m_has_ub,\n-\t\t\t\t\tnew tainted_array_index (*this, diag_arg,\n-\t\t\t\t\t\t\t\t BOUNDS_UPPER));\n-\t      sm_ctxt->on_transition (node, stmt, arg, m_has_ub, m_stop);\n+\t      /* Complain about missing bounds.  */\n+\t      pending_diagnostic *d\n+\t\t= new tainted_array_index (*this, diag_arg,\n+\t\t\t\t\t   is_unsigned\n+\t\t\t\t\t   ? BOUNDS_LOWER : BOUNDS_NONE);\n+\t      sm_ctxt->warn (node, stmt, arg, d);\n+\t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t    }\n+\t  else if (state == m_has_lb)\n+\t    {\n+\t      /* Complain about missing upper bound.  */\n+\t      sm_ctxt->warn (node, stmt, arg,\n+\t\t\t      new tainted_array_index (*this, diag_arg,\n+\t\t\t\t\t\t       BOUNDS_LOWER));\n+\t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t    }\n+\t  else if (state == m_has_ub)\n+\t    {\n+\t      /* Complain about missing lower bound.  */\n+\t      if (!is_unsigned)\n+\t\t{\n+\t\t  sm_ctxt->warn  (node, stmt, arg,\n+\t\t\t\t  new tainted_array_index (*this, diag_arg,\n+\t\t\t\t\t\t\t   BOUNDS_UPPER));\n+\t\t  sm_ctxt->set_next_state (stmt, arg, m_stop);\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "740cbecd7a9f0d5734da702db8799a4cbdc1bed5", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25ef215abb1aa701db7ab173b9f2ac653cecf634/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=25ef215abb1aa701db7ab173b9f2ac653cecf634", "patch": "@@ -198,11 +198,9 @@ class sm_context\n   }\n \n   /* Called by state_machine in response to pattern matches:\n-     issue a diagnostic D if VAR is in state STATE, using NODE and STMT\n-     for location information.  */\n-  virtual void warn_for_state (const supernode *node, const gimple *stmt,\n-\t\t\t       tree var, state_machine::state_t state,\n-\t\t\t       pending_diagnostic *d) = 0;\n+     issue a diagnostic D using NODE and STMT for location information.  */\n+  virtual void warn (const supernode *node, const gimple *stmt,\n+\t\t     tree var, pending_diagnostic *d) = 0;\n \n   /* For use when generating trees when creating pending_diagnostics, so that\n      rather than e.g."}]}