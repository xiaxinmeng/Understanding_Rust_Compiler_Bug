{"sha": "3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjM2Q5ZWFmMTA2YzVhZDRhNTA4MTliMGFhYjA3ODczMTVlM2ExZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-02-11T01:22:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-11T01:22:36Z"}, "message": "cp-tree.h (push_template_decl): Return the decl passed in, or an equivalent duplicate.\n\n\t* cp-tree.h (push_template_decl): Return the decl passed in, or an\n\tequivalent duplicate.\n\t* decl.c (pushtag): Use the return value from push_template_decl.\n\t(duplicate_decls): When duplicating a template declaration, merge\n\tthe DECL_TEMPLATE_RESULTs as well.\n\t(make_implicit_typename): Don't try to dive into typename types to\n\tfind a context for making a new implicit typename.\n\t(start_decl): Use the return value from push_template_decl.\n\t(grokdeclarator): Complain about declarations list `const operator\n\tint'.  Since we don't correctly handle in-class initializations of\n\tnon-static data members, complain about this (now illegal)\n\tpractice.  Issue an error for initializations of non-const statics\n\tsince that is illegal as well, and since we don't handle that case\n\tcorrectly either.\n\t(start_function): Use the return value from push_template_decl.\n\t(start_method): Likewise.\n\t* decl2.c (grokfield): Likewise.  Since the change to\n\tgrokdeclarator ensures that all initialized fields are in fact\n\tstatic, remove a redundant test for TREE_PUBLIC.\n\t* parse.y (initlist): Disable labeled initializers since they do\n\tnot work as per the documentation, and since they do not use the\n\tsame syntax as the C front end.\n\t* pt.c (push_template_decl): Return the decl passed in, or an\n\tequivalent duplicate.\n\t(lookup_template_class): When searching in a nested context,\n\tuse the right arguments.\n\t(uses_template_parms): Handle the DECL_INITIAL for a CONST_DECL.\n\t* typeck.c (build_component_ref): Assign the correct type to the\n\tresult of build_vfn_ref.\n\nFrom-SVN: r17852", "tree": {"sha": "117db38464a92e2be12737390b4177d68614223c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/117db38464a92e2be12737390b4177d68614223c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/comments", "author": null, "committer": null, "parents": [{"sha": "8cd61d76f7865b537d9e4de50419789b31ab73bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd61d76f7865b537d9e4de50419789b31ab73bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd61d76f7865b537d9e4de50419789b31ab73bf"}], "stats": {"total": 6487, "additions": 3244, "deletions": 3243}, "files": [{"sha": "e944c6e68fa9d28b68dd5bbf9559c9534ff91b5f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "patch": "@@ -1,3 +1,35 @@\n+Mon Feb  9 22:23:31 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* cp-tree.h (push_template_decl): Return the decl passed in, or an\n+\tequivalent duplicate.\n+\t* decl.c (pushtag): Use the return value from push_template_decl.\n+\t(duplicate_decls): When duplicating a template declaration, merge\n+\tthe DECL_TEMPLATE_RESULTs as well.\n+\t(make_implicit_typename): Don't try to dive into typename types to\n+\tfind a context for making a new implicit typename.\n+\t(start_decl): Use the return value from push_template_decl.\n+\t(grokdeclarator): Complain about declarations list `const operator\n+\tint'.  Since we don't correctly handle in-class initializations of\n+\tnon-static data members, complain about this (now illegal)\n+\tpractice.  Issue an error for initializations of non-const statics\n+\tsince that is illegal as well, and since we don't handle that case\n+\tcorrectly either.\n+\t(start_function): Use the return value from push_template_decl.\n+\t(start_method): Likewise.\n+\t* decl2.c (grokfield): Likewise.  Since the change to\n+\tgrokdeclarator ensures that all initialized fields are in fact\n+\tstatic, remove a redundant test for TREE_PUBLIC.\n+\t* parse.y (initlist): Disable labeled initializers since they do\n+\tnot work as per the documentation, and since they do not use the\n+\tsame syntax as the C front end.\n+\t* pt.c (push_template_decl): Return the decl passed in, or an\n+\tequivalent duplicate.\n+\t(lookup_template_class): When searching in a nested context,\n+\tuse the right arguments.\n+\t(uses_template_parms): Handle the DECL_INITIAL for a CONST_DECL.\n+\t* typeck.c (build_component_ref): Assign the correct type to the\n+\tresult of build_vfn_ref.\n+\t\n Tue Feb 10 23:56:46 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (convert_nontype_argument): Fix typo."}, {"sha": "b0c908adb8bd4878dfdcccd85552934313a8e61a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "patch": "@@ -2351,7 +2351,7 @@ extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n extern void end_template_decl\t\t\tPROTO((void));\n extern tree current_template_args\t\tPROTO((void));\n-extern void push_template_decl\t\t\tPROTO((tree));\n+extern tree push_template_decl\t\t\tPROTO((tree));\n extern tree lookup_template_class\t\tPROTO((tree, tree, tree, tree));\n extern tree lookup_template_function            PROTO((tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));"}, {"sha": "45ab6d949277156456005709c511d4d686621345", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "patch": "@@ -2139,7 +2139,7 @@ pushtag (name, type, globalize)\n \t      TYPE_NAME (type) = d;\n \t      DECL_CONTEXT (d) = context;\n \t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n-\t\tpush_template_decl (d);\n+\t\td = push_template_decl (d);\n \n \t      if (b->parm_flag == 2)\n \t\td = pushdecl_class_level (d);\n@@ -2155,7 +2155,7 @@ pushtag (name, type, globalize)\n \t      TYPE_NAME (type) = d;\n \t      DECL_CONTEXT (d) = context;\n \t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n-\t\tpush_template_decl (d);\n+\t\td = push_template_decl (d);\n \n \t      d = pushdecl_class_level (d);\n \t    }\n@@ -2754,8 +2754,10 @@ duplicate_decls (newdecl, olddecl)\n     {\n       if (DECL_INITIAL (DECL_TEMPLATE_RESULT (olddecl)) == NULL_TREE)\n \t{\n-\t  TREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n-\t  DECL_TEMPLATE_RESULT (olddecl) = DECL_TEMPLATE_RESULT (newdecl);\n+\t  if (! duplicate_decls (DECL_TEMPLATE_RESULT (newdecl),\n+\t\t\t\t DECL_TEMPLATE_RESULT (olddecl)))\n+\t    cp_error (\"invalid redeclaration of %D\", newdecl);\n+\t  TREE_TYPE (olddecl) = TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl));\n \t  DECL_TEMPLATE_PARMS (olddecl) = DECL_TEMPLATE_PARMS (newdecl);\n \t}\n       return 1;\n@@ -4463,7 +4465,8 @@ make_implicit_typename (context, t)\n {\n   tree retval;\n \n-  if (uses_template_parms (DECL_CONTEXT (t))\n+  if (TREE_CODE (context) != TYPENAME_TYPE \n+      && uses_template_parms (DECL_CONTEXT (t))\n       && DECL_CONTEXT (t) != context)\n     {\n       tree binfo = get_binfo (DECL_CONTEXT (t), context, 0);\n@@ -6141,7 +6144,7 @@ start_decl (declarator, declspecs, initialized)\n   if (processing_template_decl)\n     {\n       if (! current_function_decl)\n-\tpush_template_decl (tem);\n+\ttem = push_template_decl (tem);\n       else if (minimal_parse_mode)\n \tDECL_VINDEX (decl)\n \t    = build_min_nt (DECL_STMT, copy_to_permanent (declarator),\n@@ -8457,6 +8460,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \ttype = build_complex_type (type);\n     }\n \n+  if (return_type == return_conversion \n+      && (RIDBIT_SETP (RID_CONST, specbits)\n+\t  || RIDBIT_SETP (RID_VOLATILE, specbits)))\n+    cp_error (\"`operator %T' cannot be cv-qualified\",\n+\t      ctor_return_type);\n+\n   /* Set CONSTP if this declaration is `const', whether by\n      explicit specification or via a typedef.\n      Likewise for VOLATILEP.  */\n@@ -9797,41 +9806,49 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  {\n \t    if (initialized)\n \t      {\n+\t\tif (!staticp)\n+\t\t  {\n+\t\t    /* An attempt is being made to initialize a non-static\n+\t\t       member.  But, from [class.mem]:\n+\t\t       \n+\t\t       4 A member-declarator can contain a\n+\t\t       constant-initializer only if it declares a static\n+\t\t       member (_class.static_) of integral or enumeration\n+\t\t       type, see _class.static.data_.  \n+\n+\t\t       This used to be relatively common practice, but\n+\t\t       the rest of the compiler does not correctly\n+\t\t       handle the initialization unless the member is\n+\t\t       static so we make it static below.  */\n+\t\t    cp_pedwarn (\"ANSI C++ forbids initialization of %s `%D'\",\n+\t\t\t\tconstp ? \"const member\" : \"member\", \n+\t\t\t\tdeclarator);\n+\t\t    cp_pedwarn (\"making `%D' static\", declarator);\n+\t\t    staticp = 1;\n+\t\t  }\n+\n \t\t/* Motion 10 at San Diego: If a static const integral data\n \t\t   member is initialized with an integral constant\n \t\t   expression, the initializer may appear either in the\n \t\t   declaration (within the class), or in the definition,\n \t\t   but not both.  If it appears in the class, the member is\n \t\t   a member constant.  The file-scope definition is always\n \t\t   required.  */\n-\t\tif (staticp)\n-\t\t  {\n-\t\t    if (pedantic)\n-\t\t      {\n-\t\t\tif (! constp)\n-\t\t\t  cp_pedwarn (\"ANSI C++ forbids in-class initialization of non-const static member `%D'\",\n-\t\t\t\t      declarator);\n-\n-\t\t\telse if (! INTEGRAL_TYPE_P (type))\n-\t\t\t  cp_pedwarn (\"ANSI C++ forbids member constant `%D' of non-integral type `%T'\", declarator, type);\n-\t\t      }\n-\t\t  }\n-\n-\t\t/* Note that initialization of const members is prohibited\n-\t\t   by the draft ANSI standard, though it appears to be in\n-\t\t   common practice.  12.6.2: The argument list is used to\n-\t\t   initialize the named nonstatic member....  This (or an\n-\t\t   initializer list) is the only way to initialize\n-\t\t   nonstatic const and reference members.  */\n-\t\telse if (pedantic || ! constp)\n-\t\t  cp_pedwarn (\"ANSI C++ forbids initialization of %s `%D'\",\n-\t\t\t      constp ? \"const member\" : \"member\", declarator);\n+\t\tif (! constp)\n+\t\t  /* According to Mike Stump, we generate bad code for\n+\t\t     this case, so we might as well always make it an\n+\t\t     error.  */\n+\t\t  cp_error (\"ANSI C++ forbids in-class initialization of non-const static member `%D'\",\n+\t\t\t    declarator);\n+\t\t\n+\t\tif (pedantic && ! INTEGRAL_TYPE_P (type))\n+\t\t  cp_pedwarn (\"ANSI C++ forbids initialization of member constant `%D' of non-integral type `%T'\", declarator, type);\n \t      }\n \n-\t    if (staticp || (constp && initialized))\n+\t    if (staticp)\n \t      {\n \t\t/* ANSI C++ Apr '95 wp 9.2 */\n-\t\tif (staticp && declarator == current_class_name)\n+\t\tif (declarator == current_class_name)\n \t\t  cp_pedwarn (\"ANSI C++ forbids static member `%D' with same name as enclosing class\",\n \t\t\t      declarator);\n \n@@ -9842,7 +9859,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\tdecl = build_lang_field_decl (VAR_DECL, declarator, type);\n \t\tTREE_STATIC (decl) = 1;\n \t\t/* In class context, 'static' means public access.  */\n-\t\tTREE_PUBLIC (decl) = DECL_EXTERNAL (decl) = !!staticp;\n+\t\tTREE_PUBLIC (decl) = DECL_EXTERNAL (decl) = 1;\n \t      }\n \t    else\n \t      {\n@@ -11616,7 +11633,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n      use the old decl.  */\n \n   if (processing_template_decl)\n-    push_template_decl (decl1);\n+    decl1 = push_template_decl (decl1);\n   else if (pre_parsed_p == 0)\n     {\n       /* A specialization is not used to guide overload resolution.  */\n@@ -12667,7 +12684,7 @@ start_method (declspecs, declarator)\n     DECL_INLINE (fndecl) = 1;\n \n   if (processing_template_decl)\n-    push_template_decl (fndecl);\n+    fndecl = push_template_decl (fndecl);\n \n   /* We read in the parameters on the maybepermanent_obstack,\n      but we won't be getting back to them until after we"}, {"sha": "c598c1adbf6f0f9f9bc95ed6e77027c158dff17a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "patch": "@@ -1685,46 +1685,45 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \n   if (processing_template_decl && ! current_function_decl\n       && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))\n-    push_template_decl (value);\n+    value = push_template_decl (value);\n \n   if (attrlist)\n     cplus_decl_attributes (value, TREE_PURPOSE (attrlist),\n \t\t\t   TREE_VALUE (attrlist));\n \n   if (TREE_CODE (value) == VAR_DECL)\n     {\n+      my_friendly_assert (TREE_PUBLIC (value), 0);\n+\n       /* We cannot call pushdecl here, because that would\n \t fill in the value of our TREE_CHAIN.  Instead, we\n \t modify cp_finish_decl to do the right thing, namely, to\n \t put this decl out straight away.  */\n-      if (TREE_PUBLIC (value))\n+      /* current_class_type can be NULL_TREE in case of error.  */\n+      if (asmspec == 0 && current_class_type)\n \t{\n-\t  /* current_class_type can be NULL_TREE in case of error.  */\n-\t  if (asmspec == 0 && current_class_type)\n-\t    {\n-\t      TREE_PUBLIC (value) = 1;\n-\t      DECL_INITIAL (value) = error_mark_node;\n-\t      DECL_ASSEMBLER_NAME (value)\n-\t\t= build_static_name (current_class_type, DECL_NAME (value));\n-\t    }\n-\t  if (! processing_template_decl)\n-\t    pending_statics = perm_tree_cons (NULL_TREE, value, pending_statics);\n-\n-\t  /* Static consts need not be initialized in the class definition.  */\n-\t  if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (value)))\n-\t    {\n-\t      static int explanation = 0;\n-\n-\t      error (\"initializer invalid for static member with constructor\");\n-\t      if (explanation++ == 0)\n-\t\terror (\"(you really want to initialize it separately)\");\n-\t      init = 0;\n-\t    }\n-\t  /* Force the compiler to know when an uninitialized static\n-\t     const member is being used.  */\n-\t  if (TYPE_READONLY (value) && init == 0)\n-\t    TREE_USED (value) = 1;\n+\t  TREE_PUBLIC (value) = 1;\n+\t  DECL_INITIAL (value) = error_mark_node;\n+\t  DECL_ASSEMBLER_NAME (value)\n+\t    = build_static_name (current_class_type, DECL_NAME (value));\n \t}\n+      if (! processing_template_decl)\n+\tpending_statics = perm_tree_cons (NULL_TREE, value, pending_statics);\n+      \n+      /* Static consts need not be initialized in the class definition.  */\n+      if (init != NULL_TREE && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (value)))\n+\t{\n+\t  static int explanation = 0;\n+\t  \n+\t  error (\"initializer invalid for static member with constructor\");\n+\t  if (explanation++ == 0)\n+\t    error (\"(you really want to initialize it separately)\");\n+\t  init = 0;\n+\t}\n+      /* Force the compiler to know when an uninitialized static\n+\t const member is being used.  */\n+      if (TYPE_READONLY (value) && init == 0)\n+\tTREE_USED (value) = 1;\n       DECL_INITIAL (value) = init;\n       DECL_IN_AGGR_P (value) = 1;\n       DECL_CONTEXT (value) = current_class_type;"}, {"sha": "a1a12392affb831be829cf928ea73978b632752d", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3098, "deletions": 3172, "changes": 6270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d"}, {"sha": "1b1e7679d3b6327b94c80ac771c87bbad4758977", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "patch": "@@ -2208,7 +2208,11 @@ initlist:\n \t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n \t| initlist ',' init\n \t\t{ $$ = expr_tree_cons (NULL_TREE, $3, $$); }\n-\t/* These are for labeled elements.  */\n+\t/* These are for labeled elements, which don't currently work\n+\t   as documented, or give warning messages when used with\n+\t   -ansi -pedantic, or match the syntax currently used in the\n+\t   C front-end.  They are therefore disabled.  \n+\n \t| '[' expr_no_commas ']' init\n \t\t{ $$ = build_expr_list ($2, $4); }\n \t| initlist ',' CASE expr_no_commas ':' init\n@@ -2217,6 +2221,7 @@ initlist:\n \t\t{ $$ = build_expr_list ($$, $3); }\n \t| initlist ',' identifier ':' init\n \t\t{ $$ = expr_tree_cons ($3, $5, $$); }\n+\t*/\n \t;\n \n fn.defpen:"}, {"sha": "e4fa8bb29b9286da6c996496c8b5ffefdba8a388", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "patch": "@@ -1211,7 +1211,12 @@ build_template_decl (decl, parms)\n }\n \n   \n-void\n+/* Creates a TEMPLATE_DECL for the indicated DECL using the template\n+   parameters given by current_template_args, or reuses a previously\n+   existing one, if appropriate.  Returns the DECL, or an equivalent\n+   one, if it is replaced via a call to duplicate_decls.  */\n+\n+tree\n push_template_decl (decl)\n      tree decl;\n {\n@@ -1246,14 +1251,14 @@ push_template_decl (decl)\n \t  /* purpose: args to main template\n \t     value: spec template */\n \t  if (comp_template_args (TREE_PURPOSE (spec), mainargs))\n-\t    return;\n+\t    return decl;\n \t}\n \n       DECL_TEMPLATE_SPECIALIZATIONS (maintmpl) = CLASSTYPE_TI_SPEC_INFO (type)\n \t= perm_tree_cons (mainargs, TREE_VALUE (current_template_parms),\n \t\t\t  DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n       TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)) = type;\n-      return;\n+      return decl;\n     }\n \n   args = current_template_args ();\n@@ -1286,7 +1291,7 @@ push_template_decl (decl)\n       else if (! DECL_TEMPLATE_INFO (decl))\n \t{\n \t  cp_error (\"template definition of non-template `%#D'\", decl);\n-\t  return;\n+\t  return decl;\n \t}\n       else\n \ttmpl = DECL_TI_TEMPLATE (decl);\n@@ -1315,7 +1320,7 @@ push_template_decl (decl)\n \t\tperm_tree_cons (tmpl, args, NULL_TREE);\n \n \t      register_specialization (new_tmpl, tmpl, args);\n-\t      return;\n+\t      return decl;\n \t    }\n \t  \n \t  a = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n@@ -1385,6 +1390,8 @@ push_template_decl (decl)\n     cp_error (\"template declaration of `%#D'\", decl);\n   else\n     DECL_TEMPLATE_INFO (decl) = info;\n+\n+  return DECL_TEMPLATE_RESULT (tmpl);\n }\n \n \n@@ -2366,8 +2373,13 @@ lookup_template_class (d1, arglist, in_decl, context)\n     }\n   else\n     {\n-      tree ctx = lookup_template_class (TYPE_CONTEXT (TREE_TYPE (template)),\n-\t\t\t\t\targlist, in_decl, NULL_TREE);\n+      tree type_ctx = TYPE_CONTEXT (TREE_TYPE (template));\n+      tree args = tsubst (CLASSTYPE_TI_ARGS (type_ctx),\n+\t\t\t  arglist,\n+\t\t\t  TREE_VEC_LENGTH (arglist),\n+\t\t\t  in_decl);\n+      tree ctx = lookup_template_class (type_ctx, args,\n+\t\t\t\t\tin_decl, NULL_TREE);\n       id = d1;\n       arglist = CLASSTYPE_TI_ARGS (ctx);\n \n@@ -2496,15 +2508,20 @@ uses_template_parms (t)\n          parameter */\n       return 0;\n       \n+    case CONST_DECL:\n+      if (uses_template_parms (DECL_INITIAL (t)))\n+\treturn 1;\n+      goto check_type_and_context;\n+\n     case FUNCTION_DECL:\n     case VAR_DECL:\n       /* ??? What about FIELD_DECLs?  */\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t)\n \t  && uses_template_parms (DECL_TI_ARGS (t)))\n \treturn 1;\n       /* fall through */\n-    case CONST_DECL:\n     case PARM_DECL:\n+    check_type_and_context:\n       if (uses_template_parms (TREE_TYPE (t)))\n \treturn 1;\n       if (DECL_CONTEXT (t) && uses_template_parms (DECL_CONTEXT (t)))"}, {"sha": "77221130905ec7664c48c610b3c06d5b044eb988", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3ac3d9eaf106c5ad4a50819b0aab0787315e3a1d", "patch": "@@ -1935,7 +1935,12 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t  datum = build_indirect_ref (addr, NULL_PTR);\n \t\t\t  my_friendly_assert (datum != error_mark_node, 310);\n \t\t\t  fndecl = build_vfn_ref (&addr, datum, DECL_VINDEX (fndecl));\n-\t\t\t  TREE_TYPE (fndecl) = build_pointer_type (fntype);\n+\t\t\t  /* The type of fndecl is a function type,\n+\t\t\t     not a pointer-to-function type, since\n+\t\t\t     build_vfn_ref returns not the correct\n+\t\t\t     vtable slot, but the indirection of the\n+\t\t\t     correct vtable slot.  */\n+\t\t\t  TREE_TYPE (fndecl) = fntype;\n \t\t\t}\n \t\t      else\n \t\t\tmark_used (fndecl);"}]}