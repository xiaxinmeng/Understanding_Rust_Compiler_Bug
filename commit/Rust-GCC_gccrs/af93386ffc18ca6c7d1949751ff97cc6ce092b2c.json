{"sha": "af93386ffc18ca6c7d1949751ff97cc6ce092b2c", "node_id": "C_kwDOANBUbNoAKGFmOTMzODZmZmMxOGNhNmM3ZDE5NDk3NTFmZjk3Y2M2Y2UwOTJiMmM", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-12-09T02:37:15Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-12-09T02:37:15Z"}, "message": "[PR103097] tolerate reg-stack cross-block malformed asms\n\nThe testcase shows malformed asms in one block confuse reg-stack logic\nin another block.  Moving the resetting of any_malformed_asm to the\nend of the pass enables it to take effect throughout the affected\nfunction.\n\n\nfor  gcc/ChangeLog\n\n\tPR target/103097\n\t* reg-stack.c (convert_regs_1): Move any_malformed_asm\n\tresetting...\n\t(reg_to_stack): ... here.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR target/103097\n\t* gcc.target/i386/pr103097.c: New.", "tree": {"sha": "a1fd06c35251dd11712a91dbcb4961dfe46af283", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1fd06c35251dd11712a91dbcb4961dfe46af283"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af93386ffc18ca6c7d1949751ff97cc6ce092b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af93386ffc18ca6c7d1949751ff97cc6ce092b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af93386ffc18ca6c7d1949751ff97cc6ce092b2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af93386ffc18ca6c7d1949751ff97cc6ce092b2c/comments", "author": null, "committer": null, "parents": [{"sha": "50e8b0c9bca6cdc57804f860ec5311b641753fbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e8b0c9bca6cdc57804f860ec5311b641753fbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e8b0c9bca6cdc57804f860ec5311b641753fbb"}], "stats": {"total": 35, "additions": 32, "deletions": 3}, "files": [{"sha": "cc369f0b635a07f7be2b480b3f5e00665bc2e567", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af93386ffc18ca6c7d1949751ff97cc6ce092b2c/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af93386ffc18ca6c7d1949751ff97cc6ce092b2c/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=af93386ffc18ca6c7d1949751ff97cc6ce092b2c", "patch": "@@ -453,7 +453,7 @@ get_true_reg (rtx *pat)\n       }\n }\n \f\n-/* Set if we find any malformed asms in a block.  */\n+/* Set if we find any malformed asms in a function.  */\n static bool any_malformed_asm;\n \n /* There are many rules that an asm statement for stack-like regs must\n@@ -3014,8 +3014,6 @@ convert_regs_1 (basic_block block)\n   bool cfg_altered = false;\n   int debug_insns_with_starting_stack = 0;\n \n-  any_malformed_asm = false;\n-\n   /* Choose an initial stack layout, if one hasn't already been chosen.  */\n   if (bi->stack_in.top == -2)\n     {\n@@ -3385,6 +3383,7 @@ reg_to_stack (void)\n \t  0, sizeof (char) * (max_uid + 1));\n \n   convert_regs ();\n+  any_malformed_asm = false;\n \n   free_aux_for_blocks ();\n   return true;"}, {"sha": "2b7a307deec9a5f2212632f1de74b11b6394b361", "filename": "gcc/testsuite/gcc.target/i386/pr103097.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af93386ffc18ca6c7d1949751ff97cc6ce092b2c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103097.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af93386ffc18ca6c7d1949751ff97cc6ce092b2c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103097.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103097.c?ref=af93386ffc18ca6c7d1949751ff97cc6ce092b2c", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fharden-conditional-branches\" } */\n+\n+/* This is a slightly simplified version of\n+   gcc.target/s390/vector/long-double-asm-earlyclobber.c.  On x86, the f\n+   constraints in asm statements imposes some requirements that the testcase\n+   doesn't meet.  What's unusual is that -fharden-conditional-branches extends\n+   the effects of the malformed asm onto a different basic blocks, which\n+   reg-stack did not expect.  */\n+\n+#include <assert.h>\n+#include <stdint.h>\n+\n+void\n+f (void)\n+{\n+  long double res, x = 0;\n+  asm(\"\" : \"=f\"(res) /* { dg-error \"must specify a single register\" } */\n+      : \"0\"(x));\n+  assert (res == x);\n+}  \n+\n+void\n+g (void)\n+{\n+  long double res, x = 0;\n+  asm(\"\" : \"=g\"(res) /* this is ok.  */\n+      : \"0\"(x));\n+  assert (res == x);\n+}  "}]}