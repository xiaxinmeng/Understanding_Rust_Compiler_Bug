{"sha": "2175b50b74dd03df45b4efb792029848c4a76381", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE3NWI1MGI3NGRkMDNkZjQ1YjRlZmI3OTIwMjk4NDhjNGE3NjM4MQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-06-29T00:02:20Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-20T12:31:37Z"}, "message": "[Ada] Present and No functions for type Uint\n\ngcc/ada/\n\n\t* uintp.ads, uintp.adb (Present, No): New functions for\n\tcomparing with No_Uint.\n\t* checks.adb, einfo-utils.adb, exp_aggr.adb, exp_attr.adb,\n\texp_ch3.adb, exp_ch4.adb, exp_dbug.adb, exp_disp.adb,\n\texp_util.adb, repinfo.adb, repinfo-input.adb, scn.adb,\n\tsem_attr.adb, sem_ch13.adb, sem_eval.adb, sem_util.adb,\n\tsinfo-utils.adb, treepr.adb: Use Present (...) instead of \"...\n\t/= No_Uint\", and No (...) instead of \"... = No_Uint\".", "tree": {"sha": "178a93d43acd58d98b39459ca33266ffd0b9dab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/178a93d43acd58d98b39459ca33266ffd0b9dab2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2175b50b74dd03df45b4efb792029848c4a76381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2175b50b74dd03df45b4efb792029848c4a76381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2175b50b74dd03df45b4efb792029848c4a76381", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2175b50b74dd03df45b4efb792029848c4a76381/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9613900aef1cdb5c5c3b867825b6295c0b00f4cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9613900aef1cdb5c5c3b867825b6295c0b00f4cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9613900aef1cdb5c5c3b867825b6295c0b00f4cc"}], "stats": {"total": 248, "additions": 124, "deletions": 124}, "files": [{"sha": "292a620a1ddce2390a0f770c8bae79e294d5fecd", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -9059,7 +9059,7 @@ package body Checks is\n \n       function In_Result_Range return Boolean is\n       begin\n-         if Lo = No_Uint or else Hi = No_Uint then\n+         if No (Lo) or else No (Hi) then\n             return False;\n \n          elsif Is_OK_Static_Subtype (Etype (N)) then\n@@ -9080,7 +9080,7 @@ package body Checks is\n \n       procedure Max (A : in out Uint; B : Uint) is\n       begin\n-         if A = No_Uint or else B > A then\n+         if No (A) or else B > A then\n             A := B;\n          end if;\n       end Max;\n@@ -9091,7 +9091,7 @@ package body Checks is\n \n       procedure Min (A : in out Uint; B : Uint) is\n       begin\n-         if A = No_Uint or else B < A then\n+         if No (A) or else B < A then\n             A := B;\n          end if;\n       end Min;\n@@ -9197,14 +9197,14 @@ package body Checks is\n             Minimize_Eliminate_Overflows\n               (Then_DE, Lo, Hi, Top_Level => False);\n \n-            if Lo = No_Uint then\n+            if No (Lo) then\n                Bignum_Operands := True;\n             end if;\n \n             Minimize_Eliminate_Overflows\n               (Else_DE, Rlo, Rhi, Top_Level => False);\n \n-            if Rlo = No_Uint then\n+            if No (Rlo) then\n                Bignum_Operands := True;\n             else\n                Long_Long_Integer_Operands :=\n@@ -9279,7 +9279,7 @@ package body Checks is\n                   Minimize_Eliminate_Overflows\n                     (Aexp, Lo, Hi, Top_Level => False);\n \n-                  if Lo = No_Uint then\n+                  if No (Lo) then\n                      Bignum_Operands := True;\n                   elsif Etype (Aexp) = LLIB then\n                      Long_Long_Integer_Operands := True;\n@@ -9368,7 +9368,7 @@ package body Checks is\n       --  numbers at compile time for very little gain (the number of cases\n       --  in which we could slip back from bignum mode is small).\n \n-      if Rlo = No_Uint or else (Binary and then Llo = No_Uint) then\n+      if No (Rlo) or else (Binary and then No (Llo)) then\n          Lo := No_Uint;\n          Hi := No_Uint;\n          Bignum_Operands := True;\n@@ -9441,7 +9441,7 @@ package body Checks is\n       --  0 .. 1, but the cases are rare and it is not worth the effort.\n       --  Failing to do this switching back is only an efficiency issue.\n \n-      elsif Lo = No_Uint or else Lo < LLLo or else Hi > LLHi then\n+      elsif No (Lo) or else Lo < LLLo or else Hi > LLHi then\n \n          --  OK, we are definitely outside the range of Long_Long_Integer. The\n          --  question is whether to move to Bignum mode, or stay in the domain\n@@ -11306,7 +11306,7 @@ package body Checks is\n                     renames Alignment_Warnings.Table (J);\n          begin\n             if Known_Alignment (AWR.E)\n-              and then ((AWR.A /= No_Uint\n+              and then ((Present (AWR.A)\n                           and then AWR.A mod Alignment (AWR.E) = 0)\n                         or else (Present (AWR.P)\n                                   and then Has_Compatible_Alignment"}, {"sha": "d805889dd872ae7b6690357832e0cf9c3084b532", "filename": "gcc/ada/einfo-utils.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -384,19 +384,19 @@ package body Einfo.Utils is\n \n    function Known_Component_Bit_Offset            (E : Entity_Id) return B is\n    begin\n-      return Component_Bit_Offset (E) /= No_Uint;\n+      return Present (Component_Bit_Offset (E));\n    end Known_Component_Bit_Offset;\n \n    function Known_Static_Component_Bit_Offset     (E : Entity_Id) return B is\n    begin\n-      return Component_Bit_Offset (E) /= No_Uint\n+      return Present (Component_Bit_Offset (E))\n         and then Component_Bit_Offset (E) >= Uint_0;\n    end Known_Static_Component_Bit_Offset;\n \n    function Known_Component_Size                  (E : Entity_Id) return B is\n    begin\n       return Component_Size (E) /= Uint_0\n-        and then Component_Size (E) /= No_Uint;\n+        and then Present (Component_Size (E));\n    end Known_Component_Size;\n \n    function Known_Static_Component_Size           (E : Entity_Id) return B is\n@@ -407,7 +407,7 @@ package body Einfo.Utils is\n    function Known_Esize                           (E : Entity_Id) return B is\n    begin\n       return Esize (E) /= Uint_0\n-        and then Esize (E) /= No_Uint;\n+        and then Present (Esize (E));\n    end Known_Esize;\n \n    function Known_Static_Esize                    (E : Entity_Id) return B is\n@@ -428,29 +428,29 @@ package body Einfo.Utils is\n \n    function Known_Normalized_First_Bit            (E : Entity_Id) return B is\n    begin\n-      return Normalized_First_Bit (E) /= No_Uint;\n+      return Present (Normalized_First_Bit (E));\n    end Known_Normalized_First_Bit;\n \n    function Known_Static_Normalized_First_Bit     (E : Entity_Id) return B is\n    begin\n-      return Normalized_First_Bit (E) /= No_Uint\n+      return Present (Normalized_First_Bit (E))\n         and then Normalized_First_Bit (E) >= Uint_0;\n    end Known_Static_Normalized_First_Bit;\n \n    function Known_Normalized_Position             (E : Entity_Id) return B is\n    begin\n-      return Normalized_Position (E) /= No_Uint;\n+      return Present (Normalized_Position (E));\n    end Known_Normalized_Position;\n \n    function Known_Static_Normalized_Position      (E : Entity_Id) return B is\n    begin\n-      return Normalized_Position (E) /= No_Uint\n+      return Present (Normalized_Position (E))\n         and then Normalized_Position (E) >= Uint_0;\n    end Known_Static_Normalized_Position;\n \n    function Known_RM_Size                         (E : Entity_Id) return B is\n    begin\n-      return RM_Size (E) /= No_Uint\n+      return Present (RM_Size (E))\n         and then (RM_Size (E) /= Uint_0\n                     or else Is_Discrete_Type (E)\n                     or else Is_Fixed_Point_Type (E));\n@@ -506,7 +506,7 @@ package body Einfo.Utils is\n       pragma Assert\n         (not Known_Esize (Id) or else Esize (Id) = V);\n       pragma Assert\n-        (RM_Size (Id) = No_Uint\n+        (No (RM_Size (Id))\n            or else RM_Size (Id) = Uint_0\n            or else RM_Size (Id) = V);\n       Set_Esize (Id, UI_From_Int (V));"}, {"sha": "88303c9f5055b24fd316b06f6a22f87ef55723cc", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -504,7 +504,7 @@ package body Exp_Aggr is\n       --  Scalar types are OK if their size is a multiple of Storage_Unit\n \n       elsif Is_Scalar_Type (Ctyp) then\n-         pragma Assert (Csiz /= No_Uint);\n+         pragma Assert (Present (Csiz));\n \n          if Csiz mod System_Storage_Unit /= 0 then\n             return False;"}, {"sha": "4af8cf4f32fd8c96aca3786336409bf0fc528d9b", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -8043,7 +8043,7 @@ package body Exp_Attr is\n \n       --  Common processing for record and array component case\n \n-      if Siz /= No_Uint and then Siz /= 0 then\n+      if Present (Siz) and then Siz /= 0 then\n          declare\n             CS : constant Boolean := Comes_From_Source (N);\n "}, {"sha": "15882807f3e442d9a0d05a87f15ad666ee4c82cb", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -8506,15 +8506,15 @@ package body Exp_Ch3 is\n             if Compile_Time_Known_Value (Lo) then\n                Lo_Val := Expr_Value (Lo);\n \n-               if Lo_Bound = No_Uint or else Lo_Bound < Lo_Val then\n+               if No (Lo_Bound) or else Lo_Bound < Lo_Val then\n                   Lo_Bound := Lo_Val;\n                end if;\n             end if;\n \n             if Compile_Time_Known_Value (Hi) then\n                Hi_Val := Expr_Value (Hi);\n \n-               if Hi_Bound = No_Uint or else Hi_Bound > Hi_Val then\n+               if No (Hi_Bound) or else Hi_Bound > Hi_Val then\n                   Hi_Bound := Hi_Val;\n                end if;\n             end if;\n@@ -8643,7 +8643,7 @@ package body Exp_Ch3 is\n          --  If zero is invalid, it is a convenient value to use that is for\n          --  sure an appropriate invalid value in all situations.\n \n-         elsif Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n+         elsif Present (Lo_Bound) and then Lo_Bound > Uint_0 then\n             return Make_Integer_Literal (Loc, 0);\n \n          --  Unsigned types\n@@ -8702,7 +8702,7 @@ package body Exp_Ch3 is\n          --  If zero is invalid, it is a convenient value to use that is for\n          --  sure an appropriate invalid value in all situations.\n \n-         if Lo_Bound /= No_Uint and then Lo_Bound > Uint_0 then\n+         if Present (Lo_Bound) and then Lo_Bound > Uint_0 then\n             Expr := Make_Integer_Literal (Loc, 0);\n \n          --  Cases where all one bits is the appropriate invalid value\n@@ -8741,7 +8741,7 @@ package body Exp_Ch3 is\n \n             --  For this exceptional case, use largest positive value\n \n-            if Lo_Bound /= No_Uint and then Hi_Bound /= No_Uint\n+            if Present (Lo_Bound) and then Present (Hi_Bound)\n               and then Lo_Bound <= (-(2 ** Signed_Size))\n               and then Hi_Bound < 2 ** Signed_Size\n             then\n@@ -8811,7 +8811,7 @@ package body Exp_Ch3 is\n          --  Determine the size of the object. This is either the size provided\n          --  by the caller, or the Esize of the scalar type.\n \n-         if Size = No_Uint or else Size <= Uint_0 then\n+         if No (Size) or else Size <= Uint_0 then\n             Size_To_Use := UI_Max (Uint_1, Esize (Typ));\n          else\n             Size_To_Use := Size;\n@@ -8821,7 +8821,7 @@ package body Exp_Ch3 is\n          --  will create values of type Long_Long_Long_Unsigned and the range\n          --  must fit this type.\n \n-         if Size_To_Use /= No_Uint\n+         if Present (Size_To_Use)\n            and then Size_To_Use > System_Max_Integer_Size\n          then\n             Size_To_Use := UI_From_Int (System_Max_Integer_Size);"}, {"sha": "cf9899d76c800fa6fdb5ff6ddabb4c11f6af9bc8", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -2294,7 +2294,7 @@ package body Exp_Ch4 is\n       --  We can only do this if we in fact have full range information (which\n       --  won't be the case if either operand is bignum at this stage).\n \n-      if Llo /= No_Uint and then Rlo /= No_Uint then\n+      if Present (Llo) and then Present (Rlo) then\n          case N_Op_Compare (Nkind (N)) is\n             when N_Op_Eq =>\n                if Llo = Lhi and then Rlo = Rhi and then Llo = Rlo then"}, {"sha": "a3751691f2820f0c08610c78568647cc24cbe4ec", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -438,7 +438,7 @@ package body Exp_Dbug is\n                     Enable\n                       or else Is_Packed\n                                 (Underlying_Type (Etype (Prefix (Ren))))\n-                      or else (First_Bit /= No_Uint\n+                      or else (Present (First_Bit)\n                                 and then First_Bit /= Uint_0);\n                end;\n "}, {"sha": "bac64928c574bb3f5d032f7a93c3195831c1cb29", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -577,7 +577,7 @@ package body Exp_Disp is\n          --  If number of primitives already set in the tag component, use it\n \n          if Present (Tag_Comp)\n-           and then DT_Entry_Count (Tag_Comp) /= No_Uint\n+           and then Present (DT_Entry_Count (Tag_Comp))\n          then\n             return UI_To_Int (DT_Entry_Count (Tag_Comp));\n \n@@ -8008,14 +8008,14 @@ package body Exp_Disp is\n                          (Find_Dispatching_Type (Interface_Alias (Prim)), Typ,\n                           Use_Full_View => True)\n             then\n-               pragma Assert (DT_Position (Prim) = No_Uint\n-                 and then Present (DTC_Entity (Interface_Alias (Prim))));\n+               pragma Assert (No (DT_Position (Prim)));\n+               pragma Assert (Present (DTC_Entity (Interface_Alias (Prim))));\n \n                E := Interface_Alias (Prim);\n                Set_DT_Position_Value (Prim, DT_Position (E));\n \n                pragma Assert\n-                 (DT_Position (Alias (Prim)) = No_Uint\n+                 (No (DT_Position (Alias (Prim)))\n                     or else DT_Position (Alias (Prim)) = DT_Position (E));\n                Set_DT_Position_Value (Alias (Prim), DT_Position (E));\n                Set_Fixed_Prim (UI_To_Int (DT_Position (Prim)));\n@@ -8066,7 +8066,7 @@ package body Exp_Disp is\n \n             --  Skip primitives previously set entries\n \n-            if DT_Position (Prim) /= No_Uint then\n+            if Present (DT_Position (Prim)) then\n                null;\n \n             --  Primitives covering interface primitives are handled later\n@@ -8099,7 +8099,7 @@ package body Exp_Disp is\n       while Present (Prim_Elmt) loop\n          Prim := Node (Prim_Elmt);\n \n-         if DT_Position (Prim) = No_Uint\n+         if No (DT_Position (Prim))\n            and then Present (Interface_Alias (Prim))\n          then\n             pragma Assert (Present (Alias (Prim))\n@@ -8111,14 +8111,14 @@ package body Exp_Disp is\n                  (Find_Dispatching_Type (Interface_Alias (Prim)), Typ,\n                   Use_Full_View => True)\n             then\n-               pragma Assert (DT_Position (Alias (Prim)) /= No_Uint);\n+               pragma Assert (Present (DT_Position (Alias (Prim))));\n                Set_DT_Position_Value (Prim, DT_Position (Alias (Prim)));\n \n             --  Otherwise it will be placed in the secondary DT\n \n             else\n                pragma Assert\n-                 (DT_Position (Interface_Alias (Prim)) /= No_Uint);\n+                 (Present (DT_Position (Interface_Alias (Prim))));\n                Set_DT_Position_Value (Prim,\n                  DT_Position (Interface_Alias (Prim)));\n             end if;\n@@ -8147,7 +8147,7 @@ package body Exp_Disp is\n          --  At this point all the primitives MUST have a position in the\n          --  dispatch table.\n \n-         if DT_Position (Prim) = No_Uint then\n+         if No (DT_Position (Prim)) then\n             raise Program_Error;\n          end if;\n \n@@ -8767,7 +8767,7 @@ package body Exp_Disp is\n          --  (primary or secondary) dispatch table.\n \n          if Present (DTC_Entity (Prim))\n-           and then DT_Position (Prim) /= No_Uint\n+           and then Present (DT_Position (Prim))\n          then\n             Write_Str (\" at #\");\n             Write_Int (UI_To_Int (DT_Position (Prim)));"}, {"sha": "2802169603a50720469f0e2ad31f5901cb110f98", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -13129,11 +13129,11 @@ package body Exp_Util is\n                                            (Component_Type (Ityp))));\n       end if;\n \n-      if Ialign /= No_Uint and then Ialign > Maximum_Alignment then\n+      if Present (Ialign) and then Ialign > Maximum_Alignment then\n          return True;\n \n-      elsif Ialign /= No_Uint\n-        and then Oalign /= No_Uint\n+      elsif Present (Ialign)\n+        and then Present (Oalign)\n         and then Ialign <= Oalign\n       then\n          return True;"}, {"sha": "7e250a4e2a1f527c00e487102e8d85b8a7254051", "filename": "gcc/ada/repinfo-input.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Frepinfo-input.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Frepinfo-input.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo-input.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -776,7 +776,7 @@ package body Repinfo.Input is\n             --  Compute Component_Bit_Offset from Position and First_Bit,\n             --  either symbolically or literally depending on Position.\n \n-            if Position = No_Uint or else First_Bit = No_Uint then\n+            if No (Position) or else No (First_Bit) then\n                Error (\"bit offset expected\");\n             end if;\n "}, {"sha": "ce42290e5efc6e6fc47c0f4c8494c98032be5f5d", "filename": "gcc/ada/repinfo.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Frepinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Frepinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frepinfo.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -808,7 +808,7 @@ package body Repinfo is\n    --  Start of processing for List_GCC_Expression\n \n    begin\n-      if U = No_Uint then\n+      if No (U) then\n          Write_Unknown_Val;\n       else\n          Print_Expr (U);\n@@ -2117,7 +2117,7 @@ package body Repinfo is\n \n    function Rep_Not_Constant (Val : Node_Ref_Or_Val) return Boolean is\n    begin\n-      if Val = No_Uint or else Val < 0 then\n+      if No (Val) or else Val < 0 then\n          return True;\n       else\n          return False;\n@@ -2316,7 +2316,7 @@ package body Repinfo is\n    --  Start of processing for Rep_Value\n \n    begin\n-      if Val = No_Uint then\n+      if No (Val) then\n          return No_Uint;\n \n       else\n@@ -2402,7 +2402,7 @@ package body Repinfo is\n    procedure Write_Val (Val : Node_Ref_Or_Val; Paren : Boolean := False) is\n    begin\n       if Rep_Not_Constant (Val) then\n-         if List_Representation_Info < 3 or else Val = No_Uint then\n+         if List_Representation_Info < 3 or else No (Val) then\n             Write_Unknown_Val;\n \n          else"}, {"sha": "e81985f0404c2074d33d8d2ab5c9f9cc3fbd46f1", "filename": "gcc/ada/scn.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -159,7 +159,7 @@ package body Scn is\n             --  Int_Literal_Value can be No_Uint in some cases in syntax-only\n             --  mode (see Scng.Scan.Nlit).\n \n-            if Int_Literal_Value /= No_Uint then\n+            if Present (Int_Literal_Value) then\n                Set_Intval (Token_Node, Int_Literal_Value);\n             end if;\n "}, {"sha": "9540089bac8ed3198db5947743b7ccaa90157f32", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -9189,7 +9189,7 @@ package body Sem_Attr is\n                   Fold_Uint (N, Uint_0, Static);\n \n                when LT =>\n-                  if Diff /= No_Uint then\n+                  if Present (Diff) then\n                      Fold_Uint (N, Diff + 1, Static);\n                   end if;\n \n@@ -9710,7 +9710,7 @@ package body Sem_Attr is\n                Fold_Uint (N, Uint_0, Static);\n \n             when LT =>\n-               if Diff /= No_Uint then\n+               if Present (Diff) then\n                   Fold_Uint (N, Diff + 1, Static);\n                end if;\n "}, {"sha": "0ac8bdccda4ff4c2d43577b3e8d2256f2800cfdb", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -6631,7 +6631,7 @@ package body Sem_Ch13 is\n             elsif Duplicate_Clause then\n                null;\n \n-            elsif Align /= No_Uint then\n+            elsif Present (Align) then\n                Set_Has_Alignment_Clause (U_Ent);\n \n                --  Tagged type case, check for attempt to set alignment to a\n@@ -6721,7 +6721,7 @@ package body Sem_Ch13 is\n             elsif Rep_Item_Too_Early (Btype, N) then\n                null;\n \n-            elsif Csize /= No_Uint then\n+            elsif Present (Csize) then\n                Check_Size (Expr, Ctyp, Csize, Biased);\n \n                --  For the biased case, build a declaration for a subtype that\n@@ -7061,7 +7061,7 @@ package body Sem_Ch13 is\n             elsif Duplicate_Clause then\n                null;\n \n-            elsif Radix /= No_Uint then\n+            elsif Present (Radix) then\n                Set_Has_Machine_Radix_Clause (U_Ent);\n                Set_Has_Non_Standard_Rep (Base_Type (U_Ent));\n \n@@ -7274,7 +7274,7 @@ package body Sem_Ch13 is\n                Error_Msg_N\n                  (Attr_Name & \" cannot be given for unconstrained array\", Nam);\n \n-            elsif Size /= No_Uint then\n+            elsif Present (Size) then\n                declare\n                   Etyp : constant Entity_Id :=\n                     (if Is_Type (U_Ent) then U_Ent else Etype (U_Ent));\n@@ -8106,7 +8106,7 @@ package body Sem_Ch13 is\n             --  the list. The final checks for completeness and ordering are\n             --  skipped in this case.\n \n-            if Val = No_Uint then\n+            if No (Val) then\n                Err := True;\n \n             elsif Val < Lo or else Hi < Val then\n@@ -8185,7 +8185,7 @@ package body Sem_Ch13 is\n                         Expr := Expression (Assoc);\n                         Val := Static_Integer (Expr);\n \n-                        if Val = No_Uint then\n+                        if No (Val) then\n                            Err := True;\n \n                         elsif Val < Lo or else Hi < Val then\n@@ -8220,12 +8220,12 @@ package body Sem_Ch13 is\n             else\n                Val := Enumeration_Rep (Elit);\n \n-               if Min = No_Uint then\n+               if No (Min) then\n                   Min := Val;\n                end if;\n \n-               if Val /= No_Uint then\n-                  if Max /= No_Uint and then Val <= Max then\n+               if Present (Val) then\n+                  if Present (Max) and then Val <= Max then\n                      Error_Msg_NE\n                        (\"enumeration value for& not ordered!\",\n                         Enumeration_Rep_Expr (Elit), Elit);\n@@ -8510,9 +8510,9 @@ package body Sem_Ch13 is\n             Fbit  := Static_Integer (First_Bit (CC));\n             Lbit  := Static_Integer (Last_Bit  (CC));\n \n-            if Posit /= No_Uint\n-              and then Fbit /= No_Uint\n-              and then Lbit /= No_Uint\n+            if Present (Posit)\n+              and then Present (Fbit)\n+              and then Present (Lbit)\n             then\n                if Posit < 0 then\n                   Error_Msg_N (\"position cannot be negative\", Position (CC));\n@@ -11943,7 +11943,7 @@ package body Sem_Ch13 is\n                   begin\n                      --  Skip components with unknown offsets\n \n-                     if CBO /= No_Uint and then CBO >= 0 then\n+                     if Present (CBO) and then CBO >= 0 then\n                         Error_Msg_Uint_1 := CBO - Nbit;\n \n                         if Warn and then Error_Msg_Uint_1 > 0 then\n@@ -12058,7 +12058,7 @@ package body Sem_Ch13 is\n             Pcomp := First_Entity (Tagged_Parent);\n             while Present (Pcomp) loop\n                if Ekind (Pcomp) in E_Discriminant | E_Component then\n-                  if Component_Bit_Offset (Pcomp) /= No_Uint\n+                  if Present (Component_Bit_Offset (Pcomp))\n                     and then Known_Static_Esize (Pcomp)\n                   then\n                      Parent_Last_Bit :=\n@@ -13127,7 +13127,7 @@ package body Sem_Ch13 is\n       Align : constant Uint := Static_Integer (Expr);\n \n    begin\n-      if Align = No_Uint then\n+      if No (Align) then\n          return No_Uint;\n \n       elsif Align < 0 then\n@@ -16270,7 +16270,7 @@ package body Sem_Ch13 is\n \n             elsif Nkind (N) = N_Selected_Component then\n                Off := Component_Bit_Offset (Entity (Selector_Name (N)));\n-               if Off /= No_Uint and then Off >= Uint_0 then\n+               if Present (Off) and then Off >= Uint_0 then\n                   Val := Val + Off;\n                   N   := Prefix (N);\n                else\n@@ -16279,7 +16279,7 @@ package body Sem_Ch13 is\n \n             elsif Nkind (N) = N_Indexed_Component then\n                Off := Indexed_Component_Bit_Offset (N);\n-               if Off /= No_Uint then\n+               if Present (Off) then\n                   Val := Val + Off;\n                   N   := Prefix (N);\n                else"}, {"sha": "8817cea3d923ecb29175885251b9f9b7a05e25cd", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -3069,7 +3069,7 @@ package body Sem_Eval is\n             --  Note that in this case, both Right_Int and Left_Int are set\n             --  to No_Uint, so need to test for both.\n \n-            if Right_Int = No_Uint then\n+            if No (Right_Int) then\n                Fold_Uint (N, Uint_0, Stat);\n             else\n                Fold_Uint (N,\n@@ -3083,7 +3083,7 @@ package body Sem_Eval is\n             --  Note that in this case, both Right_Int and Left_Int are set\n             --  to No_Uint, so need to test for both.\n \n-            if Right_Int = No_Uint then\n+            if No (Right_Int) then\n                Fold_Uint (N, Uint_1, Stat);\n             else\n                Fold_Uint (N,"}, {"sha": "6d53007e7904ddfa88ba1eb7a6dafdcb4c25799b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -11901,7 +11901,7 @@ package body Sem_Util is\n \n                Check_Prefix;\n                Offs := Indexed_Component_Bit_Offset (Expr);\n-               if Offs = No_Uint then\n+               if No (Offs) then\n                   Offs := Component_Size (Typ);\n                end if;\n             end;\n@@ -11932,7 +11932,7 @@ package body Sem_Util is\n                else\n                   --  If we have an offset, see if it is compatible\n \n-                  if Offs /= No_Uint and Offs > Uint_0 then\n+                  if Present (Offs) and Offs > Uint_0 then\n                      if Offs mod (System_Storage_Unit * ObjA) /= 0 then\n                         Set_Result (Known_Incompatible);\n                      end if;\n@@ -11961,15 +11961,15 @@ package body Sem_Util is\n \n                   --  If we got an alignment, see if it is acceptable\n \n-                  if ExpA /= No_Uint and then ExpA < ObjA then\n+                  if Present (ExpA) and then ExpA < ObjA then\n                      Set_Result (Known_Incompatible);\n                   end if;\n \n                   --  If Expr is a component or an entire object with a known\n                   --  alignment, then we are fine. Otherwise, if its size is\n                   --  known, it must be big enough for the required alignment.\n \n-                  if Offs /= No_Uint then\n+                  if Present (Offs) then\n                      null;\n \n                   --  See if Expr is an object with known size\n@@ -11990,7 +11990,7 @@ package body Sem_Util is\n                   --  acceptable, since the size is always a multiple of the\n                   --  alignment.\n \n-                  if SizA /= No_Uint then\n+                  if Present (SizA) then\n                      if SizA mod (ObjA * Ttypes.System_Storage_Unit) /= 0 then\n                         Set_Result (Known_Incompatible);\n                      end if;\n@@ -12001,7 +12001,7 @@ package body Sem_Util is\n          --  If we do not know required alignment, any non-zero offset is a\n          --  potential problem (but certainly may be OK, so result is unknown).\n \n-         elsif Offs /= No_Uint then\n+         elsif Present (Offs) then\n             Set_Result (Unknown);\n \n          --  If we can't find the result by direct comparison of alignment\n@@ -15044,7 +15044,7 @@ package body Sem_Util is\n    begin\n       --  Return early if the component size is not known or variable\n \n-      if Off = No_Uint or else Off < Uint_0 then\n+      if No (Off) or else Off < Uint_0 then\n          return No_Uint;\n       end if;\n \n@@ -15567,7 +15567,7 @@ package body Sem_Util is\n          --  Pragma Invalid_Scalars did not specify an invalid value for this\n          --  type. Fall back to the value provided by the binder.\n \n-         if Value = No_Uint then\n+         if No (Value) then\n             return Invalid_Binder_Value;\n          else\n             return Make_Integer_Literal (Loc, Intval => Value);\n@@ -28271,7 +28271,7 @@ package body Sem_Util is\n    begin\n       --  Detect an attempt to set a different value for the same scalar type\n \n-      pragma Assert (Slot = No_Uint);\n+      pragma Assert (No (Slot));\n       Slot := Value;\n    end Set_Invalid_Scalar_Value;\n "}, {"sha": "083c12e8239ba6d4854a2f1a721e12386e9e89cd", "filename": "gcc/ada/sinfo-utils.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fsinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -191,7 +191,7 @@ package body Sinfo.Utils is\n    function End_Location (N : Node_Id) return Source_Ptr is\n       L : constant Uint := End_Span (N);\n    begin\n-      if L = No_Uint then\n+      if No (L) then\n          return No_Location;\n       else\n          return Source_Ptr (Int (Sloc (N)) + UI_To_Int (L));"}, {"sha": "48f76cb3664ff9198dec99c1d9463fae7fc6b8d0", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -614,7 +614,7 @@ package body Treepr is\n       Write_Str (UI_Image (Val));\n       Write_Str (\")  \");\n \n-      if Val /= No_Uint then\n+      if Present (Val) then\n          Write_Location (End_Location (N));\n       end if;\n    end Print_End_Span;"}, {"sha": "51af9b4448081559ba461497c85594fd1e4d3c45", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -73,6 +73,18 @@ package body Uintp is\n    --  These values are used in some cases where the use of numeric literals\n    --  would cause ambiguities (integer vs Uint).\n \n+   type UI_Vector is array (Pos range <>) of Int;\n+   --  Vector containing the integer values of a Uint value\n+\n+   --  Note: An earlier version of this package used pointers of arrays of Ints\n+   --  (dynamically allocated) for the Uint type. The change leads to a few\n+   --  less natural idioms used throughout this code, but eliminates all uses\n+   --  of the heap except for the table package itself. For example, Uint\n+   --  parameters are often converted to UI_Vectors for internal manipulation.\n+   --  This is done by creating the local UI_Vector using the function N_Digits\n+   --  on the Uint to find the size needed for the vector, and then calling\n+   --  Init_Operand to copy the values out of the table into the vector.\n+\n    ----------------------------\n    -- UI_From_Int Hash Table --\n    ----------------------------\n@@ -127,6 +139,22 @@ package body Uintp is\n    --  contain the corresponding one or two digit value. The low bound of Vec\n    --  is always 1.\n \n+   function Vector_To_Uint\n+     (In_Vec   : UI_Vector;\n+      Negative : Boolean) return Uint;\n+   --  Functions that calculate values in UI_Vectors, call this function to\n+   --  create and return the Uint value. In_Vec contains the multiple precision\n+   --  (Base) representation of a non-negative value. Leading zeroes are\n+   --  permitted. Negative is set if the desired result is the negative of the\n+   --  given value. The result will be either the appropriate directly\n+   --  represented value, or a table entry in the proper canonical format is\n+   --  created and returned.\n+   --\n+   --  Note that Init_Operand puts a signed value in the result vector, but\n+   --  Vector_To_Uint is always presented with a non-negative value. The\n+   --  processing of signs is something that is done by the caller before\n+   --  calling Vector_To_Uint.\n+\n    function Least_Sig_Digit (Arg : Uint) return Int;\n    pragma Inline (Least_Sig_Digit);\n    --  Returns the Least Significant Digit of Arg quickly. When the given Uint\n@@ -361,7 +389,7 @@ package body Uintp is\n    --  Start of processing for Image_Out\n \n    begin\n-      if Input = No_Uint then\n+      if No (Input) then\n          Image_Char ('?');\n          return;\n       end if;\n@@ -1404,7 +1432,7 @@ package body Uintp is\n \n       U := UI_Ints.Get (Input);\n \n-      if U /= No_Uint then\n+      if Present (U) then\n          return U;\n       end if;\n \n@@ -2183,9 +2211,7 @@ package body Uintp is\n    -- UI_To_Int --\n    ---------------\n \n-   function UI_To_Int (Input : Uint) return Int is\n-      pragma Assert (Input /= No_Uint);\n-\n+   function UI_To_Int (Input : Valid_Uint) return Int is\n    begin\n       if Direct (Input) then\n          return Direct_Val (Input);\n@@ -2234,9 +2260,7 @@ package body Uintp is\n    -- UI_To_Uns64 --\n    -----------------\n \n-   function UI_To_Unsigned_64 (Input : Uint) return Unsigned_64 is\n-      pragma Assert (Input /= No_Uint);\n-\n+   function UI_To_Unsigned_64 (Input : Valid_Uint) return Unsigned_64 is\n    begin\n       if Input < Uint_0 then\n          raise Constraint_Error;"}, {"sha": "eb7137c6384af044becb52dbb97fb9d07a8fa7f2", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2175b50b74dd03df45b4efb792029848c4a76381/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=2175b50b74dd03df45b4efb792029848c4a76381", "patch": "@@ -90,22 +90,13 @@ package Uintp is\n    Uint_Minus_127 : constant Uint;\n    Uint_Minus_128 : constant Uint;\n \n-   subtype Valid_Uint is Uint with Predicate => Valid_Uint /= No_Uint;\n-   subtype Unat is Valid_Uint with Predicate => Unat >= Uint_0;\n-   subtype Upos is Valid_Uint with Predicate => Upos >= Uint_1;\n-   subtype Nonzero_Uint is Valid_Uint with Predicate => Nonzero_Uint /= Uint_0;\n-\n-   type UI_Vector is array (Pos range <>) of Int;\n-   --  Vector containing the integer values of a Uint value\n+   function No (X : Uint) return Boolean is (X = No_Uint);\n+   function Present (X : Uint) return Boolean is (not No (X));\n \n-   --  Note: An earlier version of this package used pointers of arrays of Ints\n-   --  (dynamically allocated) for the Uint type. The change leads to a few\n-   --  less natural idioms used throughout this code, but eliminates all uses\n-   --  of the heap except for the table package itself. For example, Uint\n-   --  parameters are often converted to UI_Vectors for internal manipulation.\n-   --  This is done by creating the local UI_Vector using the function N_Digits\n-   --  on the Uint to find the size needed for the vector, and then calling\n-   --  Init_Operand to copy the values out of the table into the vector.\n+   subtype Valid_Uint is Uint with Predicate => Present (Valid_Uint);\n+   subtype Unat is Valid_Uint with Predicate => Unat >= Uint_0; -- natural\n+   subtype Upos is Valid_Uint with Predicate => Upos >= Uint_1; -- positive\n+   subtype Nonzero_Uint is Valid_Uint with Predicate => Nonzero_Uint /= Uint_0;\n \n    -----------------\n    -- Subprograms --\n@@ -253,12 +244,12 @@ package Uintp is\n    function UI_From_CC (Input : Char_Code) return Uint;\n    --  Converts Char_Code value to universal integer form\n \n-   function UI_To_Int (Input : Uint) return Int;\n+   function UI_To_Int (Input : Valid_Uint) return Int;\n    --  Converts universal integer value to Int. Constraint_Error if value is\n    --  not in appropriate range.\n \n    type Unsigned_64 is mod 2**64;\n-   function UI_To_Unsigned_64 (Input : Uint) return Unsigned_64;\n+   function UI_To_Unsigned_64 (Input : Valid_Uint) return Unsigned_64;\n    --  Converts universal integer value to Unsigned_64. Constraint_Error if\n    --  value is not in appropriate range.\n \n@@ -271,22 +262,6 @@ package Uintp is\n    --  function is used for capacity checks, and it can be one bit off\n    --  without affecting its usage.\n \n-   function Vector_To_Uint\n-     (In_Vec   : UI_Vector;\n-      Negative : Boolean) return Uint;\n-   --  Functions that calculate values in UI_Vectors, call this function to\n-   --  create and return the Uint value. In_Vec contains the multiple precision\n-   --  (Base) representation of a non-negative value. Leading zeroes are\n-   --  permitted. Negative is set if the desired result is the negative of the\n-   --  given value. The result will be either the appropriate directly\n-   --  represented value, or a table entry in the proper canonical format is\n-   --  created and returned.\n-   --\n-   --  Note that Init_Operand puts a signed value in the result vector, but\n-   --  Vector_To_Uint is always presented with a non-negative value. The\n-   --  processing of signs is something that is done by the caller before\n-   --  calling Vector_To_Uint.\n-\n    ---------------------\n    -- Output Routines --\n    ---------------------\n@@ -537,8 +512,9 @@ private\n    --  Some subprograms defined in this package manipulate the Udigits table\n    --  directly, while for others it is more convenient to work with locally\n    --  defined arrays of the digits of the Universal Integers. The type\n-   --  UI_Vector is defined for this purpose and some internal subprograms\n-   --  used for converting from one to the other are defined.\n+   --  UI_Vector is declared in the package body for this purpose and some\n+   --  internal subprograms used for converting from one to the other are\n+   --  defined.\n \n    type Uint_Entry is record\n       Length : aliased Pos;"}]}