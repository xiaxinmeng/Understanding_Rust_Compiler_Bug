{"sha": "7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FhNmQxOGE3YzUxZmY3YjE5MTQ5ZDFlMDNkYjgzOWI2YjEwMzNkYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-24T09:49:56Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-24T09:49:56Z"}, "message": "sbitmap.h (SBITMAP_ELT_BITS): Use \"1u\" trick as for BITMAP_WORD_BITS.\n\ngcc/\n\t* sbitmap.h (SBITMAP_ELT_BITS): Use \"1u\" trick as for BITMAP_WORD_BITS.\n\tMove test to check that there is a popcount function for the the number\n\tof bits in SBITMAP_ELT_BITS to sbitmap.c.\n\t* sbitmap.c: Test SBITMAP_ELT_BITS, not HOST_BITS_PER_WIDEST_FAST_INT.\n\tMEM_STAT_INFO): Define in terms of their ALONE counterparts.\n\n\t* configure.ac (GATHER_STATISTICS): Always define, non-zero if enabled.\n\t* configure: Regenerate.\n\t* statistics.h (GATHER_STATISTICS): Error out if it is not defined.\n\t(GCC_MEM_STAT_ARGUMENTS): New define.\n\t(ALONE_MEM_STAT_DECL): Define in terms of GCC_MEM_STAT_ARGUMENTS.\n\t(ALONE_FINAL_MEM_STAT_DECL, ALONE_FINAL_PASS_MEM_STAT): New defines.\n\t(MEM_STAT_DECL, FINAL_MEM_STAT_DECL, PASS_MEM_STAT, FINAL_PASS_MEM_STAT,\n\t* ggc-internal.h (ggc_record_overhead): Use FINAL_MEM_STAT_DECL.\n\t* ggc.h (ggc_record_overhead, ggc_free_overhead,\n\tggc_prune_overhead_list): Remove internal prototypes, they are defined\n\talready in ggc-internal.h.\n\t* ggc-common.c (struct loc_descriptor): Remove #ifdef GATHER_STATISTICS\n\twrappers.\n\t(add_statistics): Likewise.\n\t(dump_ggc_loc_statistics): Likewise. Return if GATHER_STATISTICS is 0. \n\t* ggc-zone.c (struct page_entry): Remove #ifdef GATHER_STATISTICS\n\twrappers around \"survived\" and \"stats\" members.\n\t(alloc_large_page): Always initialize survived.\n\t(ggc_internal_alloc_zone_stat): Likewise.\n\tRemove #ifdef GATHER_STATISTICS wrappers.  Record overhead if\n\tGATHER_STATISTICS is non-0.\n\t(ggc_free): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(sweep_pages): Always increase survived.\n\t(ggc_collect_1): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(calculate_average_page_survival): Always define.\n\t(ggc_collect): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(ggc_print_statistics): Likewise.\n\t(ggc_pch_read): Likewise.\n\t* ggc-page.c (struct globals): Always define \"stats\" member.\n\t(ggc_internal_alloc_stat): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(ggc_free): Likewise.\n\t(ggc_collec): Likewise.\n\t(ggc_print_statistics): Likewise.\n\t* bitmap.h (struct bitmap_head_def): Always define \"desc\" member.\n\t(bitmap_initialize_stat): Convert #ifdef GATHER_STATISTICS to if-code.\n\t* gimple.h (enum gimple_alloc_kind): Always define.\n\t(gimple_alloc_kind): Likewise.\n\t* tree-flow.h (phinodes_print_statistics): Always define.\n\t(ssanames_print_statistics): Likewise.\n\t* vec.h (vec_heap_free): Always define.\n\t(VEC_stack_alloc): Define if GATHER_STATISTICS is non-0.\n\t* alloc-pool.c (alloc_pool_descriptor): Always define.\n\t(create_alloc_pool): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(empty_alloc_pool): Likewise.\n\t(pool_alloc): Likewise.\n\t(pool_free): Likewise.\n\t(dump_alloc_pool_statistics): Likewise.\n\t(print_statistics): Always define.\n\t* bitmap.c (struct bitmap_descriptor): Always define.\n\t(bitmap_register): Pass ALONE_FINAL_PASS_MEM_STAT.\n\t(register_overhead): Always define.\n\t(bitmap_element_free): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(bitmap_element_allocate): Likewise.\n\t(bitmap_elt_clear_from): Likewise.\n\t(bitmap_obstack_alloc_stat): Likewise.\n\t(bitmap_gc_alloc_stat): Likewise.\n\t(bitmap_obstack_free): Likewise.\n\t(bitmap_find_bit): Likewise.\n\t(bitmap_ior_and_into):  Likewise.\n\t(bitmap_print): Likewise.\n\t(dump_bitmap_statistics): Likewise. Return if GATHER_STATISTICS is 0.\n\t* gimple.c (gimple_alloc_counts, gimple_alloc_sizes): Always define.\n\t(gimple_alloc_kind_names): Likewise.\n\t(gimple_alloc_stat): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(dump_gimple_statistics): Likewise. Return if GATHER_STATISTICS is 0.\n\t* rtl.c (rtx_alloc_counts, rtx_alloc_sizes, rtvec_alloc_counts,\n\trtvec_alloc_sizes): Always define.\n\t(rvec_alloc): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(rtx_alloc_stat): Likewise.\n\t(dump_rtx_statistics): Likewise. Return if GATHER_STATISTICS is 0.\n\t* tree.c (_obstack_allocated_p, tree_code_counts, tree_node_counts,\n\ttree_node_sizes, tree_node_kind_names): Always define.\n\t(record_node_allocation_statistics): Convert #ifdef GATHER_STATISTICS\n\tto if-code.\n\t(type_hash_canon): Likewise.\n\t(dump_tree_statistics): Likewise.\n\t* tree-ssanames.c (ssa_name_nodes_reused, ssa_name_nodes_created):\n\tAlways define.\n\t(ssanames_print_statistics): Likewise.\n\t(make_ssa_name_fn): Convert #ifdef GATHER_STATISTICS to if-code.\n\t* tree-phinodes.c (phi_nodes_reused, phi_nodes_created): Always define.\n\t(phinodes_print_statistics): Likewise.\n\t(allocate_phi_node): Convert #ifdef GATHER_STATISTICS to if-code.\n\t* vec.c (struct vec_descriptor): Always define.\n\t(hash_descriptor, eq_descriptor, ptr_hash_entry, hash_ptr, eq_ptr,\n\tvec_descriptor, rester_overhead, free_overhead): Likewise.\n\t(cmp_statistic): Likewise.\n\t(vec_heap_free): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(vec_heap_o_reserve_1): Likewise.\n\t(dump_vec_loc_statistics): Likewise.\n\ncp/\n\t* cp/class.c (n_vtables, n_vtable_entries, n_vtable_searches,\n\tn_vtable_elems, n_convert_harshness, n_compute_conversion_costs,\n\tn_inner_fields_searched): Always define.\n\t(build_primary_vtable): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(print_class_statistics): Convert #ifdef GATHER_STATISTICS to if-code.\n\t* cp/tree.c (depth_reached): Always define global.\n\t(cxx_print_statistics): Convert #ifdef GATHER_STATISTICS to if-code.\n\t* cp/pt.c (depth_reached): Always define.\n\t(push_tinst_level): Convert #ifdef GATHER_STATISTICS to if-code.\n\t* cp/search.c (n_fields_searched, n_calls_lookup_field,\n\tn_calls_lookup_field_1, n_calls_lookup_fnfields,\n\tn_calls_lookup_fnfields_1, n_calls_get_base_type,\n\tn_outer_fields_searched, n_contexts_saved): Always define.\n\t(lookup_field_1): Convert #ifdef GATHER_STATISTICS to if-code.\n\t(lookup_member): Likewise.\n\t(lookup_fnfields_idx_nolazy): Likewise.\n\t(print_search_statistics): Likewise.\n\t(reinit_search_statistics): Unconditionally re-set counters.\n\t* cp/lex.c (retrofit_lang_decl): Convert #ifdef GATHER_STATISTICS\n\tto if-code.\n\t(cxx_dup_lang_specific_decl): Likewise.\n\t(copy_lang_type): Likewise.\n\t(cxx_make_type): Likewise.\n\nFrom-SVN: r189803", "tree": {"sha": "7524c306e4effe5958489e003d2bb147a0439144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7524c306e4effe5958489e003d2bb147a0439144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/comments", "author": null, "committer": null, "parents": [{"sha": "38ad2d079800cafd77f35c32a335697f643fa1a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38ad2d079800cafd77f35c32a335697f643fa1a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38ad2d079800cafd77f35c32a335697f643fa1a3"}], "stats": {"total": 1009, "additions": 534, "deletions": 475}, "files": [{"sha": "c74db97fa1da77ccbbaeca4ebef6b4eb0dbbd043", "filename": "gcc/ChangeLog", "status": "modified", "additions": 101, "deletions": 2, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -1,3 +1,102 @@\n+2012-07-24  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* sbitmap.h (SBITMAP_ELT_BITS): Use \"1u\" trick as for BITMAP_WORD_BITS.\n+\tMove test to check that there is a popcount function for the the number\n+\tof bits in SBITMAP_ELT_BITS to sbitmap.c.\n+\t* sbitmap.c: Test SBITMAP_ELT_BITS, not HOST_BITS_PER_WIDEST_FAST_INT.\n+\tMEM_STAT_INFO): Define in terms of their ALONE counterparts.\n+\n+\t* configure.ac (GATHER_STATISTICS): Always define, non-zero if enabled.\n+\t* configure: Regenerate.\n+\t* statistics.h (GATHER_STATISTICS): Error out if it is not defined.\n+\t(GCC_MEM_STAT_ARGUMENTS): New define.\n+\t(ALONE_MEM_STAT_DECL): Define in terms of GCC_MEM_STAT_ARGUMENTS.\n+\t(ALONE_FINAL_MEM_STAT_DECL, ALONE_FINAL_PASS_MEM_STAT): New defines.\n+\t(MEM_STAT_DECL, FINAL_MEM_STAT_DECL, PASS_MEM_STAT, FINAL_PASS_MEM_STAT,\n+\t* ggc-internal.h (ggc_record_overhead): Use FINAL_MEM_STAT_DECL.\n+\t* ggc.h (ggc_record_overhead, ggc_free_overhead,\n+\tggc_prune_overhead_list): Remove internal prototypes, they are defined\n+\talready in ggc-internal.h.\n+\t* ggc-common.c (struct loc_descriptor): Remove #ifdef GATHER_STATISTICS\n+\twrappers.\n+\t(add_statistics): Likewise.\n+\t(dump_ggc_loc_statistics): Likewise. Return if GATHER_STATISTICS is 0. \n+\t* ggc-zone.c (struct page_entry): Remove #ifdef GATHER_STATISTICS\n+\twrappers around \"survived\" and \"stats\" members.\n+\t(alloc_large_page): Always initialize survived.\n+\t(ggc_internal_alloc_zone_stat): Likewise.\n+\tRemove #ifdef GATHER_STATISTICS wrappers.  Record overhead if\n+\tGATHER_STATISTICS is non-0.\n+\t(ggc_free): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(sweep_pages): Always increase survived.\n+\t(ggc_collect_1): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(calculate_average_page_survival): Always define.\n+\t(ggc_collect): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(ggc_print_statistics): Likewise.\n+\t(ggc_pch_read): Likewise.\n+\t* ggc-page.c (struct globals): Always define \"stats\" member.\n+\t(ggc_internal_alloc_stat): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(ggc_free): Likewise.\n+\t(ggc_collec): Likewise.\n+\t(ggc_print_statistics): Likewise.\n+\t* bitmap.h (struct bitmap_head_def): Always define \"desc\" member.\n+\t(bitmap_initialize_stat): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t* gimple.h (enum gimple_alloc_kind): Always define.\n+\t(gimple_alloc_kind): Likewise.\n+\t* tree-flow.h (phinodes_print_statistics): Always define.\n+\t(ssanames_print_statistics): Likewise.\n+\t* vec.h (vec_heap_free): Always define.\n+\t(VEC_stack_alloc): Define if GATHER_STATISTICS is non-0.\n+\t* alloc-pool.c (alloc_pool_descriptor): Always define.\n+\t(create_alloc_pool): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(empty_alloc_pool): Likewise.\n+\t(pool_alloc): Likewise.\n+\t(pool_free): Likewise.\n+\t(dump_alloc_pool_statistics): Likewise.\n+\t(print_statistics): Always define.\n+\t* bitmap.c (struct bitmap_descriptor): Always define.\n+\t(bitmap_register): Pass ALONE_FINAL_PASS_MEM_STAT.\n+\t(register_overhead): Always define.\n+\t(bitmap_element_free): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(bitmap_element_allocate): Likewise.\n+\t(bitmap_elt_clear_from): Likewise.\n+\t(bitmap_obstack_alloc_stat): Likewise.\n+\t(bitmap_gc_alloc_stat): Likewise.\n+\t(bitmap_obstack_free): Likewise.\n+\t(bitmap_find_bit): Likewise.\n+\t(bitmap_ior_and_into):  Likewise.\n+\t(bitmap_print): Likewise.\n+\t(dump_bitmap_statistics): Likewise. Return if GATHER_STATISTICS is 0.\n+\t* gimple.c (gimple_alloc_counts, gimple_alloc_sizes): Always define.\n+\t(gimple_alloc_kind_names): Likewise.\n+\t(gimple_alloc_stat): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(dump_gimple_statistics): Likewise. Return if GATHER_STATISTICS is 0.\n+\t* rtl.c (rtx_alloc_counts, rtx_alloc_sizes, rtvec_alloc_counts,\n+\trtvec_alloc_sizes): Always define.\n+\t(rvec_alloc): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(rtx_alloc_stat): Likewise.\n+\t(dump_rtx_statistics): Likewise. Return if GATHER_STATISTICS is 0.\n+\t* tree.c (_obstack_allocated_p, tree_code_counts, tree_node_counts,\n+\ttree_node_sizes, tree_node_kind_names): Always define.\n+\t(record_node_allocation_statistics): Convert #ifdef GATHER_STATISTICS\n+\tto if-code.\n+\t(type_hash_canon): Likewise.\n+\t(dump_tree_statistics): Likewise.\n+\t* tree-ssanames.c (ssa_name_nodes_reused, ssa_name_nodes_created):\n+\tAlways define.\n+\t(ssanames_print_statistics): Likewise.\n+\t(make_ssa_name_fn): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t* tree-phinodes.c (phi_nodes_reused, phi_nodes_created): Always define.\n+\t(phinodes_print_statistics): Likewise.\n+\t(allocate_phi_node): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t* vec.c (struct vec_descriptor): Always define.\n+\t(hash_descriptor, eq_descriptor, ptr_hash_entry, hash_ptr, eq_ptr,\n+\tvec_descriptor, rester_overhead, free_overhead): Likewise.\n+\t(cmp_statistic): Likewise.\n+\t(vec_heap_free): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(vec_heap_o_reserve_1): Likewise.\n+\t(dump_vec_loc_statistics): Likewise.\n+\n 2012-07-24  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/53616\n@@ -95,7 +194,7 @@\n \t(ix86_decompose_address): Allow (zero_extend:DI (subreg:SI (...)))\n \taddresses.  Prevent zero extensions of CONST_INT operands.\n \n-2012-07-22  Steven Bosscher  <steven@gcc.gnu.org>\n+2012-07-23  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* sbitmap.h (struct int_list): Remove.\n \t(sbitmap_intersect_of_predsucc, sbitmap_union_of_predsucc):\n@@ -127,7 +226,7 @@\n \t* tree-ssa-alias.c (dump_alias_info): Walk over local decls\n \tinstead of referenced vars.\n \n-2012-07-22  Steven Bosscher  <steven@gcc.gnu.org>\n+2012-07-23  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* coverage.c: Refer to \"notes file\" instead of \"graph file\"\n \tin all comments.  Explain history of bbg prefix."}, {"sha": "5a1ada708022944bf4ac53e0d33aea78847e99f9", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -62,8 +62,6 @@ typedef struct allocation_object_def\n static ALLOC_POOL_ID_TYPE last_id;\n #endif\n \n-#ifdef GATHER_STATISTICS\n-\n /* Store information about each particular alloc_pool.  Note that this\n    will underestimate the amount the amount of storage used by a small amount:\n    1) The overhead in a pool is not accounted for.\n@@ -123,7 +121,6 @@ alloc_pool_descriptor (const char *name)\n   (*slot)->name = name;\n   return *slot;\n }\n-#endif\n \n /* Create a pool of things of size SIZE, with NUM in each block we\n    allocate.  */\n@@ -133,9 +130,6 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n {\n   alloc_pool pool;\n   size_t header_size;\n-#ifdef GATHER_STATISTICS\n-  struct alloc_pool_descriptor *desc;\n-#endif\n \n   gcc_checking_assert (name);\n \n@@ -146,10 +140,11 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n   /* Now align the size to a multiple of 4.  */\n   size = align_eight (size);\n \n-#ifdef ENABLE_CHECKING\n-  /* Add the aligned size of ID.  */\n-  size += offsetof (allocation_object, u.data);\n-#endif\n+  if (ENABLE_CHECKING)\n+    {\n+      /* Add the aligned size of ID.  */\n+      size += offsetof (allocation_object, u.data);\n+    }\n \n   /* Um, we can't really allocate 0 elements per block.  */\n   gcc_checking_assert (num);\n@@ -159,14 +154,16 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n \n   /* Now init the various pieces of our pool structure.  */\n   pool->name = /*xstrdup (name)*/name;\n-#ifdef GATHER_STATISTICS\n-  desc = alloc_pool_descriptor (name);\n-  desc->elt_size = size;\n-  desc->created++;\n-#endif\n   pool->elt_size = size;\n   pool->elts_per_block = num;\n \n+  if (GATHER_STATISTICS)\n+    {\n+      struct alloc_pool_descriptor *desc = alloc_pool_descriptor (name);\n+      desc->elt_size = size;\n+      desc->created++;\n+    }\n+\n   /* List header size should be a multiple of 8.  */\n   header_size = align_eight (sizeof (struct alloc_pool_list_def));\n \n@@ -197,9 +194,6 @@ void\n empty_alloc_pool (alloc_pool pool)\n {\n   alloc_pool_list block, next_block;\n-#ifdef GATHER_STATISTICS\n-  struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n-#endif\n \n   gcc_checking_assert (pool);\n \n@@ -210,9 +204,12 @@ empty_alloc_pool (alloc_pool pool)\n       free (block);\n     }\n \n-#ifdef GATHER_STATISTICS\n-  desc->current -= (pool->elts_allocated - pool->elts_free) * pool->elt_size;\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n+      desc->current -= (pool->elts_allocated - pool->elts_free) * pool->elt_size;\n+    }\n+\n   pool->returned_free_list = NULL;\n   pool->virgin_free_list = NULL;\n   pool->virgin_elts_remaining = 0;\n@@ -251,14 +248,16 @@ void *\n pool_alloc (alloc_pool pool)\n {\n   alloc_pool_list header;\n-#ifdef GATHER_STATISTICS\n-  struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n \n-  desc->allocated += pool->elt_size;\n-  desc->current += pool->elt_size;\n-  if (desc->peak < desc->current)\n-    desc->peak = desc->current;\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n+\n+      desc->allocated += pool->elt_size;\n+      desc->current += pool->elt_size;\n+      if (desc->peak < desc->current)\n+\tdesc->peak = desc->current;\n+    }\n \n   gcc_checking_assert (pool);\n \n@@ -324,10 +323,6 @@ void\n pool_free (alloc_pool pool, void *ptr)\n {\n   alloc_pool_list header;\n-#ifdef GATHER_STATISTICS\n-  struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n-#endif\n-\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (ptr\n@@ -340,21 +335,21 @@ pool_free (alloc_pool pool, void *ptr)\n \n   /* Mark the element to be free.  */\n   ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id = 0;\n-#else\n #endif\n \n   header = (alloc_pool_list) ptr;\n   header->next = pool->returned_free_list;\n   pool->returned_free_list = header;\n   pool->elts_free++;\n \n-#ifdef GATHER_STATISTICS\n-  desc->current -= pool->elt_size;\n-#endif\n-\n+  if (GATHER_STATISTICS)\n+    {\n+      struct alloc_pool_descriptor *desc = alloc_pool_descriptor (pool->name);\n+      desc->current -= pool->elt_size;\n+    }\n }\n+\n /* Output per-alloc_pool statistics.  */\n-#ifdef GATHER_STATISTICS\n \n /* Used to accumulate statistics about alloc_pool sizes.  */\n struct output_info\n@@ -382,15 +377,16 @@ print_statistics (void **slot, void *b)\n     }\n   return 1;\n }\n-#endif\n \n /* Output per-alloc_pool memory usage statistics.  */\n void\n dump_alloc_pool_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n   struct output_info info;\n \n+  if (! GATHER_STATISTICS)\n+    return;\n+\n   if (!alloc_pool_hash)\n     return;\n \n@@ -403,5 +399,4 @@ dump_alloc_pool_statistics (void)\n   fprintf (stderr, \"%-22s           %7lu %10lu\\n\",\n \t   \"Total\", info.total_created, info.total_allocated);\n   fprintf (stderr, \"--------------------------------------------------------------------------------------------------------------\\n\");\n-#endif\n }"}, {"sha": "2b779677550ebdaab3953cd60df59a003deb0a00", "filename": "gcc/bitmap.c", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -26,8 +26,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"hashtab.h\"\n \n-#ifdef GATHER_STATISTICS\n-\n /* Store information about each particular bitmap.  */\n struct bitmap_descriptor\n {\n@@ -99,7 +97,7 @@ bitmap_descriptor (const char *file, const char *function, int line)\n void\n bitmap_register (bitmap b MEM_STAT_DECL)\n {\n-  b->desc = bitmap_descriptor (_loc_name, _loc_function, _loc_line);\n+  b->desc = bitmap_descriptor (ALONE_FINAL_PASS_MEM_STAT);\n   b->desc->created++;\n }\n \n@@ -114,7 +112,6 @@ register_overhead (bitmap b, int amount)\n   if (b->desc->peak < b->desc->current)\n     b->desc->peak = b->desc->current;\n }\n-#endif\n \n /* Global data */\n bitmap_element bitmap_zero_bits;  /* An element of all zero bits.  */\n@@ -180,9 +177,10 @@ bitmap_element_free (bitmap head, bitmap_element *elt)\n       else\n \thead->indx = 0;\n     }\n-#ifdef GATHER_STATISTICS\n-  register_overhead (head, -((int)sizeof (bitmap_element)));\n-#endif\n+\n+  if (GATHER_STATISTICS)\n+    register_overhead (head, -((int)sizeof (bitmap_element)));\n+\n   bitmap_elem_to_freelist (head, elt);\n }\n \f\n@@ -230,9 +228,9 @@ bitmap_element_allocate (bitmap head)\n \telement = ggc_alloc_bitmap_element_def ();\n     }\n \n-#ifdef GATHER_STATISTICS\n-  register_overhead (head, sizeof (bitmap_element));\n-#endif\n+  if (GATHER_STATISTICS)\n+    register_overhead (head, sizeof (bitmap_element));\n+\n   memset (element->bits, 0, sizeof (element->bits));\n \n   return element;\n@@ -245,17 +243,16 @@ bitmap_elt_clear_from (bitmap head, bitmap_element *elt)\n {\n   bitmap_element *prev;\n   bitmap_obstack *bit_obstack = head->obstack;\n-#ifdef GATHER_STATISTICS\n-  int n;\n-#endif\n \n   if (!elt) return;\n-#ifdef GATHER_STATISTICS\n-  n = 0;\n-  for (prev = elt; prev; prev = prev->next)\n-    n++;\n-  register_overhead (head, -sizeof (bitmap_element) * n);\n-#endif\n+\n+  if (GATHER_STATISTICS)\n+    {\n+      int n = 0;\n+      for (prev = elt; prev; prev = prev->next)\n+\tn++;\n+      register_overhead (head, -sizeof (bitmap_element) * n);\n+    }\n \n   prev = elt->prev;\n   if (prev)\n@@ -358,9 +355,9 @@ bitmap_obstack_alloc_stat (bitmap_obstack *bit_obstack MEM_STAT_DECL)\n   else\n     map = XOBNEW (&bit_obstack->obstack, bitmap_head);\n   bitmap_initialize_stat (map, bit_obstack PASS_MEM_STAT);\n-#ifdef GATHER_STATISTICS\n-  register_overhead (map, sizeof (bitmap_head));\n-#endif\n+\n+  if (GATHER_STATISTICS)\n+    register_overhead (map, sizeof (bitmap_head));\n \n   return map;\n }\n@@ -374,9 +371,9 @@ bitmap_gc_alloc_stat (ALONE_MEM_STAT_DECL)\n \n   map = ggc_alloc_bitmap_head_def ();\n   bitmap_initialize_stat (map, NULL PASS_MEM_STAT);\n-#ifdef GATHER_STATISTICS\n-  register_overhead (map, sizeof (bitmap_head));\n-#endif\n+\n+  if (GATHER_STATISTICS)\n+    register_overhead (map, sizeof (bitmap_head));\n \n   return map;\n }\n@@ -390,9 +387,10 @@ bitmap_obstack_free (bitmap map)\n     {\n       bitmap_clear (map);\n       map->first = (bitmap_element *) map->obstack->heads;\n-#ifdef GATHER_STATISTICS\n-      register_overhead (map, -((int)sizeof (bitmap_head)));\n-#endif\n+\n+      if (GATHER_STATISTICS)\n+\tregister_overhead (map, -((int)sizeof (bitmap_head)));\n+\n       map->obstack->heads = map;\n     }\n }\n@@ -557,45 +555,42 @@ bitmap_find_bit (bitmap head, unsigned int bit)\n   if (head->current == 0\n       || head->indx == indx)\n     return head->current;\n-#ifdef GATHER_STATISTICS\n-  head->desc->nsearches++;\n-#endif\n+\n+  if (GATHER_STATISTICS)\n+    head->desc->nsearches++;\n \n   if (head->indx < indx)\n     /* INDX is beyond head->indx.  Search from head->current\n        forward.  */\n     for (element = head->current;\n \t element->next != 0 && element->indx < indx;\n \t element = element->next)\n-#ifdef GATHER_STATISTICS\n-      head->desc->search_iter++;\n-#else\n-      ;\n-#endif\n+      {\n+\tif (GATHER_STATISTICS)\n+\t  head->desc->search_iter++;\n+      }\n \n   else if (head->indx / 2 < indx)\n     /* INDX is less than head->indx and closer to head->indx than to\n        0.  Search from head->current backward.  */\n     for (element = head->current;\n \t element->prev != 0 && element->indx > indx;\n \t element = element->prev)\n-#ifdef GATHER_STATISTICS\n-      head->desc->search_iter++;\n-#else\n-      ;\n-#endif\n+      {\n+\tif (GATHER_STATISTICS)\n+\t  head->desc->search_iter++;\n+      }\n \n   else\n     /* INDX is less than head->indx and closer to 0 than to\n        head->indx.  Search from head->first forward.  */\n     for (element = head->first;\n \t element->next != 0 && element->indx < indx;\n \t element = element->next)\n-#ifdef GATHER_STATISTICS\n-      head->desc->search_iter++;\n-#else\n-      ;\n-#endif\n+      if (GATHER_STATISTICS)\n+\t{\n+\t  head->desc->search_iter++;\n+\t}\n \n   /* `element' is the nearest to the one we want.  If it's not the one we\n      want, the one we want doesn't exist.  */\n@@ -2032,6 +2027,24 @@ bitmap_ior_and_into (bitmap a, const_bitmap b, const_bitmap c)\n     a->indx = a->current->indx;\n   return changed;\n }\n+\n+/* Compute hash of bitmap (for purposes of hashing).  */\n+hashval_t\n+bitmap_hash (const_bitmap head)\n+{\n+  const bitmap_element *ptr;\n+  BITMAP_WORD hash = 0;\n+  int ix;\n+\n+  for (ptr = head->first; ptr; ptr = ptr->next)\n+    {\n+      hash ^= ptr->indx;\n+      for (ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n+\thash ^= ptr->bits[ix];\n+    }\n+  return (hashval_t)hash;\n+}\n+\n \f\n /* Debugging function to print out the contents of a bitmap.  */\n \n@@ -2099,7 +2112,6 @@ bitmap_print (FILE *file, const_bitmap head, const char *prefix, const char *suf\n     }\n   fputs (suffix, file);\n }\n-#ifdef GATHER_STATISTICS\n \n \n /* Used to accumulate statistics about bitmap sizes.  */\n@@ -2135,14 +2147,16 @@ print_statistics (void **slot, void *b)\n     }\n   return 1;\n }\n-#endif\n+\n /* Output per-bitmap memory usage statistics.  */\n void\n dump_bitmap_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n   struct output_info info;\n \n+  if (! GATHER_STATISTICS)\n+    return;\n+\n   if (!bitmap_desc_hash)\n     return;\n \n@@ -2157,24 +2171,6 @@ dump_bitmap_statistics (void)\n   fprintf (stderr, \"%-40s %9d %15\"HOST_WIDEST_INT_PRINT\"d\\n\",\n \t   \"Total\", info.count, info.size);\n   fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n-#endif\n-}\n-\n-/* Compute hash of bitmap (for purposes of hashing).  */\n-hashval_t\n-bitmap_hash (const_bitmap head)\n-{\n-  const bitmap_element *ptr;\n-  BITMAP_WORD hash = 0;\n-  int ix;\n-\n-  for (ptr = head->first; ptr; ptr = ptr->next)\n-    {\n-      hash ^= ptr->indx;\n-      for (ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n-\thash ^= ptr->bits[ix];\n-    }\n-  return (hashval_t)hash;\n }\n \n #include \"gt-bitmap.h\""}, {"sha": "b6edc2440305c16bbe8fb6f59fef24caab775605", "filename": "gcc/bitmap.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -78,9 +78,7 @@ typedef struct GTY(()) bitmap_head_def {\n   unsigned int indx;\t\t/* Index of last element looked at.  */\n   bitmap_obstack *obstack;\t/* Obstack to allocate elements from.\n \t\t\t\t   If NULL, then use GGC allocation.  */\n-#ifdef GATHER_STATISTICS\n   struct bitmap_descriptor GTY((skip)) *desc;\n-#endif\n } bitmap_head;\n \n /* Global data */\n@@ -166,9 +164,8 @@ bitmap_initialize_stat (bitmap head, bitmap_obstack *obstack MEM_STAT_DECL)\n {\n   head->first = head->current = NULL;\n   head->obstack = obstack;\n-#ifdef GATHER_STATISTICS\n-  bitmap_register (head PASS_MEM_STAT);\n-#endif\n+  if (GATHER_STATISTICS)\n+    bitmap_register (head PASS_MEM_STAT);\n }\n #define bitmap_initialize(h,o) bitmap_initialize_stat (h,o MEM_STAT_INFO)\n "}, {"sha": "a457d3eb3acbc04406472ca99a1b8d5a98f97f23", "filename": "gcc/configure", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -6986,11 +6986,12 @@ else\n   enable_gather_detailed_mem_stats=no\n fi\n \n-if test x$enable_gather_detailed_mem_stats = xyes ; then\n+gather_stats=`if test $enable_gather_detailed_mem_stats != no; then echo 1; else echo 0; fi`\n \n-$as_echo \"#define GATHER_STATISTICS 1\" >>confdefs.h\n+cat >>confdefs.h <<_ACEOF\n+#define GATHER_STATISTICS $gather_stats\n+_ACEOF\n \n-fi\n \n # -------------------------------\n # Miscenalleous configure options"}, {"sha": "e4069e8d042d6090b074efb25f232a3d4ee5b626", "filename": "gcc/configure.ac", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -588,10 +588,9 @@ AC_ARG_ENABLE(gather-detailed-mem-stats,\n [AS_HELP_STRING([--enable-gather-detailed-mem-stats],\n \t\t[enable detailed memory allocation stats gathering])], [],\n [enable_gather_detailed_mem_stats=no])\n-if test x$enable_gather_detailed_mem_stats = xyes ; then\n-  AC_DEFINE(GATHER_STATISTICS, 1,\n-        [Define to enable detailed memory allocation stats gathering.])\n-fi\n+gather_stats=`if test $enable_gather_detailed_mem_stats != no; then echo 1; else echo 0; fi`\n+AC_DEFINE_UNQUOTED(GATHER_STATISTICS, $gather_stats,\n+[Define to enable detailed memory allocation stats gathering.])\n \n # -------------------------------\n # Miscenalleous configure options"}, {"sha": "90064b29775156d43570ab7ce0157d75c6ea4c7c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -1,3 +1,29 @@\n+2012-07-24  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cp/class.c (n_vtables, n_vtable_entries, n_vtable_searches,\n+\tn_vtable_elems, n_convert_harshness, n_compute_conversion_costs,\n+\tn_inner_fields_searched): Always define.\n+\t(build_primary_vtable): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(print_class_statistics): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t* cp/tree.c (depth_reached): Always define global.\n+\t(cxx_print_statistics): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t* cp/pt.c (depth_reached): Always define.\n+\t(push_tinst_level): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t* cp/search.c (n_fields_searched, n_calls_lookup_field,\n+\tn_calls_lookup_field_1, n_calls_lookup_fnfields,\n+\tn_calls_lookup_fnfields_1, n_calls_get_base_type,\n+\tn_outer_fields_searched, n_contexts_saved): Always define.\n+\t(lookup_field_1): Convert #ifdef GATHER_STATISTICS to if-code.\n+\t(lookup_member): Likewise.\n+\t(lookup_fnfields_idx_nolazy): Likewise.\n+\t(print_search_statistics): Likewise.\n+\t(reinit_search_statistics): Unconditionally re-set counters.\n+\t* cp/lex.c (retrofit_lang_decl): Convert #ifdef GATHER_STATISTICS\n+\tto if-code.\n+\t(cxx_dup_lang_specific_decl): Likewise.\n+\t(copy_lang_type): Likewise.\n+\t(cxx_make_type): Likewise.\n+\n 2012-07-20  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/54038"}, {"sha": "7ccbccbc0bd0848fe5884f41375cd772a6b8701f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -212,15 +212,13 @@ static tree get_vcall_index (tree, tree);\n \n /* Variables shared between class.c and call.c.  */\n \n-#ifdef GATHER_STATISTICS\n int n_vtables = 0;\n int n_vtable_entries = 0;\n int n_vtable_searches = 0;\n int n_vtable_elems = 0;\n int n_convert_harshness = 0;\n int n_compute_conversion_costs = 0;\n int n_inner_fields_searched = 0;\n-#endif\n \n /* Convert to or from a base subobject.  EXPR is an expression of type\n    `A' or `A*', an expression of type `B' or `B*' is returned.  To\n@@ -836,10 +834,11 @@ build_primary_vtable (tree binfo, tree type)\n       virtuals = NULL_TREE;\n     }\n \n-#ifdef GATHER_STATISTICS\n-  n_vtables += 1;\n-  n_vtable_elems += list_length (virtuals);\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      n_vtables += 1;\n+      n_vtable_elems += list_length (virtuals);\n+    }\n \n   /* Initialize the association list for this type, based\n      on our first approximation.  */\n@@ -7332,7 +7331,9 @@ get_vfield_name (tree type)\n void\n print_class_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n+  if (! GATHER_STATISTICS)\n+    return;\n+\n   fprintf (stderr, \"convert_harshness = %d\\n\", n_convert_harshness);\n   fprintf (stderr, \"compute_conversion_costs = %d\\n\", n_compute_conversion_costs);\n   if (n_vtables)\n@@ -7342,7 +7343,6 @@ print_class_statistics (void)\n       fprintf (stderr, \"vtable entries = %d; vtable elems = %d\\n\",\n \t       n_vtable_entries, n_vtable_elems);\n     }\n-#endif\n }\n \n /* Build a dummy reference to ourselves so Derived::Base (and A::A) works,"}, {"sha": "54021f1e3512fd985655e48df7fd9e9469e8f89a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -571,10 +571,11 @@ retrofit_lang_decl (tree t)\n   else\n     gcc_unreachable ();\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int)lang_decl] += 1;\n-  tree_node_sizes[(int)lang_decl] += size;\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      tree_node_counts[(int)lang_decl] += 1;\n+      tree_node_sizes[(int)lang_decl] += size;\n+    }\n }\n \n void\n@@ -601,10 +602,11 @@ cxx_dup_lang_specific_decl (tree node)\n   memcpy (ld, DECL_LANG_SPECIFIC (node), size);\n   DECL_LANG_SPECIFIC (node) = ld;\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int)lang_decl] += 1;\n-  tree_node_sizes[(int)lang_decl] += size;\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      tree_node_counts[(int)lang_decl] += 1;\n+      tree_node_sizes[(int)lang_decl] += size;\n+    }\n }\n \n /* Copy DECL, including any language-specific parts.  */\n@@ -638,10 +640,11 @@ copy_lang_type (tree node)\n   memcpy (lt, TYPE_LANG_SPECIFIC (node), size);\n   TYPE_LANG_SPECIFIC (node) = lt;\n \n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int)lang_type] += 1;\n-  tree_node_sizes[(int)lang_type] += size;\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      tree_node_counts[(int)lang_type] += 1;\n+      tree_node_sizes[(int)lang_type] += size;\n+    }\n }\n \n /* Copy TYPE, including any language-specific parts.  */\n@@ -671,10 +674,11 @@ cxx_make_type (enum tree_code code)\n       TYPE_LANG_SPECIFIC (t) = pi;\n       pi->u.c.h.is_lang_type_class = 1;\n \n-#ifdef GATHER_STATISTICS\n-      tree_node_counts[(int)lang_type] += 1;\n-      tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n-#endif\n+      if (GATHER_STATISTICS)\n+\t{\n+\t  tree_node_counts[(int)lang_type] += 1;\n+\t  tree_node_sizes[(int)lang_type] += sizeof (struct lang_type);\n+\t}\n     }\n \n   /* Set up some flags that give proper default behavior.  */"}, {"sha": "1e70213a636653b1312ff9e6913e56b31be58486", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -7754,9 +7754,8 @@ limit_bad_template_recursion (tree decl)\n \n static int tinst_depth;\n extern int max_tinst_depth;\n-#ifdef GATHER_STATISTICS\n int depth_reached;\n-#endif\n+\n static GTY(()) struct tinst_level *last_error_tinst_level;\n \n /* We're starting to instantiate D; record the template instantiation context\n@@ -7799,10 +7798,8 @@ push_tinst_level (tree d)\n   current_tinst_level = new_level;\n \n   ++tinst_depth;\n-#ifdef GATHER_STATISTICS\n-  if (tinst_depth > depth_reached)\n+  if (GATHER_STATISTICS && (tinst_depth > depth_reached))\n     depth_reached = tinst_depth;\n-#endif\n \n   return 1;\n }"}, {"sha": "dc802e4e9a21aedf2a40b3df70a7a7f0bb0dd479", "filename": "gcc/cp/search.c", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -66,14 +66,12 @@ static tree dfs_get_pure_virtuals (tree, void *);\n \n \f\n /* Variables for gathering statistics.  */\n-#ifdef GATHER_STATISTICS\n static int n_fields_searched;\n static int n_calls_lookup_field, n_calls_lookup_field_1;\n static int n_calls_lookup_fnfields, n_calls_lookup_fnfields_1;\n static int n_calls_get_base_type;\n static int n_outer_fields_searched;\n static int n_contexts_saved;\n-#endif /* GATHER_STATISTICS */\n \n \f\n /* Data for lookup_base and its workers.  */\n@@ -407,9 +405,8 @@ lookup_field_1 (tree type, tree name, bool want_type)\n \t{\n \t  i = (lo + hi) / 2;\n \n-#ifdef GATHER_STATISTICS\n-\t  n_fields_searched++;\n-#endif /* GATHER_STATISTICS */\n+\t  if (GATHER_STATISTICS)\n+\t    n_fields_searched++;\n \n \t  if (DECL_NAME (fields[i]) > name)\n \t    hi = i;\n@@ -454,16 +451,16 @@ lookup_field_1 (tree type, tree name, bool want_type)\n \n   field = TYPE_FIELDS (type);\n \n-#ifdef GATHER_STATISTICS\n-  n_calls_lookup_field_1++;\n-#endif /* GATHER_STATISTICS */\n+  if (GATHER_STATISTICS)\n+    n_calls_lookup_field_1++;\n+\n   for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n       tree decl = field;\n \n-#ifdef GATHER_STATISTICS\n-      n_fields_searched++;\n-#endif /* GATHER_STATISTICS */\n+      if (GATHER_STATISTICS)\n+\tn_fields_searched++;\n+\n       gcc_assert (DECL_P (field));\n       if (DECL_NAME (field) == NULL_TREE\n \t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n@@ -1203,9 +1200,8 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n   if (!basetype_path)\n     return NULL_TREE;\n \n-#ifdef GATHER_STATISTICS\n-  n_calls_lookup_field++;\n-#endif /* GATHER_STATISTICS */\n+  if (GATHER_STATISTICS)\n+    n_calls_lookup_field++;\n \n   memset (&lfi, 0, sizeof (lfi));\n   lfi.type = type;\n@@ -1370,9 +1366,8 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n   if (!method_vec)\n     return -1;\n \n-#ifdef GATHER_STATISTICS\n-  n_calls_lookup_fnfields_1++;\n-#endif /* GATHER_STATISTICS */\n+  if (GATHER_STATISTICS)\n+    n_calls_lookup_fnfields_1++;\n \n   /* Constructors are first...  */\n   if (name == ctor_identifier)\n@@ -1408,9 +1403,8 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n \t{\n \t  i = (lo + hi) / 2;\n \n-#ifdef GATHER_STATISTICS\n-\t  n_outer_fields_searched++;\n-#endif /* GATHER_STATISTICS */\n+\t  if (GATHER_STATISTICS)\n+\t    n_outer_fields_searched++;\n \n \t  tmp = VEC_index (tree, method_vec, i);\n \t  tmp = DECL_NAME (OVL_CURRENT (tmp));\n@@ -1425,9 +1419,8 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n   else\n     for (; VEC_iterate (tree, method_vec, i, fn); ++i)\n       {\n-#ifdef GATHER_STATISTICS\n-\tn_outer_fields_searched++;\n-#endif /* GATHER_STATISTICS */\n+\tif (GATHER_STATISTICS)\n+\t  n_outer_fields_searched++;\n \tif (DECL_NAME (OVL_CURRENT (fn)) == name)\n \t  return i;\n       }\n@@ -2207,28 +2200,28 @@ note_debug_info_needed (tree type)\n void\n print_search_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n+  if (! GATHER_STATISTICS)\n+    {\n+      fprintf (stderr, \"no search statistics\\n\");\n+      return;\n+    }\n+\n   fprintf (stderr, \"%d fields searched in %d[%d] calls to lookup_field[_1]\\n\",\n \t   n_fields_searched, n_calls_lookup_field, n_calls_lookup_field_1);\n   fprintf (stderr, \"%d fnfields searched in %d calls to lookup_fnfields\\n\",\n \t   n_outer_fields_searched, n_calls_lookup_fnfields);\n   fprintf (stderr, \"%d calls to get_base_type\\n\", n_calls_get_base_type);\n-#else /* GATHER_STATISTICS */\n-  fprintf (stderr, \"no search statistics\\n\");\n-#endif /* GATHER_STATISTICS */\n }\n \n void\n reinit_search_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n   n_fields_searched = 0;\n   n_calls_lookup_field = 0, n_calls_lookup_field_1 = 0;\n   n_calls_lookup_fnfields = 0, n_calls_lookup_fnfields_1 = 0;\n   n_calls_get_base_type = 0;\n   n_outer_fields_searched = 0;\n   n_contexts_saved = 0;\n-#endif /* GATHER_STATISTICS */\n }\n \n /* Helper for lookup_conversions_r.  TO_TYPE is the type converted to"}, {"sha": "26e7fced793454cceaebc3cc7e6bd2fa3fcf729e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -2044,20 +2044,17 @@ no_linkage_check (tree t, bool relaxed_p)\n     }\n }\n \n-#ifdef GATHER_STATISTICS\n extern int depth_reached;\n-#endif\n \n void\n cxx_print_statistics (void)\n {\n   print_search_statistics ();\n   print_class_statistics ();\n   print_template_statistics ();\n-#ifdef GATHER_STATISTICS\n-  fprintf (stderr, \"maximum template instantiation depth reached: %d\\n\",\n-\t   depth_reached);\n-#endif\n+  if (GATHER_STATISTICS)\n+    fprintf (stderr, \"maximum template instantiation depth reached: %d\\n\",\n+\t     depth_reached);\n }\n \n /* Return, as an INTEGER_CST node, the number of elements for TYPE"}, {"sha": "6a997238629e6ceb94a36dab51d8e194e222ccd5", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -845,8 +845,6 @@ init_ggc_heuristics (void)\n #endif\n }\n \n-#ifdef GATHER_STATISTICS\n-\n /* Datastructure used to store per-call-site statistics.  */\n struct loc_descriptor\n {\n@@ -1040,16 +1038,18 @@ add_statistics (void **slot, void *b)\n }\n \n /* Dump per-site memory statistics.  */\n-#endif\n+\n void\n-dump_ggc_loc_statistics (bool final ATTRIBUTE_UNUSED)\n+dump_ggc_loc_statistics (bool final)\n {\n-#ifdef GATHER_STATISTICS\n   int nentries = 0;\n   char s[4096];\n   size_t collected = 0, freed = 0, allocated = 0, overhead = 0, times = 0;\n   int i;\n \n+  if (! GATHER_STATISTICS)\n+    return;\n+\n   ggc_force_collect = true;\n   ggc_collect ();\n \n@@ -1102,5 +1102,4 @@ dump_ggc_loc_statistics (bool final ATTRIBUTE_UNUSED)\n \t   \"source location\", \"Garbage\", \"Freed\", \"Leak\", \"Overhead\", \"Times\");\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n   ggc_force_collect = false;\n-#endif\n }"}, {"sha": "dcb048777e5dda2e0d4d8ece4670cfec4c526f1d", "filename": "gcc/ggc-internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-internal.h?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -94,7 +94,7 @@ extern void ggc_pch_read (FILE *, void *);\n /* When set, ggc_collect will do collection.  */\n extern bool ggc_force_collect;\n \n-extern void ggc_record_overhead (size_t, size_t, void * MEM_STAT_DECL);\n+extern void ggc_record_overhead (size_t, size_t, void * FINAL_MEM_STAT_DECL);\n \n extern void ggc_free_overhead (void *);\n "}, {"sha": "d3d186d8d7f4b1eb5dd3a1bbeb5c752c2ad8723f", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 64, "deletions": 69, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -432,7 +432,6 @@ static struct globals\n   struct free_object *free_object_list;\n #endif\n \n-#ifdef GATHER_STATISTICS\n   struct\n   {\n     /* Total GC-allocated memory.  */\n@@ -459,7 +458,6 @@ static struct globals\n     /* The overhead for each of the allocation orders.  */\n     unsigned long long total_overhead_per_order[NUM_ORDERS];\n   } stats;\n-#endif\n } G;\n \n /* The size in bytes required to maintain a bitmap for the objects\n@@ -1324,10 +1322,9 @@ ggc_internal_alloc_stat (size_t size MEM_STAT_DECL)\n \n   /* Calculate the object's address.  */\n   result = entry->page + object_offset;\n-#ifdef GATHER_STATISTICS\n-  ggc_record_overhead (OBJECT_SIZE (order), OBJECT_SIZE (order) - size,\n-\t\t       result PASS_MEM_STAT);\n-#endif\n+  if (GATHER_STATISTICS)\n+    ggc_record_overhead (OBJECT_SIZE (order), OBJECT_SIZE (order) - size,\n+\t\t\t result FINAL_PASS_MEM_STAT);\n \n #ifdef ENABLE_GC_CHECKING\n   /* Keep poisoning-by-writing-0xaf the object, in an attempt to keep the\n@@ -1358,32 +1355,31 @@ ggc_internal_alloc_stat (size_t size MEM_STAT_DECL)\n   /* For timevar statistics.  */\n   timevar_ggc_mem_total += object_size;\n \n-#ifdef GATHER_STATISTICS\n-  {\n-    size_t overhead = object_size - size;\n+  if (GATHER_STATISTICS)\n+    {\n+      size_t overhead = object_size - size;\n \n-    G.stats.total_overhead += overhead;\n-    G.stats.total_allocated += object_size;\n-    G.stats.total_overhead_per_order[order] += overhead;\n-    G.stats.total_allocated_per_order[order] += object_size;\n+      G.stats.total_overhead += overhead;\n+      G.stats.total_allocated += object_size;\n+      G.stats.total_overhead_per_order[order] += overhead;\n+      G.stats.total_allocated_per_order[order] += object_size;\n \n-    if (size <= 32)\n-      {\n-\tG.stats.total_overhead_under32 += overhead;\n-\tG.stats.total_allocated_under32 += object_size;\n-      }\n-    if (size <= 64)\n-      {\n-\tG.stats.total_overhead_under64 += overhead;\n-\tG.stats.total_allocated_under64 += object_size;\n-      }\n-    if (size <= 128)\n-      {\n-\tG.stats.total_overhead_under128 += overhead;\n-\tG.stats.total_allocated_under128 += object_size;\n-      }\n-  }\n-#endif\n+      if (size <= 32)\n+\t{\n+\t  G.stats.total_overhead_under32 += overhead;\n+\t  G.stats.total_allocated_under32 += object_size;\n+\t}\n+      if (size <= 64)\n+\t{\n+\t  G.stats.total_overhead_under64 += overhead;\n+\t  G.stats.total_allocated_under64 += object_size;\n+\t}\n+      if (size <= 128)\n+\t{\n+\t  G.stats.total_overhead_under128 += overhead;\n+\t  G.stats.total_allocated_under128 += object_size;\n+\t}\n+    }\n \n   if (GGC_DEBUG_LEVEL >= 3)\n     fprintf (G.debug_file,\n@@ -1524,9 +1520,8 @@ ggc_free (void *p)\n   size_t order = pe->order;\n   size_t size = OBJECT_SIZE (order);\n \n-#ifdef GATHER_STATISTICS\n-  ggc_free_overhead (p);\n-#endif\n+  if (GATHER_STATISTICS)\n+    ggc_free_overhead (p);\n \n   if (GGC_DEBUG_LEVEL >= 3)\n     fprintf (G.debug_file,\n@@ -2070,9 +2065,10 @@ ggc_collect (void)\n \n   clear_marks ();\n   ggc_mark_roots ();\n-#ifdef GATHER_STATISTICS\n-  ggc_prune_overhead_list ();\n-#endif\n+\n+  if (GATHER_STATISTICS)\n+    ggc_prune_overhead_list ();\n+\n   poison_pages ();\n   validate_free_objects ();\n   sweep_pages ();\n@@ -2160,40 +2156,39 @@ ggc_print_statistics (void)\n \t   SCALE (G.allocated), STAT_LABEL(G.allocated),\n \t   SCALE (total_overhead), STAT_LABEL (total_overhead));\n \n-#ifdef GATHER_STATISTICS\n-  {\n-    fprintf (stderr, \"\\nTotal allocations and overheads during the compilation process\\n\");\n-\n-    fprintf (stderr, \"Total Overhead:                        %10lld\\n\",\n-             G.stats.total_overhead);\n-    fprintf (stderr, \"Total Allocated:                       %10lld\\n\",\n-             G.stats.total_allocated);\n-\n-    fprintf (stderr, \"Total Overhead  under  32B:            %10lld\\n\",\n-             G.stats.total_overhead_under32);\n-    fprintf (stderr, \"Total Allocated under  32B:            %10lld\\n\",\n-             G.stats.total_allocated_under32);\n-    fprintf (stderr, \"Total Overhead  under  64B:            %10lld\\n\",\n-             G.stats.total_overhead_under64);\n-    fprintf (stderr, \"Total Allocated under  64B:            %10lld\\n\",\n-             G.stats.total_allocated_under64);\n-    fprintf (stderr, \"Total Overhead  under 128B:            %10lld\\n\",\n-             G.stats.total_overhead_under128);\n-    fprintf (stderr, \"Total Allocated under 128B:            %10lld\\n\",\n-             G.stats.total_allocated_under128);\n-\n-    for (i = 0; i < NUM_ORDERS; i++)\n-      if (G.stats.total_allocated_per_order[i])\n-        {\n-          fprintf (stderr, \"Total Overhead  page size %7lu:     %10lld\\n\",\n-                   (unsigned long) OBJECT_SIZE (i),\n-\t\t   G.stats.total_overhead_per_order[i]);\n-          fprintf (stderr, \"Total Allocated page size %7lu:     %10lld\\n\",\n-                   (unsigned long) OBJECT_SIZE (i),\n-\t\t   G.stats.total_allocated_per_order[i]);\n-        }\n+  if (GATHER_STATISTICS)\n+    {\n+      fprintf (stderr, \"\\nTotal allocations and overheads during the compilation process\\n\");\n+\n+      fprintf (stderr, \"Total Overhead:                        %10lld\\n\",\n+\t       G.stats.total_overhead);\n+      fprintf (stderr, \"Total Allocated:                       %10lld\\n\",\n+\t       G.stats.total_allocated);\n+\n+      fprintf (stderr, \"Total Overhead  under  32B:            %10lld\\n\",\n+\t       G.stats.total_overhead_under32);\n+      fprintf (stderr, \"Total Allocated under  32B:            %10lld\\n\",\n+\t       G.stats.total_allocated_under32);\n+      fprintf (stderr, \"Total Overhead  under  64B:            %10lld\\n\",\n+\t       G.stats.total_overhead_under64);\n+      fprintf (stderr, \"Total Allocated under  64B:            %10lld\\n\",\n+\t       G.stats.total_allocated_under64);\n+      fprintf (stderr, \"Total Overhead  under 128B:            %10lld\\n\",\n+\t       G.stats.total_overhead_under128);\n+      fprintf (stderr, \"Total Allocated under 128B:            %10lld\\n\",\n+\t       G.stats.total_allocated_under128);\n+\n+      for (i = 0; i < NUM_ORDERS; i++)\n+\tif (G.stats.total_allocated_per_order[i])\n+\t  {\n+\t    fprintf (stderr, \"Total Overhead  page size %7lu:     %10lld\\n\",\n+\t\t     (unsigned long) OBJECT_SIZE (i),\n+\t\t     G.stats.total_overhead_per_order[i]);\n+\t    fprintf (stderr, \"Total Allocated page size %7lu:     %10lld\\n\",\n+\t\t     (unsigned long) OBJECT_SIZE (i),\n+\t\t     G.stats.total_allocated_per_order[i]);\n+\t  }\n   }\n-#endif\n }\n \f\n struct ggc_pch_ondisk"}, {"sha": "baf807649ab5470c369ae29ed057001c8f7c665b", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 55, "deletions": 73, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -216,10 +216,8 @@ typedef struct page_entry\n   /* The zone that this page entry belongs to.  */\n   struct alloc_zone *zone;\n \n-#ifdef GATHER_STATISTICS\n   /* How many collections we've survived.  */\n   size_t survived;\n-#endif\n \n   /* Does this page contain small objects, or one large object?  */\n   bool large_p;\n@@ -403,7 +401,6 @@ struct alloc_zone\n   /* True if this zone should be destroyed after the next collection.  */\n   bool dead;\n \n-#ifdef GATHER_STATISTICS\n   struct\n   {\n     /* Total GC-allocated memory.  */\n@@ -424,7 +421,6 @@ struct alloc_zone\n     unsigned long long total_allocated_under128;\n     unsigned long long total_overhead_under128;\n   } stats;\n-#endif\n } main_zone;\n \n /* Some default zones.  */\n@@ -931,9 +927,7 @@ alloc_large_page (size_t size, struct alloc_zone *zone)\n   entry->common.large_p = true;\n   entry->common.pch_p = false;\n   entry->common.zone = zone;\n-#ifdef GATHER_STATISTICS\n   entry->common.survived = 0;\n-#endif\n   entry->mark_p = false;\n   entry->bytes = size;\n   entry->prev = NULL;\n@@ -1250,9 +1244,7 @@ ggc_internal_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n     {\n       struct large_page_entry *entry = alloc_large_page (size, zone);\n \n-#ifdef GATHER_STATISTICS\n       entry->common.survived = 0;\n-#endif\n \n       entry->next = zone->large_pages;\n       if (zone->large_pages)\n@@ -1315,8 +1307,8 @@ ggc_internal_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n \n   timevar_ggc_mem_total += size;\n \n-#ifdef GATHER_STATISTICS\n-  ggc_record_overhead (orig_size, size - orig_size, result PASS_MEM_STAT);\n+  if (GATHER_STATISTICS)\n+    ggc_record_overhead (orig_size, size - orig_size, result FINAL_PASS_MEM_STAT);\n \n   {\n     size_t object_size = size;\n@@ -1413,9 +1405,8 @@ ggc_free (void *p)\n {\n   struct page_entry *page;\n \n-#ifdef GATHER_STATISTICS\n-  ggc_free_overhead (p);\n-#endif\n+  if (GATHER_STATISTICS)\n+    ggc_free_overhead (p);\n \n   poison_region (p, ggc_get_size (p));\n \n@@ -1753,10 +1744,8 @@ sweep_pages (struct alloc_zone *zone)\n \n       lnext = lp->next;\n \n-#ifdef GATHER_STATISTICS\n       /* This page has now survived another collection.  */\n       lp->common.survived++;\n-#endif\n \n       if (lp->mark_p)\n \t{\n@@ -1791,10 +1780,8 @@ sweep_pages (struct alloc_zone *zone)\n \n       snext = sp->next;\n \n-#ifdef GATHER_STATISTICS\n       /* This page has now survived another collection.  */\n       sp->common.survived++;\n-#endif\n \n       /* Step through all chunks, consolidate those that are free and\n \t insert them into the free lists.  Note that consolidation\n@@ -1948,9 +1935,8 @@ ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n     {\n       zone_allocate_marks ();\n       ggc_mark_roots ();\n-#ifdef GATHER_STATISTICS\n-      ggc_prune_overhead_list ();\n-#endif\n+      if (GATHER_STATISTICS)\n+\tggc_prune_overhead_list ();\n     }\n \n   sweep_pages (zone);\n@@ -1962,7 +1948,6 @@ ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n   return true;\n }\n \n-#ifdef GATHER_STATISTICS\n /* Calculate the average page survival rate in terms of number of\n    collections.  */\n \n@@ -1985,7 +1970,6 @@ calculate_average_page_survival (struct alloc_zone *zone)\n     }\n   return survival/count;\n }\n-#endif\n \n /* Top level collection routine.  */\n \n@@ -2047,9 +2031,8 @@ ggc_collect (void)\n \t}\n     }\n \n-#ifdef GATHER_STATISTICS\n   /* Print page survival stats, if someone wants them.  */\n-  if (GGC_DEBUG_LEVEL >= 2)\n+  if (GATHER_STATISTICS && GGC_DEBUG_LEVEL >= 2)\n     {\n       for (zone = G.zones; zone; zone = zone->next_zone)\n \t{\n@@ -2061,7 +2044,6 @@ ggc_collect (void)\n \t    }\n \t}\n     }\n-#endif\n \n   if (marked)\n     zone_free_marks ();\n@@ -2210,54 +2192,53 @@ ggc_print_statistics (void)\n \t   SCALE (total_allocated), LABEL(total_allocated),\n \t   SCALE (total_overhead), LABEL (total_overhead));\n \n-#ifdef GATHER_STATISTICS\n-  {\n-    unsigned long long all_overhead = 0, all_allocated = 0;\n-    unsigned long long all_overhead_under32 = 0, all_allocated_under32 = 0;\n-    unsigned long long all_overhead_under64 = 0, all_allocated_under64 = 0;\n-    unsigned long long all_overhead_under128 = 0, all_allocated_under128 = 0;\n+  if (GATHER_STATISTICS)\n+    {\n+      unsigned long long all_overhead = 0, all_allocated = 0;\n+      unsigned long long all_overhead_under32 = 0, all_allocated_under32 = 0;\n+      unsigned long long all_overhead_under64 = 0, all_allocated_under64 = 0;\n+      unsigned long long all_overhead_under128 = 0, all_allocated_under128 = 0;\n \n-    fprintf (stderr, \"\\nTotal allocations and overheads during the compilation process\\n\");\n+      fprintf (stderr, \"\\nTotal allocations and overheads during the compilation process\\n\");\n \n-    for (zone = G.zones; zone; zone = zone->next_zone)\n-      {\n-\tall_overhead += zone->stats.total_overhead;\n-\tall_allocated += zone->stats.total_allocated;\n+      for (zone = G.zones; zone; zone = zone->next_zone)\n+\t{\n+\t  all_overhead += zone->stats.total_overhead;\n+\t  all_allocated += zone->stats.total_allocated;\n \n-\tall_allocated_under32 += zone->stats.total_allocated_under32;\n-\tall_overhead_under32 += zone->stats.total_overhead_under32;\n+\t  all_allocated_under32 += zone->stats.total_allocated_under32;\n+\t  all_overhead_under32 += zone->stats.total_overhead_under32;\n \n-\tall_allocated_under64 += zone->stats.total_allocated_under64;\n-\tall_overhead_under64 += zone->stats.total_overhead_under64;\n+\t  all_allocated_under64 += zone->stats.total_allocated_under64;\n+\t  all_overhead_under64 += zone->stats.total_overhead_under64;\n \n-\tall_allocated_under128 += zone->stats.total_allocated_under128;\n-\tall_overhead_under128 += zone->stats.total_overhead_under128;\n+\t  all_allocated_under128 += zone->stats.total_allocated_under128;\n+\t  all_overhead_under128 += zone->stats.total_overhead_under128;\n \n-\tfprintf (stderr, \"%20s:                  %10lld\\n\",\n-\t\t zone->name, zone->stats.total_allocated);\n-      }\n+\t  fprintf (stderr, \"%20s:                  %10lld\\n\",\n+\t\t   zone->name, zone->stats.total_allocated);\n+\t}\n \n-    fprintf (stderr, \"\\n\");\n-\n-    fprintf (stderr, \"Total Overhead:                        %10lld\\n\",\n-             all_overhead);\n-    fprintf (stderr, \"Total Allocated:                       %10lld\\n\",\n-             all_allocated);\n-\n-    fprintf (stderr, \"Total Overhead  under  32B:            %10lld\\n\",\n-             all_overhead_under32);\n-    fprintf (stderr, \"Total Allocated under  32B:            %10lld\\n\",\n-             all_allocated_under32);\n-    fprintf (stderr, \"Total Overhead  under  64B:            %10lld\\n\",\n-             all_overhead_under64);\n-    fprintf (stderr, \"Total Allocated under  64B:            %10lld\\n\",\n-             all_allocated_under64);\n-    fprintf (stderr, \"Total Overhead  under 128B:            %10lld\\n\",\n-             all_overhead_under128);\n-    fprintf (stderr, \"Total Allocated under 128B:            %10lld\\n\",\n-             all_allocated_under128);\n-  }\n-#endif\n+      fprintf (stderr, \"\\n\");\n+\n+      fprintf (stderr, \"Total Overhead:                        %10lld\\n\",\n+\t       all_overhead);\n+      fprintf (stderr, \"Total Allocated:                       %10lld\\n\",\n+\t       all_allocated);\n+\n+      fprintf (stderr, \"Total Overhead  under  32B:            %10lld\\n\",\n+\t       all_overhead_under32);\n+      fprintf (stderr, \"Total Allocated under  32B:            %10lld\\n\",\n+\t       all_allocated_under32);\n+      fprintf (stderr, \"Total Overhead  under  64B:            %10lld\\n\",\n+\t       all_overhead_under64);\n+      fprintf (stderr, \"Total Allocated under  64B:            %10lld\\n\",\n+\t       all_allocated_under64);\n+      fprintf (stderr, \"Total Overhead  under 128B:            %10lld\\n\",\n+\t       all_overhead_under128);\n+      fprintf (stderr, \"Total Allocated under 128B:            %10lld\\n\",\n+\t       all_allocated_under128);\n+    }\n }\n \n /* Precompiled header support.  */\n@@ -2472,13 +2453,14 @@ ggc_pch_read (FILE *f, void *addr)\n   pch_zone.page = (char *) addr;\n   pch_zone.end = (char *) pch_zone.alloc_bits;\n \n-  /* We've just read in a PCH file.  So, every object that used to be\n-     allocated is now free.  */\n-#ifdef GATHER_STATISTICS\n-  zone_allocate_marks ();\n-  ggc_prune_overhead_list ();\n-  zone_free_marks ();\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      /* We've just read in a PCH file.  So, every object that used to be\n+\t allocated is now free.  */\n+      zone_allocate_marks ();\n+      ggc_prune_overhead_list ();\n+      zone_free_marks ();\n+    }\n \n   for (zone = G.zones; zone; zone = zone->next_zone)\n     {"}, {"sha": "59a996bc828311daf637434d4a371320f23a0529", "filename": "gcc/ggc.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -166,10 +166,6 @@ extern void *ggc_realloc_stat (void *, size_t MEM_STAT_DECL);\n /* Free a block.  To be used when known for certain it's not reachable.  */\n extern void ggc_free (void *);\n \n-extern void ggc_record_overhead (size_t, size_t, void * MEM_STAT_DECL);\n-extern void ggc_free_overhead (void *);\n-extern void ggc_prune_overhead_list (void);\n-\n extern void dump_ggc_loc_statistics (bool);\n \n /* Reallocators.  */"}, {"sha": "7686f8105cd5025cc00e2d702977e66bb6185f1c", "filename": "gcc/gimple.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -79,7 +79,6 @@ EXPORTED_CONST enum gimple_statement_structure_enum gss_for_code_[] = {\n };\n #undef DEFGSCODE\n \n-#ifdef GATHER_STATISTICS\n /* Gimple stats.  */\n \n int gimple_alloc_counts[(int) gimple_alloc_kind_all];\n@@ -93,8 +92,6 @@ static const char * const gimple_alloc_kind_names[] = {\n     \"everything else\"\n };\n \n-#endif /* GATHER_STATISTICS */\n-\n /* Private API manipulation functions shared only with some\n    other files.  */\n extern void gimple_set_stored_syms (gimple, bitmap, bitmap_obstack *);\n@@ -134,13 +131,12 @@ gimple_alloc_stat (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n   if (num_ops > 0)\n     size += sizeof (tree) * (num_ops - 1);\n \n-#ifdef GATHER_STATISTICS\n-  {\n-    enum gimple_alloc_kind kind = gimple_alloc_kind (code);\n-    gimple_alloc_counts[(int) kind]++;\n-    gimple_alloc_sizes[(int) kind] += size;\n-  }\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      enum gimple_alloc_kind kind = gimple_alloc_kind (code);\n+      gimple_alloc_counts[(int) kind]++;\n+      gimple_alloc_sizes[(int) kind] += size;\n+    }\n \n   stmt = ggc_alloc_cleared_gimple_statement_d_stat (size PASS_MEM_STAT);\n   gimple_set_code (stmt, code);\n@@ -645,9 +641,8 @@ gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n   p->gimple_asm.nl = nlabels;\n   p->gimple_asm.string = ggc_alloc_string (string, size);\n \n-#ifdef GATHER_STATISTICS\n-  gimple_alloc_sizes[(int) gimple_alloc_kind (GIMPLE_ASM)] += size;\n-#endif\n+  if (GATHER_STATISTICS)\n+    gimple_alloc_sizes[(int) gimple_alloc_kind (GIMPLE_ASM)] += size;\n \n   return p;\n }\n@@ -2503,9 +2498,14 @@ gimple_assign_rhs_could_trap_p (gimple s)\n void\n dump_gimple_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n   int i, total_tuples = 0, total_bytes = 0;\n \n+  if (! GATHER_STATISTICS)\n+    {\n+      fprintf (stderr, \"No gimple statistics\\n\");\n+      return;\n+    }\n+\n   fprintf (stderr, \"\\nGIMPLE statements\\n\");\n   fprintf (stderr, \"Kind                   Stmts      Bytes\\n\");\n   fprintf (stderr, \"---------------------------------------\\n\");\n@@ -2519,9 +2519,6 @@ dump_gimple_statistics (void)\n   fprintf (stderr, \"---------------------------------------\\n\");\n   fprintf (stderr, \"%-20s %7d %10d\\n\", \"Total\", total_tuples, total_bytes);\n   fprintf (stderr, \"---------------------------------------\\n\");\n-#else\n-  fprintf (stderr, \"No gimple statistics\\n\");\n-#endif\n }\n \n "}, {"sha": "5180e8e5445e29fe54ee43812ff0296781947720", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -5270,7 +5270,6 @@ tree walk_gimple_stmt (gimple_stmt_iterator *, walk_stmt_fn, walk_tree_fn,\n \t\t       struct walk_stmt_info *);\n tree walk_gimple_op (gimple, walk_tree_fn, struct walk_stmt_info *);\n \n-#ifdef GATHER_STATISTICS\n /* Enum and arrays used for allocation stats.  Keep in sync with\n    gimple.c:gimple_alloc_kind_names.  */\n enum gimple_alloc_kind\n@@ -5301,7 +5300,6 @@ gimple_alloc_kind (enum gimple_code code)\n \treturn gimple_alloc_kind_rest;\n     }\n }\n-#endif /* GATHER_STATISTICS */\n \n extern void dump_gimple_statistics (void);\n "}, {"sha": "0f59991702a0c85deabf8b91c8ca96741611b912", "filename": "gcc/rtl.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -135,12 +135,10 @@ const char * const reg_note_name[REG_NOTE_MAX] =\n #undef DEF_REG_NOTE\n };\n \n-#ifdef GATHER_STATISTICS\n static int rtx_alloc_counts[(int) LAST_AND_UNUSED_RTX_CODE];\n static int rtx_alloc_sizes[(int) LAST_AND_UNUSED_RTX_CODE];\n static int rtvec_alloc_counts;\n static int rtvec_alloc_sizes;\n-#endif\n \n \f\n /* Allocate an rtx vector of N elements.\n@@ -157,10 +155,11 @@ rtvec_alloc (int n)\n \n   PUT_NUM_ELEM (rt, n);\n \n-#ifdef GATHER_STATISTICS\n-  rtvec_alloc_counts++;\n-  rtvec_alloc_sizes += n * sizeof (rtx);\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      rtvec_alloc_counts++;\n+      rtvec_alloc_sizes += n * sizeof (rtx);\n+    }\n \n   return rt;\n }\n@@ -205,10 +204,11 @@ rtx_alloc_stat (RTX_CODE code MEM_STAT_DECL)\n   memset (rt, 0, RTX_HDR_SIZE);\n   PUT_CODE (rt, code);\n \n-#ifdef GATHER_STATISTICS\n-  rtx_alloc_counts[code]++;\n-  rtx_alloc_sizes[code] += RTX_CODE_SIZE (code);\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      rtx_alloc_counts[code]++;\n+      rtx_alloc_sizes[code] += RTX_CODE_SIZE (code);\n+    }\n \n   return rt;\n }\n@@ -706,10 +706,16 @@ iterative_hash_rtx (const_rtx x, hashval_t hash)\n void\n dump_rtx_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n   int i;\n   int total_counts = 0;\n   int total_sizes = 0;\n+\n+  if (! GATHER_STATISTICS)\n+    {\n+      fprintf (stderr, \"No RTX statistics\\n\");\n+      return;\n+    }\n+\n   fprintf (stderr, \"\\nRTX Kind               Count      Bytes\\n\");\n   fprintf (stderr, \"---------------------------------------\\n\");\n   for (i = 0; i < LAST_AND_UNUSED_RTX_CODE; i++)\n@@ -731,7 +737,6 @@ dump_rtx_statistics (void)\n   fprintf (stderr, \"%-20s %7d %10d\\n\",\n            \"Total\", total_counts, total_sizes);\n   fprintf (stderr, \"---------------------------------------\\n\");\n-#endif\n }\n \f\n #if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007)"}, {"sha": "a67f1028e012441673fea14f62b1b6efb7a729e8", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -23,10 +23,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"sbitmap.h\"\n \n+/* This suffices for roughly 99% of the hosts we run on, and the rest\n+   don't have 256 bit integers.  */\n+#if SBITMAP_ELT_BITS > 255\n+#error Need to increase size of datatype used for popcount\n+#endif\n+\n #if GCC_VERSION >= 3400\n-#  if HOST_BITS_PER_WIDEST_FAST_INT == HOST_BITS_PER_LONG\n+#  if SBITMAP_ELT_BITS == HOST_BITS_PER_LONG\n #    define do_popcount(x) __builtin_popcountl(x)\n-#  elif HOST_BITS_PER_WIDEST_FAST_INT == HOST_BITS_PER_LONGLONG\n+#  elif SBITMAP_ELT_BITS == HOST_BITS_PER_LONGLONG\n #    define do_popcount(x) __builtin_popcountll(x)\n #  else\n #    error \"internal error: sbitmap.h and hwint.h are inconsistent\""}, {"sha": "231dfd4195c7973e706ac7245e8b85e6d2c5a0dd", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -25,17 +25,9 @@ along with GCC; see the file COPYING3.  If not see\n    It should be straightforward to convert so for now we keep things simple\n    while more important issues are dealt with.  */\n \n-#define SBITMAP_ELT_BITS ((unsigned) HOST_BITS_PER_WIDEST_FAST_INT)\n+#define SBITMAP_ELT_BITS (HOST_BITS_PER_WIDEST_FAST_INT * 1u)\n #define SBITMAP_ELT_TYPE unsigned HOST_WIDEST_FAST_INT\n \n-/* Can't use SBITMAP_ELT_BITS in this macro because it contains a\n-   cast.  There is no perfect macro in GCC to test against.  This\n-   suffices for roughly 99% of the hosts we run on, and the rest\n-   don't have 256 bit integers.  */\n-#if HOST_BITS_PER_WIDEST_FAST_INT > 255\n-#error Need to increase size of datatype used for popcount\n-#endif\n-\n struct simple_bitmap_def\n {\n   unsigned char *popcount;      /* Population count.  */"}, {"sha": "60fd68a36d129ea35eeda8769c527edf869ca937", "filename": "gcc/statistics.h", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fstatistics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fstatistics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.h?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -22,20 +22,33 @@\n #ifndef GCC_STATISTICS\n #define GCC_STATISTICS\n \n-#ifdef GATHER_STATISTICS\n-#define MEM_STAT_DECL , const char * ARG_UNUSED (_loc_name), int ARG_UNUSED (_loc_line), const char * ARG_UNUSED (_loc_function)\n-#define ALONE_MEM_STAT_DECL const char * ARG_UNUSED (_loc_name), int ARG_UNUSED (_loc_line), const char * ARG_UNUSED (_loc_function)\n-#define PASS_MEM_STAT , _loc_name, _loc_line,  _loc_function\n+#if ! defined GATHER_STATISTICS\n+#error GATHER_STATISTICS must be defined\n+#endif\n+\n+#define GCC_MEM_STAT_ARGUMENTS const char * ARG_UNUSED (_loc_name), int ARG_UNUSED (_loc_line), const char * ARG_UNUSED (_loc_function)\n+#if GATHER_STATISTICS\n+#define ALONE_MEM_STAT_DECL GCC_MEM_STAT_ARGUMENTS\n+#define ALONE_FINAL_MEM_STAT_DECL ALONE_MEM_STAT_INFO\n #define ALONE_PASS_MEM_STAT _loc_name, _loc_line,  _loc_function\n-#define MEM_STAT_INFO , __FILE__, __LINE__, __FUNCTION__\n+#define ALONE_FINAL_PASS_MEM_STAT ALONE_PASS_MEM_STAT\n #define ALONE_MEM_STAT_INFO __FILE__, __LINE__, __FUNCTION__\n+#define MEM_STAT_DECL , ALONE_MEM_STAT_DECL\n+#define FINAL_MEM_STAT_DECL , ALONE_FINAL_MEM_STAT_DECL\n+#define PASS_MEM_STAT , ALONE_PASS_MEM_STAT\n+#define FINAL_PASS_MEM_STAT , ALONE_FINAL_PASS_MEM_STAT\n+#define MEM_STAT_INFO , ALONE_MEM_STAT_INFO\n #else\n-#define MEM_STAT_DECL\n #define ALONE_MEM_STAT_DECL void\n-#define PASS_MEM_STAT\n+#define ALONE_FINAL_MEM_STAT_DECL GCC_MEM_STAT_ARGUMENTS\n #define ALONE_PASS_MEM_STAT\n-#define MEM_STAT_INFO\n+#define ALONE_FINAL_PASS_MEM_STAT 0,0,0\n #define ALONE_MEM_STAT_INFO\n+#define MEM_STAT_DECL\n+#define FINAL_MEM_STAT_DECL , ALONE_FINAL_MEM_STAT_DECL\n+#define PASS_MEM_STAT\n+#define FINAL_PASS_MEM_STAT , ALONE_FINAL_PASS_MEM_STAT\n+#define MEM_STAT_INFO ALONE_MEM_STAT_INFO\n #endif\n \n struct function;"}, {"sha": "4dc7ec9614626990573f184589bd2edbe54cde39", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -511,9 +511,7 @@ extern void remove_phi_args (edge);\n extern void remove_phi_node (gimple_stmt_iterator *, bool);\n extern void remove_phi_nodes (basic_block);\n extern void release_phi_node (gimple);\n-#ifdef GATHER_STATISTICS\n extern void phinodes_print_statistics (void);\n-#endif\n \n /* In gimple-low.c  */\n extern void record_vars_into (tree, tree);\n@@ -599,9 +597,7 @@ extern void set_ptr_info_alignment (struct ptr_info_def *, unsigned int,\n extern void adjust_ptr_info_misalignment (struct ptr_info_def *,\n \t\t\t\t\t  unsigned int);\n \n-#ifdef GATHER_STATISTICS\n extern void ssanames_print_statistics (void);\n-#endif\n \n /* In tree-ssa-ccp.c  */\n tree fold_const_aggregate_ref (tree);"}, {"sha": "d488941f36d1151a124e7557edd7f2af3b489865", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -77,21 +77,17 @@ static unsigned long free_phinode_count;\n \n static int ideal_phi_node_len (int);\n \n-#ifdef GATHER_STATISTICS\n unsigned int phi_nodes_reused;\n unsigned int phi_nodes_created;\n-#endif\n \n /* Dump some simple statistics regarding the re-use of PHI nodes.  */\n \n-#ifdef GATHER_STATISTICS\n void\n phinodes_print_statistics (void)\n {\n   fprintf (stderr, \"PHI nodes allocated: %u\\n\", phi_nodes_created);\n   fprintf (stderr, \"PHI nodes reused: %u\\n\", phi_nodes_reused);\n }\n-#endif\n \n /* Allocate a PHI node with at least LEN arguments.  If the free list\n    happens to contain a PHI node with LEN arguments or more, return\n@@ -119,21 +115,19 @@ allocate_phi_node (size_t len)\n       phi = VEC_pop (gimple, free_phinodes[bucket]);\n       if (VEC_empty (gimple, free_phinodes[bucket]))\n \tVEC_free (gimple, gc, free_phinodes[bucket]);\n-#ifdef GATHER_STATISTICS\n-      phi_nodes_reused++;\n-#endif\n+      if (GATHER_STATISTICS)\n+\tphi_nodes_reused++;\n     }\n   else\n     {\n       phi = ggc_alloc_gimple_statement_d (size);\n-#ifdef GATHER_STATISTICS\n-      phi_nodes_created++;\n+      if (GATHER_STATISTICS)\n \t{\n \t  enum gimple_alloc_kind kind = gimple_alloc_kind (GIMPLE_PHI);\n-          gimple_alloc_counts[(int) kind]++;\n-          gimple_alloc_sizes[(int) kind] += size;\n+\t  phi_nodes_created++;\n+\t  gimple_alloc_counts[(int) kind]++;\n+\t  gimple_alloc_sizes[(int) kind] += size;\n \t}\n-#endif\n     }\n \n   return phi;"}, {"sha": "35e8751316d0fb92120394287abba62ea096d24c", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -61,10 +61,8 @@ along with GCC; see the file COPYING3.  If not see\n    numbers after the special ones.  */\n #define UNUSED_NAME_VERSION 0\n \n-#ifdef GATHER_STATISTICS\n unsigned int ssa_name_nodes_reused;\n unsigned int ssa_name_nodes_created;\n-#endif\n \n /* Initialize management of SSA_NAMEs to default SIZE.  If SIZE is\n    zero use default.  */\n@@ -101,14 +99,12 @@ fini_ssanames (void)\n \n /* Dump some simple statistics regarding the re-use of SSA_NAME nodes.  */\n \n-#ifdef GATHER_STATISTICS\n void\n ssanames_print_statistics (void)\n {\n   fprintf (stderr, \"SSA_NAME nodes allocated: %u\\n\", ssa_name_nodes_created);\n   fprintf (stderr, \"SSA_NAME nodes reused: %u\\n\", ssa_name_nodes_reused);\n }\n-#endif\n \n /* Return an SSA_NAME node for variable VAR defined in statement STMT\n    in function FN.  STMT may be an empty statement for artificial\n@@ -127,9 +123,8 @@ make_ssa_name_fn (struct function *fn, tree var, gimple stmt)\n   if (!VEC_empty (tree, FREE_SSANAMES (fn)))\n     {\n       t = VEC_pop (tree, FREE_SSANAMES (fn));\n-#ifdef GATHER_STATISTICS\n-      ssa_name_nodes_reused++;\n-#endif\n+      if (GATHER_STATISTICS)\n+\tssa_name_nodes_reused++;\n \n       /* The node was cleared out when we put it on the free list, so\n \t there is no need to do so again here.  */\n@@ -141,9 +136,8 @@ make_ssa_name_fn (struct function *fn, tree var, gimple stmt)\n       t = make_node (SSA_NAME);\n       SSA_NAME_VERSION (t) = VEC_length (tree, SSANAMES (fn));\n       VEC_safe_push (tree, gc, SSANAMES (fn), t);\n-#ifdef GATHER_STATISTICS\n-      ssa_name_nodes_created++;\n-#endif\n+      if (GATHER_STATISTICS)\n+\tssa_name_nodes_created++;\n     }\n \n   TREE_TYPE (t) = TREE_TYPE (var);"}, {"sha": "4fea005a5250c47a79c288727a2bfd0fd5e69c2b", "filename": "gcc/tree.c", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -121,7 +121,6 @@ const char *const tree_code_class_strings[] =\n /* obstack.[ch] explicitly declined to prototype this.  */\n extern int _obstack_allocated_p (struct obstack *h, void *obj);\n \n-#ifdef GATHER_STATISTICS\n /* Statistics-gathering stuff.  */\n \n static int tree_code_counts[MAX_TREE_CODES];\n@@ -147,7 +146,6 @@ static const char * const tree_node_kind_names[] = {\n   \"lang_type kinds\",\n   \"omp clauses\",\n };\n-#endif /* GATHER_STATISTICS */\n \n /* Unique id for next decl created.  */\n static GTY(()) int next_decl_uid;\n@@ -751,10 +749,12 @@ static void\n record_node_allocation_statistics (enum tree_code code ATTRIBUTE_UNUSED,\n \t\t\t\t   size_t length ATTRIBUTE_UNUSED)\n {\n-#ifdef GATHER_STATISTICS\n   enum tree_code_class type = TREE_CODE_CLASS (code);\n   tree_node_kind kind;\n \n+  if (!GATHER_STATISTICS)\n+    return;\n+\n   switch (type)\n     {\n     case tcc_declaration:  /* A decl node */\n@@ -832,7 +832,6 @@ record_node_allocation_statistics (enum tree_code code ATTRIBUTE_UNUSED,\n   tree_code_counts[(int) code]++;\n   tree_node_counts[(int) kind]++;\n   tree_node_sizes[(int) kind] += length;\n-#endif\n }\n \n /* Allocate and return a new UID from the DECL_UID namespace.  */\n@@ -6337,11 +6336,12 @@ type_hash_canon (unsigned int hashcode, tree type)\n   t1 = type_hash_lookup (hashcode, type);\n   if (t1 != 0)\n     {\n-#ifdef GATHER_STATISTICS\n-      tree_code_counts[(int) TREE_CODE (type)]--;\n-      tree_node_counts[(int) t_kind]--;\n-      tree_node_sizes[(int) t_kind] -= sizeof (struct tree_type_non_common);\n-#endif\n+      if (GATHER_STATISTICS)\n+\t{\n+\t  tree_code_counts[(int) TREE_CODE (type)]--;\n+\t  tree_node_counts[(int) t_kind]--;\n+\t  tree_node_sizes[(int) t_kind] -= sizeof (struct tree_type_non_common);\n+\t}\n       return t1;\n     }\n   else\n@@ -8709,36 +8709,34 @@ get_callee_fndecl (const_tree call)\n void\n dump_tree_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n-  int i;\n-  int total_nodes, total_bytes;\n-#endif\n+  if (GATHER_STATISTICS)\n+    {\n+      int i;\n+      int total_nodes, total_bytes;\n+      fprintf (stderr, \"Kind                   Nodes      Bytes\\n\");\n+      fprintf (stderr, \"---------------------------------------\\n\");\n+      total_nodes = total_bytes = 0;\n+      for (i = 0; i < (int) all_kinds; i++)\n+\t{\n+\t  fprintf (stderr, \"%-20s %7d %10d\\n\", tree_node_kind_names[i],\n+\t\t   tree_node_counts[i], tree_node_sizes[i]);\n+\t  total_nodes += tree_node_counts[i];\n+\t  total_bytes += tree_node_sizes[i];\n+\t}\n+      fprintf (stderr, \"---------------------------------------\\n\");\n+      fprintf (stderr, \"%-20s %7d %10d\\n\", \"Total\", total_nodes, total_bytes);\n+      fprintf (stderr, \"---------------------------------------\\n\");\n+      fprintf (stderr, \"Code                   Nodes\\n\");\n+      fprintf (stderr, \"----------------------------\\n\");\n+      for (i = 0; i < (int) MAX_TREE_CODES; i++)\n+\tfprintf (stderr, \"%-20s %7d\\n\", tree_code_name[i], tree_code_counts[i]);\n+      fprintf (stderr, \"----------------------------\\n\");\n+      ssanames_print_statistics ();\n+      phinodes_print_statistics ();\n+    }\n+  else\n+    fprintf (stderr, \"(No per-node statistics)\\n\");\n \n-  fprintf (stderr, \"\\n??? tree nodes created\\n\\n\");\n-#ifdef GATHER_STATISTICS\n-  fprintf (stderr, \"Kind                   Nodes      Bytes\\n\");\n-  fprintf (stderr, \"---------------------------------------\\n\");\n-  total_nodes = total_bytes = 0;\n-  for (i = 0; i < (int) all_kinds; i++)\n-    {\n-      fprintf (stderr, \"%-20s %7d %10d\\n\", tree_node_kind_names[i],\n-\t       tree_node_counts[i], tree_node_sizes[i]);\n-      total_nodes += tree_node_counts[i];\n-      total_bytes += tree_node_sizes[i];\n-    }\n-  fprintf (stderr, \"---------------------------------------\\n\");\n-  fprintf (stderr, \"%-20s %7d %10d\\n\", \"Total\", total_nodes, total_bytes);\n-  fprintf (stderr, \"---------------------------------------\\n\");\n-  fprintf (stderr, \"Code                   Nodes\\n\");\n-  fprintf (stderr, \"----------------------------\\n\");\n-  for (i = 0; i < (int) MAX_TREE_CODES; i++)\n-    fprintf (stderr, \"%-20s %7d\\n\", tree_code_name[i], tree_code_counts[i]);\n-  fprintf (stderr, \"----------------------------\\n\");\n-  ssanames_print_statistics ();\n-  phinodes_print_statistics ();\n-#else\n-  fprintf (stderr, \"(No per-node statistics)\\n\");\n-#endif\n   print_type_hash_statistics ();\n   print_debug_expr_statistics ();\n   print_value_expr_statistics ();"}, {"sha": "85274c4e00c202e680761cef516bd17bb58b6261", "filename": "gcc/vec.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -34,8 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"hashtab.h\"\n \n-#ifdef GATHER_STATISTICS\n-\n /* Store information about each particular vector.  */\n struct vec_descriptor\n {\n@@ -158,10 +156,10 @@ free_overhead (struct vec_prefix *ptr)\n void\n vec_heap_free (void *ptr)\n {\n-  free_overhead ((struct vec_prefix *)ptr);\n+  if (GATHER_STATISTICS)\n+    free_overhead ((struct vec_prefix *)ptr);\n   free (ptr);\n }\n-#endif\n \n /* Calculate the new ALLOC value, making sure that RESERVE slots are\n    free.  If EXACT grow exactly, otherwise grow exponentially.  */\n@@ -316,20 +314,16 @@ vec_heap_o_reserve_1 (void *vec, int reserve, size_t vec_offset,\n       return NULL;\n     }\n \n-#ifdef GATHER_STATISTICS\n-  if (vec)\n+  if (GATHER_STATISTICS && vec)\n     free_overhead (pfx);\n-#endif\n \n   vec = xrealloc (vec, vec_offset + alloc * elt_size);\n   ((struct vec_prefix *)vec)->alloc = alloc;\n   if (!pfx)\n     ((struct vec_prefix *)vec)->num = 0;\n-#ifdef GATHER_STATISTICS\n-  if (vec)\n+  if (GATHER_STATISTICS && vec)\n     register_overhead ((struct vec_prefix *)vec,\n-    \t\t       vec_offset + alloc * elt_size PASS_MEM_STAT);\n-#endif\n+    \t\t       vec_offset + alloc * elt_size FINAL_PASS_MEM_STAT);\n \n   return vec;\n }\n@@ -529,7 +523,6 @@ vec_assert_fail (const char *op, const char *struct_name,\n }\n #endif\n \n-#ifdef GATHER_STATISTICS\n /* Helper for qsort; sort descriptors by amount of memory consumed.  */\n static int\n cmp_statistic (const void *loc1, const void *loc2)\n@@ -558,17 +551,19 @@ add_statistics (void **slot, void *b)\n }\n \n /* Dump per-site memory statistics.  */\n-#endif\n+\n void\n dump_vec_loc_statistics (void)\n {\n-#ifdef GATHER_STATISTICS\n   int nentries = 0;\n   char s[4096];\n   size_t allocated = 0;\n   size_t times = 0;\n   int i;\n \n+  if (! GATHER_STATISTICS)\n+    return;\n+\n   loc_array = XCNEWVEC (struct vec_descriptor *, vec_desc_hash->n_elements);\n   fprintf (stderr, \"Heap vectors:\\n\");\n   fprintf (stderr, \"\\n%-48s %10s       %10s       %10s\\n\",\n@@ -603,5 +598,4 @@ dump_vec_loc_statistics (void)\n   fprintf (stderr, \"\\n%-48s %10s       %10s       %10s\\n\",\n \t   \"source location\", \"Leak\", \"Peak\", \"Times\");\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n-#endif\n }"}, {"sha": "f38c763104fc8de68c1db47aea15a35f995c2568", "filename": "gcc/vec.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aa6d18a7c51ff7b19149d1e03db839b6b1033dc/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=7aa6d18a7c51ff7b19149d1e03db839b6b1033dc", "patch": "@@ -482,12 +482,7 @@ extern void *vec_heap_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n extern void *vec_heap_o_reserve_exact (void *, int, size_t, size_t\n \t\t\t\t       MEM_STAT_DECL);\n extern void dump_vec_loc_statistics (void);\n-#ifdef GATHER_STATISTICS\n-void vec_heap_free (void *);\n-#else\n-/* Avoid problems with frontends that #define free(x).  */\n-#define vec_heap_free(V) (free) (V)\n-#endif\n+extern void vec_heap_free (void *);\n \n #if ENABLE_CHECKING\n #define VEC_CHECK_INFO ,__FILE__,__LINE__,__FUNCTION__\n@@ -1356,7 +1351,8 @@ extern void *vec_stack_o_reserve_exact (void *, int, size_t, size_t\n \t\t\t\t\t MEM_STAT_DECL);\n extern void vec_stack_free (void *);\n \n-#ifdef GATHER_STATISTICS\n+/* Unfortunately, we cannot use MEM_STAT_DECL here.  */\n+#if GATHER_STATISTICS\n #define VEC_stack_alloc(T,alloc,name,line,function)\t\t\t  \\\n   (VEC_OP (T,stack,alloc1)\t\t\t\t\t\t  \\\n    (alloc, XALLOCAVAR (VEC(T,stack), VEC_embedded_size (T, alloc))))"}]}