{"sha": "7a95d078fa0edafc862f5d6e2999fc894081d4d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E5NWQwNzhmYTBlZGFmYzg2MmY1ZDZlMjk5OWZjODk0MDgxZDRkOA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-28T16:03:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-28T16:03:09Z"}, "message": "tree-ssa-ccp.c: Remove comment regarding STORE-CCP.\n\n2010-07-28  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-ccp.c: Remove comment regarding STORE-CCP.\n\t(set_lattice_value): Do not query an old default value.\n\t(get_value_for_expr): New function.  Properly canonicalize\n\tfloat values.\n\t(ccp_visit_phi_node): Use it.\n\nFrom-SVN: r162638", "tree": {"sha": "a39f84dc9ca118ac88aa33df39a3b8e2d319becb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a39f84dc9ca118ac88aa33df39a3b8e2d319becb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a95d078fa0edafc862f5d6e2999fc894081d4d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a95d078fa0edafc862f5d6e2999fc894081d4d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a95d078fa0edafc862f5d6e2999fc894081d4d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a95d078fa0edafc862f5d6e2999fc894081d4d8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12ffc7d5f6cdf9fd9f45f6cce12577655889e6a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12ffc7d5f6cdf9fd9f45f6cce12577655889e6a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12ffc7d5f6cdf9fd9f45f6cce12577655889e6a3"}], "stats": {"total": 123, "additions": 36, "deletions": 87}, "files": [{"sha": "599176dfe84ac6fbd561a26c381fffa6968e0078", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95d078fa0edafc862f5d6e2999fc894081d4d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95d078fa0edafc862f5d6e2999fc894081d4d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a95d078fa0edafc862f5d6e2999fc894081d4d8", "patch": "@@ -1,3 +1,11 @@\n+2010-07-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-ccp.c: Remove comment regarding STORE-CCP.\n+\t(set_lattice_value): Do not query an old default value.\n+\t(get_value_for_expr): New function.  Properly canonicalize\n+\tfloat values.\n+\t(ccp_visit_phi_node): Use it.\n+\n 2010-07-28  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \t* config/arm/arm.c (arm_pcs_default): Remove static."}, {"sha": "f573b0d8ade1ef68da68f2eade7cf57d477719d0", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 28, "deletions": 87, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a95d078fa0edafc862f5d6e2999fc894081d4d8/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a95d078fa0edafc862f5d6e2999fc894081d4d8/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=7a95d078fa0edafc862f5d6e2999fc894081d4d8", "patch": "@@ -99,81 +99,6 @@ along with GCC; see the file COPYING3.  If not see\n    array CONST_VAL[i].VALUE.  That is fed into substitute_and_fold for\n    final substitution and folding.\n \n-\n-   Constant propagation in stores and loads (STORE-CCP)\n-   ----------------------------------------------------\n-\n-   While CCP has all the logic to propagate constants in GIMPLE\n-   registers, it is missing the ability to associate constants with\n-   stores and loads (i.e., pointer dereferences, structures and\n-   global/aliased variables).  We don't keep loads and stores in\n-   SSA, but we do build a factored use-def web for them (in the\n-   virtual operands).\n-\n-   For instance, consider the following code fragment:\n-\n-\t  struct A a;\n-\t  const int B = 42;\n-\n-\t  void foo (int i)\n-\t  {\n-\t    if (i > 10)\n-\t      a.a = 42;\n-\t    else\n-\t      {\n-\t\ta.b = 21;\n-\t\ta.a = a.b + 21;\n-\t      }\n-\n-\t    if (a.a != B)\n-\t      never_executed ();\n-\t  }\n-\n-   We should be able to deduce that the predicate 'a.a != B' is always\n-   false.  To achieve this, we associate constant values to the SSA\n-   names in the VDEF operands for each store.  Additionally,\n-   since we also glob partial loads/stores with the base symbol, we\n-   also keep track of the memory reference where the constant value\n-   was stored (in the MEM_REF field of PROP_VALUE_T).  For instance,\n-\n-        # a_5 = VDEF <a_4>\n-        a.a = 2;\n-\n-        # VUSE <a_5>\n-        x_3 = a.b;\n-\n-   In the example above, CCP will associate value '2' with 'a_5', but\n-   it would be wrong to replace the load from 'a.b' with '2', because\n-   '2' had been stored into a.a.\n-\n-   Note that the initial value of virtual operands is VARYING, not\n-   UNDEFINED.  Consider, for instance global variables:\n-\n-   \tint A;\n-\n-   \tfoo (int i)\n-  \t{\n-\t  if (i_3 > 10)\n-\t    A_4 = 3;\n-          # A_5 = PHI (A_4, A_2);\n-\n-\t  # VUSE <A_5>\n-\t  A.0_6 = A;\n-\n-\t  return A.0_6;\n-\t}\n-\n-   The value of A_2 cannot be assumed to be UNDEFINED, as it may have\n-   been defined outside of foo.  If we were to assume it UNDEFINED, we\n-   would erroneously optimize the above into 'return 3;'.\n-\n-   Though STORE-CCP is not too expensive, it does have to do more work\n-   than regular CCP, so it is only enabled at -O2.  Both regular CCP\n-   and STORE-CCP use the exact same algorithm.  The only distinction\n-   is that when doing STORE-CCP, the boolean variable DO_STORE_CCP is\n-   set to true.  This affects the evaluation of statements and PHI\n-   nodes.\n-\n    References:\n \n      Constant propagation with conditional branches,\n@@ -420,7 +345,8 @@ canonicalize_float_value (prop_value_t *val)\n static bool\n set_lattice_value (tree var, prop_value_t new_val)\n {\n-  prop_value_t *old_val = get_value (var);\n+  /* We can deal with old UNINITIALIZED values just fine here.  */\n+  prop_value_t *old_val = &const_val[SSA_NAME_VERSION (var)];\n \n   canonicalize_float_value (&new_val);\n \n@@ -443,13 +369,37 @@ set_lattice_value (tree var, prop_value_t new_val)\n \n       *old_val = new_val;\n \n-      gcc_assert (new_val.lattice_val != UNDEFINED);\n+      gcc_assert (new_val.lattice_val != UNINITIALIZED);\n       return true;\n     }\n \n   return false;\n }\n \n+/* Return the value for the tree operand EXPR.  */\n+\n+static prop_value_t\n+get_value_for_expr (tree expr)\n+{\n+  prop_value_t val;\n+\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    val = *(get_value (expr));\n+  else if (is_gimple_min_invariant (expr))\n+    {\n+      val.lattice_val = CONSTANT;\n+      val.value = expr;\n+      canonicalize_float_value (&val);\n+    }\n+  else\n+    {\n+      val.lattice_val = VARYING;\n+      val.value = NULL_TREE;\n+    }\n+\n+  return val;\n+}\n+\n \n /* Return the likely CCP lattice value for STMT.\n \n@@ -797,15 +747,7 @@ ccp_visit_phi_node (gimple phi)\n       if (e->flags & EDGE_EXECUTABLE)\n \t{\n \t  tree arg = gimple_phi_arg (phi, i)->def;\n-\t  prop_value_t arg_val;\n-\n-\t  if (is_gimple_min_invariant (arg))\n-\t    {\n-\t      arg_val.lattice_val = CONSTANT;\n-\t      arg_val.value = arg;\n-\t    }\n-\t  else\n-\t    arg_val = *(get_value (arg));\n+\t  prop_value_t arg_val = get_value_for_expr (arg);\n \n \t  ccp_lattice_meet (&new_val, &arg_val);\n \n@@ -1137,7 +1079,6 @@ ccp_fold (gimple stmt)\n     }\n }\n \n-\n /* Return the tree representing the element referenced by T if T is an\n    ARRAY_REF or COMPONENT_REF into constant aggregates.  Return\n    NULL_TREE otherwise.  */"}]}