{"sha": "4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUwMmZlOGRmY2IxY2MyYzU5YjUwYjg2OGFjNzVmYjVjZGQ3NDJmYw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-05-13T10:16:09Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-05-13T10:16:09Z"}, "message": "re PR middle-end/42371 (dead code not eliminated during folding with whole-program)\n\n2013-05-13  Martin Jambor  <mjambor@suse.cz>\n\n\tPR middle-end/42371\n\t* ipa-prop.h (IPA_UNDESCRIBED_USE): New macro.\n\t(ipa_constant_data): New type.\n\t(ipa_jump_func): Use ipa_constant_data to hold information about\n\tconstant jump functions.\n\t(ipa_get_jf_constant): Adjust to jump function type changes.\n\t(ipa_get_jf_constant_rdesc): New function.\n\t(ipa_param_descriptor): New field controlled_uses.\n\t(ipa_get_controlled_uses): New function.\n\t(ipa_set_controlled_uses): Likewise.\n\t* ipa-ref.h (ipa_find_reference): Declare.\n\t* ipa-prop.c (ipa_cst_ref_desc): New type.\n\t(ipa_print_node_jump_functions_for_edge): Adjust for jump function type\n\tchanges.\n\t(ipa_set_jf_constant): Likewise.  Also create reference descriptions.\n\tNew parameter cs.  Adjust all callers.\n\t(ipa_analyze_params_uses): Detect uncontrolled and controlled uses.\n\t(remove_described_reference): New function.\n\t(jfunc_rdesc_usable): Likewise.\n\t(try_make_edge_direct_simple_call): Decrement controlled use count,\n\tattempt to remove reference if it hits zero.\n\t(combine_controlled_uses_counters): New function.\n\t(propagate_controlled_uses): Likewise.\n\t(ipa_propagate_indirect_call_infos): Call propagate_controlled_uses.\n\t(ipa_edge_duplication_hook): Duplicate reference descriptions.\n\t(ipa_print_node_params): Print described use counter.\n\t(ipa_write_jump_function): Adjust to jump function type changes.\n\t(ipa_read_jump_function): New parameter CS, pass it to\n\tipa_set_jf_constant.  Adjust caller.\n\t(ipa_write_node_info): Stream controlled use count\n\t(ipa_read_node_info): Likewise.\n\t* cgraph.c (cgraph_mark_address_taken_node): Bail out instead of\n\tasserting.\n\t* ipa-cp.c (ipcp_discover_new_direct_edges): Decrement controlled use\n\tcount.  Remove cloning-added reference if it reaches zero.\n\t* ipa-ref.c (ipa_find_reference): New function.\n\ntestsuite/\n\t* gcc.dg/ipa/remref-0.c: New test.\n\t* gcc.dg/ipa/remref-1a.c: Likewise.\n\t* gcc.dg/ipa/remref-1b.c: Likewise.\n\t* gcc.dg/ipa/remref-2a.c: Likewise.\n\t* gcc.dg/ipa/remref-2b.c: Likewise.\n\nFrom-SVN: r198821", "tree": {"sha": "eb36587215072023d7faafc93b4cb03eb6f629f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb36587215072023d7faafc93b4cb03eb6f629f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0864bfc257a3d3198ba182c562b729ba1e96466d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0864bfc257a3d3198ba182c562b729ba1e96466d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0864bfc257a3d3198ba182c562b729ba1e96466d"}], "stats": {"total": 762, "additions": 740, "deletions": 22}, "files": [{"sha": "8a3a7338789ba0eadc0085dea28f6f3c4d2b71e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -1,3 +1,42 @@\n+2013-05-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/42371\n+\t* ipa-prop.h (IPA_UNDESCRIBED_USE): New macro.\n+\t(ipa_constant_data): New type.\n+\t(ipa_jump_func): Use ipa_constant_data to hold information about\n+\tconstant jump functions.\n+\t(ipa_get_jf_constant): Adjust to jump function type changes.\n+\t(ipa_get_jf_constant_rdesc): New function.\n+\t(ipa_param_descriptor): New field controlled_uses.\n+\t(ipa_get_controlled_uses): New function.\n+\t(ipa_set_controlled_uses): Likewise.\n+\t* ipa-ref.h (ipa_find_reference): Declare.\n+\t* ipa-prop.c (ipa_cst_ref_desc): New type.\n+\t(ipa_print_node_jump_functions_for_edge): Adjust for jump function type\n+\tchanges.\n+\t(ipa_set_jf_constant): Likewise.  Also create reference descriptions.\n+\tNew parameter cs.  Adjust all callers.\n+\t(ipa_analyze_params_uses): Detect uncontrolled and controlled uses.\n+\t(remove_described_reference): New function.\n+\t(jfunc_rdesc_usable): Likewise.\n+\t(try_make_edge_direct_simple_call): Decrement controlled use count,\n+\tattempt to remove reference if it hits zero.\n+\t(combine_controlled_uses_counters): New function.\n+\t(propagate_controlled_uses): Likewise.\n+\t(ipa_propagate_indirect_call_infos): Call propagate_controlled_uses.\n+\t(ipa_edge_duplication_hook): Duplicate reference descriptions.\n+\t(ipa_print_node_params): Print described use counter.\n+\t(ipa_write_jump_function): Adjust to jump function type changes.\n+\t(ipa_read_jump_function): New parameter CS, pass it to\n+\tipa_set_jf_constant.  Adjust caller.\n+\t(ipa_write_node_info): Stream controlled use count\n+\t(ipa_read_node_info): Likewise.\n+\t* cgraph.c (cgraph_mark_address_taken_node): Bail out instead of\n+\tasserting.\n+\t* ipa-cp.c (ipcp_discover_new_direct_edges): Decrement controlled use\n+\tcount.  Remove cloning-added reference if it reaches zero.\n+\t* ipa-ref.c (ipa_find_reference): New function.\n+\n 2013-05-13  Ganesh Gopalasubramanian  <Ganesh.Gopalasubramanian@amd.com>\n \n \t* config/i386/i386.c (processor_target_table): Modified default "}, {"sha": "568486ebc80f9127dee9189a922ab9903250b498", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -1409,7 +1409,14 @@ cgraph_remove_node (struct cgraph_node *node)\n void\n cgraph_mark_address_taken_node (struct cgraph_node *node)\n {\n-  gcc_assert (!node->global.inlined_to);\n+  /* Indirect inlining can figure out that all uses of the address are\n+     inlined.  */\n+  if (node->global.inlined_to)\n+    {\n+      gcc_assert (cfun->after_inlining);\n+      gcc_assert (node->callers->indirect_inlining_edge);\n+      return;\n+    }\n   /* FIXME: address_taken flag is used both as a shortcut for testing whether\n      IPA_REF_ADDR reference exists (and thus it should be set on node\n      representing alias we take address of) and as a test whether address"}, {"sha": "98c91ef38e7eae0ea62975ce745b79b8dee40d70", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -2276,8 +2276,36 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t\t\t\t\t       aggvals);\n       if (target)\n \t{\n-\t  ipa_make_edge_direct_to_target (ie, target);\n+\t  struct cgraph_edge *cs = ipa_make_edge_direct_to_target (ie, target);\n \t  found = true;\n+\n+\t  if (cs && !ie->indirect_info->agg_contents\n+\t      && !ie->indirect_info->polymorphic)\n+\t    {\n+\t      struct ipa_node_params *info = IPA_NODE_REF (node);\n+\t      int param_index = ie->indirect_info->param_index;\n+\t      int c = ipa_get_controlled_uses (info, param_index);\n+\t      if (c != IPA_UNDESCRIBED_USE)\n+\t\t{\n+\t\t  struct ipa_ref *to_del;\n+\n+\t\t  c--;\n+\t\t  ipa_set_controlled_uses (info, param_index, c);\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"     controlled uses count of param \"\n+\t\t\t     \"%i bumped down to %i\\n\", param_index, c);\n+\t\t  if (c == 0\n+\t\t      && (to_del = ipa_find_reference ((symtab_node) node,\n+\t\t\t\t\t\t       (symtab_node) cs->callee,\n+\t\t\t\t\t\t       NULL)))\n+\t\t    {\n+\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\tfprintf (dump_file, \"       and even removing its \"\n+\t\t\t\t \"cloning-created reference\\n\");\n+\t\t      ipa_remove_reference (to_del);\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n     }\n   /* Turning calls to direct calls will improve overall summary.  */"}, {"sha": "76b3136e3cfffaee6e2fb7dca6c20f55ee4794e6", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 309, "deletions": 18, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -62,6 +62,22 @@ static struct cgraph_2edge_hook_list *edge_duplication_hook_holder;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n \n+/* Description of a reference to an IPA constant.  */\n+struct ipa_cst_ref_desc\n+{\n+  /* Edge that corresponds to the statement which took the reference.  */\n+  struct cgraph_edge *cs;\n+  /* Linked list of duplicates created when call graph edges are cloned.  */\n+  struct ipa_cst_ref_desc *next_duplicate;\n+  /* Number of references in IPA structures, IPA_UNDESCRIBED_USE if the value\n+     if out of control.  */\n+  int refcount;\n+};\n+\n+/* Allocation pool for reference descriptions.  */\n+\n+static alloc_pool ipa_refdesc_pool;\n+\n /* Return index of the formal whose tree is PTREE in function which corresponds\n    to INFO.  */\n \n@@ -175,7 +191,7 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t}\n       else if (type == IPA_JF_CONST)\n \t{\n-\t  tree val = jump_func->value.constant;\n+\t  tree val = jump_func->value.constant.value;\n \t  fprintf (f, \"CONST: \");\n \t  print_generic_expr (f, val, 0);\n \t  if (TREE_CODE (val) == ADDR_EXPR\n@@ -309,13 +325,31 @@ ipa_set_jf_known_type (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n /* Set JFUNC to be a constant jmp function.  */\n \n static void\n-ipa_set_jf_constant (struct ipa_jump_func *jfunc, tree constant)\n+ipa_set_jf_constant (struct ipa_jump_func *jfunc, tree constant,\n+\t\t     struct cgraph_edge *cs)\n {\n   constant = unshare_expr (constant);\n   if (constant && EXPR_P (constant))\n     SET_EXPR_LOCATION (constant, UNKNOWN_LOCATION);\n   jfunc->type = IPA_JF_CONST;\n-  jfunc->value.constant = unshare_expr_without_location (constant);\n+  jfunc->value.constant.value = unshare_expr_without_location (constant);\n+\n+  if (TREE_CODE (constant) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (constant, 0)) == FUNCTION_DECL)\n+    {\n+      struct ipa_cst_ref_desc *rdesc;\n+      if (!ipa_refdesc_pool)\n+\tipa_refdesc_pool = create_alloc_pool (\"IPA-PROP ref descriptions\",\n+\t\t\t\t\tsizeof (struct ipa_cst_ref_desc), 32);\n+\n+      rdesc = (struct ipa_cst_ref_desc *) pool_alloc (ipa_refdesc_pool);\n+      rdesc->cs = cs;\n+      rdesc->next_duplicate = NULL;\n+      rdesc->refcount = 1;\n+      jfunc->value.constant.rdesc = rdesc;\n+    }\n+  else\n+    jfunc->value.constant.rdesc = NULL;\n }\n \n /* Set JFUNC to be a simple pass-through jump function.  */\n@@ -1404,7 +1438,7 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n       tree arg = gimple_call_arg (call, n);\n \n       if (is_gimple_ip_invariant (arg))\n-\tipa_set_jf_constant (jfunc, arg);\n+\tipa_set_jf_constant (jfunc, arg, cs);\n       else if (!is_gimple_reg_type (TREE_TYPE (arg))\n \t       && TREE_CODE (arg) == PARM_DECL)\n \t{\n@@ -1891,14 +1925,35 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n   for (i = 0; i < ipa_get_param_count (info); i++)\n     {\n       tree parm = ipa_get_param (info, i);\n-      tree ddef;\n+      int controlled_uses = 0;\n+\n       /* For SSA regs see if parameter is used.  For non-SSA we compute\n \t the flag during modification analysis.  */\n-      if (is_gimple_reg (parm)\n-\t  && (ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->symbol.decl),\n-\t\t\t\t      parm)) != NULL_TREE\n-\t  && !has_zero_uses (ddef))\n-\tipa_set_param_used (info, i, true);\n+      if (is_gimple_reg (parm))\n+\t{\n+\t  tree ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->symbol.decl),\n+\t\t\t\t       parm);\n+\t  if (ddef && !has_zero_uses (ddef))\n+\t    {\n+\t      imm_use_iterator imm_iter;\n+\t      use_operand_p use_p;\n+\n+\t      ipa_set_param_used (info, i, true);\n+\t      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, ddef)\n+\t\tif (!is_gimple_call (USE_STMT (use_p)))\n+\t\t  {\n+\t\t    controlled_uses = IPA_UNDESCRIBED_USE;\n+\t\t    break;\n+\t\t  }\n+\t\telse\n+\t\t  controlled_uses++;\n+\t    }\n+\t  else\n+\t    controlled_uses = 0;\n+\t}\n+      else\n+\tcontrolled_uses = IPA_UNDESCRIBED_USE;\n+      ipa_set_controlled_uses (info, i, controlled_uses);\n     }\n \n   func = DECL_STRUCT_FUNCTION (decl);\n@@ -2226,6 +2281,40 @@ ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg,\n   return NULL;\n }\n \n+/* Remove a reference to SYMBOL from the list of references of a node given by\n+   reference description RDESC.  */\n+\n+static void\n+remove_described_reference (symtab_node symbol, struct ipa_cst_ref_desc *rdesc)\n+{\n+  struct ipa_ref *to_del;\n+  struct cgraph_edge *origin;\n+\n+  origin = rdesc->cs;\n+  to_del = ipa_find_reference ((symtab_node) origin->caller, symbol,\n+\t\t\t       origin->call_stmt);\n+  gcc_assert (to_del);\n+  ipa_remove_reference (to_del);\n+  if (dump_file)\n+    fprintf (dump_file, \"ipa-prop: Removed a reference from %s/%i to %s.\\n\",\n+\t     xstrdup (cgraph_node_name (origin->caller)),\n+\t     origin->caller->uid, xstrdup (symtab_node_name (symbol)));\n+}\n+\n+/* If JFUNC has a reference description with refcount different from\n+   IPA_UNDESCRIBED_USE, return the reference description, otherwise return\n+   NULL.  JFUNC must be a constant jump function.  */\n+\n+static struct ipa_cst_ref_desc *\n+jfunc_rdesc_usable (struct ipa_jump_func *jfunc)\n+{\n+  struct ipa_cst_ref_desc *rdesc = ipa_get_jf_constant_rdesc (jfunc);\n+  if (rdesc && rdesc->refcount != IPA_UNDESCRIBED_USE)\n+    return rdesc;\n+  else\n+    return NULL;\n+}\n+\n /* Try to find a destination for indirect edge IE that corresponds to a simple\n    call or a call of a member function pointer and where the destination is a\n    pointer formal parameter described by jump function JFUNC.  If it can be\n@@ -2237,6 +2326,8 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n \t\t\t\t  struct ipa_node_params *new_root_info)\n {\n+  struct ipa_cst_ref_desc *rdesc;\n+  struct cgraph_edge *cs;\n   tree target;\n \n   if (ie->indirect_info->agg_contents)\n@@ -2247,7 +2338,15 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n     target = ipa_value_from_jfunc (new_root_info, jfunc);\n   if (!target)\n     return NULL;\n-  return ipa_make_edge_direct_to_target (ie, target);\n+  cs = ipa_make_edge_direct_to_target (ie, target);\n+\n+  if (cs && !ie->indirect_info->agg_contents\n+      && jfunc->type == IPA_JF_CONST\n+      && (rdesc = jfunc_rdesc_usable (jfunc))\n+      && --rdesc->refcount == 0)\n+    remove_described_reference ((symtab_node) cs->callee, rdesc);\n+\n+  return cs;\n }\n \n /* Try to find a destination for indirect edge IE that corresponds to a virtual\n@@ -2411,6 +2510,135 @@ propagate_info_to_inlined_callees (struct cgraph_edge *cs,\n   return res;\n }\n \n+/* Combine two controlled uses counts as done during inlining.  */\n+\n+static int\n+combine_controlled_uses_counters (int c, int d)\n+{\n+  if (c == IPA_UNDESCRIBED_USE || d == IPA_UNDESCRIBED_USE)\n+    return IPA_UNDESCRIBED_USE;\n+  else\n+    return c + d - 1;\n+}\n+\n+/* Propagate number of controlled users from CS->caleee to the new root of the\n+   tree of inlined nodes.  */\n+\n+static void\n+propagate_controlled_uses (struct cgraph_edge *cs)\n+{\n+  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  struct cgraph_node *new_root = cs->caller->global.inlined_to\n+    ? cs->caller->global.inlined_to : cs->caller;\n+  struct ipa_node_params *new_root_info = IPA_NODE_REF (new_root);\n+  struct ipa_node_params *old_root_info = IPA_NODE_REF (cs->callee);\n+  int count, i;\n+\n+  count = MIN (ipa_get_cs_argument_count (args),\n+\t       ipa_get_param_count (old_root_info));\n+  for (i = 0; i < count; i++)\n+    {\n+      struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n+      struct ipa_cst_ref_desc *rdesc;\n+\n+      if (jf->type == IPA_JF_PASS_THROUGH)\n+\t{\n+\t  int src_idx, c, d;\n+\t  src_idx = ipa_get_jf_pass_through_formal_id (jf);\n+\t  c = ipa_get_controlled_uses (new_root_info, src_idx);\n+\t  d = ipa_get_controlled_uses (old_root_info, i);\n+\n+\t  gcc_checking_assert (ipa_get_jf_pass_through_operation (jf)\n+\t\t\t       == NOP_EXPR || c == IPA_UNDESCRIBED_USE);\n+\t  c = combine_controlled_uses_counters (c, d);\n+\t  ipa_set_controlled_uses (new_root_info, src_idx, c);\n+\t  if (c == 0 && new_root_info->ipcp_orig_node)\n+\t    {\n+\t      struct cgraph_node *n;\n+\t      struct ipa_ref *ref;\n+\t      tree t = new_root_info->known_vals[src_idx];\n+\n+\t      if (t && TREE_CODE (t) == ADDR_EXPR\n+\t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n+\t\t  && (n = cgraph_get_node (TREE_OPERAND (t, 0)))\n+\t\t  && (ref = ipa_find_reference ((symtab_node) new_root,\n+\t\t\t\t\t\t(symtab_node) n, NULL)))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"ipa-prop: Removing cloning-created \"\n+\t\t\t     \"reference from %s/%i to %s/%i.\\n\",\n+\t\t\t     xstrdup (cgraph_node_name (new_root)),\n+\t\t\t     new_root->uid,\n+\t\t\t     xstrdup (cgraph_node_name (n)), n->uid);\n+\t\t  ipa_remove_reference (ref);\n+\t\t}\n+\t    }\n+\t}\n+      else if (jf->type == IPA_JF_CONST\n+\t       && (rdesc = jfunc_rdesc_usable (jf)))\n+\t{\n+\t  int d = ipa_get_controlled_uses (old_root_info, i);\n+\t  int c = rdesc->refcount;\n+\t  rdesc->refcount = combine_controlled_uses_counters (c, d);\n+\t  if (rdesc->refcount == 0)\n+\t    {\n+\t      tree cst = ipa_get_jf_constant (jf);\n+\t      struct cgraph_node *n;\n+\t      gcc_checking_assert (TREE_CODE (cst) == ADDR_EXPR\n+\t\t\t\t   && TREE_CODE (TREE_OPERAND (cst, 0))\n+\t\t\t\t   == FUNCTION_DECL);\n+\t      n = cgraph_get_node (TREE_OPERAND (cst, 0));\n+\t      if (n)\n+\t\t{\n+\t\t  struct cgraph_node *clone;\n+\t\t  remove_described_reference ((symtab_node) n, rdesc);\n+\n+\t\t  clone = cs->caller;\n+\t\t  while (clone->global.inlined_to\n+\t\t\t && clone != rdesc->cs->caller\n+\t\t\t && IPA_NODE_REF (clone)->ipcp_orig_node)\n+\t\t    {\n+\t\t      struct ipa_ref *ref;\n+\t\t      ref = ipa_find_reference ((symtab_node) clone,\n+\t\t\t\t\t\t(symtab_node) n, NULL);\n+\t\t      if (ref)\n+\t\t\t{\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file, \"ipa-prop: Removing \"\n+\t\t\t\t     \"cloning-created reference \"\n+\t\t\t\t     \"from %s/%i to %s/%i.\\n\",\n+\t\t\t\t     xstrdup (cgraph_node_name (clone)),\n+\t\t\t\t     clone->uid,\n+\t\t\t\t     xstrdup (cgraph_node_name (n)),\n+\t\t\t\t     n->uid);\n+\t\t\t  ipa_remove_reference (ref);\n+\t\t\t}\n+\t\t      clone = clone->callers->caller;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  for (i = ipa_get_param_count (old_root_info);\n+       i < ipa_get_cs_argument_count (args);\n+       i++)\n+    {\n+      struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n+\n+      if (jf->type == IPA_JF_CONST)\n+\t{\n+\t  struct ipa_cst_ref_desc *rdesc = jfunc_rdesc_usable (jf);\n+\t  if (rdesc)\n+\t    rdesc->refcount = IPA_UNDESCRIBED_USE;\n+\t}\n+      else if (jf->type == IPA_JF_PASS_THROUGH)\n+\tipa_set_controlled_uses (new_root_info,\n+\t\t\t\t jf->value.pass_through.formal_id,\n+\t\t\t\t IPA_UNDESCRIBED_USE);\n+    }\n+}\n+\n /* Update jump functions and call note functions on inlining the call site CS.\n    CS is expected to lead to a node already cloned by\n    cgraph_clone_inline_nodes.  Newly discovered indirect edges will be added to\n@@ -2428,6 +2656,7 @@ ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n     return false;\n   gcc_assert (ipa_edge_args_vector);\n \n+  propagate_controlled_uses (cs);\n   changed = propagate_info_to_inlined_callees (cs, cs->callee, new_edges);\n \n   /* We do not keep jump functions of inlined edges up to date. Better to free\n@@ -2543,8 +2772,53 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n   new_args->jump_functions = vec_safe_copy (old_args->jump_functions);\n \n   for (i = 0; i < vec_safe_length (old_args->jump_functions); i++)\n-    (*new_args->jump_functions)[i].agg.items\n-\t= vec_safe_copy ((*old_args->jump_functions)[i].agg.items);\n+    {\n+      struct ipa_jump_func *src_jf = ipa_get_ith_jump_func (old_args, i);\n+      struct ipa_jump_func *dst_jf = ipa_get_ith_jump_func (new_args, i);\n+\n+      dst_jf->agg.items = vec_safe_copy (dst_jf->agg.items);\n+\n+      if (src_jf->type == IPA_JF_CONST)\n+\t{\n+\t  struct ipa_cst_ref_desc *src_rdesc = jfunc_rdesc_usable (src_jf);\n+\n+\t  if (!src_rdesc)\n+\t    dst_jf->value.constant.rdesc = NULL;\n+\t  else if (src_rdesc->cs == src)\n+\t    {\n+\t      struct ipa_cst_ref_desc *dst_rdesc;\n+\t      gcc_checking_assert (ipa_refdesc_pool);\n+\t      dst_rdesc\n+\t\t= (struct ipa_cst_ref_desc *) pool_alloc (ipa_refdesc_pool);\n+\t      dst_rdesc->cs = dst;\n+\t      dst_rdesc->next_duplicate = src_rdesc->next_duplicate;\n+\t      src_rdesc->next_duplicate = dst_rdesc;\n+\t      dst_rdesc->refcount = src_rdesc->refcount;\n+\t      dst_jf->value.constant.rdesc = dst_rdesc;\n+\t    }\n+\t  else\n+\t    {\n+\t      struct ipa_cst_ref_desc *dst_rdesc;\n+\t      /* This can happen during inlining, when a JFUNC can refer to a\n+\t\t reference taken in a function up in the tree of inline clones.\n+\t\t We need to find the duplicate that refers to our tree of\n+\t\t inline clones.  */\n+\n+\t      gcc_assert (dst->caller->global.inlined_to);\n+\t      for (dst_rdesc = src_rdesc->next_duplicate;\n+\t\t   dst_rdesc;\n+\t\t   dst_rdesc = dst_rdesc->next_duplicate)\n+\t\t{\n+\t\t  gcc_assert (dst_rdesc->cs->caller->global.inlined_to);\n+\t\t  if (dst_rdesc->cs->caller->global.inlined_to\n+\t\t      == dst->caller->global.inlined_to)\n+\t\t    break;\n+\t\t}\n+\n+\t      dst_jf->value.constant.rdesc = dst_rdesc;\n+\t    }\n+\t}\n+    }\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n@@ -2646,6 +2920,8 @@ ipa_free_all_structures_after_ipa_cp (void)\n       free_alloc_pool (ipcp_values_pool);\n       free_alloc_pool (ipcp_agg_lattice_pool);\n       ipa_unregister_cgraph_hooks ();\n+      if (ipa_refdesc_pool)\n+\tfree_alloc_pool (ipa_refdesc_pool);\n     }\n }\n \n@@ -2664,6 +2940,8 @@ ipa_free_all_structures_after_iinln (void)\n     free_alloc_pool (ipcp_values_pool);\n   if (ipcp_agg_lattice_pool)\n     free_alloc_pool (ipcp_agg_lattice_pool);\n+  if (ipa_refdesc_pool)\n+    free_alloc_pool (ipa_refdesc_pool);\n }\n \n /* Print ipa_tree_map data structures of all functions in the\n@@ -2684,6 +2962,8 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n     {\n+      int c;\n+\n       temp = ipa_get_param (info, i);\n       if (TREE_CODE (temp) == PARM_DECL)\n \tfprintf (f, \"    param %d : %s\", i,\n@@ -2692,6 +2972,11 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n                   : \"(unnamed)\"));\n       if (ipa_is_param_used (info, i))\n \tfprintf (f, \" used\");\n+      c = ipa_get_controlled_uses (info, i);\n+      if (c == IPA_UNDESCRIBED_USE)\n+\tfprintf (f, \" undescribed_use\");\n+      else\n+\tfprintf (f, \"  controlled_uses=%i\", c);\n       fprintf (f, \"\\n\");\n     }\n }\n@@ -3311,8 +3596,8 @@ ipa_write_jump_function (struct output_block *ob,\n       break;\n     case IPA_JF_CONST:\n       gcc_assert (\n-\t  EXPR_LOCATION (jump_func->value.constant) == UNKNOWN_LOCATION);\n-      stream_write_tree (ob, jump_func->value.constant, true);\n+\t  EXPR_LOCATION (jump_func->value.constant.value) == UNKNOWN_LOCATION);\n+      stream_write_tree (ob, jump_func->value.constant.value, true);\n       break;\n     case IPA_JF_PASS_THROUGH:\n       streamer_write_uhwi (ob, jump_func->value.pass_through.operation);\n@@ -3360,6 +3645,7 @@ ipa_write_jump_function (struct output_block *ob,\n static void\n ipa_read_jump_function (struct lto_input_block *ib,\n \t\t\tstruct ipa_jump_func *jump_func,\n+\t\t\tstruct cgraph_edge *cs,\n \t\t\tstruct data_in *data_in)\n {\n   enum jump_func_type jftype;\n@@ -3382,7 +3668,7 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \tbreak;\n       }\n     case IPA_JF_CONST:\n-      ipa_set_jf_constant (jump_func, stream_read_tree (ib, data_in));\n+      ipa_set_jf_constant (jump_func, stream_read_tree (ib, data_in), cs);\n       break;\n     case IPA_JF_PASS_THROUGH:\n       operation = (enum tree_code) streamer_read_uhwi (ib);\n@@ -3503,6 +3789,8 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   for (j = 0; j < ipa_get_param_count (info); j++)\n     bp_pack_value (&bp, ipa_is_param_used (info, j), 1);\n   streamer_write_bitpack (&bp);\n+  for (j = 0; j < ipa_get_param_count (info); j++)\n+    streamer_write_hwi (ob, ipa_get_controlled_uses (info, j));\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n@@ -3539,6 +3827,8 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   if (ipa_get_param_count (info) != 0)\n     info->uses_analysis_done = true;\n   info->node_enqueued = false;\n+  for (k = 0; k < ipa_get_param_count (info); k++)\n+    ipa_set_controlled_uses (info, k, streamer_read_hwi (ib));\n   for (k = 0; k < ipa_get_param_count (info); k++)\n     ipa_set_param_used (info, k, bp_unpack_value (&bp, 1));\n   for (e = node->callees; e; e = e->next_callee)\n@@ -3551,7 +3841,8 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n       vec_safe_grow_cleared (args->jump_functions, count);\n \n       for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n-\tipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), data_in);\n+\tipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n+\t\t\t\tdata_in);\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n@@ -3562,7 +3853,7 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n \t{\n \t  vec_safe_grow_cleared (args->jump_functions, count);\n           for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n-\t    ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k),\n+\t    ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), e,\n \t\t\t\t    data_in);\n \t}\n       ipa_read_indirect_edge_info (ib, data_in, e);"}, {"sha": "3399e82730fe18533835d34159a20fa57c6b1d80", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -29,6 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n /* The following definitions and interfaces are used by\n    interprocedural analyses or parameters.  */\n \n+#define IPA_UNDESCRIBED_USE -1\n+\n /* ipa-prop.c stuff (ipa-cp, indirect inlining):  */\n \n /* A jump function for a callsite represents the values passed as actual\n@@ -84,6 +86,17 @@ struct GTY(()) ipa_known_type_data\n   tree component_type;\n };\n \n+struct ipa_cst_ref_desc;\n+\n+/* Structure holding data required to describe a constant jump function.  */\n+struct GTY(()) ipa_constant_data\n+{\n+  /* THe value of the constant.  */\n+  tree value;\n+  /* Pointer to the structure that describes the reference.  */\n+  struct ipa_cst_ref_desc GTY((skip)) *rdesc;\n+};\n+\n /* Structure holding data required to describe a pass-through jump function.  */\n \n struct GTY(()) ipa_pass_through_data\n@@ -172,7 +185,7 @@ typedef struct GTY (()) ipa_jump_func\n   union jump_func_value\n   {\n     struct ipa_known_type_data GTY ((tag (\"IPA_JF_KNOWN_TYPE\"))) known_type;\n-    tree GTY ((tag (\"IPA_JF_CONST\"))) constant;\n+    struct ipa_constant_data GTY ((tag (\"IPA_JF_CONST\"))) constant;\n     struct ipa_pass_through_data GTY ((tag (\"IPA_JF_PASS_THROUGH\"))) pass_through;\n     struct ipa_ancestor_jf_data GTY ((tag (\"IPA_JF_ANCESTOR\"))) ancestor;\n   } GTY ((desc (\"%1.type\"))) value;\n@@ -213,7 +226,14 @@ static inline tree\n ipa_get_jf_constant (struct ipa_jump_func *jfunc)\n {\n   gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n-  return jfunc->value.constant;\n+  return jfunc->value.constant.value;\n+}\n+\n+static inline struct ipa_cst_ref_desc *\n+ipa_get_jf_constant_rdesc (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n+  return jfunc->value.constant.rdesc;\n }\n \n /* Return the operand of a pass through jmp function JFUNC.  */\n@@ -296,6 +316,10 @@ struct ipa_param_descriptor\n {\n   /* PARAM_DECL of this parameter.  */\n   tree decl;\n+  /* If all uses of the parameter are described by ipa-prop structures, this\n+     says how many there are.  If any use could not be described by means of\n+     ipa-prop structures, this is IPA_UNDESCRIBED_USE.  */\n+  int controlled_uses;\n   /* The parameter is used.  */\n   unsigned used : 1;\n };\n@@ -365,6 +389,23 @@ ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n   info->descriptors[i].used = val;\n }\n \n+/* Return how many uses described by ipa-prop a parameter has or\n+   IPA_UNDESCRIBED_USE if there is a use that is not described by these\n+   structures.  */\n+static inline int\n+ipa_get_controlled_uses (struct ipa_node_params *info, int i)\n+{\n+  return info->descriptors[i].controlled_uses;\n+}\n+\n+/* Set the controlled counter of a given parameter.  */\n+\n+static inline void\n+ipa_set_controlled_uses (struct ipa_node_params *info, int i, int val)\n+{\n+  info->descriptors[i].controlled_uses = val;\n+}\n+\n /* Return the used flag corresponding to the Ith formal parameter of the\n    function associated with INFO.  */\n "}, {"sha": "d6ac25ffccdfd379d94ca9f15d5f237654cf7996", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -198,3 +198,20 @@ ipa_ref_has_aliases_p (struct ipa_ref_list *ref_list)\n       return true;\n   return false;\n }\n+\n+/* Find the structure describing a reference in REFERRING_NODE to REFERRED_NODE\n+   and associated with statement STMT.  */\n+\n+struct ipa_ref *\n+ipa_find_reference (symtab_node referring_node, symtab_node referred_node,\n+\t\t    gimple stmt)\n+{\n+  struct ipa_ref *r = NULL;\n+  int i;\n+\n+  FOR_EACH_VEC_SAFE_ELT (referring_node->symbol.ref_list.references, i, r)\n+    if (r->referred == referred_node\n+\t&& (in_lto_p || r->stmt == stmt))\n+      return r;\n+  return NULL;\n+}"}, {"sha": "972e9737f9ad904f353f67b3668827ba256e7687", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -71,3 +71,4 @@ void ipa_clone_references (symtab_node, struct ipa_ref_list *);\n void ipa_clone_referring (symtab_node, struct ipa_ref_list *);\n bool ipa_ref_cannot_lead_to_return (struct ipa_ref *);\n bool ipa_ref_has_aliases_p (struct ipa_ref_list *);\n+struct ipa_ref * ipa_find_reference (symtab_node, symtab_node, gimple);"}, {"sha": "b4fc7f95451da0d6e3048524f3576546e9d8762d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -1,3 +1,12 @@\n+2013-05-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/42371\n+\t* gcc.dg/ipa/remref-0.c: New test.\n+\t* gcc.dg/ipa/remref-1a.c: Likewise.\n+\t* gcc.dg/ipa/remref-1b.c: Likewise.\n+\t* gcc.dg/ipa/remref-2a.c: Likewise.\n+\t* gcc.dg/ipa/remref-2b.c: Likewise.\n+\n 2013-05-13  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* gcc.dg/vector-shift-2.c: New testcase."}, {"sha": "a9e434a86d3f70a67373d4260fab6cd713d3378e", "filename": "gcc/testsuite/gcc.dg/ipa/remref-0.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-0.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -0,0 +1,30 @@\n+/* Verify that indirect inlining machinery can remove references to functions\n+   passed as parameters that are never used.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-ipa-sra -fno-ipa-cp -fdump-ipa-inline -fdump-tree-optimized\"  } */\n+\n+extern int __attribute__ ((noinline, noclone, used))\n+stuff (int i)\n+{\n+  return 0;\n+}\n+\n+static void hooray ()\n+{\n+  stuff (1);\n+}\n+\n+static int hiphip (void (*f)())\n+{\n+  return stuff (2);\n+}\n+\n+int main (void)\n+{\n+  return hiphip (hooray);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"ipa-prop: Removed a reference\"  \"inline\"  } } */\n+/* { dg-final { scan-tree-dump-not \"hooray\"  \"optimized\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "9db2bd61927664743f80a8fb897517c7c3ee96aa", "filename": "gcc/testsuite/gcc.dg/ipa/remref-1a.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-1a.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -0,0 +1,34 @@\n+/* Verify that indirect inlining can also remove references of the functions it\n+   discovers calls for.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-ipa-cp -fdump-ipa-inline -fdump-tree-optimized\"  } */\n+\n+int global;\n+\n+void __attribute__ ((noinline, noclone, used))\n+stuff (int i)\n+{\n+  global = i;\n+}\n+\n+static void hooray ()\n+{\n+  stuff (1);\n+}\n+\n+static void hiphip (void (*f)())\n+{\n+  stuff (2);\n+  f ();\n+}\n+\n+int main (void)\n+{\n+  hiphip (hooray);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"ipa-prop: Removed a reference\"  \"inline\"  } } */\n+/* { dg-final { scan-tree-dump-not \"hooray\"  \"optimized\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "a17cf4828a9550e9586aad676fe95bb63aaacdbf", "filename": "gcc/testsuite/gcc.dg/ipa/remref-1b.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-1b.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -0,0 +1,37 @@\n+/* Verify that indirect inlining can also remove references of the functions it\n+   discovers calls for, even when nodes being inlined are virtual IPA-CP\n+   clones.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-early-inlining -fdump-ipa-cp-details -fdump-ipa-inline -fdump-tree-optimized\"  } */\n+\n+int global;\n+\n+void __attribute__ ((noinline, noclone, used))\n+stuff (int i)\n+{\n+  global = i;\n+}\n+\n+static void hooray ()\n+{\n+  stuff (1);\n+}\n+\n+static void hiphip (void (*f)())\n+{\n+  stuff (2);\n+  f ();\n+}\n+\n+int main (void)\n+{\n+  hiphip (hooray);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"removing its cloning-created reference\"  \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"ipa-prop: Removed a reference\"  \"inline\"  } } */\n+/* { dg-final { scan-tree-dump-not \"hooray\"  \"optimized\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "1e0df2e84d2d924a3214053c50ed2edd8e7de656", "filename": "gcc/testsuite/gcc.dg/ipa/remref-2a.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-2a.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -0,0 +1,90 @@\n+/* Verify that indirect inlining can also remove references of the functions it\n+   discovers calls for.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-ipa-cp -fdump-ipa-inline -fdump-tree-optimized\"  } */\n+\n+int global;\n+\n+void __attribute__ ((noinline, noclone, used))\n+stuff (int i)\n+{\n+  global = i;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static void\n+hooray_1 ()\n+{\n+  stuff (1);\n+}\n+\n+static inline void\n+hip2_1 (void (*g)())\n+{\n+  int i;\n+  g ();\n+  /* Some stuff to make the function bigger so that hip1_1 gets inlined\n+     fiorst. */\n+  for (i = 0; i < get_input (); i++)\n+    {\n+      stuff (2);\n+      stuff (2+2);\n+    }\n+}\n+\n+static inline void\n+hip1_1 (void (*g)())\n+{\n+  hip2_1 (g);\n+}\n+\n+static void\n+hooray_2 ()\n+{\n+  stuff (1);\n+}\n+\n+static inline void\n+hip2_2 (void (*g)())\n+{\n+  g ();\n+}\n+\n+static inline void\n+hip1_2 (void (*g)())\n+{\n+  int i;\n+\n+  hip2_2 (g);\n+\n+  /* Some stuff to make the function bigger so that hip2_2 gets inlined\n+     fiorst. */\n+  for (i = 0; i < get_input (); i++)\n+    {\n+      stuff (2);\n+      stuff (2+2);\n+    }\n+}\n+\n+\n+int\n+main (int argc, int *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    {\n+      hip1_1 (hooray_1);\n+      hip1_2 (hooray_2);\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"ipa-prop: Removed a reference\" 2 \"inline\"  } } */\n+/* { dg-final { scan-tree-dump-not \"hooray\"  \"optimized\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "554f306d26254cadb3826c617363fdb67adc083a", "filename": "gcc/testsuite/gcc.dg/ipa/remref-2b.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fremref-2b.c?ref=4502fe8dfcb1cc2c59b50b868ac75fb5cdd742fc", "patch": "@@ -0,0 +1,94 @@\n+/* Verify that indirect inlining can also remove references of the functions it\n+   discovers calls for, even when nodes being inlined are virtual IPA-CP\n+   clones.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-early-inlining -fdump-ipa-cp-details -fdump-ipa-inline -fdump-tree-optimized\"  } */\n+\n+\n+int global;\n+\n+void __attribute__ ((noinline, noclone, used))\n+stuff (int i)\n+{\n+  global = i;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static void\n+hooray_1 ()\n+{\n+  stuff (1);\n+}\n+\n+static inline void\n+hip2_1 (void (*g)())\n+{\n+  int i;\n+  g ();\n+  /* Some stuff to make the function bigger so that hip1_1 gets inlined\n+     fiorst. */\n+  for (i = 0; i < get_input (); i++)\n+    {\n+      stuff (2);\n+      stuff (2+2);\n+    }\n+}\n+\n+static inline void\n+hip1_1 (void (*g)())\n+{\n+  hip2_1 (g);\n+}\n+\n+static void\n+hooray_2 ()\n+{\n+  stuff (1);\n+}\n+\n+static inline void\n+hip2_2 (void (*g)())\n+{\n+  g ();\n+}\n+\n+static inline void\n+hip1_2 (void (*g)())\n+{\n+  int i;\n+\n+  hip2_2 (g);\n+\n+  /* Some stuff to make the function bigger so that hip2_2 gets inlined\n+     fiorst. */\n+  for (i = 0; i < get_input (); i++)\n+    {\n+      stuff (2);\n+      stuff (2+2);\n+    }\n+}\n+\n+int\n+main (int argc, int *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    {\n+      hip1_1 (hooray_1);\n+      hip1_2 (hooray_2);\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"removing its cloning-created reference\" 2 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"ipa-prop: Removed a reference\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump-times \"ipa-prop: Removing cloning-created reference\" 2 \"inline\"  } } */\n+/* { dg-final { scan-tree-dump-not \"hooray\"  \"optimized\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}