{"sha": "7010bcd1c80e2a89f43c064ba21289df8c67a84c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAxMGJjZDFjODBlMmE4OWY0M2MwNjRiYTIxMjg5ZGY4YzY3YTg0Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-01-07T21:30:43Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2020-01-07T21:30:43Z"}, "message": "Revert patch accidentily created on the wrong sandbox\n\nFrom-SVN: r279973", "tree": {"sha": "7faa959c71a9709981d28d0f4a489693da621246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7faa959c71a9709981d28d0f4a489693da621246"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7010bcd1c80e2a89f43c064ba21289df8c67a84c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7010bcd1c80e2a89f43c064ba21289df8c67a84c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7010bcd1c80e2a89f43c064ba21289df8c67a84c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7010bcd1c80e2a89f43c064ba21289df8c67a84c/comments", "author": null, "committer": null, "parents": [{"sha": "56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56eb4c70ea7a78a53fbb6e7597e74e7ba04d4570"}], "stats": {"total": 86, "additions": 0, "deletions": 86}, "files": [{"sha": "127927d9583a418367f854e51a80ea5afc0150ec", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7010bcd1c80e2a89f43c064ba21289df8c67a84c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7010bcd1c80e2a89f43c064ba21289df8c67a84c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7010bcd1c80e2a89f43c064ba21289df8c67a84c", "patch": "@@ -6753,90 +6753,6 @@ hard_reg_and_mode_to_addr_mask (rtx reg, machine_mode mode)\n   return addr_mask;\n }\n \n-/* Helper function to adjust a vector address (ADDR) to point to a given\n-   element offset (ELEMENT_OFFSET).  This function handles updating addresses\n-   that use PLUS (i.e. a D_FORM address with an integer constant or an X_FORM\n-   address adding two registers).  If we can't update the address directly, we\n-   can use the base register temporary (BASE_TMP) to form a valid address.  The\n-   mode of the element within the vector is SCALAR_MODE.  */\n-\n-rtx\n-adjust_vec_address_plus (rtx addr,\n-\t\t\t rtx element_offset,\n-\t\t\t rtx base_tmp,\n-\t\t\t machine_mode scalar_mode)\n-{\n-  gcc_assert (GET_CODE (addr) == PLUS);\n-\n-  rtx new_addr = NULL;\n-  rtx op0 = XEXP (addr, 0);\n-  rtx op1 = XEXP (addr, 1);\n-  rtx insn;\n-\n-  gcc_assert (REG_P (op0) || SUBREG_P (op0));\n-\n-  if (CONST_INT_P (op1) && CONST_INT_P (element_offset))\n-    {\n-      HOST_WIDE_INT offset = INTVAL (op1) + INTVAL (element_offset);\n-      rtx offset_rtx = GEN_INT (offset);\n-      new_addr = gen_rtx_PLUS (Pmode, op0, offset_rtx);\n-\n-      enum insn_form iform = address_to_insn_form (new_addr, scalar_mode,\n-\t\t\t\t\t\t   NON_PREFIXED_DEFAULT);\n-\n-      /* If the address isn't valid, change REG+OFFSET into REG+REG.  */\n-      if (iform == INSN_FORM_BAD)\n-\t{\n-\t  /* The offset either overflowed or it might not be a valid DS/DQ\n-\t     offset, move offset to the temporary (which will likely be split),\n-\t     and do X-FORM addressing.  */\n-\t  emit_move_insn (base_tmp, offset_rtx);\n-\t  new_addr = gen_rtx_PLUS (Pmode, op0, base_tmp);\n-\t}\n-    }\n-\n-  else\n-    {\n-      bool op1_reg_p = (REG_P (op1) || SUBREG_P (op1));\n-      bool ele_reg_p = (REG_P (element_offset) || SUBREG_P (element_offset));\n-\n-      /* Note, ADDI requires the register being added to be a base\n-\t register.  If the register was R0, load it up into the temporary\n-\t and do the add.  */\n-      if (op1_reg_p\n-\t  && (ele_reg_p || reg_or_subregno (op1) != FIRST_GPR_REGNO))\n-\t{\n-\t  insn = gen_add3_insn (base_tmp, op1, element_offset);\n-\t  gcc_assert (insn != NULL_RTX);\n-\t  emit_insn (insn);\n-\t}\n-\n-      else if (ele_reg_p\n-\t       && reg_or_subregno (element_offset) != FIRST_GPR_REGNO)\n-\t{\n-\t  insn = gen_add3_insn (base_tmp, element_offset, op1);\n-\t  gcc_assert (insn != NULL_RTX);\n-\t  emit_insn (insn);\n-\t}\n-\n-      /* Make sure we don't overwrite the temporary if the element being\n-\t extracted is variable, and we've put the offset into base_tmp\n-\t previously.  */\n-      else if (reg_mentioned_p (base_tmp, element_offset))\n-\temit_insn (gen_add2_insn (base_tmp, op1));\n-\n-      else\n-\t{\n-\t  emit_move_insn (base_tmp, op1);\n-\t  emit_insn (gen_add2_insn (base_tmp, element_offset));\n-\t}\n-\n-      new_addr = gen_rtx_PLUS (Pmode, op0, base_tmp);\n-    }\n-\n-  return new_addr;\n-}\n-\n /* Adjust a memory address (MEM) of a vector type to point to a scalar field\n    within the vector (ELEMENT) with a mode (SCALAR_MODE).  Use a base register\n    temporary (BASE_TMP) to fixup the address.  Return the new memory address\n@@ -6982,8 +6898,6 @@ rs6000_adjust_vec_address (rtx scalar_reg,\n \tvalid_addr_p = (addr_mask & RELOAD_REG_OFFSET) != 0;\n     }\n \n-  /* An address that is a single register is always valid for either indexed or\n-     offsettable loads.  */\n   else if (REG_P (new_addr) || SUBREG_P (new_addr))\n     valid_addr_p = true;\n "}]}