{"sha": "3eca1bd776507834a9092ee8c871e91e78ef59b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VjYTFiZDc3NjUwNzgzNGE5MDkyZWU4Yzg3MWU5MWU3OGVmNTliOA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-06-28T00:52:35Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-06-28T00:52:35Z"}, "message": "re PR tree-optimization/21959 (vrp miscompiles Ada front-end, drops loop exit test in well-defined wrap-around circumstances)\n\n\n\tPR 21959\n\t* tree-ssa-loop-niter.c (scev_probably_wraps_p): Handle type\n\tcasts between unsigned and signed types with different size\n\tor precision.\n\ntestsuite/ChangeLog\n\n\tPR 21959\n\t* gcc.dg/tree-ssa/pr21959.c: New test.\n\nFrom-SVN: r101365", "tree": {"sha": "6ac1b1fa0c3b8ade5a237d12fe531f37f0172b03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ac1b1fa0c3b8ade5a237d12fe531f37f0172b03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3eca1bd776507834a9092ee8c871e91e78ef59b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eca1bd776507834a9092ee8c871e91e78ef59b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eca1bd776507834a9092ee8c871e91e78ef59b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eca1bd776507834a9092ee8c871e91e78ef59b8/comments", "author": null, "committer": null, "parents": [{"sha": "5ab2b3e44e3a264663c716a85cd8d7566043ac7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab2b3e44e3a264663c716a85cd8d7566043ac7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab2b3e44e3a264663c716a85cd8d7566043ac7c"}], "stats": {"total": 67, "additions": 67, "deletions": 0}, "files": [{"sha": "d8fdb6dbd376654573e8fecafafad8e183870495", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eca1bd776507834a9092ee8c871e91e78ef59b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eca1bd776507834a9092ee8c871e91e78ef59b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3eca1bd776507834a9092ee8c871e91e78ef59b8", "patch": "@@ -1,3 +1,10 @@\n+2005-06-27  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 21959\n+\t* tree-ssa-loop-niter.c (scev_probably_wraps_p): Handle type\n+\tcasts between unsigned and signed types with different size\n+\tor precision.\n+\n 2005-06-28  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-optimize.c (exercute_free_datastructures):"}, {"sha": "1fab590a607f87a5323f4a06ed84ec7a77e5c0f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eca1bd776507834a9092ee8c871e91e78ef59b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eca1bd776507834a9092ee8c871e91e78ef59b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3eca1bd776507834a9092ee8c871e91e78ef59b8", "patch": "@@ -1,3 +1,8 @@\n+2005-06-27  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 21959\n+\t* gcc.dg/tree-ssa/pr21959.c: New test.\n+\n 2005-06-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/builtins/lib/main.c (abort): Add prototype."}, {"sha": "7b83b0352716792dbd02b3c12115a4394856f2a5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21959.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eca1bd776507834a9092ee8c871e91e78ef59b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21959.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eca1bd776507834a9092ee8c871e91e78ef59b8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21959.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21959.c?ref=3eca1bd776507834a9092ee8c871e91e78ef59b8", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp\" } */\n+\n+unsigned char c[0xFF];\n+void f(void)\n+{\n+  unsigned char i;\n+  c[128] = 128;\n+  i = 0;\n+  while (1)\n+  {\n+    /* This predicate should not be folded out.  */\n+    if (((signed char) i) < 0) break;\n+    c[i] = ' ';\n+    i++;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate \" 0 \"vrp\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp\" } } */"}, {"sha": "c99aa386be33032770bda131c519fc698c0a4acf", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eca1bd776507834a9092ee8c871e91e78ef59b8/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eca1bd776507834a9092ee8c871e91e78ef59b8/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=3eca1bd776507834a9092ee8c871e91e78ef59b8", "patch": "@@ -1649,6 +1649,41 @@ scev_probably_wraps_p (tree type, tree base, tree step,\n       return true;\n     }\n \n+  /* If AT_STMT represents a cast operation, we may not be able to\n+     take advantage of the undefinedness of signed type evolutions.\n+     See PR 21959 for a test case.  Essentially, given a cast\n+     operation\n+     \t\tunsigned char i;\n+\t\tsigned char i.0;\n+\t\t...\n+     \t\ti.0_6 = (signed char) i_2;\n+\t\tif (i.0_6 < 0)\n+\t\t  ...\n+\n+     where i_2 and i.0_6 have the scev {0, +, 1}, we would consider\n+     i_2 to wrap around, but not i.0_6, because it is of a signed\n+     type.  This causes VRP to erroneously fold the predicate above\n+     because it thinks that i.0_6 cannot be negative.  */\n+  if (TREE_CODE (at_stmt) == MODIFY_EXPR)\n+    {\n+      tree rhs = TREE_OPERAND (at_stmt, 1);\n+      tree outer_t = TREE_TYPE (rhs);\n+\n+      if (!TYPE_UNSIGNED (outer_t)\n+\t  && (TREE_CODE (rhs) == NOP_EXPR || TREE_CODE (rhs) == CONVERT_EXPR))\n+\t{\n+\t  tree inner_t = TREE_TYPE (TREE_OPERAND (rhs, 0));\n+\n+\t  /* If the inner type is unsigned and its size and/or\n+\t     precision are smaller to that of the outer type, then the\n+\t     expression may wrap around.  */\n+\t  if (TYPE_UNSIGNED (inner_t)\n+\t      && (TYPE_SIZE (inner_t) <= TYPE_SIZE (outer_t)\n+\t\t  || TYPE_PRECISION (inner_t) <= TYPE_PRECISION (outer_t)))\n+\t    return true;\n+\t}\n+    }\n+\n   /* After having set INIT_IS_MAX, we can return false: when not using\n      wrapping arithmetic, signed types don't wrap.  */\n   if (!flag_wrapv && !TYPE_UNSIGNED (type))"}]}