{"sha": "a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThkZTMwMDJmMTllYjA5Y2Y5NWQzNmYxYTk3ZTMwZjIzNGRmN2Q5ZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-09-22T07:46:07Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-09-22T07:46:07Z"}, "message": "interface.c (check_dtio_interface1): Introduce errors for alternate returns and incorrect numbers of arguments.\n\n2016-09-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* interface.c (check_dtio_interface1): Introduce errors for\n\talternate returns and incorrect numbers of arguments.\n\t(gfc_find_specific_dtio_proc): Return cleanly if the derived\n\ttype either doesn't exist or has no namespace.\n\n2016-09-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/dtio_11.f90: Correct for changed error messages.\n\t* gfortran.dg/dtio_13.f90: New test.\n\nFrom-SVN: r240342", "tree": {"sha": "20c8a2260ebf12f29bf9cbce0b762dbf8b19f6dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20c8a2260ebf12f29bf9cbce0b762dbf8b19f6dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/comments", "author": null, "committer": null, "parents": [{"sha": "39abef62a17740d59f4bab506c07867cffa7da10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39abef62a17740d59f4bab506c07867cffa7da10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39abef62a17740d59f4bab506c07867cffa7da10"}], "stats": {"total": 213, "additions": 209, "deletions": 4}, "files": [{"sha": "9f146aa73879ab05a536cc636355de165bf4e134", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "patch": "@@ -1,3 +1,10 @@\n+2016-09-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* interface.c (check_dtio_interface1): Introduce errors for\n+\talternate returns and incorrect numbers of arguments.\n+\t(gfc_find_specific_dtio_proc): Return cleanly if the derived\n+\ttype either doesn't exist or has no namespace.\n+\n 2016-09-21  Louis Krupp  <louis.krupp@zoho.com>\n \n \tPR fortran/66107"}, {"sha": "09f5a539e7c4c2a8f0093e135b511837a40639bf", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "patch": "@@ -4629,7 +4629,7 @@ check_dtio_interface1 (gfc_symbol *derived, gfc_symtree *tb_io_st,\n \n       for (intr = tb_io_st->n.sym->generic; intr; intr = intr->next)\n \t{\n-\t  if (intr->sym && intr->sym->formal\n+\t  if (intr->sym && intr->sym->formal && intr->sym->formal->sym\n \t      && ((intr->sym->formal->sym->ts.type == BT_CLASS\n \t           && CLASS_DATA (intr->sym->formal->sym)->ts.u.derived\n \t\t\t\t\t\t\t     == derived)\n@@ -4639,6 +4639,12 @@ check_dtio_interface1 (gfc_symbol *derived, gfc_symtree *tb_io_st,\n \t      dtio_sub = intr->sym;\n \t      break;\n \t    }\n+\t  else if (intr->sym && intr->sym->formal && !intr->sym->formal->sym)\n+\t    {\n+\t      gfc_error (\"Alternate return at %L is not permitted in a DTIO \"\n+\t\t\t \"procedure\", &intr->sym->declared_at);\n+\t      return;\n+\t    }\n \t}\n \n       if (dtio_sub == NULL)\n@@ -4647,16 +4653,43 @@ check_dtio_interface1 (gfc_symbol *derived, gfc_symtree *tb_io_st,\n \n   gcc_assert (dtio_sub);\n   if (!dtio_sub->attr.subroutine)\n-    gfc_error (\"DTIO procedure %s at %L must be a subroutine\",\n+    gfc_error (\"DTIO procedure '%s' at %L must be a subroutine\",\n \t       dtio_sub->name, &dtio_sub->declared_at);\n \n+  arg_num = 0;\n+  for (formal = dtio_sub->formal; formal; formal = formal->next)\n+    arg_num++;\n+\n+  if (arg_num < (formatted ? 6 : 4))\n+    {\n+      gfc_error (\"Too few dummy arguments in DTIO procedure '%s' at %L\",\n+\t\t dtio_sub->name, &dtio_sub->declared_at);\n+      return;\n+    }\n+\n+  if (arg_num > (formatted ? 6 : 4))\n+    {\n+      gfc_error (\"Too many dummy arguments in DTIO procedure '%s' at %L\",\n+\t\t dtio_sub->name, &dtio_sub->declared_at);\n+      return;\n+    }\n+\n+\n   /* Now go through the formal arglist.  */\n   arg_num = 1;\n   for (formal = dtio_sub->formal; formal; formal = formal->next, arg_num++)\n     {\n       if (!formatted && arg_num == 3)\n \targ_num = 5;\n       fsym = formal->sym;\n+\n+      if (fsym == NULL)\n+\t{\n+\t  gfc_error (\"Alternate return at %L is not permitted in a DTIO \"\n+\t\t     \"procedure\", &dtio_sub->declared_at);\n+\t  return;\n+\t}\n+\n       switch (arg_num)\n \t{\n \tcase(1):\t\t\t/* DTV  */\n@@ -4823,6 +4856,9 @@ gfc_find_specific_dtio_proc (gfc_symbol *derived, bool write, bool formatted)\n   for (extended = derived; extended;\n        extended = gfc_get_derived_super_type (extended))\n     {\n+      if (extended == NULL || extended->ns == NULL)\n+\treturn NULL;\n+\n       if (formatted == true)\n \t{\n \t  if (write == true)"}, {"sha": "c354612164c109c72b39451116a3149f1bb796b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "patch": "@@ -1,3 +1,8 @@\n+2016-09-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/dtio_11.f90: Correct for changed error messages.\n+\t* gfortran.dg/dtio_13.f90: New test.\n+\n 2016-09-21  Louis Krupp  <louis.krupp@zoho.com>\n \n \tPR fortran/66107"}, {"sha": "1f148c3b8960116e7dec42cde6aca39f22344d58", "filename": "gcc/testsuite/gfortran.dg/dtio_11.f90", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_11.f90?ref=a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "patch": "@@ -25,15 +25,28 @@ subroutine s(x)\n    end\n end\n \n-! PR77533 comment #1 - gave warning that\n+! PR77533 comment #1 - gave error 'KIND = 0'\n module m3\n    type t\n    contains\n       procedure :: s ! { dg-error \"Non-polymorphic passed-object\" }\n       generic :: write(formatted) => s\n    end type\n contains\n-   subroutine s(x) ! { dg-error \"must be of type CLASS\" }\n+   subroutine s(x) ! { dg-error \"Too few dummy arguments\" }\n       class(t), intent(in) : x ! { dg-error \"Invalid character in name\" }\n    end\n end\n+\n+! PR77534\n+module m4\n+   type t\n+   end type\n+   interface read(unformatted)\n+      module procedure s\n+   end interface\n+contains\n+   subroutine s(dtv) ! { dg-error \"Too few dummy arguments\" }\n+      type(t), intent(inout) :: dtv\n+   end\n+end"}, {"sha": "9b907201afcf71be5e1f7f619c3f885f32ae1c73", "filename": "gcc/testsuite/gfortran.dg/dtio_13.f90", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8de3002f19eb09cf95d36f1a97e30f234df7d9e/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_13.f90?ref=a8de3002f19eb09cf95d36f1a97e30f234df7d9e", "patch": "@@ -0,0 +1,144 @@\n+! { dg-do compile }\n+! { dg-options -std=legacy }\n+!\n+! Test elimination of various segfaults and ICEs on error recovery.\n+!\n+! Contributed by Gerhard Steinmetz  <gerhard.steinmetz.fortran@t-online.de>\n+!\n+module m1\n+   type t\n+   end type\n+   interface write(formatted)\n+      module procedure s\n+   end interface\n+contains\n+   subroutine s(dtv,unit,iotype,vlist,extra,iostat,iomsg) ! { dg-error \"Too many dummy arguments\" }\n+      class(t), intent(in) :: dtv\n+      integer, intent(in) :: unit\n+      character(len=*), intent(in) :: iotype\n+      integer, intent(in) :: vlist(:)\n+      integer, intent(out) :: iostat\n+      character(len=*), intent(inout) :: iomsg\n+   end\n+end\n+\n+module m2\n+   type t\n+   end type\n+   interface read(formatted)\n+      module procedure s\n+   end interface\n+contains\n+   subroutine s(dtv,unit,iotype,vlist,iostat,iomsg,extra) ! { dg-error \"Too many dummy arguments\" }\n+      class(t), intent(inout) :: dtv\n+      integer, intent(in) :: unit\n+      character(len=*), intent(in) :: iotype\n+      integer, intent(in) :: vlist(:)\n+      integer, intent(out) :: iostat\n+      character(len=*), intent(inout) :: iomsg\n+   end\n+end\n+\n+module m3\n+   type t\n+   end type\n+   interface read(formatted)\n+      module procedure s\n+   end interface\n+contains\n+   subroutine s(dtv,extra,unit,iotype,vlist,iostat,iomsg) ! { dg-error \"Too many dummy arguments\" }\n+      class(t), intent(inout) :: dtv\n+      integer, intent(in) :: unit\n+      character(len=*), intent(in) :: iotype\n+      integer, intent(in) :: vlist(:)\n+      integer, intent(out) :: iostat\n+      character(len=*), intent(inout) :: iomsg\n+   end\n+end\n+\n+module m4\n+   type t\n+   end type\n+   interface write(unformatted)\n+      module procedure s\n+   end interface\n+contains\n+   subroutine s(*) ! { dg-error \"Alternate return\" }\n+   end\n+end\n+\n+module m5\n+   type t\n+   contains\n+      procedure :: s\n+      generic :: write(unformatted) => s\n+   end type\n+contains\n+   subroutine s(dtv, *) ! { dg-error \"Too few dummy arguments\" }\n+      class(t), intent(out) :: dtv\n+   end\n+end\n+\n+module m6\n+   type t\n+      character(len=20) :: name\n+      integer(4) :: age\n+   contains\n+      procedure :: pruf\n+      generic :: read(unformatted) => pruf\n+   end type\n+contains\n+   subroutine pruf (dtv,unit,*,iomsg) ! { dg-error \"Alternate return\" }\n+      class(t), intent(inout) :: dtv\n+      integer, intent(in) :: unit\n+      character(len=*), intent(inout) :: iomsg\n+      write (unit=unit, iostat=iostat, iomsg=iomsg) dtv%name, dtv%age\n+   end\n+end\n+\n+module m7\n+   type t\n+      character(len=20) :: name\n+      integer(4) :: age\n+   contains\n+      procedure :: pruf\n+      generic :: read(unformatted) => pruf\n+   end type\n+contains\n+   subroutine pruf (dtv,unit,iostat) ! { dg-error \"Too few dummy arguments\" }\n+      class(t), intent(inout) :: dtv\n+      integer, intent(in) :: unit\n+      integer, intent(out) :: iostat\n+      character(len=1) :: iomsg\n+      write (unit=unit, iostat=iostat, iomsg=iomsg) dtv%name, dtv%age\n+   end\n+end\n+\n+module m\n+   type t\n+      character(len=20) :: name\n+      integer(4) :: age\n+   contains\n+      procedure :: pruf\n+      generic :: read(unformatted) => pruf\n+   end type\n+contains\n+   subroutine pruf (dtv,unit,iostat,iomsg)\n+      class(t), intent(inout) :: dtv\n+      integer, intent(in) :: unit\n+      integer, intent(out) :: iostat\n+      character(len=*), intent(inout) :: iomsg\n+      write (unit=unit, iostat=iostat, iomsg=iomsg) dtv%name, dtv%age\n+   end\n+end\n+program test\n+   use m\n+   character(3) :: a, b\n+   class(t) :: chairman ! { dg-error \"must be dummy, allocatable or pointer\" }\n+   open (unit=71, file='myunformatted_data.dat', form='unformatted')\n+! The following error is spurious and is eliminated if previous error is corrected.\n+! TODO Although better than an ICE, fix me.\n+   read (71) a, chairman, b ! { dg-error \"cannot be polymorphic\" }\n+   close (unit=71)\n+end\n+"}]}