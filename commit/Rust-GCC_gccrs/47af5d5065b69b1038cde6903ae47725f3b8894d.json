{"sha": "47af5d5065b69b1038cde6903ae47725f3b8894d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdhZjVkNTA2NWI2OWIxMDM4Y2RlNjkwM2FlNDc3MjVmM2I4ODk0ZA==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-12-30T03:37:29Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-12-30T03:37:29Z"}, "message": "(bit complement): Constrain inputs and outputs to match,\n\ninstead of using match_dup.\n(zero_extract test): Reenable with separate patterns to match\nQImode and SImode zero_extract.\n\nFrom-SVN: r2984", "tree": {"sha": "384586059f76e0cd1c25e20adaf534acbbdbdc8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/384586059f76e0cd1c25e20adaf534acbbdbdc8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47af5d5065b69b1038cde6903ae47725f3b8894d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47af5d5065b69b1038cde6903ae47725f3b8894d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47af5d5065b69b1038cde6903ae47725f3b8894d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47af5d5065b69b1038cde6903ae47725f3b8894d/comments", "author": null, "committer": null, "parents": [{"sha": "924d959ea245009194629a11da4ffefaa4e02603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924d959ea245009194629a11da4ffefaa4e02603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/924d959ea245009194629a11da4ffefaa4e02603"}], "stats": {"total": 81, "additions": 53, "deletions": 28}, "files": [{"sha": "ccd4583cb6902af37434686cd95ee65eb10a55cd", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47af5d5065b69b1038cde6903ae47725f3b8894d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47af5d5065b69b1038cde6903ae47725f3b8894d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=47af5d5065b69b1038cde6903ae47725f3b8894d", "patch": "@@ -2928,10 +2928,10 @@\n ;; Bit complement.  See comments on previous pattern.\n ;; ??? Is this really worthwhile?\n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"+rm\")\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n \t(xor:SI (ashift:SI (const_int 1)\n \t\t\t   (match_operand:SI 1 \"general_operand\" \"r\"))\n-\t\t(match_dup 0)))]\n+\t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n   \"! TARGET_486 && GET_CODE (operands[1]) != CONST_INT\"\n   \"*\n {\n@@ -2940,22 +2940,18 @@\n   return AS2 (btc%L0,%1,%0);\n }\")\n \n-/* ??? This works, but that SUBREG looks dangerous.\n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"+rm\")\n-\t(xor:HI (subreg:HI\n-\t\t (ashift:SI (const_int 1)\n-\t\t\t    (sign_extend:SI\n-\t\t\t     (match_operand:HI 1 \"nonimmediate_operand\" \"r\"))) 0)\n-\t\t(match_dup 0)))]\n-  \"! TARGET_486\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n+\t(xor:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(ashift:SI (const_int 1)\n+\t\t\t   (match_operand:SI 2 \"general_operand\" \"r\"))))]\n+  \"! TARGET_486 && GET_CODE (operands[2]) != CONST_INT\"\n   \"*\n {\n   CC_STATUS_INIT;\n \n-  return AS2 (btc%W0,%1,%0);\n+  return AS2 (btc%L0,%2,%0);\n }\")\n-*/\n \f\n ;; Recognizers for bit-test instructions.\n \n@@ -2967,16 +2963,56 @@\n ;; don't allow a MEM in the operand predicate without allowing it in the\n ;; constraint.\n \n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"r\")))]\n+  \"GET_CODE (operands[1]) != CONST_INT\"\n+  \"*\n+{\n+  cc_status.flags |= CC_Z_IN_NOT_C;\n+  return AS2 (bt%L0,%1,%0);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"*\n+{\n+  unsigned int mask;\n+\n+  mask = ((1 << INTVAL (operands[1])) - 1) << INTVAL (operands[2]);\n+  operands[1] = GEN_INT (mask);\n+\n+  if (QI_REG_P (operands[0]))\n+    {\n+      if ((mask & ~0xff) == 0)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  return AS2 (test%B0,%1,%b0);\n+\t}\n+\n+      if ((mask & ~0xff00) == 0)\n+        {\n+\t  cc_status.flags |= CC_NOT_NEGATIVE;\n+\t  operands[1] = GEN_INT (mask >> 8);\n+\t  return AS2 (test%B0,%1,%h0);\n+\t}\n+    }\n+\n+  return AS2 (test%L0,%1,%0);\n+}\")\n+\n ;; ??? All bets are off if operand 0 is a volatile MEM reference.\n+;; The CPU may access unspecified bytes around the actual target byte.\n \n-/*\n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand 0 \"general_operand\" \"rm\")\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"general_operand\" \"rm\")\n \t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT\n-   && GET_MODE_SIZE (GET_MODE (operands[0])) <= 4\n-   && (GET_CODE (operands[0]) != MEM || ! MEM_VOLATILE_P (operands[0]))\"\n+  \"GET_CODE (operands[0]) != MEM || ! MEM_VOLATILE_P (operands[0])\"\n   \"*\n {\n   unsigned int mask;\n@@ -3028,17 +3064,6 @@\n \n   return AS2 (test%L1,%0,%1);\n }\")\n-*/\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"r\")))]\n-  \"GET_CODE (operands[1]) != CONST_INT\"\n-  \"*\n-{\n-  cc_status.flags |= CC_Z_IN_NOT_C;\n-  return AS2 (bt%L0,%1,%0);\n-}\")\n \f\n ;; Store-flag instructions.\n "}]}