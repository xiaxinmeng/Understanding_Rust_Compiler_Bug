{"sha": "7d8272552fe9cf00fdebeb04145e7332a9589b9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4MjcyNTUyZmU5Y2YwMGZkZWJlYjA0MTQ1ZTczMzJhOTU4OWI5YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T10:41:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T10:41:57Z"}, "message": "[multiple changes]\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* a-comlin.ads, a-comlin.adb (Argument): Move the constraint\n\tcheck back to the body, because SPARK is not yet ready for\n\t\"or else raise Constraint_Error\".\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call_Helper): Replace call to null\n\tprocedure by a single null statement, after evaluating the\n\tactuals that require it.\n\n2017-09-06  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_aggr.adb (Backend_Processing_Possible.Component_Check):\n\tGenerating C code improve the code that checks the use of nested\n\taggregates to initialize object declarations.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch3.adb (Derived_Type_Declaration): Detect\n\tviolations of new rule SPARK RM 3.4(1).  Also refactor existing\n\tcheck to use the new function Find_Partial_View.\n\n2017-09-06  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb: gnat ls -V -P... invokes gprls -V -P...\tThe code\n\tfrom the Prj hierarchy has been removed from the GNAT driver.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_type.adb (Interface_Present_In_Ancestor): Within an\n\texpression function, or within a spec expression (default value,\n\tetc) a reference to an incomplete type is legal: legality of\n\tthe operation will be checked when some related entity (type,\n\tobject or subprogram) is frozen.\n\nFrom-SVN: r251776", "tree": {"sha": "2f123430542ffbb783a77ede543ded15ef1d101f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f123430542ffbb783a77ede543ded15ef1d101f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d8272552fe9cf00fdebeb04145e7332a9589b9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8272552fe9cf00fdebeb04145e7332a9589b9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8272552fe9cf00fdebeb04145e7332a9589b9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8272552fe9cf00fdebeb04145e7332a9589b9a/comments", "author": null, "committer": null, "parents": [{"sha": "a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a316b3fcd05624ce0aadca3478f6a3c7b494c2d0"}], "stats": {"total": 782, "additions": 153, "deletions": 629}, "files": [{"sha": "7a146be789c4a37b158a78e301ab90591d09b944", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7d8272552fe9cf00fdebeb04145e7332a9589b9a", "patch": "@@ -1,3 +1,40 @@\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* a-comlin.ads, a-comlin.adb (Argument): Move the constraint\n+\tcheck back to the body, because SPARK is not yet ready for\n+\t\"or else raise Constraint_Error\".\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call_Helper): Replace call to null\n+\tprocedure by a single null statement, after evaluating the\n+\tactuals that require it.\n+\n+2017-09-06  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_aggr.adb (Backend_Processing_Possible.Component_Check):\n+\tGenerating C code improve the code that checks the use of nested\n+\taggregates to initialize object declarations.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch3.adb (Derived_Type_Declaration): Detect\n+\tviolations of new rule SPARK RM 3.4(1).  Also refactor existing\n+\tcheck to use the new function Find_Partial_View.\n+\n+2017-09-06  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb: gnat ls -V -P... invokes gprls -V -P...\tThe code\n+\tfrom the Prj hierarchy has been removed from the GNAT driver.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_type.adb (Interface_Present_In_Ancestor): Within an\n+\texpression function, or within a spec expression (default value,\n+\tetc) a reference to an incomplete type is legal: legality of\n+\tthe operation will be checked when some related entity (type,\n+\tobject or subprogram) is frozen.\n+\n 2017-09-06  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_ch5.adb, s-diinio.ads, sem_ch4.adb, s-diflio.ads: Minor spelling"}, {"sha": "49caca5abaffd5a024d6020abf436f201bafb152", "filename": "gcc/ada/a-comlin.adb", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fa-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fa-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comlin.adb?ref=7d8272552fe9cf00fdebeb04145e7332a9589b9a", "patch": "@@ -56,12 +56,19 @@ package body Ada.Command_Line is\n    --------------\n \n    function Argument (Number : Positive) return String is\n-      Num : constant Positive :=\n-        (if Remove_Args = null then Number else Remove_Args (Number));\n-      Arg : aliased String (1 .. Len_Arg (Num));\n    begin\n-      Fill_Arg (Arg'Address, Num);\n-      return Arg;\n+      if Number > Argument_Count then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Num : constant Positive :=\n+           (if Remove_Args = null then Number else Remove_Args (Number));\n+         Arg : aliased String (1 .. Len_Arg (Num));\n+      begin\n+         Fill_Arg (Arg'Address, Num);\n+         return Arg;\n+      end;\n    end Argument;\n \n    --------------------"}, {"sha": "c4eeceffd2fe7f7f625339f0ff59465f721733a2", "filename": "gcc/ada/a-comlin.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fa-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fa-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comlin.ads?ref=7d8272552fe9cf00fdebeb04145e7332a9589b9a", "patch": "@@ -43,8 +43,14 @@ package Ada.Command_Line is\n    --\n    --  In GNAT: Corresponds to (argc - 1) in C.\n \n+   pragma Assertion_Policy (Pre => Ignore);\n+   --  We need to ignore the precondition of Argument, below, so that we don't\n+   --  raise Assertion_Error. The body raises Constraint_Error. It would be\n+   --  cleaner to add \"or else raise Constraint_Error\" to the precondition, but\n+   --  SPARK does not yet support raise expressions.\n+\n    function Argument (Number : Positive) return String with\n-      Pre => Number <= Argument_Count or else raise Constraint_Error;\n+      Pre => Number <= Argument_Count;\n    --  If the external execution environment supports passing arguments to\n    --  a program, then Argument returns an implementation-defined value\n    --  corresponding to the argument at relative position Number. If Number"}, {"sha": "38d233b2973ae3da92bc3b49acf3957a558f55b9", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7d8272552fe9cf00fdebeb04145e7332a9589b9a", "patch": "@@ -644,15 +644,27 @@ package body Exp_Aggr is\n             return False;\n          end if;\n \n-         --  Checks 11: (part of an object declaration)\n+         --  Checks 11: The C code generator cannot handle aggregates that\n+         --  are not part of an object declaration.\n \n-         if Modify_Tree_For_C\n-           and then Nkind (Parent (N)) /= N_Object_Declaration\n-           and then\n-             (Nkind (Parent (N)) /= N_Qualified_Expression\n-               or else Nkind (Parent (Parent (N))) /= N_Object_Declaration)\n-         then\n-            return False;\n+         if Modify_Tree_For_C then\n+            declare\n+               Par : Node_Id := Parent (N);\n+\n+            begin\n+               --  Skip enclosing nested aggregates and their qualified\n+               --  expressions\n+\n+               while Nkind (Par) = N_Aggregate\n+                 or else Nkind (Par) = N_Qualified_Expression\n+               loop\n+                  Par := Parent (Par);\n+               end loop;\n+\n+               if Nkind (Par) /= N_Object_Declaration then\n+                  return False;\n+               end if;\n+            end;\n          end if;\n \n          --  Checks on components"}, {"sha": "55831e48f2964f783ab5086d31e96a208d1149cf", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=7d8272552fe9cf00fdebeb04145e7332a9589b9a", "patch": "@@ -3951,6 +3951,20 @@ package body Exp_Ch6 is\n               Unchecked_Convert_To\n                 (RTE (RE_Address), Relocate_Node (First_Actual (Call_Node))));\n             return;\n+\n+         --  A call to a null procedure is replaced by a null statement, but\n+         --  we are not allowed to ignore possible side effects of the call,\n+         --  so we make sure that actuals are evaluated.\n+\n+         elsif Is_Null_Procedure (Subp) then\n+            Actual := First_Actual (Call_Node);\n+            while Present (Actual) loop\n+               Remove_Side_Effects (Actual);\n+               Next_Actual (Actual);\n+            end loop;\n+\n+            Rewrite (Call_Node, Make_Null_Statement (Loc));\n+            return;\n          end if;\n \n          --  Handle inlining. No action needed if the subprogram is not inlined"}, {"sha": "e5df7bbead015795347b60b8ab877ba27ffb013c", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 4, "deletions": 605, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=7d8272552fe9cf00fdebeb04145e7332a9589b9a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,33 +23,18 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Csets;\n with Gnatvsn;\n-with Makeutl;  use Makeutl;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n-with Prj;      use Prj;\n-with Prj.Env;\n-with Prj.Ext;  use Prj.Ext;\n-with Prj.Pars;\n-with Prj.Tree; use Prj.Tree;\n-with Prj.Util; use Prj.Util;\n-with Sdefault;\n-with Sinput.P;\n-with Snames;   use Snames;\n-with Stringt;\n with Switch;   use Switch;\n with Table;\n-with Tempdir;\n-with Types;    use Types;\n \n with Ada.Characters.Handling; use Ada.Characters.Handling;\n with Ada.Command_Line;        use Ada.Command_Line;\n with Ada.Text_IO;             use Ada.Text_IO;\n \n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n procedure GNATCmd is\n@@ -97,25 +82,6 @@ procedure GNATCmd is\n       Pp    => Pretty);\n    --  Mapping of alternate commands to commands\n \n-   Call_GPR_Tool : Boolean := False;\n-   --  True when a GPR tool should be called, if available\n-\n-   Project_Node_Tree : Project_Node_Tree_Ref;\n-   Project_File      : String_Access;\n-   Project           : Prj.Project_Id;\n-   Current_Verbosity : Prj.Verbosity := Prj.Default;\n-   Tool_Package_Name : Name_Id       := No_Name;\n-\n-   Project_Tree : constant Project_Tree_Ref :=\n-                    new Project_Tree_Data (Is_Root_Tree => True);\n-   --  The project tree\n-\n-   All_Projects : Boolean := False;\n-\n-   Temp_File_Name : Path_Name_Type := No_Path;\n-   --  The name of the temporary text file to put a list of source/object\n-   --  files to pass to a tool.\n-\n    package First_Switches is new Table.Table\n      (Table_Component_Type => String_Access,\n       Table_Index_Type     => Integer,\n@@ -256,178 +222,16 @@ procedure GNATCmd is\n          Unixsws  => null)\n      );\n \n-   subtype SA is String_Access;\n-\n-   Naming_String      : constant SA := new String'(\"naming\");\n-   Gnatls_String      : constant SA := new String'(\"gnatls\");\n-\n-   Packages_To_Check_By_Gnatls    : constant String_List_Access :=\n-     new String_List'((Naming_String, Gnatls_String));\n-\n-   Packages_To_Check : String_List_Access := Prj.All_Packages;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Check_Files;\n-   --  For GNAT LIST -V, check if a project file is specified, without any file\n-   --  arguments and without a switch -files=. If it is the case, invoke the\n-   --  GNAT tool with the proper list of files, derived from the sources of\n-   --  the project.\n-\n    procedure Output_Version;\n    --  Output the version of this program\n \n    procedure Usage;\n    --  Display usage\n \n-   -----------------\n-   -- Check_Files --\n-   -----------------\n-\n-   procedure Check_Files is\n-      Add_Sources : Boolean := True;\n-      Unit        : Prj.Unit_Index;\n-      Subunit     : Boolean := False;\n-      FD          : File_Descriptor := Invalid_FD;\n-      Status      : Integer;\n-      Success     : Boolean;\n-\n-      procedure Add_To_Response_File\n-        (File_Name  : String;\n-         Check_File : Boolean := True);\n-      --  Include the file name passed as parameter in the response file for\n-      --  the tool being called. If the response file can not be written then\n-      --  the file name is passed in the parameter list of the tool. If the\n-      --  Check_File parameter is True then the procedure verifies the\n-      --  existence of the file before adding it to the response file.\n-\n-      --------------------------\n-      -- Add_To_Response_File --\n-      --------------------------\n-\n-      procedure Add_To_Response_File\n-        (File_Name  : String;\n-         Check_File : Boolean := True)\n-      is\n-      begin\n-         Name_Len := 0;\n-\n-         Add_Str_To_Name_Buffer (File_Name);\n-\n-         if not Check_File or else\n-           Is_Regular_File (Name_Buffer (1 .. Name_Len))\n-         then\n-            if FD /= Invalid_FD then\n-               Name_Len := Name_Len + 1;\n-               Name_Buffer (Name_Len) := ASCII.LF;\n-\n-               Status := Write (FD, Name_Buffer (1)'Address, Name_Len);\n-\n-               if Status /= Name_Len then\n-                  Osint.Fail (\"disk full\");\n-               end if;\n-            else\n-               Last_Switches.Increment_Last;\n-               Last_Switches.Table (Last_Switches.Last) :=\n-                 new String'(File_Name);\n-            end if;\n-         end if;\n-      end Add_To_Response_File;\n-\n-   --  Start of processing for Check_Files\n-\n-   begin\n-      --  Check if there is at least one argument that is not a switch\n-\n-      for Index in 1 .. Last_Switches.Last loop\n-         if Last_Switches.Table (Index) (1) /= '-'\n-           or else (Last_Switches.Table (Index).all'Length > 7\n-                     and then Last_Switches.Table (Index) (1 .. 7) = \"-files=\")\n-         then\n-            Add_Sources := False;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      --  If all arguments are switches and there is no switch -files=, add the\n-      --  path names of all the sources of the main project.\n-\n-      if Add_Sources then\n-         Tempdir.Create_Temp_File (FD, Temp_File_Name);\n-         Record_Temp_File (Project_Tree.Shared, Temp_File_Name);\n-         Last_Switches.Increment_Last;\n-         Last_Switches.Table (Last_Switches.Last) :=\n-           new String'(\"-files=\" & Get_Name_String (Temp_File_Name));\n-\n-         Unit := Units_Htable.Get_First (Project_Tree.Units_HT);\n-         while Unit /= No_Unit_Index loop\n-\n-            --  We only need to put the library units, body or spec, but not\n-            --  the subunits.\n-\n-            if Unit.File_Names (Impl) /= null\n-              and then not Unit.File_Names (Impl).Locally_Removed\n-            then\n-               --  There is a body, check if it is for this project\n-\n-               if All_Projects\n-                 or else Unit.File_Names (Impl).Project = Project\n-               then\n-                  Subunit := False;\n-\n-                  if Unit.File_Names (Spec) = null\n-                    or else Unit.File_Names (Spec).Locally_Removed\n-                  then\n-                     --  We have a body with no spec: we need to check if\n-                     --  this is a subunit, because gnatls will complain\n-                     --  about subunits.\n-\n-                     declare\n-                        Src_Ind : constant Source_File_Index :=\n-                                    Sinput.P.Load_Project_File\n-                                      (Get_Name_String\n-                                         (Unit.File_Names (Impl).Path.Name));\n-                     begin\n-                        Subunit := Sinput.P.Source_File_Is_Subunit (Src_Ind);\n-                     end;\n-                  end if;\n-\n-                  if not Subunit then\n-                     Add_To_Response_File\n-                       (Get_Name_String (Unit.File_Names (Impl).Display_File),\n-                        Check_File => False);\n-                  end if;\n-               end if;\n-\n-            elsif Unit.File_Names (Spec) /= null\n-              and then not Unit.File_Names (Spec).Locally_Removed\n-            then\n-               --  We have a spec with no body. Check if it is for this project\n-\n-               if All_Projects\n-                 or else Unit.File_Names (Spec).Project = Project\n-               then\n-                  Add_To_Response_File\n-                    (Get_Name_String (Unit.File_Names (Spec).Display_File),\n-                     Check_File => False);\n-               end if;\n-            end if;\n-\n-            Unit := Units_Htable.Get_Next (Project_Tree.Units_HT);\n-         end loop;\n-\n-         if FD /= Invalid_FD then\n-            Close (FD, Success);\n-\n-            if not Success then\n-               Osint.Fail (\"disk full\");\n-            end if;\n-         end if;\n-      end if;\n-   end Check_Files;\n-\n    --------------------\n    -- Output_Version --\n    --------------------\n@@ -485,17 +289,6 @@ begin\n \n    --  Initializations\n \n-   Csets.Initialize;\n-   Snames.Initialize;\n-   Stringt.Initialize;\n-\n-   Prj.Tree.Initialize (Root_Environment, Gnatmake_Flags);\n-\n-   Project_Node_Tree := new Project_Node_Tree_Data;\n-   Prj.Tree.Initialize (Project_Node_Tree);\n-\n-   Prj.Initialize (Project_Tree);\n-\n    Last_Switches.Init;\n    Last_Switches.Set_Last (0);\n \n@@ -679,23 +472,17 @@ begin\n            or else The_Command = List\n          then\n             declare\n-               Switch            : String_Access;\n-               Dash_V_Switch     : constant String := \"-V\";\n-\n+               Switch        : String_Access;\n+               Call_GPR_Tool : Boolean := False;\n             begin\n                for J in 1 .. Last_Switches.Last loop\n                   Switch := Last_Switches.Table (J);\n \n-                  if The_Command = List and then Switch.all = Dash_V_Switch\n-                  then\n-                     Call_GPR_Tool := False;\n-                     exit;\n-                  end if;\n-\n                   if Switch'Length >= 2\n                     and then Switch (Switch'First .. Switch'First + 1) = \"-P\"\n                   then\n                      Call_GPR_Tool := True;\n+                     exit;\n                   end if;\n                end loop;\n \n@@ -806,390 +593,6 @@ begin\n          end;\n       end if;\n \n-      if The_Command = List and then not Call_GPR_Tool then\n-         Tool_Package_Name := Name_Gnatls;\n-         Packages_To_Check := Packages_To_Check_By_Gnatls;\n-\n-         --  Check that the switches are consistent. Detect project file\n-         --  related switches.\n-\n-         Inspect_Switches : declare\n-            Arg_Num : Positive := 1;\n-            Argv    : String_Access;\n-\n-            procedure Remove_Switch (Num : Positive);\n-            --  Remove a project related switch from table Last_Switches\n-\n-            -------------------\n-            -- Remove_Switch --\n-            -------------------\n-\n-            procedure Remove_Switch (Num : Positive) is\n-            begin\n-               Last_Switches.Table (Num .. Last_Switches.Last - 1) :=\n-                 Last_Switches.Table (Num + 1 .. Last_Switches.Last);\n-               Last_Switches.Decrement_Last;\n-            end Remove_Switch;\n-\n-         --  Start of processing for Inspect_Switches\n-\n-         begin\n-            while Arg_Num <= Last_Switches.Last loop\n-               Argv := Last_Switches.Table (Arg_Num);\n-\n-               if Argv (Argv'First) = '-' then\n-                  if Argv'Length = 1 then\n-                     Fail (\"switch character cannot be followed by a blank\");\n-                  end if;\n-\n-                  --  --subdirs=... Specify Subdirs\n-\n-                  if Argv'Length > Makeutl.Subdirs_Option'Length\n-                    and then\n-                      Argv\n-                       (Argv'First ..\n-                        Argv'First + Makeutl.Subdirs_Option'Length - 1) =\n-                                                        Makeutl.Subdirs_Option\n-                  then\n-                     Subdirs :=\n-                       new String'\n-                         (Argv (Argv'First + Makeutl.Subdirs_Option'Length ..\n-                                Argv'Last));\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  -aPdir  Add dir to the project search path\n-\n-                  elsif Argv'Length > 3\n-                    and then Argv (Argv'First + 1 .. Argv'First + 2) = \"aP\"\n-                  then\n-                     Prj.Env.Add_Directories\n-                       (Root_Environment.Project_Path,\n-                        Argv (Argv'First + 3 .. Argv'Last));\n-\n-                     --  Pass -aPdir to gnatls, but not to other tools\n-\n-                     if The_Command = List then\n-                        Arg_Num := Arg_Num + 1;\n-                     else\n-                        Remove_Switch (Arg_Num);\n-                     end if;\n-\n-                  --  -eL  Follow links for files\n-\n-                  elsif Argv.all = \"-eL\" then\n-                     Follow_Links_For_Files := True;\n-                     Follow_Links_For_Dirs  := True;\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  -vPx  Specify verbosity while parsing project files\n-\n-                  elsif Argv'Length >= 3\n-                    and then  Argv (Argv'First + 1 .. Argv'First + 2) = \"vP\"\n-                  then\n-                     if Argv'Length = 4\n-                       and then Argv (Argv'Last) in '0' .. '2'\n-                     then\n-                        case Argv (Argv'Last) is\n-                           when '0' =>\n-                              Current_Verbosity := Prj.Default;\n-                           when '1' =>\n-                              Current_Verbosity := Prj.Medium;\n-                           when '2' =>\n-                              Current_Verbosity := Prj.High;\n-                           when others =>\n-\n-                              --  Cannot happen\n-\n-                              raise Program_Error;\n-                        end case;\n-                     else\n-                        Fail (\"invalid verbosity level: \"\n-                              & Argv (Argv'First + 3 .. Argv'Last));\n-                     end if;\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  -Pproject_file  Specify project file to be used\n-\n-                  elsif Argv (Argv'First + 1) = 'P' then\n-\n-                     --  Only one -P switch can be used\n-\n-                     if Project_File /= null then\n-                        Fail\n-                          (Argv.all\n-                           & \": second project file forbidden (first is \"\"\"\n-                           & Project_File.all & \"\"\")\");\n-\n-                     elsif Argv'Length = 2 then\n-\n-                        --  There is space between -P and the project file\n-                        --  name. -P cannot be the last option.\n-\n-                        if Arg_Num = Last_Switches.Last then\n-                           Fail (\"project file name missing after -P\");\n-\n-                        else\n-                           Remove_Switch (Arg_Num);\n-                           Argv := Last_Switches.Table (Arg_Num);\n-\n-                           --  After -P, there must be a project file name,\n-                           --  not another switch.\n-\n-                           if Argv (Argv'First) = '-' then\n-                              Fail (\"project file name missing after -P\");\n-\n-                           else\n-                              Project_File := new String'(Argv.all);\n-                           end if;\n-                        end if;\n-\n-                     else\n-                        --  No space between -P and project file name\n-\n-                        Project_File :=\n-                          new String'(Argv (Argv'First + 2 .. Argv'Last));\n-                     end if;\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  -Xexternal=value Specify an external reference to be\n-                  --                   used in project files\n-\n-                  elsif Argv'Length >= 5\n-                    and then Argv (Argv'First + 1) = 'X'\n-                  then\n-                     if not Check (Root_Environment.External,\n-                                    Argv (Argv'First + 2 .. Argv'Last))\n-                     then\n-                        Fail\n-                          (Argv.all & \" is not a valid external assignment.\");\n-                     end if;\n-\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  --unchecked-shared-lib-imports\n-\n-                  elsif Argv.all = \"--unchecked-shared-lib-imports\" then\n-                     Opt.Unchecked_Shared_Lib_Imports := True;\n-                     Remove_Switch (Arg_Num);\n-\n-                  --  gnat list -U\n-\n-                  elsif\n-                    The_Command = List\n-                    and then Argv'Length = 2\n-                    and then Argv (2) = 'U'\n-                  then\n-                     All_Projects := True;\n-                     Remove_Switch (Arg_Num);\n-\n-                  else\n-                     Arg_Num := Arg_Num + 1;\n-                  end if;\n-\n-               else\n-                  Arg_Num := Arg_Num + 1;\n-               end if;\n-            end loop;\n-         end Inspect_Switches;\n-      end if;\n-\n-      --  Add the default project search directories now, after the directories\n-      --  that have been specified by switches -aP<dir>.\n-\n-      Prj.Env.Initialize_Default_Project_Path\n-        (Root_Environment.Project_Path,\n-         Target_Name => Sdefault.Target_Name.all);\n-\n-      --  If there is a project file specified, parse it, get the switches\n-      --  for the tool and setup PATH environment variables.\n-\n-      if Project_File /= null then\n-         Prj.Pars.Set_Verbosity (To => Current_Verbosity);\n-\n-         Prj.Pars.Parse\n-           (Project           => Project,\n-            In_Tree           => Project_Tree,\n-            In_Node_Tree      => Project_Node_Tree,\n-            Project_File_Name => Project_File.all,\n-            Env               => Root_Environment,\n-            Packages_To_Check => Packages_To_Check);\n-\n-         --  Prj.Pars.Parse calls Set_Standard_Output, reset to stderr\n-\n-         Set_Standard_Error;\n-\n-         if Project = Prj.No_Project then\n-            Fail (\"\"\"\" & Project_File.all & \"\"\" processing failed\");\n-\n-         elsif Project.Qualifier = Aggregate then\n-            Fail (\"aggregate projects are not supported\");\n-\n-         elsif Aggregate_Libraries_In (Project_Tree) then\n-            Fail (\"aggregate library projects are not supported\");\n-         end if;\n-\n-         --  Check if a package with the name of the tool is in the project\n-         --  file and if there is one, get the switches, if any, and scan them.\n-\n-         declare\n-            Pkg : constant Prj.Package_Id :=\n-                    Prj.Util.Value_Of\n-                      (Name        => Tool_Package_Name,\n-                       In_Packages => Project.Decl.Packages,\n-                       Shared      => Project_Tree.Shared);\n-\n-            Element : Package_Element;\n-\n-            Switches_Array : Array_Element_Id;\n-\n-            The_Switches : Prj.Variable_Value;\n-            Current      : Prj.String_List_Id;\n-            The_String   : String_Element;\n-\n-            Main : String_Access := null;\n-\n-         begin\n-            if Pkg /= No_Package then\n-               Element := Project_Tree.Shared.Packages.Table (Pkg);\n-\n-               --  Package Gnatls has a single attribute Switches, that is not\n-               --  an associative array.\n-\n-               if The_Command = List then\n-                  The_Switches :=\n-                    Prj.Util.Value_Of\n-                    (Variable_Name => Snames.Name_Switches,\n-                     In_Variables  => Element.Decl.Attributes,\n-                     Shared        => Project_Tree.Shared);\n-\n-               --  Packages Binder (for gnatbind), Cross_Reference (for\n-               --  gnatxref), Linker (for gnatlink), Finder (for gnatfind),\n-               --  have an attributed Switches, an associative array, indexed\n-               --  by the name of the file.\n-\n-               --  They also have an attribute Default_Switches, indexed by the\n-               --  name of the programming language.\n-\n-               else\n-                  --  First check if there is a single main\n-\n-                  for J in 1 .. Last_Switches.Last loop\n-                     if Last_Switches.Table (J) (1) /= '-' then\n-                        if Main = null then\n-                           Main := Last_Switches.Table (J);\n-                        else\n-                           Main := null;\n-                           exit;\n-                        end if;\n-                     end if;\n-                  end loop;\n-\n-                  if Main /= null then\n-                     Switches_Array :=\n-                       Prj.Util.Value_Of\n-                         (Name      => Name_Switches,\n-                          In_Arrays => Element.Decl.Arrays,\n-                          Shared    => Project_Tree.Shared);\n-                     Name_Len := 0;\n-\n-                     --  If the single main has been specified as an absolute\n-                     --  path, use only the simple file name. If the absolute\n-                     --  path is incorrect, an error will be reported by the\n-                     --  underlying tool and it does not make a difference\n-                     --  what switches are used.\n-\n-                     if Is_Absolute_Path (Main.all) then\n-                        Add_Str_To_Name_Buffer (File_Name (Main.all));\n-                     else\n-                        Add_Str_To_Name_Buffer (Main.all);\n-                     end if;\n-\n-                     The_Switches := Prj.Util.Value_Of\n-                       (Index     => Name_Find,\n-                        Src_Index => 0,\n-                        In_Array  => Switches_Array,\n-                        Shared    => Project_Tree.Shared);\n-                  end if;\n-\n-                  if The_Switches.Kind = Prj.Undefined then\n-                     Switches_Array :=\n-                       Prj.Util.Value_Of\n-                         (Name      => Name_Default_Switches,\n-                          In_Arrays => Element.Decl.Arrays,\n-                          Shared    => Project_Tree.Shared);\n-                     The_Switches := Prj.Util.Value_Of\n-                       (Index     => Name_Ada,\n-                        Src_Index => 0,\n-                        In_Array  => Switches_Array,\n-                        Shared    => Project_Tree.Shared);\n-                  end if;\n-               end if;\n-\n-               --  If there are switches specified in the package of the\n-               --  project file corresponding to the tool, scan them.\n-\n-               case The_Switches.Kind is\n-                  when Prj.Undefined =>\n-                     null;\n-\n-                  when Prj.Single =>\n-                     declare\n-                        Switch : constant String :=\n-                                   Get_Name_String (The_Switches.Value);\n-                     begin\n-                        if Switch'Length > 0 then\n-                           First_Switches.Increment_Last;\n-                           First_Switches.Table (First_Switches.Last) :=\n-                             new String'(Switch);\n-                        end if;\n-                     end;\n-\n-                  when Prj.List =>\n-                     Current := The_Switches.Values;\n-                     while Current /= Prj.Nil_String loop\n-                        The_String := Project_Tree.Shared.String_Elements.\n-                                        Table (Current);\n-\n-                        declare\n-                           Switch : constant String :=\n-                                      Get_Name_String (The_String.Value);\n-                        begin\n-                           if Switch'Length > 0 then\n-                              First_Switches.Increment_Last;\n-                              First_Switches.Table (First_Switches.Last) :=\n-                                new String'(Switch);\n-                           end if;\n-                        end;\n-\n-                        Current := The_String.Next;\n-                     end loop;\n-               end case;\n-            end if;\n-         end;\n-\n-         if The_Command = Bind or else The_Command = Link then\n-            if Project.Object_Directory.Name = No_Path then\n-               Fail (\"project \" & Get_Name_String (Project.Display_Name)\n-                     & \" has no object directory\");\n-            end if;\n-\n-            Change_Dir (Get_Name_String (Project.Object_Directory.Name));\n-         end if;\n-\n-         --  Set up the env vars for project path files\n-\n-         Prj.Env.Set_Ada_Paths\n-           (Project, Project_Tree, Including_Libraries => True);\n-\n-         if The_Command = List then\n-            Check_Files;\n-         end if;\n-      end if;\n-\n       --  Gather all the arguments and invoke the executable\n \n       declare\n@@ -1220,10 +623,6 @@ begin\n \n          My_Exit_Status := Exit_Status (Spawn (Exec_Path.all, The_Args));\n \n-         if not Keep_Temporary_Files then\n-            Delete_All_Temp_Files (Project_Tree.Shared);\n-         end if;\n-\n          Set_Exit_Status (My_Exit_Status);\n       end;\n    end;"}, {"sha": "be241a43ced86dce675bafc3ae03fe7d4108a279", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7d8272552fe9cf00fdebeb04145e7332a9589b9a", "patch": "@@ -16241,6 +16241,9 @@ package body Sem_Ch3 is\n       --  Check whether the parent type is a generic formal, or derives\n       --  directly or indirectly from one.\n \n+      function Find_Partial_View (T : Entity_Id) return Entity_Id;\n+      --  Return the partial view for a type entity T, when there is one\n+\n       ------------------------\n       -- Comes_From_Generic --\n       ------------------------\n@@ -16267,6 +16270,28 @@ package body Sem_Ch3 is\n          end if;\n       end Comes_From_Generic;\n \n+      -----------------------\n+      -- Find_Partial_View --\n+      -----------------------\n+\n+      function Find_Partial_View (T : Entity_Id) return Entity_Id is\n+         Partial_View : Entity_Id;\n+\n+      begin\n+         --  Look for the associated private type declaration\n+\n+         Partial_View := First_Entity (Scope (T));\n+         loop\n+            exit when No (Partial_View)\n+              or else (Has_Private_Declaration (Partial_View)\n+                        and then Full_View (Partial_View) = T);\n+\n+            Next_Entity (Partial_View);\n+         end loop;\n+\n+         return Partial_View;\n+      end Find_Partial_View;\n+\n       --  Local variables\n \n       Def          : constant Node_Id := Type_Definition (N);\n@@ -16281,6 +16306,28 @@ package body Sem_Ch3 is\n    begin\n       Parent_Type := Find_Type_Of_Subtype_Indic (Indic);\n \n+      if SPARK_Mode = On\n+        and then Is_Tagged_Type (Parent_Type)\n+      then\n+         declare\n+            Partial_View : constant Entity_Id :=\n+              Find_Partial_View (Parent_Type);\n+\n+         begin\n+            --  If the partial view was not found then the parent type is not a\n+            --  private type. Otherwise check that the partial view is declared\n+            --  as tagged.\n+\n+            if Present (Partial_View)\n+              and then not Is_Tagged_Type (Partial_View)\n+            then\n+               Error_Msg_NE (\"cannot derive from & declared as \"\n+                             & \"untagged private (SPARK RM 3.4(1))\",\n+                             N, Partial_View);\n+            end if;\n+         end;\n+      end if;\n+\n       --  Ada 2005 (AI-251): In case of interface derivation check that the\n       --  parent is also an interface.\n \n@@ -16468,14 +16515,7 @@ package body Sem_Ch3 is\n          begin\n             --  Look for the associated private type declaration\n \n-            Partial_View := First_Entity (Current_Scope);\n-            loop\n-               exit when No (Partial_View)\n-                 or else (Has_Private_Declaration (Partial_View)\n-                           and then Full_View (Partial_View) = T);\n-\n-               Next_Entity (Partial_View);\n-            end loop;\n+            Partial_View := Find_Partial_View (T);\n \n             --  If the partial view was not found then the source code has\n             --  errors and the transformation is not needed."}, {"sha": "f098760534a63f0f87f833f2995b44990717a6e9", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8272552fe9cf00fdebeb04145e7332a9589b9a/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=7d8272552fe9cf00fdebeb04145e7332a9589b9a", "patch": "@@ -2704,8 +2704,17 @@ package body Sem_Type is\n          if Present (Full_View (Target_Typ)) then\n             Target_Typ := Full_View (Target_Typ);\n          else\n-            pragma Assert (Present (Non_Limited_View (Target_Typ)));\n-            Target_Typ := Non_Limited_View (Target_Typ);\n+            --  In a spec expression or in an expression function, the use of\n+            --  an incomplete type is legal; legality of the conversion will be\n+            --  checked at freeze point of related entity.\n+\n+            if In_Spec_Expression then\n+               return True;\n+\n+            else\n+               pragma Assert (Present (Non_Limited_View (Target_Typ)));\n+               Target_Typ := Non_Limited_View (Target_Typ);\n+            end if;\n          end if;\n \n          --  Protect the front end against previously detected errors"}]}