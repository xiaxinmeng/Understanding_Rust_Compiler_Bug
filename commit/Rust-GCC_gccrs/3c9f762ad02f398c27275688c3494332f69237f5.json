{"sha": "3c9f762ad02f398c27275688c3494332f69237f5", "node_id": "C_kwDOANBUbNoAKDNjOWY3NjJhZDAyZjM5OGMyNzI3NTY4OGMzNDk0MzMyZjY5MjM3ZjU", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-02-03T20:27:16Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-02-03T20:27:16Z"}, "message": "Constrain conservative string lengths to array sizes [PR104119].\n\nResolves:\nPR tree-optimization/104119 - unexpected -Wformat-overflow after strlen in ILP32 since Ranger integration\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/104119\n\t* gimple-ssa-sprintf.cc (struct directive): Change argument type.\n\t(format_none): Same.\n\t(format_percent): Same.\n\t(format_integer): Same.\n\t(format_floating): Same.\n\t(get_string_length): Same.\n\t(format_character): Same.\n\t(format_string): Same.\n\t(format_plain): Same.\n\t(format_directive): Same.\n\t(compute_format_length): Same.\n\t(handle_printf_call): Same.\n\t* tree-ssa-strlen.cc (get_range_strlen_dynamic): Same.   Call\n\tget_maxbound.\n\t(get_range_strlen_phi): Same.\n\t(get_maxbound): New function.\n\t(strlen_pass::get_len_or_size): Adjust to parameter change.\n\t* tree-ssa-strlen.h (get_range_strlen_dynamic): Change argument type.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/104119\n\t* gcc.dg/tree-ssa/builtin-snprintf-13.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-29.c: New test.", "tree": {"sha": "ecc309dacfde97c9940b401ccb9cc35f8fe1bdd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecc309dacfde97c9940b401ccb9cc35f8fe1bdd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c9f762ad02f398c27275688c3494332f69237f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9f762ad02f398c27275688c3494332f69237f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9f762ad02f398c27275688c3494332f69237f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9f762ad02f398c27275688c3494332f69237f5/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e4252db0348a7274663a892c3a96d3ed7702aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e4252db0348a7274663a892c3a96d3ed7702aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e4252db0348a7274663a892c3a96d3ed7702aff"}], "stats": {"total": 453, "additions": 412, "deletions": 41}, "files": [{"sha": "c93f12f90b53e128cf098e60b3b06ccaefcdc63b", "filename": "gcc/gimple-ssa-sprintf.cc", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Fgimple-ssa-sprintf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Fgimple-ssa-sprintf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.cc?ref=3c9f762ad02f398c27275688c3494332f69237f5", "patch": "@@ -600,7 +600,7 @@ struct directive\n \n   /* Format conversion function that given a directive and an argument\n      returns the formatting result.  */\n-  fmtresult (*fmtfunc) (const directive &, tree, range_query *);\n+  fmtresult (*fmtfunc) (const directive &, tree, pointer_query &);\n \n   /* Return True when the format flag CHR has been used.  */\n   bool get_flag (char chr) const\n@@ -968,7 +968,7 @@ directive::set_precision (tree arg, range_query *query)\n /* Return the result of formatting a no-op directive (such as '%n').  */\n \n static fmtresult\n-format_none (const directive &, tree, range_query *)\n+format_none (const directive &, tree, pointer_query &)\n {\n   fmtresult res (0);\n   return res;\n@@ -977,7 +977,7 @@ format_none (const directive &, tree, range_query *)\n /* Return the result of formatting the '%%' directive.  */\n \n static fmtresult\n-format_percent (const directive &, tree, range_query *)\n+format_percent (const directive &, tree, pointer_query &)\n {\n   fmtresult res (1);\n   return res;\n@@ -1199,7 +1199,7 @@ adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n    used when the directive argument or its value isn't known.  */\n \n static fmtresult\n-format_integer (const directive &dir, tree arg, range_query *query)\n+format_integer (const directive &dir, tree arg, pointer_query &ptr_qry)\n {\n   tree intmax_type_node;\n   tree uintmax_type_node;\n@@ -1383,7 +1383,7 @@ format_integer (const directive &dir, tree arg, range_query *query)\n       /* Try to determine the range of values of the integer argument\n \t (range information is not available for pointers).  */\n       value_range vr;\n-      query->range_of_expr (vr, arg, dir.info->callstmt);\n+      ptr_qry.rvals->range_of_expr (vr, arg, dir.info->callstmt);\n \n       if (!vr.varying_p () && !vr.undefined_p ())\n \t{\n@@ -1414,7 +1414,7 @@ format_integer (const directive &dir, tree arg, range_query *query)\n \t      if (code == INTEGER_CST)\n \t\t{\n \t\t  arg = gimple_assign_rhs1 (def);\n-\t\t  return format_integer (dir, arg, query);\n+\t\t  return format_integer (dir, arg, ptr_qry);\n \t\t}\n \n \t      if (code == NOP_EXPR)\n@@ -1459,16 +1459,16 @@ format_integer (const directive &dir, tree arg, range_query *query)\n       /* For unsigned conversions/directives or signed when\n \t the minimum is positive, use the minimum and maximum to compute\n \t the shortest and longest output, respectively.  */\n-      res.range.min = format_integer (dir, argmin, query).range.min;\n-      res.range.max = format_integer (dir, argmax, query).range.max;\n+      res.range.min = format_integer (dir, argmin, ptr_qry).range.min;\n+      res.range.max = format_integer (dir, argmax, ptr_qry).range.max;\n     }\n   else if (tree_int_cst_sgn (argmax) < 0)\n     {\n       /* For signed conversions/directives if maximum is negative,\n \t use the minimum as the longest output and maximum as the\n \t shortest output.  */\n-      res.range.min = format_integer (dir, argmax, query).range.min;\n-      res.range.max = format_integer (dir, argmin, query).range.max;\n+      res.range.min = format_integer (dir, argmax, ptr_qry).range.min;\n+      res.range.max = format_integer (dir, argmin, ptr_qry).range.max;\n     }\n   else\n     {\n@@ -1477,11 +1477,11 @@ format_integer (const directive &dir, tree arg, range_query *query)\n \t length of the output of both minimum and maximum and pick the\n \t longer.  */\n       unsigned HOST_WIDE_INT max1\n-\t= format_integer (dir, argmin, query).range.max;\n+\t= format_integer (dir, argmin, ptr_qry).range.max;\n       unsigned HOST_WIDE_INT max2\n-\t= format_integer (dir, argmax, query).range.max;\n+\t= format_integer (dir, argmax, ptr_qry).range.max;\n       res.range.min\n-\t= format_integer (dir, integer_zero_node, query).range.min;\n+\t= format_integer (dir, integer_zero_node, ptr_qry).range.min;\n       res.range.max = MAX (max1, max2);\n     }\n \n@@ -1830,7 +1830,7 @@ format_floating (const directive &dir, const HOST_WIDE_INT prec[2])\n    ARG.  */\n \n static fmtresult\n-format_floating (const directive &dir, tree arg, range_query *)\n+format_floating (const directive &dir, tree arg, pointer_query &)\n {\n   HOST_WIDE_INT prec[] = { dir.prec[0], dir.prec[1] };\n   tree type = (dir.modifier == FMT_LEN_L || dir.modifier == FMT_LEN_ll\n@@ -2025,7 +2025,7 @@ format_floating (const directive &dir, tree arg, range_query *)\n \n static fmtresult\n get_string_length (tree str, gimple *stmt, unsigned HOST_WIDE_INT max_size,\n-\t\t   unsigned eltsize, range_query *query)\n+\t\t   unsigned eltsize, pointer_query &ptr_qry)\n {\n   if (!str)\n     return fmtresult ();\n@@ -2036,7 +2036,7 @@ get_string_length (tree str, gimple *stmt, unsigned HOST_WIDE_INT max_size,\n   c_strlen_data lendata = { };\n   lendata.maxbound = str;\n   if (eltsize == 1)\n-    get_range_strlen_dynamic (str, stmt, &lendata, query);\n+    get_range_strlen_dynamic (str, stmt, &lendata, ptr_qry);\n   else\n     {\n       /* Determine the length of the shortest and longest string referenced\n@@ -2084,17 +2084,30 @@ get_string_length (tree str, gimple *stmt, unsigned HOST_WIDE_INT max_size,\n       return res;\n     }\n \n+  /* The minimum length of the string.  */\n   HOST_WIDE_INT min\n     = (tree_fits_uhwi_p (lendata.minlen)\n        ? tree_to_uhwi (lendata.minlen)\n        : 0);\n \n+  /* The maximum length of the string; initially set to MAXBOUND which\n+     may be less than MAXLEN, but may be adjusted up below.  */\n   HOST_WIDE_INT max\n     = (lendata.maxbound && tree_fits_uhwi_p (lendata.maxbound)\n        ? tree_to_uhwi (lendata.maxbound)\n        : HOST_WIDE_INT_M1U);\n \n-  const bool unbounded = integer_all_onesp (lendata.maxlen);\n+  /* True if either the maximum length is unknown or (conservatively)\n+     the array bound is less than the maximum length.  That can happen\n+     when the length of the string is unknown but the array in which\n+     the string is stored is a member of a struct.  The warning uses\n+     the size of the member as the upper bound but the optimization\n+     doesn't.  The optimization could still use the size of\n+     enclosing object as the upper bound but that's not done here.  */\n+  const bool unbounded\n+    = (integer_all_onesp (lendata.maxlen)\n+       || (lendata.maxbound\n+\t   && tree_int_cst_lt (lendata.maxbound, lendata.maxlen)));\n \n   /* Set the max/likely counters to unbounded when a minimum is known\n      but the maximum length isn't bounded.  This implies that STR is\n@@ -2147,7 +2160,7 @@ get_string_length (tree str, gimple *stmt, unsigned HOST_WIDE_INT max_size,\n    vsprinf).  */\n \n static fmtresult\n-format_character (const directive &dir, tree arg, range_query *query)\n+format_character (const directive &dir, tree arg, pointer_query &ptr_qry)\n {\n   fmtresult res;\n \n@@ -2160,7 +2173,8 @@ format_character (const directive &dir, tree arg, range_query *query)\n       res.range.min = 0;\n \n       HOST_WIDE_INT min, max;\n-      if (get_int_range (arg, dir.info->callstmt, &min, &max, false, 0, query))\n+      if (get_int_range (arg, dir.info->callstmt, &min, &max, false, 0,\n+\t\t\t ptr_qry.rvals))\n \t{\n \t  if (min == 0 && max == 0)\n \t    {\n@@ -2457,7 +2471,7 @@ alias_offset (tree arg, HOST_WIDE_INT *arg_size,\n    vsprinf).  */\n \n static fmtresult\n-format_string (const directive &dir, tree arg, range_query *query)\n+format_string (const directive &dir, tree arg, pointer_query &ptr_qry)\n {\n   fmtresult res;\n \n@@ -2495,7 +2509,7 @@ format_string (const directive &dir, tree arg, range_query *query)\n     }\n \n   fmtresult slen =\n-    get_string_length (arg, dir.info->callstmt, arg_size, count_by, query);\n+    get_string_length (arg, dir.info->callstmt, arg_size, count_by, ptr_qry);\n   if (slen.range.min == slen.range.max\n       && slen.range.min < HOST_WIDE_INT_MAX)\n     {\n@@ -2667,7 +2681,7 @@ format_string (const directive &dir, tree arg, range_query *query)\n /* Format plain string (part of the format string itself).  */\n \n static fmtresult\n-format_plain (const directive &dir, tree, range_query *)\n+format_plain (const directive &dir, tree, pointer_query &)\n {\n   fmtresult res (dir.len);\n   return res;\n@@ -3063,7 +3077,7 @@ bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n static bool\n format_directive (const call_info &info,\n \t\t  format_result *res, const directive &dir,\n-\t\t  range_query *query)\n+\t\t  pointer_query &ptr_qry)\n {\n   /* Offset of the beginning of the directive from the beginning\n      of the format string.  */\n@@ -3088,7 +3102,7 @@ format_directive (const call_info &info,\n     return false;\n \n   /* Compute the range of lengths of the formatted output.  */\n-  fmtresult fmtres = dir.fmtfunc (dir, dir.arg, query);\n+  fmtresult fmtres = dir.fmtfunc (dir, dir.arg, ptr_qry);\n \n   /* Record whether the output of all directives is known to be\n      bounded by some maximum, implying that their arguments are\n@@ -3990,7 +4004,8 @@ maybe_warn_overlap (call_info &info, format_result *res)\n    that caused the processing to be terminated early).  */\n \n static bool\n-compute_format_length (call_info &info, format_result *res, range_query *query)\n+compute_format_length (call_info &info, format_result *res,\n+\t\t       pointer_query &ptr_qry)\n {\n   if (dump_file)\n     {\n@@ -4027,10 +4042,10 @@ compute_format_length (call_info &info, format_result *res, range_query *query)\n     {\n       directive dir (&info, dirno);\n \n-      size_t n = parse_directive (info, dir, res, pf, &argno, query);\n+      size_t n = parse_directive (info, dir, res, pf, &argno, ptr_qry.rvals);\n \n       /* Return failure if the format function fails.  */\n-      if (!format_directive (info, res, dir, query))\n+      if (!format_directive (info, res, dir, ptr_qry))\n \treturn false;\n \n       /* Return success when the directive is zero bytes long and it's\n@@ -4700,7 +4715,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, pointer_query &ptr_qry)\n      never set to true again).  */\n   res.posunder4k = posunder4k && dstptr;\n \n-  bool success = compute_format_length (info, &res, ptr_qry.rvals);\n+  bool success = compute_format_length (info, &res, ptr_qry);\n   if (res.warned)\n     suppress_warning (info.callstmt, info.warnopt ());\n "}, {"sha": "c5b5f0c6b65c2d7e7e577997afb465a6b9f4369c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-13.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-13.c?ref=3c9f762ad02f398c27275688c3494332f69237f5", "patch": "@@ -0,0 +1,131 @@\n+/* PR tree-optimization/104119 - unexpected -Wformat-overflow after strlen\n+   in ILP32 since Ranger integration\n+   Verify that unlike -Wformat-overflow the sprintf optimization doesn't\n+   assume the length of a string isn't bounded by the size of the array\n+   member it's stored in.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* memcpy (void*, const void*, size_t);\n+int snprintf (char*, size_t, const char*, ...);\n+char* strcpy (char*, const char*);\n+size_t strlen (const char*);\n+\n+extern void keep_call_on_line (int);\n+extern void elim_call_on_line (int);\n+\n+void sink (void*, ...);\n+\n+struct __attribute__ ((packed)) S\n+{\n+  char a4[4], b4[4], ax[];\n+};\n+\n+extern struct S es;\n+\n+void test_extern_decl_memcpy (void)\n+{\n+  struct S *p = &es;\n+\n+  /* Set strlen (P->A4) to [3, PTRDIFF - 2].   */\n+  memcpy (p->a4, \"123\", 3);\n+  int i = snprintf (0, 0, \"%s\", p->a4);\n+  if (i > 4)\n+    keep_call_on_line (__LINE__);\n+}\n+\n+void test_extern_decl_strcpy_3 (void)\n+{\n+  struct S *p = &es;\n+\n+  /* Set strlen (P->A4) to 3.   */\n+  strcpy (p->a4, \"123\");\n+  int i = snprintf (0, 0, \"%s\", p->a4);\n+  if (i > 4)\n+    elim_call_on_line (__LINE__);\n+}\n+\n+void test_extern_decl_strcpy_X (const char *s)\n+{\n+  struct S *p = &es;\n+\n+  /* Set strlen (P->A4) to [0, PTRDIFF_MAX - 2].   */\n+  strcpy (p->a4, s);\n+  int i = snprintf (0, 0, \"%s\", p->a4);\n+  if (i > 4)\n+    keep_call_on_line (__LINE__);\n+}\n+\n+size_t test_extern_decl_strlen (void)\n+{\n+  struct S *p = &es;\n+\n+  /* Set strlen (P->A4) to [0, PTRDIFF - 2].   */\n+  size_t n = strlen (p->a4);\n+  int i = snprintf (0, 0, \"%s\", p->a4);\n+  if (i > 4)\n+    keep_call_on_line (__LINE__);\n+  return n;\n+}\n+\n+\n+static struct S ss;\n+\n+/* Store and read SS to prevent optimizers from assuming it's unchanged.  */\n+\n+extern void set_ss (struct S *p)\n+{\n+  if (ss.a4[(unsigned char)*p->a4])\n+    __builtin_memcpy (&ss, p, sizeof ss);\n+}\n+\n+\n+void test_static_decl_memcpy (void)\n+{\n+  struct S *p = &ss;\n+\n+  /* Set strlen (P->A4) to [3, PTRDIFF - 2].   */\n+  memcpy (p->a4, \"123\", 3);\n+  int i = snprintf (0, 0, \"%s\", p->a4);\n+  if (i > 4)\n+    keep_call_on_line (__LINE__);\n+}\n+\n+void test_static_decl_strcpy_3 (void)\n+{\n+  struct S *p = &ss;\n+\n+  /* Set strlen (P->A4) to 3.   */\n+  strcpy (p->a4, \"123\");\n+  int i = snprintf (0, 0, \"%s\", p->a4);\n+  if (i > 4)\n+    elim_call_on_line (__LINE__);\n+}\n+\n+void test_static_decl_strcpy_X (const char *s)\n+{\n+  struct S *p = &ss;\n+\n+  /* Set strlen (P->A4) to [0, PTRDIFF_MAX - 2].   */\n+  strcpy (p->a4, s);\n+  int i = snprintf (0, 0, \"%s\", p->a4);\n+  if (i > 4)\n+    keep_call_on_line (__LINE__);\n+}\n+\n+size_t test_static_decl_strlen (void)\n+{\n+  struct S *p = &ss;\n+\n+  /* Set strlen (P->A4) to [0, PTRDIFF - 2].   */\n+  size_t n = strlen (p->a4);\n+  int i = snprintf (0, 0, \"%s\", p->a4);\n+  if (i > 4)\n+    keep_call_on_line (__LINE__);\n+  return n;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"keep_call_on_line\" 6 \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"elim_call_on_line\" \"optimized\" } } */"}, {"sha": "3591f4f1851fc51963a2e81efa4b018ef46d425e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-29.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-29.c?ref=3c9f762ad02f398c27275688c3494332f69237f5", "patch": "@@ -0,0 +1,179 @@\n+/* PR tree-optimization/104119 - unexpected -Wformat-overflow after strlen\n+   in ILP32 since Ranger integration\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* malloc (size_t);\n+int sprintf (char*, const char*, ...);\n+size_t strlen (const char*);\n+\n+void sink (void*, ...);\n+\n+struct __attribute__ ((packed)) S\n+{\n+  char a3[3], a4[4], a5[5], a6[6], a7[7], a8[8], a9[9], ax[];\n+};\n+\n+extern struct S s;\n+extern char a4[4], a7[7], a8[8];\n+\n+\n+void test_decl (void)\n+{\n+  struct S *p = &s;\n+\n+  {\n+    size_t n = strlen (p->a3);\n+    sprintf (a4, \"%s\", p->a3);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a4);\n+    sprintf (a4, \"%s\", p->a4);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a5);\n+    sprintf (a4, \"%s\", p->a5);    // { dg-warning \"may write a terminating nul past the end\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a7);\n+    sprintf (a8, \"%s\", p->a7);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a8);\n+    sprintf (a8, \"%s\", p->a8);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a9);\n+    sprintf (a8, \"%s\", p->a9);    // { dg-warning \"may write a terminating nul past the end \" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->ax);\n+    sprintf (a7, \"%s\", p->ax);    // { dg-bogus \"-Wformat-overflow\" \"pr??????\" { xfail ilp32 } }\n+    sink (a7, n);\n+  }\n+}\n+\n+\n+/* Verify the warning with a pointer to an allocated object with nonstant\n+   size in known range.  */\n+\n+void test_alloc_5_8 (int n)\n+{\n+  if (n < 5 || 8 < n)\n+    n = 5;\n+\n+  struct S *p = (struct S*)malloc (sizeof *p + n);\n+  sink (p);   // initialize *p\n+\n+  {\n+    size_t n = strlen (p->a3);\n+    sprintf (a4, \"%s\", p->a3);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a4);\n+    sprintf (a4, \"%s\", p->a4);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a5);\n+    sprintf (a4, \"%s\", p->a5);    // { dg-warning \"may write a terminating nul past the end\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a7);\n+    sprintf (a8, \"%s\", p->a7);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a8);\n+    sprintf (a8, \"%s\", p->a8);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a9);\n+    sprintf (a8, \"%s\", p->a9);    // { dg-warning \"may write a terminating nul past the end \" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    /* The size of the flexible array member p->ax is between 5 and 8\n+       bytes so the length of the string stored in it is at most 7.\n+       Verify the warning triggers based on its size and also gets\n+       the length right.  */\n+    size_t n = strlen (p->ax);\n+    sprintf (a4, \"%s\", p->ax);    // { dg-warning \"writing up to 7 bytes \" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->ax);\n+    sprintf (a8, \"%s\", p->ax);\n+    sink (a8, n);\n+  }\n+}\n+\n+\n+void test_ptr (struct S *p)\n+{\n+  {\n+    size_t n = strlen (p->a3);\n+    sprintf (a4, \"%s\", p->a3);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a4);\n+    sprintf (a4, \"%s\", p->a4);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a5);\n+    sprintf (a4, \"%s\", p->a5);    // { dg-warning \"may write a terminating nul past the end\" }\n+    sink (a4, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a7);\n+    sprintf (a8, \"%s\", p->a7);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a8);\n+    sprintf (a8, \"%s\", p->a8);    // { dg-bogus \"-Wformat-overflow\" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->a9);\n+    sprintf (a8, \"%s\", p->a9);    // { dg-warning \"may write a terminating nul past the end \" }\n+    sink (a8, n);\n+  }\n+\n+  {\n+    size_t n = strlen (p->ax);\n+    sprintf (a8, \"%s\", p->ax);    // { dg-bogus \"-Wformat-overflow\" \"pr??????\" { xfail ilp32 } }\n+    sink (a8, n);\n+  }\n+}"}, {"sha": "b5f800e73ab599f6a78f9b1db645eb2b14db484b", "filename": "gcc/tree-ssa-strlen.cc", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Ftree-ssa-strlen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Ftree-ssa-strlen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.cc?ref=3c9f762ad02f398c27275688c3494332f69237f5", "patch": "@@ -193,8 +193,8 @@ struct laststmt_struct\n } laststmt;\n \n static int get_stridx_plus_constant (strinfo *, unsigned HOST_WIDE_INT, tree);\n-static bool get_range_strlen_dynamic (tree, gimple *s, c_strlen_data *,\n-\t\t\t\t      bitmap, range_query *, unsigned *);\n+static bool get_range_strlen_dynamic (tree, gimple *, c_strlen_data *,\n+\t\t\t\t      bitmap, pointer_query *, unsigned *);\n \n /* Sets MINMAX to either the constant value or the range VAL is in\n    and returns either the constant value or VAL on success or null\n@@ -1094,7 +1094,7 @@ dump_strlen_info (FILE *fp, gimple *stmt, range_query *rvals)\n static bool\n get_range_strlen_phi (tree src, gphi *phi,\n \t\t      c_strlen_data *pdata, bitmap visited,\n-\t\t      range_query *rvals, unsigned *pssa_def_max)\n+\t\t      pointer_query *ptr_qry, unsigned *pssa_def_max)\n {\n   if (!bitmap_set_bit (visited, SSA_NAME_VERSION (src)))\n     return true;\n@@ -1113,7 +1113,7 @@ get_range_strlen_phi (tree src, gphi *phi,\n \tcontinue;\n \n       c_strlen_data argdata = { };\n-      if (!get_range_strlen_dynamic (arg, phi, &argdata, visited, rvals,\n+      if (!get_range_strlen_dynamic (arg, phi, &argdata, visited, ptr_qry,\n \t\t\t\t     pssa_def_max))\n \t{\n \t  pdata->maxlen = build_all_ones_cst (size_type_node);\n@@ -1159,6 +1159,48 @@ get_range_strlen_phi (tree src, gphi *phi,\n   return true;\n }\n \n+/* Return the maximum possible length of the string PTR that's less\n+   than MAXLEN given the size of the object of subobject it points\n+   to at the given STMT.  MAXLEN is the maximum length of the string\n+   determined so far.  Return null when no such maximum can be\n+   determined.  */\n+\n+static tree\n+get_maxbound (tree ptr, gimple *stmt, offset_int maxlen,\n+\t      pointer_query *ptr_qry)\n+{\n+  access_ref aref;\n+  if (!ptr_qry->get_ref (ptr, stmt, &aref))\n+    return NULL_TREE;\n+\n+  offset_int sizrem = aref.size_remaining ();\n+  if (sizrem <= 0)\n+    return NULL_TREE;\n+\n+  if (sizrem < maxlen)\n+    maxlen = sizrem - 1;\n+\n+  /* Try to determine the maximum from the subobject at the offset.\n+     This handles MEM [&some-struct, member-offset] that's often\n+     the result of folding COMPONENT_REF [some-struct, member].  */\n+  tree reftype = TREE_TYPE (aref.ref);\n+  if (!RECORD_OR_UNION_TYPE_P (reftype)\n+      || aref.offrng[0] != aref.offrng[1]\n+      || !wi::fits_shwi_p (aref.offrng[0]))\n+    return wide_int_to_tree (size_type_node, maxlen);\n+\n+  HOST_WIDE_INT off = aref.offrng[0].to_shwi ();\n+  tree fld = field_at_offset (reftype, NULL_TREE, off);\n+  if (!fld || !DECL_SIZE_UNIT (fld))\n+    return wide_int_to_tree (size_type_node, maxlen);\n+\n+  offset_int size = wi::to_offset (DECL_SIZE_UNIT (fld));\n+  if (maxlen < size)\n+    return wide_int_to_tree (size_type_node, maxlen);\n+\n+  return wide_int_to_tree (size_type_node, size - 1);\n+}\n+\n /* Attempt to determine the length of the string SRC.  On success, store\n    the length in *PDATA and return true.  Otherwise, return false.\n    VISITED is a bitmap of visited PHI nodes.  RVALS points to the valuation\n@@ -1168,7 +1210,7 @@ get_range_strlen_phi (tree src, gphi *phi,\n static bool\n get_range_strlen_dynamic (tree src, gimple *stmt,\n \t\t\t  c_strlen_data *pdata, bitmap visited,\n-\t\t\t  range_query *rvals, unsigned *pssa_def_max)\n+\t\t\t  pointer_query *ptr_qry, unsigned *pssa_def_max)\n {\n   int idx = get_stridx (src, stmt);\n   if (!idx)\n@@ -1177,7 +1219,7 @@ get_range_strlen_dynamic (tree src, gimple *stmt,\n \t{\n \t  gimple *def_stmt = SSA_NAME_DEF_STMT (src);\n \t  if (gphi *phi = dyn_cast<gphi *>(def_stmt))\n-\t    return get_range_strlen_phi (src, phi, pdata, visited, rvals,\n+\t    return get_range_strlen_phi (src, phi, pdata, visited, ptr_qry,\n \t\t\t\t\t pssa_def_max);\n \t}\n \n@@ -1206,7 +1248,7 @@ get_range_strlen_dynamic (tree src, gimple *stmt,\n \t  else if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t    {\n \t      value_range vr;\n-\t      rvals->range_of_expr (vr, si->nonzero_chars, si->stmt);\n+\t      ptr_qry->rvals->range_of_expr (vr, si->nonzero_chars, si->stmt);\n \t      if (range_int_cst_p (&vr))\n \t\t{\n \t\t  pdata->minlen = vr.min ();\n@@ -1250,12 +1292,16 @@ get_range_strlen_dynamic (tree src, gimple *stmt,\n       else if (pdata->minlen && TREE_CODE (pdata->minlen) == SSA_NAME)\n \t{\n \t  value_range vr;\n-\t  rvals->range_of_expr (vr, si->nonzero_chars, stmt);\n+\t  ptr_qry->rvals->range_of_expr (vr, si->nonzero_chars, stmt);\n \t  if (range_int_cst_p (&vr))\n \t    {\n \t      pdata->minlen = vr.min ();\n \t      pdata->maxlen = vr.max ();\n-\t      pdata->maxbound = pdata->maxlen;\n+\t      offset_int max = offset_int::from (vr.upper_bound (0), SIGNED);\n+\t      if (tree maxbound = get_maxbound (si->ptr, stmt, max, ptr_qry))\n+\t\tpdata->maxbound = maxbound;\n+\t      else\n+\t\tpdata->maxbound = pdata->maxlen;\n \t    }\n \t  else\n \t    {\n@@ -1293,13 +1339,13 @@ get_range_strlen_dynamic (tree src, gimple *stmt,\n \n void\n get_range_strlen_dynamic (tree src, gimple *stmt, c_strlen_data *pdata,\n-\t\t\t  range_query *rvals)\n+\t\t\t  pointer_query &ptr_qry)\n {\n   auto_bitmap visited;\n   tree maxbound = pdata->maxbound;\n \n   unsigned limit = param_ssa_name_def_chain_limit;\n-  if (!get_range_strlen_dynamic (src, stmt, pdata, visited, rvals, &limit))\n+  if (!get_range_strlen_dynamic (src, stmt, pdata, visited, &ptr_qry, &limit))\n     {\n       /* On failure extend the length range to an impossible maximum\n \t (a valid MAXLEN must be less than PTRDIFF_MAX - 1).  Other\n@@ -4030,7 +4076,7 @@ strlen_pass::get_len_or_size (gimple *stmt, tree arg, int idx,\n   /* Set MAXBOUND to an arbitrary non-null non-integer node as a request\n      to have it set to the length of the longest string in a PHI.  */\n   lendata.maxbound = arg;\n-  get_range_strlen_dynamic (arg, stmt, &lendata, ptr_qry.rvals);\n+  get_range_strlen_dynamic (arg, stmt, &lendata, ptr_qry);\n \n   unsigned HOST_WIDE_INT maxbound = HOST_WIDE_INT_M1U;\n   if (tree_fits_uhwi_p (lendata.maxbound)"}, {"sha": "8d155450db8b2b423a46d6db4dca0fee6e66f178", "filename": "gcc/tree-ssa-strlen.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Ftree-ssa-strlen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9f762ad02f398c27275688c3494332f69237f5/gcc%2Ftree-ssa-strlen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.h?ref=3c9f762ad02f398c27275688c3494332f69237f5", "patch": "@@ -33,7 +33,7 @@ extern tree get_range (tree, gimple *, wide_int[2],\n \n struct c_strlen_data;\n extern void get_range_strlen_dynamic (tree, gimple *, c_strlen_data *,\n-\t\t\t\t      class range_query *);\n+\t\t\t\t      pointer_query &);\n \n /* APIs internal to strlen pass.  Defined in gimple-ssa-sprintf.cc.  */\n extern bool handle_printf_call (gimple_stmt_iterator *, pointer_query &);"}]}