{"sha": "48028e2196413a9dd37f204e8e019001dbd95338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgwMjhlMjE5NjQxM2E5ZGQzN2YyMDRlOGUwMTkwMDFkYmQ5NTMzOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2003-06-13T03:56:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-06-13T03:56:10Z"}, "message": "re PR target/10142 ([SPARC64] gcc produces wrong code when passing structures by value)\n\n\tPR target/10142\n\t* config/sparc/sparc.c (function_arg_record_value_parms): Add\n\tnew 'stack' field.\n\t(function_arg_record_value_1): Set 'stack' to 1 if we run out of\n\tinteger slots for an integer field.\n\t(function_arg_record_value_3): Shift vector index.\n\t(function_arg_record_value_2): Likewise.\n\t(function_arg_record_value): Initialize 'stack' to 0.\n\tSet 'stack' to 1 if we run out of integer slots for an integer field.\n\tGenerate (parallel [(expr_list (nil) ...) ...]) if 'stack' is set to 1.\n\nCo-Authored-By: Christian Ehrhardt <ehrhardt@mathematik.uni-ulm.de>\n\nFrom-SVN: r67874", "tree": {"sha": "6b5d3d014bf41f9b8d9449281ac2e3e8bb39309f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b5d3d014bf41f9b8d9449281ac2e3e8bb39309f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48028e2196413a9dd37f204e8e019001dbd95338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48028e2196413a9dd37f204e8e019001dbd95338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48028e2196413a9dd37f204e8e019001dbd95338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48028e2196413a9dd37f204e8e019001dbd95338/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28e089c6fdabc1b432d442635a018677307cd1c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e089c6fdabc1b432d442635a018677307cd1c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e089c6fdabc1b432d442635a018677307cd1c2"}], "stats": {"total": 74, "additions": 61, "deletions": 13}, "files": [{"sha": "c224d5dbd3a8ad732a7598956e2bb7e0ca2dc23d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48028e2196413a9dd37f204e8e019001dbd95338/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48028e2196413a9dd37f204e8e019001dbd95338/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48028e2196413a9dd37f204e8e019001dbd95338", "patch": "@@ -1,3 +1,17 @@\n+2003-06-13  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+            Christian Ehrhardt <ehrhardt@mathematik.uni-ulm.de>\n+\n+\tPR target/10142\n+\t* config/sparc/sparc.c (function_arg_record_value_parms): Add\n+\tnew 'stack' field.\n+\t(function_arg_record_value_1): Set 'stack' to 1 if we run out of\n+\tinteger slots for an integer field.\n+\t(function_arg_record_value_3): Shift vector index.\n+\t(function_arg_record_value_2): Likewise.\n+\t(function_arg_record_value): Initialize 'stack' to 0.\n+\tSet 'stack' to 1 if we run out of integer slots for an integer field.\n+\tGenerate (parallel [(expr_list (nil) ...) ...]) if 'stack' is set to 1.\n+\n 2003-06-13  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR optimization/10955"}, {"sha": "3be2f9ddaf492fff9b36834134abf2c4ee0ae8f2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48028e2196413a9dd37f204e8e019001dbd95338/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48028e2196413a9dd37f204e8e019001dbd95338/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=48028e2196413a9dd37f204e8e019001dbd95338", "patch": "@@ -4530,10 +4530,13 @@ function_arg_slotno (cum, mode, type, named, incoming_p, pregno, ppadding)\n \n struct function_arg_record_value_parms\n {\n-  rtx ret;\n-  int slotno, named, regbase;\n-  unsigned int nregs;\n-  int intoffset;\n+  rtx ret;\t\t/* return expression being built.  */\n+  int slotno;\t\t/* slot number of the argument.  */\n+  int named;\t\t/* whether the argument is named.  */\n+  int regbase;\t\t/* regno of the base register.  */\n+  int stack;\t\t/* 1 if part of the argument is on the stack.  */\n+  int intoffset;\t/* offset of the pending integer field.  */\n+  unsigned int nregs;\t/* number of words passed in registers.  */\n };\n \n static void function_arg_record_value_3\n@@ -4608,8 +4611,13 @@ function_arg_record_value_1 (type, startbitpos, parms)\n \t\t  this_slotno = parms->slotno + parms->intoffset\n \t\t    / BITS_PER_WORD;\n \n-\t\t  intslots = MIN (intslots, SPARC_INT_ARG_MAX - this_slotno);\n-\t\t  intslots = MAX (intslots, 0);\n+\t\t  if (intslots > 0 && intslots > SPARC_INT_ARG_MAX - this_slotno)\n+\t\t    {\n+\t\t      intslots = MAX (0, SPARC_INT_ARG_MAX - this_slotno);\n+\t\t      /* We need to pass this field on the stack.  */\n+\t\t      parms->stack = 1;\n+\t\t    }\n+\n \t\t  parms->nregs += intslots;\n \t\t  parms->intoffset = -1;\n \t\t}\n@@ -4674,7 +4682,7 @@ function_arg_record_value_3 (bitpos, parms)\n     {\n       regno = parms->regbase + this_slotno;\n       reg = gen_rtx_REG (mode, regno);\n-      XVECEXP (parms->ret, 0, parms->nregs)\n+      XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n \t= gen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (intoffset));\n \n       this_slotno += 1;\n@@ -4747,15 +4755,15 @@ function_arg_record_value_2 (type, startbitpos, parms)\n \t\tdefault: break;\n \t\t}\n \t      reg = gen_rtx_REG (mode, regno);\n-\t      XVECEXP (parms->ret, 0, parms->nregs)\n+\t      XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n \t\t= gen_rtx_EXPR_LIST (VOIDmode, reg,\n \t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n \t      parms->nregs += 1;\n \t      if (TREE_CODE (TREE_TYPE (field)) == COMPLEX_TYPE)\n \t\t{\n \t\t  regno += GET_MODE_SIZE (mode) / 4;\n \t  \t  reg = gen_rtx_REG (mode, regno);\n-\t\t  XVECEXP (parms->ret, 0, parms->nregs)\n+\t\t  XVECEXP (parms->ret, 0, parms->stack + parms->nregs)\n \t\t    = gen_rtx_EXPR_LIST (VOIDmode, reg,\n \t\t\tGEN_INT ((bitpos + GET_MODE_BITSIZE (mode))\n \t\t\t\t / BITS_PER_UNIT));\n@@ -4772,8 +4780,19 @@ function_arg_record_value_2 (type, startbitpos, parms)\n }\n \n /* Used by function_arg and function_value to implement the complex\n-   SPARC64 structure calling conventions.  */\n+   conventions of the 64-bit ABI for passing and returning structures.\n+   Return an expression valid as a return value for the two macros\n+   FUNCTION_ARG and FUNCTION_VALUE.\n \n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   MODE is the argument's machine mode.\n+   SLOTNO is the index number of the argument's slot in the parameter array.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+   REGBASE is the regno of the base register for the parameter array.  */\n+   \n static rtx\n function_arg_record_value (type, mode, slotno, named, regbase)\n      tree type;\n@@ -4788,6 +4807,7 @@ function_arg_record_value (type, mode, slotno, named, regbase)\n   parms.slotno = slotno;\n   parms.named = named;\n   parms.regbase = regbase;\n+  parms.stack = 0;\n \n   /* Compute how many registers we need.  */\n   parms.nregs = 0;\n@@ -4804,8 +4824,12 @@ function_arg_record_value (type, mode, slotno, named, regbase)\n       intslots = (endbit - startbit) / BITS_PER_WORD;\n       this_slotno = slotno + parms.intoffset / BITS_PER_WORD;\n \n-      intslots = MIN (intslots, SPARC_INT_ARG_MAX - this_slotno);\n-      intslots = MAX (intslots, 0);\n+      if (intslots > 0 && intslots > SPARC_INT_ARG_MAX - this_slotno)\n+        {\n+\t  intslots = MAX (0, SPARC_INT_ARG_MAX - this_slotno);\n+\t  /* We need to pass this field on the stack.  */\n+\t  parms.stack = 1;\n+        }\n \n       parms.nregs += intslots;\n     }\n@@ -4835,7 +4859,17 @@ function_arg_record_value (type, mode, slotno, named, regbase)\n   if (nregs == 0)\n     abort ();\n \n-  parms.ret = gen_rtx_PARALLEL (mode, rtvec_alloc (nregs));\n+  parms.ret = gen_rtx_PARALLEL (mode, rtvec_alloc (parms.stack + nregs));\n+\n+  /* If at least one field must be passed on the stack, generate\n+     (parallel [(expr_list (nil) ...) ...]) so that all fields will\n+     also be passed on the stack.  We can't do much better because the\n+     semantics of FUNCTION_ARG_PARTIAL_NREGS doesn't handle the case\n+     of structures for which the fields passed exclusively in registers\n+     are not at the beginning of the structure.  */\n+  if (parms.stack)\n+    XVECEXP (parms.ret, 0, 0)\n+      = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n \n   /* Fill in the entries.  */\n   parms.nregs = 0;"}]}