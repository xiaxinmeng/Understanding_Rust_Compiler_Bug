{"sha": "0a180c0ee8779e656fd59c604a4a4443e242a7f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGExODBjMGVlODc3OWU2NTZmZDU5YzYwNGE0YTQ0NDNlMjQyYTdmNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-02-09T02:18:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-02-09T02:18:59Z"}, "message": "tree-ssa-dce.c (remove_dead_statement): When removing a dead control statement...\n\n        * tree-ssa-dce.c (remove_dead_statement): When removing a dead\n        control statement, handle all three special cases in the same\n        manner as they all have the same desired solution.  No longer\n        special case edge flag updating when the post dominator is\n        the exit block.\n\nFrom-SVN: r110784", "tree": {"sha": "a64f23c9c77ce31c8416c904d0b39f38e87380e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a64f23c9c77ce31c8416c904d0b39f38e87380e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a180c0ee8779e656fd59c604a4a4443e242a7f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a180c0ee8779e656fd59c604a4a4443e242a7f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a180c0ee8779e656fd59c604a4a4443e242a7f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a180c0ee8779e656fd59c604a4a4443e242a7f7/comments", "author": null, "committer": null, "parents": [{"sha": "1349c6885196987a8a167b852ff5c482de834333", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1349c6885196987a8a167b852ff5c482de834333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1349c6885196987a8a167b852ff5c482de834333"}], "stats": {"total": 53, "additions": 30, "deletions": 23}, "files": [{"sha": "5f7e20ca1e28cedda9bae99d1148074fcbc5aa87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a180c0ee8779e656fd59c604a4a4443e242a7f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a180c0ee8779e656fd59c604a4a4443e242a7f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a180c0ee8779e656fd59c604a4a4443e242a7f7", "patch": "@@ -1,3 +1,11 @@\n+2006-02-08  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dce.c (remove_dead_statement): When removing a dead\n+\tcontrol statement, handle all three special cases in the same\n+\tmanner as they all have the same desired solution.  No longer\n+\tspecial case edge flag updating when the post dominator is\n+\tthe exit block.\n+\n 2006-02-08  Roger Sayle  <roger@eyesopen.com>\n \n \t* tree.def (CHAR_TYPE): Remove."}, {"sha": "c8a30a4024fb1f0b17753424537def826702aa46", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a180c0ee8779e656fd59c604a4a4443e242a7f7/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a180c0ee8779e656fd59c604a4a4443e242a7f7/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=0a180c0ee8779e656fd59c604a4a4443e242a7f7", "patch": "@@ -734,23 +734,27 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n       gcc_assert (dom_computed[CDI_POST_DOMINATORS] == DOM_OK);\n       /* Get the immediate post dominator of bb.  */\n       post_dom_bb = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n-      /* Some blocks don't have an immediate post dominator.  This can happen\n-\t for example with infinite loops.  Removing an infinite loop is an\n-\t inappropriate transformation anyway...  */\n-      if (! post_dom_bb)\n-\t{\n-\t  bsi_next (i);\n-\t  return;\n-\t}\n \n-      /* If the post dominator block has PHI nodes, we might be unable\n-\t to compute the right PHI args for them.  Since the control\n-\t statement is unnecessary, all edges can be regarded as\n-\t equivalent, but we have to get rid of the condition, since it\n-\t might reference a variable that was determined to be\n-\t unnecessary and thus removed.  */\n-      if (phi_nodes (post_dom_bb))\n-\tpost_dom_bb = EDGE_SUCC (bb, 0)->dest;\n+      /* There are three particularly problematical cases.\n+\n+\t 1. Blocks that do not have an immediate post dominator.  This\n+\t    can happen with infinite loops.\n+\n+\t 2. Blocks that are only post dominated by the exit block.  These\n+\t    can also happen for infinite loops as we create fake edges\n+\t    in the dominator tree.\n+\n+\t 3. If the post dominator has PHI nodes we may be able to compute\n+\t    the right PHI args for them.\n+\n+\n+\t In each of these cases we must remove the control statement\n+\t as it may reference SSA_NAMEs which are going to be removed and\n+\t we remove all but one outgoing edge from the block.  */\n+      if (! post_dom_bb\n+\t  || post_dom_bb == EXIT_BLOCK_PTR\n+\t  || phi_nodes (post_dom_bb))\n+\t;\n       else\n \t{\n \t  /* Redirect the first edge out of BB to reach POST_DOM_BB.  */\n@@ -764,13 +768,8 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n \t not have TRUE/FALSE flags.  */\n       EDGE_SUCC (bb, 0)->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n \n-      /* If the edge reaches any block other than the exit, then it is a\n-\t fallthru edge; if it reaches the exit, then it is not a fallthru\n-\t edge.  */\n-      if (post_dom_bb != EXIT_BLOCK_PTR)\n-\tEDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n-      else\n-\tEDGE_SUCC (bb, 0)->flags &= ~EDGE_FALLTHRU;\n+      /* The lone outgoing edge from BB will be a fallthru edge.  */\n+      EDGE_SUCC (bb, 0)->flags |= EDGE_FALLTHRU;\n \n       /* Remove the remaining the outgoing edges.  */\n       while (!single_succ_p (bb))"}]}