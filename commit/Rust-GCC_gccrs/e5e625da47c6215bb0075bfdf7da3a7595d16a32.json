{"sha": "e5e625da47c6215bb0075bfdf7da3a7595d16a32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVlNjI1ZGE0N2M2MjE1YmIwMDc1YmZkZjdkYTNhNzU5NWQxNmEzMg==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@apple.com", "date": "2005-04-09T20:41:49Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2005-04-09T20:41:49Z"}, "message": "Fix problems with labels with hot/cold partitioning.\n\nFrom-SVN: r97928", "tree": {"sha": "ec3765f0365ed2285df397e3dba04f4164e18760", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec3765f0365ed2285df397e3dba04f4164e18760"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5e625da47c6215bb0075bfdf7da3a7595d16a32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e625da47c6215bb0075bfdf7da3a7595d16a32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e625da47c6215bb0075bfdf7da3a7595d16a32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e625da47c6215bb0075bfdf7da3a7595d16a32/comments", "author": null, "committer": null, "parents": [{"sha": "bd0e28a2adf23055c04afb46a8cda62bc02265b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0e28a2adf23055c04afb46a8cda62bc02265b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd0e28a2adf23055c04afb46a8cda62bc02265b1"}], "stats": {"total": 515, "additions": 318, "deletions": 197}, "files": [{"sha": "228d76eb14dfee734de558baa28c50c8f62f1ed0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -1,3 +1,72 @@\n+2005-04-09  Caroline Tice  <ctice@apple.com>\n+\n+\t* bb-reorder.c (find_rarely_executed_basic_blocks_and_crossing_edges):\n+\tRemove targetm.have_named_sections test.\n+\t(fix_edges_for_rarely_executed_code): Likewise.\n+\t(insert_section_boundary_note): Likewise.\n+\t(reorder_basic_blocks): Check partitioning flag before calling\n+\tverify_hot_cold_block_grouping.\n+\t* dbxout.c (dbxout_function_end): Get hot/cold section labels from\n+\tthe function struct rather than global variables.\n+\t* dwarf2out.c (COLD_TEXT_SECTION_LABEL): New macro.\n+\t(COLD_END_LABEL): Likewise\n+\t(cold_text_section_label): New static global variable.\n+\t(cold_end_label): Likewise.\n+\t(dwarf2out_switch_text_section): Get hot/cold section labels from\n+\tthe function struct rather than global variables.\n+\t(output_aranges): Use cold_text_section_label and cold_end_label;\n+\tcheck partitioning flag before putting out delta.\n+\t(output_ranges): Remove incorrect code attempting to use\n+\thot/cold labels.\n+\t(output_line_info): Get cold section label from function struct.\n+\t(add_location_or_const_value_attribute): Likewise.\n+\t(get_subprogram_die): Get hot/cold section labels from function struct.\n+\t(dwarf2out_var_location): Likewise.\n+\t(dwarf2out_init): Generate cold_text_section_label and cold_end_label;\n+\twrite out cold_text_section_label if partition flag is set.\n+\t(dwarf2out_finish): Write out cold_end_label if partition flag is set;\n+\t* function.h (struct function): Add new fields to point to hot/cold\n+\tsection labels: hot_section_label, cold_section_label,\n+\thot_section_end_label and cold_section_end_label; also add new field\n+\tfor cold text section name, unlikely_text_section_name.\n+\t* opts.c (decode_options): Turn off partitioning flag if\n+\t!targetm.have_named_sections.\n+\t* output.h (hot_section_label): Remove.\n+\t(hot_section_end_label): Remove.\n+\t(cold_section_end_label): Remove.\n+\t(unlikely_section_label): Remove.\n+\t(unlikely_text_section_name): Remove.\n+\t* passes.c (rest_of_handle_final):  Remove code that frees\n+\tunlikely_text_section_name.\n+\t* varasm.c (unlikely_section_label): Remove.\n+\t(hot_section_label): Remove.\n+\t(hot_section_end_label): Remove.\n+\t(cold_section_end_label): Remove.\n+\t(unlikely_text_section_name):  Remove.\n+\t(initialize_cold_section_name): Modify to call\n+\ttargetm.strip_name_encoding; to store cold section name in current\n+\tfunction struct, if it exists; and to only use the decl_section_name\n+\tif flag_named_sections is true.\n+\t(unlikely_text_section): Modify to get section name out of current\n+\tfunction struct, if there is one; otherwise build it from\n+\tUNLIKELY_EXECUTED_TEXT_SECTION_NAME.\n+\t(in_unlikely_text_section): Likewise.\n+\t(named_section): Modify to get/put cold section name in current function\n+\tstruct, if there is one.\n+\t(function_section):  Change 'bool unlikely' to 'int reloc'; check\n+\ttargetm.have_named_sections before calling named_section.\n+\t(current_function_section): Likewise.\n+\t(assemble_start_function): Modify to get/put unlikely_text_section_name\n+\tin current function struct; modify to get hot/cold section labels\n+\tfrom function struct; initialize labels using \n+\tASM_GENERATE_INTERNAL_LABEL;\n+\ttest partitioning flag before writing out hot section label.\n+\t(assemble_end_function): Test partitioning flag before writing out\n+\thot/cold section labels.\n+\t(default_section_type_flags_1):  Modify to use array instead of\n+\t char* for unlikely_text_section_name; set flags correctly for\n+\t cold text section if there is not a current function decl.\n+\n 2005-04-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD"}, {"sha": "4936ca409107a089d45fe1fb85db30ca0d3f6ec4", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 37, "deletions": 50, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -1241,27 +1241,24 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n   /* Mark every edge that crosses between sections.  */\n \n   i = 0;\n-  if (targetm.have_named_sections)\n+  FOR_EACH_BB (bb)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n-      FOR_EACH_BB (bb)\n-        FOR_EACH_EDGE (e, ei, bb->succs)\n-\t  {\n-\t    if (e->src != ENTRY_BLOCK_PTR\n-\t\t&& e->dest != EXIT_BLOCK_PTR\n-\t\t&& BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n-\t      {\n-\t\te->flags |= EDGE_CROSSING;\n-\t\tif (i == *max_idx)\n-\t\t  {\n-\t\t    *max_idx *= 2;\n-\t\t    crossing_edges = xrealloc (crossing_edges,\n-\t\t\t\t\t       (*max_idx) * sizeof (edge));\n-\t\t  }\n-\t\tcrossing_edges[i++] = e;\n-\t      }\n-\t    else\n-\t      e->flags &= ~EDGE_CROSSING;\n-\t  }\n+      if (e->src != ENTRY_BLOCK_PTR\n+\t  && e->dest != EXIT_BLOCK_PTR\n+\t  && BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n+\t{\n+\t  e->flags |= EDGE_CROSSING;\n+\t  if (i == *max_idx)\n+\t    {\n+\t      *max_idx *= 2;\n+\t      crossing_edges = xrealloc (crossing_edges,\n+\t\t\t\t\t (*max_idx) * sizeof (edge));\n+\t    }\n+\t  crossing_edges[i++] = e;\n+\t}\n+      else\n+\te->flags &= ~EDGE_CROSSING;\n     }\n   *n_crossing_edges = i;\n }\n@@ -1825,36 +1822,26 @@ fix_edges_for_rarely_executed_code (edge *crossing_edges,\n   \n   fix_up_fall_thru_edges ();\n   \n-  /* Only do the parts necessary for writing separate sections if\n-     the target architecture has the ability to write separate sections\n-     (i.e. it has named sections).  Otherwise, the hot/cold partitioning\n-     information will be used when reordering blocks to try to put all\n-     the hot blocks together, then all the cold blocks, but no actual\n-     section partitioning will be done.  */\n-\n-  if (targetm.have_named_sections)\n-    {\n-      /* If the architecture does not have conditional branches that can\n-\t span all of memory, convert crossing conditional branches into\n-\t crossing unconditional branches.  */\n+  /* If the architecture does not have conditional branches that can\n+     span all of memory, convert crossing conditional branches into\n+     crossing unconditional branches.  */\n   \n-      if (!HAS_LONG_COND_BRANCH)\n-\tfix_crossing_conditional_branches ();\n+  if (!HAS_LONG_COND_BRANCH)\n+    fix_crossing_conditional_branches ();\n   \n-      /* If the architecture does not have unconditional branches that\n-\t can span all of memory, convert crossing unconditional branches\n-\t into indirect jumps.  Since adding an indirect jump also adds\n-\t a new register usage, update the register usage information as\n-\t well.  */\n-      \n-      if (!HAS_LONG_UNCOND_BRANCH)\n-\t{\n-\t  fix_crossing_unconditional_branches ();\n-\t  reg_scan (get_insns(), max_reg_num ());\n-\t}\n-\n-      add_reg_crossing_jump_notes ();\n+  /* If the architecture does not have unconditional branches that\n+     can span all of memory, convert crossing unconditional branches\n+     into indirect jumps.  Since adding an indirect jump also adds\n+     a new register usage, update the register usage information as\n+     well.  */\n+  \n+  if (!HAS_LONG_UNCOND_BRANCH)\n+    {\n+      fix_crossing_unconditional_branches ();\n+      reg_scan (get_insns(), max_reg_num ());\n     }\n+  \n+  add_reg_crossing_jump_notes ();\n }\n \n /* Verify, in the basic block chain, that there is at most one switch\n@@ -1946,7 +1933,8 @@ reorder_basic_blocks (unsigned int flags)\n     dump_flow_info (dump_file);\n \n   cfg_layout_finalize ();\n-  verify_hot_cold_block_grouping ();\n+  if (flag_reorder_blocks_and_partition)\n+    verify_hot_cold_block_grouping ();\n \n   timevar_pop (TV_REORDER_BLOCKS);\n }\n@@ -1966,8 +1954,7 @@ insert_section_boundary_note (void)\n   rtx new_note;\n   int first_partition = 0;\n   \n-  if (flag_reorder_blocks_and_partition\n-      && targetm.have_named_sections)\n+  if (flag_reorder_blocks_and_partition)\n     FOR_EACH_BB (bb)\n     {\n       if (!first_partition)"}, {"sha": "33bbd716b1713efa132623c3c864f56485a4b595", "filename": "gcc/dbxout.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -938,11 +938,14 @@ dbxout_function_end (tree decl)\n #else\n   if (flag_reorder_blocks_and_partition)\n     {\n+      struct function *cfun = DECL_STRUCT_FUNCTION (decl);\n+\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (hot_section_end_label, hot_section_label);\n+      dbxout_stab_value_label_diff (cfun->hot_section_end_label, \n+\t\t\t\t    cfun->hot_section_label);\n       dbxout_begin_empty_stabs (N_FUN);\n-      dbxout_stab_value_label_diff (cold_section_end_label, \n-\t\t\t\t    unlikely_section_label);\n+      dbxout_stab_value_label_diff (cfun->cold_section_end_label, \n+\t\t\t\t    cfun->cold_section_label);\n     }\n   else\n     {"}, {"sha": "a7b2b86a0098f1ad0995f4670d5bbb648c174840", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 49, "deletions": 36, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -4122,6 +4122,9 @@ static int maybe_emit_file (int);\n #ifndef TEXT_SECTION_LABEL\n #define TEXT_SECTION_LABEL\t\t\"Ltext\"\n #endif\n+#ifndef COLD_TEXT_SECTION_LABEL\n+#define COLD_TEXT_SECTION_LABEL         \"Ltext_cold\"\n+#endif\n #ifndef DEBUG_LINE_SECTION_LABEL\n #define DEBUG_LINE_SECTION_LABEL\t\"Ldebug_line\"\n #endif\n@@ -4149,6 +4152,8 @@ static int maybe_emit_file (int);\n \n static char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+static char cold_text_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+static char cold_end_label[MAX_ARTIFICIAL_LABEL_BYTES]; \n static char abbrev_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_info_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n static char debug_line_section_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -4159,6 +4164,9 @@ static char ranges_section_label[2 * MAX_ARTIFICIAL_LABEL_BYTES];\n #ifndef TEXT_END_LABEL\n #define TEXT_END_LABEL\t\t\"Letext\"\n #endif\n+#ifndef COLD_END_LABEL\n+#define COLD_END_LABEL          \"Letext_cold\"\n+#endif\n #ifndef BLOCK_BEGIN_LABEL\n #define BLOCK_BEGIN_LABEL\t\"LBB\"\n #endif\n@@ -6799,13 +6807,14 @@ static void\n dwarf2out_switch_text_section (void)\n {\n   dw_fde_ref fde;\n+  struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n   fde = &fde_table[fde_table_in_use - 1];\n   fde->dw_fde_switched_sections = true;\n-  fde->dw_fde_hot_section_label = xstrdup (hot_section_label);\n-  fde->dw_fde_hot_section_end_label = xstrdup (hot_section_end_label);\n-  fde->dw_fde_unlikely_section_label = xstrdup (unlikely_section_label);\n-  fde->dw_fde_unlikely_section_end_label = xstrdup (cold_section_end_label);\n+  fde->dw_fde_hot_section_label = cfun->hot_section_label;\n+  fde->dw_fde_hot_section_end_label = cfun->hot_section_end_label;\n+  fde->dw_fde_unlikely_section_label = cfun->cold_section_label;\n+  fde->dw_fde_unlikely_section_end_label = cfun->cold_section_end_label;\n   separate_line_info_table_in_use++;\n }\n \n@@ -7235,14 +7244,15 @@ output_aranges (void)\n     }\n \n   dw2_asm_output_addr (DWARF2_ADDR_SIZE, text_section_label, \"Address\");\n-  if (last_text_section == in_unlikely_executed_text\n-      || (last_text_section == in_named\n-\t  && last_text_section_name == unlikely_text_section_name))\n-    dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n-\t\t\t  unlikely_section_label, \"Length\");\n-  else\n-    dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n-\t\t\t  text_section_label, \"Length\");\n+  dw2_asm_output_delta (DWARF2_ADDR_SIZE, text_end_label,\n+\t\t\ttext_section_label, \"Length\");\n+  if (flag_reorder_blocks_and_partition)\n+    {\n+      dw2_asm_output_addr (DWARF2_ADDR_SIZE, cold_text_section_label, \n+\t\t\t   \"Address\");\n+      dw2_asm_output_delta (DWARF2_ADDR_SIZE, cold_end_label,\n+\t\t\t    cold_text_section_label, \"Length\");\n+    }\n \n   for (i = 0; i < arange_table_in_use; i++)\n     {\n@@ -7332,24 +7342,11 @@ output_ranges (void)\n \t     base of the text section.  */\n \t  if (separate_line_info_table_in_use == 0)\n \t    {\n-\t      if (last_text_section == in_unlikely_executed_text\n-\t\t  || (last_text_section == in_named\n-\t\t      && last_text_section_name == unlikely_text_section_name))\n-\t\t{\n-\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n-\t\t\t\t\tunlikely_section_label,\n-\t\t\t\t\tfmt, i * 2 * DWARF2_ADDR_SIZE);\n-\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n-\t\t\t\t\tunlikely_section_label, NULL);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n-\t\t\t\t\ttext_section_label,\n-\t\t\t\t\tfmt, i * 2 * DWARF2_ADDR_SIZE);\n-\t\t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n-\t\t\t\t\ttext_section_label, NULL);\n-\t\t}\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, blabel,\n+\t\t\t\t    text_section_label,\n+\t\t\t\t    fmt, i * 2 * DWARF2_ADDR_SIZE);\n+\t      dw2_asm_output_delta (DWARF2_ADDR_SIZE, elabel,\n+\t\t\t\t    text_section_label, NULL);\n \t    }\n \n \t  /* Otherwise, we add a DW_AT_entry_pc attribute to force the\n@@ -7665,6 +7662,7 @@ output_line_info (void)\n   long line_delta;\n   unsigned long current_file;\n   unsigned long function;\n+  struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n   ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, 0);\n@@ -7736,8 +7734,8 @@ output_line_info (void)\n   current_line = 1;\n   if (last_text_section == in_unlikely_executed_text\n       || (last_text_section == in_named\n-\t  && last_text_section_name == unlikely_text_section_name))\n-    strcpy (prev_line_label, unlikely_section_label);\n+\t  && last_text_section_name == cfun->unlikely_text_section_name))\n+    strcpy (prev_line_label, cfun->cold_section_label);\n   else\n     strcpy (prev_line_label, text_section_label);\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n@@ -10110,6 +10108,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       const char *endname;\n       dw_loc_list_ref list;\n       rtx varloc;\n+      struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n \n       /* We need to figure out what section we should use as the base\n@@ -10135,8 +10134,8 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t}\n       else if (last_text_section == in_unlikely_executed_text\n \t       || (last_text_section == in_named\n-\t\t   && last_text_section_name == unlikely_text_section_name))\n-\tsecname = unlikely_section_label;\n+\t\t   && last_text_section_name == cfun->unlikely_text_section_name))\n+\tsecname = cfun->cold_section_label;\n       else\n \tsecname = text_section_label;\n \n@@ -13229,6 +13228,7 @@ dwarf2out_var_location (rtx loc_note)\n   static rtx last_insn;\n   static const char *last_label;\n   tree decl;\n+  struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n   if (!DECL_P (NOTE_VAR_LOCATION_DECL (loc_note)))\n     return;\n@@ -13257,8 +13257,8 @@ dwarf2out_var_location (rtx loc_note)\n \n   if (last_text_section == in_unlikely_executed_text\n       || (last_text_section == in_named\n-\t  && last_text_section_name == unlikely_text_section_name))\n-    newloc->section_label = unlikely_section_label;\n+\t  && last_text_section_name == cfun->unlikely_text_section_name))\n+    newloc->section_label = cfun->cold_section_label;\n   else\n     newloc->section_label = text_section_label;\n \n@@ -13496,6 +13496,9 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label,\n \t\t\t       DEBUG_ABBREV_SECTION_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (text_section_label, TEXT_SECTION_LABEL, 0);\n+  ASM_GENERATE_INTERNAL_LABEL (cold_text_section_label, \n+\t\t\t       COLD_TEXT_SECTION_LABEL, 0);\n+  ASM_GENERATE_INTERNAL_LABEL (cold_end_label, COLD_END_LABEL, 0);\n \n   ASM_GENERATE_INTERNAL_LABEL (debug_info_section_label,\n \t\t\t       DEBUG_INFO_SECTION_LABEL, 0);\n@@ -13520,6 +13523,11 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n \n   text_section ();\n   ASM_OUTPUT_LABEL (asm_out_file, text_section_label);\n+  if (flag_reorder_blocks_and_partition)\n+    {\n+      unlikely_text_section ();\n+      ASM_OUTPUT_LABEL (asm_out_file, cold_text_section_label);\n+    }\n }\n \n /* A helper function for dwarf2out_finish called through\n@@ -13851,6 +13859,11 @@ dwarf2out_finish (const char *filename)\n   /* Output a terminator label for the .text section.  */\n   text_section ();\n   targetm.asm_out.internal_label (asm_out_file, TEXT_END_LABEL, 0);\n+  if (flag_reorder_blocks_and_partition)\n+    {\n+      unlikely_text_section ();\n+      targetm.asm_out.internal_label (asm_out_file, COLD_END_LABEL, 0);\n+    }\n \n   /* Output the source line correspondence table.  We must do this\n      even if there is no line information.  Otherwise, on an empty"}, {"sha": "d1f006ba1e82617416779619934f9b6910531d79", "filename": "gcc/function.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -349,6 +349,20 @@ struct function GTY(())\n   /* The variables unexpanded so far.  */\n   tree unexpanded_var_list;\n \n+  /* Assembly labels for the hot and cold text sections, to\n+     be used by debugger functions for determining the size of text\n+     sections.  */\n+\n+  const char * hot_section_label;\n+  const char * cold_section_label;\n+  const char * hot_section_end_label;\n+  const char * cold_section_end_label;\n+\n+  /* String to be used for name of cold text sections, via\n+     targetm.asm_out.named_section.  */\n+\n+  const char *unlikely_text_section_name;\n+\n   /* Collected bit flags.  */\n \n   /* Nonzero if function being compiled needs to be given an address"}, {"sha": "c2cf1251cc9a804ced5b58199a6ddaddd4af4cf1", "filename": "gcc/opts.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -678,6 +678,15 @@ decode_options (unsigned int argc, const char **argv)\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n+\n+  if (flag_reorder_blocks_and_partition\n+      && !targetm.have_named_sections)\n+    {\n+      inform \n+       (\"-freorder-blocks-and-partition does not work on this architecture.\");\n+      flag_reorder_blocks_and_partition = 0;\n+      flag_reorder_blocks = 1;\n+    }\n }\n \n /* Handle target- and language-independent options.  Return zero to"}, {"sha": "ac90908baf87c8b82d70781a7fefb123a19d5f73", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -453,11 +453,6 @@ enum in_section { no_section, in_text, in_unlikely_executed_text, in_data,\n #endif\n };\n \n-extern char *unlikely_section_label;\n-extern char *hot_section_label;\n-extern char *hot_section_end_label;\n-extern char *cold_section_end_label;\n-extern char *unlikely_text_section_name;\n extern const char *last_text_section_name;\n extern enum in_section last_text_section;\n extern bool first_function_block_is_cold;"}, {"sha": "fa9bc22fbd30abf960d4a53a9009cae35fe0b8a3", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -329,11 +329,6 @@ rest_of_handle_final (void)\n \n   timevar_push (TV_SYMOUT);\n   (*debug_hooks->function_decl) (current_function_decl);\n-  if (unlikely_text_section_name)\n-    {\n-      free (unlikely_text_section_name);\n-      unlikely_text_section_name = NULL;\n-    }\n   timevar_pop (TV_SYMOUT);\n \n   ggc_collect ();"}, {"sha": "a1859836a0a065031bb4aea11da6a962343e7932", "filename": "gcc/varasm.c", "status": "modified", "additions": 134, "deletions": 98, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5e625da47c6215bb0075bfdf7da3a7595d16a32/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e5e625da47c6215bb0075bfdf7da3a7595d16a32", "patch": "@@ -101,40 +101,6 @@ tree last_assemble_variable_decl;\n \n bool first_function_block_is_cold;\n \n-/* The following global variable indicates the label name to be put at\n-   the start of the first cold section within each function, when\n-   partitioning basic blocks into hot and cold sections.  Used for\n-   debug info.  */\n-\n-char *unlikely_section_label;\n-\n-/* The following global variable indicates the label name to be put at\n-   the start of the first hot section within each function, when\n-   partitioning basic blocks into hot and cold sections.  Used for\n-   debug info.  */\n-\n-char *hot_section_label;\n-\n-/* The following global variable indicates the label name to be put at\n-   the end of the last hot section within each function, when\n-   partitioning basic blocks into hot and cold sections.  Used for\n-   debug info.  */\n-\n-char *hot_section_end_label;\n-\n-/* The following global variable indicates the label name to be put at\n-   the end of the last cold section within each function, when\n-   partitioning basic blocks into hot and cold sections.  Used for \n-   debug info.*/\n-\n-char *cold_section_end_label;\n- \n-/* The following global variable indicates the section name to be used\n-   for the current cold section, when partitiong hot and cold basic \n-   blocks into separate sections.  */\n-\n-char *unlikely_text_section_name;\n-\n /* We give all constants their own alias set.  Perhaps redundant with\n    MEM_READONLY_P, but pre-dates it.  */\n \n@@ -210,29 +176,38 @@ EXTRA_SECTION_FUNCTIONS\n static void\n initialize_cold_section_name (void)\n {\n-  const char* name;\n+  const char *name;\n+  const char *stripped_name;\n+  char *buffer;\n   int len;\n+  struct function *cfun;\n \n-  if (! unlikely_text_section_name)\n+  if (current_function_decl)\n     {\n-      if (DECL_SECTION_NAME (current_function_decl)\n-\t  && (strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME\n-\t\t\t\t\t   (current_function_decl)),\n-\t\t      HOT_TEXT_SECTION_NAME) != 0)\n-\t  && (strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME\n-\t\t\t\t\t   (current_function_decl)),\n-\t\t      UNLIKELY_EXECUTED_TEXT_SECTION_NAME) != 0))\n+      cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n+      if (!cfun->unlikely_text_section_name)\n \t{\n-\t  name = TREE_STRING_POINTER (DECL_SECTION_NAME \n-\t\t\t\t                   (current_function_decl));\n-\t  len = strlen (name);\n-\t  unlikely_text_section_name = xmalloc (len + 10);\n-\t  sprintf (unlikely_text_section_name, \"%s%s\", name, \"_unlikely\");\n+\t  if (flag_function_sections\n+\t      && DECL_SECTION_NAME (current_function_decl))\n+\t    {\n+\t      name = xstrdup (TREE_STRING_POINTER (DECL_SECTION_NAME \n+\t\t\t\t\t\t   (current_function_decl)));\n+\t      stripped_name = targetm.strip_name_encoding (name);\n+\t      len = strlen (stripped_name);\n+\t      buffer = (char *) xmalloc (len + 10);\n+\t      sprintf (buffer, \"%s%s\", stripped_name, \"_unlikely\");\n+\t      cfun->unlikely_text_section_name = ggc_strdup (buffer);\n+\t      free (buffer);\n+\t      free ((char *) name);\n+\t    }\n+\t  else\n+\t    cfun->unlikely_text_section_name = \n+\t                                UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n \t}\n-      else\n-\tunlikely_text_section_name = \n-\t                      xstrdup (UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n     }\n+  else\n+   internal_error \n+     (\"initialize_cold_section_name called without valid current_function_decl.\");\n }\n \n /* Tell assembler to switch to text section.  */\n@@ -253,14 +228,25 @@ text_section (void)\n void\n unlikely_text_section (void)\n {\n-  if (! unlikely_text_section_name)\n-    initialize_cold_section_name ();\n+  if (current_function_decl)\n+    {\n+      struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n-  if ((in_section != in_unlikely_executed_text)\n-      &&  (in_section != in_named \n-\t   || strcmp (in_named_name, unlikely_text_section_name) != 0))\n+      if (!cfun->unlikely_text_section_name)\n+\tinitialize_cold_section_name ();\n+\n+      if ((in_section != in_unlikely_executed_text)\n+\t  &&  (in_section != in_named \n+\t       || strcmp (in_named_name, cfun->unlikely_text_section_name) != 0))\n+\t{\n+\t  named_section (NULL_TREE, cfun->unlikely_text_section_name, 0);\n+\t  in_section = in_unlikely_executed_text;\n+\t  last_text_section = in_unlikely_executed_text;\n+\t}\n+    }\n+  else\n     {\n-      named_section (NULL_TREE, unlikely_text_section_name, 0);\n+      named_section (NULL_TREE, UNLIKELY_EXECUTED_TEXT_SECTION_NAME, 0);\n       in_section = in_unlikely_executed_text;\n       last_text_section = in_unlikely_executed_text;\n     }\n@@ -314,11 +300,25 @@ int\n in_unlikely_text_section (void)\n {\n   bool ret_val;\n+  struct function *cfun;\n \n-  ret_val = ((in_section == in_unlikely_executed_text)\n-\t     || (in_section == in_named\n-\t\t && unlikely_text_section_name\n-\t\t && strcmp (in_named_name, unlikely_text_section_name) == 0));\n+  if (current_function_decl)\n+    {\n+      cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n+\n+      ret_val = ((in_section == in_unlikely_executed_text)\n+\t\t || (in_section == in_named\n+\t\t     && cfun->unlikely_text_section_name\n+\t\t     && strcmp (in_named_name, \n+\t\t\t\tcfun->unlikely_text_section_name) == 0));\n+    }\n+  else\n+    {\n+      ret_val = ((in_section == in_unlikely_executed_text)\n+\t\t || (in_section == in_named\n+\t\t     && strcmp (in_named_name,\n+\t\t\t\tUNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0));\n+    }\n \n   return ret_val;\n }\n@@ -463,9 +463,12 @@ named_section (tree decl, const char *name, int reloc)\n     name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n \n   if (strcmp (name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0\n-      && !unlikely_text_section_name)\n-      unlikely_text_section_name =\n-\txstrdup (UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n+      && current_function_decl\n+      && !(DECL_STRUCT_FUNCTION (current_function_decl))->unlikely_text_section_name)\n+    {\n+      struct function *cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n+      cfun->unlikely_text_section_name = UNLIKELY_EXECUTED_TEXT_SECTION_NAME;\n+    }\n \n   flags = targetm.section_type_flags (decl, name, reloc);\n \n@@ -574,16 +577,17 @@ asm_output_aligned_bss (FILE *file, tree decl ATTRIBUTE_UNUSED,\n void\n function_section (tree decl)\n {\n-  bool unlikely = false;\n+  int reloc = 0;\n     \n   if (first_function_block_is_cold)\n-    unlikely = true;\n+    reloc = 1;\n   \n #ifdef USE_SELECT_SECTION_FOR_FUNCTIONS\n-  targetm.asm_out.select_section (decl, unlikely, DECL_ALIGN (decl));\n+  targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n #else\n   if (decl != NULL_TREE\n-      && DECL_SECTION_NAME (decl) != NULL_TREE)\n+      && DECL_SECTION_NAME (decl) != NULL_TREE\n+      && targetm.have_named_sections)\n     named_section (decl, (char *) 0, 0);\n   else\n     text_section ();\n@@ -594,16 +598,20 @@ void\n current_function_section (tree decl)\n {\n #ifdef USE_SELECT_SECTION_FOR_FUNCTIONS\n-  bool unlikely = (in_unlikely_text_section () \n-\t\t   || (last_text_section == in_unlikely_executed_text));\n-  \n-  targetm.asm_out.select_section (decl, unlikely, DECL_ALIGN (decl));\n+  int reloc = 0; \n+\n+  if (in_unlikely_text_section () \n+      || last_text_section == in_unlikely_executed_text)\n+    reloc = 1;\n+ \n+  targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n #else\n   if (last_text_section == in_unlikely_executed_text)\n     unlikely_text_section ();\n   else if (last_text_section == in_text)\n     text_section ();\n-  else if (last_text_section == in_named)\n+  else if (last_text_section == in_named\n+\t   && targetm.have_named_sections)\n     named_section (NULL_TREE, last_text_section_name, 0);\n   else\n     function_section (decl);\n@@ -1224,18 +1232,32 @@ void\n assemble_start_function (tree decl, const char *fnname)\n {\n   int align;\n+  char tmp_label[100];\n   bool hot_label_written = false;\n+  struct function *cfun = DECL_STRUCT_FUNCTION (decl);\n \n-  unlikely_text_section_name = NULL;\n-  \n+  cfun->unlikely_text_section_name = NULL;\n+ \n   first_function_block_is_cold = false;\n-  hot_section_label = reconcat (hot_section_label, fnname, \".hot_section\", NULL);\n-  unlikely_section_label = reconcat (unlikely_section_label, \n-\t\t\t\t     fnname, \".unlikely_section\", NULL);\n-  hot_section_end_label = reconcat (hot_section_end_label,\n-\t\t\t\t    fnname, \".end\", NULL);\n-  cold_section_end_label = reconcat (cold_section_end_label,\n-\t\t\t\t    fnname, \".end.cold\", NULL);\n+  if (flag_reorder_blocks_and_partition)\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"HOTB\", const_labelno);\n+      cfun->hot_section_label = ggc_strdup (tmp_label);\n+      ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"COLDB\", const_labelno);\n+      cfun->cold_section_label = ggc_strdup (tmp_label);\n+      ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"HOTE\", const_labelno);\n+      cfun->hot_section_end_label = ggc_strdup (tmp_label);\n+      ASM_GENERATE_INTERNAL_LABEL (tmp_label, \"COLDE\", const_labelno);\n+      cfun->cold_section_end_label = ggc_strdup (tmp_label);\n+      const_labelno++;\n+    }\n+  else\n+    {\n+      cfun->hot_section_label = NULL;\n+      cfun->cold_section_label = NULL;\n+      cfun->hot_section_end_label = NULL;\n+      cfun->cold_section_end_label = NULL;\n+    }\n \n   /* The following code does not need preprocessing in the assembler.  */\n \n@@ -1253,15 +1275,15 @@ assemble_start_function (tree decl, const char *fnname)\n     {\n       unlikely_text_section ();\n       assemble_align (FUNCTION_BOUNDARY);\n-      ASM_OUTPUT_LABEL (asm_out_file, unlikely_section_label);\n+      ASM_OUTPUT_LABEL (asm_out_file, cfun->cold_section_label);\n       if (BB_PARTITION (ENTRY_BLOCK_PTR->next_bb) == BB_COLD_PARTITION)\n \t{\n \t  /* Since the function starts with a cold section, we need to\n \t     explicitly align the hot section and write out the hot\n \t     section label.  */\n \t  text_section ();\n \t  assemble_align (FUNCTION_BOUNDARY);\n-\t  ASM_OUTPUT_LABEL (asm_out_file, hot_section_label);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_label);\n \t  hot_label_written = true;\n \t  first_function_block_is_cold = true;\n \t}\n@@ -1291,8 +1313,8 @@ assemble_start_function (tree decl, const char *fnname)\n \ts[i] = (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)))[i];\n       s[len] = '\\0';\n       \n-      if (unlikely_text_section_name \n-\t  && (strcmp (s, unlikely_text_section_name) == 0))\n+      if (cfun->unlikely_text_section_name \n+\t  && (strcmp (s, cfun->unlikely_text_section_name) == 0))\n \tfirst_function_block_is_cold = true;\n     }\n \n@@ -1303,8 +1325,8 @@ assemble_start_function (tree decl, const char *fnname)\n   /* Switch to the correct text section for the start of the function.  */\n \n   function_section (decl);\n-  if (!hot_label_written)\n-    ASM_OUTPUT_LABEL (asm_out_file, hot_section_label);\n+  if (flag_reorder_blocks_and_partition && !hot_label_written)\n+    ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_label);\n \n   /* Tell assembler to move to target machine's alignment for functions.  */\n   align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n@@ -1366,7 +1388,6 @@ assemble_start_function (tree decl, const char *fnname)\n void\n assemble_end_function (tree decl, const char *fnname)\n {\n-  enum in_section save_text_section;\n #ifdef ASM_DECLARE_FUNCTION_SIZE\n   ASM_DECLARE_FUNCTION_SIZE (asm_out_file, fnname, decl);\n #endif\n@@ -1377,13 +1398,19 @@ assemble_end_function (tree decl, const char *fnname)\n     }\n   /* Output labels for end of hot/cold text sections (to be used by\n      debug info.)  */\n-  save_text_section = in_section;\n-  unlikely_text_section ();\n-  ASM_OUTPUT_LABEL (asm_out_file, cold_section_end_label);\n-  text_section ();\n-  ASM_OUTPUT_LABEL (asm_out_file, hot_section_end_label);\n-  if (save_text_section == in_unlikely_executed_text)\n-    unlikely_text_section ();\n+  if (flag_reorder_blocks_and_partition)\n+    {\n+      enum in_section save_text_section;\n+      struct function *cfun = DECL_STRUCT_FUNCTION (decl);\n+\n+      save_text_section = in_section;\n+      unlikely_text_section ();\n+      ASM_OUTPUT_LABEL (asm_out_file, cfun->cold_section_end_label);\n+      text_section ();\n+      ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_end_label);\n+      if (save_text_section == in_unlikely_executed_text)\n+\tunlikely_text_section ();\n+    }\n }\n \f\n /* Assemble code to leave SIZE bytes of zeros.  */\n@@ -4766,14 +4793,23 @@ default_section_type_flags_1 (tree decl, const char *name, int reloc,\n \t\t\t      int shlib)\n {\n   unsigned int flags;\n+  struct function *cfun = NULL;\n+\n+  if (current_function_decl)\n+    cfun = DECL_STRUCT_FUNCTION (current_function_decl);\n \n   if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n     flags = SECTION_CODE;\n   else if (decl && decl_readonly_section_1 (decl, reloc, shlib))\n     flags = 0;\n-  else if (unlikely_text_section_name\n-\t   && strcmp (name, unlikely_text_section_name) == 0)\n+  else if (current_function_decl\n+\t   && cfun->unlikely_text_section_name\n+\t   && strcmp (name, cfun->unlikely_text_section_name) == 0)\n     flags = SECTION_CODE;\n+  else if (!decl \n+\t   && !current_function_decl\n+\t   && strcmp (name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0)\n+    flags = SECTION_CODE; \n   else\n     flags = SECTION_WRITE;\n "}]}