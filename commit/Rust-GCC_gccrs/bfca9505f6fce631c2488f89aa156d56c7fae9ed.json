{"sha": "bfca9505f6fce631c2488f89aa156d56c7fae9ed", "node_id": "C_kwDOANBUbNoAKGJmY2E5NTA1ZjZmY2U2MzFjMjQ4OGY4OWFhMTU2ZDU2YzdmYWU5ZWQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-10-05T00:19:07Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-10-05T00:19:07Z"}, "message": "analyzer: revamp side-effects of call summaries [PR107072]\n\nWith -fanalyzer-call-summaries the analyzer canl attempt to summarize\nthe effects of some function calls at their call site, rather than\nsimulate the call directly, which can avoid big slowdowns during\nanalysis.\n\nPreviously, this summarization was extremely simplistic: no attempt\nwas made to update sm-state, and region_model::update_for_call_summary\nwould simply set the return value of the function to UNKNOWN, and assume\nthe function had no side effects.\n\nThis patch implements less simplistic summarizations: it tracks each\npossible return enode from the called function, and attempts to generate\na successor enode from the callsite for each that have compatible\nconditions, mapping state changes in the summary to state changes\nat the callsite.  It also implements the beginnings of heuristics for\ngenerating user-facing descriptions of a summary e.g.\n  \"when 'foo' returns NULL\"\nversus:\n  \"when 'foo' returns a heap-allocated buffer\"\n\nThis still has some bugs, but much more accurately tracks the effects\nof a call, and so is an improvement; it should only have an effect\nwhen -fanalyzer-call-summaries is enabled.\n\nAs before, -fanalyzer-call-summaries is disabled by default in\nanalyzer.opt (but enabled by default in the test suite).\n\ngcc/ChangeLog:\n\tPR analyzer/107072\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/call-summary.o.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/107072\n\t* analyzer-logging.h: Include \"diagnostic-core.h\".\n\t* analyzer.h: Include \"function.h\".\n\t(class call_summary): New forward decl.\n\t(class call_summary_replay): New forward decl.\n\t(struct per_function_data): New forward decl.\n\t(struct interesting_t): New forward decl.\n\t(custom_edge_info::update_state): New vfunc.\n\t* call-info.cc (custom_edge_info::update_state): New.\n\t* call-summary.cc: New file.\n\t* call-summary.h: New file.\n\t* constraint-manager.cc: Include \"analyzer/call-summary.h\".\n\t(class replay_fact_visitor): New.\n\t(constraint_manager::replay_call_summary): New.\n\t* constraint-manager.h (constraint_manager::replay_call_summary):\n\tNew.\n\t* engine.cc: Include \"analyzer/call-summary.h\".\n\t(exploded_node::on_stmt): Handle call summaries.\n\t(class call_summary_edge_info): New.\n\t(exploded_node::replay_call_summaries): New.\n\t(exploded_node::replay_call_summary): New.\n\t(per_function_data::~per_function_data): New.\n\t(per_function_data::add_call_summary): Move here from header and\n\treimplement.\n\t(exploded_graph::process_node): Call update_state rather than\n\tupdate_model when handling bifurcation\n\t(viz_callgraph_node::dump_dot): Use a regular label rather\n\tthan an HTML table; add summaries to dump.\n\t* exploded-graph.h: Include \"alloc-pool.h\", \"fibonacci_heap.h\",\n\t\"supergraph.h\", \"sbitmap.h\", \"shortest-paths.h\", \"analyzer/sm.h\",\n\t\"analyzer/program-state.h\", and \"analyzer/diagnostic-manager.h\".\n\t(exploded_node::replay_call_summaries): New decl.\n\t(exploded_node::replay_call_summary): New decl.\n\t(per_function_data::~per_function_data): New decl.\n\t(per_function_data::add_call_summary): Move implemention from\n\theader.\n\t(per_function_data::m_summaries): Update type of element.\n\t* known-function-manager.h: Include \"analyzer/analyzer-logging.h\".\n\t* program-point.h: Include \"pretty-print.h\" and\n\t\"analyzer/call-string.h\".\n\t* program-state.cc: Include \"analyzer/call-summary.h\".\n\t(sm_state_map::replay_call_summary): New.\n\t(program_state::replay_call_summary): New.\n\t* program-state.h (sm_state_map::replay_call_summary): New decl.\n\t(program_state::replay_call_summary): New decl.\n\t* region-model-manager.cc\n\t(region_model_manager::get_or_create_asm_output_svalue): New\n\toverload.\n\t* region-model-manager.h\n\t(region_model_manager::get_or_create_asm_output_svalue): New\n\toverload decl.\n\t* region-model.cc: Include \"analyzer/call-summary.h\".\n\t(region_model::maybe_update_for_edge): Remove call to\n\tregion_model::update_for_call_summary on\n\tSUPEREDGE_INTRAPROCEDURAL_CALL.\n\t(region_model::update_for_call_summary): Delete.\n\t(region_model::replay_call_summary): New.\n\t* region-model.h (region_model::replay_call_summary): New decl.\n\t(region_model::update_for_call_summary): Delete decl.\n\t* store.cc: Include \"analyzer/call-summary.h\".\n\t(store::replay_call_summary): New.\n\t(store::replay_call_summary_cluster): New.\n\t* store.h: Include \"tristate.h\".\n\t(is_a_helper <const ana::concrete_binding *>::test): New.\n\t(store::replay_call_summary): New decl.\n\t(store::replay_call_summary_cluster): New decl.\n\t* supergraph.cc (get_ultimate_function_for_cgraph_edge): Remove\n\t\"static\" from decl.\n\t(supergraph_call_edge): Make stmt param const.\n\t* supergraph.h: Include \"ordered-hash-map.h\", \"cfg.h\",\n\t\"basic-block.h\", \"gimple.h\", \"gimple-iterator.h\", and \"digraph.h\".\n\t(supergraph_call_edge): Make stmt param const.\n\t(get_ultimate_function_for_cgraph_edge): New decl.\n\t* svalue.cc (compound_svalue::compound_svalue): Assert that we're\n\tnot nesting compound_svalues.\n\t* svalue.h: Include \"json.h\", \"analyzer/store.h\", and\n\t\"analyzer/program-point.h\".\n\t(asm_output_svalue::get_num_outputs): New accessor.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/107072\n\t* gcc.dg/analyzer/call-summaries-2.c: New test.\n\t* gcc.dg/analyzer/call-summaries-3.c: New test.\n\t* gcc.dg/analyzer/call-summaries-asm-x86.c: New test.\n\t* gcc.dg/analyzer/call-summaries-malloc.c: New test.\n\t* gcc.dg/analyzer/call-summaries-pr107072.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "655ae3b5c555f4ff9d12b96cdaebafd0b4d02e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/655ae3b5c555f4ff9d12b96cdaebafd0b4d02e38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfca9505f6fce631c2488f89aa156d56c7fae9ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfca9505f6fce631c2488f89aa156d56c7fae9ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfca9505f6fce631c2488f89aa156d56c7fae9ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfca9505f6fce631c2488f89aa156d56c7fae9ed/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0167154cdd02c9508239982ea7568a7a8cee080e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0167154cdd02c9508239982ea7568a7a8cee080e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0167154cdd02c9508239982ea7568a7a8cee080e"}], "stats": {"total": 2533, "additions": 2479, "deletions": 54}, "files": [{"sha": "f672e6ea5498ceac781486f053238209326129e6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -1255,6 +1255,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/bar-chart.o \\\n \tanalyzer/call-info.o \\\n \tanalyzer/call-string.o \\\n+\tanalyzer/call-summary.o \\\n \tanalyzer/checker-path.o \\\n \tanalyzer/complexity.o \\\n \tanalyzer/constraint-manager.o \\"}, {"sha": "71b540c65183e0b31b35d1428c406ffcc6f08088", "filename": "gcc/analyzer/analyzer-logging.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fanalyzer-logging.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fanalyzer-logging.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-logging.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -23,6 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef ANALYZER_LOGGING_H\n #define ANALYZER_LOGGING_H\n \n+#include \"diagnostic-core.h\"\n+\n namespace ana {\n \n /* A logger encapsulates a logging stream: a way to send"}, {"sha": "49c19af7fc04beefebd1b899cdac98db6b614a4a", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_ANALYZER_H\n #define GCC_ANALYZER_ANALYZER_H\n \n+#include \"function.h\"\n+\n class graphviz_out;\n \n namespace ana {\n@@ -114,6 +116,10 @@ class state_machine;\n class logger;\n class visitor;\n class known_function_manager;\n+class call_summary;\n+class call_summary_replay;\n+struct per_function_data;\n+struct interesting_t;\n \n /* Forward decls of functions.  */\n \n@@ -263,6 +269,11 @@ class custom_edge_info\n   /* Hook for making .dot label more readable.  */\n   virtual void print (pretty_printer *pp) const = 0;\n \n+  /* Hook for updating STATE when handling bifurcation.  */\n+  virtual bool update_state (program_state *state,\n+\t\t\t     const exploded_edge *eedge,\n+\t\t\t     region_model_context *ctxt) const;\n+\n   /* Hook for updating MODEL within exploded_path::feasible_p\n      and when handling bifurcation.  */\n   virtual bool update_model (region_model *model,"}, {"sha": "d9a261fe217e4b4af6a5ea7347bf3c392944c5c7", "filename": "gcc/analyzer/call-info.cc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fcall-info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fcall-info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-info.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -66,7 +66,17 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n-/* class call_info : public custom_eedge_info_t.  */\n+/* class custom_edge_info.  */\n+\n+bool\n+custom_edge_info::update_state (program_state *state,\n+\t\t\t\tconst exploded_edge *eedge,\n+\t\t\t\tregion_model_context *ctxt) const\n+{\n+  return update_model (state->m_region_model, eedge, ctxt);\n+}\n+\n+/* class call_info : public custom_edge_info.  */\n \n /* Implementation of custom_edge_info::print vfunc for call_info:\n    use get_desc to get a label_text, and print it to PP.  */"}, {"sha": "9d8716da96eeb409e31b83649b337b6ca750b48e", "filename": "gcc/analyzer/call-summary.cc", "status": "added", "additions": 875, "deletions": 0, "changes": 875, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fcall-summary.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fcall-summary.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-summary.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -0,0 +1,875 @@\n+/* Classes for working with summaries of function calls.\n+   Copyright (C) 2022 David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tree-dfa.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/call-summary.h\"\n+#include \"analyzer/exploded-graph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class call_summary.  */\n+\n+const program_state &\n+call_summary::get_state () const\n+{\n+  return m_enode->get_state ();\n+}\n+\n+tree\n+call_summary::get_fndecl () const\n+{\n+  return m_enode->get_point ().get_fndecl ();\n+}\n+\n+label_text\n+call_summary::get_desc () const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+\n+  get_user_facing_desc (&pp);\n+  if (flag_analyzer_verbose_edges)\n+    pp_printf (&pp, \" (call summary; EN: %i)\", m_enode->m_index);\n+\n+  return label_text::take (xstrdup (pp_formatted_text (&pp)));\n+}\n+\n+/* Generate a user-facing description of this call summary.c\n+   This has various heuristics for distinguishing between different\n+   summaries.\n+   This will help with debugging, too.  */\n+\n+void\n+call_summary::get_user_facing_desc (pretty_printer *pp) const\n+{\n+  tree fndecl = get_fndecl ();\n+\n+  /* If there are multiple summaries, try to use the return value to\n+     distinguish between them.  */\n+  if (m_per_fn_data->m_summaries.length () > 1)\n+    {\n+      if (tree result = DECL_RESULT (fndecl))\n+\t{\n+\t  const region *result_reg\n+\t    = get_state ().m_region_model->get_lvalue (result, NULL);\n+\t  const svalue *result_sval\n+\t    = get_state ().m_region_model->get_store_value (result_reg, NULL);\n+\t  switch (result_sval->get_kind ())\n+\t    {\n+\t    default:\n+\t      break;\n+\t    case SK_REGION:\n+\t      {\n+\t\tconst region_svalue *region_sval\n+\t\t  = as_a <const region_svalue *> (result_sval);\n+\t\tconst region *pointee_reg = region_sval->get_pointee ();\n+\t\tswitch (pointee_reg->get_kind ())\n+\t\t  {\n+\t\t  default:\n+\t\t    break;\n+\t\t  case RK_HEAP_ALLOCATED:\n+\t\t    pp_printf (pp,\n+\t\t\t       \"when %qE returns pointer\"\n+\t\t\t       \" to heap-allocated buffer\",\n+\t\t\t       fndecl);\n+\t\t    return;\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    case SK_CONSTANT:\n+\t      {\n+\t\tconst constant_svalue *constant_sval\n+\t\t  = as_a <const constant_svalue *> (result_sval);\n+\t\ttree cst = constant_sval->get_constant ();\n+\t\tif (POINTER_TYPE_P (TREE_TYPE (result))\n+\t\t    && zerop (cst))\n+\t\t  pp_printf (pp, \"when %qE returns NULL\", fndecl);\n+\t\telse\n+\t\t  pp_printf (pp, \"when %qE returns %qE\", fndecl, cst);\n+\t\treturn;\n+\t      }\n+\t    }\n+\t}\n+    }\n+\n+  /* Fallback.  */\n+  pp_printf (pp, \"when %qE returns\", fndecl);\n+}\n+\n+/* Dump a multiline representation of this object to PP.  */\n+\n+void\n+call_summary::dump_to_pp (const extrinsic_state &ext_state,\n+\t\t\t  pretty_printer *pp,\n+\t\t\t  bool simple) const\n+{\n+  label_text desc = get_desc ();\n+  pp_printf (pp, \"desc: %qs\", desc.get ());\n+  pp_newline (pp);\n+\n+  get_state ().dump_to_pp (ext_state, simple, true, pp);\n+}\n+\n+/* Dump a multiline representation of this object to FILE.  */\n+\n+void\n+call_summary::dump (const extrinsic_state &ext_state,\n+\t\t    FILE *fp,\n+\t\t    bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = fp;\n+  dump_to_pp (ext_state, &pp, simple);\n+  pp_flush (&pp);\n+}\n+\n+/* Dump a multiline representation of this object to stderr.  */\n+\n+DEBUG_FUNCTION void\n+call_summary::dump (const extrinsic_state &ext_state, bool simple) const\n+{\n+  dump (ext_state, stderr, simple);\n+}\n+\n+/* class call_summary_replay.  */\n+\n+/* call_summary_replay's ctor.\n+   Populate the cache with params for the summary based on\n+   arguments at the caller. */\n+\n+call_summary_replay::call_summary_replay (const call_details &cd,\n+\t\t\t\t\t  function *called_fn,\n+\t\t\t\t\t  call_summary *summary,\n+\t\t\t\t\t  const extrinsic_state &ext_state)\n+: m_cd (cd),\n+  m_called_fn (called_fn),\n+  m_summary (summary),\n+  m_ext_state (ext_state)\n+{\n+  region_model_manager *mgr = cd.get_manager ();\n+\n+  // populate params based on args\n+  tree fndecl = called_fn->decl;\n+\n+  /* Get a frame_region for use with respect to the summary.\n+     This will be a top-level frame, since that's what's in\n+     the summary.  */\n+  const frame_region *summary_frame\n+    = mgr->get_frame_region (NULL, called_fn);\n+\n+  unsigned idx = 0;\n+  for (tree iter_parm = DECL_ARGUMENTS (fndecl); iter_parm;\n+       iter_parm = DECL_CHAIN (iter_parm), ++idx)\n+    {\n+      /* If there's a mismatching declaration, the call stmt might\n+\t not have enough args.  Handle this case by leaving the\n+\t rest of the params as uninitialized.  */\n+      if (idx >= cd.num_args ())\n+\tbreak;\n+      const svalue *caller_arg_sval = cd.get_arg_svalue (idx);\n+      tree parm_lval = iter_parm;\n+      if (tree parm_default_ssa = ssa_default_def (called_fn, iter_parm))\n+\tparm_lval = parm_default_ssa;\n+      const region *summary_parm_reg\n+\t= summary_frame->get_region_for_local (mgr, parm_lval, cd.get_ctxt ());\n+      const svalue *summary_initial_parm_reg\n+\t= mgr->get_or_create_initial_value (summary_parm_reg);\n+      add_svalue_mapping (summary_initial_parm_reg, caller_arg_sval);\n+    }\n+\n+  /* Handle any variadic args.  */\n+  unsigned va_arg_idx = 0;\n+  for (; idx < cd.num_args (); idx++, va_arg_idx++)\n+    {\n+      const svalue *caller_arg_sval = cd.get_arg_svalue (idx);\n+      const region *summary_var_arg_reg\n+\t= mgr->get_var_arg_region (summary_frame, va_arg_idx);\n+      const svalue *summary_initial_var_arg_reg\n+\t= mgr->get_or_create_initial_value (summary_var_arg_reg);\n+      add_svalue_mapping (summary_initial_var_arg_reg, caller_arg_sval);\n+    }\n+}\n+\n+/* Try to convert SUMMARY_SVAL in the summary to a corresponding svalue\n+   in the caller, caching the result.\n+\n+   Return NULL if the conversion is not possible.  */\n+\n+const svalue *\n+call_summary_replay::convert_svalue_from_summary (const svalue *summary_sval)\n+{\n+  gcc_assert (summary_sval);\n+\n+  if (const svalue **slot\n+\t= m_map_svalue_from_summary_to_caller.get (summary_sval))\n+    return *slot;\n+\n+  const svalue *caller_sval = convert_svalue_from_summary_1 (summary_sval);\n+\n+  /* Add to cache.  */\n+  add_svalue_mapping (summary_sval, caller_sval);\n+\n+  return caller_sval;\n+}\n+\n+/* Implementation of call_summary_replay::convert_svalue_from_summary.  */\n+\n+const svalue *\n+call_summary_replay::convert_svalue_from_summary_1 (const svalue *summary_sval)\n+{\n+  gcc_assert (summary_sval);\n+\n+  switch (summary_sval->get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case SK_REGION:\n+      {\n+\tconst region_svalue *region_summary_sval\n+\t  = as_a <const region_svalue *> (summary_sval);\n+\tconst region *summary_reg = region_summary_sval->get_pointee ();\n+\tconst region *caller_reg = convert_region_from_summary (summary_reg);\n+\tif (!caller_reg)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\tconst svalue *caller_ptr\n+\t  = mgr->get_ptr_svalue (summary_sval->get_type (),\n+\t\t\t\t caller_reg);\n+\treturn caller_ptr;\n+      }\n+      break;\n+\n+    case SK_CONSTANT:\n+    case SK_PLACEHOLDER:\n+    case SK_POISONED:\n+    case SK_UNKNOWN:\n+      return summary_sval;\n+\n+    case SK_SETJMP:\n+      return NULL; // TODO\n+\n+    case SK_INITIAL:\n+      {\n+\tconst initial_svalue *initial_summary_sval\n+\t  = as_a <const initial_svalue *> (summary_sval);\n+\t/* Params should already be in the cache, courtesy of the ctor.  */\n+\tgcc_assert (!initial_summary_sval->initial_value_of_param_p ());\n+\n+\t/* Initial value of region within the summary is the value of the\n+\t   region at the point of the call.  */\n+\tconst region *summary_reg = initial_summary_sval->get_region ();\n+\tconst region *caller_reg = convert_region_from_summary (summary_reg);\n+\tif (!caller_reg)\n+\t  return NULL;\n+\tconst svalue *caller_sval\n+\t  = m_cd.get_model ()->get_store_value (caller_reg, m_cd.get_ctxt ());\n+\treturn caller_sval;\n+      }\n+      break;\n+    case SK_UNARYOP:\n+      {\n+\tconst unaryop_svalue *unaryop_summary_sval\n+\t  = as_a <const unaryop_svalue *> (summary_sval);\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_unaryop\n+\t  (summary_sval->get_type (),\n+\t   unaryop_summary_sval->get_op (),\n+\t   convert_svalue_from_summary (unaryop_summary_sval->get_arg ()));\n+      }\n+      break;\n+    case SK_BINOP:\n+      {\n+\tconst binop_svalue *binop_summary_sval\n+\t  = as_a <const binop_svalue *> (summary_sval);\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_binop\n+\t  (summary_sval->get_type (),\n+\t   binop_summary_sval->get_op (),\n+\t   convert_svalue_from_summary (binop_summary_sval->get_arg0 ()),\n+\t   convert_svalue_from_summary (binop_summary_sval->get_arg1 ()));\n+      }\n+      break;\n+    case SK_SUB:\n+      {\n+\tconst sub_svalue *sub_summary_sval\n+\t  = as_a <const sub_svalue *> (summary_sval);\n+\tregion_model_manager *mgr = get_manager ();\n+\tconst svalue *summary_parent_sval = sub_summary_sval->get_parent ();\n+\tif (!summary_parent_sval)\n+\t  return NULL;\n+\tconst region *summary_subregion = sub_summary_sval->get_subregion ();\n+\tif (!summary_subregion)\n+\t  return NULL;\n+\treturn mgr->get_or_create_sub_svalue (summary_sval->get_type (),\n+\t\t\t\t\t      summary_parent_sval,\n+\t\t\t\t\t      summary_subregion);\n+      }\n+      break;\n+    case SK_REPEATED:\n+      {\n+\tconst repeated_svalue *repeated_summary_sval\n+\t  = as_a <const repeated_svalue *> (summary_sval);\n+\tconst svalue *summary_outer_size\n+\t  = repeated_summary_sval->get_outer_size ();\n+\tconst svalue *caller_outer_size\n+\t  = convert_svalue_from_summary (summary_outer_size);\n+\tif (!caller_outer_size)\n+\t  return NULL;\n+\tconst svalue *summary_inner_sval\n+\t  = repeated_summary_sval->get_inner_svalue ();\n+\tconst svalue *caller_inner_sval\n+\t  = convert_svalue_from_summary (summary_inner_sval);\n+\tif (!caller_inner_sval)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_repeated_svalue (summary_sval->get_type (),\n+\t\t\t\t\t\t   caller_outer_size,\n+\t\t\t\t\t\t   caller_inner_sval);\n+      }\n+      break;\n+    case SK_BITS_WITHIN:\n+      {\n+\tconst bits_within_svalue *bits_within_summary_sval\n+\t  = as_a <const bits_within_svalue *> (summary_sval);\n+\tconst bit_range &bits = bits_within_summary_sval->get_bits ();\n+\tconst svalue *summary_inner_sval\n+\t  = bits_within_summary_sval->get_inner_svalue ();\n+\tconst svalue *caller_inner_sval\n+\t  = convert_svalue_from_summary (summary_inner_sval);\n+\tif (!caller_inner_sval)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_bits_within (summary_sval->get_type (),\n+\t\t\t\t\t       bits,\n+\t\t\t\t\t       caller_inner_sval);\n+      }\n+      break;\n+    case SK_UNMERGEABLE:\n+      {\n+\tconst unmergeable_svalue *unmergeable_summary_sval\n+\t  = as_a <const unmergeable_svalue *> (summary_sval);\n+\tconst svalue *summary_arg_sval = unmergeable_summary_sval->get_arg ();\n+\tconst svalue *caller_arg_sval\n+\t  = convert_svalue_from_summary (summary_arg_sval);\n+\tif (!caller_arg_sval)\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_unmergeable (caller_arg_sval);\n+      }\n+      break;\n+    case SK_WIDENING:\n+      {\n+\tconst widening_svalue *widening_summary_sval\n+\t  = as_a <const widening_svalue *> (summary_sval);\n+\tconst function_point &point = widening_summary_sval->get_point ();\n+\tconst svalue *summary_base_sval\n+\t  = widening_summary_sval->get_base_svalue ();\n+\tconst svalue *caller_base_sval\n+\t  = convert_svalue_from_summary (summary_base_sval);\n+\tif (!(caller_base_sval\n+\t      && caller_base_sval->can_have_associated_state_p ()))\n+\t  return NULL;\n+\tconst svalue *summary_iter_sval\n+\t  = widening_summary_sval->get_iter_svalue ();\n+\tconst svalue *caller_iter_sval\n+\t  = convert_svalue_from_summary (summary_iter_sval);\n+\tif (!(caller_iter_sval\n+\t      && caller_iter_sval->can_have_associated_state_p ()))\n+\t  return NULL;\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_widening_svalue\n+\t  (summary_iter_sval->get_type (),\n+\t   point,\n+\t   caller_base_sval,\n+\t   caller_iter_sval);\n+      }\n+      break;\n+    case SK_COMPOUND:\n+      {\n+\tconst compound_svalue *compound_summary_sval\n+\t  = as_a <const compound_svalue *> (summary_sval);\n+\tregion_model_manager *mgr = get_manager ();\n+\tstore_manager *store_mgr = mgr->get_store_manager ();\n+\tbinding_map caller_map;\n+\tauto_vec <const binding_key *> summary_keys;\n+\tfor (auto kv : *compound_summary_sval)\n+\t  summary_keys.safe_push (kv.first);\n+\tsummary_keys.qsort (binding_key::cmp_ptrs);\n+\tfor (auto key : summary_keys)\n+\t  {\n+\t    gcc_assert (key->concrete_p ());\n+\t    /* No remapping is needed for concrete binding keys.  */\n+\n+\t    const svalue *bound_summary_sval\n+\t      = compound_summary_sval->get_map ().get (key);\n+\t    const svalue *caller_sval\n+\t      = convert_svalue_from_summary (bound_summary_sval);\n+\t    if (!caller_sval)\n+\t      caller_sval = mgr->get_or_create_unknown_svalue (NULL_TREE);\n+\n+\t    if (const compound_svalue *inner_compound_sval\n+\t\t= caller_sval->dyn_cast_compound_svalue ())\n+\t      {\n+\t\tconst concrete_binding *outer_key\n+\t\t  = as_a <const concrete_binding *> (key);\n+\t\tfor (auto inner_kv : *inner_compound_sval)\n+\t\t  {\n+\t\t    // These should already be mapped to the caller.\n+\t\t    const binding_key *inner_key = inner_kv.first;\n+\t\t    const svalue *inner_sval = inner_kv.second;\n+\t\t    gcc_assert (inner_key->concrete_p ());\n+\t\t    const concrete_binding *concrete_key\n+\t\t      = as_a <const concrete_binding *> (inner_key);\n+\t\t    bit_offset_t effective_start\n+\t\t      = (concrete_key->get_start_bit_offset ()\n+\t\t\t + outer_key->get_start_bit_offset ());\n+\t\t    const concrete_binding *effective_concrete_key\n+\t\t      = store_mgr->get_concrete_binding\n+\t\t\t  (effective_start,\n+\t\t\t   concrete_key->get_size_in_bits ());\n+\t\t    caller_map.put (effective_concrete_key, inner_sval);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      caller_map.put (key, caller_sval);\n+\t  }\n+\treturn mgr->get_or_create_compound_svalue (summary_sval->get_type (),\n+\t\t\t\t\t\t   caller_map);\n+      }\n+      break;\n+    case SK_CONJURED:\n+      {\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_unknown_svalue (summary_sval->get_type ());\n+      }\n+      break;\n+    case SK_ASM_OUTPUT:\n+      {\n+\tconst asm_output_svalue *asm_output_summary_sval\n+\t  = as_a <const asm_output_svalue *> (summary_sval);\n+\tconst char *asm_string = asm_output_summary_sval->get_asm_string ();\n+\tunsigned output_idx = asm_output_summary_sval->get_output_idx ();\n+\tunsigned num_inputs = asm_output_summary_sval->get_num_inputs ();\n+\tunsigned num_outputs = asm_output_summary_sval->get_num_outputs ();\n+\tauto_vec<const svalue *> inputs (num_inputs);\n+\tfor (unsigned idx = 0; idx < num_inputs; idx++)\n+\t  {\n+\t    const svalue *summary_input\n+\t      = asm_output_summary_sval->get_input (idx);\n+\t    const svalue *caller_input\n+\t      = convert_svalue_from_summary (summary_input);\n+\t    if (!caller_input)\n+\t      return NULL;\n+\t    inputs.safe_push (caller_input);\n+\t  }\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_asm_output_svalue (summary_sval->get_type (),\n+\t\t\t\t\t\t     asm_string,\n+\t\t\t\t\t\t     output_idx,\n+\t\t\t\t\t\t     num_outputs,\n+\t\t\t\t\t\t     inputs);\n+      }\n+      break;\n+    case SK_CONST_FN_RESULT:\n+      {\n+\tconst const_fn_result_svalue *const_fn_result_summary_sval\n+\t  = as_a <const const_fn_result_svalue *> (summary_sval);\n+\ttree fndecl = const_fn_result_summary_sval->get_fndecl ();\n+\tunsigned num_inputs = const_fn_result_summary_sval->get_num_inputs ();\n+\tauto_vec<const svalue *> inputs (num_inputs);\n+\tfor (unsigned idx = 0; idx < num_inputs; idx++)\n+\t  {\n+\t    const svalue *summary_input\n+\t      = const_fn_result_summary_sval->get_input (idx);\n+\t    const svalue *caller_input\n+\t      = convert_svalue_from_summary (summary_input);\n+\t    if (!caller_input)\n+\t      return NULL;\n+\t    inputs.safe_push (caller_input);\n+\t  }\n+\tregion_model_manager *mgr = get_manager ();\n+\treturn mgr->get_or_create_const_fn_result_svalue\n+\t  (summary_sval->get_type (),\n+\t   fndecl,\n+\t   inputs);\n+      }\n+      break;\n+    }\n+}\n+\n+/* Try to convert SUMMARY_REG in the summary to a corresponding region\n+   in the caller, caching the result.\n+\n+   Return NULL if the conversion is not possible.  */\n+\n+const region *\n+call_summary_replay::convert_region_from_summary (const region *summary_reg)\n+{\n+  gcc_assert (summary_reg);\n+\n+  if (const region **slot\n+\t= m_map_region_from_summary_to_caller.get (summary_reg))\n+    return *slot;\n+\n+  const region *caller_reg = convert_region_from_summary_1 (summary_reg);\n+\n+  /* Add to cache.  */\n+  add_region_mapping (summary_reg, caller_reg);\n+\n+  return caller_reg;\n+}\n+\n+/* Implementation of call_summary_replay::convert_region_from_summary.  */\n+\n+const region *\n+call_summary_replay::convert_region_from_summary_1 (const region *summary_reg)\n+{\n+  gcc_assert (summary_reg);\n+\n+  region_model_manager *mgr = get_manager ();\n+  switch (summary_reg->get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+      /* Top-level regions.  */\n+    case RK_FRAME:\n+    case RK_GLOBALS:\n+    case RK_CODE:\n+    case RK_STACK:\n+    case RK_HEAP:\n+    case RK_ROOT:\n+      /* These should never be pointed to by a region_svalue.  */\n+      gcc_unreachable ();\n+\n+    case RK_FUNCTION:\n+    case RK_LABEL:\n+    case RK_STRING:\n+    case RK_UNKNOWN:\n+      /* We can reuse these regions directly.  */\n+      return summary_reg;\n+\n+    case RK_SYMBOLIC:\n+      {\n+\tconst symbolic_region *summary_symbolic_reg\n+\t  = as_a <const symbolic_region *> (summary_reg);\n+\tconst svalue *summary_ptr_sval = summary_symbolic_reg->get_pointer ();\n+\tconst svalue *caller_ptr_sval\n+\t  = convert_svalue_from_summary (summary_ptr_sval);\n+\tif (!caller_ptr_sval)\n+\t  return NULL;\n+\tconst region *caller_reg\n+\t  = get_caller_model ()->deref_rvalue (caller_ptr_sval,\n+\t\t\t\t\t       NULL_TREE,\n+\t\t\t\t\t       get_ctxt ());\n+\treturn caller_reg;\n+      }\n+      break;\n+\n+    case RK_DECL:\n+      {\n+\tconst decl_region *summary_decl_reg\n+\t  = as_a <const decl_region *> (summary_reg);\n+\ttree decl = summary_decl_reg->get_decl ();\n+\tswitch (TREE_CODE (decl))\n+\t  {\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  case SSA_NAME:\n+\t    /* We don't care about writes to locals within\n+\t       the summary.  */\n+\t    return NULL;\n+\t  case VAR_DECL:\n+\t    /* We don't care about writes to locals within\n+\t       the summary.  */\n+\t    if (is_global_var (decl))\n+\t      /* If it's a global, we can reuse the region directly.  */\n+\t      return summary_reg;\n+\t    else\n+\t      /* Otherwise, we don't care about locals.  */\n+\t      return NULL;\n+\t  case RESULT_DECL:\n+\t    return m_cd.get_lhs_region ();\n+\t  case PARM_DECL:\n+\t    /* Writes (by value) to parms should be visible to the caller.  */\n+\t    return NULL;\n+\t  }\n+      }\n+      break;\n+    case RK_FIELD:\n+      {\n+\tconst field_region *summary_field_reg\n+\t  = as_a <const field_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\ttree field = summary_field_reg->get_field ();\n+\treturn mgr->get_field_region (caller_parent_reg, field);\n+      }\n+      break;\n+    case RK_ELEMENT:\n+      {\n+\tconst element_region *summary_element_reg\n+\t  = as_a <const element_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\tconst svalue *summary_index = summary_element_reg->get_index ();\n+\tconst svalue *caller_index\n+\t  = convert_svalue_from_summary (summary_index);\n+\tif (!caller_index)\n+\t  return NULL;\n+\treturn mgr->get_element_region (caller_parent_reg,\n+\t\t\t\t\tsummary_reg->get_type (),\n+\t\t\t\t\tcaller_index);\n+      }\n+      break;\n+    case RK_OFFSET:\n+      {\n+\tconst offset_region *summary_offset_reg\n+\t  = as_a <const offset_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\tconst svalue *summary_byte_offset\n+\t  = summary_offset_reg->get_byte_offset ();\n+\tconst svalue *caller_byte_offset\n+\t  = convert_svalue_from_summary (summary_byte_offset);\n+\tif (!caller_byte_offset)\n+\t  return NULL;\n+\treturn mgr->get_offset_region (caller_parent_reg,\n+\t\t\t\t       summary_reg->get_type (),\n+\t\t\t\t       caller_byte_offset);\n+      }\n+      break;\n+    case RK_SIZED:\n+      {\n+\tconst sized_region *summary_sized_reg\n+\t  = as_a <const sized_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\tconst svalue *summary_byte_size\n+\t  = summary_sized_reg->get_byte_size_sval (mgr);\n+\tconst svalue *caller_byte_size\n+\t  = convert_svalue_from_summary (summary_byte_size);\n+\tif (!caller_byte_size)\n+\t  return NULL;\n+\treturn mgr->get_sized_region (caller_parent_reg,\n+\t\t\t\t       summary_reg->get_type (),\n+\t\t\t\t       caller_byte_size);\n+      }\n+      break;\n+    case RK_CAST:\n+      {\n+\tconst cast_region *summary_cast_reg\n+\t  = as_a <const cast_region *> (summary_reg);\n+\tconst region *summary_original_reg\n+\t  = summary_cast_reg->get_original_region ();\n+\tconst region *caller_original_reg\n+\t  = convert_region_from_summary (summary_original_reg);\n+\tif (!caller_original_reg)\n+\t  return NULL;\n+\treturn mgr->get_cast_region (caller_original_reg,\n+\t\t\t\t     summary_reg->get_type ());\n+      }\n+      break;\n+    case RK_HEAP_ALLOCATED:\n+      {\n+\t/* If we have a heap-allocated region in the summary, then\n+\t   it was allocated within the callee.\n+\t   Create a new heap-allocated region to summarize this.  */\n+\treturn mgr->create_region_for_heap_alloc ();\n+      }\n+      break;\n+    case RK_ALLOCA:\n+      return NULL;\n+    case RK_BIT_RANGE:\n+      {\n+\tconst bit_range_region *summary_bit_range_reg\n+\t  = as_a <const bit_range_region *> (summary_reg);\n+\tconst region *summary_parent_reg = summary_reg->get_parent_region ();\n+\tconst region *caller_parent_reg\n+\t  = convert_region_from_summary (summary_parent_reg);\n+\tif (!caller_parent_reg)\n+\t  return NULL;\n+\tconst bit_range &bits = summary_bit_range_reg->get_bits ();\n+\treturn mgr->get_bit_range (caller_parent_reg,\n+\t\t\t\t   summary_reg->get_type (),\n+\t\t\t\t   bits);\n+      }\n+      break;\n+    case RK_VAR_ARG:\n+      return NULL;\n+    }\n+}\n+\n+/* Try to convert SUMMARY_KEY in the summary to a corresponding binding key\n+   in the caller.\n+\n+   Return NULL if the conversion is not possible.  */\n+\n+const binding_key *\n+call_summary_replay::convert_key_from_summary (const binding_key *summary_key)\n+{\n+  if (summary_key->concrete_p ())\n+    return summary_key;\n+\n+  const symbolic_binding *symbolic_key = (const symbolic_binding *)summary_key;\n+  const region *summary_reg = symbolic_key->get_region ();\n+  const region *caller_reg = convert_region_from_summary (summary_reg);\n+  if (!caller_reg)\n+    return NULL;\n+  region_model_manager *mgr = get_manager ();\n+  store_manager *store_mgr = mgr->get_store_manager ();\n+  return store_mgr->get_symbolic_binding (caller_reg);\n+}\n+\n+/* Record that SUMMARY_SVAL maps to CALLER_SVAL for this replay.  */\n+\n+void\n+call_summary_replay::add_svalue_mapping (const svalue *summary_sval,\n+\t\t\t\t\t const svalue *caller_sval)\n+{\n+  gcc_assert (summary_sval);\n+  // CALLER_SVAL can be NULL\n+  m_map_svalue_from_summary_to_caller.put (summary_sval, caller_sval);\n+}\n+\n+/* Record that SUMMARY_REG maps to CALLER_REG for this replay.  */\n+\n+void\n+call_summary_replay::add_region_mapping (const region *summary_reg,\n+\t\t\t\t\t const region *caller_reg)\n+{\n+  gcc_assert (summary_reg);\n+  // CALLER_REG can be NULL\n+  m_map_region_from_summary_to_caller.put (summary_reg, caller_reg);\n+}\n+\n+/* Dump a multiline representation of this object to PP.  */\n+\n+void\n+call_summary_replay::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  pp_newline (pp);\n+  pp_string (pp, \"CALL DETAILS:\");\n+  pp_newline (pp);\n+  m_cd.dump_to_pp (pp, simple);\n+\n+  pp_newline (pp);\n+  pp_string (pp, \"CALLEE SUMMARY:\");\n+  pp_newline (pp);\n+  m_summary->dump_to_pp (m_ext_state, pp, simple);\n+\n+  /* Current state of caller (could be in mid-update).  */\n+  pp_newline (pp);\n+  pp_string (pp, \"CALLER:\");\n+  pp_newline (pp);\n+  m_cd.get_model ()->dump_to_pp (pp, simple, true);\n+\n+  pp_newline (pp);\n+  pp_string (pp, \"REPLAY STATE:\");\n+  pp_newline (pp);\n+  pp_string (pp, \"svalue mappings from summary to caller:\");\n+  pp_newline (pp);\n+  auto_vec <const svalue *> summary_svals;\n+  for (auto kv : m_map_svalue_from_summary_to_caller)\n+    summary_svals.safe_push (kv.first);\n+  summary_svals.qsort (svalue::cmp_ptr_ptr);\n+  for (auto summary_sval : summary_svals)\n+    {\n+      pp_string (pp, \"sval in summary: \");\n+      summary_sval->dump_to_pp (pp, simple);\n+      pp_newline (pp);\n+\n+      const svalue *caller_sval\n+\t= *((const_cast<svalue_map_t &>\n+\t     (m_map_svalue_from_summary_to_caller)).get (summary_sval));\n+      pp_string (pp, \" sval in caller: \");\n+      caller_sval->dump_to_pp (pp, simple);\n+      pp_newline (pp);\n+    }\n+\n+  pp_newline (pp);\n+  pp_string (pp, \"region mappings from summary to caller:\");\n+  pp_newline (pp);\n+  auto_vec <const region *> summary_regs;\n+  for (auto kv : m_map_region_from_summary_to_caller)\n+    summary_regs.safe_push (kv.first);\n+  summary_regs.qsort (region::cmp_ptr_ptr);\n+  for (auto summary_reg : summary_regs)\n+    {\n+      pp_string (pp, \"reg in summary: \");\n+      summary_reg->dump_to_pp (pp, simple);\n+      pp_newline (pp);\n+\n+      const region *caller_reg\n+\t= *((const_cast<region_map_t &>\n+\t     (m_map_region_from_summary_to_caller)).get (summary_reg));\n+      pp_string (pp, \" reg in caller: \");\n+      caller_reg->dump_to_pp (pp, simple);\n+      pp_newline (pp);\n+    }\n+}\n+\n+/* Dump a multiline representation of this object to FILE.  */\n+\n+void\n+call_summary_replay::dump (FILE *fp, bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = fp;\n+  dump_to_pp (&pp, simple);\n+  pp_flush (&pp);\n+}\n+\n+/* Dump a multiline representation of this object to stderr.  */\n+\n+DEBUG_FUNCTION void\n+call_summary_replay::dump (bool simple) const\n+{\n+  dump (stderr, simple);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "f4c5ff0b3aaec0dc71798ce154794456929c1ac8", "filename": "gcc/analyzer/call-summary.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fcall-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fcall-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-summary.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -0,0 +1,118 @@\n+/* Classes for working with summaries of function calls.\n+   Copyright (C) 2022 David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_CALL_SUMMARY_H\n+#define GCC_ANALYZER_CALL_SUMMARY_H\n+\n+namespace ana {\n+\n+/* A class summarizing one particular outcome of a function that\n+   we've already analyzed.\n+   This lets us efficiently replay the analysis when we see calls\n+   to the function, providing an approximation of the behavior of\n+   the function without having to execute within the function itself.  */\n+\n+class call_summary\n+{\n+public:\n+  call_summary (per_function_data *per_fn_data,\n+\t\tconst exploded_node *enode)\n+  : m_per_fn_data (per_fn_data),\n+    m_enode (enode)\n+  {}\n+  const program_state &get_state () const;\n+  tree get_fndecl () const;\n+\n+  label_text get_desc () const;\n+\n+  void dump_to_pp (const extrinsic_state &ext_state,\n+\t\t   pretty_printer *pp,\n+\t\t   bool simple) const;\n+  void dump (const extrinsic_state &ext_state, FILE *fp, bool simple) const;\n+  void dump (const extrinsic_state &ext_state, bool simple) const;\n+\n+private:\n+  void get_user_facing_desc (pretty_printer *pp) const;\n+\n+  per_function_data *const m_per_fn_data;\n+  const exploded_node *const m_enode;\n+};\n+\n+/* A class for handling replaying a specific call summary at\n+   a specific call site.\n+\n+   Supports remapping svalues and regions, e.g. remapping\n+     INIT_VAL(param of callee)\n+   to:\n+     whatever that argument is at the call site.  */\n+\n+class call_summary_replay\n+{\n+public:\n+  call_summary_replay (const call_details &cd,\n+\t\t       function *called_fn,\n+\t\t       call_summary *m_summary,\n+\t\t       const extrinsic_state &ext_state);\n+\n+  const call_details &get_call_details () const { return m_cd; }\n+  const gcall *get_call_stmt () const { return m_cd.get_call_stmt (); }\n+  region_model_manager *get_manager () const { return m_cd.get_manager (); }\n+  store_manager *get_store_manager () const\n+  {\n+    return get_manager ()->get_store_manager ();\n+  }\n+  region_model_context *get_ctxt () const { return m_cd.get_ctxt (); }\n+  region_model *get_caller_model () const { return m_cd.get_model (); }\n+\n+  const svalue *convert_svalue_from_summary (const svalue *);\n+  const region *convert_region_from_summary (const region *);\n+  const binding_key *convert_key_from_summary (const binding_key *);\n+\n+  void add_svalue_mapping (const svalue *summary_sval,\n+\t\t\t   const svalue *caller_sval);\n+  void add_region_mapping (const region *summary_sval,\n+\t\t\t   const region *caller_sval);\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const;\n+  void dump (FILE *fp, bool simple) const;\n+  void dump (bool simple) const;\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (call_summary_replay);\n+\n+  const svalue *convert_svalue_from_summary_1 (const svalue *);\n+  const region *convert_region_from_summary_1 (const region *);\n+\n+  const call_details &m_cd;\n+  function *m_called_fn;\n+  call_summary *m_summary;\n+  const extrinsic_state &m_ext_state;\n+\n+  // Mapping from svalues in summary to svalues for callsite:\n+  typedef hash_map <const svalue *, const svalue *> svalue_map_t;\n+  svalue_map_t m_map_svalue_from_summary_to_caller;\n+\n+  // Mapping from regions in summary to regions for callsite:\n+  typedef hash_map <const region *, const region *> region_map_t;\n+  region_map_t m_map_region_from_summary_to_caller;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_CALL_SUMMARY_H */"}, {"sha": "6685e2e801c24f1c07a8ac48e1a0ffae9b78967f", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/constraint-manager.h\"\n+#include \"analyzer/call-summary.h\"\n #include \"analyzer/analyzer-selftests.h\"\n #include \"tree-pretty-print.h\"\n \n@@ -3043,6 +3044,60 @@ constraint_manager::for_each_fact (fact_visitor *visitor) const\n     }\n }\n \n+/* Subclass of fact_visitor for use by\n+   constraint_manager::replay_call_summary.  */\n+\n+class replay_fact_visitor : public fact_visitor\n+{\n+public:\n+  replay_fact_visitor (call_summary_replay &r,\n+\t\t       constraint_manager *out)\n+  : m_r (r), m_out (out), m_feasible (true)\n+  {}\n+\n+  bool feasible_p () const { return m_feasible; }\n+\n+  void on_fact (const svalue *lhs, enum tree_code code, const svalue *rhs)\n+    final override\n+  {\n+    const svalue *caller_lhs = m_r.convert_svalue_from_summary (lhs);\n+    if (!caller_lhs)\n+      return;\n+    const svalue *caller_rhs = m_r.convert_svalue_from_summary (rhs);\n+    if (!caller_rhs)\n+      return;\n+    if (!m_out->add_constraint (caller_lhs, code, caller_rhs))\n+      m_feasible = false;\n+  }\n+\n+  void on_ranges (const svalue *lhs_sval,\n+\t\t  const bounded_ranges *ranges) final override\n+  {\n+    const svalue *caller_lhs = m_r.convert_svalue_from_summary (lhs_sval);\n+    if (!caller_lhs)\n+      return;\n+    if (!m_out->add_bounded_ranges (caller_lhs, ranges))\n+      m_feasible = false;\n+  }\n+\n+private:\n+  call_summary_replay &m_r;\n+  constraint_manager *m_out;\n+  bool m_feasible;\n+};\n+\n+/* Attempt to use R to replay the constraints from SUMMARY into this object.\n+   Return true if it is feasible.  */\n+\n+bool\n+constraint_manager::replay_call_summary (call_summary_replay &r,\n+\t\t\t\t\t const constraint_manager &summary)\n+{\n+  replay_fact_visitor v (r, this);\n+  summary.for_each_fact (&v);\n+  return v.feasible_p ();\n+}\n+\n /* Assert that this object is valid.  */\n \n void"}, {"sha": "daacaa3e6a4007f688358734f5cd33160b755ff4", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -487,6 +487,9 @@ class constraint_manager\n \n   bounded_ranges_manager *get_range_manager () const;\n \n+  bool replay_call_summary (call_summary_replay &r,\n+\t\t\t    const constraint_manager &summary);\n+\n   auto_delete_vec<equiv_class> m_equiv_classes;\n   auto_vec<constraint> m_constraints;\n   auto_vec<bounded_ranges_constraint> m_bounded_ranges_constraints;"}, {"sha": "b4deee50f1f50fc663600153e64290cd5a9add2a", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 183, "deletions": 18, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -72,6 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"tree-dfa.h\"\n #include \"analyzer/known-function-manager.h\"\n+#include \"analyzer/call-summary.h\"\n \n /* For an overview, see gcc/doc/analyzer.texi.  */\n \n@@ -1425,6 +1426,26 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t\t\t\t  &old_state, state, uncertainty,\n \t\t\t\t  path_ctxt, stmt);\n \n+  /* Handle call summaries here.  */\n+  if (cgraph_edge *cgedge\n+\t  = supergraph_call_edge (snode->get_function (), stmt))\n+    if (eg.get_analysis_plan ().use_summary_p (cgedge))\n+      {\n+\tfunction *called_fn = get_ultimate_function_for_cgraph_edge (cgedge);\n+\tper_function_data *called_fn_data\n+\t  = eg.get_per_function_data (called_fn);\n+\tif (called_fn_data)\n+\t  return replay_call_summaries (eg,\n+\t\t\t\t\tsnode,\n+\t\t\t\t\tas_a <const gcall *> (stmt),\n+\t\t\t\t\tstate,\n+\t\t\t\t\tuncertainty,\n+\t\t\t\t\tpath_ctxt,\n+\t\t\t\t\tcalled_fn,\n+\t\t\t\t\tcalled_fn_data,\n+\t\t\t\t\t&ctxt);\n+      }\n+\n   bool unknown_side_effects = false;\n   bool terminate_path = false;\n \n@@ -1520,6 +1541,142 @@ exploded_node::on_stmt_post (const gimple *stmt,\n     state->m_region_model->on_call_post (call, unknown_side_effects, ctxt);\n }\n \n+/* A concrete call_info subclass representing a replay of a call summary.  */\n+\n+class call_summary_edge_info : public call_info\n+{\n+public:\n+  call_summary_edge_info (const call_details &cd,\n+\t\t\t  function *called_fn,\n+\t\t\t  call_summary *summary,\n+\t\t\t  const extrinsic_state &ext_state)\n+  : call_info (cd),\n+    m_called_fn (called_fn),\n+    m_summary (summary),\n+    m_ext_state (ext_state)\n+  {}\n+\n+  bool update_state (program_state *state,\n+\t\t     const exploded_edge *,\n+\t\t     region_model_context *ctxt) const final override\n+  {\n+    /* Update STATE based on summary_end_state.  */\n+    call_details cd (get_call_details (state->m_region_model, ctxt));\n+    call_summary_replay r (cd, m_called_fn, m_summary, m_ext_state);\n+    const program_state &summary_end_state = m_summary->get_state ();\n+    return state->replay_call_summary (r, summary_end_state);\n+  }\n+\n+  bool update_model (region_model *model,\n+\t\t     const exploded_edge *,\n+\t\t     region_model_context *ctxt) const final override\n+  {\n+    /* Update STATE based on summary_end_state.  */\n+    call_details cd (get_call_details (model, ctxt));\n+    call_summary_replay r (cd, m_called_fn, m_summary, m_ext_state);\n+    const program_state &summary_end_state = m_summary->get_state ();\n+    model->replay_call_summary (r, *summary_end_state.m_region_model);\n+    return true;\n+  }\n+\n+  label_text get_desc (bool /*can_colorize*/) const final override\n+  {\n+    return m_summary->get_desc ();\n+  }\n+\n+private:\n+  function *m_called_fn;\n+  call_summary *m_summary;\n+  const extrinsic_state &m_ext_state;\n+};\n+\n+/* Use PATH_CTXT to bifurcate, which when handled will add custom edges\n+   for a replay of the various feasible summaries in CALLED_FN_DATA.  */\n+\n+exploded_node::on_stmt_flags\n+exploded_node::replay_call_summaries (exploded_graph &eg,\n+\t\t\t\t      const supernode *snode,\n+\t\t\t\t      const gcall *call_stmt,\n+\t\t\t\t      program_state *state,\n+\t\t\t\t      uncertainty_t *uncertainty,\n+\t\t\t\t      path_context *path_ctxt,\n+\t\t\t\t      function *called_fn,\n+\t\t\t\t      per_function_data *called_fn_data,\n+\t\t\t\t      region_model_context *ctxt)\n+{\n+  logger *logger = eg.get_logger ();\n+  LOG_SCOPE (logger);\n+\n+  gcc_assert (called_fn);\n+  gcc_assert (called_fn_data);\n+\n+  /* Each summary will call bifurcate on the PATH_CTXT.  */\n+  for (auto summary : called_fn_data->m_summaries)\n+    replay_call_summary (eg, snode, call_stmt, state, uncertainty,\n+\t\t\t path_ctxt, called_fn, summary, ctxt);\n+  path_ctxt->terminate_path ();\n+\n+  return on_stmt_flags ();\n+}\n+\n+/* Use PATH_CTXT to bifurcate, which when handled will add a\n+   custom edge for a replay of SUMMARY, if the summary's\n+   conditions are feasible based on the current state.  */\n+\n+void\n+exploded_node::replay_call_summary (exploded_graph &eg,\n+\t\t\t\t    const supernode *snode,\n+\t\t\t\t    const gcall *call_stmt,\n+\t\t\t\t    program_state *old_state,\n+\t\t\t\t    uncertainty_t *uncertainty,\n+\t\t\t\t    path_context *path_ctxt,\n+\t\t\t\t    function *called_fn,\n+\t\t\t\t    call_summary *summary,\n+\t\t\t\t    region_model_context *ctxt)\n+{\n+  logger *logger = eg.get_logger ();\n+  LOG_SCOPE (logger);\n+  gcc_assert (snode);\n+  gcc_assert (call_stmt);\n+  gcc_assert (old_state);\n+  gcc_assert (called_fn);\n+  gcc_assert (summary);\n+\n+  if (logger)\n+    logger->log (\"using %s as summary for call to %qE from %qE\",\n+\t\t summary->get_desc ().get (),\n+\t\t called_fn->decl,\n+\t\t snode->get_function ()->decl);\n+  const extrinsic_state &ext_state = eg.get_ext_state ();\n+  const program_state &summary_end_state = summary->get_state ();\n+  if (logger)\n+    {\n+      pretty_printer *pp = logger->get_printer ();\n+\n+      logger->start_log_line ();\n+      pp_string (pp, \"callsite state: \");\n+      old_state->dump_to_pp (ext_state, true, false, pp);\n+      logger->end_log_line ();\n+\n+      logger->start_log_line ();\n+      pp_string (pp, \"summary end state: \");\n+      summary_end_state.dump_to_pp (ext_state, true, false, pp);\n+      logger->end_log_line ();\n+    }\n+\n+  program_state new_state (*old_state);\n+\n+  call_details cd (call_stmt, new_state.m_region_model, ctxt);\n+  call_summary_replay r (cd, called_fn, summary, ext_state);\n+\n+  if (path_ctxt)\n+    path_ctxt->bifurcate (new call_summary_edge_info (cd,\n+\t\t\t\t\t\t      called_fn,\n+\t\t\t\t\t\t      summary,\n+\t\t\t\t\t\t      ext_state));\n+}\n+\n+\n /* Consider the effect of following superedge SUCC from this node.\n \n    Return true if it's feasible to follow the edge, or false\n@@ -2115,6 +2272,20 @@ stats::get_total_enodes () const\n   return result;\n }\n \n+/* struct per_function_data.  */\n+\n+per_function_data::~per_function_data ()\n+{\n+  for (auto iter : m_summaries)\n+    delete iter;\n+}\n+\n+void\n+per_function_data::add_call_summary (exploded_node *node)\n+{\n+  m_summaries.safe_push (new call_summary (this, node));\n+}\n+\n /* strongly_connected_components's ctor.  Tarjan's SCC algorithm.  */\n \n strongly_connected_components::\n@@ -3980,7 +4151,7 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\t\tNULL, // uncertainty_t *uncertainty\n \t\t\t\tNULL, // path_context *path_ctxt\n \t\t\t\tstmt);\n-\t    if (edge_info->update_model (bifurcated_new_state.m_region_model,\n+\t    if (edge_info->update_state (&bifurcated_new_state,\n \t\t\t\t\t NULL, /* no exploded_edge yet.  */\n \t\t\t\t\t &bifurcation_ctxt))\n \t      {\n@@ -5350,24 +5521,17 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n     pretty_printer *pp = gv->get_pp ();\n \n     dump_dot_id (pp);\n-    pp_printf (pp, \" [shape=none,margin=0,style=filled,fillcolor=%s,label=<\",\n+    pp_printf (pp, \" [shape=none,margin=0,style=filled,fillcolor=%s,label=\\\"\",\n \t       \"lightgrey\");\n-    pp_string (pp, \"<TABLE BORDER=\\\"0\\\">\");\n     pp_write_text_to_stream (pp);\n \n-    gv->begin_trtd ();\n     pp_printf (pp, \"VCG: %i: %s\", m_index, function_name (m_fun));\n-    gv->end_tdtr ();\n     pp_newline (pp);\n \n-    gv->begin_trtd ();\n     pp_printf (pp, \"supernodes: %i\\n\", m_num_supernodes);\n-    gv->end_tdtr ();\n     pp_newline (pp);\n \n-    gv->begin_trtd ();\n     pp_printf (pp, \"superedges: %i\\n\", m_num_superedges);\n-    gv->end_tdtr ();\n     pp_newline (pp);\n \n     if (args.m_eg)\n@@ -5380,9 +5544,7 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \t    if (enode->get_point ().get_function () == m_fun)\n \t      num_enodes++;\n \t  }\n-\tgv->begin_trtd ();\n \tpp_printf (pp, \"enodes: %i\\n\", num_enodes);\n-\tgv->end_tdtr ();\n \tpp_newline (pp);\n \n \t// TODO: also show the per-callstring breakdown\n@@ -5404,11 +5566,8 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \t      }\n \t    if (num_enodes > 0)\n \t      {\n-\t\tgv->begin_trtd ();\n \t\tcs->print (pp);\n \t\tpp_printf (pp, \": %i\\n\", num_enodes);\n-\t\tpp_write_text_as_html_like_dot_to_stream (pp);\n-\t\tgv->end_tdtr ();\n \t      }\n \t  }\n \n@@ -5417,14 +5576,20 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \tif (data)\n \t  {\n \t    pp_newline (pp);\n-\t    gv->begin_trtd ();\n \t    pp_printf (pp, \"summaries: %i\\n\", data->m_summaries.length ());\n-\t    pp_write_text_as_html_like_dot_to_stream (pp);\n-\t    gv->end_tdtr ();\n+\t    for (auto summary : data->m_summaries)\n+\t      {\n+\t\tpp_printf (pp, \"\\nsummary: %s:\\n\", summary->get_desc ().get ());\n+\t\tconst extrinsic_state &ext_state = args.m_eg->get_ext_state ();\n+\t\tconst program_state &state = summary->get_state ();\n+\t\tstate.dump_to_pp (ext_state, false, true, pp);\n+\t\tpp_newline (pp);\n+\t      }\n \t  }\n       }\n \n-    pp_string (pp, \"</TABLE>>];\\n\\n\");\n+    pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n+    pp_string (pp, \"\\\"];\\n\\n\");\n     pp_flush (pp);\n   }\n "}, {"sha": "ea4a890b9ce8a6f195d862f8ae16b03d258a5ec0", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -21,6 +21,15 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_EXPLODED_GRAPH_H\n #define GCC_ANALYZER_EXPLODED_GRAPH_H\n \n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"shortest-paths.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+\n namespace ana {\n \n /* Concrete implementation of region_model_context, wiring it up to the\n@@ -258,6 +267,25 @@ class exploded_node : public dnode<eg_traits>\n \t\t     bool unknown_side_effects,\n \t\t     region_model_context *ctxt);\n \n+  on_stmt_flags replay_call_summaries (exploded_graph &eg,\n+\t\t\t\t       const supernode *snode,\n+\t\t\t\t       const gcall *call_stmt,\n+\t\t\t\t       program_state *state,\n+\t\t\t\t\tuncertainty_t *uncertainty,\n+\t\t\t\t       path_context *path_ctxt,\n+\t\t\t\t       function *called_fn,\n+\t\t\t\t       per_function_data *called_fn_data,\n+\t\t\t\t       region_model_context *ctxt);\n+  void replay_call_summary (exploded_graph &eg,\n+\t\t\t    const supernode *snode,\n+\t\t\t    const gcall *call_stmt,\n+\t\t\t    program_state *state,\n+\t\t\t    uncertainty_t *uncertainty,\n+\t\t\t    path_context *path_ctxt,\n+\t\t\t    function *called_fn,\n+\t\t\t    call_summary *summary,\n+\t\t\t    region_model_context *ctxt);\n+\n   bool on_edge (exploded_graph &eg,\n \t\tconst superedge *succ,\n \t\tprogram_point *next_point,\n@@ -611,13 +639,11 @@ struct per_call_string_data\n struct per_function_data\n {\n   per_function_data () {}\n+  ~per_function_data ();\n \n-  void add_call_summary (exploded_node *node)\n-  {\n-    m_summaries.safe_push (node);\n-  }\n+  void add_call_summary (exploded_node *node);\n \n-  auto_vec<exploded_node *> m_summaries;\n+  auto_vec<call_summary *> m_summaries;\n };\n \n "}, {"sha": "2b95b7e2589843c6b3b74b2d0303add7416b1a68", "filename": "gcc/analyzer/known-function-manager.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fknown-function-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fknown-function-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_KNOWN_FUNCTION_MANAGER_H\n #define GCC_ANALYZER_KNOWN_FUNCTION_MANAGER_H\n \n+#include \"analyzer/analyzer-logging.h\"\n+\n namespace ana {\n \n class known_function_manager : public log_user"}, {"sha": "f72b86de4eb892b8f934598a9e3eaa609afb2252", "filename": "gcc/analyzer/program-point.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -21,6 +21,9 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_PROGRAM_POINT_H\n #define GCC_ANALYZER_PROGRAM_POINT_H\n \n+#include \"pretty-print.h\"\n+#include \"analyzer/call-string.h\"\n+\n namespace ana {\n \n class exploded_graph;"}, {"sha": "b54bdcee85433e6e83bfb450f03b28bf2ecdf19c", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-state.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"analyzer/state-purge.h\"\n+#include \"analyzer/call-summary.h\"\n #include \"analyzer/analyzer-selftests.h\"\n \n #if ENABLE_ANALYZER\n@@ -743,6 +744,31 @@ program_state::program_state (const extrinsic_state &ext_state)\n     }\n }\n \n+/* Attempt to to use R to replay SUMMARY into this object.\n+   Return true if it is possible.  */\n+\n+bool\n+sm_state_map::replay_call_summary (call_summary_replay &r,\n+\t\t\t\t   const sm_state_map &summary)\n+{\n+  for (auto kv : summary.m_map)\n+    {\n+      const svalue *summary_sval = kv.first;\n+      const svalue *caller_sval = r.convert_svalue_from_summary (summary_sval);\n+      if (!caller_sval)\n+\tcontinue;\n+      const svalue *summary_origin = kv.second.m_origin;\n+      const svalue *caller_origin\n+\t= (summary_origin\n+\t   ? r.convert_svalue_from_summary (summary_origin)\n+\t   : NULL);\n+      // caller_origin can be NULL.\n+      m_map.put (caller_sval, entry_t (kv.second.m_state, caller_origin));\n+    }\n+  m_global_state = summary.m_global_state;\n+  return true;\n+}\n+\n /* program_state's copy ctor.  */\n \n program_state::program_state (const program_state &other)\n@@ -1437,6 +1463,28 @@ program_state::detect_leaks (const program_state &src_state,\n \tdest_state.m_region_model->unset_dynamic_extents (reg);\n }\n \n+/* Attempt to to use R to replay SUMMARY into this object.\n+   Return true if it is possible.  */\n+\n+bool\n+program_state::replay_call_summary (call_summary_replay &r,\n+\t\t\t\t    const program_state &summary)\n+{\n+  if (!m_region_model->replay_call_summary (r, *summary.m_region_model))\n+    return false;\n+\n+  for (unsigned sm_idx = 0; sm_idx < m_checker_states.length (); sm_idx++)\n+    {\n+      const sm_state_map *summary_sm_map = summary.m_checker_states[sm_idx];\n+      m_checker_states[sm_idx]->replay_call_summary (r, *summary_sm_map);\n+    }\n+\n+  if (!summary.m_valid)\n+    m_valid = false;\n+\n+  return true;\n+}\n+\n /* Handle calls to \"__analyzer_dump_state\".  */\n \n void"}, {"sha": "ad40578c7030e96cec44cb664cd8551fa1a8ae4c", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -171,6 +171,9 @@ class sm_state_map\n   static const svalue *\n   canonicalize_svalue (const svalue *sval, const extrinsic_state &ext_state);\n \n+  bool replay_call_summary (call_summary_replay &r,\n+\t\t\t    const sm_state_map &summary);\n+\n private:\n   const state_machine &m_sm;\n   map_t m_map;\n@@ -273,6 +276,9 @@ class program_state\n \t\t\t    const extrinsic_state &ext_state,\n \t\t\t    region_model_context *ctxt);\n \n+  bool replay_call_summary (call_summary_replay &r,\n+\t\t\t    const program_state &summary);\n+\n   void impl_call_analyzer_dump_state (const gcall *call,\n \t\t\t\t      const extrinsic_state &ext_state,\n \t\t\t\t      region_model_context *ctxt);"}, {"sha": "9a2ee08df78452609678f65a397da55fca027acd", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -1275,6 +1275,33 @@ get_or_create_asm_output_svalue (tree type,\n   return asm_output_sval;\n }\n \n+/* Return the svalue * of type TYPE for OUTPUT_IDX of a deterministic\n+   asm stmt with string ASM_STRING with NUM_OUTPUTS outputs, given\n+   INPUTS as inputs.  */\n+\n+const svalue *\n+region_model_manager::\n+get_or_create_asm_output_svalue (tree type,\n+\t\t\t\t const char *asm_string,\n+\t\t\t\t unsigned output_idx,\n+\t\t\t\t unsigned num_outputs,\n+\t\t\t\t const vec<const svalue *> &inputs)\n+{\n+  gcc_assert (inputs.length () <= asm_output_svalue::MAX_INPUTS);\n+\n+  if (const svalue *folded\n+\t= maybe_fold_asm_output_svalue (type, inputs))\n+    return folded;\n+\n+  asm_output_svalue::key_t key (type, asm_string, output_idx, inputs);\n+  if (asm_output_svalue **slot = m_asm_output_values_map.get (key))\n+    return *slot;\n+  asm_output_svalue *asm_output_sval\n+    = new asm_output_svalue (type, asm_string, output_idx, num_outputs, inputs);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (asm_output_sval);\n+  m_asm_output_values_map.put (key, asm_output_sval);\n+  return asm_output_sval;\n+}\n \n /* Return the svalue * of type TYPE for the result of a call to FNDECL\n    with __attribute__((const)), given INPUTS as inputs.  */"}, {"sha": "3d8f76ee24c393c0adfeaa26a4a16a1df3461a11", "filename": "gcc/analyzer/region-model-manager.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fregion-model-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fregion-model-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -81,6 +81,12 @@ class region_model_manager\n \t\t\t\t   unsigned output_idx,\n \t\t\t\t   const vec<const svalue *> &inputs);\n   const svalue *\n+  get_or_create_asm_output_svalue (tree type,\n+\t\t\t\t   const char *asm_string,\n+\t\t\t\t   unsigned output_idx,\n+\t\t\t\t   unsigned num_outputs,\n+\t\t\t\t   const vec<const svalue *> &inputs);\n+  const svalue *\n   get_or_create_const_fn_result_svalue (tree type,\n \t\t\t\t\ttree fndecl,\n \t\t\t\t\tconst vec<const svalue *> &inputs);"}, {"sha": "d14f3a1840e7213b8f2248447b154d5b8510166d", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/region-model-reachability.h\"\n #include \"analyzer/analyzer-selftests.h\"\n #include \"analyzer/program-state.h\"\n+#include \"analyzer/call-summary.h\"\n #include \"stor-layout.h\"\n #include \"attribs.h\"\n #include \"tree-object-size.h\"\n@@ -5038,11 +5039,8 @@ region_model::maybe_update_for_edge (const superedge &edge,\n       break;\n \n     case SUPEREDGE_INTRAPROCEDURAL_CALL:\n-      {\n-\tconst callgraph_superedge *cg_sedge\n-\t  = as_a <const callgraph_superedge *> (&edge);\n-\tupdate_for_call_summary (*cg_sedge, ctxt);\n-      }\n+      /* This is a no-op for call summaries; we should already\n+\t have handled the effect of the call summary at the call stmt.  */\n       break;\n     }\n \n@@ -5140,25 +5138,34 @@ region_model::update_for_return_superedge (const return_superedge &return_edge,\n   update_for_return_gcall (call_stmt, ctxt);\n }\n \n-/* Update this region_model with a summary of the effect of calling\n-   and returning from CG_SEDGE.\n+/* Attempt to to use R to replay SUMMARY into this object.\n+   Return true if it is possible.  */\n \n-   TODO: Currently this is extremely simplistic: we merely set the\n-   return value to \"unknown\".  A proper implementation would e.g. update\n-   sm-state, and presumably be reworked to support multiple outcomes.  */\n-\n-void\n-region_model::update_for_call_summary (const callgraph_superedge &cg_sedge,\n-\t\t\t\t       region_model_context *ctxt)\n+bool\n+region_model::replay_call_summary (call_summary_replay &r,\n+\t\t\t\t   const region_model &summary)\n {\n-  /* For now, set any return value to \"unknown\".  */\n-  const gcall *call_stmt = cg_sedge.get_call_stmt ();\n-  tree lhs = gimple_call_lhs (call_stmt);\n-  if (lhs)\n-    mark_region_as_unknown (get_lvalue (lhs, ctxt),\n-\t\t\t    ctxt ? ctxt->get_uncertainty () : NULL);\n+  gcc_assert (summary.get_stack_depth () == 1);\n+\n+  m_store.replay_call_summary (r, summary.m_store);\n \n-  // TODO: actually implement some kind of summary here\n+  if (!m_constraints->replay_call_summary (r, *summary.m_constraints))\n+    return false;\n+\n+  for (auto kv : summary.m_dynamic_extents)\n+    {\n+      const region *summary_reg = kv.first;\n+      const region *caller_reg = r.convert_region_from_summary (summary_reg);\n+      if (!caller_reg)\n+\tcontinue;\n+      const svalue *summary_sval = kv.second;\n+      const svalue *caller_sval = r.convert_svalue_from_summary (summary_sval);\n+      if (!caller_sval)\n+\tcontinue;\n+      m_dynamic_extents.put (caller_reg, caller_sval);\n+    }\n+\n+  return true;\n }\n \n /* Given a true or false edge guarded by conditional statement COND_STMT,"}, {"sha": "6903090fcd3b6578e987bb37e8856eb35602e040", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -529,6 +529,9 @@ class region_model\n   const svalue *get_string_size (const svalue *sval) const;\n   const svalue *get_string_size (const region *reg) const;\n \n+  bool replay_call_summary (call_summary_replay &r,\n+\t\t\t    const region_model &summary);\n+\n   void maybe_complain_about_infoleak (const region *dst_reg,\n \t\t\t\t      const svalue *copied_sval,\n \t\t\t\t      const region *src_reg,\n@@ -570,8 +573,6 @@ class region_model\n \t\t\t\t  region_model_context *ctxt);\n   void update_for_return_superedge (const return_superedge &return_edge,\n \t\t\t\t    region_model_context *ctxt);\n-  void update_for_call_summary (const callgraph_superedge &cg_sedge,\n-\t\t\t\tregion_model_context *ctxt);\n   bool apply_constraints_for_gcond (const cfg_superedge &edge,\n \t\t\t\t    const gcond *cond_stmt,\n \t\t\t\t    region_model_context *ctxt,"}, {"sha": "74b481dce48da44b53e587fc6dbaab53e45bcafc", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/call-summary.h\"\n #include \"analyzer/analyzer-selftests.h\"\n #include \"stor-layout.h\"\n \n@@ -3130,6 +3131,166 @@ store::loop_replay_fixup (const store *other_store,\n     }\n }\n \n+/* Use R to replay the bindings from SUMMARY into this object.  */\n+\n+void\n+store::replay_call_summary (call_summary_replay &r,\n+\t\t\t    const store &summary)\n+{\n+  if (summary.m_called_unknown_fn)\n+    {\n+      /* A call to an external function occurred in the summary.\n+\t Hence we need to invalidate our knownledge of globals,\n+\t escaped regions, etc.  */\n+      on_unknown_fncall (r.get_call_stmt (),\n+\t\t\t r.get_store_manager (),\n+\t\t\t conjured_purge (r.get_caller_model (),\n+\t\t\t\t\t r.get_ctxt ()));\n+    }\n+\n+  auto_vec<const region *> keys (summary.m_cluster_map.elements ());\n+  for (auto kv : summary.m_cluster_map)\n+    keys.quick_push (kv.first);\n+  keys.qsort (region::cmp_ptr_ptr);\n+  for (auto base_reg : keys)\n+    replay_call_summary_cluster (r, summary, base_reg);\n+}\n+\n+/* Use R and SUMMARY to replay the bindings in SUMMARY_CLUSTER\n+   into this object.  */\n+\n+void\n+store::replay_call_summary_cluster (call_summary_replay &r,\n+\t\t\t\t    const store &summary,\n+\t\t\t\t    const region *summary_base_reg)\n+{\n+  const call_details &cd = r.get_call_details ();\n+  region_model_manager *reg_mgr = r.get_manager ();\n+  store_manager *mgr = reg_mgr->get_store_manager ();\n+  const binding_cluster *summary_cluster\n+    = summary.get_cluster (summary_base_reg);\n+\n+  /* Handle \"ESCAPED\" and \"TOUCHED\" flags.  */\n+  if (summary_cluster->escaped_p () || summary_cluster->touched_p ())\n+    if (const region *caller_reg\n+\t= r.convert_region_from_summary (summary_base_reg))\n+      {\n+\tconst region *caller_base_reg = caller_reg->get_base_region ();\n+\tbinding_cluster *caller_cluster\n+\t  = get_or_create_cluster (caller_base_reg);\n+\tif (summary_cluster->escaped_p ())\n+\t  caller_cluster->mark_as_escaped ();\n+\tif (summary_cluster->touched_p ())\n+\t  caller_cluster->m_touched = true;\n+      }\n+\n+  switch (summary_base_reg->get_kind ())\n+    {\n+    /* Top-level regions.  */\n+    case RK_FRAME:\n+    case RK_GLOBALS:\n+    case RK_CODE:\n+    case RK_STACK:\n+    case RK_HEAP:\n+    case RK_ROOT:\n+    /* Child regions.  */\n+    case RK_FIELD:\n+    case RK_ELEMENT:\n+    case RK_OFFSET:\n+    case RK_SIZED:\n+    case RK_CAST:\n+    case RK_BIT_RANGE:\n+    /* Other regions.  */\n+    case RK_VAR_ARG:\n+    case RK_UNKNOWN:\n+      /* These should never be the base region of a binding cluster.  */\n+      gcc_unreachable ();\n+      break;\n+\n+    case RK_FUNCTION:\n+    case RK_LABEL:\n+    case RK_STRING:\n+      /* These can be marked as escaping.  */\n+      break;\n+\n+    case RK_SYMBOLIC:\n+      {\n+\tconst symbolic_region *summary_symbolic_reg\n+\t  = as_a <const symbolic_region *> (summary_base_reg);\n+\tconst svalue *summary_ptr_sval = summary_symbolic_reg->get_pointer ();\n+\tconst svalue *caller_ptr_sval\n+\t  = r.convert_svalue_from_summary (summary_ptr_sval);\n+\tif (!caller_ptr_sval)\n+\t  return;\n+\tconst region *caller_dest_reg\n+\t  = cd.get_model ()->deref_rvalue (caller_ptr_sval,\n+\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t   cd.get_ctxt ());\n+\tconst svalue *summary_sval\n+\t  = summary.get_any_binding (mgr, summary_base_reg);\n+\tif (!summary_sval)\n+\t  return;\n+\tconst svalue *caller_sval\n+\t  = r.convert_svalue_from_summary (summary_sval);\n+\tif (!caller_sval)\n+\t  caller_sval =\n+\t    reg_mgr->get_or_create_unknown_svalue (summary_sval->get_type ());\n+\tset_value (mgr, caller_dest_reg,\n+\t\t   caller_sval, NULL /* uncertainty_t * */);\n+      }\n+      break;\n+    case RK_DECL:\n+      {\n+\tconst region *caller_dest_reg\n+\t  = r.convert_region_from_summary (summary_base_reg);\n+\tif (!caller_dest_reg)\n+\t  return;\n+\tconst svalue *summary_sval\n+\t  = summary.get_any_binding (mgr, summary_base_reg);\n+\tconst svalue *caller_sval\n+\t  = r.convert_svalue_from_summary (summary_sval);\n+\tif (!caller_sval)\n+\t  caller_sval =\n+\t    reg_mgr->get_or_create_unknown_svalue (summary_sval->get_type ());\n+\tset_value (mgr, caller_dest_reg,\n+\t\t   caller_sval, NULL /* uncertainty_t * */);\n+      }\n+      break;\n+    case RK_HEAP_ALLOCATED:\n+      {\n+\tconst region *caller_dest_reg\n+\t  = r.convert_region_from_summary (summary_base_reg);\n+\tgcc_assert (caller_dest_reg);\n+\tbinding_cluster *caller_cluster\n+\t  = get_or_create_cluster (caller_dest_reg);\n+\tauto_vec <const binding_key *> summary_keys;\n+\tfor (auto kv : *summary_cluster)\n+\t  summary_keys.safe_push (kv.first);\n+\tsummary_keys.qsort (binding_key::cmp_ptrs);\n+\tfor (auto summary_key : summary_keys)\n+\t  {\n+\t    const binding_key *caller_key\n+\t      = r.convert_key_from_summary (summary_key);\n+\t    if (!caller_key)\n+\t      continue;\n+\t    const svalue *summary_sval\n+\t      = summary_cluster->get_map ().get (summary_key);\n+\t    const svalue *caller_sval\n+\t      = r.convert_svalue_from_summary (summary_sval);\n+\t    if (!caller_sval)\n+\t      caller_sval = reg_mgr->get_or_create_unknown_svalue\n+\t\t(summary_sval->get_type ());\n+\t    caller_cluster->bind_key (caller_key, caller_sval);\n+\t  }\n+      }\n+      break;\n+\n+    case RK_ALLOCA:\n+      /* Ignore bindings of alloca regions in the summary.  */\n+      break;\n+    }\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "0b5cbd69e51c9b4e891ea46c2aa3fd7405f6d6dc", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_STORE_H\n #define GCC_ANALYZER_STORE_H\n \n+#include \"tristate.h\"\n+\n /* Implementation of the region-based ternary model described in:\n      \"A Memory Model for Static Analysis of C Programs\"\n       (Zhongxing Xu, Ted Kremenek, and Jian Zhang)\n@@ -418,6 +420,14 @@ class concrete_binding : public binding_key\n \n } // namespace ana\n \n+template <>\n+template <>\n+inline bool\n+is_a_helper <const ana::concrete_binding *>::test (const ana::binding_key *key)\n+{\n+  return key->concrete_p ();\n+}\n+\n template <> struct default_hash_traits<ana::concrete_binding>\n : public member_function_hash_traits<ana::concrete_binding>\n {\n@@ -786,6 +796,12 @@ class store\n   void loop_replay_fixup (const store *other_store,\n \t\t\t  region_model_manager *mgr);\n \n+  void replay_call_summary (call_summary_replay &r,\n+\t\t\t    const store &summary);\n+  void replay_call_summary_cluster (call_summary_replay &r,\n+\t\t\t\t    const store &summary,\n+\t\t\t\t    const region *base_reg);\n+\n private:\n   void remove_overlapping_bindings (store_manager *mgr, const region *reg,\n \t\t\t\t    uncertainty_t *uncertainty);"}, {"sha": "a4a495aeaa2dbb3539d314b4b41574523f9486a8", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -62,7 +62,7 @@ namespace ana {\n /* Get the function of the ultimate alias target being called at EDGE,\n    if any.  */\n \n-static function *\n+function *\n get_ultimate_function_for_cgraph_edge (cgraph_edge *edge)\n {\n   cgraph_node *ultimate_node = edge->callee->ultimate_alias_target ();\n@@ -74,12 +74,13 @@ get_ultimate_function_for_cgraph_edge (cgraph_edge *edge)\n /* Get the cgraph_edge, but only if there's an underlying function body.  */\n \n cgraph_edge *\n-supergraph_call_edge (function *fun, gimple *stmt)\n+supergraph_call_edge (function *fun, const gimple *stmt)\n {\n-  gcall *call = dyn_cast<gcall *> (stmt);\n+  const gcall *call = dyn_cast<const gcall *> (stmt);\n   if (!call)\n     return NULL;\n-  cgraph_edge *edge = cgraph_node::get (fun->decl)->get_edge (stmt);\n+  cgraph_edge *edge\n+    = cgraph_node::get (fun->decl)->get_edge (const_cast <gimple *> (stmt));\n   if (!edge)\n     return NULL;\n   if (!edge->callee)"}, {"sha": "f66058cc3ec780ed2c962cdbaa6be94df03c02ca", "filename": "gcc/analyzer/supergraph.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -21,6 +21,13 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_SUPERGRAPH_H\n #define GCC_ANALYZER_SUPERGRAPH_H\n \n+#include \"ordered-hash-map.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"digraph.h\"\n+\n using namespace ana;\n \n namespace ana {\n@@ -605,7 +612,8 @@ class dot_annotator\n   }\n };\n \n-extern cgraph_edge *supergraph_call_edge (function *fun, gimple *stmt);\n+extern cgraph_edge *supergraph_call_edge (function *fun, const gimple *stmt);\n+extern function *get_ultimate_function_for_cgraph_edge (cgraph_edge *edge);\n \n } // namespace ana\n "}, {"sha": "d8d419a1032465a2deb8342ec6ff04c13ce5b599", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -1728,13 +1728,17 @@ unmergeable_svalue::implicitly_live_p (const svalue_set *live_svalues,\n compound_svalue::compound_svalue (tree type, const binding_map &map)\n : svalue (calc_complexity (map), type), m_map (map)\n {\n-  /* All keys within the underlying binding_map are required to be concrete,\n-     not symbolic.  */\n #if CHECKING_P\n   for (iterator_t iter = begin (); iter != end (); ++iter)\n     {\n+      /* All keys within the underlying binding_map are required to be concrete,\n+\t not symbolic.  */\n       const binding_key *key = (*iter).first;\n       gcc_assert (key->concrete_p ());\n+\n+      /* We don't nest compound svalues.  */\n+      const svalue *sval = (*iter).second;\n+      gcc_assert (sval->get_kind () != SK_COMPOUND);\n     }\n #endif\n }"}, {"sha": "9d0f04d7502cf09f0a994e5ab59ff3fa61947153", "filename": "gcc/analyzer/svalue.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -21,7 +21,10 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_SVALUE_H\n #define GCC_ANALYZER_SVALUE_H\n \n+#include \"json.h\"\n #include \"analyzer/complexity.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/program-point.h\"\n \n using namespace ana;\n \n@@ -1527,6 +1530,7 @@ class asm_output_svalue : public svalue\n \n   const char *get_asm_string () const { return m_asm_string; }\n   unsigned get_output_idx () const { return m_output_idx; }\n+  unsigned get_num_outputs () const { return m_num_outputs; }\n   unsigned get_num_inputs () const { return m_num_inputs; }\n   const svalue *get_input (unsigned idx) const { return m_input_arr[idx]; }\n "}, {"sha": "0aaf67b8fd473a1db78e0e7ace0c9ecb091d7442", "filename": "gcc/testsuite/gcc.dg/analyzer/call-summaries-2.c", "status": "added", "additions": 646, "deletions": 0, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-2.c?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -0,0 +1,646 @@\n+/* { dg-additional-options \"-fanalyzer-call-summaries --param analyzer-min-snodes-for-call-summary=0\" } */\n+\n+/* There need to be at least two calls to a function for the\n+   call-summarization code to be used.\n+   TODO: add some kind of test that summarization *was* used.  */\n+\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+extern int external_fn (void *);\n+\n+int returns_const (void)\n+{\n+  return 42;\n+}\n+\n+void test_summarized_returns_const (void)\n+{\n+  __analyzer_eval (returns_const () == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_const () == 42); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test_summarized_returns_const_2 (void)\n+{\n+  returns_const (); /* { dg-message \"when 'returns_const' returns\" } */\n+  __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}\n+\n+int returns_param (int i)\n+{\n+  return i;\n+}\n+\n+void test_summarized_returns_param (int j)\n+{\n+  __analyzer_eval (returns_param (j) == j); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_param (j) == j); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void writes_const_to_ptr (int *p)\n+{\n+  *p = 42;\n+}\n+\n+void test_summarized_writes_const_to_ptr (void)\n+{\n+  int i, j;\n+  writes_const_to_ptr (&i);\n+  writes_const_to_ptr (&j);\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+}\n+\n+// TODO: we should complain about this:\n+\n+void test_summarized_write_through_null (void)\n+{\n+  writes_const_to_ptr (NULL);\n+}\n+\n+void writes_param_to_ptr (int i, int *p)\n+{\n+  *p = i;\n+}\n+\n+void test_summarized_writes_param_to_ptr (int j)\n+{\n+  int x, y;\n+  writes_param_to_ptr (j, &x);\n+  writes_param_to_ptr (j, &y);\n+  __analyzer_eval (x == j); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (y == j); /* { dg-warning \"TRUE\" } */\n+}\n+\n+int g;\n+\n+void writes_to_global (int i)\n+{\n+  g = i;\n+}\n+\n+void test_writes_to_global (int x, int y)\n+{\n+  writes_to_global (x);\n+  __analyzer_eval (g == x); /* { dg-warning \"TRUE\" } */\n+\n+  writes_to_global (y);\n+  __analyzer_eval (g == y); /* { dg-warning \"TRUE\" } */\n+}\n+\n+int reads_from_global (void)\n+{\n+  return g;\n+}\n+\n+void test_reads_from_global (int x, int y)\n+{\n+  g = x;\n+  __analyzer_eval (reads_from_global () == x); /* { dg-warning \"TRUE\" } */\n+\n+  g = y;\n+  __analyzer_eval (reads_from_global () == y); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Example of a unary op.  */\n+\n+int returns_negation (int i)\n+{\n+  return -i;\n+}\n+\n+void test_returns_negation (int x)\n+{\n+  __analyzer_eval (returns_negation (5) == -5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_negation (x) == -x); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_negation (-x) == x); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Example of a binary op.  */\n+\n+int returns_sum (int i, int j)\n+{\n+  return i + j;\n+}\n+\n+void test_returns_sum (int x, int y)\n+{\n+  __analyzer_eval (returns_sum (5, 3) == 8); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_sum (7, 2) == 9); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_sum (x, y) == x + y); /* { dg-warning \"TRUE\" } */\n+}\n+\n+struct coord\n+{\n+  int x;\n+  int y;\n+};\n+\n+struct coord make_coord (int x, int y)\n+{\n+  struct coord result = {x, y};\n+  return result;\n+}\n+\n+void test_make_coord (int i, int j)\n+{\n+  struct coord c1 = make_coord (3, 4);\n+  __analyzer_eval (c1.x == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c1.y == 4); /* { dg-warning \"TRUE\" } */\n+\n+  struct coord c2 = make_coord (i, j);\n+  __analyzer_eval (c2.x == i); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c2.y == j); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Example of nested usage of summaries.  */\n+\n+struct rect\n+{\n+  struct coord nw;\n+  struct coord se;\n+};\n+\n+struct rect make_rect (int top, int bottom, int left, int right)\n+{\n+  struct rect result = {make_coord (left, top),\n+\t\t\tmake_coord (right, bottom)};\n+  return result;\n+}\n+\n+void test_make_rect (int top, int bottom, int left, int right)\n+{\n+  struct rect r1 = make_rect (3, 4, 5, 6);\n+  __analyzer_eval (r1.nw.y == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (r1.se.y == 4); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (r1.nw.x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (r1.se.x == 6); /* { dg-warning \"TRUE\" } */\n+\n+  struct rect r2 = make_rect (top, bottom, left, right);\n+  __analyzer_eval (r2.nw.y == top); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (r2.se.y == bottom); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (r2.nw.x == left); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (r2.se.x == right); /* { dg-warning \"TRUE\" } */\n+}\n+\n+const char *returns_str (void)\n+{\n+  return \"abc\";\n+}\n+\n+void test_returns_str (void)\n+{\n+  __analyzer_eval (returns_str () != NULL); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_str ()[0] == 'a'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_str ()[1] == 'b'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_str ()[2] == 'c'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_str ()[3] == '\\0'); /* { dg-warning \"TRUE\" } */\n+}\n+\n+int returns_field (struct coord *p)\n+{\n+  return p->y;\n+}\n+\n+void test_returns_field (struct coord *q)\n+{\n+  __analyzer_eval (returns_field (q) == q->y); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_field (q) == q->y); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void writes_to_fields (struct coord *p, int x, int y)\n+{\n+  p->x = x;\n+  p->y = y;\n+}\n+\n+void test_writes_to_field (struct coord *q, int qx, int qy)\n+{\n+  struct coord a, b;\n+  writes_to_fields (&a, 1, 2);\n+  __analyzer_eval (a.x == 1); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (a.y == 2); /* { dg-warning \"TRUE\" } */\n+  writes_to_fields (&b, 3, 4);\n+  __analyzer_eval (b.x == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (b.y == 4); /* { dg-warning \"TRUE\" } */\n+  writes_to_fields (q, qx, qy);\n+  __analyzer_eval (q->x == qx); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (q->y == qy); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Example of nested function summarization.  */\n+\n+int get_min_x (struct rect *p)\n+{\n+  return p->nw.x;\n+}\n+\n+int get_min_y (struct rect *p)\n+{\n+  return p->nw.y;\n+}\n+\n+int get_max_x (struct rect *p)\n+{\n+  return p->se.x;\n+}\n+\n+int get_max_y (struct rect *p)\n+{\n+  return p->se.y;\n+}\n+\n+int get_area (struct rect *p)\n+{\n+  return ((get_max_x (p) - get_min_x (p))\n+\t  * (get_max_y (p) - get_min_y (p)));\n+}\n+\n+void test_get_area (int top, int bottom, int left, int right, struct rect *p)\n+{\n+  {\n+    /* 1x1 at origin.  */\n+    struct rect a = make_rect (0, 1, 0, 1);\n+    __analyzer_eval (get_min_y (&a) == 0); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_max_y (&a) == 1); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_min_x (&a) == 0); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_max_x (&a) == 1); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_area (&a) == 1); /* { dg-warning \"TRUE\" } */\n+  }\n+\n+  {\n+    /* 4x5. */\n+    struct rect b = make_rect (3, 7, 4, 9);\n+    __analyzer_eval (get_min_y (&b) == 3); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_max_y (&b) == 7); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_min_x (&b) == 4); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_max_x (&b) == 9); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_area (&b) == 20); /* { dg-warning \"TRUE\" } */\n+  }\n+\n+  {\n+    /* Symbolic.  */\n+    struct rect c = make_rect (top, bottom, left, right);\n+    __analyzer_eval (get_min_y (&c) == top); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_max_y (&c) == bottom); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_min_x (&c) == left); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_max_x (&c) == right); /* { dg-warning \"TRUE\" } */\n+    __analyzer_eval (get_area (&c) == ((right - left) * (bottom - top))); /* { dg-warning \"TRUE\" } */\n+  }\n+\n+  /* Symbolic via ptr.  */\n+  __analyzer_eval (get_min_y (p) == p->nw.y); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (get_max_y (p) == p->se.y); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (get_min_x (p) == p->nw.x); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (get_max_x (p) == p->se.x); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (get_area (p) == ((p->se.x - p->nw.x) * (p->se.y - p->nw.y))); /* { dg-warning \"TRUE\" } */\n+}\n+\n+int returns_element (int i)\n+{\n+  static const int arr[3] = {7, 8, 9};\n+  return arr[i];\n+}\n+\n+void test_returns_element (int j)\n+{\n+  __analyzer_eval (returns_element (0) == 7); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_element (1) == 8); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_element (2) == 9); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_element (3) == 10); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: out of bounds\n+}\n+\n+const int *returns_element_ptr (int i)\n+{\n+  static const int arr[3] = {7, 8, 9};\n+  return &arr[i];\n+}\n+\n+int test_returns_element_ptr (int j)\n+{\n+  __analyzer_eval (*returns_element_ptr (0) == 7); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (*returns_element_ptr (1) == 8); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (*returns_element_ptr (2) == 9); /* { dg-warning \"TRUE\" } */\n+  return *returns_element_ptr (3); /* { dg-warning \"buffer overread\" } */\n+}\n+\n+int returns_offset (int arr[3], int i)\n+{\n+  return arr[i];\n+}\n+\n+void test_returns_offset (int outer_arr[3], int idx)\n+{\n+  int a[3] = {4, 5, 6};\n+  __analyzer_eval (returns_offset (a, 0) == 4); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset (a, 1) == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset (a, 2) == 6); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset (a, idx) == a[idx]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_offset (outer_arr, 0) == outer_arr[0]); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset (outer_arr, idx) == outer_arr[idx]); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+int returns_offset_2 (int arr[], int i)\n+{\n+  return arr[i];\n+}\n+\n+void test_returns_offset_2 (int outer_arr[], int idx)\n+{\n+  int a[3] = {4, 5, 6};\n+  __analyzer_eval (returns_offset_2 (a, 0) == 4); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset_2 (a, 1) == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset_2 (a, 2) == 6); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset_2 (a, idx) == a[idx]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_offset_2 (outer_arr, 0) == outer_arr[0]); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset_2 (outer_arr, idx) == outer_arr[idx]); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+int returns_offset_3 (int *p, int i)\n+{\n+  return p[i];\n+}\n+\n+void test_returns_offset_3 (int *q, int j)\n+{\n+  __analyzer_eval (returns_offset_3 (q, j) == q[j]); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_offset_3 (q, j) == q[j]); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* With state merging, this is summarized as returning \"UNKNOWN\".  */\n+\n+int two_outcomes (int flag, int x, int y)\n+{\n+  if (flag)\n+    return x;\n+  else\n+    return y;\n+}\n+\n+void test_two_outcomes (int outer_flag, int a, int b)\n+{\n+  int r;\n+  __analyzer_eval (two_outcomes (1, a, b) == a); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (two_outcomes (0, a, b) == b); /* { dg-warning \"UNKNOWN\" } */\n+  r = two_outcomes (outer_flag, a, b);\n+  if (outer_flag)\n+    __analyzer_eval (r == a); /* { dg-warning \"UNKNOWN\" } */\n+  else\n+    __analyzer_eval (r == b); /* { dg-warning \"UNKNOWN\" } */  \n+}\n+\n+/* Verify that summary replays capture postconditions.  */\n+\n+void check_int_nonnegative (int i)\n+{\n+  if (i < 0)\n+    __builtin_unreachable ();\n+}\n+\n+void test_check_int_nonnegative (int i, int j)\n+{\n+  __analyzer_eval (i >= 0); /* { dg-warning \"UNKNOWN\" } */\n+  check_int_nonnegative (i);\n+  __analyzer_eval (i >= 0); /* { dg-warning \"TRUE\" } */\n+\n+  __analyzer_eval (j >= 0); /* { dg-warning \"UNKNOWN\" } */\n+  check_int_nonnegative (j);\n+  __analyzer_eval (j >= 0); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void calls_external_fn (void)\n+{\n+  external_fn (NULL);\n+}\n+\n+void test_calls_external_fn (void)\n+{\n+  g = 1;\n+  __analyzer_eval (g == 1); /* { dg-warning \"TRUE\" } */\n+  calls_external_fn ();\n+  calls_external_fn ();\n+  __analyzer_eval (g == 1); /* { dg-warning \"UNKNOWN\" \"expected\" { xfail *-*-* } } */\n+  /* { dg-bogus \"TRUE\" \"bogus\" { xfail *-*-* } .-1 } */\n+  // TODO(xfails)\n+}\n+\n+int returns_iterator (int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+    }\n+  return i;\n+}\n+\n+void test_returns_iterator (int j, int k)\n+{\n+  __analyzer_eval (returns_iterator (j) == j); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_iterator (k) == k); /* { dg-warning \"UNKNOWN\" } */\n+  /* TODO: ideally we'd capture these equalities, but this is an issue \n+     with how we handle loops.  */\n+}\n+\n+int returns_external_result (void)\n+{\n+  return external_fn (NULL);\n+}\n+\n+int test_returns_external_result (void)\n+{\n+  int i, j;\n+  i = returns_external_result ();\n+  j = returns_external_result ();\n+  __analyzer_eval (i == j); /* { dg-warning \"UNKNOWN\" } */\n+  return i * j;\n+}\n+\n+int uses_alloca (int i)\n+{\n+  int *p = alloca (sizeof (int));\n+  *p = i;\n+  return *p;\n+}\n+\n+void test_uses_alloca (int x)\n+{\n+  __analyzer_eval (uses_alloca (42) == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (uses_alloca (x) == x); /* { dg-warning \"TRUE\" } */\n+}\n+\n+struct bits\n+{\n+  unsigned b0 : 1;\n+  unsigned b1 : 1;\n+  unsigned b2 : 1;\n+  unsigned b3 : 1;\n+  unsigned b4 : 1;\n+  unsigned b5 : 1;\n+  unsigned b6 : 1;\n+  unsigned b7 : 1;\n+};\n+\n+int returns_bitfield (struct bits b)\n+{\n+  return b.b3;\n+}\n+\n+void test_returns_bitfield (struct bits s)\n+{\n+  __analyzer_eval (returns_bitfield (s) == s.b3); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_bitfield (s) == s.b3); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: ideally it would figure out that these are equal\n+}\n+\n+int consume_two_ints_from_va_list (__builtin_va_list ap)\n+{\n+  int i, j;\n+  i = __builtin_va_arg (ap, int);\n+  j = __builtin_va_arg (ap, int);\n+  return i * j;\n+}\n+\n+int test_consume_two_ints_from_va_list (__builtin_va_list ap1)\n+{\n+  int p1, p2;\n+  __builtin_va_list ap2;\n+  __builtin_va_copy (ap2, ap1);\n+  p1 = consume_two_ints_from_va_list (ap1);\n+  p2 = consume_two_ints_from_va_list (ap2);\n+  __analyzer_eval (p1 == p2); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: ideally it would figure out these are equal\n+  __builtin_va_end (ap2);\n+}\n+\n+int consume_two_ints_from_varargs (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, placeholder);\n+  i = __builtin_va_arg (ap, int);\n+  j = __builtin_va_arg (ap, int);\n+  __builtin_va_end (ap);\n+  return i * j;\n+}\n+\n+void test_consume_two_ints_from_varargs (int x, int y)\n+{\n+  __analyzer_eval (consume_two_ints_from_varargs (0, 4, 5) == 20); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (consume_two_ints_from_varargs (0, 3, 6) == 18); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (consume_two_ints_from_varargs (0, x, 6) == x * y); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: ideally it would figure these out\n+}\n+\n+extern int const_fn_1 (int) __attribute__ ((const));\n+int calls_const_fn (int i)\n+{\n+  return const_fn_1 (i);\n+}\n+\n+void test_calls_const_fn (int x)\n+{\n+  int r1, r2;\n+  r1 = calls_const_fn (x);\n+  r2 = calls_const_fn (x);\n+  __analyzer_eval (r1 == r2); /* { dg-warning \"TRUE\" } */\n+}\n+\n+typedef struct iv2 { int arr[2]; } iv2_t;\n+typedef struct iv4 { int arr[4]; } iv4_t;\n+\n+iv2_t returns_iv2_t (int x, int y)\n+{\n+  iv2_t result = {x, y};\n+  return result;\n+}\n+\n+void test_returns_iv2_t (int a, int b)\n+{\n+  __analyzer_eval (returns_iv2_t (a, b).arr[0] == a); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_iv2_t (a, b).arr[1] == b); /* { dg-warning \"TRUE\" } */\n+}\n+\n+iv4_t returns_iv4_t (int a, iv2_t bc, int d)\n+{\n+  iv4_t result = {a, bc.arr[0], bc.arr[1], d};\n+  return result;\n+}\n+\n+void test_returns_iv4_t (int p, iv2_t qr, int s)\n+{\n+  __analyzer_eval (returns_iv4_t (p, qr, s).arr[0] == p); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (returns_iv4_t (p, qr, s).arr[1] == qr.arr[0]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_iv4_t (p, qr, s).arr[2] == qr.arr[1]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_iv4_t (p, qr, s).arr[3] == s); /* { dg-warning \"TRUE\" } */\n+  // TODO: ideally the UNKNOWNs would be TRUEs.\n+}\n+\n+void copies_iv2_t (int *p, iv2_t xy)\n+{\n+  __builtin_memcpy (p, &xy, sizeof (xy));\n+}\n+\n+void test_copies_iv2_t (iv2_t ab, iv2_t cd)\n+{\n+  iv4_t t;\n+  copies_iv2_t (&t.arr[0], ab);\n+  copies_iv2_t (&t.arr[2], cd);\n+  __analyzer_eval (t.arr[0] = ab.arr[0]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (t.arr[1] = ab.arr[1]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (t.arr[2] = cd.arr[0]); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (t.arr[3] = cd.arr[1]); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: ideally the UNKNOWNs would be TRUEs.\n+}\n+\n+void partially_inits (int *p, int v)\n+{\n+  p[1] = v;\n+}\n+\n+void test_partially_inits (int x)\n+{\n+  int arr[2];\n+  partially_inits (arr, x);\n+  partially_inits (arr, x);\n+\n+  __analyzer_eval (arr[0]); /* { dg-warning \"UNKNOWN\" \"eval\" } */\n+  /* { dg-warning \"use of uninitialized value 'arr\\\\\\[0\\\\\\]'\" \"uninit\" { target *-*-* } .-1 } */\n+\n+  __analyzer_eval (arr[1] == x); /* { dg-warning \"UNKNOWN\" \"eval\" } */ \n+  /* { dg-bogus \"use of uninitialized value 'arr\\\\\\[1\\\\\\]'\" \"uninit\" { xfail *-*-* } .-1 } */\n+  // TODO(xfail), and eval should be \"TRUE\"\n+}\n+\n+int uses_switch (int i)\n+{\n+  switch (i)\n+    {\n+    case 0:\n+      return 42;\n+    case 1:\n+      return 17;\n+    default:\n+      return i * 2;\n+    }\n+}\n+\n+void test_uses_switch (int x)\n+{\n+  __analyzer_eval (uses_switch (0) == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (uses_switch (1) == 17); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (uses_switch (2) == x * 2); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: ideally the UNKNOWNs would be TRUEs.\n+}\n+\n+int *returns_ptr_to_first_field (struct coord *p)\n+{\n+  return &p->x;\n+}\n+\n+void test_returns_ptr_to_first_field (struct coord *q)\n+{\n+  __analyzer_eval (returns_ptr_to_first_field (q) == (int *)q); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (returns_ptr_to_first_field (q) == (int *)q); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: ideally the UNKNOWNs would be TRUEs.\n+}"}, {"sha": "d63eb0cf9a3f805f99eb00edab9d853b4027d9b4", "filename": "gcc/testsuite/gcc.dg/analyzer/call-summaries-3.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-3.c?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-additional-options \"-fanalyzer-call-summaries --param analyzer-min-snodes-for-call-summary=0 -fno-analyzer-state-merge\" } */\n+\n+/* There need to be at least two calls to a function for the\n+   call-summarization code to be used.\n+   TODO: add some kind of test that summarization *was* used.  */\n+\n+#include \"analyzer-decls.h\"\n+\n+/* With state merging disabled, we get two summaries here.  */\n+\n+int two_outcomes (int flag, int x, int y)\n+{\n+  if (flag)\n+    return x;\n+  else\n+    return y;\n+}\n+\n+void test_two_outcomes (int outer_flag, int a, int b)\n+{\n+  int r;\n+  __analyzer_eval (two_outcomes (1, a, b) == a); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (two_outcomes (0, a, b) == b); /* { dg-warning \"TRUE\" } */\n+  r = two_outcomes (outer_flag, a, b);\n+  if (outer_flag)\n+    __analyzer_eval (r == a); /* { dg-warning \"TRUE\" } */\n+  else\n+    __analyzer_eval (r == b); /* { dg-warning \"TRUE\" } */  \n+}"}, {"sha": "cc23283f0f8df3fa383ee4cd8c3ca31ca8a6a53e", "filename": "gcc/testsuite/gcc.dg/analyzer/call-summaries-asm-x86.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-asm-x86.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-asm-x86.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-asm-x86.c?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target x86_64-*-* } } */\n+/* { dg-additional-options \"-fanalyzer-call-summaries --param analyzer-min-snodes-for-call-summary=0\" } */\n+\n+#include \"analyzer-decls.h\"\n+\n+int returns_asm_value (void)\n+{\n+  int dst;\n+  asm (\"mov 42, %0\"\n+       : \"=r\" (dst));\n+  return dst;\n+}\n+\n+void test_returns_asm_value (void)\n+{\n+  int a, b;\n+  a = returns_asm_value ();\n+  b = returns_asm_value ();\n+  __analyzer_eval (a == b); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "87173a08d064c025ced7765d8d829cb4250a4697", "filename": "gcc/testsuite/gcc.dg/analyzer/call-summaries-malloc.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-malloc.c?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-additional-options \"-fanalyzer-call-summaries --param analyzer-min-snodes-for-call-summary=0\" } */\n+\n+/* There need to be at least two calls to a function for the\n+   call-summarization code to be used.\n+   TODO: add some kind of test that summarization *was* used.  */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"analyzer-decls.h\"\n+\n+int *malloc_int (int i)\n+{\n+  int *res = malloc (sizeof (int));\n+  if (!res)\n+    return NULL;\n+  *res = i;\n+  return res;\n+}\n+\n+void test_malloc_int (int x)\n+{\n+  int *p, *q;\n+\n+  p = malloc_int (42);\n+  if (p)\n+    __analyzer_eval (*p == 42); /* { dg-warning \"TRUE\" } */\n+  free (p);\n+\n+  q = malloc_int (x);\n+  if (q)\n+    __analyzer_eval (*q == x); /* { dg-warning \"TRUE\" } */\n+  free (q);\n+}\n+\n+void test_leak (int x)\n+{\n+  int *p = malloc_int (x); /* { dg-message \"when 'malloc_int' returns pointer to heap-allocated buffer\" } */\n+} /* { dg-message \"leak of 'p'\" } */\n+\n+void *wrapped_malloc (size_t sz)\n+{\n+  return malloc (sz);\n+}\n+\n+void wrapped_free (void *p)\n+{\n+  free (p);\n+}\n+\n+void test_wrapped_malloc_and_free (size_t sz)\n+{\n+  void *p = wrapped_malloc (100);\n+  void *q = wrapped_malloc (sz);\n+  __analyzer_dump_capacity (p); /* { dg-warning \"capacity: '\\\\(\\[^\\n\\r\\]*\\\\)100'\" } */\n+  __analyzer_dump_capacity (q); /* { dg-warning \"capacity: 'INIT_VAL\\\\(sz_\\[^\\n\\r\\]*\\\\)'\" } */\n+  wrapped_free (p);\n+  wrapped_free (q);\n+}\n+\n+void test_use_after_free (void)\n+{\n+  // TODO\n+}\n+\n+void test_use_without_check (size_t sz)\n+{\n+  char *buf = wrapped_malloc (sz); /* { dg-message \"this call could return NULL\" } */\n+  memset (buf, 'x', sz); /* { dg-warning \"use of possibly-NULL 'buf' where non-null expected\" } */\n+  wrapped_free (buf);\n+}\n+\n+void test_out_of_bounds (size_t sz)\n+{\n+  char *buf = wrapped_malloc (sz);\n+  if (!buf)\n+    return;\n+  memset (buf, 'x', sz);\n+  buf[sz] = '\\0'; /* { dg-warning \"heap-based buffer overflow\" } */\n+  wrapped_free (buf);\n+}"}, {"sha": "1e689b3860c5bd18171af81ebe42ab5a6025a6e2", "filename": "gcc/testsuite/gcc.dg/analyzer/call-summaries-pr107072.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-pr107072.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfca9505f6fce631c2488f89aa156d56c7fae9ed/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-pr107072.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-pr107072.c?ref=bfca9505f6fce631c2488f89aa156d56c7fae9ed", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-additional-options \"-fanalyzer-call-summaries --param analyzer-min-snodes-for-call-summary=0\" } */\n+\n+/* There need to be at least two calls to a function for the\n+   call-summarization code to be used.\n+   TODO: add some kind of test that summarization *was* used.  */\n+\n+/* Reduced from an example in Emacs in which string_char_and_length\n+   was being incorrectly summarized, failing to see the write to *length.  */\n+\n+typedef long int ptrdiff_t;\n+typedef struct Lisp_X *Lisp_Word;\n+typedef Lisp_Word Lisp_Object;\n+extern _Bool STRING_MULTIBYTE(Lisp_Object str);\n+extern unsigned char *SDATA(Lisp_Object string);\n+enum { MAX_2_BYTE_CHAR = 0x7FF };\n+enum { MAX_3_BYTE_CHAR = 0xFFFF };\n+enum { MAX_4_BYTE_CHAR = 0x1FFFFF };\n+enum { MAX_5_BYTE_CHAR = 0x3FFF7F };\n+extern int make_char_multibyte(int c);\n+static inline int string_char_and_length(unsigned char const *p, int *length) {\n+  int c = p[0];\n+  if (!(c & 0x80)) {\n+    *length = 1;\n+    return c;\n+  }\n+  ((0xC0 <= c) ? (void)0 : __builtin_unreachable());\n+  int d = (c << 6) + p[1] - ((0xC0 << 6) + 0x80);\n+  if (!(c & 0x20)) {\n+    *length = 2;\n+    return d + (c < 0xC2 ? 0x3FFF80 : 0);\n+  }\n+  d = (d << 6) + p[2] - ((0x20 << 12) + 0x80);\n+  if (!(c & 0x10)) {\n+    *length = 3;\n+    ((MAX_2_BYTE_CHAR < d && d <= MAX_3_BYTE_CHAR)\n+     ? (void)0\n+     : __builtin_unreachable());\n+    return d;\n+  }\n+  d = (d << 6) + p[3] - ((0x10 << 18) + 0x80);\n+  if (!(c & 0x08)) {\n+    *length = 4;\n+    ((MAX_3_BYTE_CHAR < d && d <= MAX_4_BYTE_CHAR)\n+     ? (void)0\n+     : __builtin_unreachable());\n+    return d;\n+  }\n+  d = (d << 6) + p[4] - ((0x08 << 24) + 0x80);\n+  *length = 5;\n+  ((MAX_4_BYTE_CHAR < d && d <= MAX_5_BYTE_CHAR)\n+   ? (void)0\n+   : __builtin_unreachable());\n+  return d;\n+}\n+int fetch_string_char_advance(Lisp_Object string,\n+\t\t\t      ptrdiff_t *charidx,\n+\t\t\t      ptrdiff_t *byteidx) {\n+  int output;\n+  ptrdiff_t b = *byteidx;\n+  unsigned char *chp = SDATA(string) + b;\n+  if (STRING_MULTIBYTE(string)) {\n+    int chlen;\n+    output = string_char_and_length(chp, &chlen);\n+    b += chlen;\n+  } else {\n+    output = *chp;\n+    b++;\n+  }\n+  (*charidx)++;\n+  *byteidx = b;\n+  return output;\n+}\n+int fetch_string_char_as_multibyte_advance(Lisp_Object string,\n+\t\t\t\t\t   ptrdiff_t *charidx,\n+\t\t\t\t\t   ptrdiff_t *byteidx) {\n+  int output;\n+  ptrdiff_t b = *byteidx;\n+  unsigned char *chp = SDATA(string) + b;\n+  if (STRING_MULTIBYTE(string)) {\n+    int chlen;\n+    output = string_char_and_length(chp, &chlen);\n+    b += chlen;\n+  } else {\n+    output = make_char_multibyte(*chp);\n+    b++;\n+  }\n+  (*charidx)++;\n+  *byteidx = b;\n+  return output;\n+}"}]}