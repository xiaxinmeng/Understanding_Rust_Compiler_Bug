{"sha": "85ddb3994b49715fb52c3235cfca33c29d868dda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVkZGIzOTk0YjQ5NzE1ZmI1MmMzMjM1Y2ZjYTMzYzI5ZDg2OGRkYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-31T21:17:49Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-31T21:17:49Z"}, "message": "(output_move_double): Undo 10/25 change.\n\n(output_move_double): Undo 10/25 change.  Handle case\nwhere part of a dest reg is used in a src mem rtx, without using stack.\n\nFrom-SVN: r2665", "tree": {"sha": "d5754fce2fe8aea0995d9930e6a27498cb0f1206", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5754fce2fe8aea0995d9930e6a27498cb0f1206"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85ddb3994b49715fb52c3235cfca33c29d868dda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ddb3994b49715fb52c3235cfca33c29d868dda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85ddb3994b49715fb52c3235cfca33c29d868dda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85ddb3994b49715fb52c3235cfca33c29d868dda/comments", "author": null, "committer": null, "parents": [{"sha": "f9e67232ef84bdb81faf1f70359c5d6f2ffcc2e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e67232ef84bdb81faf1f70359c5d6f2ffcc2e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9e67232ef84bdb81faf1f70359c5d6f2ffcc2e9"}], "stats": {"total": 37, "additions": 24, "deletions": 13}, "files": [{"sha": "fd2f1f92f8c1068e3dd4b47133eb5f2483a2d663", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85ddb3994b49715fb52c3235cfca33c29d868dda/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85ddb3994b49715fb52c3235cfca33c29d868dda/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=85ddb3994b49715fb52c3235cfca33c29d868dda", "patch": "@@ -42,7 +42,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define AT_BP(mode) (gen_rtx (MEM, (mode), frame_pointer_rtx))\n \n-extern rtx gen_push_operand ();\n extern FILE *asm_out_file;\n extern char *strcat ();\n \n@@ -244,7 +243,7 @@ output_move_double (operands)\n   enum {REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n   rtx latehalf[2];\n   rtx addreg0 = 0, addreg1 = 0;\n-  rtx pop_after = 0;\n+  int dest_overlapped_low = 0;\n \n   /* First classify both operands.  */\n \n@@ -355,13 +354,29 @@ output_move_double (operands)\n     operands[1] = latehalf[1];\n \n   /* For (set (reg:DI N) (mem:DI ... (reg:SI N) ...)),\n-     push the first word on the stack, and pop it off afterward.  */\n+     if the upper part of reg N does not appear in the MEM, arrange to\n+     emit the move late-half first.  Otherwise, compute the MEM address\n+     into the upper part of N and use that as a pointer to the memory\n+     operand.  */\n   if (optype0 == REGOP\n-      && refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t    operands[1], 0))\n+      && (optype1 == OFFSOP || optype1 == MEMOP))\n     {\n-      pop_after = operands[0];\n-      operands[0] = gen_rtx (MEM, SImode, gen_push_operand ());\n+      if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n+\t  && reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n+\t{\n+\t  /* If both halves of dest are used in the src memory address,\n+\t     compute the address into latehalf of dest.  */\n+\t  rtx xops[2];\n+\t  xops[0] = latehalf[0];\n+\t  xops[1] = XEXP (operands[1], 0);\n+\t  output_asm_insn (AS2 (lea%L0,%a1,%0), xops);\n+\t  operands[1] = gen_rtx (MEM, DImode, latehalf[0]);\n+\t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+\t}\n+      else if (reg_mentioned_p (operands[0], XEXP (operands[1], 0)))\n+\t/* If the low half of dest is mentioned in the source memory\n+\t   address, the arrange to emit the move late half first.  */\n+\tdest_overlapped_low = 1;\n     }\n \n   /* If one or both operands autodecrementing,\n@@ -374,7 +389,8 @@ output_move_double (operands)\n \n   if (optype0 == PUSHOP || optype1 == PUSHOP\n       || (optype0 == REGOP && optype1 == REGOP\n-\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+\t  && REGNO (operands[0]) == REGNO (latehalf[1]))\n+      || dest_overlapped_low)\n     {\n       /* Make any unoffsettable addresses point at high-numbered word.  */\n       if (addreg0)\n@@ -414,11 +430,6 @@ output_move_double (operands)\n   if (addreg1)\n     asm_add (-4, addreg1);\n \n-  /* If we diverted a word to the stack, pop it now\n-     to the proper register.  */\n-  if (pop_after != 0)\n-    output_asm_insn (\"pop%L0 %0\", &pop_after);\n-\n   return \"\";\n }\n \f"}]}