{"sha": "7467ab4232babb1ac9b906fe91abb9226464b884", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ2N2FiNDIzMmJhYmIxYWM5YjkwNmZlOTFhYmI5MjI2NDY0Yjg4NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-01-18T10:59:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-01-18T10:59:33Z"}, "message": "re PR tree-optimization/83887 ([graphite] ICE in verify_dominators, at dominance.c:1184 (error: dominator of 3 should be 21, not 18))\n\n2018-01-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/83887\n\t* graphite-scop-detection.c\n\t(scop_detection::get_nearest_dom_with_single_entry): Remove.\n\t(scop_detection::get_nearest_pdom_with_single_exit): Likewise.\n\t(scop_detection::merge_sese): Re-implement with a flood-fill\n\talgorithm that properly finds a SESE region if it exists.\n\n\t* gcc.dg/graphite/pr83887.c: New testcase.\n\t* gfortran.dg/graphite/pr83887.f90: Likewise.\n\t* gfortran.dg/graphite/pr83887.f: Likewise.\n\nFrom-SVN: r256841", "tree": {"sha": "79560bae0f827facc7346ddfc7f8c7557c1211ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79560bae0f827facc7346ddfc7f8c7557c1211ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7467ab4232babb1ac9b906fe91abb9226464b884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7467ab4232babb1ac9b906fe91abb9226464b884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7467ab4232babb1ac9b906fe91abb9226464b884", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7467ab4232babb1ac9b906fe91abb9226464b884/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5affc0451c9eb83c5142c726710cb8dbe04b66f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5affc0451c9eb83c5142c726710cb8dbe04b66f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5affc0451c9eb83c5142c726710cb8dbe04b66f"}], "stats": {"total": 332, "additions": 184, "deletions": 148}, "files": [{"sha": "61b003a138f7b4dda0d41c47ec81642755d74e96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7467ab4232babb1ac9b906fe91abb9226464b884", "patch": "@@ -1,3 +1,12 @@\n+2018-01-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/83887\n+\t* graphite-scop-detection.c\n+\t(scop_detection::get_nearest_dom_with_single_entry): Remove.\n+\t(scop_detection::get_nearest_pdom_with_single_exit): Likewise.\n+\t(scop_detection::merge_sese): Re-implement with a flood-fill\n+\talgorithm that properly finds a SESE region if it exists.\n+\n 2018-01-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/61240"}, {"sha": "b1122c227eb73cd445a6f94bcff5c3d683e7f954", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 64, "deletions": 148, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=7467ab4232babb1ac9b906fe91abb9226464b884", "patch": "@@ -309,16 +309,6 @@ class scop_detection\n \n   sese_l get_sese (loop_p loop);\n \n-  /* Return the closest dominator with a single entry edge.  In case of a\n-     back-loop the back-edge is not counted.  */\n-\n-  static edge get_nearest_dom_with_single_entry (basic_block dom);\n-\n-  /* Return the closest post-dominator with a single exit edge.  In case of a\n-     back-loop the back-edge is not counted.  */\n-\n-  static edge get_nearest_pdom_with_single_exit (basic_block dom);\n-\n   /* Merge scops at same loop depth and returns the new sese.\n      Returns a new SESE when merge was successful, INVALID_SESE otherwise.  */\n \n@@ -441,85 +431,6 @@ scop_detection::get_sese (loop_p loop)\n   return sese_l (scop_begin, scop_end);\n }\n \n-/* Return the closest dominator with a single entry edge.  */\n-\n-edge\n-scop_detection::get_nearest_dom_with_single_entry (basic_block dom)\n-{\n-  if (!dom->preds)\n-    return NULL;\n-\n-  /* If any of the dominators has two predecessors but one of them is a back\n-     edge, then that basic block also qualifies as a dominator with single\n-     entry.  */\n-  if (dom->preds->length () == 2)\n-    {\n-      /* If e1->src dominates e2->src then e1->src will also dominate dom.  */\n-      edge e1 = (*dom->preds)[0];\n-      edge e2 = (*dom->preds)[1];\n-      loop_p l = dom->loop_father;\n-      loop_p l1 = e1->src->loop_father;\n-      loop_p l2 = e2->src->loop_father;\n-      if (l != l1 && l == l2\n-\t  && dominated_by_p (CDI_DOMINATORS, e2->src, e1->src))\n-\treturn e1;\n-      if (l != l2 && l == l1\n-\t  && dominated_by_p (CDI_DOMINATORS, e1->src, e2->src))\n-\treturn e2;\n-    }\n-\n-  while (dom->preds->length () != 1)\n-    {\n-      if (dom->preds->length () < 1)\n-\treturn NULL;\n-      dom = get_immediate_dominator (CDI_DOMINATORS, dom);\n-      if (!dom->preds)\n-\treturn NULL;\n-    }\n-  return (*dom->preds)[0];\n-}\n-\n-/* Return the closest post-dominator with a single exit edge.  In case of a\n-   back-loop the back-edge is not counted.  */\n-\n-edge\n-scop_detection::get_nearest_pdom_with_single_exit (basic_block pdom)\n-{\n-  if (!pdom->succs)\n-    return NULL;\n-\n-  /* If any of the post-dominators has two successors but one of them is a back\n-     edge, then that basic block also qualifies as a post-dominator with single\n-     exit. */\n-  if (pdom->succs->length () == 2)\n-    {\n-      /* If e1->dest post-dominates e2->dest then e1->dest will also\n-\t post-dominate pdom.  */\n-      edge e1 = (*pdom->succs)[0];\n-      edge e2 = (*pdom->succs)[1];\n-      loop_p l = pdom->loop_father;\n-      loop_p l1 = e1->dest->loop_father;\n-      loop_p l2 = e2->dest->loop_father;\n-      if (l != l1 && l == l2\n-\t  && dominated_by_p (CDI_POST_DOMINATORS, e2->dest, e1->dest))\n-\treturn e1;\n-      if (l != l2 && l == l1\n-\t  && dominated_by_p (CDI_POST_DOMINATORS, e1->dest, e2->dest))\n-\treturn e2;\n-    }\n-\n-  while (pdom->succs->length () != 1)\n-    {\n-      if (pdom->succs->length () < 1)\n-\treturn NULL;\n-      pdom = get_immediate_dominator (CDI_POST_DOMINATORS, pdom);\n-      if (!pdom->succs)\n-\treturn NULL;\n-    }\n-\n-  return (*pdom->succs)[0];\n-}\n-\n /* Merge scops at same loop depth and returns the new sese.\n    Returns a new SESE when merge was successful, INVALID_SESE otherwise.  */\n \n@@ -537,73 +448,78 @@ scop_detection::merge_sese (sese_l first, sese_l second) const\n \t       dp << \"[scop-detection] try merging sese s2: \";\n \t       print_sese (dump_file, second));\n \n-  /* Assumption: Both the sese's should be at the same loop depth or one scop\n-     should subsume the other like in case of nested loops.  */\n-\n-  /* Find the common dominators for entry,\n-     and common post-dominators for the exit.  */\n-  basic_block dom = nearest_common_dominator (CDI_DOMINATORS,\n-\t\t\t\t\t      get_entry_bb (first),\n-\t\t\t\t\t      get_entry_bb (second));\n-\n-  edge entry = get_nearest_dom_with_single_entry (dom);\n-\n-  if (!entry || (entry->flags & EDGE_IRREDUCIBLE_LOOP))\n-    return invalid_sese;\n-\n-  basic_block pdom = nearest_common_dominator (CDI_POST_DOMINATORS,\n-\t\t\t\t\t       get_exit_bb (first),\n-\t\t\t\t\t       get_exit_bb (second));\n-  pdom = nearest_common_dominator (CDI_POST_DOMINATORS, dom, pdom);\n-\n-  edge exit = get_nearest_pdom_with_single_exit (pdom);\n-\n-  if (!exit || (exit->flags & EDGE_IRREDUCIBLE_LOOP))\n-    return invalid_sese;\n-\n-  sese_l combined (entry, exit);\n-\n-  DEBUG_PRINT (dp << \"[scop-detection] checking combined sese: \";\n-\t       print_sese (dump_file, combined));\n-\n-  /* FIXME: We could iterate to find the dom which dominates pdom, and pdom\n-     which post-dominates dom, until it stabilizes.  Also, ENTRY->SRC and\n-     EXIT->DEST should be in the same loop nest.  */\n-  if (!dominated_by_p (CDI_DOMINATORS, pdom, dom)\n-      || entry->src->loop_father != exit->dest->loop_father)\n-    return invalid_sese;\n-\n-  /* For now we just bail out when there is a loop exit in the region\n-     that is not also the exit of the region.  We could enlarge the\n-     region to cover the loop that region exits to.  See PR79977.  */\n-  if (loop_outer (entry->src->loop_father))\n+  auto_bitmap worklist, in_sese_region;\n+  bitmap_set_bit (worklist, get_entry_bb (first)->index);\n+  bitmap_set_bit (worklist, get_exit_bb (first)->index);\n+  bitmap_set_bit (worklist, get_entry_bb (second)->index);\n+  bitmap_set_bit (worklist, get_exit_bb (second)->index);\n+  edge entry = NULL, exit = NULL;\n+\n+  /* We can optimize the case of adding a loop entry dest or exit\n+     src to the worklist (for single-exit loops) by skipping\n+     directly to the exit dest / entry src.  in_sese_region\n+     doesn't have to cover all blocks in the region but merely\n+     its border it acts more like a visited bitmap.  */\n+  do\n     {\n-      vec<edge> exits = get_loop_exit_edges (entry->src->loop_father);\n-      for (unsigned i = 0; i < exits.length (); ++i)\n+      int index = bitmap_first_set_bit (worklist);\n+      bitmap_clear_bit (worklist, index);\n+      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, index);\n+      edge_iterator ei;\n+      edge e;\n+\n+      /* With fake exit edges we can end up with no possible exit.  */\n+      if (index == EXIT_BLOCK)\n \t{\n-\t  if (exits[i] != exit\n-\t      && bb_in_region (exits[i]->src, entry->dest, exit->src))\n-\t    {\n-\t      DEBUG_PRINT (dp << \"[scop-detection-fail] cannot merge seses.\\n\");\n-\t      exits.release ();\n-\t      return invalid_sese;\n-\t    }\n+\t  DEBUG_PRINT (dp << \"[scop-detection-fail] cannot merge seses.\\n\");\n+\t  return invalid_sese;\n \t}\n-      exits.release ();\n+\n+      bitmap_set_bit (in_sese_region, bb->index);\n+         \n+      basic_block dom = get_immediate_dominator (CDI_DOMINATORS, bb);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->src == dom\n+\t    && (! entry\n+\t\t|| dominated_by_p (CDI_DOMINATORS, entry->dest, bb)))\n+\t  {\n+\t    if (entry\n+\t\t&& ! bitmap_bit_p (in_sese_region, entry->src->index))\n+\t      bitmap_set_bit (worklist, entry->src->index);\n+\t    entry = e;\n+\t  }\n+\telse if (! bitmap_bit_p (in_sese_region, e->src->index))\n+\t  bitmap_set_bit (worklist, e->src->index);\n+\n+      basic_block pdom = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->dest == pdom\n+\t    && (! exit\n+\t\t|| dominated_by_p (CDI_POST_DOMINATORS, exit->src, bb)))\n+\t  {\n+\t    if (exit\n+\t\t&& ! bitmap_bit_p (in_sese_region, exit->dest->index))\n+\t      bitmap_set_bit (worklist, exit->dest->index);\n+\t    exit = e;\n+\t  }\n+\telse if (! bitmap_bit_p (in_sese_region, e->dest->index))\n+\t  bitmap_set_bit (worklist, e->dest->index);\n     }\n+  while (! bitmap_empty_p (worklist));\n \n-  /* For now we just want to bail out when exit does not post-dominate entry.\n-     TODO: We might just add a basic_block at the exit to make exit\n-     post-dominate entry (the entire region).  */\n-  if (!dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (combined),\n-\t\t       get_exit_bb (combined))\n-      || !dominated_by_p (CDI_DOMINATORS, get_exit_bb (combined),\n-\t\t\t  get_entry_bb (combined)))\n+  /* Include the BB with the loop-closed SSA PHI nodes.\n+     canonicalize_loop_closed_ssa makes sure that is in proper shape.  */\n+  if (exit->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n+      && loop_exit_edge_p (exit->src->loop_father, exit))\n     {\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] cannot merge seses.\\n\");\n-      return invalid_sese;\n+      gcc_assert (single_pred_p (exit->dest)\n+\t\t  && single_succ_p (exit->dest)\n+\t\t  && sese_trivially_empty_bb_p (exit->dest));\n+      exit = single_succ_edge (exit->dest);\n     }\n \n+  sese_l combined (entry, exit);\n+\n   DEBUG_PRINT (dp << \"[merged-sese] s1: \"; print_sese (dump_file, combined));\n \n   return combined;"}, {"sha": "3cc5bda045461235d46500c1e0f863d773fcdfd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7467ab4232babb1ac9b906fe91abb9226464b884", "patch": "@@ -1,3 +1,10 @@\n+2018-01-18  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/83887\n+\t* gcc.dg/graphite/pr83887.c: New testcase.\n+\t* gfortran.dg/graphite/pr83887.f90: Likewise.\n+\t* gfortran.dg/graphite/pr83887.f: Likewise.\n+\n 2018-01-18  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/65578"}, {"sha": "b230ec9a1d0eb5f2318ccfc797cf8b7ced04ecd1", "filename": "gcc/testsuite/gcc.dg/graphite/pr83887.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr83887.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr83887.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr83887.c?ref=7467ab4232babb1ac9b906fe91abb9226464b884", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -floop-nest-optimize -fno-tree-loop-im\" } */\n+\n+int z4, g7;\n+\n+void\n+x3 (int my)\n+{\n+  while (my < 2)\n+    {\n+      for (z4 = 0; z4 < 2; ++z4)\n+\t{\n+\t}\n+\n+      if (my != 0)\n+\tfor (g7 = 0; g7 < 2; ++g7)\n+\t  {\n+\t  }\n+\n+      ++my;\n+    }\n+}"}, {"sha": "f6672224907f397dcc81237c01ed0016ab4bab74", "filename": "gcc/testsuite/gfortran.dg/graphite/pr83887.f", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr83887.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr83887.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr83887.f?ref=7467ab4232babb1ac9b906fe91abb9226464b884", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -floop-nest-optimize\" }\n+      SUBROUTINE STONG(IGAUSS)\n+      DIMENSION EXX(6)\n+      PARAMETER (MXSH=1000, MXGTOT=5000)\n+      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),NSHELL\n+  100 CONTINUE\n+      NSHELL = NSHELL+1\n+      IF(NSHELL.GT.MXSH) THEN\n+         RETURN\n+      END IF\n+      DO 320 I = 1,IGAUSS\n+         K = K1+I-1\n+         EX(K) = EXX(I)*SCALE\n+  320 CONTINUE\n+      IF(TNORM.GT.TOLNRM) THEN\n+         STOP\n+      END IF\n+      DO 460 IG = K1,K2\n+         CS(IG) = FACS*CS(IG)\n+  460 CONTINUE\n+      GO TO 100\n+      END"}, {"sha": "2f299cd9c70330dd0f603813d418e48ecc65ce9d", "filename": "gcc/testsuite/gfortran.dg/graphite/pr83887.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr83887.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7467ab4232babb1ac9b906fe91abb9226464b884/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr83887.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr83887.f90?ref=7467ab4232babb1ac9b906fe91abb9226464b884", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do compile }\n+! { dg-options \"-O -floop-nest-optimize\" }\n+      SUBROUTINE ZTRMM ( SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, &\n+                   B, LDB )\n+      CHARACTER*1        SIDE, UPLO, TRANSA, DIAG\n+      INTEGER            M, N, LDA, LDB\n+      complex(kind((1.0d0,1.0d0)))         ALPHA\n+      complex(kind((1.0d0,1.0d0)))         A( LDA, * ), B( LDB, * )\n+      EXTERNAL           XERBLA\n+      INTRINSIC          CONJG, MAX\n+      LOGICAL            LSIDE, NOCONJ, NOUNIT, UPPER\n+      INTEGER            I, INFO, J, K, NROWA\n+      complex(kind((1.0d0,1.0d0)))         TEMP\n+      complex(kind((1.0d0,1.0d0)))         ONE\n+      PARAMETER        ( ONE  = ( 1.0D+0, 0.0D+0 ) )\n+      complex(kind((1.0d0,1.0d0)))         ZERO\n+      PARAMETER        ( ZERO = ( 0.0D+0, 0.0D+0 ) )\n+      LSIDE  =  scan( SIDE  , 'Ll' )>0\n+      IF( LSIDE )THEN\n+         NROWA = M\n+      ELSE\n+         NROWA = N\n+      END IF\n+      NOCONJ =  scan( TRANSA, 'Tt' )>0\n+      NOUNIT =  scan( DIAG  , 'Nn' )>0\n+      UPPER  =  scan( UPLO  , 'Uu' )>0\n+      INFO   = 0\n+      IF( N.EQ.0 ) &\n+   RETURN\n+      IF( ALPHA.EQ.ZERO )THEN\n+         DO 20, J = 1, N\n+            DO 10, I = 1, M\n+               B( I, J ) = ZERO\n+   10       CONTINUE\n+   20    CONTINUE\n+         RETURN\n+      END IF\n+               DO 160, J = 1, N\n+                  DO 150, I = 1, M\n+                     TEMP = B( I, J )\n+                     IF( NOCONJ )THEN\n+                        IF( NOUNIT ) &\n+                     TEMP = TEMP*A( I, I )\n+                        DO 130, K = I + 1, M\n+                           TEMP = TEMP + A( K, I )*B( K, J )\n+  130                   CONTINUE\n+                     ELSE\n+                        IF( NOUNIT ) &\n+                     TEMP = TEMP*CONJG( A( I, I ) )\n+                        DO 140, K = I + 1, M\n+                           TEMP = TEMP + CONJG( A( K, I ) )*B( K, J )\n+  140                   CONTINUE\n+                     END IF\n+                     B( I, J ) = ALPHA*TEMP\n+  150             CONTINUE\n+  160          CONTINUE\n+      RETURN\n+      END\n+"}]}