{"sha": "2adb671d186febfe9610f8d8ac8ba296b79d2c90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFkYjY3MWQxODZmZWJmZTk2MTBmOGQ4YWM4YmEyOTZiNzlkMmM5MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2016-08-30T03:27:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-08-30T03:27:43Z"}, "message": "compiler: add -fgo-c-header=FILE to create a C header\n    \n    The new -fgo-c-header=FILE option will write a C header file defining\n    all the struct types and numeric const values in package scope.  This\n    will be used when building the Go runtime package (libgo/go/runtime) to\n    generate a C header file that may be included by the C code in the C\n    runtime package (libgo/runtime).\n    \n    This will ensure that the Go code and C code are working with the same\n    data structures as we convert the runtime from C to Go to upgrade to the\n    current GC runtime, notably the concurrent garbage collector.\n    \n    Reviewed-on: https://go-review.googlesource.com/28000\n\n\t* lang.opt (fgo-c-header, fgo-compiling-runtime): New options.\n\t* go-c.h (struct go_create_gogo_args): Define.\n\t(go_create_gogo): Change declaration to take struct pointer.\n\t* go-lang.c (go_c_header): New static variable.\n\t(go_langhook_init): Update call to go_create_gogo.\n\t* gccgo.texi (Invoking gccgo): Document -fgo-c-header and\n\t-fgo-compiling-runtime.\n\nFrom-SVN: r239852", "tree": {"sha": "4e9dd1801c8fffce5ca94c71063a0a5a3acd0d30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e9dd1801c8fffce5ca94c71063a0a5a3acd0d30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2adb671d186febfe9610f8d8ac8ba296b79d2c90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2adb671d186febfe9610f8d8ac8ba296b79d2c90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2adb671d186febfe9610f8d8ac8ba296b79d2c90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2adb671d186febfe9610f8d8ac8ba296b79d2c90/comments", "author": null, "committer": null, "parents": [{"sha": "0b390d608949864df9ce128a5090b1788dc07b16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b390d608949864df9ce128a5090b1788dc07b16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b390d608949864df9ce128a5090b1788dc07b16"}], "stats": {"total": 552, "additions": 525, "deletions": 27}, "files": [{"sha": "2052a977029f260e25eed447c17cdc27837c116b", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -1,3 +1,13 @@\n+2016-08-29  Ian Lance Taylor  <iant@google.com>\n+\n+\t* lang.opt (fgo-c-header, fgo-compiling-runtime): New options.\n+\t* go-c.h (struct go_create_gogo_args): Define.\n+\t(go_create_gogo): Change declaration to take struct pointer.\n+\t* go-lang.c (go_c_header): New static variable.\n+\t(go_langhook_init): Update call to go_create_gogo.\n+\t* gccgo.texi (Invoking gccgo): Document -fgo-c-header and\n+\t-fgo-compiling-runtime.\n+\n 2016-08-09  Ian Lance Taylor  <iant@google.com>\n \n \t* gccgo.texi (Invoking gccgo): Document -fgo-optimize-allocs and"}, {"sha": "04ce3e996c737e8164efa50fabff2b9d3f4ce0e1", "filename": "gcc/go/gccgo.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgccgo.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgccgo.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgccgo.texi?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -239,6 +239,17 @@ heap when possible.  In the future this may be the default.\n Output escape analysis debugging information.  Larger values of\n @var{n} generate more information.\n \n+@item -fgo-c-header=@var{file}\n+@cindex @option{-fgo-c-header}\n+Write top-level named Go struct definitions to @var{file} as C code.\n+This is used when compiling the runtime package.\n+\n+@item -fgo-compiling-runtime\n+@cindex @option{-fgo-compiling-runtime}\n+Apply special rules for compiling the runtime package.  Implicit\n+memory allocation is forbidden.  Some additional compiler directives\n+are supported.\n+\n @item -g\n @cindex @option{-g for gccgo}\n This is the standard @command{gcc} option (@pxref{Debugging Options, ,"}, {"sha": "a96812d3cb5cb08ef3b27c30675109f9859419e2", "filename": "gcc/go/go-c.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -31,11 +31,21 @@ extern int go_enable_optimize (const char*);\n \n extern void go_add_search_path (const char*);\n \n-extern void go_create_gogo (int int_type_size, int pointer_size,\n-\t\t\t    const char* pkgpath, const char *prefix,\n-\t\t\t    const char *relative_import_path,\n-\t\t\t    bool check_divide_zero, bool check_divide_overflow,\n-\t\t\t    int debug_escape_level);\n+struct go_create_gogo_args\n+{\n+  int int_type_size;\n+  int pointer_size;\n+  const char* pkgpath;\n+  const char *prefix;\n+  const char *relative_import_path;\n+  const char *c_header;\n+  bool check_divide_by_zero;\n+  bool check_divide_overflow;\n+  bool compiling_runtime;\n+  int debug_escape_level;\n+};\n+\n+extern void go_create_gogo (const struct go_create_gogo_args*);\n \n extern void go_parse_input_files (const char**, unsigned int,\n \t\t\t\t  bool only_check_syntax,"}, {"sha": "88667e0c9b4aa6d74d4719f9b78172ee2755d65b", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -83,6 +83,7 @@ struct GTY(()) language_function\n static const char *go_pkgpath = NULL;\n static const char *go_prefix = NULL;\n static const char *go_relative_import_path = NULL;\n+static const char *go_c_header = NULL;\n \n /* Language hooks.  */\n \n@@ -99,9 +100,18 @@ go_langhook_init (void)\n      to, e.g., unsigned_char_type_node) but before calling\n      build_common_builtin_nodes (because it calls, indirectly,\n      go_type_for_size).  */\n-  go_create_gogo (INT_TYPE_SIZE, POINTER_SIZE, go_pkgpath, go_prefix,\n-\t\t  go_relative_import_path, go_check_divide_zero,\n-\t\t  go_check_divide_overflow, go_debug_escape_level);\n+  struct go_create_gogo_args args;\n+  args.int_type_size = INT_TYPE_SIZE;\n+  args.pointer_size = POINTER_SIZE;\n+  args.pkgpath = go_pkgpath;\n+  args.prefix = go_prefix;\n+  args.relative_import_path = go_relative_import_path;\n+  args.c_header = go_c_header;\n+  args.check_divide_by_zero = go_check_divide_zero;\n+  args.check_divide_overflow = go_check_divide_overflow;\n+  args.compiling_runtime = go_compiling_runtime;\n+  args.debug_escape_level = go_debug_escape_level;\n+  go_create_gogo (&args);\n \n   build_common_builtin_nodes ();\n \n@@ -247,6 +257,10 @@ go_langhook_handle_option (\n       go_relative_import_path = arg;\n       break;\n \n+    case OPT_fgo_c_header_:\n+      go_c_header = arg;\n+      break;\n+\n     default:\n       /* Just return 1 to indicate that the option is valid.  */\n       break;"}, {"sha": "e92aee31835ee3f5729e9387ae1d2d4fea25f32a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -1,4 +1,4 @@\n-0e505f5d191182abd8beb9b4c8232174bc116f97\n+9c91e7eeb404b5b639cd6e80e2a38da948bb35ec\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d0f523bdfe8764fd13791c4ceb4b280046884566", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -20,27 +20,29 @@ static Gogo* gogo;\n \n GO_EXTERN_C\n void\n-go_create_gogo(int int_type_size, int pointer_size, const char *pkgpath,\n-\t       const char *prefix, const char *relative_import_path,\n-\t       bool check_divide_by_zero, bool check_divide_overflow,\n-\t       int debug_escape_level)\n+go_create_gogo(const struct go_create_gogo_args* args)\n {\n   go_assert(::gogo == NULL);\n   Linemap* linemap = go_get_linemap();\n-  ::gogo = new Gogo(go_get_backend(), linemap, int_type_size, pointer_size);\n-\n-  if (pkgpath != NULL)\n-    ::gogo->set_pkgpath(pkgpath);\n-  else if (prefix != NULL)\n-    ::gogo->set_prefix(prefix);\n-\n-  if (relative_import_path != NULL)\n-    ::gogo->set_relative_import_path(relative_import_path);\n-  if (check_divide_by_zero)\n-    ::gogo->set_check_divide_by_zero(check_divide_by_zero);\n-  if (check_divide_overflow)\n-    ::gogo->set_check_divide_overflow(check_divide_overflow);\n-  ::gogo->set_debug_escape_level(debug_escape_level);\n+  ::gogo = new Gogo(go_get_backend(), linemap, args->int_type_size,\n+\t\t    args->pointer_size);\n+\n+  if (args->pkgpath != NULL)\n+    ::gogo->set_pkgpath(args->pkgpath);\n+  else if (args->prefix != NULL)\n+    ::gogo->set_prefix(args->prefix);\n+\n+  if (args->relative_import_path != NULL)\n+    ::gogo->set_relative_import_path(args->relative_import_path);\n+  if (args->check_divide_by_zero)\n+    ::gogo->set_check_divide_by_zero(args->check_divide_by_zero);\n+  if (args->check_divide_overflow)\n+    ::gogo->set_check_divide_overflow(args->check_divide_overflow);\n+  if (args->compiling_runtime)\n+    ::gogo->set_compiling_runtime(args->compiling_runtime);\n+  if (args->c_header != NULL)\n+    ::gogo->set_c_header(args->c_header);\n+  ::gogo->set_debug_escape_level(args->debug_escape_level);\n }\n \n // Parse the input files."}, {"sha": "3b7ecd3491fbe335c8ff05b45aab64c5557335c8", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -6,6 +6,8 @@\n \n #include \"go-system.h\"\n \n+#include <fstream>\n+\n #include \"filenames.h\"\n \n #include \"go-c.h\"\n@@ -4429,6 +4431,131 @@ Gogo::do_exports()\n \t\t      : \"\"),\n \t\t     this->imported_init_fns_,\n \t\t     this->package_->bindings());\n+\n+  if (!this->c_header_.empty() && !saw_errors())\n+    this->write_c_header();\n+}\n+\n+// Write the top level named struct types in C format to a C header\n+// file.  This is used when building the runtime package, to share\n+// struct definitions between C and Go.\n+\n+void\n+Gogo::write_c_header()\n+{\n+  std::ofstream out;\n+  out.open(this->c_header_.c_str());\n+  if (out.fail())\n+    {\n+      error(\"cannot open %s: %m\", this->c_header_.c_str());\n+      return;\n+    }\n+\n+  std::list<Named_object*> types;\n+  Bindings* top = this->package_->bindings();\n+  for (Bindings::const_definitions_iterator p = top->begin_definitions();\n+       p != top->end_definitions();\n+       ++p)\n+    {\n+      Named_object* no = *p;\n+      if (no->is_type() && no->type_value()->struct_type() != NULL)\n+\ttypes.push_back(no);\n+      if (no->is_const() && no->const_value()->type()->integer_type() != NULL)\n+\t{\n+\t  Numeric_constant nc;\n+\t  unsigned long val;\n+\t  if (no->const_value()->expr()->numeric_constant_value(&nc)\n+\t      && nc.to_unsigned_long(&val) == Numeric_constant::NC_UL_VALID)\n+\t    {\n+\t      out << \"#define \" << no->message_name() << ' ' << val\n+\t\t  << std::endl;\n+\t    }\n+\t}\n+    }\n+\n+  std::vector<const Named_object*> written;\n+  int loop = 0;\n+  while (!types.empty())\n+    {\n+      Named_object* no = types.front();\n+      types.pop_front();\n+\n+      std::vector<const Named_object*> requires;\n+      std::vector<const Named_object*> declare;\n+      if (!no->type_value()->struct_type()->can_write_to_c_header(&requires,\n+\t\t\t\t\t\t\t\t  &declare))\n+\tcontinue;\n+\n+      bool ok = true;\n+      for (std::vector<const Named_object*>::const_iterator pr\n+\t     = requires.begin();\n+\t   pr != requires.end() && ok;\n+\t   ++pr)\n+\t{\n+\t  for (std::list<Named_object*>::const_iterator pt = types.begin();\n+\t       pt != types.end() && ok;\n+\t       ++pt)\n+\t    if (*pr == *pt)\n+\t      ok = false;\n+\t}\n+      if (!ok)\n+\t{\n+\t  ++loop;\n+\t  if (loop > 10000)\n+\t    {\n+\t      // This should be impossible since the code parsed and\n+\t      // type checked.\n+\t      go_unreachable();\n+\t    }\n+\n+\t  types.push_back(no);\n+\t  continue;\n+\t}\n+\n+      for (std::vector<const Named_object*>::const_iterator pd\n+\t     = declare.begin();\n+\t   pd != declare.end();\n+\t   ++pd)\n+\t{\n+\t  if (*pd == no)\n+\t    continue;\n+\n+\t  std::vector<const Named_object*> drequires;\n+\t  std::vector<const Named_object*> ddeclare;\n+\t  if (!(*pd)->type_value()->struct_type()->\n+\t      can_write_to_c_header(&drequires, &ddeclare))\n+\t    continue;\n+\n+\t  bool done = false;\n+\t  for (std::vector<const Named_object*>::const_iterator pw\n+\t\t = written.begin();\n+\t       pw != written.end();\n+\t       ++pw)\n+\t    {\n+\t      if (*pw == *pd)\n+\t\t{\n+\t\t  done = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (!done)\n+\t    {\n+\t      out << std::endl;\n+\t      out << \"struct \" << (*pd)->message_name() << \";\" << std::endl;\n+\t      written.push_back(*pd);\n+\t    }\n+\t}\n+\n+      out << std::endl;\n+      out << \"struct \" << no->message_name() << \" {\" << std::endl;\n+      no->type_value()->struct_type()->write_to_c_header(out);\n+      out << \"};\" << std::endl;\n+      written.push_back(no);\n+    }\n+\n+  out.close();\n+  if (out.fail())\n+    error(\"error writing to %s: %m\", this->c_header_.c_str());\n }\n \n // Find the blocks in order to convert named types defined in blocks."}, {"sha": "fe9322c0be681a99bda057ab2d3e8b8d5ef0ba36", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -250,6 +250,12 @@ class Gogo\n   set_relative_import_path(const std::string& s)\n   { this->relative_import_path_ = s; }\n \n+  // Set the C header file to write.  This is used for the runtime\n+  // package.\n+  void\n+  set_c_header(const std::string& s)\n+  { this->c_header_ = s; }\n+\n   // Return whether to check for division by zero in binary operations.\n   bool\n   check_divide_by_zero() const\n@@ -270,6 +276,16 @@ class Gogo\n   set_check_divide_overflow(bool b)\n   { this->check_divide_overflow_ = b; }\n \n+  // Return whether we are compiling the runtime package.\n+  bool\n+  compiling_runtime() const\n+  { return this->compiling_runtime_; }\n+\n+  // Set whether we are compiling the runtime package.\n+  void\n+  set_compiling_runtime(bool b)\n+  { this->compiling_runtime_ = b; }\n+\n   // Return the level of escape analysis debug information to emit.\n   int\n   debug_escape_level() const\n@@ -731,6 +747,9 @@ class Gogo\n   const Bindings*\n   current_bindings() const;\n \n+  void\n+  write_c_header();\n+\n   // Get the decl for the magic initialization function.\n   Named_object*\n   initialization_function_decl();\n@@ -841,12 +860,17 @@ class Gogo\n   // The relative import path, from the -fgo-relative-import-path\n   // option.\n   std::string relative_import_path_;\n+  // The C header file to write, from the -fgo-c-header option.\n+  std::string c_header_;\n   // Whether or not to check for division by zero, from the\n   // -fgo-check-divide-zero option.\n   bool check_divide_by_zero_;\n   // Whether or not to check for division overflow, from the\n   // -fgo-check-divide-overflow option.\n   bool check_divide_overflow_;\n+  // Whether we are compiling the runtime package, from the\n+  // -fgo-compiling-runtime option.\n+  bool compiling_runtime_;\n   // The level of escape analysis debug information to emit, from the\n   // -fgo-debug-escape option.\n   int debug_escape_level_;"}, {"sha": "d91180a04971947bc9957e56fd050ce50aad73a2", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -6,6 +6,8 @@\n \n #include \"go-system.h\"\n \n+#include <ostream>\n+\n #include \"go-c.h\"\n #include \"gogo.h\"\n #include \"operator.h\"\n@@ -5680,6 +5682,276 @@ Struct_type::do_import(Import* imp)\n   return Type::make_struct_type(fields, imp->location());\n }\n \n+// Whether we can write this struct type to a C header file.\n+// We can't if any of the fields are structs defined in a different package.\n+\n+bool\n+Struct_type::can_write_to_c_header(\n+    std::vector<const Named_object*>* requires,\n+    std::vector<const Named_object*>* declare) const\n+{\n+  const Struct_field_list* fields = this->fields_;\n+  if (fields == NULL || fields->empty())\n+    return false;\n+  for (Struct_field_list::const_iterator p = fields->begin();\n+       p != fields->end();\n+       ++p)\n+    {\n+      if (p->is_anonymous())\n+\treturn false;\n+      if (!this->can_write_type_to_c_header(p->type(), requires, declare))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+// Whether we can write the type T to a C header file.\n+\n+bool\n+Struct_type::can_write_type_to_c_header(\n+    const Type* t,\n+    std::vector<const Named_object*>* requires,\n+    std::vector<const Named_object*>* declare) const\n+{\n+  t = t->forwarded();\n+  switch (t->classification())\n+    {\n+    case TYPE_ERROR:\n+    case TYPE_FORWARD:\n+      return false;\n+\n+    case TYPE_VOID:\n+    case TYPE_BOOLEAN:\n+    case TYPE_INTEGER:\n+    case TYPE_FLOAT:\n+    case TYPE_COMPLEX:\n+    case TYPE_STRING:\n+    case TYPE_FUNCTION:\n+    case TYPE_MAP:\n+    case TYPE_CHANNEL:\n+    case TYPE_INTERFACE:\n+      return true;\n+\n+    case TYPE_POINTER:\n+      if (t->points_to()->named_type() != NULL\n+\t  && t->points_to()->struct_type() != NULL)\n+\tdeclare->push_back(t->points_to()->named_type()->named_object());\n+      return true;\n+\n+    case TYPE_STRUCT:\n+      return t->struct_type()->can_write_to_c_header(requires, declare);\n+\n+    case TYPE_ARRAY:\n+      if (t->is_slice_type())\n+\treturn true;\n+      return this->can_write_type_to_c_header(t->array_type()->element_type(),\n+\t\t\t\t\t      requires, declare);\n+\n+    case TYPE_NAMED:\n+      {\n+\tconst Named_object* no = t->named_type()->named_object();\n+\tif (no->package() != NULL)\n+\t  {\n+\t    if (t->is_unsafe_pointer_type())\n+\t      return true;\n+\t    return false;\n+\t  }\n+\tif (t->struct_type() != NULL)\n+\t  {\n+\t    requires->push_back(no);\n+\t    return t->struct_type()->can_write_to_c_header(requires, declare);\n+\t  }\n+\treturn this->can_write_type_to_c_header(t->base(), requires, declare);\n+      }\n+\n+    case TYPE_CALL_MULTIPLE_RESULT:\n+    case TYPE_NIL:\n+    case TYPE_SINK:\n+    default:\n+      go_unreachable();\n+    }\n+}\n+\n+// Write this struct to a C header file.\n+\n+void\n+Struct_type::write_to_c_header(std::ostream& os) const\n+{\n+  const Struct_field_list* fields = this->fields_;\n+  for (Struct_field_list::const_iterator p = fields->begin();\n+       p != fields->end();\n+       ++p)\n+    {\n+      os << '\\t';\n+      this->write_field_to_c_header(os, p->field_name(), p->type());\n+      os << ';' << std::endl;\n+    }\n+}\n+\n+// Write the type of a struct field to a C header file.\n+\n+void\n+Struct_type::write_field_to_c_header(std::ostream& os, const std::string& name,\n+\t\t\t\t     const Type *t) const\n+{\n+  bool print_name = true;\n+  t = t->forwarded();\n+  switch (t->classification())\n+    {\n+    case TYPE_VOID:\n+      os << \"void\";\n+      break;\n+\n+    case TYPE_BOOLEAN:\n+      os << \"_Bool\";\n+      break;\n+\n+    case TYPE_INTEGER:\n+      {\n+\tconst Integer_type* it = t->integer_type();\n+\tif (it->is_unsigned())\n+\t  os << 'u';\n+\tos << \"int\" << it->bits() << \"_t\";\n+      }\n+      break;\n+\n+    case TYPE_FLOAT:\n+      switch (t->float_type()->bits())\n+\t{\n+\tcase 32:\n+\t  os << \"float\";\n+\t  break;\n+\tcase 64:\n+\t  os << \"double\";\n+\t  break;\n+\tdefault:\n+\t  go_unreachable();\n+\t}\n+      break;\n+\n+    case TYPE_COMPLEX:\n+      switch (t->complex_type()->bits())\n+\t{\n+\tcase 64:\n+\t  os << \"float _Complex\";\n+\t  break;\n+\tcase 128:\n+\t  os << \"double _Complex\";\n+\t  break;\n+\tdefault:\n+\t  go_unreachable();\n+\t}\n+      break;\n+\n+    case TYPE_STRING:\n+      os << \"String\";\n+      break;\n+\n+    case TYPE_FUNCTION:\n+      os << \"FuncVal\";\n+      break;\n+\n+    case TYPE_POINTER:\n+      {\n+\tstd::vector<const Named_object*> requires;\n+\tstd::vector<const Named_object*> declare;\n+\tif (!this->can_write_type_to_c_header(t->points_to(), &requires,\n+\t\t\t\t\t      &declare))\n+\t  os << \"void*\";\n+\telse\n+\t  {\n+\t    this->write_field_to_c_header(os, \"\", t->points_to());\n+\t    os << '*';\n+\t  }\n+      }\n+      break;\n+\n+    case TYPE_MAP:\n+      os << \"Map*\";\n+      break;\n+\n+    case TYPE_CHANNEL:\n+      os << \"Chan*\";\n+      break;\n+\n+    case TYPE_INTERFACE:\n+      if (t->interface_type()->is_empty())\n+\tos << \"Eface\";\n+      else\n+\tos << \"Iface\";\n+      break;\n+\n+    case TYPE_STRUCT:\n+      os << \"struct {\" << std::endl;\n+      t->struct_type()->write_to_c_header(os);\n+      os << \"\\t}\";\n+      break;\n+\n+    case TYPE_ARRAY:\n+      if (t->is_slice_type())\n+\tos << \"Slice\";\n+      else\n+\t{\n+\t  const Type *ele = t;\n+\t  std::vector<const Type*> array_types;\n+\t  while (ele->array_type() != NULL && !ele->is_slice_type())\n+\t    {\n+\t      array_types.push_back(ele);\n+\t      ele = ele->array_type()->element_type();\n+\t    }\n+\t  this->write_field_to_c_header(os, \"\", ele);\n+\t  os << ' ' << Gogo::message_name(name);\n+\t  print_name = false;\n+\t  while (!array_types.empty())\n+\t    {\n+\t      ele = array_types.back();\n+\t      array_types.pop_back();\n+\t      os << '[';\n+\t      Numeric_constant nc;\n+\t      if (!ele->array_type()->length()->numeric_constant_value(&nc))\n+\t\tgo_unreachable();\n+\t      mpz_t val;\n+\t      if (!nc.to_int(&val))\n+\t\tgo_unreachable();\n+\t      char* s = mpz_get_str(NULL, 10, val);\n+\t      os << s;\n+\t      free(s);\n+\t      mpz_clear(val);\n+\t      os << ']';\n+\t    }\n+\t}\n+      break;\n+\n+    case TYPE_NAMED:\n+      {\n+\tconst Named_object* no = t->named_type()->named_object();\n+\tif (t->struct_type() != NULL)\n+\t  os << \"struct \" << no->message_name();\n+\telse if (t->is_unsafe_pointer_type())\n+\t  os << \"void*\";\n+\telse if (t == Type::lookup_integer_type(\"uintptr\"))\n+\t  os << \"uintptr_t\";\n+\telse\n+\t  {\n+\t    this->write_field_to_c_header(os, name, t->base());\n+\t    print_name = false;\n+\t  }\n+      }\n+      break;\n+\n+    case TYPE_ERROR:\n+    case TYPE_FORWARD:\n+    case TYPE_CALL_MULTIPLE_RESULT:\n+    case TYPE_NIL:\n+    case TYPE_SINK:\n+    default:\n+      go_unreachable();\n+    }\n+\n+  if (print_name && !name.empty())\n+    os << ' ' << Gogo::message_name(name);\n+}\n+\n // Make a struct type.\n \n Struct_type*"}, {"sha": "5de49ae3534e5388b3cef2e4d1d01bf9845b125a", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -7,6 +7,8 @@\n #ifndef GO_TYPES_H\n #define GO_TYPES_H\n \n+#include <ostream>\n+\n #include \"go-linemap.h\"\n #include \"escape.h\"\n \n@@ -2329,6 +2331,16 @@ class Struct_type : public Type\n   void\n   write_equal_function(Gogo*, Named_type*);\n \n+  // Whether we can write this type to a C header file, to implement\n+  // -fgo-c-header.\n+  bool\n+  can_write_to_c_header(std::vector<const Named_object*>*,\n+\t\t\tstd::vector<const Named_object*>*) const;\n+\n+  // Write this type to a C header file, to implement -fgo-c-header.\n+  void\n+  write_to_c_header(std::ostream&) const;\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -2364,6 +2376,14 @@ class Struct_type : public Type\n   do_export(Export*) const;\n \n  private:\n+  bool\n+  can_write_type_to_c_header(const Type*,\n+\t\t\t     std::vector<const Named_object*>*,\n+\t\t\t     std::vector<const Named_object*>*) const;\n+\n+  void\n+  write_field_to_c_header(std::ostream&, const std::string&, const Type*) const;\n+\n   // Used to merge method sets of identical unnamed structs.\n   typedef Unordered_map_hash(Struct_type*, Struct_type*, Type_hash_identical,\n \t\t\t     Type_identical) Identical_structs;"}, {"sha": "503fc7dfd238297a00957d0e93b676edf169f44d", "filename": "gcc/go/lang.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2adb671d186febfe9610f8d8ac8ba296b79d2c90/gcc%2Fgo%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Flang.opt?ref=2adb671d186febfe9610f8d8ac8ba296b79d2c90", "patch": "@@ -37,6 +37,10 @@ Wall\n Go\n ; Documented in c.opt\n \n+fgo-c-header=\n+Go Joined RejectNegative\n+-fgo-c-header=<file>\tWrite Go struct definitions to file as C code.\n+\n fgo-check-divide-zero\n Go Var(go_check_divide_zero) Init(1)\n Add explicit checks for division by zero.\n@@ -45,6 +49,10 @@ fgo-check-divide-overflow\n Go Var(go_check_divide_overflow) Init(1)\n Add explicit checks for division overflow in INT_MIN / -1.\n \n+fgo-compiling-runtime\n+Go Var(go_compiling_runtime) Init(0)\n+Apply special rules for compiling runtime package.\n+\n fgo-dump-\n Go Joined RejectNegative\n -fgo-dump-<type>\tDump Go frontend internal information."}]}