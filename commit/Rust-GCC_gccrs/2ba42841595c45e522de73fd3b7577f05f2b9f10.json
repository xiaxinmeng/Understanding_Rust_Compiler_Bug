{"sha": "2ba42841595c45e522de73fd3b7577f05f2b9f10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJhNDI4NDE1OTVjNDVlNTIyZGU3M2ZkM2I3NTc3ZjA1ZjJiOWYxMA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2011-06-03T01:41:54Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2011-06-03T01:41:54Z"}, "message": "re PR debug/47590 (pragma optimize doesn't recompute derived options (was: var tracking produces wrong debug in code where optimization is turned off using pragma))\n\nPR debug/47590\n* target.def (delay_sched2, delay_vartrack): New.\n* doc/tm.texi.in: Update.\n* doc/tm.texi: Rebuild.\n* sched-rgn.c (gate_handle_sched2): Fail if delay_sched2.\n* var-tracking.c (gate_handle_var_tracking): Likewise.\n* config/bfin/bfin.c (bfin_flag_schedule_insns2): Drop.\n(bfin_flag_var_tracking): Drop.\n(output_file_start): Don't save and override flag_var_tracking.\n(bfin_option_override): Ditto flag_schedule_insns_after_reload.\n(bfin_reorg): Test original variables.\n(TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.\n* config/ia64/ia64.c (ia64_flag_schedule_insns2): Drop.\n(ia64_flag_var_tracking): Drop.\n(TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.\n(ia64_file_start): Don't save and override flag_var_tracking.\n(ia64_override_options_after_change): Ditto\nflag_schedule_insns_after_reload.\n(ia64_reorg): Test original variables.\n* config/picochip/picochip.c (picochip_flag_schedule_insns2): Drop.\n(picochip_flag_var_tracking): Drop.\n(TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.\n(picochip_option_override): Don't save and override\nflag_schedule_insns_after_reload.\n(picochip_asm_file_start): Ditto flag_var_tracking.\n(picochip_reorg): Test original variables.\n* config/spu/spu.c (spu_flag_var_tracking): Drop.\n(TARGET_DELAY_VARTRACK): Define.\n(spu_var_tracking): New.\n(spu_machine_dependent_reorg): Call it.\n(asm_file_start): Don't save and override flag_var_tracking.\n\nFrom-SVN: r174595", "tree": {"sha": "130af17e97b82f01416842e2e1eb7a7c299619c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/130af17e97b82f01416842e2e1eb7a7c299619c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ba42841595c45e522de73fd3b7577f05f2b9f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba42841595c45e522de73fd3b7577f05f2b9f10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba42841595c45e522de73fd3b7577f05f2b9f10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba42841595c45e522de73fd3b7577f05f2b9f10/comments", "author": null, "committer": null, "parents": [{"sha": "7a7249780d14ee05e74a57e41bd4618b9a4f176d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7249780d14ee05e74a57e41bd4618b9a4f176d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a7249780d14ee05e74a57e41bd4618b9a4f176d"}], "stats": {"total": 241, "additions": 132, "deletions": 109}, "files": [{"sha": "ad6842d79eddb02b6477e41df9198d9950b5111c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -1,3 +1,37 @@\n+2011-06-02  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/47590\n+\t* target.def (delay_sched2, delay_vartrack): New.\n+\t* doc/tm.texi.in: Update.\n+\t* doc/tm.texi: Rebuild.\n+\t* sched-rgn.c (gate_handle_sched2): Fail if delay_sched2.\n+\t* var-tracking.c (gate_handle_var_tracking): Likewise.\n+\t* config/bfin/bfin.c (bfin_flag_schedule_insns2): Drop.\n+\t(bfin_flag_var_tracking): Drop.\n+\t(output_file_start): Don't save and override flag_var_tracking.\n+\t(bfin_option_override): Ditto flag_schedule_insns_after_reload.\n+\t(bfin_reorg): Test original variables.\n+\t(TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.\n+\t* config/ia64/ia64.c (ia64_flag_schedule_insns2): Drop.\n+\t(ia64_flag_var_tracking): Drop.\n+\t(TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.\n+\t(ia64_file_start): Don't save and override flag_var_tracking.\n+\t(ia64_override_options_after_change): Ditto\n+\tflag_schedule_insns_after_reload.\n+\t(ia64_reorg): Test original variables.\n+\t* config/picochip/picochip.c (picochip_flag_schedule_insns2): Drop.\n+\t(picochip_flag_var_tracking): Drop.\n+\t(TARGET_DELAY_SCHED2, TARGET_DELAY_VARTRACK): Define.\n+\t(picochip_option_override): Don't save and override\n+\tflag_schedule_insns_after_reload.\n+\t(picochip_asm_file_start): Ditto flag_var_tracking.\n+\t(picochip_reorg): Test original variables.\n+\t* config/spu/spu.c (spu_flag_var_tracking): Drop.\n+\t(TARGET_DELAY_VARTRACK): Define.\n+\t(spu_var_tracking): New.\n+\t(spu_machine_dependent_reorg): Call it.\n+\t(asm_file_start): Don't save and override flag_var_tracking.\n+\n 2011-06-02  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR target/49163"}, {"sha": "2af0afe6db565e398e15bf7f329cd1d016b34a6f", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -86,14 +86,6 @@ const char *byte_reg_names[]   =  BYTE_REGISTER_NAMES;\n static int arg_regs[] = FUNCTION_ARG_REGISTERS;\n static int ret_regs[] = FUNCTION_RETURN_REGISTERS;\n \n-/* Nonzero if -fschedule-insns2 was given.  We override it and\n-   call the scheduler ourselves during reorg.  */\n-static int bfin_flag_schedule_insns2;\n-\n-/* Determines whether we run variable tracking in machine dependent\n-   reorganization.  */\n-static int bfin_flag_var_tracking;\n-\n struct bfin_cpu\n {\n   const char *name;\n@@ -375,13 +367,6 @@ output_file_start (void)\n   FILE *file = asm_out_file;\n   int i;\n \n-  /* Variable tracking should be run after all optimizations which change order\n-     of insns.  It also needs a valid CFG.  This can't be done in\n-     bfin_option_override, because flag_var_tracking is finalized after\n-     that.  */\n-  bfin_flag_var_tracking = flag_var_tracking;\n-  flag_var_tracking = 0;\n-\n   fprintf (file, \".file \\\"%s\\\";\\n\", input_filename);\n   \n   for (i = 0; arg_regs[i] >= 0; i++)\n@@ -2774,11 +2759,6 @@ bfin_option_override (void)\n \n   flag_schedule_insns = 0;\n \n-  /* Passes after sched2 can break the helpful TImode annotations that\n-     haifa-sched puts on every insn.  Just do scheduling in reorg.  */\n-  bfin_flag_schedule_insns2 = flag_schedule_insns_after_reload;\n-  flag_schedule_insns_after_reload = 0;\n-\n   init_machine_status = bfin_init_machine_status;\n }\n \n@@ -5552,7 +5532,7 @@ bfin_reorg (void)\n      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n   compute_bb_for_insn ();\n \n-  if (bfin_flag_schedule_insns2)\n+  if (flag_schedule_insns_after_reload)\n     {\n       splitting_for_sched = 1;\n       split_all_insns ();\n@@ -5581,7 +5561,7 @@ bfin_reorg (void)\n \n   workaround_speculation ();\n \n-  if (bfin_flag_var_tracking)\n+  if (flag_var_tracking)\n     {\n       timevar_push (TV_VAR_TRACKING);\n       variable_tracking_main ();\n@@ -6767,4 +6747,14 @@ bfin_conditional_register_usage (void)\n #undef TARGET_EXTRA_LIVE_ON_ENTRY\n #define TARGET_EXTRA_LIVE_ON_ENTRY bfin_extra_live_on_entry\n \n+/* Passes after sched2 can break the helpful TImode annotations that\n+   haifa-sched puts on every insn.  Just do scheduling in reorg.  */\n+#undef TARGET_DELAY_SCHED2\n+#define TARGET_DELAY_SCHED2 true\n+\n+/* Variable tracking should be run after all optimizations which\n+   change order of insns.  It also needs a valid CFG.  */\n+#undef TARGET_DELAY_VARTRACK\n+#define TARGET_DELAY_VARTRACK true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "d6eeb3d706997e723c7e31c5791dc681ab10d293", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -103,14 +103,6 @@ static const char * const ia64_local_reg_names[80] =\n static const char * const ia64_output_reg_names[8] =\n { \"out0\", \"out1\", \"out2\", \"out3\", \"out4\", \"out5\", \"out6\", \"out7\" };\n \n-/* Determines whether we run our final scheduling pass or not.  We always\n-   avoid the normal second scheduling pass.  */\n-static int ia64_flag_schedule_insns2;\n-\n-/* Determines whether we run variable tracking in machine dependent\n-   reorganization.  */\n-static int ia64_flag_var_tracking;\n-\n /* Variables which are this size or smaller are put in the sdata/sbss\n    sections.  */\n \n@@ -640,6 +632,14 @@ static const struct default_options ia64_option_optimization_table[] =\n #undef TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS ia64_preferred_reload_class\n \n+#undef TARGET_DELAY_SCHED2\n+#define TARGET_DELAY_SCHED2 true\n+\n+/* Variable tracking should be run after all optimizations which\n+   change order of insns.  It also needs a valid CFG.  */\n+#undef TARGET_DELAY_VARTRACK\n+#define TARGET_DELAY_VARTRACK true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n typedef enum\n@@ -2390,13 +2390,6 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n static void\n ia64_file_start (void)\n {\n-  /* Variable tracking should be run after all optimizations which change order\n-     of insns.  It also needs a valid CFG.  This can't be done in\n-     ia64_option_override, because flag_var_tracking is finalized after\n-     that.  */\n-  ia64_flag_var_tracking = flag_var_tracking;\n-  flag_var_tracking = 0;\n-\n   default_file_start ();\n   emit_safe_across_calls ();\n }\n@@ -5727,9 +5720,6 @@ ia64_option_override (void)\n static void\n ia64_override_options_after_change (void)\n {\n-  ia64_flag_schedule_insns2 = flag_schedule_insns_after_reload;\n-  flag_schedule_insns_after_reload = 0;\n-\n   if (optimize >= 3\n       && !global_options_set.x_flag_selective_scheduling\n       && !global_options_set.x_flag_selective_scheduling2)\n@@ -9401,7 +9391,7 @@ ia64_reorg (void)\n   if (optimize == 0)\n     split_all_insns ();\n \n-  if (optimize && ia64_flag_schedule_insns2\n+  if (optimize && flag_schedule_insns_after_reload\n       && dbg_cnt (ia64_sched2))\n     {\n       timevar_push (TV_SCHED2);\n@@ -9531,7 +9521,7 @@ ia64_reorg (void)\n \n   emit_predicate_relation_info ();\n \n-  if (ia64_flag_var_tracking)\n+  if (flag_var_tracking)\n     {\n       timevar_push (TV_VAR_TRACKING);\n       variable_tracking_main ();"}, {"sha": "f755020b2f6bcf396d24367d5da9c335cf8f08d1", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -149,13 +149,6 @@ const char *picochip_regnames[] = REGISTER_NAMES;\n \n /* Target scheduling information. */\n \n-/* Determine whether we run our final scheduling pass or not.  We always\n-   avoid the normal second scheduling pass.  */\n-int picochip_flag_schedule_insns2;\n-\n-/* Check if variable tracking needs to be run. */\n-int picochip_flag_var_tracking;\n-\n /* This flag indicates whether the next instruction to be output is a\n    VLIW continuation instruction.  It is used to communicate between\n    final_prescan_insn and asm_output_opcode. */\n@@ -343,6 +336,17 @@ static const struct default_options picochip_option_optimization_table[] =\n #undef TARGET_EXCEPT_UNWIND_INFO\n #define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n \n+/* The 2nd scheduling pass option is switched off, and a machine\n+   dependent reorganisation ensures that it is run later on, after the\n+   second jump optimisation.  */\n+#undef TARGET_DELAY_SCHED2\n+#define TARGET_DELAY_SCHED2 true\n+\n+/* Variable tracking should be run after all optimizations which\n+   change order of insns.  It also needs a valid CFG.  */\n+#undef TARGET_DELAY_VARTRACK\n+#define TARGET_DELAY_VARTRACK true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -356,10 +360,7 @@ picochip_return_in_memory(const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n   return ((unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 4);\n }\n \n-/* Allow some options to be overriden.  In particular, the 2nd\n-   scheduling pass option is switched off, and a machine dependent\n-   reorganisation ensures that it is run later on, after the second\n-   jump optimisation. */\n+/* Allow some options to be overriden. */\n \n static void\n picochip_option_override (void)\n@@ -396,18 +397,16 @@ picochip_option_override (void)\n   if (optimize >= 1)\n     flag_section_anchors = 1;\n \n-  /* Turn off the second scheduling pass, and move it to\n-     picochip_reorg, to avoid having the second jump optimisation\n-     trash the instruction modes (e.g., instructions are changed to\n-     TImode to mark the beginning of cycles). Two types of DFA\n-     scheduling are possible: space and speed. In both cases,\n-     instructions are reordered to avoid stalls (e.g., memory loads\n-     stall for one cycle). Speed scheduling will also enable VLIW\n-     instruction packing. VLIW instructions use more code space, so\n-     VLIW scheduling is disabled when scheduling for size. */\n-  picochip_flag_schedule_insns2 = flag_schedule_insns_after_reload;\n-  flag_schedule_insns_after_reload = 0;\n-  if (picochip_flag_schedule_insns2)\n+  /* The second scheduling pass runs within picochip_reorg, to avoid\n+     having the second jump optimisation trash the instruction modes\n+     (e.g., instructions are changed to TImode to mark the beginning\n+     of cycles).  Two types of DFA scheduling are possible: space and\n+     speed.  In both cases, instructions are reordered to avoid stalls\n+     (e.g., memory loads stall for one cycle).  Speed scheduling will\n+     also enable VLIW instruction packing.  VLIW instructions use more\n+     code space, so VLIW scheduling is disabled when scheduling for\n+     size.  */\n+  if (flag_schedule_insns_after_reload)\n     {\n       if (optimize_size)\n \tpicochip_schedule_type = DFA_TYPE_SPACE;\n@@ -461,7 +460,6 @@ picochip_option_override (void)\n \terror (\"invalid mul type specified (%s) - expected mac, mul or none\",\n \t       picochip_mul_type_string);\n     }\n-\n }\n \f\n \n@@ -1813,13 +1811,6 @@ picochip_asm_file_start (void)\n     fprintf (asm_out_file, \"// Has multiply: Yes (Mac unit)\\n\");\n   else\n     fprintf (asm_out_file, \"// Has multiply: No\\n\");\n-\n-  /* Variable tracking should be run after all optimizations which change order\n-     of insns.  It also needs a valid CFG.  This can't be done in\n-     picochip_option_override, because flag_var_tracking is finalized after\n-     that.  */\n-  picochip_flag_var_tracking = flag_var_tracking;\n-  flag_var_tracking = 0;\n }\n \n /* Output the end of an ASM file. */\n@@ -3376,15 +3367,16 @@ picochip_reorg (void)\n \t  delete_insn (prologue_end_note);\n \t}\n     }\n-  if (picochip_flag_var_tracking)\n-  {\n-    timevar_push (TV_VAR_TRACKING);\n-    variable_tracking_main ();\n-    /* We also have to deal with variable tracking notes in the middle \n-       of VLIW packets. */\n-    reorder_var_tracking_notes();\n-    timevar_pop (TV_VAR_TRACKING);\n-  }\n+\n+  if (flag_var_tracking)\n+    {\n+      timevar_push (TV_VAR_TRACKING);\n+      variable_tracking_main ();\n+      /* We also have to deal with variable tracking notes in the\n+\t middle of VLIW packets. */\n+      reorder_var_tracking_notes();\n+      timevar_pop (TV_VAR_TRACKING);\n+    }\n }\n \n /* Return the ALU character identifier for the current"}, {"sha": "9e62f16414cd49ece05edcc7fa42ca1fdd61a2e7", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -248,10 +248,6 @@ int spu_tune;\n    inserted in pairs, so we round down. */\n int spu_hint_dist = (8*4) - (2*4);\n \n-/* Determines whether we run variable tracking in machine dependent\n-   reorganization.  */\n-static int spu_flag_var_tracking;\n-\n enum spu_immediate {\n   SPU_NONE,\n   SPU_IL,\n@@ -509,6 +505,11 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK hook_bool_const_tree_hwi_hwi_const_tree_true\n \n+/* Variable tracking should be run after all optimizations which\n+   change order of insns.  It also needs a valid CFG.  */\n+#undef TARGET_DELAY_VARTRACK\n+#define TARGET_DELAY_VARTRACK true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n static void\n@@ -2696,6 +2697,19 @@ insert_hbrp (void)\n \n static int in_spu_reorg;\n \n+static void\n+spu_var_tracking (void)\n+{\n+  if (flag_var_tracking)\n+    {\n+      df_analyze ();\n+      timevar_push (TV_VAR_TRACKING);\n+      variable_tracking_main ();\n+      timevar_pop (TV_VAR_TRACKING);\n+      df_finish_pass (false);\n+    }\n+}\n+\n /* Insert branch hints.  There are no branch optimizations after this\n    pass, so it's safe to set our branch hints now. */\n static void\n@@ -2715,6 +2729,7 @@ spu_machine_dependent_reorg (void)\n          function might have hinted a call or return. */\n       insert_hbrp ();\n       pad_bb ();\n+      spu_var_tracking ();\n       return;\n     }\n \n@@ -2921,14 +2936,7 @@ spu_machine_dependent_reorg (void)\n \t  XVECEXP (unspec, 0, 0) = plus_constant (label_ref, offset);\n       }\n \n-  if (spu_flag_var_tracking)\n-    {\n-      df_analyze ();\n-      timevar_push (TV_VAR_TRACKING);\n-      variable_tracking_main ();\n-      timevar_pop (TV_VAR_TRACKING);\n-      df_finish_pass (false);\n-    }\n+  spu_var_tracking ();\n \n   free_bb_for_insn ();\n \n@@ -7057,19 +7065,6 @@ spu_libgcc_shift_count_mode (void)\n static void\n asm_file_start (void)\n {\n-  /* Variable tracking should be run after all optimizations which\n-     change order of insns.  It also needs a valid CFG.  Therefore,\n-     *if* we make nontrivial changes in machine-dependent reorg,\n-     run variable tracking after those.  However, if we do not run\n-     our machine-dependent reorg pass, we must still run the normal\n-     variable tracking pass (or else we will ICE in final since\n-     debug insns have not been removed).  */\n-  if (TARGET_BRANCH_HINTS && optimize)\n-    {\n-      spu_flag_var_tracking = flag_var_tracking;\n-      flag_var_tracking = 0;\n-    }\n-\n   default_file_start ();\n }\n "}, {"sha": "b28a27ed6c9a718c2b71c8dc11ef22a14054e163", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -9432,6 +9432,14 @@ tables, and hence is desirable if it works.\n True if the @code{.debug_pubtypes} and @code{.debug_pubnames} sections should be emitted.  These sections are not used on most platforms, and in particular GDB does not use them.\n @end deftypevr\n \n+@deftypevr {Target Hook} bool TARGET_DELAY_SCHED2\n+True if sched2 is not to be run at its normal place.  This usually means it will be run as part of machine-specific reorg.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} bool TARGET_DELAY_VARTRACK\n+True if vartrack is not to be run at its normal place.  This usually means it will be run as part of machine-specific reorg.\n+@end deftypevr\n+\n @defmac ASM_OUTPUT_DWARF_DELTA (@var{stream}, @var{size}, @var{label1}, @var{label2})\n A C statement to issue assembly directives that create a difference\n @var{lab1} minus @var{lab2}, using an integer of the given @var{size}."}, {"sha": "2b8511d2deccb1e42344278a8024e4737532021d", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -9353,6 +9353,10 @@ tables, and hence is desirable if it works.\n \n @hook TARGET_WANT_DEBUG_PUB_SECTIONS\n \n+@hook TARGET_DELAY_SCHED2\n+\n+@hook TARGET_DELAY_VARTRACK\n+\n @defmac ASM_OUTPUT_DWARF_DELTA (@var{stream}, @var{size}, @var{label1}, @var{label2})\n A C statement to issue assembly directives that create a difference\n @var{lab1} minus @var{lab2}, using an integer of the given @var{size}."}, {"sha": "248b870a75abd5e5d1a373a9498c5f92238a72d9", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -3508,7 +3508,7 @@ gate_handle_sched2 (void)\n {\n #ifdef INSN_SCHEDULING\n   return optimize > 0 && flag_schedule_insns_after_reload\n-    && dbg_cnt (sched2_func);\n+    && !targetm.delay_sched2 && dbg_cnt (sched2_func);\n #else\n   return 0;\n #endif"}, {"sha": "3215bd3ddcfa39c13ef547c87a635c7e984d41fe", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -2717,6 +2717,16 @@ DEFHOOKPOD\n  in particular GDB does not use them.\",\n  bool, false)\n \n+DEFHOOKPOD\n+(delay_sched2, \"True if sched2 is not to be run at its normal place.  \\\n+This usually means it will be run as part of machine-specific reorg.\",\n+bool, false)\n+\n+DEFHOOKPOD\n+(delay_vartrack, \"True if vartrack is not to be run at its normal place.  \\\n+This usually means it will be run as part of machine-specific reorg.\",\n+bool, false)\n+\n /* Leave the boolean fields at the end.  */\n \n /* Close the 'struct gcc_target' definition.  */"}, {"sha": "d9732a611d84ca6b84d18f398df7bbde3fc74e7f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba42841595c45e522de73fd3b7577f05f2b9f10/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=2ba42841595c45e522de73fd3b7577f05f2b9f10", "patch": "@@ -9111,7 +9111,7 @@ variable_tracking_main (void)\n static bool\n gate_handle_var_tracking (void)\n {\n-  return (flag_var_tracking);\n+  return (flag_var_tracking && !targetm.delay_vartrack);\n }\n \n "}]}