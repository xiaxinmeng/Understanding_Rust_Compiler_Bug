{"sha": "b6a10c9fe17597c7870f182aa505e7bf77aab429", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZhMTBjOWZlMTc1OTdjNzg3MGYxODJhYTUwNWU3YmY3N2FhYjQyOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-04T20:36:23Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-04T20:36:23Z"}, "message": "(common_type): Handle complex types.\n\n(lvalue_p): Handle REALPART_EXPR, IMAGPART_EXPR.\n(build_binary_op, build_unary_op): Handle complex types.\n\nFrom-SVN: r3646", "tree": {"sha": "da8407adc4edba6cdb495b63b78f5c4e9efb6739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da8407adc4edba6cdb495b63b78f5c4e9efb6739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6a10c9fe17597c7870f182aa505e7bf77aab429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a10c9fe17597c7870f182aa505e7bf77aab429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a10c9fe17597c7870f182aa505e7bf77aab429", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a10c9fe17597c7870f182aa505e7bf77aab429/comments", "author": null, "committer": null, "parents": [{"sha": "f0b996c50ca3dc47e41a3e4c6f92b6403a1f55c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0b996c50ca3dc47e41a3e4c6f92b6403a1f55c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0b996c50ca3dc47e41a3e4c6f92b6403a1f55c9"}], "stats": {"total": 106, "additions": 87, "deletions": 19}, "files": [{"sha": "d5c251be668a9d15ee9578b683a6a3449d52c8d1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 87, "deletions": 19, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a10c9fe17597c7870f182aa505e7bf77aab429/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a10c9fe17597c7870f182aa505e7bf77aab429/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=b6a10c9fe17597c7870f182aa505e7bf77aab429", "patch": "@@ -188,6 +188,24 @@ common_type (t1, t2)\n   code1 = TREE_CODE (t1);\n   code2 = TREE_CODE (t2);\n \n+  /* If one type is complex, form the common type\n+     of the non-complex components,\n+     then make that complex.  */\n+  if (code1 == COMPLEX_TYPE || code2 == COMPLEX_TYPE)\n+    {\n+      tree subtype1, subtype2, subtype;\n+      if (code1 == COMPLEX_TYPE)\n+\tsubtype1 = TREE_TYPE (t1);\n+      else\n+\tsubtype1 = t1;\n+      if (code2 == COMPLEX_TYPE)\n+\tsubtype2 = TREE_TYPE (t2);\n+      else\n+\tsubtype2 = t2;\n+      subtype = common_type (subtype1, subtype2);\n+      return build_complex_type (subtype);\n+    }\n+\n   switch (code1)\n     {\n     case INTEGER_TYPE:\n@@ -2308,8 +2326,10 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n+\t   || code0 == COMPLEX_TYPE)\n+\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t      || code1 == COMPLEX_TYPE))\n \t{\n \t  if (!(code0 == INTEGER_TYPE && code1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n@@ -2363,8 +2383,10 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n     case TRUTH_XOR_EXPR:\n-      if ((code0 == INTEGER_TYPE || code0 == POINTER_TYPE || code0 == REAL_TYPE)\n-\t  && (code1 == INTEGER_TYPE || code1 == POINTER_TYPE || code1 == REAL_TYPE))\n+      if ((code0 == INTEGER_TYPE || code0 == POINTER_TYPE\n+\t   || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n+\t  && (code1 == INTEGER_TYPE || code1 == POINTER_TYPE\n+\t      || code1 == REAL_TYPE || code1 == COMPLEX_TYPE))\n \t{\n \t  /* Result of these operations is always an int,\n \t     but that does not mean the operands should be\n@@ -2473,8 +2495,10 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t but don't convert the args to int!  */\n       result_type = integer_type_node;\n       converted = 1;\n-      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n+\t   || code0 == COMPLEX_TYPE)\n+\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t      || code1 == COMPLEX_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n@@ -2525,8 +2549,10 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \n     case MAX_EXPR:\n     case MIN_EXPR:\n-      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-\t   && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n+\t   || code0 == COMPLEX_TYPE)\n+\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t      || code1 == COMPLEX_TYPE))\n \tshorten = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n@@ -2543,8 +2569,10 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     case GE_EXPR:\n     case LT_EXPR:\n     case GT_EXPR:\n-      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-\t   && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+      if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE\n+\t   || code0 == COMPLEX_TYPE)\n+\t  && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t      || code1 == COMPLEX_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n@@ -2589,9 +2617,12 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n       break;\n     }\n \n-  if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n-      && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n+  if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n+      &&\n+      (code1 == INTEGER_TYPE || code1 == REAL_TYPE || code1 == COMPLEX_TYPE))\n     {\n+      int none_complex = (code0 != COMPLEX_TYPE && code1 != COMPLEX_TYPE);\n+\n       if (shorten || common || short_compare)\n \tresult_type = common_type (type0, type1);\n \n@@ -2606,7 +2637,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t Eg, (short)-1 | (unsigned short)-1 is (int)-1\n \t but calculated in (unsigned short) it would be (unsigned short)-1.  */\n \n-      if (shorten)\n+      if (shorten && none_complex)\n \t{\n \t  int unsigned0, unsigned1;\n \t  tree arg0 = get_narrower (op0, &unsigned0);\n@@ -2708,7 +2739,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n       /* Comparison operations are shortened too but differently.\n \t They identify themselves by setting short_compare = 1.  */\n \n-      if (short_compare)\n+      if (short_compare && none_complex)\n \t{\n \t  /* Don't write &op0, etc., because that would prevent op0\n \t     from being kept in a register.\n@@ -2938,14 +2969,16 @@ build_unary_op (code, xarg, noconvert)\n       /* This is used for unary plus, because a CONVERT_EXPR\n \t is enough to prevent anybody from looking inside for\n \t associativity, but won't generate any code.  */\n-      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE))\n+      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n+\t    || typecode == COMPLEX_TYPE))\n         errstring = \"wrong type argument to unary plus\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n \n     case NEGATE_EXPR:\n-      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE))\n+      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n+\t    || typecode == COMPLEX_TYPE))\n         errstring = \"wrong type argument to unary minus\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n@@ -2959,7 +2992,8 @@ build_unary_op (code, xarg, noconvert)\n       break;\n \n     case ABS_EXPR:\n-      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE))\n+      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE\n+\t    || typecode == COMPLEX_TYPE))\n         errstring = \"wrong type argument to abs\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n@@ -2968,6 +3002,7 @@ build_unary_op (code, xarg, noconvert)\n     case TRUTH_NOT_EXPR:\n       if (typecode != INTEGER_TYPE\n \t  && typecode != REAL_TYPE && typecode != POINTER_TYPE\n+\t  && typecode != COMPLEX_TYPE\n \t  /* These will convert to a pointer.  */\n \t  && typecode != ARRAY_TYPE && typecode != FUNCTION_TYPE)\n \t{\n@@ -2979,6 +3014,22 @@ build_unary_op (code, xarg, noconvert)\n \n     case NOP_EXPR:\n       break;\n+\n+    case REALPART_EXPR:\n+      if (TREE_CODE (arg) == COMPLEX_CST)\n+\treturn TREE_REALPART (arg);\n+      else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n+\treturn fold (build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n+      else\n+\treturn arg;\n+\n+    case IMAGPART_EXPR:\n+      if (TREE_CODE (arg) == COMPLEX_CST)\n+\treturn TREE_IMAGPART (arg);\n+      else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n+\treturn fold (build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n+      else\n+\treturn convert (TREE_TYPE (arg), integer_zero_node);\n       \n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n@@ -2991,6 +3042,19 @@ build_unary_op (code, xarg, noconvert)\n       if (val != 0)\n \treturn val;\n \n+      /* Increment or decrement the real part of the value,\n+\t and don't change the imaginary part.  */\n+      if (typecode == COMPLEX_TYPE)\n+\t{\n+\t  tree real, imag;\n+\n+\t  arg = stabilize_reference (arg);\n+\t  real = build_unary_op (REALPART_EXPR, arg, 1);\n+\t  imag = build_unary_op (IMAGPART_EXPR, arg, 1);\n+\t  return build (COMPLEX_EXPR, TREE_TYPE (arg),\n+\t\t\tbuild_unary_op (code, real, 1), imag);\n+\t}\n+\n       /* Report invalid types.  */\n \n       if (typecode != POINTER_TYPE\n@@ -3273,6 +3337,8 @@ lvalue_p (ref)\n \n   switch (code)\n     {\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n     case COMPONENT_REF:\n       return lvalue_p (TREE_OPERAND (ref, 0));\n \n@@ -4057,9 +4123,11 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n       return error_mark_node;\n     }\n   /* Arithmetic types all interconvert, and enum is treated like int.  */\n-  if ((codel == INTEGER_TYPE || codel == REAL_TYPE || codel == ENUMERAL_TYPE)\n+  if ((codel == INTEGER_TYPE || codel == REAL_TYPE || codel == ENUMERAL_TYPE\n+       || codel == COMPLEX_TYPE)\n        &&\n-      (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == ENUMERAL_TYPE))\n+      (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == ENUMERAL_TYPE\n+       || codel == COMPLEX_TYPE))\n     return convert_and_check (type, rhs);\n   /* Conversion to a union from its member types.  */\n   else if (codel == UNION_TYPE)"}]}