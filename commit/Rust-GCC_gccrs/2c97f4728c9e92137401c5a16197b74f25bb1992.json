{"sha": "2c97f4728c9e92137401c5a16197b74f25bb1992", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM5N2Y0NzI4YzllOTIxMzc0MDFjNWExNjE5N2I3NGYyNWJiMTk5Mg==", "commit": {"author": {"name": "Zhenqiang Chen", "email": "zhenqiang.chen@linaro.org", "date": "2014-06-23T02:47:54Z"}, "committer": {"name": "Zhenqiang Chen", "email": "zqchen@gcc.gnu.org", "date": "2014-06-23T02:47:54Z"}, "message": "loop-invariant.c (pre_check_invariant_p): New function.\n\n2014-06-23  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n\n\t* loop-invariant.c (pre_check_invariant_p): New function.\n\t(find_invariant_insn): Call pre_check_invariant_p.\n\nFrom-SVN: r211885", "tree": {"sha": "d52146a9a8d50d107fb3fd1d7fee7e2900245fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d52146a9a8d50d107fb3fd1d7fee7e2900245fdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c97f4728c9e92137401c5a16197b74f25bb1992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c97f4728c9e92137401c5a16197b74f25bb1992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c97f4728c9e92137401c5a16197b74f25bb1992", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c97f4728c9e92137401c5a16197b74f25bb1992/comments", "author": null, "committer": null, "parents": [{"sha": "0001689b2edda047cbc5e6d057d8c1491282243b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0001689b2edda047cbc5e6d057d8c1491282243b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0001689b2edda047cbc5e6d057d8c1491282243b"}], "stats": {"total": 41, "additions": 40, "deletions": 1}, "files": [{"sha": "105f4ac3ac1805c23fa20c81505e497e856a2cec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c97f4728c9e92137401c5a16197b74f25bb1992/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c97f4728c9e92137401c5a16197b74f25bb1992/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c97f4728c9e92137401c5a16197b74f25bb1992", "patch": "@@ -1,3 +1,8 @@\n+2014-06-23  Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n+\n+\t* loop-invariant.c (pre_check_invariant_p): New function.\n+\t(find_invariant_insn): Call pre_check_invariant_p.\n+\n 2014-06-22  Richard Henderson  <rth@redhat.com>\n \n \tPR target/61565"}, {"sha": "25e63e442725dd228d33e72af9cbb923087049d4", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c97f4728c9e92137401c5a16197b74f25bb1992/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c97f4728c9e92137401c5a16197b74f25bb1992/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=2c97f4728c9e92137401c5a16197b74f25bb1992", "patch": "@@ -839,6 +839,39 @@ check_dependencies (rtx insn, bitmap depends_on)\n   return true;\n }\n \n+/* Pre-check candidate DEST to skip the one which can not make a valid insn\n+   during move_invariant_reg.  SIMPLE is to skip HARD_REGISTER.  */\n+static bool\n+pre_check_invariant_p (bool simple, rtx dest)\n+{\n+  if (simple && REG_P (dest) && DF_REG_DEF_COUNT (REGNO (dest)) > 1)\n+    {\n+      df_ref use;\n+      rtx ref;\n+      unsigned int i = REGNO (dest);\n+      struct df_insn_info *insn_info;\n+      df_ref def_rec;\n+\n+      for (use = DF_REG_USE_CHAIN (i); use; use = DF_REF_NEXT_REG (use))\n+\t{\n+\t  ref = DF_REF_INSN (use);\n+\t  insn_info = DF_INSN_INFO_GET (ref);\n+\n+\t  FOR_EACH_INSN_INFO_DEF (def_rec, insn_info)\n+\t    if (DF_REF_REGNO (def_rec) == i)\n+\t      {\n+\t\t/* Multi definitions at this stage, most likely are due to\n+\t\t   instruction constraints, which requires both read and write\n+\t\t   on the same register.  Since move_invariant_reg is not\n+\t\t   powerful enough to handle such cases, just ignore the INV\n+\t\t   and leave the chance to others.  */\n+\t\treturn false;\n+\t      }\n+\t}\n+    }\n+  return true;\n+}\n+\n /* Finds invariant in INSN.  ALWAYS_REACHED is true if the insn is always\n    executed.  ALWAYS_EXECUTED is true if the insn is always executed,\n    unless the program ends due to a function call.  */\n@@ -868,7 +901,8 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n       || HARD_REGISTER_P (dest))\n     simple = false;\n \n-  if (!may_assign_reg_p (SET_DEST (set))\n+  if (!may_assign_reg_p (dest)\n+      || !pre_check_invariant_p (simple, dest)\n       || !check_maybe_invariant (SET_SRC (set)))\n     return;\n "}]}