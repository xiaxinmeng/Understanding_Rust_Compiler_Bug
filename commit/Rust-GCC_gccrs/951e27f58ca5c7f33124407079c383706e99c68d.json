{"sha": "951e27f58ca5c7f33124407079c383706e99c68d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUxZTI3ZjU4Y2E1YzdmMzMxMjQ0MDcwNzljMzgzNzA2ZTk5YzY4ZA==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2019-12-19T02:54:40Z"}, "committer": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-12-19T02:54:40Z"}, "message": "Handle aggregate pass-through for self-recursive call (PR ipa/92794)\n\n2019-12-19  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/92794\n        * ipa-cp.c (self_recursive_agg_pass_through_p): New function.\n        (intersect_with_plats): Use error_mark_node as place holder\n        when aggregate jump function is simple pass-through for\n        self-recursive call.\n        (intersect_with_agg_replacements): Likewise.\n        (intersect_aggregates_with_edge): Likewise.\n        (find_aggregate_values_for_callers_subset): Likewise.\n\n2019-12-19  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/92794\n        * gcc.dg/ipa/92794.c: New test.\n\nFrom-SVN: r279561", "tree": {"sha": "b65a6e0da38ccfd243a0ba0325bae4961c4a4f5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b65a6e0da38ccfd243a0ba0325bae4961c4a4f5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/951e27f58ca5c7f33124407079c383706e99c68d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951e27f58ca5c7f33124407079c383706e99c68d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/951e27f58ca5c7f33124407079c383706e99c68d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951e27f58ca5c7f33124407079c383706e99c68d/comments", "author": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ed6330924d2b7f961bbf68d7e2617c4e9372c4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed6330924d2b7f961bbf68d7e2617c4e9372c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ed6330924d2b7f961bbf68d7e2617c4e9372c4f"}], "stats": {"total": 145, "additions": 129, "deletions": 16}, "files": [{"sha": "e52d05634d34e8d94cbeb1e9cf328a332dff3c2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951e27f58ca5c7f33124407079c383706e99c68d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951e27f58ca5c7f33124407079c383706e99c68d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=951e27f58ca5c7f33124407079c383706e99c68d", "patch": "@@ -1,3 +1,14 @@\n+2019-12-19  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/92794\n+\t* ipa-cp.c (self_recursive_agg_pass_through_p): New function.\n+\t(intersect_with_plats): Use error_mark_node as place holder\n+\twhen aggregate jump function is simple pass-through for\n+\tself-recursive call.\n+\t(intersect_with_agg_replacements): Likewise.\n+\t(intersect_aggregates_with_edge): Likewise.\n+\t(find_aggregate_values_for_callers_subset): Likewise.\n+\n 2019-12-18  David Malcolm  <dmalcolm@redhat.com>\n \n \t* common.opt (fdiagnostics-show-cwe): Add."}, {"sha": "126d154318cc608accc5a2e61a156e02b60891e5", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 83, "deletions": 16, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951e27f58ca5c7f33124407079c383706e99c68d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951e27f58ca5c7f33124407079c383706e99c68d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=951e27f58ca5c7f33124407079c383706e99c68d", "patch": "@@ -4564,6 +4564,25 @@ self_recursive_pass_through_p (cgraph_edge *cs, ipa_jump_func *jfunc, int i)\n   return false;\n }\n \n+/* Return true, if JFUNC, which describes a part of an aggregate represented\n+   or pointed to by the i-th parameter of call CS, is a simple no-operation\n+   pass-through function to itself.  */\n+\n+static bool\n+self_recursive_agg_pass_through_p (cgraph_edge *cs, ipa_agg_jf_item *jfunc,\n+\t\t\t\t   int i)\n+{\n+  enum availability availability;\n+  if (cs->caller == cs->callee->function_symbol (&availability)\n+      && availability > AVAIL_INTERPOSABLE\n+      && jfunc->jftype == IPA_JF_LOAD_AGG\n+      && jfunc->offset == jfunc->value.load_agg.offset\n+      && jfunc->value.pass_through.operation == NOP_EXPR\n+      && jfunc->value.pass_through.formal_id == i)\n+    return true;\n+  return false;\n+}\n+\n /* Given a NODE, and a subset of its CALLERS, try to populate blanks slots in\n    KNOWN_CSTS with constants that are also known for all of the CALLERS.  */\n \n@@ -4756,10 +4775,19 @@ intersect_with_plats (class ipcp_param_lattices *plats,\n \t  if (aglat->offset - offset == item->offset)\n \t    {\n \t      gcc_checking_assert (item->value);\n-\t      if (aglat->is_single_const ()\n-\t\t  && values_equal_for_ipcp_p (item->value,\n-\t\t\t\t\t      aglat->values->value))\n-\t\tfound = true;\n+\t      if (aglat->is_single_const ())\n+\t\t{\n+\t\t  tree value = aglat->values->value;\n+\n+\t\t  if (values_equal_for_ipcp_p (item->value, value))\n+\t\t    found = true;\n+\t\t  else if (item->value == error_mark_node)\n+\t\t    {\n+\t\t      /* Replace unknown place holder value with real one.  */\n+\t\t      item->value = value;\n+\t\t      found = true;\n+\t\t    }\n+\t\t}\n \t      break;\n \t    }\n \t  aglat = aglat->next;\n@@ -4827,6 +4855,12 @@ intersect_with_agg_replacements (struct cgraph_node *node, int index,\n \t    {\n \t      if (values_equal_for_ipcp_p (item->value, av->value))\n \t\tfound = true;\n+\t      else if (item->value == error_mark_node)\n+\t\t{\n+\t\t  /* Replace place holder value with real one.  */\n+\t\t  item->value = av->value;\n+\t\t  found = true;\n+\t\t}\n \t      break;\n \t    }\n \t}\n@@ -4931,17 +4965,31 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \tfor (unsigned i = 0; i < jfunc->agg.items->length (); i++)\n \t  {\n \t    struct ipa_agg_jf_item *agg_item = &(*jfunc->agg.items)[i];\n-\t    tree value = ipa_agg_value_from_node (caller_info, cs->caller,\n-\t\t\t\t\t\t  agg_item);\n-\t    if (value)\n+\t    struct ipa_agg_value agg_value;\n+\n+\t    if (self_recursive_agg_pass_through_p (cs, agg_item, index))\n \t      {\n-\t\tstruct ipa_agg_value agg_value;\n+\t\t/* For a self-recursive call, if aggregate jump function is a\n+\t\t   simple pass-through, the exact value that it stands for is\n+\t\t   not known at this point, which must comes from other call\n+\t\t   sites.  But we still need to add a place holder in value\n+\t\t   sets to indicate it, here we use error_mark_node to\n+\t\t   represent the special unknown value, which will be replaced\n+\t\t   with real one during later intersecting operations.  */\n+\t\tagg_value.value = error_mark_node;\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree value = ipa_agg_value_from_node (caller_info, cs->caller,\n+\t\t\t\t\t\t      agg_item);\n+\t\tif (!value)\n+\t\t  continue;\n \n-\t\tagg_value.offset = agg_item->offset;\n \t\tagg_value.value = value;\n-\n-\t\tinter.safe_push (agg_value);\n \t      }\n+\n+\t    agg_value.offset = agg_item->offset;\n+\t    inter.safe_push (agg_value);\n \t  }\n       else\n \tFOR_EACH_VEC_ELT (inter, k, item)\n@@ -4960,11 +5008,27 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \t\t  break;\n \t\tif (ti->offset == item->offset)\n \t\t  {\n-\t\t    tree value = ipa_agg_value_from_node (caller_info,\n-\t\t\t\t\t\t\t  cs->caller, ti);\n-\t\t    if (value\n-\t\t\t&& values_equal_for_ipcp_p (item->value, value))\n-\t\t      found = true;\n+\t\t    tree value;\n+\n+\t\t    if (self_recursive_agg_pass_through_p (cs, ti, index))\n+\t\t      {\n+\t\t\t/* A simple aggregate pass-through in self-recursive\n+\t\t\t   call should lead to same value.  */\n+\t\t\tfound = true;\n+\t\t      }\n+\t\t    else if ((value = ipa_agg_value_from_node (caller_info,\n+\t\t\t\t\t\t\t     cs->caller, ti)))\n+\t\t      {\n+\t\t\tif (values_equal_for_ipcp_p (item->value, value))\n+\t\t\t  found = true;\n+\t\t\telse if (item->value == error_mark_node)\n+\t\t\t  {\n+\t\t\t    /* Replace unknown place holder value with real\n+\t\t\t       one.  */\n+\t\t\t    item->value = value;\n+\t\t\t    found = true;\n+\t\t\t  }\n+\t\t      }\n \t\t    break;\n \t\t  }\n \t\tl++;\n@@ -5040,6 +5104,9 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n \t  if (!item->value)\n \t    continue;\n \n+\t  /* All values must be real values, not unknown place holders.  */\n+\t  gcc_assert (item->value != error_mark_node);\n+\n \t  v = ggc_alloc<ipa_agg_replacement_value> ();\n \t  v->index = i;\n \t  v->offset = item->offset;"}, {"sha": "e66980e07679b4da26375d586a578849c97a759d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951e27f58ca5c7f33124407079c383706e99c68d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951e27f58ca5c7f33124407079c383706e99c68d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=951e27f58ca5c7f33124407079c383706e99c68d", "patch": "@@ -1,3 +1,8 @@\n+2019-12-19  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/92794\n+\t* gcc.dg/ipa/92794.c: New test.\n+\n 2019-12-18  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/plugin/diagnostic-test-metadata.c: New test."}, {"sha": "c3546177ccd2bce574fec61d24a32feee1133f97", "filename": "gcc/testsuite/gcc.dg/ipa/pr92794.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951e27f58ca5c7f33124407079c383706e99c68d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr92794.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951e27f58ca5c7f33124407079c383706e99c68d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr92794.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr92794.c?ref=951e27f58ca5c7f33124407079c383706e99c68d", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 --param ipa-cp-eval-threshold=1\" } */\n+\n+int data[100];\n+int depth = 0;\n+\n+int recur_fn (int *__restrict p)\n+{\n+  int i = *p;\n+\n+  if (depth++ > 6) \n+    return 10;\n+\n+  data[i] = i; \n+\n+  recur_fn (&i);\n+\n+  depth--;\n+\n+  return i;\n+}\n+\n+int main ()\n+{\n+  int i = 1;\n+\n+  recur_fn (&i);\n+\n+  return 0;\n+}"}]}