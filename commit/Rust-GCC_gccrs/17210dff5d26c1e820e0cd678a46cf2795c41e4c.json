{"sha": "17210dff5d26c1e820e0cd678a46cf2795c41e4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcyMTBkZmY1ZDI2YzFlODIwZTBjZDY3OGE0NmNmMjc5NWM0MWU0Yw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-10-11T18:45:43Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-10-11T18:45:43Z"}, "message": "re PR libgcj/14856 (Update bundled zlib)\n\n\tPR libgcj/14856:\n\t* Imported zlib 1.2.1; merged local changes.\n\nFrom-SVN: r88898", "tree": {"sha": "01e6e6bb5683a568f3e4d7be40728b9b503640c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01e6e6bb5683a568f3e4d7be40728b9b503640c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17210dff5d26c1e820e0cd678a46cf2795c41e4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17210dff5d26c1e820e0cd678a46cf2795c41e4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17210dff5d26c1e820e0cd678a46cf2795c41e4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17210dff5d26c1e820e0cd678a46cf2795c41e4c/comments", "author": null, "committer": null, "parents": [{"sha": "1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}], "stats": {"total": 19288, "additions": 7817, "deletions": 11471}, "files": [{"sha": "fe07df582b68ac7972dbdbdf3973c43a62b5e27e", "filename": "zlib/ChangeLog", "status": "modified", "additions": 248, "deletions": 7, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FChangeLog?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,5 +1,246 @@\n \n-\t\tChangeLog file for zlib\n+                ChangeLog file for zlib\n+\n+Changes in 1.2.1 (17 November 2003)\n+- Remove a tab in contrib/gzappend/gzappend.c\n+- Update some interfaces in contrib for new zlib functions\n+- Update zlib version number in some contrib entries\n+- Add Windows CE definition for ptrdiff_t in zutil.h [Mai, Truta]\n+- Support shared libraries on Hurd and KFreeBSD [Brown]\n+- Fix error in NO_DIVIDE option of adler32.c\n+\n+Changes in 1.2.0.8 (4 November 2003)\n+- Update version in contrib/delphi/ZLib.pas and contrib/pascal/zlibpas.pas\n+- Add experimental NO_DIVIDE #define in adler32.c\n+    - Possibly faster on some processors (let me know if it is)\n+- Correct Z_BLOCK to not return on first inflate call if no wrap\n+- Fix strm->data_type on inflate() return to correctly indicate EOB\n+- Add deflatePrime() function for appending in the middle of a byte\n+- Add contrib/gzappend for an example of appending to a stream\n+- Update win32/DLL_FAQ.txt [Truta]\n+- Delete Turbo C comment in README [Truta]\n+- Improve some indentation in zconf.h [Truta]\n+- Fix infinite loop on bad input in configure script [Church]\n+- Fix gzeof() for concatenated gzip files [Johnson]\n+- Add example to contrib/visual-basic.txt [Michael B.]\n+- Add -p to mkdir's in Makefile.in [vda]\n+- Fix configure to properly detect presence or lack of printf functions\n+- Add AS400 support [Monnerat]\n+- Add a little Cygwin support [Wilson]\n+\n+Changes in 1.2.0.7 (21 September 2003)\n+- Correct some debug formats in contrib/infback9\n+- Cast a type in a debug statement in trees.c\n+- Change search and replace delimiter in configure from % to # [Beebe]\n+- Update contrib/untgz to 0.2 with various fixes [Truta]\n+- Add build support for Amiga [Nikl]\n+- Remove some directories in old that have been updated to 1.2\n+- Add dylib building for Mac OS X in configure and Makefile.in\n+- Remove old distribution stuff from Makefile\n+- Update README to point to DLL_FAQ.txt, and add comment on Mac OS X\n+- Update links in README\n+\n+Changes in 1.2.0.6 (13 September 2003)\n+- Minor FAQ updates\n+- Update contrib/minizip to 1.00 [Vollant]\n+- Remove test of gz functions in example.c when GZ_COMPRESS defined [Truta]\n+- Update POSTINC comment for 68060 [Nikl]\n+- Add contrib/infback9 with deflate64 decoding (unsupported)\n+- For MVS define NO_vsnprintf and undefine FAR [van Burik]\n+- Add pragma for fdopen on MVS [van Burik]\n+\n+Changes in 1.2.0.5 (8 September 2003)\n+- Add OF to inflateBackEnd() declaration in zlib.h\n+- Remember start when using gzdopen in the middle of a file\n+- Use internal off_t counters in gz* functions to properly handle seeks\n+- Perform more rigorous check for distance-too-far in inffast.c\n+- Add Z_BLOCK flush option to return from inflate at block boundary\n+- Set strm->data_type on return from inflate\n+    - Indicate bits unused, if at block boundary, and if in last block\n+- Replace size_t with ptrdiff_t in crc32.c, and check for correct size\n+- Add condition so old NO_DEFLATE define still works for compatibility\n+- FAQ update regarding the Windows DLL [Truta]\n+- INDEX update: add qnx entry, remove aix entry [Truta]\n+- Install zlib.3 into mandir [Wilson]\n+- Move contrib/zlib_dll_FAQ.txt to win32/DLL_FAQ.txt; update [Truta]\n+- Adapt the zlib interface to the new DLL convention guidelines [Truta]\n+- Introduce ZLIB_WINAPI macro to allow the export of functions using\n+  the WINAPI calling convention, for Visual Basic [Vollant, Truta]\n+- Update msdos and win32 scripts and makefiles [Truta]\n+- Export symbols by name, not by ordinal, in win32/zlib.def [Truta]\n+- Add contrib/ada [Anisimkov]\n+- Move asm files from contrib/vstudio/vc70_32 to contrib/asm386 [Truta]\n+- Rename contrib/asm386 to contrib/masmx86 [Truta, Vollant]\n+- Add contrib/masm686 [Truta]\n+- Fix offsets in contrib/inflate86 and contrib/masmx86/inffas32.asm\n+  [Truta, Vollant]\n+- Update contrib/delphi; rename to contrib/pascal; add example [Truta]\n+- Remove contrib/delphi2; add a new contrib/delphi [Truta]\n+- Avoid inclusion of the nonstandard <memory.h> in contrib/iostream,\n+  and fix some method prototypes [Truta]\n+- Fix the ZCR_SEED2 constant to avoid warnings in contrib/minizip\n+  [Truta]\n+- Avoid the use of backslash (\\) in contrib/minizip [Vollant]\n+- Fix file time handling in contrib/untgz; update makefiles [Truta]\n+- Update contrib/vstudio/vc70_32 to comply with the new DLL guidelines\n+  [Vollant]\n+- Remove contrib/vstudio/vc15_16 [Vollant]\n+- Rename contrib/vstudio/vc70_32 to contrib/vstudio/vc7 [Truta]\n+- Update README.contrib [Truta]\n+- Invert the assignment order of match_head and s->prev[...] in\n+  INSERT_STRING [Truta]\n+- Compare TOO_FAR with 32767 instead of 32768, to avoid 16-bit warnings\n+  [Truta]\n+- Compare function pointers with 0, not with NULL or Z_NULL [Truta]\n+- Fix prototype of syncsearch in inflate.c [Truta]\n+- Introduce ASMINF macro to be enabled when using an ASM implementation\n+  of inflate_fast [Truta]\n+- Change NO_DEFLATE to NO_GZCOMPRESS [Truta]\n+- Modify test_gzio in example.c to take a single file name as a\n+  parameter [Truta]\n+- Exit the example.c program if gzopen fails [Truta]\n+- Add type casts around strlen in example.c [Truta]\n+- Remove casting to sizeof in minigzip.c; give a proper type\n+  to the variable compared with SUFFIX_LEN [Truta]\n+- Update definitions of STDC and STDC99 in zconf.h [Truta]\n+- Synchronize zconf.h with the new Windows DLL interface [Truta]\n+- Use SYS16BIT instead of __32BIT__ to distinguish between\n+  16- and 32-bit platforms [Truta]\n+- Use far memory allocators in small 16-bit memory models for\n+  Turbo C [Truta]\n+- Add info about the use of ASMV, ASMINF and ZLIB_WINAPI in\n+  zlibCompileFlags [Truta]\n+- Cygwin has vsnprintf [Wilson]\n+- In Windows16, OS_CODE is 0, as in MSDOS [Truta]\n+- In Cygwin, OS_CODE is 3 (Unix), not 11 (Windows32) [Wilson]\n+\n+Changes in 1.2.0.4 (10 August 2003)\n+- Minor FAQ updates\n+- Be more strict when checking inflateInit2's windowBits parameter\n+- Change NO_GUNZIP compile option to NO_GZIP to cover deflate as well\n+- Add gzip wrapper option to deflateInit2 using windowBits\n+- Add updated QNX rule in configure and qnx directory [Bonnefoy]\n+- Make inflate distance-too-far checks more rigorous\n+- Clean up FAR usage in inflate\n+- Add casting to sizeof() in gzio.c and minigzip.c\n+\n+Changes in 1.2.0.3 (19 July 2003)\n+- Fix silly error in gzungetc() implementation [Vollant]\n+- Update contrib/minizip and contrib/vstudio [Vollant]\n+- Fix printf format in example.c\n+- Correct cdecl support in zconf.in.h [Anisimkov]\n+- Minor FAQ updates\n+\n+Changes in 1.2.0.2 (13 July 2003)\n+- Add ZLIB_VERNUM in zlib.h for numerical preprocessor comparisons\n+- Attempt to avoid warnings in crc32.c for pointer-int conversion\n+- Add AIX to configure, remove aix directory [Bakker]\n+- Add some casts to minigzip.c\n+- Improve checking after insecure sprintf() or vsprintf() calls\n+- Remove #elif's from crc32.c\n+- Change leave label to inf_leave in inflate.c and infback.c to avoid\n+  library conflicts\n+- Remove inflate gzip decoding by default--only enable gzip decoding by\n+  special request for stricter backward compatibility\n+- Add zlibCompileFlags() function to return compilation information\n+- More typecasting in deflate.c to avoid warnings\n+- Remove leading underscore from _Capital #defines [Truta]\n+- Fix configure to link shared library when testing\n+- Add some Windows CE target adjustments [Mai]\n+- Remove #define ZLIB_DLL in zconf.h [Vollant]\n+- Add zlib.3 [Rodgers]\n+- Update RFC URL in deflate.c and algorithm.txt [Mai]\n+- Add zlib_dll_FAQ.txt to contrib [Truta]\n+- Add UL to some constants [Truta]\n+- Update minizip and vstudio [Vollant]\n+- Remove vestigial NEED_DUMMY_RETURN from zconf.in.h\n+- Expand use of NO_DUMMY_DECL to avoid all dummy structures\n+- Added iostream3 to contrib [Schwardt]\n+- Replace rewind() with fseek() for WinCE [Truta]\n+- Improve setting of zlib format compression level flags\n+    - Report 0 for huffman and rle strategies and for level == 0 or 1\n+    - Report 2 only for level == 6\n+- Only deal with 64K limit when necessary at compile time [Truta]\n+- Allow TOO_FAR check to be turned off at compile time [Truta]\n+- Add gzclearerr() function [Souza]\n+- Add gzungetc() function\n+\n+Changes in 1.2.0.1 (17 March 2003)\n+- Add Z_RLE strategy for run-length encoding [Truta]\n+    - When Z_RLE requested, restrict matches to distance one\n+    - Update zlib.h, minigzip.c, gzopen(), gzdopen() for Z_RLE\n+- Correct FASTEST compilation to allow level == 0\n+- Clean up what gets compiled for FASTEST\n+- Incorporate changes to zconf.in.h [Vollant]\n+    - Refine detection of Turbo C need for dummy returns\n+    - Refine ZLIB_DLL compilation\n+    - Include additional header file on VMS for off_t typedef\n+- Try to use _vsnprintf where it supplants vsprintf [Vollant]\n+- Add some casts in inffast.c\n+- Enchance comments in zlib.h on what happens if gzprintf() tries to\n+  write more than 4095 bytes before compression\n+- Remove unused state from inflateBackEnd()\n+- Remove exit(0) from minigzip.c, example.c\n+- Get rid of all those darn tabs\n+- Add \"check\" target to Makefile.in that does the same thing as \"test\"\n+- Add \"mostlyclean\" and \"maintainer-clean\" targets to Makefile.in\n+- Update contrib/inflate86 [Anderson]\n+- Update contrib/testzlib, contrib/vstudio, contrib/minizip [Vollant]\n+- Add msdos and win32 directories with makefiles [Truta]\n+- More additions and improvements to the FAQ\n+\n+Changes in 1.2.0 (9 March 2003)\n+- New and improved inflate code\n+    - About 20% faster\n+    - Does not allocate 32K window unless and until needed\n+    - Automatically detects and decompresses gzip streams\n+    - Raw inflate no longer needs an extra dummy byte at end\n+    - Added inflateBack functions using a callback interface--even faster\n+      than inflate, useful for file utilities (gzip, zip)\n+    - Added inflateCopy() function to record state for random access on\n+      externally generated deflate streams (e.g. in gzip files)\n+    - More readable code (I hope)\n+- New and improved crc32()\n+    - About 50% faster, thanks to suggestions from Rodney Brown\n+- Add deflateBound() and compressBound() functions\n+- Fix memory leak in deflateInit2()\n+- Permit setting dictionary for raw deflate (for parallel deflate)\n+- Fix const declaration for gzwrite()\n+- Check for some malloc() failures in gzio.c\n+- Fix bug in gzopen() on single-byte file 0x1f\n+- Fix bug in gzread() on concatenated file with 0x1f at end of buffer\n+  and next buffer doesn't start with 0x8b\n+- Fix uncompress() to return Z_DATA_ERROR on truncated input\n+- Free memory at end of example.c\n+- Remove MAX #define in trees.c (conflicted with some libraries)\n+- Fix static const's in deflate.c, gzio.c, and zutil.[ch]\n+- Declare malloc() and free() in gzio.c if STDC not defined\n+- Use malloc() instead of calloc() in zutil.c if int big enough\n+- Define STDC for AIX\n+- Add aix/ with approach for compiling shared library on AIX\n+- Add HP-UX support for shared libraries in configure\n+- Add OpenUNIX support for shared libraries in configure\n+- Use $cc instead of gcc to build shared library\n+- Make prefix directory if needed when installing\n+- Correct Macintosh avoidance of typedef Byte in zconf.h\n+- Correct Turbo C memory allocation when under Linux\n+- Use libz.a instead of -lz in Makefile (assure use of compiled library)\n+- Update configure to check for snprintf or vsnprintf functions and their\n+  return value, warn during make if using an insecure function\n+- Fix configure problem with compile-time knowledge of HAVE_UNISTD_H that\n+  is lost when library is used--resolution is to build new zconf.h\n+- Documentation improvements (in zlib.h):\n+    - Document raw deflate and inflate\n+    - Update RFCs URL\n+    - Point out that zlib and gzip formats are different\n+    - Note that Z_BUF_ERROR is not fatal\n+    - Document string limit for gzprintf() and possible buffer overflow\n+    - Note requirement on avail_out when flushing\n+    - Note permitted values of flush parameter of inflate()\n+- Add some FAQs (and even answers) to the FAQ\n+- Add contrib/inflate86/ for x86 faster inflate\n+- Add contrib/blast/ for PKWare Data Compression Library decompression\n+- Add contrib/puff/ simple inflate for deflate format description\n \n Changes in 1.1.4 (11 March 2002)\n - ZFREE was repeated on same allocation on some error conditions.\n@@ -10,7 +251,7 @@ Changes in 1.1.4 (11 March 2002)\n   less than 32K.\n - force windowBits > 8 to avoid a bug in the encoder for a window size\n   of 256 bytes. (A complete fix will be available in 1.1.5).\n-\t\n+\n Changes in 1.1.3 (9 July 1998)\n - fix \"an inflate input buffer bug that shows up on rare but persistent\n   occasions\" (Mark)\n@@ -184,13 +425,13 @@ Changes in 1.0.6 (19 Jan 1998)\n - added Makefile.nt (thanks to Stephen Williams)\n - added the unsupported \"contrib\" directory:\n    contrib/asm386/ by Gilles Vollant <info@winimage.com>\n-\t386 asm code replacing longest_match().\n+        386 asm code replacing longest_match().\n    contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>\n         A C++ I/O streams interface to the zlib gz* functions\n    contrib/iostream2/  by Tyge L\ufffdvset <Tyge.Lovset@cmr.no>\n-\tAnother C++ I/O streams interface\n+        Another C++ I/O streams interface\n    contrib/untgz/  by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n-\tA very simple tar.gz file extractor using zlib\n+        A very simple tar.gz file extractor using zlib\n    contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>\n         How to use compress(), uncompress() and the gz* functions from VB.\n - pass params -f (filtered data), -h (huffman only), -1 to -9 (compression\n@@ -217,7 +458,7 @@ Changes in 1.0.6 (19 Jan 1998)\n - add NEED_DUMMY_RETURN for Borland\n - use variable z_verbose for tracing in debug mode (L. Peter Deutsch).\n - allow compilation with CC\n-- defined STDC for OS/2 (David Charlap)\t\n+- defined STDC for OS/2 (David Charlap)\n - limit external names to 8 chars for MVS (Thomas Lund)\n - in minigzip.c, use static buffers only for 16-bit systems\n - fix suffix check for \"minigzip -d foo.gz\"\n@@ -242,7 +483,7 @@ Changes in 1.0.5 (3 Jan 98)\n - Eliminate memory leaks on error conditions in inflate\n - Removed some vestigial code in inflate\n - Update web address in README\n-  \n+\n Changes in 1.0.4 (24 Jul 96)\n - In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF\n   bit, so the decompressor could decompress all the correct data but went"}, {"sha": "7115ec38d60179bdbc040ec349e92679bd3b5ba2", "filename": "zlib/FAQ", "status": "modified", "additions": 231, "deletions": 16, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FFAQ", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FFAQ", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FFAQ?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,8 +1,8 @@\n \n-\t\tFrequently Asked Questions about zlib\n+                Frequently Asked Questions about zlib\n \n \n-If your question is not there, please check the zlib home page \n+If your question is not there, please check the zlib home page\n http://www.zlib.org which may have more recent information.\n The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n \n@@ -13,14 +13,15 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n \n  2. Where can I get a Windows DLL version?\n \n-    The zlib sources can be compiled without change to produce a DLL. If you\n-    want a precompiled DLL, see http://www.winimage.com/zLibDll/ . Questions\n-    about the zlib DLL should be sent to Gilles Vollant (info@winimage.com).\n+    The zlib sources can be compiled without change to produce a DLL.\n+    See the file win32/DLL_FAQ.txt in the zlib distribution.\n+    Pointers to the precompiled DLL are found in the zlib web site at\n+    http://www.zlib.org.\n \n  3. Where can I get a Visual Basic interface to zlib?\n \n     See\n-        * http://www.winimage.com/zLibDll/cmp-z-it.zip\n+        * http://www.winimage.com/zLibDll/\n         * http://www.dogma.net/markn/articles/zlibtool/zlibtool.htm\n         * contrib/visual-basic.txt in the zlib distribution\n \n@@ -36,6 +37,11 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n     Before making the call, make sure that avail_in and avail_out are not\n     zero. When setting the parameter flush equal to Z_FINISH, also make sure\n     that avail_out is big enough to allow processing all pending input.\n+    Note that a Z_BUF_ERROR is not fatal--another call to deflate() or\n+    inflate() can be made with more input or output space. A Z_BUF_ERROR\n+    may in fact be unavoidable depending on how the functions are used, since\n+    it is not possible to tell whether or not there is more output pending\n+    when strm.avail_out returns with zero.\n \n  6. Where's the zlib documentation (man pages, etc.)?\n \n@@ -61,14 +67,13 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n     If \"make test\" produces something like\n \n        example.o(.text+0x154): undefined reference to `gzputc'\n-      \n+\n     check that you don't have old files libz.* in /usr/lib, /usr/local/lib or\n     /usr/X11R6/lib. Remove any old versions, then do \"make install\".\n \n 10. I need a Delphi interface to zlib.\n \n-    See the directories contrib/delphi and contrib/delphi2 in the zlib\n-    distribution.\n+    See the contrib/delphi directory in the zlib distribution.\n \n 11. Can zlib handle .zip archives?\n \n@@ -85,16 +90,226 @@ The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html\n     ./configure -s\n     make\n \n-14. Why does \"make test\" fail on Mac OS X?\n+14. How do I install a shared zlib library on Unix?\n+\n+    make install\n \n-    Mac OS X already includes zlib as a shared library, and so -lz links the\n-    shared library instead of the one that the \"make\" compiled. For zlib\n-    1.1.3, the two are incompatible due to different compile-time\n-    options. Simply change the -lz in the Makefile to libz.a, and it will use\n-    the compiled library instead of the shared one and the \"make test\" will\n-    succeed.\n+    However, many flavors of Unix come with a shared zlib already installed.\n+    Before going to the trouble of compiling a shared version of zlib and\n+    trying to install it, you may want to check if it's already there! If you\n+    can #include <zlib.h>, it's there. The -lz option will probably link to it.\n \n 15. I have a question about OttoPDF\n \n     We are not the authors of OttoPDF. The real author is on the OttoPDF web\n     site Joel Hainley jhainley@myndkryme.com.\n+\n+16. Why does gzip give an error on a file I make with compress/deflate?\n+\n+    The compress and deflate functions produce data in the zlib format, which\n+    is different and incompatible with the gzip format. The gz* functions in\n+    zlib on the other hand use the gzip format. Both the zlib and gzip\n+    formats use the same compressed data format internally, but have different\n+    headers and trailers around the compressed data.\n+\n+17. Ok, so why are there two different formats?\n+\n+    The gzip format was designed to retain the directory information about\n+    a single file, such as the name and last modification date. The zlib\n+    format on the other hand was designed for in-memory and communication\n+    channel applications, and has a much more compact header and trailer and\n+    uses a faster integrity check than gzip.\n+\n+18. Well that's nice, but how do I make a gzip file in memory?\n+\n+    You can request that deflate write the gzip format instead of the zlib\n+    format using deflateInit2(). You can also request that inflate decode\n+    the gzip format using inflateInit2(). Read zlib.h for more details.\n+\n+    Note that you cannot specify special gzip header contents (e.g. a file\n+    name or modification date), nor will inflate tell you what was in the\n+    gzip header. If you need to customize the header or see what's in it,\n+    you can use the raw deflate and inflate operations and the crc32()\n+    function and roll your own gzip encoding and decoding. Read the gzip\n+    RFC 1952 for details of the header and trailer format.\n+\n+19. Is zlib thread-safe?\n+\n+    Yes. However any library routines that zlib uses and any application-\n+    provided memory allocation routines must also be thread-safe. zlib's gz*\n+    functions use stdio library routines, and most of zlib's functions use the\n+    library memory allocation routines by default. zlib's Init functions allow\n+    for the application to provide custom memory allocation routines.\n+\n+    Of course, you should only operate on any given zlib or gzip stream from a\n+    single thread at a time.\n+\n+20. Can I use zlib in my commercial application?\n+\n+    Yes. Please read the license in zlib.h.\n+\n+21. Is zlib under the GNU license?\n+\n+    No. Please read the license in zlib.h.\n+\n+22. The license says that altered source versions must be \"plainly marked\". So\n+    what exactly do I need to do to meet that requirement?\n+\n+    You need to change the ZLIB_VERSION and ZLIB_VERNUM #defines in zlib.h. In\n+    particular, the final version number needs to be changed to \"f\", and an\n+    identification string should be appended to ZLIB_VERSION. Version numbers\n+    x.x.x.f are reserved for modifications to zlib by others than the zlib\n+    maintainers. For example, if the version of the base zlib you are altering\n+    is \"1.2.3.4\", then in zlib.h you should change ZLIB_VERNUM to 0x123f, and\n+    ZLIB_VERSION to something like \"1.2.3.f-zachary-mods-v3\". You can also\n+    update the version strings in deflate.c and inftrees.c.\n+\n+    For altered source distributions, you should also note the origin and\n+    nature of the changes in zlib.h, as well as in ChangeLog and README, along\n+    with the dates of the alterations. The origin should include at least your\n+    name (or your company's name), and an email address to contact for help or\n+    issues with the library.\n+\n+    Note that distributing a compiled zlib library along with zlib.h and\n+    zconf.h is also a source distribution, and so you should change\n+    ZLIB_VERSION and ZLIB_VERNUM and note the origin and nature of the changes\n+    in zlib.h as you would for a full source distribution.\n+\n+23. Will zlib work on a big-endian or little-endian architecture, and can I\n+    exchange compressed data between them?\n+\n+    Yes and yes.\n+\n+24. Will zlib work on a 64-bit machine?\n+\n+    It should. It has been tested on 64-bit machines, and has no dependence\n+    on any data types being limited to 32-bits in length. If you have any\n+    difficulties, please provide a complete problem report to zlib@gzip.org\n+\n+25. Will zlib decompress data from the PKWare Data Compression Library?\n+\n+    No. The PKWare DCL uses a completely different compressed data format\n+    than does PKZIP and zlib. However, you can look in zlib's contrib/blast\n+    directory for a possible solution to your problem.\n+\n+26. Can I access data randomly in a compressed stream?\n+\n+    No, not without some preparation. If when compressing you periodically\n+    use Z_FULL_FLUSH, carefully write all the pending data at those points,\n+    and keep an index of those locations, then you can start decompression\n+    at those points. You have to be careful to not use Z_FULL_FLUSH too\n+    often, since it can significantly degrade compression.\n+\n+27. Does zlib work on MVS, OS/390, CICS, etc.?\n+\n+    We don't know for sure. We have heard occasional reports of success on\n+    these systems. If you do use it on one of these, please provide us with\n+    a report, instructions, and patches that we can reference when we get\n+    these questions. Thanks.\n+\n+28. Is there some simpler, easier to read version of inflate I can look at\n+    to understand the deflate format?\n+\n+    First off, you should read RFC 1951. Second, yes. Look in zlib's\n+    contrib/puff directory.\n+\n+29. Does zlib infringe on any patents?\n+\n+    As far as we know, no. In fact, that was originally the whole point behind\n+    zlib. Look here for some more information:\n+\n+    http://www.gzip.org/#faq11\n+\n+30. Can zlib work with greater than 4 GB of data?\n+\n+    Yes. inflate() and deflate() will process any amount of data correctly.\n+    Each call of inflate() or deflate() is limited to input and output chunks\n+    of the maximum value that can be stored in the compiler's \"unsigned int\"\n+    type, but there is no limit to the number of chunks. Note however that the\n+    strm.total_in and strm_total_out counters may be limited to 4 GB. These\n+    counters are provided as a convenience and are not used internally by\n+    inflate() or deflate(). The application can easily set up its own counters\n+    updated after each call of inflate() or deflate() to count beyond 4 GB.\n+    compress() and uncompress() may be limited to 4 GB, since they operate in a\n+    single call. gzseek() and gztell() may be limited to 4 GB depending on how\n+    zlib is compiled. See the zlibCompileFlags() function in zlib.h.\n+\n+    The word \"may\" appears several times above since there is a 4 GB limit\n+    only if the compiler's \"long\" type is 32 bits. If the compiler's \"long\"\n+    type is 64 bits, then the limit is 16 exabytes.\n+\n+31. Does zlib have any security vulnerabilities?\n+\n+    The only one that we are aware of is potentially in gzprintf(). If zlib\n+    is compiled to use sprintf() or vsprintf(), then there is no protection\n+    against a buffer overflow of a 4K string space, other than the caller of\n+    gzprintf() assuring that the output will not exceed 4K. On the other\n+    hand, if zlib is compiled to use snprintf() or vsnprintf(), which should\n+    normally be the case, then there is no vulnerability. The ./configure\n+    script will display warnings if an insecure variation of sprintf() will\n+    be used by gzprintf(). Also the zlibCompileFlags() function will return\n+    information on what variant of sprintf() is used by gzprintf().\n+\n+    If you don't have snprintf() or vsnprintf() and would like one, you can\n+    find a portable implementation here:\n+\n+        http://www.ijs.si/software/snprintf/\n+\n+    Note that you should be using the most recent version of zlib. Versions\n+    1.1.3 and before were subject to a double-free vulnerability.\n+\n+32. Is there a Java version of zlib?\n+\n+    Probably what you want is to use zlib in Java. zlib is already included\n+    as part of the Java SDK in the java.util.zip package. If you really want\n+    a version of zlib written in the Java language, look on the zlib home\n+    page for links: http://www.zlib.org/\n+\n+33. I get this or that compiler or source-code scanner warning when I crank it\n+    up to maximally-pendantic. Can't you guys write proper code?\n+\n+    Many years ago, we gave up attempting to avoid warnings on every compiler\n+    in the universe. It just got to be a waste of time, and some compilers\n+    were downright silly. So now, we simply make sure that the code always\n+    works.\n+\n+34. Will zlib read the (insert any ancient or arcane format here) compressed\n+    data format?\n+\n+    Probably not. Look in the comp.compression FAQ for pointers to various\n+    formats and associated software.\n+\n+35. How can I encrypt/decrypt zip files with zlib?\n+\n+    zlib doesn't support encryption. The original PKZIP encryption is very weak\n+    and can be broken with freely available programs. To get strong encryption,\n+    use gpg ( http://www.gnupg.org/ ) which already includes zlib compression.\n+    For PKZIP compatible \"encryption\", look at http://www.info-zip.org/\n+\n+36. What's the difference between the \"gzip\" and \"deflate\" HTTP 1.1 encodings?\n+\n+    \"gzip\" is the gzip format, and \"deflate\" is the zlib format. They should\n+    probably have called the second one \"zlib\" instead to avoid confusion\n+    with the raw deflate compressed data format. While the HTTP 1.1 RFC 2616\n+    correctly points to the zlib specification in RFC 1950 for the \"deflate\"\n+    transfer encoding, there have been reports of servers and browsers that\n+    incorrectly produce or expect raw deflate data per the deflate\n+    specficiation in RFC 1951, most notably Microsoft. So even though the\n+    \"deflate\" transfer encoding using the zlib format would be the more\n+    efficient approach (and in fact exactly what the zlib format was designed\n+    for), using the \"gzip\" transfer encoding is probably more reliable due to\n+    an unfortunate choice of name on the part of the HTTP 1.1 authors.\n+\n+    Bottom line: use the gzip format for HTTP 1.1 encoding.\n+\n+37. Does zlib support the new \"Deflate64\" format introduced by PKWare?\n+\n+    No. PKWare has apparently decided to keep that format proprietary, since\n+    they have not documented it as they have previous compression formats.\n+    In any case, the compression improvements are so modest compared to other\n+    more modern approaches, that it's not worth the effort to implement.\n+\n+38. Can you please sign these lengthy legal documents and fax them back to us\n+    so that we can use your software in our product?\n+\n+    No. Go away. Shoo."}, {"sha": "a9de7844d166388625fa8b16722f1a00f9945830", "filename": "zlib/INDEX", "status": "modified", "additions": 26, "deletions": 64, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FINDEX", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FINDEX", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FINDEX?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,86 +1,48 @@\n-ChangeLog\t\thistory of changes\n-INDEX\t\t\tthis file\n-FAQ\t\t\tFrequently Asked Questions about zlib\n-Make_vms.com\t\tscript for Vax/VMS\n-Makefile\t\tmakefile for Unix (generated by configure)\n-Makefile.in\t\tmakefile for Unix (template for configure)\n-Makefile.riscos \tmakefile for RISCOS\n-README\t\t\tguess what\n-algorithm.txt\t\tdescription of the (de)compression algorithm\n-configure\t\tconfigure script for Unix\n-descrip.mms\t\tmakefile for Vax/VMS\n-zlib.3\t\t\tmini man page for zlib (volunteers to write full\n-\t\t\tman pages from zlib.h welcome. write to jloup@gzip.org)\n-\n-amiga/Makefile.sas\tmakefile for Amiga SAS/C\n-amiga/Makefile.pup      makefile for Amiga powerUP SAS/C PPC\n-\n-msdos/Makefile.w32      makefile for Microsoft Visual C++ 32-bit\n-msdos/Makefile.b32\tmakefile for Borland C++   32-bit\n-msdos/Makefile.bor\tmakefile for Borland C/C++ 16-bit\n-msdos/Makefile.dj2\tmakefile for DJGPP 2.x\n-msdos/Makefile.emx\tmakefile for EMX 0.9c (32-bit DOS/OS2)\n-msdos/Makefile.msc\tmakefile for Microsoft C 16-bit\n-msdos/Makefile.tc\tmakefile for Turbo C\n-msdos/Makefile.wat\tmakefile for Watcom C\n-msdos/zlib.def        \tdefinition file for Windows DLL\n-msdos/zlib.rc         \tdefinition file for Windows DLL\n-\n-nt/Makefile.nt\t\tmakefile for Windows NT\n-nt/zlib.dnt\t\tdefinition file for Windows NT DLL\n-nt/Makefile.emx\t\tmakefile for EMX 0.9c/RSXNT 1.41 (Win32 Intel)\n-nt/Makefile.gcc\t\tmakefile for Windows NT using GCC (mingw32)\n-\n-\n-\t\tzlib public header files (must be kept):\n+ChangeLog       history of changes\n+FAQ             Frequently Asked Questions about zlib\n+INDEX           this file\n+Makefile        makefile for Unix (generated by configure)\n+Makefile.in     makefile for Unix (template for configure)\n+README          guess what\n+algorithm.txt   description of the (de)compression algorithm\n+configure       configure script for Unix\n+zconf.in.h      template for zconf.h (used by configure)\n+\n+msdos/          makefiles for MSDOS\n+old/            makefiles for various architectures and zlib documentation\n+                files that have not yet been updated for zlib 1.2.x\n+qnx/            makefiles for QNX\n+win32/          makefiles for Windows\n+\n+                zlib public header files (must be kept):\n zconf.h\n zlib.h\n \n-\t\tprivate source files used to build the zlib library:\n+                private source files used to build the zlib library:\n adler32.c\n compress.c\n crc32.c\n+crc32.h\n deflate.c\n deflate.h\n gzio.c\n-infblock.c\n-infblock.h\n-infcodes.c\n-infcodes.h\n+infback.c\n inffast.c\n inffast.h\n+inffixed.h\n inflate.c\n+inflate.h\n inftrees.c\n inftrees.h\n-infutil.c\n-infutil.h\n-maketree.c\n trees.c\n+trees.h\n uncompr.c\n zutil.c\n zutil.h\n \n-\t\tsource files for sample programs:\n+                source files for sample programs:\n example.c\n minigzip.c\n \n-\t\tunsupported contribution by third parties\n-\n-contrib/asm386/ by Gilles Vollant <info@winimage.com>\n-\t386 asm code replacing longest_match().\n-\n-contrib/minizip/ by Gilles Vollant <info@winimage.com>\n-\tMini zip and unzip based on zlib\n-        See http://www.winimage.com/zLibDll/unzip.html\n-\n-contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>\n-        A C++ I/O streams interface to the zlib gz* functions\n-\n-contrib/iostream2/  by Tyge L\ufffdvset <Tyge.Lovset@cmr.no>\n-\tAnother C++ I/O streams interface\n-\n-contrib/untgz/  by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n-\tA very simple tar.gz extractor using zlib\n-\n-contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>\n-        How to use compress(), uncompress() and the gz* functions from VB.\n+                unsupported contribution by third parties\n+See contrib/README.contrib"}, {"sha": "1c57e8f0e02d2091ac6a7c33d3638c9bf75772eb", "filename": "zlib/Make_vms.com", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2FMake_vms.com", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2FMake_vms.com", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FMake_vms.com?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,115 +0,0 @@\n-$! make libz under VMS\n-$! written by Martin P.J. Zinser <m.zinser@gsi.de>\n-$!\n-$! Look for the compiler used\n-$!\n-$ ccopt = \"\"\n-$ if f$getsyi(\"HW_MODEL\").ge.1024\n-$ then\n-$  ccopt = \"/prefix=all\"+ccopt\n-$  comp  = \"__decc__=1\"\n-$  if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n-$ else\n-$  if f$search(\"SYS$SYSTEM:DECC$COMPILER.EXE\").eqs.\"\"\n-$   then\n-$    comp  = \"__vaxc__=1\"\n-$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys sys$library:\n-$   else\n-$    if f$trnlnm(\"SYS\").eqs.\"\" then define sys decc$library_include:\n-$    ccopt = \"/decc/prefix=all\"+ccopt\n-$    comp  = \"__decc__=1\"\n-$  endif\n-$ endif\n-$!\n-$! Build the thing plain or with mms\n-$!\n-$ write sys$output \"Compiling Zlib sources ...\"\n-$ if f$search(\"SYS$SYSTEM:MMS.EXE\").eqs.\"\"\n-$  then\n-$   dele example.obj;*,minigzip.obj;*\n-$   CALL MAKE adler32.OBJ \"CC ''CCOPT' adler32\" -\n-                adler32.c zlib.h zconf.h\n-$   CALL MAKE compress.OBJ \"CC ''CCOPT' compress\" -\n-                compress.c zlib.h zconf.h\n-$   CALL MAKE crc32.OBJ \"CC ''CCOPT' crc32\" -\n-                crc32.c zlib.h zconf.h\n-$   CALL MAKE deflate.OBJ \"CC ''CCOPT' deflate\" -\n-                deflate.c deflate.h zutil.h zlib.h zconf.h\n-$   CALL MAKE gzio.OBJ \"CC ''CCOPT' gzio\" -\n-                gzio.c zutil.h zlib.h zconf.h\n-$   CALL MAKE infblock.OBJ \"CC ''CCOPT' infblock\" -\n-                infblock.c zutil.h zlib.h zconf.h infblock.h\n-$   CALL MAKE infcodes.OBJ \"CC ''CCOPT' infcodes\" -\n-                infcodes.c zutil.h zlib.h zconf.h inftrees.h\n-$   CALL MAKE inffast.OBJ \"CC ''CCOPT' inffast\" -\n-                inffast.c zutil.h zlib.h zconf.h inffast.h\n-$   CALL MAKE inflate.OBJ \"CC ''CCOPT' inflate\" -\n-                inflate.c zutil.h zlib.h zconf.h infblock.h\n-$   CALL MAKE inftrees.OBJ \"CC ''CCOPT' inftrees\" -\n-                inftrees.c zutil.h zlib.h zconf.h inftrees.h\n-$   CALL MAKE infutil.OBJ \"CC ''CCOPT' infutil\" -\n-                infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n-$   CALL MAKE trees.OBJ \"CC ''CCOPT' trees\" -\n-                trees.c deflate.h zutil.h zlib.h zconf.h\n-$   CALL MAKE uncompr.OBJ \"CC ''CCOPT' uncompr\" -\n-                uncompr.c zlib.h zconf.h\n-$   CALL MAKE zutil.OBJ \"CC ''CCOPT' zutil\" -\n-                zutil.c zutil.h zlib.h zconf.h\n-$   write sys$output \"Building Zlib ...\"\n-$   CALL MAKE libz.OLB \"lib/crea libz.olb *.obj\" *.OBJ\n-$   write sys$output \"Building example...\"\n-$   CALL MAKE example.OBJ \"CC ''CCOPT' example\" -\n-                example.c zlib.h zconf.h\n-$   call make example.exe \"LINK example,libz.olb/lib\" example.obj libz.olb\n-$   write sys$output \"Building minigzip...\"\n-$   CALL MAKE minigzip.OBJ \"CC ''CCOPT' minigzip\" -\n-                minigzip.c zlib.h zconf.h\n-$   call make minigzip.exe - \n-                \"LINK minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\" - \n-                minigzip.obj libz.olb\n-$  else\n-$   mms/macro=('comp')\n-$  endif\n-$ write sys$output \"Zlib build completed\"\n-$ exit\n-$!\n-$!\n-$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES\n-$ V = 'F$Verify(0)\n-$! P1 = What we are trying to make\n-$! P2 = Command to make it\n-$! P3 - P8  What it depends on\n-$\n-$ If F$Search(P1) .Eqs. \"\" Then Goto Makeit\n-$ Time = F$CvTime(F$File(P1,\"RDT\"))\n-$arg=3\n-$Loop:\n-$       Argument = P'arg\n-$       If Argument .Eqs. \"\" Then Goto Exit\n-$       El=0\n-$Loop2:\n-$       File = F$Element(El,\" \",Argument)\n-$       If File .Eqs. \" \" Then Goto Endl\n-$       AFile = \"\"\n-$Loop3:\n-$       OFile = AFile\n-$       AFile = F$Search(File)\n-$       If AFile .Eqs. \"\" .Or. AFile .Eqs. OFile Then Goto NextEl\n-$       If F$CvTime(F$File(AFile,\"RDT\")) .Ges. Time Then Goto Makeit\n-$       Goto Loop3\n-$NextEL:\n-$       El = El + 1\n-$       Goto Loop2\n-$EndL:\n-$ arg=arg+1\n-$ If arg .Le. 8 Then Goto Loop\n-$ Goto Exit\n-$\n-$Makeit:\n-$ VV=F$VERIFY(0)\n-$ write sys$output P2\n-$ 'P2\n-$ VV='F$Verify(VV)\n-$Exit:\n-$ If V Then Set Verify\n-$ENDSUBROUTINE"}, {"sha": "42ccd78be3fa52a5bbbc6d7d9624f7058b8e2dea", "filename": "zlib/Makefile.am", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FMakefile.am?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -2,10 +2,10 @@\n \n AUTOMAKE_OPTIONS = 1.8 cygnus\n \n-ZLIB_SOURCES = adler32.c compress.c crc32.c deflate.c deflate.h \\\n-gzio.c infblock.c infblock.h infcodes.c infcodes.h inffast.c inffast.h \\\n-inffixed.h inflate.c inftrees.c inftrees.h infutil.c infutil.h trees.c \\\n-trees.h uncompr.c zconf.h zlib.h zutil.c zutil.h\n+ZLIB_SOURCES = adler32.c compress.c crc32.c crc32.h deflate.c \\\n+deflate.h gzio.c infback.c inffast.c inffast.h inffixed.h inflate.c \\\n+inflate.h inftrees.c inftrees.h trees.c trees.h uncompr.c zconf.h \\\n+zconf.in.h zlib.h zutil.c zutil.h\n \n if TARGET_LIBRARY\n noinst_LTLIBRARIES = libzgcj_convenience.la"}, {"sha": "39796f9b6651d741b81e610bc80ebe7cf6ee927c", "filename": "zlib/Makefile.in", "status": "modified", "additions": 40, "deletions": 95, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FMakefile.in?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated by automake 1.8.5 from Makefile.am.\n+# Makefile.in generated by automake 1.9.2 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n@@ -47,9 +47,9 @@ DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub README \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n \t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n-\t$(srcdir)/../compile $(srcdir)/../compile $(srcdir)/../compile \\\n-\t$(srcdir)/../compile $(srcdir)/../ltmain.sh \\\n-\t$(srcdir)/../config.guess $(srcdir)/../config.sub\n+\t$(srcdir)/../compile $(srcdir)/../compile \\\n+\t$(srcdir)/../ltmain.sh $(srcdir)/../config.guess \\\n+\t$(srcdir)/../config.sub\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \\\n@@ -60,40 +60,36 @@ am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n  configure.lineno configure.status.lineno\n CONFIG_CLEAN_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;\n am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n toolexeclibLIBRARIES_INSTALL = $(INSTALL_DATA)\n LIBRARIES = $(toolexeclib_LIBRARIES)\n AR = ar\n ARFLAGS = cru\n libz_a_AR = $(AR) $(ARFLAGS)\n libz_a_LIBADD =\n-am__libz_a_SOURCES_DIST = adler32.c compress.c crc32.c deflate.c \\\n-\tdeflate.h gzio.c infblock.c infblock.h infcodes.c infcodes.h \\\n-\tinffast.c inffast.h inffixed.h inflate.c inftrees.c inftrees.h \\\n-\tinfutil.c infutil.h trees.c trees.h uncompr.c zconf.h zlib.h \\\n-\tzutil.c zutil.h\n am__objects_1 = libz_a-adler32.$(OBJEXT) libz_a-compress.$(OBJEXT) \\\n \tlibz_a-crc32.$(OBJEXT) libz_a-deflate.$(OBJEXT) \\\n-\tlibz_a-gzio.$(OBJEXT) libz_a-infblock.$(OBJEXT) \\\n-\tlibz_a-infcodes.$(OBJEXT) libz_a-inffast.$(OBJEXT) \\\n-\tlibz_a-inflate.$(OBJEXT) libz_a-inftrees.$(OBJEXT) \\\n-\tlibz_a-infutil.$(OBJEXT) libz_a-trees.$(OBJEXT) \\\n+\tlibz_a-gzio.$(OBJEXT) libz_a-infback.$(OBJEXT) \\\n+\tlibz_a-inffast.$(OBJEXT) libz_a-inflate.$(OBJEXT) \\\n+\tlibz_a-inftrees.$(OBJEXT) libz_a-trees.$(OBJEXT) \\\n \tlibz_a-uncompr.$(OBJEXT) libz_a-zutil.$(OBJEXT)\n @TARGET_LIBRARY_FALSE@am_libz_a_OBJECTS = $(am__objects_1)\n libz_a_OBJECTS = $(am_libz_a_OBJECTS)\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n libzgcj_convenience_la_LIBADD =\n-am__libzgcj_convenience_la_SOURCES_DIST = adler32.c compress.c crc32.c \\\n-\tdeflate.c deflate.h gzio.c infblock.c infblock.h infcodes.c \\\n-\tinfcodes.h inffast.c inffast.h inffixed.h inflate.c inftrees.c \\\n-\tinftrees.h infutil.c infutil.h trees.c trees.h uncompr.c \\\n-\tzconf.h zlib.h zutil.c zutil.h\n am__objects_2 = adler32.lo compress.lo crc32.lo deflate.lo gzio.lo \\\n-\tinfblock.lo infcodes.lo inffast.lo inflate.lo inftrees.lo \\\n-\tinfutil.lo trees.lo uncompr.lo zutil.lo\n+\tinfback.lo inffast.lo inflate.lo inftrees.lo trees.lo \\\n+\tuncompr.lo zutil.lo\n @TARGET_LIBRARY_TRUE@am_libzgcj_convenience_la_OBJECTS =  \\\n @TARGET_LIBRARY_TRUE@\t$(am__objects_2)\n libzgcj_convenience_la_OBJECTS = $(am_libzgcj_convenience_la_OBJECTS)\n+@TARGET_LIBRARY_TRUE@am_libzgcj_convenience_la_rpath =\n DEFAULT_INCLUDES = -I. -I$(srcdir)\n depcomp =\n am__depfiles_maybe =\n@@ -106,8 +102,6 @@ CCLD = $(CC)\n LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n \t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n SOURCES = $(libz_a_SOURCES) $(libzgcj_convenience_la_SOURCES)\n-DIST_SOURCES = $(am__libz_a_SOURCES_DIST) \\\n-\t$(am__libzgcj_convenience_la_SOURCES_DIST)\n MULTISRCTOP = \n MULTIBUILDTOP = \n MULTIDIRS = \n@@ -174,6 +168,8 @@ am__fastdepCC_TRUE = @am__fastdepCC_TRUE@\n am__include = @am__include@\n am__leading_dot = @am__leading_dot@\n am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n bindir = @bindir@\n build = @build@\n build_alias = @build_alias@\n@@ -212,10 +208,10 @@ target_vendor = @target_vendor@\n toolexecdir = @toolexecdir@\n toolexeclibdir = @toolexeclibdir@\n AUTOMAKE_OPTIONS = 1.8 cygnus\n-ZLIB_SOURCES = adler32.c compress.c crc32.c deflate.c deflate.h \\\n-gzio.c infblock.c infblock.h infcodes.c infcodes.h inffast.c inffast.h \\\n-inffixed.h inflate.c inftrees.c inftrees.h infutil.c infutil.h trees.c \\\n-trees.h uncompr.c zconf.h zlib.h zutil.c zutil.h\n+ZLIB_SOURCES = adler32.c compress.c crc32.c crc32.h deflate.c \\\n+deflate.h gzio.c infback.c inffast.c inffast.h inffixed.h inflate.c \\\n+inflate.h inftrees.c inftrees.h trees.c trees.h uncompr.c zconf.h \\\n+zconf.in.h zlib.h zutil.c zutil.h\n \n @TARGET_LIBRARY_TRUE@noinst_LTLIBRARIES = libzgcj_convenience.la\n @TARGET_LIBRARY_TRUE@libzgcj_convenience_la_SOURCES = $(ZLIB_SOURCES)\n@@ -306,15 +302,15 @@ install-toolexeclibLIBRARIES: $(toolexeclib_LIBRARIES)\n \ttest -z \"$(toolexeclibdir)\" || $(mkdir_p) \"$(DESTDIR)$(toolexeclibdir)\"\n \t@list='$(toolexeclib_LIBRARIES)'; for p in $$list; do \\\n \t  if test -f $$p; then \\\n-\t    f=\"`echo $$p | sed -e 's|^.*/||'`\"; \\\n+\t    f=$(am__strip_dir) \\\n \t    echo \" $(toolexeclibLIBRARIES_INSTALL) '$$p' '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n \t    $(toolexeclibLIBRARIES_INSTALL) \"$$p\" \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n \t  else :; fi; \\\n \tdone\n \t@$(POST_INSTALL)\n \t@list='$(toolexeclib_LIBRARIES)'; for p in $$list; do \\\n \t  if test -f $$p; then \\\n-\t    p=\"`echo $$p | sed -e 's|^.*/||'`\"; \\\n+\t    p=$(am__strip_dir) \\\n \t    echo \" $(RANLIB) '$(DESTDIR)$(toolexeclibdir)/$$p'\"; \\\n \t    $(RANLIB) \"$(DESTDIR)$(toolexeclibdir)/$$p\"; \\\n \t  else :; fi; \\\n@@ -323,7 +319,7 @@ install-toolexeclibLIBRARIES: $(toolexeclib_LIBRARIES)\n uninstall-toolexeclibLIBRARIES:\n \t@$(NORMAL_UNINSTALL)\n \t@list='$(toolexeclib_LIBRARIES)'; for p in $$list; do \\\n-\t  p=\"`echo $$p | sed -e 's|^.*/||'`\"; \\\n+\t  p=$(am__strip_dir) \\\n \t  echo \" rm -f '$(DESTDIR)$(toolexeclibdir)/$$p'\"; \\\n \t  rm -f \"$(DESTDIR)$(toolexeclibdir)/$$p\"; \\\n \tdone\n@@ -344,7 +340,7 @@ clean-noinstLTLIBRARIES:\n \t  rm -f \"$${dir}/so_locations\"; \\\n \tdone\n libzgcj_convenience.la: $(libzgcj_convenience_la_OBJECTS) $(libzgcj_convenience_la_DEPENDENCIES) \n-\t$(LINK)  $(libzgcj_convenience_la_LDFLAGS) $(libzgcj_convenience_la_OBJECTS) $(libzgcj_convenience_la_LIBADD) $(LIBS)\n+\t$(LINK) $(am_libzgcj_convenience_la_rpath) $(libzgcj_convenience_la_LDFLAGS) $(libzgcj_convenience_la_OBJECTS) $(libzgcj_convenience_la_LIBADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)\n@@ -367,126 +363,72 @@ libz_a-adler32.o: adler32.c\n libz_a-adler32.obj: adler32.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-adler32.obj `if test -f 'adler32.c'; then $(CYGPATH_W) 'adler32.c'; else $(CYGPATH_W) '$(srcdir)/adler32.c'; fi`\n \n-libz_a-adler32.lo: adler32.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-adler32.lo `test -f 'adler32.c' || echo '$(srcdir)/'`adler32.c\n-\n libz_a-compress.o: compress.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-compress.o `test -f 'compress.c' || echo '$(srcdir)/'`compress.c\n \n libz_a-compress.obj: compress.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-compress.obj `if test -f 'compress.c'; then $(CYGPATH_W) 'compress.c'; else $(CYGPATH_W) '$(srcdir)/compress.c'; fi`\n \n-libz_a-compress.lo: compress.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-compress.lo `test -f 'compress.c' || echo '$(srcdir)/'`compress.c\n-\n libz_a-crc32.o: crc32.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-crc32.o `test -f 'crc32.c' || echo '$(srcdir)/'`crc32.c\n \n libz_a-crc32.obj: crc32.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-crc32.obj `if test -f 'crc32.c'; then $(CYGPATH_W) 'crc32.c'; else $(CYGPATH_W) '$(srcdir)/crc32.c'; fi`\n \n-libz_a-crc32.lo: crc32.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-crc32.lo `test -f 'crc32.c' || echo '$(srcdir)/'`crc32.c\n-\n libz_a-deflate.o: deflate.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-deflate.o `test -f 'deflate.c' || echo '$(srcdir)/'`deflate.c\n \n libz_a-deflate.obj: deflate.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-deflate.obj `if test -f 'deflate.c'; then $(CYGPATH_W) 'deflate.c'; else $(CYGPATH_W) '$(srcdir)/deflate.c'; fi`\n \n-libz_a-deflate.lo: deflate.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-deflate.lo `test -f 'deflate.c' || echo '$(srcdir)/'`deflate.c\n-\n libz_a-gzio.o: gzio.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzio.o `test -f 'gzio.c' || echo '$(srcdir)/'`gzio.c\n \n libz_a-gzio.obj: gzio.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzio.obj `if test -f 'gzio.c'; then $(CYGPATH_W) 'gzio.c'; else $(CYGPATH_W) '$(srcdir)/gzio.c'; fi`\n \n-libz_a-gzio.lo: gzio.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzio.lo `test -f 'gzio.c' || echo '$(srcdir)/'`gzio.c\n-\n-libz_a-infblock.o: infblock.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infblock.o `test -f 'infblock.c' || echo '$(srcdir)/'`infblock.c\n-\n-libz_a-infblock.obj: infblock.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infblock.obj `if test -f 'infblock.c'; then $(CYGPATH_W) 'infblock.c'; else $(CYGPATH_W) '$(srcdir)/infblock.c'; fi`\n-\n-libz_a-infblock.lo: infblock.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infblock.lo `test -f 'infblock.c' || echo '$(srcdir)/'`infblock.c\n-\n-libz_a-infcodes.o: infcodes.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infcodes.o `test -f 'infcodes.c' || echo '$(srcdir)/'`infcodes.c\n-\n-libz_a-infcodes.obj: infcodes.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infcodes.obj `if test -f 'infcodes.c'; then $(CYGPATH_W) 'infcodes.c'; else $(CYGPATH_W) '$(srcdir)/infcodes.c'; fi`\n+libz_a-infback.o: infback.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infback.o `test -f 'infback.c' || echo '$(srcdir)/'`infback.c\n \n-libz_a-infcodes.lo: infcodes.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infcodes.lo `test -f 'infcodes.c' || echo '$(srcdir)/'`infcodes.c\n+libz_a-infback.obj: infback.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infback.obj `if test -f 'infback.c'; then $(CYGPATH_W) 'infback.c'; else $(CYGPATH_W) '$(srcdir)/infback.c'; fi`\n \n libz_a-inffast.o: inffast.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inffast.o `test -f 'inffast.c' || echo '$(srcdir)/'`inffast.c\n \n libz_a-inffast.obj: inffast.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inffast.obj `if test -f 'inffast.c'; then $(CYGPATH_W) 'inffast.c'; else $(CYGPATH_W) '$(srcdir)/inffast.c'; fi`\n \n-libz_a-inffast.lo: inffast.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inffast.lo `test -f 'inffast.c' || echo '$(srcdir)/'`inffast.c\n-\n libz_a-inflate.o: inflate.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inflate.o `test -f 'inflate.c' || echo '$(srcdir)/'`inflate.c\n \n libz_a-inflate.obj: inflate.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inflate.obj `if test -f 'inflate.c'; then $(CYGPATH_W) 'inflate.c'; else $(CYGPATH_W) '$(srcdir)/inflate.c'; fi`\n \n-libz_a-inflate.lo: inflate.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inflate.lo `test -f 'inflate.c' || echo '$(srcdir)/'`inflate.c\n-\n libz_a-inftrees.o: inftrees.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inftrees.o `test -f 'inftrees.c' || echo '$(srcdir)/'`inftrees.c\n \n libz_a-inftrees.obj: inftrees.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inftrees.obj `if test -f 'inftrees.c'; then $(CYGPATH_W) 'inftrees.c'; else $(CYGPATH_W) '$(srcdir)/inftrees.c'; fi`\n \n-libz_a-inftrees.lo: inftrees.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inftrees.lo `test -f 'inftrees.c' || echo '$(srcdir)/'`inftrees.c\n-\n-libz_a-infutil.o: infutil.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infutil.o `test -f 'infutil.c' || echo '$(srcdir)/'`infutil.c\n-\n-libz_a-infutil.obj: infutil.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infutil.obj `if test -f 'infutil.c'; then $(CYGPATH_W) 'infutil.c'; else $(CYGPATH_W) '$(srcdir)/infutil.c'; fi`\n-\n-libz_a-infutil.lo: infutil.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infutil.lo `test -f 'infutil.c' || echo '$(srcdir)/'`infutil.c\n-\n libz_a-trees.o: trees.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-trees.o `test -f 'trees.c' || echo '$(srcdir)/'`trees.c\n \n libz_a-trees.obj: trees.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-trees.obj `if test -f 'trees.c'; then $(CYGPATH_W) 'trees.c'; else $(CYGPATH_W) '$(srcdir)/trees.c'; fi`\n \n-libz_a-trees.lo: trees.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-trees.lo `test -f 'trees.c' || echo '$(srcdir)/'`trees.c\n-\n libz_a-uncompr.o: uncompr.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-uncompr.o `test -f 'uncompr.c' || echo '$(srcdir)/'`uncompr.c\n \n libz_a-uncompr.obj: uncompr.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-uncompr.obj `if test -f 'uncompr.c'; then $(CYGPATH_W) 'uncompr.c'; else $(CYGPATH_W) '$(srcdir)/uncompr.c'; fi`\n \n-libz_a-uncompr.lo: uncompr.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-uncompr.lo `test -f 'uncompr.c' || echo '$(srcdir)/'`uncompr.c\n-\n libz_a-zutil.o: zutil.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-zutil.o `test -f 'zutil.c' || echo '$(srcdir)/'`zutil.c\n \n libz_a-zutil.obj: zutil.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-zutil.obj `if test -f 'zutil.c'; then $(CYGPATH_W) 'zutil.c'; else $(CYGPATH_W) '$(srcdir)/zutil.c'; fi`\n \n-libz_a-zutil.lo: zutil.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-zutil.lo `test -f 'zutil.c' || echo '$(srcdir)/'`zutil.c\n-\n mostlyclean-libtool:\n \t-rm -f *.lo\n \n@@ -496,19 +438,22 @@ clean-libtool:\n distclean-libtool:\n \t-rm -f libtool\n \n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n \n mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n uninstall-info-am:\n \n ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n@@ -584,7 +529,7 @@ mostlyclean-generic:\n clean-generic:\n \n distclean-generic:\n-\t-rm -f $(CONFIG_CLEAN_FILES)\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n \n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\""}, {"sha": "d97f4492370f1be65002d26866c2312937730a67", "filename": "zlib/Makefile.riscos", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2FMakefile.riscos", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2FMakefile.riscos", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FMakefile.riscos?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,151 +0,0 @@\n-# Project:   zlib_1_03\n-# Patched for zlib 1.1.2 rw@shadow.org.uk 19980430\n-# test works out-of-the-box, installs `somewhere' on demand\n-\n-# Toolflags:\n-CCflags = -c -depend !Depend -IC: -g -throwback  -DRISCOS  -fah \n-C++flags = -c -depend !Depend -IC: -throwback\n-Linkflags = -aif -c++ -o $@ \n-ObjAsmflags = -throwback -NoCache -depend !Depend\n-CMHGflags = \n-LibFileflags = -c -l -o $@ \n-Squeezeflags = -o $@\n-\n-# change the line below to where _you_ want the library installed.\n-libdest = lib:zlib\n-\n-# Final targets:\n-@.lib:   @.o.adler32 @.o.compress @.o.crc32 @.o.deflate @.o.gzio \\\n-        @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil @.o.trees \\\n-        @.o.uncompr @.o.zutil \n-        LibFile $(LibFileflags) @.o.adler32 @.o.compress @.o.crc32 @.o.deflate \\\n-        @.o.gzio @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil \\\n-        @.o.trees @.o.uncompr @.o.zutil \n-test:   @.minigzip @.example @.lib\n-\t@copy @.lib @.libc  A~C~DF~L~N~P~Q~RS~TV\n-\t@echo running tests: hang on.\n-\t@/@.minigzip -f -9 libc\n-\t@/@.minigzip -d libc-gz\n-\t@/@.minigzip -f -1 libc\n-\t@/@.minigzip -d libc-gz\n-\t@/@.minigzip -h -9 libc\n-\t@/@.minigzip -d libc-gz\n-\t@/@.minigzip -h -1 libc\n-\t@/@.minigzip -d libc-gz\n-\t@/@.minigzip -9 libc\n-\t@/@.minigzip -d libc-gz\n-\t@/@.minigzip -1 libc\n-\t@/@.minigzip -d libc-gz\n-\t@diff @.lib @.libc\n-\t@echo that should have reported '@.lib and @.libc identical' if you have diff.\n-\t@/@.example @.fred @.fred\n-\t@echo that will have given lots of hello!'s.\n-\n-@.minigzip:   @.o.minigzip @.lib C:o.Stubs \n-        Link $(Linkflags) @.o.minigzip @.lib C:o.Stubs \n-@.example:   @.o.example @.lib C:o.Stubs \n-        Link $(Linkflags) @.o.example @.lib C:o.Stubs\n-\n-install: @.lib\n-\tcdir $(libdest)\n-\tcdir $(libdest).h\n-\t@copy @.h.zlib $(libdest).h.zlib A~C~DF~L~N~P~Q~RS~TV\n-\t@copy @.h.zconf $(libdest).h.zconf A~C~DF~L~N~P~Q~RS~TV\n-\t@copy @.lib $(libdest).lib  A~C~DF~L~N~P~Q~RS~TV\n-\t@echo okay, installed zlib in $(libdest)\n-\n-clean:; remove @.minigzip\n-\tremove @.example\n-\tremove @.libc\n-\t-wipe @.o.* F~r~cV\n-\tremove @.fred\n-\n-# User-editable dependencies:\n-.c.o:\n-        cc $(ccflags) -o $@ $<\n-\n-# Static dependencies:\n-\n-# Dynamic dependencies:\n-o.example:\tc.example\n-o.example:\th.zlib\n-o.example:\th.zconf\n-o.minigzip:\tc.minigzip\n-o.minigzip:\th.zlib\n-o.minigzip:\th.zconf\n-o.adler32:\tc.adler32\n-o.adler32:\th.zlib\n-o.adler32:\th.zconf\n-o.compress:\tc.compress\n-o.compress:\th.zlib\n-o.compress:\th.zconf\n-o.crc32:\tc.crc32\n-o.crc32:\th.zlib\n-o.crc32:\th.zconf\n-o.deflate:\tc.deflate\n-o.deflate:\th.deflate\n-o.deflate:\th.zutil\n-o.deflate:\th.zlib\n-o.deflate:\th.zconf\n-o.gzio:\tc.gzio\n-o.gzio:\th.zutil\n-o.gzio:\th.zlib\n-o.gzio:\th.zconf\n-o.infblock:\tc.infblock\n-o.infblock:\th.zutil\n-o.infblock:\th.zlib\n-o.infblock:\th.zconf\n-o.infblock:\th.infblock\n-o.infblock:\th.inftrees\n-o.infblock:\th.infcodes\n-o.infblock:\th.infutil\n-o.infcodes:\tc.infcodes\n-o.infcodes:\th.zutil\n-o.infcodes:\th.zlib\n-o.infcodes:\th.zconf\n-o.infcodes:\th.inftrees\n-o.infcodes:\th.infblock\n-o.infcodes:\th.infcodes\n-o.infcodes:\th.infutil\n-o.infcodes:\th.inffast\n-o.inffast:\tc.inffast\n-o.inffast:\th.zutil\n-o.inffast:\th.zlib\n-o.inffast:\th.zconf\n-o.inffast:\th.inftrees\n-o.inffast:\th.infblock\n-o.inffast:\th.infcodes\n-o.inffast:\th.infutil\n-o.inffast:\th.inffast\n-o.inflate:\tc.inflate\n-o.inflate:\th.zutil\n-o.inflate:\th.zlib\n-o.inflate:\th.zconf\n-o.inflate:\th.infblock\n-o.inftrees:\tc.inftrees\n-o.inftrees:\th.zutil\n-o.inftrees:\th.zlib\n-o.inftrees:\th.zconf\n-o.inftrees:\th.inftrees\n-o.inftrees:\th.inffixed\n-o.infutil:\tc.infutil\n-o.infutil:\th.zutil\n-o.infutil:\th.zlib\n-o.infutil:\th.zconf\n-o.infutil:\th.infblock\n-o.infutil:\th.inftrees\n-o.infutil:\th.infcodes\n-o.infutil:\th.infutil\n-o.trees:\tc.trees\n-o.trees:\th.deflate\n-o.trees:\th.zutil\n-o.trees:\th.zlib\n-o.trees:\th.zconf\n-o.trees:\th.trees\n-o.uncompr:\tc.uncompr\n-o.uncompr:\th.zlib\n-o.uncompr:\th.zconf\n-o.zutil:\tc.zutil\n-o.zutil:\th.zutil\n-o.zutil:\th.zlib\n-o.zutil:\th.zconf"}, {"sha": "2edc660779502991bd051088c1bce8e37a2282aa", "filename": "zlib/README", "status": "modified", "additions": 58, "deletions": 79, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2FREADME?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,113 +1,90 @@\n This directory contains the zlib package, which is not part of GCC but\n shipped with GCC as convenience.\n \n-zlib 1.1.4 is a general purpose data compression library.  All the code\n-is thread safe.  The data format used by the zlib library\n-is described by RFCs (Request for Comments) 1950 to 1952 in the files \n-http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate\n-format) and rfc1952.txt (gzip format). These documents are also available in\n-other formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html\n+ZLIB DATA COMPRESSION LIBRARY\n+\n+zlib 1.2.1 is a general purpose data compression library.  All the code is\n+thread safe.  The data format used by the zlib library is described by RFCs\n+(Request for Comments) 1950 to 1952 in the files\n+http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)\n+and rfc1952.txt (gzip format). These documents are also available in other\n+formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html\n \n All functions of the compression library are documented in the file zlib.h\n-(volunteer to write man pages welcome, contact jloup@gzip.org). A usage\n-example of the library is given in the file example.c which also tests that\n-the library is working correctly. Another example is given in the file\n-minigzip.c. The compression library itself is composed of all source files\n-except example.c and minigzip.c.\n-\n-To compile all files and run the test program, follow the instructions\n-given at the top of Makefile. In short \"make test; make install\"\n-should work for most machines. For Unix: \"./configure; make test; make install\"\n-For MSDOS, use one of the special makefiles such as Makefile.msc.\n-For VMS, use Make_vms.com or descrip.mms.\n-\n-Questions about zlib should be sent to <zlib@gzip.org>, or to\n-Gilles Vollant <info@winimage.com> for the Windows DLL version.\n-The zlib home page is http://www.zlib.org or http://www.gzip.org/zlib/\n-Before reporting a problem, please check this site to verify that\n-you have the latest version of zlib; otherwise get the latest version and\n-check whether the problem still exists or not.\n-\n-PLEASE read the zlib FAQ http://www.gzip.org/zlib/zlib_faq.html\n-before asking for help.\n+(volunteer to write man pages welcome, contact zlib@gzip.org). A usage example\n+of the library is given in the file example.c which also tests that the library\n+is working correctly. Another example is given in the file minigzip.c. The\n+compression library itself is composed of all source files except example.c and\n+minigzip.c.\n+\n+To compile all files and run the test program, follow the instructions given at\n+the top of Makefile. In short \"make test; make install\" should work for most\n+machines. For Unix: \"./configure; make test; make install\" For MSDOS, use one\n+of the special makefiles such as Makefile.msc. For VMS, use Make_vms.com or\n+descrip.mms.\n+\n+Questions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant\n+<info@winimage.com> for the Windows DLL version. The zlib home page is\n+http://www.zlib.org or http://www.gzip.org/zlib/ Before reporting a problem,\n+please check this site to verify that you have the latest version of zlib;\n+otherwise get the latest version and check whether the problem still exists or\n+not.\n+\n+PLEASE read the zlib FAQ http://www.gzip.org/zlib/zlib_faq.html before asking\n+for help.\n \n Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan. 1997\n issue of  Dr. Dobb's Journal; a copy of the article is available in\n http://dogma.net/markn/articles/zlibtool/zlibtool.htm\n \n-The changes made in version 1.1.4 are documented in the file ChangeLog.\n-The only changes made since 1.1.3 are bug corrections:\n-\n-- ZFREE was repeated on same allocation on some error conditions.\n-  This creates a security problem described in\n-  http://www.zlib.org/advisory-2002-03-11.txt\n-- Returned incorrect error (Z_MEM_ERROR) on some invalid data\n-- Avoid accesses before window for invalid distances with inflate window\n-  less than 32K.\n-- force windowBits > 8 to avoid a bug in the encoder for a window size\n-  of 256 bytes. (A complete fix will be available in 1.1.5).\n-\n-The beta version 1.1.5beta includes many more changes. A new official\n-version 1.1.5 will be released as soon as extensive testing has been\n-completed on it.\n-\n+The changes made in version 1.2.1 are documented in the file ChangeLog.\n \n Unsupported third party contributions are provided in directory \"contrib\".\n \n A Java implementation of zlib is available in the Java Development Kit\n-http://www.javasoft.com/products/JDK/1.1/docs/api/Package-java.util.zip.html\n+http://java.sun.com/j2se/1.4.2/docs/api/java/util/zip/package-summary.html\n See the zlib home page http://www.zlib.org for details.\n \n-A Perl interface to zlib written by Paul Marquess <pmarquess@bfsec.bt.co.uk>\n-is in the CPAN (Comprehensive Perl Archive Network) sites\n+A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is in the\n+CPAN (Comprehensive Perl Archive Network) sites\n http://www.cpan.org/modules/by-module/Compress/\n \n-A Python interface to zlib written by A.M. Kuchling <amk@magnet.com>\n-is available in Python 1.5 and later versions, see\n+A Python interface to zlib written by A.M. Kuchling <amk@magnet.com> is\n+available in Python 1.5 and later versions, see\n http://www.python.org/doc/lib/module-zlib.html\n \n-A zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com>\n-is availlable at http://www.westend.com/~kupries/doc/trf/man/man.html\n+A zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com> is\n+availlable at http://www.oche.de/~akupries/soft/trf/trf_zip.html\n \n-An experimental package to read and write files in .zip format,\n-written on top of zlib by Gilles Vollant <info@winimage.com>, is\n-available at http://www.winimage.com/zLibDll/unzip.html\n-and also in the contrib/minizip directory of zlib.\n+An experimental package to read and write files in .zip format, written on top\n+of zlib by Gilles Vollant <info@winimage.com>, is available in the\n+contrib/minizip directory of zlib.\n \n \n Notes for some targets:\n \n-- To build a Windows DLL version, include in a DLL project zlib.def, zlib.rc\n-  and all .c files except example.c and minigzip.c; compile with -DZLIB_DLL\n-  The zlib DLL support was initially done by Alessandro Iacopetti and is\n-  now maintained by Gilles Vollant <info@winimage.com>. Check the zlib DLL\n-  home page at http://www.winimage.com/zLibDll\n-\n-  From Visual Basic, you can call the DLL functions which do not take\n-  a structure as argument: compress, uncompress and all gz* functions.\n-  See contrib/visual-basic.txt for more information, or get\n-  http://www.tcfb.com/dowseware/cmp-z-it.zip\n+- For Windows DLL versions, please see win32/DLL_FAQ.txt\n \n-- For 64-bit Irix, deflate.c must be compiled without any optimization.\n-  With -O, one libpng test fails. The test works in 32 bit mode (with\n-  the -n32 compiler flag). The compiler bug has been reported to SGI.\n+- For 64-bit Irix, deflate.c must be compiled without any optimization. With\n+  -O, one libpng test fails. The test works in 32 bit mode (with the -n32\n+  compiler flag). The compiler bug has been reported to SGI.\n \n-- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1   \n-  it works when compiled with cc.\n+- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1 it works\n+  when compiled with cc.\n \n-- on Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1\n-  is necessary to get gzprintf working correctly. This is done by configure.\n+- On Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1 is\n+  necessary to get gzprintf working correctly. This is done by configure.\n \n-- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works\n-  with other compilers. Use \"make test\" to check your compiler.\n+- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works with\n+  other compilers. Use \"make test\" to check your compiler.\n \n - gzdopen is not supported on RISCOS, BEOS and by some Mac compilers.\n \n-- For Turbo C the small model is supported only with reduced performance to\n-  avoid any far allocation; it was tested with -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3\n+- For PalmOs, see http://palmzlib.sourceforge.net/\n \n-- For PalmOs, see http://www.cs.uit.no/~perm/PASTA/pilot/software.html\n-  Per Harald Myrvang <perm@stud.cs.uit.no>\n+- When building a shared, i.e. dynamic library on Mac OS X, the library must be\n+  installed before testing (do \"make install\" before \"make test\"), since the\n+  library location is specified in the library.\n \n \n Acknowledgments:\n@@ -119,7 +96,7 @@ Acknowledgments:\n \n Copyright notice:\n \n- (C) 1995-2002 Jean-loup Gailly and Mark Adler\n+ (C) 1995-2003 Jean-loup Gailly and Mark Adler\n \n   This software is provided 'as-is', without any express or implied\n   warranty.  In no event will the authors be held liable for any damages\n@@ -147,4 +124,6 @@ entirely written by Jean-loup Gailly and Mark Adler; it does not\n include third-party code.\n \n If you redistribute modified sources, we would appreciate that you include\n-in the file ChangeLog history information documenting your changes.\n+in the file ChangeLog history information documenting your changes. Please\n+read the FAQ for more information on the distribution of modified source\n+versions."}, {"sha": "6d40a6ebea9d75b4199ee98b974532729675cfe6", "filename": "zlib/aclocal.m4", "status": "modified", "additions": 145, "deletions": 33, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Faclocal.m4?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,4 +1,4 @@\n-# generated automatically by aclocal 1.8.5 -*- Autoconf -*-\n+# generated automatically by aclocal 1.9.2 -*- Autoconf -*-\n \n # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n # Free Software Foundation, Inc.\n@@ -33,14 +33,14 @@\n # ----------------------------\n # Automake X.Y traces this macro to ensure aclocal.m4 has been\n # generated from the m4 files accompanying Automake X.Y.\n-AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version=\"1.8\"])\n+AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version=\"1.9\"])\n \n # AM_SET_CURRENT_AUTOMAKE_VERSION\n # -------------------------------\n # Call AM_AUTOMAKE_VERSION so it can be traced.\n # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.\n AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-\t [AM_AUTOMAKE_VERSION([1.8.5])])\n+\t [AM_AUTOMAKE_VERSION([1.9.2])])\n \n # AM_AUX_DIR_EXPAND\n \n@@ -108,7 +108,7 @@ am_aux_dir=`cd $ac_aux_dir && pwd`\n \n # AM_CONDITIONAL                                              -*- Autoconf -*-\n \n-# Copyright (C) 1997, 2000, 2001, 2003 Free Software Foundation, Inc.\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -145,8 +145,8 @@ else\n fi\n AC_CONFIG_COMMANDS_PRE(\n [if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.])\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n fi])])\n \n # serial 7\t\t\t\t\t\t-*- Autoconf -*-\n@@ -319,7 +319,8 @@ AC_SUBST([AMDEPBACKSLASH])\n \n # Generate code to set up dependency tracking.   -*- Autoconf -*-\n \n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+#   Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -355,27 +356,21 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n   else\n     continue\n   fi\n-  grep '^DEP_FILES *= *[[^ @%:@]]' < \"$mf\" > /dev/null || continue\n-  # Extract the definition of DEP_FILES from the Makefile without\n-  # running `make'.\n+  # Extract the definition of DEPDIR, am__include, and am__quote\n+  # from the Makefile without running `make'.\n   DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n   test -z \"$DEPDIR\" && continue\n+  am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+  test -z \"am__include\" && continue\n+  am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n   # When using ansi2knr, U may be empty or an underscore; expand it\n   U=`sed -n 's/^U = //p' < \"$mf\"`\n-  test -d \"$dirpart/$DEPDIR\" || mkdir \"$dirpart/$DEPDIR\"\n-  # We invoke sed twice because it is the simplest approach to\n-  # changing $(DEPDIR) to its actual value in the expansion.\n-  for file in `sed -n '\n-    /^DEP_FILES = .*\\\\\\\\$/ {\n-      s/^DEP_FILES = //\n-      :loop\n-\ts/\\\\\\\\$//\n-\tp\n-\tn\n-\t/\\\\\\\\$/ b loop\n-      p\n-    }\n-    /^DEP_FILES = / s/^DEP_FILES = //p' < \"$mf\" | \\\n+  # Find all dependency output files, they are included files with\n+  # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+  # simplest approach to changing $(DEPDIR) to its actual value in the\n+  # expansion.\n+  for file in `sed -n \"\n+    s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n        sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n     # Make sure the directory exists.\n     test -f \"$dirpart/$file\" && continue\n@@ -406,7 +401,7 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n # This macro actually does too much some checks are only needed if\n # your package does certain things.  But this isn't really a big deal.\n \n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n # Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n@@ -482,7 +477,6 @@ AM_MISSING_PROG(AUTOCONF, autoconf)\n AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n AM_MISSING_PROG(AUTOHEADER, autoheader)\n AM_MISSING_PROG(MAKEINFO, makeinfo)\n-AM_MISSING_PROG(AMTAR, tar)\n AM_PROG_INSTALL_SH\n AM_PROG_INSTALL_STRIP\n AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n@@ -491,7 +485,9 @@ AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n AC_REQUIRE([AC_PROG_AWK])dnl\n AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+              [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t      \t\t     [_AM_PROG_TAR([v7])])])\n _AM_IF_OPTION([no-dependencies],,\n [AC_PROVIDE_IFELSE([AC_PROG_CC],\n                   [_AM_DEPENDENCIES(CC)],\n@@ -774,13 +770,21 @@ fi\n # this.)\n AC_DEFUN([AM_PROG_MKDIR_P],\n [if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then\n-  # Keeping the `.' argument allows $(mkdir_p) to be used without\n-  # argument.  Indeed, we sometimes output rules like\n+  # We used to keeping the `.' as first argument, in order to\n+  # allow $(mkdir_p) to be used without argument.  As in\n   #   $(mkdir_p) $(somedir)\n-  # where $(somedir) is conditionally defined.\n-  # (`test -n '$(somedir)' && $(mkdir_p) $(somedir)' is a more\n-  # expensive solution, as it forces Make to start a sub-shell.)\n-  mkdir_p='mkdir -p -- .'\n+  # where $(somedir) is conditionally defined.  However this is wrong\n+  # for two reasons:\n+  #  1. if the package is installed by a user who cannot write `.'\n+  #     make install will fail,\n+  #  2. the above comment should most certainly read\n+  #     $(mkdir_p) $(DESTDIR)$(somedir)\n+  #     so it does not work when $(somedir) is undefined and\n+  #     $(DESTDIR) is not.\n+  #  To support the latter case, we have to write\n+  #     test -z \"$(somedir)\" || $(mkdir_p) $(DESTDIR)$(somedir),\n+  #  so the `.' trick is pointless.\n+  mkdir_p='mkdir -p --'\n else\n   # On NextStep and OpenStep, the `mkdir' command does not\n   # recognize any option.  It will interpret all options as\n@@ -1015,4 +1019,112 @@ fi\n INSTALL_STRIP_PROGRAM=\"\\${SHELL} \\$(install_sh) -c -s\"\n AC_SUBST([INSTALL_STRIP_PROGRAM])])\n \n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n+# 02111-1307, USA.\n+\n+# serial 1\n+\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n m4_include([acinclude.m4])"}, {"sha": "fe964a6ef4e5f3bf0bb72fb389d88f9baba51eda", "filename": "zlib/adler32.c", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fadler32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fadler32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fadler32.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,13 +1,14 @@\n /* adler32.c -- compute the Adler-32 checksum of a data stream\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /* @(#) $Id: adler32.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */\n \n+#define ZLIB_INTERNAL\n #include \"zlib.h\"\n \n-#define BASE 65521L /* largest prime smaller than 65536 */\n+#define BASE 65521UL    /* largest prime smaller than 65536 */\n #define NMAX 5552\n /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */\n \n@@ -17,6 +18,31 @@\n #define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);\n #define DO16(buf)   DO8(buf,0); DO8(buf,8);\n \n+#ifdef NO_DIVIDE\n+#  define MOD(a) \\\n+    do { \\\n+        if (a >= (BASE << 16)) a -= (BASE << 16); \\\n+        if (a >= (BASE << 15)) a -= (BASE << 15); \\\n+        if (a >= (BASE << 14)) a -= (BASE << 14); \\\n+        if (a >= (BASE << 13)) a -= (BASE << 13); \\\n+        if (a >= (BASE << 12)) a -= (BASE << 12); \\\n+        if (a >= (BASE << 11)) a -= (BASE << 11); \\\n+        if (a >= (BASE << 10)) a -= (BASE << 10); \\\n+        if (a >= (BASE << 9)) a -= (BASE << 9); \\\n+        if (a >= (BASE << 8)) a -= (BASE << 8); \\\n+        if (a >= (BASE << 7)) a -= (BASE << 7); \\\n+        if (a >= (BASE << 6)) a -= (BASE << 6); \\\n+        if (a >= (BASE << 5)) a -= (BASE << 5); \\\n+        if (a >= (BASE << 4)) a -= (BASE << 4); \\\n+        if (a >= (BASE << 3)) a -= (BASE << 3); \\\n+        if (a >= (BASE << 2)) a -= (BASE << 2); \\\n+        if (a >= (BASE << 1)) a -= (BASE << 1); \\\n+        if (a >= BASE) a -= BASE; \\\n+    } while (0)\n+#else\n+#  define MOD(a) a %= BASE\n+#endif\n+\n /* ========================================================================= */\n uLong ZEXPORT adler32(adler, buf, len)\n     uLong adler;\n@@ -30,19 +56,19 @@ uLong ZEXPORT adler32(adler, buf, len)\n     if (buf == Z_NULL) return 1L;\n \n     while (len > 0) {\n-        k = len < NMAX ? len : NMAX;\n+        k = len < NMAX ? (int)len : NMAX;\n         len -= k;\n         while (k >= 16) {\n             DO16(buf);\n-\t    buf += 16;\n+            buf += 16;\n             k -= 16;\n         }\n         if (k != 0) do {\n             s1 += *buf++;\n-\t    s2 += s1;\n+            s2 += s1;\n         } while (--k);\n-        s1 %= BASE;\n-        s2 %= BASE;\n+        MOD(s1);\n+        MOD(s2);\n     }\n     return (s2 << 16) | s1;\n }"}, {"sha": "b022dde312a1139fde1d9c0ec90c9640108d9645", "filename": "zlib/algorithm.txt", "status": "modified", "additions": 51, "deletions": 55, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Falgorithm.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Falgorithm.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Falgorithm.txt?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -59,10 +59,10 @@ but saves time since there are both fewer insertions and fewer searches.\n \n 2.1 Introduction\n \n-The real question is, given a Huffman tree, how to decode fast.  The most\n-important realization is that shorter codes are much more common than\n-longer codes, so pay attention to decoding the short codes fast, and let\n-the long codes take longer to decode.\n+The key question is how to represent a Huffman code (or any prefix code) so\n+that you can decode fast.  The most important characteristic is that shorter\n+codes are much more common than longer codes, so pay attention to decoding the\n+short codes fast, and let the long codes take longer to decode.\n \n inflate() sets up a first level table that covers some number of bits of\n input less than the length of longest code.  It gets that many bits from the\n@@ -77,58 +77,54 @@ table took no time (and if you had infinite memory), then there would only\n be a first level table to cover all the way to the longest code.  However,\n building the table ends up taking a lot longer for more bits since short\n codes are replicated many times in such a table.  What inflate() does is\n-simply to make the number of bits in the first table a variable, and set it\n-for the maximum speed.\n-\n-inflate() sends new trees relatively often, so it is possibly set for a\n-smaller first level table than an application that has only one tree for\n-all the data.  For inflate, which has 286 possible codes for the\n-literal/length tree, the size of the first table is nine bits.  Also the\n-distance trees have 30 possible values, and the size of the first table is\n-six bits.  Note that for each of those cases, the table ended up one bit\n-longer than the ``average'' code length, i.e. the code length of an\n-approximately flat code which would be a little more than eight bits for\n-286 symbols and a little less than five bits for 30 symbols.  It would be\n-interesting to see if optimizing the first level table for other\n-applications gave values within a bit or two of the flat code size.\n+simply to make the number of bits in the first table a variable, and  then\n+to set that variable for the maximum speed.\n+\n+For inflate, which has 286 possible codes for the literal/length tree, the size\n+of the first table is nine bits.  Also the distance trees have 30 possible\n+values, and the size of the first table is six bits.  Note that for each of\n+those cases, the table ended up one bit longer than the ``average'' code\n+length, i.e. the code length of an approximately flat code which would be a\n+little more than eight bits for 286 symbols and a little less than five bits\n+for 30 symbols.\n \n \n 2.2 More details on the inflate table lookup\n \n-Ok, you want to know what this cleverly obfuscated inflate tree actually  \n-looks like.  You are correct that it's not a Huffman tree.  It is simply a  \n-lookup table for the first, let's say, nine bits of a Huffman symbol.  The  \n-symbol could be as short as one bit or as long as 15 bits.  If a particular  \n+Ok, you want to know what this cleverly obfuscated inflate tree actually\n+looks like.  You are correct that it's not a Huffman tree.  It is simply a\n+lookup table for the first, let's say, nine bits of a Huffman symbol.  The\n+symbol could be as short as one bit or as long as 15 bits.  If a particular\n symbol is shorter than nine bits, then that symbol's translation is duplicated\n-in all those entries that start with that symbol's bits.  For example, if the  \n-symbol is four bits, then it's duplicated 32 times in a nine-bit table.  If a  \n+in all those entries that start with that symbol's bits.  For example, if the\n+symbol is four bits, then it's duplicated 32 times in a nine-bit table.  If a\n symbol is nine bits long, it appears in the table once.\n \n-If the symbol is longer than nine bits, then that entry in the table points  \n-to another similar table for the remaining bits.  Again, there are duplicated  \n+If the symbol is longer than nine bits, then that entry in the table points\n+to another similar table for the remaining bits.  Again, there are duplicated\n entries as needed.  The idea is that most of the time the symbol will be short\n-and there will only be one table look up.  (That's whole idea behind data  \n-compression in the first place.)  For the less frequent long symbols, there  \n-will be two lookups.  If you had a compression method with really long  \n-symbols, you could have as many levels of lookups as is efficient.  For  \n+and there will only be one table look up.  (That's whole idea behind data\n+compression in the first place.)  For the less frequent long symbols, there\n+will be two lookups.  If you had a compression method with really long\n+symbols, you could have as many levels of lookups as is efficient.  For\n inflate, two is enough.\n \n-So a table entry either points to another table (in which case nine bits in  \n-the above example are gobbled), or it contains the translation for the symbol  \n-and the number of bits to gobble.  Then you start again with the next  \n+So a table entry either points to another table (in which case nine bits in\n+the above example are gobbled), or it contains the translation for the symbol\n+and the number of bits to gobble.  Then you start again with the next\n ungobbled bit.\n \n-You may wonder: why not just have one lookup table for how ever many bits the  \n-longest symbol is?  The reason is that if you do that, you end up spending  \n-more time filling in duplicate symbol entries than you do actually decoding.   \n-At least for deflate's output that generates new trees every several 10's of  \n-kbytes.  You can imagine that filling in a 2^15 entry table for a 15-bit code  \n-would take too long if you're only decoding several thousand symbols.  At the  \n+You may wonder: why not just have one lookup table for how ever many bits the\n+longest symbol is?  The reason is that if you do that, you end up spending\n+more time filling in duplicate symbol entries than you do actually decoding.\n+At least for deflate's output that generates new trees every several 10's of\n+kbytes.  You can imagine that filling in a 2^15 entry table for a 15-bit code\n+would take too long if you're only decoding several thousand symbols.  At the\n other extreme, you could make a new table for every bit in the code.  In fact,\n-that's essentially a Huffman tree.  But then you spend two much time  \n+that's essentially a Huffman tree.  But then you spend two much time\n traversing the tree while decoding, even for short symbols.\n \n-So the number of bits for the first lookup table is a trade of the time to  \n+So the number of bits for the first lookup table is a trade of the time to\n fill out the table vs. the time spent looking at the second level and above of\n the table.\n \n@@ -158,7 +154,7 @@ Let's make the first table three bits long (eight entries):\n 110: -> table X (gobble 3 bits)\n 111: -> table Y (gobble 3 bits)\n \n-Each entry is what the bits decode to and how many bits that is, i.e. how  \n+Each entry is what the bits decode as and how many bits that is, i.e. how\n many bits to gobble.  Or the entry points to another table, with the number of\n bits to gobble implicit in the size of the table.\n \n@@ -170,7 +166,7 @@ long:\n 10: D,2\n 11: E,2\n \n-Table Y is three bits long since the longest code starting with 111 is six  \n+Table Y is three bits long since the longest code starting with 111 is six\n bits long:\n \n 000: F,2\n@@ -182,20 +178,20 @@ bits long:\n 110: I,3\n 111: J,3\n \n-So what we have here are three tables with a total of 20 entries that had to  \n-be constructed.  That's compared to 64 entries for a single table.  Or  \n-compared to 16 entries for a Huffman tree (six two entry tables and one four  \n-entry table).  Assuming that the code ideally represents the probability of  \n+So what we have here are three tables with a total of 20 entries that had to\n+be constructed.  That's compared to 64 entries for a single table.  Or\n+compared to 16 entries for a Huffman tree (six two entry tables and one four\n+entry table).  Assuming that the code ideally represents the probability of\n the symbols, it takes on the average 1.25 lookups per symbol.  That's compared\n-to one lookup for the single table, or 1.66 lookups per symbol for the  \n+to one lookup for the single table, or 1.66 lookups per symbol for the\n Huffman tree.\n \n-There, I think that gives you a picture of what's going on.  For inflate, the  \n-meaning of a particular symbol is often more than just a letter.  It can be a  \n-byte (a \"literal\"), or it can be either a length or a distance which  \n-indicates a base value and a number of bits to fetch after the code that is  \n-added to the base value.  Or it might be the special end-of-block code.  The  \n-data structures created in inftrees.c try to encode all that information  \n+There, I think that gives you a picture of what's going on.  For inflate, the\n+meaning of a particular symbol is often more than just a letter.  It can be a\n+byte (a \"literal\"), or it can be either a length or a distance which\n+indicates a base value and a number of bits to fetch after the code that is\n+added to the base value.  Or it might be the special end-of-block code.  The\n+data structures created in inftrees.c try to encode all that information\n compactly in the tables.\n \n \n@@ -210,4 +206,4 @@ Compression,'' IEEE Transactions on Information Theory, Vol. 23, No. 3,\n pp. 337-343.\n \n ``DEFLATE Compressed Data Format Specification'' available in\n-ftp://ds.internic.net/rfc/rfc1951.txt\n+http://www.ietf.org/rfc/rfc1951.txt"}, {"sha": "3f7e15537f1bb03e5d89a7e42dd6fdd71d7f3055", "filename": "zlib/amiga/Makefile.pup", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Famiga%2FMakefile.pup", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Famiga%2FMakefile.pup", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Famiga%2FMakefile.pup?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -2,65 +2,65 @@\n # makefile for libpng and SAS C V6.58/7.00 PPC compiler\n # Copyright (C) 1998 by Andreas R. Kleinert\n \n-CC       = scppc\n-CFLAGS   = NOSTKCHK NOSINT OPTIMIZE OPTGO OPTPEEP OPTINLOCAL OPTINL \\\n-           OPTLOOP OPTRDEP=8 OPTDEP=8 OPTCOMP=8\n-LIBNAME  = libzip.a\n-AR       = ppc-amigaos-ar\n-AR_FLAGS = cr\n-RANLIB   = ppc-amigaos-ranlib\n-LDFLAGS  = -r -o\n-LDLIBS   = LIB:scppc.a\n-LN       = ppc-amigaos-ld\n-RM       = delete quiet\n+LIBNAME\t= libzip.a\n+\n+CC\t= scppc\n+CFLAGS\t= NOSTKCHK NOSINT OPTIMIZE OPTGO OPTPEEP OPTINLOCAL OPTINL \\\n+\t  OPTLOOP OPTRDEP=8 OPTDEP=8 OPTCOMP=8 NOVER\n+AR\t= ppc-amigaos-ar cr\n+RANLIB\t= ppc-amigaos-ranlib\n+LD\t= ppc-amigaos-ld -r\n+LDFLAGS\t= -o\n+LDLIBS\t= LIB:scppc.a LIB:end.o\n+RM\t= delete quiet\n \n OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n-       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+       zutil.o inflate.o infback.o inftrees.o inffast.o\n \n TEST_OBJS = example.o minigzip.o\n \n all: example minigzip\n \n+check: test\n test: all\n-        example\n-        echo hello world | minigzip | minigzip -d\n+\texample\n+\techo hello world | minigzip | minigzip -d\n \n $(LIBNAME): $(OBJS)\n-            $(AR) $(AR_FLAGS) $@ $(OBJS)\n-            $(RANLIB) $@\n+\t$(AR) $@ $(OBJS)\n+\t-$(RANLIB) $@\n \n example: example.o $(LIBNAME)\n-        $(LN) $(LDFLAGS) example LIB:c_ppc.o example.o $(LIBNAME) $(LDLIBS) LIB:end.o\n+\t$(LD) $(LDFLAGS) $@ LIB:c_ppc.o $@.o $(LIBNAME) $(LDLIBS)\n \n minigzip: minigzip.o $(LIBNAME)\n-        $(LN) $(LDFLAGS) minigzip LIB:c_ppc.o minigzip.o $(LIBNAME) $(LDLIBS) LIB:end.o\n+\t$(LD) $(LDFLAGS) $@ LIB:c_ppc.o $@.o $(LIBNAME) $(LDLIBS)\n \n+mostlyclean: clean\n clean:\n-        $(RM) *.o example minigzip $(LIBNAME) foo.gz\n+\t$(RM) *.o example minigzip $(LIBNAME) foo.gz\n \n zip:\n-        zip -ul9 zlib README ChangeLog Makefile Make????.??? Makefile.?? \\\n-          descrip.mms *.[ch]\n+\tzip -ul9 zlib README ChangeLog Makefile Make????.??? Makefile.?? \\\n+\t  descrip.mms *.[ch]\n \n tgz:\n-        cd ..; tar cfz zlib/zlib.tgz zlib/README zlib/ChangeLog zlib/Makefile \\\n-          zlib/Make????.??? zlib/Makefile.?? zlib/descrip.mms zlib/*.[ch]\n+\tcd ..; tar cfz zlib/zlib.tgz zlib/README zlib/ChangeLog zlib/Makefile \\\n+\t  zlib/Make????.??? zlib/Makefile.?? zlib/descrip.mms zlib/*.[ch]\n \n # DO NOT DELETE THIS LINE -- make depend depends on it.\n \n-adler32.o: zutil.h zlib.h zconf.h\n+adler32.o: zlib.h zconf.h\n compress.o: zlib.h zconf.h\n-crc32.o: zutil.h zlib.h zconf.h\n+crc32.o: crc32.h zlib.h zconf.h\n deflate.o: deflate.h zutil.h zlib.h zconf.h\n example.o: zlib.h zconf.h\n gzio.o: zutil.h zlib.h zconf.h\n-infblock.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n-infcodes.o: zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h\n-inffast.o: zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n-inflate.o: zutil.h zlib.h zconf.h infblock.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n+infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n-infutil.o: zutil.h zlib.h zconf.h inftrees.h infutil.h\n minigzip.o: zlib.h zconf.h\n-trees.o: deflate.h zutil.h zlib.h zconf.h\n+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h\n uncompr.o: zlib.h zconf.h\n zutil.o: zutil.h zlib.h zconf.h"}, {"sha": "d6842b89c33b96773e84f55321122de9f3461e79", "filename": "zlib/amiga/Makefile.sas", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Famiga%2FMakefile.sas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Famiga%2FMakefile.sas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Famiga%2FMakefile.sas?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -10,22 +10,24 @@ CFLAGS=OPT\n LDFLAGS=LIB z.lib\n \n SCOPTIONS=OPTSCHED OPTINLINE OPTALIAS OPTTIME OPTINLOCAL STRMERGE \\\n-       NOICONS PARMS=BOTH NOSTACKCHECK UTILLIB NOVERSION ERRORREXX \n+       NOICONS PARMS=BOTH NOSTACKCHECK UTILLIB NOVERSION ERRORREXX \\\n+       DEF=POSTINC\n \n OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n-       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+       zutil.o inflate.o infback.o inftrees.o inffast.o\n \n TEST_OBJS = example.o minigzip.o\n \n all: SCOPTIONS example minigzip\n \n+check: test\n test: all\n-\t`cd`/example\n+\texample\n \techo hello world | minigzip | minigzip -d \n \n install: z.lib\n-\tcopy zlib.h zconf.h INCLUDE: clone\n-\tcopy z.lib LIB: clone\n+\tcopy clone zlib.h zconf.h INCLUDE:\n+\tcopy clone z.lib LIB:\n \n z.lib: $(OBJS)\n \toml z.lib r $(OBJS)\n@@ -36,29 +38,28 @@ example: example.o z.lib\n minigzip: minigzip.o z.lib\n \t$(CC) $(CFLAGS) LINK TO $@ minigzip.o $(LDFLAGS)\n \n+mostlyclean: clean\n clean:\n-\t-delete force quiet *.o example minigzip z.lib foo.gz *.lnk SCOPTIONS\n+\t-delete force quiet example minigzip *.o z.lib foo.gz *.lnk SCOPTIONS\n \n-SCOPTIONS: Smakefile\n-        copy to $@ <from <\n+SCOPTIONS: Makefile.sas\n+\tcopy to $@ <from <\n $(SCOPTIONS)\n <\n \n # DO NOT DELETE THIS LINE -- make depend depends on it.\n \n-adler32.o: zutil.h zlib.h zconf.h\n+adler32.o: zlib.h zconf.h\n compress.o: zlib.h zconf.h\n-crc32.o: zutil.h zlib.h zconf.h\n+crc32.o: crc32.h zlib.h zconf.h\n deflate.o: deflate.h zutil.h zlib.h zconf.h\n example.o: zlib.h zconf.h\n gzio.o: zutil.h zlib.h zconf.h\n-infblock.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n-infcodes.o: zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h\n-inffast.o: zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n-inflate.o: zutil.h zlib.h zconf.h infblock.h\n+inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n+inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n+infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h\n inftrees.o: zutil.h zlib.h zconf.h inftrees.h\n-infutil.o: zutil.h zlib.h zconf.h inftrees.h infutil.h\n minigzip.o: zlib.h zconf.h\n-trees.o: deflate.h zutil.h zlib.h zconf.h\n+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h\n uncompr.o: zlib.h zconf.h\n zutil.o: zutil.h zlib.h zconf.h"}, {"sha": "4e035d0322f6a93d928d5c7a112685a45247b735", "filename": "zlib/compress.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcompress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcompress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcompress.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,10 +1,11 @@\n /* compress.c -- compress a memory buffer\n  * Copyright (C) 1995-2002 Jean-loup Gailly.\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /* @(#) $Id: compress.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */\n \n+#define ZLIB_INTERNAL\n #include \"zlib.h\"\n \n /* ===========================================================================\n@@ -66,3 +67,13 @@ int ZEXPORT compress (dest, destLen, source, sourceLen)\n {\n     return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);\n }\n+\n+/* ===========================================================================\n+     If the default memLevel or windowBits for deflateInit() is changed, then\n+   this function needs to be updated.\n+ */\n+uLong ZEXPORT compressBound (sourceLen)\n+    uLong sourceLen;\n+{\n+    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + 11;\n+}"}, {"sha": "eb43ffe0a6bc7c2bd2b6ec70436d19a8e406feb2", "filename": "zlib/configure", "status": "modified", "additions": 72, "deletions": 51, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fconfigure?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -309,7 +309,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os mkinstalldirs INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT COMPPATH CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS LN_S RANLIB ac_ct_RANLIB LIBTOOL CPP CPPFLAGS EGREP target_all toolexecdir toolexeclibdir TARGET_LIBRARY_TRUE TARGET_LIBRARY_FALSE LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os mkinstalldirs INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT COMPPATH CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CFLAGS LN_S RANLIB ac_ct_RANLIB LIBTOOL CPP CPPFLAGS EGREP target_all toolexecdir toolexeclibdir TARGET_LIBRARY_TRUE TARGET_LIBRARY_FALSE LIBOBJS LTLIBOBJS'\n ac_subst_files=''\n \n # Initialize some variables set by options.\n@@ -958,7 +958,7 @@ esac\n     else\n       echo \"$as_me: WARNING: no configuration information is in $ac_dir\" >&2\n     fi\n-    cd \"$ac_popdir\"\n+    cd $ac_popdir\n   done\n fi\n \n@@ -1452,7 +1452,7 @@ test -n \"$target_alias\" &&\n mkinstalldirs=\"`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs\"\n \n \n-am__api_version=\"1.8\"\n+am__api_version=\"1.9\"\n # Find a good install program.  We prefer a C program (faster),\n # so one script is as good as another.  But avoid the broken or\n # incompatible versions:\n@@ -1604,13 +1604,21 @@ echo \"$as_me: WARNING: \\`missing' script is too old or missing\" >&2;}\n fi\n \n if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then\n-  # Keeping the `.' argument allows $(mkdir_p) to be used without\n-  # argument.  Indeed, we sometimes output rules like\n+  # We used to keeping the `.' as first argument, in order to\n+  # allow $(mkdir_p) to be used without argument.  As in\n   #   $(mkdir_p) $(somedir)\n-  # where $(somedir) is conditionally defined.\n-  # (`test -n '$(somedir)' && $(mkdir_p) $(somedir)' is a more\n-  # expensive solution, as it forces Make to start a sub-shell.)\n-  mkdir_p='mkdir -p -- .'\n+  # where $(somedir) is conditionally defined.  However this is wrong\n+  # for two reasons:\n+  #  1. if the package is installed by a user who cannot write `.'\n+  #     make install will fail,\n+  #  2. the above comment should most certainly read\n+  #     $(mkdir_p) $(DESTDIR)$(somedir)\n+  #     so it does not work when $(somedir) is undefined and\n+  #     $(DESTDIR) is not.\n+  #  To support the latter case, we have to write\n+  #     test -z \"$(somedir)\" || $(mkdir_p) $(DESTDIR)$(somedir),\n+  #  so the `.' trick is pointless.\n+  mkdir_p='mkdir -p --'\n else\n   # On NextStep and OpenStep, the `mkdir' command does not\n   # recognize any option.  It will interpret all options as\n@@ -1754,9 +1762,6 @@ AUTOHEADER=${AUTOHEADER-\"${am_missing_run}autoheader\"}\n \n MAKEINFO=${MAKEINFO-\"${am_missing_run}makeinfo\"}\n \n-\n-AMTAR=${AMTAR-\"${am_missing_run}tar\"}\n-\n install_sh=${install_sh-\"$am_aux_dir/install-sh\"}\n \n # Installed binaries are usually stripped using `strip' when the user\n@@ -1849,6 +1854,13 @@ INSTALL_STRIP_PROGRAM=\"\\${SHELL} \\$(install_sh) -c -s\"\n \n # We need awk for the \"check\" target.  The system \"awk\" is bad on\n # some platforms.\n+# Always define AMTAR for backward compatibility.\n+\n+AMTAR=${AMTAR-\"${am_missing_run}tar\"}\n+\n+am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'\n+\n+\n \n \n \n@@ -2531,7 +2543,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2589,7 +2602,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2705,7 +2719,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2759,7 +2774,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2804,7 +2820,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2848,7 +2865,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -3807,7 +3825,7 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 3810 \"configure\"' > conftest.$ac_ext\n+  echo '#line 3828 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -3954,7 +3972,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -4409,7 +4428,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -4579,7 +4599,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -4647,7 +4668,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -4836,7 +4858,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5119,7 +5142,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5196,7 +5220,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5268,7 +5293,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -6135,7 +6161,6 @@ s,@AUTOCONF@,$AUTOCONF,;t t\n s,@AUTOMAKE@,$AUTOMAKE,;t t\n s,@AUTOHEADER@,$AUTOHEADER,;t t\n s,@MAKEINFO@,$MAKEINFO,;t t\n-s,@AMTAR@,$AMTAR,;t t\n s,@install_sh@,$install_sh,;t t\n s,@STRIP@,$STRIP,;t t\n s,@ac_ct_STRIP@,$ac_ct_STRIP,;t t\n@@ -6144,6 +6169,9 @@ s,@mkdir_p@,$mkdir_p,;t t\n s,@AWK@,$AWK,;t t\n s,@SET_MAKE@,$SET_MAKE,;t t\n s,@am__leading_dot@,$am__leading_dot,;t t\n+s,@AMTAR@,$AMTAR,;t t\n+s,@am__tar@,$am__tar,;t t\n+s,@am__untar@,$am__untar,;t t\n s,@MAINTAINER_MODE_TRUE@,$MAINTAINER_MODE_TRUE,;t t\n s,@MAINTAINER_MODE_FALSE@,$MAINTAINER_MODE_FALSE,;t t\n s,@MAINT@,$MAINT,;t t\n@@ -6342,6 +6370,11 @@ esac\n   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;\n   esac\n \n+  if test x\"$ac_file\" != x-; then\n+    { echo \"$as_me:$LINENO: creating $ac_file\" >&5\n+echo \"$as_me: creating $ac_file\" >&6;}\n+    rm -f \"$ac_file\"\n+  fi\n   # Let's still pretend it is `configure' which instantiates (i.e., don't\n   # use $as_me), people would be surprised to read:\n   #    /* config.h.  Generated by config.status.  */\n@@ -6380,12 +6413,6 @@ echo \"$as_me: error: cannot find input file: $f\" >&2;}\n \t fi;;\n       esac\n     done` || { (exit 1); exit 1; }\n-\n-  if test x\"$ac_file\" != x-; then\n-    { echo \"$as_me:$LINENO: creating $ac_file\" >&5\n-echo \"$as_me: creating $ac_file\" >&6;}\n-    rm -f \"$ac_file\"\n-  fi\n _ACEOF\n cat >>$CONFIG_STATUS <<_ACEOF\n   sed \"$ac_vpsub\n@@ -6562,27 +6589,21 @@ echo X\"$mf\" |\n   else\n     continue\n   fi\n-  grep '^DEP_FILES *= *[^ #]' < \"$mf\" > /dev/null || continue\n-  # Extract the definition of DEP_FILES from the Makefile without\n-  # running `make'.\n+  # Extract the definition of DEPDIR, am__include, and am__quote\n+  # from the Makefile without running `make'.\n   DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n   test -z \"$DEPDIR\" && continue\n+  am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+  test -z \"am__include\" && continue\n+  am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n   # When using ansi2knr, U may be empty or an underscore; expand it\n   U=`sed -n 's/^U = //p' < \"$mf\"`\n-  test -d \"$dirpart/$DEPDIR\" || mkdir \"$dirpart/$DEPDIR\"\n-  # We invoke sed twice because it is the simplest approach to\n-  # changing $(DEPDIR) to its actual value in the expansion.\n-  for file in `sed -n '\n-    /^DEP_FILES = .*\\\\\\\\$/ {\n-      s/^DEP_FILES = //\n-      :loop\n-\ts/\\\\\\\\$//\n-\tp\n-\tn\n-\t/\\\\\\\\$/ b loop\n-      p\n-    }\n-    /^DEP_FILES = / s/^DEP_FILES = //p' < \"$mf\" | \\\n+  # Find all dependency output files, they are included files with\n+  # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+  # simplest approach to changing $(DEPDIR) to its actual value in the\n+  # expansion.\n+  for file in `sed -n \"\n+    s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n        sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n     # Make sure the directory exists.\n     test -f \"$dirpart/$file\" && continue"}, {"sha": "8860f31e527cfb54b8e967de3345da92bc6da226", "filename": "zlib/contrib/README.contrib", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2FREADME.contrib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2FREADME.contrib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2FREADME.contrib?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -4,31 +4,67 @@ Use at your own risk. Please contact the authors of the contributions\n for help about these, not the zlib authors. Thanks.\n \n \n-asm386/     by Gilles Vollant <info@winimage.com>\n-\t386 asm code replacing longest_match(), for Visual C++ 4.2 and ML 6.11c\n+ada/        by Dmitriy Anisimkov <anisimkov@yahoo.com>\n+        Support for Ada\n+        See http://zlib-ada.sourceforge.net/\n \n-asm586/ and asm686/    by Brian Raiter <breadbox@muppetlabs.com> \n-        asm code for Pentium and Pentium Pro\n+asm586/\n+asm686/     by Brian Raiter <breadbox@muppetlabs.com>\n+        asm code for Pentium and PPro/PII, using the AT&T (GNU as) syntax\n         See http://www.muppetlabs.com/~breadbox/software/assembly.html\n \n-delphi/      by Bob Dellaca <bobdl@xtra.co.nz>\n-\tSupport for Delphi\n+blast/      by Mark Adler <madler@alumni.caltech.edu>\n+        Decompressor for output of PKWare Data Compression Library (DCL)\n \n-delphi2/     by Davide Moretti <dave@rimini.com>\n-        Another support for C++Builder and Delphi\n+delphi/     by Cosmin Truta <cosmint@cs.ubbcluj.ro>\n+        Support for Delphi and C++ Builder\n \n-minizip/    by Gilles Vollant <info@winimage.com>\n-\tMini zip and unzip based on zlib\n-        See http://www.winimage.com/zLibDll/unzip.html\n+gzappend/   by Mark Adler <madler@alumni.caltech.edu>\n+        append to a gzip file -- illustrates the use of Z_BLOCK\n+\n+infback9/   by Mark Adler <madler@alumni.caltech.edu>\n+        Unsupported diffs to infback to decode the deflate64 format\n+\n+inflate86/  by Chris Anderson <christop@charm.net>\n+        Tuned x86 gcc asm code to replace inflate_fast()\n \n iostream/   by Kevin Ruland <kevin@rodin.wustl.edu>\n         A C++ I/O streams interface to the zlib gz* functions\n \n iostream2/  by Tyge L\ufffdvset <Tyge.Lovset@cmr.no>\n-\tAnother C++ I/O streams interface\n+        Another C++ I/O streams interface\n+\n+iostream3/  by Ludwig Schwardt <schwardt@sun.ac.za>\n+            and Kevin Ruland <kevin@rodin.wustl.edu>\n+        Yet another C++ I/O streams interface\n+\n+masm686/    by Dan Higdon <hdan@kinesoft.com>\n+            and Chuck Walbourn <chuckw@kinesoft.com>\n+        asm code for Pentium Pro/PII, using the MASM syntax\n+\n+masmx86/    by Gilles Vollant <info@winimage.com>\n+        x86 asm code to replace longest_match() and inflate_fast(),\n+        for Visual C++ and MASM\n+\n+minizip/    by Gilles Vollant <info@winimage.com>\n+        Mini zip and unzip based on zlib\n+        See http://www.winimage.com/zLibDll/unzip.html\n+\n+pascal/     by Bob Dellaca <bobdl@xtra.co.nz> et al.\n+        Support for Pascal\n+\n+puff/       by Mark Adler <madler@alumni.caltech.edu>\n+        Small, low memory usage inflate.  Also serves to provide an\n+        unambiguous description of the deflate format.\n+\n+testzlib/   by Gilles Vollant <info@winimage.com>\n+        Example of the use of zlib\n \n untgz/      by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n-\tA very simple tar.gz file extractor using zlib\n+        A very simple tar.gz file extractor using zlib\n \n visual-basic.txt by Carlos Rios <c_rios@sonda.cl>\n-        How to use compress(), uncompress() and the gz* functions from VB.\n+        How to use compress(), uncompress() and the gz* functions from VB\n+\n+vstudio/    by Gilles Vollant <info@winimage.com>\n+        Building zlib with Visual Studio .NET"}, {"sha": "28d527f47f885e4cd957e1c2559f0ef74697b5cd", "filename": "zlib/contrib/asm386/gvmat32.asm", "status": "removed", "additions": 0, "deletions": 559, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fgvmat32.asm?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,559 +0,0 @@\n-;\n-; gvmat32.asm -- Asm portion of the optimized longest_match for 32 bits x86\n-; Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\n-; File written by Gilles Vollant, by modifiying the longest_match\n-;  from Jean-loup Gailly in deflate.c\n-; It need wmask == 0x7fff\n-;     (assembly code is faster with a fixed wmask)\n-;\n-; For Visual C++ 4.2 and ML 6.11c (version in directory \\MASM611C of Win95 DDK)\n-;   I compile with : \"ml /coff /Zi /c gvmat32.asm\"\n-;\n-\n-;uInt longest_match_7fff(s, cur_match)\n-;    deflate_state *s;\n-;    IPos cur_match;                             /* current match */\n-\n-        NbStack         equ     76\n-        cur_match       equ     dword ptr[esp+NbStack-0]\n-        str_s           equ     dword ptr[esp+NbStack-4]\n-; 5 dword on top (ret,ebp,esi,edi,ebx)\n-        adrret          equ     dword ptr[esp+NbStack-8]\n-        pushebp         equ     dword ptr[esp+NbStack-12]\n-        pushedi         equ     dword ptr[esp+NbStack-16]\n-        pushesi         equ     dword ptr[esp+NbStack-20]\n-        pushebx         equ     dword ptr[esp+NbStack-24]\n-\n-        chain_length    equ     dword ptr [esp+NbStack-28]\n-        limit           equ     dword ptr [esp+NbStack-32]\n-        best_len        equ     dword ptr [esp+NbStack-36]\n-        window          equ     dword ptr [esp+NbStack-40]\n-        prev            equ     dword ptr [esp+NbStack-44]\n-        scan_start      equ      word ptr [esp+NbStack-48]\n-        wmask           equ     dword ptr [esp+NbStack-52]\n-        match_start_ptr equ     dword ptr [esp+NbStack-56]\n-        nice_match      equ     dword ptr [esp+NbStack-60]\n-        scan            equ     dword ptr [esp+NbStack-64]\n-\n-        windowlen       equ     dword ptr [esp+NbStack-68]\n-        match_start     equ     dword ptr [esp+NbStack-72]\n-        strend          equ     dword ptr [esp+NbStack-76]\n-        NbStackAdd      equ     (NbStack-24)\n-\n-    .386p\n-\n-    name    gvmatch\n-    .MODEL  FLAT\n-\n-\n-\n-;  all the +4 offsets are due to the addition of pending_buf_size (in zlib\n-;  in the deflate_state structure since the asm code was first written\n-;  (if you compile with zlib 1.0.4 or older, remove the +4).\n-;  Note : these value are good with a 8 bytes boundary pack structure\n-    dep_chain_length    equ     70h+4\n-    dep_window          equ     2ch+4\n-    dep_strstart        equ     60h+4\n-    dep_prev_length     equ     6ch+4\n-    dep_nice_match      equ     84h+4\n-    dep_w_size          equ     20h+4\n-    dep_prev            equ     34h+4\n-    dep_w_mask          equ     28h+4\n-    dep_good_match      equ     80h+4\n-    dep_match_start     equ     64h+4\n-    dep_lookahead       equ     68h+4\n-\n-\n-_TEXT                   segment\n-\n-IFDEF NOUNDERLINE\n-                        public  longest_match_7fff\n-;                        public  match_init\n-ELSE\n-                        public  _longest_match_7fff\n-;                        public  _match_init\n-ENDIF\n-\n-    MAX_MATCH           equ     258\n-    MIN_MATCH           equ     3\n-    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)\n-\n-\n-\n-IFDEF NOUNDERLINE\n-;match_init      proc near\n-;                ret\n-;match_init      endp\n-ELSE\n-;_match_init     proc near\n-;                ret\n-;_match_init     endp\n-ENDIF\n-\n-\n-IFDEF NOUNDERLINE\n-longest_match_7fff   proc near\n-ELSE\n-_longest_match_7fff  proc near\n-ENDIF\n-\n-        mov     edx,[esp+4]\n-\n-\n-\n-        push    ebp\n-        push    edi\n-        push    esi\n-        push    ebx\n-\n-        sub     esp,NbStackAdd\n-\n-; initialize or check the variables used in match.asm.\n-        mov     ebp,edx\n-\n-; chain_length = s->max_chain_length\n-; if (prev_length>=good_match) chain_length >>= 2\n-        mov     edx,[ebp+dep_chain_length]\n-        mov     ebx,[ebp+dep_prev_length]\n-        cmp     [ebp+dep_good_match],ebx\n-        ja      noshr\n-        shr     edx,2\n-noshr:\n-; we increment chain_length because in the asm, the --chain_lenght is in the beginning of the loop\n-        inc     edx\n-        mov     edi,[ebp+dep_nice_match]\n-        mov     chain_length,edx\n-        mov     eax,[ebp+dep_lookahead]\n-        cmp     eax,edi\n-; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n-        jae     nolookaheadnicematch\n-        mov     edi,eax\n-nolookaheadnicematch:\n-; best_len = s->prev_length\n-        mov     best_len,ebx\n-\n-; window = s->window\n-        mov     esi,[ebp+dep_window]\n-        mov     ecx,[ebp+dep_strstart]\n-        mov     window,esi\n-\n-        mov     nice_match,edi\n-; scan = window + strstart\n-        add     esi,ecx\n-        mov     scan,esi\n-; dx = *window\n-        mov     dx,word ptr [esi]\n-; bx = *(window+best_len-1)\n-        mov     bx,word ptr [esi+ebx-1]\n-        add     esi,MAX_MATCH-1\n-; scan_start = *scan\n-        mov     scan_start,dx\n-; strend = scan + MAX_MATCH-1\n-        mov     strend,esi\n-; bx = scan_end = *(window+best_len-1)\n-\n-;    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n-;        s->strstart - (IPos)MAX_DIST(s) : NIL;\n-\n-        mov     esi,[ebp+dep_w_size]\n-        sub     esi,MIN_LOOKAHEAD\n-; here esi = MAX_DIST(s)\n-        sub     ecx,esi\n-        ja      nodist\n-        xor     ecx,ecx\n-nodist:\n-        mov     limit,ecx\n-\n-; prev = s->prev\n-        mov     edx,[ebp+dep_prev]\n-        mov     prev,edx\n-\n-;\n-        mov     edx,dword ptr [ebp+dep_match_start]\n-        mov     bp,scan_start\n-        mov     eax,cur_match\n-        mov     match_start,edx\n-\n-        mov     edx,window\n-        mov     edi,edx\n-        add     edi,best_len\n-        mov     esi,prev\n-        dec     edi\n-; windowlen = window + best_len -1\n-        mov     windowlen,edi\n-\n-        jmp     beginloop2\n-        align   4\n-\n-; here, in the loop\n-;       eax = ax = cur_match\n-;       ecx = limit\n-;        bx = scan_end\n-;        bp = scan_start\n-;       edi = windowlen (window + best_len -1)\n-;       esi = prev\n-\n-\n-;// here; chain_length <=16\n-normalbeg0add16:\n-        add     chain_length,16\n-        jz      exitloop\n-normalbeg0:\n-        cmp     word ptr[edi+eax],bx\n-        je      normalbeg2noroll\n-rcontlabnoroll:\n-; cur_match = prev[cur_match & wmask]\n-        and     eax,7fffh\n-        mov     ax,word ptr[esi+eax*2]\n-; if cur_match > limit, go to exitloop\n-        cmp     ecx,eax\n-        jnb     exitloop\n-; if --chain_length != 0, go to exitloop\n-        dec     chain_length\n-        jnz     normalbeg0\n-        jmp     exitloop\n-\n-normalbeg2noroll:\n-; if (scan_start==*(cur_match+window)) goto normalbeg2\n-        cmp     bp,word ptr[edx+eax]\n-        jne     rcontlabnoroll\n-        jmp     normalbeg2\n-\n-contloop3:\n-        mov     edi,windowlen\n-\n-; cur_match = prev[cur_match & wmask]\n-        and     eax,7fffh\n-        mov     ax,word ptr[esi+eax*2]\n-; if cur_match > limit, go to exitloop\n-        cmp     ecx,eax\n-jnbexitloopshort1:\n-        jnb     exitloop\n-; if --chain_length != 0, go to exitloop\n-\n-\n-; begin the main loop\n-beginloop2:\n-        sub     chain_length,16+1\n-; if chain_length <=16, don't use the unrolled loop\n-        jna     normalbeg0add16\n-\n-do16:\n-        cmp     word ptr[edi+eax],bx\n-        je      normalbeg2dc0\n-\n-maccn   MACRO   lab\n-        and     eax,7fffh\n-        mov     ax,word ptr[esi+eax*2]\n-        cmp     ecx,eax\n-        jnb     exitloop\n-        cmp     word ptr[edi+eax],bx\n-        je      lab\n-        ENDM\n-\n-rcontloop0:\n-        maccn   normalbeg2dc1\n-\n-rcontloop1:\n-        maccn   normalbeg2dc2\n-\n-rcontloop2:\n-        maccn   normalbeg2dc3\n-\n-rcontloop3:\n-        maccn   normalbeg2dc4\n-\n-rcontloop4:\n-        maccn   normalbeg2dc5\n-\n-rcontloop5:\n-        maccn   normalbeg2dc6\n-\n-rcontloop6:\n-        maccn   normalbeg2dc7\n-\n-rcontloop7:\n-        maccn   normalbeg2dc8\n-\n-rcontloop8:\n-        maccn   normalbeg2dc9\n-\n-rcontloop9:\n-        maccn   normalbeg2dc10\n-\n-rcontloop10:\n-        maccn   short normalbeg2dc11\n-\n-rcontloop11:\n-        maccn   short normalbeg2dc12\n-\n-rcontloop12:\n-        maccn   short normalbeg2dc13\n-\n-rcontloop13:\n-        maccn   short normalbeg2dc14\n-\n-rcontloop14:\n-        maccn   short normalbeg2dc15\n-\n-rcontloop15:\n-        and     eax,7fffh\n-        mov     ax,word ptr[esi+eax*2]\n-        cmp     ecx,eax\n-        jnb     exitloop\n-\n-        sub     chain_length,16\n-        ja      do16\n-        jmp     normalbeg0add16\n-\n-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n-\n-normbeg MACRO   rcontlab,valsub\n-; if we are here, we know that *(match+best_len-1) == scan_end\n-        cmp     bp,word ptr[edx+eax]\n-; if (match != scan_start) goto rcontlab\n-        jne     rcontlab\n-; calculate the good chain_length, and we'll compare scan and match string\n-        add     chain_length,16-valsub\n-        jmp     iseq\n-        ENDM\n-\n-\n-normalbeg2dc11:\n-        normbeg rcontloop11,11\n-\n-normalbeg2dc12:\n-        normbeg short rcontloop12,12\n-\n-normalbeg2dc13:\n-        normbeg short rcontloop13,13\n-\n-normalbeg2dc14:\n-        normbeg short rcontloop14,14\n-\n-normalbeg2dc15:\n-        normbeg short rcontloop15,15\n-\n-normalbeg2dc10:\n-        normbeg rcontloop10,10\n-\n-normalbeg2dc9:\n-        normbeg rcontloop9,9\n-\n-normalbeg2dc8:\n-        normbeg rcontloop8,8\n-\n-normalbeg2dc7:\n-        normbeg rcontloop7,7\n-\n-normalbeg2dc6:\n-        normbeg rcontloop6,6\n-\n-normalbeg2dc5:\n-        normbeg rcontloop5,5\n-\n-normalbeg2dc4:\n-        normbeg rcontloop4,4\n-\n-normalbeg2dc3:\n-        normbeg rcontloop3,3\n-\n-normalbeg2dc2:\n-        normbeg rcontloop2,2\n-\n-normalbeg2dc1:\n-        normbeg rcontloop1,1\n-\n-normalbeg2dc0:\n-        normbeg rcontloop0,0\n-\n-\n-; we go in normalbeg2 because *(ushf*)(match+best_len-1) == scan_end\n-\n-normalbeg2:\n-        mov     edi,window\n-\n-        cmp     bp,word ptr[edi+eax]\n-        jne     contloop3                   ; if *(ushf*)match != scan_start, continue\n-\n-iseq:\n-; if we are here, we know that *(match+best_len-1) == scan_end\n-; and (match == scan_start)\n-\n-        mov     edi,edx\n-        mov     esi,scan                    ; esi = scan\n-        add     edi,eax                     ; edi = window + cur_match = match\n-\n-        mov     edx,[esi+3]                 ; compare manually dword at match+3\n-        xor     edx,[edi+3]                 ; and scan +3\n-\n-        jz      begincompare                ; if equal, go to long compare\n-\n-; we will determine the unmatch byte and calculate len (in esi)\n-        or      dl,dl\n-        je      eq1rr\n-        mov     esi,3\n-        jmp     trfinval\n-eq1rr:\n-        or      dx,dx\n-        je      eq1\n-\n-        mov     esi,4\n-        jmp     trfinval\n-eq1:\n-        and     edx,0ffffffh\n-        jz      eq11\n-        mov     esi,5\n-        jmp     trfinval\n-eq11:\n-        mov     esi,6\n-        jmp     trfinval\n-\n-begincompare:\n-        ; here we now scan and match begin same\n-        add     edi,6\n-        add     esi,6\n-        mov     ecx,(MAX_MATCH-(2+4))/4     ; scan for at most MAX_MATCH bytes\n-        repe    cmpsd                       ; loop until mismatch\n-\n-        je      trfin                       ; go to trfin if not unmatch\n-; we determine the unmatch byte\n-        sub     esi,4\n-        mov     edx,[edi-4]\n-        xor     edx,[esi]\n-\n-        or      dl,dl\n-        jnz     trfin\n-        inc     esi\n-\n-        or      dx,dx\n-        jnz     trfin\n-        inc     esi\n-\n-        and     edx,0ffffffh\n-        jnz     trfin\n-        inc     esi\n-\n-trfin:\n-        sub     esi,scan          ; esi = len\n-trfinval:\n-; here we have finised compare, and esi contain len of equal string\n-        cmp     esi,best_len        ; if len > best_len, go newbestlen\n-        ja      short newbestlen\n-; now we restore edx, ecx and esi, for the big loop\n-        mov     esi,prev\n-        mov     ecx,limit\n-        mov     edx,window\n-        jmp     contloop3\n-\n-newbestlen:\n-        mov     best_len,esi        ; len become best_len\n-\n-        mov     match_start,eax     ; save new position as match_start\n-        cmp     esi,nice_match      ; if best_len >= nice_match, exit\n-        jae     exitloop\n-        mov     ecx,scan\n-        mov     edx,window          ; restore edx=window\n-        add     ecx,esi\n-        add     esi,edx\n-\n-        dec     esi\n-        mov     windowlen,esi       ; windowlen = window + best_len-1\n-        mov     bx,[ecx-1]          ; bx = *(scan+best_len-1) = scan_end\n-\n-; now we restore ecx and esi, for the big loop :\n-        mov     esi,prev\n-        mov     ecx,limit\n-        jmp     contloop3\n-\n-exitloop:\n-; exit : s->match_start=match_start\n-        mov     ebx,match_start\n-        mov     ebp,str_s\n-        mov     ecx,best_len\n-        mov     dword ptr [ebp+dep_match_start],ebx        \n-        mov     eax,dword ptr [ebp+dep_lookahead]\n-        cmp     ecx,eax\n-        ja      minexlo\n-        mov     eax,ecx\n-minexlo:\n-; return min(best_len,s->lookahead)\n-        \n-; restore stack and register ebx,esi,edi,ebp\n-        add     esp,NbStackAdd\n-\n-        pop     ebx\n-        pop     esi\n-        pop     edi\n-        pop     ebp\n-        ret\n-InfoAuthor:\n-; please don't remove this string !\n-; Your are free use gvmat32 in any fre or commercial apps if you don't remove the string in the binary!\n-        db     0dh,0ah,\"GVMat32 optimised assembly code written 1996-98 by Gilles Vollant\",0dh,0ah\n-\n-\n-\n-IFDEF NOUNDERLINE\n-longest_match_7fff   endp\n-ELSE\n-_longest_match_7fff  endp\n-ENDIF\n-\n-\n-IFDEF NOUNDERLINE\n-cpudetect32     proc near\n-ELSE\n-_cpudetect32    proc near\n-ENDIF\n-\n-\n-\tpushfd                  ; push original EFLAGS\n-\tpop     eax             ; get original EFLAGS\n-\tmov     ecx, eax        ; save original EFLAGS\n-\txor     eax, 40000h     ; flip AC bit in EFLAGS\n-\tpush    eax             ; save new EFLAGS value on stack\n-\tpopfd                   ; replace current EFLAGS value\n-\tpushfd                  ; get new EFLAGS\n-\tpop     eax             ; store new EFLAGS in EAX\n-\txor     eax, ecx        ; can\ufffdt toggle AC bit, processor=80386\n-\tjz      end_cpu_is_386  ; jump if 80386 processor\n-\tpush    ecx\n-\tpopfd                   ; restore AC bit in EFLAGS first\n-\n-\tpushfd\n-\tpushfd\n-\tpop     ecx\n-\t\t\t\n-\tmov     eax, ecx        ; get original EFLAGS\n-\txor     eax, 200000h    ; flip ID bit in EFLAGS\n-\tpush    eax             ; save new EFLAGS value on stack\n-\tpopfd                   ; replace current EFLAGS value\n-\tpushfd                  ; get new EFLAGS\n-\tpop\t\teax\t            ; store new EFLAGS in EAX\n-\tpopfd                   ; restore original EFLAGS\n-\txor\t\teax, ecx        ; can\ufffdt toggle ID bit,\n-\tje\t\tis_old_486\t\t; processor=old\n-\n-\tmov     eax,1\n-\tdb      0fh,0a2h        ;CPUID   \n-\n-exitcpudetect:\n-\tret\n-\n-end_cpu_is_386:\n-\tmov     eax,0300h\n-\tjmp     exitcpudetect\n-\n-is_old_486:\n-\tmov     eax,0400h\n-\tjmp     exitcpudetect\n-\n-IFDEF NOUNDERLINE\n-cpudetect32     endp\n-ELSE\n-_cpudetect32    endp\n-ENDIF\n-\n-_TEXT   ends\n-end"}, {"sha": "d853bb7ce8ab0b2b4a5aa37fc6ee567e6650bc78", "filename": "zlib/contrib/asm386/gvmat32c.c", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fgvmat32c.c?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,200 +0,0 @@\n-/* gvmat32.c -- C portion of the optimized longest_match for 32 bits x86\n- * Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.\n- * File written by Gilles Vollant, by modifiying the longest_match\n- *  from Jean-loup Gailly in deflate.c\n- *  it prepare all parameters and call the assembly longest_match_gvasm\n- *  longest_match execute standard C code is wmask != 0x7fff\n- *     (assembly code is faster with a fixed wmask)\n- *\n- */\n-\n-#include \"deflate.h\"\n-\n-#undef FAR\n-#include <windows.h>\n-\n-#ifdef ASMV\n-#define NIL 0\n-\n-#define UNALIGNED_OK\n-\n-\n-/* if your C compiler don't add underline before function name,\n-\t\tdefine ADD_UNDERLINE_ASMFUNC */\n-#ifdef ADD_UNDERLINE_ASMFUNC\n-#define longest_match_7fff _longest_match_7fff\n-#endif\n-\n-\n-\n-void match_init()\n-{\n-}\n-\n-unsigned long cpudetect32();\n-\n-uInt longest_match_c(\n-    deflate_state *s,\n-    IPos cur_match);                             /* current match */\n-\n-\n-uInt longest_match_7fff(\n-    deflate_state *s,\n-    IPos cur_match);                             /* current match */\n-\n-uInt longest_match(\n-    deflate_state *s,\n-    IPos cur_match)                             /* current match */\n-{\n-\tstatic uInt iIsPPro=2;\n-\n-    if ((s->w_mask == 0x7fff) && (iIsPPro==0))\n-        return longest_match_7fff(s,cur_match);\n-\n-\tif (iIsPPro==2)\n-\t\tiIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;\n-\n-\treturn longest_match_c(s,cur_match);\n-}\n-\n-\n-\n-uInt longest_match_c(s, cur_match)\n-    deflate_state *s;\n-    IPos cur_match;                             /* current match */\n-{\n-    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n-    register Bytef *scan = s->window + s->strstart; /* current string */\n-    register Bytef *match;                       /* matched string */\n-    register int len;                           /* length of current match */\n-    int best_len = s->prev_length;              /* best match length so far */\n-    int nice_match = s->nice_match;             /* stop if match long enough */\n-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n-        s->strstart - (IPos)MAX_DIST(s) : NIL;\n-    /* Stop when cur_match becomes <= limit. To simplify the code,\n-     * we prevent matches with the string of window index 0.\n-     */\n-    Posf *prev = s->prev;\n-    uInt wmask = s->w_mask;\n-\n-#ifdef UNALIGNED_OK\n-    /* Compare two bytes at a time. Note: this is not always beneficial.\n-     * Try with and without -DUNALIGNED_OK to check.\n-     */\n-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n-    register ush scan_start = *(ushf*)scan;\n-    register ush scan_end   = *(ushf*)(scan+best_len-1);\n-#else\n-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n-    register Byte scan_end1  = scan[best_len-1];\n-    register Byte scan_end   = scan[best_len];\n-#endif\n-\n-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n-     * It is easy to get rid of this optimization if necessary.\n-     */\n-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n-\n-    /* Do not waste too much time if we already have a good match: */\n-    if (s->prev_length >= s->good_match) {\n-        chain_length >>= 2;\n-    }\n-    /* Do not look for matches beyond the end of the input. This is necessary\n-     * to make deflate deterministic.\n-     */\n-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n-\n-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n-\n-    do {\n-        Assert(cur_match < s->strstart, \"no future\");\n-        match = s->window + cur_match;\n-\n-        /* Skip to next match if the match length cannot increase\n-         * or if the match length is less than 2:\n-         */\n-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n-        /* This code assumes sizeof(unsigned short) == 2. Do not use\n-         * UNALIGNED_OK if your compiler uses a different size.\n-         */\n-        if (*(ushf*)(match+best_len-1) != scan_end ||\n-            *(ushf*)match != scan_start) continue;\n-\n-        /* It is not necessary to compare scan[2] and match[2] since they are\n-         * always equal when the other bytes match, given that the hash keys\n-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n-         * strstart+3, +5, ... up to strstart+257. We check for insufficient\n-         * lookahead only every 4th comparison; the 128th check will be made\n-         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is\n-         * necessary to put more guard bytes at the end of the window, or\n-         * to check more often for insufficient lookahead.\n-         */\n-        Assert(scan[2] == match[2], \"scan[2]?\");\n-        scan++, match++;\n-        do {\n-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&\n-                 scan < strend);\n-        /* The funny \"do {}\" generates better code on most compilers */\n-\n-        /* Here, scan <= window+strstart+257 */\n-        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n-        if (*scan == *match) scan++;\n-\n-        len = (MAX_MATCH - 1) - (int)(strend-scan);\n-        scan = strend - (MAX_MATCH-1);\n-\n-#else /* UNALIGNED_OK */\n-\n-        if (match[best_len]   != scan_end  ||\n-            match[best_len-1] != scan_end1 ||\n-            *match            != *scan     ||\n-            *++match          != scan[1])      continue;\n-\n-        /* The check at best_len-1 can be removed because it will be made\n-         * again later. (This heuristic is not always a win.)\n-         * It is not necessary to compare scan[2] and match[2] since they\n-         * are always equal when the other bytes match, given that\n-         * the hash keys are equal and that HASH_BITS >= 8.\n-         */\n-        scan += 2, match++;\n-        Assert(*scan == *match, \"match[2]?\");\n-\n-        /* We check for insufficient lookahead only every 8th comparison;\n-         * the 256th check will be made at strstart+258.\n-         */\n-        do {\n-        } while (*++scan == *++match && *++scan == *++match &&\n-                 *++scan == *++match && *++scan == *++match &&\n-                 *++scan == *++match && *++scan == *++match &&\n-                 *++scan == *++match && *++scan == *++match &&\n-                 scan < strend);\n-\n-        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n-\n-        len = MAX_MATCH - (int)(strend - scan);\n-        scan = strend - MAX_MATCH;\n-\n-#endif /* UNALIGNED_OK */\n-\n-        if (len > best_len) {\n-            s->match_start = cur_match;\n-            best_len = len;\n-            if (len >= nice_match) break;\n-#ifdef UNALIGNED_OK\n-            scan_end = *(ushf*)(scan+best_len-1);\n-#else\n-            scan_end1  = scan[best_len-1];\n-            scan_end   = scan[best_len];\n-#endif\n-        }\n-    } while ((cur_match = prev[cur_match & wmask]) > limit\n-             && --chain_length != 0);\n-\n-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n-    return s->lookahead;\n-}\n-\n-#endif /* ASMV */"}, {"sha": "6c5ffd7a024f70e7166474beabfc6710cbe38199", "filename": "zlib/contrib/asm386/mkgvmt32.bat", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fmkgvmt32.bat?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1 +0,0 @@\n-c:\\masm611\\bin\\ml /coff /Zi /c /Flgvmat32.lst gvmat32.asm"}, {"sha": "7e9d60d55d90d410e2d4b519f8bcfeb36027081c", "filename": "zlib/contrib/asm386/zlibvc.def", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.def?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,74 +0,0 @@\n-LIBRARY\t\t\"zlib\"\n-\n-DESCRIPTION\t'\"\"\"zlib data compression library\"\"\"'\n-\n-\n-VERSION\t\t1.11\n-\n-\n-HEAPSIZE\t1048576,8192\n-\n-EXPORTS\n-    adler32                        @1\n-    compress                       @2\n-    crc32                          @3\n-    deflate                        @4\n-    deflateCopy                    @5\n-    deflateEnd                     @6\n-    deflateInit2_                  @7\n-    deflateInit_                   @8\n-    deflateParams                  @9\n-    deflateReset                   @10\n-    deflateSetDictionary           @11\n-    gzclose                        @12\n-    gzdopen                        @13\n-    gzerror                        @14\n-    gzflush                        @15\n-    gzopen                         @16\n-    gzread                         @17\n-    gzwrite                        @18\n-    inflate                        @19\n-    inflateEnd                     @20\n-    inflateInit2_                  @21\n-    inflateInit_                   @22\n-    inflateReset                   @23\n-    inflateSetDictionary           @24\n-    inflateSync                    @25\n-    uncompress                     @26\n-    zlibVersion                    @27\n-    gzprintf                       @28\n-    gzputc                         @29\n-    gzgetc                         @30\n-    gzseek                         @31\n-    gzrewind                       @32\n-    gztell                         @33\n-    gzeof                          @34\n-    gzsetparams                    @35\n-    zError                         @36\n-    inflateSyncPoint               @37\n-    get_crc_table                  @38\n-    compress2                      @39\n-    gzputs                         @40\n-    gzgets                         @41\n-\n-\tunzOpen                       @61\n-\tunzClose                      @62\n-\tunzGetGlobalInfo              @63\n-\tunzGetCurrentFileInfo         @64\n-\tunzGoToFirstFile              @65\n-\tunzGoToNextFile               @66\n-\tunzOpenCurrentFile            @67\n-\tunzReadCurrentFile            @68\n-\tunztell                       @70\n-\tunzeof                        @71\n-\tunzCloseCurrentFile           @72\n-\tunzGetGlobalComment           @73\n-\tunzStringFileNameCompare      @74\n-\tunzLocateFile                 @75\n-\tunzGetLocalExtrafield         @76\n-\n-\tzipOpen                       @80\n-\tzipOpenNewFileInZip           @81\n-\tzipWriteInFileInZip           @82\n-\tzipCloseFileInZip             @83\n-\tzipClose                      @84"}, {"sha": "a70d4d4a6b0ec6ad54f2966c42b445e9b8ded02b", "filename": "zlib/contrib/asm386/zlibvc.dsp", "status": "removed", "additions": 0, "deletions": 651, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsp?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,651 +0,0 @@\n-# Microsoft Developer Studio Project File - Name=\"zlibvc\" - Package Owner=<4>\n-# Microsoft Developer Studio Generated Build File, Format Version 5.00\n-# ** DO NOT EDIT **\n-\n-# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n-# TARGTYPE \"Win32 (ALPHA) Dynamic-Link Library\" 0x0602\n-\n-CFG=zlibvc - Win32 Release\n-!MESSAGE This is not a valid makefile. To build this project using NMAKE,\n-!MESSAGE use the Export Makefile command and run\n-!MESSAGE \n-!MESSAGE NMAKE /f \"zlibvc.mak\".\n-!MESSAGE \n-!MESSAGE You can specify a configuration when running NMAKE\n-!MESSAGE by defining the macro CFG on the command line. For example:\n-!MESSAGE \n-!MESSAGE NMAKE /f \"zlibvc.mak\" CFG=\"zlibvc - Win32 Release\"\n-!MESSAGE \n-!MESSAGE Possible choices for configuration are:\n-!MESSAGE \n-!MESSAGE \"zlibvc - Win32 Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \"zlibvc - Win32 Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \"zlibvc - Win32 ReleaseAxp\" (based on\\\n- \"Win32 (ALPHA) Dynamic-Link Library\")\n-!MESSAGE \"zlibvc - Win32 ReleaseWithoutAsm\" (based on\\\n- \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \"zlibvc - Win32 ReleaseWithoutCrtdll\" (based on\\\n- \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \n-\n-# Begin Project\n-# PROP Scc_ProjName \"\"\n-# PROP Scc_LocalPath \"\"\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \".\\Release\"\n-# PROP BASE Intermediate_Dir \".\\Release\"\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \".\\Release\"\n-# PROP Intermediate_Dir \".\\Release\"\n-# PROP Ignore_Export_Lib 0\n-# PROP Target_Dir \"\"\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /FD /c\n-# SUBTRACT CPP /YX\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n-# ADD RSC /l 0x40c /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n-# ADD LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n-# SUBTRACT LINK32 /pdb:none\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 1\n-# PROP BASE Output_Dir \".\\Debug\"\n-# PROP BASE Intermediate_Dir \".\\Debug\"\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 1\n-# PROP Output_Dir \".\\Debug\"\n-# PROP Intermediate_Dir \".\\Debug\"\n-# PROP Target_Dir \"\"\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /FD /c\n-# SUBTRACT CPP /YX\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n-# ADD MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"_DEBUG\"\n-# ADD RSC /l 0x40c /d \"_DEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:\".\\Debug\\zlib.dll\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"zlibvc__\"\n-# PROP BASE Intermediate_Dir \"zlibvc__\"\n-# PROP BASE Ignore_Export_Lib 0\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"zlibvc__\"\n-# PROP Intermediate_Dir \"zlibvc__\"\n-# PROP Ignore_Export_Lib 0\n-# PROP Target_Dir \"\"\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /Gt0 /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /YX /FD /c\n-# ADD CPP /nologo /MT /Gt0 /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /FD /c\n-# SUBTRACT CPP /YX\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n-# ADD RSC /l 0x40c /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 crtdll.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /map /machine:ALPHA /nodefaultlib /out:\".\\Release\\zlib.dll\"\n-# SUBTRACT BASE LINK32 /pdb:none\n-# ADD LINK32 crtdll.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /map /machine:ALPHA /nodefaultlib /out:\"zlibvc__\\zlib.dll\"\n-# SUBTRACT LINK32 /pdb:none\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"zlibvc_0\"\n-# PROP BASE Intermediate_Dir \"zlibvc_0\"\n-# PROP BASE Ignore_Export_Lib 0\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"zlibvc_0\"\n-# PROP Intermediate_Dir \"zlibvc_0\"\n-# PROP Ignore_Export_Lib 0\n-# PROP Target_Dir \"\"\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /YX /FD /c\n-# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /FD /c\n-# SUBTRACT CPP /YX\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n-# ADD RSC /l 0x40c /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n-# SUBTRACT BASE LINK32 /pdb:none\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\zlibvc_0\\zlib.dll\"\n-# SUBTRACT LINK32 /pdb:none\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"zlibvc_1\"\n-# PROP BASE Intermediate_Dir \"zlibvc_1\"\n-# PROP BASE Ignore_Export_Lib 0\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"zlibvc_1\"\n-# PROP Intermediate_Dir \"zlibvc_1\"\n-# PROP Ignore_Export_Lib 0\n-# PROP Target_Dir \"\"\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /YX /FD /c\n-# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /FD /c\n-# SUBTRACT CPP /YX\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n-# ADD RSC /l 0x40c /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n-# SUBTRACT BASE LINK32 /pdb:none\n-# ADD LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\zlibvc_1\\zlib.dll\"\n-# SUBTRACT LINK32 /pdb:none\n-\n-!ENDIF \n-\n-# Begin Target\n-\n-# Name \"zlibvc - Win32 Release\"\n-# Name \"zlibvc - Win32 Debug\"\n-# Name \"zlibvc - Win32 ReleaseAxp\"\n-# Name \"zlibvc - Win32 ReleaseWithoutAsm\"\n-# Name \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-# Begin Group \"Source Files\"\n-\n-# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90\"\n-# Begin Source File\n-\n-SOURCE=.\\adler32.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_ADLER=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\compress.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_COMPR=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\crc32.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_CRC32=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\deflate.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_DEFLA=\\\n-\t\".\\deflate.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\gvmat32c.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\gzio.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_GZIO_=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infblock.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFBL=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\infcodes.h\"\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\infutil.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infcodes.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFCO=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\infcodes.h\"\\\n-\t\".\\inffast.h\"\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\infutil.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inffast.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFFA=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\infcodes.h\"\\\n-\t\".\\inffast.h\"\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\infutil.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inflate.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFLA=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inftrees.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFTR=\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infutil.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFUT=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\infcodes.h\"\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\infutil.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\trees.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_TREES=\\\n-\t\".\\deflate.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\uncompr.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_UNCOM=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\unzip.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zip.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zlib.rc\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zlibvc.def\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zutil.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_ZUTIL=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# End Group\n-# Begin Group \"Header Files\"\n-\n-# PROP Default_Filter \"h;hpp;hxx;hm;inl;fi;fd\"\n-# Begin Source File\n-\n-SOURCE=.\\deflate.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infblock.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infcodes.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inffast.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inftrees.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infutil.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zconf.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zlib.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zutil.h\n-# End Source File\n-# End Group\n-# Begin Group \"Resource Files\"\n-\n-# PROP Default_Filter \"ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe\"\n-# End Group\n-# End Target\n-# End Project"}, {"sha": "493cd870365a5cfb7e0725656d66c3b1d0b3dd21", "filename": "zlib/contrib/asm386/zlibvc.dsw", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fasm386%2Fzlibvc.dsw?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,41 +0,0 @@\n-Microsoft Developer Studio Workspace File, Format Version 5.00\n-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!\n-\n-###############################################################################\n-\n-Project: \"zlibstat\"=.\\zlibstat.dsp - Package Owner=<4>\n-\n-Package=<5>\n-{{{\n-}}}\n-\n-Package=<4>\n-{{{\n-}}}\n-\n-###############################################################################\n-\n-Project: \"zlibvc\"=.\\zlibvc.dsp - Package Owner=<4>\n-\n-Package=<5>\n-{{{\n-}}}\n-\n-Package=<4>\n-{{{\n-}}}\n-\n-###############################################################################\n-\n-Global:\n-\n-Package=<5>\n-{{{\n-}}}\n-\n-Package=<3>\n-{{{\n-}}}\n-\n-###############################################################################\n-"}, {"sha": "ba557e2b9772c764ca04ecbc368932b4f64336dd", "filename": "zlib/contrib/delphi/zlib.mak", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi%2Fzlib.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi%2Fzlib.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2Fzlib.mak?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,36 +0,0 @@\n-# Makefile for zlib32bd.lib\n-# ------------- Borland C++ 4.5 -------------\n-\n-# The (32-bit) zlib32bd.lib made with this makefile is intended for use \n-# in making the (32-bit) DLL, png32bd.dll. It uses the \"stdcall\" calling \n-# convention.\n-\n-CFLAGS= -ps -O2 -C -K -N- -k- -d -3 -r- -w-par -w-aus -WDE\n-CC=f:\\bc45\\bin\\bcc32\n-LIBFLAGS= /C\n-LIB=f:\\bc45\\bin\\tlib\n-ZLIB=zlib32bd.lib\n-\n-.autodepend\n-.c.obj:\n-        $(CC) -c $(CFLAGS) $<\n-\n-OBJ1=adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infblock.obj \n-OBJ2=infcodes.obj inflate.obj inftrees.obj infutil.obj inffast.obj \n-OBJ3=trees.obj uncompr.obj zutil.obj\n-pOBJ1=+adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infblock.obj \n-pOBJ2=+infcodes.obj+inflate.obj+inftrees.obj+infutil.obj+inffast.obj \n-pOBJ3=+trees.obj+uncompr.obj+zutil.obj\n-\n-all: $(ZLIB)\n-\n-$(ZLIB): $(OBJ1) $(OBJ2) $(OBJ3)\n-        @if exist $@ del $@\n-        $(LIB) @&&|\n-$@ $(LIBFLAGS) &\n-$(pOBJ1) &\n-$(pOBJ2) &\n-$(pOBJ3)\n-|\n-\n-# End of makefile for zlib32bd.lib"}, {"sha": "4f96b7d2c5045360b06cd45ccf04b742a895b5eb", "filename": "zlib/contrib/delphi/zlibdef.pas", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi%2Fzlibdef.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi%2Fzlibdef.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi%2Fzlibdef.pas?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,169 +0,0 @@\n-unit zlibdef;\n-\n-interface\n-\n-uses\n-  Windows;\n-\n-const\n-  ZLIB_VERSION = '1.1.3';\n-\n-type\n-  voidpf = Pointer;\n-  int    = Integer;\n-  uInt   = Cardinal;\n-  pBytef = PChar;\n-  uLong  = Cardinal;\n-\n-  alloc_func = function(opaque: voidpf; items, size: uInt): voidpf;\n-                    stdcall;\n-  free_func  = procedure(opaque, address: voidpf);\n-                    stdcall;\n-\n-  internal_state = Pointer;\n-\n-  z_streamp = ^z_stream;\n-  z_stream = packed record\n-    next_in: pBytef;          // next input byte\n-    avail_in: uInt;           // number of bytes available at next_in\n-    total_in: uLong;          // total nb of input bytes read so far\n-\n-    next_out: pBytef;         // next output byte should be put there\n-    avail_out: uInt;          // remaining free space at next_out\n-    total_out: uLong;         // total nb of bytes output so far\n-\n-    msg: PChar;               // last error message, NULL if no error\n-    state: internal_state;    // not visible by applications\n-\n-    zalloc: alloc_func;       // used to allocate the internal state\n-    zfree: free_func;         // used to free the internal state\n-    opaque: voidpf;           // private data object passed to zalloc and zfree\n-\n-    data_type: int;           // best guess about the data type: ascii or binary\n-    adler: uLong;             // adler32 value of the uncompressed data\n-    reserved: uLong;          // reserved for future use\n-    end;\n-\n-const\n-  Z_NO_FLUSH      = 0;\n-  Z_SYNC_FLUSH    = 2;\n-  Z_FULL_FLUSH    = 3;\n-  Z_FINISH        = 4;\n-\n-  Z_OK            = 0;\n-  Z_STREAM_END    = 1;\n-\n-  Z_NO_COMPRESSION         =  0;\n-  Z_BEST_SPEED             =  1;\n-  Z_BEST_COMPRESSION       =  9;\n-  Z_DEFAULT_COMPRESSION    = -1;\n-\n-  Z_FILTERED            = 1;\n-  Z_HUFFMAN_ONLY        = 2;\n-  Z_DEFAULT_STRATEGY    = 0;\n-\n-  Z_BINARY   = 0;\n-  Z_ASCII    = 1;\n-  Z_UNKNOWN  = 2;\n-\n-  Z_DEFLATED    = 8;\n-\n-  MAX_MEM_LEVEL = 9;\n-\n-function adler32(adler: uLong; const buf: pBytef; len: uInt): uLong;\n-             stdcall;\n-function crc32(crc: uLong; const buf: pBytef; len: uInt): uLong;\n-             stdcall;\n-function deflate(strm: z_streamp; flush: int): int;\n-             stdcall;\n-function deflateCopy(dest, source: z_streamp): int;\n-             stdcall;\n-function deflateEnd(strm: z_streamp): int;\n-             stdcall;\n-function deflateInit2_(strm: z_streamp; level, method,\n-                       windowBits, memLevel, strategy: int;\n-                       const version: PChar; stream_size: int): int;\n-             stdcall;\n-function deflateInit_(strm: z_streamp; level: int;\n-                      const version: PChar; stream_size: int): int;\n-             stdcall;\n-function deflateParams(strm: z_streamp; level, strategy: int): int;\n-             stdcall;\n-function deflateReset(strm: z_streamp): int;\n-             stdcall;\n-function deflateSetDictionary(strm: z_streamp;\n-                              const dictionary: pBytef;\n-                              dictLength: uInt): int;\n-             stdcall;\n-function inflate(strm: z_streamp; flush: int): int;\n-             stdcall;\n-function inflateEnd(strm: z_streamp): int;\n-             stdcall;\n-function inflateInit2_(strm: z_streamp; windowBits: int;\n-                       const version: PChar; stream_size: int): int;\n-             stdcall;\n-function inflateInit_(strm: z_streamp; const version: PChar;\n-                      stream_size: int): int;\n-             stdcall;\n-function inflateReset(strm: z_streamp): int;\n-             stdcall;\n-function inflateSetDictionary(strm: z_streamp;\n-                              const dictionary: pBytef;\n-                              dictLength: uInt): int;\n-             stdcall;\n-function inflateSync(strm: z_streamp): int;\n-             stdcall;\n-\n-function deflateInit(strm: z_streamp; level: int): int;\n-function deflateInit2(strm: z_streamp; level, method, windowBits,\n-                      memLevel, strategy: int): int;\n-function inflateInit(strm: z_streamp): int;\n-function inflateInit2(strm: z_streamp; windowBits: int): int;\n-\n-implementation\n-\n-function deflateInit(strm: z_streamp; level: int): int;\n-begin\n-  Result := deflateInit_(strm, level, ZLIB_VERSION, sizeof(z_stream));\n-end;\n-\n-function deflateInit2(strm: z_streamp; level, method, windowBits,\n-                      memLevel, strategy: int): int;\n-begin\n-  Result := deflateInit2_(strm, level, method, windowBits, memLevel,\n-                          strategy, ZLIB_VERSION, sizeof(z_stream));\n-end;\n-\n-function inflateInit(strm: z_streamp): int;\n-begin\n-  Result := inflateInit_(strm, ZLIB_VERSION, sizeof(z_stream));\n-end;\n-\n-function inflateInit2(strm: z_streamp; windowBits: int): int;\n-begin\n-  Result := inflateInit2_(strm, windowBits, ZLIB_VERSION,\n-                          sizeof(z_stream));\n-end;\n-\n-const\n-  zlibDLL = 'png32bd.dll';\n-\n-function adler32; external zlibDLL;\n-function crc32; external zlibDLL;\n-function deflate; external zlibDLL;\n-function deflateCopy; external zlibDLL;\n-function deflateEnd; external zlibDLL;\n-function deflateInit2_; external zlibDLL;\n-function deflateInit_; external zlibDLL;\n-function deflateParams; external zlibDLL;\n-function deflateReset; external zlibDLL;\n-function deflateSetDictionary; external zlibDLL;\n-function inflate; external zlibDLL;\n-function inflateEnd; external zlibDLL;\n-function inflateInit2_; external zlibDLL;\n-function inflateInit_; external zlibDLL;\n-function inflateReset; external zlibDLL;\n-function inflateSetDictionary; external zlibDLL;\n-function inflateSync; external zlibDLL;\n-\n-end."}, {"sha": "78bb254088a5b57eb578afd0fbcd9cbd3963a5b5", "filename": "zlib/contrib/delphi2/d_zlib.bpr", "status": "removed", "additions": 0, "deletions": 224, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.bpr?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,224 +0,0 @@\n-# ---------------------------------------------------------------------------\n-!if !$d(BCB)\n-BCB = $(MAKEDIR)\\..\n-!endif\n-\n-# ---------------------------------------------------------------------------\n-# IDE SECTION\n-# ---------------------------------------------------------------------------\n-# The following section of the project makefile is managed by the BCB IDE.\n-# It is recommended to use the IDE to change any of the values in this\n-# section.\n-# ---------------------------------------------------------------------------\n-\n-VERSION = BCB.03\n-# ---------------------------------------------------------------------------\n-PROJECT = d_zlib.lib\n-OBJFILES = d_zlib.obj adler32.obj deflate.obj infblock.obj infcodes.obj inffast.obj \\\n-  inflate.obj inftrees.obj infutil.obj trees.obj\n-RESFILES =\n-RESDEPEN = $(RESFILES)\n-LIBFILES =\n-LIBRARIES = VCL35.lib\n-SPARELIBS = VCL35.lib\n-DEFFILE =\n-PACKAGES = VCLX35.bpi VCL35.bpi VCLDB35.bpi VCLDBX35.bpi ibsmp35.bpi bcbsmp35.bpi \\\n-  dclocx35.bpi QRPT35.bpi TEEUI35.bpi TEEDB35.bpi TEE35.bpi DSS35.bpi \\\n-  NMFAST35.bpi INETDB35.bpi INET35.bpi VCLMID35.bpi\n-# ---------------------------------------------------------------------------\n-PATHCPP = .;\n-PATHASM = .;\n-PATHPAS = .;\n-PATHRC = .;\n-DEBUGLIBPATH = $(BCB)\\lib\\debug\n-RELEASELIBPATH = $(BCB)\\lib\\release\n-# ---------------------------------------------------------------------------\n-CFLAG1 = -O2 -Ve -d -k- -vi\n-CFLAG2 = -I$(BCB)\\include;$(BCB)\\include\\vcl -H=$(BCB)\\lib\\vcl35.csm\n-CFLAG3 = -ff -pr -5\n-PFLAGS = -U;$(DEBUGLIBPATH) -I$(BCB)\\include;$(BCB)\\include\\vcl -H -W -$I- -v -JPHN -M\n-RFLAGS = -i$(BCB)\\include;$(BCB)\\include\\vcl \n-AFLAGS = /i$(BCB)\\include /i$(BCB)\\include\\vcl /mx /w2 /zn\n-LFLAGS =\n-IFLAGS = -g -Gn\n-# ---------------------------------------------------------------------------\n-ALLOBJ = c0w32.obj $(OBJFILES)\n-ALLRES = $(RESFILES)\n-ALLLIB = $(LIBFILES) $(LIBRARIES) import32.lib cp32mt.lib\n-# ---------------------------------------------------------------------------\n-!!ifdef IDEOPTIONS\n-\n-[Version Info]\n-IncludeVerInfo=0\n-AutoIncBuild=0\n-MajorVer=1\n-MinorVer=0\n-Release=0\n-Build=0\n-Debug=0\n-PreRelease=0\n-Special=0\n-Private=0\n-DLL=0\n-Locale=1040\n-CodePage=1252\n-\n-[Version Info Keys]\n-CompanyName=\n-FileDescription=\n-FileVersion=1.0.0.0\n-InternalName=\n-LegalCopyright=\n-LegalTrademarks=\n-OriginalFilename=\n-ProductName=\n-ProductVersion=1.0.0.0\n-Comments=\n-\n-[HistoryLists\\hlIncludePath]\n-Count=2\n-Item0=$(BCB)\\include\n-Item1=$(BCB)\\include;$(BCB)\\include\\vcl\n-\n-[HistoryLists\\hlLibraryPath]\n-Count=1\n-Item0=$(BCB)\\lib\\obj;$(BCB)\\lib\n-\n-[HistoryLists\\hlDebugSourcePath]\n-Count=1\n-Item0=$(BCB)\\source\\vcl\n-\n-[Debugging]\n-DebugSourceDirs=\n-\n-[Parameters]\n-RunParams=\n-HostApplication=\n-\n-!endif\n-\n- ---------------------------------------------------------------------------\n-# MAKE SECTION\n-# ---------------------------------------------------------------------------\n-# This section of the project file is not used by the BCB IDE.  It is for\n-# the benefit of building from the command-line using the MAKE utility.\n-# ---------------------------------------------------------------------------\n-\n-.autodepend\n-# ---------------------------------------------------------------------------\n-!if !$d(BCC32)\n-BCC32 = bcc32\n-!endif\n-\n-!if !$d(DCC32)\n-DCC32 = dcc32\n-!endif\n-\n-!if !$d(TASM32)\n-TASM32 = tasm32\n-!endif\n-\n-!if !$d(LINKER)\n-LINKER = TLib\n-!endif\n-\n-!if !$d(BRCC32)\n-BRCC32 = brcc32\n-!endif\n-# ---------------------------------------------------------------------------\n-!if $d(PATHCPP)\n-.PATH.CPP = $(PATHCPP)\n-.PATH.C   = $(PATHCPP)\n-!endif\n-\n-!if $d(PATHPAS)\n-.PATH.PAS = $(PATHPAS)\n-!endif\n-\n-!if $d(PATHASM)\n-.PATH.ASM = $(PATHASM)\n-!endif\n-\n-!if $d(PATHRC)\n-.PATH.RC  = $(PATHRC)\n-!endif\n-# ---------------------------------------------------------------------------\n-!ifdef IDEOPTIONS\n-\n-[Version Info]\n-IncludeVerInfo=0\n-AutoIncBuild=0\n-MajorVer=1\n-MinorVer=0\n-Release=0\n-Build=0\n-Debug=0\n-PreRelease=0\n-Special=0\n-Private=0\n-DLL=0\n-Locale=1040\n-CodePage=1252\n-\n-[Version Info Keys]\n-CompanyName=\n-FileDescription=\n-FileVersion=1.0.0.0\n-InternalName=\n-LegalCopyright=\n-LegalTrademarks=\n-OriginalFilename=\n-ProductName=\n-ProductVersion=1.0.0.0\n-Comments=\n-\n-[HistoryLists\\hlIncludePath]\n-Count=2\n-Item0=$(BCB)\\include;$(BCB)\\include\\vcl\n-Item1=$(BCB)\\include\n-\n-[HistoryLists\\hlLibraryPath]\n-Count=1\n-Item0=$(BCB)\\lib\\obj;$(BCB)\\lib\n-\n-[HistoryLists\\hlDebugSourcePath]\n-Count=1\n-Item0=$(BCB)\\source\\vcl\n-\n-[Debugging]\n-DebugSourceDirs=\n-\n-[Parameters]\n-RunParams=\n-HostApplication=\n-\n-!endif\n-\n-$(PROJECT): $(OBJFILES) $(RESDEPEN) $(DEFFILE)\n-    $(BCB)\\BIN\\$(LINKER) @&&!\n-    $(LFLAGS) $(IFLAGS) +\n-    $(ALLOBJ), +\n-    $(PROJECT),, +\n-    $(ALLLIB), +\n-    $(DEFFILE), +\n-    $(ALLRES)\n-!\n-# ---------------------------------------------------------------------------\n-.pas.hpp:\n-    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n-\n-.pas.obj:\n-    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n-\n-.cpp.obj:\n-    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n-\n-.c.obj:\n-    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n-\n-.asm.obj:\n-    $(BCB)\\BIN\\$(TASM32) $(AFLAGS) $<, $@\n-\n-.rc.res:\n-    $(BCB)\\BIN\\$(BRCC32) $(RFLAGS) -fo$@ $<\n-# ---------------------------------------------------------------------------"}, {"sha": "f5dea59b762332ad7f8f875637023b601af6647b", "filename": "zlib/contrib/delphi2/d_zlib.cpp", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fd_zlib.cpp?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,17 +0,0 @@\n-#include <condefs.h>\n-#pragma hdrstop\n-//---------------------------------------------------------------------------\n-USEUNIT(\"adler32.c\");\n-USEUNIT(\"deflate.c\");\n-USEUNIT(\"infblock.c\");\n-USEUNIT(\"infcodes.c\");\n-USEUNIT(\"inffast.c\");\n-USEUNIT(\"inflate.c\");\n-USEUNIT(\"inftrees.c\");\n-USEUNIT(\"infutil.c\");\n-USEUNIT(\"trees.c\");\n-//---------------------------------------------------------------------------\n-#define Library\n-\n-// To add a file to the library use the Project menu 'Add to Project'.\n-"}, {"sha": "cbd31620d87b42a2b58f4cdb81741c10cdbb39bd", "filename": "zlib/contrib/delphi2/readme.txt", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Freadme.txt?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,17 +0,0 @@\n-These are files used to compile zlib under Borland C++ Builder 3.\n-\n-zlib.bpg is the main project group that can be loaded in the BCB IDE and\n-loads all other *.bpr projects\n-\n-zlib.bpr is a project used to create a static zlib.lib library with C calling\n-convention for functions.\n-\n-zlib32.bpr creates a zlib32.dll dynamic link library with Windows standard\n-calling convention.\n-\n-d_zlib.bpr creates a set of .obj files with register calling convention.\n-These files are used by zlib.pas to create a Delphi unit containing zlib.\n-The d_zlib.lib file generated isn't useful and can be deleted.\n-\n-zlib.cpp, zlib32.cpp and d_zlib.cpp are used by the above projects.\n-"}, {"sha": "b6c9acdf8c90fd799ea414d64fc42324fe55e1f4", "filename": "zlib/contrib/delphi2/zlib.bpg", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpg?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,26 +0,0 @@\n-#------------------------------------------------------------------------------\n-VERSION = BWS.01\n-#------------------------------------------------------------------------------\n-!ifndef ROOT\n-ROOT = $(MAKEDIR)\\..\n-!endif\n-#------------------------------------------------------------------------------\n-MAKE = $(ROOT)\\bin\\make.exe -$(MAKEFLAGS) -f$**\n-DCC = $(ROOT)\\bin\\dcc32.exe $**\n-BRCC = $(ROOT)\\bin\\brcc32.exe $**\n-#------------------------------------------------------------------------------\n-PROJECTS = zlib zlib32 d_zlib\n-#------------------------------------------------------------------------------\n-default: $(PROJECTS)\n-#------------------------------------------------------------------------------\n-\n-zlib: zlib.bpr\n-  $(MAKE)\n-\n-zlib32: zlib32.bpr\n-  $(MAKE)\n-\n-d_zlib: d_zlib.bpr\n-  $(MAKE)\n-\n-"}, {"sha": "cf3945b2523339928e570a643b1d866ecf15f6ba", "filename": "zlib/contrib/delphi2/zlib.bpr", "status": "removed", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.bpr?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,225 +0,0 @@\n-# ---------------------------------------------------------------------------\n-!if !$d(BCB)\n-BCB = $(MAKEDIR)\\..\n-!endif\n-\n-# ---------------------------------------------------------------------------\n-# IDE SECTION\n-# ---------------------------------------------------------------------------\n-# The following section of the project makefile is managed by the BCB IDE.\n-# It is recommended to use the IDE to change any of the values in this\n-# section.\n-# ---------------------------------------------------------------------------\n-\n-VERSION = BCB.03\n-# ---------------------------------------------------------------------------\n-PROJECT = zlib.lib\n-OBJFILES = zlib.obj adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infblock.obj \\\n-  infcodes.obj inffast.obj inflate.obj inftrees.obj infutil.obj trees.obj \\\n-  uncompr.obj zutil.obj\n-RESFILES =\n-RESDEPEN = $(RESFILES)\n-LIBFILES =\n-LIBRARIES = VCL35.lib\n-SPARELIBS = VCL35.lib\n-DEFFILE =\n-PACKAGES = VCLX35.bpi VCL35.bpi VCLDB35.bpi VCLDBX35.bpi ibsmp35.bpi bcbsmp35.bpi \\\n-  dclocx35.bpi QRPT35.bpi TEEUI35.bpi TEEDB35.bpi TEE35.bpi DSS35.bpi \\\n-  NMFAST35.bpi INETDB35.bpi INET35.bpi VCLMID35.bpi\n-# ---------------------------------------------------------------------------\n-PATHCPP = .;\n-PATHASM = .;\n-PATHPAS = .;\n-PATHRC = .;\n-DEBUGLIBPATH = $(BCB)\\lib\\debug\n-RELEASELIBPATH = $(BCB)\\lib\\release\n-# ---------------------------------------------------------------------------\n-CFLAG1 = -O2 -Ve -d -k- -vi\n-CFLAG2 = -I$(BCB)\\include;$(BCB)\\include\\vcl -H=$(BCB)\\lib\\vcl35.csm\n-CFLAG3 = -ff -5\n-PFLAGS = -U;$(DEBUGLIBPATH) -I$(BCB)\\include;$(BCB)\\include\\vcl -H -W -$I- -v -JPHN -M\n-RFLAGS = -i$(BCB)\\include;$(BCB)\\include\\vcl \n-AFLAGS = /i$(BCB)\\include /i$(BCB)\\include\\vcl /mx /w2 /zn\n-LFLAGS =\n-IFLAGS = -g -Gn\n-# ---------------------------------------------------------------------------\n-ALLOBJ = c0w32.obj $(OBJFILES)\n-ALLRES = $(RESFILES)\n-ALLLIB = $(LIBFILES) $(LIBRARIES) import32.lib cp32mt.lib\n-# ---------------------------------------------------------------------------\n-!!ifdef IDEOPTIONS\n-\n-[Version Info]\n-IncludeVerInfo=0\n-AutoIncBuild=0\n-MajorVer=1\n-MinorVer=0\n-Release=0\n-Build=0\n-Debug=0\n-PreRelease=0\n-Special=0\n-Private=0\n-DLL=0\n-Locale=1040\n-CodePage=1252\n-\n-[Version Info Keys]\n-CompanyName=\n-FileDescription=\n-FileVersion=1.0.0.0\n-InternalName=\n-LegalCopyright=\n-LegalTrademarks=\n-OriginalFilename=\n-ProductName=\n-ProductVersion=1.0.0.0\n-Comments=\n-\n-[HistoryLists\\hlIncludePath]\n-Count=2\n-Item0=$(BCB)\\include\n-Item1=$(BCB)\\include;$(BCB)\\include\\vcl\n-\n-[HistoryLists\\hlLibraryPath]\n-Count=1\n-Item0=$(BCB)\\lib\\obj;$(BCB)\\lib\n-\n-[HistoryLists\\hlDebugSourcePath]\n-Count=1\n-Item0=$(BCB)\\source\\vcl\n-\n-[Debugging]\n-DebugSourceDirs=\n-\n-[Parameters]\n-RunParams=\n-HostApplication=\n-\n-!endif\n-\n- ---------------------------------------------------------------------------\n-# MAKE SECTION\n-# ---------------------------------------------------------------------------\n-# This section of the project file is not used by the BCB IDE.  It is for\n-# the benefit of building from the command-line using the MAKE utility.\n-# ---------------------------------------------------------------------------\n-\n-.autodepend\n-# ---------------------------------------------------------------------------\n-!if !$d(BCC32)\n-BCC32 = bcc32\n-!endif\n-\n-!if !$d(DCC32)\n-DCC32 = dcc32\n-!endif\n-\n-!if !$d(TASM32)\n-TASM32 = tasm32\n-!endif\n-\n-!if !$d(LINKER)\n-LINKER = TLib\n-!endif\n-\n-!if !$d(BRCC32)\n-BRCC32 = brcc32\n-!endif\n-# ---------------------------------------------------------------------------\n-!if $d(PATHCPP)\n-.PATH.CPP = $(PATHCPP)\n-.PATH.C   = $(PATHCPP)\n-!endif\n-\n-!if $d(PATHPAS)\n-.PATH.PAS = $(PATHPAS)\n-!endif\n-\n-!if $d(PATHASM)\n-.PATH.ASM = $(PATHASM)\n-!endif\n-\n-!if $d(PATHRC)\n-.PATH.RC  = $(PATHRC)\n-!endif\n-# ---------------------------------------------------------------------------\n-!ifdef IDEOPTIONS\n-\n-[Version Info]\n-IncludeVerInfo=0\n-AutoIncBuild=0\n-MajorVer=1\n-MinorVer=0\n-Release=0\n-Build=0\n-Debug=0\n-PreRelease=0\n-Special=0\n-Private=0\n-DLL=0\n-Locale=1040\n-CodePage=1252\n-\n-[Version Info Keys]\n-CompanyName=\n-FileDescription=\n-FileVersion=1.0.0.0\n-InternalName=\n-LegalCopyright=\n-LegalTrademarks=\n-OriginalFilename=\n-ProductName=\n-ProductVersion=1.0.0.0\n-Comments=\n-\n-[HistoryLists\\hlIncludePath]\n-Count=2\n-Item0=$(BCB)\\include;$(BCB)\\include\\vcl\n-Item1=$(BCB)\\include\n-\n-[HistoryLists\\hlLibraryPath]\n-Count=1\n-Item0=$(BCB)\\lib\\obj;$(BCB)\\lib\n-\n-[HistoryLists\\hlDebugSourcePath]\n-Count=1\n-Item0=$(BCB)\\source\\vcl\n-\n-[Debugging]\n-DebugSourceDirs=\n-\n-[Parameters]\n-RunParams=\n-HostApplication=\n-\n-!endif\n-\n-$(PROJECT): $(OBJFILES) $(RESDEPEN) $(DEFFILE)\n-    $(BCB)\\BIN\\$(LINKER) @&&!\n-    $(LFLAGS) $(IFLAGS) +\n-    $(ALLOBJ), +\n-    $(PROJECT),, +\n-    $(ALLLIB), +\n-    $(DEFFILE), +\n-    $(ALLRES)\n-!\n-# ---------------------------------------------------------------------------\n-.pas.hpp:\n-    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n-\n-.pas.obj:\n-    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n-\n-.cpp.obj:\n-    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n-\n-.c.obj:\n-    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n-\n-.asm.obj:\n-    $(BCB)\\BIN\\$(TASM32) $(AFLAGS) $<, $@\n-\n-.rc.res:\n-    $(BCB)\\BIN\\$(BRCC32) $(RFLAGS) -fo$@ $<\n-# ---------------------------------------------------------------------------"}, {"sha": "bf6953ba1985710b5b96db20abdf46d3c12c14d1", "filename": "zlib/contrib/delphi2/zlib.cpp", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.cpp?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,22 +0,0 @@\n-#include <condefs.h>\n-#pragma hdrstop\n-//---------------------------------------------------------------------------\n-USEUNIT(\"adler32.c\");\n-USEUNIT(\"compress.c\");\n-USEUNIT(\"crc32.c\");\n-USEUNIT(\"deflate.c\");\n-USEUNIT(\"gzio.c\");\n-USEUNIT(\"infblock.c\");\n-USEUNIT(\"infcodes.c\");\n-USEUNIT(\"inffast.c\");\n-USEUNIT(\"inflate.c\");\n-USEUNIT(\"inftrees.c\");\n-USEUNIT(\"infutil.c\");\n-USEUNIT(\"trees.c\");\n-USEUNIT(\"uncompr.c\");\n-USEUNIT(\"zutil.c\");\n-//---------------------------------------------------------------------------\n-#define Library\n-\n-// To add a file to the library use the Project menu 'Add to Project'.\n-"}, {"sha": "10ae4cae2568638dfb9c250392da6f3700a5219e", "filename": "zlib/contrib/delphi2/zlib.pas", "status": "removed", "additions": 0, "deletions": 534, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib.pas?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,534 +0,0 @@\n-{*******************************************************}\n-{                                                       }\n-{       Delphi Supplemental Components                  }\n-{       ZLIB Data Compression Interface Unit            }\n-{                                                       }\n-{       Copyright (c) 1997 Borland International        }\n-{                                                       }\n-{*******************************************************}\n-\n-{ Modified for zlib 1.1.3 by Davide Moretti <dave@rimini.com }\n-\n-unit zlib;\n-\n-interface\n-\n-uses Sysutils, Classes;\n-\n-type\n-  TAlloc = function (AppData: Pointer; Items, Size: Integer): Pointer;\n-  TFree = procedure (AppData, Block: Pointer);\n-\n-  // Internal structure.  Ignore.\n-  TZStreamRec = packed record\n-    next_in: PChar;       // next input byte\n-    avail_in: Integer;    // number of bytes available at next_in\n-    total_in: Integer;    // total nb of input bytes read so far\n-\n-    next_out: PChar;      // next output byte should be put here\n-    avail_out: Integer;   // remaining free space at next_out\n-    total_out: Integer;   // total nb of bytes output so far\n-\n-    msg: PChar;           // last error message, NULL if no error\n-    internal: Pointer;    // not visible by applications\n-\n-    zalloc: TAlloc;       // used to allocate the internal state\n-    zfree: TFree;         // used to free the internal state\n-    AppData: Pointer;     // private data object passed to zalloc and zfree\n-\n-    data_type: Integer;   //  best guess about the data type: ascii or binary\n-    adler: Integer;       // adler32 value of the uncompressed data\n-    reserved: Integer;    // reserved for future use\n-  end;\n-\n-  // Abstract ancestor class\n-  TCustomZlibStream = class(TStream)\n-  private\n-    FStrm: TStream;\n-    FStrmPos: Integer;\n-    FOnProgress: TNotifyEvent;\n-    FZRec: TZStreamRec;\n-    FBuffer: array [Word] of Char;\n-  protected\n-    procedure Progress(Sender: TObject); dynamic;\n-    property OnProgress: TNotifyEvent read FOnProgress write FOnProgress;\n-    constructor Create(Strm: TStream);\n-  end;\n-\n-{ TCompressionStream compresses data on the fly as data is written to it, and\n-  stores the compressed data to another stream.\n-\n-  TCompressionStream is write-only and strictly sequential. Reading from the\n-  stream will raise an exception. Using Seek to move the stream pointer\n-  will raise an exception.\n-\n-  Output data is cached internally, written to the output stream only when\n-  the internal output buffer is full.  All pending output data is flushed\n-  when the stream is destroyed.\n-\n-  The Position property returns the number of uncompressed bytes of\n-  data that have been written to the stream so far.\n-\n-  CompressionRate returns the on-the-fly percentage by which the original\n-  data has been compressed:  (1 - (CompressedBytes / UncompressedBytes)) * 100\n-  If raw data size = 100 and compressed data size = 25, the CompressionRate\n-  is 75%\n-\n-  The OnProgress event is called each time the output buffer is filled and\n-  written to the output stream.  This is useful for updating a progress\n-  indicator when you are writing a large chunk of data to the compression\n-  stream in a single call.}\n-\n-\n-  TCompressionLevel = (clNone, clFastest, clDefault, clMax);\n-\n-  TCompressionStream = class(TCustomZlibStream)\n-  private\n-    function GetCompressionRate: Single;\n-  public\n-    constructor Create(CompressionLevel: TCompressionLevel; Dest: TStream);\n-    destructor Destroy; override;\n-    function Read(var Buffer; Count: Longint): Longint; override;\n-    function Write(const Buffer; Count: Longint): Longint; override;\n-    function Seek(Offset: Longint; Origin: Word): Longint; override;\n-    property CompressionRate: Single read GetCompressionRate;\n-    property OnProgress;\n-  end;\n-\n-{ TDecompressionStream decompresses data on the fly as data is read from it.\n-\n-  Compressed data comes from a separate source stream.  TDecompressionStream\n-  is read-only and unidirectional; you can seek forward in the stream, but not\n-  backwards.  The special case of setting the stream position to zero is\n-  allowed.  Seeking forward decompresses data until the requested position in\n-  the uncompressed data has been reached.  Seeking backwards, seeking relative\n-  to the end of the stream, requesting the size of the stream, and writing to\n-  the stream will raise an exception.\n-\n-  The Position property returns the number of bytes of uncompressed data that\n-  have been read from the stream so far.\n-\n-  The OnProgress event is called each time the internal input buffer of\n-  compressed data is exhausted and the next block is read from the input stream.\n-  This is useful for updating a progress indicator when you are reading a\n-  large chunk of data from the decompression stream in a single call.}\n-\n-  TDecompressionStream = class(TCustomZlibStream)\n-  public\n-    constructor Create(Source: TStream);\n-    destructor Destroy; override;\n-    function Read(var Buffer; Count: Longint): Longint; override;\n-    function Write(const Buffer; Count: Longint): Longint; override;\n-    function Seek(Offset: Longint; Origin: Word): Longint; override;\n-    property OnProgress;\n-  end;\n-\n-\n-\n-{ CompressBuf compresses data, buffer to buffer, in one call.\n-   In: InBuf = ptr to compressed data\n-       InBytes = number of bytes in InBuf\n-  Out: OutBuf = ptr to newly allocated buffer containing decompressed data\n-       OutBytes = number of bytes in OutBuf   }\n-procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;\n-                      out OutBuf: Pointer; out OutBytes: Integer);\n-\n-\n-{ DecompressBuf decompresses data, buffer to buffer, in one call.\n-   In: InBuf = ptr to compressed data\n-       InBytes = number of bytes in InBuf\n-       OutEstimate = zero, or est. size of the decompressed data\n-  Out: OutBuf = ptr to newly allocated buffer containing decompressed data\n-       OutBytes = number of bytes in OutBuf   }\n-procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;\n- OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);\n-\n-const\n-  zlib_version = '1.1.3';\n-\n-type\n-  EZlibError = class(Exception);\n-  ECompressionError = class(EZlibError);\n-  EDecompressionError = class(EZlibError);\n-\n-function adler32(adler: Integer; buf: PChar; len: Integer): Integer;\n-\n-implementation\n-\n-const\n-  Z_NO_FLUSH      = 0;\n-  Z_PARTIAL_FLUSH = 1;\n-  Z_SYNC_FLUSH    = 2;\n-  Z_FULL_FLUSH    = 3;\n-  Z_FINISH        = 4;\n-\n-  Z_OK            = 0;\n-  Z_STREAM_END    = 1;\n-  Z_NEED_DICT     = 2;\n-  Z_ERRNO         = (-1);\n-  Z_STREAM_ERROR  = (-2);\n-  Z_DATA_ERROR    = (-3);\n-  Z_MEM_ERROR     = (-4);\n-  Z_BUF_ERROR     = (-5);\n-  Z_VERSION_ERROR = (-6);\n-\n-  Z_NO_COMPRESSION       =   0;\n-  Z_BEST_SPEED           =   1;\n-  Z_BEST_COMPRESSION     =   9;\n-  Z_DEFAULT_COMPRESSION  = (-1);\n-\n-  Z_FILTERED            = 1;\n-  Z_HUFFMAN_ONLY        = 2;\n-  Z_DEFAULT_STRATEGY    = 0;\n-\n-  Z_BINARY   = 0;\n-  Z_ASCII    = 1;\n-  Z_UNKNOWN  = 2;\n-\n-  Z_DEFLATED = 8;\n-\n-  _z_errmsg: array[0..9] of PChar = (\n-    'need dictionary',      // Z_NEED_DICT      (2)\n-    'stream end',           // Z_STREAM_END     (1)\n-    '',                     // Z_OK             (0)\n-    'file error',           // Z_ERRNO          (-1)\n-    'stream error',         // Z_STREAM_ERROR   (-2)\n-    'data error',           // Z_DATA_ERROR     (-3)\n-    'insufficient memory',  // Z_MEM_ERROR      (-4)\n-    'buffer error',         // Z_BUF_ERROR      (-5)\n-    'incompatible version', // Z_VERSION_ERROR  (-6)\n-    ''\n-  );\n-\n-{$L deflate.obj}\n-{$L inflate.obj}\n-{$L inftrees.obj}\n-{$L trees.obj}\n-{$L adler32.obj}\n-{$L infblock.obj}\n-{$L infcodes.obj}\n-{$L infutil.obj}\n-{$L inffast.obj}\n-\n-procedure _tr_init; external;\n-procedure _tr_tally; external;\n-procedure _tr_flush_block; external;\n-procedure _tr_align; external;\n-procedure _tr_stored_block; external;\n-function adler32; external;\n-procedure inflate_blocks_new; external;\n-procedure inflate_blocks; external;\n-procedure inflate_blocks_reset; external;\n-procedure inflate_blocks_free; external;\n-procedure inflate_set_dictionary; external;\n-procedure inflate_trees_bits; external;\n-procedure inflate_trees_dynamic; external;\n-procedure inflate_trees_fixed; external;\n-procedure inflate_codes_new; external;\n-procedure inflate_codes; external;\n-procedure inflate_codes_free; external;\n-procedure _inflate_mask; external;\n-procedure inflate_flush; external;\n-procedure inflate_fast; external;\n-\n-procedure _memset(P: Pointer; B: Byte; count: Integer);cdecl;\n-begin\n-  FillChar(P^, count, B);\n-end;\n-\n-procedure _memcpy(dest, source: Pointer; count: Integer);cdecl;\n-begin\n-  Move(source^, dest^, count);\n-end;\n-\n-\n-\n-// deflate compresses data\n-function deflateInit_(var strm: TZStreamRec; level: Integer; version: PChar;\n-  recsize: Integer): Integer; external;\n-function deflate(var strm: TZStreamRec; flush: Integer): Integer; external;\n-function deflateEnd(var strm: TZStreamRec): Integer; external;\n-\n-// inflate decompresses data\n-function inflateInit_(var strm: TZStreamRec; version: PChar;\n-  recsize: Integer): Integer; external;\n-function inflate(var strm: TZStreamRec; flush: Integer): Integer; external;\n-function inflateEnd(var strm: TZStreamRec): Integer; external;\n-function inflateReset(var strm: TZStreamRec): Integer; external;\n-\n-\n-function zcalloc(AppData: Pointer; Items, Size: Integer): Pointer;\n-begin\n-  GetMem(Result, Items*Size);\n-end;\n-\n-procedure zcfree(AppData, Block: Pointer);\n-begin\n-  FreeMem(Block);\n-end;\n-\n-function zlibCheck(code: Integer): Integer;\n-begin\n-  Result := code;\n-  if code < 0 then\n-    raise EZlibError.Create('error');    //!!\n-end;\n-\n-function CCheck(code: Integer): Integer;\n-begin\n-  Result := code;\n-  if code < 0 then\n-    raise ECompressionError.Create('error'); //!!\n-end;\n-\n-function DCheck(code: Integer): Integer;\n-begin\n-  Result := code;\n-  if code < 0 then\n-    raise EDecompressionError.Create('error');  //!!\n-end;\n-\n-procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;\n-                      out OutBuf: Pointer; out OutBytes: Integer);\n-var\n-  strm: TZStreamRec;\n-  P: Pointer;\n-begin\n-  FillChar(strm, sizeof(strm), 0);\n-  OutBytes := ((InBytes + (InBytes div 10) + 12) + 255) and not 255;\n-  GetMem(OutBuf, OutBytes);\n-  try\n-    strm.next_in := InBuf;\n-    strm.avail_in := InBytes;\n-    strm.next_out := OutBuf;\n-    strm.avail_out := OutBytes;\n-    CCheck(deflateInit_(strm, Z_BEST_COMPRESSION, zlib_version, sizeof(strm)));\n-    try\n-      while CCheck(deflate(strm, Z_FINISH)) <> Z_STREAM_END do\n-      begin\n-        P := OutBuf;\n-        Inc(OutBytes, 256);\n-        ReallocMem(OutBuf, OutBytes);\n-        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));\n-        strm.avail_out := 256;\n-      end;\n-    finally\n-      CCheck(deflateEnd(strm));\n-    end;\n-    ReallocMem(OutBuf, strm.total_out);\n-    OutBytes := strm.total_out;\n-  except\n-    FreeMem(OutBuf);\n-    raise\n-  end;\n-end;\n-\n-\n-procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;\n-  OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);\n-var\n-  strm: TZStreamRec;\n-  P: Pointer;\n-  BufInc: Integer;\n-begin\n-  FillChar(strm, sizeof(strm), 0);\n-  BufInc := (InBytes + 255) and not 255;\n-  if OutEstimate = 0 then\n-    OutBytes := BufInc\n-  else\n-    OutBytes := OutEstimate;\n-  GetMem(OutBuf, OutBytes);\n-  try\n-    strm.next_in := InBuf;\n-    strm.avail_in := InBytes;\n-    strm.next_out := OutBuf;\n-    strm.avail_out := OutBytes;\n-    DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));\n-    try\n-      while DCheck(inflate(strm, Z_FINISH)) <> Z_STREAM_END do\n-      begin\n-        P := OutBuf;\n-        Inc(OutBytes, BufInc);\n-        ReallocMem(OutBuf, OutBytes);\n-        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));\n-        strm.avail_out := BufInc;\n-      end;\n-    finally\n-      DCheck(inflateEnd(strm));\n-    end;\n-    ReallocMem(OutBuf, strm.total_out);\n-    OutBytes := strm.total_out;\n-  except\n-    FreeMem(OutBuf);\n-    raise\n-  end;\n-end;\n-\n-\n-// TCustomZlibStream\n-\n-constructor TCustomZLibStream.Create(Strm: TStream);\n-begin\n-  inherited Create;\n-  FStrm := Strm;\n-  FStrmPos := Strm.Position;\n-end;\n-\n-procedure TCustomZLibStream.Progress(Sender: TObject);\n-begin\n-  if Assigned(FOnProgress) then FOnProgress(Sender);\n-end;\n-\n-\n-// TCompressionStream\n-\n-constructor TCompressionStream.Create(CompressionLevel: TCompressionLevel;\n-  Dest: TStream);\n-const\n-  Levels: array [TCompressionLevel] of ShortInt =\n-    (Z_NO_COMPRESSION, Z_BEST_SPEED, Z_DEFAULT_COMPRESSION, Z_BEST_COMPRESSION);\n-begin\n-  inherited Create(Dest);\n-  FZRec.next_out := FBuffer;\n-  FZRec.avail_out := sizeof(FBuffer);\n-  CCheck(deflateInit_(FZRec, Levels[CompressionLevel], zlib_version, sizeof(FZRec)));\n-end;\n-\n-destructor TCompressionStream.Destroy;\n-begin\n-  FZRec.next_in := nil;\n-  FZRec.avail_in := 0;\n-  try\n-    if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n-    while (CCheck(deflate(FZRec, Z_FINISH)) <> Z_STREAM_END)\n-      and (FZRec.avail_out = 0) do\n-    begin\n-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));\n-      FZRec.next_out := FBuffer;\n-      FZRec.avail_out := sizeof(FBuffer);\n-    end;\n-    if FZRec.avail_out < sizeof(FBuffer) then\n-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer) - FZRec.avail_out);\n-  finally\n-    deflateEnd(FZRec);\n-  end;\n-  inherited Destroy;\n-end;\n-\n-function TCompressionStream.Read(var Buffer; Count: Longint): Longint;\n-begin\n-  raise ECompressionError.Create('Invalid stream operation');\n-end;\n-\n-function TCompressionStream.Write(const Buffer; Count: Longint): Longint;\n-begin\n-  FZRec.next_in := @Buffer;\n-  FZRec.avail_in := Count;\n-  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n-  while (FZRec.avail_in > 0) do\n-  begin\n-    CCheck(deflate(FZRec, 0));\n-    if FZRec.avail_out = 0 then\n-    begin\n-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));\n-      FZRec.next_out := FBuffer;\n-      FZRec.avail_out := sizeof(FBuffer);\n-      FStrmPos := FStrm.Position;\n-      Progress(Self);\n-    end;\n-  end;\n-  Result := Count;\n-end;\n-\n-function TCompressionStream.Seek(Offset: Longint; Origin: Word): Longint;\n-begin\n-  if (Offset = 0) and (Origin = soFromCurrent) then\n-    Result := FZRec.total_in\n-  else\n-    raise ECompressionError.Create('Invalid stream operation');\n-end;\n-\n-function TCompressionStream.GetCompressionRate: Single;\n-begin\n-  if FZRec.total_in = 0 then\n-    Result := 0\n-  else\n-    Result := (1.0 - (FZRec.total_out / FZRec.total_in)) * 100.0;\n-end;\n-\n-\n-// TDecompressionStream\n-\n-constructor TDecompressionStream.Create(Source: TStream);\n-begin\n-  inherited Create(Source);\n-  FZRec.next_in := FBuffer;\n-  FZRec.avail_in := 0;\n-  DCheck(inflateInit_(FZRec, zlib_version, sizeof(FZRec)));\n-end;\n-\n-destructor TDecompressionStream.Destroy;\n-begin\n-  inflateEnd(FZRec);\n-  inherited Destroy;\n-end;\n-\n-function TDecompressionStream.Read(var Buffer; Count: Longint): Longint;\n-begin\n-  FZRec.next_out := @Buffer;\n-  FZRec.avail_out := Count;\n-  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;\n-  while (FZRec.avail_out > 0) do\n-  begin\n-    if FZRec.avail_in = 0 then\n-    begin\n-      FZRec.avail_in := FStrm.Read(FBuffer, sizeof(FBuffer));\n-      if FZRec.avail_in = 0 then\n-        begin\n-          Result := Count - FZRec.avail_out;\n-          Exit;\n-        end;\n-      FZRec.next_in := FBuffer;\n-      FStrmPos := FStrm.Position;\n-      Progress(Self);\n-    end;\n-    DCheck(inflate(FZRec, 0));\n-  end;\n-  Result := Count;\n-end;\n-\n-function TDecompressionStream.Write(const Buffer; Count: Longint): Longint;\n-begin\n-  raise EDecompressionError.Create('Invalid stream operation');\n-end;\n-\n-function TDecompressionStream.Seek(Offset: Longint; Origin: Word): Longint;\n-var\n-  I: Integer;\n-  Buf: array [0..4095] of Char;\n-begin\n-  if (Offset = 0) and (Origin = soFromBeginning) then\n-  begin\n-    DCheck(inflateReset(FZRec));\n-    FZRec.next_in := FBuffer;\n-    FZRec.avail_in := 0;\n-    FStrm.Position := 0;\n-    FStrmPos := 0;\n-  end\n-  else if ( (Offset >= 0) and (Origin = soFromCurrent)) or\n-          ( ((Offset - FZRec.total_out) > 0) and (Origin = soFromBeginning)) then\n-  begin\n-    if Origin = soFromBeginning then Dec(Offset, FZRec.total_out);\n-    if Offset > 0 then\n-    begin\n-      for I := 1 to Offset div sizeof(Buf) do\n-        ReadBuffer(Buf, sizeof(Buf));\n-      ReadBuffer(Buf, Offset mod sizeof(Buf));\n-    end;\n-  end\n-  else\n-    raise EDecompressionError.Create('Invalid stream operation');\n-  Result := FZRec.total_out;\n-end;\n-\n-end."}, {"sha": "cabcec449474e2df0e805fc22375021126d355df", "filename": "zlib/contrib/delphi2/zlib32.bpr", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.bpr?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,174 +0,0 @@\n-# ---------------------------------------------------------------------------\n-!if !$d(BCB)\n-BCB = $(MAKEDIR)\\..\n-!endif\n-\n-# ---------------------------------------------------------------------------\n-# IDE SECTION\n-# ---------------------------------------------------------------------------\n-# The following section of the project makefile is managed by the BCB IDE.\n-# It is recommended to use the IDE to change any of the values in this\n-# section.\n-# ---------------------------------------------------------------------------\n-\n-VERSION = BCB.03\n-# ---------------------------------------------------------------------------\n-PROJECT = zlib32.dll\n-OBJFILES = zlib32.obj adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infblock.obj \\\n-  infcodes.obj inffast.obj inflate.obj inftrees.obj infutil.obj trees.obj \\\n-  uncompr.obj zutil.obj\n-RESFILES =\n-RESDEPEN = $(RESFILES)\n-LIBFILES =\n-LIBRARIES = \n-SPARELIBS = \n-DEFFILE =\n-PACKAGES = VCLX35.bpi VCL35.bpi VCLDB35.bpi VCLDBX35.bpi ibsmp35.bpi bcbsmp35.bpi \\\n-  dclocx35.bpi QRPT35.bpi TEEUI35.bpi TEEDB35.bpi TEE35.bpi DSS35.bpi \\\n-  NMFAST35.bpi INETDB35.bpi INET35.bpi VCLMID35.bpi\n-# ---------------------------------------------------------------------------\n-PATHCPP = .;\n-PATHASM = .;\n-PATHPAS = .;\n-PATHRC = .;\n-DEBUGLIBPATH = $(BCB)\\lib\\debug\n-RELEASELIBPATH = $(BCB)\\lib\\release\n-# ---------------------------------------------------------------------------\n-CFLAG1 = -WD -O2 -Ve -d -k- -vi -c -tWD\n-CFLAG2 = -D_NO_VCL;ZLIB_DLL -I$(BCB)\\include\n-CFLAG3 = -ff -5\n-PFLAGS = -D_NO_VCL;ZLIB_DLL -U$(BCB)\\lib;$(RELEASELIBPATH) -I$(BCB)\\include -$I- -v \\\n-  -JPHN -M\n-RFLAGS = -D_NO_VCL;ZLIB_DLL -i$(BCB)\\include\n-AFLAGS = /i$(BCB)\\include /d_NO_VCL /dZLIB_DLL /mx /w2 /zn\n-LFLAGS = -L$(BCB)\\lib;$(RELEASELIBPATH) -aa -Tpd -x -Gi\n-IFLAGS = -Gn -g\n-# ---------------------------------------------------------------------------\n-ALLOBJ = c0d32.obj $(OBJFILES)\n-ALLRES = $(RESFILES)\n-ALLLIB = $(LIBFILES)  import32.lib cw32mt.lib\n-# ---------------------------------------------------------------------------\n-!ifdef IDEOPTIONS\n-\n-[Version Info]\n-IncludeVerInfo=0\n-AutoIncBuild=0\n-MajorVer=1\n-MinorVer=0\n-Release=0\n-Build=0\n-Debug=0\n-PreRelease=0\n-Special=0\n-Private=0\n-DLL=1\n-Locale=1040\n-CodePage=1252\n-\n-[Version Info Keys]\n-CompanyName=\n-FileDescription=DLL (GUI)\n-FileVersion=1.0.0.0\n-InternalName=\n-LegalCopyright=\n-LegalTrademarks=\n-OriginalFilename=\n-ProductName=\n-ProductVersion=1.0.0.0\n-Comments=\n-\n-[HistoryLists\\hlIncludePath]\n-Count=1\n-Item0=$(BCB)\\include\n-\n-[HistoryLists\\hlLibraryPath]\n-Count=1\n-Item0=$(BCB)\\lib\n-\n-[HistoryLists\\hlConditionals]\n-Count=1\n-Item0=_NO_VCL;ZLIB_DLL\n-\n-[Debugging]\n-DebugSourceDirs=\n-\n-[Parameters]\n-RunParams=\n-HostApplication=\n-\n-!endif\n-\n-# ---------------------------------------------------------------------------\n-# MAKE SECTION\n-# ---------------------------------------------------------------------------\n-# This section of the project file is not used by the BCB IDE.  It is for\n-# the benefit of building from the command-line using the MAKE utility.\n-# ---------------------------------------------------------------------------\n-\n-.autodepend\n-# ---------------------------------------------------------------------------\n-!if !$d(BCC32)\n-BCC32 = bcc32\n-!endif\n-\n-!if !$d(DCC32)\n-DCC32 = dcc32\n-!endif\n-\n-!if !$d(TASM32)\n-TASM32 = tasm32\n-!endif\n-\n-!if !$d(LINKER)\n-LINKER = ilink32\n-!endif\n-\n-!if !$d(BRCC32)\n-BRCC32 = brcc32\n-!endif\n-# ---------------------------------------------------------------------------\n-!if $d(PATHCPP)\n-.PATH.CPP = $(PATHCPP)\n-.PATH.C   = $(PATHCPP)\n-!endif\n-\n-!if $d(PATHPAS)\n-.PATH.PAS = $(PATHPAS)\n-!endif\n-\n-!if $d(PATHASM)\n-.PATH.ASM = $(PATHASM)\n-!endif\n-\n-!if $d(PATHRC)\n-.PATH.RC  = $(PATHRC)\n-!endif\n-# ---------------------------------------------------------------------------\n-$(PROJECT): $(OBJFILES) $(RESDEPEN) $(DEFFILE)\n-    $(BCB)\\BIN\\$(LINKER) @&&!\n-    $(LFLAGS) $(IFLAGS) +\n-    $(ALLOBJ), +\n-    $(PROJECT),, +\n-    $(ALLLIB), +\n-    $(DEFFILE), +\n-    $(ALLRES)\n-!\n-# ---------------------------------------------------------------------------\n-.pas.hpp:\n-    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n-\n-.pas.obj:\n-    $(BCB)\\BIN\\$(DCC32) $(PFLAGS) {$< }\n-\n-.cpp.obj:\n-    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n-\n-.c.obj:\n-    $(BCB)\\BIN\\$(BCC32) $(CFLAG1) $(CFLAG2) $(CFLAG3) -n$(@D) {$< }\n-\n-.asm.obj:\n-    $(BCB)\\BIN\\$(TASM32) $(AFLAGS) $<, $@\n-\n-.rc.res:\n-    $(BCB)\\BIN\\$(BRCC32) $(RFLAGS) -fo$@ $<\n-# ---------------------------------------------------------------------------"}, {"sha": "7372f6b985f8d57538fca6bc0520f759c1f868f6", "filename": "zlib/contrib/delphi2/zlib32.cpp", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fdelphi2%2Fzlib32.cpp?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,42 +0,0 @@\n-\n-#include <windows.h>\n-#pragma hdrstop\n-#include <condefs.h>\n-\n-\n-//---------------------------------------------------------------------------\n-//   Important note about DLL memory management in a VCL DLL:\n-//\n-//\n-//\n-// If your DLL uses VCL and exports any functions that pass VCL String objects\n-// (or structs/classes containing nested Strings) as parameter or function\n-// results, you will need to build both your DLL project and any EXE projects\n-// that use your DLL with the dynamic RTL (the RTL DLL).  This will change your\n-// DLL and its calling EXE's to use BORLNDMM.DLL as their memory manager. In\n-// these cases, the file BORLNDMM.DLL should be deployed along with your DLL\n-// and the RTL DLL (CP3240MT.DLL). To avoid the requiring BORLNDMM.DLL in\n-// these situations, pass string information using \"char *\" or ShortString\n-// parameters and then link with the static RTL.\n-//\n-//---------------------------------------------------------------------------\n-USEUNIT(\"adler32.c\");\n-USEUNIT(\"compress.c\");\n-USEUNIT(\"crc32.c\");\n-USEUNIT(\"deflate.c\");\n-USEUNIT(\"gzio.c\");\n-USEUNIT(\"infblock.c\");\n-USEUNIT(\"infcodes.c\");\n-USEUNIT(\"inffast.c\");\n-USEUNIT(\"inflate.c\");\n-USEUNIT(\"inftrees.c\");\n-USEUNIT(\"infutil.c\");\n-USEUNIT(\"trees.c\");\n-USEUNIT(\"uncompr.c\");\n-USEUNIT(\"zutil.c\");\n-//---------------------------------------------------------------------------\n-#pragma argsused\n-int WINAPI DllEntryPoint(HINSTANCE hinst, unsigned long reason, void*)\n-{\n-        return 1;\n-}"}, {"sha": "d0cd85faaf5b2260b241b1f05ee88437bd6c6a60", "filename": "zlib/contrib/iostream/zfstream.cpp", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fiostream%2Fzfstream.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fiostream%2Fzfstream.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream%2Fzfstream.cpp?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,5 +1,4 @@\n \n-#include <memory.h>\n #include \"zfstream.h\"\n \n gzfilebuf::gzfilebuf() :\n@@ -17,15 +16,13 @@ gzfilebuf::~gzfilebuf() {\n }\n \n gzfilebuf *gzfilebuf::open( const char *name,\n-\t\t\t    int io_mode ) {\n+                            int io_mode ) {\n \n   if ( is_open() )\n     return NULL;\n \n   char char_mode[10];\n-  char *p;\n-  memset(char_mode,'\\0',10);\n-  p = char_mode;\n+  char *p = char_mode;\n \n   if ( io_mode & ios::in ) {\n     mode = ios::in;\n@@ -48,6 +45,9 @@ gzfilebuf *gzfilebuf::open( const char *name,\n     *p++ = '9';\n   }\n \n+  // Put the end-of-string indicator\n+  *p = '\\0';\n+\n   if ( (file = gzopen(name, char_mode)) == NULL )\n     return NULL;\n \n@@ -58,15 +58,13 @@ gzfilebuf *gzfilebuf::open( const char *name,\n }\n \n gzfilebuf *gzfilebuf::attach( int file_descriptor,\n-\t\t\t      int io_mode ) {\n+                              int io_mode ) {\n \n   if ( is_open() )\n     return NULL;\n \n   char char_mode[10];\n-  char *p;\n-  memset(char_mode,'\\0',10);\n-  p = char_mode;\n+  char *p = char_mode;\n \n   if ( io_mode & ios::in ) {\n     mode = ios::in;\n@@ -89,6 +87,9 @@ gzfilebuf *gzfilebuf::attach( int file_descriptor,\n     *p++ = '9';\n   }\n \n+  // Put the end-of-string indicator\n+  *p = '\\0';\n+\n   if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )\n     return NULL;\n \n@@ -112,13 +113,13 @@ gzfilebuf *gzfilebuf::close() {\n \n }\n \n-int gzfilebuf::setcompressionlevel( short comp_level ) {\n+int gzfilebuf::setcompressionlevel( int comp_level ) {\n \n   return gzsetparams(file, comp_level, -2);\n \n }\n \n-int gzfilebuf::setcompressionstrategy( short comp_strategy ) {\n+int gzfilebuf::setcompressionstrategy( int comp_strategy ) {\n \n   return gzsetparams(file, -2, comp_strategy);\n \n@@ -151,7 +152,7 @@ int gzfilebuf::underflow() {\n \n     if ( out_waiting() ) {\n       if ( flushbuf() == EOF )\n-\treturn EOF;\n+        return EOF;\n     }\n \n   }\n@@ -180,11 +181,11 @@ int gzfilebuf::overflow( int c ) {\n     setg(0,0,0);\n   } else {\n     if (in_avail()) {\n-\treturn EOF;\n+        return EOF;\n     }\n     if (out_waiting()) {\n       if (flushbuf() == EOF)\n-\treturn EOF;\n+        return EOF;\n     }\n   }\n \n@@ -282,12 +283,11 @@ void gzfilestream_common::close() {\n \n }\n \n-gzfilebuf *gzfilestream_common::rdbuf() {\n-\n+gzfilebuf *gzfilestream_common::rdbuf()\n+{\n   return &buffer;\n-\n }\n-     \n+\n gzifstream::gzifstream() :\n   ios( gzfilestream_common::rdbuf() )\n {"}, {"sha": "ed79098a3adaf5d4a33720325186e3e1c3df8a62", "filename": "zlib/contrib/iostream/zfstream.h", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fiostream%2Fzfstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fiostream%2Fzfstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream%2Fzfstream.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,6 +1,6 @@\n \n-#ifndef _zfstream_h\n-#define _zfstream_h\n+#ifndef zfstream_h\n+#define zfstream_h\n \n #include <fstream.h>\n #include \"zlib.h\"\n@@ -16,8 +16,8 @@ class gzfilebuf : public streambuf {\n   gzfilebuf *attach( int file_descriptor, int io_mode );\n   gzfilebuf *close();\n \n-  int setcompressionlevel( short comp_level );\n-  int setcompressionstrategy( short comp_strategy );\n+  int setcompressionlevel( int comp_level );\n+  int setcompressionstrategy( int comp_strategy );\n \n   inline int is_open() const { return (file !=NULL); }\n \n@@ -98,18 +98,19 @@ template<class T> class gzomanip {\n   T val;\n };\n \n-template<class T> gzofstream &operator<<(gzofstream &s,\n-\t\t\t\t\t const gzomanip<T> &m) {\n+template<class T> gzofstream &operator<<(gzofstream &s, const gzomanip<T> &m)\n+{\n   return (*m.func)(s, m.val);\n-  \n }\n \n-inline gzofstream &setcompressionlevel( gzofstream &s, int l ) {\n+inline gzofstream &setcompressionlevel( gzofstream &s, int l )\n+{\n   (s.rdbuf())->setcompressionlevel(l);\n   return s;\n }\n \n-inline gzofstream &setcompressionstrategy( gzofstream &s, int l ) {\n+inline gzofstream &setcompressionstrategy( gzofstream &s, int l )\n+{\n   (s.rdbuf())->setcompressionstrategy(l);\n   return s;\n }\n@@ -125,18 +126,3 @@ inline gzomanip<int> setcompressionstrategy(int l)\n }\n \n #endif\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "6273f62d62a8fa280edcfb798a013e0a0ae84534", "filename": "zlib/contrib/iostream2/zstream_test.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fiostream2%2Fzstream_test.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fiostream2%2Fzstream_test.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fiostream2%2Fzstream_test.cpp?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -4,9 +4,9 @@\n #include <iomanip.h>\n \n void main() {\n-\tchar h[256] = \"Hello\";\n-\tchar* g = \"Goodbye\";\n-\tozstream out(\"temp.gz\");\n+    char h[256] = \"Hello\";\n+    char* g = \"Goodbye\";\n+    ozstream out(\"temp.gz\");\n     out < \"This works well\" < h < g;\n     out.close();\n "}, {"sha": "d7d4b6ba5847bea8728e2c9b7f80683bb240b0b9", "filename": "zlib/contrib/minizip/ChangeLogUnzip", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2FChangeLogUnzip?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,10 +1,27 @@\n+Change in 1.00: (10 sept 03)\n+- rename to 1.00\n+- cosmetic code change\n+\n+Change in 0.22: (19 May 03)\n+- crypting support (unless you define NOCRYPT)\n+- append file in existing zipfile\n+\n+Change in 0.21: (10 Mar 03)\n+- bug fixes\n+\n+Change in 0.17: (27 Jan 02)\n+- bug fixes\n+\n+Change in 0.16: (19 Jan 02)\n+- Support of ioapi for virtualize zip file access\n+\n Change in 0.15: (19 Mar 98)\n - fix memory leak in minizip.c\n \n Change in 0.14: (10 Mar 98)\n - fix bugs in minizip.c sample for zipping big file\n - fix problem in month in date handling\n-- fix bug in unzlocal_GetCurrentFileInfoInternal in unzip.c for \n+- fix bug in unzlocal_GetCurrentFileInfoInternal in unzip.c for\n     comment handling\n \n Change in 0.13: (6 Mar 98)\n@@ -32,7 +49,7 @@ Change in 0.10: (2 Mar 98)\n - add a new sample, miniunz.c\n \n Change in 0.4: (25 Feb 98)\n-- suppress the type unzipFileInZip. \n+- suppress the type unzipFileInZip.\n   Only on file in the zipfile can be open at the same time\n - fix somes typo in code\n - added tm_unz structure in unzip_file_info (date/time in readable format)"}, {"sha": "84eaad20d4fb19b00965268dd75d7e9b66c8cc21", "filename": "zlib/contrib/minizip/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2FMakefile?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,8 +1,8 @@\n CC=cc\n CFLAGS=-O -I../..\n \n-UNZ_OBJS = miniunz.o unzip.o ../../libz.a\n-ZIP_OBJS = minizip.o zip.o   ../../libz.a\n+UNZ_OBJS = miniunz.o unzip.o ioapi.o ../../libz.a\n+ZIP_OBJS = minizip.o zip.o   ioapi.o ../../libz.a\n \n .c.o:\n \t$(CC) -c $(CFLAGS) $*.c"}, {"sha": "c8cf81e3be37f6b457d06fa0dd53640a611e6348", "filename": "zlib/contrib/minizip/miniunz.c", "status": "modified", "additions": 335, "deletions": 287, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Fminiunz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Fminiunz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminiunz.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -17,7 +17,12 @@\n \n #define CASESENSITIVITY (0)\n #define WRITEBUFFERSIZE (8192)\n+#define MAXFILENAME (256)\n \n+#ifdef WIN32\n+#define USEWIN32IOAPI\n+#include \"iowin32.h\"\n+#endif\n /*\n   mini unzip, demo of unzip package\n \n@@ -34,9 +39,9 @@\n     dosdate : the new date at the MSDos format (4 bytes)\n     tmu_date : the SAME new date at the tm_unz format */\n void change_file_date(filename,dosdate,tmu_date)\n-\tconst char *filename;\n-\tuLong dosdate;\n-\ttm_unz tmu_date;\n+    const char *filename;\n+    uLong dosdate;\n+    tm_unz tmu_date;\n {\n #ifdef WIN32\n   HANDLE hFile;\n@@ -75,32 +80,32 @@ void change_file_date(filename,dosdate,tmu_date)\n    As I don't know well Unix, I wait feedback for the unix portion */\n \n int mymkdir(dirname)\n-\tconst char* dirname;\n+    const char* dirname;\n {\n     int ret=0;\n #ifdef WIN32\n-\tret = mkdir(dirname);\n+    ret = mkdir(dirname);\n #else\n #ifdef unix\n-\tret = mkdir (dirname,0775);\n+    ret = mkdir (dirname,0775);\n #endif\n #endif\n-\treturn ret;\n+    return ret;\n }\n \n int makedir (newdir)\n     char *newdir;\n {\n   char *buffer ;\n   char *p;\n-  int  len = strlen(newdir);  \n+  int  len = (int)strlen(newdir);\n \n-  if (len <= 0) \n+  if (len <= 0)\n     return 0;\n \n   buffer = (char*)malloc(len+1);\n   strcpy(buffer,newdir);\n-  \n+\n   if (buffer[len-1] == '/') {\n     buffer[len-1] = '\\0';\n   }\n@@ -135,104 +140,118 @@ int makedir (newdir)\n \n void do_banner()\n {\n-\tprintf(\"MiniUnz 0.15, demo of zLib + Unz package written by Gilles Vollant\\n\");\n-\tprintf(\"more info at http://wwww.winimage/zLibDll/unzip.htm\\n\\n\");\n+    printf(\"MiniUnz 1.00, demo of zLib + Unz package written by Gilles Vollant\\n\");\n+    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n }\n \n void do_help()\n-{\t\n-\tprintf(\"Usage : miniunz [-exvlo] file.zip [file_to_extract]\\n\\n\") ;\n+{\n+    printf(\"Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.]\\n\\n\" \\\n+           \"  -e  Extract without pathname (junk paths)\\n\" \\\n+           \"  -x  Extract with pathname\\n\" \\\n+           \"  -v  list files\\n\" \\\n+           \"  -l  list files\\n\" \\\n+           \"  -o  overwrite files without prompting\\n\" \\\n+           \"  -p  extract crypted file using password\\n\\n\");\n }\n \n \n int do_list(uf)\n-\tunzFile uf;\n+    unzFile uf;\n {\n-\tuLong i;\n-\tunz_global_info gi;\n-\tint err;\n+    uLong i;\n+    unz_global_info gi;\n+    int err;\n \n-\terr = unzGetGlobalInfo (uf,&gi);\n-\tif (err!=UNZ_OK)\n-\t\tprintf(\"error %d with zipfile in unzGetGlobalInfo \\n\",err);\n+    err = unzGetGlobalInfo (uf,&gi);\n+    if (err!=UNZ_OK)\n+        printf(\"error %d with zipfile in unzGetGlobalInfo \\n\",err);\n     printf(\" Length  Method   Size  Ratio   Date    Time   CRC-32     Name\\n\");\n     printf(\" ------  ------   ----  -----   ----    ----   ------     ----\\n\");\n-\tfor (i=0;i<gi.number_entry;i++)\n-\t{\n-\t\tchar filename_inzip[256];\n-\t\tunz_file_info file_info;\n-\t\tuLong ratio=0;\n-\t\tconst char *string_method;\n-\t\terr = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);\n-\t\tif (err!=UNZ_OK)\n-\t\t{\n-\t\t\tprintf(\"error %d with zipfile in unzGetCurrentFileInfo\\n\",err);\n-\t\t\tbreak;\n-\t\t}\n-\t\tif (file_info.uncompressed_size>0)\n-\t\t\tratio = (file_info.compressed_size*100)/file_info.uncompressed_size;\n-\n-\t\tif (file_info.compression_method==0)\n-\t\t\tstring_method=\"Stored\";\n-\t\telse\n-\t\tif (file_info.compression_method==Z_DEFLATED)\n-\t\t{\n-\t\t\tuInt iLevel=(uInt)((file_info.flag & 0x6)/2);\n-\t\t\tif (iLevel==0)\n-\t\t\t  string_method=\"Defl:N\";\n-\t\t\telse if (iLevel==1)\n-\t\t\t  string_method=\"Defl:X\";\n-\t\t\telse if ((iLevel==2) || (iLevel==3))\n-\t\t\t  string_method=\"Defl:F\"; /* 2:fast , 3 : extra fast*/\n-\t\t}\n-\t\telse\n-\t\t\tstring_method=\"Unkn. \";\n-\n-\t\tprintf(\"%7lu  %6s %7lu %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\\n\",\n-\t\t\t    file_info.uncompressed_size,string_method,file_info.compressed_size,\n-\t\t\t\tratio,\n-\t\t\t\t(uLong)file_info.tmu_date.tm_mon + 1,\n+    for (i=0;i<gi.number_entry;i++)\n+    {\n+        char filename_inzip[256];\n+        unz_file_info file_info;\n+        uLong ratio=0;\n+        const char *string_method;\n+        char charCrypt=' ';\n+        err = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);\n+        if (err!=UNZ_OK)\n+        {\n+            printf(\"error %d with zipfile in unzGetCurrentFileInfo\\n\",err);\n+            break;\n+        }\n+        if (file_info.uncompressed_size>0)\n+            ratio = (file_info.compressed_size*100)/file_info.uncompressed_size;\n+\n+        /* display a '*' if the file is crypted */\n+        if ((file_info.flag & 1) != 0)\n+            charCrypt='*';\n+\n+        if (file_info.compression_method==0)\n+            string_method=\"Stored\";\n+        else\n+        if (file_info.compression_method==Z_DEFLATED)\n+        {\n+            uInt iLevel=(uInt)((file_info.flag & 0x6)/2);\n+            if (iLevel==0)\n+              string_method=\"Defl:N\";\n+            else if (iLevel==1)\n+              string_method=\"Defl:X\";\n+            else if ((iLevel==2) || (iLevel==3))\n+              string_method=\"Defl:F\"; /* 2:fast , 3 : extra fast*/\n+        }\n+        else\n+            string_method=\"Unkn. \";\n+\n+        printf(\"%7lu  %6s%c%7lu %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\\n\",\n+                file_info.uncompressed_size,string_method,\n+                charCrypt,\n+                file_info.compressed_size,\n+                ratio,\n+                (uLong)file_info.tmu_date.tm_mon + 1,\n                 (uLong)file_info.tmu_date.tm_mday,\n-\t\t\t\t(uLong)file_info.tmu_date.tm_year % 100,\n-\t\t\t\t(uLong)file_info.tmu_date.tm_hour,(uLong)file_info.tmu_date.tm_min,\n-\t\t\t\t(uLong)file_info.crc,filename_inzip);\n-\t\tif ((i+1)<gi.number_entry)\n-\t\t{\n-\t\t\terr = unzGoToNextFile(uf);\n-\t\t\tif (err!=UNZ_OK)\n-\t\t\t{\n-\t\t\t\tprintf(\"error %d with zipfile in unzGoToNextFile\\n\",err);\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn 0;\n+                (uLong)file_info.tmu_date.tm_year % 100,\n+                (uLong)file_info.tmu_date.tm_hour,(uLong)file_info.tmu_date.tm_min,\n+                (uLong)file_info.crc,filename_inzip);\n+        if ((i+1)<gi.number_entry)\n+        {\n+            err = unzGoToNextFile(uf);\n+            if (err!=UNZ_OK)\n+            {\n+                printf(\"error %d with zipfile in unzGoToNextFile\\n\",err);\n+                break;\n+            }\n+        }\n+    }\n+\n+    return 0;\n }\n \n \n-int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite)\n-\tunzFile uf;\n-\tconst int* popt_extract_without_path;\n+int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite,password)\n+    unzFile uf;\n+    const int* popt_extract_without_path;\n     int* popt_overwrite;\n+    const char* password;\n {\n-\tchar filename_inzip[256];\n-\tchar* filename_withoutpath;\n-\tchar* p;\n+    char filename_inzip[256];\n+    char* filename_withoutpath;\n+    char* p;\n     int err=UNZ_OK;\n     FILE *fout=NULL;\n     void* buf;\n     uInt size_buf;\n-\t\n-\tunz_file_info file_info;\n-\tuLong ratio=0;\n-\terr = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);\n \n-\tif (err!=UNZ_OK)\n-\t{\n-\t\tprintf(\"error %d with zipfile in unzGetCurrentFileInfo\\n\",err);\n-\t\treturn err;\n-\t}\n+    unz_file_info file_info;\n+    uLong ratio=0;\n+    err = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);\n+\n+    if (err!=UNZ_OK)\n+    {\n+        printf(\"error %d with zipfile in unzGetCurrentFileInfo\\n\",err);\n+        return err;\n+    }\n \n     size_buf = WRITEBUFFERSIZE;\n     buf = (void*)malloc(size_buf);\n@@ -242,71 +261,71 @@ int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite)\n         return UNZ_INTERNALERROR;\n     }\n \n-\tp = filename_withoutpath = filename_inzip;\n-\twhile ((*p) != '\\0')\n-\t{\n-\t\tif (((*p)=='/') || ((*p)=='\\\\'))\n-\t\t\tfilename_withoutpath = p+1;\n-\t\tp++;\n-\t}\n-\n-\tif ((*filename_withoutpath)=='\\0')\n-\t{\n-\t\tif ((*popt_extract_without_path)==0)\n-\t\t{\n-\t\t\tprintf(\"creating directory: %s\\n\",filename_inzip);\n-\t\t\tmymkdir(filename_inzip);\n-\t\t}\n-\t}\n-\telse\n-\t{\n-\t\tconst char* write_filename;\n-\t\tint skip=0;\n-\n-\t\tif ((*popt_extract_without_path)==0)\n-\t\t\twrite_filename = filename_inzip;\n-\t\telse\n-\t\t\twrite_filename = filename_withoutpath;\n-\n-\t\terr = unzOpenCurrentFile(uf);\n-\t\tif (err!=UNZ_OK)\n-\t\t{\n-\t\t\tprintf(\"error %d with zipfile in unzOpenCurrentFile\\n\",err);\n-\t\t}\n-\n-\t\tif (((*popt_overwrite)==0) && (err==UNZ_OK))\n-\t\t{\n-\t\t\tchar rep;\n-\t\t\tFILE* ftestexist;\n-\t\t\tftestexist = fopen(write_filename,\"rb\");\n-\t\t\tif (ftestexist!=NULL)\n-\t\t\t{\n-\t\t\t\tfclose(ftestexist);\n-\t\t\t\tdo\n-\t\t\t\t{\n-\t\t\t\t\tchar answer[128];\n-\t\t\t\t\tprintf(\"The file %s exist. Overwrite ? [y]es, [n]o, [A]ll: \",write_filename);\n-\t\t\t\t\tscanf(\"%1s\",answer);\n-\t\t\t\t\trep = answer[0] ;\n-\t\t\t\t\tif ((rep>='a') && (rep<='z'))\n-\t\t\t\t\t\trep -= 0x20;\n-\t\t\t\t}\n-\t\t\t\twhile ((rep!='Y') && (rep!='N') && (rep!='A'));\n-\t\t\t}\n-\n-\t\t\tif (rep == 'N')\n-\t\t\t\tskip = 1;\n-\n-\t\t\tif (rep == 'A')\n-\t\t\t\t*popt_overwrite=1;\n-\t\t}\n-\n-\t\tif ((skip==0) && (err==UNZ_OK))\n-\t\t{\n-\t\t\tfout=fopen(write_filename,\"wb\");\n+    p = filename_withoutpath = filename_inzip;\n+    while ((*p) != '\\0')\n+    {\n+        if (((*p)=='/') || ((*p)=='\\\\'))\n+            filename_withoutpath = p+1;\n+        p++;\n+    }\n+\n+    if ((*filename_withoutpath)=='\\0')\n+    {\n+        if ((*popt_extract_without_path)==0)\n+        {\n+            printf(\"creating directory: %s\\n\",filename_inzip);\n+            mymkdir(filename_inzip);\n+        }\n+    }\n+    else\n+    {\n+        const char* write_filename;\n+        int skip=0;\n+\n+        if ((*popt_extract_without_path)==0)\n+            write_filename = filename_inzip;\n+        else\n+            write_filename = filename_withoutpath;\n+\n+        err = unzOpenCurrentFilePassword(uf,password);\n+        if (err!=UNZ_OK)\n+        {\n+            printf(\"error %d with zipfile in unzOpenCurrentFilePassword\\n\",err);\n+        }\n+\n+        if (((*popt_overwrite)==0) && (err==UNZ_OK))\n+        {\n+            char rep=0;\n+            FILE* ftestexist;\n+            ftestexist = fopen(write_filename,\"rb\");\n+            if (ftestexist!=NULL)\n+            {\n+                fclose(ftestexist);\n+                do\n+                {\n+                    char answer[128];\n+                    printf(\"The file %s exist. Overwrite ? [y]es, [n]o, [A]ll: \",write_filename);\n+                    scanf(\"%1s\",answer);\n+                    rep = answer[0] ;\n+                    if ((rep>='a') && (rep<='z'))\n+                        rep -= 0x20;\n+                }\n+                while ((rep!='Y') && (rep!='N') && (rep!='A'));\n+            }\n+\n+            if (rep == 'N')\n+                skip = 1;\n+\n+            if (rep == 'A')\n+                *popt_overwrite=1;\n+        }\n+\n+        if ((skip==0) && (err==UNZ_OK))\n+        {\n+            fout=fopen(write_filename,\"wb\");\n \n             /* some zipfile don't contain directory alone before file */\n-            if ((fout==NULL) && ((*popt_extract_without_path)==0) && \n+            if ((fout==NULL) && ((*popt_extract_without_path)==0) &&\n                                 (filename_withoutpath!=(char*)filename_inzip))\n             {\n                 char c=*(filename_withoutpath-1);\n@@ -316,95 +335,100 @@ int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite)\n                 fout=fopen(write_filename,\"wb\");\n             }\n \n-\t\t\tif (fout==NULL)\n-\t\t\t{\n-\t\t\t\tprintf(\"error opening %s\\n\",write_filename);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (fout!=NULL)\n-\t\t{\n-\t\t\tprintf(\" extracting: %s\\n\",write_filename);\n-\n-\t\t\tdo\n-\t\t\t{\n-\t\t\t\terr = unzReadCurrentFile(uf,buf,size_buf);\n-\t\t\t\tif (err<0)\t\n-\t\t\t\t{\n-\t\t\t\t\tprintf(\"error %d with zipfile in unzReadCurrentFile\\n\",err);\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tif (err>0)\n-\t\t\t\t\tif (fwrite(buf,err,1,fout)!=1)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tprintf(\"error in writing extracted file\\n\");\n+            if (fout==NULL)\n+            {\n+                printf(\"error opening %s\\n\",write_filename);\n+            }\n+        }\n+\n+        if (fout!=NULL)\n+        {\n+            printf(\" extracting: %s\\n\",write_filename);\n+\n+            do\n+            {\n+                err = unzReadCurrentFile(uf,buf,size_buf);\n+                if (err<0)\n+                {\n+                    printf(\"error %d with zipfile in unzReadCurrentFile\\n\",err);\n+                    break;\n+                }\n+                if (err>0)\n+                    if (fwrite(buf,err,1,fout)!=1)\n+                    {\n+                        printf(\"error in writing extracted file\\n\");\n                         err=UNZ_ERRNO;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t}\n-\t\t\twhile (err>0);\n-\t\t\tfclose(fout);\n-\t\t\tif (err==0) \n-\t\t\t\tchange_file_date(write_filename,file_info.dosDate,\n-\t\t\t\t\t             file_info.tmu_date);\n-\t\t}\n+                        break;\n+                    }\n+            }\n+            while (err>0);\n+            if (fout)\n+                    fclose(fout);\n+\n+            if (err==0)\n+                change_file_date(write_filename,file_info.dosDate,\n+                                 file_info.tmu_date);\n+        }\n \n         if (err==UNZ_OK)\n         {\n-\t\t    err = unzCloseCurrentFile (uf);\n-\t\t    if (err!=UNZ_OK)\n-\t\t    {\n-\t\t\t    printf(\"error %d with zipfile in unzCloseCurrentFile\\n\",err);\n-\t\t    }\n+            err = unzCloseCurrentFile (uf);\n+            if (err!=UNZ_OK)\n+            {\n+                printf(\"error %d with zipfile in unzCloseCurrentFile\\n\",err);\n+            }\n         }\n         else\n-            unzCloseCurrentFile(uf); /* don't lose the error */       \n-\t}\n+            unzCloseCurrentFile(uf); /* don't lose the error */\n+    }\n \n-    free(buf);    \n+    free(buf);\n     return err;\n }\n \n \n-int do_extract(uf,opt_extract_without_path,opt_overwrite)\n-\tunzFile uf;\n-\tint opt_extract_without_path;\n+int do_extract(uf,opt_extract_without_path,opt_overwrite,password)\n+    unzFile uf;\n+    int opt_extract_without_path;\n     int opt_overwrite;\n+    const char* password;\n {\n-\tuLong i;\n-\tunz_global_info gi;\n-\tint err;\n-\tFILE* fout=NULL;\t\n+    uLong i;\n+    unz_global_info gi;\n+    int err;\n+    FILE* fout=NULL;\n \n-\terr = unzGetGlobalInfo (uf,&gi);\n-\tif (err!=UNZ_OK)\n-\t\tprintf(\"error %d with zipfile in unzGetGlobalInfo \\n\",err);\n+    err = unzGetGlobalInfo (uf,&gi);\n+    if (err!=UNZ_OK)\n+        printf(\"error %d with zipfile in unzGetGlobalInfo \\n\",err);\n \n-\tfor (i=0;i<gi.number_entry;i++)\n-\t{\n+    for (i=0;i<gi.number_entry;i++)\n+    {\n         if (do_extract_currentfile(uf,&opt_extract_without_path,\n-                                      &opt_overwrite) != UNZ_OK)\n+                                      &opt_overwrite,\n+                                      password) != UNZ_OK)\n             break;\n \n-\t\tif ((i+1)<gi.number_entry)\n-\t\t{\n-\t\t\terr = unzGoToNextFile(uf);\n-\t\t\tif (err!=UNZ_OK)\n-\t\t\t{\n-\t\t\t\tprintf(\"error %d with zipfile in unzGoToNextFile\\n\",err);\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\treturn 0;\n+        if ((i+1)<gi.number_entry)\n+        {\n+            err = unzGoToNextFile(uf);\n+            if (err!=UNZ_OK)\n+            {\n+                printf(\"error %d with zipfile in unzGoToNextFile\\n\",err);\n+                break;\n+            }\n+        }\n+    }\n+\n+    return 0;\n }\n \n-int do_extract_onefile(uf,filename,opt_extract_without_path,opt_overwrite)\n-\tunzFile uf;\n-\tconst char* filename;\n-\tint opt_extract_without_path;\n+int do_extract_onefile(uf,filename,opt_extract_without_path,opt_overwrite,password)\n+    unzFile uf;\n+    const char* filename;\n+    int opt_extract_without_path;\n     int opt_overwrite;\n+    const char* password;\n {\n     int err = UNZ_OK;\n     if (unzLocateFile(uf,filename,CASESENSITIVITY)!=UNZ_OK)\n@@ -414,95 +438,119 @@ int do_extract_onefile(uf,filename,opt_extract_without_path,opt_overwrite)\n     }\n \n     if (do_extract_currentfile(uf,&opt_extract_without_path,\n-                                      &opt_overwrite) == UNZ_OK)\n+                                      &opt_overwrite,\n+                                      password) == UNZ_OK)\n         return 0;\n     else\n         return 1;\n }\n \n \n int main(argc,argv)\n-\tint argc;\n-\tchar *argv[];\n+    int argc;\n+    char *argv[];\n {\n-\tconst char *zipfilename=NULL;\n+    const char *zipfilename=NULL;\n     const char *filename_to_extract=NULL;\n-\tint i;\n-\tint opt_do_list=0;\n-\tint opt_do_extract=1;\n-\tint opt_do_extract_withoutpath=0;\n-\tint opt_overwrite=0;\n-\tchar filename_try[512];\n-\tunzFile uf=NULL;\n-\n-\tdo_banner();\n-\tif (argc==1)\n-\t{\n-\t\tdo_help();\n-\t\texit(0);\n-\t}\n-\telse\n-\t{\n-\t\tfor (i=1;i<argc;i++)\n-\t\t{\n-\t\t\tif ((*argv[i])=='-')\n-\t\t\t{\n-\t\t\t\tconst char *p=argv[i]+1;\n-\t\t\t\t\n-\t\t\t\twhile ((*p)!='\\0')\n-\t\t\t\t{\t\t\t\n-\t\t\t\t\tchar c=*(p++);;\n-\t\t\t\t\tif ((c=='l') || (c=='L'))\n-\t\t\t\t\t\topt_do_list = 1;\n-\t\t\t\t\tif ((c=='v') || (c=='V'))\n-\t\t\t\t\t\topt_do_list = 1;\n-\t\t\t\t\tif ((c=='x') || (c=='X'))\n-\t\t\t\t\t\topt_do_extract = 1;\n-\t\t\t\t\tif ((c=='e') || (c=='E'))\n-\t\t\t\t\t\topt_do_extract = opt_do_extract_withoutpath = 1;\n-\t\t\t\t\tif ((c=='o') || (c=='O'))\n-\t\t\t\t\t\topt_overwrite=1;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n+    const char *password=NULL;\n+    char filename_try[MAXFILENAME+16] = \"\";\n+    int i;\n+    int opt_do_list=0;\n+    int opt_do_extract=1;\n+    int opt_do_extract_withoutpath=0;\n+    int opt_overwrite=0;\n+    unzFile uf=NULL;\n+\n+    do_banner();\n+    if (argc==1)\n+    {\n+        do_help();\n+        return 0;\n+    }\n+    else\n+    {\n+        for (i=1;i<argc;i++)\n+        {\n+            if ((*argv[i])=='-')\n+            {\n+                const char *p=argv[i]+1;\n+\n+                while ((*p)!='\\0')\n+                {\n+                    char c=*(p++);;\n+                    if ((c=='l') || (c=='L'))\n+                        opt_do_list = 1;\n+                    if ((c=='v') || (c=='V'))\n+                        opt_do_list = 1;\n+                    if ((c=='x') || (c=='X'))\n+                        opt_do_extract = 1;\n+                    if ((c=='e') || (c=='E'))\n+                        opt_do_extract = opt_do_extract_withoutpath = 1;\n+                    if ((c=='o') || (c=='O'))\n+                        opt_overwrite=1;\n+                    if (((c=='p') || (c=='P')) && (i+1<argc))\n+                    {\n+                        password=argv[i+1];\n+                        i++;\n+                    }\n+                }\n+            }\n+            else\n             {\n-\t\t\t\tif (zipfilename == NULL)\n-\t\t\t\t\tzipfilename = argv[i];\n+                if (zipfilename == NULL)\n+                    zipfilename = argv[i];\n                 else if (filename_to_extract==NULL)\n                         filename_to_extract = argv[i] ;\n             }\n-\t\t}\n-\t}\n-\n-\tif (zipfilename!=NULL)\n-\t{\n-\t\tstrcpy(filename_try,zipfilename);\n-\t\tuf = unzOpen(zipfilename);\n-\t\tif (uf==NULL)\n-\t\t{\n-\t\t\tstrcat(filename_try,\".zip\");\n-\t\t\tuf = unzOpen(filename_try);\n-\t\t}\n-\t}\n-\n-\tif (uf==NULL)\n-\t{\n-\t\tprintf(\"Cannot open %s or %s.zip\\n\",zipfilename,zipfilename);\n-\t\texit (1);\n-\t}\n+        }\n+    }\n+\n+    if (zipfilename!=NULL)\n+    {\n+\n+#        ifdef USEWIN32IOAPI\n+        zlib_filefunc_def ffunc;\n+#        endif\n+\n+        strncpy(filename_try, zipfilename,MAXFILENAME-1);\n+        /* strncpy doesnt append the trailing NULL, of the string is too long. */\n+        filename_try[ MAXFILENAME ] = '\\0';\n+\n+#        ifdef USEWIN32IOAPI\n+        fill_win32_filefunc(&ffunc);\n+        uf = unzOpen2(zipfilename,&ffunc);\n+#        else\n+        uf = unzOpen(zipfilename);\n+#        endif\n+        if (uf==NULL)\n+        {\n+            strcat(filename_try,\".zip\");\n+#            ifdef USEWIN32IOAPI\n+            uf = unzOpen2(filename_try,&ffunc);\n+#            else\n+            uf = unzOpen(filename_try);\n+#            endif\n+        }\n+    }\n+\n+    if (uf==NULL)\n+    {\n+        printf(\"Cannot open %s or %s.zip\\n\",zipfilename,zipfilename);\n+        return 1;\n+    }\n     printf(\"%s opened\\n\",filename_try);\n \n-\tif (opt_do_list==1)\n-\t\treturn do_list(uf);\n-\telse if (opt_do_extract==1)\n+    if (opt_do_list==1)\n+        return do_list(uf);\n+    else if (opt_do_extract==1)\n     {\n         if (filename_to_extract == NULL)\n-\t\t    return do_extract(uf,opt_do_extract_withoutpath,opt_overwrite);\n+            return do_extract(uf,opt_do_extract_withoutpath,opt_overwrite,password);\n         else\n             return do_extract_onefile(uf,filename_to_extract,\n-                                      opt_do_extract_withoutpath,opt_overwrite);\n+                                      opt_do_extract_withoutpath,opt_overwrite,password);\n     }\n-\tunzCloseCurrentFile(uf);\n+    unzCloseCurrentFile(uf);\n \n-\treturn 0;  /* to avoid warning */\n+    return 0;\n }"}, {"sha": "5746f5cff8d437a26025cc96a7dbf9dc92da6461", "filename": "zlib/contrib/minizip/minizip.c", "status": "modified", "additions": 165, "deletions": 70, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Fminizip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Fminizip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fminizip.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -17,6 +17,12 @@\n \n #include \"zip.h\"\n \n+#ifdef WIN32\n+#define USEWIN32IOAPI\n+#include \"iowin32.h\"\n+#endif\n+\n+\n \n #define WRITEBUFFERSIZE (16384)\n #define MAXFILENAME (256)\n@@ -55,12 +61,16 @@ uLong filetime(f, tmzip, dt)\n   struct stat s;        /* results of stat() */\n   struct tm* filedate;\n   time_t tm_t=0;\n-  \n+\n   if (strcmp(f,\"-\")!=0)\n   {\n-    char name[MAXFILENAME];\n+    char name[MAXFILENAME+1];\n     int len = strlen(f);\n-    strcpy(name, f);\n+\n+    strncpy(name, f,MAXFILENAME-1);\n+    /* strncpy doesnt append the trailing NULL, of the string is too long. */\n+    name[ MAXFILENAME ] = '\\0';\n+\n     if (name[len - 1] == '/')\n       name[len - 1] = '\\0';\n     /* not all systems allow stat'ing a file with / appended */\n@@ -98,10 +108,10 @@ uLong filetime(f, tmzip, dt)\n int check_exist_file(filename)\n     const char* filename;\n {\n-\tFILE* ftestexist;\n+    FILE* ftestexist;\n     int ret = 1;\n-\tftestexist = fopen(filename,\"rb\");\n-\tif (ftestexist==NULL)\n+    ftestexist = fopen(filename,\"rb\");\n+    if (ftestexist==NULL)\n         ret = 0;\n     else\n         fclose(ftestexist);\n@@ -110,59 +120,112 @@ int check_exist_file(filename)\n \n void do_banner()\n {\n-\tprintf(\"MiniZip 0.15, demo of zLib + Zip package written by Gilles Vollant\\n\");\n-\tprintf(\"more info at http://wwww.winimage/zLibDll/unzip.htm\\n\\n\");\n+    printf(\"MiniZip 1.00, demo of zLib + Zip package written by Gilles Vollant\\n\");\n+    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n }\n \n void do_help()\n-{\t\n-\tprintf(\"Usage : minizip [-o] file.zip [files_to_add]\\n\\n\") ;\n+{\n+    printf(\"Usage : minizip [-o] [-a] [-0 to -9] [-p password] file.zip [files_to_add]\\n\\n\" \\\n+           \"  -o  Overwrite existing file.zip\\n\" \\\n+           \"  -a  Append to existing file.zip\\n\" \\\n+           \"  -0  Store only\\n\" \\\n+           \"  -1  Compress faster\\n\" \\\n+           \"  -9  Compress better\\n\\n\");\n+}\n+\n+/* calculate the CRC32 of a file,\n+   because to encrypt a file, we need known the CRC32 of the file before */\n+int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)\n+{\n+   unsigned long calculate_crc=0;\n+   int err=ZIP_OK;\n+   FILE * fin = fopen(filenameinzip,\"rb\");\n+   unsigned long size_read = 0;\n+   unsigned long total_read = 0;\n+   if (fin==NULL)\n+   {\n+       err = ZIP_ERRNO;\n+   }\n+\n+    if (err == ZIP_OK)\n+        do\n+        {\n+            err = ZIP_OK;\n+            size_read = (int)fread(buf,1,size_buf,fin);\n+            if (size_read < size_buf)\n+                if (feof(fin)==0)\n+            {\n+                printf(\"error in reading %s\\n\",filenameinzip);\n+                err = ZIP_ERRNO;\n+            }\n+\n+            if (size_read>0)\n+                calculate_crc = crc32(calculate_crc,buf,size_read);\n+            total_read += size_read;\n+\n+        } while ((err == ZIP_OK) && (size_read>0));\n+\n+    if (fin)\n+        fclose(fin);\n+\n+    *result_crc=calculate_crc;\n+    printf(\"file %s crc %x\\n\",filenameinzip,calculate_crc);\n+    return err;\n }\n \n int main(argc,argv)\n-\tint argc;\n-\tchar *argv[];\n+    int argc;\n+    char *argv[];\n {\n-\tint i;\n-\tint opt_overwrite=0;\n+    int i;\n+    int opt_overwrite=0;\n     int opt_compress_level=Z_DEFAULT_COMPRESSION;\n     int zipfilenamearg = 0;\n-\tchar filename_try[MAXFILENAME];\n+    char filename_try[MAXFILENAME+16];\n     int zipok;\n     int err=0;\n     int size_buf=0;\n-    void* buf=NULL,\n+    void* buf=NULL;\n+    const char* password=NULL;\n \n \n-\tdo_banner();\n-\tif (argc==1)\n-\t{\n-\t\tdo_help();\n-\t\texit(0);\n+    do_banner();\n+    if (argc==1)\n+    {\n+        do_help();\n         return 0;\n-\t}\n-\telse\n-\t{\n-\t\tfor (i=1;i<argc;i++)\n-\t\t{\n-\t\t\tif ((*argv[i])=='-')\n-\t\t\t{\n-\t\t\t\tconst char *p=argv[i]+1;\n-\t\t\t\t\n-\t\t\t\twhile ((*p)!='\\0')\n-\t\t\t\t{\t\t\t\n-\t\t\t\t\tchar c=*(p++);;\n-\t\t\t\t\tif ((c=='o') || (c=='O'))\n-\t\t\t\t\t\topt_overwrite = 1;\n+    }\n+    else\n+    {\n+        for (i=1;i<argc;i++)\n+        {\n+            if ((*argv[i])=='-')\n+            {\n+                const char *p=argv[i]+1;\n+\n+                while ((*p)!='\\0')\n+                {\n+                    char c=*(p++);;\n+                    if ((c=='o') || (c=='O'))\n+                        opt_overwrite = 1;\n+                    if ((c=='a') || (c=='A'))\n+                        opt_overwrite = 2;\n                     if ((c>='0') && (c<='9'))\n                         opt_compress_level = c-'0';\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse\n-\t\t\t\tif (zipfilenamearg == 0)\n+\n+                    if (((c=='p') || (c=='P')) && (i+1<argc))\n+                    {\n+                        password=argv[i+1];\n+                        i++;\n+                    }\n+                }\n+            }\n+            else\n+                if (zipfilenamearg == 0)\n                     zipfilenamearg = i ;\n-\t\t}\n-\t}\n+        }\n+    }\n \n     size_buf = WRITEBUFFERSIZE;\n     buf = (void*)malloc(size_buf);\n@@ -172,53 +235,72 @@ int main(argc,argv)\n         return ZIP_INTERNALERROR;\n     }\n \n-\tif (zipfilenamearg==0)\n+    if (zipfilenamearg==0)\n         zipok=0;\n     else\n-\t{\n+    {\n         int i,len;\n         int dot_found=0;\n \n         zipok = 1 ;\n-\t\tstrcpy(filename_try,argv[zipfilenamearg]);\n-        len=strlen(filename_try);\n+        strncpy(filename_try, argv[zipfilenamearg],MAXFILENAME-1);\n+        /* strncpy doesnt append the trailing NULL, of the string is too long. */\n+        filename_try[ MAXFILENAME ] = '\\0';\n+\n+        len=(int)strlen(filename_try);\n         for (i=0;i<len;i++)\n             if (filename_try[i]=='.')\n                 dot_found=1;\n \n         if (dot_found==0)\n             strcat(filename_try,\".zip\");\n \n+        if (opt_overwrite==2)\n+        {\n+            /* if the file don't exist, we not append file */\n+            if (check_exist_file(filename_try)==0)\n+                opt_overwrite=1;\n+        }\n+        else\n         if (opt_overwrite==0)\n             if (check_exist_file(filename_try)!=0)\n-\t\t\t{\n-                char rep;\n-\t\t\t\tdo\n-\t\t\t\t{\n-\t\t\t\t\tchar answer[128];\n-\t\t\t\t\tprintf(\"The file %s exist. Overwrite ? [y]es, [n]o : \",filename_try);\n-\t\t\t\t\tscanf(\"%1s\",answer);\n-\t\t\t\t\trep = answer[0] ;\n-\t\t\t\t\tif ((rep>='a') && (rep<='z'))\n-\t\t\t\t\t\trep -= 0x20;\n-\t\t\t\t}\n-\t\t\t\twhile ((rep!='Y') && (rep!='N'));\n+            {\n+                char rep=0;\n+                do\n+                {\n+                    char answer[128];\n+                    printf(\"The file %s exist. Overwrite ? [y]es, [n]o, [a]ppend : \",filename_try);\n+                    scanf(\"%1s\",answer);\n+                    rep = answer[0] ;\n+                    if ((rep>='a') && (rep<='z'))\n+                        rep -= 0x20;\n+                }\n+                while ((rep!='Y') && (rep!='N') && (rep!='A'));\n                 if (rep=='N')\n                     zipok = 0;\n-\t\t\t}\n+                if (rep=='A')\n+                    opt_overwrite = 2;\n+            }\n     }\n \n     if (zipok==1)\n     {\n         zipFile zf;\n         int errclose;\n-        zf = zipOpen(filename_try,0);\n+#        ifdef USEWIN32IOAPI\n+        zlib_filefunc_def ffunc;\n+        fill_win32_filefunc(&ffunc);\n+        zf = zipOpen2(filename_try,(opt_overwrite==2) ? 2 : 0,NULL,&ffunc);\n+#        else\n+        zf = zipOpen(filename_try,(opt_overwrite==2) ? 2 : 0);\n+#        endif\n+\n         if (zf == NULL)\n         {\n             printf(\"error opening %s\\n\",filename_try);\n             err= ZIP_ERRNO;\n         }\n-        else \n+        else\n             printf(\"creating %s\\n\",filename_try);\n \n         for (i=zipfilenamearg+1;(i<argc) && (err==ZIP_OK);i++)\n@@ -229,19 +311,31 @@ int main(argc,argv)\n                 int size_read;\n                 const char* filenameinzip = argv[i];\n                 zip_fileinfo zi;\n+                unsigned long crcFile=0;\n \n-                zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour = \n-                zi.tmz_date.tm_mday = zi.tmz_date.tm_min = zi.tmz_date.tm_year = 0;\n+                zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour =\n+                zi.tmz_date.tm_mday = zi.tmz_date.tm_mon = zi.tmz_date.tm_year = 0;\n                 zi.dosDate = 0;\n                 zi.internal_fa = 0;\n                 zi.external_fa = 0;\n                 filetime(filenameinzip,&zi.tmz_date,&zi.dosDate);\n \n-\n+/*\n                 err = zipOpenNewFileInZip(zf,filenameinzip,&zi,\n-                                 NULL,0,NULL,0,NULL /* comment*/,\n+                                 NULL,0,NULL,0,NULL / * comment * /,\n                                  (opt_compress_level != 0) ? Z_DEFLATED : 0,\n                                  opt_compress_level);\n+*/\n+                if ((password != NULL) && (err==ZIP_OK))\n+                    err = getFileCrc(filenameinzip,buf,size_buf,&crcFile);\n+\n+                err = zipOpenNewFileInZip3(zf,filenameinzip,&zi,\n+                                 NULL,0,NULL,0,NULL /* comment*/,\n+                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,\n+                                 opt_compress_level,0,\n+                                 /* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */\n+                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n+                                 password,crcFile);\n \n                 if (err != ZIP_OK)\n                     printf(\"error in opening %s in zipfile\\n\",filenameinzip);\n@@ -259,7 +353,7 @@ int main(argc,argv)\n                     do\n                     {\n                         err = ZIP_OK;\n-                        size_read = fread(buf,1,size_buf,fin);\n+                        size_read = (int)fread(buf,1,size_buf,fin);\n                         if (size_read < size_buf)\n                             if (feof(fin)==0)\n                         {\n@@ -275,15 +369,17 @@ int main(argc,argv)\n                                 printf(\"error in writing %s in the zipfile\\n\",\n                                                  filenameinzip);\n                             }\n-                                \n+\n                         }\n                     } while ((err == ZIP_OK) && (size_read>0));\n \n-                fclose(fin);\n+                if (fin)\n+                    fclose(fin);\n+\n                 if (err<0)\n                     err=ZIP_ERRNO;\n                 else\n-                {                    \n+                {\n                     err = zipCloseFileInZip(zf);\n                     if (err!=ZIP_OK)\n                         printf(\"error in closing %s in the zipfile\\n\",\n@@ -297,6 +393,5 @@ int main(argc,argv)\n    }\n \n     free(buf);\n-    exit(0);\n-\treturn 0;  /* to avoid warning */\n+    return 0;\n }"}, {"sha": "1fc023c720b1f8f089559d0b88e772b1362a6878", "filename": "zlib/contrib/minizip/readme.txt", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Freadme.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Freadme.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Freadme.txt?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,37 +0,0 @@\n-\n-UnZip 0.15 additionnal library\n-\n-\n-  This unzip package allow extract file from .ZIP file, compatible with \n-PKZip 2.04g, WinZip, InfoZip tools and compatible.\n-\n-  Multi volume ZipFile (span) are not supported, and old compression used by old \n-PKZip 1.x are not supported.\n-\n-See probdesc.zip from PKWare for specification of .ZIP format.\n-\n-What is Unzip\n-  The Zlib library support the deflate compression and the creation of gzip (.gz) \n-file. Zlib is free and small.\n-  The .Zip format, which can contain several compressed files (.gz can containt\n-only one file) is a very popular format. This is why I've written a package for reading file compressed in Zipfile.\n-\n-Using Unzip package\n-\n-You need source of Zlib (get zlib111.zip and read zlib.h).\n-Get unzlb015.zip and read unzip.h (whith documentation of unzip functions)\n-\n-The Unzip package is only two file : unzip.h and unzip.c. But it use the Zlib \n-  files.\n-unztst.c is a simple sample program, which list file in a zipfile and display\n-  README.TXT or FILE_ID.DIZ (if these files are found).\n-miniunz.c is a mini unzip program.\n-\n-I'm also currenlyt writing a zipping portion (zip.h, zip.c and test with minizip.c)\n-\n-Please email me for feedback.\n-I hope my source is compatible with Unix system, but I need your help for be sure\n-\n-Latest revision : Mar 04th, 1998\n-\n-Check http://www.winimage.com/zLibDll/unzip.html for up to date info."}, {"sha": "f08f624f00f270d33fcfa9bb5dcd09da8dfe706f", "filename": "zlib/contrib/minizip/unzip.c", "status": "modified", "additions": 1061, "deletions": 809, "changes": 1870, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Funzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Funzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,9 +1,39 @@\n-/* unzip.c -- IO on .zip files using zlib \n-   Version 0.15 beta, Mar 19th, 1998,\n+/* unzip.c -- IO for uncompress .zip files using zlib\n+   Version 1.00, September 10th, 2003\n+\n+   Copyright (C) 1998-2003 Gilles Vollant\n \n    Read unzip.h for more info\n */\n \n+/* Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of\n+compatibility with older software. The following is from the original crypt.c. Code\n+woven in by Terry Thorsen 1/2003.\n+*/\n+/*\n+  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.\n+\n+  See the accompanying file LICENSE, version 2000-Apr-09 or later\n+  (the contents of which are also included in zip.h) for terms of use.\n+  If, for some reason, all these files are missing, the Info-ZIP license\n+  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html\n+*/\n+/*\n+  crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]\n+\n+  The encryption/decryption parts of this source code (as opposed to the\n+  non-echoing password parts) were originally written in Europe.  The\n+  whole source package can be freely distributed, including from the USA.\n+  (Prior to January 2000, re-export from the US was a violation of US law.)\n+ */\n+\n+/*\n+  This encryption code is a direct transcription of the algorithm from\n+  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This\n+  file (appnote.txt) is distributed with the PKZIP program (even in the\n+  version without encryption capabilities).\n+ */\n+\n \n #include <stdio.h>\n #include <stdlib.h>\n@@ -29,10 +59,10 @@\n /* compile with -Dlocal if your debugger can't find static symbols */\n \n \n-\n-#if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES) && \\\n-                      !defined(CASESENSITIVITYDEFAULT_NO)\n-#define CASESENSITIVITYDEFAULT_NO\n+#ifndef CASESENSITIVITYDEFAULT_NO\n+#  if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES)\n+#    define CASESENSITIVITYDEFAULT_NO\n+#  endif\n #endif\n \n \n@@ -55,22 +85,10 @@\n #define SIZEZIPLOCALHEADER (0x1e)\n \n \n-/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */\n-\n-#ifndef SEEK_CUR\n-#define SEEK_CUR    1\n-#endif\n-\n-#ifndef SEEK_END\n-#define SEEK_END    2\n-#endif\n \n-#ifndef SEEK_SET\n-#define SEEK_SET    0\n-#endif\n \n const char unz_copyright[] =\n-   \" unzip 0.15 Copyright 1998 Gilles Vollant \";\n+   \" unzip 1.00 Copyright 1998-2003 Gilles Vollant - http://www.winimage.com/zLibDll\";\n \n /* unz_file_info_interntal contain internal info about a file in zipfile*/\n typedef struct unz_file_info_internal_s\n@@ -83,70 +101,88 @@ typedef struct unz_file_info_internal_s\n     when reading and decompress it */\n typedef struct\n {\n-\tchar  *read_buffer;         /* internal buffer for compressed data */\n-\tz_stream stream;            /* zLib stream structure for inflate */\n-\n-\tuLong pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/\n-\tuLong stream_initialised;   /* flag set if stream structure is initialised*/\n-\n-\tuLong offset_local_extrafield;/* offset of the local extra field */\n-\tuInt  size_local_extrafield;/* size of the local extra field */\n-\tuLong pos_local_extrafield;   /* position in the local extra field in read*/\n-\n-\tuLong crc32;                /* crc32 of all data uncompressed */\n-\tuLong crc32_wait;           /* crc32 we must obtain after decompress all */\n-\tuLong rest_read_compressed; /* number of byte to be decompressed */\n-\tuLong rest_read_uncompressed;/*number of byte to be obtained after decomp*/\n-\tFILE* file;                 /* io structore of the zipfile */\n-\tuLong compression_method;   /* compression method (0==store) */\n-\tuLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n+    char  *read_buffer;         /* internal buffer for compressed data */\n+    z_stream stream;            /* zLib stream structure for inflate */\n+\n+    uLong pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/\n+    uLong stream_initialised;   /* flag set if stream structure is initialised*/\n+\n+    uLong offset_local_extrafield;/* offset of the local extra field */\n+    uInt  size_local_extrafield;/* size of the local extra field */\n+    uLong pos_local_extrafield;   /* position in the local extra field in read*/\n+\n+    uLong crc32;                /* crc32 of all data uncompressed */\n+    uLong crc32_wait;           /* crc32 we must obtain after decompress all */\n+    uLong rest_read_compressed; /* number of byte to be decompressed */\n+    uLong rest_read_uncompressed;/*number of byte to be obtained after decomp*/\n+    zlib_filefunc_def z_filefunc;\n+    voidpf filestream;        /* io structore of the zipfile */\n+    uLong compression_method;   /* compression method (0==store) */\n+    uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n+    int   raw;\n } file_in_zip_read_info_s;\n \n \n /* unz_s contain internal information about the zipfile\n */\n typedef struct\n {\n-\tFILE* file;                 /* io structore of the zipfile */\n-\tunz_global_info gi;       /* public global information */\n-\tuLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n-\tuLong num_file;             /* number of the current file in the zipfile*/\n-\tuLong pos_in_central_dir;   /* pos of the current file in the central dir*/\n-\tuLong current_file_ok;      /* flag about the usability of the current file*/\n-\tuLong central_pos;          /* position of the beginning of the central dir*/\n-\n-\tuLong size_central_dir;     /* size of the central directory  */\n-\tuLong offset_central_dir;   /* offset of start of central directory with\n-\t\t\t\t\t\t\t\t   respect to the starting disk number */\n-\n-\tunz_file_info cur_file_info; /* public info about the current file in zip*/\n-\tunz_file_info_internal cur_file_info_internal; /* private info about it*/\n+    zlib_filefunc_def z_filefunc;\n+    voidpf filestream;        /* io structore of the zipfile */\n+    unz_global_info gi;       /* public global information */\n+    uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n+    uLong num_file;             /* number of the current file in the zipfile*/\n+    uLong pos_in_central_dir;   /* pos of the current file in the central dir*/\n+    uLong current_file_ok;      /* flag about the usability of the current file*/\n+    uLong central_pos;          /* position of the beginning of the central dir*/\n+\n+    uLong size_central_dir;     /* size of the central directory  */\n+    uLong offset_central_dir;   /* offset of start of central directory with\n+                                   respect to the starting disk number */\n+\n+    unz_file_info cur_file_info; /* public info about the current file in zip*/\n+    unz_file_info_internal cur_file_info_internal; /* private info about it*/\n     file_in_zip_read_info_s* pfile_in_zip_read; /* structure about the current\n-\t                                    file if we are decompressing it */\n+                                        file if we are decompressing it */\n+    int encrypted;\n+#    ifndef NOUNCRYPT\n+    unsigned long keys[3];     /* keys defining the pseudo-random sequence */\n+    const unsigned long* pcrc_32_tab;\n+#    endif\n } unz_s;\n \n \n+#ifndef NOUNCRYPT\n+#include \"crypt.h\"\n+#endif\n+\n /* ===========================================================================\n      Read a byte from a gz_stream; update next_in and avail_in. Return EOF\n    for end of file.\n    IN assertion: the stream s has been sucessfully opened for reading.\n */\n \n \n-local int unzlocal_getByte(fin,pi)\n-\tFILE *fin;\n-\tint *pi;\n+local int unzlocal_getByte OF((\n+    const zlib_filefunc_def* pzlib_filefunc_def,\n+    voidpf filestream,\n+    int *pi));\n+\n+local int unzlocal_getByte(pzlib_filefunc_def,filestream,pi)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n+    int *pi;\n {\n     unsigned char c;\n-\tint err = fread(&c, 1, 1, fin);\n+    int err = (int)ZREAD(*pzlib_filefunc_def,filestream,&c,1);\n     if (err==1)\n     {\n         *pi = (int)c;\n         return UNZ_OK;\n     }\n     else\n     {\n-        if (ferror(fin)) \n+        if (ZERROR(*pzlib_filefunc_def,filestream))\n             return UNZ_ERRNO;\n         else\n             return UNZ_EOF;\n@@ -155,53 +191,65 @@ local int unzlocal_getByte(fin,pi)\n \n \n /* ===========================================================================\n-   Reads a long in LSB order from the given gz_stream. Sets \n+   Reads a long in LSB order from the given gz_stream. Sets\n */\n-local int unzlocal_getShort (fin,pX)\n-\tFILE* fin;\n+local int unzlocal_getShort OF((\n+    const zlib_filefunc_def* pzlib_filefunc_def,\n+    voidpf filestream,\n+    uLong *pX));\n+\n+local int unzlocal_getShort (pzlib_filefunc_def,filestream,pX)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n     uLong *pX;\n {\n     uLong x ;\n     int i;\n     int err;\n \n-    err = unzlocal_getByte(fin,&i);\n+    err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);\n     x = (uLong)i;\n-    \n+\n     if (err==UNZ_OK)\n-        err = unzlocal_getByte(fin,&i);\n+        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);\n     x += ((uLong)i)<<8;\n-   \n+\n     if (err==UNZ_OK)\n         *pX = x;\n     else\n         *pX = 0;\n     return err;\n }\n \n-local int unzlocal_getLong (fin,pX)\n-\tFILE* fin;\n+local int unzlocal_getLong OF((\n+    const zlib_filefunc_def* pzlib_filefunc_def,\n+    voidpf filestream,\n+    uLong *pX));\n+\n+local int unzlocal_getLong (pzlib_filefunc_def,filestream,pX)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n     uLong *pX;\n {\n     uLong x ;\n     int i;\n     int err;\n \n-    err = unzlocal_getByte(fin,&i);\n+    err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);\n     x = (uLong)i;\n-    \n+\n     if (err==UNZ_OK)\n-        err = unzlocal_getByte(fin,&i);\n+        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);\n     x += ((uLong)i)<<8;\n \n     if (err==UNZ_OK)\n-        err = unzlocal_getByte(fin,&i);\n+        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);\n     x += ((uLong)i)<<16;\n \n     if (err==UNZ_OK)\n-        err = unzlocal_getByte(fin,&i);\n+        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);\n     x += ((uLong)i)<<24;\n-   \n+\n     if (err==UNZ_OK)\n         *pX = x;\n     else\n@@ -212,26 +260,26 @@ local int unzlocal_getLong (fin,pX)\n \n /* My own strcmpi / strcasecmp */\n local int strcmpcasenosensitive_internal (fileName1,fileName2)\n-\tconst char* fileName1;\n-\tconst char* fileName2;\n+    const char* fileName1;\n+    const char* fileName2;\n {\n-\tfor (;;)\n-\t{\n-\t\tchar c1=*(fileName1++);\n-\t\tchar c2=*(fileName2++);\n-\t\tif ((c1>='a') && (c1<='z'))\n-\t\t\tc1 -= 0x20;\n-\t\tif ((c2>='a') && (c2<='z'))\n-\t\t\tc2 -= 0x20;\n-\t\tif (c1=='\\0')\n-\t\t\treturn ((c2=='\\0') ? 0 : -1);\n-\t\tif (c2=='\\0')\n-\t\t\treturn 1;\n-\t\tif (c1<c2)\n-\t\t\treturn -1;\n-\t\tif (c1>c2)\n-\t\t\treturn 1;\n-\t}\n+    for (;;)\n+    {\n+        char c1=*(fileName1++);\n+        char c2=*(fileName2++);\n+        if ((c1>='a') && (c1<='z'))\n+            c1 -= 0x20;\n+        if ((c2>='a') && (c2<='z'))\n+            c2 -= 0x20;\n+        if (c1=='\\0')\n+            return ((c2=='\\0') ? 0 : -1);\n+        if (c2=='\\0')\n+            return 1;\n+        if (c1<c2)\n+            return -1;\n+        if (c1>c2)\n+            return 1;\n+    }\n }\n \n \n@@ -245,7 +293,7 @@ local int strcmpcasenosensitive_internal (fileName1,fileName2)\n #define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal\n #endif\n \n-/* \n+/*\n    Compare two filename (fileName1,fileName2).\n    If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n    If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n@@ -255,203 +303,225 @@ local int strcmpcasenosensitive_internal (fileName1,fileName2)\n \n */\n extern int ZEXPORT unzStringFileNameCompare (fileName1,fileName2,iCaseSensitivity)\n-\tconst char* fileName1;\n-\tconst char* fileName2;\n-\tint iCaseSensitivity;\n+    const char* fileName1;\n+    const char* fileName2;\n+    int iCaseSensitivity;\n {\n-\tif (iCaseSensitivity==0)\n-\t\tiCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n+    if (iCaseSensitivity==0)\n+        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n \n-\tif (iCaseSensitivity==1)\n-\t\treturn strcmp(fileName1,fileName2);\n+    if (iCaseSensitivity==1)\n+        return strcmp(fileName1,fileName2);\n \n-\treturn STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n-} \n+    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n+}\n \n+#ifndef BUFREADCOMMENT\n #define BUFREADCOMMENT (0x400)\n+#endif\n \n /*\n   Locate the Central directory of a zipfile (at the end, just before\n     the global comment)\n */\n-local uLong unzlocal_SearchCentralDir(fin)\n-\tFILE *fin;\n+local uLong unzlocal_SearchCentralDir OF((\n+    const zlib_filefunc_def* pzlib_filefunc_def,\n+    voidpf filestream));\n+\n+local uLong unzlocal_SearchCentralDir(pzlib_filefunc_def,filestream)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n {\n-\tunsigned char* buf;\n-\tuLong uSizeFile;\n-\tuLong uBackRead;\n-\tuLong uMaxBack=0xffff; /* maximum size of global comment */\n-\tuLong uPosFound=0;\n-\t\n-\tif (fseek(fin,0,SEEK_END) != 0)\n-\t\treturn 0;\n-\n-\n-\tuSizeFile = ftell( fin );\n-\t\n-\tif (uMaxBack>uSizeFile)\n-\t\tuMaxBack = uSizeFile;\n-\n-\tbuf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n-\tif (buf==NULL)\n-\t\treturn 0;\n-\n-\tuBackRead = 4;\n-\twhile (uBackRead<uMaxBack)\n-\t{\n-\t\tuLong uReadSize,uReadPos ;\n-\t\tint i;\n-\t\tif (uBackRead+BUFREADCOMMENT>uMaxBack) \n-\t\t\tuBackRead = uMaxBack;\n-\t\telse\n-\t\t\tuBackRead+=BUFREADCOMMENT;\n-\t\tuReadPos = uSizeFile-uBackRead ;\n-\t\t\n-\t\tuReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ? \n+    unsigned char* buf;\n+    uLong uSizeFile;\n+    uLong uBackRead;\n+    uLong uMaxBack=0xffff; /* maximum size of global comment */\n+    uLong uPosFound=0;\n+\n+    if (ZSEEK(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n+        return 0;\n+\n+\n+    uSizeFile = ZTELL(*pzlib_filefunc_def,filestream);\n+\n+    if (uMaxBack>uSizeFile)\n+        uMaxBack = uSizeFile;\n+\n+    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n+    if (buf==NULL)\n+        return 0;\n+\n+    uBackRead = 4;\n+    while (uBackRead<uMaxBack)\n+    {\n+        uLong uReadSize,uReadPos ;\n+        int i;\n+        if (uBackRead+BUFREADCOMMENT>uMaxBack)\n+            uBackRead = uMaxBack;\n+        else\n+            uBackRead+=BUFREADCOMMENT;\n+        uReadPos = uSizeFile-uBackRead ;\n+\n+        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n                      (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);\n-\t\tif (fseek(fin,uReadPos,SEEK_SET)!=0)\n-\t\t\tbreak;\n-\n-\t\tif (fread(buf,(uInt)uReadSize,1,fin)!=1)\n-\t\t\tbreak;\n-\n-                for (i=(int)uReadSize-3; (i--)>0;)\n-\t\t\tif (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && \n-\t\t\t\t((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n-\t\t\t{\n-\t\t\t\tuPosFound = uReadPos+i;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\n-\t\tif (uPosFound!=0)\n-\t\t\tbreak;\n-\t}\n-\tTRYFREE(buf);\n-\treturn uPosFound;\n+        if (ZSEEK(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+            break;\n+\n+        if (ZREAD(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n+            break;\n+\n+        for (i=(int)uReadSize-3; (i--)>0;)\n+            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n+                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n+            {\n+                uPosFound = uReadPos+i;\n+                break;\n+            }\n+\n+        if (uPosFound!=0)\n+            break;\n+    }\n+    TRYFREE(buf);\n+    return uPosFound;\n }\n \n /*\n   Open a Zip file. path contain the full pathname (by example,\n-     on a Windows NT computer \"c:\\\\test\\\\zlib109.zip\" or on an Unix computer\n-\t \"zlib/zlib109.zip\".\n-\t If the zipfile cannot be opened (file don't exist or in not valid), the\n-\t   return value is NULL.\n+     on a Windows NT computer \"c:\\\\test\\\\zlib114.zip\" or on an Unix computer\n+     \"zlib/zlib114.zip\".\n+     If the zipfile cannot be opened (file doesn't exist or in not valid), the\n+       return value is NULL.\n      Else, the return value is a unzFile Handle, usable with other function\n-\t   of this unzip package.\n+       of this unzip package.\n */\n-extern unzFile ZEXPORT unzOpen (path)\n-\tconst char *path;\n+extern unzFile ZEXPORT unzOpen2 (path, pzlib_filefunc_def)\n+    const char *path;\n+    zlib_filefunc_def* pzlib_filefunc_def;\n {\n-\tunz_s us;\n-\tunz_s *s;\n-\tuLong central_pos,uL;\n-\tFILE * fin ;\n+    unz_s us;\n+    unz_s *s;\n+    uLong central_pos,uL;\n \n-\tuLong number_disk;          /* number of the current dist, used for \n-\t\t\t\t\t\t\t\t   spaning ZIP, unsupported, always 0*/\n-\tuLong number_disk_with_CD;  /* number the the disk with central dir, used\n-\t\t\t\t\t\t\t\t   for spaning ZIP, unsupported, always 0*/\n-\tuLong number_entry_CD;      /* total number of entries in\n-\t                               the central dir \n-\t                               (same than number_entry on nospan) */\n+    uLong number_disk;          /* number of the current dist, used for\n+                                   spaning ZIP, unsupported, always 0*/\n+    uLong number_disk_with_CD;  /* number the the disk with central dir, used\n+                                   for spaning ZIP, unsupported, always 0*/\n+    uLong number_entry_CD;      /* total number of entries in\n+                                   the central dir\n+                                   (same than number_entry on nospan) */\n \n-\tint err=UNZ_OK;\n+    int err=UNZ_OK;\n \n     if (unz_copyright[0]!=' ')\n         return NULL;\n \n-    fin=fopen(path,\"rb\");\n-\tif (fin==NULL)\n-\t\treturn NULL;\n-\n-\tcentral_pos = unzlocal_SearchCentralDir(fin);\n-\tif (central_pos==0)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (fseek(fin,central_pos,SEEK_SET)!=0)\n-\t\terr=UNZ_ERRNO;\n-\n-\t/* the signature, already checked */\n-\tif (unzlocal_getLong(fin,&uL)!=UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\t/* number of this disk */\n-\tif (unzlocal_getShort(fin,&number_disk)!=UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\t/* number of the disk with the start of the central directory */\n-\tif (unzlocal_getShort(fin,&number_disk_with_CD)!=UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\t/* total number of entries in the central dir on this disk */\n-\tif (unzlocal_getShort(fin,&us.gi.number_entry)!=UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\t/* total number of entries in the central dir */\n-\tif (unzlocal_getShort(fin,&number_entry_CD)!=UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif ((number_entry_CD!=us.gi.number_entry) ||\n-\t\t(number_disk_with_CD!=0) ||\n-\t\t(number_disk!=0))\n-\t\terr=UNZ_BADZIPFILE;\n-\n-\t/* size of the central directory */\n-\tif (unzlocal_getLong(fin,&us.size_central_dir)!=UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\t/* offset of start of central directory with respect to the \n-\t      starting disk number */\n-\tif (unzlocal_getLong(fin,&us.offset_central_dir)!=UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\t/* zipfile comment length */\n-\tif (unzlocal_getShort(fin,&us.gi.size_comment)!=UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif ((central_pos<us.offset_central_dir+us.size_central_dir) && \n-\t\t(err==UNZ_OK))\n-\t\terr=UNZ_BADZIPFILE;\n-\n-\tif (err!=UNZ_OK)\n-\t{\n-\t\tfclose(fin);\n-\t\treturn NULL;\n-\t}\n-\n-\tus.file=fin;\n-\tus.byte_before_the_zipfile = central_pos -\n-\t\t                    (us.offset_central_dir+us.size_central_dir);\n-\tus.central_pos = central_pos;\n+    if (pzlib_filefunc_def==NULL)\n+        fill_fopen_filefunc(&us.z_filefunc);\n+    else\n+        us.z_filefunc = *pzlib_filefunc_def;\n+\n+    us.filestream= (*(us.z_filefunc.zopen_file))(us.z_filefunc.opaque,\n+                                                 path,\n+                                                 ZLIB_FILEFUNC_MODE_READ |\n+                                                 ZLIB_FILEFUNC_MODE_EXISTING);\n+    if (us.filestream==NULL)\n+        return NULL;\n+\n+    central_pos = unzlocal_SearchCentralDir(&us.z_filefunc,us.filestream);\n+    if (central_pos==0)\n+        err=UNZ_ERRNO;\n+\n+    if (ZSEEK(us.z_filefunc, us.filestream,\n+                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+        err=UNZ_ERRNO;\n+\n+    /* the signature, already checked */\n+    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    /* number of this disk */\n+    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    /* number of the disk with the start of the central directory */\n+    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    /* total number of entries in the central dir on this disk */\n+    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    /* total number of entries in the central dir */\n+    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if ((number_entry_CD!=us.gi.number_entry) ||\n+        (number_disk_with_CD!=0) ||\n+        (number_disk!=0))\n+        err=UNZ_BADZIPFILE;\n+\n+    /* size of the central directory */\n+    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    /* offset of start of central directory with respect to the\n+          starting disk number */\n+    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    /* zipfile comment length */\n+    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&\n+        (err==UNZ_OK))\n+        err=UNZ_BADZIPFILE;\n+\n+    if (err!=UNZ_OK)\n+    {\n+        ZCLOSE(us.z_filefunc, us.filestream);\n+        return NULL;\n+    }\n+\n+    us.byte_before_the_zipfile = central_pos -\n+                            (us.offset_central_dir+us.size_central_dir);\n+    us.central_pos = central_pos;\n     us.pfile_in_zip_read = NULL;\n-\t\n+    us.encrypted = 0;\n+\n \n-\ts=(unz_s*)ALLOC(sizeof(unz_s));\n-\t*s=us;\n-\tunzGoToFirstFile((unzFile)s);\t\n-\treturn (unzFile)s;\t\n+    s=(unz_s*)ALLOC(sizeof(unz_s));\n+    *s=us;\n+    unzGoToFirstFile((unzFile)s);\n+    return (unzFile)s;\n }\n \n \n+extern unzFile ZEXPORT unzOpen (path)\n+    const char *path;\n+{\n+    return unzOpen2(path, NULL);\n+}\n+\n /*\n   Close a ZipFile opened with unzipOpen.\n   If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),\n     these files MUST be closed with unzipCloseCurrentFile before call unzipClose.\n   return UNZ_OK if there is no problem. */\n extern int ZEXPORT unzClose (file)\n-\tunzFile file;\n+    unzFile file;\n {\n-\tunz_s* s;\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n+    unz_s* s;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n \n     if (s->pfile_in_zip_read!=NULL)\n         unzCloseCurrentFile(file);\n \n-\tfclose(s->file);\n-\tTRYFREE(s);\n-\treturn UNZ_OK;\n+    ZCLOSE(s->z_filefunc, s->filestream);\n+    TRYFREE(s);\n+    return UNZ_OK;\n }\n \n \n@@ -460,15 +530,15 @@ extern int ZEXPORT unzClose (file)\n   No preparation of the structure is needed\n   return UNZ_OK if there is no problem. */\n extern int ZEXPORT unzGetGlobalInfo (file,pglobal_info)\n-\tunzFile file;\n-\tunz_global_info *pglobal_info;\n+    unzFile file;\n+    unz_global_info *pglobal_info;\n {\n-\tunz_s* s;\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n-\t*pglobal_info=s->gi;\n-\treturn UNZ_OK;\n+    unz_s* s;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+    *pglobal_info=s->gi;\n+    return UNZ_OK;\n }\n \n \n@@ -495,171 +565,173 @@ local void unzlocal_DosDateToTmuDate (ulDosDate, ptm)\n */\n local int unzlocal_GetCurrentFileInfoInternal OF((unzFile file,\n                                                   unz_file_info *pfile_info,\n-                                                  unz_file_info_internal \n+                                                  unz_file_info_internal\n                                                   *pfile_info_internal,\n                                                   char *szFileName,\n-\t\t\t\t\t\t\t\t\t\t\t\t  uLong fileNameBufferSize,\n+                                                  uLong fileNameBufferSize,\n                                                   void *extraField,\n-\t\t\t\t\t\t\t\t\t\t\t\t  uLong extraFieldBufferSize,\n+                                                  uLong extraFieldBufferSize,\n                                                   char *szComment,\n-\t\t\t\t\t\t\t\t\t\t\t\t  uLong commentBufferSize));\n+                                                  uLong commentBufferSize));\n \n local int unzlocal_GetCurrentFileInfoInternal (file,\n                                               pfile_info,\n                                               pfile_info_internal,\n                                               szFileName, fileNameBufferSize,\n                                               extraField, extraFieldBufferSize,\n                                               szComment,  commentBufferSize)\n-\tunzFile file;\n-\tunz_file_info *pfile_info;\n-\tunz_file_info_internal *pfile_info_internal;\n-\tchar *szFileName;\n-\tuLong fileNameBufferSize;\n-\tvoid *extraField;\n-\tuLong extraFieldBufferSize;\n-\tchar *szComment;\n-\tuLong commentBufferSize;\n+    unzFile file;\n+    unz_file_info *pfile_info;\n+    unz_file_info_internal *pfile_info_internal;\n+    char *szFileName;\n+    uLong fileNameBufferSize;\n+    void *extraField;\n+    uLong extraFieldBufferSize;\n+    char *szComment;\n+    uLong commentBufferSize;\n {\n-\tunz_s* s;\n-\tunz_file_info file_info;\n-\tunz_file_info_internal file_info_internal;\n-\tint err=UNZ_OK;\n-\tuLong uMagic;\n-\tlong lSeek=0;\n-\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n-\tif (fseek(s->file,s->pos_in_central_dir+s->byte_before_the_zipfile,SEEK_SET)!=0)\n-\t\terr=UNZ_ERRNO;\n+    unz_s* s;\n+    unz_file_info file_info;\n+    unz_file_info_internal file_info_internal;\n+    int err=UNZ_OK;\n+    uLong uMagic;\n+    long lSeek=0;\n+\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+    if (ZSEEK(s->z_filefunc, s->filestream,\n+              s->pos_in_central_dir+s->byte_before_the_zipfile,\n+              ZLIB_FILEFUNC_SEEK_SET)!=0)\n+        err=UNZ_ERRNO;\n \n \n-\t/* we check the magic */\n-\tif (err==UNZ_OK)\n-\t\tif (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)\n-\t\t\terr=UNZ_ERRNO;\n-\t\telse if (uMagic!=0x02014b50)\n-\t\t\terr=UNZ_BADZIPFILE;\n+    /* we check the magic */\n+    if (err==UNZ_OK)\n+        if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n+            err=UNZ_ERRNO;\n+        else if (uMagic!=0x02014b50)\n+            err=UNZ_BADZIPFILE;\n \n-\tif (unzlocal_getShort(s->file,&file_info.version) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)\n+        err=UNZ_ERRNO;\n \n-\tif (unzlocal_getShort(s->file,&file_info.version_needed) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)\n+        err=UNZ_ERRNO;\n \n-\tif (unzlocal_getShort(s->file,&file_info.flag) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)\n+        err=UNZ_ERRNO;\n \n-\tif (unzlocal_getShort(s->file,&file_info.compression_method) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)\n+        err=UNZ_ERRNO;\n \n-\tif (unzlocal_getLong(s->file,&file_info.dosDate) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)\n+        err=UNZ_ERRNO;\n \n     unzlocal_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);\n \n-\tif (unzlocal_getLong(s->file,&file_info.crc) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getLong(s->file,&file_info.compressed_size) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getLong(s->file,&file_info.uncompressed_size) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getShort(s->file,&file_info.size_filename) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getShort(s->file,&file_info.size_file_extra) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getShort(s->file,&file_info.size_file_comment) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getShort(s->file,&file_info.disk_num_start) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getShort(s->file,&file_info.internal_fa) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getLong(s->file,&file_info.external_fa) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tif (unzlocal_getLong(s->file,&file_info_internal.offset_curfile) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\n-\tlSeek+=file_info.size_filename;\n-\tif ((err==UNZ_OK) && (szFileName!=NULL))\n-\t{\n-\t\tuLong uSizeRead ;\n-\t\tif (file_info.size_filename<fileNameBufferSize)\n-\t\t{\n-\t\t\t*(szFileName+file_info.size_filename)='\\0';\n-\t\t\tuSizeRead = file_info.size_filename;\n-\t\t}\n-\t\telse\n-\t\t\tuSizeRead = fileNameBufferSize;\n-\n-\t\tif ((file_info.size_filename>0) && (fileNameBufferSize>0))\n-\t\t\tif (fread(szFileName,(uInt)uSizeRead,1,s->file)!=1)\n-\t\t\t\terr=UNZ_ERRNO;\n-\t\tlSeek -= uSizeRead;\n-\t}\n-\n-\t\n-\tif ((err==UNZ_OK) && (extraField!=NULL))\n-\t{\n-\t\tuLong uSizeRead ;\n-\t\tif (file_info.size_file_extra<extraFieldBufferSize)\n-\t\t\tuSizeRead = file_info.size_file_extra;\n-\t\telse\n-\t\t\tuSizeRead = extraFieldBufferSize;\n-\n-\t\tif (lSeek!=0)\n-\t\t\tif (fseek(s->file,lSeek,SEEK_CUR)==0)\n-\t\t\t\tlSeek=0;\n-\t\t\telse\n-\t\t\t\terr=UNZ_ERRNO;\n-\t\tif ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))\n-\t\t\tif (fread(extraField,(uInt)uSizeRead,1,s->file)!=1)\n-\t\t\t\terr=UNZ_ERRNO;\n-\t\tlSeek += file_info.size_file_extra - uSizeRead;\n-\t}\n-\telse\n-\t\tlSeek+=file_info.size_file_extra; \n-\n-\t\n-\tif ((err==UNZ_OK) && (szComment!=NULL))\n-\t{\n-\t\tuLong uSizeRead ;\n-\t\tif (file_info.size_file_comment<commentBufferSize)\n-\t\t{\n-\t\t\t*(szComment+file_info.size_file_comment)='\\0';\n-\t\t\tuSizeRead = file_info.size_file_comment;\n-\t\t}\n-\t\telse\n-\t\t\tuSizeRead = commentBufferSize;\n-\n-\t\tif (lSeek!=0)\n-\t\t\tif (fseek(s->file,lSeek,SEEK_CUR)==0)\n-\t\t\t\tlSeek=0;\n-\t\t\telse\n-\t\t\t\terr=UNZ_ERRNO;\n-\t\tif ((file_info.size_file_comment>0) && (commentBufferSize>0))\n-\t\t\tif (fread(szComment,(uInt)uSizeRead,1,s->file)!=1)\n-\t\t\t\terr=UNZ_ERRNO;\n-\t\tlSeek+=file_info.size_file_comment - uSizeRead;\n-\t}\n-\telse\n-\t\tlSeek+=file_info.size_file_comment;\n-\n-\tif ((err==UNZ_OK) && (pfile_info!=NULL))\n-\t\t*pfile_info=file_info;\n-\n-\tif ((err==UNZ_OK) && (pfile_info_internal!=NULL))\n-\t\t*pfile_info_internal=file_info_internal;\n-\n-\treturn err;\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+\n+    lSeek+=file_info.size_filename;\n+    if ((err==UNZ_OK) && (szFileName!=NULL))\n+    {\n+        uLong uSizeRead ;\n+        if (file_info.size_filename<fileNameBufferSize)\n+        {\n+            *(szFileName+file_info.size_filename)='\\0';\n+            uSizeRead = file_info.size_filename;\n+        }\n+        else\n+            uSizeRead = fileNameBufferSize;\n+\n+        if ((file_info.size_filename>0) && (fileNameBufferSize>0))\n+            if (ZREAD(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)\n+                err=UNZ_ERRNO;\n+        lSeek -= uSizeRead;\n+    }\n+\n+\n+    if ((err==UNZ_OK) && (extraField!=NULL))\n+    {\n+        uLong uSizeRead ;\n+        if (file_info.size_file_extra<extraFieldBufferSize)\n+            uSizeRead = file_info.size_file_extra;\n+        else\n+            uSizeRead = extraFieldBufferSize;\n+\n+        if (lSeek!=0)\n+            if (ZSEEK(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n+                lSeek=0;\n+            else\n+                err=UNZ_ERRNO;\n+        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))\n+            if (ZREAD(s->z_filefunc, s->filestream,extraField,uSizeRead)!=uSizeRead)\n+                err=UNZ_ERRNO;\n+        lSeek += file_info.size_file_extra - uSizeRead;\n+    }\n+    else\n+        lSeek+=file_info.size_file_extra;\n+\n+\n+    if ((err==UNZ_OK) && (szComment!=NULL))\n+    {\n+        uLong uSizeRead ;\n+        if (file_info.size_file_comment<commentBufferSize)\n+        {\n+            *(szComment+file_info.size_file_comment)='\\0';\n+            uSizeRead = file_info.size_file_comment;\n+        }\n+        else\n+            uSizeRead = commentBufferSize;\n+\n+        if (lSeek!=0)\n+            if (ZSEEK(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n+                lSeek=0;\n+            else\n+                err=UNZ_ERRNO;\n+        if ((file_info.size_file_comment>0) && (commentBufferSize>0))\n+            if (ZREAD(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)\n+                err=UNZ_ERRNO;\n+        lSeek+=file_info.size_file_comment - uSizeRead;\n+    }\n+    else\n+        lSeek+=file_info.size_file_comment;\n+\n+    if ((err==UNZ_OK) && (pfile_info!=NULL))\n+        *pfile_info=file_info;\n+\n+    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))\n+        *pfile_info_internal=file_info_internal;\n+\n+    return err;\n }\n \n \n@@ -670,74 +742,73 @@ local int unzlocal_GetCurrentFileInfoInternal (file,\n   return UNZ_OK if there is no problem.\n */\n extern int ZEXPORT unzGetCurrentFileInfo (file,\n-                                                  pfile_info,\n-                                                  szFileName, fileNameBufferSize,\n-                                                  extraField, extraFieldBufferSize,\n-                                                  szComment,  commentBufferSize)\n-\tunzFile file;\n-\tunz_file_info *pfile_info;\n-\tchar *szFileName;\n-\tuLong fileNameBufferSize;\n-\tvoid *extraField;\n-\tuLong extraFieldBufferSize;\n-\tchar *szComment;\n-\tuLong commentBufferSize;\n+                                          pfile_info,\n+                                          szFileName, fileNameBufferSize,\n+                                          extraField, extraFieldBufferSize,\n+                                          szComment,  commentBufferSize)\n+    unzFile file;\n+    unz_file_info *pfile_info;\n+    char *szFileName;\n+    uLong fileNameBufferSize;\n+    void *extraField;\n+    uLong extraFieldBufferSize;\n+    char *szComment;\n+    uLong commentBufferSize;\n {\n-\treturn unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n-\t\t\t\t\t\t\t\t\t\t\t\tszFileName,fileNameBufferSize,\n-\t\t\t\t\t\t\t\t\t\t\t\textraField,extraFieldBufferSize,\n-\t\t\t\t\t\t\t\t\t\t\t\tszComment,commentBufferSize);\n+    return unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n+                                                szFileName,fileNameBufferSize,\n+                                                extraField,extraFieldBufferSize,\n+                                                szComment,commentBufferSize);\n }\n \n /*\n   Set the current file of the zipfile to the first file.\n   return UNZ_OK if there is no problem\n */\n extern int ZEXPORT unzGoToFirstFile (file)\n-\tunzFile file;\n+    unzFile file;\n {\n-\tint err=UNZ_OK;\n-\tunz_s* s;\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n-\ts->pos_in_central_dir=s->offset_central_dir;\n-\ts->num_file=0;\n-\terr=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n-\t\t\t\t\t\t\t\t\t\t\t &s->cur_file_info_internal,\n-\t\t\t\t\t\t\t\t\t\t\t NULL,0,NULL,0,NULL,0);\n-\ts->current_file_ok = (err == UNZ_OK);\n-\treturn err;\n+    int err=UNZ_OK;\n+    unz_s* s;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+    s->pos_in_central_dir=s->offset_central_dir;\n+    s->num_file=0;\n+    err=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n+                                             &s->cur_file_info_internal,\n+                                             NULL,0,NULL,0,NULL,0);\n+    s->current_file_ok = (err == UNZ_OK);\n+    return err;\n }\n \n-\n /*\n   Set the current file of the zipfile to the next file.\n   return UNZ_OK if there is no problem\n   return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n */\n extern int ZEXPORT unzGoToNextFile (file)\n-\tunzFile file;\n+    unzFile file;\n {\n-\tunz_s* s;\t\n-\tint err;\n-\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n-\tif (!s->current_file_ok)\n-\t\treturn UNZ_END_OF_LIST_OF_FILE;\n-\tif (s->num_file+1==s->gi.number_entry)\n-\t\treturn UNZ_END_OF_LIST_OF_FILE;\n-\n-\ts->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n-\t\t\ts->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n-\ts->num_file++;\n-\terr = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n-\t\t\t\t\t\t\t\t\t\t\t   &s->cur_file_info_internal,\n-\t\t\t\t\t\t\t\t\t\t\t   NULL,0,NULL,0,NULL,0);\n-\ts->current_file_ok = (err == UNZ_OK);\n-\treturn err;\n+    unz_s* s;\n+    int err;\n+\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+    if (!s->current_file_ok)\n+        return UNZ_END_OF_LIST_OF_FILE;\n+    if (s->num_file+1==s->gi.number_entry)\n+        return UNZ_END_OF_LIST_OF_FILE;\n+\n+    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n+            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n+    s->num_file++;\n+    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n+                                               &s->cur_file_info_internal,\n+                                               NULL,0,NULL,0,NULL,0);\n+    s->current_file_ok = (err == UNZ_OK);\n+    return err;\n }\n \n \n@@ -750,51 +821,131 @@ extern int ZEXPORT unzGoToNextFile (file)\n   UNZ_END_OF_LIST_OF_FILE if the file is not found\n */\n extern int ZEXPORT unzLocateFile (file, szFileName, iCaseSensitivity)\n-\tunzFile file;\n-\tconst char *szFileName;\n-\tint iCaseSensitivity;\n+    unzFile file;\n+    const char *szFileName;\n+    int iCaseSensitivity;\n {\n-\tunz_s* s;\t\n-\tint err;\n+    unz_s* s;\n+    int err;\n \n-\t\n-\tuLong num_fileSaved;\n-\tuLong pos_in_central_dirSaved;\n+    /* We remember the 'current' position in the file so that we can jump\n+     * back there if we fail.\n+     */\n+    unz_file_info cur_file_infoSaved;\n+    unz_file_info_internal cur_file_info_internalSaved;\n+    uLong num_fileSaved;\n+    uLong pos_in_central_dirSaved;\n \n \n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n \n     if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n         return UNZ_PARAMERROR;\n \n-\ts=(unz_s*)file;\n-\tif (!s->current_file_ok)\n-\t\treturn UNZ_END_OF_LIST_OF_FILE;\n-\n-\tnum_fileSaved = s->num_file;\n-\tpos_in_central_dirSaved = s->pos_in_central_dir;\n-\n-\terr = unzGoToFirstFile(file);\n-\n-\twhile (err == UNZ_OK)\n-\t{\n-\t\tchar szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n-\t\tunzGetCurrentFileInfo(file,NULL,\n-\t\t\t\t\t\t\t\tszCurrentFileName,sizeof(szCurrentFileName)-1,\n-\t\t\t\t\t\t\t\tNULL,0,NULL,0);\n-\t\tif (unzStringFileNameCompare(szCurrentFileName,\n-\t\t\t\t\t\t\t\t\t\tszFileName,iCaseSensitivity)==0)\n-\t\t\treturn UNZ_OK;\n-\t\terr = unzGoToNextFile(file);\n-\t}\n-\n-\ts->num_file = num_fileSaved ;\n-\ts->pos_in_central_dir = pos_in_central_dirSaved ;\n-\treturn err;\n+    s=(unz_s*)file;\n+    if (!s->current_file_ok)\n+        return UNZ_END_OF_LIST_OF_FILE;\n+\n+    /* Save the current state */\n+    num_fileSaved = s->num_file;\n+    pos_in_central_dirSaved = s->pos_in_central_dir;\n+    cur_file_infoSaved = s->cur_file_info;\n+    cur_file_info_internalSaved = s->cur_file_info_internal;\n+\n+    err = unzGoToFirstFile(file);\n+\n+    while (err == UNZ_OK)\n+    {\n+        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n+        err = unzGetCurrentFileInfo(file,NULL,\n+                                    szCurrentFileName,sizeof(szCurrentFileName)-1,\n+                                    NULL,0,NULL,0);\n+        if (err == UNZ_OK)\n+        {\n+            if (unzStringFileNameCompare(szCurrentFileName,\n+                                            szFileName,iCaseSensitivity)==0)\n+                return UNZ_OK;\n+            err = unzGoToNextFile(file);\n+        }\n+    }\n+\n+    /* We failed, so restore the state of the 'current file' to where we\n+     * were.\n+     */\n+    s->num_file = num_fileSaved ;\n+    s->pos_in_central_dir = pos_in_central_dirSaved ;\n+    s->cur_file_info = cur_file_infoSaved;\n+    s->cur_file_info_internal = cur_file_info_internalSaved;\n+    return err;\n }\n \n \n+/*\n+///////////////////////////////////////////\n+// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)\n+// I need random access\n+//\n+// Further optimization could be realized by adding an ability\n+// to cache the directory in memory. The goal being a single\n+// comprehensive file read to put the file I need in a memory.\n+*/\n+\n+/*\n+typedef struct unz_file_pos_s\n+{\n+    uLong pos_in_zip_directory;   // offset in file\n+    uLong num_of_file;            // # of file\n+} unz_file_pos;\n+*/\n+\n+extern int ZEXPORT unzGetFilePos(file, file_pos)\n+    unzFile file;\n+    unz_file_pos* file_pos;\n+{\n+    unz_s* s;\n+\n+    if (file==NULL || file_pos==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+    if (!s->current_file_ok)\n+        return UNZ_END_OF_LIST_OF_FILE;\n+\n+    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;\n+    file_pos->num_of_file           = s->num_file;\n+\n+    return UNZ_OK;\n+}\n+\n+extern int ZEXPORT unzGoToFilePos(file, file_pos)\n+    unzFile file;\n+    unz_file_pos* file_pos;\n+{\n+    unz_s* s;\n+    int err;\n+\n+    if (file==NULL || file_pos==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+\n+    /* jump to the right spot */\n+    s->pos_in_central_dir = file_pos->pos_in_zip_directory;\n+    s->num_file           = file_pos->num_of_file;\n+\n+    /* set the current file */\n+    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n+                                               &s->cur_file_info_internal,\n+                                               NULL,0,NULL,0,NULL,0);\n+    /* return results */\n+    s->current_file_ok = (err == UNZ_OK);\n+    return err;\n+}\n+\n+/*\n+// Unzip Helper Functions - should be here?\n+///////////////////////////////////////////\n+*/\n+\n /*\n   Read the local header of the current zipfile\n   Check the coherency of the local header and info in the end of central\n@@ -803,185 +954,258 @@ extern int ZEXPORT unzLocateFile (file, szFileName, iCaseSensitivity)\n         (filename and size of extra field data)\n */\n local int unzlocal_CheckCurrentFileCoherencyHeader (s,piSizeVar,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tpoffset_local_extrafield,\n-\t\t\t\t\t\t\t\t\t\t\t\t\tpsize_local_extrafield)\n-\tunz_s* s;\n-\tuInt* piSizeVar;\n-\tuLong *poffset_local_extrafield;\n-\tuInt  *psize_local_extrafield;\n+                                                    poffset_local_extrafield,\n+                                                    psize_local_extrafield)\n+    unz_s* s;\n+    uInt* piSizeVar;\n+    uLong *poffset_local_extrafield;\n+    uInt  *psize_local_extrafield;\n {\n-\tuLong uMagic,uData,uFlags;\n-\tuLong size_filename;\n-\tuLong size_extra_field;\n-\tint err=UNZ_OK;\n+    uLong uMagic,uData,uFlags;\n+    uLong size_filename;\n+    uLong size_extra_field;\n+    int err=UNZ_OK;\n \n-\t*piSizeVar = 0;\n-\t*poffset_local_extrafield = 0;\n-\t*psize_local_extrafield = 0;\n+    *piSizeVar = 0;\n+    *poffset_local_extrafield = 0;\n+    *psize_local_extrafield = 0;\n \n-\tif (fseek(s->file,s->cur_file_info_internal.offset_curfile +\n-\t\t\t\t\t\t\t\ts->byte_before_the_zipfile,SEEK_SET)!=0)\n-\t\treturn UNZ_ERRNO;\n+    if (ZSEEK(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +\n+                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+        return UNZ_ERRNO;\n \n \n-\tif (err==UNZ_OK)\n-\t\tif (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)\n-\t\t\terr=UNZ_ERRNO;\n-\t\telse if (uMagic!=0x04034b50)\n-\t\t\terr=UNZ_BADZIPFILE;\n+    if (err==UNZ_OK)\n+        if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n+            err=UNZ_ERRNO;\n+        else if (uMagic!=0x04034b50)\n+            err=UNZ_BADZIPFILE;\n \n-\tif (unzlocal_getShort(s->file,&uData) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n+        err=UNZ_ERRNO;\n /*\n-\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n-\t\terr=UNZ_BADZIPFILE;\n+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n+        err=UNZ_BADZIPFILE;\n */\n-\tif (unzlocal_getShort(s->file,&uFlags) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)\n+        err=UNZ_ERRNO;\n \n-\tif (unzlocal_getShort(s->file,&uData) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n-\t\terr=UNZ_BADZIPFILE;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n+        err=UNZ_BADZIPFILE;\n \n     if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n                          (s->cur_file_info.compression_method!=Z_DEFLATED))\n         err=UNZ_BADZIPFILE;\n \n-\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* date/time */\n-\t\terr=UNZ_ERRNO;\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */\n+        err=UNZ_ERRNO;\n \n-\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* crc */\n-\t\terr=UNZ_ERRNO;\n-\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&\n-\t\t                      ((uFlags & 8)==0))\n-\t\terr=UNZ_BADZIPFILE;\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */\n+        err=UNZ_ERRNO;\n+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&\n+                              ((uFlags & 8)==0))\n+        err=UNZ_BADZIPFILE;\n \n-\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* size compr */\n-\t\terr=UNZ_ERRNO;\n-\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&\n-\t\t\t\t\t\t\t  ((uFlags & 8)==0))\n-\t\terr=UNZ_BADZIPFILE;\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */\n+        err=UNZ_ERRNO;\n+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&\n+                              ((uFlags & 8)==0))\n+        err=UNZ_BADZIPFILE;\n \n-\tif (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* size uncompr */\n-\t\terr=UNZ_ERRNO;\n-\telse if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && \n-\t\t\t\t\t\t\t  ((uFlags & 8)==0))\n-\t\terr=UNZ_BADZIPFILE;\n+    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */\n+        err=UNZ_ERRNO;\n+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) &&\n+                              ((uFlags & 8)==0))\n+        err=UNZ_BADZIPFILE;\n \n \n-\tif (unzlocal_getShort(s->file,&size_filename) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\telse if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n-\t\terr=UNZ_BADZIPFILE;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n+        err=UNZ_BADZIPFILE;\n \n-\t*piSizeVar += (uInt)size_filename;\n+    *piSizeVar += (uInt)size_filename;\n \n-\tif (unzlocal_getShort(s->file,&size_extra_field) != UNZ_OK)\n-\t\terr=UNZ_ERRNO;\n-\t*poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n-\t\t\t\t\t\t\t\t\tSIZEZIPLOCALHEADER + size_filename;\n-\t*psize_local_extrafield = (uInt)size_extra_field;\n+    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)\n+        err=UNZ_ERRNO;\n+    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n+                                    SIZEZIPLOCALHEADER + size_filename;\n+    *psize_local_extrafield = (uInt)size_extra_field;\n \n-\t*piSizeVar += (uInt)size_extra_field;\n+    *piSizeVar += (uInt)size_extra_field;\n \n-\treturn err;\n+    return err;\n }\n-\t\t\t\t\t\t\t\t\t\t\t\t\n+\n /*\n   Open for reading data the current file in the zipfile.\n   If there is no error and the file is opened, the return value is UNZ_OK.\n */\n-extern int ZEXPORT unzOpenCurrentFile (file)\n-\tunzFile file;\n+extern int ZEXPORT unzOpenCurrentFile3 (file, method, level, raw, password)\n+    unzFile file;\n+    int* method;\n+    int* level;\n+    int raw;\n+    const char* password;\n {\n-\tint err=UNZ_OK;\n-\tint Store;\n-\tuInt iSizeVar;\n-\tunz_s* s;\n-\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n-\tuLong offset_local_extrafield;  /* offset of the local extra field */\n-\tuInt  size_local_extrafield;    /* size of the local extra field */\n-\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n-\tif (!s->current_file_ok)\n-\t\treturn UNZ_PARAMERROR;\n+    int err=UNZ_OK;\n+    uInt iSizeVar;\n+    unz_s* s;\n+    file_in_zip_read_info_s* pfile_in_zip_read_info;\n+    uLong offset_local_extrafield;  /* offset of the local extra field */\n+    uInt  size_local_extrafield;    /* size of the local extra field */\n+#    ifndef NOUNCRYPT\n+    char source[12];\n+#    else\n+    if (password != NULL)\n+        return UNZ_PARAMERROR;\n+#    endif\n+\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n+    if (!s->current_file_ok)\n+        return UNZ_PARAMERROR;\n \n     if (s->pfile_in_zip_read != NULL)\n         unzCloseCurrentFile(file);\n \n-\tif (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,\n-\t\t\t\t&offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n-\t\treturn UNZ_BADZIPFILE;\n-\n-\tpfile_in_zip_read_info = (file_in_zip_read_info_s*)\n-\t\t\t\t\t\t\t\t\t    ALLOC(sizeof(file_in_zip_read_info_s));\n-\tif (pfile_in_zip_read_info==NULL)\n-\t\treturn UNZ_INTERNALERROR;\n-\n-\tpfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n-\tpfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n-\tpfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n-\tpfile_in_zip_read_info->pos_local_extrafield=0;\n-\n-\tif (pfile_in_zip_read_info->read_buffer==NULL)\n-\t{\n-\t\tTRYFREE(pfile_in_zip_read_info);\n-\t\treturn UNZ_INTERNALERROR;\n-\t}\n-\n-\tpfile_in_zip_read_info->stream_initialised=0;\n-\t\n-\tif ((s->cur_file_info.compression_method!=0) &&\n+    if (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,\n+                &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n+        return UNZ_BADZIPFILE;\n+\n+    pfile_in_zip_read_info = (file_in_zip_read_info_s*)\n+                                        ALLOC(sizeof(file_in_zip_read_info_s));\n+    if (pfile_in_zip_read_info==NULL)\n+        return UNZ_INTERNALERROR;\n+\n+    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n+    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n+    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n+    pfile_in_zip_read_info->pos_local_extrafield=0;\n+    pfile_in_zip_read_info->raw=raw;\n+\n+    if (pfile_in_zip_read_info->read_buffer==NULL)\n+    {\n+        TRYFREE(pfile_in_zip_read_info);\n+        return UNZ_INTERNALERROR;\n+    }\n+\n+    pfile_in_zip_read_info->stream_initialised=0;\n+\n+    if (method!=NULL)\n+        *method = (int)s->cur_file_info.compression_method;\n+\n+    if (level!=NULL)\n+    {\n+        *level = 6;\n+        switch (s->cur_file_info.flag & 0x06)\n+        {\n+          case 6 : *level = 1; break;\n+          case 4 : *level = 2; break;\n+          case 2 : *level = 9; break;\n+        }\n+    }\n+\n+    if ((s->cur_file_info.compression_method!=0) &&\n         (s->cur_file_info.compression_method!=Z_DEFLATED))\n-\t\terr=UNZ_BADZIPFILE;\n-\tStore = s->cur_file_info.compression_method==0;\n+        err=UNZ_BADZIPFILE;\n \n-\tpfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n-\tpfile_in_zip_read_info->crc32=0;\n-\tpfile_in_zip_read_info->compression_method =\n+    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n+    pfile_in_zip_read_info->crc32=0;\n+    pfile_in_zip_read_info->compression_method =\n             s->cur_file_info.compression_method;\n-\tpfile_in_zip_read_info->file=s->file;\n-\tpfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n+    pfile_in_zip_read_info->filestream=s->filestream;\n+    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n+    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n \n     pfile_in_zip_read_info->stream.total_out = 0;\n \n-\tif (!Store)\n-\t{\n-\t  pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n-\t  pfile_in_zip_read_info->stream.zfree = (free_func)0;\n-\t  pfile_in_zip_read_info->stream.opaque = (voidpf)0; \n-      \n-\t  err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n-\t  if (err == Z_OK)\n-\t    pfile_in_zip_read_info->stream_initialised=1;\n+    if ((s->cur_file_info.compression_method==Z_DEFLATED) &&\n+        (!raw))\n+    {\n+      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n+      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n+      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n+      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n+      pfile_in_zip_read_info->stream.avail_in = 0;\n+\n+      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n+      if (err == Z_OK)\n+        pfile_in_zip_read_info->stream_initialised=1;\n+      else\n+        return err;\n         /* windowBits is passed < 0 to tell that there is no zlib header.\n          * Note that in this case inflate *requires* an extra \"dummy\" byte\n          * after the compressed stream in order to complete decompression and\n-         * return Z_STREAM_END. \n-         * In unzip, i don't wait absolutely Z_STREAM_END because I known the \n+         * return Z_STREAM_END.\n+         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n          * size of both compressed and uncompressed data\n          */\n-\t}\n-\tpfile_in_zip_read_info->rest_read_compressed = \n+    }\n+    pfile_in_zip_read_info->rest_read_compressed =\n             s->cur_file_info.compressed_size ;\n-\tpfile_in_zip_read_info->rest_read_uncompressed = \n+    pfile_in_zip_read_info->rest_read_uncompressed =\n             s->cur_file_info.uncompressed_size ;\n \n-\t\n-\tpfile_in_zip_read_info->pos_in_zipfile = \n-            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER + \n-\t\t\t  iSizeVar;\n-\t\n-\tpfile_in_zip_read_info->stream.avail_in = (uInt)0;\n+\n+    pfile_in_zip_read_info->pos_in_zipfile =\n+            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n+              iSizeVar;\n+\n+    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n+\n+    s->pfile_in_zip_read = pfile_in_zip_read_info;\n+\n+#    ifndef NOUNCRYPT\n+    if (password != NULL)\n+    {\n+        int i;\n+        s->pcrc_32_tab = get_crc_table();\n+        init_keys(password,s->keys,s->pcrc_32_tab);\n+        if (ZSEEK(s->z_filefunc, s->filestream,\n+                  s->pfile_in_zip_read->pos_in_zipfile +\n+                     s->pfile_in_zip_read->byte_before_the_zipfile,\n+                  SEEK_SET)!=0)\n+            return UNZ_INTERNALERROR;\n+        if(ZREAD(s->z_filefunc, s->filestream,source, 12)<12)\n+            return UNZ_INTERNALERROR;\n+\n+        for (i = 0; i<12; i++)\n+            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n+\n+        s->pfile_in_zip_read->pos_in_zipfile+=12;\n+        s->encrypted=1;\n+    }\n+#    endif\n \n \n-\ts->pfile_in_zip_read = pfile_in_zip_read_info;\n     return UNZ_OK;\n }\n \n+extern int ZEXPORT unzOpenCurrentFile (file)\n+    unzFile file;\n+{\n+    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);\n+}\n+\n+extern int ZEXPORT unzOpenCurrentFilePassword (file, password)\n+    unzFile file;\n+    const char* password;\n+{\n+    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);\n+}\n+\n+extern int ZEXPORT unzOpenCurrentFile2 (file,method,level,raw)\n+    unzFile file;\n+    int* method;\n+    int* level;\n+    int raw;\n+{\n+    return unzOpenCurrentFile3(file, method, level, raw, NULL);\n+}\n \n /*\n   Read bytes from the current file.\n@@ -994,169 +1218,192 @@ extern int ZEXPORT unzOpenCurrentFile (file)\n     (UNZ_ERRNO for IO error, or zLib error for uncompress error)\n */\n extern int ZEXPORT unzReadCurrentFile  (file, buf, len)\n-\tunzFile file;\n-\tvoidp buf;\n-\tunsigned len;\n+    unzFile file;\n+    voidp buf;\n+    unsigned len;\n {\n-\tint err=UNZ_OK;\n-\tuInt iRead = 0;\n-\tunz_s* s;\n-\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n+    int err=UNZ_OK;\n+    uInt iRead = 0;\n+    unz_s* s;\n+    file_in_zip_read_info_s* pfile_in_zip_read_info;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n     pfile_in_zip_read_info=s->pfile_in_zip_read;\n \n-\tif (pfile_in_zip_read_info==NULL)\n-\t\treturn UNZ_PARAMERROR;\n+    if (pfile_in_zip_read_info==NULL)\n+        return UNZ_PARAMERROR;\n+\n \n+    if ((pfile_in_zip_read_info->read_buffer == NULL))\n+        return UNZ_END_OF_LIST_OF_FILE;\n+    if (len==0)\n+        return 0;\n \n-\tif ((pfile_in_zip_read_info->read_buffer == NULL))\n-\t\treturn UNZ_END_OF_LIST_OF_FILE;\n-\tif (len==0)\n-\t\treturn 0;\n+    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n \n-\tpfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n+    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n \n-\tpfile_in_zip_read_info->stream.avail_out = (uInt)len;\n-\t\n-\tif (len>pfile_in_zip_read_info->rest_read_uncompressed)\n-\t\tpfile_in_zip_read_info->stream.avail_out = \n-\t\t  (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n+    if (len>pfile_in_zip_read_info->rest_read_uncompressed)\n+        pfile_in_zip_read_info->stream.avail_out =\n+          (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n \n-\twhile (pfile_in_zip_read_info->stream.avail_out>0)\n-\t{\n-\t\tif ((pfile_in_zip_read_info->stream.avail_in==0) &&\n+    while (pfile_in_zip_read_info->stream.avail_out>0)\n+    {\n+        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n             (pfile_in_zip_read_info->rest_read_compressed>0))\n-\t\t{\n-\t\t\tuInt uReadThis = UNZ_BUFSIZE;\n-\t\t\tif (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n-\t\t\t\tuReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n-\t\t\tif (uReadThis == 0)\n-\t\t\t\treturn UNZ_EOF;\n-\t\t\tif (fseek(pfile_in_zip_read_info->file,\n-                      pfile_in_zip_read_info->pos_in_zipfile + \n-                         pfile_in_zip_read_info->byte_before_the_zipfile,SEEK_SET)!=0)\n-\t\t\t\treturn UNZ_ERRNO;\n-\t\t\tif (fread(pfile_in_zip_read_info->read_buffer,uReadThis,1,\n-                         pfile_in_zip_read_info->file)!=1)\n-\t\t\t\treturn UNZ_ERRNO;\n-\t\t\tpfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n-\n-\t\t\tpfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n-\t\t\t\n-\t\t\tpfile_in_zip_read_info->stream.next_in = \n+        {\n+            uInt uReadThis = UNZ_BUFSIZE;\n+            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n+                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n+            if (uReadThis == 0)\n+                return UNZ_EOF;\n+            if (ZSEEK(pfile_in_zip_read_info->z_filefunc,\n+                      pfile_in_zip_read_info->filestream,\n+                      pfile_in_zip_read_info->pos_in_zipfile +\n+                         pfile_in_zip_read_info->byte_before_the_zipfile,\n+                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n+                return UNZ_ERRNO;\n+            if (ZREAD(pfile_in_zip_read_info->z_filefunc,\n+                      pfile_in_zip_read_info->filestream,\n+                      pfile_in_zip_read_info->read_buffer,\n+                      uReadThis)!=uReadThis)\n+                return UNZ_ERRNO;\n+\n+\n+#            ifndef NOUNCRYPT\n+            if(s->encrypted)\n+            {\n+                uInt i;\n+                for(i=0;i<uReadThis;i++)\n+                  pfile_in_zip_read_info->read_buffer[i] =\n+                      zdecode(s->keys,s->pcrc_32_tab,\n+                              pfile_in_zip_read_info->read_buffer[i]);\n+            }\n+#            endif\n+\n+\n+            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n+\n+            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n+\n+            pfile_in_zip_read_info->stream.next_in =\n                 (Bytef*)pfile_in_zip_read_info->read_buffer;\n-\t\t\tpfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n-\t\t}\n+            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n+        }\n \n-\t\tif (pfile_in_zip_read_info->compression_method==0)\n-\t\t{\n-\t\t\tuInt uDoCopy,i ;\n-\t\t\tif (pfile_in_zip_read_info->stream.avail_out < \n+        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n+        {\n+            uInt uDoCopy,i ;\n+\n+            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n+                (pfile_in_zip_read_info->rest_read_compressed == 0))\n+                return (iRead==0) ? UNZ_EOF : iRead;\n+\n+            if (pfile_in_zip_read_info->stream.avail_out <\n                             pfile_in_zip_read_info->stream.avail_in)\n-\t\t\t\tuDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n-\t\t\telse\n-\t\t\t\tuDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n-\t\t\t\t\n-\t\t\tfor (i=0;i<uDoCopy;i++)\n-\t\t\t\t*(pfile_in_zip_read_info->stream.next_out+i) =\n+                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n+            else\n+                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n+\n+            for (i=0;i<uDoCopy;i++)\n+                *(pfile_in_zip_read_info->stream.next_out+i) =\n                         *(pfile_in_zip_read_info->stream.next_in+i);\n-\t\t\t\t\t\n-\t\t\tpfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n-\t\t\t\t\t\t\t\tpfile_in_zip_read_info->stream.next_out,\n-\t\t\t\t\t\t\t\tuDoCopy);\n-\t\t\tpfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n-\t\t\tpfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n-\t\t\tpfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n-\t\t\tpfile_in_zip_read_info->stream.next_out += uDoCopy;\n-\t\t\tpfile_in_zip_read_info->stream.next_in += uDoCopy;\n+\n+            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n+                                pfile_in_zip_read_info->stream.next_out,\n+                                uDoCopy);\n+            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n+            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n+            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n+            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n+            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n             pfile_in_zip_read_info->stream.total_out += uDoCopy;\n-\t\t\tiRead += uDoCopy;\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\tuLong uTotalOutBefore,uTotalOutAfter;\n-\t\t\tconst Bytef *bufBefore;\n-\t\t\tuLong uOutThis;\n-\t\t\tint flush=Z_SYNC_FLUSH;\n-\n-\t\t\tuTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n-\t\t\tbufBefore = pfile_in_zip_read_info->stream.next_out;\n-\n-\t\t\t/*\n-\t\t\tif ((pfile_in_zip_read_info->rest_read_uncompressed ==\n-\t\t\t         pfile_in_zip_read_info->stream.avail_out) &&\n-\t\t\t\t(pfile_in_zip_read_info->rest_read_compressed == 0))\n-\t\t\t\tflush = Z_FINISH;\n-\t\t\t*/\n-\t\t\terr=inflate(&pfile_in_zip_read_info->stream,flush);\n-\n-\t\t\tuTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n-\t\t\tuOutThis = uTotalOutAfter-uTotalOutBefore;\n-\t\t\t\n-\t\t\tpfile_in_zip_read_info->crc32 = \n+            iRead += uDoCopy;\n+        }\n+        else\n+        {\n+            uLong uTotalOutBefore,uTotalOutAfter;\n+            const Bytef *bufBefore;\n+            uLong uOutThis;\n+            int flush=Z_SYNC_FLUSH;\n+\n+            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n+            bufBefore = pfile_in_zip_read_info->stream.next_out;\n+\n+            /*\n+            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n+                     pfile_in_zip_read_info->stream.avail_out) &&\n+                (pfile_in_zip_read_info->rest_read_compressed == 0))\n+                flush = Z_FINISH;\n+            */\n+            err=inflate(&pfile_in_zip_read_info->stream,flush);\n+\n+            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n+            uOutThis = uTotalOutAfter-uTotalOutBefore;\n+\n+            pfile_in_zip_read_info->crc32 =\n                 crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                         (uInt)(uOutThis));\n \n-\t\t\tpfile_in_zip_read_info->rest_read_uncompressed -=\n+            pfile_in_zip_read_info->rest_read_uncompressed -=\n                 uOutThis;\n \n-\t\t\tiRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n-            \n-\t\t\tif (err==Z_STREAM_END)\n-\t\t\t\treturn (iRead==0) ? UNZ_EOF : iRead;\n-\t\t\tif (err!=Z_OK) \n-\t\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\tif (err==Z_OK)\n-\t\treturn iRead;\n-\treturn err;\n+            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n+\n+            if (err==Z_STREAM_END)\n+                return (iRead==0) ? UNZ_EOF : iRead;\n+            if (err!=Z_OK)\n+                break;\n+        }\n+    }\n+\n+    if (err==Z_OK)\n+        return iRead;\n+    return err;\n }\n \n \n /*\n   Give the current position in uncompressed data\n */\n extern z_off_t ZEXPORT unztell (file)\n-\tunzFile file;\n+    unzFile file;\n {\n-\tunz_s* s;\n-\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n+    unz_s* s;\n+    file_in_zip_read_info_s* pfile_in_zip_read_info;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n     pfile_in_zip_read_info=s->pfile_in_zip_read;\n \n-\tif (pfile_in_zip_read_info==NULL)\n-\t\treturn UNZ_PARAMERROR;\n+    if (pfile_in_zip_read_info==NULL)\n+        return UNZ_PARAMERROR;\n \n-\treturn (z_off_t)pfile_in_zip_read_info->stream.total_out;\n+    return (z_off_t)pfile_in_zip_read_info->stream.total_out;\n }\n \n \n /*\n-  return 1 if the end of file was reached, 0 elsewhere \n+  return 1 if the end of file was reached, 0 elsewhere\n */\n extern int ZEXPORT unzeof (file)\n-\tunzFile file;\n+    unzFile file;\n {\n-\tunz_s* s;\n-\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n+    unz_s* s;\n+    file_in_zip_read_info_s* pfile_in_zip_read_info;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n     pfile_in_zip_read_info=s->pfile_in_zip_read;\n \n-\tif (pfile_in_zip_read_info==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\t\n-\tif (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n-\t\treturn 1;\n-\telse\n-\t\treturn 0;\n+    if (pfile_in_zip_read_info==NULL)\n+        return UNZ_PARAMERROR;\n+\n+    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n+        return 1;\n+    else\n+        return 0;\n }\n \n \n@@ -1169,91 +1416,96 @@ extern int ZEXPORT unzeof (file)\n   if buf==NULL, it return the size of the local extra field that can be read\n \n   if buf!=NULL, len is the size of the buffer, the extra header is copied in\n-\tbuf.\n-  the return value is the number of bytes copied in buf, or (if <0) \n-\tthe error code\n+    buf.\n+  the return value is the number of bytes copied in buf, or (if <0)\n+    the error code\n */\n extern int ZEXPORT unzGetLocalExtrafield (file,buf,len)\n-\tunzFile file;\n-\tvoidp buf;\n-\tunsigned len;\n+    unzFile file;\n+    voidp buf;\n+    unsigned len;\n {\n-\tunz_s* s;\n-\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n-\tuInt read_now;\n-\tuLong size_to_read;\n-\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n+    unz_s* s;\n+    file_in_zip_read_info_s* pfile_in_zip_read_info;\n+    uInt read_now;\n+    uLong size_to_read;\n+\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n     pfile_in_zip_read_info=s->pfile_in_zip_read;\n \n-\tif (pfile_in_zip_read_info==NULL)\n-\t\treturn UNZ_PARAMERROR;\n+    if (pfile_in_zip_read_info==NULL)\n+        return UNZ_PARAMERROR;\n \n-\tsize_to_read = (pfile_in_zip_read_info->size_local_extrafield - \n-\t\t\t\tpfile_in_zip_read_info->pos_local_extrafield);\n+    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n+                pfile_in_zip_read_info->pos_local_extrafield);\n+\n+    if (buf==NULL)\n+        return (int)size_to_read;\n+\n+    if (len>size_to_read)\n+        read_now = (uInt)size_to_read;\n+    else\n+        read_now = (uInt)len ;\n \n-\tif (buf==NULL)\n-\t\treturn (int)size_to_read;\n-\t\n-\tif (len>size_to_read)\n-\t\tread_now = (uInt)size_to_read;\n-\telse\n-\t\tread_now = (uInt)len ;\n+    if (read_now==0)\n+        return 0;\n \n-\tif (read_now==0)\n-\t\treturn 0;\n-\t\n-\tif (fseek(pfile_in_zip_read_info->file,\n-              pfile_in_zip_read_info->offset_local_extrafield + \n-\t\t\t  pfile_in_zip_read_info->pos_local_extrafield,SEEK_SET)!=0)\n-\t\treturn UNZ_ERRNO;\n+    if (ZSEEK(pfile_in_zip_read_info->z_filefunc,\n+              pfile_in_zip_read_info->filestream,\n+              pfile_in_zip_read_info->offset_local_extrafield +\n+              pfile_in_zip_read_info->pos_local_extrafield,\n+              ZLIB_FILEFUNC_SEEK_SET)!=0)\n+        return UNZ_ERRNO;\n \n-\tif (fread(buf,(uInt)size_to_read,1,pfile_in_zip_read_info->file)!=1)\n-\t\treturn UNZ_ERRNO;\n+    if (ZREAD(pfile_in_zip_read_info->z_filefunc,\n+              pfile_in_zip_read_info->filestream,\n+              buf,size_to_read)!=size_to_read)\n+        return UNZ_ERRNO;\n \n-\treturn (int)read_now;\n+    return (int)read_now;\n }\n \n /*\n   Close the file in zip opened with unzipOpenCurrentFile\n   Return UNZ_CRCERROR if all the file was read but the CRC is not good\n */\n extern int ZEXPORT unzCloseCurrentFile (file)\n-\tunzFile file;\n+    unzFile file;\n {\n-\tint err=UNZ_OK;\n+    int err=UNZ_OK;\n \n-\tunz_s* s;\n-\tfile_in_zip_read_info_s* pfile_in_zip_read_info;\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n+    unz_s* s;\n+    file_in_zip_read_info_s* pfile_in_zip_read_info;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n     pfile_in_zip_read_info=s->pfile_in_zip_read;\n \n-\tif (pfile_in_zip_read_info==NULL)\n-\t\treturn UNZ_PARAMERROR;\n+    if (pfile_in_zip_read_info==NULL)\n+        return UNZ_PARAMERROR;\n \n \n-\tif (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n-\t{\n-\t\tif (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n-\t\t\terr=UNZ_CRCERROR;\n-\t}\n+    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&\n+        (!pfile_in_zip_read_info->raw))\n+    {\n+        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n+            err=UNZ_CRCERROR;\n+    }\n \n \n-\tTRYFREE(pfile_in_zip_read_info->read_buffer);\n-\tpfile_in_zip_read_info->read_buffer = NULL;\n-\tif (pfile_in_zip_read_info->stream_initialised)\n-\t\tinflateEnd(&pfile_in_zip_read_info->stream);\n+    TRYFREE(pfile_in_zip_read_info->read_buffer);\n+    pfile_in_zip_read_info->read_buffer = NULL;\n+    if (pfile_in_zip_read_info->stream_initialised)\n+        inflateEnd(&pfile_in_zip_read_info->stream);\n \n-\tpfile_in_zip_read_info->stream_initialised = 0;\n-\tTRYFREE(pfile_in_zip_read_info);\n+    pfile_in_zip_read_info->stream_initialised = 0;\n+    TRYFREE(pfile_in_zip_read_info);\n \n     s->pfile_in_zip_read=NULL;\n \n-\treturn err;\n+    return err;\n }\n \n \n@@ -1263,32 +1515,32 @@ extern int ZEXPORT unzCloseCurrentFile (file)\n   return the number of byte copied or an error code <0\n */\n extern int ZEXPORT unzGetGlobalComment (file, szComment, uSizeBuf)\n-\tunzFile file;\n-\tchar *szComment;\n-\tuLong uSizeBuf;\n+    unzFile file;\n+    char *szComment;\n+    uLong uSizeBuf;\n {\n-\tint err=UNZ_OK;\n-\tunz_s* s;\n-\tuLong uReadThis ;\n-\tif (file==NULL)\n-\t\treturn UNZ_PARAMERROR;\n-\ts=(unz_s*)file;\n+    int err=UNZ_OK;\n+    unz_s* s;\n+    uLong uReadThis ;\n+    if (file==NULL)\n+        return UNZ_PARAMERROR;\n+    s=(unz_s*)file;\n \n-\tuReadThis = uSizeBuf;\n-\tif (uReadThis>s->gi.size_comment)\n-\t\tuReadThis = s->gi.size_comment;\n+    uReadThis = uSizeBuf;\n+    if (uReadThis>s->gi.size_comment)\n+        uReadThis = s->gi.size_comment;\n \n-\tif (fseek(s->file,s->central_pos+22,SEEK_SET)!=0)\n-\t\treturn UNZ_ERRNO;\n+    if (ZSEEK(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+        return UNZ_ERRNO;\n \n-\tif (uReadThis>0)\n+    if (uReadThis>0)\n     {\n       *szComment='\\0';\n-\t  if (fread(szComment,(uInt)uReadThis,1,s->file)!=1)\n-\t\treturn UNZ_ERRNO;\n+      if (ZREAD(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)\n+        return UNZ_ERRNO;\n     }\n \n-\tif ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n-\t\t*(szComment+s->gi.size_comment)='\\0';\n-\treturn (int)uReadThis;\n+    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n+        *(szComment+s->gi.size_comment)='\\0';\n+    return (int)uReadThis;\n }"}, {"sha": "f6ede89bc96632477951e12966203743e1360088", "filename": "zlib/contrib/minizip/unzip.def", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Funzip.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Funzip.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.def?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,15 +0,0 @@\n-\tunzOpen                       @61\n-\tunzClose                      @62\n-\tunzGetGlobalInfo              @63\n-\tunzGetCurrentFileInfo         @64\n-\tunzGoToFirstFile              @65\n-\tunzGoToNextFile               @66\n-\tunzOpenCurrentFile            @67\n-\tunzReadCurrentFile            @68\n-\tunztell                       @70\n-\tunzeof                        @71\n-\tunzCloseCurrentFile           @72\n-\tunzGetGlobalComment           @73\n-\tunzStringFileNameCompare      @74\n-\tunzLocateFile                 @75\n-\tunzGetLocalExtrafield         @76"}, {"sha": "4e50979d8eab4be1deb64d68c06f5ba2fac54df7", "filename": "zlib/contrib/minizip/unzip.h", "status": "modified", "additions": 129, "deletions": 62, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Funzip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Funzip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Funzip.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,15 +1,14 @@\n-/* unzip.h -- IO for uncompress .zip files using zlib \n-   Version 0.15 beta, Mar 19th, 1998,\n+/* unzip.h -- IO for uncompress .zip files using zlib\n+   Version 1.00, September 10th, 2003\n \n-   Copyright (C) 1998 Gilles Vollant\n+   Copyright (C) 1998-2003 Gilles Vollant\n \n    This unzip package allow extract file from .ZIP file, compatible with PKZip 2.04g\n      WinZip, InfoZip tools and compatible.\n    Encryption and multi volume ZipFile (span) are not supported.\n    Old compressions used by old PKZip 1.x are not supported\n \n-   THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE\n-   CAN CHANGE IN FUTURE VERSION !!\n+\n    I WAIT FEEDBACK at mail info@winimage.com\n    Visit also http://www.winimage.com/zLibDll/unzip.htm for evolution\n \n@@ -33,10 +32,13 @@\n \n \n */\n-/* for more info about .ZIP format, see \n-      ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip\n+\n+/* for more info about .ZIP format, see\n+      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip\n+      http://www.info-zip.org/pub/infozip/doc/\n    PkWare has also a specification at :\n-      ftp://ftp.pkware.com/probdesc.zip */\n+      ftp://ftp.pkware.com/probdesc.zip\n+*/\n \n #ifndef _unz_H\n #define _unz_H\n@@ -49,43 +51,47 @@ extern \"C\" {\n #include \"zlib.h\"\n #endif\n \n+#ifndef _ZLIBIOAPI_H\n+#include \"ioapi.h\"\n+#endif\n+\n #if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)\n /* like the STRICT of WIN32, we define a pointer that cannot be converted\n     from (void*) without cast */\n-typedef struct TagunzFile__ { int unused; } unzFile__; \n+typedef struct TagunzFile__ { int unused; } unzFile__;\n typedef unzFile__ *unzFile;\n #else\n typedef voidp unzFile;\n #endif\n \n \n-#define UNZ_OK                                  (0)\n-#define UNZ_END_OF_LIST_OF_FILE (-100)\n-#define UNZ_ERRNO               (Z_ERRNO)\n-#define UNZ_EOF                 (0)\n+#define UNZ_OK                          (0)\n+#define UNZ_END_OF_LIST_OF_FILE         (-100)\n+#define UNZ_ERRNO                       (Z_ERRNO)\n+#define UNZ_EOF                         (0)\n #define UNZ_PARAMERROR                  (-102)\n #define UNZ_BADZIPFILE                  (-103)\n #define UNZ_INTERNALERROR               (-104)\n #define UNZ_CRCERROR                    (-105)\n \n /* tm_unz contain date/time info */\n-typedef struct tm_unz_s \n+typedef struct tm_unz_s\n {\n-\tuInt tm_sec;            /* seconds after the minute - [0,59] */\n-\tuInt tm_min;            /* minutes after the hour - [0,59] */\n-\tuInt tm_hour;           /* hours since midnight - [0,23] */\n-\tuInt tm_mday;           /* day of the month - [1,31] */\n-\tuInt tm_mon;            /* months since January - [0,11] */\n-\tuInt tm_year;           /* years - [1980..2044] */\n+    uInt tm_sec;            /* seconds after the minute - [0,59] */\n+    uInt tm_min;            /* minutes after the hour - [0,59] */\n+    uInt tm_hour;           /* hours since midnight - [0,23] */\n+    uInt tm_mday;           /* day of the month - [1,31] */\n+    uInt tm_mon;            /* months since January - [0,11] */\n+    uInt tm_year;           /* years - [1980..2044] */\n } tm_unz;\n \n /* unz_global_info structure contain global data about the ZIPfile\n    These data comes from the end of central dir */\n typedef struct unz_global_info_s\n {\n-\tuLong number_entry;         /* total number of entries in\n-\t\t\t\t       the central dir on this disk */\n-\tuLong size_comment;         /* size of the global comment of the zipfile */\n+    uLong number_entry;         /* total number of entries in\n+                       the central dir on this disk */\n+    uLong size_comment;         /* size of the global comment of the zipfile */\n } unz_global_info;\n \n \n@@ -98,8 +104,8 @@ typedef struct unz_file_info_s\n     uLong compression_method;   /* compression method              2 bytes */\n     uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */\n     uLong crc;                  /* crc-32                          4 bytes */\n-    uLong compressed_size;      /* compressed size                 4 bytes */ \n-    uLong uncompressed_size;    /* uncompressed size               4 bytes */ \n+    uLong compressed_size;      /* compressed size                 4 bytes */\n+    uLong uncompressed_size;    /* uncompressed size               4 bytes */\n     uLong size_filename;        /* filename length                 2 bytes */\n     uLong size_file_extra;      /* extra field length              2 bytes */\n     uLong size_file_comment;    /* file comment length             2 bytes */\n@@ -112,27 +118,34 @@ typedef struct unz_file_info_s\n } unz_file_info;\n \n extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,\n-\t\t\t\t\t\t\t\t\t\t\t\t const char* fileName2,\n-\t\t\t\t\t\t\t\t\t\t\t\t int iCaseSensitivity));\n+                                                 const char* fileName2,\n+                                                 int iCaseSensitivity));\n /*\n    Compare two filename (fileName1,fileName2).\n    If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)\n    If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi\n-\t\t\t\t\t\t\t\tor strcasecmp)\n+                                or strcasecmp)\n    If iCaseSenisivity = 0, case sensitivity is defaut of your operating system\n-\t(like 1 on Unix, 2 on Windows)\n+    (like 1 on Unix, 2 on Windows)\n */\n \n \n extern unzFile ZEXPORT unzOpen OF((const char *path));\n /*\n   Open a Zip file. path contain the full pathname (by example,\n-     on a Windows NT computer \"c:\\\\zlib\\\\zlib111.zip\" or on an Unix computer\n-\t \"zlib/zlib111.zip\".\n-\t If the zipfile cannot be opened (file don't exist or in not valid), the\n-\t   return value is NULL.\n+     on a Windows XP computer \"c:\\\\zlib\\\\zlib113.zip\" or on an Unix computer\n+     \"zlib/zlib113.zip\".\n+     If the zipfile cannot be opened (file don't exist or in not valid), the\n+       return value is NULL.\n      Else, the return value is a unzFile Handle, usable with other function\n-\t   of this unzip package.\n+       of this unzip package.\n+*/\n+\n+extern unzFile ZEXPORT unzOpen2 OF((const char *path,\n+                                    zlib_filefunc_def* pzlib_filefunc_def));\n+/*\n+   Open a Zip file, like unzOpen, but provide a set of file low level API\n+      for read/write the zip file (see ioapi.h)\n */\n \n extern int ZEXPORT unzClose OF((unzFile file));\n@@ -143,16 +156,16 @@ extern int ZEXPORT unzClose OF((unzFile file));\n   return UNZ_OK if there is no problem. */\n \n extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,\n-\t\t\t\t\tunz_global_info *pglobal_info));\n+                                        unz_global_info *pglobal_info));\n /*\n   Write info about the ZipFile in the *pglobal_info structure.\n   No preparation of the structure is needed\n   return UNZ_OK if there is no problem. */\n \n \n extern int ZEXPORT unzGetGlobalComment OF((unzFile file,\n-\t\t\t\t\t\t\t\t\t\t   char *szComment,\n-\t\t\t\t\t   uLong uSizeBuf));\n+                                           char *szComment,\n+                                           uLong uSizeBuf));\n /*\n   Get the global comment string of the ZipFile, in the szComment buffer.\n   uSizeBuf is the size of the szComment buffer.\n@@ -176,9 +189,9 @@ extern int ZEXPORT unzGoToNextFile OF((unzFile file));\n   return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.\n */\n \n-extern int ZEXPORT unzLocateFile OF((unzFile file, \n-\t\t\t\t     const char *szFileName,\n-\t\t\t\t     int iCaseSensitivity));\n+extern int ZEXPORT unzLocateFile OF((unzFile file,\n+                     const char *szFileName,\n+                     int iCaseSensitivity));\n /*\n   Try locate the file szFileName in the zipfile.\n   For the iCaseSensitivity signification, see unzStringFileNameCompare\n@@ -189,25 +202,44 @@ extern int ZEXPORT unzLocateFile OF((unzFile file,\n */\n \n \n+/* ****************************************** */\n+/* Ryan supplied functions */\n+/* unz_file_info contain information about a file in the zipfile */\n+typedef struct unz_file_pos_s\n+{\n+    uLong pos_in_zip_directory;   /* offset in zip file directory */\n+    uLong num_of_file;            /* # of file */\n+} unz_file_pos;\n+\n+extern int ZEXPORT unzGetFilePos(\n+    unzFile file,\n+    unz_file_pos* file_pos);\n+\n+extern int ZEXPORT unzGoToFilePos(\n+    unzFile file,\n+    unz_file_pos* file_pos);\n+\n+/* ****************************************** */\n+\n extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,\n-\t\t\t\t\t     unz_file_info *pfile_info,\n-\t\t\t\t\t     char *szFileName,\n-\t\t\t\t\t     uLong fileNameBufferSize,\n-\t\t\t\t\t     void *extraField,\n-\t\t\t\t\t     uLong extraFieldBufferSize,\n-\t\t\t\t\t     char *szComment,\n-\t\t\t\t\t     uLong commentBufferSize));\n+                         unz_file_info *pfile_info,\n+                         char *szFileName,\n+                         uLong fileNameBufferSize,\n+                         void *extraField,\n+                         uLong extraFieldBufferSize,\n+                         char *szComment,\n+                         uLong commentBufferSize));\n /*\n   Get Info about the current file\n   if pfile_info!=NULL, the *pfile_info structure will contain somes info about\n-\t    the current file\n+        the current file\n   if szFileName!=NULL, the filemane string will be copied in szFileName\n-\t\t\t(fileNameBufferSize is the size of the buffer)\n+            (fileNameBufferSize is the size of the buffer)\n   if extraField!=NULL, the extra field information will be copied in extraField\n-\t\t\t(extraFieldBufferSize is the size of the buffer).\n-\t\t\tThis is the Central-header version of the extra field\n+            (extraFieldBufferSize is the size of the buffer).\n+            This is the Central-header version of the extra field\n   if szComment!=NULL, the comment string of the file will be copied in szComment\n-\t\t\t(commentBufferSize is the size of the buffer)\n+            (commentBufferSize is the size of the buffer)\n */\n \n /***************************************************************************/\n@@ -221,16 +253,51 @@ extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));\n   If there is no error, the return value is UNZ_OK.\n */\n \n+extern int ZEXPORT unzOpenCurrentFilePassword OF((unzFile file,\n+                                                  const char* password));\n+/*\n+  Open for reading data the current file in the zipfile.\n+  password is a crypting password\n+  If there is no error, the return value is UNZ_OK.\n+*/\n+\n+extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,\n+                                           int* method,\n+                                           int* level,\n+                                           int raw));\n+/*\n+  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)\n+    if raw==1\n+  *method will receive method of compression, *level will receive level of\n+     compression\n+  note : you can set level parameter as NULL (if you did not want known level,\n+         but you CANNOT set method parameter as NULL\n+*/\n+\n+extern int ZEXPORT unzOpenCurrentFile3 OF((unzFile file,\n+                                           int* method,\n+                                           int* level,\n+                                           int raw,\n+                                           const char* password));\n+/*\n+  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)\n+    if raw==1\n+  *method will receive method of compression, *level will receive level of\n+     compression\n+  note : you can set level parameter as NULL (if you did not want known level,\n+         but you CANNOT set method parameter as NULL\n+*/\n+\n+\n extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));\n /*\n   Close the file in zip opened with unzOpenCurrentFile\n   Return UNZ_CRCERROR if all the file was read but the CRC is not good\n */\n \n-\t\t\t\t\t\t\t\t\t\t\t\t\n-extern int ZEXPORT unzReadCurrentFile OF((unzFile file, \n-\t\t\t\t\t  voidp buf,\n-\t\t\t\t\t  unsigned len));\n+extern int ZEXPORT unzReadCurrentFile OF((unzFile file,\n+                      voidp buf,\n+                      unsigned len));\n /*\n   Read bytes from the current file (opened by unzOpenCurrentFile)\n   buf contain buffer where data must be copied\n@@ -249,12 +316,12 @@ extern z_off_t ZEXPORT unztell OF((unzFile file));\n \n extern int ZEXPORT unzeof OF((unzFile file));\n /*\n-  return 1 if the end of file was reached, 0 elsewhere \n+  return 1 if the end of file was reached, 0 elsewhere\n */\n \n extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,\n-\t\t\t\t\t\t\t\t\t\t\t voidp buf,\n-\t\t\t\t\t\t\t\t\t\t\t unsigned len));\n+                                             voidp buf,\n+                                             unsigned len));\n /*\n   Read extra field from the current file (opened by unzOpenCurrentFile)\n   This is the local-header version of the extra field (sometimes, there is\n@@ -263,9 +330,9 @@ extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,\n   if buf==NULL, it return the size of the local extra field\n \n   if buf!=NULL, len is the size of the buffer, the extra header is copied in\n-\tbuf.\n-  the return value is the number of bytes copied in buf, or (if <0) \n-\tthe error code\n+    buf.\n+  the return value is the number of bytes copied in buf, or (if <0)\n+    the error code\n */\n \n #ifdef __cplusplus"}, {"sha": "1a713e50842001926670dfa1b049073f790a3986", "filename": "zlib/contrib/minizip/zip.c", "status": "modified", "additions": 558, "deletions": 106, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Fzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Fzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,5 +1,7 @@\n-/* zip.c -- IO on .zip files using zlib \n-   Version 0.15 beta, Mar 19th, 1998,\n+/* zip.c -- IO on .zip files using zlib\n+   Version 1.00, September 10th, 2003\n+\n+   Copyright (C) 1998-2003 Gilles Vollant\n \n    Read zip.h for more info\n */\n@@ -8,6 +10,7 @@\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n+#include <time.h>\n #include \"zlib.h\"\n #include \"zip.h\"\n \n@@ -66,8 +69,15 @@\n #define SEEK_SET    0\n #endif\n \n+#ifndef DEF_MEM_LEVEL\n+#if MAX_MEM_LEVEL >= 8\n+#  define DEF_MEM_LEVEL 8\n+#else\n+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL\n+#endif\n+#endif\n const char zip_copyright[] =\n-   \" zip 0.15 Copyright 1998 Gilles Vollant \";\n+   \" zip 1.00 Copyright 1998-2003 Gilles Vollant - http://www.winimage.com/zLibDll\";\n \n \n #define SIZEDATA_INDATABLOCK (4096-(4*4))\n@@ -99,33 +109,49 @@ typedef struct linkedlist_data_s\n \n typedef struct\n {\n-\tz_stream stream;            /* zLib stream structure for inflate */\n+    z_stream stream;            /* zLib stream structure for inflate */\n     int  stream_initialised;    /* 1 is stream is initialised */\n     uInt pos_in_buffered_data;  /* last written byte in buffered_data */\n \n-    uLong pos_local_header;     /* offset of the local header of the file \n+    uLong pos_local_header;     /* offset of the local header of the file\n                                      currenty writing */\n     char* central_header;       /* central header data for the current file */\n     uLong size_centralheader;   /* size of the central header for cur file */\n     uLong flag;                 /* flag of the file currently writing */\n \n     int  method;                /* compression method of file currenty wr.*/\n+    int  raw;                   /* 1 for directly writing raw data */\n     Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/\n     uLong dosDate;\n     uLong crc32;\n+    int  encrypt;\n+#ifndef NOCRYPT\n+    unsigned long keys[3];     /* keys defining the pseudo-random sequence */\n+    const unsigned long* pcrc_32_tab;\n+    int crypt_header_size;\n+#endif\n } curfile_info;\n \n typedef struct\n {\n-    FILE * filezip;\n+    zlib_filefunc_def z_filefunc;\n+    voidpf filestream;        /* io structore of the zipfile */\n     linkedlist_data central_dir;/* datablock with central dir in construction*/\n     int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/\n     curfile_info ci;            /* info on the file curretly writing */\n \n     uLong begin_pos;            /* position of the beginning of the zipfile */\n+    uLong add_position_when_writting_offset;\n     uLong number_entry;\n } zip_internal;\n \n+\n+\n+#ifndef NOCRYPT\n+#define INCLUDECRYPTINGCODE_IFCRYPTALLOWED\n+#include \"crypt.h\"\n+#endif\n+\n local linkedlist_datablock_internal* allocate_new_datablock()\n {\n     linkedlist_datablock_internal* ldi;\n@@ -166,7 +192,7 @@ local void free_linkedlist(ll)\n \n \n local int add_data_in_datablock(ll,buf,len)\n-    linkedlist_data* ll;    \n+    linkedlist_data* ll;\n     const void* buf;\n     uLong len;\n {\n@@ -220,32 +246,20 @@ local int add_data_in_datablock(ll,buf,len)\n }\n \n \n-local int write_datablock(fout,ll)\n-    FILE * fout;\n-    linkedlist_data* ll;    \n-{\n-    linkedlist_datablock_internal* ldi;\n-    ldi = ll->first_block;\n-    while (ldi!=NULL)\n-    {\n-        if (ldi->filled_in_this_block > 0)\n-            if (fwrite(ldi->data,(uInt)ldi->filled_in_this_block,1,fout)!=1)\n-                return ZIP_ERRNO;\n-        ldi = ldi->next_datablock;\n-    }\n-    return ZIP_OK;\n-}\n \n /****************************************************************************/\n \n+#ifndef NO_ADDFILEINEXISTINGZIP\n /* ===========================================================================\n-   Outputs a long in LSB order to the given file\n+   Inputs a long in LSB order to the given file\n    nbByte == 1, 2 or 4 (byte, short or long)\n */\n \n-local int ziplocal_putValue OF((FILE *file, uLong x, int nbByte));\n-local int ziplocal_putValue (file, x, nbByte)\n-    FILE *file;\n+local int ziplocal_putValue OF((const zlib_filefunc_def* pzlib_filefunc_def,\n+                                voidpf filestream, uLong x, int nbByte));\n+local int ziplocal_putValue (pzlib_filefunc_def, filestream, x, nbByte)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n     uLong x;\n     int nbByte;\n {\n@@ -255,7 +269,7 @@ local int ziplocal_putValue (file, x, nbByte)\n         buf[n] = (unsigned char)(x & 0xff);\n         x >>= 8;\n     }\n-    if (fwrite(buf,nbByte,1,file)!=1)\n+    if (ZWRITE(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)\n         return ZIP_ERRNO;\n     else\n         return ZIP_OK;\n@@ -278,7 +292,7 @@ local void ziplocal_putValue_inmemory (dest, x, nbByte)\n \n \n local uLong ziplocal_TmzDateToDosDate(ptm,dosDate)\n-    tm_zip* ptm;\n+    const tm_zip* ptm;\n     uLong dosDate;\n {\n     uLong year = (uLong)ptm->tm_year;\n@@ -294,38 +308,348 @@ local uLong ziplocal_TmzDateToDosDate(ptm,dosDate)\n \n /****************************************************************************/\n \n-extern zipFile ZEXPORT zipOpen (pathname, append)\n+local int ziplocal_getByte OF((\n+    const zlib_filefunc_def* pzlib_filefunc_def,\n+    voidpf filestream,\n+    int *pi));\n+\n+local int ziplocal_getByte(pzlib_filefunc_def,filestream,pi)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n+    int *pi;\n+{\n+    unsigned char c;\n+    int err = (int)ZREAD(*pzlib_filefunc_def,filestream,&c,1);\n+    if (err==1)\n+    {\n+        *pi = (int)c;\n+        return ZIP_OK;\n+    }\n+    else\n+    {\n+        if (ZERROR(*pzlib_filefunc_def,filestream))\n+            return ZIP_ERRNO;\n+        else\n+            return ZIP_EOF;\n+    }\n+}\n+\n+\n+/* ===========================================================================\n+   Reads a long in LSB order from the given gz_stream. Sets\n+*/\n+local int ziplocal_getShort OF((\n+    const zlib_filefunc_def* pzlib_filefunc_def,\n+    voidpf filestream,\n+    uLong *pX));\n+\n+local int ziplocal_getShort (pzlib_filefunc_def,filestream,pX)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n+    uLong *pX;\n+{\n+    uLong x ;\n+    int i;\n+    int err;\n+\n+    err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);\n+    x = (uLong)i;\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);\n+    x += ((uLong)i)<<8;\n+\n+    if (err==ZIP_OK)\n+        *pX = x;\n+    else\n+        *pX = 0;\n+    return err;\n+}\n+\n+local int ziplocal_getLong OF((\n+    const zlib_filefunc_def* pzlib_filefunc_def,\n+    voidpf filestream,\n+    uLong *pX));\n+\n+local int ziplocal_getLong (pzlib_filefunc_def,filestream,pX)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n+    uLong *pX;\n+{\n+    uLong x ;\n+    int i;\n+    int err;\n+\n+    err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);\n+    x = (uLong)i;\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);\n+    x += ((uLong)i)<<8;\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);\n+    x += ((uLong)i)<<16;\n+\n+    if (err==ZIP_OK)\n+        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);\n+    x += ((uLong)i)<<24;\n+\n+    if (err==ZIP_OK)\n+        *pX = x;\n+    else\n+        *pX = 0;\n+    return err;\n+}\n+\n+#ifndef BUFREADCOMMENT\n+#define BUFREADCOMMENT (0x400)\n+#endif\n+/*\n+  Locate the Central directory of a zipfile (at the end, just before\n+    the global comment)\n+*/\n+local uLong ziplocal_SearchCentralDir OF((\n+    const zlib_filefunc_def* pzlib_filefunc_def,\n+    voidpf filestream));\n+\n+local uLong ziplocal_SearchCentralDir(pzlib_filefunc_def,filestream)\n+    const zlib_filefunc_def* pzlib_filefunc_def;\n+    voidpf filestream;\n+{\n+    unsigned char* buf;\n+    uLong uSizeFile;\n+    uLong uBackRead;\n+    uLong uMaxBack=0xffff; /* maximum size of global comment */\n+    uLong uPosFound=0;\n+\n+    if (ZSEEK(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n+        return 0;\n+\n+\n+    uSizeFile = ZTELL(*pzlib_filefunc_def,filestream);\n+\n+    if (uMaxBack>uSizeFile)\n+        uMaxBack = uSizeFile;\n+\n+    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n+    if (buf==NULL)\n+        return 0;\n+\n+    uBackRead = 4;\n+    while (uBackRead<uMaxBack)\n+    {\n+        uLong uReadSize,uReadPos ;\n+        int i;\n+        if (uBackRead+BUFREADCOMMENT>uMaxBack)\n+            uBackRead = uMaxBack;\n+        else\n+            uBackRead+=BUFREADCOMMENT;\n+        uReadPos = uSizeFile-uBackRead ;\n+\n+        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n+                     (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);\n+        if (ZSEEK(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+            break;\n+\n+        if (ZREAD(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n+            break;\n+\n+        for (i=(int)uReadSize-3; (i--)>0;)\n+            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n+                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n+            {\n+                uPosFound = uReadPos+i;\n+                break;\n+            }\n+\n+        if (uPosFound!=0)\n+            break;\n+    }\n+    TRYFREE(buf);\n+    return uPosFound;\n+}\n+#endif /* !NO_ADDFILEINEXISTINGZIP*/\n+\n+/************************************************************/\n+extern zipFile ZEXPORT zipOpen2 (pathname, append, globalcomment, pzlib_filefunc_def)\n     const char *pathname;\n     int append;\n+    zipcharpc* globalcomment;\n+    zlib_filefunc_def* pzlib_filefunc_def;\n {\n     zip_internal ziinit;\n     zip_internal* zi;\n+    int err=ZIP_OK;\n \n-    ziinit.filezip = fopen(pathname,(append == 0) ? \"wb\" : \"ab\");\n-    if (ziinit.filezip == NULL)\n+\n+    if (pzlib_filefunc_def==NULL)\n+        fill_fopen_filefunc(&ziinit.z_filefunc);\n+    else\n+        ziinit.z_filefunc = *pzlib_filefunc_def;\n+\n+    ziinit.filestream = (*(ziinit.z_filefunc.zopen_file))\n+                 (ziinit.z_filefunc.opaque,\n+                  pathname,\n+                  (append == APPEND_STATUS_CREATE) ?\n+                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :\n+                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));\n+\n+    if (ziinit.filestream == NULL)\n         return NULL;\n-    ziinit.begin_pos = ftell(ziinit.filezip);\n+    ziinit.begin_pos = ZTELL(ziinit.z_filefunc,ziinit.filestream);\n     ziinit.in_opened_file_inzip = 0;\n     ziinit.ci.stream_initialised = 0;\n     ziinit.number_entry = 0;\n+    ziinit.add_position_when_writting_offset = 0;\n     init_linkedlist(&(ziinit.central_dir));\n \n \n     zi = (zip_internal*)ALLOC(sizeof(zip_internal));\n     if (zi==NULL)\n     {\n-        fclose(ziinit.filezip);\n+        ZCLOSE(ziinit.z_filefunc,ziinit.filestream);\n         return NULL;\n     }\n \n-    *zi = ziinit;\n-    return (zipFile)zi;\n+    /* now we add file in a zipfile */\n+#    ifndef NO_ADDFILEINEXISTINGZIP\n+    if (append == APPEND_STATUS_ADDINZIP)\n+    {\n+        uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n+\n+        uLong size_central_dir;     /* size of the central directory  */\n+        uLong offset_central_dir;   /* offset of start of central directory */\n+        uLong central_pos,uL;\n+\n+        uLong number_disk;          /* number of the current dist, used for\n+                                    spaning ZIP, unsupported, always 0*/\n+        uLong number_disk_with_CD;  /* number the the disk with central dir, used\n+                                    for spaning ZIP, unsupported, always 0*/\n+        uLong number_entry;\n+        uLong number_entry_CD;      /* total number of entries in\n+                                    the central dir\n+                                    (same than number_entry on nospan) */\n+        uLong size_comment;\n+\n+        central_pos = ziplocal_SearchCentralDir(&ziinit.z_filefunc,ziinit.filestream);\n+        if (central_pos==0)\n+            err=ZIP_ERRNO;\n+\n+        if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,\n+                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+            err=ZIP_ERRNO;\n+\n+        /* the signature, already checked */\n+        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&uL)!=ZIP_OK)\n+            err=ZIP_ERRNO;\n+\n+        /* number of this disk */\n+        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_disk)!=ZIP_OK)\n+            err=ZIP_ERRNO;\n+\n+        /* number of the disk with the start of the central directory */\n+        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_disk_with_CD)!=ZIP_OK)\n+            err=ZIP_ERRNO;\n+\n+        /* total number of entries in the central dir on this disk */\n+        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_entry)!=ZIP_OK)\n+            err=ZIP_ERRNO;\n+\n+        /* total number of entries in the central dir */\n+        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_entry_CD)!=ZIP_OK)\n+            err=ZIP_ERRNO;\n+\n+        if ((number_entry_CD!=number_entry) ||\n+            (number_disk_with_CD!=0) ||\n+            (number_disk!=0))\n+            err=ZIP_BADZIPFILE;\n+\n+        /* size of the central directory */\n+        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&size_central_dir)!=ZIP_OK)\n+            err=ZIP_ERRNO;\n+\n+        /* offset of start of central directory with respect to the\n+            starting disk number */\n+        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&offset_central_dir)!=ZIP_OK)\n+            err=ZIP_ERRNO;\n+\n+        /* zipfile comment length */\n+        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&size_comment)!=ZIP_OK)\n+            err=ZIP_ERRNO;\n+\n+        if ((central_pos<offset_central_dir+size_central_dir) &&\n+            (err==ZIP_OK))\n+            err=ZIP_BADZIPFILE;\n+\n+        if (err!=ZIP_OK)\n+        {\n+            ZCLOSE(ziinit.z_filefunc, ziinit.filestream);\n+            return NULL;\n+        }\n+\n+        byte_before_the_zipfile = central_pos -\n+                                (offset_central_dir+size_central_dir);\n+        ziinit.add_position_when_writting_offset = byte_before_the_zipfile ;\n+\n+        {\n+            uLong size_central_dir_to_read = size_central_dir;\n+            size_t buf_size = SIZEDATA_INDATABLOCK;\n+            void* buf_read = (void*)ALLOC(buf_size);\n+            if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,\n+                  offset_central_dir + byte_before_the_zipfile,\n+                  ZLIB_FILEFUNC_SEEK_SET) != 0)\n+                  err=ZIP_ERRNO;\n+\n+            while ((size_central_dir_to_read>0) && (err==ZIP_OK))\n+            {\n+                uLong read_this = SIZEDATA_INDATABLOCK;\n+                if (read_this > size_central_dir_to_read)\n+                    read_this = size_central_dir_to_read;\n+                if (ZREAD(ziinit.z_filefunc, ziinit.filestream,buf_read,read_this) != read_this)\n+                    err=ZIP_ERRNO;\n+\n+                if (err==ZIP_OK)\n+                    err = add_data_in_datablock(&ziinit.central_dir,buf_read,\n+                                                (uLong)read_this);\n+                size_central_dir_to_read-=read_this;\n+            }\n+            TRYFREE(buf_read);\n+        }\n+        ziinit.begin_pos = byte_before_the_zipfile;\n+        ziinit.number_entry = number_entry_CD;\n+\n+        if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,\n+                  offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+            err=ZIP_ERRNO;\n+    }\n+#    endif /* !NO_ADDFILEINEXISTINGZIP*/\n+\n+    if (err != ZIP_OK)\n+    {\n+        TRYFREE(zi);\n+        return NULL;\n+    }\n+    else\n+    {\n+        *zi = ziinit;\n+        return (zipFile)zi;\n+    }\n }\n \n-extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi, \n-                                        extrafield_local, size_extrafield_local,\n-                                        extrafield_global, size_extrafield_global,\n-                                        comment, method, level)\n+extern zipFile ZEXPORT zipOpen (pathname, append)\n+    const char *pathname;\n+    int append;\n+{\n+    return zipOpen2(pathname,append,NULL,NULL);\n+}\n+\n+extern int ZEXPORT zipOpenNewFileInZip3 (file, filename, zipfi,\n+                                         extrafield_local, size_extrafield_local,\n+                                         extrafield_global, size_extrafield_global,\n+                                         comment, method, level, raw,\n+                                         windowBits, memLevel, strategy,\n+                                         password, crcForCrypting)\n     zipFile file;\n     const char* filename;\n     const zip_fileinfo* zipfi;\n@@ -336,13 +660,24 @@ extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi,\n     const char* comment;\n     int method;\n     int level;\n+    int raw;\n+    int windowBits;\n+    int memLevel;\n+    int strategy;\n+    const char* password;\n+    uLong crcForCrypting;\n {\n     zip_internal* zi;\n     uInt size_filename;\n     uInt size_comment;\n     uInt i;\n     int err = ZIP_OK;\n \n+#    ifdef NOCRYPT\n+    if (password != NULL)\n+        return ZIP_PARAMERROR;\n+#    endif\n+\n     if (file == NULL)\n         return ZIP_PARAMERROR;\n     if ((method!=0) && (method!=Z_DEFLATED))\n@@ -384,13 +719,17 @@ extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi,\n       zi->ci.flag |= 4;\n     if ((level==1))\n       zi->ci.flag |= 6;\n+    if (password != NULL)\n+      zi->ci.flag |= 1;\n \n     zi->ci.crc32 = 0;\n     zi->ci.method = method;\n+    zi->ci.encrypt = 0;\n     zi->ci.stream_initialised = 0;\n     zi->ci.pos_in_buffered_data = 0;\n-    zi->ci.pos_local_header = ftell(zi->filezip);\n-    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + \n+    zi->ci.raw = raw;\n+    zi->ci.pos_local_header = ZTELL(zi->z_filefunc,zi->filestream) ;\n+    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename +\n                                       size_extrafield_global + size_comment;\n     zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader);\n \n@@ -410,16 +749,16 @@ extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi,\n     ziplocal_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/\n \n     if (zipfi==NULL)\n-        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2); \n+        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2);\n     else\n-        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2); \n+        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2);\n \n     if (zipfi==NULL)\n-        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4); \n+        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4);\n     else\n         ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);\n \n-    ziplocal_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header,4);\n+    ziplocal_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header- zi->add_position_when_writting_offset,4);\n \n     for (i=0;i<size_filename;i++)\n         *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);\n@@ -430,44 +769,44 @@ extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi,\n \n     for (i=0;i<size_comment;i++)\n         *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+\n-              size_extrafield_global+i) = *(filename+i);\n+              size_extrafield_global+i) = *(comment+i);\n     if (zi->ci.central_header == NULL)\n         return ZIP_INTERNALERROR;\n \n     /* write the local header */\n-    err = ziplocal_putValue(zi->filezip,(uLong)LOCALHEADERMAGIC,4);\n+    err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC,4);\n \n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)20,2);/* version needed to extract */\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */\n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.flag,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);\n \n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.method,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);\n \n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.dosDate,4);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);\n \n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* crc 32, unknown */\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */\n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* compressed size, unknown */\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */\n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* uncompressed size, unknown */\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */\n \n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)size_filename,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);\n \n     if (err==ZIP_OK)\n-        err = ziplocal_putValue(zi->filezip,(uLong)size_extrafield_local,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield_local,2);\n \n     if ((err==ZIP_OK) && (size_filename>0))\n-        if (fwrite(filename,(uInt)size_filename,1,zi->filezip)!=1)\n+        if (ZWRITE(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)\n                 err = ZIP_ERRNO;\n \n     if ((err==ZIP_OK) && (size_extrafield_local>0))\n-        if (fwrite(extrafield_local,(uInt)size_extrafield_local,1,zi->filezip)\n-                                                                           !=1)\n+        if (ZWRITE(zi->z_filefunc,zi->filestream,extrafield_local,size_extrafield_local)\n+                                                                           !=size_extrafield_local)\n                 err = ZIP_ERRNO;\n \n     zi->ci.stream.avail_in = (uInt)0;\n@@ -476,28 +815,114 @@ extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi,\n     zi->ci.stream.total_in = 0;\n     zi->ci.stream.total_out = 0;\n \n-    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED))\n+    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n     {\n         zi->ci.stream.zalloc = (alloc_func)0;\n         zi->ci.stream.zfree = (free_func)0;\n         zi->ci.stream.opaque = (voidpf)0;\n \n+        if (windowBits>0)\n+            windowBits = -windowBits;\n+\n         err = deflateInit2(&zi->ci.stream, level,\n-               Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, 0);\n+               Z_DEFLATED, windowBits, memLevel, strategy);\n \n         if (err==Z_OK)\n             zi->ci.stream_initialised = 1;\n     }\n+#    ifndef NOCRYPT\n+    zi->ci.crypt_header_size = 0;\n+    if ((err==Z_OK) && (password != NULL))\n+    {\n+        unsigned char bufHead[RAND_HEAD_LEN];\n+        unsigned int sizeHead;\n+        zi->ci.encrypt = 1;\n+        zi->ci.pcrc_32_tab = get_crc_table();\n+        /*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/\n+\n+        sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi->ci.keys,zi->ci.pcrc_32_tab,crcForCrypting);\n+        zi->ci.crypt_header_size = sizeHead;\n \n+        if (ZWRITE(zi->z_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)\n+                err = ZIP_ERRNO;\n+    }\n+#    endif\n \n     if (err==Z_OK)\n         zi->in_opened_file_inzip = 1;\n     return err;\n }\n \n+extern int ZEXPORT zipOpenNewFileInZip2(file, filename, zipfi,\n+                                        extrafield_local, size_extrafield_local,\n+                                        extrafield_global, size_extrafield_global,\n+                                        comment, method, level, raw)\n+    zipFile file;\n+    const char* filename;\n+    const zip_fileinfo* zipfi;\n+    const void* extrafield_local;\n+    uInt size_extrafield_local;\n+    const void* extrafield_global;\n+    uInt size_extrafield_global;\n+    const char* comment;\n+    int method;\n+    int level;\n+    int raw;\n+{\n+    return zipOpenNewFileInZip3 (file, filename, zipfi,\n+                                 extrafield_local, size_extrafield_local,\n+                                 extrafield_global, size_extrafield_global,\n+                                 comment, method, level, raw,\n+                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n+                                 NULL, 0);\n+}\n+\n+extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi,\n+                                        extrafield_local, size_extrafield_local,\n+                                        extrafield_global, size_extrafield_global,\n+                                        comment, method, level)\n+    zipFile file;\n+    const char* filename;\n+    const zip_fileinfo* zipfi;\n+    const void* extrafield_local;\n+    uInt size_extrafield_local;\n+    const void* extrafield_global;\n+    uInt size_extrafield_global;\n+    const char* comment;\n+    int method;\n+    int level;\n+{\n+    return zipOpenNewFileInZip2 (file, filename, zipfi,\n+                                 extrafield_local, size_extrafield_local,\n+                                 extrafield_global, size_extrafield_global,\n+                                 comment, method, level, 0);\n+}\n+\n+local int zipFlushWriteBuffer(zi)\n+  zip_internal* zi;\n+{\n+    int err=ZIP_OK;\n+\n+    if (zi->ci.encrypt != 0)\n+    {\n+#ifndef NOCRYPT\n+        uInt i;\n+        int t;\n+        for (i=0;i<zi->ci.pos_in_buffered_data;i++)\n+            zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab,\n+                                       zi->ci.buffered_data[i],t);\n+#endif\n+    }\n+    if (ZWRITE(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data)\n+                                                                    !=zi->ci.pos_in_buffered_data)\n+      err = ZIP_ERRNO;\n+    zi->ci.pos_in_buffered_data = 0;\n+    return err;\n+}\n+\n extern int ZEXPORT zipWriteInFileInZip (file, buf, len)\n     zipFile file;\n-    const voidp buf;\n+    const void* buf;\n     unsigned len;\n {\n     zip_internal* zi;\n@@ -510,23 +935,25 @@ extern int ZEXPORT zipWriteInFileInZip (file, buf, len)\n     if (zi->in_opened_file_inzip == 0)\n         return ZIP_PARAMERROR;\n \n-    zi->ci.stream.next_in = buf;\n+    zi->ci.stream.next_in = (void*)buf;\n     zi->ci.stream.avail_in = len;\n     zi->ci.crc32 = crc32(zi->ci.crc32,buf,len);\n \n     while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))\n     {\n         if (zi->ci.stream.avail_out == 0)\n         {\n-            if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)\n-                                                                           !=1)\n+            if (zipFlushWriteBuffer(zi) == ZIP_ERRNO)\n                 err = ZIP_ERRNO;\n-            zi->ci.pos_in_buffered_data = 0;\n             zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n             zi->ci.stream.next_out = zi->ci.buffered_data;\n         }\n \n-        if (zi->ci.method == Z_DEFLATED)\n+\n+        if(err != ZIP_OK)\n+            break;\n+\n+        if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n         {\n             uLong uTotalOutBefore = zi->ci.stream.total_out;\n             err=deflate(&zi->ci.stream,  Z_NO_FLUSH);\n@@ -555,33 +982,34 @@ extern int ZEXPORT zipWriteInFileInZip (file, buf, len)\n         }\n     }\n \n-    return 0;\n+    return err;\n }\n \n-extern int ZEXPORT zipCloseFileInZip (file)\n+extern int ZEXPORT zipCloseFileInZipRaw (file, uncompressed_size, crc32)\n     zipFile file;\n+    uLong uncompressed_size;\n+    uLong crc32;\n {\n     zip_internal* zi;\n+    uLong compressed_size;\n     int err=ZIP_OK;\n \n     if (file == NULL)\n         return ZIP_PARAMERROR;\n     zi = (zip_internal*)file;\n \n-    if (zi->in_opened_file_inzip == 0)    \n+    if (zi->in_opened_file_inzip == 0)\n         return ZIP_PARAMERROR;\n     zi->ci.stream.avail_in = 0;\n-    \n-    if (zi->ci.method == Z_DEFLATED)\n+\n+    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n         while (err==ZIP_OK)\n     {\n         uLong uTotalOutBefore;\n         if (zi->ci.stream.avail_out == 0)\n         {\n-            if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)\n-                                                                           !=1)\n+            if (zipFlushWriteBuffer(zi) == ZIP_ERRNO)\n                 err = ZIP_ERRNO;\n-            zi->ci.pos_in_buffered_data = 0;\n             zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n             zi->ci.stream.next_out = zi->ci.buffered_data;\n         }\n@@ -594,21 +1022,32 @@ extern int ZEXPORT zipCloseFileInZip (file)\n         err=ZIP_OK; /* this is normal */\n \n     if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))\n-        if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)\n-                                                                       !=1)\n+        if (zipFlushWriteBuffer(zi)==ZIP_ERRNO)\n             err = ZIP_ERRNO;\n \n-    if ((zi->ci.method == Z_DEFLATED) && (err==ZIP_OK))\n+    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n     {\n         err=deflateEnd(&zi->ci.stream);\n         zi->ci.stream_initialised = 0;\n     }\n \n-    ziplocal_putValue_inmemory(zi->ci.central_header+16,(uLong)zi->ci.crc32,4); /*crc*/\n+    if (!zi->ci.raw)\n+    {\n+        crc32 = (uLong)zi->ci.crc32;\n+        uncompressed_size = (uLong)zi->ci.stream.total_in;\n+    }\n+    compressed_size = (uLong)zi->ci.stream.total_out;\n+#    ifndef NOCRYPT\n+    compressed_size += zi->ci.crypt_header_size;\n+#    endif\n+\n+    ziplocal_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/\n     ziplocal_putValue_inmemory(zi->ci.central_header+20,\n-                                (uLong)zi->ci.stream.total_out,4); /*compr size*/\n+                                compressed_size,4); /*compr size*/\n+    if (zi->ci.stream.data_type == Z_ASCII)\n+        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);\n     ziplocal_putValue_inmemory(zi->ci.central_header+24,\n-                                (uLong)zi->ci.stream.total_in,4); /*uncompr size*/\n+                                uncompressed_size,4); /*uncompr size*/\n \n     if (err==ZIP_OK)\n         err = add_data_in_datablock(&zi->central_dir,zi->ci.central_header,\n@@ -617,23 +1056,23 @@ extern int ZEXPORT zipCloseFileInZip (file)\n \n     if (err==ZIP_OK)\n     {\n-        long cur_pos_inzip = ftell(zi->filezip);\n-\t    if (fseek(zi->filezip,\n-                  zi->ci.pos_local_header + 14,SEEK_SET)!=0)\n-\t\t    err = ZIP_ERRNO;\n+        long cur_pos_inzip = ZTELL(zi->z_filefunc,zi->filestream);\n+        if (ZSEEK(zi->z_filefunc,zi->filestream,\n+                  zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+            err = ZIP_ERRNO;\n \n         if (err==ZIP_OK)\n-            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.crc32,4); /* crc 32, unknown */\n+            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */\n \n         if (err==ZIP_OK) /* compressed size, unknown */\n-            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.stream.total_out,4); \n+            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);\n \n         if (err==ZIP_OK) /* uncompressed size, unknown */\n-            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.stream.total_in,4);\n+            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);\n \n-\t    if (fseek(zi->filezip,\n-                  cur_pos_inzip,SEEK_SET)!=0)\n-\t\t    err = ZIP_ERRNO;\n+        if (ZSEEK(zi->z_filefunc,zi->filestream,\n+                  cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)\n+            err = ZIP_ERRNO;\n     }\n \n     zi->number_entry ++;\n@@ -642,6 +1081,12 @@ extern int ZEXPORT zipCloseFileInZip (file)\n     return err;\n }\n \n+extern int ZEXPORT zipCloseFileInZip (file)\n+    zipFile file;\n+{\n+    return zipCloseFileInZipRaw (file,0,0);\n+}\n+\n extern int ZEXPORT zipClose (file, global_comment)\n     zipFile file;\n     const char* global_comment;\n@@ -666,15 +1111,16 @@ extern int ZEXPORT zipClose (file, global_comment)\n         size_global_comment = strlen(global_comment);\n \n \n-    centraldir_pos_inzip = ftell(zi->filezip);\n+    centraldir_pos_inzip = ZTELL(zi->z_filefunc,zi->filestream);\n     if (err==ZIP_OK)\n     {\n         linkedlist_datablock_internal* ldi = zi->central_dir.first_block ;\n         while (ldi!=NULL)\n         {\n             if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))\n-                if (fwrite(ldi->data,(uInt)ldi->filled_in_this_block,\n-                                        1,zi->filezip) !=1 )\n+                if (ZWRITE(zi->z_filefunc,zi->filestream,\n+                           ldi->data,ldi->filled_in_this_block)\n+                              !=ldi->filled_in_this_block )\n                     err = ZIP_ERRNO;\n \n             size_centraldir += ldi->filled_in_this_block;\n@@ -684,34 +1130,40 @@ extern int ZEXPORT zipClose (file, global_comment)\n     free_datablock(zi->central_dir.first_block);\n \n     if (err==ZIP_OK) /* Magic End */\n-        err = ziplocal_putValue(zi->filezip,(uLong)ENDHEADERMAGIC,4);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);\n \n     if (err==ZIP_OK) /* number of this disk */\n-        err = ziplocal_putValue(zi->filezip,(uLong)0,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n \n     if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n-        err = ziplocal_putValue(zi->filezip,(uLong)0,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n \n     if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n-        err = ziplocal_putValue(zi->filezip,(uLong)zi->number_entry,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n \n     if (err==ZIP_OK) /* total number of entries in the central dir */\n-        err = ziplocal_putValue(zi->filezip,(uLong)zi->number_entry,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n \n     if (err==ZIP_OK) /* size of the central directory */\n-        err = ziplocal_putValue(zi->filezip,(uLong)size_centraldir,4);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);\n \n-    if (err==ZIP_OK) /* offset of start of central directory with respect to the \n-\t                        starting disk number */\n-        err = ziplocal_putValue(zi->filezip,(uLong)centraldir_pos_inzip ,4);\n+    if (err==ZIP_OK) /* offset of start of central directory with respect to the\n+                            starting disk number */\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,\n+                                (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);\n \n     if (err==ZIP_OK) /* zipfile comment length */\n-        err = ziplocal_putValue(zi->filezip,(uLong)size_global_comment,2);\n+        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);\n \n     if ((err==ZIP_OK) && (size_global_comment>0))\n-        if (fwrite(global_comment,(uInt)size_global_comment,1,zi->filezip) !=1 )\n+        if (ZWRITE(zi->z_filefunc,zi->filestream,\n+                   global_comment,size_global_comment) != size_global_comment)\n                 err = ZIP_ERRNO;\n-    fclose(zi->filezip);\n+\n+    if (ZCLOSE(zi->z_filefunc,zi->filestream) != 0)\n+        if (err == ZIP_OK)\n+            err = ZIP_ERRNO;\n+\n     TRYFREE(zi);\n \n     return err;"}, {"sha": "5d5079fbcee8ba3eeee8e865d3e3cfbee863a246", "filename": "zlib/contrib/minizip/zip.def", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Fzip.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Fzip.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.def?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,5 +0,0 @@\n-\tzipOpen                       @80\n-\tzipOpenNewFileInZip           @81\n-\tzipWriteInFileInZip           @82\n-\tzipCloseFileInZip             @83\n-\tzipClose                      @84"}, {"sha": "c37ea21872ca7936234af1ce8d4cfae8499cf48b", "filename": "zlib/contrib/minizip/zip.h", "status": "modified", "additions": 123, "deletions": 38, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Fzip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fminizip%2Fzip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzip.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,7 +1,7 @@\n-/* zip.h -- IO for compress .zip files using zlib \n-   Version 0.15 alpha, Mar 19th, 1998,\n+/* zip.h -- IO for compress .zip files using zlib\n+   Version 1.00, September 10th, 2003\n \n-   Copyright (C) 1998 Gilles Vollant\n+   Copyright (C) 1998-2003 Gilles Vollant\n \n    This unzip package allow creates .ZIP file, compatible with PKZip 2.04g\n      WinZip, InfoZip tools and compatible.\n@@ -10,10 +10,9 @@\n \n   For uncompress .zip file, look at unzip.h\n \n-   THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE\n-   CAN CHANGE IN FUTURE VERSION !!\n+\n    I WAIT FEEDBACK at mail info@winimage.com\n-   Visit also http://www.winimage.com/zLibDll/zip.htm for evolution\n+   Visit also http://www.winimage.com/zLibDll/unzip.html for evolution\n \n    Condition of use and distribution are the same than zlib :\n \n@@ -36,8 +35,9 @@\n \n */\n \n-/* for more info about .ZIP format, see \n-      ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip\n+/* for more info about .ZIP format, see\n+      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip\n+      http://www.info-zip.org/pub/infozip/doc/\n    PkWare has also a specification at :\n       ftp://ftp.pkware.com/probdesc.zip\n */\n@@ -53,65 +53,98 @@ extern \"C\" {\n #include \"zlib.h\"\n #endif\n \n+#ifndef _ZLIBIOAPI_H\n+#include \"ioapi.h\"\n+#endif\n+\n #if defined(STRICTZIP) || defined(STRICTZIPUNZIP)\n /* like the STRICT of WIN32, we define a pointer that cannot be converted\n     from (void*) without cast */\n-typedef struct TagzipFile__ { int unused; } zipFile__; \n+typedef struct TagzipFile__ { int unused; } zipFile__;\n typedef zipFile__ *zipFile;\n #else\n typedef voidp zipFile;\n #endif\n \n-#define ZIP_OK                                  (0)\n-#define ZIP_ERRNO               (Z_ERRNO)\n+#define ZIP_OK                          (0)\n+#define ZIP_EOF                         (0)\n+#define ZIP_ERRNO                       (Z_ERRNO)\n #define ZIP_PARAMERROR                  (-102)\n+#define ZIP_BADZIPFILE                  (-103)\n #define ZIP_INTERNALERROR               (-104)\n \n+#ifndef DEF_MEM_LEVEL\n+#  if MAX_MEM_LEVEL >= 8\n+#    define DEF_MEM_LEVEL 8\n+#  else\n+#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL\n+#  endif\n+#endif\n+/* default memLevel */\n+\n /* tm_zip contain date/time info */\n-typedef struct tm_zip_s \n+typedef struct tm_zip_s\n {\n-\tuInt tm_sec;            /* seconds after the minute - [0,59] */\n-\tuInt tm_min;            /* minutes after the hour - [0,59] */\n-\tuInt tm_hour;           /* hours since midnight - [0,23] */\n-\tuInt tm_mday;           /* day of the month - [1,31] */\n-\tuInt tm_mon;            /* months since January - [0,11] */\n-\tuInt tm_year;           /* years - [1980..2044] */\n+    uInt tm_sec;            /* seconds after the minute - [0,59] */\n+    uInt tm_min;            /* minutes after the hour - [0,59] */\n+    uInt tm_hour;           /* hours since midnight - [0,23] */\n+    uInt tm_mday;           /* day of the month - [1,31] */\n+    uInt tm_mon;            /* months since January - [0,11] */\n+    uInt tm_year;           /* years - [1980..2044] */\n } tm_zip;\n \n typedef struct\n {\n-\ttm_zip      tmz_date;       /* date in understandable format           */\n+    tm_zip      tmz_date;       /* date in understandable format           */\n     uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */\n /*    uLong       flag;        */   /* general purpose bit flag        2 bytes */\n \n     uLong       internal_fa;    /* internal file attributes        2 bytes */\n     uLong       external_fa;    /* external file attributes        4 bytes */\n } zip_fileinfo;\n \n+typedef const char* zipcharpc;\n+\n+\n+#define APPEND_STATUS_CREATE        (0)\n+#define APPEND_STATUS_CREATEAFTER   (1)\n+#define APPEND_STATUS_ADDINZIP      (2)\n+\n extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));\n /*\n   Create a zipfile.\n-\t pathname contain on Windows NT a filename like \"c:\\\\zlib\\\\zlib111.zip\" or on\n-\t   an Unix computer \"zlib/zlib111.zip\".\n-\t if the file pathname exist and append=1, the zip will be created at the end\n-\t   of the file. (useful if the file contain a self extractor code)\n-\t If the zipfile cannot be opened, the return value is NULL.\n+     pathname contain on Windows XP a filename like \"c:\\\\zlib\\\\zlib113.zip\" or on\n+       an Unix computer \"zlib/zlib113.zip\".\n+     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip\n+       will be created at the end of the file.\n+         (useful if the file contain a self extractor code)\n+     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will\n+       add files in existing zip (be sure you don't add file that doesn't exist)\n+     If the zipfile cannot be opened, the return value is NULL.\n      Else, the return value is a zipFile Handle, usable with other function\n-\t   of this zip package.\n-\n+       of this zip package.\n+*/\n \n+/* Note : there is no delete function into a zipfile.\n+   If you want delete file into a zipfile, you must open a zipfile, and create another\n+   Of couse, you can use RAW reading and writing to copy the file you did not want delte\n */\n \n+extern zipFile ZEXPORT zipOpen2 OF((const char *pathname,\n+                                   int append,\n+                                   zipcharpc* globalcomment,\n+                                   zlib_filefunc_def* pzlib_filefunc_def));\n+\n extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,\n-\t\t\t\t\t   const char* filename,\n-\t\t\t\t\t   const zip_fileinfo* zipfi,\n-\t\t\t\t\t   const void* extrafield_local,\n-\t\t\t\t\t   uInt size_extrafield_local,\n-\t\t\t\t\t   const void* extrafield_global,\n-\t\t\t\t\t   uInt size_extrafield_global,\n-\t\t\t\t\t   const char* comment,\n-\t\t\t\t\t   int method,\n-\t\t\t\t\t   int level));\n+                       const char* filename,\n+                       const zip_fileinfo* zipfi,\n+                       const void* extrafield_local,\n+                       uInt size_extrafield_local,\n+                       const void* extrafield_global,\n+                       uInt size_extrafield_global,\n+                       const char* comment,\n+                       int method,\n+                       int level));\n /*\n   Open a file in the ZIP for writing.\n   filename : the filename in zip (if NULL, '-' without quote will be used\n@@ -125,9 +158,51 @@ extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,\n   level contain the level of compression (can be Z_DEFAULT_COMPRESSION)\n */\n \n+\n+extern int ZEXPORT zipOpenNewFileInZip2 OF((zipFile file,\n+                                            const char* filename,\n+                                            const zip_fileinfo* zipfi,\n+                                            const void* extrafield_local,\n+                                            uInt size_extrafield_local,\n+                                            const void* extrafield_global,\n+                                            uInt size_extrafield_global,\n+                                            const char* comment,\n+                                            int method,\n+                                            int level,\n+                                            int raw));\n+\n+/*\n+  Same than zipOpenNewFileInZip, except if raw=1, we write raw file\n+ */\n+\n+extern int ZEXPORT zipOpenNewFileInZip3 OF((zipFile file,\n+                                            const char* filename,\n+                                            const zip_fileinfo* zipfi,\n+                                            const void* extrafield_local,\n+                                            uInt size_extrafield_local,\n+                                            const void* extrafield_global,\n+                                            uInt size_extrafield_global,\n+                                            const char* comment,\n+                                            int method,\n+                                            int level,\n+                                            int raw,\n+                                            int windowBits,\n+                                            int memLevel,\n+                                            int strategy,\n+                                            const char* password,\n+                                            uLong crcForCtypting));\n+\n+/*\n+  Same than zipOpenNewFileInZip2, except\n+    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2\n+    password : crypting password (NULL for no crypting)\n+    crcForCtypting : crc of file to compress (needed for crypting)\n+ */\n+\n+\n extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,\n-\t\t\t\t\t   const voidp buf,\n-\t\t\t\t\t   unsigned len));\n+                       const void* buf,\n+                       unsigned len));\n /*\n   Write data in the zipfile\n */\n@@ -137,8 +212,18 @@ extern int ZEXPORT zipCloseFileInZip OF((zipFile file));\n   Close the current file in the zipfile\n */\n \n+\n+extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,\n+                                            uLong uncompressed_size,\n+                                            uLong crc32));\n+/*\n+  Close the current file in the zipfile, for fiel opened with\n+    parameter raw=1 in zipOpenNewFileInZip2\n+  uncompressed_size and crc32 are value for the uncompressed size\n+*/\n+\n extern int ZEXPORT zipClose OF((zipFile file,\n-\t\t\t\tconst char* global_comment));\n+                const char* global_comment));\n /*\n   Close the zipfile\n */"}, {"sha": "7e9d60d55d90d410e2d4b519f8bcfeb36027081c", "filename": "zlib/contrib/minizip/zlibvc.def", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Fzlibvc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Fzlibvc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzlibvc.def?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,74 +0,0 @@\n-LIBRARY\t\t\"zlib\"\n-\n-DESCRIPTION\t'\"\"\"zlib data compression library\"\"\"'\n-\n-\n-VERSION\t\t1.11\n-\n-\n-HEAPSIZE\t1048576,8192\n-\n-EXPORTS\n-    adler32                        @1\n-    compress                       @2\n-    crc32                          @3\n-    deflate                        @4\n-    deflateCopy                    @5\n-    deflateEnd                     @6\n-    deflateInit2_                  @7\n-    deflateInit_                   @8\n-    deflateParams                  @9\n-    deflateReset                   @10\n-    deflateSetDictionary           @11\n-    gzclose                        @12\n-    gzdopen                        @13\n-    gzerror                        @14\n-    gzflush                        @15\n-    gzopen                         @16\n-    gzread                         @17\n-    gzwrite                        @18\n-    inflate                        @19\n-    inflateEnd                     @20\n-    inflateInit2_                  @21\n-    inflateInit_                   @22\n-    inflateReset                   @23\n-    inflateSetDictionary           @24\n-    inflateSync                    @25\n-    uncompress                     @26\n-    zlibVersion                    @27\n-    gzprintf                       @28\n-    gzputc                         @29\n-    gzgetc                         @30\n-    gzseek                         @31\n-    gzrewind                       @32\n-    gztell                         @33\n-    gzeof                          @34\n-    gzsetparams                    @35\n-    zError                         @36\n-    inflateSyncPoint               @37\n-    get_crc_table                  @38\n-    compress2                      @39\n-    gzputs                         @40\n-    gzgets                         @41\n-\n-\tunzOpen                       @61\n-\tunzClose                      @62\n-\tunzGetGlobalInfo              @63\n-\tunzGetCurrentFileInfo         @64\n-\tunzGoToFirstFile              @65\n-\tunzGoToNextFile               @66\n-\tunzOpenCurrentFile            @67\n-\tunzReadCurrentFile            @68\n-\tunztell                       @70\n-\tunzeof                        @71\n-\tunzCloseCurrentFile           @72\n-\tunzGetGlobalComment           @73\n-\tunzStringFileNameCompare      @74\n-\tunzLocateFile                 @75\n-\tunzGetLocalExtrafield         @76\n-\n-\tzipOpen                       @80\n-\tzipOpenNewFileInZip           @81\n-\tzipWriteInFileInZip           @82\n-\tzipCloseFileInZip             @83\n-\tzipClose                      @84"}, {"sha": "a70d4d4a6b0ec6ad54f2966c42b445e9b8ded02b", "filename": "zlib/contrib/minizip/zlibvc.dsp", "status": "removed", "additions": 0, "deletions": 651, "changes": 651, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsp?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,651 +0,0 @@\n-# Microsoft Developer Studio Project File - Name=\"zlibvc\" - Package Owner=<4>\n-# Microsoft Developer Studio Generated Build File, Format Version 5.00\n-# ** DO NOT EDIT **\n-\n-# TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n-# TARGTYPE \"Win32 (ALPHA) Dynamic-Link Library\" 0x0602\n-\n-CFG=zlibvc - Win32 Release\n-!MESSAGE This is not a valid makefile. To build this project using NMAKE,\n-!MESSAGE use the Export Makefile command and run\n-!MESSAGE \n-!MESSAGE NMAKE /f \"zlibvc.mak\".\n-!MESSAGE \n-!MESSAGE You can specify a configuration when running NMAKE\n-!MESSAGE by defining the macro CFG on the command line. For example:\n-!MESSAGE \n-!MESSAGE NMAKE /f \"zlibvc.mak\" CFG=\"zlibvc - Win32 Release\"\n-!MESSAGE \n-!MESSAGE Possible choices for configuration are:\n-!MESSAGE \n-!MESSAGE \"zlibvc - Win32 Release\" (based on \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \"zlibvc - Win32 Debug\" (based on \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \"zlibvc - Win32 ReleaseAxp\" (based on\\\n- \"Win32 (ALPHA) Dynamic-Link Library\")\n-!MESSAGE \"zlibvc - Win32 ReleaseWithoutAsm\" (based on\\\n- \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \"zlibvc - Win32 ReleaseWithoutCrtdll\" (based on\\\n- \"Win32 (x86) Dynamic-Link Library\")\n-!MESSAGE \n-\n-# Begin Project\n-# PROP Scc_ProjName \"\"\n-# PROP Scc_LocalPath \"\"\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \".\\Release\"\n-# PROP BASE Intermediate_Dir \".\\Release\"\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \".\\Release\"\n-# PROP Intermediate_Dir \".\\Release\"\n-# PROP Ignore_Export_Lib 0\n-# PROP Target_Dir \"\"\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /FD /c\n-# SUBTRACT CPP /YX\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n-# ADD RSC /l 0x40c /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386\n-# ADD LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n-# SUBTRACT LINK32 /pdb:none\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 1\n-# PROP BASE Output_Dir \".\\Debug\"\n-# PROP BASE Intermediate_Dir \".\\Debug\"\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 1\n-# PROP Output_Dir \".\\Debug\"\n-# PROP Intermediate_Dir \".\\Debug\"\n-# PROP Target_Dir \"\"\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /FD /c\n-# SUBTRACT CPP /YX\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"_DEBUG\" /win32\n-# ADD MTL /nologo /D \"_DEBUG\" /mktyplib203 /win32\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"_DEBUG\"\n-# ADD RSC /l 0x40c /d \"_DEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:\".\\Debug\\zlib.dll\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"zlibvc__\"\n-# PROP BASE Intermediate_Dir \"zlibvc__\"\n-# PROP BASE Ignore_Export_Lib 0\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"zlibvc__\"\n-# PROP Intermediate_Dir \"zlibvc__\"\n-# PROP Ignore_Export_Lib 0\n-# PROP Target_Dir \"\"\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /Gt0 /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /YX /FD /c\n-# ADD CPP /nologo /MT /Gt0 /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /FD /c\n-# SUBTRACT CPP /YX\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n-# ADD RSC /l 0x40c /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 crtdll.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /map /machine:ALPHA /nodefaultlib /out:\".\\Release\\zlib.dll\"\n-# SUBTRACT BASE LINK32 /pdb:none\n-# ADD LINK32 crtdll.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib /nologo /subsystem:windows /dll /map /machine:ALPHA /nodefaultlib /out:\"zlibvc__\\zlib.dll\"\n-# SUBTRACT LINK32 /pdb:none\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"zlibvc_0\"\n-# PROP BASE Intermediate_Dir \"zlibvc_0\"\n-# PROP BASE Ignore_Export_Lib 0\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"zlibvc_0\"\n-# PROP Intermediate_Dir \"zlibvc_0\"\n-# PROP Ignore_Export_Lib 0\n-# PROP Target_Dir \"\"\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /YX /FD /c\n-# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /FAcs /FR /FD /c\n-# SUBTRACT CPP /YX\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n-# ADD RSC /l 0x40c /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n-# SUBTRACT BASE LINK32 /pdb:none\n-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\zlibvc_0\\zlib.dll\"\n-# SUBTRACT LINK32 /pdb:none\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-# PROP BASE Use_MFC 0\n-# PROP BASE Use_Debug_Libraries 0\n-# PROP BASE Output_Dir \"zlibvc_1\"\n-# PROP BASE Intermediate_Dir \"zlibvc_1\"\n-# PROP BASE Ignore_Export_Lib 0\n-# PROP BASE Target_Dir \"\"\n-# PROP Use_MFC 0\n-# PROP Use_Debug_Libraries 0\n-# PROP Output_Dir \"zlibvc_1\"\n-# PROP Intermediate_Dir \"zlibvc_1\"\n-# PROP Ignore_Export_Lib 0\n-# PROP Target_Dir \"\"\n-CPP=cl.exe\n-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /YX /FD /c\n-# ADD CPP /nologo /MT /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"_WINDLL\" /D \"_WIN32\" /D \"BUILD_ZLIBDLL\" /D \"ZLIB_DLL\" /D \"DYNAMIC_CRC_TABLE\" /D \"ASMV\" /FAcs /FR /FD /c\n-# SUBTRACT CPP /YX\n-MTL=midl.exe\n-# ADD BASE MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-# ADD MTL /nologo /D \"NDEBUG\" /mktyplib203 /win32\n-RSC=rc.exe\n-# ADD BASE RSC /l 0x40c /d \"NDEBUG\"\n-# ADD RSC /l 0x40c /d \"NDEBUG\"\n-BSC32=bscmake.exe\n-# ADD BASE BSC32 /nologo\n-# ADD BSC32 /nologo\n-LINK32=link.exe\n-# ADD BASE LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\Release\\zlib.dll\"\n-# SUBTRACT BASE LINK32 /pdb:none\n-# ADD LINK32 gvmat32.obj kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib crtdll.lib /nologo /subsystem:windows /dll /map /machine:I386 /nodefaultlib /out:\".\\zlibvc_1\\zlib.dll\"\n-# SUBTRACT LINK32 /pdb:none\n-\n-!ENDIF \n-\n-# Begin Target\n-\n-# Name \"zlibvc - Win32 Release\"\n-# Name \"zlibvc - Win32 Debug\"\n-# Name \"zlibvc - Win32 ReleaseAxp\"\n-# Name \"zlibvc - Win32 ReleaseWithoutAsm\"\n-# Name \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-# Begin Group \"Source Files\"\n-\n-# PROP Default_Filter \"cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90\"\n-# Begin Source File\n-\n-SOURCE=.\\adler32.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_ADLER=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\compress.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_COMPR=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\crc32.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_CRC32=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\deflate.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_DEFLA=\\\n-\t\".\\deflate.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\gvmat32c.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\gzio.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_GZIO_=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infblock.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFBL=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\infcodes.h\"\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\infutil.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infcodes.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFCO=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\infcodes.h\"\\\n-\t\".\\inffast.h\"\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\infutil.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inffast.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFFA=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\infcodes.h\"\\\n-\t\".\\inffast.h\"\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\infutil.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inflate.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFLA=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inftrees.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFTR=\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infutil.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_INFUT=\\\n-\t\".\\infblock.h\"\\\n-\t\".\\infcodes.h\"\\\n-\t\".\\inftrees.h\"\\\n-\t\".\\infutil.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\trees.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_TREES=\\\n-\t\".\\deflate.h\"\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\uncompr.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_UNCOM=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\unzip.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zip.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zlib.rc\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zlibvc.def\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zutil.c\n-\n-!IF  \"$(CFG)\" == \"zlibvc - Win32 Release\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 Debug\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseAxp\"\n-\n-DEP_CPP_ZUTIL=\\\n-\t\".\\zconf.h\"\\\n-\t\".\\zlib.h\"\\\n-\t\".\\zutil.h\"\\\n-\t\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutAsm\"\n-\n-!ELSEIF  \"$(CFG)\" == \"zlibvc - Win32 ReleaseWithoutCrtdll\"\n-\n-!ENDIF \n-\n-# End Source File\n-# End Group\n-# Begin Group \"Header Files\"\n-\n-# PROP Default_Filter \"h;hpp;hxx;hm;inl;fi;fd\"\n-# Begin Source File\n-\n-SOURCE=.\\deflate.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infblock.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infcodes.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inffast.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\inftrees.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\infutil.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zconf.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zlib.h\n-# End Source File\n-# Begin Source File\n-\n-SOURCE=.\\zutil.h\n-# End Source File\n-# End Group\n-# Begin Group \"Resource Files\"\n-\n-# PROP Default_Filter \"ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe\"\n-# End Group\n-# End Target\n-# End Project"}, {"sha": "493cd870365a5cfb7e0725656d66c3b1d0b3dd21", "filename": "zlib/contrib/minizip/zlibvc.dsw", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fminizip%2Fzlibvc.dsw?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,41 +0,0 @@\n-Microsoft Developer Studio Workspace File, Format Version 5.00\n-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!\n-\n-###############################################################################\n-\n-Project: \"zlibstat\"=.\\zlibstat.dsp - Package Owner=<4>\n-\n-Package=<5>\n-{{{\n-}}}\n-\n-Package=<4>\n-{{{\n-}}}\n-\n-###############################################################################\n-\n-Project: \"zlibvc\"=.\\zlibvc.dsp - Package Owner=<4>\n-\n-Package=<5>\n-{{{\n-}}}\n-\n-Package=<4>\n-{{{\n-}}}\n-\n-###############################################################################\n-\n-Global:\n-\n-Package=<5>\n-{{{\n-}}}\n-\n-Package=<3>\n-{{{\n-}}}\n-\n-###############################################################################\n-"}, {"sha": "b54266fba20a167a1d83b7afd503dfd2f849ca57", "filename": "zlib/contrib/untgz/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Funtgz%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Funtgz%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Funtgz%2FMakefile?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,14 +1,14 @@\n CC=cc\n CFLAGS=-g\n \n-untgz: untgz.o  ../../libz.a\n-\t$(CC) $(CFLAGS) -o untgz  untgz.o -L../.. -lz\n+untgz: untgz.o ../../libz.a\n+\t$(CC) $(CFLAGS) -o untgz untgz.o -L../.. -lz\n \n untgz.o: untgz.c ../../zlib.h\n \t$(CC) $(CFLAGS) -c -I../.. untgz.c\n \n ../../libz.a:\n-\tcd ../..; make\n+\tcd ../..; ./configure; make\n \n clean:\n \trm -f untgz untgz.o *~"}, {"sha": "c99dc28cf55a36bebcb9ce3b13ec7e98e0ec18ac", "filename": "zlib/contrib/untgz/makefile.w32", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Funtgz%2Fmakefile.w32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fcontrib%2Funtgz%2Fmakefile.w32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Funtgz%2Fmakefile.w32?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,63 +0,0 @@\n-# Makefile for zlib.  Modified for mingw32\n-# For conditions of distribution and use, see copyright notice in zlib.h \n-\n-# To compile, \n-# \n-#   make -fmakefile.w32\n-# \n-\n-CC=gcc\n-\n-# Generate dependencies (see end of the file)\n-\n-CPPFLAGS=-MMD \n-\n-#CFLAGS=-MMD -O\n-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\n-#CFLAGS=-MMD -g -DDEBUG\n-CFLAGS=-O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \\\n-             -Wstrict-prototypes -Wmissing-prototypes\n-\n-# If cp.exe is not found, replace with copy /Y .\n-CP=cp -f\n-\n-# The default value of RM is \"rm -f.\"  \n-# If \"rm.exe\" is not found, uncomment:\n-# RM=del\n-\n-LD=gcc\n-LDLIBS=-L. -lz\n-LDFLAGS=-s\n-\n-\n-INCL=zlib.h zconf.h\n-LIBS=libz.a\n-\n-AR=ar rcs\n-\n-OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n-       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o \\\n-       inffast.o\n-\n-TEST_OBJS = minigzip.o untgz.o\n-\n-all: minigzip.exe untgz.exe\n-\n-rebuild:\tclean\tall\n-\n-libz.a: $(OBJS)\n-\t$(AR) $@ $(OBJS)\n-\n-%.exe : %.o $(LIBS)\n-\t$(LD) $(LDFLAGS) -o $@ $< $(LDLIBS)\n-\n-.PHONY : clean\n-\n-clean:\n-\t$(RM) *.d *.o *.exe libz.a foo.gz\n-\n-DEPS := $(wildcard *.d)\n-ifneq ($(DEPS),)\n-include $(DEPS)\n-endif\n-"}, {"sha": "d748b6905bbfe435b157d6d7ae56f85529766d48", "filename": "zlib/contrib/untgz/untgz.c", "status": "modified", "additions": 331, "deletions": 284, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Funtgz%2Funtgz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Funtgz%2Funtgz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Funtgz%2Funtgz.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,213 +1,265 @@\n /*\n- * untgz.c -- Display contents and/or extract file from\n- * a gzip'd TAR file\n+ * untgz.c -- Display contents and extract files from a gzip'd TAR file\n+ *\n  * written by \"Pedro A. Aranda Guti\\irrez\" <paag@tid.es>\n  * adaptation to Unix by Jean-loup Gailly <jloup@gzip.org>\n+ * various fixes by Cosmin Truta <cosmint@cs.ubbcluj.ro>\n  */\n \n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n #include <time.h>\n #include <errno.h>\n-#include <fcntl.h>\n+\n+#include \"zlib.h\"\n+\n #ifdef unix\n # include <unistd.h>\n #else\n # include <direct.h>\n # include <io.h>\n #endif\n \n-#include \"zlib.h\"\n-\n #ifdef WIN32\n+#include <windows.h>\n #  ifndef F_OK\n-#    define F_OK (0)\n+#    define F_OK  0\n #  endif\n+#  define mkdir(dirname,mode)   _mkdir(dirname)\n #  ifdef _MSC_VER\n-#    define mkdir(dirname,mode) _mkdir(dirname)\n #    define strdup(str)         _strdup(str)\n-#    define unlink(fn)          _unlink(fn)\n #    define access(path,mode)   _access(path,mode)\n-#  else\n-#    define mkdir(dirname,mode) _mkdir(dirname)\n #  endif\n #else\n #  include <utime.h>\n #endif\n \n \n-/* Values used in typeflag field.  */\n+/* values used in typeflag field */\n \n-#define REGTYPE\t '0'\t\t/* regular file */\n-#define AREGTYPE '\\0'\t\t/* regular file */\n-#define LNKTYPE  '1'\t\t/* link */\n-#define SYMTYPE  '2'\t\t/* reserved */\n-#define CHRTYPE  '3'\t\t/* character special */\n-#define BLKTYPE  '4'\t\t/* block special */\n-#define DIRTYPE  '5'\t\t/* directory */\n-#define FIFOTYPE '6'\t\t/* FIFO special */\n-#define CONTTYPE '7'\t\t/* reserved */\n+#define REGTYPE  '0'            /* regular file */\n+#define AREGTYPE '\\0'           /* regular file */\n+#define LNKTYPE  '1'            /* link */\n+#define SYMTYPE  '2'            /* reserved */\n+#define CHRTYPE  '3'            /* character special */\n+#define BLKTYPE  '4'            /* block special */\n+#define DIRTYPE  '5'            /* directory */\n+#define FIFOTYPE '6'            /* FIFO special */\n+#define CONTTYPE '7'            /* reserved */\n \n #define BLOCKSIZE 512\n \n struct tar_header\n-{\t\t\t\t/* byte offset */\n-  char name[100];\t\t/*   0 */\n-  char mode[8];\t\t\t/* 100 */\n-  char uid[8];\t\t\t/* 108 */\n-  char gid[8];\t\t\t/* 116 */\n-  char size[12];\t\t/* 124 */\n-  char mtime[12];\t\t/* 136 */\n-  char chksum[8];\t\t/* 148 */\n-  char typeflag;\t\t/* 156 */\n-  char linkname[100];\t\t/* 157 */\n-  char magic[6];\t\t/* 257 */\n-  char version[2];\t\t/* 263 */\n-  char uname[32];\t\t/* 265 */\n-  char gname[32];\t\t/* 297 */\n-  char devmajor[8];\t\t/* 329 */\n-  char devminor[8];\t\t/* 337 */\n-  char prefix[155];\t\t/* 345 */\n-\t\t\t\t/* 500 */\n+{                               /* byte offset */\n+  char name[100];               /*   0 */\n+  char mode[8];                 /* 100 */\n+  char uid[8];                  /* 108 */\n+  char gid[8];                  /* 116 */\n+  char size[12];                /* 124 */\n+  char mtime[12];               /* 136 */\n+  char chksum[8];               /* 148 */\n+  char typeflag;                /* 156 */\n+  char linkname[100];           /* 157 */\n+  char magic[6];                /* 257 */\n+  char version[2];              /* 263 */\n+  char uname[32];               /* 265 */\n+  char gname[32];               /* 297 */\n+  char devmajor[8];             /* 329 */\n+  char devminor[8];             /* 337 */\n+  char prefix[155];             /* 345 */\n+                                /* 500 */\n };\n \n union tar_buffer {\n   char               buffer[BLOCKSIZE];\n   struct tar_header  header;\n };\n \n-enum { TGZ_EXTRACT = 0, TGZ_LIST };\n+enum { TGZ_EXTRACT, TGZ_LIST, TGZ_INVALID };\n \n-static char *TGZfname\tOF((const char *));\n-void TGZnotfound\tOF((const char *));\n+char *TGZfname          OF((const char *));\n+void TGZnotfound        OF((const char *));\n \n-int getoct\t\tOF((char *, int));\n-char *strtime\t\tOF((time_t *));\n-int ExprMatch\t\tOF((char *,char *));\n+int getoct              OF((char *, int));\n+char *strtime           OF((time_t *));\n+int setfiletime         OF((char *, time_t));\n+int ExprMatch           OF((char *, char *));\n \n-int makedir\t\tOF((char *));\n-int matchname\t\tOF((int,int,char **,char *));\n+int makedir             OF((char *));\n+int matchname           OF((int, int, char **, char *));\n \n-void error\t\tOF((const char *));\n-int  tar\t\tOF((gzFile, int, int, int, char **));\n+void error              OF((const char *));\n+int tar                 OF((gzFile, int, int, int, char **));\n \n-void help\t\tOF((int));\n-int main\t\tOF((int, char **));\n+void help               OF((int));\n+int main                OF((int, char **));\n \n char *prog;\n \n-/* This will give a benign warning */\n+const char *TGZsuffix[] = { \"\\0\", \".tar\", \".tar.gz\", \".taz\", \".tgz\", NULL };\n \n-static char *TGZprefix[] = { \"\\0\", \".tgz\", \".tar.gz\", \".tar\", NULL };\n+/* return the file name of the TGZ archive */\n+/* or NULL if it does not exist */\n \n-/* Return the real name of the TGZ archive */\n-/* or NULL if it does not exist. */\n-\n-static char *TGZfname OF((const char *fname))\n+char *TGZfname (const char *arcname)\n {\n   static char buffer[1024];\n   int origlen,i;\n-  \n-  strcpy(buffer,fname);\n+\n+  strcpy(buffer,arcname);\n   origlen = strlen(buffer);\n \n-  for (i=0; TGZprefix[i]; i++)\n+  for (i=0; TGZsuffix[i]; i++)\n     {\n-       strcpy(buffer+origlen,TGZprefix[i]);\n+       strcpy(buffer+origlen,TGZsuffix[i]);\n        if (access(buffer,F_OK) == 0)\n          return buffer;\n     }\n   return NULL;\n }\n \n+\n /* error message for the filename */\n \n-void TGZnotfound OF((const char *fname))\n+void TGZnotfound (const char *arcname)\n {\n   int i;\n \n-  fprintf(stderr,\"%s : couldn't find \",prog);\n-  for (i=0;TGZprefix[i];i++)\n-    fprintf(stderr,(TGZprefix[i+1]) ? \"%s%s, \" : \"or %s%s\\n\",\n-            fname,\n-            TGZprefix[i]);\n+  fprintf(stderr,\"%s: Couldn't find \",prog);\n+  for (i=0;TGZsuffix[i];i++)\n+    fprintf(stderr,(TGZsuffix[i+1]) ? \"%s%s, \" : \"or %s%s\\n\",\n+            arcname,\n+            TGZsuffix[i]);\n   exit(1);\n }\n \n \n-/* help functions */\n+/* convert octal digits to int */\n+/* on error return -1 */\n \n-int getoct(char *p,int width)\n+int getoct (char *p,int width)\n {\n   int result = 0;\n   char c;\n-  \n-  while (width --)\n+\n+  while (width--)\n     {\n       c = *p++;\n-      if (c == ' ')\n-\tcontinue;\n       if (c == 0)\n-\tbreak;\n+        break;\n+      if (c == ' ')\n+        continue;\n+      if (c < '0' || c > '7')\n+        return -1;\n       result = result * 8 + (c - '0');\n     }\n   return result;\n }\n \n+\n+/* convert time_t to string */\n+/* use the \"YYYY/MM/DD hh:mm:ss\" format */\n+\n char *strtime (time_t *t)\n {\n   struct tm   *local;\n   static char result[32];\n \n   local = localtime(t);\n-  sprintf(result,\"%2d/%02d/%4d %02d:%02d:%02d\",\n-\t  local->tm_mday, local->tm_mon+1, local->tm_year+1900,\n-\t  local->tm_hour, local->tm_min,   local->tm_sec);\n+  sprintf(result,\"%4d/%02d/%02d %02d:%02d:%02d\",\n+          local->tm_year+1900, local->tm_mon+1, local->tm_mday,\n+          local->tm_hour, local->tm_min, local->tm_sec);\n+  return result;\n+}\n+\n+\n+/* set file time */\n+\n+int setfiletime (char *fname,time_t ftime)\n+{\n+#ifdef WIN32\n+  static int isWinNT = -1;\n+  SYSTEMTIME st;\n+  FILETIME locft, modft;\n+  struct tm *loctm;\n+  HANDLE hFile;\n+  int result;\n+\n+  loctm = localtime(&ftime);\n+  if (loctm == NULL)\n+    return -1;\n+\n+  st.wYear         = (WORD)loctm->tm_year + 1900;\n+  st.wMonth        = (WORD)loctm->tm_mon + 1;\n+  st.wDayOfWeek    = (WORD)loctm->tm_wday;\n+  st.wDay          = (WORD)loctm->tm_mday;\n+  st.wHour         = (WORD)loctm->tm_hour;\n+  st.wMinute       = (WORD)loctm->tm_min;\n+  st.wSecond       = (WORD)loctm->tm_sec;\n+  st.wMilliseconds = 0;\n+  if (!SystemTimeToFileTime(&st, &locft) ||\n+      !LocalFileTimeToFileTime(&locft, &modft))\n+    return -1;\n+\n+  if (isWinNT < 0)\n+    isWinNT = (GetVersion() < 0x80000000) ? 1 : 0;\n+  hFile = CreateFile(fname, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\n+                     (isWinNT ? FILE_FLAG_BACKUP_SEMANTICS : 0),\n+                     NULL);\n+  if (hFile == INVALID_HANDLE_VALUE)\n+    return -1;\n+  result = SetFileTime(hFile, NULL, NULL, &modft) ? 0 : -1;\n+  CloseHandle(hFile);\n   return result;\n+#else\n+  struct utimbuf settime;\n+\n+  settime.actime = settime.modtime = ftime;\n+  return utime(fname,&settime);\n+#endif\n }\n \n \n /* regular expression matching */\n \n #define ISSPECIAL(c) (((c) == '*') || ((c) == '/'))\n \n-int ExprMatch(char *string,char *expr)\n+int ExprMatch (char *string,char *expr)\n {\n   while (1)\n     {\n       if (ISSPECIAL(*expr))\n-\t{\n-\t  if (*expr == '/')\n-\t    {\n-\t      if (*string != '\\\\' && *string != '/')\n-\t\treturn 0;\n-\t      string ++; expr++;\n-\t    }\n-\t  else if (*expr == '*')\n-\t    {\n-\t      if (*expr ++ == 0)\n-\t\treturn 1;\n-\t      while (*++string != *expr)\n-\t\tif (*string == 0)\n-\t\t  return 0;\n-\t    }\n-\t}\n+        {\n+          if (*expr == '/')\n+            {\n+              if (*string != '\\\\' && *string != '/')\n+                return 0;\n+              string ++; expr++;\n+            }\n+          else if (*expr == '*')\n+            {\n+              if (*expr ++ == 0)\n+                return 1;\n+              while (*++string != *expr)\n+                if (*string == 0)\n+                  return 0;\n+            }\n+        }\n       else\n-\t{\n-\t  if (*string != *expr)\n-\t    return 0;\n-\t  if (*expr++ == 0)\n-\t    return 1;\n-\t  string++;\n-\t}\n+        {\n+          if (*string != *expr)\n+            return 0;\n+          if (*expr++ == 0)\n+            return 1;\n+          string++;\n+        }\n     }\n }\n \n-/* recursive make directory */\n-/* abort if you get an ENOENT errno somewhere in the middle */\n-/* e.g. ignore error \"mkdir on existing directory\" */\n-/* */\n+\n+/* recursive mkdir */\n+/* abort on ENOENT; ignore other errors like \"directory already exists\" */\n /* return 1 if OK */\n /*        0 on error */\n \n@@ -216,15 +268,15 @@ int makedir (char *newdir)\n   char *buffer = strdup(newdir);\n   char *p;\n   int  len = strlen(buffer);\n-  \n+\n   if (len <= 0) {\n     free(buffer);\n     return 0;\n   }\n   if (buffer[len-1] == '/') {\n     buffer[len-1] = '\\0';\n   }\n-  if (mkdir(buffer, 0775) == 0)\n+  if (mkdir(buffer, 0755) == 0)\n     {\n       free(buffer);\n       return 1;\n@@ -234,28 +286,29 @@ int makedir (char *newdir)\n   while (1)\n     {\n       char hold;\n-      \n+\n       while(*p && *p != '\\\\' && *p != '/')\n-\tp++;\n+        p++;\n       hold = *p;\n       *p = 0;\n-      if ((mkdir(buffer, 0775) == -1) && (errno == ENOENT))\n-\t{\n-\t  fprintf(stderr,\"%s: couldn't create directory %s\\n\",prog,buffer);\n-\t  free(buffer);\n-\t  return 0;\n-\t}\n+      if ((mkdir(buffer, 0755) == -1) && (errno == ENOENT))\n+        {\n+          fprintf(stderr,\"%s: Couldn't create directory %s\\n\",prog,buffer);\n+          free(buffer);\n+          return 0;\n+        }\n       if (hold == 0)\n-\tbreak;\n+        break;\n       *p++ = hold;\n     }\n   free(buffer);\n   return 1;\n }\n \n+\n int matchname (int arg,int argc,char **argv,char *fname)\n {\n-  if (arg == argc)\t\t/* no arguments given (untgz tgzarchive) */\n+  if (arg == argc)      /* no arguments given (untgz tgzarchive) */\n     return 1;\n \n   while (arg < argc)\n@@ -266,7 +319,7 @@ int matchname (int arg,int argc,char **argv,char *fname)\n }\n \n \n-/* Tar file list or extract */\n+/* tar file list or extract */\n \n int tar (gzFile in,int action,int arg,int argc,char **argv)\n {\n@@ -277,219 +330,215 @@ int tar (gzFile in,int action,int arg,int argc,char **argv)\n   int    remaining = 0;\n   FILE   *outfile = NULL;\n   char   fname[BLOCKSIZE];\n+  int    tarmode;\n   time_t tartime;\n-  \n+\n   if (action == TGZ_LIST)\n-    printf(\"     day      time     size                       file\\n\"\n-\t   \" ---------- -------- --------- -------------------------------------\\n\");\n+    printf(\"    date      time     size                       file\\n\"\n+           \" ---------- -------- --------- -------------------------------------\\n\");\n   while (1)\n     {\n       len = gzread(in, &buffer, BLOCKSIZE);\n       if (len < 0)\n-\terror (gzerror(in, &err));\n+        error(gzerror(in, &err));\n       /*\n        * Always expect complete blocks to process\n        * the tar information.\n        */\n       if (len != BLOCKSIZE)\n-\terror(\"gzread: incomplete block read\");\n-      \n+        {\n+          action = TGZ_INVALID; /* force error exit */\n+          remaining = 0;        /* force I/O cleanup */\n+        }\n+\n       /*\n        * If we have to get a tar header\n        */\n       if (getheader == 1)\n-\t{\n-\t  /*\n-\t   * if we met the end of the tar\n-\t   * or the end-of-tar block,\n-\t   * we are done\n-\t   */\n-\t  if ((len == 0)  || (buffer.header.name[0]== 0)) break;\n-\n-\t  tartime = (time_t)getoct(buffer.header.mtime,12);\n-\t  strcpy(fname,buffer.header.name);\n-\t  \n-\t  switch (buffer.header.typeflag)\n-\t    {\n-\t    case DIRTYPE:\n-\t      if (action == TGZ_LIST)\n-\t\tprintf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n-\t      if (action == TGZ_EXTRACT)\n-\t\tmakedir(fname);\n-\t      break;\n-\t    case REGTYPE:\n-\t    case AREGTYPE:\n-\t      remaining = getoct(buffer.header.size,12);\n-\t      if (action == TGZ_LIST)\n-\t\tprintf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n-\t      if (action == TGZ_EXTRACT)\n-\t\t{\n-\t\t  if ((remaining) && (matchname(arg,argc,argv,fname)))\n-\t\t    {\n-\t\t      outfile = fopen(fname,\"wb\");\n-\t\t      if (outfile == NULL) {\n-\t\t\t/* try creating directory */\n-\t\t\tchar *p = strrchr(fname, '/');\n-\t\t\tif (p != NULL) {\n-\t\t\t  *p = '\\0';\n-\t\t\t  makedir(fname);\n-\t\t\t  *p = '/';\n-\t\t\t  outfile = fopen(fname,\"wb\");\n-\t\t\t}\n-\t\t      }\n-\t\t      fprintf(stderr,\n-\t\t\t      \"%s %s\\n\",\n-\t\t\t      (outfile) ? \"Extracting\" : \"Couldn't create\",\n-\t\t\t      fname);\n-\t\t    }\n-\t\t  else\n-\t\t    outfile = NULL;\n-\t\t}\n-\t      /*\n-\t       * could have no contents\n-\t       */\n-\t      getheader = (remaining) ? 0 : 1;\n-\t      break;\n-\t    default:\n-\t      if (action == TGZ_LIST)\n-\t\tprintf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n-\t      break;\n-\t    }\n-\t}\n+        {\n+          /*\n+           * if we met the end of the tar\n+           * or the end-of-tar block,\n+           * we are done\n+           */\n+          if ((len == 0) || (buffer.header.name[0] == 0)) break;\n+\n+          tarmode = getoct(buffer.header.mode,8);\n+          tartime = (time_t)getoct(buffer.header.mtime,12);\n+          if (tarmode == -1 || tartime == (time_t)-1)\n+            {\n+              buffer.header.name[0] = 0;\n+              action = TGZ_INVALID;\n+            }\n+\n+          strcpy(fname,buffer.header.name);\n+\n+          switch (buffer.header.typeflag)\n+            {\n+            case DIRTYPE:\n+              if (action == TGZ_LIST)\n+                printf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n+              if (action == TGZ_EXTRACT)\n+                {\n+                  makedir(fname);\n+                  setfiletime(fname,tartime);\n+                }\n+              break;\n+            case REGTYPE:\n+            case AREGTYPE:\n+              remaining = getoct(buffer.header.size,12);\n+              if (remaining == -1)\n+                {\n+                  action = TGZ_INVALID;\n+                  break;\n+                }\n+              if (action == TGZ_LIST)\n+                printf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n+              else if (action == TGZ_EXTRACT)\n+                {\n+                  if (matchname(arg,argc,argv,fname))\n+                    {\n+                      outfile = fopen(fname,\"wb\");\n+                      if (outfile == NULL) {\n+                        /* try creating directory */\n+                        char *p = strrchr(fname, '/');\n+                        if (p != NULL) {\n+                          *p = '\\0';\n+                          makedir(fname);\n+                          *p = '/';\n+                          outfile = fopen(fname,\"wb\");\n+                        }\n+                      }\n+                      if (outfile != NULL)\n+                        printf(\"Extracting %s\\n\",fname);\n+                      else\n+                        fprintf(stderr, \"%s: Couldn't create %s\",prog,fname);\n+                    }\n+                  else\n+                    outfile = NULL;\n+                }\n+              getheader = 0;\n+              break;\n+            default:\n+              if (action == TGZ_LIST)\n+                printf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n+              break;\n+            }\n+        }\n       else\n-\t{\n-\t  unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n-\n-\t  if ((action == TGZ_EXTRACT) && (outfile != NULL))\n-\t    {\n-\t      if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n-\t\t{\n-\t\t  fprintf(stderr,\"%s : error writing %s skipping...\\n\",prog,fname);\n-\t\t  fclose(outfile);\n-\t\t  unlink(fname);\n-\t\t}\n-\t    }\n-\t  remaining -= bytes;\n-\t  if (remaining == 0)\n-\t    {\n-\t      getheader = 1;\n-\t      if ((action == TGZ_EXTRACT) && (outfile != NULL))\n-\t\t{\n-#ifdef WIN32\n-\t\t  HANDLE hFile;\n-\t\t  FILETIME ftm,ftLocal;\n-\t\t  SYSTEMTIME st;\n-\t\t  struct tm localt;\n- \n-\t\t  fclose(outfile);\n-\n-\t\t  localt = *localtime(&tartime);\n-\n-\t\t  hFile = CreateFile(fname, GENERIC_READ | GENERIC_WRITE,\n-\t\t\t\t     0, NULL, OPEN_EXISTING, 0, NULL);\n-\t\t  \n-\t\t  st.wYear = (WORD)localt.tm_year+1900;\n-\t\t  st.wMonth = (WORD)localt.tm_mon;\n-\t\t  st.wDayOfWeek = (WORD)localt.tm_wday;\n-\t\t  st.wDay = (WORD)localt.tm_mday;\n-\t\t  st.wHour = (WORD)localt.tm_hour;\n-\t\t  st.wMinute = (WORD)localt.tm_min;\n-\t\t  st.wSecond = (WORD)localt.tm_sec;\n-\t\t  st.wMilliseconds = 0;\n-\t\t  SystemTimeToFileTime(&st,&ftLocal);\n-\t\t  LocalFileTimeToFileTime(&ftLocal,&ftm);\n-\t\t  SetFileTime(hFile,&ftm,NULL,&ftm);\n-\t\t  CloseHandle(hFile);\n-\n-\t\t  outfile = NULL;\n-#else\n-\t\t  struct utimbuf settime;\n-\n-\t\t  settime.actime = settime.modtime = tartime;\n+        {\n+          unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n+\n+          if (outfile != NULL)\n+            {\n+              if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n+                {\n+                  fprintf(stderr,\"%s: Error writing %s -- skipping\\n\",prog,fname);\n+                  fclose(outfile);\n+                  outfile = NULL;\n+                  remove(fname);\n+                }\n+            }\n+          remaining -= bytes;\n+        }\n+\n+      if (remaining == 0)\n+        {\n+          getheader = 1;\n+          if (outfile != NULL)\n+            {\n+              fclose(outfile);\n+              outfile = NULL;\n+              if (action != TGZ_INVALID)\n+                setfiletime(fname,tartime);\n+            }\n+        }\n \n-\t\t  fclose(outfile);\n-\t\t  outfile = NULL;\n-\t\t  utime(fname,&settime);\n-#endif\n-\t\t}\n-\t    }\n-\t}\n+      /*\n+       * Abandon if errors are found\n+       */\n+      if (action == TGZ_INVALID)\n+        {\n+          error(\"broken archive\");\n+          break;\n+        }\n     }\n-  \n+\n   if (gzclose(in) != Z_OK)\n     error(\"failed gzclose\");\n \n   return 0;\n }\n \n \n-/* =========================================================== */\n+/* ============================================================ */\n \n void help(int exitval)\n {\n-  fprintf(stderr,\n-\t  \"untgz v 0.1\\n\"\n-\t  \" an sample application of zlib 1.0.4\\n\\n\"\n-          \"Usage : untgz TGZfile            to extract all files\\n\"\n-          \"        untgz TGZfile fname ...  to extract selected files\\n\"\n-          \"        untgz -l TGZfile         to list archive contents\\n\"\n-          \"        untgz -h                 to display this help\\n\\n\");\n+  printf(\"untgz version 0.2\\n\"\n+         \"  using zlib version %s\\n\\n\",\n+         zlibVersion());\n+  printf(\"Usage: untgz file.tgz            extract all files\\n\"\n+         \"       untgz file.tgz fname ...  extract selected files\\n\"\n+         \"       untgz -l file.tgz         list archive contents\\n\"\n+         \"       untgz -h                  display this help\\n\");\n   exit(exitval);\n }\n \n void error(const char *msg)\n {\n-    fprintf(stderr, \"%s: %s\\n\", prog, msg);\n-    exit(1);\n+  fprintf(stderr, \"%s: %s\\n\", prog, msg);\n+  exit(1);\n }\n \n \n-/* ====================================================================== */\n+/* ============================================================ */\n \n-int _CRT_glob = 0;\t/* disable globbing of the arguments */\n+#if defined(WIN32) && defined(__GNUC__)\n+int _CRT_glob = 0;      /* disable argument globbing in MinGW */\n+#endif\n \n int main(int argc,char **argv)\n {\n-    int \taction = TGZ_EXTRACT;\n-    int \targ = 1;\n-    char\t*TGZfile;\n-    gzFile\t*f;\n-    \n+    int         action = TGZ_EXTRACT;\n+    int         arg = 1;\n+    char        *TGZfile;\n+    gzFile      *f;\n \n     prog = strrchr(argv[0],'\\\\');\n     if (prog == NULL)\n       {\n-\tprog = strrchr(argv[0],'/');\n-\tif (prog == NULL)\n-\t  {\n-\t    prog = strrchr(argv[0],':');\n-\t    if (prog == NULL)\n-\t      prog = argv[0];\n-\t    else\n-\t      prog++;\n-\t  }\n-\telse\n-\t  prog++;\n+        prog = strrchr(argv[0],'/');\n+        if (prog == NULL)\n+          {\n+            prog = strrchr(argv[0],':');\n+            if (prog == NULL)\n+              prog = argv[0];\n+            else\n+              prog++;\n+          }\n+        else\n+          prog++;\n       }\n     else\n       prog++;\n-    \n+\n     if (argc == 1)\n       help(0);\n \n     if (strcmp(argv[arg],\"-l\") == 0)\n       {\n-\taction = TGZ_LIST;\n-\tif (argc == ++arg)\n-\t  help(0);\n+        action = TGZ_LIST;\n+        if (argc == ++arg)\n+          help(0);\n       }\n     else if (strcmp(argv[arg],\"-h\") == 0)\n       {\n-\thelp(0);\n+        help(0);\n       }\n \n     if ((TGZfile = TGZfname(argv[arg])) == NULL)\n-      TGZnotfound(argv[arg]);            \n+      TGZnotfound(argv[arg]);\n \n     ++arg;\n     if ((action == TGZ_LIST) && (arg != argc))\n@@ -502,20 +551,18 @@ int main(int argc,char **argv)\n       {\n       case TGZ_LIST:\n       case TGZ_EXTRACT:\n-\tf = gzopen(TGZfile,\"rb\");\n-\tif (f == NULL)\n-\t  {\n-\t    fprintf(stderr,\"%s: Couldn't gzopen %s\\n\",\n-\t\t    prog,\n-\t\t    TGZfile);\n-\t    return 1;\n-\t  }\n-\texit(tar(f, action, arg, argc, argv));\n+        f = gzopen(TGZfile,\"rb\");\n+        if (f == NULL)\n+          {\n+            fprintf(stderr,\"%s: Couldn't gzopen %s\\n\",prog,TGZfile);\n+            return 1;\n+          }\n+        exit(tar(f, action, arg, argc, argv));\n       break;\n-\t\n+\n       default:\n-\terror(\"Unknown option!\");\n-\texit(1);\n+        error(\"Unknown option\");\n+        exit(1);\n       }\n \n     return 0;"}, {"sha": "57efe58124eed661c2ff5827258772ab97a44bdc", "filename": "zlib/contrib/visual-basic.txt", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fvisual-basic.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcontrib%2Fvisual-basic.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcontrib%2Fvisual-basic.txt?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -67,3 +67,94 @@ Declare Function gzclose Lib \"ZLIB32.DLL\"\n -Jon Caruana\n jon-net@usa.net\n Microsoft Sitebuilder Network Level 1 Member - HTML Writer's Guild Member\n+\n+\n+Here is another example from Michael <michael_borgsys@hotmail.com> that he\n+says conforms to the VB guidelines, and that solves the problem of not\n+knowing the uncompressed size by storing it at the end of the file:\n+\n+'Calling the functions:\n+'bracket meaning: <parameter> [optional] {Range of possible values}\n+'Call subCompressFile(<path with filename to compress> [, <path with\n+filename to write to>, [level of compression {1..9}]])\n+'Call subUncompressFile(<path with filename to compress>)\n+\n+Option Explicit\n+Private lngpvtPcnSml As Long 'Stores value for 'lngPercentSmaller'\n+Private Const SUCCESS As Long = 0\n+Private Const strFilExt As String = \".cpr\"\n+Private Declare Function lngfncCpr Lib \"zlib.dll\" Alias \"compress2\" (ByRef\n+dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long,\n+ByVal level As Integer) As Long\n+Private Declare Function lngfncUcp Lib \"zlib.dll\" Alias \"uncompress\" (ByRef\n+dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long)\n+As Long\n+\n+Public Sub subCompressFile(ByVal strargOriFilPth As String, Optional ByVal\n+strargCprFilPth As String, Optional ByVal intLvl As Integer = 9)\n+    Dim strCprPth As String\n+    Dim lngOriSiz As Long\n+    Dim lngCprSiz As Long\n+    Dim bytaryOri() As Byte\n+    Dim bytaryCpr() As Byte\n+    lngOriSiz = FileLen(strargOriFilPth)\n+    ReDim bytaryOri(lngOriSiz - 1)\n+    Open strargOriFilPth For Binary Access Read As #1\n+        Get #1, , bytaryOri()\n+    Close #1\n+    strCprPth = IIf(strargCprFilPth = \"\", strargOriFilPth, strargCprFilPth)\n+'Select file path and name\n+    strCprPth = strCprPth & IIf(Right(strCprPth, Len(strFilExt)) =\n+strFilExt, \"\", strFilExt) 'Add file extension if not exists\n+    lngCprSiz = (lngOriSiz * 1.01) + 12 'Compression needs temporary a bit\n+more space then original file size\n+    ReDim bytaryCpr(lngCprSiz - 1)\n+    If lngfncCpr(bytaryCpr(0), lngCprSiz, bytaryOri(0), lngOriSiz, intLvl) =\n+SUCCESS Then\n+        lngpvtPcnSml = (1# - (lngCprSiz / lngOriSiz)) * 100\n+        ReDim Preserve bytaryCpr(lngCprSiz - 1)\n+        Open strCprPth For Binary Access Write As #1\n+            Put #1, , bytaryCpr()\n+            Put #1, , lngOriSiz 'Add the the original size value to the end\n+(last 4 bytes)\n+        Close #1\n+    Else\n+        MsgBox \"Compression error\"\n+    End If\n+    Erase bytaryCpr\n+    Erase bytaryOri\n+End Sub\n+\n+Public Sub subUncompressFile(ByVal strargFilPth As String)\n+    Dim bytaryCpr() As Byte\n+    Dim bytaryOri() As Byte\n+    Dim lngOriSiz As Long\n+    Dim lngCprSiz As Long\n+    Dim strOriPth As String\n+    lngCprSiz = FileLen(strargFilPth)\n+    ReDim bytaryCpr(lngCprSiz - 1)\n+    Open strargFilPth For Binary Access Read As #1\n+        Get #1, , bytaryCpr()\n+    Close #1\n+    'Read the original file size value:\n+    lngOriSiz = bytaryCpr(lngCprSiz - 1) * (2 ^ 24) _\n+              + bytaryCpr(lngCprSiz - 2) * (2 ^ 16) _\n+              + bytaryCpr(lngCprSiz - 3) * (2 ^ 8) _\n+              + bytaryCpr(lngCprSiz - 4)\n+    ReDim Preserve bytaryCpr(lngCprSiz - 5) 'Cut of the original size value\n+    ReDim bytaryOri(lngOriSiz - 1)\n+    If lngfncUcp(bytaryOri(0), lngOriSiz, bytaryCpr(0), lngCprSiz) = SUCCESS\n+Then\n+        strOriPth = Left(strargFilPth, Len(strargFilPth) - Len(strFilExt))\n+        Open strOriPth For Binary Access Write As #1\n+            Put #1, , bytaryOri()\n+        Close #1\n+    Else\n+        MsgBox \"Uncompression error\"\n+    End If\n+    Erase bytaryCpr\n+    Erase bytaryOri\n+End Sub\n+Public Property Get lngPercentSmaller() As Long\n+    lngPercentSmaller = lngpvtPcnSml\n+End Property"}, {"sha": "be8ccd6f475c810ba8a8e560ee2b37a6fd04e090", "filename": "zlib/crc32.c", "status": "modified", "additions": 253, "deletions": 104, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcrc32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fcrc32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fcrc32.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,22 +1,72 @@\n /* crc32.c -- compute the CRC-32 of a data stream\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ *\n+ * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster\n+ * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing\n+ * tables for updating the shift register in one step with three exclusive-ors\n+ * instead of four steps with four exclusive-ors.  This results about a factor\n+ * of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.\n  */\n \n /* @(#) $Id: crc32.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */\n \n-#include \"zlib.h\"\n+#ifdef MAKECRCH\n+#  include <stdio.h>\n+#  ifndef DYNAMIC_CRC_TABLE\n+#    define DYNAMIC_CRC_TABLE\n+#  endif /* !DYNAMIC_CRC_TABLE */\n+#endif /* MAKECRCH */\n+\n+#include \"zutil.h\"      /* for STDC and FAR definitions */\n \n #define local static\n \n+/* Find a four-byte integer type for crc32_little() and crc32_big(). */\n+#ifndef NOBYFOUR\n+#  ifdef STDC           /* need ANSI C limits.h to determine sizes */\n+#    include <limits.h>\n+#    define BYFOUR\n+#    if (UINT_MAX == 0xffffffffUL)\n+       typedef unsigned int u4;\n+#    else\n+#      if (ULONG_MAX == 0xffffffffUL)\n+         typedef unsigned long u4;\n+#      else\n+#        if (USHRT_MAX == 0xffffffffUL)\n+           typedef unsigned short u4;\n+#        else\n+#          undef BYFOUR     /* can't find a four-byte integer type! */\n+#        endif\n+#      endif\n+#    endif\n+#  endif /* STDC */\n+#endif /* !NOBYFOUR */\n+\n+/* Definitions for doing the crc four data bytes at a time. */\n+#ifdef BYFOUR\n+#  define REV(w) (((w)>>24)+(((w)>>8)&0xff00)+ \\\n+                (((w)&0xff00)<<8)+(((w)&0xff)<<24))\n+   local unsigned long crc32_little OF((unsigned long,\n+                        const unsigned char FAR *, unsigned));\n+   local unsigned long crc32_big OF((unsigned long,\n+                        const unsigned char FAR *, unsigned));\n+#  define TBLS 8\n+#else\n+#  define TBLS 1\n+#endif /* BYFOUR */\n+\n #ifdef DYNAMIC_CRC_TABLE\n \n local int crc_table_empty = 1;\n-local uLongf crc_table[256];\n+local unsigned long FAR crc_table[TBLS][256];\n local void make_crc_table OF((void));\n+#ifdef MAKECRCH\n+   local void write_table OF((FILE *, const unsigned long FAR *));\n+#endif /* MAKECRCH */\n \n /*\n-  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:\n+  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:\n   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.\n \n   Polynomials over GF(2) are represented in binary, one bit per coefficient,\n@@ -35,128 +85,227 @@ local void make_crc_table OF((void));\n   out is a one).  We start with the highest power (least significant bit) of\n   q and repeat for all eight bits of q.\n \n-  The table is simply the CRC of all possible eight bit values.  This is all\n-  the information needed to generate CRC's on data a byte at a time for all\n-  combinations of CRC register values and incoming bytes.\n+  The first table is simply the CRC of all possible eight bit values.  This is\n+  all the information needed to generate CRCs on data a byte at a time for all\n+  combinations of CRC register values and incoming bytes.  The remaining tables\n+  allow for word-at-a-time CRC calculation for both big-endian and little-\n+  endian machines, where a word is four bytes.\n */\n local void make_crc_table()\n {\n-  uLong c;\n-  int n, k;\n-  uLong poly;            /* polynomial exclusive-or pattern */\n-  /* terms of polynomial defining this crc (except x^32): */\n-  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n-\n-  /* make exclusive-or pattern from polynomial (0xedb88320L) */\n-  poly = 0L;\n-  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)\n-    poly |= 1L << (31 - p[n]);\n- \n-  for (n = 0; n < 256; n++)\n-  {\n-    c = (uLong)n;\n-    for (k = 0; k < 8; k++)\n-      c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n-    crc_table[n] = c;\n-  }\n+    unsigned long c;\n+    int n, k;\n+    unsigned long poly;            /* polynomial exclusive-or pattern */\n+    /* terms of polynomial defining this crc (except x^32): */\n+    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n+\n+    /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n+    poly = 0UL;\n+    for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)\n+        poly |= 1UL << (31 - p[n]);\n+\n+    /* generate a crc for every 8-bit value */\n+    for (n = 0; n < 256; n++) {\n+        c = (unsigned long)n;\n+        for (k = 0; k < 8; k++)\n+            c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n+        crc_table[0][n] = c;\n+    }\n+\n+#ifdef BYFOUR\n+    /* generate crc for each value followed by one, two, and three zeros, and\n+       then the byte reversal of those as well as the first table */\n+    for (n = 0; n < 256; n++) {\n+        c = crc_table[0][n];\n+        crc_table[4][n] = REV(c);\n+        for (k = 1; k < 4; k++) {\n+            c = crc_table[0][c & 0xff] ^ (c >> 8);\n+            crc_table[k][n] = c;\n+            crc_table[k + 4][n] = REV(c);\n+        }\n+    }\n+#endif /* BYFOUR */\n+\n   crc_table_empty = 0;\n+\n+#ifdef MAKECRCH\n+    /* write out CRC tables to crc32.h */\n+    {\n+        FILE *out;\n+\n+        out = fopen(\"crc32.h\", \"w\");\n+        if (out == NULL) return;\n+        fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n+        fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n+        fprintf(out, \"local const unsigned long FAR \");\n+        fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n+        write_table(out, crc_table[0]);\n+#  ifdef BYFOUR\n+        fprintf(out, \"#ifdef BYFOUR\\n\");\n+        for (k = 1; k < 8; k++) {\n+            fprintf(out, \"  },\\n  {\\n\");\n+            write_table(out, crc_table[k]);\n+        }\n+        fprintf(out, \"#endif\\n\");\n+#  endif /* BYFOUR */\n+        fprintf(out, \"  }\\n};\\n\");\n+        fclose(out);\n+    }\n+#endif /* MAKECRCH */\n }\n-#else\n+\n+#ifdef MAKECRCH\n+local void write_table(out, table)\n+    FILE *out;\n+    const unsigned long FAR *table;\n+{\n+    int n;\n+\n+    for (n = 0; n < 256; n++)\n+        fprintf(out, \"%s0x%08lxUL%s\", n % 5 ? \"\" : \"    \", table[n],\n+                n == 255 ? \"\\n\" : (n % 5 == 4 ? \",\\n\" : \", \"));\n+}\n+#endif /* MAKECRCH */\n+\n+#else /* !DYNAMIC_CRC_TABLE */\n /* ========================================================================\n- * Table of CRC-32's of all single-byte values (made by make_crc_table)\n+ * Tables of CRC-32s of all single-byte values, made by make_crc_table().\n  */\n-local const uLongf crc_table[256] = {\n-  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,\n-  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,\n-  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,\n-  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,\n-  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,\n-  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,\n-  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,\n-  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,\n-  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,\n-  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,\n-  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,\n-  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,\n-  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,\n-  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,\n-  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,\n-  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,\n-  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,\n-  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,\n-  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,\n-  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,\n-  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,\n-  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,\n-  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,\n-  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,\n-  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,\n-  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,\n-  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,\n-  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,\n-  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,\n-  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,\n-  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,\n-  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,\n-  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,\n-  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,\n-  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,\n-  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,\n-  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,\n-  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,\n-  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,\n-  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,\n-  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,\n-  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,\n-  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,\n-  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,\n-  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,\n-  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,\n-  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,\n-  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,\n-  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,\n-  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,\n-  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,\n-  0x2d02ef8dL\n-};\n-#endif\n+#include \"crc32.h\"\n+#endif /* DYNAMIC_CRC_TABLE */\n \n /* =========================================================================\n  * This function can be used by asm versions of crc32()\n  */\n-const uLongf * ZEXPORT get_crc_table()\n+const unsigned long FAR * ZEXPORT get_crc_table()\n {\n #ifdef DYNAMIC_CRC_TABLE\n   if (crc_table_empty) make_crc_table();\n-#endif\n-  return (const uLongf *)crc_table;\n+#endif /* DYNAMIC_CRC_TABLE */\n+  return (const unsigned long FAR *)crc_table;\n }\n \n /* ========================================================================= */\n-#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);\n-#define DO2(buf)  DO1(buf); DO1(buf);\n-#define DO4(buf)  DO2(buf); DO2(buf);\n-#define DO8(buf)  DO4(buf); DO4(buf);\n+#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)\n+#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1\n \n /* ========================================================================= */\n-uLong ZEXPORT crc32(crc, buf, len)\n-    uLong crc;\n-    const Bytef *buf;\n-    uInt len;\n+unsigned long ZEXPORT crc32(crc, buf, len)\n+    unsigned long crc;\n+    const unsigned char FAR *buf;\n+    unsigned len;\n {\n-    if (buf == Z_NULL) return 0L;\n+    if (buf == Z_NULL) return 0UL;\n+\n #ifdef DYNAMIC_CRC_TABLE\n     if (crc_table_empty)\n-      make_crc_table();\n-#endif\n-    crc = crc ^ 0xffffffffL;\n-    while (len >= 8)\n-    {\n-      DO8(buf);\n-      len -= 8;\n+        make_crc_table();\n+#endif /* DYNAMIC_CRC_TABLE */\n+\n+#ifdef BYFOUR\n+    if (sizeof(void *) == sizeof(ptrdiff_t)) {\n+        u4 endian;\n+\n+        endian = 1;\n+        if (*((unsigned char *)(&endian)))\n+            return crc32_little(crc, buf, len);\n+        else\n+            return crc32_big(crc, buf, len);\n+    }\n+#endif /* BYFOUR */\n+    crc = crc ^ 0xffffffffUL;\n+    while (len >= 8) {\n+        DO8;\n+        len -= 8;\n     }\n     if (len) do {\n-      DO1(buf);\n+        DO1;\n     } while (--len);\n-    return crc ^ 0xffffffffL;\n+    return crc ^ 0xffffffffUL;\n }\n+\n+#ifdef BYFOUR\n+\n+/* ========================================================================= */\n+#define DOLIT4 c ^= *buf4++; \\\n+        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \\\n+            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]\n+#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4\n+\n+/* ========================================================================= */\n+local unsigned long crc32_little(crc, buf, len)\n+    unsigned long crc;\n+    const unsigned char FAR *buf;\n+    unsigned len;\n+{\n+    register u4 c;\n+    register const u4 FAR *buf4;\n+\n+    c = (u4)crc;\n+    c = ~c;\n+    while (len && ((ptrdiff_t)buf & 3)) {\n+        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);\n+        len--;\n+    }\n+\n+    buf4 = (const u4 FAR *)buf;\n+    while (len >= 32) {\n+        DOLIT32;\n+        len -= 32;\n+    }\n+    while (len >= 4) {\n+        DOLIT4;\n+        len -= 4;\n+    }\n+    buf = (const unsigned char FAR *)buf4;\n+\n+    if (len) do {\n+        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);\n+    } while (--len);\n+    c = ~c;\n+    return (unsigned long)c;\n+}\n+\n+/* ========================================================================= */\n+#define DOBIG4 c ^= *++buf4; \\\n+        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \\\n+            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]\n+#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4\n+\n+/* ========================================================================= */\n+local unsigned long crc32_big(crc, buf, len)\n+    unsigned long crc;\n+    const unsigned char FAR *buf;\n+    unsigned len;\n+{\n+    register u4 c;\n+    register const u4 FAR *buf4;\n+\n+    c = REV((u4)crc);\n+    c = ~c;\n+    while (len && ((ptrdiff_t)buf & 3)) {\n+        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n+        len--;\n+    }\n+\n+    buf4 = (const u4 FAR *)buf;\n+    buf4--;\n+    while (len >= 32) {\n+        DOBIG32;\n+        len -= 32;\n+    }\n+    while (len >= 4) {\n+        DOBIG4;\n+        len -= 4;\n+    }\n+    buf4++;\n+    buf = (const unsigned char FAR *)buf4;\n+\n+    if (len) do {\n+        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n+    } while (--len);\n+    c = ~c;\n+    return (unsigned long)(REV(c));\n+}\n+\n+#endif /* BYFOUR */"}, {"sha": "12a90d6e6fe20e9757f664b89b53e7bb228d7ae3", "filename": "zlib/deflate.c", "status": "modified", "additions": 327, "deletions": 175, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fdeflate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fdeflate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdeflate.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,6 +1,6 @@\n /* deflate.c -- compress data using the deflation algorithm\n- * Copyright (C) 1995-2002 Jean-loup Gailly.\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /*\n@@ -37,7 +37,7 @@\n  *  REFERENCES\n  *\n  *      Deutsch, L.P.,\"DEFLATE Compressed Data Format Specification\".\n- *      Available in ftp://ds.internic.net/rfc/rfc1951.txt\n+ *      Available in http://www.ietf.org/rfc/rfc1951.txt\n  *\n  *      A description of the Rabin and Karp algorithm is given in the book\n  *         \"Algorithms\" by R. Sedgewick, Addison-Wesley, p252.\n@@ -52,7 +52,7 @@\n #include \"deflate.h\"\n \n const char deflate_copyright[] =\n-   \" deflate 1.1.4 Copyright 1995-2002 Jean-loup Gailly \";\n+   \" deflate 1.2.1 Copyright 1995-2003 Jean-loup Gailly \";\n /*\n   If you use the zlib library in a product, an acknowledgment is welcome\n   in the documentation of your product. If for some reason you cannot\n@@ -76,17 +76,22 @@ typedef block_state (*compress_func) OF((deflate_state *s, int flush));\n local void fill_window    OF((deflate_state *s));\n local block_state deflate_stored OF((deflate_state *s, int flush));\n local block_state deflate_fast   OF((deflate_state *s, int flush));\n+#ifndef FASTEST\n local block_state deflate_slow   OF((deflate_state *s, int flush));\n+#endif\n local void lm_init        OF((deflate_state *s));\n local void putShortMSB    OF((deflate_state *s, uInt b));\n local void flush_pending  OF((z_streamp strm));\n local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));\n+#ifndef FASTEST\n #ifdef ASMV\n       void match_init OF((void)); /* asm code initialization */\n       uInt longest_match  OF((deflate_state *s, IPos cur_match));\n #else\n local uInt longest_match  OF((deflate_state *s, IPos cur_match));\n #endif\n+#endif\n+local uInt longest_match_fast OF((deflate_state *s, IPos cur_match));\n \n #ifdef DEBUG\n local  void check_match OF((deflate_state *s, IPos start, IPos match,\n@@ -123,10 +128,16 @@ typedef struct config_s {\n    compress_func func;\n } config;\n \n+#ifdef FASTEST\n+local const config configuration_table[2] = {\n+/*      good lazy nice chain */\n+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */\n+/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */\n+#else\n local const config configuration_table[10] = {\n /*      good lazy nice chain */\n /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */\n-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */\n+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */\n /* 2 */ {4,    5, 16,    8, deflate_fast},\n /* 3 */ {4,    6, 32,   32, deflate_fast},\n \n@@ -135,7 +146,8 @@ local const config configuration_table[10] = {\n /* 6 */ {8,   16, 128, 128, deflate_slow},\n /* 7 */ {8,   32, 128, 256, deflate_slow},\n /* 8 */ {32, 128, 258, 1024, deflate_slow},\n-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */\n+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */\n+#endif\n \n /* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4\n  * For deflate_fast() (levels <= 3) good is ignored and lazy has a different\n@@ -145,7 +157,9 @@ local const config configuration_table[10] = {\n #define EQUAL 0\n /* result of memcmp for equal strings */\n \n+#ifndef NO_DUMMY_DECL\n struct static_tree_desc_s {int dummy;}; /* for buggy compilers */\n+#endif\n \n /* ===========================================================================\n  * Update a hash value with the given input byte\n@@ -174,7 +188,7 @@ struct static_tree_desc_s {int dummy;}; /* for buggy compilers */\n #else\n #define INSERT_STRING(s, str, match_head) \\\n    (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \\\n-    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \\\n+    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \\\n     s->head[s->ins_h] = (Pos)(str))\n #endif\n \n@@ -194,13 +208,13 @@ int ZEXPORT deflateInit_(strm, level, version, stream_size)\n     int stream_size;\n {\n     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,\n-\t\t\t Z_DEFAULT_STRATEGY, version, stream_size);\n+                         Z_DEFAULT_STRATEGY, version, stream_size);\n     /* To do: ignore strm->next_in if we use it as window */\n }\n \n /* ========================================================================= */\n int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n-\t\t  version, stream_size)\n+                  version, stream_size)\n     z_streamp strm;\n     int  level;\n     int  method;\n@@ -211,8 +225,8 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n     int stream_size;\n {\n     deflate_state *s;\n-    int noheader = 0;\n-    static const char* my_version = ZLIB_VERSION;\n+    int wrap = 1;\n+    static const char my_version[] = ZLIB_VERSION;\n \n     ushf *overlay;\n     /* We overlay pending_buf and d_buf+l_buf. This works since the average\n@@ -221,37 +235,45 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n \n     if (version == Z_NULL || version[0] != my_version[0] ||\n         stream_size != sizeof(z_stream)) {\n-\treturn Z_VERSION_ERROR;\n+        return Z_VERSION_ERROR;\n     }\n     if (strm == Z_NULL) return Z_STREAM_ERROR;\n \n     strm->msg = Z_NULL;\n-    if (strm->zalloc == Z_NULL) {\n-\tstrm->zalloc = zcalloc;\n-\tstrm->opaque = (voidpf)0;\n+    if (strm->zalloc == (alloc_func)0) {\n+        strm->zalloc = zcalloc;\n+        strm->opaque = (voidpf)0;\n     }\n-    if (strm->zfree == Z_NULL) strm->zfree = zcfree;\n+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n \n-    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n #ifdef FASTEST\n-    level = 1;\n+    if (level != 0) level = 1;\n+#else\n+    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n #endif\n \n-    if (windowBits < 0) { /* undocumented feature: suppress zlib header */\n-        noheader = 1;\n+    if (windowBits < 0) { /* suppress zlib wrapper */\n+        wrap = 0;\n         windowBits = -windowBits;\n     }\n+#ifdef GZIP\n+    else if (windowBits > 15) {\n+        wrap = 2;       /* write gzip wrapper instead */\n+        windowBits -= 16;\n+    }\n+#endif\n     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\n-        windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||\n-\tstrategy < 0 || strategy > Z_HUFFMAN_ONLY) {\n+        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n+        strategy < 0 || strategy > Z_RLE) {\n         return Z_STREAM_ERROR;\n     }\n+    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */\n     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));\n     if (s == Z_NULL) return Z_MEM_ERROR;\n     strm->state = (struct internal_state FAR *)s;\n     s->strm = strm;\n \n-    s->noheader = noheader;\n+    s->wrap = wrap;\n     s->w_bits = windowBits;\n     s->w_size = 1 << s->w_bits;\n     s->w_mask = s->w_size - 1;\n@@ -273,6 +295,7 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n \n     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||\n         s->pending_buf == Z_NULL) {\n+        s->status = FINISH_STATE;\n         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);\n         deflateEnd (strm);\n         return Z_MEM_ERROR;\n@@ -299,16 +322,19 @@ int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)\n     IPos hash_head = 0;\n \n     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||\n-        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;\n+        strm->state->wrap == 2 ||\n+        (strm->state->wrap == 1 && strm->state->status != INIT_STATE))\n+        return Z_STREAM_ERROR;\n \n     s = strm->state;\n-    strm->adler = adler32(strm->adler, dictionary, dictLength);\n+    if (s->wrap)\n+        strm->adler = adler32(strm->adler, dictionary, dictLength);\n \n     if (length < MIN_MATCH) return Z_OK;\n     if (length > MAX_DIST(s)) {\n-\tlength = MAX_DIST(s);\n+        length = MAX_DIST(s);\n #ifndef USE_DICT_HEAD\n-\tdictionary += dictLength - length; /* use the tail of the dictionary */\n+        dictionary += dictLength - length; /* use the tail of the dictionary */\n #endif\n     }\n     zmemcpy(s->window, dictionary, length);\n@@ -322,7 +348,7 @@ int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)\n     s->ins_h = s->window[0];\n     UPDATE_HASH(s, s->ins_h, s->window[1]);\n     for (n = 0; n <= length - MIN_MATCH; n++) {\n-\tINSERT_STRING(s, n, hash_head);\n+        INSERT_STRING(s, n, hash_head);\n     }\n     if (hash_head) hash_head = 0;  /* to make compiler happy */\n     return Z_OK;\n@@ -333,9 +359,11 @@ int ZEXPORT deflateReset (strm)\n     z_streamp strm;\n {\n     deflate_state *s;\n-    \n+\n     if (strm == Z_NULL || strm->state == Z_NULL ||\n-        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;\n+        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {\n+        return Z_STREAM_ERROR;\n+    }\n \n     strm->total_in = strm->total_out = 0;\n     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */\n@@ -345,11 +373,15 @@ int ZEXPORT deflateReset (strm)\n     s->pending = 0;\n     s->pending_out = s->pending_buf;\n \n-    if (s->noheader < 0) {\n-        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */\n+    if (s->wrap < 0) {\n+        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */\n     }\n-    s->status = s->noheader ? BUSY_STATE : INIT_STATE;\n-    strm->adler = 1;\n+    s->status = s->wrap ? INIT_STATE : BUSY_STATE;\n+    strm->adler =\n+#ifdef GZIP\n+        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :\n+#endif\n+        adler32(0L, Z_NULL, 0);\n     s->last_flush = Z_NO_FLUSH;\n \n     _tr_init(s);\n@@ -358,6 +390,18 @@ int ZEXPORT deflateReset (strm)\n     return Z_OK;\n }\n \n+/* ========================================================================= */\n+int ZEXPORT deflatePrime (strm, bits, value)\n+    z_streamp strm;\n+    int bits;\n+    int value;\n+{\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    strm->state->bi_valid = bits;\n+    strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));\n+    return Z_OK;\n+}\n+\n /* ========================================================================= */\n int ZEXPORT deflateParams(strm, level, strategy)\n     z_streamp strm;\n@@ -371,29 +415,72 @@ int ZEXPORT deflateParams(strm, level, strategy)\n     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n     s = strm->state;\n \n-    if (level == Z_DEFAULT_COMPRESSION) {\n-\tlevel = 6;\n-    }\n-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {\n-\treturn Z_STREAM_ERROR;\n+#ifdef FASTEST\n+    if (level != 0) level = 1;\n+#else\n+    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n+#endif\n+    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_RLE) {\n+        return Z_STREAM_ERROR;\n     }\n     func = configuration_table[s->level].func;\n \n     if (func != configuration_table[level].func && strm->total_in != 0) {\n-\t/* Flush the last buffer: */\n-\terr = deflate(strm, Z_PARTIAL_FLUSH);\n+        /* Flush the last buffer: */\n+        err = deflate(strm, Z_PARTIAL_FLUSH);\n     }\n     if (s->level != level) {\n-\ts->level = level;\n-\ts->max_lazy_match   = configuration_table[level].max_lazy;\n-\ts->good_match       = configuration_table[level].good_length;\n-\ts->nice_match       = configuration_table[level].nice_length;\n-\ts->max_chain_length = configuration_table[level].max_chain;\n+        s->level = level;\n+        s->max_lazy_match   = configuration_table[level].max_lazy;\n+        s->good_match       = configuration_table[level].good_length;\n+        s->nice_match       = configuration_table[level].nice_length;\n+        s->max_chain_length = configuration_table[level].max_chain;\n     }\n     s->strategy = strategy;\n     return err;\n }\n \n+/* =========================================================================\n+ * For the default windowBits of 15 and memLevel of 8, this function returns\n+ * a close to exact, as well as small, upper bound on the compressed size.\n+ * They are coded as constants here for a reason--if the #define's are\n+ * changed, then this function needs to be changed as well.  The return\n+ * value for 15 and 8 only works for those exact settings.\n+ *\n+ * For any setting other than those defaults for windowBits and memLevel,\n+ * the value returned is a conservative worst case for the maximum expansion\n+ * resulting from using fixed blocks instead of stored blocks, which deflate\n+ * can emit on compressed data for some combinations of the parameters.\n+ *\n+ * This function could be more sophisticated to provide closer upper bounds\n+ * for every combination of windowBits and memLevel, as well as wrap.\n+ * But even the conservative upper bound of about 14% expansion does not\n+ * seem onerous for output buffer allocation.\n+ */\n+uLong ZEXPORT deflateBound(strm, sourceLen)\n+    z_streamp strm;\n+    uLong sourceLen;\n+{\n+    deflate_state *s;\n+    uLong destLen;\n+\n+    /* conservative upper bound */\n+    destLen = sourceLen +\n+              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 11;\n+\n+    /* if can't get parameters, return conservative bound */\n+    if (strm == Z_NULL || strm->state == Z_NULL)\n+        return destLen;\n+\n+    /* if not default parameters, return conservative bound */\n+    s = strm->state;\n+    if (s->w_bits != 15 || s->hash_bits != 8 + 7)\n+        return destLen;\n+\n+    /* default settings: return tight bound for that case */\n+    return compressBound(sourceLen);\n+}\n+\n /* =========================================================================\n  * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n  * IN assertion: the stream state is correct and there is enough room in\n@@ -405,7 +492,7 @@ local void putShortMSB (s, b)\n {\n     put_byte(s, (Byte)(b >> 8));\n     put_byte(s, (Byte)(b & 0xff));\n-}   \n+}\n \n /* =========================================================================\n  * Flush as much pending output as possible. All deflate() output goes\n@@ -441,14 +528,14 @@ int ZEXPORT deflate (strm, flush)\n     deflate_state *s;\n \n     if (strm == Z_NULL || strm->state == Z_NULL ||\n-\tflush > Z_FINISH || flush < 0) {\n+        flush > Z_FINISH || flush < 0) {\n         return Z_STREAM_ERROR;\n     }\n     s = strm->state;\n \n     if (strm->next_out == Z_NULL ||\n         (strm->next_in == Z_NULL && strm->avail_in != 0) ||\n-\t(s->status == FINISH_STATE && flush != Z_FINISH)) {\n+        (s->status == FINISH_STATE && flush != Z_FINISH)) {\n         ERR_RETURN(strm, Z_STREAM_ERROR);\n     }\n     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);\n@@ -457,48 +544,75 @@ int ZEXPORT deflate (strm, flush)\n     old_flush = s->last_flush;\n     s->last_flush = flush;\n \n-    /* Write the zlib header */\n+    /* Write the header */\n     if (s->status == INIT_STATE) {\n-\n-        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\n-        uInt level_flags = (s->level-1) >> 1;\n-\n-        if (level_flags > 3) level_flags = 3;\n-        header |= (level_flags << 6);\n-\tif (s->strstart != 0) header |= PRESET_DICT;\n-        header += 31 - (header % 31);\n-\n-        s->status = BUSY_STATE;\n-        putShortMSB(s, header);\n-\n-\t/* Save the adler32 of the preset dictionary: */\n-\tif (s->strstart != 0) {\n-\t    putShortMSB(s, (uInt)(strm->adler >> 16));\n-\t    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n-\t}\n-\tstrm->adler = 1L;\n+#ifdef GZIP\n+        if (s->wrap == 2) {\n+            put_byte(s, 31);\n+            put_byte(s, 139);\n+            put_byte(s, 8);\n+            put_byte(s, 0);\n+            put_byte(s, 0);\n+            put_byte(s, 0);\n+            put_byte(s, 0);\n+            put_byte(s, 0);\n+            put_byte(s, s->level == 9 ? 2 :\n+                        (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?\n+                         4 : 0));\n+            put_byte(s, 255);\n+            s->status = BUSY_STATE;\n+            strm->adler = crc32(0L, Z_NULL, 0);\n+        }\n+        else\n+#endif\n+        {\n+            uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\n+            uInt level_flags;\n+\n+            if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)\n+                level_flags = 0;\n+            else if (s->level < 6)\n+                level_flags = 1;\n+            else if (s->level == 6)\n+                level_flags = 2;\n+            else\n+                level_flags = 3;\n+            header |= (level_flags << 6);\n+            if (s->strstart != 0) header |= PRESET_DICT;\n+            header += 31 - (header % 31);\n+\n+            s->status = BUSY_STATE;\n+            putShortMSB(s, header);\n+\n+            /* Save the adler32 of the preset dictionary: */\n+            if (s->strstart != 0) {\n+                putShortMSB(s, (uInt)(strm->adler >> 16));\n+                putShortMSB(s, (uInt)(strm->adler & 0xffff));\n+            }\n+            strm->adler = adler32(0L, Z_NULL, 0);\n+        }\n     }\n \n     /* Flush as much pending output as possible */\n     if (s->pending != 0) {\n         flush_pending(strm);\n         if (strm->avail_out == 0) {\n-\t    /* Since avail_out is 0, deflate will be called again with\n-\t     * more output space, but possibly with both pending and\n-\t     * avail_in equal to zero. There won't be anything to do,\n-\t     * but this is not an error situation so make sure we\n-\t     * return OK instead of BUF_ERROR at next call of deflate:\n+            /* Since avail_out is 0, deflate will be called again with\n+             * more output space, but possibly with both pending and\n+             * avail_in equal to zero. There won't be anything to do,\n+             * but this is not an error situation so make sure we\n+             * return OK instead of BUF_ERROR at next call of deflate:\n              */\n-\t    s->last_flush = -1;\n-\t    return Z_OK;\n-\t}\n+            s->last_flush = -1;\n+            return Z_OK;\n+        }\n \n     /* Make sure there is something to do and avoid duplicate consecutive\n      * flushes. For repeated and useless calls with Z_FINISH, we keep\n-     * returning Z_STREAM_END instead of Z_BUFF_ERROR.\n+     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n      */\n     } else if (strm->avail_in == 0 && flush <= old_flush &&\n-\t       flush != Z_FINISH) {\n+               flush != Z_FINISH) {\n         ERR_RETURN(strm, Z_BUF_ERROR);\n     }\n \n@@ -513,24 +627,24 @@ int ZEXPORT deflate (strm, flush)\n         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {\n         block_state bstate;\n \n-\tbstate = (*(configuration_table[s->level].func))(s, flush);\n+        bstate = (*(configuration_table[s->level].func))(s, flush);\n \n         if (bstate == finish_started || bstate == finish_done) {\n             s->status = FINISH_STATE;\n         }\n         if (bstate == need_more || bstate == finish_started) {\n-\t    if (strm->avail_out == 0) {\n-\t        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */\n-\t    }\n-\t    return Z_OK;\n-\t    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n-\t     * of deflate should use the same flush parameter to make sure\n-\t     * that the flush is complete. So we don't have to output an\n-\t     * empty block here, this will be done at next call. This also\n-\t     * ensures that for a very small output buffer, we emit at most\n-\t     * one empty block.\n-\t     */\n-\t}\n+            if (strm->avail_out == 0) {\n+                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */\n+            }\n+            return Z_OK;\n+            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n+             * of deflate should use the same flush parameter to make sure\n+             * that the flush is complete. So we don't have to output an\n+             * empty block here, this will be done at next call. This also\n+             * ensures that for a very small output buffer, we emit at most\n+             * one empty block.\n+             */\n+        }\n         if (bstate == block_done) {\n             if (flush == Z_PARTIAL_FLUSH) {\n                 _tr_align(s);\n@@ -544,25 +658,40 @@ int ZEXPORT deflate (strm, flush)\n                 }\n             }\n             flush_pending(strm);\n-\t    if (strm->avail_out == 0) {\n-\t      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n-\t      return Z_OK;\n-\t    }\n+            if (strm->avail_out == 0) {\n+              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n+              return Z_OK;\n+            }\n         }\n     }\n     Assert(strm->avail_out > 0, \"bug2\");\n \n     if (flush != Z_FINISH) return Z_OK;\n-    if (s->noheader) return Z_STREAM_END;\n-\n-    /* Write the zlib trailer (adler32) */\n-    putShortMSB(s, (uInt)(strm->adler >> 16));\n-    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n+    if (s->wrap <= 0) return Z_STREAM_END;\n+\n+    /* Write the trailer */\n+#ifdef GZIP\n+    if (s->wrap == 2) {\n+        put_byte(s, (Byte)(strm->adler & 0xff));\n+        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));\n+        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));\n+        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));\n+        put_byte(s, (Byte)(strm->total_in & 0xff));\n+        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));\n+        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));\n+        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));\n+    }\n+    else\n+#endif\n+    {\n+        putShortMSB(s, (uInt)(strm->adler >> 16));\n+        putShortMSB(s, (uInt)(strm->adler & 0xffff));\n+    }\n     flush_pending(strm);\n     /* If avail_out is zero, the application will call deflate again\n      * to flush the rest.\n      */\n-    s->noheader = -1; /* write the trailer only once! */\n+    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */\n     return s->pending != 0 ? Z_OK : Z_STREAM_END;\n }\n \n@@ -576,7 +705,7 @@ int ZEXPORT deflateEnd (strm)\n \n     status = strm->state->status;\n     if (status != INIT_STATE && status != BUSY_STATE &&\n-\tstatus != FINISH_STATE) {\n+        status != FINISH_STATE) {\n       return Z_STREAM_ERROR;\n     }\n \n@@ -649,7 +778,7 @@ int ZEXPORT deflateCopy (dest, source)\n     ds->bl_desc.dyn_tree = ds->bl_tree;\n \n     return Z_OK;\n-#endif\n+#endif /* MAXSEG_64K */\n }\n \n /* ===========================================================================\n@@ -671,9 +800,14 @@ local int read_buf(strm, buf, size)\n \n     strm->avail_in  -= len;\n \n-    if (!strm->state->noheader) {\n+    if (strm->state->wrap == 1) {\n         strm->adler = adler32(strm->adler, strm->next_in, len);\n     }\n+#ifdef GZIP\n+    else if (strm->state->wrap == 2) {\n+        strm->adler = crc32(strm->adler, strm->next_in, len);\n+    }\n+#endif\n     zmemcpy(buf, strm->next_in, len);\n     strm->next_in  += len;\n     strm->total_in += len;\n@@ -709,6 +843,7 @@ local void lm_init (s)\n #endif\n }\n \n+#ifndef FASTEST\n /* ===========================================================================\n  * Set match_start to the longest match starting at the given string and\n  * return its length. Matches shorter or equal to prev_length are discarded,\n@@ -722,7 +857,6 @@ local void lm_init (s)\n /* For 80x86 and 680x0, an optimized version will be provided in match.asm or\n  * match.S. The code will be functionally equivalent.\n  */\n-#ifndef FASTEST\n local uInt longest_match(s, cur_match)\n     deflate_state *s;\n     IPos cur_match;                             /* current match */\n@@ -860,12 +994,13 @@ local uInt longest_match(s, cur_match)\n     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n     return s->lookahead;\n }\n+#endif /* ASMV */\n+#endif /* FASTEST */\n \n-#else /* FASTEST */\n /* ---------------------------------------------------------------------------\n- * Optimized version for level == 1 only\n+ * Optimized version for level == 1 or strategy == Z_RLE only\n  */\n-local uInt longest_match(s, cur_match)\n+local uInt longest_match_fast(s, cur_match)\n     deflate_state *s;\n     IPos cur_match;                             /* current match */\n {\n@@ -903,10 +1038,10 @@ local uInt longest_match(s, cur_match)\n      */\n     do {\n     } while (*++scan == *++match && *++scan == *++match &&\n-\t     *++scan == *++match && *++scan == *++match &&\n-\t     *++scan == *++match && *++scan == *++match &&\n-\t     *++scan == *++match && *++scan == *++match &&\n-\t     scan < strend);\n+             *++scan == *++match && *++scan == *++match &&\n+             *++scan == *++match && *++scan == *++match &&\n+             *++scan == *++match && *++scan == *++match &&\n+             scan < strend);\n \n     Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n \n@@ -915,10 +1050,8 @@ local uInt longest_match(s, cur_match)\n     if (len < MIN_MATCH) return MIN_MATCH - 1;\n \n     s->match_start = cur_match;\n-    return len <= s->lookahead ? len : s->lookahead;\n+    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;\n }\n-#endif /* FASTEST */\n-#endif /* ASMV */\n \n #ifdef DEBUG\n /* ===========================================================================\n@@ -933,10 +1066,10 @@ local void check_match(s, start, match, length)\n     if (zmemcmp(s->window + match,\n                 s->window + start, length) != EQUAL) {\n         fprintf(stderr, \" start %u, match %u, length %d\\n\",\n-\t\tstart, match, length);\n+                start, match, length);\n         do {\n-\t    fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);\n-\t} while (--length != 0);\n+            fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);\n+        } while (--length != 0);\n         z_error(\"invalid match\");\n     }\n     if (z_verbose > 1) {\n@@ -946,7 +1079,7 @@ local void check_match(s, start, match, length)\n }\n #else\n #  define check_match(s, start, match, length)\n-#endif\n+#endif /* DEBUG */\n \n /* ===========================================================================\n  * Fill the window when the lookahead becomes insufficient.\n@@ -970,19 +1103,22 @@ local void fill_window(s)\n         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n \n         /* Deal with !@#$% 64K limit: */\n-        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n-            more = wsize;\n+        if (sizeof(int) <= 2) {\n+            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n+                more = wsize;\n \n-        } else if (more == (unsigned)(-1)) {\n-            /* Very unlikely, but possible on 16 bit machine if strstart == 0\n-             * and lookahead == 1 (input done one byte at time)\n-             */\n-            more--;\n+            } else if (more == (unsigned)(-1)) {\n+                /* Very unlikely, but possible on 16 bit machine if\n+                 * strstart == 0 && lookahead == 1 (input done a byte at time)\n+                 */\n+                more--;\n+            }\n+        }\n \n         /* If the window is almost full and there is insufficient lookahead,\n          * move the upper half to the lower one to make room in the upper half.\n          */\n-        } else if (s->strstart >= wsize+MAX_DIST(s)) {\n+        if (s->strstart >= wsize+MAX_DIST(s)) {\n \n             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);\n             s->match_start -= wsize;\n@@ -995,23 +1131,23 @@ local void fill_window(s)\n                later. (Using level 0 permanently is not an optimal usage of\n                zlib, so we don't care about this pathological case.)\n              */\n-\t    n = s->hash_size;\n-\t    p = &s->head[n];\n-\t    do {\n-\t\tm = *--p;\n-\t\t*p = (Pos)(m >= wsize ? m-wsize : NIL);\n-\t    } while (--n);\n-\n-\t    n = wsize;\n+            n = s->hash_size;\n+            p = &s->head[n];\n+            do {\n+                m = *--p;\n+                *p = (Pos)(m >= wsize ? m-wsize : NIL);\n+            } while (--n);\n+\n+            n = wsize;\n #ifndef FASTEST\n-\t    p = &s->prev[n];\n-\t    do {\n-\t\tm = *--p;\n-\t\t*p = (Pos)(m >= wsize ? m-wsize : NIL);\n-\t\t/* If n is not on any hash chain, prev[n] is garbage but\n-\t\t * its value will never be used.\n-\t\t */\n-\t    } while (--n);\n+            p = &s->prev[n];\n+            do {\n+                m = *--p;\n+                *p = (Pos)(m >= wsize ? m-wsize : NIL);\n+                /* If n is not on any hash chain, prev[n] is garbage but\n+                 * its value will never be used.\n+                 */\n+            } while (--n);\n #endif\n             more += wsize;\n         }\n@@ -1056,8 +1192,8 @@ local void fill_window(s)\n    _tr_flush_block(s, (s->block_start >= 0L ? \\\n                    (charf *)&s->window[(unsigned)s->block_start] : \\\n                    (charf *)Z_NULL), \\\n-\t\t(ulg)((long)s->strstart - s->block_start), \\\n-\t\t(eof)); \\\n+                (ulg)((long)s->strstart - s->block_start), \\\n+                (eof)); \\\n    s->block_start = s->strstart; \\\n    flush_pending(s->strm); \\\n    Tracev((stderr,\"[FLUSH]\")); \\\n@@ -1098,32 +1234,32 @@ local block_state deflate_stored(s, flush)\n         if (s->lookahead <= 1) {\n \n             Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n-\t\t   s->block_start >= (long)s->w_size, \"slide too late\");\n+                   s->block_start >= (long)s->w_size, \"slide too late\");\n \n             fill_window(s);\n             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;\n \n             if (s->lookahead == 0) break; /* flush the current block */\n         }\n-\tAssert(s->block_start >= 0L, \"block gone\");\n+        Assert(s->block_start >= 0L, \"block gone\");\n \n-\ts->strstart += s->lookahead;\n-\ts->lookahead = 0;\n+        s->strstart += s->lookahead;\n+        s->lookahead = 0;\n \n-\t/* Emit a stored block if pending_buf will be full: */\n- \tmax_start = s->block_start + max_block_size;\n+        /* Emit a stored block if pending_buf will be full: */\n+        max_start = s->block_start + max_block_size;\n         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {\n-\t    /* strstart == 0 is possible when wraparound on 16-bit machine */\n-\t    s->lookahead = (uInt)(s->strstart - max_start);\n-\t    s->strstart = (uInt)max_start;\n+            /* strstart == 0 is possible when wraparound on 16-bit machine */\n+            s->lookahead = (uInt)(s->strstart - max_start);\n+            s->strstart = (uInt)max_start;\n             FLUSH_BLOCK(s, 0);\n-\t}\n-\t/* Flush if we may have to slide, otherwise block_start may become\n+        }\n+        /* Flush if we may have to slide, otherwise block_start may become\n          * negative and the data will be gone:\n          */\n         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {\n             FLUSH_BLOCK(s, 0);\n-\t}\n+        }\n     }\n     FLUSH_BLOCK(s, flush == Z_FINISH);\n     return flush == Z_FINISH ? finish_done : block_done;\n@@ -1152,8 +1288,8 @@ local block_state deflate_fast(s, flush)\n         if (s->lookahead < MIN_LOOKAHEAD) {\n             fill_window(s);\n             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n-\t        return need_more;\n-\t    }\n+                return need_more;\n+            }\n             if (s->lookahead == 0) break; /* flush the current block */\n         }\n \n@@ -1172,10 +1308,19 @@ local block_state deflate_fast(s, flush)\n              * of window index 0 (in particular we have to avoid a match\n              * of the string with itself at the start of the input file).\n              */\n-            if (s->strategy != Z_HUFFMAN_ONLY) {\n+#ifdef FASTEST\n+            if ((s->strategy < Z_HUFFMAN_ONLY) ||\n+                (s->strategy == Z_RLE && s->strstart - hash_head == 1)) {\n+                s->match_length = longest_match_fast (s, hash_head);\n+            }\n+#else\n+            if (s->strategy < Z_HUFFMAN_ONLY) {\n                 s->match_length = longest_match (s, hash_head);\n+            } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {\n+                s->match_length = longest_match_fast (s, hash_head);\n             }\n-            /* longest_match() sets match_start */\n+#endif\n+            /* longest_match() or longest_match_fast() sets match_start */\n         }\n         if (s->match_length >= MIN_MATCH) {\n             check_match(s, s->strstart, s->match_start, s->match_length);\n@@ -1191,18 +1336,18 @@ local block_state deflate_fast(s, flush)\n #ifndef FASTEST\n             if (s->match_length <= s->max_insert_length &&\n                 s->lookahead >= MIN_MATCH) {\n-                s->match_length--; /* string at strstart already in hash table */\n+                s->match_length--; /* string at strstart already in table */\n                 do {\n                     s->strstart++;\n                     INSERT_STRING(s, s->strstart, hash_head);\n                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                      * always MIN_MATCH bytes ahead.\n                      */\n                 } while (--s->match_length != 0);\n-                s->strstart++; \n+                s->strstart++;\n             } else\n #endif\n-\t    {\n+            {\n                 s->strstart += s->match_length;\n                 s->match_length = 0;\n                 s->ins_h = s->window[s->strstart];\n@@ -1219,14 +1364,15 @@ local block_state deflate_fast(s, flush)\n             Tracevv((stderr,\"%c\", s->window[s->strstart]));\n             _tr_tally_lit (s, s->window[s->strstart], bflush);\n             s->lookahead--;\n-            s->strstart++; \n+            s->strstart++;\n         }\n         if (bflush) FLUSH_BLOCK(s, 0);\n     }\n     FLUSH_BLOCK(s, flush == Z_FINISH);\n     return flush == Z_FINISH ? finish_done : block_done;\n }\n \n+#ifndef FASTEST\n /* ===========================================================================\n  * Same as above, but achieves better compression. We use a lazy\n  * evaluation for matches: a match is finally adopted only if there is\n@@ -1249,8 +1395,8 @@ local block_state deflate_slow(s, flush)\n         if (s->lookahead < MIN_LOOKAHEAD) {\n             fill_window(s);\n             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n-\t        return need_more;\n-\t    }\n+                return need_more;\n+            }\n             if (s->lookahead == 0) break; /* flush the current block */\n         }\n \n@@ -1272,14 +1418,19 @@ local block_state deflate_slow(s, flush)\n              * of window index 0 (in particular we have to avoid a match\n              * of the string with itself at the start of the input file).\n              */\n-            if (s->strategy != Z_HUFFMAN_ONLY) {\n+            if (s->strategy < Z_HUFFMAN_ONLY) {\n                 s->match_length = longest_match (s, hash_head);\n+            } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {\n+                s->match_length = longest_match_fast (s, hash_head);\n             }\n-            /* longest_match() sets match_start */\n+            /* longest_match() or longest_match_fast() sets match_start */\n \n-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||\n-                 (s->match_length == MIN_MATCH &&\n-                  s->strstart - s->match_start > TOO_FAR))) {\n+            if (s->match_length <= 5 && (s->strategy == Z_FILTERED\n+#if TOO_FAR <= 32767\n+                || (s->match_length == MIN_MATCH &&\n+                    s->strstart - s->match_start > TOO_FAR)\n+#endif\n+                )) {\n \n                 /* If prev_match is also MIN_MATCH, match_start is garbage\n                  * but we will ignore the current match anyway.\n@@ -1297,7 +1448,7 @@ local block_state deflate_slow(s, flush)\n             check_match(s, s->strstart-1, s->prev_match, s->prev_length);\n \n             _tr_tally_dist(s, s->strstart -1 - s->prev_match,\n-\t\t\t   s->prev_length - MIN_MATCH, bflush);\n+                           s->prev_length - MIN_MATCH, bflush);\n \n             /* Insert in hash table all strings up to the end of the match.\n              * strstart-1 and strstart are already inserted. If there is not\n@@ -1323,8 +1474,8 @@ local block_state deflate_slow(s, flush)\n              * is longer, truncate the previous match to a single literal.\n              */\n             Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n-\t    _tr_tally_lit(s, s->window[s->strstart-1], bflush);\n-\t    if (bflush) {\n+            _tr_tally_lit(s, s->window[s->strstart-1], bflush);\n+            if (bflush) {\n                 FLUSH_BLOCK_ONLY(s, 0);\n             }\n             s->strstart++;\n@@ -1348,3 +1499,4 @@ local block_state deflate_slow(s, flush)\n     FLUSH_BLOCK(s, flush == Z_FINISH);\n     return flush == Z_FINISH ? finish_done : block_done;\n }\n+#endif /* FASTEST */"}, {"sha": "49e58a9832926d08e291c4391f85bc5f98b09afd", "filename": "zlib/deflate.h", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fdeflate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fdeflate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdeflate.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,6 +1,6 @@\n /* deflate.h -- internal compression state\n  * Copyright (C) 1995-2002 Jean-loup Gailly\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /* WARNING: this file should *not* be used by applications. It is\n@@ -10,11 +10,19 @@\n \n /* @(#) $Id: deflate.h,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */\n \n-#ifndef _DEFLATE_H\n-#define _DEFLATE_H\n+#ifndef DEFLATE_H\n+#define DEFLATE_H\n \n #include \"zutil.h\"\n \n+/* define NO_GZIP when compiling if you want to disable gzip header and\n+   trailer creation by deflate().  NO_GZIP would be used to avoid linking in\n+   the crc code when it is not needed.  For shared libraries, gzip encoding\n+   should be left enabled. */\n+#ifndef NO_GZIP\n+#  define GZIP\n+#endif\n+\n /* ===========================================================================\n  * Internal compression state.\n  */\n@@ -86,7 +94,7 @@ typedef struct internal_state {\n     ulg   pending_buf_size; /* size of pending_buf */\n     Bytef *pending_out;  /* next pending byte to output to the stream */\n     int   pending;       /* nb of bytes in the pending buffer */\n-    int   noheader;      /* suppress zlib header and adler32 */\n+    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */\n     Byte  data_type;     /* UNKNOWN, BINARY or ASCII */\n     Byte  method;        /* STORED (for zip only) or DEFLATED */\n     int   last_flush;    /* value of flush param for previous deflate call */\n@@ -269,7 +277,7 @@ typedef struct internal_state {\n void _tr_init         OF((deflate_state *s));\n int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));\n void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,\n-\t\t\t  int eof));\n+                          int eof));\n void _tr_align        OF((deflate_state *s));\n void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,\n                           int eof));\n@@ -312,7 +320,7 @@ void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,\n #else\n # define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)\n # define _tr_tally_dist(s, distance, length, flush) \\\n-              flush = _tr_tally(s, distance, length) \n+              flush = _tr_tally(s, distance, length)\n #endif\n \n-#endif\n+#endif /* DEFLATE_H */"}, {"sha": "9d364598a2716431b789b260974354adaeafc771", "filename": "zlib/descrip.mms", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fdescrip.mms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fdescrip.mms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fdescrip.mms?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,48 +0,0 @@\n-# descrip.mms: MMS description file for building zlib on VMS\n-# written by Martin P.J. Zinser <m.zinser@gsi.de>\n-\n-cc_defs = \n-c_deb = \n-\n-.ifdef __DECC__\n-pref = /prefix=all\n-.endif\n-\n-OBJS = adler32.obj, compress.obj, crc32.obj, gzio.obj, uncompr.obj,\\\n-       deflate.obj, trees.obj, zutil.obj, inflate.obj, infblock.obj,\\\n-       inftrees.obj, infcodes.obj, infutil.obj, inffast.obj\n-\n-CFLAGS= $(C_DEB) $(CC_DEFS) $(PREF)\n-\n-all : example.exe minigzip.exe\n-        @ write sys$output \" Example applications available\"\n-libz.olb : libz.olb($(OBJS))\n-\t@ write sys$output \" libz available\"\n-\n-example.exe : example.obj libz.olb\n-              link example,libz.olb/lib\n-\n-minigzip.exe : minigzip.obj libz.olb\n-              link minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib\n-\n-clean : \n-\tdelete *.obj;*,libz.olb;*\n-\n-\n-# Other dependencies.\n-adler32.obj : zutil.h zlib.h zconf.h\n-compress.obj : zlib.h zconf.h\n-crc32.obj : zutil.h zlib.h zconf.h\n-deflate.obj : deflate.h zutil.h zlib.h zconf.h\n-example.obj : zlib.h zconf.h\n-gzio.obj : zutil.h zlib.h zconf.h\n-infblock.obj : zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h\n-infcodes.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h\n-inffast.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n-inflate.obj : zutil.h zlib.h zconf.h infblock.h\n-inftrees.obj : zutil.h zlib.h zconf.h inftrees.h\n-infutil.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h\n-minigzip.obj : zlib.h zconf.h\n-trees.obj : deflate.h zutil.h zlib.h zconf.h\n-uncompr.obj : zlib.h zconf.h\n-zutil.obj : zutil.h zlib.h zconf.h"}, {"sha": "27237d507f7b7f2387c1b31e397463cc41d91fe0", "filename": "zlib/example.c", "status": "modified", "additions": 74, "deletions": 63, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fexample.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fexample.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fexample.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,6 +1,6 @@\n /* example.c -- usage example of the zlib compression library\n- * Copyright (C) 1995-2002 Jean-loup Gailly.\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * Copyright (C) 1995-2003 Jean-loup Gailly.\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /* @(#) $Id: example.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */\n@@ -37,22 +37,22 @@ const char dictionary[] = \"hello\";\n uLong dictId; /* Adler32 value of the dictionary */\n \n void test_compress      OF((Byte *compr, uLong comprLen,\n-\t\t            Byte *uncompr, uLong uncomprLen));\n-void test_gzio          OF((const char *out, const char *in, \n-\t\t            Byte *uncompr, int uncomprLen));\n+                            Byte *uncompr, uLong uncomprLen));\n+void test_gzio          OF((const char *fname,\n+                            Byte *uncompr, uLong uncomprLen));\n void test_deflate       OF((Byte *compr, uLong comprLen));\n void test_inflate       OF((Byte *compr, uLong comprLen,\n-\t\t            Byte *uncompr, uLong uncomprLen));\n+                            Byte *uncompr, uLong uncomprLen));\n void test_large_deflate OF((Byte *compr, uLong comprLen,\n-\t\t            Byte *uncompr, uLong uncomprLen));\n+                            Byte *uncompr, uLong uncomprLen));\n void test_large_inflate OF((Byte *compr, uLong comprLen,\n-\t\t            Byte *uncompr, uLong uncomprLen));\n+                            Byte *uncompr, uLong uncomprLen));\n void test_flush         OF((Byte *compr, uLong *comprLen));\n void test_sync          OF((Byte *compr, uLong comprLen,\n-\t\t            Byte *uncompr, uLong uncomprLen));\n+                            Byte *uncompr, uLong uncomprLen));\n void test_dict_deflate  OF((Byte *compr, uLong comprLen));\n void test_dict_inflate  OF((Byte *compr, uLong comprLen,\n-\t\t            Byte *uncompr, uLong uncomprLen));\n+                            Byte *uncompr, uLong uncomprLen));\n int  main               OF((int argc, char *argv[]));\n \n /* ===========================================================================\n@@ -63,7 +63,7 @@ void test_compress(compr, comprLen, uncompr, uncomprLen)\n     uLong comprLen, uncomprLen;\n {\n     int err;\n-    uLong len = strlen(hello)+1;\n+    uLong len = (uLong)strlen(hello)+1;\n \n     err = compress(compr, &comprLen, (const Bytef*)hello, len);\n     CHECK_ERR(err, \"compress\");\n@@ -75,7 +75,7 @@ void test_compress(compr, comprLen, uncompr, uncomprLen)\n \n     if (strcmp((char*)uncompr, hello)) {\n         fprintf(stderr, \"bad uncompress\\n\");\n-\texit(1);\n+        exit(1);\n     } else {\n         printf(\"uncompress(): %s\\n\", (char *)uncompr);\n     }\n@@ -84,78 +84,85 @@ void test_compress(compr, comprLen, uncompr, uncomprLen)\n /* ===========================================================================\n  * Test read/write of .gz files\n  */\n-void test_gzio(out, in, uncompr, uncomprLen)\n-    const char *out; /* compressed output file */\n-    const char *in;  /* compressed input file */\n+void test_gzio(fname, uncompr, uncomprLen)\n+    const char *fname; /* compressed file name */\n     Byte *uncompr;\n-    int  uncomprLen;\n+    uLong uncomprLen;\n {\n+#ifdef NO_GZCOMPRESS\n+    fprintf(stderr, \"NO_GZCOMPRESS -- gz* functions cannot compress\\n\");\n+#else\n     int err;\n-    int len = strlen(hello)+1;\n+    int len = (int)strlen(hello)+1;\n     gzFile file;\n     z_off_t pos;\n \n-    file = gzopen(out, \"wb\");\n+    file = gzopen(fname, \"wb\");\n     if (file == NULL) {\n         fprintf(stderr, \"gzopen error\\n\");\n         exit(1);\n     }\n     gzputc(file, 'h');\n     if (gzputs(file, \"ello\") != 4) {\n         fprintf(stderr, \"gzputs err: %s\\n\", gzerror(file, &err));\n-\texit(1);\n+        exit(1);\n     }\n     if (gzprintf(file, \", %s!\", \"hello\") != 8) {\n         fprintf(stderr, \"gzprintf err: %s\\n\", gzerror(file, &err));\n-\texit(1);\n+        exit(1);\n     }\n     gzseek(file, 1L, SEEK_CUR); /* add one zero byte */\n     gzclose(file);\n \n-    file = gzopen(in, \"rb\");\n+    file = gzopen(fname, \"rb\");\n     if (file == NULL) {\n         fprintf(stderr, \"gzopen error\\n\");\n+        exit(1);\n     }\n     strcpy((char*)uncompr, \"garbage\");\n \n-    uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);\n-    if (uncomprLen != len) {\n+    if (gzread(file, uncompr, (unsigned)uncomprLen) != len) {\n         fprintf(stderr, \"gzread err: %s\\n\", gzerror(file, &err));\n-\texit(1);\n+        exit(1);\n     }\n     if (strcmp((char*)uncompr, hello)) {\n         fprintf(stderr, \"bad gzread: %s\\n\", (char*)uncompr);\n-\texit(1);\n+        exit(1);\n     } else {\n-        printf(\"gzread(): %s\\n\", (char *)uncompr);\n+        printf(\"gzread(): %s\\n\", (char*)uncompr);\n     }\n \n     pos = gzseek(file, -8L, SEEK_CUR);\n     if (pos != 6 || gztell(file) != pos) {\n-\tfprintf(stderr, \"gzseek error, pos=%ld, gztell=%ld\\n\",\n-\t\t(long)pos, (long)gztell(file));\n-\texit(1);\n+        fprintf(stderr, \"gzseek error, pos=%ld, gztell=%ld\\n\",\n+                (long)pos, (long)gztell(file));\n+        exit(1);\n     }\n \n     if (gzgetc(file) != ' ') {\n-\tfprintf(stderr, \"gzgetc error\\n\");\n-\texit(1);\n+        fprintf(stderr, \"gzgetc error\\n\");\n+        exit(1);\n+    }\n+\n+    if (gzungetc(' ', file) != ' ') {\n+        fprintf(stderr, \"gzungetc error\\n\");\n+        exit(1);\n     }\n \n-    gzgets(file, (char*)uncompr, uncomprLen);\n-    uncomprLen = strlen((char*)uncompr);\n-    if (uncomprLen != 6) { /* \"hello!\" */\n+    gzgets(file, (char*)uncompr, (int)uncomprLen);\n+    if (strlen((char*)uncompr) != 7) { /* \" hello!\" */\n         fprintf(stderr, \"gzgets err after gzseek: %s\\n\", gzerror(file, &err));\n-\texit(1);\n+        exit(1);\n     }\n-    if (strcmp((char*)uncompr, hello+7)) {\n+    if (strcmp((char*)uncompr, hello + 6)) {\n         fprintf(stderr, \"bad gzgets after gzseek\\n\");\n-\texit(1);\n+        exit(1);\n     } else {\n-        printf(\"gzgets() after gzseek: %s\\n\", (char *)uncompr);\n+        printf(\"gzgets() after gzseek: %s\\n\", (char*)uncompr);\n     }\n \n     gzclose(file);\n+#endif\n }\n \n /* ===========================================================================\n@@ -167,7 +174,7 @@ void test_deflate(compr, comprLen)\n {\n     z_stream c_stream; /* compression stream */\n     int err;\n-    int len = strlen(hello)+1;\n+    uLong len = (uLong)strlen(hello)+1;\n \n     c_stream.zalloc = (alloc_func)0;\n     c_stream.zfree = (free_func)0;\n@@ -179,7 +186,7 @@ void test_deflate(compr, comprLen)\n     c_stream.next_in  = (Bytef*)hello;\n     c_stream.next_out = compr;\n \n-    while (c_stream.total_in != (uLong)len && c_stream.total_out < comprLen) {\n+    while (c_stream.total_in != len && c_stream.total_out < comprLen) {\n         c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */\n         err = deflate(&c_stream, Z_NO_FLUSH);\n         CHECK_ERR(err, \"deflate\");\n@@ -231,7 +238,7 @@ void test_inflate(compr, comprLen, uncompr, uncomprLen)\n \n     if (strcmp((char*)uncompr, hello)) {\n         fprintf(stderr, \"bad inflate\\n\");\n-\texit(1);\n+        exit(1);\n     } else {\n         printf(\"inflate(): %s\\n\", (char *)uncompr);\n     }\n@@ -266,7 +273,7 @@ void test_large_deflate(compr, comprLen, uncompr, uncomprLen)\n     CHECK_ERR(err, \"deflate\");\n     if (c_stream.avail_in != 0) {\n         fprintf(stderr, \"deflate not greedy\\n\");\n-\texit(1);\n+        exit(1);\n     }\n \n     /* Feed in already compressed data and switch to no compression: */\n@@ -286,7 +293,7 @@ void test_large_deflate(compr, comprLen, uncompr, uncomprLen)\n     err = deflate(&c_stream, Z_FINISH);\n     if (err != Z_STREAM_END) {\n         fprintf(stderr, \"deflate should report Z_STREAM_END\\n\");\n-\texit(1);\n+        exit(1);\n     }\n     err = deflateEnd(&c_stream);\n     CHECK_ERR(err, \"deflateEnd\");\n@@ -316,7 +323,7 @@ void test_large_inflate(compr, comprLen, uncompr, uncomprLen)\n \n     for (;;) {\n         d_stream.next_out = uncompr;            /* discard the output */\n-\td_stream.avail_out = (uInt)uncomprLen;\n+        d_stream.avail_out = (uInt)uncomprLen;\n         err = inflate(&d_stream, Z_NO_FLUSH);\n         if (err == Z_STREAM_END) break;\n         CHECK_ERR(err, \"large inflate\");\n@@ -327,7 +334,7 @@ void test_large_inflate(compr, comprLen, uncompr, uncomprLen)\n \n     if (d_stream.total_out != 2*uncomprLen + comprLen/2) {\n         fprintf(stderr, \"bad large inflate: %ld\\n\", d_stream.total_out);\n-\texit(1);\n+        exit(1);\n     } else {\n         printf(\"large_inflate(): OK\\n\");\n     }\n@@ -342,7 +349,7 @@ void test_flush(compr, comprLen)\n {\n     z_stream c_stream; /* compression stream */\n     int err;\n-    int len = strlen(hello)+1;\n+    uInt len = (uInt)strlen(hello)+1;\n \n     c_stream.zalloc = (alloc_func)0;\n     c_stream.zfree = (free_func)0;\n@@ -407,7 +414,7 @@ void test_sync(compr, comprLen, uncompr, uncomprLen)\n     if (err != Z_DATA_ERROR) {\n         fprintf(stderr, \"inflate should report DATA_ERROR\\n\");\n         /* Because of incorrect adler32 */\n-\texit(1);\n+        exit(1);\n     }\n     err = inflateEnd(&d_stream);\n     CHECK_ERR(err, \"inflateEnd\");\n@@ -433,7 +440,7 @@ void test_dict_deflate(compr, comprLen)\n     CHECK_ERR(err, \"deflateInit\");\n \n     err = deflateSetDictionary(&c_stream,\n-\t\t\t       (const Bytef*)dictionary, sizeof(dictionary));\n+                               (const Bytef*)dictionary, sizeof(dictionary));\n     CHECK_ERR(err, \"deflateSetDictionary\");\n \n     dictId = c_stream.adler;\n@@ -446,7 +453,7 @@ void test_dict_deflate(compr, comprLen)\n     err = deflate(&c_stream, Z_FINISH);\n     if (err != Z_STREAM_END) {\n         fprintf(stderr, \"deflate should report Z_STREAM_END\\n\");\n-\texit(1);\n+        exit(1);\n     }\n     err = deflateEnd(&c_stream);\n     CHECK_ERR(err, \"deflateEnd\");\n@@ -480,14 +487,14 @@ void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)\n     for (;;) {\n         err = inflate(&d_stream, Z_NO_FLUSH);\n         if (err == Z_STREAM_END) break;\n-\tif (err == Z_NEED_DICT) {\n-\t    if (d_stream.adler != dictId) {\n-\t\tfprintf(stderr, \"unexpected dictionary\");\n-\t\texit(1);\n-\t    }\n-\t    err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,\n-\t\t\t\t       sizeof(dictionary));\n-\t}\n+        if (err == Z_NEED_DICT) {\n+            if (d_stream.adler != dictId) {\n+                fprintf(stderr, \"unexpected dictionary\");\n+                exit(1);\n+            }\n+            err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,\n+                                       sizeof(dictionary));\n+        }\n         CHECK_ERR(err, \"inflate with dict\");\n     }\n \n@@ -496,7 +503,7 @@ void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)\n \n     if (strcmp((char*)uncompr, hello)) {\n         fprintf(stderr, \"bad inflate with dict\\n\");\n-\texit(1);\n+        exit(1);\n     } else {\n         printf(\"inflate with dictionary: %s\\n\", (char *)uncompr);\n     }\n@@ -523,20 +530,22 @@ int main(argc, argv)\n         fprintf(stderr, \"warning: different zlib version\\n\");\n     }\n \n+    printf(\"zlib version %s = 0x%04x, compile flags = 0x%lx\\n\",\n+            ZLIB_VERSION, ZLIB_VERNUM, zlibCompileFlags());\n+\n     compr    = (Byte*)calloc((uInt)comprLen, 1);\n     uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);\n     /* compr and uncompr are cleared to avoid reading uninitialized\n      * data and to ensure that uncompr compresses well.\n      */\n     if (compr == Z_NULL || uncompr == Z_NULL) {\n         printf(\"out of memory\\n\");\n-\texit(1);\n+        exit(1);\n     }\n     test_compress(compr, comprLen, uncompr, uncomprLen);\n \n     test_gzio((argc > 1 ? argv[1] : TESTFILE),\n-              (argc > 2 ? argv[2] : TESTFILE),\n-\t      uncompr, (int)uncomprLen);\n+              uncompr, uncomprLen);\n \n     test_deflate(compr, comprLen);\n     test_inflate(compr, comprLen, uncompr, uncomprLen);\n@@ -551,6 +560,8 @@ int main(argc, argv)\n     test_dict_deflate(compr, comprLen);\n     test_dict_inflate(compr, comprLen, uncompr, uncomprLen);\n \n-    exit(0);\n-    return 0; /* to avoid warning */\n+    free(compr);\n+    free(uncompr);\n+\n+    return 0;\n }"}, {"sha": "4054e8c735a99da2f95326c11a423eac444926af", "filename": "zlib/gzio.c", "status": "modified", "additions": 328, "deletions": 198, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fgzio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fgzio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fgzio.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,8 +1,8 @@\n /* gzio.c -- IO on .gz files\n- * Copyright (C) 1995-2002 Jean-loup Gailly.\n+ * Copyright (C) 1995-2003 Jean-loup Gailly.\n  * For conditions of distribution and use, see copyright notice in zlib.h\n  *\n- * Compile this file with -DNO_DEFLATE to avoid the compression code.\n+ * Compile this file with -DNO_GZCOMPRESS to avoid the compression code.\n  */\n \n /* @(#) $Id: gzio.c,v 1.1.1.2 2002/03/11 21:53:24 tromey Exp $ */\n@@ -11,7 +11,13 @@\n \n #include \"zutil.h\"\n \n+#ifdef NO_DEFLATE       /* for compatiblity with old definition */\n+#  define NO_GZCOMPRESS\n+#endif\n+\n+#ifndef NO_DUMMY_DECL\n struct internal_state {int dummy;}; /* for buggy compilers */\n+#endif\n \n #ifndef Z_BUFSIZE\n #  ifdef MAXSEG_64K\n@@ -24,10 +30,20 @@ struct internal_state {int dummy;}; /* for buggy compilers */\n #  define Z_PRINTF_BUFSIZE 4096\n #endif\n \n+#ifdef __MVS__\n+#  pragma map (fdopen , \"\\174\\174FDOPEN\")\n+   FILE *fdopen(int, const char *);\n+#endif\n+\n+#ifndef STDC\n+extern voidp  malloc OF((uInt size));\n+extern void   free   OF((voidpf ptr));\n+#endif\n+\n #define ALLOC(size) malloc(size)\n #define TRYFREE(p) {if (p) free(p);}\n \n-static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */\n+static int const gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */\n \n /* gzip flag byte */\n #define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */\n@@ -49,7 +65,11 @@ typedef struct gz_stream {\n     char     *path;   /* path name for debugging only */\n     int      transparent; /* 1 if input file is not a .gz file */\n     char     mode;    /* 'w' or 'r' */\n-    long     startpos; /* start of compressed data in file (header skipped) */\n+    z_off_t  start;   /* start of compressed data in file (header skipped) */\n+    z_off_t  in;      /* bytes into deflate or inflate */\n+    z_off_t  out;     /* bytes out of deflate or inflate */\n+    int      back;    /* one character push-back */\n+    int      last;    /* true if push-back is last character */\n } gz_stream;\n \n \n@@ -65,7 +85,7 @@ local uLong  getLong      OF((gz_stream *s));\n      Opens a gzip (.gz) file for reading or writing. The mode parameter\n    is as in fopen (\"rb\" or \"wb\"). The file is given either by file descriptor\n    or path name (if fd == -1).\n-     gz_open return NULL if the file could not be opened or if there was\n+     gz_open returns NULL if the file could not be opened or if there was\n    insufficient memory to allocate the (de)compression state; errno\n    can be checked to distinguish the two cases (if errno is zero, the\n    zlib error is Z_MEM_ERROR).\n@@ -97,6 +117,9 @@ local gzFile gz_open (path, mode, fd)\n     s->file = NULL;\n     s->z_err = Z_OK;\n     s->z_eof = 0;\n+    s->in = 0;\n+    s->out = 0;\n+    s->back = EOF;\n     s->crc = crc32(0L, Z_NULL, 0);\n     s->msg = NULL;\n     s->transparent = 0;\n@@ -112,19 +135,21 @@ local gzFile gz_open (path, mode, fd)\n         if (*p == 'r') s->mode = 'r';\n         if (*p == 'w' || *p == 'a') s->mode = 'w';\n         if (*p >= '0' && *p <= '9') {\n-\t    level = *p - '0';\n-\t} else if (*p == 'f') {\n-\t  strategy = Z_FILTERED;\n-\t} else if (*p == 'h') {\n-\t  strategy = Z_HUFFMAN_ONLY;\n-\t} else {\n-\t    *m++ = *p; /* copy the mode */\n-\t}\n+            level = *p - '0';\n+        } else if (*p == 'f') {\n+          strategy = Z_FILTERED;\n+        } else if (*p == 'h') {\n+          strategy = Z_HUFFMAN_ONLY;\n+        } else if (*p == 'R') {\n+          strategy = Z_RLE;\n+        } else {\n+            *m++ = *p; /* copy the mode */\n+        }\n     } while (*p++ && m != fmode + sizeof(fmode));\n     if (s->mode == '\\0') return destroy(s), (gzFile)Z_NULL;\n-    \n+\n     if (s->mode == 'w') {\n-#ifdef NO_DEFLATE\n+#ifdef NO_GZCOMPRESS\n         err = Z_STREAM_ERROR;\n #else\n         err = deflateInit2(&(s->stream), level,\n@@ -163,17 +188,17 @@ local gzFile gz_open (path, mode, fd)\n          */\n         fprintf(s->file, \"%c%c%c%c%c%c%c%c%c%c\", gz_magic[0], gz_magic[1],\n              Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);\n-\ts->startpos = 10L;\n-\t/* We use 10L instead of ftell(s->file) to because ftell causes an\n+        s->start = 10L;\n+        /* We use 10L instead of ftell(s->file) to because ftell causes an\n          * fflush on some systems. This version of the library doesn't use\n-         * startpos anyway in write mode, so this initialization is not\n+         * start anyway in write mode, so this initialization is not\n          * necessary.\n          */\n     } else {\n-\tcheck_header(s); /* skip the .gz header */\n-\ts->startpos = (ftell(s->file) - s->stream.avail_in);\n+        check_header(s); /* skip the .gz header */\n+        s->start = ftell(s->file) - s->stream.avail_in;\n     }\n-    \n+\n     return (gzFile)s;\n }\n \n@@ -218,11 +243,11 @@ int ZEXPORT gzsetparams (file, level, strategy)\n     /* Make room to allow flushing */\n     if (s->stream.avail_out == 0) {\n \n-\ts->stream.next_out = s->outbuf;\n-\tif (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {\n-\t    s->z_err = Z_ERRNO;\n-\t}\n-\ts->stream.avail_out = Z_BUFSIZE;\n+        s->stream.next_out = s->outbuf;\n+        if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {\n+            s->z_err = Z_ERRNO;\n+        }\n+        s->stream.avail_out = Z_BUFSIZE;\n     }\n \n     return deflateParams (&(s->stream), level, strategy);\n@@ -238,14 +263,14 @@ local int get_byte(s)\n {\n     if (s->z_eof) return EOF;\n     if (s->stream.avail_in == 0) {\n-\terrno = 0;\n-\ts->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n-\tif (s->stream.avail_in == 0) {\n-\t    s->z_eof = 1;\n-\t    if (ferror(s->file)) s->z_err = Z_ERRNO;\n-\t    return EOF;\n-\t}\n-\ts->stream.next_in = s->inbuf;\n+        errno = 0;\n+        s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n+        if (s->stream.avail_in == 0) {\n+            s->z_eof = 1;\n+            if (ferror(s->file)) s->z_err = Z_ERRNO;\n+            return EOF;\n+        }\n+        s->stream.next_in = s->inbuf;\n     }\n     s->stream.avail_in--;\n     return *(s->stream.next_in)++;\n@@ -268,43 +293,57 @@ local void check_header(s)\n     uInt len;\n     int c;\n \n-    /* Check the gzip magic header */\n-    for (len = 0; len < 2; len++) {\n-\tc = get_byte(s);\n-\tif (c != gz_magic[len]) {\n-\t    if (len != 0) s->stream.avail_in++, s->stream.next_in--;\n-\t    if (c != EOF) {\n-\t\ts->stream.avail_in++, s->stream.next_in--;\n-\t\ts->transparent = 1;\n-\t    }\n-\t    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;\n-\t    return;\n-\t}\n+    /* Assure two bytes in the buffer so we can peek ahead -- handle case\n+       where first byte of header is at the end of the buffer after the last\n+       gzip segment */\n+    len = s->stream.avail_in;\n+    if (len < 2) {\n+        if (len) s->inbuf[0] = s->stream.next_in[0];\n+        errno = 0;\n+        len = fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);\n+        if (len == 0 && ferror(s->file)) s->z_err = Z_ERRNO;\n+        s->stream.avail_in += len;\n+        s->stream.next_in = s->inbuf;\n+        if (s->stream.avail_in < 2) {\n+            s->transparent = s->stream.avail_in;\n+            return;\n+        }\n     }\n+\n+    /* Peek ahead to check the gzip magic header */\n+    if (s->stream.next_in[0] != gz_magic[0] ||\n+        s->stream.next_in[1] != gz_magic[1]) {\n+        s->transparent = 1;\n+        return;\n+    }\n+    s->stream.avail_in -= 2;\n+    s->stream.next_in += 2;\n+\n+    /* Check the rest of the gzip header */\n     method = get_byte(s);\n     flags = get_byte(s);\n     if (method != Z_DEFLATED || (flags & RESERVED) != 0) {\n-\ts->z_err = Z_DATA_ERROR;\n-\treturn;\n+        s->z_err = Z_DATA_ERROR;\n+        return;\n     }\n \n     /* Discard time, xflags and OS code: */\n     for (len = 0; len < 6; len++) (void)get_byte(s);\n \n     if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */\n-\tlen  =  (uInt)get_byte(s);\n-\tlen += ((uInt)get_byte(s))<<8;\n-\t/* len is garbage if EOF but the loop below will quit anyway */\n-\twhile (len-- != 0 && get_byte(s) != EOF) ;\n+        len  =  (uInt)get_byte(s);\n+        len += ((uInt)get_byte(s))<<8;\n+        /* len is garbage if EOF but the loop below will quit anyway */\n+        while (len-- != 0 && get_byte(s) != EOF) ;\n     }\n     if ((flags & ORIG_NAME) != 0) { /* skip the original file name */\n-\twhile ((c = get_byte(s)) != 0 && c != EOF) ;\n+        while ((c = get_byte(s)) != 0 && c != EOF) ;\n     }\n     if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */\n-\twhile ((c = get_byte(s)) != 0 && c != EOF) ;\n+        while ((c = get_byte(s)) != 0 && c != EOF) ;\n     }\n     if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */\n-\tfor (len = 0; len < 2; len++) (void)get_byte(s);\n+        for (len = 0; len < 2; len++) (void)get_byte(s);\n     }\n     s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;\n }\n@@ -323,21 +362,21 @@ local int destroy (s)\n     TRYFREE(s->msg);\n \n     if (s->stream.state != NULL) {\n-\tif (s->mode == 'w') {\n-#ifdef NO_DEFLATE\n-\t    err = Z_STREAM_ERROR;\n+        if (s->mode == 'w') {\n+#ifdef NO_GZCOMPRESS\n+            err = Z_STREAM_ERROR;\n #else\n-\t    err = deflateEnd(&(s->stream));\n+            err = deflateEnd(&(s->stream));\n #endif\n-\t} else if (s->mode == 'r') {\n-\t    err = inflateEnd(&(s->stream));\n-\t}\n+        } else if (s->mode == 'r') {\n+            err = inflateEnd(&(s->stream));\n+        }\n     }\n     if (s->file != NULL && fclose(s->file)) {\n #ifdef ESPIPE\n-\tif (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */\n+        if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */\n #endif\n-\t    err = Z_ERRNO;\n+            err = Z_ERRNO;\n     }\n     if (s->z_err < 0) err = s->z_err;\n \n@@ -370,71 +409,82 @@ int ZEXPORT gzread (file, buf, len)\n     s->stream.next_out = (Bytef*)buf;\n     s->stream.avail_out = len;\n \n+    if (s->stream.avail_out && s->back != EOF) {\n+        *next_out++ = s->back;\n+        s->stream.next_out++;\n+        s->stream.avail_out--;\n+        s->back = EOF;\n+        s->out++;\n+        if (s->last) {\n+            s->z_err = Z_STREAM_END;\n+            return 1;\n+        }\n+    }\n+\n     while (s->stream.avail_out != 0) {\n \n-\tif (s->transparent) {\n-\t    /* Copy first the lookahead bytes: */\n-\t    uInt n = s->stream.avail_in;\n-\t    if (n > s->stream.avail_out) n = s->stream.avail_out;\n-\t    if (n > 0) {\n-\t\tzmemcpy(s->stream.next_out, s->stream.next_in, n);\n-\t\tnext_out += n;\n-\t\ts->stream.next_out = next_out;\n-\t\ts->stream.next_in   += n;\n-\t\ts->stream.avail_out -= n;\n-\t\ts->stream.avail_in  -= n;\n-\t    }\n-\t    if (s->stream.avail_out > 0) {\n-\t\ts->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,\n-\t\t\t\t\t     s->file);\n-\t    }\n-\t    len -= s->stream.avail_out;\n-\t    s->stream.total_in  += (uLong)len;\n-\t    s->stream.total_out += (uLong)len;\n+        if (s->transparent) {\n+            /* Copy first the lookahead bytes: */\n+            uInt n = s->stream.avail_in;\n+            if (n > s->stream.avail_out) n = s->stream.avail_out;\n+            if (n > 0) {\n+                zmemcpy(s->stream.next_out, s->stream.next_in, n);\n+                next_out += n;\n+                s->stream.next_out = next_out;\n+                s->stream.next_in   += n;\n+                s->stream.avail_out -= n;\n+                s->stream.avail_in  -= n;\n+            }\n+            if (s->stream.avail_out > 0) {\n+                s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,\n+                                             s->file);\n+            }\n+            len -= s->stream.avail_out;\n+            s->in  += len;\n+            s->out += len;\n             if (len == 0) s->z_eof = 1;\n-\t    return (int)len;\n-\t}\n+            return (int)len;\n+        }\n         if (s->stream.avail_in == 0 && !s->z_eof) {\n \n             errno = 0;\n             s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);\n             if (s->stream.avail_in == 0) {\n                 s->z_eof = 1;\n-\t\tif (ferror(s->file)) {\n-\t\t    s->z_err = Z_ERRNO;\n-\t\t    break;\n-\t\t}\n+                if (ferror(s->file)) {\n+                    s->z_err = Z_ERRNO;\n+                    break;\n+                }\n             }\n             s->stream.next_in = s->inbuf;\n         }\n+        s->in += s->stream.avail_in;\n+        s->out += s->stream.avail_out;\n         s->z_err = inflate(&(s->stream), Z_NO_FLUSH);\n-\n-\tif (s->z_err == Z_STREAM_END) {\n-\t    /* Check CRC and original size */\n-\t    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n-\t    start = s->stream.next_out;\n-\n-\t    if (getLong(s) != s->crc) {\n-\t\ts->z_err = Z_DATA_ERROR;\n-\t    } else {\n-\t        (void)getLong(s);\n-                /* The uncompressed length returned by above getlong() may\n-                 * be different from s->stream.total_out) in case of\n-\t\t * concatenated .gz files. Check for such files:\n-\t\t */\n-\t\tcheck_header(s);\n-\t\tif (s->z_err == Z_OK) {\n-\t\t    uLong total_in = s->stream.total_in;\n-\t\t    uLong total_out = s->stream.total_out;\n-\n-\t\t    inflateReset(&(s->stream));\n-\t\t    s->stream.total_in = total_in;\n-\t\t    s->stream.total_out = total_out;\n-\t\t    s->crc = crc32(0L, Z_NULL, 0);\n-\t\t}\n-\t    }\n-\t}\n-\tif (s->z_err != Z_OK || s->z_eof) break;\n+        s->in -= s->stream.avail_in;\n+        s->out -= s->stream.avail_out;\n+\n+        if (s->z_err == Z_STREAM_END) {\n+            /* Check CRC and original size */\n+            s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n+            start = s->stream.next_out;\n+\n+            if (getLong(s) != s->crc) {\n+                s->z_err = Z_DATA_ERROR;\n+            } else {\n+                (void)getLong(s);\n+                /* The uncompressed length returned by above getlong() may be\n+                 * different from s->out in case of concatenated .gz files.\n+                 * Check for such files:\n+                 */\n+                check_header(s);\n+                if (s->z_err == Z_OK) {\n+                    inflateReset(&(s->stream));\n+                    s->crc = crc32(0L, Z_NULL, 0);\n+                }\n+            }\n+        }\n+        if (s->z_err != Z_OK || s->z_eof) break;\n     }\n     s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));\n \n@@ -455,6 +505,25 @@ int ZEXPORT gzgetc(file)\n }\n \n \n+/* ===========================================================================\n+      Push one byte back onto the stream.\n+*/\n+int ZEXPORT gzungetc(c, file)\n+    int c;\n+    gzFile file;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL || s->mode != 'r' || c == EOF || s->back != EOF) return EOF;\n+    s->back = c;\n+    s->out--;\n+    s->last = (s->z_err == Z_STREAM_END);\n+    if (s->last) s->z_err = Z_OK;\n+    s->z_eof = 0;\n+    return c;\n+}\n+\n+\n /* ===========================================================================\n       Reads bytes from the compressed file until len-1 characters are\n    read, or a newline character is read and transferred to buf, or an\n@@ -478,14 +547,14 @@ char * ZEXPORT gzgets(file, buf, len)\n }\n \n \n-#ifndef NO_DEFLATE\n+#ifndef NO_GZCOMPRESS\n /* ===========================================================================\n      Writes the given number of uncompressed bytes into the compressed file.\n    gzwrite returns the number of bytes actually written (0 in case of error).\n */\n int ZEXPORT gzwrite (file, buf, len)\n     gzFile file;\n-    const voidp buf;\n+    voidpc buf;\n     unsigned len;\n {\n     gz_stream *s = (gz_stream*)file;\n@@ -506,14 +575,19 @@ int ZEXPORT gzwrite (file, buf, len)\n             }\n             s->stream.avail_out = Z_BUFSIZE;\n         }\n+        s->in += s->stream.avail_in;\n+        s->out += s->stream.avail_out;\n         s->z_err = deflate(&(s->stream), Z_NO_FLUSH);\n+        s->in -= s->stream.avail_in;\n+        s->out -= s->stream.avail_out;\n         if (s->z_err != Z_OK) break;\n     }\n     s->crc = crc32(s->crc, (const Bytef *)buf, len);\n \n     return (int)(len - s->stream.avail_in);\n }\n \n+\n /* ===========================================================================\n      Converts, formats, and writes the args to the compressed file under\n    control of the format string, as in fprintf. gzprintf returns the number of\n@@ -528,40 +602,67 @@ int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)\n     va_list va;\n     int len;\n \n+    buf[sizeof(buf) - 1] = 0;\n     va_start(va, format);\n-#ifdef HAS_vsnprintf\n-    (void)vsnprintf(buf, sizeof(buf), format, va);\n-#else\n+#ifdef NO_vsnprintf\n+#  ifdef HAS_vsprintf_void\n     (void)vsprintf(buf, format, va);\n-#endif\n     va_end(va);\n-    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */\n-    if (len <= 0) return 0;\n-\n+    for (len = 0; len < sizeof(buf); len++)\n+        if (buf[len] == 0) break;\n+#  else\n+    len = vsprintf(buf, format, va);\n+    va_end(va);\n+#  endif\n+#else\n+#  ifdef HAS_vsnprintf_void\n+    (void)vsnprintf(buf, sizeof(buf), format, va);\n+    va_end(va);\n+    len = strlen(buf);\n+#  else\n+    len = vsnprintf(buf, sizeof(buf), format, va);\n+    va_end(va);\n+#  endif\n+#endif\n+    if (len <= 0 || len >= (int)sizeof(buf) || buf[sizeof(buf) - 1] != 0)\n+        return 0;\n     return gzwrite(file, buf, (unsigned)len);\n }\n #else /* not ANSI C */\n \n int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n-\t               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)\n+                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)\n     gzFile file;\n     const char *format;\n     int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n-\ta11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n+        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n {\n     char buf[Z_PRINTF_BUFSIZE];\n     int len;\n \n-#ifdef HAS_snprintf\n-    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,\n-\t     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n-#else\n+    buf[sizeof(buf) - 1] = 0;\n+#ifdef NO_snprintf\n+#  ifdef HAS_sprintf_void\n     sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,\n-\t    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+    for (len = 0; len < sizeof(buf); len++)\n+        if (buf[len] == 0) break;\n+#  else\n+    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,\n+                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+#  endif\n+#else\n+#  ifdef HAS_snprintf_void\n+    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,\n+             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+    len = strlen(buf);\n+#  else\n+    len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,\n+                 a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n+#  endif\n #endif\n-    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */\n-    if (len <= 0) return 0;\n-\n+    if (len <= 0 || len >= sizeof(buf) || buf[sizeof(buf) - 1] != 0)\n+        return 0;\n     return gzwrite(file, buf, len);\n }\n #endif\n@@ -621,16 +722,18 @@ local int do_flush (file, flush)\n             s->stream.avail_out = Z_BUFSIZE;\n         }\n         if (done) break;\n+        s->out += s->stream.avail_out;\n         s->z_err = deflate(&(s->stream), flush);\n+        s->out -= s->stream.avail_out;\n \n-\t/* Ignore the second of two consecutive flushes: */\n-\tif (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;\n+        /* Ignore the second of two consecutive flushes: */\n+        if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;\n \n         /* deflate has finished flushing only when it hasn't used up\n-         * all the available space in the output buffer: \n+         * all the available space in the output buffer:\n          */\n         done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);\n- \n+\n         if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;\n     }\n     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;\n@@ -647,7 +750,7 @@ int ZEXPORT gzflush (file, flush)\n     fflush(s->file);\n     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;\n }\n-#endif /* NO_DEFLATE */\n+#endif /* NO_GZCOMPRESS */\n \n /* ===========================================================================\n       Sets the starting position for the next gzread or gzwrite on the given\n@@ -665,99 +768,105 @@ z_off_t ZEXPORT gzseek (file, offset, whence)\n     gz_stream *s = (gz_stream*)file;\n \n     if (s == NULL || whence == SEEK_END ||\n-\ts->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {\n-\treturn -1L;\n+        s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {\n+        return -1L;\n     }\n-    \n+\n     if (s->mode == 'w') {\n-#ifdef NO_DEFLATE\n-\treturn -1L;\n+#ifdef NO_GZCOMPRESS\n+        return -1L;\n #else\n-\tif (whence == SEEK_SET) {\n-\t    offset -= s->stream.total_in;\n-\t}\n-\tif (offset < 0) return -1L;\n-\n-\t/* At this point, offset is the number of zero bytes to write. */\n-\tif (s->inbuf == Z_NULL) {\n-\t    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */\n-\t    zmemzero(s->inbuf, Z_BUFSIZE);\n-\t}\n-\twhile (offset > 0)  {\n-\t    uInt size = Z_BUFSIZE;\n-\t    if (offset < Z_BUFSIZE) size = (uInt)offset;\n-\n-\t    size = gzwrite(file, s->inbuf, size);\n-\t    if (size == 0) return -1L;\n-\n-\t    offset -= size;\n-\t}\n-\treturn (z_off_t)s->stream.total_in;\n+        if (whence == SEEK_SET) {\n+            offset -= s->in;\n+        }\n+        if (offset < 0) return -1L;\n+\n+        /* At this point, offset is the number of zero bytes to write. */\n+        if (s->inbuf == Z_NULL) {\n+            s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */\n+            if (s->inbuf == Z_NULL) return -1L;\n+            zmemzero(s->inbuf, Z_BUFSIZE);\n+        }\n+        while (offset > 0)  {\n+            uInt size = Z_BUFSIZE;\n+            if (offset < Z_BUFSIZE) size = (uInt)offset;\n+\n+            size = gzwrite(file, s->inbuf, size);\n+            if (size == 0) return -1L;\n+\n+            offset -= size;\n+        }\n+        return s->in;\n #endif\n     }\n     /* Rest of function is for reading only */\n \n     /* compute absolute position */\n     if (whence == SEEK_CUR) {\n-\toffset += s->stream.total_out;\n+        offset += s->out;\n     }\n     if (offset < 0) return -1L;\n \n     if (s->transparent) {\n-\t/* map to fseek */\n-\ts->stream.avail_in = 0;\n-\ts->stream.next_in = s->inbuf;\n+        /* map to fseek */\n+        s->back = EOF;\n+        s->stream.avail_in = 0;\n+        s->stream.next_in = s->inbuf;\n         if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;\n \n-\ts->stream.total_in = s->stream.total_out = (uLong)offset;\n-\treturn offset;\n+        s->in = s->out = offset;\n+        return offset;\n     }\n \n     /* For a negative seek, rewind and use positive seek */\n-    if ((uLong)offset >= s->stream.total_out) {\n-\toffset -= s->stream.total_out;\n+    if (offset >= s->out) {\n+        offset -= s->out;\n     } else if (gzrewind(file) < 0) {\n-\treturn -1L;\n+        return -1L;\n     }\n     /* offset is now the number of bytes to skip. */\n \n     if (offset != 0 && s->outbuf == Z_NULL) {\n-\ts->outbuf = (Byte*)ALLOC(Z_BUFSIZE);\n+        s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);\n+        if (s->outbuf == Z_NULL) return -1L;\n+    }\n+    if (offset && s->back != EOF) {\n+        s->back = EOF;\n+        s->out++;\n+        offset--;\n+        if (s->last) s->z_err = Z_STREAM_END;\n     }\n     while (offset > 0)  {\n-\tint size = Z_BUFSIZE;\n-\tif (offset < Z_BUFSIZE) size = (int)offset;\n+        int size = Z_BUFSIZE;\n+        if (offset < Z_BUFSIZE) size = (int)offset;\n \n-\tsize = gzread(file, s->outbuf, (uInt)size);\n-\tif (size <= 0) return -1L;\n-\toffset -= size;\n+        size = gzread(file, s->outbuf, (uInt)size);\n+        if (size <= 0) return -1L;\n+        offset -= size;\n     }\n-    return (z_off_t)s->stream.total_out;\n+    return s->out;\n }\n \n /* ===========================================================================\n-     Rewinds input file. \n+     Rewinds input file.\n */\n int ZEXPORT gzrewind (file)\n     gzFile file;\n {\n     gz_stream *s = (gz_stream*)file;\n-    \n+\n     if (s == NULL || s->mode != 'r') return -1;\n \n     s->z_err = Z_OK;\n     s->z_eof = 0;\n+    s->back = EOF;\n     s->stream.avail_in = 0;\n     s->stream.next_in = s->inbuf;\n     s->crc = crc32(0L, Z_NULL, 0);\n-\t\n-    if (s->startpos == 0) { /* not a compressed file */\n-\trewind(s->file);\n-\treturn 0;\n-    }\n-\n-    (void) inflateReset(&s->stream);\n-    return fseek(s->file, s->startpos, SEEK_SET);\n+    if (!s->transparent) (void)inflateReset(&s->stream);\n+    s->in = 0;\n+    s->out = 0;\n+    return fseek(s->file, s->start, SEEK_SET);\n }\n \n /* ===========================================================================\n@@ -779,8 +888,14 @@ int ZEXPORT gzeof (file)\n     gzFile file;\n {\n     gz_stream *s = (gz_stream*)file;\n-    \n-    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;\n+\n+    /* With concatenated compressed files that can have embedded\n+     * crc trailers, z_eof is no longer the only/best indicator of EOF\n+     * on a gz_stream. Handle end-of-stream error explicitly here.\n+     */\n+    if (s == NULL || s->mode != 'r') return 0;\n+    if (s->z_eof) return 1;\n+    return s->z_err == Z_STREAM_END;\n }\n \n /* ===========================================================================\n@@ -828,14 +943,14 @@ int ZEXPORT gzclose (file)\n     if (s == NULL) return Z_STREAM_ERROR;\n \n     if (s->mode == 'w') {\n-#ifdef NO_DEFLATE\n-\treturn Z_STREAM_ERROR;\n+#ifdef NO_GZCOMPRESS\n+        return Z_STREAM_ERROR;\n #else\n         err = do_flush (file, Z_FINISH);\n         if (err != Z_OK) return destroy((gz_stream*)file);\n \n         putLong (s->file, s->crc);\n-        putLong (s->file, s->stream.total_in);\n+        putLong (s->file, (uLong)(s->in & 0xffffffff));\n #endif\n     }\n     return destroy((gz_stream*)file);\n@@ -848,7 +963,7 @@ int ZEXPORT gzclose (file)\n    errnum is set to Z_ERRNO and the application may consult errno\n    to get the exact error code.\n */\n-const char*  ZEXPORT gzerror (file, errnum)\n+const char * ZEXPORT gzerror (file, errnum)\n     gzFile file;\n     int *errnum;\n {\n@@ -862,14 +977,29 @@ const char*  ZEXPORT gzerror (file, errnum)\n     *errnum = s->z_err;\n     if (*errnum == Z_OK) return (const char*)\"\";\n \n-    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);\n+    m = (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);\n \n     if (m == NULL || *m == '\\0') m = (char*)ERR_MSG(s->z_err);\n \n     TRYFREE(s->msg);\n     s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);\n+    if (s->msg == Z_NULL) return (const char*)ERR_MSG(Z_MEM_ERROR);\n     strcpy(s->msg, s->path);\n     strcat(s->msg, \": \");\n     strcat(s->msg, m);\n     return (const char*)s->msg;\n }\n+\n+/* ===========================================================================\n+     Clear the error and end-of-file flags, and do the same for the real file.\n+*/\n+void ZEXPORT gzclearerr (file)\n+    gzFile file;\n+{\n+    gz_stream *s = (gz_stream*)file;\n+\n+    if (s == NULL) return;\n+    if (s->z_err != Z_STREAM_END) s->z_err = Z_OK;\n+    s->z_eof = 0;\n+    clearerr(s->file);\n+}"}, {"sha": "dd7a6d40a8da1714a03fcd0631cdcb8ae7bc091c", "filename": "zlib/infblock.c", "status": "removed", "additions": 0, "deletions": 403, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfblock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfblock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfblock.c?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,403 +0,0 @@\n-/* infblock.c -- interpret and process block types to last block\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n- */\n-\n-#include \"zutil.h\"\n-#include \"infblock.h\"\n-#include \"inftrees.h\"\n-#include \"infcodes.h\"\n-#include \"infutil.h\"\n-\n-struct inflate_codes_state {int dummy;}; /* for buggy compilers */\n-\n-/* simplify the use of the inflate_huft type with some defines */\n-#define exop word.what.Exop\n-#define bits word.what.Bits\n-\n-/* Table for deflate from PKZIP's appnote.txt. */\n-local const uInt border[] = { /* Order of the bit length code lengths */\n-        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n-\n-/*\n-   Notes beyond the 1.93a appnote.txt:\n-\n-   1. Distance pointers never point before the beginning of the output\n-      stream.\n-   2. Distance pointers can point back across blocks, up to 32k away.\n-   3. There is an implied maximum of 7 bits for the bit length table and\n-      15 bits for the actual data.\n-   4. If only one code exists, then it is encoded using one bit.  (Zero\n-      would be more efficient, but perhaps a little confusing.)  If two\n-      codes exist, they are coded using one bit each (0 and 1).\n-   5. There is no way of sending zero distance codes--a dummy must be\n-      sent if there are none.  (History: a pre 2.0 version of PKZIP would\n-      store blocks with no distance codes, but this was discovered to be\n-      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow\n-      zero distance codes, which is sent as one code of zero bits in\n-      length.\n-   6. There are up to 286 literal/length codes.  Code 256 represents the\n-      end-of-block.  Note however that the static length tree defines\n-      288 codes just to fill out the Huffman codes.  Codes 286 and 287\n-      cannot be used though, since there is no length base or extra bits\n-      defined for them.  Similarily, there are up to 30 distance codes.\n-      However, static trees define 32 codes (all 5 bits) to fill out the\n-      Huffman codes, but the last two had better not show up in the data.\n-   7. Unzip can check dynamic Huffman blocks for complete code sets.\n-      The exception is that a single code would not be complete (see #4).\n-   8. The five bits following the block type is really the number of\n-      literal codes sent minus 257.\n-   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits\n-      (1+6+6).  Therefore, to output three times the length, you output\n-      three codes (1+1+1), whereas to output four times the same length,\n-      you only need two codes (1+3).  Hmm.\n-  10. In the tree reconstruction algorithm, Code = Code + Increment\n-      only if BitLength(i) is not zero.  (Pretty obvious.)\n-  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)\n-  12. Note: length code 284 can represent 227-258, but length code 285\n-      really is 258.  The last length deserves its own, short code\n-      since it gets used a lot in very redundant files.  The length\n-      258 is special since 258 - 3 (the min match length) is 255.\n-  13. The literal/length and distance code bit lengths are read as a\n-      single stream of lengths.  It is possible (and advantageous) for\n-      a repeat code (16, 17, or 18) to go across the boundary between\n-      the two sets of lengths.\n- */\n-\n-\n-void inflate_blocks_reset(s, z, c)\n-inflate_blocks_statef *s;\n-z_streamp z;\n-uLongf *c;\n-{\n-  if (c != Z_NULL)\n-    *c = s->check;\n-  if (s->mode == BTREE || s->mode == DTREE)\n-    ZFREE(z, s->sub.trees.blens);\n-  if (s->mode == CODES)\n-    inflate_codes_free(s->sub.decode.codes, z);\n-  s->mode = TYPE;\n-  s->bitk = 0;\n-  s->bitb = 0;\n-  s->read = s->write = s->window;\n-  if (s->checkfn != Z_NULL)\n-    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);\n-  Tracev((stderr, \"inflate:   blocks reset\\n\"));\n-}\n-\n-\n-inflate_blocks_statef *inflate_blocks_new(z, c, w)\n-z_streamp z;\n-check_func c;\n-uInt w;\n-{\n-  inflate_blocks_statef *s;\n-\n-  if ((s = (inflate_blocks_statef *)ZALLOC\n-       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)\n-    return s;\n-  if ((s->hufts =\n-       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)\n-  {\n-    ZFREE(z, s);\n-    return Z_NULL;\n-  }\n-  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)\n-  {\n-    ZFREE(z, s->hufts);\n-    ZFREE(z, s);\n-    return Z_NULL;\n-  }\n-  s->end = s->window + w;\n-  s->checkfn = c;\n-  s->mode = TYPE;\n-  Tracev((stderr, \"inflate:   blocks allocated\\n\"));\n-  inflate_blocks_reset(s, z, Z_NULL);\n-  return s;\n-}\n-\n-\n-int inflate_blocks(s, z, r)\n-inflate_blocks_statef *s;\n-z_streamp z;\n-int r;\n-{\n-  uInt t;               /* temporary storage */\n-  uLong b;              /* bit buffer */\n-  uInt k;               /* bits in bit buffer */\n-  Bytef *p;             /* input data pointer */\n-  uInt n;               /* bytes available there */\n-  Bytef *q;             /* output window write pointer */\n-  uInt m;               /* bytes to end of window or read pointer */\n-\n-  /* copy input/output information to locals (UPDATE macro restores) */\n-  LOAD\n-\n-  /* process input based on current state */\n-  while (1) switch (s->mode)\n-  {\n-    case TYPE:\n-      NEEDBITS(3)\n-      t = (uInt)b & 7;\n-      s->last = t & 1;\n-      switch (t >> 1)\n-      {\n-        case 0:                         /* stored */\n-          Tracev((stderr, \"inflate:     stored block%s\\n\",\n-                 s->last ? \" (last)\" : \"\"));\n-          DUMPBITS(3)\n-          t = k & 7;                    /* go to byte boundary */\n-          DUMPBITS(t)\n-          s->mode = LENS;               /* get length of stored block */\n-          break;\n-        case 1:                         /* fixed */\n-          Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n-                 s->last ? \" (last)\" : \"\"));\n-          {\n-            uInt bl, bd;\n-            inflate_huft *tl, *td;\n-\n-            inflate_trees_fixed(&bl, &bd, &tl, &td, z);\n-            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);\n-            if (s->sub.decode.codes == Z_NULL)\n-            {\n-              r = Z_MEM_ERROR;\n-              LEAVE\n-            }\n-          }\n-          DUMPBITS(3)\n-          s->mode = CODES;\n-          break;\n-        case 2:                         /* dynamic */\n-          Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n-                 s->last ? \" (last)\" : \"\"));\n-          DUMPBITS(3)\n-          s->mode = TABLE;\n-          break;\n-        case 3:                         /* illegal */\n-          DUMPBITS(3)\n-          s->mode = BAD;\n-          z->msg = (char*)\"invalid block type\";\n-          r = Z_DATA_ERROR;\n-          LEAVE\n-      }\n-      break;\n-    case LENS:\n-      NEEDBITS(32)\n-      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))\n-      {\n-        s->mode = BAD;\n-        z->msg = (char*)\"invalid stored block lengths\";\n-        r = Z_DATA_ERROR;\n-        LEAVE\n-      }\n-      s->sub.left = (uInt)b & 0xffff;\n-      b = k = 0;                      /* dump bits */\n-      Tracev((stderr, \"inflate:       stored length %u\\n\", s->sub.left));\n-      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);\n-      break;\n-    case STORED:\n-      if (n == 0)\n-        LEAVE\n-      NEEDOUT\n-      t = s->sub.left;\n-      if (t > n) t = n;\n-      if (t > m) t = m;\n-      zmemcpy(q, p, t);\n-      p += t;  n -= t;\n-      q += t;  m -= t;\n-      if ((s->sub.left -= t) != 0)\n-        break;\n-      Tracev((stderr, \"inflate:       stored end, %lu total out\\n\",\n-              z->total_out + (q >= s->read ? q - s->read :\n-              (s->end - s->read) + (q - s->window))));\n-      s->mode = s->last ? DRY : TYPE;\n-      break;\n-    case TABLE:\n-      NEEDBITS(14)\n-      s->sub.trees.table = t = (uInt)b & 0x3fff;\n-#ifndef PKZIP_BUG_WORKAROUND\n-      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n-      {\n-        s->mode = BAD;\n-        z->msg = (char*)\"too many length or distance symbols\";\n-        r = Z_DATA_ERROR;\n-        LEAVE\n-      }\n-#endif\n-      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n-      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)\n-      {\n-        r = Z_MEM_ERROR;\n-        LEAVE\n-      }\n-      DUMPBITS(14)\n-      s->sub.trees.index = 0;\n-      Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n-      s->mode = BTREE;\n-    case BTREE:\n-      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))\n-      {\n-        NEEDBITS(3)\n-        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;\n-        DUMPBITS(3)\n-      }\n-      while (s->sub.trees.index < 19)\n-        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;\n-      s->sub.trees.bb = 7;\n-      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,\n-                             &s->sub.trees.tb, s->hufts, z);\n-      if (t != Z_OK)\n-      {\n-        r = t;\n-        if (r == Z_DATA_ERROR)\n-        {\n-          ZFREE(z, s->sub.trees.blens);\n-          s->mode = BAD;\n-        }\n-        LEAVE\n-      }\n-      s->sub.trees.index = 0;\n-      Tracev((stderr, \"inflate:       bits tree ok\\n\"));\n-      s->mode = DTREE;\n-    case DTREE:\n-      while (t = s->sub.trees.table,\n-             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))\n-      {\n-        inflate_huft *h;\n-        uInt i, j, c;\n-\n-        t = s->sub.trees.bb;\n-        NEEDBITS(t)\n-        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);\n-        t = h->bits;\n-        c = h->base;\n-        if (c < 16)\n-        {\n-          DUMPBITS(t)\n-          s->sub.trees.blens[s->sub.trees.index++] = c;\n-        }\n-        else /* c == 16..18 */\n-        {\n-          i = c == 18 ? 7 : c - 14;\n-          j = c == 18 ? 11 : 3;\n-          NEEDBITS(t + i)\n-          DUMPBITS(t)\n-          j += (uInt)b & inflate_mask[i];\n-          DUMPBITS(i)\n-          i = s->sub.trees.index;\n-          t = s->sub.trees.table;\n-          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n-              (c == 16 && i < 1))\n-          {\n-            ZFREE(z, s->sub.trees.blens);\n-            s->mode = BAD;\n-            z->msg = (char*)\"invalid bit length repeat\";\n-            r = Z_DATA_ERROR;\n-            LEAVE\n-          }\n-          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;\n-          do {\n-            s->sub.trees.blens[i++] = c;\n-          } while (--j);\n-          s->sub.trees.index = i;\n-        }\n-      }\n-      s->sub.trees.tb = Z_NULL;\n-      {\n-        uInt bl, bd;\n-        inflate_huft *tl, *td;\n-        inflate_codes_statef *c;\n-\n-        bl = 9;         /* must be <= 9 for lookahead assumptions */\n-        bd = 6;         /* must be <= 9 for lookahead assumptions */\n-        t = s->sub.trees.table;\n-        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),\n-                                  s->sub.trees.blens, &bl, &bd, &tl, &td,\n-                                  s->hufts, z);\n-        if (t != Z_OK)\n-        {\n-          if (t == (uInt)Z_DATA_ERROR)\n-          {\n-            ZFREE(z, s->sub.trees.blens);\n-            s->mode = BAD;\n-          }\n-          r = t;\n-          LEAVE\n-        }\n-        Tracev((stderr, \"inflate:       trees ok\\n\"));\n-        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)\n-        {\n-          r = Z_MEM_ERROR;\n-          LEAVE\n-        }\n-        s->sub.decode.codes = c;\n-      }\n-      ZFREE(z, s->sub.trees.blens);\n-      s->mode = CODES;\n-    case CODES:\n-      UPDATE\n-      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)\n-        return inflate_flush(s, z, r);\n-      r = Z_OK;\n-      inflate_codes_free(s->sub.decode.codes, z);\n-      LOAD\n-      Tracev((stderr, \"inflate:       codes end, %lu total out\\n\",\n-              z->total_out + (q >= s->read ? q - s->read :\n-              (s->end - s->read) + (q - s->window))));\n-      if (!s->last)\n-      {\n-        s->mode = TYPE;\n-        break;\n-      }\n-      s->mode = DRY;\n-    case DRY:\n-      FLUSH\n-      if (s->read != s->write)\n-        LEAVE\n-      s->mode = DONE;\n-    case DONE:\n-      r = Z_STREAM_END;\n-      LEAVE\n-    case BAD:\n-      r = Z_DATA_ERROR;\n-      LEAVE\n-    default:\n-      r = Z_STREAM_ERROR;\n-      LEAVE\n-  }\n-}\n-\n-\n-int inflate_blocks_free(s, z)\n-inflate_blocks_statef *s;\n-z_streamp z;\n-{\n-  inflate_blocks_reset(s, z, Z_NULL);\n-  ZFREE(z, s->window);\n-  ZFREE(z, s->hufts);\n-  ZFREE(z, s);\n-  Tracev((stderr, \"inflate:   blocks freed\\n\"));\n-  return Z_OK;\n-}\n-\n-\n-void inflate_set_dictionary(s, d, n)\n-inflate_blocks_statef *s;\n-const Bytef *d;\n-uInt  n;\n-{\n-  zmemcpy(s->window, d, n);\n-  s->read = s->write = s->window + n;\n-}\n-\n-\n-/* Returns true if inflate is currently at the end of a block generated\n- * by Z_SYNC_FLUSH or Z_FULL_FLUSH. \n- * IN assertion: s != Z_NULL\n- */\n-int inflate_blocks_sync_point(s)\n-inflate_blocks_statef *s;\n-{\n-  return s->mode == LENS;\n-}"}, {"sha": "173b2267adec585700a3b986f6905efd41a7899d", "filename": "zlib/infblock.h", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfblock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfblock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfblock.h?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,39 +0,0 @@\n-/* infblock.h -- header to use infblock.c\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n- */\n-\n-/* WARNING: this file should *not* be used by applications. It is\n-   part of the implementation of the compression library and is\n-   subject to change. Applications should only use zlib.h.\n- */\n-\n-struct inflate_blocks_state;\n-typedef struct inflate_blocks_state FAR inflate_blocks_statef;\n-\n-extern inflate_blocks_statef * inflate_blocks_new OF((\n-    z_streamp z,\n-    check_func c,               /* check function */\n-    uInt w));                   /* window size */\n-\n-extern int inflate_blocks OF((\n-    inflate_blocks_statef *,\n-    z_streamp ,\n-    int));                      /* initial return code */\n-\n-extern void inflate_blocks_reset OF((\n-    inflate_blocks_statef *,\n-    z_streamp ,\n-    uLongf *));                  /* check value on output */\n-\n-extern int inflate_blocks_free OF((\n-    inflate_blocks_statef *,\n-    z_streamp));\n-\n-extern void inflate_set_dictionary OF((\n-    inflate_blocks_statef *s,\n-    const Bytef *d,  /* dictionary */\n-    uInt  n));       /* dictionary length */\n-\n-extern int inflate_blocks_sync_point OF((\n-    inflate_blocks_statef *s));"}, {"sha": "9abe5412b9c8b1ae61596ee3743ac9aaa7f3232d", "filename": "zlib/infcodes.c", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfcodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfcodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfcodes.c?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,251 +0,0 @@\n-/* infcodes.c -- process literals and length/distance pairs\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n- */\n-\n-#include \"zutil.h\"\n-#include \"inftrees.h\"\n-#include \"infblock.h\"\n-#include \"infcodes.h\"\n-#include \"infutil.h\"\n-#include \"inffast.h\"\n-\n-/* simplify the use of the inflate_huft type with some defines */\n-#define exop word.what.Exop\n-#define bits word.what.Bits\n-\n-typedef enum {        /* waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing */\n-      START,    /* x: set up for LEN */\n-      LEN,      /* i: get length/literal/eob next */\n-      LENEXT,   /* i: getting length extra (have base) */\n-      DIST,     /* i: get distance next */\n-      DISTEXT,  /* i: getting distance extra */\n-      COPY,     /* o: copying bytes in window, waiting for space */\n-      LIT,      /* o: got literal, waiting for output space */\n-      WASH,     /* o: got eob, possibly still output waiting */\n-      END,      /* x: got eob and all data flushed */\n-      BADCODE}  /* x: got error */\n-inflate_codes_mode;\n-\n-/* inflate codes private state */\n-struct inflate_codes_state {\n-\n-  /* mode */\n-  inflate_codes_mode mode;      /* current inflate_codes mode */\n-\n-  /* mode dependent information */\n-  uInt len;\n-  union {\n-    struct {\n-      inflate_huft *tree;       /* pointer into tree */\n-      uInt need;                /* bits needed */\n-    } code;             /* if LEN or DIST, where in tree */\n-    uInt lit;           /* if LIT, literal */\n-    struct {\n-      uInt get;                 /* bits to get for extra */\n-      uInt dist;                /* distance back to copy from */\n-    } copy;             /* if EXT or COPY, where and how much */\n-  } sub;                /* submode */\n-\n-  /* mode independent information */\n-  Byte lbits;           /* ltree bits decoded per branch */\n-  Byte dbits;           /* dtree bits decoder per branch */\n-  inflate_huft *ltree;          /* literal/length/eob tree */\n-  inflate_huft *dtree;          /* distance tree */\n-\n-};\n-\n-\n-inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)\n-uInt bl, bd;\n-inflate_huft *tl;\n-inflate_huft *td; /* need separate declaration for Borland C++ */\n-z_streamp z;\n-{\n-  inflate_codes_statef *c;\n-\n-  if ((c = (inflate_codes_statef *)\n-       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)\n-  {\n-    c->mode = START;\n-    c->lbits = (Byte)bl;\n-    c->dbits = (Byte)bd;\n-    c->ltree = tl;\n-    c->dtree = td;\n-    Tracev((stderr, \"inflate:       codes new\\n\"));\n-  }\n-  return c;\n-}\n-\n-\n-int inflate_codes(s, z, r)\n-inflate_blocks_statef *s;\n-z_streamp z;\n-int r;\n-{\n-  uInt j;               /* temporary storage */\n-  inflate_huft *t;      /* temporary pointer */\n-  uInt e;               /* extra bits or operation */\n-  uLong b;              /* bit buffer */\n-  uInt k;               /* bits in bit buffer */\n-  Bytef *p;             /* input data pointer */\n-  uInt n;               /* bytes available there */\n-  Bytef *q;             /* output window write pointer */\n-  uInt m;               /* bytes to end of window or read pointer */\n-  Bytef *f;             /* pointer to copy strings from */\n-  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */\n-\n-  /* copy input/output information to locals (UPDATE macro restores) */\n-  LOAD\n-\n-  /* process input and output based on current state */\n-  while (1) switch (c->mode)\n-  {             /* waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing */\n-    case START:         /* x: set up for LEN */\n-#ifndef SLOW\n-      if (m >= 258 && n >= 10)\n-      {\n-        UPDATE\n-        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);\n-        LOAD\n-        if (r != Z_OK)\n-        {\n-          c->mode = r == Z_STREAM_END ? WASH : BADCODE;\n-          break;\n-        }\n-      }\n-#endif /* !SLOW */\n-      c->sub.code.need = c->lbits;\n-      c->sub.code.tree = c->ltree;\n-      c->mode = LEN;\n-    case LEN:           /* i: get length/literal/eob next */\n-      j = c->sub.code.need;\n-      NEEDBITS(j)\n-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);\n-      DUMPBITS(t->bits)\n-      e = (uInt)(t->exop);\n-      if (e == 0)               /* literal */\n-      {\n-        c->sub.lit = t->base;\n-        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n-                 \"inflate:         literal '%c'\\n\" :\n-                 \"inflate:         literal 0x%02x\\n\", t->base));\n-        c->mode = LIT;\n-        break;\n-      }\n-      if (e & 16)               /* length */\n-      {\n-        c->sub.copy.get = e & 15;\n-        c->len = t->base;\n-        c->mode = LENEXT;\n-        break;\n-      }\n-      if ((e & 64) == 0)        /* next table */\n-      {\n-        c->sub.code.need = e;\n-        c->sub.code.tree = t + t->base;\n-        break;\n-      }\n-      if (e & 32)               /* end of block */\n-      {\n-        Tracevv((stderr, \"inflate:         end of block\\n\"));\n-        c->mode = WASH;\n-        break;\n-      }\n-      c->mode = BADCODE;        /* invalid code */\n-      z->msg = (char*)\"invalid literal/length code\";\n-      r = Z_DATA_ERROR;\n-      LEAVE\n-    case LENEXT:        /* i: getting length extra (have base) */\n-      j = c->sub.copy.get;\n-      NEEDBITS(j)\n-      c->len += (uInt)b & inflate_mask[j];\n-      DUMPBITS(j)\n-      c->sub.code.need = c->dbits;\n-      c->sub.code.tree = c->dtree;\n-      Tracevv((stderr, \"inflate:         length %u\\n\", c->len));\n-      c->mode = DIST;\n-    case DIST:          /* i: get distance next */\n-      j = c->sub.code.need;\n-      NEEDBITS(j)\n-      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);\n-      DUMPBITS(t->bits)\n-      e = (uInt)(t->exop);\n-      if (e & 16)               /* distance */\n-      {\n-        c->sub.copy.get = e & 15;\n-        c->sub.copy.dist = t->base;\n-        c->mode = DISTEXT;\n-        break;\n-      }\n-      if ((e & 64) == 0)        /* next table */\n-      {\n-        c->sub.code.need = e;\n-        c->sub.code.tree = t + t->base;\n-        break;\n-      }\n-      c->mode = BADCODE;        /* invalid code */\n-      z->msg = (char*)\"invalid distance code\";\n-      r = Z_DATA_ERROR;\n-      LEAVE\n-    case DISTEXT:       /* i: getting distance extra */\n-      j = c->sub.copy.get;\n-      NEEDBITS(j)\n-      c->sub.copy.dist += (uInt)b & inflate_mask[j];\n-      DUMPBITS(j)\n-      Tracevv((stderr, \"inflate:         distance %u\\n\", c->sub.copy.dist));\n-      c->mode = COPY;\n-    case COPY:          /* o: copying bytes in window, waiting for space */\n-      f = q - c->sub.copy.dist;\n-      while (f < s->window)             /* modulo window size-\"while\" instead */\n-        f += s->end - s->window;        /* of \"if\" handles invalid distances */\n-      while (c->len)\n-      {\n-        NEEDOUT\n-        OUTBYTE(*f++)\n-        if (f == s->end)\n-          f = s->window;\n-        c->len--;\n-      }\n-      c->mode = START;\n-      break;\n-    case LIT:           /* o: got literal, waiting for output space */\n-      NEEDOUT\n-      OUTBYTE(c->sub.lit)\n-      c->mode = START;\n-      break;\n-    case WASH:          /* o: got eob, possibly more output */\n-      if (k > 7)        /* return unused byte, if any */\n-      {\n-        Assert(k < 16, \"inflate_codes grabbed too many bytes\")\n-        k -= 8;\n-        n++;\n-        p--;            /* can always return one */\n-      }\n-      FLUSH\n-      if (s->read != s->write)\n-        LEAVE\n-      c->mode = END;\n-    case END:\n-      r = Z_STREAM_END;\n-      LEAVE\n-    case BADCODE:       /* x: got error */\n-      r = Z_DATA_ERROR;\n-      LEAVE\n-    default:\n-      r = Z_STREAM_ERROR;\n-      LEAVE\n-  }\n-#ifdef NEED_DUMMY_RETURN\n-  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */\n-#endif\n-}\n-\n-\n-void inflate_codes_free(c, z)\n-inflate_codes_statef *c;\n-z_streamp z;\n-{\n-  ZFREE(z, c);\n-  Tracev((stderr, \"inflate:       codes free\\n\"));\n-}"}, {"sha": "46821a02be65826c8c366e600798f4629c35be05", "filename": "zlib/infcodes.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfcodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfcodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfcodes.h?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,27 +0,0 @@\n-/* infcodes.h -- header to use infcodes.c\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n- */\n-\n-/* WARNING: this file should *not* be used by applications. It is\n-   part of the implementation of the compression library and is\n-   subject to change. Applications should only use zlib.h.\n- */\n-\n-struct inflate_codes_state;\n-typedef struct inflate_codes_state FAR inflate_codes_statef;\n-\n-extern inflate_codes_statef *inflate_codes_new OF((\n-    uInt, uInt,\n-    inflate_huft *, inflate_huft *,\n-    z_streamp ));\n-\n-extern int inflate_codes OF((\n-    inflate_blocks_statef *,\n-    z_streamp ,\n-    int));\n-\n-extern void inflate_codes_free OF((\n-    inflate_codes_statef *,\n-    z_streamp ));\n-"}, {"sha": "c716440a92ac9edcf86bd89c10eb82479638bb4f", "filename": "zlib/inffast.c", "status": "modified", "additions": 288, "deletions": 166, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finffast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finffast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finffast.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,183 +1,305 @@\n-/* inffast.c -- process literals and length/distance pairs fast\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+/* inffast.c -- fast decoding\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n #include \"zutil.h\"\n #include \"inftrees.h\"\n-#include \"infblock.h\"\n-#include \"infcodes.h\"\n-#include \"infutil.h\"\n+#include \"inflate.h\"\n #include \"inffast.h\"\n \n-struct inflate_codes_state {int dummy;}; /* for buggy compilers */\n+#ifndef ASMINF\n \n-/* simplify the use of the inflate_huft type with some defines */\n-#define exop word.what.Exop\n-#define bits word.what.Bits\n+/* Allow machine dependent optimization for post-increment or pre-increment.\n+   Based on testing to date,\n+   Pre-increment preferred for:\n+   - PowerPC G3 (Adler)\n+   - MIPS R5000 (Randers-Pehrson)\n+   Post-increment preferred for:\n+   - none\n+   No measurable difference:\n+   - Pentium III (Anderson)\n+   - 68060 (Nikl)\n+ */\n+#ifdef POSTINC\n+#  define OFF 0\n+#  define PUP(a) *(a)++\n+#else\n+#  define OFF 1\n+#  define PUP(a) *++(a)\n+#endif\n+\n+/*\n+   Decode literal, length, and distance codes and write out the resulting\n+   literal and match bytes until either not enough input or output is\n+   available, an end-of-block is encountered, or a data error is encountered.\n+   When large enough input and output buffers are supplied to inflate(), for\n+   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n+   inflate execution time is spent in this routine.\n+\n+   Entry assumptions:\n+\n+        state->mode == LEN\n+        strm->avail_in >= 6\n+        strm->avail_out >= 258\n+        start >= strm->avail_out\n+        state->bits < 8\n+\n+   On return, state->mode is one of:\n+\n+        LEN -- ran out of enough output space or enough available input\n+        TYPE -- reached end of block code, inflate() to interpret next block\n+        BAD -- error in block data\n \n-/* macros for bit input with no checking and for returning unused bytes */\n-#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}\n-#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}\n+   Notes:\n \n-/* Called with number of bytes left to write in window at least 258\n-   (the maximum string length) and number of input bytes available\n-   at least ten.  The ten bytes are six bytes for the longest length/\n-   distance pair plus four bytes for overloading the bit buffer. */\n+    - The maximum input bits used by a length/distance pair is 15 bits for the\n+      length code, 5 bits for the length extra, 15 bits for the distance code,\n+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n+      Therefore if strm->avail_in >= 6, then there is enough input to avoid\n+      checking for available input while decoding.\n \n-int inflate_fast(bl, bd, tl, td, s, z)\n-uInt bl, bd;\n-inflate_huft *tl;\n-inflate_huft *td; /* need separate declaration for Borland C++ */\n-inflate_blocks_statef *s;\n-z_streamp z;\n+    - The maximum bytes that a single length/distance pair can output is 258\n+      bytes, which is the maximum length that can be coded.  inflate_fast()\n+      requires strm->avail_out >= 258 for each loop to avoid checking for\n+      output space.\n+ */\n+void inflate_fast(strm, start)\n+z_streamp strm;\n+unsigned start;         /* inflate()'s starting value for strm->avail_out */\n {\n-  inflate_huft *t;      /* temporary pointer */\n-  uInt e;               /* extra bits or operation */\n-  uLong b;              /* bit buffer */\n-  uInt k;               /* bits in bit buffer */\n-  Bytef *p;             /* input data pointer */\n-  uInt n;               /* bytes available there */\n-  Bytef *q;             /* output window write pointer */\n-  uInt m;               /* bytes to end of window or read pointer */\n-  uInt ml;              /* mask for literal/length tree */\n-  uInt md;              /* mask for distance tree */\n-  uInt c;               /* bytes to copy */\n-  uInt d;               /* distance back to copy from */\n-  Bytef *r;             /* copy source pointer */\n-\n-  /* load input, output, bit values */\n-  LOAD\n-\n-  /* initialize masks */\n-  ml = inflate_mask[bl];\n-  md = inflate_mask[bd];\n-\n-  /* do until not enough input or output space for fast loop */\n-  do {                          /* assume called with m >= 258 && n >= 10 */\n-    /* get literal/length code */\n-    GRABBITS(20)                /* max bits for literal/length code */\n-    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)\n-    {\n-      DUMPBITS(t->bits)\n-      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n-                \"inflate:         * literal '%c'\\n\" :\n-                \"inflate:         * literal 0x%02x\\n\", t->base));\n-      *q++ = (Byte)t->base;\n-      m--;\n-      continue;\n-    }\n+    struct inflate_state FAR *state;\n+    unsigned char FAR *in;      /* local strm->next_in */\n+    unsigned char FAR *last;    /* while in < last, enough input available */\n+    unsigned char FAR *out;     /* local strm->next_out */\n+    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n+    unsigned char FAR *end;     /* while out < end, enough space available */\n+    unsigned wsize;             /* window size or zero if not using window */\n+    unsigned whave;             /* valid bytes in the window */\n+    unsigned write;             /* window write index */\n+    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n+    unsigned long hold;         /* local strm->hold */\n+    unsigned bits;              /* local strm->bits */\n+    code const FAR *lcode;      /* local strm->lencode */\n+    code const FAR *dcode;      /* local strm->distcode */\n+    unsigned lmask;             /* mask for first level of length codes */\n+    unsigned dmask;             /* mask for first level of distance codes */\n+    code this;                  /* retrieved table entry */\n+    unsigned op;                /* code bits, operation, extra bits, or */\n+                                /*  window position, window bytes to copy */\n+    unsigned len;               /* match length, unused bytes */\n+    unsigned dist;              /* match distance */\n+    unsigned char FAR *from;    /* where to copy match from */\n+\n+    /* copy state to local variables */\n+    state = (struct inflate_state FAR *)strm->state;\n+    in = strm->next_in - OFF;\n+    last = in + (strm->avail_in - 5);\n+    out = strm->next_out - OFF;\n+    beg = out - (start - strm->avail_out);\n+    end = out + (strm->avail_out - 257);\n+    wsize = state->wsize;\n+    whave = state->whave;\n+    write = state->write;\n+    window = state->window;\n+    hold = state->hold;\n+    bits = state->bits;\n+    lcode = state->lencode;\n+    dcode = state->distcode;\n+    lmask = (1U << state->lenbits) - 1;\n+    dmask = (1U << state->distbits) - 1;\n+\n+    /* decode literals and length/distances until end-of-block or not enough\n+       input data or output space */\n     do {\n-      DUMPBITS(t->bits)\n-      if (e & 16)\n-      {\n-        /* get extra bits for length */\n-        e &= 15;\n-        c = t->base + ((uInt)b & inflate_mask[e]);\n-        DUMPBITS(e)\n-        Tracevv((stderr, \"inflate:         * length %u\\n\", c));\n-\n-        /* decode distance base of block to copy */\n-        GRABBITS(15);           /* max bits for distance code */\n-        e = (t = td + ((uInt)b & md))->exop;\n-        do {\n-          DUMPBITS(t->bits)\n-          if (e & 16)\n-          {\n-            /* get extra bits to add to distance base */\n-            e &= 15;\n-            GRABBITS(e)         /* get extra bits (up to 13) */\n-            d = t->base + ((uInt)b & inflate_mask[e]);\n-            DUMPBITS(e)\n-            Tracevv((stderr, \"inflate:         * distance %u\\n\", d));\n-\n-            /* do the copy */\n-            m -= c;\n-            r = q - d;\n-            if (r < s->window)                  /* wrap if needed */\n-            {\n-              do {\n-                r += s->end - s->window;        /* force pointer in window */\n-              } while (r < s->window);          /* covers invalid distances */\n-              e = s->end - r;\n-              if (c > e)\n-              {\n-                c -= e;                         /* wrapped copy */\n-                do {\n-                    *q++ = *r++;\n-                } while (--e);\n-                r = s->window;\n-                do {\n-                    *q++ = *r++;\n-                } while (--c);\n-              }\n-              else                              /* normal copy */\n-              {\n-                *q++ = *r++;  c--;\n-                *q++ = *r++;  c--;\n-                do {\n-                    *q++ = *r++;\n-                } while (--c);\n-              }\n+        if (bits < 15) {\n+            hold += (unsigned long)(PUP(in)) << bits;\n+            bits += 8;\n+            hold += (unsigned long)(PUP(in)) << bits;\n+            bits += 8;\n+        }\n+        this = lcode[hold & lmask];\n+      dolen:\n+        op = (unsigned)(this.bits);\n+        hold >>= op;\n+        bits -= op;\n+        op = (unsigned)(this.op);\n+        if (op == 0) {                          /* literal */\n+            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?\n+                    \"inflate:         literal '%c'\\n\" :\n+                    \"inflate:         literal 0x%02x\\n\", this.val));\n+            PUP(out) = (unsigned char)(this.val);\n+        }\n+        else if (op & 16) {                     /* length base */\n+            len = (unsigned)(this.val);\n+            op &= 15;                           /* number of extra bits */\n+            if (op) {\n+                if (bits < op) {\n+                    hold += (unsigned long)(PUP(in)) << bits;\n+                    bits += 8;\n+                }\n+                len += (unsigned)hold & ((1U << op) - 1);\n+                hold >>= op;\n+                bits -= op;\n+            }\n+            Tracevv((stderr, \"inflate:         length %u\\n\", len));\n+            if (bits < 15) {\n+                hold += (unsigned long)(PUP(in)) << bits;\n+                bits += 8;\n+                hold += (unsigned long)(PUP(in)) << bits;\n+                bits += 8;\n             }\n-            else                                /* normal copy */\n-            {\n-              *q++ = *r++;  c--;\n-              *q++ = *r++;  c--;\n-              do {\n-                *q++ = *r++;\n-              } while (--c);\n+            this = dcode[hold & dmask];\n+          dodist:\n+            op = (unsigned)(this.bits);\n+            hold >>= op;\n+            bits -= op;\n+            op = (unsigned)(this.op);\n+            if (op & 16) {                      /* distance base */\n+                dist = (unsigned)(this.val);\n+                op &= 15;                       /* number of extra bits */\n+                if (bits < op) {\n+                    hold += (unsigned long)(PUP(in)) << bits;\n+                    bits += 8;\n+                    if (bits < op) {\n+                        hold += (unsigned long)(PUP(in)) << bits;\n+                        bits += 8;\n+                    }\n+                }\n+                dist += (unsigned)hold & ((1U << op) - 1);\n+                hold >>= op;\n+                bits -= op;\n+                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n+                op = (unsigned)(out - beg);     /* max distance in output */\n+                if (dist > op) {                /* see if copy from window */\n+                    op = dist - op;             /* distance back in window */\n+                    if (op > whave) {\n+                        strm->msg = (char *)\"invalid distance too far back\";\n+                        state->mode = BAD;\n+                        break;\n+                    }\n+                    from = window - OFF;\n+                    if (write == 0) {           /* very common case */\n+                        from += wsize - op;\n+                        if (op < len) {         /* some from window */\n+                            len -= op;\n+                            do {\n+                                PUP(out) = PUP(from);\n+                            } while (--op);\n+                            from = out - dist;  /* rest from output */\n+                        }\n+                    }\n+                    else if (write < op) {      /* wrap around window */\n+                        from += wsize + write - op;\n+                        op -= write;\n+                        if (op < len) {         /* some from end of window */\n+                            len -= op;\n+                            do {\n+                                PUP(out) = PUP(from);\n+                            } while (--op);\n+                            from = window - OFF;\n+                            if (write < len) {  /* some from start of window */\n+                                op = write;\n+                                len -= op;\n+                                do {\n+                                    PUP(out) = PUP(from);\n+                                } while (--op);\n+                                from = out - dist;      /* rest from output */\n+                            }\n+                        }\n+                    }\n+                    else {                      /* contiguous in window */\n+                        from += write - op;\n+                        if (op < len) {         /* some from window */\n+                            len -= op;\n+                            do {\n+                                PUP(out) = PUP(from);\n+                            } while (--op);\n+                            from = out - dist;  /* rest from output */\n+                        }\n+                    }\n+                    while (len > 2) {\n+                        PUP(out) = PUP(from);\n+                        PUP(out) = PUP(from);\n+                        PUP(out) = PUP(from);\n+                        len -= 3;\n+                    }\n+                    if (len) {\n+                        PUP(out) = PUP(from);\n+                        if (len > 1)\n+                            PUP(out) = PUP(from);\n+                    }\n+                }\n+                else {\n+                    from = out - dist;          /* copy direct from output */\n+                    do {                        /* minimum length is three */\n+                        PUP(out) = PUP(from);\n+                        PUP(out) = PUP(from);\n+                        PUP(out) = PUP(from);\n+                        len -= 3;\n+                    } while (len > 2);\n+                    if (len) {\n+                        PUP(out) = PUP(from);\n+                        if (len > 1)\n+                            PUP(out) = PUP(from);\n+                    }\n+                }\n             }\n+            else if ((op & 64) == 0) {          /* 2nd level distance code */\n+                this = dcode[this.val + (hold & ((1U << op) - 1))];\n+                goto dodist;\n+            }\n+            else {\n+                strm->msg = (char *)\"invalid distance code\";\n+                state->mode = BAD;\n+                break;\n+            }\n+        }\n+        else if ((op & 64) == 0) {              /* 2nd level length code */\n+            this = lcode[this.val + (hold & ((1U << op) - 1))];\n+            goto dolen;\n+        }\n+        else if (op & 32) {                     /* end-of-block */\n+            Tracevv((stderr, \"inflate:         end of block\\n\"));\n+            state->mode = TYPE;\n+            break;\n+        }\n+        else {\n+            strm->msg = (char *)\"invalid literal/length code\";\n+            state->mode = BAD;\n             break;\n-          }\n-          else if ((e & 64) == 0)\n-          {\n-            t += t->base;\n-            e = (t += ((uInt)b & inflate_mask[e]))->exop;\n-          }\n-          else\n-          {\n-            z->msg = (char*)\"invalid distance code\";\n-            UNGRAB\n-            UPDATE\n-            return Z_DATA_ERROR;\n-          }\n-        } while (1);\n-        break;\n-      }\n-      if ((e & 64) == 0)\n-      {\n-        t += t->base;\n-        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)\n-        {\n-          DUMPBITS(t->bits)\n-          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?\n-                    \"inflate:         * literal '%c'\\n\" :\n-                    \"inflate:         * literal 0x%02x\\n\", t->base));\n-          *q++ = (Byte)t->base;\n-          m--;\n-          break;\n         }\n-      }\n-      else if (e & 32)\n-      {\n-        Tracevv((stderr, \"inflate:         * end of block\\n\"));\n-        UNGRAB\n-        UPDATE\n-        return Z_STREAM_END;\n-      }\n-      else\n-      {\n-        z->msg = (char*)\"invalid literal/length code\";\n-        UNGRAB\n-        UPDATE\n-        return Z_DATA_ERROR;\n-      }\n-    } while (1);\n-  } while (m >= 258 && n >= 10);\n-\n-  /* not enough input or output--restore pointers and return */\n-  UNGRAB\n-  UPDATE\n-  return Z_OK;\n+    } while (in < last && out < end);\n+\n+    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n+    len = bits >> 3;\n+    in -= len;\n+    bits -= len << 3;\n+    hold &= (1U << bits) - 1;\n+\n+    /* update state and return */\n+    strm->next_in = in + OFF;\n+    strm->next_out = out + OFF;\n+    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n+    strm->avail_out = (unsigned)(out < end ?\n+                                 257 + (end - out) : 257 - (out - end));\n+    state->hold = hold;\n+    state->bits = bits;\n+    return;\n }\n+\n+/*\n+   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):\n+   - Using bit fields for code structure\n+   - Different op definition to avoid & for extra bits (do & for table bits)\n+   - Three separate decoding do-loops for direct, window, and write == 0\n+   - Special case for distance > 1 copies to do overlapped load and store copy\n+   - Explicit branch predictions (based on measured branch probabilities)\n+   - Deferring match copy and interspersed it with decoding subsequent codes\n+   - Swapping literal/length else\n+   - Swapping window/direct else\n+   - Larger unrolled copy loops (three is about right)\n+   - Moving len -= 3 statement into middle of loop\n+ */\n+\n+#endif /* !ASMINF */"}, {"sha": "1e88d2d97b568d37c44800c5aa7e54cfa33d46d3", "filename": "zlib/inffast.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finffast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finffast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finffast.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,17 +1,11 @@\n /* inffast.h -- header to use inffast.c\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /* WARNING: this file should *not* be used by applications. It is\n    part of the implementation of the compression library and is\n    subject to change. Applications should only use zlib.h.\n  */\n \n-extern int inflate_fast OF((\n-    uInt,\n-    uInt,\n-    inflate_huft *,\n-    inflate_huft *,\n-    inflate_blocks_statef *,\n-    z_streamp ));\n+void inflate_fast OF((z_streamp strm, unsigned start));"}, {"sha": "75ed4b5978de4be3c44ad48a060b75500f17a0a2", "filename": "zlib/inffixed.h", "status": "modified", "additions": 92, "deletions": 149, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finffixed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finffixed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finffixed.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,151 +1,94 @@\n-/* inffixed.h -- table for decoding fixed codes\n- * Generated automatically by the maketree.c program\n- */\n+    /* inffixed.h -- table for decoding fixed codes\n+     * Generated automatically by makefixed().\n+     */\n \n-/* WARNING: this file should *not* be used by applications. It is\n-   part of the implementation of the compression library and is\n-   subject to change. Applications should only use zlib.h.\n- */\n+    /* WARNING: this file should *not* be used by applications. It\n+       is part of the implementation of the compression library and\n+       is subject to change. Applications should only use zlib.h.\n+     */\n \n-local uInt fixed_bl = 9;\n-local uInt fixed_bd = 5;\n-local inflate_huft fixed_tl[] = {\n-    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},\n-    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},\n-    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},\n-    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},\n-    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},\n-    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},\n-    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},\n-    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},\n-    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},\n-    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},\n-    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},\n-    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},\n-    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},\n-    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},\n-    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},\n-    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},\n-    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},\n-    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},\n-    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},\n-    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},\n-    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},\n-    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},\n-    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},\n-    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},\n-    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},\n-    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},\n-    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},\n-    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},\n-    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},\n-    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},\n-    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},\n-    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},\n-    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},\n-    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},\n-    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},\n-    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},\n-    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},\n-    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},\n-    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},\n-    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},\n-    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},\n-    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},\n-    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},\n-    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},\n-    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},\n-    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},\n-    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},\n-    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},\n-    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},\n-    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},\n-    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},\n-    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},\n-    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},\n-    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},\n-    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},\n-    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},\n-    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},\n-    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},\n-    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},\n-    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},\n-    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},\n-    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},\n-    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},\n-    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},\n-    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},\n-    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},\n-    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},\n-    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},\n-    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},\n-    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},\n-    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},\n-    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},\n-    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},\n-    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},\n-    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},\n-    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},\n-    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},\n-    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},\n-    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},\n-    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},\n-    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},\n-    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},\n-    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},\n-    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},\n-    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},\n-    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},\n-    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},\n-    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},\n-    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},\n-    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},\n-    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},\n-    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},\n-    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},\n-    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},\n-    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},\n-    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},\n-    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},\n-    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},\n-    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},\n-    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},\n-    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},\n-    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},\n-    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},\n-    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},\n-    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},\n-    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},\n-    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},\n-    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},\n-    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},\n-    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},\n-    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},\n-    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},\n-    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},\n-    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},\n-    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},\n-    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},\n-    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},\n-    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},\n-    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},\n-    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},\n-    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},\n-    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},\n-    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},\n-    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},\n-    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},\n-    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},\n-    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},\n-    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}\n-  };\n-local inflate_huft fixed_td[] = {\n-    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},\n-    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},\n-    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},\n-    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},\n-    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},\n-    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},\n-    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},\n-    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}\n-  };\n+    static const code lenfix[512] = {\n+        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},\n+        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},\n+        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},\n+        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},\n+        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},\n+        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},\n+        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},\n+        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},\n+        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},\n+        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},\n+        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},\n+        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},\n+        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},\n+        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},\n+        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},\n+        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},\n+        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},\n+        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},\n+        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},\n+        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},\n+        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},\n+        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},\n+        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},\n+        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},\n+        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},\n+        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},\n+        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},\n+        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},\n+        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},\n+        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},\n+        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},\n+        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},\n+        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},\n+        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},\n+        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},\n+        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},\n+        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},\n+        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},\n+        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},\n+        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},\n+        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},\n+        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},\n+        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},\n+        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},\n+        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},\n+        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},\n+        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},\n+        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},\n+        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},\n+        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},\n+        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},\n+        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},\n+        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},\n+        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},\n+        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},\n+        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},\n+        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},\n+        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},\n+        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},\n+        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},\n+        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},\n+        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},\n+        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},\n+        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},\n+        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},\n+        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},\n+        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},\n+        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},\n+        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},\n+        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},\n+        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},\n+        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},\n+        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},\n+        {0,9,255}\n+    };\n+\n+    static const code distfix[32] = {\n+        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},\n+        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},\n+        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},\n+        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},\n+        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},\n+        {22,5,193},{64,5,0}\n+    };"}, {"sha": "a53b5c7446ebd7f097942faa28618cb897a51169", "filename": "zlib/inflate.c", "status": "modified", "additions": 1233, "deletions": 329, "changes": 1562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finflate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finflate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finflate.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,366 +1,1270 @@\n-/* inflate.c -- zlib interface to inflate modules\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+/* inflate.c -- zlib decompression\n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n+ */\n+\n+/*\n+ * Change history:\n+ *\n+ * 1.2.beta0    24 Nov 2002\n+ * - First version -- complete rewrite of inflate to simplify code, avoid\n+ *   creation of window when not needed, minimize use of window when it is\n+ *   needed, make inffast.c even faster, implement gzip decoding, and to\n+ *   improve code readability and style over the previous zlib inflate code\n+ *\n+ * 1.2.beta1    25 Nov 2002\n+ * - Use pointers for available input and output checking in inffast.c\n+ * - Remove input and output counters in inffast.c\n+ * - Change inffast.c entry and loop from avail_in >= 7 to >= 6\n+ * - Remove unnecessary second byte pull from length extra in inffast.c\n+ * - Unroll direct copy to three copies per loop in inffast.c\n+ *\n+ * 1.2.beta2    4 Dec 2002\n+ * - Change external routine names to reduce potential conflicts\n+ * - Correct filename to inffixed.h for fixed tables in inflate.c\n+ * - Make hbuf[] unsigned char to match parameter type in inflate.c\n+ * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)\n+ *   to avoid negation problem on Alphas (64 bit) in inflate.c\n+ *\n+ * 1.2.beta3    22 Dec 2002\n+ * - Add comments on state->bits assertion in inffast.c\n+ * - Add comments on op field in inftrees.h\n+ * - Fix bug in reuse of allocated window after inflateReset()\n+ * - Remove bit fields--back to byte structure for speed\n+ * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths\n+ * - Change post-increments to pre-increments in inflate_fast(), PPC biased?\n+ * - Add compile time option, POSTINC, to use post-increments instead (Intel?)\n+ * - Make MATCH copy in inflate() much faster for when inflate_fast() not used\n+ * - Use local copies of stream next and avail values, as well as local bit\n+ *   buffer and bit count in inflate()--for speed when inflate_fast() not used\n+ *\n+ * 1.2.beta4    1 Jan 2003\n+ * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings\n+ * - Move a comment on output buffer sizes from inffast.c to inflate.c\n+ * - Add comments in inffast.c to introduce the inflate_fast() routine\n+ * - Rearrange window copies in inflate_fast() for speed and simplification\n+ * - Unroll last copy for window match in inflate_fast()\n+ * - Use local copies of window variables in inflate_fast() for speed\n+ * - Pull out common write == 0 case for speed in inflate_fast()\n+ * - Make op and len in inflate_fast() unsigned for consistency\n+ * - Add FAR to lcode and dcode declarations in inflate_fast()\n+ * - Simplified bad distance check in inflate_fast()\n+ * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new\n+ *   source file infback.c to provide a call-back interface to inflate for\n+ *   programs like gzip and unzip -- uses window as output buffer to avoid\n+ *   window copying\n+ *\n+ * 1.2.beta5    1 Jan 2003\n+ * - Improved inflateBack() interface to allow the caller to provide initial\n+ *   input in strm.\n+ * - Fixed stored blocks bug in inflateBack()\n+ *\n+ * 1.2.beta6    4 Jan 2003\n+ * - Added comments in inffast.c on effectiveness of POSTINC\n+ * - Typecasting all around to reduce compiler warnings\n+ * - Changed loops from while (1) or do {} while (1) to for (;;), again to\n+ *   make compilers happy\n+ * - Changed type of window in inflateBackInit() to unsigned char *\n+ *\n+ * 1.2.beta7    27 Jan 2003\n+ * - Changed many types to unsigned or unsigned short to avoid warnings\n+ * - Added inflateCopy() function\n+ *\n+ * 1.2.0        9 Mar 2003\n+ * - Changed inflateBack() interface to provide separate opaque descriptors\n+ *   for the in() and out() functions\n+ * - Changed inflateBack() argument and in_func typedef to swap the length\n+ *   and buffer address return values for the input function\n+ * - Check next_in and next_out for Z_NULL on entry to inflate()\n+ *\n+ * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.\n  */\n \n #include \"zutil.h\"\n-#include \"infblock.h\"\n-\n-struct inflate_blocks_state {int dummy;}; /* for buggy compilers */\n-\n-typedef enum {\n-      METHOD,   /* waiting for method byte */\n-      FLAG,     /* waiting for flag byte */\n-      DICT4,    /* four dictionary check bytes to go */\n-      DICT3,    /* three dictionary check bytes to go */\n-      DICT2,    /* two dictionary check bytes to go */\n-      DICT1,    /* one dictionary check byte to go */\n-      DICT0,    /* waiting for inflateSetDictionary */\n-      BLOCKS,   /* decompressing blocks */\n-      CHECK4,   /* four check bytes to go */\n-      CHECK3,   /* three check bytes to go */\n-      CHECK2,   /* two check bytes to go */\n-      CHECK1,   /* one check byte to go */\n-      DONE,     /* finished check, done */\n-      BAD}      /* got an error--stay here */\n-inflate_mode;\n-\n-/* inflate private state */\n-struct internal_state {\n-\n-  /* mode */\n-  inflate_mode  mode;   /* current inflate mode */\n-\n-  /* mode dependent information */\n-  union {\n-    uInt method;        /* if FLAGS, method byte */\n-    struct {\n-      uLong was;                /* computed check value */\n-      uLong need;               /* stream check value */\n-    } check;            /* if CHECK, check values to compare */\n-    uInt marker;        /* if BAD, inflateSync's marker bytes count */\n-  } sub;        /* submode */\n-\n-  /* mode independent information */\n-  int  nowrap;          /* flag for no wrapper */\n-  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */\n-  inflate_blocks_statef \n-    *blocks;            /* current inflate_blocks state */\n-\n-};\n-\n-\n-int ZEXPORT inflateReset(z)\n-z_streamp z;\n-{\n-  if (z == Z_NULL || z->state == Z_NULL)\n-    return Z_STREAM_ERROR;\n-  z->total_in = z->total_out = 0;\n-  z->msg = Z_NULL;\n-  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;\n-  inflate_blocks_reset(z->state->blocks, z, Z_NULL);\n-  Tracev((stderr, \"inflate: reset\\n\"));\n-  return Z_OK;\n-}\n+#include \"inftrees.h\"\n+#include \"inflate.h\"\n+#include \"inffast.h\"\n \n+#ifdef MAKEFIXED\n+#  ifndef BUILDFIXED\n+#    define BUILDFIXED\n+#  endif\n+#endif\n+\n+/* function prototypes */\n+local void fixedtables OF((struct inflate_state FAR *state));\n+local int updatewindow OF((z_streamp strm, unsigned out));\n+#ifdef BUILDFIXED\n+   void makefixed OF((void));\n+#endif\n+local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,\n+                              unsigned len));\n \n-int ZEXPORT inflateEnd(z)\n-z_streamp z;\n+int ZEXPORT inflateReset(strm)\n+z_streamp strm;\n {\n-  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)\n-    return Z_STREAM_ERROR;\n-  if (z->state->blocks != Z_NULL)\n-    inflate_blocks_free(z->state->blocks, z);\n-  ZFREE(z, z->state);\n-  z->state = Z_NULL;\n-  Tracev((stderr, \"inflate: end\\n\"));\n-  return Z_OK;\n-}\n+    struct inflate_state FAR *state;\n \n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+    strm->total_in = strm->total_out = state->total = 0;\n+    strm->msg = Z_NULL;\n+    state->mode = HEAD;\n+    state->last = 0;\n+    state->havedict = 0;\n+    state->wsize = 0;\n+    state->whave = 0;\n+    state->hold = 0;\n+    state->bits = 0;\n+    state->lencode = state->distcode = state->next = state->codes;\n+    Tracev((stderr, \"inflate: reset\\n\"));\n+    return Z_OK;\n+}\n \n-int ZEXPORT inflateInit2_(z, w, version, stream_size)\n-z_streamp z;\n-int w;\n+int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)\n+z_streamp strm;\n+int windowBits;\n const char *version;\n int stream_size;\n {\n-  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n-      stream_size != sizeof(z_stream))\n-      return Z_VERSION_ERROR;\n-\n-  /* initialize state */\n-  if (z == Z_NULL)\n-    return Z_STREAM_ERROR;\n-  z->msg = Z_NULL;\n-  if (z->zalloc == Z_NULL)\n-  {\n-    z->zalloc = zcalloc;\n-    z->opaque = (voidpf)0;\n-  }\n-  if (z->zfree == Z_NULL) z->zfree = zcfree;\n-  if ((z->state = (struct internal_state FAR *)\n-       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)\n-    return Z_MEM_ERROR;\n-  z->state->blocks = Z_NULL;\n-\n-  /* handle undocumented nowrap option (no zlib header or check) */\n-  z->state->nowrap = 0;\n-  if (w < 0)\n-  {\n-    w = - w;\n-    z->state->nowrap = 1;\n-  }\n-\n-  /* set window size */\n-  if (w < 8 || w > 15)\n-  {\n-    inflateEnd(z);\n-    return Z_STREAM_ERROR;\n-  }\n-  z->state->wbits = (uInt)w;\n-\n-  /* create inflate_blocks state */\n-  if ((z->state->blocks =\n-      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))\n-      == Z_NULL)\n-  {\n-    inflateEnd(z);\n-    return Z_MEM_ERROR;\n-  }\n-  Tracev((stderr, \"inflate: allocated\\n\"));\n-\n-  /* reset state */\n-  inflateReset(z);\n-  return Z_OK;\n-}\n+    struct inflate_state FAR *state;\n \n+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n+        stream_size != (int)(sizeof(z_stream)))\n+        return Z_VERSION_ERROR;\n+    if (strm == Z_NULL) return Z_STREAM_ERROR;\n+    strm->msg = Z_NULL;                 /* in case we return an error */\n+    if (strm->zalloc == (alloc_func)0) {\n+        strm->zalloc = zcalloc;\n+        strm->opaque = (voidpf)0;\n+    }\n+    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n+    state = (struct inflate_state FAR *)\n+            ZALLOC(strm, 1, sizeof(struct inflate_state));\n+    if (state == Z_NULL) return Z_MEM_ERROR;\n+    Tracev((stderr, \"inflate: allocated\\n\"));\n+    strm->state = (voidpf)state;\n+    if (windowBits < 0) {\n+        state->wrap = 0;\n+        windowBits = -windowBits;\n+    }\n+    else {\n+        state->wrap = (windowBits >> 4) + 1;\n+#ifdef GUNZIP\n+        if (windowBits < 48) windowBits &= 15;\n+#endif\n+    }\n+    if (windowBits < 8 || windowBits > 15) {\n+        ZFREE(strm, state);\n+        strm->state = Z_NULL;\n+        return Z_STREAM_ERROR;\n+    }\n+    state->wbits = (unsigned)windowBits;\n+    state->window = Z_NULL;\n+    return inflateReset(strm);\n+}\n \n-int ZEXPORT inflateInit_(z, version, stream_size)\n-z_streamp z;\n+int ZEXPORT inflateInit_(strm, version, stream_size)\n+z_streamp strm;\n const char *version;\n int stream_size;\n {\n-  return inflateInit2_(z, DEF_WBITS, version, stream_size);\n+    return inflateInit2_(strm, DEF_WBITS, version, stream_size);\n+}\n+\n+/*\n+   Return state with length and distance decoding tables and index sizes set to\n+   fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n+   If BUILDFIXED is defined, then instead this routine builds the tables the\n+   first time it's called, and returns those tables the first time and\n+   thereafter.  This reduces the size of the code by about 2K bytes, in\n+   exchange for a little execution time.  However, BUILDFIXED should not be\n+   used for threaded applications, since the rewriting of the tables and virgin\n+   may not be thread-safe.\n+ */\n+local void fixedtables(state)\n+struct inflate_state FAR *state;\n+{\n+#ifdef BUILDFIXED\n+    static int virgin = 1;\n+    static code *lenfix, *distfix;\n+    static code fixed[544];\n+\n+    /* build fixed huffman tables if first call (may not be thread safe) */\n+    if (virgin) {\n+        unsigned sym, bits;\n+        static code *next;\n+\n+        /* literal/length table */\n+        sym = 0;\n+        while (sym < 144) state->lens[sym++] = 8;\n+        while (sym < 256) state->lens[sym++] = 9;\n+        while (sym < 280) state->lens[sym++] = 7;\n+        while (sym < 288) state->lens[sym++] = 8;\n+        next = fixed;\n+        lenfix = next;\n+        bits = 9;\n+        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);\n+\n+        /* distance table */\n+        sym = 0;\n+        while (sym < 32) state->lens[sym++] = 5;\n+        distfix = next;\n+        bits = 5;\n+        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);\n+\n+        /* do this just once */\n+        virgin = 0;\n+    }\n+#else /* !BUILDFIXED */\n+#   include \"inffixed.h\"\n+#endif /* BUILDFIXED */\n+    state->lencode = lenfix;\n+    state->lenbits = 9;\n+    state->distcode = distfix;\n+    state->distbits = 5;\n }\n \n+#ifdef MAKEFIXED\n+#include <stdio.h>\n \n-#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}\n-#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)\n+/*\n+   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also\n+   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes\n+   those tables to stdout, which would be piped to inffixed.h.  A small program\n+   can simply call makefixed to do this:\n \n-int ZEXPORT inflate(z, f)\n-z_streamp z;\n-int f;\n+    void makefixed(void);\n+\n+    int main(void)\n+    {\n+        makefixed();\n+        return 0;\n+    }\n+\n+   Then that can be linked with zlib built with MAKEFIXED defined and run:\n+\n+    a.out > inffixed.h\n+ */\n+void makefixed()\n {\n-  int r;\n-  uInt b;\n-\n-  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)\n-    return Z_STREAM_ERROR;\n-  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n-  r = Z_BUF_ERROR;\n-  while (1) switch (z->state->mode)\n-  {\n-    case METHOD:\n-      NEEDBYTE\n-      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)\n-      {\n-        z->state->mode = BAD;\n-        z->msg = (char*)\"unknown compression method\";\n-        z->state->sub.marker = 5;       /* can't try inflateSync */\n-        break;\n-      }\n-      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)\n-      {\n-        z->state->mode = BAD;\n-        z->msg = (char*)\"invalid window size\";\n-        z->state->sub.marker = 5;       /* can't try inflateSync */\n-        break;\n-      }\n-      z->state->mode = FLAG;\n-    case FLAG:\n-      NEEDBYTE\n-      b = NEXTBYTE;\n-      if (((z->state->sub.method << 8) + b) % 31)\n-      {\n-        z->state->mode = BAD;\n-        z->msg = (char*)\"incorrect header check\";\n-        z->state->sub.marker = 5;       /* can't try inflateSync */\n-        break;\n-      }\n-      Tracev((stderr, \"inflate: zlib header ok\\n\"));\n-      if (!(b & PRESET_DICT))\n-      {\n-        z->state->mode = BLOCKS;\n-        break;\n-      }\n-      z->state->mode = DICT4;\n-    case DICT4:\n-      NEEDBYTE\n-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;\n-      z->state->mode = DICT3;\n-    case DICT3:\n-      NEEDBYTE\n-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;\n-      z->state->mode = DICT2;\n-    case DICT2:\n-      NEEDBYTE\n-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;\n-      z->state->mode = DICT1;\n-    case DICT1:\n-      NEEDBYTE\n-      z->state->sub.check.need += (uLong)NEXTBYTE;\n-      z->adler = z->state->sub.check.need;\n-      z->state->mode = DICT0;\n-      return Z_NEED_DICT;\n-    case DICT0:\n-      z->state->mode = BAD;\n-      z->msg = (char*)\"need dictionary\";\n-      z->state->sub.marker = 0;       /* can try inflateSync */\n-      return Z_STREAM_ERROR;\n-    case BLOCKS:\n-      r = inflate_blocks(z->state->blocks, z, r);\n-      if (r == Z_DATA_ERROR)\n-      {\n-        z->state->mode = BAD;\n-        z->state->sub.marker = 0;       /* can try inflateSync */\n-        break;\n-      }\n-      if (r == Z_OK)\n-        r = f;\n-      if (r != Z_STREAM_END)\n-        return r;\n-      r = f;\n-      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);\n-      if (z->state->nowrap)\n-      {\n-        z->state->mode = DONE;\n-        break;\n-      }\n-      z->state->mode = CHECK4;\n-    case CHECK4:\n-      NEEDBYTE\n-      z->state->sub.check.need = (uLong)NEXTBYTE << 24;\n-      z->state->mode = CHECK3;\n-    case CHECK3:\n-      NEEDBYTE\n-      z->state->sub.check.need += (uLong)NEXTBYTE << 16;\n-      z->state->mode = CHECK2;\n-    case CHECK2:\n-      NEEDBYTE\n-      z->state->sub.check.need += (uLong)NEXTBYTE << 8;\n-      z->state->mode = CHECK1;\n-    case CHECK1:\n-      NEEDBYTE\n-      z->state->sub.check.need += (uLong)NEXTBYTE;\n-\n-      if (z->state->sub.check.was != z->state->sub.check.need)\n-      {\n-        z->state->mode = BAD;\n-        z->msg = (char*)\"incorrect data check\";\n-        z->state->sub.marker = 5;       /* can't try inflateSync */\n+    unsigned low, size;\n+    struct inflate_state state;\n+\n+    fixedtables(&state);\n+    puts(\"    /* inffixed.h -- table for decoding fixed codes\");\n+    puts(\"     * Generated automatically by makefixed().\");\n+    puts(\"     */\");\n+    puts(\"\");\n+    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n+    puts(\"       It is part of the implementation of this library and is\");\n+    puts(\"       subject to change. Applications should only use zlib.h.\");\n+    puts(\"     */\");\n+    puts(\"\");\n+    size = 1U << 9;\n+    printf(\"    static const code lenfix[%u] = {\", size);\n+    low = 0;\n+    for (;;) {\n+        if ((low % 7) == 0) printf(\"\\n        \");\n+        printf(\"{%u,%u,%d}\", state.lencode[low].op, state.lencode[low].bits,\n+               state.lencode[low].val);\n+        if (++low == size) break;\n+        putchar(',');\n+    }\n+    puts(\"\\n    };\");\n+    size = 1U << 5;\n+    printf(\"\\n    static const code distfix[%u] = {\", size);\n+    low = 0;\n+    for (;;) {\n+        if ((low % 6) == 0) printf(\"\\n        \");\n+        printf(\"{%u,%u,%d}\", state.distcode[low].op, state.distcode[low].bits,\n+               state.distcode[low].val);\n+        if (++low == size) break;\n+        putchar(',');\n+    }\n+    puts(\"\\n    };\");\n+}\n+#endif /* MAKEFIXED */\n+\n+/*\n+   Update the window with the last wsize (normally 32K) bytes written before\n+   returning.  If window does not exist yet, create it.  This is only called\n+   when a window is already in use, or when output has been written during this\n+   inflate call, but the end of the deflate stream has not been reached yet.\n+   It is also called to create a window for dictionary data when a dictionary\n+   is loaded.\n+\n+   Providing output buffers larger than 32K to inflate() should provide a speed\n+   advantage, since only the last 32K of output is copied to the sliding window\n+   upon return from inflate(), and since all distances after the first 32K of\n+   output will fall in the output data, making match copies simpler and faster.\n+   The advantage may be dependent on the size of the processor's data caches.\n+ */\n+local int updatewindow(strm, out)\n+z_streamp strm;\n+unsigned out;\n+{\n+    struct inflate_state FAR *state;\n+    unsigned copy, dist;\n+\n+    state = (struct inflate_state FAR *)strm->state;\n+\n+    /* if it hasn't been done already, allocate space for the window */\n+    if (state->window == Z_NULL) {\n+        state->window = (unsigned char FAR *)\n+                        ZALLOC(strm, 1U << state->wbits,\n+                               sizeof(unsigned char));\n+        if (state->window == Z_NULL) return 1;\n+    }\n+\n+    /* if window not in use yet, initialize */\n+    if (state->wsize == 0) {\n+        state->wsize = 1U << state->wbits;\n+        state->write = 0;\n+        state->whave = 0;\n+    }\n+\n+    /* copy state->wsize or less output bytes into the circular window */\n+    copy = out - strm->avail_out;\n+    if (copy >= state->wsize) {\n+        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);\n+        state->write = 0;\n+        state->whave = state->wsize;\n+    }\n+    else {\n+        dist = state->wsize - state->write;\n+        if (dist > copy) dist = copy;\n+        zmemcpy(state->window + state->write, strm->next_out - copy, dist);\n+        copy -= dist;\n+        if (copy) {\n+            zmemcpy(state->window, strm->next_out - copy, copy);\n+            state->write = copy;\n+            state->whave = state->wsize;\n+        }\n+        else {\n+            state->write += dist;\n+            if (state->write == state->wsize) state->write = 0;\n+            if (state->whave < state->wsize) state->whave += dist;\n+        }\n+    }\n+    return 0;\n+}\n+\n+/* Macros for inflate(): */\n+\n+/* check function to use adler32() for zlib or crc32() for gzip */\n+#ifdef GUNZIP\n+#  define UPDATE(check, buf, len) \\\n+    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))\n+#else\n+#  define UPDATE(check, buf, len) adler32(check, buf, len)\n+#endif\n+\n+/* check macros for header crc */\n+#ifdef GUNZIP\n+#  define CRC2(check, word) \\\n+    do { \\\n+        hbuf[0] = (unsigned char)(word); \\\n+        hbuf[1] = (unsigned char)((word) >> 8); \\\n+        check = crc32(check, hbuf, 2); \\\n+    } while (0)\n+\n+#  define CRC4(check, word) \\\n+    do { \\\n+        hbuf[0] = (unsigned char)(word); \\\n+        hbuf[1] = (unsigned char)((word) >> 8); \\\n+        hbuf[2] = (unsigned char)((word) >> 16); \\\n+        hbuf[3] = (unsigned char)((word) >> 24); \\\n+        check = crc32(check, hbuf, 4); \\\n+    } while (0)\n+#endif\n+\n+/* Load registers with state in inflate() for speed */\n+#define LOAD() \\\n+    do { \\\n+        put = strm->next_out; \\\n+        left = strm->avail_out; \\\n+        next = strm->next_in; \\\n+        have = strm->avail_in; \\\n+        hold = state->hold; \\\n+        bits = state->bits; \\\n+    } while (0)\n+\n+/* Restore state from registers in inflate() */\n+#define RESTORE() \\\n+    do { \\\n+        strm->next_out = put; \\\n+        strm->avail_out = left; \\\n+        strm->next_in = next; \\\n+        strm->avail_in = have; \\\n+        state->hold = hold; \\\n+        state->bits = bits; \\\n+    } while (0)\n+\n+/* Clear the input bit accumulator */\n+#define INITBITS() \\\n+    do { \\\n+        hold = 0; \\\n+        bits = 0; \\\n+    } while (0)\n+\n+/* Get a byte of input into the bit accumulator, or return from inflate()\n+   if there is no input available. */\n+#define PULLBYTE() \\\n+    do { \\\n+        if (have == 0) goto inf_leave; \\\n+        have--; \\\n+        hold += (unsigned long)(*next++) << bits; \\\n+        bits += 8; \\\n+    } while (0)\n+\n+/* Assure that there are at least n bits in the bit accumulator.  If there is\n+   not enough available input to do that, then return from inflate(). */\n+#define NEEDBITS(n) \\\n+    do { \\\n+        while (bits < (unsigned)(n)) \\\n+            PULLBYTE(); \\\n+    } while (0)\n+\n+/* Return the low n bits of the bit accumulator (n < 16) */\n+#define BITS(n) \\\n+    ((unsigned)hold & ((1U << (n)) - 1))\n+\n+/* Remove n bits from the bit accumulator */\n+#define DROPBITS(n) \\\n+    do { \\\n+        hold >>= (n); \\\n+        bits -= (unsigned)(n); \\\n+    } while (0)\n+\n+/* Remove zero to seven bits as needed to go to a byte boundary */\n+#define BYTEBITS() \\\n+    do { \\\n+        hold >>= bits & 7; \\\n+        bits -= bits & 7; \\\n+    } while (0)\n+\n+/* Reverse the bytes in a 32-bit value */\n+#define REVERSE(q) \\\n+    ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \\\n+     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))\n+\n+/*\n+   inflate() uses a state machine to process as much input data and generate as\n+   much output data as possible before returning.  The state machine is\n+   structured roughly as follows:\n+\n+    for (;;) switch (state) {\n+    ...\n+    case STATEn:\n+        if (not enough input data or output space to make progress)\n+            return;\n+        ... make progress ...\n+        state = STATEm;\n         break;\n-      }\n-      Tracev((stderr, \"inflate: zlib check ok\\n\"));\n-      z->state->mode = DONE;\n-    case DONE:\n-      return Z_STREAM_END;\n-    case BAD:\n-      return Z_DATA_ERROR;\n-    default:\n-      return Z_STREAM_ERROR;\n-  }\n-#ifdef NEED_DUMMY_RETURN\n-  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */\n+    ...\n+    }\n+\n+   so when inflate() is called again, the same case is attempted again, and\n+   if the appropriate resources are provided, the machine proceeds to the\n+   next state.  The NEEDBITS() macro is usually the way the state evaluates\n+   whether it can proceed or should return.  NEEDBITS() does the return if\n+   the requested bits are not available.  The typical use of the BITS macros\n+   is:\n+\n+        NEEDBITS(n);\n+        ... do something with BITS(n) ...\n+        DROPBITS(n);\n+\n+   where NEEDBITS(n) either returns from inflate() if there isn't enough\n+   input left to load n bits into the accumulator, or it continues.  BITS(n)\n+   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops\n+   the low n bits off the accumulator.  INITBITS() clears the accumulator\n+   and sets the number of available bits to zero.  BYTEBITS() discards just\n+   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()\n+   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.\n+\n+   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return\n+   if there is no input available.  The decoding of variable length codes uses\n+   PULLBYTE() directly in order to pull just enough bytes to decode the next\n+   code, and no more.\n+\n+   Some states loop until they get enough input, making sure that enough\n+   state information is maintained to continue the loop where it left off\n+   if NEEDBITS() returns in the loop.  For example, want, need, and keep\n+   would all have to actually be part of the saved state in case NEEDBITS()\n+   returns:\n+\n+    case STATEw:\n+        while (want < need) {\n+            NEEDBITS(n);\n+            keep[want++] = BITS(n);\n+            DROPBITS(n);\n+        }\n+        state = STATEx;\n+    case STATEx:\n+\n+   As shown above, if the next state is also the next case, then the break\n+   is omitted.\n+\n+   A state may also return if there is not enough output space available to\n+   complete that state.  Those states are copying stored data, writing a\n+   literal byte, and copying a matching string.\n+\n+   When returning, a \"goto inf_leave\" is used to update the total counters,\n+   update the check value, and determine whether any progress has been made\n+   during that inflate() call in order to return the proper return code.\n+   Progress is defined as a change in either strm->avail_in or strm->avail_out.\n+   When there is a window, goto inf_leave will update the window with the last\n+   output written.  If a goto inf_leave occurs in the middle of decompression\n+   and there is no window currently, goto inf_leave will create one and copy\n+   output to the window for the next call of inflate().\n+\n+   In this implementation, the flush parameter of inflate() only affects the\n+   return code (per zlib.h).  inflate() always writes as much as possible to\n+   strm->next_out, given the space available and the provided input--the effect\n+   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers\n+   the allocation of and copying into a sliding window until necessary, which\n+   provides the effect documented in zlib.h for Z_FINISH when the entire input\n+   stream available.  So the only thing the flush parameter actually does is:\n+   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it\n+   will return Z_BUF_ERROR if it has not reached the end of the stream.\n+ */\n+\n+int ZEXPORT inflate(strm, flush)\n+z_streamp strm;\n+int flush;\n+{\n+    struct inflate_state FAR *state;\n+    unsigned char FAR *next;    /* next input */\n+    unsigned char FAR *put;     /* next output */\n+    unsigned have, left;        /* available input and output */\n+    unsigned long hold;         /* bit buffer */\n+    unsigned bits;              /* bits in bit buffer */\n+    unsigned in, out;           /* save starting available input and output */\n+    unsigned copy;              /* number of stored or match bytes to copy */\n+    unsigned char FAR *from;    /* where to copy match bytes from */\n+    code this;                  /* current decoding table entry */\n+    code last;                  /* parent table entry */\n+    unsigned len;               /* length to copy for repeats, bits to drop */\n+    int ret;                    /* return code */\n+#ifdef GUNZIP\n+    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n+#endif\n+    static const unsigned short order[19] = /* permutation of code lengths */\n+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||\n+        (strm->next_in == Z_NULL && strm->avail_in != 0))\n+        return Z_STREAM_ERROR;\n+\n+    state = (struct inflate_state FAR *)strm->state;\n+    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */\n+    LOAD();\n+    in = have;\n+    out = left;\n+    ret = Z_OK;\n+    for (;;)\n+        switch (state->mode) {\n+        case HEAD:\n+            if (state->wrap == 0) {\n+                state->mode = TYPEDO;\n+                break;\n+            }\n+            NEEDBITS(16);\n+#ifdef GUNZIP\n+            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n+                state->check = crc32(0L, Z_NULL, 0);\n+                CRC2(state->check, hold);\n+                INITBITS();\n+                state->mode = FLAGS;\n+                break;\n+            }\n+            state->flags = 0;           /* expect zlib header */\n+            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n+#else\n+            if (\n+#endif\n+                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n+                strm->msg = (char *)\"incorrect header check\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            if (BITS(4) != Z_DEFLATED) {\n+                strm->msg = (char *)\"unknown compression method\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            DROPBITS(4);\n+            if (BITS(4) + 8 > state->wbits) {\n+                strm->msg = (char *)\"invalid window size\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n+            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n+            state->mode = hold & 0x200 ? DICTID : TYPE;\n+            INITBITS();\n+            break;\n+#ifdef GUNZIP\n+        case FLAGS:\n+            NEEDBITS(16);\n+            state->flags = (int)(hold);\n+            if ((state->flags & 0xff) != Z_DEFLATED) {\n+                strm->msg = (char *)\"unknown compression method\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            if (state->flags & 0xe000) {\n+                strm->msg = (char *)\"unknown header flags set\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            if (state->flags & 0x0200) CRC2(state->check, hold);\n+            INITBITS();\n+            state->mode = TIME;\n+        case TIME:\n+            NEEDBITS(32);\n+            if (state->flags & 0x0200) CRC4(state->check, hold);\n+            INITBITS();\n+            state->mode = OS;\n+        case OS:\n+            NEEDBITS(16);\n+            if (state->flags & 0x0200) CRC2(state->check, hold);\n+            INITBITS();\n+            state->mode = EXLEN;\n+        case EXLEN:\n+            if (state->flags & 0x0400) {\n+                NEEDBITS(16);\n+                state->length = (unsigned)(hold);\n+                if (state->flags & 0x0200) CRC2(state->check, hold);\n+                INITBITS();\n+            }\n+            state->mode = EXTRA;\n+        case EXTRA:\n+            if (state->flags & 0x0400) {\n+                copy = state->length;\n+                if (copy > have) copy = have;\n+                if (copy) {\n+                    if (state->flags & 0x0200)\n+                        state->check = crc32(state->check, next, copy);\n+                    have -= copy;\n+                    next += copy;\n+                    state->length -= copy;\n+                }\n+                if (state->length) goto inf_leave;\n+            }\n+            state->mode = NAME;\n+        case NAME:\n+            if (state->flags & 0x0800) {\n+                if (have == 0) goto inf_leave;\n+                copy = 0;\n+                do {\n+                    len = (unsigned)(next[copy++]);\n+                } while (len && copy < have);\n+                if (state->flags & 0x02000)\n+                    state->check = crc32(state->check, next, copy);\n+                have -= copy;\n+                next += copy;\n+                if (len) goto inf_leave;\n+            }\n+            state->mode = COMMENT;\n+        case COMMENT:\n+            if (state->flags & 0x1000) {\n+                if (have == 0) goto inf_leave;\n+                copy = 0;\n+                do {\n+                    len = (unsigned)(next[copy++]);\n+                } while (len && copy < have);\n+                if (state->flags & 0x02000)\n+                    state->check = crc32(state->check, next, copy);\n+                have -= copy;\n+                next += copy;\n+                if (len) goto inf_leave;\n+            }\n+            state->mode = HCRC;\n+        case HCRC:\n+            if (state->flags & 0x0200) {\n+                NEEDBITS(16);\n+                if (hold != (state->check & 0xffff)) {\n+                    strm->msg = (char *)\"header crc mismatch\";\n+                    state->mode = BAD;\n+                    break;\n+                }\n+                INITBITS();\n+            }\n+            strm->adler = state->check = crc32(0L, Z_NULL, 0);\n+            state->mode = TYPE;\n+            break;\n+#endif\n+        case DICTID:\n+            NEEDBITS(32);\n+            strm->adler = state->check = REVERSE(hold);\n+            INITBITS();\n+            state->mode = DICT;\n+        case DICT:\n+            if (state->havedict == 0) {\n+                RESTORE();\n+                return Z_NEED_DICT;\n+            }\n+            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n+            state->mode = TYPE;\n+        case TYPE:\n+            if (flush == Z_BLOCK) goto inf_leave;\n+        case TYPEDO:\n+            if (state->last) {\n+                BYTEBITS();\n+                state->mode = CHECK;\n+                break;\n+            }\n+            NEEDBITS(3);\n+            state->last = BITS(1);\n+            DROPBITS(1);\n+            switch (BITS(2)) {\n+            case 0:                             /* stored block */\n+                Tracev((stderr, \"inflate:     stored block%s\\n\",\n+                        state->last ? \" (last)\" : \"\"));\n+                state->mode = STORED;\n+                break;\n+            case 1:                             /* fixed block */\n+                fixedtables(state);\n+                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n+                        state->last ? \" (last)\" : \"\"));\n+                state->mode = LEN;              /* decode codes */\n+                break;\n+            case 2:                             /* dynamic block */\n+                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n+                        state->last ? \" (last)\" : \"\"));\n+                state->mode = TABLE;\n+                break;\n+            case 3:\n+                strm->msg = (char *)\"invalid block type\";\n+                state->mode = BAD;\n+            }\n+            DROPBITS(2);\n+            break;\n+        case STORED:\n+            BYTEBITS();                         /* go to byte boundary */\n+            NEEDBITS(32);\n+            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n+                strm->msg = (char *)\"invalid stored block lengths\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            state->length = (unsigned)hold & 0xffff;\n+            Tracev((stderr, \"inflate:       stored length %u\\n\",\n+                    state->length));\n+            INITBITS();\n+            state->mode = COPY;\n+        case COPY:\n+            copy = state->length;\n+            if (copy) {\n+                if (copy > have) copy = have;\n+                if (copy > left) copy = left;\n+                if (copy == 0) goto inf_leave;\n+                zmemcpy(put, next, copy);\n+                have -= copy;\n+                next += copy;\n+                left -= copy;\n+                put += copy;\n+                state->length -= copy;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:       stored end\\n\"));\n+            state->mode = TYPE;\n+            break;\n+        case TABLE:\n+            NEEDBITS(14);\n+            state->nlen = BITS(5) + 257;\n+            DROPBITS(5);\n+            state->ndist = BITS(5) + 1;\n+            DROPBITS(5);\n+            state->ncode = BITS(4) + 4;\n+            DROPBITS(4);\n+#ifndef PKZIP_BUG_WORKAROUND\n+            if (state->nlen > 286 || state->ndist > 30) {\n+                strm->msg = (char *)\"too many length or distance symbols\";\n+                state->mode = BAD;\n+                break;\n+            }\n #endif\n+            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n+            state->have = 0;\n+            state->mode = LENLENS;\n+        case LENLENS:\n+            while (state->have < state->ncode) {\n+                NEEDBITS(3);\n+                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n+                DROPBITS(3);\n+            }\n+            while (state->have < 19)\n+                state->lens[order[state->have++]] = 0;\n+            state->next = state->codes;\n+            state->lencode = (code const FAR *)(state->next);\n+            state->lenbits = 7;\n+            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n+                                &(state->lenbits), state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid code lengths set\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n+            state->have = 0;\n+            state->mode = CODELENS;\n+        case CODELENS:\n+            while (state->have < state->nlen + state->ndist) {\n+                for (;;) {\n+                    this = state->lencode[BITS(state->lenbits)];\n+                    if ((unsigned)(this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                if (this.val < 16) {\n+                    NEEDBITS(this.bits);\n+                    DROPBITS(this.bits);\n+                    state->lens[state->have++] = this.val;\n+                }\n+                else {\n+                    if (this.val == 16) {\n+                        NEEDBITS(this.bits + 2);\n+                        DROPBITS(this.bits);\n+                        if (state->have == 0) {\n+                            strm->msg = (char *)\"invalid bit length repeat\";\n+                            state->mode = BAD;\n+                            break;\n+                        }\n+                        len = state->lens[state->have - 1];\n+                        copy = 3 + BITS(2);\n+                        DROPBITS(2);\n+                    }\n+                    else if (this.val == 17) {\n+                        NEEDBITS(this.bits + 3);\n+                        DROPBITS(this.bits);\n+                        len = 0;\n+                        copy = 3 + BITS(3);\n+                        DROPBITS(3);\n+                    }\n+                    else {\n+                        NEEDBITS(this.bits + 7);\n+                        DROPBITS(this.bits);\n+                        len = 0;\n+                        copy = 11 + BITS(7);\n+                        DROPBITS(7);\n+                    }\n+                    if (state->have + copy > state->nlen + state->ndist) {\n+                        strm->msg = (char *)\"invalid bit length repeat\";\n+                        state->mode = BAD;\n+                        break;\n+                    }\n+                    while (copy--)\n+                        state->lens[state->have++] = (unsigned short)len;\n+                }\n+            }\n+\n+            /* build code tables */\n+            state->next = state->codes;\n+            state->lencode = (code const FAR *)(state->next);\n+            state->lenbits = 9;\n+            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n+                                &(state->lenbits), state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid literal/lengths set\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            state->distcode = (code const FAR *)(state->next);\n+            state->distbits = 6;\n+            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n+                            &(state->next), &(state->distbits), state->work);\n+            if (ret) {\n+                strm->msg = (char *)\"invalid distances set\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            Tracev((stderr, \"inflate:       codes ok\\n\"));\n+            state->mode = LEN;\n+        case LEN:\n+            if (have >= 6 && left >= 258) {\n+                RESTORE();\n+                inflate_fast(strm, out);\n+                LOAD();\n+                break;\n+            }\n+            for (;;) {\n+                this = state->lencode[BITS(state->lenbits)];\n+                if ((unsigned)(this.bits) <= bits) break;\n+                PULLBYTE();\n+            }\n+            if (this.op && (this.op & 0xf0) == 0) {\n+                last = this;\n+                for (;;) {\n+                    this = state->lencode[last.val +\n+                            (BITS(last.bits + last.op) >> last.bits)];\n+                    if ((unsigned)(last.bits + this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                DROPBITS(last.bits);\n+            }\n+            DROPBITS(this.bits);\n+            state->length = (unsigned)this.val;\n+            if ((int)(this.op) == 0) {\n+                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?\n+                        \"inflate:         literal '%c'\\n\" :\n+                        \"inflate:         literal 0x%02x\\n\", this.val));\n+                state->mode = LIT;\n+                break;\n+            }\n+            if (this.op & 32) {\n+                Tracevv((stderr, \"inflate:         end of block\\n\"));\n+                state->mode = TYPE;\n+                break;\n+            }\n+            if (this.op & 64) {\n+                strm->msg = (char *)\"invalid literal/length code\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            state->extra = (unsigned)(this.op) & 15;\n+            state->mode = LENEXT;\n+        case LENEXT:\n+            if (state->extra) {\n+                NEEDBITS(state->extra);\n+                state->length += BITS(state->extra);\n+                DROPBITS(state->extra);\n+            }\n+            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n+            state->mode = DIST;\n+        case DIST:\n+            for (;;) {\n+                this = state->distcode[BITS(state->distbits)];\n+                if ((unsigned)(this.bits) <= bits) break;\n+                PULLBYTE();\n+            }\n+            if ((this.op & 0xf0) == 0) {\n+                last = this;\n+                for (;;) {\n+                    this = state->distcode[last.val +\n+                            (BITS(last.bits + last.op) >> last.bits)];\n+                    if ((unsigned)(last.bits + this.bits) <= bits) break;\n+                    PULLBYTE();\n+                }\n+                DROPBITS(last.bits);\n+            }\n+            DROPBITS(this.bits);\n+            if (this.op & 64) {\n+                strm->msg = (char *)\"invalid distance code\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            state->offset = (unsigned)this.val;\n+            state->extra = (unsigned)(this.op) & 15;\n+            state->mode = DISTEXT;\n+        case DISTEXT:\n+            if (state->extra) {\n+                NEEDBITS(state->extra);\n+                state->offset += BITS(state->extra);\n+                DROPBITS(state->extra);\n+            }\n+            if (state->offset > state->whave + out - left) {\n+                strm->msg = (char *)\"invalid distance too far back\";\n+                state->mode = BAD;\n+                break;\n+            }\n+            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n+            state->mode = MATCH;\n+        case MATCH:\n+            if (left == 0) goto inf_leave;\n+            copy = out - left;\n+            if (state->offset > copy) {         /* copy from window */\n+                copy = state->offset - copy;\n+                if (copy > state->write) {\n+                    copy -= state->write;\n+                    from = state->window + (state->wsize - copy);\n+                }\n+                else\n+                    from = state->window + (state->write - copy);\n+                if (copy > state->length) copy = state->length;\n+            }\n+            else {                              /* copy from output */\n+                from = put - state->offset;\n+                copy = state->length;\n+            }\n+            if (copy > left) copy = left;\n+            left -= copy;\n+            state->length -= copy;\n+            do {\n+                *put++ = *from++;\n+            } while (--copy);\n+            if (state->length == 0) state->mode = LEN;\n+            break;\n+        case LIT:\n+            if (left == 0) goto inf_leave;\n+            *put++ = (unsigned char)(state->length);\n+            left--;\n+            state->mode = LEN;\n+            break;\n+        case CHECK:\n+            if (state->wrap) {\n+                NEEDBITS(32);\n+                out -= left;\n+                strm->total_out += out;\n+                state->total += out;\n+                if (out)\n+                    strm->adler = state->check =\n+                        UPDATE(state->check, put - out, out);\n+                out = left;\n+                if ((\n+#ifdef GUNZIP\n+                     state->flags ? hold :\n+#endif\n+                     REVERSE(hold)) != state->check) {\n+                    strm->msg = (char *)\"incorrect data check\";\n+                    state->mode = BAD;\n+                    break;\n+                }\n+                INITBITS();\n+                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n+            }\n+#ifdef GUNZIP\n+            state->mode = LENGTH;\n+        case LENGTH:\n+            if (state->wrap && state->flags) {\n+                NEEDBITS(32);\n+                if (hold != (state->total & 0xffffffffUL)) {\n+                    strm->msg = (char *)\"incorrect length check\";\n+                    state->mode = BAD;\n+                    break;\n+                }\n+                INITBITS();\n+                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n+            }\n+#endif\n+            state->mode = DONE;\n+        case DONE:\n+            ret = Z_STREAM_END;\n+            goto inf_leave;\n+        case BAD:\n+            ret = Z_DATA_ERROR;\n+            goto inf_leave;\n+        case MEM:\n+            return Z_MEM_ERROR;\n+        case SYNC:\n+        default:\n+            return Z_STREAM_ERROR;\n+        }\n+\n+    /*\n+       Return from inflate(), updating the total counts and the check value.\n+       If there was no progress during the inflate() call, return a buffer\n+       error.  Call updatewindow() to create and/or update the window state.\n+       Note: a memory error from inflate() is non-recoverable.\n+     */\n+  inf_leave:\n+    RESTORE();\n+    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))\n+        if (updatewindow(strm, out)) {\n+            state->mode = MEM;\n+            return Z_MEM_ERROR;\n+        }\n+    in -= strm->avail_in;\n+    out -= strm->avail_out;\n+    strm->total_in += in;\n+    strm->total_out += out;\n+    state->total += out;\n+    if (state->wrap && out)\n+        strm->adler = state->check =\n+            UPDATE(state->check, strm->next_out - out, out);\n+    strm->data_type = state->bits + (state->last ? 64 : 0) +\n+                      (state->mode == TYPE ? 128 : 0);\n+    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n+        ret = Z_BUF_ERROR;\n+    return ret;\n }\n \n+int ZEXPORT inflateEnd(strm)\n+z_streamp strm;\n+{\n+    struct inflate_state FAR *state;\n+    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)\n+        return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+    if (state->window != Z_NULL) ZFREE(strm, state->window);\n+    ZFREE(strm, strm->state);\n+    strm->state = Z_NULL;\n+    Tracev((stderr, \"inflate: end\\n\"));\n+    return Z_OK;\n+}\n \n-int ZEXPORT inflateSetDictionary(z, dictionary, dictLength)\n-z_streamp z;\n+int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)\n+z_streamp strm;\n const Bytef *dictionary;\n-uInt  dictLength;\n+uInt dictLength;\n {\n-  uInt length = dictLength;\n-\n-  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)\n-    return Z_STREAM_ERROR;\n-\n-  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;\n-  z->adler = 1L;\n-\n-  if (length >= ((uInt)1<<z->state->wbits))\n-  {\n-    length = (1<<z->state->wbits)-1;\n-    dictionary += dictLength - length;\n-  }\n-  inflate_set_dictionary(z->state->blocks, dictionary, length);\n-  z->state->mode = BLOCKS;\n-  return Z_OK;\n-}\n+    struct inflate_state FAR *state;\n+    unsigned long id;\n \n+    /* check state */\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+    if (state->mode != DICT) return Z_STREAM_ERROR;\n \n-int ZEXPORT inflateSync(z)\n-z_streamp z;\n+    /* check for correct dictionary id */\n+    id = adler32(0L, Z_NULL, 0);\n+    id = adler32(id, dictionary, dictLength);\n+    if (id != state->check) return Z_DATA_ERROR;\n+\n+    /* copy dictionary to window */\n+    if (updatewindow(strm, strm->avail_out)) {\n+        state->mode = MEM;\n+        return Z_MEM_ERROR;\n+    }\n+    if (dictLength > state->wsize) {\n+        zmemcpy(state->window, dictionary + dictLength - state->wsize,\n+                state->wsize);\n+        state->whave = state->wsize;\n+    }\n+    else {\n+        zmemcpy(state->window + state->wsize - dictLength, dictionary,\n+                dictLength);\n+        state->whave = dictLength;\n+    }\n+    state->havedict = 1;\n+    Tracev((stderr, \"inflate:   dictionary set\\n\"));\n+    return Z_OK;\n+}\n+\n+/*\n+   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found\n+   or when out of input.  When called, *have is the number of pattern bytes\n+   found in order so far, in 0..3.  On return *have is updated to the new\n+   state.  If on return *have equals four, then the pattern was found and the\n+   return value is how many bytes were read including the last byte of the\n+   pattern.  If *have is less than four, then the pattern has not been found\n+   yet and the return value is len.  In the latter case, syncsearch() can be\n+   called again with more data and the *have state.  *have is initialized to\n+   zero for the first call.\n+ */\n+local unsigned syncsearch(have, buf, len)\n+unsigned FAR *have;\n+unsigned char FAR *buf;\n+unsigned len;\n {\n-  uInt n;       /* number of bytes to look at */\n-  Bytef *p;     /* pointer to bytes */\n-  uInt m;       /* number of marker bytes found in a row */\n-  uLong r, w;   /* temporaries to save total_in and total_out */\n-\n-  /* set up */\n-  if (z == Z_NULL || z->state == Z_NULL)\n-    return Z_STREAM_ERROR;\n-  if (z->state->mode != BAD)\n-  {\n-    z->state->mode = BAD;\n-    z->state->sub.marker = 0;\n-  }\n-  if ((n = z->avail_in) == 0)\n-    return Z_BUF_ERROR;\n-  p = z->next_in;\n-  m = z->state->sub.marker;\n-\n-  /* search */\n-  while (n && m < 4)\n-  {\n-    static const Byte mark[4] = {0, 0, 0xff, 0xff};\n-    if (*p == mark[m])\n-      m++;\n-    else if (*p)\n-      m = 0;\n-    else\n-      m = 4 - m;\n-    p++, n--;\n-  }\n-\n-  /* restore */\n-  z->total_in += p - z->next_in;\n-  z->next_in = p;\n-  z->avail_in = n;\n-  z->state->sub.marker = m;\n-\n-  /* return no joy or set up to restart on a new block */\n-  if (m != 4)\n-    return Z_DATA_ERROR;\n-  r = z->total_in;  w = z->total_out;\n-  inflateReset(z);\n-  z->total_in = r;  z->total_out = w;\n-  z->state->mode = BLOCKS;\n-  return Z_OK;\n+    unsigned got;\n+    unsigned next;\n+\n+    got = *have;\n+    next = 0;\n+    while (next < len && got < 4) {\n+        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))\n+            got++;\n+        else if (buf[next])\n+            got = 0;\n+        else\n+            got = 4 - got;\n+        next++;\n+    }\n+    *have = got;\n+    return next;\n }\n \n+int ZEXPORT inflateSync(strm)\n+z_streamp strm;\n+{\n+    unsigned len;               /* number of bytes to look at or looked at */\n+    unsigned long in, out;      /* temporary to save total_in and total_out */\n+    unsigned char buf[4];       /* to restore bit buffer to byte string */\n+    struct inflate_state FAR *state;\n \n-/* Returns true if inflate is currently at the end of a block generated\n- * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n- * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n- * but removes the length bytes of the resulting empty stored block. When\n- * decompressing, PPP checks that at the end of input packet, inflate is\n- * waiting for these length bytes.\n+    /* check parameters */\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;\n+\n+    /* if first time, start search in bit buffer */\n+    if (state->mode != SYNC) {\n+        state->mode = SYNC;\n+        state->hold <<= state->bits & 7;\n+        state->bits -= state->bits & 7;\n+        len = 0;\n+        while (state->bits >= 8) {\n+            buf[len++] = (unsigned char)(state->hold);\n+            state->hold >>= 8;\n+            state->bits -= 8;\n+        }\n+        state->have = 0;\n+        syncsearch(&(state->have), buf, len);\n+    }\n+\n+    /* search available input */\n+    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);\n+    strm->avail_in -= len;\n+    strm->next_in += len;\n+    strm->total_in += len;\n+\n+    /* return no joy or set up to restart inflate() on a new block */\n+    if (state->have != 4) return Z_DATA_ERROR;\n+    in = strm->total_in;  out = strm->total_out;\n+    inflateReset(strm);\n+    strm->total_in = in;  strm->total_out = out;\n+    state->mode = TYPE;\n+    return Z_OK;\n+}\n+\n+/*\n+   Returns true if inflate is currently at the end of a block generated by\n+   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n+   implementation to provide an additional safety check. PPP uses\n+   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored\n+   block. When decompressing, PPP checks that at the end of input packet,\n+   inflate is waiting for these length bytes.\n  */\n-int ZEXPORT inflateSyncPoint(z)\n-z_streamp z;\n+int ZEXPORT inflateSyncPoint(strm)\n+z_streamp strm;\n+{\n+    struct inflate_state FAR *state;\n+\n+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)strm->state;\n+    return state->mode == STORED && state->bits == 0;\n+}\n+\n+int ZEXPORT inflateCopy(dest, source)\n+z_streamp dest;\n+z_streamp source;\n {\n-  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)\n-    return Z_STREAM_ERROR;\n-  return inflate_blocks_sync_point(z->state->blocks);\n+    struct inflate_state FAR *state;\n+    struct inflate_state FAR *copy;\n+    unsigned char FAR *window;\n+\n+    /* check input */\n+    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||\n+        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)\n+        return Z_STREAM_ERROR;\n+    state = (struct inflate_state FAR *)source->state;\n+\n+    /* allocate space */\n+    copy = (struct inflate_state FAR *)\n+           ZALLOC(source, 1, sizeof(struct inflate_state));\n+    if (copy == Z_NULL) return Z_MEM_ERROR;\n+    window = Z_NULL;\n+    if (state->window != Z_NULL) {\n+        window = (unsigned char FAR *)\n+                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));\n+        if (window == Z_NULL) {\n+            ZFREE(source, copy);\n+            return Z_MEM_ERROR;\n+        }\n+    }\n+\n+    /* copy state */\n+    *dest = *source;\n+    *copy = *state;\n+    copy->lencode = copy->codes + (state->lencode - state->codes);\n+    copy->distcode = copy->codes + (state->distcode - state->codes);\n+    copy->next = copy->codes + (state->next - state->codes);\n+    if (window != Z_NULL)\n+        zmemcpy(window, state->window, 1U << state->wbits);\n+    copy->window = window;\n+    dest->state = (voidpf)copy;\n+    return Z_OK;\n }"}, {"sha": "3bb56398e1c36a182504c69dffec0379bcfba637", "filename": "zlib/inftrees.c", "status": "modified", "additions": 289, "deletions": 422, "changes": 711, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finftrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finftrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finftrees.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,454 +1,321 @@\n /* inftrees.c -- generate Huffman trees for efficient decoding\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n #include \"zutil.h\"\n #include \"inftrees.h\"\n \n-#if !defined(BUILDFIXED) && !defined(STDC)\n-#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */\n-#endif\n+#define MAXBITS 15\n \n const char inflate_copyright[] =\n-   \" inflate 1.1.4 Copyright 1995-2002 Mark Adler \";\n+   \" inflate 1.2.1 Copyright 1995-2003 Mark Adler \";\n /*\n   If you use the zlib library in a product, an acknowledgment is welcome\n   in the documentation of your product. If for some reason you cannot\n   include such an acknowledgment, I would appreciate that you keep this\n   copyright string in the executable of your product.\n  */\n-struct internal_state  {int dummy;}; /* for buggy compilers */\n-\n-/* simplify the use of the inflate_huft type with some defines */\n-#define exop word.what.Exop\n-#define bits word.what.Bits\n-\n-\n-local int huft_build OF((\n-    uIntf *,            /* code lengths in bits */\n-    uInt,               /* number of codes */\n-    uInt,               /* number of \"simple\" codes */\n-    const uIntf *,      /* list of base values for non-simple codes */\n-    const uIntf *,      /* list of extra bits for non-simple codes */\n-    inflate_huft * FAR*,/* result: starting table */\n-    uIntf *,            /* maximum lookup bits (returns actual) */\n-    inflate_huft *,     /* space for trees */\n-    uInt *,             /* hufts used in space */\n-    uIntf * ));         /* space for values */\n-\n-/* Tables for deflate from PKZIP's appnote.txt. */\n-local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */\n-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n-        /* see note #13 above about 258 */\n-local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */\n-        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n-        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */\n-local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */\n-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n-        8193, 12289, 16385, 24577};\n-local const uInt cpdext[30] = { /* Extra bits for distance codes */\n-        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n-        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n-        12, 12, 13, 13};\n \n /*\n-   Huffman code decoding is performed using a multi-level table lookup.\n-   The fastest way to decode is to simply build a lookup table whose\n-   size is determined by the longest code.  However, the time it takes\n-   to build this table can also be a factor if the data being decoded\n-   is not very long.  The most common codes are necessarily the\n-   shortest codes, so those codes dominate the decoding time, and hence\n-   the speed.  The idea is you can have a shorter table that decodes the\n-   shorter, more probable codes, and then point to subsidiary tables for\n-   the longer codes.  The time it costs to decode the longer codes is\n-   then traded against the time it takes to make longer tables.\n-\n-   This results of this trade are in the variables lbits and dbits\n-   below.  lbits is the number of bits the first level table for literal/\n-   length codes can decode in one step, and dbits is the same thing for\n-   the distance codes.  Subsequent tables are also less than or equal to\n-   those sizes.  These values may be adjusted either when all of the\n-   codes are shorter than that, in which case the longest code length in\n-   bits is used, or when the shortest code is *longer* than the requested\n-   table size, in which case the length of the shortest code in bits is\n-   used.\n-\n-   There are two different values for the two tables, since they code a\n-   different number of possibilities each.  The literal/length table\n-   codes 286 possible values, or in a flat code, a little over eight\n-   bits.  The distance table codes 30 possible values, or a little less\n-   than five bits, flat.  The optimum values for speed end up being\n-   about one bit more than those, so lbits is 8+1 and dbits is 5+1.\n-   The optimum values may differ though from machine to machine, and\n-   possibly even between compilers.  Your mileage may vary.\n+   Build a set of tables to decode the provided canonical Huffman code.\n+   The code lengths are lens[0..codes-1].  The result starts at *table,\n+   whose indices are 0..2^bits-1.  work is a writable array of at least\n+   lens shorts, which is used as a work area.  type is the type of code\n+   to be generated, CODES, LENS, or DISTS.  On return, zero is success,\n+   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table\n+   on return points to the next available entry's address.  bits is the\n+   requested root table index bits, and on return it is the actual root\n+   table index bits.  It will differ if the request is greater than the\n+   longest code or if it is less than the shortest code.\n  */\n-\n-\n-/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */\n-#define BMAX 15         /* maximum bit length of any code */\n-\n-local int huft_build(b, n, s, d, e, t, m, hp, hn, v)\n-uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */\n-uInt n;                 /* number of codes (assumed <= 288) */\n-uInt s;                 /* number of simple-valued codes (0..s-1) */\n-const uIntf *d;         /* list of base values for non-simple codes */\n-const uIntf *e;         /* list of extra bits for non-simple codes */\n-inflate_huft * FAR *t;  /* result: starting table */\n-uIntf *m;               /* maximum lookup bits, returns actual */\n-inflate_huft *hp;       /* space for trees */\n-uInt *hn;               /* hufts used in space */\n-uIntf *v;               /* working area: values in order of bit length */\n-/* Given a list of code lengths and a maximum table size, make a set of\n-   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n-   if the given code set is incomplete (the tables are still built in this\n-   case), or Z_DATA_ERROR if the input is invalid. */\n+int inflate_table(type, lens, codes, table, bits, work)\n+codetype type;\n+unsigned short FAR *lens;\n+unsigned codes;\n+code FAR * FAR *table;\n+unsigned FAR *bits;\n+unsigned short FAR *work;\n {\n+    unsigned len;               /* a code's length in bits */\n+    unsigned sym;               /* index of code symbols */\n+    unsigned min, max;          /* minimum and maximum code lengths */\n+    unsigned root;              /* number of index bits for root table */\n+    unsigned curr;              /* number of index bits for current table */\n+    unsigned drop;              /* code bits to drop for sub-table */\n+    int left;                   /* number of prefix codes available */\n+    unsigned used;              /* code entries in table used */\n+    unsigned huff;              /* Huffman code */\n+    unsigned incr;              /* for incrementing code, index */\n+    unsigned fill;              /* index for replicating entries */\n+    unsigned low;               /* low bits for current root entry */\n+    unsigned mask;              /* mask for low root bits */\n+    code this;                  /* table entry for duplication */\n+    code FAR *next;             /* next available space in table */\n+    const unsigned short FAR *base;     /* base value table to use */\n+    const unsigned short FAR *extra;    /* extra bits table to use */\n+    int end;                    /* use base and extra for symbol > end */\n+    unsigned short count[MAXBITS+1];    /* number of codes of each length */\n+    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n+    static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n+    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n+        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 76, 66};\n+    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n+        8193, 12289, 16385, 24577, 0, 0};\n+    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */\n+        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n+        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n+        28, 28, 29, 29, 64, 64};\n+\n+    /*\n+       Process a set of code lengths to create a canonical Huffman code.  The\n+       code lengths are lens[0..codes-1].  Each length corresponds to the\n+       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n+       symbols by length from short to long, and retaining the symbol order\n+       for codes with equal lengths.  Then the code starts with all zero bits\n+       for the first code of the shortest length, and the codes are integer\n+       increments for the same length, and zeros are appended as the length\n+       increases.  For the deflate format, these bits are stored backwards\n+       from their more natural integer increment ordering, and so when the\n+       decoding tables are built in the large loop below, the integer codes\n+       are incremented backwards.\n+\n+       This routine assumes, but does not check, that all of the entries in\n+       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n+       1..MAXBITS is interpreted as that code length.  zero means that that\n+       symbol does not occur in this code.\n+\n+       The codes are sorted by computing a count of codes for each length,\n+       creating from that a table of starting indices for each length in the\n+       sorted table, and then entering the symbols in order in the sorted\n+       table.  The sorted table is work[], with that space being provided by\n+       the caller.\n+\n+       The length counts are used for other purposes as well, i.e. finding\n+       the minimum and maximum length codes, determining if there are any\n+       codes at all, checking for a valid set of lengths, and looking ahead\n+       at length counts to determine sub-table sizes when building the\n+       decoding tables.\n+     */\n+\n+    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n+    for (len = 0; len <= MAXBITS; len++)\n+        count[len] = 0;\n+    for (sym = 0; sym < codes; sym++)\n+        count[lens[sym]]++;\n+\n+    /* bound code lengths, force root to be within code lengths */\n+    root = *bits;\n+    for (max = MAXBITS; max >= 1; max--)\n+        if (count[max] != 0) break;\n+    if (root > max) root = max;\n+    if (max == 0) return -1;            /* no codes! */\n+    for (min = 1; min <= MAXBITS; min++)\n+        if (count[min] != 0) break;\n+    if (root < min) root = min;\n+\n+    /* check for an over-subscribed or incomplete set of lengths */\n+    left = 1;\n+    for (len = 1; len <= MAXBITS; len++) {\n+        left <<= 1;\n+        left -= count[len];\n+        if (left < 0) return -1;        /* over-subscribed */\n+    }\n+    if (left > 0 && (type == CODES || (codes - count[0] != 1)))\n+        return -1;                      /* incomplete set */\n+\n+    /* generate offsets into symbol table for each length for sorting */\n+    offs[1] = 0;\n+    for (len = 1; len < MAXBITS; len++)\n+        offs[len + 1] = offs[len] + count[len];\n+\n+    /* sort symbols by length, by symbol order within each length */\n+    for (sym = 0; sym < codes; sym++)\n+        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n+\n+    /*\n+       Create and fill in decoding tables.  In this loop, the table being\n+       filled is at next and has curr index bits.  The code being used is huff\n+       with length len.  That code is converted to an index by dropping drop\n+       bits off of the bottom.  For codes where len is less than drop + curr,\n+       those top drop + curr - len bits are incremented through all values to\n+       fill the table with replicated entries.\n+\n+       root is the number of index bits for the root table.  When len exceeds\n+       root, sub-tables are created pointed to by the root entry with an index\n+       of the low root bits of huff.  This is saved in low to check for when a\n+       new sub-table should be started.  drop is zero when the root table is\n+       being filled, and drop is root when sub-tables are being filled.\n+\n+       When a new sub-table is needed, it is necessary to look ahead in the\n+       code lengths to determine what size sub-table is needed.  The length\n+       counts are used for this, and so count[] is decremented as codes are\n+       entered in the tables.\n+\n+       used keeps track of how many table entries have been allocated from the\n+       provided *table space.  It is checked when a LENS table is being made\n+       against the space in *table, ENOUGH, minus the maximum space needed by\n+       the worst case distance code, MAXD.  This should never happen, but the\n+       sufficiency of ENOUGH has not been proven exhaustively, hence the check.\n+       This assumes that when type == LENS, bits == 9.\n+\n+       sym increments through all symbols, and the loop terminates when\n+       all codes of length max, i.e. all codes, have been processed.  This\n+       routine permits incomplete codes, so another loop after this one fills\n+       in the rest of the decoding tables with invalid code markers.\n+     */\n+\n+    /* set up for code type */\n+    switch (type) {\n+    case CODES:\n+        base = extra = work;    /* dummy value--not used */\n+        end = 19;\n+        break;\n+    case LENS:\n+        base = lbase;\n+        base -= 257;\n+        extra = lext;\n+        extra -= 257;\n+        end = 256;\n+        break;\n+    default:            /* DISTS */\n+        base = dbase;\n+        extra = dext;\n+        end = -1;\n+    }\n \n-  uInt a;                       /* counter for codes of length k */\n-  uInt c[BMAX+1];               /* bit length count table */\n-  uInt f;                       /* i repeats in table every f entries */\n-  int g;                        /* maximum code length */\n-  int h;                        /* table level */\n-  register uInt i;              /* counter, current code */\n-  register uInt j;              /* counter */\n-  register int k;               /* number of bits in current code */\n-  int l;                        /* bits per table (returned in m) */\n-  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */\n-  register uIntf *p;            /* pointer into c[], b[], or v[] */\n-  inflate_huft *q;              /* points to current table */\n-  struct inflate_huft_s r;      /* table entry for structure assignment */\n-  inflate_huft *u[BMAX];        /* table stack */\n-  register int w;               /* bits before this table == (l * h) */\n-  uInt x[BMAX+1];               /* bit offsets, then code stack */\n-  uIntf *xp;                    /* pointer into x */\n-  int y;                        /* number of dummy codes added */\n-  uInt z;                       /* number of entries in current table */\n-\n-\n-  /* Generate counts for each bit length */\n-  p = c;\n-#define C0 *p++ = 0;\n-#define C2 C0 C0 C0 C0\n-#define C4 C2 C2 C2 C2\n-  C4                            /* clear c[]--assume BMAX+1 is 16 */\n-  p = b;  i = n;\n-  do {\n-    c[*p++]++;                  /* assume all entries <= BMAX */\n-  } while (--i);\n-  if (c[0] == n)                /* null input--all zero length codes */\n-  {\n-    *t = (inflate_huft *)Z_NULL;\n-    *m = 0;\n-    return Z_OK;\n-  }\n-\n-\n-  /* Find minimum and maximum length, bound *m by those */\n-  l = *m;\n-  for (j = 1; j <= BMAX; j++)\n-    if (c[j])\n-      break;\n-  k = j;                        /* minimum code length */\n-  if ((uInt)l < j)\n-    l = j;\n-  for (i = BMAX; i; i--)\n-    if (c[i])\n-      break;\n-  g = i;                        /* maximum code length */\n-  if ((uInt)l > i)\n-    l = i;\n-  *m = l;\n-\n-\n-  /* Adjust last length count to fill out codes, if needed */\n-  for (y = 1 << j; j < i; j++, y <<= 1)\n-    if ((y -= c[j]) < 0)\n-      return Z_DATA_ERROR;\n-  if ((y -= c[i]) < 0)\n-    return Z_DATA_ERROR;\n-  c[i] += y;\n-\n-\n-  /* Generate starting offsets into the value table for each length */\n-  x[1] = j = 0;\n-  p = c + 1;  xp = x + 2;\n-  while (--i) {                 /* note that i == g from above */\n-    *xp++ = (j += *p++);\n-  }\n-\n-\n-  /* Make a table of values in order of bit lengths */\n-  p = b;  i = 0;\n-  do {\n-    if ((j = *p++) != 0)\n-      v[x[j]++] = i;\n-  } while (++i < n);\n-  n = x[g];                     /* set n to length of v */\n-\n-\n-  /* Generate the Huffman codes and for each, make the table entries */\n-  x[0] = i = 0;                 /* first Huffman code is zero */\n-  p = v;                        /* grab values in bit order */\n-  h = -1;                       /* no tables yet--level -1 */\n-  w = -l;                       /* bits decoded == (l * h) */\n-  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */\n-  q = (inflate_huft *)Z_NULL;   /* ditto */\n-  z = 0;                        /* ditto */\n-\n-  /* go through the bit lengths (k already is bits in shortest code) */\n-  for (; k <= g; k++)\n-  {\n-    a = c[k];\n-    while (a--)\n-    {\n-      /* here i is the Huffman code of length k bits for value *p */\n-      /* make tables up to required level */\n-      while (k > w + l)\n-      {\n-        h++;\n-        w += l;                 /* previous table always l bits */\n-\n-        /* compute minimum size table less than or equal to l bits */\n-        z = g - w;\n-        z = z > (uInt)l ? l : z;        /* table size upper limit */\n-        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */\n-        {                       /* too few codes for k-w bit table */\n-          f -= a + 1;           /* deduct codes from patterns left */\n-          xp = c + k;\n-          if (j < z)\n-            while (++j < z)     /* try smaller tables up to z bits */\n-            {\n-              if ((f <<= 1) <= *++xp)\n-                break;          /* enough codes to use up j bits */\n-              f -= *xp;         /* else deduct codes from patterns */\n-            }\n+    /* initialize state for loop */\n+    huff = 0;                   /* starting code */\n+    sym = 0;                    /* starting code symbol */\n+    len = min;                  /* starting code length */\n+    next = *table;              /* current table to fill in */\n+    curr = root;                /* current table index bits */\n+    drop = 0;                   /* current bits to drop from code for index */\n+    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n+    used = 1U << root;          /* use root table entries */\n+    mask = used - 1;            /* mask for comparing low */\n+\n+    /* check available table space */\n+    if (type == LENS && used >= ENOUGH - MAXD)\n+        return 1;\n+\n+    /* process all codes and make table entries */\n+    for (;;) {\n+        /* create table entry */\n+        this.bits = (unsigned char)(len - drop);\n+        if ((int)(work[sym]) < end) {\n+            this.op = (unsigned char)0;\n+            this.val = work[sym];\n         }\n-        z = 1 << j;             /* table entries for j-bit table */\n-\n-        /* allocate new table */\n-        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */\n-          return Z_DATA_ERROR;  /* overflow of MANY */\n-        u[h] = q = hp + *hn;\n-        *hn += z;\n-\n-        /* connect to last table, if there is one */\n-        if (h)\n-        {\n-          x[h] = i;             /* save pattern for backing up */\n-          r.bits = (Byte)l;     /* bits to dump before this table */\n-          r.exop = (Byte)j;     /* bits in this table */\n-          j = i >> (w - l);\n-          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */\n-          u[h-1][j] = r;        /* connect to last table */\n+        else if ((int)(work[sym]) > end) {\n+            this.op = (unsigned char)(extra[work[sym]]);\n+            this.val = base[work[sym]];\n+        }\n+        else {\n+            this.op = (unsigned char)(32 + 64);         /* end of block */\n+            this.val = 0;\n         }\n-        else\n-          *t = q;               /* first table is returned result */\n-      }\n-\n-      /* set up table entry in r */\n-      r.bits = (Byte)(k - w);\n-      if (p >= v + n)\n-        r.exop = 128 + 64;      /* out of values--invalid code */\n-      else if (*p < s)\n-      {\n-        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */\n-        r.base = *p++;          /* simple code is just the value */\n-      }\n-      else\n-      {\n-        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */\n-        r.base = d[*p++ - s];\n-      }\n-\n-      /* fill code-like entries with r */\n-      f = 1 << (k - w);\n-      for (j = i >> w; j < z; j += f)\n-        q[j] = r;\n-\n-      /* backwards increment the k-bit code i */\n-      for (j = 1 << (k - 1); i & j; j >>= 1)\n-        i ^= j;\n-      i ^= j;\n-\n-      /* backup over finished tables */\n-      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */\n-      while ((i & mask) != x[h])\n-      {\n-        h--;                    /* don't need to update q */\n-        w -= l;\n-        mask = (1 << w) - 1;\n-      }\n-    }\n-  }\n-\n \n-  /* Return Z_BUF_ERROR if we were given an incomplete table */\n-  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n-}\n+        /* replicate for those indices with low len bits equal to huff */\n+        incr = 1U << (len - drop);\n+        fill = 1U << curr;\n+        do {\n+            fill -= incr;\n+            next[(huff >> drop) + fill] = this;\n+        } while (fill != 0);\n+\n+        /* backwards increment the len-bit code huff */\n+        incr = 1U << (len - 1);\n+        while (huff & incr)\n+            incr >>= 1;\n+        if (incr != 0) {\n+            huff &= incr - 1;\n+            huff += incr;\n+        }\n+        else\n+            huff = 0;\n \n+        /* go to next symbol, update count, len */\n+        sym++;\n+        if (--(count[len]) == 0) {\n+            if (len == max) break;\n+            len = lens[work[sym]];\n+        }\n \n-int inflate_trees_bits(c, bb, tb, hp, z)\n-uIntf *c;               /* 19 code lengths */\n-uIntf *bb;              /* bits tree desired/actual depth */\n-inflate_huft * FAR *tb; /* bits tree result */\n-inflate_huft *hp;       /* space for trees */\n-z_streamp z;            /* for messages */\n-{\n-  int r;\n-  uInt hn = 0;          /* hufts used in space */\n-  uIntf *v;             /* work area for huft_build */\n-\n-  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)\n-    return Z_MEM_ERROR;\n-  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,\n-                 tb, bb, hp, &hn, v);\n-  if (r == Z_DATA_ERROR)\n-    z->msg = (char*)\"oversubscribed dynamic bit lengths tree\";\n-  else if (r == Z_BUF_ERROR || *bb == 0)\n-  {\n-    z->msg = (char*)\"incomplete dynamic bit lengths tree\";\n-    r = Z_DATA_ERROR;\n-  }\n-  ZFREE(z, v);\n-  return r;\n-}\n+        /* create new sub-table if needed */\n+        if (len > root && (huff & mask) != low) {\n+            /* if first time, transition to sub-tables */\n+            if (drop == 0)\n+                drop = root;\n+\n+            /* increment past last table */\n+            next += 1U << curr;\n+\n+            /* determine length of next table */\n+            curr = len - drop;\n+            left = (int)(1 << curr);\n+            while (curr + drop < max) {\n+                left -= count[curr + drop];\n+                if (left <= 0) break;\n+                curr++;\n+                left <<= 1;\n+            }\n \n+            /* check for enough space */\n+            used += 1U << curr;\n+            if (type == LENS && used >= ENOUGH - MAXD)\n+                return 1;\n \n-int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)\n-uInt nl;                /* number of literal/length codes */\n-uInt nd;                /* number of distance codes */\n-uIntf *c;               /* that many (total) code lengths */\n-uIntf *bl;              /* literal desired/actual bit depth */\n-uIntf *bd;              /* distance desired/actual bit depth */\n-inflate_huft * FAR *tl; /* literal/length tree result */\n-inflate_huft * FAR *td; /* distance tree result */\n-inflate_huft *hp;       /* space for trees */\n-z_streamp z;            /* for messages */\n-{\n-  int r;\n-  uInt hn = 0;          /* hufts used in space */\n-  uIntf *v;             /* work area for huft_build */\n-\n-  /* allocate work area */\n-  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n-    return Z_MEM_ERROR;\n-\n-  /* build literal/length tree */\n-  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);\n-  if (r != Z_OK || *bl == 0)\n-  {\n-    if (r == Z_DATA_ERROR)\n-      z->msg = (char*)\"oversubscribed literal/length tree\";\n-    else if (r != Z_MEM_ERROR)\n-    {\n-      z->msg = (char*)\"incomplete literal/length tree\";\n-      r = Z_DATA_ERROR;\n-    }\n-    ZFREE(z, v);\n-    return r;\n-  }\n-\n-  /* build distance tree */\n-  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);\n-  if (r != Z_OK || (*bd == 0 && nl > 257))\n-  {\n-    if (r == Z_DATA_ERROR)\n-      z->msg = (char*)\"oversubscribed distance tree\";\n-    else if (r == Z_BUF_ERROR) {\n-#ifdef PKZIP_BUG_WORKAROUND\n-      r = Z_OK;\n-    }\n-#else\n-      z->msg = (char*)\"incomplete distance tree\";\n-      r = Z_DATA_ERROR;\n-    }\n-    else if (r != Z_MEM_ERROR)\n-    {\n-      z->msg = (char*)\"empty distance tree with lengths\";\n-      r = Z_DATA_ERROR;\n+            /* point entry in root table to sub-table */\n+            low = huff & mask;\n+            (*table)[low].op = (unsigned char)curr;\n+            (*table)[low].bits = (unsigned char)root;\n+            (*table)[low].val = (unsigned short)(next - *table);\n+        }\n     }\n-    ZFREE(z, v);\n-    return r;\n-#endif\n-  }\n-\n-  /* done */\n-  ZFREE(z, v);\n-  return Z_OK;\n-}\n \n+    /*\n+       Fill in rest of table for incomplete codes.  This loop is similar to the\n+       loop above in incrementing huff for table indices.  It is assumed that\n+       len is equal to curr + drop, so there is no loop needed to increment\n+       through high index bits.  When the current sub-table is filled, the loop\n+       drops back to the root table to fill in any remaining entries there.\n+     */\n+    this.op = (unsigned char)64;                /* invalid code marker */\n+    this.bits = (unsigned char)(len - drop);\n+    this.val = (unsigned short)0;\n+    while (huff != 0) {\n+        /* when done with sub-table, drop back to root table */\n+        if (drop != 0 && (huff & mask) != low) {\n+            drop = 0;\n+            len = root;\n+            next = *table;\n+            curr = root;\n+            this.bits = (unsigned char)len;\n+        }\n+\n+        /* put invalid code marker in table */\n+        next[huff >> drop] = this;\n \n-/* build fixed tables only once--keep them here */\n-#ifdef BUILDFIXED\n-local int fixed_built = 0;\n-#define FIXEDH 544      /* number of hufts used by fixed tables */\n-local inflate_huft fixed_mem[FIXEDH];\n-local uInt fixed_bl;\n-local uInt fixed_bd;\n-local inflate_huft *fixed_tl;\n-local inflate_huft *fixed_td;\n-#else\n-#include \"inffixed.h\"\n-#endif\n-\n-\n-int inflate_trees_fixed(bl, bd, tl, td, z)\n-uIntf *bl;               /* literal desired/actual bit depth */\n-uIntf *bd;               /* distance desired/actual bit depth */\n-inflate_huft * FAR *tl;  /* literal/length tree result */\n-inflate_huft * FAR *td;  /* distance tree result */\n-z_streamp z;             /* for memory allocation */\n-{\n-#ifdef BUILDFIXED\n-  /* build fixed tables if not already */\n-  if (!fixed_built)\n-  {\n-    int k;              /* temporary variable */\n-    uInt f = 0;         /* number of hufts used in fixed_mem */\n-    uIntf *c;           /* length list for huft_build */\n-    uIntf *v;           /* work area for huft_build */\n-\n-    /* allocate memory */\n-    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n-      return Z_MEM_ERROR;\n-    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)\n-    {\n-      ZFREE(z, c);\n-      return Z_MEM_ERROR;\n+        /* backwards increment the len-bit code huff */\n+        incr = 1U << (len - 1);\n+        while (huff & incr)\n+            incr >>= 1;\n+        if (incr != 0) {\n+            huff &= incr - 1;\n+            huff += incr;\n+        }\n+        else\n+            huff = 0;\n     }\n \n-    /* literal table */\n-    for (k = 0; k < 144; k++)\n-      c[k] = 8;\n-    for (; k < 256; k++)\n-      c[k] = 9;\n-    for (; k < 280; k++)\n-      c[k] = 7;\n-    for (; k < 288; k++)\n-      c[k] = 8;\n-    fixed_bl = 9;\n-    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,\n-               fixed_mem, &f, v);\n-\n-    /* distance table */\n-    for (k = 0; k < 30; k++)\n-      c[k] = 5;\n-    fixed_bd = 5;\n-    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,\n-               fixed_mem, &f, v);\n-\n-    /* done */\n-    ZFREE(z, v);\n-    ZFREE(z, c);\n-    fixed_built = 1;\n-  }\n-#endif\n-  *bl = fixed_bl;\n-  *bd = fixed_bd;\n-  *tl = fixed_tl;\n-  *td = fixed_td;\n-  return Z_OK;\n+    /* set return parameters */\n+    *table += used;\n+    *bits = root;\n+    return 0;\n }"}, {"sha": "82d365a7e901c749e7181527b62330c11c255695", "filename": "zlib/inftrees.h", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finftrees.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Finftrees.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finftrees.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,58 +1,55 @@\n /* inftrees.h -- header to use inftrees.c\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * Copyright (C) 1995-2003 Mark Adler\n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /* WARNING: this file should *not* be used by applications. It is\n    part of the implementation of the compression library and is\n    subject to change. Applications should only use zlib.h.\n  */\n \n-/* Huffman code lookup table entry--this entry is four bytes for machines\n-   that have 16-bit pointers (e.g. PC's in the small or medium model). */\n-\n-typedef struct inflate_huft_s FAR inflate_huft;\n-\n-struct inflate_huft_s {\n-  union {\n-    struct {\n-      Byte Exop;        /* number of extra bits or operation */\n-      Byte Bits;        /* number of bits in this code or subcode */\n-    } what;\n-    uInt pad;           /* pad structure to a power of 2 (4 bytes for */\n-  } word;               /*  16-bit, 8 bytes for 32-bit int's) */\n-  uInt base;            /* literal, length base, distance base,\n-                           or table offset */\n-};\n+/* Structure for decoding tables.  Each entry provides either the\n+   information needed to do the operation requested by the code that\n+   indexed that table entry, or it provides a pointer to another\n+   table that indexes more bits of the code.  op indicates whether\n+   the entry is a pointer to another table, a literal, a length or\n+   distance, an end-of-block, or an invalid code.  For a table\n+   pointer, the low four bits of op is the number of index bits of\n+   that table.  For a length or distance, the low four bits of op\n+   is the number of extra bits to get after the code.  bits is\n+   the number of bits in this code or part of the code to drop off\n+   of the bit buffer.  val is the actual byte to output in the case\n+   of a literal, the base length or distance, or the offset from\n+   the current table to the next table.  Each entry is four bytes. */\n+typedef struct {\n+    unsigned char op;           /* operation, extra bits, table bits */\n+    unsigned char bits;         /* bits in this part of the code */\n+    unsigned short val;         /* offset in table or code value */\n+} code;\n+\n+/* op values as set by inflate_table():\n+    00000000 - literal\n+    0000tttt - table link, tttt != 0 is the number of table index bits\n+    0001eeee - length or distance, eeee is the number of extra bits\n+    01100000 - end of block\n+    01000000 - invalid code\n+ */\n \n /* Maximum size of dynamic tree.  The maximum found in a long but non-\n-   exhaustive search was 1004 huft structures (850 for length/literals\n+   exhaustive search was 1004 code structures (850 for length/literals\n    and 154 for distances, the latter actually the result of an\n-   exhaustive search).  The actual maximum is not known, but the\n-   value below is more than safe. */\n-#define MANY 1440\n-\n-extern int inflate_trees_bits OF((\n-    uIntf *,                    /* 19 code lengths */\n-    uIntf *,                    /* bits tree desired/actual depth */\n-    inflate_huft * FAR *,       /* bits tree result */\n-    inflate_huft *,             /* space for trees */\n-    z_streamp));                /* for messages */\n-\n-extern int inflate_trees_dynamic OF((\n-    uInt,                       /* number of literal/length codes */\n-    uInt,                       /* number of distance codes */\n-    uIntf *,                    /* that many (total) code lengths */\n-    uIntf *,                    /* literal desired/actual bit depth */\n-    uIntf *,                    /* distance desired/actual bit depth */\n-    inflate_huft * FAR *,       /* literal/length tree result */\n-    inflate_huft * FAR *,       /* distance tree result */\n-    inflate_huft *,             /* space for trees */\n-    z_streamp));                /* for messages */\n-\n-extern int inflate_trees_fixed OF((\n-    uIntf *,                    /* literal desired/actual bit depth */\n-    uIntf *,                    /* distance desired/actual bit depth */\n-    inflate_huft * FAR *,       /* literal/length tree result */\n-    inflate_huft * FAR *,       /* distance tree result */\n-    z_streamp));                /* for memory allocation */\n+   exhaustive search).  The true maximum is not known, but the value\n+   below is more than safe. */\n+#define ENOUGH 1440\n+#define MAXD 154\n+\n+/* Type of code to build for inftable() */\n+typedef enum {\n+    CODES,\n+    LENS,\n+    DISTS\n+} codetype;\n+\n+extern int inflate_table OF((codetype type, unsigned short FAR *lens,\n+                             unsigned codes, code FAR * FAR *table,\n+                             unsigned FAR *bits, unsigned short FAR *work));"}, {"sha": "9a076221f2a5c514a06ae1085a118211b45bd4bf", "filename": "zlib/infutil.c", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfutil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfutil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfutil.c?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,87 +0,0 @@\n-/* inflate_util.c -- data and routines common to blocks and codes\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n- */\n-\n-#include \"zutil.h\"\n-#include \"infblock.h\"\n-#include \"inftrees.h\"\n-#include \"infcodes.h\"\n-#include \"infutil.h\"\n-\n-struct inflate_codes_state {int dummy;}; /* for buggy compilers */\n-\n-/* And'ing with mask[n] masks the lower n bits */\n-uInt inflate_mask[17] = {\n-    0x0000,\n-    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n-    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n-};\n-\n-\n-/* copy as much as possible from the sliding window to the output area */\n-int inflate_flush(s, z, r)\n-inflate_blocks_statef *s;\n-z_streamp z;\n-int r;\n-{\n-  uInt n;\n-  Bytef *p;\n-  Bytef *q;\n-\n-  /* local copies of source and destination pointers */\n-  p = z->next_out;\n-  q = s->read;\n-\n-  /* compute number of bytes to copy as far as end of window */\n-  n = (uInt)((q <= s->write ? s->write : s->end) - q);\n-  if (n > z->avail_out) n = z->avail_out;\n-  if (n && r == Z_BUF_ERROR) r = Z_OK;\n-\n-  /* update counters */\n-  z->avail_out -= n;\n-  z->total_out += n;\n-\n-  /* update check information */\n-  if (s->checkfn != Z_NULL)\n-    z->adler = s->check = (*s->checkfn)(s->check, q, n);\n-\n-  /* copy as far as end of window */\n-  zmemcpy(p, q, n);\n-  p += n;\n-  q += n;\n-\n-  /* see if more to copy at beginning of window */\n-  if (q == s->end)\n-  {\n-    /* wrap pointers */\n-    q = s->window;\n-    if (s->write == s->end)\n-      s->write = s->window;\n-\n-    /* compute bytes to copy */\n-    n = (uInt)(s->write - q);\n-    if (n > z->avail_out) n = z->avail_out;\n-    if (n && r == Z_BUF_ERROR) r = Z_OK;\n-\n-    /* update counters */\n-    z->avail_out -= n;\n-    z->total_out += n;\n-\n-    /* update check information */\n-    if (s->checkfn != Z_NULL)\n-      z->adler = s->check = (*s->checkfn)(s->check, q, n);\n-\n-    /* copy */\n-    zmemcpy(p, q, n);\n-    p += n;\n-    q += n;\n-  }\n-\n-  /* update pointers */\n-  z->next_out = p;\n-  s->read = q;\n-\n-  /* done */\n-  return r;\n-}"}, {"sha": "4401df82fc8914408e75cb9eba7ec5117976544c", "filename": "zlib/infutil.h", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfutil.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Finfutil.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Finfutil.h?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,98 +0,0 @@\n-/* infutil.h -- types and macros common to blocks and codes\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n- */\n-\n-/* WARNING: this file should *not* be used by applications. It is\n-   part of the implementation of the compression library and is\n-   subject to change. Applications should only use zlib.h.\n- */\n-\n-#ifndef _INFUTIL_H\n-#define _INFUTIL_H\n-\n-typedef enum {\n-      TYPE,     /* get type bits (3, including end bit) */\n-      LENS,     /* get lengths for stored */\n-      STORED,   /* processing stored block */\n-      TABLE,    /* get table lengths */\n-      BTREE,    /* get bit lengths tree for a dynamic block */\n-      DTREE,    /* get length, distance trees for a dynamic block */\n-      CODES,    /* processing fixed or dynamic block */\n-      DRY,      /* output remaining window bytes */\n-      DONE,     /* finished last block, done */\n-      BAD}      /* got a data error--stuck here */\n-inflate_block_mode;\n-\n-/* inflate blocks semi-private state */\n-struct inflate_blocks_state {\n-\n-  /* mode */\n-  inflate_block_mode  mode;     /* current inflate_block mode */\n-\n-  /* mode dependent information */\n-  union {\n-    uInt left;          /* if STORED, bytes left to copy */\n-    struct {\n-      uInt table;               /* table lengths (14 bits) */\n-      uInt index;               /* index into blens (or border) */\n-      uIntf *blens;             /* bit lengths of codes */\n-      uInt bb;                  /* bit length tree depth */\n-      inflate_huft *tb;         /* bit length decoding tree */\n-    } trees;            /* if DTREE, decoding info for trees */\n-    struct {\n-      inflate_codes_statef \n-         *codes;\n-    } decode;           /* if CODES, current state */\n-  } sub;                /* submode */\n-  uInt last;            /* true if this block is the last block */\n-\n-  /* mode independent information */\n-  uInt bitk;            /* bits in bit buffer */\n-  uLong bitb;           /* bit buffer */\n-  inflate_huft *hufts;  /* single malloc for tree space */\n-  Bytef *window;        /* sliding window */\n-  Bytef *end;           /* one byte after sliding window */\n-  Bytef *read;          /* window read pointer */\n-  Bytef *write;         /* window write pointer */\n-  check_func checkfn;   /* check function */\n-  uLong check;          /* check on output */\n-\n-};\n-\n-\n-/* defines for inflate input/output */\n-/*   update pointers and return */\n-#define UPDBITS {s->bitb=b;s->bitk=k;}\n-#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}\n-#define UPDOUT {s->write=q;}\n-#define UPDATE {UPDBITS UPDIN UPDOUT}\n-#define LEAVE {UPDATE return inflate_flush(s,z,r);}\n-/*   get bytes and bits */\n-#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}\n-#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}\n-#define NEXTBYTE (n--,*p++)\n-#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}\n-#define DUMPBITS(j) {b>>=(j);k-=(j);}\n-/*   output bytes */\n-#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)\n-#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}\n-#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}\n-#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}\n-#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}\n-#define OUTBYTE(a) {*q++=(Byte)(a);m--;}\n-/*   load local pointers */\n-#define LOAD {LOADIN LOADOUT}\n-\n-/* masks for lower bits (size given to avoid silly warnings with Visual C++) */\n-extern uInt inflate_mask[17];\n-\n-/* copy as much as possible from the sliding window to the output area */\n-extern int inflate_flush OF((\n-    inflate_blocks_statef *,\n-    z_streamp ,\n-    int));\n-\n-struct internal_state      {int dummy;}; /* for buggy compilers */\n-\n-#endif"}, {"sha": "a16d4b14608a7b5026ee4919107752dd2faa44ba", "filename": "zlib/maketree.c", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmaketree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmaketree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmaketree.c?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,85 +0,0 @@\n-/* maketree.c -- make inffixed.h table for decoding fixed codes\n- * Copyright (C) 1995-2002 Mark Adler\n- * For conditions of distribution and use, see copyright notice in zlib.h \n- */\n-\n-/* WARNING: this file should *not* be used by applications. It is\n-   part of the implementation of the compression library and is\n-   subject to change. Applications should only use zlib.h.\n- */\n-\n-/* This program is included in the distribution for completeness.\n-   You do not need to compile or run this program since inffixed.h\n-   is already included in the distribution.  To use this program\n-   you need to compile zlib with BUILDFIXED defined and then compile\n-   and link this program with the zlib library.  Then the output of\n-   this program can be piped to inffixed.h. */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include \"zutil.h\"\n-#include \"inftrees.h\"\n-\n-/* simplify the use of the inflate_huft type with some defines */\n-#define exop word.what.Exop\n-#define bits word.what.Bits\n-\n-/* generate initialization table for an inflate_huft structure array */\n-void maketree(uInt b, inflate_huft *t)\n-{\n-  int i, e;\n-\n-  i = 0;\n-  while (1)\n-  {\n-    e = t[i].exop;\n-    if (e && (e & (16+64)) == 0)        /* table pointer */\n-    {\n-      fprintf(stderr, \"maketree: cannot initialize sub-tables!\\n\");\n-      exit(1);\n-    }\n-    if (i % 4 == 0)\n-      printf(\"\\n   \");\n-    printf(\" {{{%u,%u}},%u}\", t[i].exop, t[i].bits, t[i].base);\n-    if (++i == (1<<b))\n-      break;\n-    putchar(',');\n-  }\n-  puts(\"\");\n-}\n-\n-/* create the fixed tables in C initialization syntax */\n-void main(void)\n-{\n-  int r;\n-  uInt bl, bd;\n-  inflate_huft *tl, *td;\n-  z_stream z;\n-\n-  z.zalloc = zcalloc;\n-  z.opaque = (voidpf)0;\n-  z.zfree = zcfree;\n-  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);\n-  if (r)\n-  {\n-    fprintf(stderr, \"inflate_trees_fixed error %d\\n\", r);\n-    return;\n-  }\n-  puts(\"/* inffixed.h -- table for decoding fixed codes\");\n-  puts(\" * Generated automatically by the maketree.c program\");\n-  puts(\" */\");\n-  puts(\"\");\n-  puts(\"/* WARNING: this file should *not* be used by applications. It is\");\n-  puts(\"   part of the implementation of the compression library and is\");\n-  puts(\"   subject to change. Applications should only use zlib.h.\");\n-  puts(\" */\");\n-  puts(\"\");\n-  printf(\"local uInt fixed_bl = %d;\\n\", bl);\n-  printf(\"local uInt fixed_bd = %d;\\n\", bd);\n-  printf(\"local inflate_huft fixed_tl[] = {\");\n-  maketree(bl, tl);\n-  puts(\"  };\");\n-  printf(\"local inflate_huft fixed_td[] = {\");\n-  maketree(bd, td);\n-  puts(\"  };\");\n-}"}, {"sha": "768a9a73d6fbf600edea6a7a9f56bbd582111e63", "filename": "zlib/minigzip.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fminigzip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fminigzip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fminigzip.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,6 +1,6 @@\n /* minigzip.c -- simulate gzip using the zlib compression library\n  * Copyright (C) 1995-2002 Jean-loup Gailly.\n- * For conditions of distribution and use, see copyright notice in zlib.h \n+ * For conditions of distribution and use, see copyright notice in zlib.h\n  */\n \n /*\n@@ -31,7 +31,7 @@\n #  include <sys/stat.h>\n #endif\n \n-#if defined(MSDOS) || defined(OS2) || defined(WIN32)\n+#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)\n #  include <fcntl.h>\n #  include <io.h>\n #  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)\n@@ -112,7 +112,7 @@ void gz_compress(in, out)\n     if (gz_compress_mmap(in, out) == Z_OK) return;\n #endif\n     for (;;) {\n-        len = fread(buf, 1, sizeof(buf), in);\n+        len = (int)fread(buf, 1, sizeof(buf), in);\n         if (ferror(in)) {\n             perror(\"fread\");\n             exit(1);\n@@ -147,7 +147,7 @@ int gz_compress_mmap(in, out)\n     if (buf_len <= 0) return Z_ERRNO;\n \n     /* Now do the actual mmap: */\n-    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0); \n+    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);\n     if (buf == (caddr_t)(-1)) return Z_ERRNO;\n \n     /* Compress the whole file at once: */\n@@ -179,8 +179,8 @@ void gz_uncompress(in, out)\n         if (len == 0) break;\n \n         if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {\n-\t    error(\"failed fwrite\");\n-\t}\n+            error(\"failed fwrite\");\n+        }\n     }\n     if (fclose(out)) error(\"failed fclose\");\n \n@@ -229,7 +229,7 @@ void file_uncompress(file)\n     char *infile, *outfile;\n     FILE  *out;\n     gzFile in;\n-    int len = strlen(file);\n+    uInt len = (uInt)strlen(file);\n \n     strcpy(buf, file);\n \n@@ -260,10 +260,11 @@ void file_uncompress(file)\n \n \n /* ===========================================================================\n- * Usage:  minigzip [-d] [-f] [-h] [-1 to -9] [files...]\n+ * Usage:  minigzip [-d] [-f] [-h] [-r] [-1 to -9] [files...]\n  *   -d : decompress\n  *   -f : compress with Z_FILTERED\n  *   -h : compress with Z_HUFFMAN_ONLY\n+ *   -r : compress with Z_RLE\n  *   -1 to -9 : compression level\n  */\n \n@@ -282,16 +283,18 @@ int main(argc, argv)\n \n     while (argc > 0) {\n       if (strcmp(*argv, \"-d\") == 0)\n-\tuncompr = 1;\n+        uncompr = 1;\n       else if (strcmp(*argv, \"-f\") == 0)\n-\toutmode[3] = 'f';\n+        outmode[3] = 'f';\n       else if (strcmp(*argv, \"-h\") == 0)\n-\toutmode[3] = 'h';\n+        outmode[3] = 'h';\n+      else if (strcmp(*argv, \"-r\") == 0)\n+        outmode[3] = 'R';\n       else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&\n-\t       (*argv)[2] == 0)\n-\toutmode[2] = (*argv)[1];\n+               (*argv)[2] == 0)\n+        outmode[2] = (*argv)[1];\n       else\n-\tbreak;\n+        break;\n       argc--, argv++;\n     }\n     if (argc == 0) {\n@@ -315,6 +318,5 @@ int main(argc, argv)\n             }\n         } while (argv++, --argc);\n     }\n-    exit(0);\n-    return 0; /* to avoid warning */\n+    return 0;\n }"}, {"sha": "f476da916491d0d14b622ca712e0c74a81036e56", "filename": "zlib/msdos/Makefile.b32", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2FMakefile.b32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2FMakefile.b32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.b32?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06", "patch": "@@ -1,104 +0,0 @@\n-# Makefile for zlib\n-# Borland C++   \n-\n-# This version of the zlib makefile was adapted by Chris Young for use\n-# with Borland C 4.5x with the Dos Power Pack for a 32-bit protected mode\n-# flat memory model.  It was created for use with POV-Ray ray tracer and\n-# you may choose to edit the CFLAGS to suit your needs but the\n-# switches -WX and -DMSDOS are required.\n-# -- Chris Young 76702.1655@compuserve.com\n-\n-# To use, do \"make -fmakefile.b32\"\n-\n-# See zconf.h for details about the memory requirements.\n-\n-# ------------- Borland C++ -------------\n-MODEL=-WX \n-CFLAGS= $(MODEL) -P-C -K -N- -k- -d -3 -r- -v- -f -DMSDOS\n-CC=bcc32\n-LD=bcc32\n-LIB=tlib\n-LDFLAGS= $(MODEL)\n-O=.obj\n-\n-# variables\n-OBJ1 = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \\\n-  trees$(O)\n-OBJP1 = adler32$(O)+compress$(O)+crc32$(O)+gzio$(O)+uncompr$(O)+deflate$(O)+\\\n-  trees$(O)\n-OBJ2 = zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \\\n-  infutil$(O) inffast$(O)\n-OBJP2 = zutil$(O)+inflate$(O)+infblock$(O)+inftrees$(O)+infcodes$(O)+\\\n-  infutil$(O)+inffast$(O)\n-\n-all: test\n-\n-adler32.obj: adler32.c zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-compress.obj: compress.c zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-crc32.obj: crc32.c zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-gzio.obj: gzio.c zutil.h zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-infblock.obj: infblock.c zutil.h zlib.h zconf.h infblock.h inftrees.h\\\n-   infcodes.h infutil.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-infcodes.obj: infcodes.c zutil.h zlib.h zconf.h inftrees.h infutil.h\\\n-   infcodes.h inffast.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-inflate.obj: inflate.c zutil.h zlib.h zconf.h infblock.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-infutil.obj: infutil.c zutil.h zlib.h zconf.h inftrees.h infutil.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-trees.obj: trees.c deflate.h zutil.h zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-uncompr.obj: uncompr.c zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-zutil.obj: zutil.c zutil.h zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-example.obj: example.c zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-minigzip.obj: minigzip.c zlib.h zconf.h\n-\t$(CC) -c $(CFLAGS) $*.c\n-\n-# we must cut the command line to fit in the MS/DOS 128 byte limit:\n-zlib.lib: $(OBJ1) $(OBJ2)\n-\tdel zlib.lib\n-\t$(LIB) zlib +$(OBJP1)\n-\t$(LIB) zlib +$(OBJP2)\n-\n-example.exe: example.obj zlib.lib\n-\t$(LD) $(LDFLAGS) example.obj zlib.lib\n-\n-minigzip.exe: minigzip.obj zlib.lib\n-\t$(LD) $(LDFLAGS) minigzip.obj zlib.lib\n-\n-test: example.exe minigzip.exe\n-\texample\n-\techo hello world | minigzip | minigzip -d \n-\n-#clean:\n-#\tdel *.obj\n-#\tdel *.exe"}, {"sha": "8f8132d12231246d8ffa6d9d640a06f0bf134e00", "filename": "zlib/msdos/Makefile.bor", "status": "modified", "additions": 47, "deletions": 63, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.bor", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.bor", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.bor?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,5 +1,6 @@\n # Makefile for zlib\n-# Borland C++   ************ UNTESTED ***********\n+# Borland C++\n+# Last updated: 15-Mar-2003\n \n # To use, do \"make -fmakefile.bor\"\n # To compile in small model, set below: MODEL=s\n@@ -12,103 +13,83 @@\n #   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14\n # See zconf.h for details about the memory requirements.\n \n-# ------------- Turbo C++, Borland C++ -------------\n+# ------------ Turbo C++, Borland C++ ------------\n \n #    Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)\n #    should be added to the environment via \"set LOCAL_ZLIB=-DFOO\" or added\n #    to the declaration of LOC here:\n LOC = $(LOCAL_ZLIB)\n \n-# Type for CPU required: 0: 8086, 1: 80186, 2: 80286, 3: 80386, etc.\n+# type for CPU required: 0: 8086, 1: 80186, 2: 80286, 3: 80386, etc.\n CPU_TYP = 0\n \n-# Memory model: one of s, m, c, l (small, medium, compact, large)\n+# memory model: one of s, m, c, l (small, medium, compact, large)\n MODEL=l\n \n+# replace bcc with tcc for Turbo C++ 1.0, with bcc32 for the 32 bit version\n CC=bcc\n-#   replace bcc with tcc for Turbo C++ 1.0, with bcc32 for the 32 bit version\n-LD=$(CC)\n+LD=bcc\n AR=tlib\n \n # compiler flags\n+# replace \"-O2\" by \"-O -G -a -d\" for Turbo C++ 1.0\n CFLAGS=-O2 -Z -m$(MODEL) $(LOC)\n-#   replace \"-O2\" by \"-O -G -a -d\" for Turbo C++ 1.0\n \n-LDFLAGS=-m$(MODEL)\n+LDFLAGS=-m$(MODEL) -f-\n \n-O=.obj\n \n # variables\n-OBJ1 = adler32$(O) compress$(O) crc32$(O) gzio$(O) uncompr$(O) deflate$(O) \\\n-  trees$(O)\n-OBJP1 = adler32$(O)+compress$(O)+crc32$(O)+gzio$(O)+uncompr$(O)+deflate$(O)+\\\n-  trees$(O)\n-OBJ2 = zutil$(O) inflate$(O) infblock$(O) inftrees$(O) infcodes$(O) \\\n-  infutil$(O) inffast$(O)\n-OBJP2 = zutil$(O)+inflate$(O)+infblock$(O)+inftrees$(O)+infcodes$(O)+\\\n-  infutil$(O)+inffast$(O)\n-\n-ZLIB_H = zlib.h zconf.h\n-ZUTIL_H = zutil.h $(ZLIB_H)\n-\n ZLIB_LIB = zlib_$(MODEL).lib\n \n-all: test\n+OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj\n+OBJ2 = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj\n+OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj\n+OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj\n \n-# individual dependencies and action rules:\n-adler32.obj: adler32.c $(ZLIB_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n \n-compress.obj: compress.c $(ZLIB_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n+# targets\n+all: $(ZLIB_LIB) example.exe minigzip.exe\n \n-crc32.obj: crc32.c $(ZLIB_H)\n+.c.obj:\n \t$(CC) -c $(CFLAGS) $*.c\n \n-deflate.obj: deflate.c deflate.h $(ZUTIL_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n+adler32.obj: adler32.c zlib.h zconf.h\n \n-gzio.obj: gzio.c $(ZUTIL_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n+compress.obj: compress.c zlib.h zconf.h\n \n-infblock.obj: infblock.c $(ZUTIL_H) infblock.h inftrees.h infcodes.h infutil.h\n-\t$(CC) -c $(CFLAGS) $*.c\n+crc32.obj: crc32.c zlib.h zconf.h crc32.h\n \n-infcodes.obj: infcodes.c $(ZUTIL_H) inftrees.h infutil.h infcodes.h inffast.h\n-\t$(CC) -c $(CFLAGS) $*.c\n+deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h\n \n-inflate.obj: inflate.c $(ZUTIL_H) infblock.h\n-\t$(CC) -c $(CFLAGS) $*.c\n+gzio.obj: gzio.c zutil.h zlib.h zconf.h\n \n-inftrees.obj: inftrees.c $(ZUTIL_H) inftrees.h\n-\t$(CC) -c $(CFLAGS) $*.c\n+infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h inffixed.h\n \n-infutil.obj: infutil.c $(ZUTIL_H) inftrees.h infutil.h\n-\t$(CC) -c $(CFLAGS) $*.c\n+inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h\n \n-inffast.obj: inffast.c $(ZUTIL_H) inftrees.h infutil.h inffast.h\n-\t$(CC) -c $(CFLAGS) $*.c\n+inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \\\n+ inffast.h inffixed.h\n \n-trees.obj: trees.c deflate.h $(ZUTIL_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n+inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h\n \n-uncompr.obj: uncompr.c $(ZLIB_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n+trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h\n \n-zutil.obj: zutil.c $(ZUTIL_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n+uncompr.obj: uncompr.c zlib.h zconf.h\n \n-example.obj: example.c $(ZLIB_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n+zutil.obj: zutil.c zutil.h zlib.h zconf.h\n \n-minigzip.obj: minigzip.c $(ZLIB_H)\n-\t$(CC) -c $(CFLAGS) $*.c\n+example.obj: example.c zlib.h zconf.h\n+\n+minigzip.obj: minigzip.c zlib.h zconf.h\n \n-# we must cut the command line to fit in the MS/DOS 128 byte limit:\n+\n+# the command line is cut to fit in the MS-DOS 128 byte limit:\n $(ZLIB_LIB): $(OBJ1) $(OBJ2)\n-\tdel $(ZLIB_LIB)\n-\t$(AR) $(ZLIB_LIB) +$(OBJP1)\n-\t$(AR) $(ZLIB_LIB) +$(OBJP2)\n+\t-del $(ZLIB_LIB)\n+\t$(AR) $(ZLIB_LIB) $(OBJP1)\n+\t$(AR) $(ZLIB_LIB) $(OBJP2)\n \n example.exe: example.obj $(ZLIB_LIB)\n \t$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)\n@@ -118,8 +99,11 @@ minigzip.exe: minigzip.obj $(ZLIB_LIB)\n \n test: example.exe minigzip.exe\n \texample\n-\techo hello world | minigzip | minigzip -d \n-\n-#clean:\n-#\tdel *.obj\n-#\tdel *.exe\n+\techo hello world | minigzip | minigzip -d\n+\n+clean:\n+\t-del *.obj\n+\t-del *.lib\n+\t-del *.exe\n+\t-del zlib_*.bak\n+\t-del foo.gz"}, {"sha": "283d1d961604b61b875f175ad0b1d31cb515dabe", "filename": "zlib/msdos/Makefile.dj2", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.dj2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.dj2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.dj2?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,15 +1,15 @@\n # Makefile for zlib.  Modified for djgpp v2.0 by F. J. Donahoe, 3/15/96.\n # Copyright (C) 1995-1998 Jean-loup Gailly.\n-# For conditions of distribution and use, see copyright notice in zlib.h \n+# For conditions of distribution and use, see copyright notice in zlib.h\n \n # To compile, or to compile and test, type:\n-# \n+#\n #   make -fmakefile.dj2;  make test -fmakefile.dj2\n-# \n+#\n # To install libz.a, zconf.h and zlib.h in the djgpp directories, type:\n-# \n+#\n #    make install -fmakefile.dj2\n-# \n+#\n # after first defining LIBRARY_PATH and INCLUDE_PATH in djgpp.env as\n # in the sample below if the pattern of the DJGPP distribution is to\n # be followed.  Remember that, while <sp>'es around <=> are ignored in\n@@ -52,21 +52,25 @@ prefix=/usr/local\n exec_prefix = $(prefix)\n \n OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n-       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+       zutil.o inflate.o infback.o inftrees.o inffast.o\n+\n+OBJA =\n+# to use the asm code: make OBJA=match.o\n \n TEST_OBJS = example.o minigzip.o\n \n all: example.exe minigzip.exe\n \n+check: test\n test: all\n \t./example\n-\techo hello world | .\\minigzip | .\\minigzip -d \n+\techo hello world | .\\minigzip | .\\minigzip -d\n \n %.o : %.c\n \t$(CC) $(CFLAGS) -c $< -o $@\n \n-libz.a: $(OBJS)\n-\t$(AR) $@ $(OBJS)\n+libz.a: $(OBJS) $(OBJA)\n+\t$(AR) $@ $(OBJS) $(OBJA)\n \n %.exe : %.o $(LIBS)\n \t$(LD) $@ $< $(LDLIBS)"}, {"sha": "ed4c31fbbde0f797e0a2f4d0f4ea8b438c5eb2a1", "filename": "zlib/msdos/Makefile.emx", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.emx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.emx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.emx?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c", "patch": "@@ -1,11 +1,11 @@\n # Makefile for zlib.  Modified for emx 0.9c by Chr. Spieler, 6/17/98.\n # Copyright (C) 1995-1998 Jean-loup Gailly.\n-# For conditions of distribution and use, see copyright notice in zlib.h \n+# For conditions of distribution and use, see copyright notice in zlib.h\n \n # To compile, or to compile and test, type:\n-# \n+#\n #   make -fmakefile.emx;  make test -fmakefile.emx\n-# \n+#\n \n CC=gcc\n \n@@ -34,15 +34,15 @@ prefix=/usr/local\n exec_prefix = $(prefix)\n \n OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \\\n-       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o\n+       zutil.o inflate.o infback.o inftrees.o inffast.o\n \n TEST_OBJS = example.o minigzip.o\n \n all: example.exe minigzip.exe\n \n test: all\n \t./example\n-\techo hello world | .\\minigzip | .\\minigzip -d \n+\techo hello world | .\\minigzip | .\\minigzip -d\n \n %.o : %.c\n \t$(CC) $(CFLAGS) -c $< -o $@"}, {"sha": "b8fc665efba6464013c2ca947913f9537f26ebb4", "filename": "zlib/msdos/Makefile.msc", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.msc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.msc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.msc?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}, {"sha": "480750ade25c51dcb6c99e0f4e14ff7153effb7a", "filename": "zlib/msdos/Makefile.tc", "status": "modified", "additions": 48, "deletions": 62, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.tc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fmsdos%2FMakefile.tc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.tc?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}, {"sha": "0a05fa9a46968a12d242ecf75453070a5a52be39", "filename": "zlib/msdos/Makefile.w32", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2FMakefile.w32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2FMakefile.w32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.w32?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "44bf8607f6f0060789c90f3656860adca868f18d", "filename": "zlib/msdos/Makefile.wat", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2FMakefile.wat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2FMakefile.wat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2FMakefile.wat?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "6c04412f9b00380763e54499b90d49e282e7f1c3", "filename": "zlib/msdos/zlib.def", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2Fzlib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2Fzlib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2Fzlib.def?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "556d4ff950ab5a26410d5f71d1f11575a5c39e56", "filename": "zlib/msdos/zlib.rc", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2Fzlib.rc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fmsdos%2Fzlib.rc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fmsdos%2Fzlib.rc?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "2d475b1847e11f1ee53b44603a3c1000d55415f2", "filename": "zlib/nt/Makefile.emx", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fnt%2FMakefile.emx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fnt%2FMakefile.emx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.emx?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "cdd652f236028439ef45ebea059d36ccf526caec", "filename": "zlib/nt/Makefile.gcc", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fnt%2FMakefile.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fnt%2FMakefile.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.gcc?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "b250f2ac7d2aab67fa45ea00fff2ca4f8bf59ba8", "filename": "zlib/nt/Makefile.nt", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fnt%2FMakefile.nt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fnt%2FMakefile.nt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2FMakefile.nt?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "7f9475cfb0ee39b4653f03cc5d8a2ceb48ca1eec", "filename": "zlib/nt/zlib.dnt", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fnt%2Fzlib.dnt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fnt%2Fzlib.dnt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fnt%2Fzlib.dnt?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "4f569471ecab93be6d411066c7dc3ed647ec04cc", "filename": "zlib/os2/Makefile.os2", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fos2%2FMakefile.os2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fos2%2FMakefile.os2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fos2%2FMakefile.os2?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "4c753f1a3b993842030429bbdeccdb48f8a86ebe", "filename": "zlib/os2/zlib.def", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fos2%2Fzlib.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fos2%2Fzlib.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fos2%2Fzlib.def?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "7e8c33cf59cba7e975277c0577aff7e86b0466da", "filename": "zlib/trees.c", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Ftrees.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Ftrees.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Ftrees.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}, {"sha": "8519d9bfaf83b67655e5414edb168a64abf8cce3", "filename": "zlib/uncompr.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Funcompr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Funcompr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Funcompr.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}, {"sha": "831285e8efb0c27179a257c4c0b7ca0216bc1a4d", "filename": "zlib/zconf.h", "status": "modified", "additions": 152, "deletions": 108, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzconf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzconf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzconf.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}, {"sha": "890098449dd212d57d14d8214091af27354bedb0", "filename": "zlib/zlib.3", "status": "modified", "additions": 81, "deletions": 29, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzlib.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzlib.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.3?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}, {"sha": "92edf96ff3ecf8c671d06401eb5c2ff2c5162e71", "filename": "zlib/zlib.h", "status": "modified", "additions": 386, "deletions": 79, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}, {"sha": "c34370386936db13cd2855004ef474baa1eed7d8", "filename": "zlib/zlib.html", "status": "removed", "additions": 0, "deletions": 971, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fzlib.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06/zlib%2Fzlib.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzlib.html?ref=1325e2b519f4a1b3d9fbd92ece22bdf3e4df0b06"}, {"sha": "48f45386940bac5ba862a9126786965b85969903", "filename": "zlib/zutil.c", "status": "modified", "additions": 105, "deletions": 11, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzutil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzutil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzutil.c?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}, {"sha": "65d4bd790159dbf968a2cbb272411a21adfa94ff", "filename": "zlib/zutil.h", "status": "modified", "additions": 64, "deletions": 26, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzutil.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17210dff5d26c1e820e0cd678a46cf2795c41e4c/zlib%2Fzutil.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/zlib%2Fzutil.h?ref=17210dff5d26c1e820e0cd678a46cf2795c41e4c"}]}