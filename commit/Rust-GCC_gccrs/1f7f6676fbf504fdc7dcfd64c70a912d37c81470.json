{"sha": "1f7f6676fbf504fdc7dcfd64c70a912d37c81470", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY3ZjY2NzZmYmY1MDRmZGM3ZGNmZDY0YzcwYTkxMmQzN2M4MTQ3MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2008-01-31T09:25:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-01-31T09:25:52Z"}, "message": "re PR target/34995 (MIPS16 ICE in gcc.c-torture/compile/pr34856.c)\n\ngcc/\n\tPR rtl-optimization/34995\n\t* reload.c (alternative_allows_const_pool_ref): Take an rtx\n\tparameter and return a bool.  If the rtx parameter is nonnull,\n\tcheck that it satisfies an EXTRA_MEMORY_CONSTRAINT.\n\t(find_reloads): Update call accordingly.  Pass the new operand\n\tif it needed no address reloads, otherwise pass null.\n\nFrom-SVN: r131976", "tree": {"sha": "67a44fcb3781dd72b17bb7d4adfa08e14a951d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67a44fcb3781dd72b17bb7d4adfa08e14a951d54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f7f6676fbf504fdc7dcfd64c70a912d37c81470", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f7f6676fbf504fdc7dcfd64c70a912d37c81470", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f7f6676fbf504fdc7dcfd64c70a912d37c81470", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f7f6676fbf504fdc7dcfd64c70a912d37c81470/comments", "author": null, "committer": null, "parents": [{"sha": "9a75e92d56e187187bf73194b542b3d3756316a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a75e92d56e187187bf73194b542b3d3756316a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a75e92d56e187187bf73194b542b3d3756316a7"}], "stats": {"total": 55, "additions": 43, "deletions": 12}, "files": [{"sha": "751326a4cc317fa2259db123f6853862465dd0f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f7f6676fbf504fdc7dcfd64c70a912d37c81470/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f7f6676fbf504fdc7dcfd64c70a912d37c81470/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f7f6676fbf504fdc7dcfd64c70a912d37c81470", "patch": "@@ -1,3 +1,12 @@\n+2008-01-31  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR rtl-optimization/34995\n+\t* reload.c (alternative_allows_const_pool_ref): Take an rtx\n+\tparameter and return a bool.  If the rtx parameter is nonnull,\n+\tcheck that it satisfies an EXTRA_MEMORY_CONSTRAINT.\n+\t(find_reloads): Update call accordingly.  Pass the new operand\n+\tif it needed no address reloads, otherwise pass null.\n+\n 2008-01-30  Richard Henderson  <rth@redhat.com>\n \n \tPR c/34993"}, {"sha": "d880097a164634d1f107c921cd0e4f4238baf921", "filename": "gcc/reload.c", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f7f6676fbf504fdc7dcfd64c70a912d37c81470/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f7f6676fbf504fdc7dcfd64c70a912d37c81470/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=1f7f6676fbf504fdc7dcfd64c70a912d37c81470", "patch": "@@ -263,7 +263,7 @@ static rtx find_dummy_reload (rtx, rtx, rtx *, rtx *, enum machine_mode,\n static int hard_reg_set_here_p (unsigned int, unsigned int, rtx);\n static struct decomposition decompose (rtx);\n static int immune_p (rtx, rtx, struct decomposition);\n-static int alternative_allows_memconst (const char *, int);\n+static bool alternative_allows_const_pool_ref (rtx, const char *, int);\n static rtx find_reloads_toplev (rtx, int, enum reload_type, int, int, rtx,\n \t\t\t\tint *);\n static rtx make_memloc (rtx, int);\n@@ -3836,13 +3836,19 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    || no_input_reloads)\n \t&& operand_mode[i] != VOIDmode)\n       {\n+\tint this_address_reloaded;\n+\n+\tthis_address_reloaded = 0;\n \tsubsted_operand[i] = recog_data.operand[i]\n \t  = find_reloads_toplev (force_const_mem (operand_mode[i],\n \t\t\t\t\t\t  recog_data.operand[i]),\n \t\t\t\t i, address_type[i], ind_levels, 0, insn,\n-\t\t\t\t NULL);\n-\tif (alternative_allows_memconst (recog_data.constraints[i],\n-\t\t\t\t\t goal_alternative_number))\n+\t\t\t\t &this_address_reloaded);\n+\tif (alternative_allows_const_pool_ref (this_address_reloaded == 0\n+\t\t\t\t\t       ? substed_operand[i]\n+\t\t\t\t\t       : NULL,\n+\t\t\t\t\t       recog_data.constraints[i],\n+\t\t\t\t\t       goal_alternative_number))\n \t  goal_alternative_win[i] = 1;\n       }\n \n@@ -4498,26 +4504,42 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   return retval;\n }\n \n-/* Return 1 if alternative number ALTNUM in constraint-string CONSTRAINT\n-   accepts a memory operand with constant address.  */\n+/* Return true if alternative number ALTNUM in constraint-string\n+   CONSTRAINT is guaranteed to accept a reloaded constant-pool reference.\n+   MEM gives the reference if it didn't need any reloads, otherwise it\n+   is null.  */\n \n-static int\n-alternative_allows_memconst (const char *constraint, int altnum)\n+static bool\n+alternative_allows_const_pool_ref (rtx mem, const char *constraint, int altnum)\n {\n   int c;\n+\n   /* Skip alternatives before the one requested.  */\n   while (altnum > 0)\n     {\n       while (*constraint++ != ',');\n       altnum--;\n     }\n   /* Scan the requested alternative for 'm' or 'o'.\n-     If one of them is present, this alternative accepts memory constants.  */\n+     If one of them is present, this alternative accepts the result of\n+     passing a constant-pool reference through find_reloads_toplev.\n+\n+     The same is true of extra memory constraints if the address\n+     was reloaded into a register.  However, the target may elect\n+     to disallow the original constant address, forcing it to be\n+     reloaded into a register instead.  */\n   for (; (c = *constraint) && c != ',' && c != '#';\n        constraint += CONSTRAINT_LEN (c, constraint))\n-    if (c == 'm' || c == 'o' || EXTRA_MEMORY_CONSTRAINT (c, constraint))\n-      return 1;\n-  return 0;\n+    {\n+      if (c == 'm' || c == 'o')\n+\treturn true;\n+#ifdef EXTRA_CONSTRAINT_STR\n+      if (EXTRA_MEMORY_CONSTRAINT (c, constraint)\n+\t  && (mem == NULL || EXTRA_CONSTRAINT_STR (mem, c, constraint)))\n+\treturn true;\n+#endif\n+    }\n+  return false;\n }\n \f\n /* Scan X for memory references and scan the addresses for reloading."}]}