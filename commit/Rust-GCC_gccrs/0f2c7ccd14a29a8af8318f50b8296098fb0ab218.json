{"sha": "0f2c7ccd14a29a8af8318f50b8296098fb0ab218", "node_id": "C_kwDOANBUbNoAKDBmMmM3Y2NkMTRhMjlhOGFmODMxOGY1MGI4Mjk2MDk4ZmIwYWIyMTg", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2022-08-12T14:25:28Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2022-08-12T14:25:28Z"}, "message": "Fix invalid devirtualization when combining final keyword and anonymous types\n\nthis patch fixes a wrong code issue where we incorrectly devirtualize to\n__builtin_unreachable.  The problem occurs in combination of anonymous\nnamespaces and final keyword used on methods.  We do two optimizations here\n 1) when reacing final method we cut the search for possible new targets\n 2) if the type is anonymous we detect whether it is ever instatiated by\n    looking if its vtable is referred to.\nNow this goes wrong when thre is an anonymous type with final method that\nis not instantiated while its derived type is.  So if 1 triggers we need\nto make 2 to look for vtables of all derived types as done by this patch.\n\nBootstrpaped/regtested x86_64-linux\n\nHonza\n\ngcc/ChangeLog:\n\n2022-08-10  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR middle-end/106057\n\t* ipa-devirt.cc (type_or_derived_type_possibly_instantiated_p): New\n\tfunction.\n\t(possible_polymorphic_call_targets): Use it.\n\ngcc/testsuite/ChangeLog:\n\n2022-08-10  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR middle-end/106057\n\t* g++.dg/tree-ssa/pr101839.C: New test.", "tree": {"sha": "fe93a91853ba0197baf4082b304b7e579ac0323c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe93a91853ba0197baf4082b304b7e579ac0323c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f2c7ccd14a29a8af8318f50b8296098fb0ab218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2c7ccd14a29a8af8318f50b8296098fb0ab218", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2c7ccd14a29a8af8318f50b8296098fb0ab218", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2c7ccd14a29a8af8318f50b8296098fb0ab218/comments", "author": null, "committer": null, "parents": [{"sha": "88ee126ee0401e293888e7d1b9219ad35eb130b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ee126ee0401e293888e7d1b9219ad35eb130b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ee126ee0401e293888e7d1b9219ad35eb130b5"}], "stats": {"total": 90, "additions": 82, "deletions": 8}, "files": [{"sha": "265d07bb354135e3c0583d613e9f00632174e206", "filename": "gcc/ipa-devirt.cc", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2c7ccd14a29a8af8318f50b8296098fb0ab218/gcc%2Fipa-devirt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2c7ccd14a29a8af8318f50b8296098fb0ab218/gcc%2Fipa-devirt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.cc?ref=0f2c7ccd14a29a8af8318f50b8296098fb0ab218", "patch": "@@ -285,6 +285,19 @@ type_possibly_instantiated_p (tree t)\n   return vnode && vnode->definition;\n }\n \n+/* Return true if T or type derived from T may have instance.  */\n+\n+static bool\n+type_or_derived_type_possibly_instantiated_p (odr_type t)\n+{\n+  if (type_possibly_instantiated_p (t->type))\n+    return true;\n+  for (auto derived : t->derived_types)\n+    if (type_or_derived_type_possibly_instantiated_p (derived))\n+      return true;\n+  return false;\n+}\n+\n /* Hash used to unify ODR types based on their mangled name and for anonymous\n    namespace types.  */\n \n@@ -3172,6 +3185,7 @@ possible_polymorphic_call_targets (tree otr_type,\n     {\n       odr_type speculative_outer_type;\n       bool speculation_complete = true;\n+      bool check_derived_types = false;\n \n       /* First insert target from type itself and check if it may have\n \t derived types.  */\n@@ -3190,8 +3204,12 @@ possible_polymorphic_call_targets (tree otr_type,\n \t to walk derivations.  */\n       if (target && DECL_FINAL_P (target))\n \tcontext.speculative_maybe_derived_type = false;\n-      if (type_possibly_instantiated_p (speculative_outer_type->type))\n-\tmaybe_record_node (nodes, target, &inserted, can_refer, &speculation_complete);\n+      if (check_derived_types\n+\t  ? type_or_derived_type_possibly_instantiated_p\n+\t\t (speculative_outer_type)\n+\t  : type_possibly_instantiated_p (speculative_outer_type->type))\n+\tmaybe_record_node (nodes, target, &inserted, can_refer,\n+\t\t\t   &speculation_complete);\n       if (binfo)\n \tmatched_vtables.add (BINFO_VTABLE (binfo));\n \n@@ -3212,6 +3230,7 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   if (!speculative || !nodes.length ())\n     {\n+      bool check_derived_types = false;\n       /* First see virtual method of type itself.  */\n       binfo = get_binfo_at_offset (TYPE_BINFO (outer_type->type),\n \t\t\t\t   context.offset, otr_type);\n@@ -3229,16 +3248,18 @@ possible_polymorphic_call_targets (tree otr_type,\n       if (target && DECL_CXX_DESTRUCTOR_P (target))\n \tcontext.maybe_in_construction = false;\n \n-      if (target)\n+      /* In the case we get complete method, we don't need \n+\t to walk derivations.  */\n+      if (target && DECL_FINAL_P (target))\n \t{\n-\t  /* In the case we get complete method, we don't need \n-\t     to walk derivations.  */\n-\t  if (DECL_FINAL_P (target))\n-\t    context.maybe_derived_type = false;\n+\t  check_derived_types = true;\n+\t  context.maybe_derived_type = false;\n \t}\n \n       /* If OUTER_TYPE is abstract, we know we are not seeing its instance.  */\n-      if (type_possibly_instantiated_p (outer_type->type))\n+      if (check_derived_types\n+\t  ? type_or_derived_type_possibly_instantiated_p (outer_type)\n+\t  : type_possibly_instantiated_p (outer_type->type))\n \tmaybe_record_node (nodes, target, &inserted, can_refer, &complete);\n       else\n \tskipped = true;"}, {"sha": "bb7b61cad436db139673c88cc472e1709694671d", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr101839.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2c7ccd14a29a8af8318f50b8296098fb0ab218/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr101839.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2c7ccd14a29a8af8318f50b8296098fb0ab218/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr101839.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr101839.C?ref=0f2c7ccd14a29a8af8318f50b8296098fb0ab218", "patch": "@@ -0,0 +1,53 @@\n+// { dg-do run }                                                            \n+// { dg-options \"-O2 -fdump-tree-optimized\" }                                   \n+// { dg-require-effective-target c++11 }\n+\n+#include <string.h>\n+#include <iostream>\n+#include <map>\n+namespace {\n+  struct Buf {\n+    char * buf; int a{0}; int b{0};\n+    Buf(char * b) : buf(b) { }\n+    void add(int v) {\n+      ::memcpy(buf, &v, sizeof(v));\n+      a += sizeof(v);\n+      b += sizeof(v);\n+    }\n+  };\n+  struct A {\n+    virtual void fill(Buf &buf) {\n+      buf.add(type());\n+      buf.add(type());\n+    }\n+    virtual ~A() {}\n+    virtual int type() = 0;\n+  };\n+  struct BA : A {\n+    void fill(Buf &buf) {\n+      A::fill(buf);\n+      buf.add(type());\n+      buf.add(type());\n+    }\n+    int type() final {\n+      return 1;\n+    }\n+  };\n+  struct CBA final : BA {\n+  };\n+  struct CA final : A {\n+    ::std::map<int, int> m;\n+    int type() final {\n+      return 2;\n+    }\n+  };\n+}\n+int main(int argc, char ** ) {\n+  char d[1024];\n+  CBA cba;\n+  Buf buf(d);\n+  cba.fill(buf);\n+  CA ca;\n+  return 0;\n+}\n+// { dg-final { scan-tree-dump-not \"__builtin_unreachable\" \"optimized\" } }"}]}