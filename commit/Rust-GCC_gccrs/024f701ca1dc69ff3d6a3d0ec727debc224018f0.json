{"sha": "024f701ca1dc69ff3d6a3d0ec727debc224018f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI0ZjcwMWNhMWRjNjlmZjNkNmEzZDBlYzcyN2RlYmMyMjQwMThmMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-16T10:21:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-16T10:21:22Z"}, "message": "Optimise CONCAT handling in emit_group_load\n\nThe CONCAT handling in emit_group_load chooses between doing\nan extraction from a single component or forcing the whole\nthing to memory and extracting from there.  The condition for\nthe former (more efficient) option was:\n\n\t  if ((bytepos == 0 && bytelen == slen0)\n\t      || (bytepos != 0 && bytepos + bytelen <= slen))\n\nOn the one hand this seems dangerous, since the second line\nallows bit ranges that start in the first component and leak\ninto the second.  On the other hand it seems strange to allow\nreferences that start after the first byte of the second\ncomponent but not those that start after the first byte\nof the first component.  This led to a pessimisation of\nthings like gcc.dg/builtins-54.c for hppa64-hp-hpux11.23.\n\nThis patch simply checks whether the reference is contained\nwithin a single component.  It also makes sure that we do\nan extraction on anything that doesn't span the whole\ncomponent (even if it's constant).\n\ngcc/\n2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* expr.c (emit_group_load_1): Tighten check for whether an\n\taccess involves only one operand of a CONCAT.  Use extract_bit_field\n\tfor constants if the bit range does span the whole operand.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r242477", "tree": {"sha": "52508ae9bd9955501846133b59b4d7f9e41e762a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52508ae9bd9955501846133b59b4d7f9e41e762a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/024f701ca1dc69ff3d6a3d0ec727debc224018f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/024f701ca1dc69ff3d6a3d0ec727debc224018f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/024f701ca1dc69ff3d6a3d0ec727debc224018f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/024f701ca1dc69ff3d6a3d0ec727debc224018f0/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e0af68921530695ddfd86780a0d955674ef239f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e0af68921530695ddfd86780a0d955674ef239f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e0af68921530695ddfd86780a0d955674ef239f"}], "stats": {"total": 23, "additions": 17, "deletions": 6}, "files": [{"sha": "a9263afaef24272bc68c7802efeb184a2f48ea94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/024f701ca1dc69ff3d6a3d0ec727debc224018f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/024f701ca1dc69ff3d6a3d0ec727debc224018f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=024f701ca1dc69ff3d6a3d0ec727debc224018f0", "patch": "@@ -1,3 +1,11 @@\n+2016-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* expr.c (emit_group_load_1): Tighten check for whether an\n+\taccess involves only one operand of a CONCAT.  Use extract_bit_field\n+\tfor constants if the bit range does span the whole operand.\n+\n 2016-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "985c2b3285f9289eeaac43293f85195b5f3d0d5b", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/024f701ca1dc69ff3d6a3d0ec727debc224018f0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/024f701ca1dc69ff3d6a3d0ec727debc224018f0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=024f701ca1dc69ff3d6a3d0ec727debc224018f0", "patch": "@@ -2175,19 +2175,22 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t{\n \t  unsigned int slen = GET_MODE_SIZE (GET_MODE (src));\n \t  unsigned int slen0 = GET_MODE_SIZE (GET_MODE (XEXP (src, 0)));\n+\t  unsigned int elt = bytepos / slen0;\n+\t  unsigned int subpos = bytepos % slen0;\n \n-\t  if ((bytepos == 0 && bytelen == slen0)\n-\t      || (bytepos != 0 && bytepos + bytelen <= slen))\n+\t  if (subpos + bytelen <= slen0)\n \t    {\n \t      /* The following assumes that the concatenated objects all\n \t\t have the same size.  In this case, a simple calculation\n \t\t can be used to determine the object and the bit field\n \t\t to be extracted.  */\n-\t      tmps[i] = XEXP (src, bytepos / slen0);\n-\t      if (! CONSTANT_P (tmps[i])\n-\t\t  && (!REG_P (tmps[i]) || GET_MODE (tmps[i]) != mode))\n+\t      tmps[i] = XEXP (src, elt);\n+\t      if (subpos != 0\n+\t\t  || subpos + bytelen != slen0\n+\t\t  || (!CONSTANT_P (tmps[i])\n+\t\t      && (!REG_P (tmps[i]) || GET_MODE (tmps[i]) != mode)))\n \t\ttmps[i] = extract_bit_field (tmps[i], bytelen * BITS_PER_UNIT,\n-\t\t\t\t\t     (bytepos % slen0) * BITS_PER_UNIT,\n+\t\t\t\t\t     subpos * BITS_PER_UNIT,\n \t\t\t\t\t     1, NULL_RTX, mode, mode, false);\n \t    }\n \t  else"}]}