{"sha": "2d2ee18641557deba692c286cbc2d8751310f697", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQyZWUxODY0MTU1N2RlYmE2OTJjMjg2Y2JjMmQ4NzUxMzEwZjY5Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-09-20T12:58:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-09-20T12:58:23Z"}, "message": "Fix PEELING_FOR_NITERS calculation (PR 87288)\n\nPEELING_FOR_GAPS now means \"peel one iteration for the epilogue\",\nin much the same way that PEELING_FOR_ALIGNMENT > 0 means\n\"peel that number of iterations for the prologue\".  We weren't\ntaking this into account when deciding whether we needed to peel\nfurther scalar iterations beyond the iterations for \"gaps\" and\n\"alignment\".\n\nOnly the first test failed before the patch.  The other two\nare just for completeness.\n\n2018-09-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR tree-optimization/87288\n\t* tree-vect-loop.c (vect_analyze_loop_2): Take PEELING_FOR_GAPS\n\tinto account when determining PEELING_FOR_NITERS.\n\ngcc/testsuite/\n\tPR tree-optimization/87288\n\t* gcc.dg/vect/pr87288-1.c: New test.\n\t* gcc.dg/vect/pr87288-2.c: Likewise,\n\t* gcc.dg/vect/pr87288-3.c: Likewise.\n\nFrom-SVN: r264440", "tree": {"sha": "d8c4f81ba2a6850b20fcfc807b297787b0a8afe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8c4f81ba2a6850b20fcfc807b297787b0a8afe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d2ee18641557deba692c286cbc2d8751310f697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d2ee18641557deba692c286cbc2d8751310f697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d2ee18641557deba692c286cbc2d8751310f697", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d2ee18641557deba692c286cbc2d8751310f697/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "508a909eca536f7f6a60af9bd7ecea761bd2e8f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508a909eca536f7f6a60af9bd7ecea761bd2e8f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508a909eca536f7f6a60af9bd7ecea761bd2e8f1"}], "stats": {"total": 204, "additions": 201, "deletions": 3}, "files": [{"sha": "f4002840a8cf3325c61c875bc457875fb21ddcdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d2ee18641557deba692c286cbc2d8751310f697", "patch": "@@ -1,3 +1,9 @@\n+2018-09-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/87288\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Take PEELING_FOR_GAPS\n+\tinto account when determining PEELING_FOR_NITERS.\n+\n 2018-09-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/86877"}, {"sha": "c7c8e90b27c5670f7264285d75f3e2ef417201d7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d2ee18641557deba692c286cbc2d8751310f697", "patch": "@@ -1,3 +1,10 @@\n+2018-09-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/87288\n+\t* gcc.dg/vect/pr87288-1.c: New test.\n+\t* gcc.dg/vect/pr87288-2.c: Likewise,\n+\t* gcc.dg/vect/pr87288-3.c: Likewise.\n+\n 2018-09-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/86877"}, {"sha": "0d0a70dff6f21b2f07fecd937d4fe26c0df61513", "filename": "gcc/testsuite/gcc.dg/vect/pr87288-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-1.c?ref=2d2ee18641557deba692c286cbc2d8751310f697", "patch": "@@ -0,0 +1,49 @@\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS / 32)\n+#define MAX_COUNT 4\n+\n+void __attribute__ ((noipa))\n+run (int *restrict a, int *restrict b, int count)\n+{\n+  for (int i = 0; i < count * N; ++i)\n+    {\n+      a[i * 2] = b[i * 2] + count;\n+      a[i * 2 + 1] = count;\n+    }\n+}\n+\n+void __attribute__ ((noipa))\n+check (int *restrict a, int count)\n+{\n+  for (int i = 0; i < count * N; ++i)\n+    if (a[i * 2] != i * 41 + count || a[i * 2 + 1] != count)\n+      __builtin_abort ();\n+  if (a[count * 2 * N] != 999)\n+    __builtin_abort ();\n+}\n+\n+int a[N * MAX_COUNT * 2 + 1], b[N * MAX_COUNT * 2];\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < N * MAX_COUNT; ++i)\n+    {\n+      b[i * 2] = i * 41;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+\n+  for (int i = 0; i <= MAX_COUNT; ++i)\n+    {\n+      a[i * 2 * N] = 999;\n+      run (a, b, i);\n+      check (a, i);\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {LOOP VECTORIZED} 1 \"vect\" { target { { vect_int && vect_perm } && vect_element_align } } } } */"}, {"sha": "e9ff9a0be7c08a9755972717a63025f2825e95cf", "filename": "gcc/testsuite/gcc.dg/vect/pr87288-2.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-2.c?ref=2d2ee18641557deba692c286cbc2d8751310f697", "patch": "@@ -0,0 +1,64 @@\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS / 32)\n+#define MAX_COUNT 4\n+\n+#define RUN_COUNT(COUNT)\t\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\\\n+  run_##COUNT (int *restrict a, int *restrict b)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * COUNT; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\ta[i * 2] = b[i * 2] + COUNT;\t\t\t\\\n+\ta[i * 2 + 1] = COUNT;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+RUN_COUNT (1)\n+RUN_COUNT (2)\n+RUN_COUNT (3)\n+RUN_COUNT (4)\n+\n+void __attribute__ ((noipa))\n+check (int *restrict a, int count)\n+{\n+  for (int i = 0; i < count * N; ++i)\n+    if (a[i * 2] != i * 41 + count || a[i * 2 + 1] != count)\n+      __builtin_abort ();\n+  if (a[count * 2 * N] != 999)\n+    __builtin_abort ();\n+}\n+\n+int a[N * MAX_COUNT * 2 + 1], b[N * MAX_COUNT * 2];\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < N * MAX_COUNT; ++i)\n+    {\n+      b[i * 2] = i * 41;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+\n+  a[N * 2] = 999;\n+  run_1 (a, b);\n+  check (a, 1);\n+\n+  a[N * 4] = 999;\n+  run_2 (a, b);\n+  check (a, 2);\n+\n+  a[N * 6] = 999;\n+  run_3 (a, b);\n+  check (a, 3);\n+\n+  a[N * 8] = 999;\n+  run_4 (a, b);\n+  check (a, 4);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {LOOP VECTORIZED} \"vect\" { target { { vect_int && vect_perm } && vect_element_align } } } } */"}, {"sha": "23f574ccb53268b59b933ec59a5eadaa890007ff", "filename": "gcc/testsuite/gcc.dg/vect/pr87288-3.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr87288-3.c?ref=2d2ee18641557deba692c286cbc2d8751310f697", "patch": "@@ -0,0 +1,64 @@\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS / 32)\n+#define MAX_COUNT 4\n+\n+#define RUN_COUNT(COUNT)\t\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\\\n+  run_##COUNT (int *restrict a, int *restrict b)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N * COUNT + 1; ++i)\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\ta[i * 2] = b[i * 2] + COUNT;\t\t\t\\\n+\ta[i * 2 + 1] = COUNT;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+RUN_COUNT (1)\n+RUN_COUNT (2)\n+RUN_COUNT (3)\n+RUN_COUNT (4)\n+\n+void __attribute__ ((noipa))\n+check (int *restrict a, int count)\n+{\n+  for (int i = 0; i < count * N + 1; ++i)\n+    if (a[i * 2] != i * 41 + count || a[i * 2 + 1] != count)\n+      __builtin_abort ();\n+  if (a[count * 2 * N + 2] != 999)\n+    __builtin_abort ();\n+}\n+\n+int a[N * MAX_COUNT * 2 + 3], b[N * MAX_COUNT * 2 + 2];\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < N * MAX_COUNT + 1; ++i)\n+    {\n+      b[i * 2] = i * 41;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+\n+  a[N * 2 + 2] = 999;\n+  run_1 (a, b);\n+  check (a, 1);\n+\n+  a[N * 4 + 2] = 999;\n+  run_2 (a, b);\n+  check (a, 2);\n+\n+  a[N * 6 + 2] = 999;\n+  run_3 (a, b);\n+  check (a, 3);\n+\n+  a[N * 8 + 2] = 999;\n+  run_4 (a, b);\n+  check (a, 4);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {LOOP VECTORIZED} \"vect\" { target { { vect_int && vect_perm } && vect_element_align } } } } */"}, {"sha": "fdac10bab5acd8d8e914ea134bf5f73bd2efc86a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d2ee18641557deba692c286cbc2d8751310f697/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=2d2ee18641557deba692c286cbc2d8751310f697", "patch": "@@ -2074,14 +2074,22 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n     /* The main loop handles all iterations.  */\n     LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n   else if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t   && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n+\t   && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) >= 0)\n     {\n-      if (!multiple_p (LOOP_VINFO_INT_NITERS (loop_vinfo)\n-\t\t       - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo),\n+      /* Work out the (constant) number of iterations that need to be\n+\t peeled for reasons other than niters.  */\n+      unsigned int peel_niter = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+\tpeel_niter += 1;\n+      if (!multiple_p (LOOP_VINFO_INT_NITERS (loop_vinfo) - peel_niter,\n \t\t       LOOP_VINFO_VECT_FACTOR (loop_vinfo)))\n \tLOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = true;\n     }\n   else if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo)\n+\t   /* ??? When peeling for gaps but not alignment, we could\n+\t      try to check whether the (variable) niters is known to be\n+\t      VF * N + 1.  That's something of a niche case though.  */\n+\t   || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n \t   || !LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&const_vf)\n \t   || ((tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n \t\t< (unsigned) exact_log2 (const_vf))"}]}