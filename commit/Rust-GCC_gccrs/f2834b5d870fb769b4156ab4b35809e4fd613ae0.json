{"sha": "f2834b5d870fb769b4156ab4b35809e4fd613ae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI4MzRiNWQ4NzBmYjc2OWI0MTU2YWI0YjM1ODA5ZTRmZDYxM2FlMA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2015-12-02T15:57:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2015-12-02T15:57:34Z"}, "message": "Track indirect calls for call site information in debug info\n\ngcc/ChangeLog:\n\n\t* dwarf2out.c (dwar2out_var_location): In addition to notes,\n\tprocess indirect calls whose target is compile-time known.\n\tEnhance pattern matching to get the SYMBOL_REF they embed.\n\t(gen_subprogram_die): Handle such calls.\n\t* final.c (final_scan_insn): For call instructions, invoke the\n\tvar_location debug hook only after the call has been emitted.\n\nFrom-SVN: r231185", "tree": {"sha": "a32dc57ea24048ca49e8b206953e1025378e8dc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a32dc57ea24048ca49e8b206953e1025378e8dc7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2834b5d870fb769b4156ab4b35809e4fd613ae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2834b5d870fb769b4156ab4b35809e4fd613ae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2834b5d870fb769b4156ab4b35809e4fd613ae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2834b5d870fb769b4156ab4b35809e4fd613ae0/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff7a55bf56a6f148b29c8fd44ca90c4e535fc2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7a55bf56a6f148b29c8fd44ca90c4e535fc2bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7a55bf56a6f148b29c8fd44ca90c4e535fc2bd"}], "stats": {"total": 117, "additions": 93, "deletions": 24}, "files": [{"sha": "ca0b22e452a0ae7941a849326fddee7dcb301755", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2834b5d870fb769b4156ab4b35809e4fd613ae0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2834b5d870fb769b4156ab4b35809e4fd613ae0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2834b5d870fb769b4156ab4b35809e4fd613ae0", "patch": "@@ -1,3 +1,12 @@\n+2015-12-02  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* dwarf2out.c (dwar2out_var_location): In addition to notes,\n+\tprocess indirect calls whose target is compile-time known.\n+\tEnhance pattern matching to get the SYMBOL_REF they embed.\n+\t(gen_subprogram_die): Handle such calls.\n+\t* final.c (final_scan_insn): For call instructions, invoke the\n+\tvar_location debug hook only after the call has been emitted.\n+\n 2015-12-02  Tom de Vries  <tom@codesourcery.com>\n \n \t* gimplify.c (enum gimplify_omp_var_data): Add enum value"}, {"sha": "6af57b58864317dc7f47c355c74e0049b1de968f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 76, "deletions": 21, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2834b5d870fb769b4156ab4b35809e4fd613ae0/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2834b5d870fb769b4156ab4b35809e4fd613ae0/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f2834b5d870fb769b4156ab4b35809e4fd613ae0", "patch": "@@ -19268,7 +19268,9 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t      rtx tloc = NULL_RTX, tlocc = NULL_RTX;\n \t      rtx arg, next_arg;\n \n-\t      for (arg = NOTE_VAR_LOCATION (ca_loc->call_arg_loc_note);\n+\t      for (arg = (ca_loc->call_arg_loc_note != NULL_RTX\n+\t\t\t  ? NOTE_VAR_LOCATION (ca_loc->call_arg_loc_note)\n+\t\t\t  : NULL_RTX);\n \t\t   arg; arg = next_arg)\n \t\t{\n \t\t  dw_loc_descr_ref reg, val;\n@@ -19291,18 +19293,23 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t    }\n \t\t  if (mode == VOIDmode || mode == BLKmode)\n \t\t    continue;\n-\t\t  if (XEXP (XEXP (arg, 0), 0) == pc_rtx)\n+\t\t  /* Get dynamic information about call target only if we\n+\t\t     have no static information: we cannot generate both\n+\t\t     DW_AT_abstract_origin and DW_AT_GNU_call_site_target\n+\t\t     attributes.  */\n+\t\t  if (ca_loc->symbol_ref == NULL_RTX)\n \t\t    {\n-\t\t      gcc_assert (ca_loc->symbol_ref == NULL_RTX);\n-\t\t      tloc = XEXP (XEXP (arg, 0), 1);\n-\t\t      continue;\n-\t\t    }\n-\t\t  else if (GET_CODE (XEXP (XEXP (arg, 0), 0)) == CLOBBER\n-\t\t\t   && XEXP (XEXP (XEXP (arg, 0), 0), 0) == pc_rtx)\n-\t\t    {\n-\t\t      gcc_assert (ca_loc->symbol_ref == NULL_RTX);\n-\t\t      tlocc = XEXP (XEXP (arg, 0), 1);\n-\t\t      continue;\n+\t\t      if (XEXP (XEXP (arg, 0), 0) == pc_rtx)\n+\t\t\t{\n+\t\t\t  tloc = XEXP (XEXP (arg, 0), 1);\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t      else if (GET_CODE (XEXP (XEXP (arg, 0), 0)) == CLOBBER\n+\t\t\t       && XEXP (XEXP (XEXP (arg, 0), 0), 0) == pc_rtx)\n+\t\t\t{\n+\t\t\t  tlocc = XEXP (XEXP (arg, 0), 1);\n+\t\t\t  continue;\n+\t\t\t}\n \t\t    }\n \t\t  reg = NULL;\n \t\t  if (REG_P (XEXP (XEXP (arg, 0), 0)))\n@@ -22289,6 +22296,7 @@ dwarf2out_var_location (rtx_insn *loc_note)\n   char loclabel[MAX_ARTIFICIAL_LABEL_BYTES + 2];\n   struct var_loc_node *newloc;\n   rtx_insn *next_real, *next_note;\n+  rtx_insn *call_insn = NULL;\n   static const char *last_label;\n   static const char *last_postcall_label;\n   static bool last_in_cold_section_p;\n@@ -22303,6 +22311,35 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t  call_site_count++;\n \t  if (SIBLING_CALL_P (loc_note))\n \t    tail_call_site_count++;\n+\t  if (optimize == 0 && !flag_var_tracking)\n+\t    {\n+\t      /* When the var-tracking pass is not running, there is no note\n+\t\t for indirect calls whose target is compile-time known. In this\n+\t\t case, process such calls specifically so that we generate call\n+\t\t sites for them anyway.  */\n+\t      rtx x = PATTERN (loc_note);\n+\t      if (GET_CODE (x) == PARALLEL)\n+\t\tx = XVECEXP (x, 0, 0);\n+\t      if (GET_CODE (x) == SET)\n+\t\tx = SET_SRC (x);\n+\t      if (GET_CODE (x) == CALL)\n+\t\tx = XEXP (x, 0);\n+\t      if (!MEM_P (x)\n+\t\t  || GET_CODE (XEXP (x, 0)) != SYMBOL_REF\n+\t\t  || !SYMBOL_REF_DECL (XEXP (x, 0))\n+\t\t  || (TREE_CODE (SYMBOL_REF_DECL (XEXP (x, 0)))\n+\t\t      != FUNCTION_DECL))\n+\t\t{\n+\t\t  call_insn = loc_note;\n+\t\t  loc_note = NULL;\n+\t\t  var_loc_p = false;\n+\n+\t\t  next_real = next_real_insn (call_insn);\n+\t\t  next_note = NULL;\n+\t\t  cached_next_real_insn = NULL;\n+\t\t  goto create_label;\n+\t\t}\n+\t    }\n \t}\n       return;\n     }\n@@ -22348,6 +22385,8 @@ dwarf2out_var_location (rtx_insn *loc_note)\n       && !NOTE_DURING_CALL_P (loc_note))\n     return;\n \n+create_label:\n+\n   if (next_real == NULL_RTX)\n     next_real = get_last_insn ();\n \n@@ -22427,12 +22466,16 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t}\n     }\n \n+  gcc_assert ((loc_note == NULL_RTX && call_insn != NULL_RTX)\n+\t      || (loc_note != NULL_RTX && call_insn == NULL_RTX));\n+\n   if (!var_loc_p)\n     {\n       struct call_arg_loc_node *ca_loc\n \t= ggc_cleared_alloc<call_arg_loc_node> ();\n-      rtx_insn *prev = prev_real_insn (loc_note);\n-      rtx x;\n+      rtx_insn *prev\n+        = loc_note != NULL_RTX ? prev_real_insn (loc_note) : call_insn;\n+\n       ca_loc->call_arg_loc_note = loc_note;\n       ca_loc->next = NULL;\n       ca_loc->label = last_label;\n@@ -22444,23 +22487,35 @@ dwarf2out_var_location (rtx_insn *loc_note)\n       if (!CALL_P (prev))\n \tprev = as_a <rtx_sequence *> (PATTERN (prev))->insn (0);\n       ca_loc->tail_call_p = SIBLING_CALL_P (prev);\n-      x = get_call_rtx_from (PATTERN (prev));\n+\n+      /* Look for a SYMBOL_REF in the \"prev\" instruction.  */\n+      rtx x = get_call_rtx_from (PATTERN (prev));\n       if (x)\n \t{\n-\t  x = XEXP (XEXP (x, 0), 0);\n-\t  if (GET_CODE (x) == SYMBOL_REF\n-\t      && SYMBOL_REF_DECL (x)\n-\t      && TREE_CODE (SYMBOL_REF_DECL (x)) == FUNCTION_DECL)\n-\t    ca_loc->symbol_ref = x;\n+\t  /* Try to get the call symbol, if any.  */\n+\t  if (MEM_P (XEXP (x, 0)))\n+\t    x = XEXP (x, 0);\n+\t  /* First, look for a memory access to a symbol_ref.  */\n+\t  if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t      && SYMBOL_REF_DECL (XEXP (x, 0))\n+\t      && TREE_CODE (SYMBOL_REF_DECL (XEXP (x, 0))) == FUNCTION_DECL)\n+\t    ca_loc->symbol_ref = XEXP (x, 0);\n+\t  /* Otherwise, look at a compile-time known user-level function\n+\t     declaration.  */\n+\t  else if (MEM_P (x)\n+\t\t   && MEM_EXPR (x)\n+\t\t   && TREE_CODE (MEM_EXPR (x)) == FUNCTION_DECL)\n+\t    ca_loc->symbol_ref = XEXP (DECL_RTL (MEM_EXPR (x)), 0);\n \t}\n+\n       ca_loc->block = insn_scope (prev);\n       if (call_arg_locations)\n \tcall_arg_loc_last->next = ca_loc;\n       else\n \tcall_arg_locations = ca_loc;\n       call_arg_loc_last = ca_loc;\n     }\n-  else if (!NOTE_DURING_CALL_P (loc_note))\n+  else if (loc_note != NULL_RTX && !NOTE_DURING_CALL_P (loc_note))\n     newloc->label = last_label;\n   else\n     {"}, {"sha": "8cb55332e3d3ad2f8d56477b26f3dceb0c5ddce7", "filename": "gcc/final.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2834b5d870fb769b4156ab4b35809e4fd613ae0/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2834b5d870fb769b4156ab4b35809e4fd613ae0/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f2834b5d870fb769b4156ab4b35809e4fd613ae0", "patch": "@@ -2995,7 +2995,8 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    && targetm.asm_out.unwind_emit)\n \t  targetm.asm_out.unwind_emit (asm_out_file, insn);\n \n-\tif (rtx_call_insn *call_insn = dyn_cast <rtx_call_insn *> (insn))\n+\trtx_call_insn *call_insn = dyn_cast <rtx_call_insn *> (insn);\n+\tif (call_insn != NULL)\n \t  {\n \t    rtx x = call_from_call_insn (call_insn);\n \t    x = XEXP (x, 0);\n@@ -3007,8 +3008,6 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t\tif (t)\n \t\t  assemble_external (t);\n \t      }\n-\t    if (!DECL_IGNORED_P (current_function_decl))\n-\t      debug_hooks->var_location (insn);\n \t  }\n \n \t/* Output assembler code from the template.  */\n@@ -3024,6 +3023,12 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    && targetm.asm_out.unwind_emit)\n \t  targetm.asm_out.unwind_emit (asm_out_file, insn);\n \n+\t/* Let the debug info back-end know about this call.  We do this only\n+\t   after the instruction has been emitted because labels that may be\n+\t   created to reference the call instruction must appear after it.  */\n+\tif (call_insn != NULL && !DECL_IGNORED_P (current_function_decl))\n+\t  debug_hooks->var_location (insn);\n+\n \tcurrent_output_insn = debug_insn = 0;\n       }\n     }"}]}