{"sha": "cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhNjE4YWMxZmJiOTNiM2I3NGYxODYxZmU3NDFkNmRmMWJkYWM0Mg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-07-28T23:55:00Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-07-28T23:55:00Z"}, "message": "cfglayout.c, [...]: Fix comment typos.\n\n\t* cfglayout.c, config/arm/arm.c, config/arm/cortex-a8.md,\n\tconfig/arm/neon-schedgen.ml, config/arm/neon.ml,\n\tconfig/arm/vec-common.md, config/ia64/div.md, cselib.c,\n\tdf-core.c, df.h, dominance.c, optabs.c, opts.c, reg-stack.c,\n\tregstat.c, target.h, tree-ssa-live.c, tree-ssa-pre.c,\n\ttree-vect-transform.c, tree.def: Fix comment typos.  Follow\n\tspelling conventions.\n\t* doc/invoke.texi: Follow spelling conventions.\n\nFrom-SVN: r127030", "tree": {"sha": "def25d7a21ae681586ef447d7554b6b4d334b0d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/def25d7a21ae681586ef447d7554b6b4d334b0d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/comments", "author": null, "committer": null, "parents": [{"sha": "1207ac677d44f3d8480cb764a2cf6bc60debd850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1207ac677d44f3d8480cb764a2cf6bc60debd850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1207ac677d44f3d8480cb764a2cf6bc60debd850"}], "stats": {"total": 67, "additions": 39, "deletions": 28}, "files": [{"sha": "009b33328405527e547dd7ebb170a71d6a9c2523", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -1,3 +1,14 @@\n+2007-07-28  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* cfglayout.c, config/arm/arm.c, config/arm/cortex-a8.md,\n+\tconfig/arm/neon-schedgen.ml, config/arm/neon.ml,\n+\tconfig/arm/vec-common.md, config/ia64/div.md, cselib.c,\n+\tdf-core.c, df.h, dominance.c, optabs.c, opts.c, reg-stack.c,\n+\tregstat.c, target.h, tree-ssa-live.c, tree-ssa-pre.c,\n+\ttree-vect-transform.c, tree.def: Fix comment typos.  Follow\n+\tspelling conventions.\n+\t* doc/invoke.texi: Follow spelling conventions.\n+\n 2007-07-29  Vladimir Yanovsky  <yanov@il.ibm.com>\n             Revital Eres  <eres@il.ibm.com>\n "}, {"sha": "7782096800e274e36202449a250d9b7a44e09895", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -1001,7 +1001,7 @@ force_one_exit_fallthru (void)\n \tredirect_edge_and_branch_force (e, forwarder);\n     }\n \n-  /* Fix up the chain of blocks -- make FORWARDER immediately preceed the\n+  /* Fix up the chain of blocks -- make FORWARDER immediately precede the\n      exit block.  */\n   FOR_EACH_BB (bb)\n     {"}, {"sha": "6424498f2cff9a71a3d0222c3fa941058102219d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -6083,7 +6083,7 @@ neon_valid_immediate (rtx op, enum machine_mode mode, int inverse,\n     {\n       unsigned HOST_WIDE_INT imm = 0;\n \n-      /* Un-invert bytes of recognized vector, if neccessary.  */\n+      /* Un-invert bytes of recognized vector, if necessary.  */\n       if (invmask != 0)\n         for (i = 0; i < idx; i++)\n           bytes[i] ^= invmask;\n@@ -6212,7 +6212,7 @@ neon_pairwise_reduce (rtx op0, rtx op1, enum machine_mode mode,\n     }\n }\n \n-/* Initialise a vector with non-constant elements.  FIXME: We can do better\n+/* Initialize a vector with non-constant elements.  FIXME: We can do better\n    than the current implementation (building a vector on the stack and then\n    loading it) in many cases.  See rs6000.c.  */\n \n@@ -12664,7 +12664,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       break;\n \n     /* %# is a \"break\" sequence. It doesn't output anything, but is used to\n-       seperate e.g. operand numbers from following text, if that text consists\n+       separate e.g. operand numbers from following text, if that text consists\n        of further digits which we don't want to be part of the operand\n        number.  */\n     case '#':"}, {"sha": "e8ff16298c9a19addf8b2d5b76158f99d05cf628", "filename": "gcc/config/arm/cortex-a8.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Fcortex-a8.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Fcortex-a8.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-a8.md?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -129,7 +129,7 @@\n                \"arm_no_early_alu_shift_value_dep\")\n \n ;; Multiplication instructions.  These are categorized according to their\n-;; reservation behaviour and the need below to distinguish certain\n+;; reservation behavior and the need below to distinguish certain\n ;; varieties for bypasses.  Results are available at the E5 stage\n ;; (but some of these are multi-cycle instructions which explains the\n ;; latencies below).\n@@ -245,7 +245,7 @@\n ;; reads the value to be stored at the start of E3 and the ALU insn\n ;; writes it at the end of E2.  Move instructions actually produce the\n ;; result at the end of E1, but since we don't have delay slots, the\n-;; scheduling behaviour will be the same.\n+;; scheduling behavior will be the same.\n (define_bypass 0 \"cortex_a8_alu,cortex_a8_alu_shift,\\\n                   cortex_a8_alu_shift_reg,cortex_a8_mov\"\n                \"cortex_a8_store1_2,cortex_a8_store3_4\""}, {"sha": "c1094e9b0384977f4afb7bcffc025e492703f4c3", "filename": "gcc/config/arm/neon-schedgen.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Fneon-schedgen.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Fneon-schedgen.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon-schedgen.ml?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -63,7 +63,7 @@ type availability = Source of int\n \n type guard = Guard_none | Guard_only_m | Guard_only_n | Guard_only_d\n \n-(* Reservation behaviours.  All but the last row here correspond to one\n+(* Reservation behaviors.  All but the last row here correspond to one\n    pipeline each.  Each constructor will correspond to one\n    define_reservation.  *)\n type reservation =\n@@ -78,7 +78,7 @@ type reservation =\n | Fmul_then_fadd | Fmul_then_fadd_2\n \n (* This table must be kept as short as possible by conflating\n-   entries with the same availability behaviour.\n+   entries with the same availability behavior.\n \n    First components: instruction group names\n    Second components: availability requirements, in the order in which"}, {"sha": "39807a48d374c1bd7fc124470dce238e54cbb277", "filename": "gcc/config/arm/neon.ml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Fneon.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Fneon.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.ml?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -177,7 +177,7 @@ type opcode =\n   (* Set/extract lanes from a vector.  *)\n   | Vget_lane\n   | Vset_lane\n-  (* Initialise vector from bit pattern.  *)\n+  (* Initialize vector from bit pattern.  *)\n   | Vcreate\n   (* Set all lanes to same value.  *)\n   | Vdup_n\n@@ -227,7 +227,7 @@ type features =\n        names.  *)\n   | Instruction_name of string list\n     (* Mark that the intrinsic yields no instructions, or expands to yield\n-       behaviour that the test generator cannot test.  *)\n+       behavior that the test generator cannot test.  *)\n   | No_op\n     (* Mark that the intrinsic has constant arguments that cannot be set\n        to the defaults (zero for pointers and one otherwise) in the test"}, {"sha": "9d576ab51f967dfe9d87258021845ad699f95bef", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -42,7 +42,7 @@\n })\n \n ;; Vector arithmetic. Expanders are blank, then unnamed insns implement\n-;; patterns seperately for IWMMXT and Neon.\n+;; patterns separately for IWMMXT and Neon.\n \n (define_expand \"add<mode>3\"\n   [(set (match_operand:VALL 0 \"s_register_operand\" \"\")"}, {"sha": "e66a8a052882653feefd51d2548c5260e2b071e3", "filename": "gcc/config/ia64/div.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Fia64%2Fdiv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fconfig%2Fia64%2Fdiv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fdiv.md?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -195,7 +195,7 @@\n    operands[2] = gen_rtx_REG (<MODE>mode, REGNO (operands[1]));\n })\n \n-;; Reciprical approximation\n+;; Reciprocal approximation\n \n (define_insn \"recip_approx_rf\"\n   [(set (match_operand:RF 0 \"fr_register_operand\" \"=f\")"}, {"sha": "1561762c931549e0ee8671bbae4b38901dac210e", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -953,7 +953,7 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n \t\t STACK_POINTER_REGNUM, FRAME_POINTER or the\n \t\t HARD_FRAME_POINTER.\n \n-\t\t Thses expansions confuses the code that notices that\n+\t\t These expansions confuses the code that notices that\n \t\t stores into the frame go dead at the end of the\n \t\t function and that the frame is not effected by calls\n \t\t to subroutines.  If you allow the"}, {"sha": "453d61a999fe814c26b65031a9ced5ac1a315bc7", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -144,7 +144,7 @@ There are four ways of doing the incremental scanning:\n    For most modern rtl passes, this is certainly the easiest way to\n    manage rescanning the insns.  This technique also has the advantage\n    that the scanning information is always correct and can be relied\n-   apon even after changes have been made to the instructions.  This\n+   upon even after changes have been made to the instructions.  This\n    technique is contra indicated in several cases:\n \n    a) If def-use chains OR use-def chains (but not both) are built,"}, {"sha": "d5c8d7ec126ad2470237d837a845f4a385c47fc1", "filename": "gcc/df.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -311,7 +311,7 @@ struct dataflow\n struct df_mw_hardreg\n {\n   rtx mw_reg;                   /* The multiword hardreg.  */ \n-  /* These two bitfields are intentially oversized, in the hope that\n+  /* These two bitfields are intentionally oversized, in the hope that\n      accesses to 16-bit fields will usually be quicker.  */\n   ENUM_BITFIELD(df_ref_type) type : 16;\n \t\t\t\t/* Used to see if the ref is read or write.  */\n@@ -360,7 +360,7 @@ struct df_ref\n   unsigned int ref_order;\n \n   unsigned int regno;\t\t/* The register number referenced.  */\n-  /* These two bitfields are intentially oversized, in the hope that\n+  /* These two bitfields are intentionally oversized, in the hope that\n      accesses to 16-bit fields will usually be quicker.  */\n   ENUM_BITFIELD(df_ref_type) type : 16;\n \t\t\t\t/* Type of ref.  */"}, {"sha": "49e29825ea090bf1cbc54473108e43dadcff2f1c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -1858,7 +1858,7 @@ been permitted when this option was not used.\n In new code it is better to use @option{-fvisibility=hidden} and\n export those classes which are intended to be externally visible.\n Unfortunately it is possible for code to rely, perhaps accidentally,\n-on the Visual Studio behaviour.\n+on the Visual Studio behavior.\n \n Among the consequences of these changes are that static data members\n of the same type with the same name but defined in different shared"}, {"sha": "ecb7f987fe4026f1923867666be7155f96489433", "filename": "gcc/dominance.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -1448,7 +1448,7 @@ debug_dominance_info (enum cdi_direction dir)\n }\n \n /* Prints to stderr representation of the dominance tree (for direction DIR)\n-   rooted in ROOT, indented by INDENT tabelators.  If INDENT_FIRST is false,\n+   rooted in ROOT, indented by INDENT tabulators.  If INDENT_FIRST is false,\n    the first line of the output is not indented.  */\n \n static void"}, {"sha": "d9346e59615ec63161c8a43f085176e3362a746c", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -4071,7 +4071,7 @@ emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n     {\n       /* If we're not emitting a branch, callers are required to pass\n \t operands in an order conforming to canonical RTL.  We relax this\n-\t for commutative comparsions so callers using EQ don't need to do\n+\t for commutative comparisons so callers using EQ don't need to do\n \t swapping by hand.  */\n       gcc_assert (label || (comparison == swap_condition (comparison)));\n "}, {"sha": "d6f0ec153ac08a78d1419b23dd296457f9310d22", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -91,7 +91,7 @@ enum debug_info_level debug_info_level = DINFO_LEVEL_NONE;\n    generated in the object file of the corresponding source file.\n    Both of these case are handled when the base name of the file of\n    the struct definition matches the base name of the source file\n-   of thet current compilation unit.  This matching emits minimal\n+   of the current compilation unit.  This matching emits minimal\n    struct debugging information.\n \n    The base file name matching rule above will fail to emit debug"}, {"sha": "217c43e5eb98e11fcbfc908b7ec11363244f356d", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -1355,9 +1355,9 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t}\n       /* Uninitialized USE might happen for functions returning uninitialized\n          value.  We will properly initialize the USE on the edge to EXIT_BLOCK,\n-\t so it is safe to ignore the use here. This is consistent with behaviour\n+\t so it is safe to ignore the use here. This is consistent with behavior\n \t of dataflow analyzer that ignores USE too.  (This also imply that \n-\t forcingly initializing the register to NaN here would lead to ICE later,\n+\t forcibly initializing the register to NaN here would lead to ICE later,\n \t since the REG_DEAD notes are not issued.)  */\n       break;\n "}, {"sha": "9f8e41f35afe488385702d4e7ee903da46022037", "filename": "gcc/regstat.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -395,7 +395,7 @@ regstat_get_setjmp_crosses (void)\n    Process REG_N_CALLS_CROSSED.  \n \n    This is used by sched_deps.  A good implementation of sched-deps\n-   would really process the blocks directly rather than going thur\n+   would really process the blocks directly rather than going through\n    lists of insns.  If it did this, it could use the exact regs that\n    cross an individual call rather than using this info that merges\n    the info for all calls."}, {"sha": "760656c43a0abe0aecef487c9c02298f4df2938e", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -420,7 +420,7 @@ struct gcc_target\n     int (*builtin_vectorization_cost) (bool);\n \n     /* Return true if vector alignment is reachable (by peeling N\n-       interations) for the given type.  */\n+       iterations) for the given type.  */\n     bool (* vector_alignment_reachable) (tree, bool);\n   } vectorize;\n "}, {"sha": "0fba499fe472c212accf39c966c8b7655ba836c6", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -461,7 +461,7 @@ mark_scope_block_unused (tree scope)\n \tor there is precisely one subblocks and the block\n \thas same abstract origin as outer block and declares\n \tno variables, so it is pure wrapper.\n-   When we are not outputting full debug info, we also elliminate dead variables\n+   When we are not outputting full debug info, we also eliminate dead variables\n    out of scope blocks to let them to be recycled by GGC and to save copying work\n    done by the inliner.  */\n "}, {"sha": "1cebc4a5e8657abc89e891dc8f3d541206729e75", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -1431,7 +1431,7 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n   return NULL;\n }\n \n-/* Determine if EXPR, a memory expressionn, is ANTIC_IN at the top of\n+/* Determine if EXPR, a memory expression, is ANTIC_IN at the top of\n    BLOCK by seeing if it is not killed in the block.  Note that we are\n    only determining whether there is a store that kills it.  Because\n    of the order in which clean iterates over values, we are guaranteed"}, {"sha": "642437cbbdf537a86e5cbd0ec00430e3e0ba7517", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -265,7 +265,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n       /* If the number of iterations is unknown, or the\n \t peeling-for-misalignment amount is unknown, we eill have to generate\n-\t a runtime test to test the loop count agains the threshold.  */\n+\t a runtime test to test the loop count against the threshold.  */\n       if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n \t  || (byte_misalign < 0))\n \truntime_test = true;"}, {"sha": "aa95cb1db316c705546a7efa0d64148c02ec7d5c", "filename": "gcc/tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea618ac1fbb93b3b74f1861fe741d6df1bdac42/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=cea618ac1fbb93b3b74f1861fe741d6df1bdac42", "patch": "@@ -884,7 +884,7 @@ DEFTREECODE (EH_FILTER_EXPR, \"eh_filter_expr\", tcc_statement, 2)\n    has no value and generates no executable code.  It is only used for\n    type based alias analysis.  This is generated by C++ placement new.\n    CHANGE_DYNAMIC_TYPE_NEW_TYPE, the first operand, is the new type.\n-   CHNAGE_DYNAMIC_TYPE_LOCATION, the second operand, is the location\n+   CHANGE_DYNAMIC_TYPE_LOCATION, the second operand, is the location\n    whose type is being changed.  */\n DEFTREECODE (CHANGE_DYNAMIC_TYPE_EXPR, \"change_dynamic_type_expr\",\n \t     tcc_statement, 2)"}]}