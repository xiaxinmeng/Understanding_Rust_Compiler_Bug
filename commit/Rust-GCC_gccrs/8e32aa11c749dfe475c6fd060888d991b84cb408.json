{"sha": "8e32aa11c749dfe475c6fd060888d991b84cb408", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUzMmFhMTFjNzQ5ZGZlNDc1YzZmZDA2MDg4OGQ5OTFiODRjYjQwOA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2009-11-06T22:15:17Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-11-06T22:15:17Z"}, "message": "user.cfg.in: Adjust includes.\n\n2009-11-06  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* doc/doxygen/user.cfg.in: Adjust includes.\n\n\t* doc/doxygen/doxygroups.cc: Move group markup.\n\t* include/tr1_impl/regex: Change \" to '. Add group markup.\n\t* include/std/utility: Same.\n\t* include/std/type_traits: Same.\n\t* include/std/streambuf: Same.\n\t* include/std/iosfwd: Same.\n\t* include/std/limits: Same.\n\t* include/std/sstream: Same.\n\t* include/profile/impl/profiler_state.h: Same.\n\t* include/profile/impl/profiler_hashtable_size.h: Same.\n\t* include/bits/stl_algobase.h: Same.\n\t* include/bits/stl_iterator_base_types.h: Same.\n\t* include/bits/stream_iterator.h: Same.\n\t* include/bits/stl_iterator.h: Same.\n\t* include/bits/stl_tempbuf.h: Same.\n\t* include/bits/streambuf_iterator.h: Same.\n\t* libsupc++/exception: Same.\n\t* libsupc++/cxxabi.h: Same.\n\t* include/tr1_impl/type_traits: Same.\n\n\t* include/parallel/multiway_merge.h: Change @__c to @c, @__f to @f.\n\t* include/parallel/list_partition.h: Same.\n\t* include/parallel/for_each.h: Same.\n\t* include/parallel/workstealing.h: Same.\n\t* include/parallel/base.h: Same.\n\t* include/parallel/equally_split.h: Same.\n\t* include/parallel/random_shuffle.h: Same.\n\t* include/parallel/balanced_quicksort.h: Same.\n\t* include/parallel/merge.h: Same.\n\t* include/parallel/multiway_mergesort.h: Same.\n\t* include/parallel/compatibility.h: Same.\n\t* include/parallel/queue.h: Same.\n\t* include/parallel/checkers.h: Same.\n\t* include/parallel/random_number.h: Same.\n\n\n\t* include/c_global/csignal: Change # to \\#.\n\t* include/c_global/cstdlib: Same.\n\t* include/c_global/cstdio: Same.\n\t* include/c_global/cstdarg: Same.\n\t* include/c_global/cctype: Same.\n\t* include/c_global/cerrno: Same.\n\t* include/c_global/cstdatomic: Same.\n\t* include/c_global/cmath: Same.\n\t* include/c_global/ciso646: Same.\n\t* include/c_global/ctime: Same.\n\t* include/c_global/clocale: Same.\n\t* include/c_global/climits: Same.\n\t* include/c_global/cassert: Same.\n\t* include/c_global/csetjmp: Same.\n\t* include/c_global/cwchar: Same.\n\t* include/c_global/cfloat: Same.\n\t* include/c_global/cstring: Same.\n\t* include/c_global/cstddef: Same.\n\t* include/c_global/cwctype: Same.\n\n\t* include/std/memory: Only dance around boost_sp_counted_base.h.\n\t* include/tr1_impl/boost_sp_counted_base.h: Add markup.\n\t* include/tr1/shared_ptr.h: Strip markup.\n\t* include/bits/shared_ptr.h: Move base types...\n\t* include/bits/shared_ptr_base.h: ...here.\n\t* include/Makefile.am: Add.\n\t* include/Makefile.in: Regenerate.\n\t* configure: Same.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc:\n\tAdjust line numbers.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc: Same.\n\nFrom-SVN: r153980", "tree": {"sha": "18e41634136fbd7b3d518ae6f5ba39007ee5497e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18e41634136fbd7b3d518ae6f5ba39007ee5497e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e32aa11c749dfe475c6fd060888d991b84cb408", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e32aa11c749dfe475c6fd060888d991b84cb408", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e32aa11c749dfe475c6fd060888d991b84cb408", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e32aa11c749dfe475c6fd060888d991b84cb408/comments", "author": null, "committer": null, "parents": [{"sha": "2fdbecf6fe8914be5117a958bb7d74cf1510aa61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fdbecf6fe8914be5117a958bb7d74cf1510aa61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fdbecf6fe8914be5117a958bb7d74cf1510aa61"}], "stats": {"total": 3123, "additions": 1611, "deletions": 1512}, "files": [{"sha": "8661b23700d7f7ca536e77a234fdbe6b49e71794", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -1,3 +1,75 @@\n+2009-11-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* doc/doxygen/user.cfg.in: Adjust includes.\n+\n+\t* doc/doxygen/doxygroups.cc: Move group markup.\n+\t* include/tr1_impl/regex: Change \" to '. Add group markup.\n+\t* include/std/utility: Same.\n+\t* include/std/type_traits: Same.\n+\t* include/std/streambuf: Same.\n+\t* include/std/iosfwd: Same.\n+\t* include/std/limits: Same.\n+\t* include/std/sstream: Same.\n+\t* include/profile/impl/profiler_state.h: Same.\n+\t* include/profile/impl/profiler_hashtable_size.h: Same.\n+\t* include/bits/stl_algobase.h: Same.\n+\t* include/bits/stl_iterator_base_types.h: Same.\n+\t* include/bits/stream_iterator.h: Same.\n+\t* include/bits/stl_iterator.h: Same.\n+\t* include/bits/stl_tempbuf.h: Same.\n+\t* include/bits/streambuf_iterator.h: Same.\n+\t* libsupc++/exception: Same.\n+\t* libsupc++/cxxabi.h: Same.\n+\t* include/tr1_impl/type_traits: Same.\n+\n+\t* include/parallel/multiway_merge.h: Change @__c to @c, @__f to @f.\n+\t* include/parallel/list_partition.h: Same.\n+\t* include/parallel/for_each.h: Same.\n+\t* include/parallel/workstealing.h: Same.\n+\t* include/parallel/base.h: Same.\n+\t* include/parallel/equally_split.h: Same.\n+\t* include/parallel/random_shuffle.h: Same.\n+\t* include/parallel/balanced_quicksort.h: Same.\n+\t* include/parallel/merge.h: Same.\n+\t* include/parallel/multiway_mergesort.h: Same.\n+\t* include/parallel/compatibility.h: Same.\n+\t* include/parallel/queue.h: Same.\n+\t* include/parallel/checkers.h: Same.\n+\t* include/parallel/random_number.h: Same.\n+\n+\n+\t* include/c_global/csignal: Change # to \\#.\n+\t* include/c_global/cstdlib: Same.\n+\t* include/c_global/cstdio: Same.\n+\t* include/c_global/cstdarg: Same.\n+\t* include/c_global/cctype: Same.\n+\t* include/c_global/cerrno: Same.\n+\t* include/c_global/cstdatomic: Same.\n+\t* include/c_global/cmath: Same.\n+\t* include/c_global/ciso646: Same.\n+\t* include/c_global/ctime: Same.\n+\t* include/c_global/clocale: Same.\n+\t* include/c_global/climits: Same.\n+\t* include/c_global/cassert: Same.\n+\t* include/c_global/csetjmp: Same.\n+\t* include/c_global/cwchar: Same.\n+\t* include/c_global/cfloat: Same.\n+\t* include/c_global/cstring: Same.\n+\t* include/c_global/cstddef: Same.\n+\t* include/c_global/cwctype: Same.\n+\n+\t* include/std/memory: Only dance around boost_sp_counted_base.h.\n+\t* include/tr1_impl/boost_sp_counted_base.h: Add markup.\n+\t* include/tr1/shared_ptr.h: Strip markup.\n+\t* include/bits/shared_ptr.h: Move base types...\n+\t* include/bits/shared_ptr_base.h: ...here.\n+\t* include/Makefile.am: Add.\n+\t* include/Makefile.in: Regenerate.\n+\t* configure: Same.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc:\n+\tAdjust line numbers.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc: Same.\n+\n 2009-11-06  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/parallel/multiway_merge.h: Simple formatting and"}, {"sha": "75adc589e12ceb9639978a27b48355c5ce2f15c6", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -19542,7 +19542,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -26444,7 +26444,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -32259,7 +32259,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -43904,7 +43904,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -44118,7 +44118,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -44593,7 +44593,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -50762,7 +50762,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -56562,7 +56562,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -56729,7 +56729,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -56878,7 +56878,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -57045,7 +57045,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`\n@@ -57217,7 +57217,7 @@ $as_echo_n \"checking for ld version... \" >&6; }\n       glibcxx_ld_is_gold=yes\n     fi\n     ldver=`$LD --version 2>/dev/null |\n-\t   sed -e 's/GNU gold /GNU ld/;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+\t   sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n \n     glibcxx_gnu_ld_version=`echo $ldver | \\\n            $AWK -F. '{ if (NF<3) $3=0; print ($1*100+$2)*100+$3 }'`"}, {"sha": "e7c664a92fb142ad02b083416027d94edc076d65", "filename": "libstdc++-v3/doc/doxygen/doxygroups.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fdoxygroups.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fdoxygroups.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fdoxygroups.cc?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -149,10 +149,3 @@ summarized in <a href=\"tables.html\">tables</a>.  */\n  * Components for concurrent operations, including threads, mutexes,\n  * and condition variables.\n  */\n-\n-/**\n- * @defgroup pointer_abstractions Pointer Abstractions\n- * @ingroup memory\n- *\n- * Components for memory allocation, deallocation, and management.\n- */"}, {"sha": "b6b9b38ea97dd54fa3a5fbc931a2eb6ee842443a", "filename": "libstdc++-v3/doc/doxygen/user.cfg.in", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fdoxygen%2Fuser.cfg.in?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -669,17 +669,6 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n                          include/profile/unordered_map \\\n                          include/profile/unordered_set \\\n                          include/profile/vector \\\n-                         include/profile/base.h \\\n-                         include/profile/impl/profiler.h \\\n-                         include/profile/impl/profiler_container_size.h \\\n-                         include/profile/impl/profiler_hash_func.h \\\n-                         include/profile/impl/profiler_hashtable_size.h \\\n-                         include/profile/impl/profiler_map_to_unordered_map.h \\\n-                         include/profile/impl/profiler_node.h \\\n-                         include/profile/impl/profiler_state.h \\\n-                         include/profile/impl/profiler_trace.h \\\n-                         include/profile/impl/profiler_vector_size.h \\\n-                         include/profile/impl/profiler_vector_to_list.h \\\n                          include/ext/algorithm \\\n                          include/ext/functional \\\n                          include/ext/iterator \\\n@@ -720,7 +709,6 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n                          include/tr1_impl/cwctype \\\n                          include/tr1_impl/functional \\\n                          include/tr1_impl/hashtable \\\n-                         include/tr1_impl/random \\\n                          include/tr1_impl/regex \\\n                          include/tr1_impl/type_traits \\\n                          include/tr1_impl/unordered_map \\\n@@ -732,10 +720,10 @@ INPUT                  = @srcdir@/doc/doxygen/doxygroups.cc \\\n                          include/@host_alias@/bits \\\n                          include/backward \\\n                          include/bits \\\n-                         include/bits/shared_ptr.h \\\n                          include/debug \\\n                          include/parallel \\\n                          include/profile \\\n+                         include/profile/impl \\\n                          include/ext \\\n                          include/ext/pb_ds \\\n                          include/ext/pb_ds/detail "}, {"sha": "1cea8a24e94efb86e3bb734ae23b343566afca94", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -121,6 +121,7 @@ bits_headers = \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\\n+\t${bits_srcdir}/shared_ptr_base.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n \t${bits_srcdir}/stl_algo.h \\"}, {"sha": "a1fab9adfbe4ae1a2d1ae6329870fe985f1e34e6", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -364,6 +364,7 @@ bits_headers = \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\\n+\t${bits_srcdir}/shared_ptr_base.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n \t${bits_srcdir}/stl_algo.h \\"}, {"sha": "796df14c2c477ad9fcede2bb11ea68e30f716684", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 147, "deletions": 1219, "changes": 1366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -22,6 +22,8 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n+// GCC Note: Based on files from version 1.32.0 of the Boost library.\n+\n //  shared_count.hpp\n //  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n \n@@ -39,8 +41,6 @@\n // accompanying file LICENSE_1_0.txt or copy at\n // http://www.boost.org/LICENSE_1_0.txt)\n \n-// GCC Note:  based on version 1.32.0 of the Boost library.\n-\n /** @file bits/shared_ptr.h\n  *  This is an internal header file, included by other library headers.\n  *  You should not attempt to use it directly.\n@@ -53,9 +53,7 @@\n # include <c++0x_warning.h>\n #endif\n \n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n+#include <bits/shared_ptr_base.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n@@ -64,563 +62,89 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    * @{\n    */\n \n-  // counted ptr with no deleter or allocator support\n-  template<typename _Ptr, _Lock_policy _Lp>\n-    class _Sp_counted_ptr\n-    : public _Sp_counted_base<_Lp>\n-    {\n-    public:\n-      _Sp_counted_ptr(_Ptr __p)\n-      : _M_ptr(__p) { }\n-    \n-      virtual void\n-      _M_dispose() // nothrow\n-      { delete _M_ptr; }\n-      \n-      virtual void\n-      _M_destroy() // nothrow\n-      { delete this; }\n-      \n-      virtual void*\n-      _M_get_deleter(const std::type_info& __ti)\n-      { return 0; }\n-      \n-      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;\n-      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;\n-      \n-    protected:\n-      _Ptr             _M_ptr;  // copy constructor must not throw\n-    };\n-\n-  // support for custom deleter and/or allocator\n-  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>\n-    class _Sp_counted_deleter\n-    : public _Sp_counted_ptr<_Ptr, _Lp>\n-    {\n-      typedef typename _Alloc::template\n-          rebind<_Sp_counted_deleter>::other _My_alloc_type;\n-\n-      // Helper class that stores the Deleter and also acts as an allocator.\n-      // Used to dispose of the owned pointer and the internal refcount\n-      // Requires that copies of _Alloc can free each other's memory.\n-      struct _My_Deleter\n-      : public _My_alloc_type    // copy constructor must not throw\n-      {\n-        _Deleter _M_del;         // copy constructor must not throw\n-        _My_Deleter(_Deleter __d, const _Alloc& __a)\n-          : _My_alloc_type(__a), _M_del(__d) { }\n-      };\n-\n-    protected:\n-      typedef _Sp_counted_ptr<_Ptr, _Lp> _Base_type;\n-\n-    public:\n-      /**\n-       *  @brief   \n-       *  @pre     __d(__p) must not throw.\n-       */\n-      _Sp_counted_deleter(_Ptr __p, _Deleter __d)\n-      : _Base_type(__p), _M_del(__d, _Alloc()) { }\n-    \n-      /**\n-       *  @brief   \n-       *  @pre     __d(__p) must not throw.\n-       */\n-      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a)\n-      : _Base_type(__p), _M_del(__d, __a) { }\n-    \n-      virtual void\n-      _M_dispose() // nothrow\n-      { _M_del._M_del(_Base_type::_M_ptr); }\n-      \n-      virtual void\n-      _M_destroy() // nothrow\n-      {\n-        _My_alloc_type __a(_M_del);\n-        this->~_Sp_counted_deleter();\n-        __a.deallocate(this, 1);\n-      }\n-      \n-      virtual void*\n-      _M_get_deleter(const std::type_info& __ti)\n-      { return __ti == typeid(_Deleter) ? &_M_del._M_del : 0; }\n-      \n-    protected:\n-      _My_Deleter      _M_del;  // copy constructor must not throw\n-    };\n-\n-  // helpers for make_shared / allocate_shared\n-\n-  template<typename _Tp>\n-    struct _Sp_destroy_inplace\n-    {\n-      void operator()(_Tp* __p) const { if (__p) __p->~_Tp(); }\n-    };\n-\n-  struct _Sp_make_shared_tag { };\n-\n-  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n-    class _Sp_counted_ptr_inplace\n-    : public _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n-    {\n-      typedef _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n-        _Base_type;\n-\n-    public:\n-      _Sp_counted_ptr_inplace(_Alloc __a)\n-      : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n-      , _M_storage()\n-      {\n-        void* __p = &_M_storage;\n-        ::new (__p) _Tp();  // might throw\n-        _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n-      }\n-\n-      template<typename... _Args>\n-        _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n-        : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n-        , _M_storage()\n-        {\n-          void* __p = &_M_storage;\n-          ::new (__p) _Tp(std::forward<_Args>(__args)...);  // might throw\n-          _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n-        }\n-\n-      // override because the allocator needs to know the dynamic type\n-      virtual void\n-      _M_destroy() // nothrow\n-      {\n-        typedef typename _Alloc::template\n-            rebind<_Sp_counted_ptr_inplace>::other _My_alloc_type;\n-        _My_alloc_type __a(_Base_type::_M_del);\n-        this->~_Sp_counted_ptr_inplace();\n-        __a.deallocate(this, 1);\n-      }\n-\n-      // sneaky trick so __shared_ptr can get the managed pointer\n-      virtual void*\n-      _M_get_deleter(const std::type_info& __ti)\n-      {\n-        return __ti == typeid(_Sp_make_shared_tag)\n-               ? static_cast<void*>(&_M_storage)\n-               : _Base_type::_M_get_deleter(__ti);\n-      }\n-      \n-    private:\n-      typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type\n-        _M_storage;\n-    };\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class __weak_count;\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class __shared_count\n-    {\n-    public: \n-      __shared_count()\n-      : _M_pi(0) // nothrow\n-      { }\n-  \n-      template<typename _Ptr>\n-        __shared_count(_Ptr __p) : _M_pi(0)\n-        {\n-          __try\n-            {\n-              _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);\n-            }\n-          __catch(...)\n-            {\n-              delete __p;\n-              __throw_exception_again;\n-            }\n-        }\n-\n-      template<typename _Ptr, typename _Deleter>\n-        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n-        {\n-          // allocator's value_type doesn't matter, will rebind it anyway\n-          typedef std::allocator<int> _Alloc;\n-          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n-          typedef std::allocator<_Sp_cd_type> _Alloc2;\n-          _Alloc2 __a2;\n-          __try\n-            {\n-              _M_pi = __a2.allocate(1);\n-              ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d);\n-            }\n-          __catch(...)\n-            {\n-              __d(__p); // Call _Deleter on __p.\n-              if (_M_pi)\n-                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n-              __throw_exception_again;\n-            }\n-        }\n-\n-      template<typename _Ptr, typename _Deleter, typename _Alloc>\n-        __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n-        {\n-          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n-          typedef typename _Alloc::template rebind<_Sp_cd_type>::other _Alloc2;\n-          _Alloc2 __a2(__a);\n-          __try\n-            {\n-              _M_pi = __a2.allocate(1);\n-              ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d, __a);\n-            }\n-          __catch(...)\n-            {\n-              __d(__p); // Call _Deleter on __p.\n-              if (_M_pi)\n-                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n-              __throw_exception_again;\n-            }\n-        }\n-\n-      template<typename _Tp, typename _Alloc, typename... _Args>\n-        __shared_count(_Sp_make_shared_tag, _Tp*, _Alloc __a, _Args&&... __args)\n-        : _M_pi(0)\n-        {\n-          typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;\n-          typedef typename _Alloc::template rebind<_Sp_cp_type>::other _Alloc2;\n-          _Alloc2 __a2(__a);\n-          __try\n-            {\n-              _M_pi = __a2.allocate(1);\n-              ::new(static_cast<void*>(_M_pi)) _Sp_cp_type(__a,\n-                    std::forward<_Args>(__args)...);\n-            }\n-          __catch(...)\n-            {\n-              if (_M_pi)\n-        \t__a2.deallocate(static_cast<_Sp_cp_type*>(_M_pi), 1);\n-              __throw_exception_again;\n-            }\n-        }\n-\n-#if _GLIBCXX_DEPRECATED\n-      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n-      template<typename _Tp>\n-        explicit\n-        __shared_count(std::auto_ptr<_Tp>&& __r)\n-        : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))\n-        { __r.release(); }\n-#endif\n-\n-      // Special case for unique_ptr<_Tp,_Del> to provide the strong guarantee.\n-      template<typename _Tp, typename _Del>\n-        explicit\n-        __shared_count(std::unique_ptr<_Tp, _Del>&& __r)\n-        : _M_pi(_S_create_from_up(std::move(__r)))\n-        { __r.release(); }\n-\n-      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n-      explicit\n-      __shared_count(const __weak_count<_Lp>& __r);\n-  \n-      ~__shared_count() // nothrow\n-      {\n-        if (_M_pi != 0)\n-          _M_pi->_M_release();\n-      }\n-\n-      __shared_count(const __shared_count& __r)\n-      : _M_pi(__r._M_pi) // nothrow\n-      {\n-        if (_M_pi != 0)\n-          _M_pi->_M_add_ref_copy();\n-      }\n-  \n-      __shared_count&\n-      operator=(const __shared_count& __r) // nothrow\n-      {\n-        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-        if (__tmp != _M_pi)\n-          {\n-            if (__tmp != 0)\n-              __tmp->_M_add_ref_copy();\n-            if (_M_pi != 0)\n-              _M_pi->_M_release();\n-            _M_pi = __tmp;\n-          }\n-        return *this;\n-      }\n-  \n-      void\n-      _M_swap(__shared_count& __r) // nothrow\n-      {\n-        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-        __r._M_pi = _M_pi;\n-        _M_pi = __tmp;\n-      }\n-  \n-      long\n-      _M_get_use_count() const // nothrow\n-      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n-\n-      bool\n-      _M_unique() const // nothrow\n-      { return this->_M_get_use_count() == 1; }\n-\n-      void*\n-      _M_get_deleter(const std::type_info& __ti) const\n-      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n-\n-      bool\n-      _M_less(const __shared_count& __rhs) const\n-      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n-\n-      bool\n-      _M_less(const __weak_count<_Lp>& __rhs) const\n-      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n-\n-      // friend function injected into enclosing namespace and found by ADL\n-      friend inline bool\n-      operator==(const __shared_count& __a, const __shared_count& __b)\n-      { return __a._M_pi == __b._M_pi; }\n-  \n-    private:\n-      friend class __weak_count<_Lp>;\n-\n-      template<typename _Tp, typename _Del>\n-        static _Sp_counted_base<_Lp>*\n-        _S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,\n-          typename std::enable_if<!std::is_reference<_Del>::value>::type* = 0)\n-        {\n-          return new _Sp_counted_deleter<_Tp*, _Del, std::allocator<_Tp>,\n-            _Lp>(__r.get(), __r.get_deleter());\n-        }\n-\n-      template<typename _Tp, typename _Del>\n-        static _Sp_counted_base<_Lp>*\n-        _S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,\n-          typename std::enable_if<std::is_reference<_Del>::value>::type* = 0)\n-        {\n-          typedef typename std::remove_reference<_Del>::type _Del1;\n-          typedef std::reference_wrapper<_Del1> _Del2;\n-          return new _Sp_counted_deleter<_Tp*, _Del2, std::allocator<_Tp>,\n-            _Lp>(__r.get(), std::ref(__r.get_deleter()));\n-        }\n-\n-      _Sp_counted_base<_Lp>*  _M_pi;\n-    };\n-\n-\n-  template<_Lock_policy _Lp>\n-    class __weak_count\n-    {\n-    public:\n-      __weak_count()\n-      : _M_pi(0) // nothrow\n-      { }\n-  \n-      __weak_count(const __shared_count<_Lp>& __r)\n-      : _M_pi(__r._M_pi) // nothrow\n-      {\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_weak_add_ref();\n-      }\n-      \n-      __weak_count(const __weak_count<_Lp>& __r)\n-      : _M_pi(__r._M_pi) // nothrow\n-      {\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_weak_add_ref();\n-      }\n-      \n-      ~__weak_count() // nothrow\n-      {\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_weak_release();\n-      }\n-      \n-      __weak_count<_Lp>&\n-      operator=(const __shared_count<_Lp>& __r) // nothrow\n-      {\n-\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-\tif (__tmp != 0)\n-\t  __tmp->_M_weak_add_ref();\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_weak_release();\n-\t_M_pi = __tmp;  \n-\treturn *this;\n-      }\n-      \n-      __weak_count<_Lp>&\n-      operator=(const __weak_count<_Lp>& __r) // nothrow\n-      {\n-\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-\tif (__tmp != 0)\n-\t  __tmp->_M_weak_add_ref();\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_weak_release();\n-\t_M_pi = __tmp;\n-\treturn *this;\n-      }\n-\n-      void\n-      _M_swap(__weak_count<_Lp>& __r) // nothrow\n-      {\n-\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-\t__r._M_pi = _M_pi;\n-\t_M_pi = __tmp;\n-      }\n-  \n-      long\n-      _M_get_use_count() const // nothrow\n-      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n-\n-      bool\n-      _M_less(const __weak_count& __rhs) const\n-      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n-\n-      bool\n-      _M_less(const __shared_count<_Lp>& __rhs) const\n-      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n-\n-      // friend function injected into enclosing namespace and found by ADL\n-      friend inline bool\n-      operator==(const __weak_count& __a, const __weak_count& __b)\n-      { return __a._M_pi == __b._M_pi; }\n-\n-    private:\n-      friend class __shared_count<_Lp>;\n-\n-      _Sp_counted_base<_Lp>*  _M_pi;\n-    };\n-\n-  // now that __weak_count is defined we can define this constructor:\n-  template<_Lock_policy _Lp>\n-    inline\n-    __shared_count<_Lp>::\n-    __shared_count(const __weak_count<_Lp>& __r)\n-    : _M_pi(__r._M_pi)\n+  /// 2.2.3.7 shared_ptr I/O\n+  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n+    std::basic_ostream<_Ch, _Tr>&\n+    operator<<(std::basic_ostream<_Ch, _Tr>& __os,\n+\t       const __shared_ptr<_Tp, _Lp>& __p)\n     {\n-      if (_M_pi != 0)\n-\t_M_pi->_M_add_ref_lock();\n-      else\n-\t__throw_bad_weak_ptr();\n+      __os << __p.get();\n+      return __os;\n     }\n \n-  // Forward declarations.\n-  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n-    class __shared_ptr;\n-  \n-  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n-    class __weak_ptr;\n-\n-  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n-    class __enable_shared_from_this;\n+  /// 2.2.3.10 shared_ptr get_deleter (experimental)\n+  template<typename _Del, typename _Tp, _Lock_policy _Lp>\n+    inline _Del*\n+    get_deleter(const __shared_ptr<_Tp, _Lp>& __p)\n+    { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n \n-  template<typename _Tp>\n-    class shared_ptr;\n-  \n-  template<typename _Tp>\n-    class weak_ptr;\n \n+  /**\n+   *  @brief  A smart pointer with reference-counted copy semantics.\n+   *\n+   *  The object pointed to is deleted when the last shared_ptr pointing to\n+   *  it is destroyed or reset.\n+  */\n   template<typename _Tp>\n-    class enable_shared_from_this;\n-\n-  // Support for enable_shared_from_this.\n-\n-  // Friend of __enable_shared_from_this.\n-  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>\n-    void\n-    __enable_shared_from_this_helper(const __shared_count<_Lp>&,\n-\t\t\t\t     const __enable_shared_from_this<_Tp1,\n-\t\t\t\t     _Lp>*, const _Tp2*);\n-\n-  // Friend of enable_shared_from_this.\n-  template<typename _Tp1, typename _Tp2>\n-    void\n-    __enable_shared_from_this_helper(const __shared_count<>&,\n-\t\t\t\t     const enable_shared_from_this<_Tp1>*,\n-\t\t\t\t     const _Tp2*);\n-\n-  template<_Lock_policy _Lp>\n-    inline void\n-    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...)\n-    { }\n-\n-\n-  template<typename _Tp, _Lock_policy _Lp>\n-    class __shared_ptr\n+    class shared_ptr : public __shared_ptr<_Tp>\n     {\n     public:\n-      typedef _Tp   element_type;\n-      \n-      /** @brief  Construct an empty %__shared_ptr.\n+      /**\n+       *  @brief  Construct an empty %shared_ptr.\n        *  @post   use_count()==0 && get()==0\n        */\n-      __shared_ptr()\n-      : _M_ptr(0), _M_refcount() // never throws\n-      { }\n+      shared_ptr() : __shared_ptr<_Tp>() { }\n \n-      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p.\n+      /**\n+       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.\n        *  @param  __p  A pointer that is convertible to element_type*.\n        *  @post   use_count() == 1 && get() == __p\n        *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n        */\n       template<typename _Tp1>\n-        explicit\n-        __shared_ptr(_Tp1* __p)\n-\t: _M_ptr(__p), _M_refcount(__p)\n-        {\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n-\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n-\t}\n+\texplicit shared_ptr(_Tp1* __p) : __shared_ptr<_Tp>(__p) { }\n \n-      //\n-      // Requirements: _Deleter's copy constructor and destructor must\n-      // not throw\n-      //\n-      // __shared_ptr will release __p by calling __d(__p)\n-      //\n-      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p\n+      /**\n+       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n        *          and the deleter @a __d.\n        *  @param  __p  A pointer.\n        *  @param  __d  A deleter.\n        *  @post   use_count() == 1 && get() == __p\n        *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n+       *\n+       *  Requirements: _Deleter's copy constructor and destructor must\n+       *  not throw\n+       *\n+       *  __shared_ptr will release __p by calling __d(__p)\n        */\n-      template<typename _Tp1, typename _Deleter>\n-        __shared_ptr(_Tp1* __p, _Deleter __d)\n-        : _M_ptr(__p), _M_refcount(__p, __d)\n-        {\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n-\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n-\t}\n-      \n-      //\n-      // Requirements: _Deleter's copy constructor and destructor must\n-      // not throw _Alloc's copy constructor and destructor must not\n-      // throw.\n-      //\n-      // __shared_ptr will release __p by calling __d(__p)\n-      //\n-      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p\n+\ttemplate<typename _Tp1, typename _Deleter>\n+\tshared_ptr(_Tp1* __p, _Deleter __d) : __shared_ptr<_Tp>(__p, __d) { }\n+\n+      /**\n+       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n        *          and the deleter @a __d.\n        *  @param  __p  A pointer.\n        *  @param  __d  A deleter.\n        *  @param  __a  An allocator.\n        *  @post   use_count() == 1 && get() == __p\n        *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n+       *\n+       *  Requirements: _Deleter's copy constructor and destructor must\n+       *  not throw _Alloc's copy constructor and destructor must not\n+       *  throw.\n+       *\n+       *  __shared_ptr will release __p by calling __d(__p)\n        */\n       template<typename _Tp1, typename _Deleter, typename _Alloc>\n-        __shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n-\t: _M_ptr(__p), _M_refcount(__p, __d, __a)\n-        {\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n-\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n-\t}\n+\tshared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+\t: __shared_ptr<_Tp>(__p, __d, __a) { }\n+\n+      // Aliasing constructor\n \n-      /** @brief  Constructs a %__shared_ptr instance that stores @a __p\n+      /**\n+       *  @brief  Constructs a %shared_ptr instance that stores @a __p\n        *          and shares ownership with @a __r.\n-       *  @param  __r  A %__shared_ptr.\n+       *  @param  __r  A %shared_ptr.\n        *  @param  __p  A pointer that will remain valid while @a *__r is valid.\n        *  @post   get() == __p && use_count() == __r.use_count()\n        *\n@@ -634,658 +158,75 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        * @endcode\n        */\n       template<typename _Tp1>\n-        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p)\n-\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n-        { }\n-\n-      //  generated copy constructor, assignment, destructor are fine.\n-      \n-      /** @brief  If @a __r is empty, constructs an empty %__shared_ptr;\n-       *          otherwise construct a %__shared_ptr that shares ownership\n+\tshared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p)\n+\t: __shared_ptr<_Tp>(__r, __p) { }\n+\n+      /**\n+       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;\n+       *          otherwise construct a %shared_ptr that shares ownership\n        *          with @a __r.\n-       *  @param  __r  A %__shared_ptr.\n+       *  @param  __r  A %shared_ptr.\n        *  @post   get() == __r.get() && use_count() == __r.use_count()\n        */\n       template<typename _Tp1>\n-        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n-\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n-        { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n+\tshared_ptr(const shared_ptr<_Tp1>& __r) : __shared_ptr<_Tp>(__r) { }\n \n-      /** @brief  Move-constructs a %__shared_ptr instance from @a __r.\n-       *  @param  __r  A %__shared_ptr rvalue.\n+      /**\n+       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n+       *  @param  __r  A %shared_ptr rvalue.\n        *  @post   *this contains the old value of @a __r, @a __r is empty.\n        */\n-      __shared_ptr(__shared_ptr&& __r)\n-      : _M_ptr(__r._M_ptr), _M_refcount() // never throws\n-      {\n-        _M_refcount._M_swap(__r._M_refcount);\n-        __r._M_ptr = 0;\n-      }\n+      shared_ptr(shared_ptr&& __r)\n+      : __shared_ptr<_Tp>(std::move(__r)) { }\n \n-      /** @brief  Move-constructs a %__shared_ptr instance from @a __r.\n-       *  @param  __r  A %__shared_ptr rvalue.\n+      /**\n+       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n+       *  @param  __r  A %shared_ptr rvalue.\n        *  @post   *this contains the old value of @a __r, @a __r is empty.\n        */\n       template<typename _Tp1>\n-        __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r)\n-\t: _M_ptr(__r._M_ptr), _M_refcount() // never throws\n-        {\n-          __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-          _M_refcount._M_swap(__r._M_refcount);\n-          __r._M_ptr = 0;\n-        }\n-\n-      /** @brief  Constructs a %__shared_ptr that shares ownership with @a __r\n+\tshared_ptr(shared_ptr<_Tp1>&& __r)\n+\t: __shared_ptr<_Tp>(std::move(__r)) { }\n+\n+      /**\n+       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r\n        *          and stores a copy of the pointer stored in @a __r.\n        *  @param  __r  A weak_ptr.\n        *  @post   use_count() == __r.use_count()\n        *  @throw  bad_weak_ptr when __r.expired(),\n        *          in which case the constructor has no effect.\n        */\n       template<typename _Tp1>\n-        explicit\n-        __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n-\t: _M_refcount(__r._M_refcount) // may throw\n-        {\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // It is now safe to copy __r._M_ptr, as _M_refcount(__r._M_refcount)\n-\t  // did not throw.\n-\t  _M_ptr = __r._M_ptr;\n-\t}\n-\n-      template<typename _Tp1, typename _Del>\n-        explicit\n-        __shared_ptr(const std::unique_ptr<_Tp1, _Del>&) = delete;\n-\n-      /**\n-       * If an exception is thrown this constructor has no effect.\n-       */\n-      template<typename _Tp1, typename _Del>\n-        explicit\n-        __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n-\t: _M_ptr(__r.get()), _M_refcount()\n-        {\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  _Tp1* __tmp = __r.get();\n-\t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n-\t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n-\t}\n-\n-#if _GLIBCXX_DEPRECATED\n-      /**\n-       * @post use_count() == 1 and __r.get() == 0\n-       */\n-      template<typename _Tp1>\n-        explicit\n-        __shared_ptr(std::auto_ptr<_Tp1>&& __r)\n-\t: _M_ptr(__r.get()), _M_refcount()\n-        {\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // TODO requires _Tp1 is complete, delete __r.release() well-formed\n-\t  _Tp1* __tmp = __r.get();\n-\t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n-\t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n-\t}\n-#endif\n-\n-      template<typename _Tp1>\n-        __shared_ptr&\n-        operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n-        {\n-\t  _M_ptr = __r._M_ptr;\n-\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw\n-\t  return *this;\n-\t}\n-\n-#if _GLIBCXX_DEPRECATED\n-      template<typename _Tp1>\n-        __shared_ptr&\n-        operator=(std::auto_ptr<_Tp1>&& __r)\n-        {\n-\t  __shared_ptr(std::move(__r)).swap(*this);\n-\t  return *this;\n-\t}\n-#endif\n-\n-      __shared_ptr&\n-      operator=(__shared_ptr&& __r)\n-      {\n-        __shared_ptr(std::move(__r)).swap(*this);\n-        return *this;\n-      }\n-     \n-      template<class _Tp1>\n-        __shared_ptr&\n-        operator=(__shared_ptr<_Tp1, _Lp>&& __r)\n-        {\n-          __shared_ptr(std::move(__r)).swap(*this);\n-          return *this;\n-        }\n-\n-      template<typename _Tp1, typename _Del>\n-        __shared_ptr&\n-        operator=(const std::unique_ptr<_Tp1, _Del>& __r) = delete;\n-\n-      template<typename _Tp1, typename _Del>\n-        __shared_ptr&\n-        operator=(std::unique_ptr<_Tp1, _Del>&& __r)\n-        {\n-\t  __shared_ptr(std::move(__r)).swap(*this);\n-\t  return *this;\n-        }\n-\n-      void\n-      reset() // never throws\n-      { __shared_ptr().swap(*this); }\n-\n-      template<typename _Tp1>\n-        void\n-        reset(_Tp1* __p) // _Tp1 must be complete.\n-        {\n-\t  // Catch self-reset errors.\n-\t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); \n-\t  __shared_ptr(__p).swap(*this);\n-\t}\n-\n-      template<typename _Tp1, typename _Deleter>\n-        void\n-        reset(_Tp1* __p, _Deleter __d)\n-        { __shared_ptr(__p, __d).swap(*this); }\n-\n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-        void\n-        reset(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n-        { __shared_ptr(__p, __d, __a).swap(*this); }\n-\n-      // Allow class instantiation when _Tp is [cv-qual] void.\n-      typename std::add_lvalue_reference<_Tp>::type\n-      operator*() const // never throws\n-      {\n-\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n-\treturn *_M_ptr;\n-      }\n-\n-      _Tp*\n-      operator->() const // never throws\n-      {\n-\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n-\treturn _M_ptr;\n-      }\n-    \n-      _Tp*\n-      get() const // never throws\n-      { return _M_ptr; }\n-\n-      explicit operator bool() const // never throws\n-      { return _M_ptr == 0 ? false : true; }\n-\n-      bool\n-      unique() const // never throws\n-      { return _M_refcount._M_unique(); }\n-\n-      long\n-      use_count() const // never throws\n-      { return _M_refcount._M_get_use_count(); }\n-\n-      void\n-      swap(__shared_ptr<_Tp, _Lp>& __other) // never throws\n-      {\n-\tstd::swap(_M_ptr, __other._M_ptr);\n-\t_M_refcount._M_swap(__other._M_refcount);\n-      }\n-\n-      template<typename _Tp1>\n-        bool\n-        owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const\n-        { return _M_refcount._M_less(__rhs._M_refcount); }\n-\n-      template<typename _Tp1>\n-        bool\n-        owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const\n-        { return _M_refcount._M_less(__rhs._M_refcount); }\n-\n-    protected:\n-      // This constructor is non-standard, it is used by allocate_shared.\n-      template<typename _Alloc, typename... _Args>\n-        __shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n-        : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n-\t\t\t\tstd::forward<_Args>(__args)...)\n-        {\n-          // _M_ptr needs to point to the newly constructed object.\n-          // This relies on _Sp_counted_ptr_inplace::_M_get_deleter.\n-          void* __p = _M_refcount._M_get_deleter(typeid(__tag));\n-          _M_ptr = static_cast<_Tp*>(__p);\n-\t  __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);\n-        }\n-\n-      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n-               typename... _Args>\n-        friend __shared_ptr<_Tp1, _Lp1>\n-        __allocate_shared(_Alloc __a, _Args&&... __args);\n-\n-    private:\n-      void*\n-      _M_get_deleter(const std::type_info& __ti) const\n-      { return _M_refcount._M_get_deleter(__ti); }\n-\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n-\n-      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n-        friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);\n-\n-      _Tp*         \t   _M_ptr;         // Contained pointer.\n-      __shared_count<_Lp>  _M_refcount;    // Reference counter.\n-    };\n-\n-  // 20.8.13.2.7 shared_ptr comparisons\n-  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n-    inline bool\n-    operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n-        const __shared_ptr<_Tp2, _Lp>& __b)\n-    { return __a.get() == __b.get(); }\n-\n-  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n-    inline bool\n-    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,\n-        const __shared_ptr<_Tp2, _Lp>& __b)\n-    { return __a.get() != __b.get(); }\n-\n-  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n-    inline bool\n-    operator<(const __shared_ptr<_Tp1, _Lp>& __a,\n-        const __shared_ptr<_Tp2, _Lp>& __b)\n-    { return __a.get() < __b.get(); }\n-\n-  template<typename _Sp>\n-    struct _Sp_less : public binary_function<_Sp, _Sp, bool>\n-    {\n-      bool\n-      operator()(const _Sp& __lhs, const _Sp& __rhs) const\n-      {\n-        return std::less<typename _Sp::element_type*>()(__lhs.get(),\n-            __rhs.get());\n-      }\n-    };\n-\n-  template<typename _Tp, _Lock_policy _Lp>\n-    struct less<__shared_ptr<_Tp, _Lp>>\n-    : public _Sp_less<__shared_ptr<_Tp, _Lp>>\n-    { };\n-\n-  // XXX LessThanComparable<_Tp> concept should provide >, >= and <=\n-  template<typename _Tp, _Lock_policy _Lp>\n-    inline bool\n-    operator>(const __shared_ptr<_Tp, _Lp>& __a,\n-        const __shared_ptr<_Tp, _Lp>& __b)\n-    { return __a.get() > __b.get(); }\n-\n-  template<typename _Tp, _Lock_policy _Lp>\n-    inline bool\n-    operator>=(const __shared_ptr<_Tp, _Lp>& __a,\n-        const __shared_ptr<_Tp, _Lp>& __b)\n-    { return __a.get() >= __b.get(); }\n-\n-  template<typename _Tp, _Lock_policy _Lp>\n-    inline bool\n-    operator<=(const __shared_ptr<_Tp, _Lp>& __a,\n-        const __shared_ptr<_Tp, _Lp>& __b)\n-    { return __a.get() <= __b.get(); }\n-\n-  // 2.2.3.8 shared_ptr specialized algorithms.\n-  template<typename _Tp, _Lock_policy _Lp>\n-    inline void\n-    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b)\n-    { __a.swap(__b); }\n-\n-  // 2.2.3.9 shared_ptr casts\n-  /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))</code>\n-   *           will eventually result in undefined behaviour,\n-   *           attempting to delete the same object twice.\n-   */\n-  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-    inline __shared_ptr<_Tp, _Lp>\n-    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }\n-\n-  /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))</code>\n-   *           will eventually result in undefined behaviour,\n-   *           attempting to delete the same object twice.\n-   */\n-  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-    inline __shared_ptr<_Tp, _Lp>\n-    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }\n-\n-  /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))</code>\n-   *           will eventually result in undefined behaviour,\n-   *           attempting to delete the same object twice.\n-   */\n-  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n-    inline __shared_ptr<_Tp, _Lp>\n-    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    {\n-      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n-        return __shared_ptr<_Tp, _Lp>(__r, __p);\n-      return __shared_ptr<_Tp, _Lp>();\n-    }\n-\n-  // 2.2.3.7 shared_ptr I/O\n-  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n-    std::basic_ostream<_Ch, _Tr>&\n-    operator<<(std::basic_ostream<_Ch, _Tr>& __os, \n-\t       const __shared_ptr<_Tp, _Lp>& __p)\n-    {\n-      __os << __p.get();\n-      return __os;\n-    }\n-\n-  // 2.2.3.10 shared_ptr get_deleter (experimental)\n-  template<typename _Del, typename _Tp, _Lock_policy _Lp>\n-    inline _Del*\n-    get_deleter(const __shared_ptr<_Tp, _Lp>& __p)\n-    { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n-\n-\n-  template<typename _Tp, _Lock_policy _Lp>\n-    class __weak_ptr\n-    {\n-    public:\n-      typedef _Tp element_type;\n-      \n-      __weak_ptr()\n-      : _M_ptr(0), _M_refcount() // never throws\n-      { }\n-\n-      // Generated copy constructor, assignment, destructor are fine.\n-      \n-      // The \"obvious\" converting constructor implementation:\n-      //\n-      //  template<typename _Tp1>\n-      //    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n-      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n-      //    { }\n-      //\n-      // has a serious problem.\n-      //\n-      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n-      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n-      //\n-      // It is not possible to avoid spurious access violations since\n-      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n-      template<typename _Tp1>\n-        __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n-\t: _M_refcount(__r._M_refcount) // never throws\n-        {\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  _M_ptr = __r.lock().get();\n-\t}\n-\n-      template<typename _Tp1>\n-        __weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n-\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n-        { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n-\n-      template<typename _Tp1>\n-        __weak_ptr&\n-        operator=(const __weak_ptr<_Tp1, _Lp>& __r) // never throws\n-        {\n-\t  _M_ptr = __r.lock().get();\n-\t  _M_refcount = __r._M_refcount;\n-\t  return *this;\n-\t}\n-      \n-      template<typename _Tp1>\n-        __weak_ptr&\n-        operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n-        {\n-\t  _M_ptr = __r._M_ptr;\n-\t  _M_refcount = __r._M_refcount;\n-\t  return *this;\n-\t}\n-\n-      __shared_ptr<_Tp, _Lp>\n-      lock() const // never throws\n-      {\n-#ifdef __GTHREADS\n-\t// Optimization: avoid throw overhead.\n-\tif (expired())\n-\t  return __shared_ptr<element_type, _Lp>();\n-\n-\t__try\n-\t  {\n-\t    return __shared_ptr<element_type, _Lp>(*this);\n-\t  }\n-\t__catch(const bad_weak_ptr&)\n-\t  {\n-\t    // Q: How can we get here?\n-\t    // A: Another thread may have invalidated r after the\n-\t    //    use_count test above.\n-\t    return __shared_ptr<element_type, _Lp>();\n-\t  }\n-\t\n-#else\n-\t// Optimization: avoid try/catch overhead when single threaded.\n-\treturn expired() ? __shared_ptr<element_type, _Lp>()\n-\t                 : __shared_ptr<element_type, _Lp>(*this);\n-\n-#endif\n-      } // XXX MT\n-\n-      long\n-      use_count() const // never throws\n-      { return _M_refcount._M_get_use_count(); }\n-\n-      bool\n-      expired() const // never throws\n-      { return _M_refcount._M_get_use_count() == 0; }\n-\n-      template<typename _Tp1>\n-        bool\n-        owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const\n-        { return _M_refcount._M_less(__rhs._M_refcount); }\n-\n-      template<typename _Tp1>\n-        bool\n-        owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n-        { return _M_refcount._M_less(__rhs._M_refcount); }\n-\n-      void\n-      reset() // never throws\n-      { __weak_ptr().swap(*this); }\n-\n-      void\n-      swap(__weak_ptr& __s) // never throws\n-      {\n-\tstd::swap(_M_ptr, __s._M_ptr);\n-\t_M_refcount._M_swap(__s._M_refcount);\n-      }\n-\n-      // comparisons\n-      template<typename _Tp1>\n-        bool operator<(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n-      template<typename _Tp1>\n-        bool operator<=(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n-      template<typename _Tp1>\n-        bool operator>(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n-      template<typename _Tp1>\n-        bool operator>=(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n-\n-    private:\n-      // Used by __enable_shared_from_this.\n-      void\n-      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount)\n-      {\n-\t_M_ptr = __ptr;\n-\t_M_refcount = __refcount;\n-      }\n-\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n-      friend class __enable_shared_from_this<_Tp, _Lp>;\n-      friend class enable_shared_from_this<_Tp>;\n-\n-      _Tp*       \t _M_ptr;         // Contained pointer.\n-      __weak_count<_Lp>  _M_refcount;    // Reference counter.\n-    };\n-\n-  // 20.8.13.3.7 weak_ptr specialized algorithms.\n-  template<typename _Tp, _Lock_policy _Lp>\n-    inline void\n-    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)\n-    { __a.swap(__b); }\n-\n-  /// owner_less\n-  template<typename _Tp> struct owner_less;\n-\n-  template<typename _Tp, typename _Tp1>\n-    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>\n-    {\n-      bool\n-      operator()(const _Tp& __lhs, const _Tp& __rhs) const\n-      { return __lhs.owner_before(__rhs); }\n-      bool\n-      operator()(const _Tp& __lhs, const _Tp1& __rhs) const\n-      { return __lhs.owner_before(__rhs); }\n-      bool\n-      operator()(const _Tp1& __lhs, const _Tp& __rhs) const\n-      { return __lhs.owner_before(__rhs); }\n-    };\n-\n-  template<typename _Tp, _Lock_policy _Lp>\n-    struct owner_less<__shared_ptr<_Tp, _Lp>>\n-    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>\n-    { };\n-\n-  template<typename _Tp, _Lock_policy _Lp>\n-    struct owner_less<__weak_ptr<_Tp, _Lp>>\n-    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>\n-    {\n-    };\n-\n-\n-  template<typename _Tp, _Lock_policy _Lp>\n-    class __enable_shared_from_this\n-    {\n-    protected:\n-      __enable_shared_from_this() { }\n-      \n-      __enable_shared_from_this(const __enable_shared_from_this&) { }\n-      \n-      __enable_shared_from_this&\n-      operator=(const __enable_shared_from_this&)\n-      { return *this; }\n-\n-      ~__enable_shared_from_this() { }\n-      \n-    public:\n-      __shared_ptr<_Tp, _Lp>\n-      shared_from_this()\n-      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }\n-\n-      __shared_ptr<const _Tp, _Lp>\n-      shared_from_this() const\n-      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }\n-\n-    private:\n-      template<typename _Tp1>\n-        void\n-        _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const\n-        { _M_weak_this._M_assign(__p, __n); }\n-\n-      template<typename _Tp1>\n-        friend void\n-        __enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,\n-\t\t\t\t\t const __enable_shared_from_this* __pe,\n-\t\t\t\t\t const _Tp1* __px)\n-        {\n-\t  if (__pe != 0)\n-\t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n-\t}\n-\n-      mutable __weak_ptr<_Tp, _Lp>  _M_weak_this;\n-    };\n-\n-  /**\n-   *  @brief A smart pointer with reference-counted copy semantics. \n-   *  \n-   *  The object pointed to is deleted when the last shared_ptr pointing to\n-   *  it is destroyed or reset.\n-   */\n-  template<typename _Tp>\n-    class shared_ptr\n-    : public __shared_ptr<_Tp>\n-    {\n-    public:\n-      shared_ptr()\n-      : __shared_ptr<_Tp>() { }\n-\n-      template<typename _Tp1>\n-        explicit\n-        shared_ptr(_Tp1* __p)\n-\t: __shared_ptr<_Tp>(__p) { }\n-\n-      template<typename _Tp1, typename _Deleter>\n-        shared_ptr(_Tp1* __p, _Deleter __d)\n-\t: __shared_ptr<_Tp>(__p, __d) { }\n-\n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-        shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n-\t: __shared_ptr<_Tp>(__p, __d, __a) { }\n-\n-      // Aliasing constructor\n-      template<typename _Tp1>\n-        shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p)\n-\t: __shared_ptr<_Tp>(__r, __p) { }\n-\n-      template<typename _Tp1>\n-        shared_ptr(const shared_ptr<_Tp1>& __r)\n-\t: __shared_ptr<_Tp>(__r) { }\n-\n-      shared_ptr(shared_ptr&& __r)\n-      : __shared_ptr<_Tp>(std::move(__r)) { }\n-\n-      template<typename _Tp1>\n-        shared_ptr(shared_ptr<_Tp1>&& __r)\n-        : __shared_ptr<_Tp>(std::move(__r)) { }\n-\n-      template<typename _Tp1>\n-        explicit\n-        shared_ptr(const weak_ptr<_Tp1>& __r)\n+\texplicit shared_ptr(const weak_ptr<_Tp1>& __r)\n \t: __shared_ptr<_Tp>(__r) { }\n \n #if _GLIBCXX_DEPRECATED\n       template<typename _Tp1>\n-        explicit\n-        shared_ptr(std::auto_ptr<_Tp1>&& __r)\n+\texplicit\n+\tshared_ptr(std::auto_ptr<_Tp1>&& __r)\n \t: __shared_ptr<_Tp>(std::move(__r)) { }\n #endif\n \n       template<typename _Tp1, typename _Del>\n-        explicit\n-        shared_ptr(const std::unique_ptr<_Tp1, _Del>&) = delete;\n+\texplicit shared_ptr(const std::unique_ptr<_Tp1, _Del>&) = delete;\n \n       template<typename _Tp1, typename _Del>\n-        explicit\n-        shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+\texplicit shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n \t: __shared_ptr<_Tp>(std::move(__r)) { }\n \n       template<typename _Tp1>\n-        shared_ptr&\n-        operator=(const shared_ptr<_Tp1>& __r) // never throws\n-        {\n+\tshared_ptr&\n+\toperator=(const shared_ptr<_Tp1>& __r) // never throws\n+\t{\n \t  this->__shared_ptr<_Tp>::operator=(__r);\n \t  return *this;\n \t}\n \n #if _GLIBCXX_DEPRECATED\n       template<typename _Tp1>\n-        shared_ptr&\n-        operator=(std::auto_ptr<_Tp1>&& __r)\n-        {\n+\tshared_ptr&\n+\toperator=(std::auto_ptr<_Tp1>&& __r)\n+\t{\n \t  this->__shared_ptr<_Tp>::operator=(std::move(__r));\n \t  return *this;\n \t}\n@@ -1294,40 +235,40 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       shared_ptr&\n       operator=(shared_ptr&& __r)\n       {\n-        this->__shared_ptr<_Tp>::operator=(std::move(__r));\n-        return *this;\n+\tthis->__shared_ptr<_Tp>::operator=(std::move(__r));\n+\treturn *this;\n       }\n-     \n+\n       template<class _Tp1>\n-        shared_ptr&\n-        operator=(shared_ptr<_Tp1>&& __r)\n-        {\n-          this->__shared_ptr<_Tp>::operator=(std::move(__r));\n-          return *this;\n-        }\n+\tshared_ptr&\n+\toperator=(shared_ptr<_Tp1>&& __r)\n+\t{\n+\t  this->__shared_ptr<_Tp>::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n \n       template<typename _Tp1, typename _Del>\n-        shared_ptr&\n-        operator=(const std::unique_ptr<_Tp1, _Del>& __r) = delete;\n+\tshared_ptr&\n+\toperator=(const std::unique_ptr<_Tp1, _Del>& __r) = delete;\n \n       template<typename _Tp1, typename _Del>\n-        shared_ptr&\n-        operator=(std::unique_ptr<_Tp1, _Del>&& __r)\n-        {\n+\tshared_ptr&\n+\toperator=(std::unique_ptr<_Tp1, _Del>&& __r)\n+\t{\n \t  this->__shared_ptr<_Tp>::operator=(std::move(__r));\n \t  return *this;\n \t}\n \n     private:\n       // This constructor is non-standard, it is used by allocate_shared.\n       template<typename _Alloc, typename... _Args>\n-        shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n-        : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)\n-        { }\n+\tshared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n+\t: __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)\n+\t{ }\n \n       template<typename _Tp1, typename _Alloc, typename... _Args>\n-        friend shared_ptr<_Tp1>\n-        allocate_shared(_Alloc __a, _Args&&... __args);\n+\tfriend shared_ptr<_Tp1>\n+\tallocate_shared(_Alloc __a, _Args&&... __args);\n     };\n \n   // 20.8.13.2.7 shared_ptr comparisons\n@@ -1347,8 +288,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     { return __a.get() < __b.get(); }\n \n   template<typename _Tp>\n-    struct less<shared_ptr<_Tp>>\n-    : public _Sp_less<shared_ptr<_Tp>>\n+    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>\n     { };\n \n   // 20.8.13.2.9 shared_ptr specialized algorithms.\n@@ -1373,44 +313,42 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n     {\n       if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n-        return shared_ptr<_Tp>(__r, __p);\n+\treturn shared_ptr<_Tp>(__r, __p);\n       return shared_ptr<_Tp>();\n     }\n \n \n-  /** \n-   *  @brief A smart pointer with weak semantics.\n-   *  \n+  /**\n+   *  @brief  A smart pointer with weak semantics.\n+   *\n    *  With forwarding constructors and assignment operators.\n    */\n   template<typename _Tp>\n-    class weak_ptr\n-    : public __weak_ptr<_Tp>\n+    class weak_ptr : public __weak_ptr<_Tp>\n     {\n     public:\n-      weak_ptr()\n-      : __weak_ptr<_Tp>() { }\n-      \n+      weak_ptr() : __weak_ptr<_Tp>() { }\n+\n       template<typename _Tp1>\n-        weak_ptr(const weak_ptr<_Tp1>& __r)\n+\tweak_ptr(const weak_ptr<_Tp1>& __r)\n \t: __weak_ptr<_Tp>(__r) { }\n \n       template<typename _Tp1>\n-        weak_ptr(const shared_ptr<_Tp1>& __r)\n+\tweak_ptr(const shared_ptr<_Tp1>& __r)\n \t: __weak_ptr<_Tp>(__r) { }\n \n       template<typename _Tp1>\n-        weak_ptr&\n-        operator=(const weak_ptr<_Tp1>& __r) // never throws\n-        {\n+\tweak_ptr&\n+\toperator=(const weak_ptr<_Tp1>& __r) // never throws\n+\t{\n \t  this->__weak_ptr<_Tp>::operator=(__r);\n \t  return *this;\n \t}\n \n       template<typename _Tp1>\n-        weak_ptr&\n-        operator=(const shared_ptr<_Tp1>& __r) // never throws\n-        {\n+\tweak_ptr&\n+\toperator=(const shared_ptr<_Tp1>& __r) // never throws\n+\t{\n \t  this->__weak_ptr<_Tp>::operator=(__r);\n \t  return *this;\n \t}\n@@ -1431,20 +369,19 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t    return shared_ptr<_Tp>();\n \t  }\n #else\n-\treturn this->expired() ? shared_ptr<_Tp>()\n-\t                       : shared_ptr<_Tp>(*this);\n+\treturn this->expired() ? shared_ptr<_Tp>() : shared_ptr<_Tp>(*this);\n #endif\n       }\n \n-      // comparisons\n+      // Comparisons\n       template<typename _Tp1>\n-        bool operator<(const weak_ptr<_Tp1>&) const = delete;\n+\tbool operator<(const weak_ptr<_Tp1>&) const = delete;\n       template<typename _Tp1>\n-        bool operator<=(const weak_ptr<_Tp1>&) const = delete;\n+\tbool operator<=(const weak_ptr<_Tp1>&) const = delete;\n       template<typename _Tp1>\n-        bool operator>(const weak_ptr<_Tp1>&) const = delete;\n+\tbool operator>(const weak_ptr<_Tp1>&) const = delete;\n       template<typename _Tp1>\n-        bool operator>=(const weak_ptr<_Tp1>&) const = delete;\n+\tbool operator>=(const weak_ptr<_Tp1>&) const = delete;\n     };\n \n   // 20.8.13.3.7 weak_ptr specialized algorithms.\n@@ -1453,26 +390,32 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b)\n     { __a.swap(__b); }\n \n-  /// owner_less\n+\n+  /// Primary template owner_less\n+  template<typename _Tp>\n+    struct owner_less;\n+\n+  /// Partial specialization of owner_less for shared_ptr.\n   template<typename _Tp>\n     struct owner_less<shared_ptr<_Tp>>\n     : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>\n     { };\n \n+  /// Partial specialization of owner_less for weak_ptr.\n   template<typename _Tp>\n     struct owner_less<weak_ptr<_Tp>>\n     : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>\n     { };\n \n-  /** \n+  /**\n    *  @brief Base class allowing use of member function shared_from_this.\n    */\n   template<typename _Tp>\n     class enable_shared_from_this\n     {\n     protected:\n       enable_shared_from_this() { }\n-      \n+\n       enable_shared_from_this(const enable_shared_from_this&) { }\n \n       enable_shared_from_this&\n@@ -1492,41 +435,25 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n     private:\n       template<typename _Tp1>\n-        void\n-        _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const\n-        { _M_weak_this._M_assign(__p, __n); }\n+\tvoid\n+\t_M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const\n+\t{ _M_weak_this._M_assign(__p, __n); }\n \n       template<typename _Tp1>\n-        friend void\n-        __enable_shared_from_this_helper(const __shared_count<>& __pn,\n+\tfriend void\n+\t__enable_shared_from_this_helper(const __shared_count<>& __pn,\n \t\t\t\t\t const enable_shared_from_this* __pe,\n \t\t\t\t\t const _Tp1* __px)\n-        {\n+\t{\n \t  if (__pe != 0)\n \t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n \t}\n \n       mutable weak_ptr<_Tp>  _M_weak_this;\n     };\n \n-  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>\n-    inline __shared_ptr<_Tp, _Lp>\n-    __allocate_shared(_Alloc __a, _Args&&... __args)\n-    {\n-      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(),\n-          std::forward<_Alloc>(__a), std::forward<_Args>(__args)...);\n-    }\n-\n-  template<typename _Tp, _Lock_policy _Lp, typename... _Args>\n-    inline __shared_ptr<_Tp, _Lp>\n-    __make_shared(_Args&&... __args)\n-    {\n-      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n-      return __allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),\n-              std::forward<_Args>(__args)...);\n-    }\n-\n-  /** @brief  Create an object that is owned by a shared_ptr.\n+  /**\n+   *  @brief  Create an object that is owned by a shared_ptr.\n    *  @param  __a     An allocator.\n    *  @param  __args  Arguments for the @a _Tp object's constructor.\n    *  @return A shared_ptr that owns the newly created object.\n@@ -1541,10 +468,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     allocate_shared(_Alloc __a, _Args&&... __args)\n     {\n       return shared_ptr<_Tp>(_Sp_make_shared_tag(), std::forward<_Alloc>(__a),\n-              std::forward<_Args>(__args)...);\n+\t\t\t     std::forward<_Args>(__args)...);\n     }\n \n-  /** @brief  Create an object that is owned by a shared_ptr. \n+  /**\n+   *  @brief  Create an object that is owned by a shared_ptr.\n    *  @param  __args  Arguments for the @a _Tp object's constructor.\n    *  @return A shared_ptr that owns the newly created object.\n    *  @throw  std::bad_alloc, or an exception thrown from the\n@@ -1556,7 +484,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     {\n       typedef typename std::remove_const<_Tp>::type _Tp_nc;\n       return allocate_shared<_Tp>(std::allocator<_Tp_nc>(),\n-              std::forward<_Args>(__args)...);\n+\t\t\t\t  std::forward<_Args>(__args)...);\n     }\n \n   // @} group pointer_abstractions"}, {"sha": "b8083e405c893d74363cd1d29f40682e5e33255f", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "added", "additions": 1114, "deletions": 0, "changes": 1114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -0,0 +1,1114 @@\n+// shared_ptr and weak_ptr implementation details -*- C++ -*-\n+\n+// Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+// GCC Note: Based on files from version 1.32.0 of the Boost library.\n+\n+//  shared_count.hpp\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n+\n+//  shared_ptr.hpp\n+//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  weak_ptr.hpp\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  enable_shared_from_this.hpp\n+//  Copyright (C) 2002 Peter Dimov\n+\n+// Distributed under the Boost Software License, Version 1.0. (See\n+// accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+/** @file bits/shared_ptr_base.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _SHARED_PTR_BASE_H\n+#define _SHARED_PTR_BASE_H 1\n+\n+_GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  // Forward declarations.\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __shared_ptr;\n+\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __weak_ptr;\n+\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __enable_shared_from_this;\n+\n+  template<typename _Tp>\n+    class shared_ptr;\n+\n+  template<typename _Tp>\n+    class weak_ptr;\n+\n+  template<typename _Tp>\n+    struct owner_less;\n+\n+  template<typename _Tp>\n+    class enable_shared_from_this;\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __weak_count;\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __shared_count;\n+\n+\n+  // Counted ptr with no deleter or allocator support\n+  template<typename _Ptr, _Lock_policy _Lp>\n+    class _Sp_counted_ptr : public _Sp_counted_base<_Lp>\n+    {\n+    public:\n+      _Sp_counted_ptr(_Ptr __p)\n+      : _M_ptr(__p) { }\n+\n+      virtual void\n+      _M_dispose() // nothrow\n+      { delete _M_ptr; }\n+\n+      virtual void\n+      _M_destroy() // nothrow\n+      { delete this; }\n+\n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      { return 0; }\n+\n+      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;\n+      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;\n+\n+    protected:\n+      _Ptr             _M_ptr;  // copy constructor must not throw\n+    };\n+\n+  // Support for custom deleter and/or allocator\n+  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_deleter : public _Sp_counted_ptr<_Ptr, _Lp>\n+    {\n+      typedef typename _Alloc::template\n+\t  rebind<_Sp_counted_deleter>::other _My_alloc_type;\n+\n+      // Helper class that stores the Deleter and also acts as an allocator.\n+      // Used to dispose of the owned pointer and the internal refcount\n+      // Requires that copies of _Alloc can free each other's memory.\n+      struct _My_Deleter\n+      : public _My_alloc_type    // copy constructor must not throw\n+      {\n+\t_Deleter _M_del;         // copy constructor must not throw\n+\t_My_Deleter(_Deleter __d, const _Alloc& __a)\n+\t  : _My_alloc_type(__a), _M_del(__d) { }\n+      };\n+\n+    protected:\n+      typedef _Sp_counted_ptr<_Ptr, _Lp> _Base_type;\n+\n+    public:\n+      // __d(__p) must not throw.\n+      _Sp_counted_deleter(_Ptr __p, _Deleter __d)\n+      : _Base_type(__p), _M_del(__d, _Alloc()) { }\n+\n+      // __d(__p) must not throw.\n+      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a)\n+      : _Base_type(__p), _M_del(__d, __a) { }\n+\n+      virtual void\n+      _M_dispose() // nothrow\n+      { _M_del._M_del(_Base_type::_M_ptr); }\n+\n+      virtual void\n+      _M_destroy() // nothrow\n+      {\n+\t_My_alloc_type __a(_M_del);\n+\tthis->~_Sp_counted_deleter();\n+\t__a.deallocate(this, 1);\n+      }\n+\n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      { return __ti == typeid(_Deleter) ? &_M_del._M_del : 0; }\n+\n+    protected:\n+      _My_Deleter      _M_del;  // copy constructor must not throw\n+    };\n+\n+  // helpers for make_shared / allocate_shared\n+\n+  template<typename _Tp>\n+    struct _Sp_destroy_inplace\n+    {\n+      void operator()(_Tp* __p) const { if (__p) __p->~_Tp(); }\n+    };\n+\n+  struct _Sp_make_shared_tag { };\n+\n+  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_ptr_inplace\n+    : public _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n+    {\n+      typedef _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n+\t_Base_type;\n+\n+    public:\n+      _Sp_counted_ptr_inplace(_Alloc __a)\n+      : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n+      , _M_storage()\n+      {\n+\tvoid* __p = &_M_storage;\n+\t::new (__p) _Tp();  // might throw\n+\t_Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n+      }\n+\n+      template<typename... _Args>\n+\t_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n+\t: _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n+\t, _M_storage()\n+\t{\n+\t  void* __p = &_M_storage;\n+\t  ::new (__p) _Tp(std::forward<_Args>(__args)...);  // might throw\n+\t  _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n+\t}\n+\n+      // Override because the allocator needs to know the dynamic type\n+      virtual void\n+      _M_destroy() // nothrow\n+      {\n+\ttypedef typename _Alloc::template\n+\t    rebind<_Sp_counted_ptr_inplace>::other _My_alloc_type;\n+\t_My_alloc_type __a(_Base_type::_M_del);\n+\tthis->~_Sp_counted_ptr_inplace();\n+\t__a.deallocate(this, 1);\n+      }\n+\n+      // Sneaky trick so __shared_ptr can get the managed pointer\n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      {\n+\treturn __ti == typeid(_Sp_make_shared_tag)\n+\t       ? static_cast<void*>(&_M_storage)\n+\t       : _Base_type::_M_get_deleter(__ti);\n+      }\n+\n+    private:\n+      typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type\n+\t_M_storage;\n+    };\n+\n+  template<_Lock_policy _Lp>\n+    class __shared_count\n+    {\n+    public:\n+      __shared_count() : _M_pi(0) // nothrow\n+      { }\n+\n+      template<typename _Ptr>\n+\t__shared_count(_Ptr __p) : _M_pi(0)\n+\t{\n+\t  __try\n+\t    {\n+\t      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      delete __p;\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+\n+      template<typename _Ptr, typename _Deleter>\n+\t__shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n+\t{\n+\t  // The allocator's value_type doesn't matter, will rebind it anyway.\n+\t  typedef std::allocator<int> _Alloc;\n+\t  typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n+\t  typedef std::allocator<_Sp_cd_type> _Alloc2;\n+\t  _Alloc2 __a2;\n+\t  __try\n+\t    {\n+\t      _M_pi = __a2.allocate(1);\n+\t      ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d);\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      __d(__p); // Call _Deleter on __p.\n+\t      if (_M_pi)\n+\t\t__a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+\n+      template<typename _Ptr, typename _Deleter, typename _Alloc>\n+\t__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n+\t{\n+\t  typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n+\t  typedef typename _Alloc::template rebind<_Sp_cd_type>::other _Alloc2;\n+\t  _Alloc2 __a2(__a);\n+\t  __try\n+\t    {\n+\t      _M_pi = __a2.allocate(1);\n+\t      ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d, __a);\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      __d(__p); // Call _Deleter on __p.\n+\t      if (_M_pi)\n+\t\t__a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+\n+      template<typename _Tp, typename _Alloc, typename... _Args>\n+\t__shared_count(_Sp_make_shared_tag, _Tp*, _Alloc __a, _Args&&... __args)\n+\t: _M_pi(0)\n+\t{\n+\t  typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;\n+\t  typedef typename _Alloc::template rebind<_Sp_cp_type>::other _Alloc2;\n+\t  _Alloc2 __a2(__a);\n+\t  __try\n+\t    {\n+\t      _M_pi = __a2.allocate(1);\n+\t      ::new(static_cast<void*>(_M_pi)) _Sp_cp_type(__a,\n+\t\t    std::forward<_Args>(__args)...);\n+\t    }\n+\t  __catch(...)\n+\t    {\n+\t      if (_M_pi)\n+\t\t__a2.deallocate(static_cast<_Sp_cp_type*>(_M_pi), 1);\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+\n+#if _GLIBCXX_DEPRECATED\n+      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n+      template<typename _Tp>\n+\texplicit __shared_count(std::auto_ptr<_Tp>&& __r)\n+\t: _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))\n+\t{ __r.release(); }\n+#endif\n+\n+      // Special case for unique_ptr<_Tp,_Del> to provide the strong guarantee.\n+      template<typename _Tp, typename _Del>\n+\texplicit __shared_count(std::unique_ptr<_Tp, _Del>&& __r)\n+\t: _M_pi(_S_create_from_up(std::move(__r)))\n+\t{ __r.release(); }\n+\n+      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n+      explicit __shared_count(const __weak_count<_Lp>& __r);\n+\n+      ~__shared_count() // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_release();\n+      }\n+\n+      __shared_count(const __shared_count& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_add_ref_copy();\n+      }\n+\n+      __shared_count&\n+      operator=(const __shared_count& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != _M_pi)\n+\t  {\n+\t    if (__tmp != 0)\n+\t      __tmp->_M_add_ref_copy();\n+\t    if (_M_pi != 0)\n+\t      _M_pi->_M_release();\n+\t    _M_pi = __tmp;\n+\t  }\n+\treturn *this;\n+      }\n+\n+      void\n+      _M_swap(__shared_count& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\t__r._M_pi = _M_pi;\n+\t_M_pi = __tmp;\n+      }\n+\n+      long\n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n+      bool\n+      _M_unique() const // nothrow\n+      { return this->_M_get_use_count() == 1; }\n+\n+      void*\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n+\n+      bool\n+      _M_less(const __shared_count& __rhs) const\n+      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n+\n+      bool\n+      _M_less(const __weak_count<_Lp>& __rhs) const\n+      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n+\n+      // Friend function injected into enclosing namespace and found by ADL\n+      friend inline bool\n+      operator==(const __shared_count& __a, const __shared_count& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+\n+    private:\n+      friend class __weak_count<_Lp>;\n+\n+      template<typename _Tp, typename _Del>\n+\tstatic _Sp_counted_base<_Lp>*\n+\t_S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,\n+\t  typename std::enable_if<!std::is_reference<_Del>::value>::type* = 0)\n+\t{\n+\t  return new _Sp_counted_deleter<_Tp*, _Del, std::allocator<_Tp>,\n+\t    _Lp>(__r.get(), __r.get_deleter());\n+\t}\n+\n+      template<typename _Tp, typename _Del>\n+\tstatic _Sp_counted_base<_Lp>*\n+\t_S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,\n+\t  typename std::enable_if<std::is_reference<_Del>::value>::type* = 0)\n+\t{\n+\t  typedef typename std::remove_reference<_Del>::type _Del1;\n+\t  typedef std::reference_wrapper<_Del1> _Del2;\n+\t  return new _Sp_counted_deleter<_Tp*, _Del2, std::allocator<_Tp>,\n+\t    _Lp>(__r.get(), std::ref(__r.get_deleter()));\n+\t}\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n+    };\n+\n+\n+  template<_Lock_policy _Lp>\n+    class __weak_count\n+    {\n+    public:\n+      __weak_count() : _M_pi(0) // nothrow\n+      { }\n+\n+      __weak_count(const __shared_count<_Lp>& __r) : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_add_ref();\n+      }\n+\n+      __weak_count(const __weak_count<_Lp>& __r) : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_add_ref();\n+      }\n+\n+      ~__weak_count() // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_release();\n+      }\n+\n+      __weak_count<_Lp>&\n+      operator=(const __shared_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != 0)\n+\t  __tmp->_M_weak_add_ref();\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_release();\n+\t_M_pi = __tmp;\n+\treturn *this;\n+      }\n+\n+      __weak_count<_Lp>&\n+      operator=(const __weak_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != 0)\n+\t  __tmp->_M_weak_add_ref();\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_release();\n+\t_M_pi = __tmp;\n+\treturn *this;\n+      }\n+\n+      void\n+      _M_swap(__weak_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\t__r._M_pi = _M_pi;\n+\t_M_pi = __tmp;\n+      }\n+\n+      long\n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n+      bool\n+      _M_less(const __weak_count& __rhs) const\n+      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n+\n+      bool\n+      _M_less(const __shared_count<_Lp>& __rhs) const\n+      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n+\n+      // Friend function injected into enclosing namespace and found by ADL\n+      friend inline bool\n+      operator==(const __weak_count& __a, const __weak_count& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+\n+    private:\n+      friend class __shared_count<_Lp>;\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n+    };\n+\n+  // Now that __weak_count is defined we can define this constructor:\n+  template<_Lock_policy _Lp>\n+    inline __shared_count<_Lp>:: __shared_count(const __weak_count<_Lp>& __r)\n+    : _M_pi(__r._M_pi)\n+    {\n+      if (_M_pi != 0)\n+\t_M_pi->_M_add_ref_lock();\n+      else\n+\t__throw_bad_weak_ptr();\n+    }\n+\n+\n+  // Support for enable_shared_from_this.\n+\n+  // Friend of __enable_shared_from_this.\n+  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>\n+    void\n+    __enable_shared_from_this_helper(const __shared_count<_Lp>&,\n+\t\t\t\t     const __enable_shared_from_this<_Tp1,\n+\t\t\t\t     _Lp>*, const _Tp2*);\n+\n+  // Friend of enable_shared_from_this.\n+  template<typename _Tp1, typename _Tp2>\n+    void\n+    __enable_shared_from_this_helper(const __shared_count<>&,\n+\t\t\t\t     const enable_shared_from_this<_Tp1>*,\n+\t\t\t\t     const _Tp2*);\n+\n+  template<_Lock_policy _Lp>\n+    inline void\n+    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...)\n+    { }\n+\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __shared_ptr\n+    {\n+    public:\n+      typedef _Tp   element_type;\n+\n+      __shared_ptr() : _M_ptr(0), _M_refcount() // never throws\n+      { }\n+\n+      template<typename _Tp1>\n+\texplicit __shared_ptr(_Tp1* __p) : _M_ptr(__p), _M_refcount(__p)\n+\t{\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n+\t}\n+\n+      template<typename _Tp1, typename _Deleter>\n+\t__shared_ptr(_Tp1* __p, _Deleter __d)\n+\t: _M_ptr(__p), _M_refcount(__p, __d)\n+\t{\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n+\t}\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+\t__shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+\t: _M_ptr(__p), _M_refcount(__p, __d, __a)\n+\t{\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n+\t}\n+\n+      template<typename _Tp1>\n+\t__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p)\n+\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n+\t{ }\n+\n+      //  generated copy constructor, assignment, destructor are fine.\n+\n+      template<typename _Tp1>\n+\t__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n+\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+\t{ __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n+\n+      __shared_ptr(__shared_ptr&& __r)\n+      : _M_ptr(__r._M_ptr), _M_refcount() // never throws\n+      {\n+\t_M_refcount._M_swap(__r._M_refcount);\n+\t__r._M_ptr = 0;\n+      }\n+\n+      template<typename _Tp1>\n+\t__shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r)\n+\t: _M_ptr(__r._M_ptr), _M_refcount() // never throws\n+\t{\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  _M_refcount._M_swap(__r._M_refcount);\n+\t  __r._M_ptr = 0;\n+\t}\n+\n+      template<typename _Tp1>\n+\texplicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+\t: _M_refcount(__r._M_refcount) // may throw\n+\t{\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\n+\t  // It is now safe to copy __r._M_ptr, as\n+\t  // _M_refcount(__r._M_refcount) did not throw.\n+\t  _M_ptr = __r._M_ptr;\n+\t}\n+\n+      template<typename _Tp1, typename _Del>\n+\texplicit __shared_ptr(const std::unique_ptr<_Tp1, _Del>&) = delete;\n+\n+      // If an exception is thrown this constructor has no effect.\n+      template<typename _Tp1, typename _Del>\n+\texplicit __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+\t: _M_ptr(__r.get()), _M_refcount()\n+\t{\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  _Tp1* __tmp = __r.get();\n+\t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n+\t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n+\t}\n+\n+#if _GLIBCXX_DEPRECATED\n+      // Postcondition: use_count() == 1 and __r.get() == 0\n+      template<typename _Tp1>\n+\texplicit __shared_ptr(std::auto_ptr<_Tp1>&& __r)\n+\t: _M_ptr(__r.get()), _M_refcount()\n+\t{\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires _Tp1 is complete, delete __r.release() well-formed\n+\t  _Tp1* __tmp = __r.get();\n+\t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n+\t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n+\t}\n+#endif\n+\n+      template<typename _Tp1>\n+\t__shared_ptr&\n+\toperator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n+\t{\n+\t  _M_ptr = __r._M_ptr;\n+\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw\n+\t  return *this;\n+\t}\n+\n+#if _GLIBCXX_DEPRECATED\n+      template<typename _Tp1>\n+\t__shared_ptr&\n+\toperator=(std::auto_ptr<_Tp1>&& __r)\n+\t{\n+\t  __shared_ptr(std::move(__r)).swap(*this);\n+\t  return *this;\n+\t}\n+#endif\n+\n+      __shared_ptr&\n+      operator=(__shared_ptr&& __r)\n+      {\n+\t__shared_ptr(std::move(__r)).swap(*this);\n+\treturn *this;\n+      }\n+\n+      template<class _Tp1>\n+\t__shared_ptr&\n+\toperator=(__shared_ptr<_Tp1, _Lp>&& __r)\n+\t{\n+\t  __shared_ptr(std::move(__r)).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      template<typename _Tp1, typename _Del>\n+\t__shared_ptr&\n+\toperator=(const std::unique_ptr<_Tp1, _Del>& __r) = delete;\n+\n+      template<typename _Tp1, typename _Del>\n+\t__shared_ptr&\n+\toperator=(std::unique_ptr<_Tp1, _Del>&& __r)\n+\t{\n+\t  __shared_ptr(std::move(__r)).swap(*this);\n+\t  return *this;\n+\t}\n+\n+      void\n+      reset() // never throws\n+      { __shared_ptr().swap(*this); }\n+\n+      template<typename _Tp1>\n+\tvoid\n+\treset(_Tp1* __p) // _Tp1 must be complete.\n+\t{\n+\t  // Catch self-reset errors.\n+\t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr);\n+\t  __shared_ptr(__p).swap(*this);\n+\t}\n+\n+      template<typename _Tp1, typename _Deleter>\n+\tvoid\n+\treset(_Tp1* __p, _Deleter __d)\n+\t{ __shared_ptr(__p, __d).swap(*this); }\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+\tvoid\n+\treset(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+\t{ __shared_ptr(__p, __d, __a).swap(*this); }\n+\n+      // Allow class instantiation when _Tp is [cv-qual] void.\n+      typename std::add_lvalue_reference<_Tp>::type\n+      operator*() const // never throws\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn *_M_ptr;\n+      }\n+\n+      _Tp*\n+      operator->() const // never throws\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn _M_ptr;\n+      }\n+\n+      _Tp*\n+      get() const // never throws\n+      { return _M_ptr; }\n+\n+      explicit operator bool() const // never throws\n+      { return _M_ptr == 0 ? false : true; }\n+\n+      bool\n+      unique() const // never throws\n+      { return _M_refcount._M_unique(); }\n+\n+      long\n+      use_count() const // never throws\n+      { return _M_refcount._M_get_use_count(); }\n+\n+      void\n+      swap(__shared_ptr<_Tp, _Lp>& __other) // never throws\n+      {\n+\tstd::swap(_M_ptr, __other._M_ptr);\n+\t_M_refcount._M_swap(__other._M_refcount);\n+      }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const\n+\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const\n+\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n+\n+    protected:\n+      // This constructor is non-standard, it is used by allocate_shared.\n+      template<typename _Alloc, typename... _Args>\n+\t__shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n+\t: _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n+\t\t\t\tstd::forward<_Args>(__args)...)\n+\t{\n+\t  // _M_ptr needs to point to the newly constructed object.\n+\t  // This relies on _Sp_counted_ptr_inplace::_M_get_deleter.\n+\t  void* __p = _M_refcount._M_get_deleter(typeid(__tag));\n+\t  _M_ptr = static_cast<_Tp*>(__p);\n+\t  __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);\n+\t}\n+\n+      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n+\t       typename... _Args>\n+\tfriend __shared_ptr<_Tp1, _Lp1>\n+\t__allocate_shared(_Alloc __a, _Args&&... __args);\n+\n+    private:\n+      void*\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_refcount._M_get_deleter(__ti); }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+\n+      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n+\tfriend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);\n+\n+      _Tp*\t   \t   _M_ptr;         // Contained pointer.\n+      __shared_count<_Lp>  _M_refcount;    // Reference counter.\n+    };\n+\n+\n+  // 20.8.13.2.7 shared_ptr comparisons\n+  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n+    inline bool\n+    operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n+\t       const __shared_ptr<_Tp2, _Lp>& __b)\n+    { return __a.get() == __b.get(); }\n+\n+  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n+    inline bool\n+    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,\n+\t       const __shared_ptr<_Tp2, _Lp>& __b)\n+    { return __a.get() != __b.get(); }\n+\n+  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n+    inline bool\n+    operator<(const __shared_ptr<_Tp1, _Lp>& __a,\n+\t      const __shared_ptr<_Tp2, _Lp>& __b)\n+    { return __a.get() < __b.get(); }\n+\n+  template<typename _Sp>\n+    struct _Sp_less : public binary_function<_Sp, _Sp, bool>\n+    {\n+      bool\n+      operator()(const _Sp& __lhs, const _Sp& __rhs) const\n+      {\n+\ttypedef typename _Sp::element_type element_type;\n+\treturn std::less<element_type*>()(__lhs.get(), __rhs.get());\n+      }\n+    };\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    struct less<__shared_ptr<_Tp, _Lp>>\n+    : public _Sp_less<__shared_ptr<_Tp, _Lp>>\n+    { };\n+\n+  // XXX LessThanComparable<_Tp> concept should provide >, >= and <=\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    operator>(const __shared_ptr<_Tp, _Lp>& __a,\n+\t      const __shared_ptr<_Tp, _Lp>& __b)\n+    { return __a.get() > __b.get(); }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    operator>=(const __shared_ptr<_Tp, _Lp>& __a,\n+\t       const __shared_ptr<_Tp, _Lp>& __b)\n+    { return __a.get() >= __b.get(); }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    operator<=(const __shared_ptr<_Tp, _Lp>& __a,\n+\t       const __shared_ptr<_Tp, _Lp>& __b)\n+    { return __a.get() <= __b.get(); }\n+\n+  // 2.2.3.8 shared_ptr specialized algorithms.\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b)\n+    { __a.swap(__b); }\n+\n+  // 2.2.3.9 shared_ptr casts\n+\n+  // The seemingly equivalent code:\n+  // shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))\n+  // will eventually result in undefined behaviour, attempting to\n+  // delete the same object twice.\n+  /// static_pointer_cast\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }\n+\n+  // The seemingly equivalent code:\n+  // shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))\n+  // will eventually result in undefined behaviour, attempting to\n+  // delete the same object twice.\n+  /// const_pointer_cast\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }\n+\n+  // The seemingly equivalent code:\n+  // shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))\n+  // will eventually result in undefined behaviour, attempting to\n+  // delete the same object twice.\n+  /// dynamic_pointer_cast\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    {\n+      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n+\treturn __shared_ptr<_Tp, _Lp>(__r, __p);\n+      return __shared_ptr<_Tp, _Lp>();\n+    }\n+\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __weak_ptr\n+    {\n+    public:\n+      typedef _Tp element_type;\n+\n+      __weak_ptr() : _M_ptr(0), _M_refcount() // never throws\n+      { }\n+\n+      // Generated copy constructor, assignment, destructor are fine.\n+\n+      // The \"obvious\" converting constructor implementation:\n+      //\n+      //  template<typename _Tp1>\n+      //    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+      //    { }\n+      //\n+      // has a serious problem.\n+      //\n+      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n+      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n+      //\n+      // It is not possible to avoid spurious access violations since\n+      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n+      template<typename _Tp1>\n+\t__weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+\t: _M_refcount(__r._M_refcount) // never throws\n+\t{\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  _M_ptr = __r.lock().get();\n+\t}\n+\n+      template<typename _Tp1>\n+\t__weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n+\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+\t{ __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n+\n+      template<typename _Tp1>\n+\t__weak_ptr&\n+\toperator=(const __weak_ptr<_Tp1, _Lp>& __r) // never throws\n+\t{\n+\t  _M_ptr = __r.lock().get();\n+\t  _M_refcount = __r._M_refcount;\n+\t  return *this;\n+\t}\n+\n+      template<typename _Tp1>\n+\t__weak_ptr&\n+\toperator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n+\t{\n+\t  _M_ptr = __r._M_ptr;\n+\t  _M_refcount = __r._M_refcount;\n+\t  return *this;\n+\t}\n+\n+      __shared_ptr<_Tp, _Lp>\n+      lock() const // never throws\n+      {\n+#ifdef __GTHREADS\n+\t// Optimization: avoid throw overhead.\n+\tif (expired())\n+\t  return __shared_ptr<element_type, _Lp>();\n+\n+\t__try\n+\t  {\n+\t    return __shared_ptr<element_type, _Lp>(*this);\n+\t  }\n+\t__catch(const bad_weak_ptr&)\n+\t  {\n+\t    // Q: How can we get here?\n+\t    // A: Another thread may have invalidated r after the\n+\t    //    use_count test above.\n+\t    return __shared_ptr<element_type, _Lp>();\n+\t  }\n+\n+#else\n+\t// Optimization: avoid try/catch overhead when single threaded.\n+\treturn expired() ? __shared_ptr<element_type, _Lp>()\n+\t\t\t : __shared_ptr<element_type, _Lp>(*this);\n+\n+#endif\n+      } // XXX MT\n+\n+      long\n+      use_count() const // never throws\n+      { return _M_refcount._M_get_use_count(); }\n+\n+      bool\n+      expired() const // never throws\n+      { return _M_refcount._M_get_use_count() == 0; }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const\n+\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n+\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n+\n+      void\n+      reset() // never throws\n+      { __weak_ptr().swap(*this); }\n+\n+      void\n+      swap(__weak_ptr& __s) // never throws\n+      {\n+\tstd::swap(_M_ptr, __s._M_ptr);\n+\t_M_refcount._M_swap(__s._M_refcount);\n+      }\n+\n+      // Comparisons\n+      template<typename _Tp1>\n+\tbool operator<(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n+\n+      template<typename _Tp1>\n+\tbool operator<=(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n+\n+      template<typename _Tp1>\n+\tbool operator>(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n+\n+      template<typename _Tp1>\n+\tbool operator>=(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n+\n+    private:\n+      // Used by __enable_shared_from_this.\n+      void\n+      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount)\n+      {\n+\t_M_ptr = __ptr;\n+\t_M_refcount = __refcount;\n+      }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+      friend class __enable_shared_from_this<_Tp, _Lp>;\n+      friend class enable_shared_from_this<_Tp>;\n+\n+      _Tp*\t \t _M_ptr;         // Contained pointer.\n+      __weak_count<_Lp>  _M_refcount;    // Reference counter.\n+    };\n+\n+  // 20.8.13.3.7 weak_ptr specialized algorithms.\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)\n+    { __a.swap(__b); }\n+\n+  template<typename _Tp, typename _Tp1>\n+    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>\n+    {\n+      bool\n+      operator()(const _Tp& __lhs, const _Tp& __rhs) const\n+      { return __lhs.owner_before(__rhs); }\n+\n+      bool\n+      operator()(const _Tp& __lhs, const _Tp1& __rhs) const\n+      { return __lhs.owner_before(__rhs); }\n+\n+      bool\n+      operator()(const _Tp1& __lhs, const _Tp& __rhs) const\n+      { return __lhs.owner_before(__rhs); }\n+    };\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    struct owner_less<__shared_ptr<_Tp, _Lp>>\n+    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>\n+    { };\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    struct owner_less<__weak_ptr<_Tp, _Lp>>\n+    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>\n+    { };\n+\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __enable_shared_from_this\n+    {\n+    protected:\n+      __enable_shared_from_this() { }\n+\n+      __enable_shared_from_this(const __enable_shared_from_this&) { }\n+\n+      __enable_shared_from_this&\n+      operator=(const __enable_shared_from_this&)\n+      { return *this; }\n+\n+      ~__enable_shared_from_this() { }\n+\n+    public:\n+      __shared_ptr<_Tp, _Lp>\n+      shared_from_this()\n+      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }\n+\n+      __shared_ptr<const _Tp, _Lp>\n+      shared_from_this() const\n+      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }\n+\n+    private:\n+      template<typename _Tp1>\n+\tvoid\n+\t_M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const\n+\t{ _M_weak_this._M_assign(__p, __n); }\n+\n+      template<typename _Tp1>\n+\tfriend void\n+\t__enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,\n+\t\t\t\t\t const __enable_shared_from_this* __pe,\n+\t\t\t\t\t const _Tp1* __px)\n+\t{\n+\t  if (__pe != 0)\n+\t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+\t}\n+\n+      mutable __weak_ptr<_Tp, _Lp>  _M_weak_this;\n+    };\n+\n+\n+  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>\n+    inline __shared_ptr<_Tp, _Lp>\n+    __allocate_shared(_Alloc __a, _Args&&... __args)\n+    {\n+      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(),\n+\t  std::forward<_Alloc>(__a), std::forward<_Args>(__args)...);\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp, typename... _Args>\n+    inline __shared_ptr<_Tp, _Lp>\n+    __make_shared(_Args&&... __args)\n+    {\n+      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n+      return __allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),\n+\t\t\t\t\t std::forward<_Args>(__args)...);\n+    }\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif // _SHARED_PTR_BASE_H"}, {"sha": "f9c3ab2b42885752c088a8b8d38f9edf76a0892d", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -998,17 +998,17 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_P)\n     }\n \n   /**\n-   *  @brief Performs \"dictionary\" comparison on ranges.\n+   *  @brief Performs 'dictionary' comparison on ranges.\n    *  @ingroup sorting_algorithms\n    *  @param  first1  An input iterator.\n    *  @param  last1   An input iterator.\n    *  @param  first2  An input iterator.\n    *  @param  last2   An input iterator.\n    *  @return   A boolean true or false.\n    *\n-   *  \"Returns true if the sequence of elements defined by the range\n+   *  'Returns true if the sequence of elements defined by the range\n    *  [first1,last1) is lexicographically less than the sequence of elements\n-   *  defined by the range [first2,last2).  Returns false otherwise.\"\n+   *  defined by the range [first2,last2).  Returns false otherwise.'\n    *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,\n    *  then this is an inline call to @c memcmp.\n   */"}, {"sha": "a60fea60a6bd7af7e2d4d477f27ed2546f037728", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -67,9 +67,14 @@\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+  /**\n+   * @addtogroup iterators\n+   * @{\n+   */\n+\n   // 24.4.1 Reverse iterators\n   /**\n-   *  \"Bidirectional and random access iterators have corresponding reverse\n+   *  'Bidirectional and random access iterators have corresponding reverse\n    *  %iterator adaptors that iterate through the data structure in the\n    *  opposite direction.  They have the same signatures as the corresponding\n    *  iterators.  The fundamental relation between a reverse %iterator and its\n@@ -80,7 +85,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *\n    *  This mapping is dictated by the fact that while there is always a\n    *  pointer past the end of an array, there might not be a valid pointer\n-   *  before the beginning of an array.\" [24.4.1]/1,2\n+   *  before the beginning of an array.' [24.4.1]/1,2\n    *\n    *  Reverse iterators can be tricky and surprising at first.  Their\n    *  semantics make sense, however, and the trickiness is a side effect of\n@@ -97,14 +102,14 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     protected:\n       _Iterator current;\n \n-    public:\n-      typedef _Iterator\t\t\t\t\t       iterator_type;\n-      typedef typename iterator_traits<_Iterator>::difference_type\n-\t\t\t\t\t\t\t       difference_type;\n-      typedef typename iterator_traits<_Iterator>::reference   reference;\n-      typedef typename iterator_traits<_Iterator>::pointer     pointer;\n+      typedef iterator_traits<_Iterator>\t\t__traits_type;\n \n     public:\n+      typedef _Iterator\t\t\t\t\titerator_type;\n+      typedef typename __traits_type::difference_type\tdifference_type;\n+      typedef typename __traits_type::pointer\t\tpointer;\n+      typedef typename __traits_type::reference\t\treference;\n+\n       /**\n        *  The default constructor default-initializes member @p current.\n        *  If it is a pointer, that means it is zero-initialized.\n@@ -651,6 +656,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t\t\t\t typename _Container::iterator(__i));\n     }\n \n+  // @} group iterators\n+\n _GLIBCXX_END_NAMESPACE\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n@@ -670,15 +677,15 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     protected:\n       _Iterator _M_current;\n \n+      typedef iterator_traits<_Iterator>\t\t__traits_type;\n+\n     public:\n-      typedef _Iterator\t\t\t\t\t     iterator_type;\n-      typedef typename iterator_traits<_Iterator>::iterator_category\n-                                                             iterator_category;\n-      typedef typename iterator_traits<_Iterator>::value_type  value_type;\n-      typedef typename iterator_traits<_Iterator>::difference_type\n-                                                             difference_type;\n-      typedef typename iterator_traits<_Iterator>::reference reference;\n-      typedef typename iterator_traits<_Iterator>::pointer   pointer;\n+      typedef _Iterator\t\t\t\t\titerator_type;\n+      typedef typename __traits_type::iterator_category iterator_category;\n+      typedef typename __traits_type::value_type  \tvalue_type;\n+      typedef typename __traits_type::difference_type \tdifference_type;\n+      typedef typename __traits_type::reference \treference;\n+      typedef typename __traits_type::pointer   \tpointer;\n \n       __normal_iterator() : _M_current(_Iterator()) { }\n \n@@ -869,6 +876,11 @@ _GLIBCXX_END_NAMESPACE\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+  /**\n+   * @addtogroup iterators\n+   * @{\n+   */\n+\n   // 24.4.3  Move iterators\n   /**\n    *  Class template move_iterator is an iterator adapter with the same\n@@ -884,18 +896,17 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     protected:\n       _Iterator _M_current;\n \n+      typedef iterator_traits<_Iterator>\t\t__traits_type;\n+\n     public:\n-      typedef _Iterator                                        iterator_type;\n-      typedef typename iterator_traits<_Iterator>::difference_type\n-                                                               difference_type;\n+      typedef _Iterator\t\t\t\t\titerator_type;\n+      typedef typename __traits_type::iterator_category iterator_category;\n+      typedef typename __traits_type::value_type  \tvalue_type;\n+      typedef typename __traits_type::difference_type\tdifference_type;\n       // NB: DR 680.\n-      typedef _Iterator                                        pointer;\n-      typedef typename iterator_traits<_Iterator>::value_type  value_type;\n-      typedef typename iterator_traits<_Iterator>::iterator_category\n-                                                               iterator_category;\n-      typedef value_type&&                                     reference;\n+      typedef _Iterator\t\t\t\t\tpointer;\n+      typedef value_type&&\t\t\t\treference;\n \n-    public:\n       move_iterator()\n       : _M_current() { }\n \n@@ -1031,6 +1042,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     make_move_iterator(const _Iterator& __i)\n     { return move_iterator<_Iterator>(__i); }\n \n+  // @} group iterators\n+\n _GLIBCXX_END_NAMESPACE\n \n #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)"}, {"sha": "d2bf647f05881b9c9e8a47d9828ac42170f07011", "filename": "libstdc++-v3/include/bits/stl_iterator_base_types.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -77,15 +77,19 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   //@{ \n   ///  Marking input iterators.\n   struct input_iterator_tag { };\n+\n   ///  Marking output iterators.\n   struct output_iterator_tag { };\n+\n   /// Forward iterators support a superset of input iterator operations.\n   struct forward_iterator_tag : public input_iterator_tag { };\n+\n   /// Bidirectional iterators support a superset of forward iterator\n   /// operations.\n   struct bidirectional_iterator_tag : public forward_iterator_tag { };\n-  /// Random-access iterators support a superset of bidirectional iterator\n-  /// operations.\n+\n+  /// Random-access iterators support a superset of bidirectional\n+  /// iterator operations.\n   struct random_access_iterator_tag : public bidirectional_iterator_tag { };\n \n \n@@ -116,6 +120,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     };\n \n   /**\n+   *  @brief  Traits class for iterators.\n+   *\n    *  This class does nothing but define nested typedefs.  The general\n    *  version simply \"forwards\" the nested typedefs from the Iterator\n    *  argument.  Specialized versions for pointers and pointers-to-const\n@@ -131,6 +137,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       typedef typename _Iterator::reference         reference;\n     };\n \n+  /// Partial specialization for pointer types.\n   template<typename _Tp>\n     struct iterator_traits<_Tp*>\n     {\n@@ -141,6 +148,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       typedef _Tp&                        reference;\n     };\n \n+  /// Partial specialization for const pointer types.\n   template<typename _Tp>\n     struct iterator_traits<const _Tp*>\n     {"}, {"sha": "27b58bf5f81d789be2f6a57addc8a4d787f90e66", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -72,9 +72,9 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *\n    *  This function tries to obtain storage for @c len adjacent Tp\n    *  objects.  The objects themselves are not constructed, of course.\n-   *  A pair<> is returned containing \"the buffer s address and\n+   *  A pair<> is returned containing 'the buffer s address and\n    *  capacity (in the units of sizeof(Tp)), or a pair of 0 values if\n-   *  no storage can be obtained.\"  Note that the capacity obtained\n+   *  no storage can be obtained.'  Note that the capacity obtained\n    *  may be less than that requested if the memory is unavailable;\n    *  you should compare len with the .second return value.\n    *"}, {"sha": "90f1b552b60457c14c9e60faef9ab9184581f870", "filename": "libstdc++-v3/include/bits/stream_iterator.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -36,6 +36,11 @@\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+  /**\n+   * @addtogroup iterators\n+   * @{\n+   */\n+\n   /// Provides input iterator semantics for streams.\n   template<typename _Tp, typename _CharT = char,\n            typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>\n@@ -206,6 +211,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       { return *this; }\n     };\n \n+  // @} group iterators\n+\n _GLIBCXX_END_NAMESPACE\n \n #endif"}, {"sha": "71c323035a2aa5b0be607c345a1207649d3ee0d0", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -39,6 +39,11 @@\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n      \n+  /**\n+   * @addtogroup iterators\n+   * @{\n+   */\n+\n   // 24.5.3 Template class istreambuf_iterator\n   /// Provides input iterator semantics for streambufs.\n   template<typename _CharT, typename _Traits>\n@@ -387,6 +392,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return __first;\n     }\n \n+// @} group iterators\n+\n _GLIBCXX_END_NAMESPACE\n \n #endif"}, {"sha": "231e419efb54ea30d42ef49c04d580ec23d2a849", "filename": "libstdc++-v3/include/c_global/cassert", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcassert", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcassert", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcassert?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file cassert\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c assert.h,"}, {"sha": "bfe45929e3c614745115440e538f0cae3a1348f9", "filename": "libstdc++-v3/include/c_global/cctype", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcctype?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/cctype\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c ctype.h,"}, {"sha": "f02d732079cd3ec041aa88ac6236b34ae6e43cdf", "filename": "libstdc++-v3/include/c_global/cerrno", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcerrno", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcerrno", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcerrno?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file cerrno\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c errno.h,"}, {"sha": "7f551446cb3e621ab0a85d60138b0f22cd9d36f9", "filename": "libstdc++-v3/include/c_global/cfloat", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfloat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfloat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcfloat?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/cfloat\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c float.h,"}, {"sha": "bb7e6294fd8fe41ba9764f687f59062acb0e1ec7", "filename": "libstdc++-v3/include/c_global/ciso646", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fciso646", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fciso646", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fciso646?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -23,7 +23,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file ciso646\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c iso646.h,"}, {"sha": "1bbe6cf27a52495dc114ce619898c5677b8925d9", "filename": "libstdc++-v3/include/c_global/climits", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclimits?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/climits\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c limits.h,"}, {"sha": "52d2b9d21487e9a7beebabef2f91de02fd144906", "filename": "libstdc++-v3/include/c_global/clocale", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclocale", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclocale", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fclocale?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file clocale\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c locale.h,"}, {"sha": "2568d6b3bf66374440f7a4d756e6345fb66cbae6", "filename": "libstdc++-v3/include/c_global/cmath", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/cmath\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c math.h,"}, {"sha": "c643d1b437a05f2fc8dccd46059e48cd207a7c1f", "filename": "libstdc++-v3/include/c_global/csetjmp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcsetjmp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcsetjmp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcsetjmp?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file csetjmp\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c setjmp.h,"}, {"sha": "147b5b618597fef394597d1f38753f9e2e69028c", "filename": "libstdc++-v3/include/c_global/csignal", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcsignal", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcsignal", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcsignal?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file csignal\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c signal.h,"}, {"sha": "c61a866bfe72099cee27c7b9fcfc768f4db9bca8", "filename": "libstdc++-v3/include/c_global/cstdarg", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdarg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdarg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdarg?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/cstdarg\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c stdarg.h,"}, {"sha": "c2aea8f02c23e9bd71bd884835698c4a6e122e72", "filename": "libstdc++-v3/include/c_global/cstdatomic", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdatomic?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -24,7 +24,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file cstdatomic\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c stdatomic.h,"}, {"sha": "6beb52588bcbce2bf69b7c823e587f3868965c18", "filename": "libstdc++-v3/include/c_global/cstddef", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstddef", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstddef", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstddef?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file cstddef\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c stddef.h,"}, {"sha": "b17f5ccf86453e9fae443e83fd179db6699e78e0", "filename": "libstdc++-v3/include/c_global/cstdio", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdio?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/cstdio\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c stdio.h,"}, {"sha": "0e0d7d5c18ca7b03bddf63660c8f9ebf16b25ffb", "filename": "libstdc++-v3/include/c_global/cstdlib", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdlib?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/cstdlib\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c stdlib.h,"}, {"sha": "acd6166b15f3d0ec42d1ae935e0aea5598625694", "filename": "libstdc++-v3/include/c_global/cstring", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstring", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstring", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstring?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file cstring\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c string.h,"}, {"sha": "8430dc84234a65745513ec691a79e22ce7f70636", "filename": "libstdc++-v3/include/c_global/ctime", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctime", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctime", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fctime?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/ctime\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c time.h,"}, {"sha": "f2f36cfc75c20a4374c093e66fc870d61535bab4", "filename": "libstdc++-v3/include/c_global/cwchar", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwchar?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/cwchar\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c wchar.h,"}, {"sha": "ffc75c82ba5a9b7e1654a58ba1595a5ef7a16037", "filename": "libstdc++-v3/include/c_global/cwctype", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcwctype?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -25,7 +25,7 @@\n // <http://www.gnu.org/licenses/>.\n \n /** @file include/cwctype\n- *  This is a Standard C++ Library file.  You should @c #include this file\n+ *  This is a Standard C++ Library file.  You should @c \\#include this file\n  *  in your programs, rather than any of the \"*.h\" implementation files.\n  *\n  *  This is the C++ version of the Standard C Library header @c wctype.h,"}, {"sha": "f3ac555908fdeb8676e81baa75e44c7647779764", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -94,7 +94,7 @@ namespace __gnu_parallel\n     *  @param __comp Comparator.\n     *  @param __num_threads Number of threads that are allowed to work on\n     *  this part.\n-    *  @pre @__c (__end-__begin)>=1 */\n+    *  @pre @c (__end-__begin)>=1 */\n   template<typename _RAIter, typename _Compare>\n     typename std::iterator_traits<_RAIter>::difference_type\n     __qsb_divide(_RAIter __begin, _RAIter __end,"}, {"sha": "87d5752441aa915873cddfa6d80dd2a4283c8840", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -93,7 +93,7 @@ namespace __gnu_parallel\n   __is_parallel(const _Parallelism __p) { return __p != sequential; }\n \n \n-  /** @brief Calculates the rounded-down logarithm of @__c __n for base 2.\n+  /** @brief Calculates the rounded-down logarithm of @c __n for base 2.\n    *  @param __n Argument.\n    *  @return Returns 0 for any argument <1.\n    */\n@@ -108,11 +108,11 @@ namespace __gnu_parallel\n     }\n \n   /** @brief Encode two integers into one gnu_parallel::_CASable.\n-   *  @param __a First integer, to be encoded in the most-significant @__c\n+   *  @param __a First integer, to be encoded in the most-significant @c\n    *  _CASable_bits/2 bits.\n    *  @param __b Second integer, to be encoded in the least-significant\n-   *  @__c _CASable_bits/2 bits.\n-   *  @return value encoding @__c __a and @__c __b.\n+   *  @c _CASable_bits/2 bits.\n+   *  @return value encoding @c __a and @c __b.\n    *  @see decode2\n    */\n   inline _CASable\n@@ -124,9 +124,9 @@ namespace __gnu_parallel\n   /** @brief Decode two integers from one gnu_parallel::_CASable.\n    *  @param __x __gnu_parallel::_CASable to decode integers from.\n    *  @param __a First integer, to be decoded from the most-significant\n-   *  @__c _CASable_bits/2 bits of @__c __x.\n+   *  @c _CASable_bits/2 bits of @c __x.\n    *  @param __b Second integer, to be encoded in the least-significant\n-   *  @__c _CASable_bits/2 bits of @__c __x.\n+   *  @c _CASable_bits/2 bits of @c __x.\n    *  @see __encode2\n    */\n   inline void\n@@ -422,7 +422,7 @@ namespace __gnu_parallel\n     };\n \n   /** @brief Compute the median of three referenced elements,\n-      according to @__c __comp.\n+      according to @c __comp.\n       *  @param __a First iterator.\n       *  @param __b Second iterator.\n       *  @param __c Third iterator."}, {"sha": "2a977acedf4fb412a964c182298db75adfb1510a", "filename": "libstdc++-v3/include/parallel/checkers.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcheckers.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -39,12 +39,12 @@\n namespace __gnu_parallel\n {\n   /**\n-   * @brief Check whether @__c [__begin, @__c __end) is sorted according\n-   * to @__c __comp.\n+   * @brief Check whether @c [__begin, @c __end) is sorted according\n+   * to @c __comp.\n    * @param __begin Begin iterator of sequence.\n    * @param __end End iterator of sequence.\n    * @param __comp Comparator.\n-   * @return @__c true if sorted, @__c false otherwise.\n+   * @return @c true if sorted, @c false otherwise.\n    */\n   template<typename _IIter, typename _Compare>\n     bool"}, {"sha": "688a7cf348f5142226ffa8484ec8b6c4a1f85732", "filename": "libstdc++-v3/include/parallel/compatibility.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -227,8 +227,8 @@ namespace __gnu_parallel\n \n #endif\n \n-  /** @brief Compare @__c *__ptr and @__c __comparand. If equal, let @__c\n-   * *__ptr=__replacement and return @__c true, return @__c false otherwise.\n+  /** @brief Compare @c *__ptr and @c __comparand. If equal, let @c\n+   * *__ptr=__replacement and return @c true, return @c false otherwise.\n    *\n    *  Implementation is heavily platform-dependent.\n    *  @param __ptr Pointer to 32-bit signed integer.\n@@ -270,8 +270,8 @@ namespace __gnu_parallel\n #endif\n   }\n \n-  /** @brief Compare @__c *__ptr and @__c __comparand. If equal, let @__c\n-   * *__ptr=__replacement and return @__c true, return @__c false otherwise.\n+  /** @brief Compare @c *__ptr and @c __comparand. If equal, let @c\n+   * *__ptr=__replacement and return @c true, return @c false otherwise.\n    *\n    *  Implementation is heavily platform-dependent.\n    *  @param __ptr Pointer to 64-bit signed integer.\n@@ -323,8 +323,8 @@ namespace __gnu_parallel\n #endif\n   }\n \n-  /** @brief Compare @__c *__ptr and @__c __comparand. If equal, let @__c\n-   * *__ptr=__replacement and return @__c true, return @__c false otherwise.\n+  /** @brief Compare @c *__ptr and @c __comparand. If equal, let @c\n+   * *__ptr=__replacement and return @c true, return @c false otherwise.\n    *\n    *  Implementation is heavily platform-dependent.\n    *  @param __ptr Pointer to signed integer."}, {"sha": "481c9886840b3da3b9af33ac3ec9e2b4f077b8f4", "filename": "libstdc++-v3/include/parallel/equally_split.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -42,7 +42,7 @@ namespace __gnu_parallel\n    *  @param __n Number of elements\n    *  @param __num_threads Number of parts\n    *  @param __s Splitters\n-   *  @returns End of __splitter sequence, i.e. @__c __s+__num_threads+1 */\n+   *  @returns End of __splitter sequence, i.e. @c __s+__num_threads+1 */\n   template<typename _DifferenceType, typename _OutputIterator>\n     _OutputIterator\n     equally_split(_DifferenceType __n, _ThreadIndex __num_threads,"}, {"sha": "e6e573ddbbf939d0625275fbe67782190994da40", "filename": "libstdc++-v3/include/parallel/for_each.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -42,7 +42,7 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Chose the desired algorithm by evaluating @__c __parallelism_tag.\n+  /** @brief Chose the desired algorithm by evaluating @c __parallelism_tag.\n    *  @param __begin Begin iterator of input sequence.\n    *  @param __end End iterator of input sequence.\n    *  @param __user_op A user-specified functor (comparator, predicate,"}, {"sha": "1f1bfa22e443d018b59ea2a54eef1d81ff2aa06f", "filename": "libstdc++-v3/include/parallel/list_partition.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -42,7 +42,7 @@ namespace __gnu_parallel\n    *  @param __os_starts Start positions worked on (oversampled).\n    *  @param __count_to_two Counts up to 2.\n    *  @param __range_length Current length of a chunk.\n-   *  @param __make_twice Whether the @__c __os_starts is allowed to be\n+   *  @param __make_twice Whether the @c __os_starts is allowed to be\n    *  grown or not\n    */\n   template<typename _IIter>\n@@ -83,16 +83,17 @@ namespace __gnu_parallel\n    *  @param __begin Begin iterator of input sequence.\n    *  @param __end End iterator of input sequence.\n    *  @param __starts Start iterators for the resulting parts, dimension\n-   *  @__c __num_parts+1. For convenience, @__c __starts @__c [__num_parts]\n+   *  @c __num_parts+1. For convenience, @c __starts @c [__num_parts]\n    *  contains the end iterator of the sequence.\n    *  @param __lengths Length of the resulting parts.\n    *  @param __num_parts Number of parts to split the sequence into.\n    *  @param __f Functor to be applied to each element by traversing __it\n    *  @param __oversampling Oversampling factor. If 0, then the\n-   *  partitions will differ in at most @__f$ \\sqrt{\\mathrm{__end} -\n-   *  \\mathrm{__begin}} @__f$ __elements. Otherwise, the ratio between the\n-   *  longest and the shortest part is bounded by @__f$\n-   *  1/(\\mathrm{__oversampling} \\cdot \\mathrm{num\\_parts}) @__f$.\n+   *  partitions will differ in at most \n+   *  \\sqrt{\\mathrm{__end} - \\mathrm{__begin}} \n+   *  __elements. Otherwise, the ratio between the\n+   *  longest and the shortest part is bounded by\n+   *  1/(\\mathrm{__oversampling} \\cdot \\mathrm{num\\_parts})\n    *  @return Length of the whole sequence.\n    */\n   template<typename _IIter, typename _FunctorType>"}, {"sha": "a19e996a0555351913c08284d39a96be2565a84d", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -37,11 +37,11 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Merge routine being able to merge only the @__c __max_length\n+  /** @brief Merge routine being able to merge only the @c __max_length\n    * smallest elements.\n    *\n-   * The @__c __begin iterators are advanced accordingly, they might not\n-   * reach @__c __end, in contrast to the usual variant.\n+   * The @c __begin iterators are advanced accordingly, they might not\n+   * reach @c __end, in contrast to the usual variant.\n    * @param __begin1 Begin iterator of first sequence.\n    * @param __end1 End iterator of first sequence.\n    * @param __begin2 Begin iterator of second sequence.\n@@ -83,11 +83,11 @@ namespace __gnu_parallel\n       return __target;\n     }\n \n-  /** @brief Merge routine being able to merge only the @__c __max_length\n+  /** @brief Merge routine being able to merge only the @c __max_length\n    * smallest elements.\n    *\n-   * The @__c __begin iterators are advanced accordingly, they might not\n-   * reach @__c __end, in contrast to the usual variant.\n+   * The @c __begin iterators are advanced accordingly, they might not\n+   * reach @c __end, in contrast to the usual variant.\n    * Specially designed code should allow the compiler to generate\n    * conditional moves instead of branches.\n    * @param __begin1 Begin iterator of first sequence.\n@@ -150,11 +150,11 @@ namespace __gnu_parallel\n       return __target;\n     }\n \n-  /** @brief Merge routine being able to merge only the @__c __max_length\n+  /** @brief Merge routine being able to merge only the @c __max_length\n    * smallest elements.\n    *\n-   *  The @__c __begin iterators are advanced accordingly, they might not\n-   *  reach @__c __end, in contrast to the usual variant.\n+   *  The @c __begin iterators are advanced accordingly, they might not\n+   *  reach @c __end, in contrast to the usual variant.\n    *  Static switch on whether to use the conditional-move variant.\n    *  @param __begin1 Begin iterator of first sequence.\n    *  @param __end1 End iterator of first sequence.\n@@ -202,11 +202,11 @@ namespace __gnu_parallel\n     { return __merge_advance(__begin1, __end1, __begin2, __end2, __target,\n \t\t\t     __max_length, __comp); }\n \n-  /** @brief Parallel merge routine being able to merge only the @__c\n+  /** @brief Parallel merge routine being able to merge only the @c\n    * __max_length smallest elements.\n    *\n-   *  The @__c __begin iterators are advanced accordingly, they might not\n-   *  reach @__c __end, in contrast to the usual variant.\n+   *  The @c __begin iterators are advanced accordingly, they might not\n+   *  reach @c __end, in contrast to the usual variant.\n    *  The functionality is projected onto parallel_multiway_merge.\n    *  @param __begin1 Begin iterator of first sequence.\n    *  @param __end1 End iterator of first sequence."}, {"sha": "cdf21540d12f93f42d46bd5d144613dce0d8bb62", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -108,7 +108,7 @@ namespace __gnu_parallel\n       /** @brief Compare two elements referenced by guarded iterators.\n        *  @param __bi1 First iterator.\n        *  @param __bi2 Second iterator.\n-       *  @return @__c true if less. */\n+       *  @return @c true if less. */\n       friend bool\n       operator<(_GuardedIterator<_RAIter, _Compare>& __bi1,\n \t\t_GuardedIterator<_RAIter, _Compare>& __bi2)\n@@ -123,7 +123,7 @@ namespace __gnu_parallel\n       /** @brief Compare two elements referenced by guarded iterators.\n        *  @param __bi1 First iterator.\n        *  @param __bi2 Second iterator.\n-       *  @return @__c True if less equal. */\n+       *  @return @c True if less equal. */\n       friend bool\n       operator<=(_GuardedIterator<_RAIter, _Compare>& __bi1,\n \t\t _GuardedIterator<_RAIter, _Compare>& __bi2)\n@@ -178,7 +178,7 @@ namespace __gnu_parallel\n       /** @brief Compare two elements referenced by unguarded iterators.\n        *  @param __bi1 First iterator.\n        *  @param __bi2 Second iterator.\n-       *  @return @__c true if less. */\n+       *  @return @c true if less. */\n       friend bool\n       operator<(_UnguardedIterator<_RAIter, _Compare>& __bi1,\n \t\t_UnguardedIterator<_RAIter, _Compare>& __bi2)\n@@ -190,7 +190,7 @@ namespace __gnu_parallel\n       /** @brief Compare two elements referenced by unguarded iterators.\n        *  @param __bi1 First iterator.\n        *  @param __bi2 Second iterator.\n-       *  @return @__c True if less equal. */\n+       *  @return @c True if less equal. */\n       friend bool\n       operator<=(_UnguardedIterator<_RAIter, _Compare>& __bi1,\n \t\t _UnguardedIterator<_RAIter, _Compare>& __bi2)\n@@ -1724,7 +1724,7 @@ namespace __gnu_parallel\n    * @pre All input sequences must be sorted.\n    * @pre Target must provide enough space to merge out length elements or\n    *    the number of elements in all sequences, whichever is smaller.\n-   * @pre For each @__c __i, @__c __seqs_begin[__i].second must be the end\n+   * @pre For each @c __i, @c __seqs_begin[__i].second must be the end\n    *    marker of the sequence, but also reference the one more __sentinel\n    *    element.\n    *"}, {"sha": "f2bb6fbc30dfe640597fed26906457ebd0987da1", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -82,14 +82,14 @@ namespace __gnu_parallel\n       /** @brief Offsets to add to the found positions. */\n       _DifferenceType* _M_offsets;\n \n-      /** @brief Pieces of data to merge @__c [thread][__sequence] */\n+      /** @brief Pieces of data to merge @c [thread][__sequence] */\n       std::vector<_Piece<_DifferenceType> >* _M_pieces;\n   };\n \n   /**\n    *  @brief Select _M_samples from a sequence.\n    *  @param __sd Pointer to algorithm data. _Result will be placed in\n-   *  @__c __sd->_M_samples.\n+   *  @c __sd->_M_samples.\n    *  @param __num_samples Number of _M_samples to select.\n    */\n   template<typename _RAIter, typename _DifferenceTp>"}, {"sha": "28c78600860abfa5c91c4c83d3f95aeedb221c6f", "filename": "libstdc++-v3/include/parallel/queue.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -45,7 +45,7 @@ namespace __gnu_parallel\n    *  atomic access.  push_front() and pop_front() must not be called\n    *  concurrently to each other, while pop_back() can be called\n    *  concurrently at all times.\n-   *  @__c empty(), @__c size(), and @__c top() are intentionally not provided.\n+   *  @c empty(), @c size(), and @c top() are intentionally not provided.\n    *  Calling them would not make sense in a concurrent setting.\n    *  @param _Tp Contained element type. */\n   template<typename _Tp>"}, {"sha": "c39f15e129812e0212659d63c5a464e26e2a8429", "filename": "libstdc++-v3/include/parallel/random_number.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -81,7 +81,7 @@ namespace __gnu_parallel\n     /** @brief Constructor.\n      *  @param __seed Random __seed.\n      *  @param _M_supremum Generate integer random numbers in the\n-     *                  interval @__c [0,_M_supremum). */\n+     *                  interval @c [0,_M_supremum). */\n     _RandomNumber(uint32_t __seed, uint64_t _M_supremum = 0x100000000ULL)\n     : _M_mt(__seed), _M_supremum(_M_supremum),\n       _M_rand_sup(1ULL << std::numeric_limits<uint32_t>::digits),\n@@ -95,7 +95,7 @@ namespace __gnu_parallel\n     { return __scale_down(_M_mt(), _M_supremum, _M_supremum_reciprocal); }\n \n     /** @brief Generate unsigned random 32-bit integer in the\n-        interval @__c [0,local_supremum). */\n+        interval @c [0,local_supremum). */\n     uint32_t\n     operator()(uint64_t local_supremum)\n     {"}, {"sha": "3082ea8dbc0306e0266f9a05af8718f24a8782a6", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -106,7 +106,7 @@ namespace __gnu_parallel\n       _DRandomShufflingGlobalData<_RAIter>* _M_sd;\n     };\n \n-  /** @brief Generate a random number in @__c [0,2^__logp).\n+  /** @brief Generate a random number in @c [0,2^__logp).\n     *  @param __logp Logarithm (basis 2) of the upper range __bound.\n     *  @param __rng Random number generator to use.\n     */"}, {"sha": "9e0db3a9584a0d02037ae7d1abbcdd2ed709cec9", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -66,7 +66,7 @@ namespace __gnu_parallel\n        *  Changed by owning thread only. */\n       _GLIBCXX_JOB_VOLATILE _DifferenceType _M_last;\n \n-      /** @brief Number of elements, i.e. @__c _M_last-_M_first+1.\n+      /** @brief Number of elements, i.e. @c _M_last-_M_first+1.\n        *\n        *  Changed by owning thread only. */\n       _GLIBCXX_JOB_VOLATILE _DifferenceType _M_load;"}, {"sha": "bfbafc14f90517ccc2220f4a38c5893b57367c5e", "filename": "libstdc++-v3/include/profile/impl/profiler_hashtable_size.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -28,7 +28,7 @@\n // reasons why the executable file might be covered by the GNU General\n // Public License.\n \n-/** @file profile/impl/profiler_hashtable_size.cc\n+/** @file profile/impl/profiler_hashtable_size.h\n  *  @brief Collection of hashtable size traces.\n  */\n "}, {"sha": "03065715463873c6e52a382af4a4937f5ee32fbf", "filename": "libstdc++-v3/include/profile/impl/profiler_state.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -28,7 +28,7 @@\n // reasons why the executable file might be covered by the GNU General\n // Public License.\n \n-/** @file profile/impl/profiler_state.cc\n+/** @file profile/impl/profiler_state.h\n  *  @brief Global profiler state.\n  */\n "}, {"sha": "b3405d7f1d5fdaeb5531b8e8c0025681ab9f3e61", "filename": "libstdc++-v3/include/std/iosfwd", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiosfwd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiosfwd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiosfwd?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -43,6 +43,36 @@\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+  /** \n+   *  @defgroup io I/O\n+   *\n+   *  Nearly all of the I/O classes are parameterized on the type of\n+   *  characters they read and write.  (The major exception is ios_base at\n+   *  the top of the hierarchy.)  This is a change from pre-Standard\n+   *  streams, which were not templates.\n+   *\n+   *  For ease of use and compatibility, all of the basic_* I/O-related\n+   *  classes are given typedef names for both of the builtin character\n+   *  widths (wide and narrow).  The typedefs are the same as the\n+   *  pre-Standard names, for example:\n+   *\n+   *  @code\n+   *     typedef basic_ifstream<char>  ifstream;\n+   *  @endcode\n+   *\n+   *  Because properly forward-declaring these classes can be difficult, you\n+   *  should not do it yourself.  Instead, include the &lt;iosfwd&gt;\n+   *  header, which contains only declarations of all the I/O classes as\n+   *  well as the typedefs.  Trying to forward-declare the typedefs\n+   *  themselves (e.g., \"class ostream;\") is not valid ISO C++.\n+   *\n+   *  For more specific declarations, see\n+   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch24.html\n+   *\n+   *  @{\n+  */\n+  class ios_base; \n+\n   template<typename _CharT, typename _Traits = char_traits<_CharT> >\n     class basic_ios;\n \n@@ -94,36 +124,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // Not included.   (??? Apparently no LWG number?)\n-  class ios_base; \n \n-  /** \n-   *  @defgroup io I/O\n-   *\n-   *  Nearly all of the I/O classes are parameterized on the type of\n-   *  characters they read and write.  (The major exception is ios_base at\n-   *  the top of the hierarchy.)  This is a change from pre-Standard\n-   *  streams, which were not templates.\n-   *\n-   *  For ease of use and compatibility, all of the basic_* I/O-related\n-   *  classes are given typedef names for both of the builtin character\n-   *  widths (wide and narrow).  The typedefs are the same as the\n-   *  pre-Standard names, for example:\n-   *\n-   *  @code\n-   *     typedef basic_ifstream<char>  ifstream;\n-   *  @endcode\n-   *\n-   *  Because properly forward-declaring these classes can be difficult, you\n-   *  should not do it yourself.  Instead, include the &lt;iosfwd&gt;\n-   *  header, which contains only declarations of all the I/O classes as\n-   *  well as the typedefs.  Trying to forward-declare the typedefs\n-   *  themselves (e.g., \"class ostream;\") is not valid ISO C++.\n-   *\n-   *  For more specific declarations, see\n-   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch24.html\n-   *\n-   *  @{\n-  */\n   typedef basic_ios<char> \t\tios;\t\t///< @isiosfwd\n   typedef basic_streambuf<char> \tstreambuf;\t///< @isiosfwd\n   typedef basic_istream<char> \t\tistream;\t///< @isiosfwd"}, {"sha": "1f3f078d0f04b471cdff8fda62ecc78eab3c37d7", "filename": "libstdc++-v3/include/std/limits", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -203,9 +203,9 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n      *  Is this supposed to be \"if the type is integral\"?\n     */\n     static const bool is_integer = false;\n-    /** True if the type uses an exact representation.  \"All integer types are\n+    /** True if the type uses an exact representation.  'All integer types are\n         exact, but not all exact types are integer.  For example, rational and\n-        fixed-exponent representations are exact but not integer.\"\n+        fixed-exponent representations are exact but not integer.'\n         [18.2.1.2]/15  */\n     static const bool is_exact = false;\n     /** For integer types, specifies the base of the representation.  For\n@@ -229,23 +229,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     /** True if the type has a representation for positive infinity.  */\n     static const bool has_infinity = false;\n     /** True if the type has a representation for a quiet (non-signaling)\n-        \"Not a Number.\"  */\n+        'Not a Number.'  */\n     static const bool has_quiet_NaN = false;\n     /** True if the type has a representation for a signaling\n-        \"Not a Number.\"  */\n+        'Not a Number.'  */\n     static const bool has_signaling_NaN = false;\n     /** See std::float_denorm_style for more information.  */\n     static const float_denorm_style has_denorm = denorm_absent;\n-    /** \"True if loss of accuracy is detected as a denormalization loss,\n-        rather than as an inexact result.\" [18.2.1.2]/42  */\n+    /** 'True if loss of accuracy is detected as a denormalization loss,\n+        rather than as an inexact result.' [18.2.1.2]/42  */\n     static const bool has_denorm_loss = false;\n \n     /** True if-and-only-if the type adheres to the IEC 559 standard, also\n         known as IEEE 754.  (Only makes sense for floating point types.)  */\n     static const bool is_iec559 = false;\n-    /** \"True if the set of values representable by the type is finite.   All\n+    /** 'True if the set of values representable by the type is finite.   All\n         built-in types are bounded, this member would be false for arbitrary\n-\tprecision types.\" [18.2.1.2]/54  */\n+\tprecision types.' [18.2.1.2]/54  */\n     static const bool is_bounded = false;\n     /** True if the type is @e modulo, that is, if it is possible to add two\n         positive numbers and have a result that wraps around to a third number"}, {"sha": "3e7d4e8466b9b1ca3db1a51067f18e4f8d55c640", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -46,6 +46,20 @@\n \n #pragma GCC system_header\n \n+/**\n+ * @defgroup memory Memory\n+ * @ingroup utilities\n+ *\n+ * Components for memory allocation, deallocation, and management.\n+ */\n+\n+/**\n+ * @defgroup pointer_abstractions Pointer Abstractions\n+ * @ingroup memory\n+ *\n+ * Smart pointers, etc.\n+ */\n+\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n #include <bits/stl_construct.h>\n@@ -64,37 +78,29 @@\n #  include <ext/concurrence.h>\n #  include <bits/functexcept.h>\n #  include <bits/stl_function.h>  // std::less\n-#  include <bits/unique_ptr.h>\n-#  include <debug/debug.h>\n #  include <type_traits>\n #  include <functional>\n+#  include <debug/debug.h>\n+#  include <bits/unique_ptr.h>\n #  if _GLIBCXX_DEPRECATED\n #    include <backward/auto_ptr.h>\n #  endif\n #  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n #    include <tr1_impl/boost_sp_counted_base.h>\n-#    include <bits/shared_ptr.h>\n #  else\n #    define _GLIBCXX_INCLUDE_AS_CXX0X\n #    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n #    define _GLIBCXX_END_NAMESPACE_TR1\n #    define _GLIBCXX_TR1\n #    include <tr1_impl/boost_sp_counted_base.h>\n-#    include <bits/shared_ptr.h>\n #    undef _GLIBCXX_TR1\n #    undef _GLIBCXX_END_NAMESPACE_TR1\n #    undef _GLIBCXX_BEGIN_NAMESPACE_TR1\n #    undef _GLIBCXX_INCLUDE_AS_CXX0X\n #  endif\n+#  include <bits/shared_ptr.h>\n #else\n #  include <backward/auto_ptr.h>\n #endif\n \n-/**\n- * @defgroup memory Memory\n- * @ingroup utilities\n- *\n- * Components for memory allocation, deallocation, and management.\n- */\n-\n #endif /* _GLIBCXX_MEMORY */"}, {"sha": "0ebf506d0c7f247af0322d2892b1b9b76a9443cd", "filename": "libstdc++-v3/include/std/sstream", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -112,9 +112,9 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        *  @brief  Copying out the string buffer.\n        *  @return  A copy of one of the underlying sequences.\n        *\n-       *  \"If the buffer is only created in input mode, the underlying\n+       *  'If the buffer is only created in input mode, the underlying\n        *  character sequence is equal to the input sequence; otherwise, it\n-       *  is equal to the output sequence.\" [27.7.1.2]/1\n+       *  is equal to the output sequence.' [27.7.1.2]/1\n       */\n       __string_type\n       str() const"}, {"sha": "7d6b8c789cbf73c422290ac76a15d0e7ae8c0c30", "filename": "libstdc++-v3/include/std/streambuf", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstreambuf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstreambuf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstreambuf?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -341,7 +341,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        *  @return  The previous character, if possible.\n        *\n        *  Similar to sungetc(), but @a c is pushed onto the stream instead\n-       *  of \"the previous character\".  If successful, the next character\n+       *  of 'the previous character.'  If successful, the next character\n        *  fetched from the input stream will be @a c.\n       */\n       int_type \n@@ -366,8 +366,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        *\n        *  If a putback position is available, this function decrements the\n        *  input pointer and returns that character.  Otherwise, calls and\n-       *  returns pbackfail().  The effect is to \"unget\" the last character\n-       *  \"gotten\".\n+       *  returns pbackfail().  The effect is to 'unget' the last character\n+       *  'gotten.'\n       */\n       int_type \n       sungetc()\n@@ -541,10 +541,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        *  @param  loc  A new locale.\n        *\n        *  Translations done during I/O which depend on the current locale\n-       *  are changed by this call.  The standard adds, \"Between invocations\n+       *  are changed by this call.  The standard adds, 'Between invocations\n        *  of this function a class derived from streambuf can safely cache\n        *  results of calls to locale functions and to members of facets\n-       *  so obtained.\"\n+       *  so obtained.'\n        *\n        *  @note  Base class version does nothing.\n       */\n@@ -608,18 +608,18 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        *  @return  An estimate of the number of characters available in the\n        *           input sequence, or -1.\n        *\n-       *  \"If it returns a positive value, then successive calls to\n+       *  'If it returns a positive value, then successive calls to\n        *  @c underflow() will not return @c traits::eof() until at least that\n        *  number of characters have been supplied.  If @c showmanyc()\n-       *  returns -1, then calls to @c underflow() or @c uflow() will fail.\"\n+       *  returns -1, then calls to @c underflow() or @c uflow() will fail.'\n        *  [27.5.2.4.3]/1\n        *\n        *  @note  Base class version does nothing, returns zero.\n-       *  @note  The standard adds that \"the intention is not only that the\n+       *  @note  The standard adds that 'the intention is not only that the\n        *         calls [to underflow or uflow] will not return @c eof() but\n-       *         that they will return \"immediately\".\n-       *  @note  The standard adds that \"the morphemes of @c showmanyc are\n-       *         \"es-how-many-see\", not \"show-manic\".\n+       *         that they will return immediately.'\n+       *  @note  The standard adds that 'the morphemes of @c showmanyc are\n+       *         'es-how-many-see', not 'show-manic'.'\n       */\n       virtual streamsize \n       showmanyc() { return 0; }\n@@ -646,7 +646,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        *\n        *  Informally, this function is called when the input buffer is\n        *  exhausted (or does not exist, as buffering need not actually be\n-       *  done).  If a buffer exists, it is \"refilled\".  In either case, the\n+       *  done).  If a buffer exists, it is 'refilled'.  In either case, the\n        *  next available character is returned, or @c traits::eof() to\n        *  indicate a null pending sequence.\n        *\n@@ -690,7 +690,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       /**\n        *  @brief  Tries to back up the input sequence.\n        *  @param  c  The character to be inserted back into the sequence.\n-       *  @return  eof() on failure, \"some other value\" on success\n+       *  @return  eof() on failure, 'some other value' on success\n        *  @post  The constraints of @c gptr(), @c eback(), and @c pptr()\n        *         are the same as for @c underflow().\n        *\n@@ -726,7 +726,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        *\n        *  Informally, this function is called when the output buffer is full\n        *  (or does not exist, as buffering need not actually be done).  If a\n-       *  buffer exists, it is \"consumed\", with \"some effect\" on the\n+       *  buffer exists, it is 'consumed', with 'some effect' on the\n        *  controlled sequence.  (Typically, the buffer is written out to the\n        *  sequence verbatim.)  In either case, the character @a c is also\n        *  written out, if @a c is not @c eof()."}, {"sha": "788edf66cff6e7f4ac731a770756abfcbd7ec857", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -57,7 +57,8 @@\n \n namespace std\n {\n-  /** @addtogroup metaprogramming\n+  /**\n+   * @addtogroup metaprogramming\n    * @{\n    */\n \n@@ -154,7 +155,7 @@ namespace std\n \n   template<typename _Tp>\n     struct __is_signed_helper<_Tp, true, false>\n-    : public integral_constant<bool, _Tp(-1) < _Tp(0)>\n+    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>\n     { };\n \n   /// is_signed"}, {"sha": "c3826eaca6b1d108bbb90bc580b7e2892a10bde8", "filename": "libstdc++-v3/include/std/utility", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -58,6 +58,14 @@\n \n #pragma GCC system_header\n \n+/**\n+ * @defgroup utilities Utilities\n+ *\n+ * Components deemed generally useful. Includes pair, tuple,\n+ * forward/move helpers, ratio, function object, metaprogramming and\n+ * type traits, time, date, and memory functions.\n+ */\n+\n #include <bits/c++config.h>\n #include <bits/stl_relops.h>\n #include <bits/stl_pair.h>\n@@ -83,12 +91,4 @@\n #  include <initializer_list>\n #endif\n \n-/**\n- * @defgroup utilities Utilities\n- *\n- * Components deemed generally useful. Includes pair, tuple,\n- * forward/move helpers, ratio, function object, metaprogramming and\n- * type traits, time, date, and memory functions.\n- */\n-\n #endif /* _GLIBCXX_UTILITY */"}, {"sha": "ba2cacae4ed79a320be41a319fe73dbf7ebb1fad", "filename": "libstdc++-v3/include/tr1/shared_ptr.h", "status": "modified", "additions": 17, "deletions": 65, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -57,16 +57,12 @@ namespace std\n {\n namespace tr1\n {\n-\n   template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n     class _Sp_counted_base_impl\n     : public _Sp_counted_base<_Lp>\n     {\n     public:\n-      /**\n-       *  @brief   \n-       *  @pre     __d(__p) must not throw.\n-       */\n+      // Precondition: __d(__p) must not throw.\n       _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n       : _M_ptr(__p), _M_del(__d) { }\n     \n@@ -346,31 +342,19 @@ namespace tr1\n   struct __const_cast_tag { };\n   struct __dynamic_cast_tag { };\n \n-  /**\n-   *  @class __shared_ptr \n-   *\n-   *  A smart pointer with reference-counted copy semantics.\n-   *  The object pointed to is deleted when the last shared_ptr pointing to\n-   *  it is destroyed or reset.\n-   */\n+  // A smart pointer with reference-counted copy semantics.  The\n+  // object pointed to is deleted when the last shared_ptr pointing to\n+  // it is destroyed or reset.\n   template<typename _Tp, _Lock_policy _Lp>\n     class __shared_ptr\n     {\n     public:\n       typedef _Tp   element_type;\n       \n-      /** @brief  Construct an empty %__shared_ptr.\n-       *  @post   use_count()==0 && get()==0\n-       */\n       __shared_ptr()\n       : _M_ptr(0), _M_refcount() // never throws\n       { }\n \n-      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p.\n-       *  @param  __p  A pointer that is convertible to element_type*.\n-       *  @post   use_count() == 1 && get() == __p\n-       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n-       */\n       template<typename _Tp1>\n         explicit\n         __shared_ptr(_Tp1* __p)\n@@ -381,19 +365,6 @@ namespace tr1\n \t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n \t}\n \n-      //\n-      // Requirements: _Deleter's copy constructor and destructor must\n-      // not throw\n-      //\n-      // __shared_ptr will release __p by calling __d(__p)\n-      //\n-      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p\n-       *          and the deleter @a __d.\n-       *  @param  __p  A pointer.\n-       *  @param  __d  A deleter.\n-       *  @post   use_count() == 1 && get() == __p\n-       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n-       */\n       template<typename _Tp1, typename _Deleter>\n         __shared_ptr(_Tp1* __p, _Deleter __d)\n         : _M_ptr(__p), _M_refcount(__p, __d)\n@@ -405,24 +376,11 @@ namespace tr1\n       \n       //  generated copy constructor, assignment, destructor are fine.\n       \n-      /** @brief  If @a __r is empty, constructs an empty %__shared_ptr;\n-       *          otherwise construct a %__shared_ptr that shares ownership\n-       *          with @a __r.\n-       *  @param  __r  A %__shared_ptr.\n-       *  @post   get() == __r.get() && use_count() == __r.use_count()\n-       */\n       template<typename _Tp1>\n         __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n \t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n         { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n \n-      /** @brief  Constructs a %__shared_ptr that shares ownership with @a __r\n-       *          and stores a copy of the pointer stored in @a __r.\n-       *  @param  __r  A weak_ptr.\n-       *  @post   use_count() == __r.use_count()\n-       *  @throw  bad_weak_ptr when __r.expired(),\n-       *          in which case the constructor has no effect.\n-       */\n       template<typename _Tp1>\n         explicit\n         __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n@@ -435,9 +393,7 @@ namespace tr1\n \t}\n \n #if !defined(__GXX_EXPERIMENTAL_CXX0X__) || _GLIBCXX_DEPRECATED\n-      /**\n-       * @post use_count() == 1 and __r.get() == 0\n-       */\n+      // Postcondition: use_count() == 1 and __r.get() == 0\n       template<typename _Tp1>\n         explicit\n         __shared_ptr(std::auto_ptr<_Tp1>& __r)\n@@ -595,30 +551,30 @@ namespace tr1\n     { __a.swap(__b); }\n \n   // 2.2.3.9 shared_ptr casts\n-  /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))</code>\n-   *           will eventually result in undefined behaviour,\n-   *           attempting to delete the same object twice.\n+  /*  The seemingly equivalent\n+   *           shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))\n+   *  will eventually result in undefined behaviour,\n+   *  attempting to delete the same object twice.\n    */\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n     inline __shared_ptr<_Tp, _Lp>\n     static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n     { return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag()); }\n \n-  /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))</code>\n-   *           will eventually result in undefined behaviour,\n-   *           attempting to delete the same object twice.\n+  /*  The seemingly equivalent\n+   *           shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))\n+   *  will eventually result in undefined behaviour,\n+   *  attempting to delete the same object twice.\n    */\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n     inline __shared_ptr<_Tp, _Lp>\n     const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n     { return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag()); }\n \n-  /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))</code>\n-   *           will eventually result in undefined behaviour,\n-   *           attempting to delete the same object twice.\n+  /*  The seemingly equivalent\n+   *           shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))\n+   *  will eventually result in undefined behaviour,\n+   *  attempting to delete the same object twice.\n    */\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n     inline __shared_ptr<_Tp, _Lp>\n@@ -825,7 +781,6 @@ namespace tr1\n     };\n \n \n-  /// shared_ptr\n   // The actual shared_ptr, with forwarding constructors and\n   // assignment operators.\n   template<typename _Tp>\n@@ -914,7 +869,6 @@ namespace tr1\n     { return shared_ptr<_Tp>(__r, __dynamic_cast_tag()); }\n \n \n-  /// weak_ptr\n   // The actual weak_ptr, with forwarding constructors and\n   // assignment operators.\n   template<typename _Tp>\n@@ -971,7 +925,6 @@ namespace tr1\n       }\n     };\n \n-  /// enable_shared_from_this\n   template<typename _Tp>\n     class enable_shared_from_this\n     {\n@@ -1013,7 +966,6 @@ namespace tr1\n \n       mutable weak_ptr<_Tp>  _M_weak_this;\n     };\n-\n }\n }\n "}, {"sha": "56030856dca639caa2e56489be5aa860c617f58c", "filename": "libstdc++-v3/include/tr1_impl/boost_sp_counted_base.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fboost_sp_counted_base.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -51,6 +51,10 @@ namespace std\n {\n _GLIBCXX_BEGIN_NAMESPACE_TR1\n \n+ /**\n+   *  @brief  Exception possibly thrown by @c shared_ptr.\n+   *  @ingroup exceptions\n+   */\n   class bad_weak_ptr : public std::exception\n   {\n   public:"}, {"sha": "8df62c212cc38cc48353bb7b61eb38a547102d19", "filename": "libstdc++-v3/include/tr1_impl/regex", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fregex?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -135,9 +135,9 @@ namespace regex_constants\n    * Specifies that the grammar recognized by the regular expression engine is\n    * that used by POSIX utility awk in IEEE Std 1003.1-2001.  This option is\n    * identical to syntax_option_type extended, except that C-style escape\n-   * sequences are supported.  These sequences are, explicitly, \"\\\\\", \"\\a\",\n-   * \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\" , \"\\v\", \"\\\"\", \"'\",\n-   * and \"\\ddd\" (where ddd is one, two, or three octal digits).  \n+   * sequences are supported.  These sequences are, explicitly, '\\\\', '\\a',\n+   * '\\b', '\\f', '\\n', '\\r', '\\t' , '\\v', '\\'', ''',\n+   * and '\\ddd' (where ddd is one, two, or three octal digits).  \n    */\n   static const syntax_option_type awk        = 1 << _S_awk;\n \n@@ -202,26 +202,26 @@ namespace regex_constants\n \n   /**\n    * The first character in the sequence [first, last) is treated as though it\n-   * is not at the beginning of a line, so the character \"^\" in the regular\n+   * is not at the beginning of a line, so the character '^' in the regular\n    * expression shall not match [first, first).\n    */\n   static const match_flag_type match_not_bol     = 1 << _S_not_bol;\n \n   /**\n    * The last character in the sequence [first, last) is treated as though it\n-   * is not at the end of a line, so the character \"$\" in the regular\n+   * is not at the end of a line, so the character '$' in the regular\n    * expression shall not match [last, last).\n    */\n   static const match_flag_type match_not_eol     = 1 << _S_not_eol;\n    \n   /**\n-   * The expression \"\\b\" is not matched against the sub-sequence\n+   * The expression '\\b' is not matched against the sub-sequence\n    * [first,first).\n    */\n   static const match_flag_type match_not_bow     = 1 << _S_not_bow;\n    \n   /**\n-   * The expression \"\\b\" should not be matched against the sub-sequence\n+   * The expression '\\b' should not be matched against the sub-sequence\n    * [last,last).\n    */\n   static const match_flag_type match_not_eow     = 1 << _S_not_eow;\n@@ -363,7 +363,7 @@ namespace regex_constants\n   static const error_type error_space(_S_error_space);\n \n   /**\n-   * One of \"*?+{\" was not preceded by a valid regular expression.\n+   * One of '*?+{' was not preceded by a valid regular expression.\n    */\n   static const error_type error_badrepeat(_S_error_badrepeat);\n \n@@ -2532,7 +2532,7 @@ namespace regex_constants\n \n   // [7.12.2] Class template regex_token_iterator\n   /**\n-   * Iterates over submatches in a range (or \"splits\" a text string).\n+   * Iterates over submatches in a range (or 'splits' a text string).\n    *\n    * The purpose of this iterator is to enumerate all, or all specified,\n    * matches of a regular expression within a text range.  The dereferenced"}, {"sha": "47f5e8f7e602e698fd2f15df4769fd7eb354b9c9", "filename": "libstdc++-v3/include/tr1_impl/type_traits", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Ftype_traits?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -497,5 +497,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n #undef _DEFINE_SPEC\n \n   // @} group metaprogramming\n+\n _GLIBCXX_END_NAMESPACE_TR1\n }"}, {"sha": "18861609040f3d9eef11a7aa95e867e288a01f36", "filename": "libstdc++-v3/libsupc++/cxxabi.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcxxabi.h?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -582,7 +582,7 @@ namespace __cxxabiv1\n /** @namespace abi\n  *  @brief The cross-vendor C++ Application Binary Interface. A\n  *  namespace alias to __cxxabiv1, but user programs should use the\n- *  alias `abi'.\n+ *  alias 'abi'.\n  *\n  *  A brief overview of an ABI is given in the libstdc++ FAQ, question\n  *  5.8 (you may have a copy of the FAQ locally, or you can view the online\n@@ -594,10 +594,10 @@ namespace __cxxabiv1\n  *  along with the current specification.\n  *\n  *  For users of GCC greater than or equal to 3.x, entry points are\n- *  available in <cxxabi.h>, which notes, <em>\"It is not normally\n+ *  available in <cxxabi.h>, which notes, <em>'It is not normally\n  *  necessary for user programs to include this header, or use the\n  *  entry points directly.  However, this header is available should\n- *  that be needed.\"</em>\n+ *  that be needed.'</em>\n */\n namespace abi = __cxxabiv1;\n "}, {"sha": "989a9ff6f74782d1ab0dca0977b49c1536d78c3f", "filename": "libstdc++-v3/libsupc++/exception", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -102,15 +102,16 @@ namespace std\n    *  violates the function's %exception specification.  */\n   void unexpected() __attribute__ ((__noreturn__));\n \n-  /** [18.6.4]/1:  \"Returns true after completing evaluation of a\n+  /** [18.6.4]/1:  'Returns true after completing evaluation of a\n    *  throw-expression until either completing initialization of the\n    *  exception-declaration in the matching handler or entering @c unexpected()\n    *  due to the throw; or after entering @c terminate() for any reason\n    *  other than an explicit call to @c terminate().  [Note: This includes\n-   *  stack unwinding [15.2].  end note]\"\n+   *  stack unwinding [15.2].  end note]'\n    *\n-   *  2:  \"When @c uncaught_exception() is true, throwing an %exception can\n-   *  result in a call of @c terminate() (15.5.1).\"\n+   *  2: 'When @c uncaught_exception() is true, throwing an\n+   *  %exception can result in a call of @c terminate()\n+   *  (15.5.1).'\n    */\n   bool uncaught_exception() throw() __attribute__ ((__pure__));\n "}, {"sha": "2ae375454e0de6e42e7b35f5884342009e84aee2", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -48,8 +48,8 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 546 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 508 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 547 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 509 }\n \n // { dg-excess-errors \"At global scope\" }\n // { dg-excess-errors \"In instantiation of\" }"}, {"sha": "5bf030cabcbd728c3ee846315ce3d0c5cc17c35d", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e32aa11c749dfe475c6fd060888d991b84cb408/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=8e32aa11c749dfe475c6fd060888d991b84cb408", "patch": "@@ -48,8 +48,8 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 467 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 429 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 468 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 430 }\n \n // { dg-excess-errors \"At global scope\" }\n // { dg-excess-errors \"In instantiation of\" }"}]}