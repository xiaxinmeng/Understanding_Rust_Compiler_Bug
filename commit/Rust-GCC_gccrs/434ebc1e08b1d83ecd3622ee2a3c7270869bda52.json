{"sha": "434ebc1e08b1d83ecd3622ee2a3c7270869bda52", "node_id": "C_kwDOANBUbNoAKDQzNGViYzFlMDhiMWQ4M2VjZDM2MjJlZTJhM2M3MjcwODY5YmRhNTI", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-10-15T16:26:13Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-10-21T13:28:22Z"}, "message": "Move ranger only VRP folder to tree-vrp.\n\nConsolidate the RVRP folder into a single \"execute_vrp\" routine that mimics\nthe format used by the vrp1 and vrp2 passes.  Relocate into the tree-vrp file.\n\n\t* gimple-ssa-evrp.c (class rvrp_folder): Move to tree-vrp.c.\n\t(execute_early_vrp): For ranger only mode, invoke ranger_vrp.\n\t* tree-vrp.c (class rvrp_folder): Relocate here.\n\t(execute_ranger_vrp): New.\n\t* tree-vrp.h (execute_ranger_vrp): Export.", "tree": {"sha": "59779b12cacdc400d1a479f96da42b4d54df0f4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59779b12cacdc400d1a479f96da42b4d54df0f4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/434ebc1e08b1d83ecd3622ee2a3c7270869bda52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/434ebc1e08b1d83ecd3622ee2a3c7270869bda52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/434ebc1e08b1d83ecd3622ee2a3c7270869bda52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/434ebc1e08b1d83ecd3622ee2a3c7270869bda52/comments", "author": null, "committer": null, "parents": [{"sha": "b4702276615ff8d43bc910e7a54fdd850ad8d461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4702276615ff8d43bc910e7a54fdd850ad8d461", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4702276615ff8d43bc910e7a54fdd850ad8d461"}], "stats": {"total": 216, "additions": 128, "deletions": 88}, "files": [{"sha": "a0192e2b2aa0230d747a48c4f02a7cf16a2d1440", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 4, "deletions": 88, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434ebc1e08b1d83ecd3622ee2a3c7270869bda52/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434ebc1e08b1d83ecd3622ee2a3c7270869bda52/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=434ebc1e08b1d83ecd3622ee2a3c7270869bda52", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-range.h\"\n #include \"fold-const.h\"\n #include \"value-pointer-equiv.h\"\n+#include \"tree-vrp.h\"\n \n // This is the classic EVRP folder which uses a dominator walk and pushes\n // ranges into the next block if it is a single predecessor block.\n@@ -110,88 +111,6 @@ class evrp_folder : public substitute_and_fold_engine\n   simplify_using_ranges simplifier;\n };\n \n-// This is a ranger based folder which continues to use the dominator\n-// walk to access the substitute and fold machinery.  Ranges are calculated\n-// on demand.\n-\n-class rvrp_folder : public substitute_and_fold_engine\n-{\n-public:\n-\n-  rvrp_folder () : substitute_and_fold_engine (), m_simplifier ()\n-  {\n-    m_ranger = enable_ranger (cfun);\n-    m_simplifier.set_range_query (m_ranger, m_ranger->non_executable_edge_flag);\n-    m_pta = new pointer_equiv_analyzer (m_ranger);\n-  }\n-      \n-  ~rvrp_folder ()\n-  {\n-    if (dump_file && (dump_flags & TDF_DETAILS))\n-      m_ranger->dump (dump_file);\n-\n-    m_ranger->export_global_ranges ();\n-    disable_ranger (cfun);\n-    delete m_pta;\n-  }\n-\n-  tree value_of_expr (tree name, gimple *s = NULL) OVERRIDE\n-  {\n-    // Shortcircuit subst_and_fold callbacks for abnormal ssa_names.\n-    if (TREE_CODE (name) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n-      return NULL;\n-    tree ret = m_ranger->value_of_expr (name, s);\n-    if (!ret && supported_pointer_equiv_p (name))\n-      ret = m_pta->get_equiv (name);\n-    return ret;\n-  }\n-\n-  tree value_on_edge (edge e, tree name) OVERRIDE\n-  {\n-    // Shortcircuit subst_and_fold callbacks for abnormal ssa_names.\n-    if (TREE_CODE (name) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n-      return NULL;\n-    tree ret = m_ranger->value_on_edge (e, name);\n-    if (!ret && supported_pointer_equiv_p (name))\n-      ret = m_pta->get_equiv (name);\n-    return ret;\n-  }\n-\n-  tree value_of_stmt (gimple *s, tree name = NULL) OVERRIDE\n-  {\n-    // Shortcircuit subst_and_fold callbacks for abnormal ssa_names.\n-    if (TREE_CODE (name) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n-      return NULL;\n-    return m_ranger->value_of_stmt (s, name);\n-  }\n-\n-  void pre_fold_bb (basic_block bb) OVERRIDE\n-  {\n-    m_pta->enter (bb);\n-  }\n-\n-  void post_fold_bb (basic_block bb) OVERRIDE\n-  {\n-    m_pta->leave (bb);\n-  }\n-\n-  void pre_fold_stmt (gimple *stmt) OVERRIDE\n-  {\n-    m_pta->visit_stmt (stmt);\n-  }\n-\n-  bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n-  {\n-    return m_simplifier.simplify (gsi);\n-  }\n-\n-private:\n-  DISABLE_COPY_AND_ASSIGN (rvrp_folder);\n-  gimple_ranger *m_ranger;\n-  simplify_using_ranges m_simplifier;\n-  pointer_equiv_analyzer *m_pta;\n-};\n-\n // In a hybrid folder, start with an EVRP folder, and add the required\n // fold_stmt bits to either try the ranger first or second.\n //\n@@ -393,6 +312,9 @@ hybrid_folder::choose_value (tree evrp_val, tree ranger_val)\n static unsigned int\n execute_early_vrp ()\n {\n+  if ((param_evrp_mode & EVRP_MODE_RVRP_FIRST) == EVRP_MODE_RVRP_ONLY)\n+    return execute_ranger_vrp (cfun, false);\n+\n   /* Ideally this setup code would move into the ctor for the folder\n      However, this setup can change the number of blocks which\n      invalidates the internal arrays that are set up by the dominator\n@@ -411,12 +333,6 @@ execute_early_vrp ()\n \tfolder.substitute_and_fold ();\n \tbreak;\n       }\n-    case EVRP_MODE_RVRP_ONLY:\n-      {\n-\trvrp_folder folder;\n-\tfolder.substitute_and_fold ();\n-\tbreak;\n-      }\n     case EVRP_MODE_EVRP_FIRST:\n       {\n \thybrid_folder folder (true);"}, {"sha": "b0b217bbf86cbaf2c222c18ba421ebcfa3b2c5fe", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434ebc1e08b1d83ecd3622ee2a3c7270869bda52/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434ebc1e08b1d83ecd3622ee2a3c7270869bda52/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=434ebc1e08b1d83ecd3622ee2a3c7270869bda52", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-array-bounds.h\"\n #include \"gimple-range.h\"\n #include \"gimple-range-path.h\"\n+#include \"value-pointer-equiv.h\"\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n@@ -4313,6 +4314,127 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n   return 0;\n }\n \n+// This is a ranger based folder which continues to use the dominator\n+// walk to access the substitute and fold machinery.  Ranges are calculated\n+// on demand.\n+\n+class rvrp_folder : public substitute_and_fold_engine\n+{\n+public:\n+\n+  rvrp_folder (gimple_ranger *r) : substitute_and_fold_engine (),\n+\t\t\t\t   m_simplifier (r, r->non_executable_edge_flag)\n+  {\n+    m_ranger = r;\n+    m_pta = new pointer_equiv_analyzer (m_ranger);\n+  }\n+\n+  ~rvrp_folder ()\n+  {\n+    delete m_pta;\n+  }\n+\n+  tree value_of_expr (tree name, gimple *s = NULL) OVERRIDE\n+  {\n+    // Shortcircuit subst_and_fold callbacks for abnormal ssa_names.\n+    if (TREE_CODE (name) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n+      return NULL;\n+    tree ret = m_ranger->value_of_expr (name, s);\n+    if (!ret && supported_pointer_equiv_p (name))\n+      ret = m_pta->get_equiv (name);\n+    return ret;\n+  }\n+\n+  tree value_on_edge (edge e, tree name) OVERRIDE\n+  {\n+    // Shortcircuit subst_and_fold callbacks for abnormal ssa_names.\n+    if (TREE_CODE (name) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n+      return NULL;\n+    tree ret = m_ranger->value_on_edge (e, name);\n+    if (!ret && supported_pointer_equiv_p (name))\n+      ret = m_pta->get_equiv (name);\n+    return ret;\n+  }\n+\n+  tree value_of_stmt (gimple *s, tree name = NULL) OVERRIDE\n+  {\n+    // Shortcircuit subst_and_fold callbacks for abnormal ssa_names.\n+    if (TREE_CODE (name) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n+      return NULL;\n+    return m_ranger->value_of_stmt (s, name);\n+  }\n+\n+  void pre_fold_bb (basic_block bb) OVERRIDE\n+  {\n+    m_pta->enter (bb);\n+  }\n+\n+  void post_fold_bb (basic_block bb) OVERRIDE\n+  {\n+    m_pta->leave (bb);\n+  }\n+\n+  void pre_fold_stmt (gimple *stmt) OVERRIDE\n+  {\n+    m_pta->visit_stmt (stmt);\n+  }\n+\n+  bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n+  {\n+    return m_simplifier.simplify (gsi);\n+  }\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (rvrp_folder);\n+  gimple_ranger *m_ranger;\n+  simplify_using_ranges m_simplifier;\n+  pointer_equiv_analyzer *m_pta;\n+};\n+\n+/* Main entry point for a VRP pass using just ranger. This can be called\n+  from anywhere to perform a VRP pass, including from EVRP.  */\n+\n+unsigned int\n+execute_ranger_vrp (struct function *fun, bool warn_array_bounds_p)\n+{\n+  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+  scev_initialize ();\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  gimple_ranger *ranger = enable_ranger (fun);\n+  rvrp_folder folder (ranger);\n+  folder.substitute_and_fold ();\n+  ranger->export_global_ranges ();\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    ranger->dump (dump_file);\n+\n+\n+  if (warn_array_bounds && warn_array_bounds_p)\n+    {\n+      // Set all edges as executable, except those ranger says aren't.\n+      int non_exec_flag = ranger->non_executable_edge_flag;\n+      basic_block bb;\n+      FOR_ALL_BB_FN (bb, fun)\n+\t{\n+\t  edge_iterator ei;\n+\t  edge e;\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    if (e->flags & non_exec_flag)\n+\t      e->flags &= ~EDGE_EXECUTABLE;\n+\t    else\n+\t      e->flags |= EDGE_EXECUTABLE;\n+\t}\n+      array_bounds_checker array_checker (fun, ranger);\n+      array_checker.check ();\n+    }\n+\n+  disable_ranger (fun);\n+  scev_finalize ();\n+  loop_optimizer_finalize ();\n+  return 0;\n+}\n+\n namespace {\n \n const pass_data pass_data_vrp ="}, {"sha": "cf379de86ff93760da279a7ffe5370109a5549ef", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/434ebc1e08b1d83ecd3622ee2a3c7270869bda52/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/434ebc1e08b1d83ecd3622ee2a3c7270869bda52/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=434ebc1e08b1d83ecd3622ee2a3c7270869bda52", "patch": "@@ -65,4 +65,6 @@ extern void maybe_set_nonzero_bits (edge, tree);\n extern wide_int masked_increment (const wide_int &val_in, const wide_int &mask,\n \t\t\t\t  const wide_int &sgnbit, unsigned int prec);\n \n+extern unsigned int execute_ranger_vrp (struct function *fun,\n+\t\t\t\t\tbool warn_array_bounds_p = false);\n #endif /* GCC_TREE_VRP_H */"}]}