{"sha": "da9e6e63d1ae22e530ec7baf59f6ed028bf05776", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE5ZTZlNjNkMWFlMjJlNTMwZWM3YmFmNTlmNmVkMDI4YmYwNTc3Ng==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-05-04T01:48:47Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2021-05-04T01:48:47Z"}, "message": "introduce try store by multiple pieces\n\nThe ldist pass turns even very short loops into memset calls.  E.g.,\nthe TFmode emulation calls end with a loop of up to 3 iterations, to\nzero out trailing words, and the loop distribution pass turns them\ninto calls of the memset builtin.\n\nThough short constant-length clearing memsets are usually dealt with\nefficiently, for non-constant-length ones, the options are setmemM, or\na function calls.\n\nRISC-V doesn't have any setmemM pattern, so the loops above end up\n\"optimized\" into memset calls, incurring not only the overhead of an\nexplicit call, but also discarding the information the compiler has\nabout the alignment of the destination, and that the length is a\nmultiple of the word alignment.\n\nThis patch handles variable lengths with multiple conditional\npower-of-2-constant-sized stores-by-pieces, so as to reduce the\noverhead of length compares.\n\nIt also changes the last copy-prop pass into ccp, so that pointer\nalignment and length's nonzero bits are detected and made available\nfor the expander, even for ldist-introduced SSA_NAMEs.\n\n\nfor  gcc/ChangeLog\n\n\t* builtins.c (try_store_by_multiple_pieces): New.\n\t(expand_builtin_memset_args): Use it.  If target_char_cast\n\tfails, proceed as for non-constant val.  Pass len's ctz to...\n\t* expr.c (clear_storage_hints): ... this.  Try store by\n\tmultiple pieces after setmem.\n\t(clear_storage): Adjust.\n\t* expr.h (clear_storage_hints): Likewise.\n\t(try_store_by_multiple_pieces): Declare.\n\t* passes.def: Replace the last copy_prop with ccp.", "tree": {"sha": "41e492d87df336bef4a7c9bb310627ba3fcb62aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41e492d87df336bef4a7c9bb310627ba3fcb62aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da9e6e63d1ae22e530ec7baf59f6ed028bf05776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9e6e63d1ae22e530ec7baf59f6ed028bf05776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da9e6e63d1ae22e530ec7baf59f6ed028bf05776", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/comments", "author": null, "committer": null, "parents": [{"sha": "e690396da796cc4e1a0592336b37fec4e97262da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e690396da796cc4e1a0592336b37fec4e97262da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e690396da796cc4e1a0592336b37fec4e97262da"}], "stats": {"total": 209, "additions": 197, "deletions": 12}, "files": [{"sha": "b0471286ac1d243d065c67bd6cc64d6074cc9ff6", "filename": "gcc/builtins.c", "status": "modified", "additions": 175, "deletions": 7, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=da9e6e63d1ae22e530ec7baf59f6ed028bf05776", "patch": "@@ -6667,6 +6667,166 @@ expand_builtin_memset (tree exp, rtx target, machine_mode mode)\n   return expand_builtin_memset_args (dest, val, len, target, mode, exp);\n }\n \n+/* Try to store VAL (or, if NULL_RTX, VALC) in LEN bytes starting at TO.\n+   Return TRUE if successful, FALSE otherwise.  TO is assumed to be\n+   aligned at an ALIGN-bits boundary.  LEN must be a multiple of\n+   1<<CTZ_LEN between MIN_LEN and MAX_LEN.\n+\n+   The strategy is to issue one store_by_pieces for each power of two,\n+   from most to least significant, guarded by a test on whether there\n+   are at least that many bytes left to copy in LEN.\n+\n+   ??? Should we skip some powers of two in favor of loops?  Maybe start\n+   at the max of TO/LEN/word alignment, at least when optimizing for\n+   size, instead of ensuring O(log len) dynamic compares?  */\n+\n+bool\n+try_store_by_multiple_pieces (rtx to, rtx len, unsigned int ctz_len,\n+\t\t\t      unsigned HOST_WIDE_INT min_len,\n+\t\t\t      unsigned HOST_WIDE_INT max_len,\n+\t\t\t      rtx val, char valc, unsigned int align)\n+{\n+  int max_bits = floor_log2 (max_len);\n+  int min_bits = floor_log2 (min_len);\n+  int sctz_len = ctz_len;\n+\n+  gcc_checking_assert (sctz_len >= 0);\n+\n+  if (val)\n+    valc = 1;\n+\n+  /* Bits more significant than TST_BITS are part of the shared prefix\n+     in the binary representation of both min_len and max_len.  Since\n+     they're identical, we don't need to test them in the loop.  */\n+  int tst_bits = (max_bits != min_bits ? max_bits\n+\t\t  : floor_log2 (max_len ^ min_len));\n+\n+  /* Check whether it's profitable to start by storing a fixed BLKSIZE\n+     bytes, to lower max_bits.  In the unlikely case of a constant LEN\n+     (implied by identical MAX_LEN and MIN_LEN), we want to issue a\n+     single store_by_pieces, but otherwise, select the minimum multiple\n+     of the ALIGN (in bytes) and of the MCD of the possible LENs, that\n+     brings MAX_LEN below TST_BITS, if that's lower than min_len.  */\n+  unsigned HOST_WIDE_INT blksize;\n+  if (max_len > min_len)\n+    {\n+      unsigned HOST_WIDE_INT alrng = MAX (HOST_WIDE_INT_1U << ctz_len,\n+\t\t\t\t\t  align / BITS_PER_UNIT);\n+      blksize = max_len - (HOST_WIDE_INT_1U << tst_bits) + alrng;\n+      blksize &= ~(alrng - 1);\n+    }\n+  else if (max_len == min_len)\n+    blksize = max_len;\n+  else\n+    gcc_unreachable ();\n+  if (min_len >= blksize)\n+    {\n+      min_len -= blksize;\n+      min_bits = floor_log2 (min_len);\n+      max_len -= blksize;\n+      max_bits = floor_log2 (max_len);\n+\n+      tst_bits = (max_bits != min_bits ? max_bits\n+\t\t : floor_log2 (max_len ^ min_len));\n+    }\n+  else\n+    blksize = 0;\n+\n+  /* Check that we can use store by pieces for the maximum store count\n+     we may issue (initial fixed-size block, plus conditional\n+     power-of-two-sized from max_bits to ctz_len.  */\n+  unsigned HOST_WIDE_INT xlenest = blksize;\n+  if (max_bits >= 0)\n+    xlenest += ((HOST_WIDE_INT_1U << max_bits) * 2\n+\t\t- (HOST_WIDE_INT_1U << ctz_len));\n+  if (!can_store_by_pieces (xlenest, builtin_memset_read_str,\n+\t\t\t    &valc, align, true))\n+    return false;\n+\n+  rtx (*constfun) (void *, HOST_WIDE_INT, scalar_int_mode);\n+  void *constfundata;\n+  if (val)\n+    {\n+      constfun = builtin_memset_gen_str;\n+      constfundata = val = force_reg (TYPE_MODE (unsigned_char_type_node),\n+\t\t\t\t      val);\n+    }\n+  else\n+    {\n+      constfun = builtin_memset_read_str;\n+      constfundata = &valc;\n+    }\n+\n+  rtx ptr = copy_addr_to_reg (convert_to_mode (ptr_mode, XEXP (to, 0), 0));\n+  rtx rem = copy_to_mode_reg (ptr_mode, convert_to_mode (ptr_mode, len, 0));\n+  to = replace_equiv_address (to, ptr);\n+  set_mem_align (to, align);\n+\n+  if (blksize)\n+    {\n+      to = store_by_pieces (to, blksize,\n+\t\t\t    constfun, constfundata,\n+\t\t\t    align, true,\n+\t\t\t    max_len != 0 ? RETURN_END : RETURN_BEGIN);\n+      if (max_len == 0)\n+\treturn true;\n+\n+      /* Adjust PTR, TO and REM.  Since TO's address is likely\n+\t PTR+offset, we have to replace it.  */\n+      emit_move_insn (ptr, XEXP (to, 0));\n+      to = replace_equiv_address (to, ptr);\n+      emit_move_insn (rem, plus_constant (ptr_mode, rem, -blksize));\n+    }\n+\n+  /* Iterate over power-of-two block sizes from the maximum length to\n+     the least significant bit possibly set in the length.  */\n+  for (int i = max_bits; i >= sctz_len; i--)\n+    {\n+      rtx_code_label *label = NULL;\n+      blksize = HOST_WIDE_INT_1U << i;\n+\n+      /* If we're past the bits shared between min_ and max_len, expand\n+\t a test on the dynamic length, comparing it with the\n+\t BLKSIZE.  */\n+      if (i <= tst_bits)\n+\t{\n+\t  label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (rem, GEN_INT (blksize), LT, NULL,\n+\t\t\t\t   ptr_mode, 1, label,\n+\t\t\t\t   profile_probability::even ());\n+\t}\n+      /* If we are at a bit that is in the prefix shared by min_ and\n+\t max_len, skip this BLKSIZE if the bit is clear.  */\n+      else if ((max_len & blksize) == 0)\n+\tcontinue;\n+\n+      /* Issue a store of BLKSIZE bytes.  */\n+      to = store_by_pieces (to, blksize,\n+\t\t\t    constfun, constfundata,\n+\t\t\t    align, true,\n+\t\t\t    i != sctz_len ? RETURN_END : RETURN_BEGIN);\n+\n+      /* Adjust REM and PTR, unless this is the last iteration.  */\n+      if (i != sctz_len)\n+\t{\n+\t  emit_move_insn (ptr, XEXP (to, 0));\n+\t  to = replace_equiv_address (to, ptr);\n+\t  emit_move_insn (rem, plus_constant (ptr_mode, rem, -blksize));\n+\t}\n+\n+      if (label)\n+\t{\n+\t  emit_label (label);\n+\n+\t  /* Given conditional stores, the offset can no longer be\n+\t     known, so clear it.  */\n+\t  clear_mem_offset (to);\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* Helper function to do the actual work for expand_builtin_memset.  The\n    arguments to the builtin_memset call DEST, VAL, and LEN are broken out\n    so that this can also be called without constructing an actual CALL_EXPR.\n@@ -6721,7 +6881,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   dest_mem = get_memory_rtx (dest, len);\n   val_mode = TYPE_MODE (unsigned_char_type_node);\n \n-  if (TREE_CODE (val) != INTEGER_CST)\n+  if (TREE_CODE (val) != INTEGER_CST\n+      || target_char_cast (val, &c))\n     {\n       rtx val_rtx;\n \n@@ -6745,17 +6906,19 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n       else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx,\n \t\t\t\t\tdest_align, expected_align,\n \t\t\t\t\texpected_size, min_size, max_size,\n-\t\t\t\t\tprobable_max_size))\n+\t\t\t\t\tprobable_max_size)\n+\t       && !try_store_by_multiple_pieces (dest_mem, len_rtx,\n+\t\t\t\t\t\t tree_ctz (len),\n+\t\t\t\t\t\t min_size, max_size,\n+\t\t\t\t\t\t val_rtx, 0,\n+\t\t\t\t\t\t dest_align))\n \tgoto do_libcall;\n \n       dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n       dest_mem = convert_memory_address (ptr_mode, dest_mem);\n       return dest_mem;\n     }\n \n-  if (target_char_cast (val, &c))\n-    goto do_libcall;\n-\n   if (c)\n     {\n       if (tree_fits_uhwi_p (len)\n@@ -6769,7 +6932,12 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t\t\t\t\tgen_int_mode (c, val_mode),\n \t\t\t\t\tdest_align, expected_align,\n \t\t\t\t\texpected_size, min_size, max_size,\n-\t\t\t\t\tprobable_max_size))\n+\t\t\t\t\tprobable_max_size)\n+\t       && !try_store_by_multiple_pieces (dest_mem, len_rtx,\n+\t\t\t\t\t\t tree_ctz (len),\n+\t\t\t\t\t\t min_size, max_size,\n+\t\t\t\t\t\t NULL_RTX, c,\n+\t\t\t\t\t\t dest_align))\n \tgoto do_libcall;\n \n       dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -6783,7 +6951,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t\t\t\t   ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n \t\t\t\t   expected_align, expected_size,\n \t\t\t\t   min_size, max_size,\n-\t\t\t\t   probable_max_size);\n+\t\t\t\t   probable_max_size, tree_ctz (len));\n \n   if (dest_addr == 0)\n     {"}, {"sha": "1b65f6b32455922e4dc3ac0fe4a3dd85a15501f8", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=da9e6e63d1ae22e530ec7baf59f6ed028bf05776", "patch": "@@ -3150,7 +3150,8 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n \t\t     unsigned int expected_align, HOST_WIDE_INT expected_size,\n \t\t     unsigned HOST_WIDE_INT min_size,\n \t\t     unsigned HOST_WIDE_INT max_size,\n-\t\t     unsigned HOST_WIDE_INT probable_max_size)\n+\t\t     unsigned HOST_WIDE_INT probable_max_size,\n+\t\t     unsigned ctz_size)\n {\n   machine_mode mode = GET_MODE (object);\n   unsigned int align;\n@@ -3197,6 +3198,10 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n \t\t\t\t   expected_align, expected_size,\n \t\t\t\t   min_size, max_size, probable_max_size))\n     ;\n+  else if (try_store_by_multiple_pieces (object, size, ctz_size,\n+\t\t\t\t\t min_size, max_size,\n+\t\t\t\t\t NULL_RTX, 0, align))\n+    ;\n   else if (ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (object)))\n     return set_storage_via_libcall (object, size, const0_rtx,\n \t\t\t\t    method == BLOCK_OP_TAILCALL);\n@@ -3214,7 +3219,7 @@ clear_storage (rtx object, rtx size, enum block_op_methods method)\n     min = max = UINTVAL (size);\n   else\n     max = GET_MODE_MASK (GET_MODE (size));\n-  return clear_storage_hints (object, size, method, 0, -1, min, max, max);\n+  return clear_storage_hints (object, size, method, 0, -1, min, max, max, 0);\n }\n \n "}, {"sha": "a4f44265759cef83647d4edf463d61ede1a9601a", "filename": "gcc/expr.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=da9e6e63d1ae22e530ec7baf59f6ed028bf05776", "patch": "@@ -201,7 +201,8 @@ extern rtx clear_storage_hints (rtx, rtx, enum block_op_methods,\n \t\t\t        unsigned int, HOST_WIDE_INT,\n \t\t\t\tunsigned HOST_WIDE_INT,\n \t\t\t\tunsigned HOST_WIDE_INT,\n-\t\t\t\tunsigned HOST_WIDE_INT);\n+\t\t\t\tunsigned HOST_WIDE_INT,\n+\t\t\t\tunsigned);\n /* The same, but always output an library call.  */\n extern rtx set_storage_via_libcall (rtx, rtx, rtx, bool = false);\n \n@@ -232,6 +233,16 @@ extern int can_store_by_pieces (unsigned HOST_WIDE_INT,\n extern rtx store_by_pieces (rtx, unsigned HOST_WIDE_INT, by_pieces_constfn,\n \t\t\t    void *, unsigned int, bool, memop_ret);\n \n+/* If can_store_by_pieces passes for worst-case values near MAX_LEN, call\n+   store_by_pieces within conditionals so as to handle variable LEN efficiently,\n+   storing VAL, if non-NULL_RTX, or valc instead.  */\n+extern bool try_store_by_multiple_pieces (rtx to, rtx len,\n+\t\t\t\t\t  unsigned int ctz_len,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT min_len,\n+\t\t\t\t\t  unsigned HOST_WIDE_INT max_len,\n+\t\t\t\t\t  rtx val, char valc,\n+\t\t\t\t\t  unsigned int align);\n+\n /* Emit insns to set X from Y.  */\n extern rtx_insn *emit_move_insn (rtx, rtx);\n extern rtx_insn *gen_move_insn (rtx, rtx);"}, {"sha": "55e8164d56b2bba8eb2f88e2cff83d948afeaf51", "filename": "gcc/passes.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da9e6e63d1ae22e530ec7baf59f6ed028bf05776/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=da9e6e63d1ae22e530ec7baf59f6ed028bf05776", "patch": "@@ -336,8 +336,9 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_thread_jumps);\n       NEXT_PASS (pass_vrp, false /* warn_array_bounds_p */);\n       /* Threading can leave many const/copy propagations in the IL.\n-\t Clean them up.  */\n-      NEXT_PASS (pass_copy_prop);\n+\t Clean them up.  Instead of just copy_prop, we use ccp to\n+\t compute alignment and nonzero bits.  */\n+      NEXT_PASS (pass_ccp, true /* nonzero_p */);\n       NEXT_PASS (pass_warn_restrict);\n       NEXT_PASS (pass_dse);\n       NEXT_PASS (pass_cd_dce, true /* update_address_taken_p */);"}]}