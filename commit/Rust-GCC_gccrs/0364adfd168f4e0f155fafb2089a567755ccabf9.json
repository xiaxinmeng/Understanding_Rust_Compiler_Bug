{"sha": "0364adfd168f4e0f155fafb2089a567755ccabf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM2NGFkZmQxNjhmNGUwZjE1NWZhZmIyMDg5YTU2Nzc1NWNjYWJmOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-06-14T14:09:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-06-14T14:09:05Z"}, "message": "dwarf2out.c (function_possibly_abstracted_p): New static function.\n\n\t* dwarf2out.c (function_possibly_abstracted_p): New static function.\n\t(gen_subprogram_die): Use it function_possibly_abstracted_p in lieu of\n\tcgraph_function_possibly_inlined_p.\n\t(gen_inlined_subroutine_die): Return if the origin is to be ignored.\n\t(process_scope_var): Do not emit concrete instances of abstracted\n\tnested functions from here.\n\t(gen_decl_die): Emit the abstract instance if the function is possibly\n\tabstracted and not only possibly inlined.\n\t(dwarf2out_finish): Find the first non-abstract parent instance and\n\tattach concrete instances on the limbo list to it.\n\nFrom-SVN: r188621", "tree": {"sha": "483f1b13f1045f868174d5a9bf379855188a002f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/483f1b13f1045f868174d5a9bf379855188a002f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0364adfd168f4e0f155fafb2089a567755ccabf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0364adfd168f4e0f155fafb2089a567755ccabf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0364adfd168f4e0f155fafb2089a567755ccabf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0364adfd168f4e0f155fafb2089a567755ccabf9/comments", "author": null, "committer": null, "parents": [{"sha": "8fcd8c83abb628bf0f4eefad8c85aaac98aca9d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fcd8c83abb628bf0f4eefad8c85aaac98aca9d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fcd8c83abb628bf0f4eefad8c85aaac98aca9d7"}], "stats": {"total": 76, "additions": 67, "deletions": 9}, "files": [{"sha": "57b57f8b4ad9e6d7ac839416de630e57f1b9f635", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0364adfd168f4e0f155fafb2089a567755ccabf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0364adfd168f4e0f155fafb2089a567755ccabf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0364adfd168f4e0f155fafb2089a567755ccabf9", "patch": "@@ -1,3 +1,16 @@\n+2012-06-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* dwarf2out.c (function_possibly_abstracted_p): New static function.\n+\t(gen_subprogram_die): Use it function_possibly_abstracted_p in lieu of\n+\tcgraph_function_possibly_inlined_p.\n+\t(gen_inlined_subroutine_die): Return if the origin is to be ignored.\n+\t(process_scope_var): Do not emit concrete instances of abstracted\n+\tnested functions from here.\n+\t(gen_decl_die): Emit the abstract instance if the function is possibly\n+\tabstracted and not only possibly inlined.\n+\t(dwarf2out_finish): Find the first non-abstract parent instance and\n+\tattach concrete instances on the limbo list to it.\n+\n 2012-06-14  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.md (divsf3, divdf3): Remove FPA support."}, {"sha": "e77fecf8808ac887d161910ca5f2d0d4bb918a54", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0364adfd168f4e0f155fafb2089a567755ccabf9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0364adfd168f4e0f155fafb2089a567755ccabf9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0364adfd168f4e0f155fafb2089a567755ccabf9", "patch": "@@ -16722,6 +16722,30 @@ gen_call_site_die (tree decl, dw_die_ref subr_die,\n   return die;\n }\n \n+/* Return true if an abstract instance of function DECL can be generated in\n+   the debug information.  */\n+\n+static bool\n+function_possibly_abstracted_p (tree decl)\n+{\n+  /* An abstract instance of DECL can be generated if DECL can be inlined or\n+     is nested in a function that can be inlined, recursively.  */\n+  while (decl)\n+    {\n+      if (cgraph_function_possibly_inlined_p (decl))\n+\treturn true;\n+      decl = decl_function_context (decl);\n+      /* Do not consider Fortran subroutines as nested in the main program.  */\n+      if (decl\n+\t  && is_fortran ()\n+\t  && !strcmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t\t      \"MAIN__\"))\n+        break;\n+    }\n+\n+  return false;\n+}\n+\n /* Generate a DIE to represent a declared function (either file-scope or\n    block-local).  */\n \n@@ -16874,14 +16898,14 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n     {\n       if (DECL_DECLARED_INLINE_P (decl))\n \t{\n-\t  if (cgraph_function_possibly_inlined_p (decl))\n+\t  if (function_possibly_abstracted_p (decl))\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_inlined);\n \t  else\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_declared_not_inlined);\n \t}\n       else\n \t{\n-\t  if (cgraph_function_possibly_inlined_p (decl))\n+\t  if (function_possibly_abstracted_p (decl))\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_inlined);\n \t  else\n \t    add_AT_unsigned (subr_die, DW_AT_inline, DW_INL_not_inlined);\n@@ -17810,6 +17834,8 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die, int depth)\n   gcc_assert (! BLOCK_ABSTRACT (stmt));\n \n   decl = block_ultimate_origin (stmt);\n+  if (DECL_IGNORED_P (decl))\n+    return;\n \n   /* Emit info for the abstract instance first, if we haven't yet.  We\n      must emit this even if the block is abstract, otherwise when we\n@@ -18751,6 +18777,7 @@ gen_block_die (tree stmt, dw_die_ref context_die, int depth)\n \n /* Process variable DECL (or variable with origin ORIGIN) within\n    block STMT and add it to CONTEXT_DIE.  */\n+\n static void\n process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n {\n@@ -18768,8 +18795,15 @@ process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n   if (die != NULL && die->die_parent == NULL)\n     add_child_die (context_die, die);\n   else if (TREE_CODE (decl_or_origin) == IMPORTED_DECL)\n-    dwarf2out_imported_module_or_decl_1 (decl_or_origin, DECL_NAME (decl_or_origin),\n+    dwarf2out_imported_module_or_decl_1 (decl_or_origin,\n+\t\t\t\t\t DECL_NAME (decl_or_origin),\n \t\t\t\t\t stmt, context_die);\n+  /* Do not emit concrete instances of abstracted nested functions within\n+     concrete instances of parent functions.  */\n+  else if (TREE_CODE (decl_or_origin) == FUNCTION_DECL\n+\t   && die\n+\t   && get_AT (die, DW_AT_inline))\n+    ;\n   else\n     gen_decl_die (decl, origin, context_die);\n }\n@@ -19116,11 +19150,11 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n \t\t\t\t     ? DECL_ORIGIN (origin)\n \t\t\t\t     : DECL_ABSTRACT_ORIGIN (decl));\n \n-      /* If we're emitting an out-of-line copy of an inline function,\n+      /* If we're emitting an out-of-line copy of an abstracted function,\n \t emit info for the abstract instance and set up to refer to it.  */\n-      else if (cgraph_function_possibly_inlined_p (decl)\n-\t       && ! DECL_ABSTRACT (decl)\n-\t       && ! class_or_namespace_scope_p (context_die)\n+      else if (!DECL_ABSTRACT (decl)\n+\t       && function_possibly_abstracted_p (decl)\n+\t       && !class_or_namespace_scope_p (context_die)\n \t       /* dwarf2out_abstract_function won't emit a die if this is just\n \t\t  a declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in\n \t\t  that case, because that works only if we have a die.  */\n@@ -22118,8 +22152,19 @@ dwarf2out_finish (const char *filename)\n \t{\n \t  dw_die_ref origin = get_AT_ref (die, DW_AT_abstract_origin);\n \n-\t  if (origin && origin->die_parent)\n-\t    add_child_die (origin->die_parent, die);\n+\t  if (origin)\n+\t    {\n+\t      /* Find the first non-abstract parent instance.  */\n+\t      do\n+\t\torigin = origin->die_parent;\n+\t      while (origin\n+\t\t     && (origin->die_tag != DW_TAG_subprogram\n+\t\t\t || get_AT (origin, DW_AT_inline)));\n+\t      if (origin)\n+\t\tadd_child_die (origin, die);\n+\t      else\n+\t\tadd_child_die (comp_unit_die (), die);\n+\t    }\n \t  else if (is_cu_die (die))\n \t    ;\n \t  else if (seen_error ())"}]}