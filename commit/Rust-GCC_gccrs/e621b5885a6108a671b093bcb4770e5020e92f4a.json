{"sha": "e621b5885a6108a671b093bcb4770e5020e92f4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYyMWI1ODg1YTYxMDhhNjcxYjA5M2JjYjQ3NzBlNTAyMGU5MmY0YQ==", "commit": {"author": {"name": "Paul Koning", "email": "pkoning@equallogic.com", "date": "2004-02-03T17:36:02Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2004-02-03T17:36:02Z"}, "message": "pdp11-modes.def: Add RESET_FLOAT_FORMAT calls.\n\n* config/pdp11/pdp11-modes.def: Add RESET_FLOAT_FORMAT calls.\n* config/pdp11/pdp11-protos.h (legitimate_const_double_p): Add.\n* config/pdp11/pdp11.c (encode_pdp11_f, decode_pdp11_f,\nencode_pdp11_d, decode_pdp11_d): New functions to handle PDP11\nfloating point format.\n(pdp11_f_format, pdp11_d_format): New real_format descriptors for\nthe above functions.\n(output_move_quad): Output float values in correct target format.\n(legitimate_const_double_p): New function.\n* config/pdp11/pdp11.h: Fix typos.\n(FLOAT_WORDS_BIG_ENDIAN): Add definition.\n(TARGET_FLOAT_FORMAT): Ditto.\n(pdp11_f_format, pdp11_d_format): Add external declarations.\n(MAX_REGS_PER_ADDRESS): Corrected.\n(LEGITIMATE_CONSTANT_P): Use legitimate_const_double_p().\n(PRINT_OPERAND): Output float literals in target format.\n\nFrom-SVN: r77180", "tree": {"sha": "cc274592d7165e286fc83149f4f969fd0056e0e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc274592d7165e286fc83149f4f969fd0056e0e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e621b5885a6108a671b093bcb4770e5020e92f4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e621b5885a6108a671b093bcb4770e5020e92f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e621b5885a6108a671b093bcb4770e5020e92f4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e621b5885a6108a671b093bcb4770e5020e92f4a/comments", "author": null, "committer": null, "parents": [{"sha": "b6d3cb37ef676c2439fdf9498e4dbe8042fb3c6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6d3cb37ef676c2439fdf9498e4dbe8042fb3c6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6d3cb37ef676c2439fdf9498e4dbe8042fb3c6a"}], "stats": {"total": 179, "additions": 153, "deletions": 26}, "files": [{"sha": "3e2cfe9060481c750f5105487a34cbadcdc69292", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e621b5885a6108a671b093bcb4770e5020e92f4a", "patch": "@@ -1,3 +1,22 @@\n+2004-02-03  Paul Koning  <pkoning@equallogic.com>\n+\n+\t* config/pdp11/pdp11-modes.def: Add RESET_FLOAT_FORMAT calls.\n+\t* config/pdp11/pdp11-protos.h (legitimate_const_double_p): Add.\n+\t* config/pdp11/pdp11.c (encode_pdp11_f, decode_pdp11_f,\n+\tencode_pdp11_d, decode_pdp11_d): New functions to handle PDP11\n+\tfloating point format.\n+\t(pdp11_f_format, pdp11_d_format): New real_format descriptors for\n+\tthe above functions.\n+\t(output_move_quad): Output float values in correct target format.\n+\t(legitimate_const_double_p): New function.\n+\t* config/pdp11/pdp11.h: Fix typos.\n+\t(FLOAT_WORDS_BIG_ENDIAN): Add definition.\n+\t(TARGET_FLOAT_FORMAT): Ditto.\n+\t(pdp11_f_format, pdp11_d_format): Add external declarations.\n+\t(MAX_REGS_PER_ADDRESS): Corrected.\n+\t(LEGITIMATE_CONSTANT_P): Use legitimate_const_double_p().\n+\t(PRINT_OPERAND): Output float literals in target format.\n+\n 2004-02-03  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/13975"}, {"sha": "fdc1540b72933e362c267cbf758c138a7e51f456", "filename": "gcc/config/pdp11/pdp11-modes.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def?ref=e621b5885a6108a671b093bcb4770e5020e92f4a", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for the pdp-11\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n    Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n \n This file is part of GCC.\n@@ -23,3 +23,5 @@ Boston, MA 02111-1307, USA.  */\n    CCFPmode is used for FPU, but should we use a separate reg? */\n \n CC_MODE (CCFP);\n+RESET_FLOAT_FORMAT (SF, pdp11_f_format);\n+RESET_FLOAT_FORMAT (DF, pdp11_d_format);"}, {"sha": "4c460affb583d2a767d18c0f2bf6c4b266ccb112", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=e621b5885a6108a671b093bcb4770e5020e92f4a", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for the pdp-11\n-   Copyright (C) 2000, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Michael K. Gschwind (mike@vlsivie.tuwien.ac.at).\n \n This file is part of GCC.\n@@ -29,6 +29,7 @@ extern int simple_memory_operand (rtx, enum machine_mode);\n extern int comp_operator (rtx, enum machine_mode);\n \n extern int legitimate_address_p (enum machine_mode, rtx);\n+extern int legitimate_const_double_p (rtx);\n extern void notice_update_cc_on_set (rtx, rtx);\n extern void output_addr_const_pdp11 (FILE *, rtx);\n extern const char *output_move_double (rtx *);"}, {"sha": "9102dcdd3a002a2d8777e818215ebcad55614853", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 105, "deletions": 16, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=e621b5885a6108a671b093bcb4770e5020e92f4a", "patch": "@@ -51,6 +51,90 @@ Boston, MA 02111-1307, USA.  */\n    defined in tm.h */\n int current_first_parm_offset;\n \n+/* Routines to encode/decode pdp11 floats */\n+static void encode_pdp11_f (const struct real_format *fmt,\n+\t\t\t    long *, const REAL_VALUE_TYPE *);\n+static void decode_pdp11_f (const struct real_format *,\n+\t\t\t    REAL_VALUE_TYPE *, const long *);\n+static void encode_pdp11_d (const struct real_format *fmt,\n+\t\t\t    long *, const REAL_VALUE_TYPE *);\n+static void decode_pdp11_d (const struct real_format *,\n+\t\t\t    REAL_VALUE_TYPE *, const long *);\n+\n+/* These two are taken from the corresponding vax descriptors\n+   in real.c, changing only the encode/decode routine pointers.  */\n+const struct real_format pdp11_f_format =\n+  {\n+    encode_pdp11_f,\n+    decode_pdp11_f,\n+    2,\n+    1,\n+    24,\n+    24,\n+    -127,\n+    127,\n+    15,\n+    false,\n+    false,\n+    false,\n+    false,\n+    false\n+  };\n+\n+const struct real_format pdp11_d_format =\n+  {\n+    encode_pdp11_d,\n+    decode_pdp11_d,\n+    2,\n+    1,\n+    56,\n+    56,\n+    -127,\n+    127,\n+    15,\n+    false,\n+    false,\n+    false,\n+    false,\n+    false\n+  };\n+\n+static void\n+encode_pdp11_f (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n+\t\tconst REAL_VALUE_TYPE *r)\n+{\n+  (*vax_f_format.encode) (fmt, buf, r);\n+  buf[0] = ((buf[0] >> 16) & 0xffff) | ((buf[0] & 0xffff) << 16);\n+}\n+\n+static void\n+decode_pdp11_f (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\tREAL_VALUE_TYPE *r, const long *buf)\n+{\n+  long tbuf;\n+  tbuf = ((buf[0] >> 16) & 0xffff) | ((buf[0] & 0xffff) << 16);\n+  (*vax_f_format.decode) (fmt, r, &tbuf);\n+}\n+\n+static void\n+encode_pdp11_d (const struct real_format *fmt ATTRIBUTE_UNUSED, long *buf,\n+\t\tconst REAL_VALUE_TYPE *r)\n+{\n+  (*vax_d_format.encode) (fmt, buf, r);\n+  buf[0] = ((buf[0] >> 16) & 0xffff) | ((buf[0] & 0xffff) << 16);\n+  buf[1] = ((buf[1] >> 16) & 0xffff) | ((buf[1] & 0xffff) << 16);\n+}\n+\n+static void\n+decode_pdp11_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\tREAL_VALUE_TYPE *r, const long *buf)\n+{\n+  long tbuf[2];\n+  tbuf[0] = ((buf[0] >> 16) & 0xffff) | ((buf[0] & 0xffff) << 16);\n+  tbuf[1] = ((buf[1] >> 16) & 0xffff) | ((buf[1] & 0xffff) << 16);\n+  (*vax_d_format.decode) (fmt, r, tbuf);\n+}\n+\n /* This is where the condition code register lives.  */\n /* rtx cc0_reg_rtx; - no longer needed? */\n \n@@ -683,22 +767,12 @@ output_move_quad (rtx *operands)\n     {\n       if (GET_CODE (operands[1]) == CONST_DOUBLE)\n \t{\n-\t    /* floats only. not yet supported!\n-\n-\t     -- compute it into PDP float format, - internally,\n-\t     just use IEEE and ignore possible problems ;-)\n-\n-\t     we might get away with it !!!! */\n-\n-\t    abort();\n-\t    \n-#ifndef HOST_WORDS_BIG_ENDIAN\n-\t  latehalf[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t  operands[1] = GEN_INT\t(CONST_DOUBLE_HIGH (operands[1]));\n-#else /* HOST_WORDS_BIG_ENDIAN */\n-\t  latehalf[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n-\t  operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-#endif /* HOST_WORDS_BIG_ENDIAN */\n+\t  REAL_VALUE_TYPE r;\n+\t  long dval[2];\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\t  REAL_VALUE_TO_TARGET_DOUBLE (r, dval);\n+\t  latehalf[1] = GEN_INT (dval[1]);\n+\t  operands[1] = GEN_INT\t(dval[0]);\n \t}\n       else if (GET_CODE(operands[1]) == CONST_INT)\n \t{\n@@ -1591,6 +1665,21 @@ legitimate_address_p (enum machine_mode mode, rtx address)\n /* #undef REG_OK_STRICT */\n }\n \n+/* This function checks whether a real value can be encoded as\n+   a literal, i.e., addressing mode 27.  In that mode, real values\n+   are one word values, so the remaining 48 bits have to be zero.  */\n+int\n+legitimate_const_double_p (rtx address)\n+{\n+  REAL_VALUE_TYPE r;\n+  long sval[2];\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, address);\n+  REAL_VALUE_TO_TARGET_DOUBLE (r, sval);\n+  if ((sval[0] & 0xffff) == 0 && sval[1] == 0)\n+    return 1;\n+  return 0;\n+}\n+\n /* A copy of output_addr_const modified for pdp11 expression syntax.\n    output_addr_const also gets called for %cDIGIT and %nDIGIT, which we don't\n    use, and for debugging output, which we don't support with this port either."}, {"sha": "6bc37685e45256cce5f90c44bb44cd8afaca3a88", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e621b5885a6108a671b093bcb4770e5020e92f4a/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=e621b5885a6108a671b093bcb4770e5020e92f4a", "patch": "@@ -167,14 +167,27 @@ extern int target_flags;\n /* Define this if most significant byte of a word is the lowest numbered.  */\n #define BYTES_BIG_ENDIAN 0\n \n-/* Define this if most significant word of a multiword number is numbered.  */\n+/* Define this if most significant word of a multiword number is first.  */\n #define WORDS_BIG_ENDIAN 1\n \n+/* Define that floats are in VAX order, not high word first as for ints. */\n+#define FLOAT_WORDS_BIG_ENDIAN 0\n+\n /* Width of a word, in units (bytes). \n \n    UNITS OR BYTES - seems like units */\n #define UNITS_PER_WORD 2\n \n+/* This machine doesn't use IEEE floats.  */\n+/* Because the pdp11 (at least Unix) convention for 32 bit ints is\n+   big endian, opposite for what you need for float, the vax float\n+   conversion routines aren't actually used directly.  But the underlying\n+   format is indeed the vax/pdp11 float format.  */\n+#define TARGET_FLOAT_FORMAT VAX_FLOAT_FORMAT\n+\n+extern const struct real_format pdp11_f_format;\n+extern const struct real_format pdp11_d_format;\n+\n /* Maximum sized of reasonable data type \n    DImode or Dfmode ...*/\n #define MAX_FIXED_MODE_SIZE 64\t\n@@ -446,8 +459,8 @@ enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REG\n    operand as its first argument and the constraint letter as its\n    second operand.\n \n-   `Q'\tis for memory references using take more than 1 instruction.\n-   `R'\tis for memory references which take 1 word for the instruction.  */\n+   `Q'\tis for memory references that require an extra word after the opcode.\n+   `R'\tis for memory references which are encoded within the opcode.  */\n \n #define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n   ((GET_CODE (OP) != MEM) ? 0\t\t\t\t\t\t\\\n@@ -678,7 +691,7 @@ extern int may_call_alloca;\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n-#define MAX_REGS_PER_ADDRESS 2\n+#define MAX_REGS_PER_ADDRESS 1\n \n /* Recognize any constant value that is a valid address.  */\n \n@@ -687,7 +700,8 @@ extern int may_call_alloca;\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) (TARGET_FPU? 1: !(GET_CODE(X) == CONST_DOUBLE))\n+#define LEGITIMATE_CONSTANT_P(X)                                        \\\n+  (GET_CODE (X) != CONST_DOUBLE || legitimate_const_double_p (X))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -1078,9 +1092,11 @@ extern struct rtx_def *cc0_reg_rtx;\n   else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n     output_address (XEXP (X, 0));\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != SImode)\t\\\n-    { char buf[30];\t\t\t\t\t\t\t\\\n-      real_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (X), sizeof (buf), 0, 1); \\\n-      fprintf (FILE, \"$0F%s\", buf); }\t\t\t\t\t\\\n+    { REAL_VALUE_TYPE r;\t\t\t\t\t\t\\\n+      long sval[2];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_DOUBLE (r, sval);\t\t\t\t\\\n+      fprintf (FILE, \"$%#o\", sval[0] >> 16); }\t\t\t\t\\\n   else { putc ('$', FILE); output_addr_const_pdp11 (FILE, X); }}\n \f\n /* Print a memory address as an operand to reference that memory location.  */"}]}