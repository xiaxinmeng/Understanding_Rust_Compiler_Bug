{"sha": "27922d518d3c81c85df4b2d391bc54e85dab01f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc5MjJkNTE4ZDNjODFjODVkZjRiMmQzOTFiYzU0ZTg1ZGFiMDFmNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-11-12T14:53:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-11-12T14:53:36Z"}, "message": "2018-11=12  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vrp.h (value_range[_base]::set): Make public.  Provide\n\toverload for single value.\n\t(value_range[_base]::set_nonnull): New.\n\t(value_range[_base]::set_null): Likewise.\n\t(value_range): Document bitmap copying behavior, mark\n\tcopy constructor and assignment operator deleted.\n\t(value_range::move): New.\n\t(value_range::set_and_canonicalize): Default bitmap to zero.\n\t(set_value_range_to_nonnull): Remove.\n\t(set_value_range_to_null): Likewise.\n\t(set_value_range): Likewise.\n\t(set_value_range_to_value): Likewise.\n\t(extract_range_from_unary_expr): Work on value_range_base.\n\t(extract_range_from_binary_expr_1): Likewise.  Rename to...\n\t(extract_range_from_binary_expr): ... this.\n\t* tree-vrp.c (value_range::update): Clear equiv bitmap\n\tif required.\n\t(value_range::move): New, move equiv bitmap.\n\t(value_range_base::set_undefined): Avoid assignment.\n\t(value_range::set_undefined): Likewise.\n\t(value_range_base::set_varying): Likewise.\n\t(value_range::set_varying): Likewise.\n\t(set_value_range): Remove.\n\t(value_range_base::set): New overload for value.\n\t(value_range::set): Likewise.\n\t(set_value_range_to_nonnull): Remove.\n\t(value_range_base::set_nonnull): New.\n\t(value_range::set_nonnull): Likewise.\n\t(set_value_range_to_null): Remove.\n\t(value_range_base::set_null): New.\n\t(value_range::set_null): Likewise.\n\t(range_is_null): Work on value_range_base.\n\t(range_is_nonnull): Likewise.\n\t(ranges_from_anti_range): Likewise.\n\t(extract_range_into_wide_ints): Likewise.\n\t(extract_range_from_multiplicative_op): Likewise.\n\t(extract_range_from_binary_expr): Likewise.  Update for API changes.\n\t(extract_range_from_unary_expr): Likewise.  Remove OBJ_TYPE_REF\n\thandling.\n\t(value_range::intersect_helper): Avoid copy and assignment.\n\t(value_range::union_helper): Likewise.\n\t(determine_value_range_1): Adjust.\n\t* gimple-ssa-evrp-analyze.c (evrp_range_analyzer::try_find_new_range):\n\tAvoid assignment by using move.\n\t(evrp_range_analyzer::record_ranges_from_stmt): Avoid assignment.\n\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_phis):\n\tLikewise.\n\t* tree-ssanames.c (get_range_info): Likewise.\n\t* vr-values.h (vr_values::get_vr_for_comparison): Adjust API.\n\t* vr-values.c (vr_values::get_value_range): Adjust.\n\t(vr_values::update_value_range): Likewise.\n\t(symbolic_range_based_on_p): Work on value_range_base.\n\t(vr_values::extract_range_from_binary_expr): Use value_range_base.\n\t(vr_values::extract_range_from_unary_expr): Likewise.\n\t(vr_values::extract_range_from_cond_expr): Avoid assignment.\n\t(vr_values::extract_range_from_comparison): Adjust.\n\t(vr_values::check_for_binary_op_overflow): Use value_range_base.\n\t(vr_values::extract_range_basic): Adjust.\n\t(vr_values::adjust_range_with_scev): Likewise.\n\t(vr_values::vrp_visit_assignment_or_call): Likewise.\n\t(vr_values::get_vr_for_comparison): Change API to avoid\n\tassignment and copy construction.\n\t(vr_values::compare_name_with_value): Adjust accordingly.\n\t(vr_values::compare_names): Likewise.\n\t(vr_values::extract_range_from_phi_node): Avoid assignment and\n\tbogus in-place modify of equiv bitmap.\n\t(vr_values::simplify_bit_ops_using_ranges): Use value_range_base.\n\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Adjust\n\tfor extract_range_from_unary_expr API change.\n\t* ipa-cp.c (ipa_vr_operation_and_type_effects): Likewise.\n\nFrom-SVN: r266030", "tree": {"sha": "9bd088ddcc23b2773c679d63544ec12296cf8f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bd088ddcc23b2773c679d63544ec12296cf8f7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27922d518d3c81c85df4b2d391bc54e85dab01f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27922d518d3c81c85df4b2d391bc54e85dab01f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27922d518d3c81c85df4b2d391bc54e85dab01f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27922d518d3c81c85df4b2d391bc54e85dab01f5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03564d3f6e5ad52bcafb7672c881b6cc68ca0eec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03564d3f6e5ad52bcafb7672c881b6cc68ca0eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03564d3f6e5ad52bcafb7672c881b6cc68ca0eec"}], "stats": {"total": 596, "additions": 343, "deletions": 253}, "files": [{"sha": "f458802acec7dfd382ff6eb5bea98bd4876f5e65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -1,3 +1,76 @@\n+2018-11-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vrp.h (value_range[_base]::set): Make public.  Provide\n+\toverload for single value.\n+\t(value_range[_base]::set_nonnull): New.\n+\t(value_range[_base]::set_null): Likewise.\n+\t(value_range): Document bitmap copying behavior, mark\n+\tcopy constructor and assignment operator deleted.\n+\t(value_range::move): New.\n+\t(value_range::set_and_canonicalize): Default bitmap to zero.\n+\t(set_value_range_to_nonnull): Remove.\n+\t(set_value_range_to_null): Likewise.\n+\t(set_value_range): Likewise.\n+\t(set_value_range_to_value): Likewise.\n+\t(extract_range_from_unary_expr): Work on value_range_base.\n+\t(extract_range_from_binary_expr_1): Likewise.  Rename to...\n+\t(extract_range_from_binary_expr): ... this.\n+\t* tree-vrp.c (value_range::update): Clear equiv bitmap\n+\tif required.\n+\t(value_range::move): New, move equiv bitmap.\n+\t(value_range_base::set_undefined): Avoid assignment.\n+\t(value_range::set_undefined): Likewise.\n+\t(value_range_base::set_varying): Likewise.\n+\t(value_range::set_varying): Likewise.\n+\t(set_value_range): Remove.\n+\t(value_range_base::set): New overload for value.\n+\t(value_range::set): Likewise.\n+\t(set_value_range_to_nonnull): Remove.\n+\t(value_range_base::set_nonnull): New.\n+\t(value_range::set_nonnull): Likewise.\n+\t(set_value_range_to_null): Remove.\n+\t(value_range_base::set_null): New.\n+\t(value_range::set_null): Likewise.\n+\t(range_is_null): Work on value_range_base.\n+\t(range_is_nonnull): Likewise.\n+\t(ranges_from_anti_range): Likewise.\n+\t(extract_range_into_wide_ints): Likewise.\n+\t(extract_range_from_multiplicative_op): Likewise.\n+\t(extract_range_from_binary_expr): Likewise.  Update for API changes.\n+\t(extract_range_from_unary_expr): Likewise.  Remove OBJ_TYPE_REF\n+\thandling.\n+\t(value_range::intersect_helper): Avoid copy and assignment.\n+\t(value_range::union_helper): Likewise.\n+\t(determine_value_range_1): Adjust.\n+\t* gimple-ssa-evrp-analyze.c (evrp_range_analyzer::try_find_new_range):\n+\tAvoid assignment by using move.\n+\t(evrp_range_analyzer::record_ranges_from_stmt): Avoid assignment.\n+\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_phis):\n+\tLikewise.\n+\t* tree-ssanames.c (get_range_info): Likewise.\n+\t* vr-values.h (vr_values::get_vr_for_comparison): Adjust API.\n+\t* vr-values.c (vr_values::get_value_range): Adjust.\n+\t(vr_values::update_value_range): Likewise.\n+\t(symbolic_range_based_on_p): Work on value_range_base.\n+\t(vr_values::extract_range_from_binary_expr): Use value_range_base.\n+\t(vr_values::extract_range_from_unary_expr): Likewise.\n+\t(vr_values::extract_range_from_cond_expr): Avoid assignment.\n+\t(vr_values::extract_range_from_comparison): Adjust.\n+\t(vr_values::check_for_binary_op_overflow): Use value_range_base.\n+\t(vr_values::extract_range_basic): Adjust.\n+\t(vr_values::adjust_range_with_scev): Likewise.\n+\t(vr_values::vrp_visit_assignment_or_call): Likewise.\n+\t(vr_values::get_vr_for_comparison): Change API to avoid\n+\tassignment and copy construction.\n+\t(vr_values::compare_name_with_value): Adjust accordingly.\n+\t(vr_values::compare_names): Likewise.\n+\t(vr_values::extract_range_from_phi_node): Avoid assignment and\n+\tbogus in-place modify of equiv bitmap.\n+\t(vr_values::simplify_bit_ops_using_ranges): Use value_range_base.\n+\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Adjust\n+\tfor extract_range_from_unary_expr API change.\n+\t* ipa-cp.c (ipa_vr_operation_and_type_effects): Likewise.\n+\n 2018-11-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/mcore/mcore.h (WORD_REGISTER_OPERATIONS): Remove duplicate."}, {"sha": "bd11eea12b4abc39ba7b338d02fe3691da28084e", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -97,7 +97,7 @@ evrp_range_analyzer::try_find_new_range (tree name,\n \t  && vrp_operand_equal_p (old_vr->max (), vr.max ()))\n \treturn NULL;\n       value_range *new_vr = vr_values->allocate_value_range ();\n-      *new_vr = vr;\n+      new_vr->move (&vr);\n       return new_vr;\n     }\n   return NULL;\n@@ -319,8 +319,8 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n \t\t also have to be very careful about sharing the underlying\n \t\t bitmaps.  Ugh.  */\n \t      value_range *new_vr = vr_values->allocate_value_range ();\n-\t      *new_vr = vr;\n-\t      new_vr->equiv_clear ();\n+\t      new_vr->set (vr.kind (), vr.min (), vr.max ());\n+\t      vr.equiv_clear ();\n \t      push_value_range (output, new_vr);\n \t    }\n \t}"}, {"sha": "81da108fb623f02c1079671ecb9d8eb0c7367231", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -1876,12 +1876,8 @@ ipa_vr_operation_and_type_effects (value_range_base *dst_vr,\n \t\t\t\t   enum tree_code operation,\n \t\t\t\t   tree dst_type, tree src_type)\n {\n-  /* ???  We'd want to use value_range_base on the VRP workers.  */\n-  value_range dst_tem;\n-  value_range src_tem (*src_vr);\n-  extract_range_from_unary_expr (&dst_tem, operation, dst_type,\n-\t\t\t\t &src_tem, src_type);\n-  *dst_vr = value_range_base (dst_tem.kind (), dst_tem.min (), dst_tem.max ());\n+  extract_range_from_unary_expr (dst_vr, operation, dst_type,\n+\t\t\t\t src_vr, src_type);\n   if (dst_vr->varying_p () || dst_vr->undefined_p ())\n     return false;\n   return true;"}, {"sha": "c779d865315ab599373039ff5a2816738fabeea1", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -1885,12 +1885,10 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t      && (type = get_range_info (arg, &min, &max))\n \t      && (type == VR_RANGE || type == VR_ANTI_RANGE))\n \t    {\n-\t      /* ???  We'd want to use value_range_base here but the\n-\t         VRP workers need to be adjusted first.  */\n-\t      value_range resvr;\n-\t      value_range tmpvr (type,\n-\t\t\t\t wide_int_to_tree (TREE_TYPE (arg), min),\n-\t\t\t\t wide_int_to_tree (TREE_TYPE (arg), max));\n+\t      value_range_base resvr;\n+\t      value_range_base tmpvr (type,\n+\t\t\t\t      wide_int_to_tree (TREE_TYPE (arg), min),\n+\t\t\t\t      wide_int_to_tree (TREE_TYPE (arg), max));\n \t      extract_range_from_unary_expr (&resvr, NOP_EXPR, param_type,\n \t\t\t\t\t     &tmpvr, TREE_TYPE (arg));\n \t      if (!resvr.undefined_p () && !resvr.varying_p ())"}, {"sha": "8be8d79acab3f60dba3c5131a1c6da7d721de9de", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -166,7 +166,7 @@ record_temporary_equivalences_from_phis (edge e,\n \t     away in the VR stack.  */\n \t  vr_values *vr_values = evrp_range_analyzer->get_vr_values ();\n \t  value_range *new_vr = vr_values->allocate_value_range ();\n-\t  *new_vr = value_range ();\n+\t  new (new_vr) value_range ();\n \n \t  /* There are three cases to consider:\n \n@@ -181,7 +181,7 @@ record_temporary_equivalences_from_phis (edge e,\n \t  if (TREE_CODE (src) == SSA_NAME)\n \t    new_vr->deep_copy (vr_values->get_value_range (src));\n \t  else if (TREE_CODE (src) == INTEGER_CST)\n-\t    set_value_range_to_value (new_vr, src,  NULL);\n+\t    new_vr->set (src);\n \t  else\n \t    new_vr->set_varying ();\n "}, {"sha": "b53c4be30746aad45114c174d3a2a4a80d05687c", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -447,7 +447,7 @@ get_range_info (const_tree name, value_range &vr)\n       min = wide_int_to_tree (TREE_TYPE (name), wmin);\n       max = wide_int_to_tree (TREE_TYPE (name), wmax);\n     }\n-  vr = value_range (kind, min, max);\n+  vr.set (kind, min, max);\n   return kind;\n }\n "}, {"sha": "a182e643ad731190f7c2b21ee0d584ad5e4ecfdb", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 128, "deletions": 131, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -134,12 +134,13 @@ value_range::value_range (const value_range_base &other)\n   set (other.kind (), other.min(), other.max (), NULL);\n }\n \n-/* Like above, but keep the equivalences intact.  */\n+/* Like set, but keep the equivalences in place.  */\n \n void\n value_range::update (value_range_kind kind, tree min, tree max)\n {\n-  set (kind, min, max, m_equiv);\n+  set (kind, min, max,\n+       (kind != VR_UNDEFINED && kind != VR_VARYING) ? m_equiv : NULL);\n }\n \n /* Copy value_range in FROM into THIS while avoiding bitmap sharing.\n@@ -154,6 +155,14 @@ value_range::deep_copy (const value_range *from)\n   set (from->m_kind, from->min (), from->max (), from->m_equiv);\n }\n \n+void\n+value_range::move (value_range *from)\n+{\n+  set (from->m_kind, from->min (), from->max ());\n+  m_equiv = from->m_equiv;\n+  from->m_equiv = NULL;\n+}\n+\n /* Check the validity of the range.  */\n \n void\n@@ -262,27 +271,25 @@ value_range_base::constant_p () const\n void\n value_range_base::set_undefined ()\n {\n-  *this = value_range_base (VR_UNDEFINED, NULL, NULL);\n+  set (VR_UNDEFINED, NULL, NULL);\n }\n \n void\n value_range::set_undefined ()\n {\n-  equiv_clear ();\n-  *this = value_range (VR_UNDEFINED, NULL, NULL, NULL);\n+  set (VR_UNDEFINED, NULL, NULL, NULL);\n }\n \n void\n value_range_base::set_varying ()\n {\n-  *this = value_range_base (VR_VARYING, NULL, NULL);\n+  set (VR_VARYING, NULL, NULL);\n }\n \n void\n value_range::set_varying ()\n {\n-  equiv_clear ();\n-  *this = value_range (VR_VARYING, NULL, NULL, NULL);\n+  set (VR_VARYING, NULL, NULL, NULL);\n }\n \n /* Return TRUE if it is possible that range contains VAL.  */\n@@ -598,15 +605,6 @@ intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n   return vr_type;\n }\n \n-/* Set value range VR to {T, MIN, MAX, EQUIV}.  */\n-\n-void\n-set_value_range (value_range *vr, enum value_range_kind kind,\n-\t\t tree min, tree max, bitmap equiv)\n-{\n-  *vr = value_range (kind, min, max, equiv);\n-}\n-\n \n /* Set value range to the canonical form of {VRTYPE, MIN, MAX, EQUIV}.\n    This means adjusting VRTYPE, MIN and MAX representing the case of a\n@@ -739,35 +737,52 @@ value_range::set_and_canonicalize (enum value_range_kind kind,\n     equiv_clear ();\n }\n \n-/* Set value range VR to a single value.  This function is only called\n-   with values we get from statements, and exists to clear the\n-   TREE_OVERFLOW flag.  */\n+void\n+value_range_base::set (tree val)\n+{\n+  gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n+  if (TREE_OVERFLOW_P (val))\n+    val = drop_tree_overflow (val);\n+  set (VR_RANGE, val, val);\n+}\n \n void\n-set_value_range_to_value (value_range *vr, tree val, bitmap equiv)\n+value_range::set (tree val)\n {\n-  gcc_assert (is_gimple_min_invariant (val));\n+  gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n   if (TREE_OVERFLOW_P (val))\n     val = drop_tree_overflow (val);\n-  set_value_range (vr, VR_RANGE, val, val, equiv);\n+  set (VR_RANGE, val, val, NULL);\n }\n \n /* Set value range VR to a non-NULL range of type TYPE.  */\n \n void\n-set_value_range_to_nonnull (value_range *vr, tree type)\n+value_range_base::set_nonnull (tree type)\n {\n   tree zero = build_int_cst (type, 0);\n-  set_value_range (vr, VR_ANTI_RANGE, zero, zero, NULL);\n+  set (VR_ANTI_RANGE, zero, zero);\n }\n \n+void\n+value_range::set_nonnull (tree type)\n+{\n+  tree zero = build_int_cst (type, 0);\n+  set (VR_ANTI_RANGE, zero, zero, NULL);\n+}\n \n /* Set value range VR to a NULL range of type TYPE.  */\n \n void\n-set_value_range_to_null (value_range *vr, tree type)\n+value_range_base::set_null (tree type)\n+{\n+  set (build_int_cst (type, 0));\n+}\n+\n+void\n+value_range::set_null (tree type)\n {\n-  set_value_range_to_value (vr, build_int_cst (type, 0), NULL);\n+  set (build_int_cst (type, 0));\n }\n \n /* Return true, if VAL1 and VAL2 are equal values for VRP purposes.  */\n@@ -797,13 +812,13 @@ vrp_bitmap_equal_p (const_bitmap b1, const_bitmap b2)\n /* Return true if VR is [0, 0].  */\n \n static inline bool\n-range_is_null (const value_range *vr)\n+range_is_null (const value_range_base *vr)\n {\n   return vr->zero_p ();\n }\n \n static inline bool\n-range_is_nonnull (const value_range *vr)\n+range_is_nonnull (const value_range_base *vr)\n {\n   return (vr->kind () == VR_ANTI_RANGE\n \t  && vr->min () == vr->max ()\n@@ -1195,8 +1210,8 @@ vrp_set_zero_nonzero_bits (const tree expr_type,\n    *VR1 will be VR_UNDEFINED.  */\n \n static bool\n-ranges_from_anti_range (const value_range *ar,\n-\t\t\tvalue_range *vr0, value_range *vr1)\n+ranges_from_anti_range (const value_range_base *ar,\n+\t\t\tvalue_range_base *vr0, value_range_base *vr1)\n {\n   tree type = ar->type ();\n \n@@ -1237,7 +1252,7 @@ ranges_from_anti_range (const value_range *ar,\n    resulting wide ints are set to [-MIN, +MAX] for the type.  */\n \n static void inline\n-extract_range_into_wide_ints (const value_range *vr,\n+extract_range_into_wide_ints (const value_range_base *vr,\n \t\t\t      signop sign, unsigned prec,\n \t\t\t      wide_int &wmin, wide_int &wmax)\n {\n@@ -1259,10 +1274,10 @@ extract_range_into_wide_ints (const value_range *vr,\n      *VR = *VR0 .CODE. *VR1.  */\n \n static void\n-extract_range_from_multiplicative_op (value_range *vr,\n+extract_range_from_multiplicative_op (value_range_base *vr,\n \t\t\t\t      enum tree_code code,\n-\t\t\t\t      const value_range *vr0,\n-\t\t\t\t      const value_range *vr1)\n+\t\t\t\t      const value_range_base *vr0,\n+\t\t\t\t      const value_range_base *vr1)\n {\n   gcc_assert (code == MULT_EXPR\n \t      || code == TRUNC_DIV_EXPR\n@@ -1290,7 +1305,7 @@ extract_range_from_multiplicative_op (value_range *vr,\n \t\t\t\t\toverflow_undefined))\n     vr->set_and_canonicalize (VR_RANGE,\n \t\t\t      wide_int_to_tree (type, res_lb),\n-\t\t\t      wide_int_to_tree (type, res_ub), NULL);\n+\t\t\t      wide_int_to_tree (type, res_ub));\n   else\n     vr->set_varying ();\n }\n@@ -1411,7 +1426,7 @@ set_value_range_with_overflow (value_range_kind &kind, tree &min, tree &max,\n \t{\n \t  /* If the limits are swapped, we wrapped around and cover\n \t     the entire range.  We have a similar check at the end of\n-\t     extract_range_from_binary_expr_1.  */\n+\t     extract_range_from_binary_expr.  */\n \t  if (wi::gt_p (tmin, tmax, sgn))\n \t    kind = VR_VARYING;\n \t  else\n@@ -1485,15 +1500,15 @@ set_value_range_with_overflow (value_range_kind &kind, tree &min, tree &max,\n    type EXPR_TYPE.  The resulting range is stored in *VR.  */\n \n void\n-extract_range_from_binary_expr_1 (value_range *vr,\n-\t\t\t\t  enum tree_code code, tree expr_type,\n-\t\t\t\t  const value_range *vr0_,\n-\t\t\t\t  const value_range *vr1_)\n+extract_range_from_binary_expr (value_range_base *vr,\n+\t\t\t\tenum tree_code code, tree expr_type,\n+\t\t\t\tconst value_range_base *vr0_,\n+\t\t\t\tconst value_range_base *vr1_)\n {\n   signop sign = TYPE_SIGN (expr_type);\n   unsigned int prec = TYPE_PRECISION (expr_type);\n-  value_range vr0 = *vr0_, vr1 = *vr1_;\n-  value_range vrtem0, vrtem1;\n+  value_range_base vr0 = *vr0_, vr1 = *vr1_;\n+  value_range_base vrtem0, vrtem1;\n   enum value_range_kind type;\n   tree min = NULL_TREE, max = NULL_TREE;\n   int cmp;\n@@ -1550,7 +1565,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n      easier to special case when vr0 is ~[0,0] for EXACT_DIV_EXPR.  */\n   if (code == EXACT_DIV_EXPR && range_is_nonnull (&vr0))\n     {\n-      set_value_range_to_nonnull (vr, expr_type);\n+      vr->set_nonnull (expr_type);\n       return;\n     }\n \n@@ -1559,11 +1574,12 @@ extract_range_from_binary_expr_1 (value_range *vr,\n   if (vr0.kind () == VR_ANTI_RANGE\n       && ranges_from_anti_range (&vr0, &vrtem0, &vrtem1))\n     {\n-      extract_range_from_binary_expr_1 (vr, code, expr_type, &vrtem0, vr1_);\n+      extract_range_from_binary_expr (vr, code, expr_type, &vrtem0, vr1_);\n       if (!vrtem1.undefined_p ())\n \t{\n-\t  value_range vrres;\n-\t  extract_range_from_binary_expr_1 (&vrres, code, expr_type,\t\t\t\t\t    &vrtem1, vr1_);\n+\t  value_range_base vrres;\n+\t  extract_range_from_binary_expr (&vrres, code, expr_type,\n+\t\t\t\t\t  &vrtem1, vr1_);\n \t  vr->union_ (&vrres);\n \t}\n       return;\n@@ -1572,12 +1588,12 @@ extract_range_from_binary_expr_1 (value_range *vr,\n   if (vr1.kind () == VR_ANTI_RANGE\n       && ranges_from_anti_range (&vr1, &vrtem0, &vrtem1))\n     {\n-      extract_range_from_binary_expr_1 (vr, code, expr_type, vr0_, &vrtem0);\n+      extract_range_from_binary_expr (vr, code, expr_type, vr0_, &vrtem0);\n       if (!vrtem1.undefined_p ())\n \t{\n-\t  value_range vrres;\n-\t  extract_range_from_binary_expr_1 (&vrres, code, expr_type,\n-\t\t\t\t\t    vr0_, &vrtem1);\n+\t  value_range_base vrres;\n+\t  extract_range_from_binary_expr (&vrres, code, expr_type,\n+\t\t\t\t\t  vr0_, &vrtem1);\n \t  vr->union_ (&vrres);\n \t}\n       return;\n@@ -1627,9 +1643,9 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t     If both are null, then the result is null. Otherwise they\n \t     are varying.  */\n \t  if (!range_includes_zero_p (&vr0) && !range_includes_zero_p (&vr1))\n-\t    set_value_range_to_nonnull (vr, expr_type);\n+\t    vr->set_nonnull (expr_type);\n \t  else if (range_is_null (&vr0) && range_is_null (&vr1))\n-\t    set_value_range_to_null (vr, expr_type);\n+\t    vr->set_null (expr_type);\n \t  else\n \t    vr->set_varying ();\n \t}\n@@ -1639,9 +1655,9 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t     whether the expression evaluates to non-NULL.  */\n \t  if (!range_includes_zero_p (&vr0)\n \t      || !range_includes_zero_p (&vr1))\n-\t    set_value_range_to_nonnull (vr, expr_type);\n+\t    vr->set_nonnull (expr_type);\n \t  else if (range_is_null (&vr0) && range_is_null (&vr1))\n-\t    set_value_range_to_null (vr, expr_type);\n+\t    vr->set_null (expr_type);\n \t  else\n \t    vr->set_varying ();\n \t}\n@@ -1650,9 +1666,9 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  /* For pointer types, we are really only interested in asserting\n \t     whether the expression evaluates to non-NULL.  */\n \t  if (!range_includes_zero_p (&vr0) && !range_includes_zero_p (&vr1))\n-\t    set_value_range_to_nonnull (vr, expr_type);\n+\t    vr->set_nonnull (expr_type);\n \t  else if (range_is_null (&vr0) || range_is_null (&vr1))\n-\t    set_value_range_to_null (vr, expr_type);\n+\t    vr->set_null (expr_type);\n \t  else\n \t    vr->set_varying ();\n \t}\n@@ -1670,13 +1686,9 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t [0,0] - VR_VARYING is not dropped to varying, but is\n \t calculated as [MIN+1, MAX].  */\n       if (vr0.varying_p ())\n-\tvr0.update (VR_RANGE,\n-\t\t    vrp_val_min (expr_type),\n-\t\t    vrp_val_max (expr_type));\n+\tvr0.set (VR_RANGE, vrp_val_min (expr_type), vrp_val_max (expr_type));\n       if (vr1.varying_p ())\n-\tvr1.update (VR_RANGE,\n-\t\t    vrp_val_min (expr_type),\n-\t\t    vrp_val_max (expr_type));\n+\tvr1.set (VR_RANGE, vrp_val_min (expr_type), vrp_val_max (expr_type));\n \n       const bool minus_p = (code == MINUS_EXPR);\n       tree min_op0 = vr0.min ();\n@@ -1779,8 +1791,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       extract_range_into_wide_ints (&vr1, sign, prec, vr1_min, vr1_max);\n       if (wide_int_range_min_max (wmin, wmax, code, sign, prec,\n \t\t\t\t  vr0_min, vr0_max, vr1_min, vr1_max))\n-\tvr->update (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n-\t\t    wide_int_to_tree (expr_type, wmax));\n+\tvr->set (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n+\t\t wide_int_to_tree (expr_type, wmax));\n       else\n \tvr->set_varying ();\n       return;\n@@ -1812,9 +1824,8 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t useful ranges just from the shift count.  E.g.\n \t\t x >> 63 for signed 64-bit x is always [-1, 0].  */\n \t      if (vr0.kind () != VR_RANGE || vr0.symbolic_p ())\n-\t\tvr0.update (VR_RANGE,\n-\t\t\t    vrp_val_min (expr_type),\n-\t\t\t    vrp_val_max (expr_type));\n+\t\tvr0.set (VR_RANGE, vrp_val_min (expr_type),\n+\t\t\t vrp_val_max (expr_type));\n \t      extract_range_from_multiplicative_op (vr, code, &vr0, &vr1);\n \t      return;\n \t    }\n@@ -1831,7 +1842,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t{\n \t\t  min = wide_int_to_tree (expr_type, res_lb);\n \t\t  max = wide_int_to_tree (expr_type, res_ub);\n-\t\t  vr->set_and_canonicalize (VR_RANGE, min, max, NULL);\n+\t\t  vr->set_and_canonicalize (VR_RANGE, min, max);\n \t\t  return;\n \t\t}\n \t    }\n@@ -1876,15 +1887,13 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  vr->set_undefined ();\n \t  return;\n \t}\n-      set_value_range (vr, VR_RANGE,\n-\t\t       wide_int_to_tree (expr_type, wmin),\n-\t\t       wide_int_to_tree (expr_type, wmax), NULL);\n+      vr->set (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n+\t       wide_int_to_tree (expr_type, wmax));\n       if (extra_range_p)\n \t{\n-\t  value_range extra_range;\n-\t  set_value_range (&extra_range, VR_RANGE,\n-\t\t\t   wide_int_to_tree (expr_type, extra_min),\n-\t\t\t   wide_int_to_tree (expr_type, extra_max), NULL);\n+\t  value_range_base\n+\t    extra_range (VR_RANGE, wide_int_to_tree (expr_type, extra_min),\n+\t\t\t wide_int_to_tree (expr_type, extra_max));\n \t  vr->union_ (&extra_range);\n \t}\n       return;\n@@ -1904,7 +1913,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t\t\t\tvr0_min, vr0_max, vr1_min, vr1_max);\n       min = wide_int_to_tree (expr_type, wmin);\n       max = wide_int_to_tree (expr_type, wmax);\n-      set_value_range (vr, VR_RANGE, min, max, NULL);\n+      vr->set (VR_RANGE, min, max);\n       return;\n     }\n   else if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR)\n@@ -1931,7 +1940,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t    {\n \t      min = wide_int_to_tree (expr_type, wmin);\n \t      max = wide_int_to_tree (expr_type, wmax);\n-\t      set_value_range (vr, VR_RANGE, min, max, NULL);\n+\t      vr->set (VR_RANGE, min, max);\n \t    }\n \t  else\n \t    vr->set_varying ();\n@@ -1949,7 +1958,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t    {\n \t      min = wide_int_to_tree (expr_type, wmin);\n \t      max = wide_int_to_tree (expr_type, wmax);\n-\t      set_value_range (vr, VR_RANGE, min, max, NULL);\n+\t      vr->set (VR_RANGE, min, max);\n \t    }\n \t  else\n \t    vr->set_varying ();\n@@ -1965,7 +1974,7 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t    {\n \t      min = wide_int_to_tree (expr_type, wmin);\n \t      max = wide_int_to_tree (expr_type, wmax);\n-\t      set_value_range (vr, VR_RANGE, min, max, NULL);\n+\t      vr->set (VR_RANGE, min, max);\n \t    }\n \t  else\n \t    vr->set_varying ();\n@@ -2004,22 +2013,22 @@ extract_range_from_binary_expr_1 (value_range *vr,\n       vr->set_varying ();\n     }\n   else\n-    set_value_range (vr, type, min, max, NULL);\n+    vr->set (type, min, max);\n }\n \n /* Extract range information from a unary operation CODE based on\n    the range of its operand *VR0 with type OP0_TYPE with resulting type TYPE.\n    The resulting range is stored in *VR.  */\n \n void\n-extract_range_from_unary_expr (value_range *vr,\n+extract_range_from_unary_expr (value_range_base *vr,\n \t\t\t       enum tree_code code, tree type,\n-\t\t\t       const value_range *vr0_, tree op0_type)\n+\t\t\t       const value_range_base *vr0_, tree op0_type)\n {\n   signop sign = TYPE_SIGN (type);\n   unsigned int prec = TYPE_PRECISION (type);\n-  value_range vr0 = *vr0_;\n-  value_range vrtem0, vrtem1;\n+  value_range_base vr0 = *vr0_;\n+  value_range_base vrtem0, vrtem1;\n \n   /* VRP only operates on integral and pointer types.  */\n   if (!(INTEGRAL_TYPE_P (op0_type)\n@@ -2039,29 +2048,28 @@ extract_range_from_unary_expr (value_range *vr,\n     }\n \n   /* Handle operations that we express in terms of others.  */\n-  if (code == PAREN_EXPR || code == OBJ_TYPE_REF)\n+  if (code == PAREN_EXPR)\n     {\n       /* PAREN_EXPR and OBJ_TYPE_REF are simple copies.  */\n-      vr->deep_copy (&vr0);\n+      *vr = vr0;\n       return;\n     }\n   else if (code == NEGATE_EXPR)\n     {\n       /* -X is simply 0 - X, so re-use existing code that also handles\n          anti-ranges fine.  */\n-      value_range zero;\n-      set_value_range_to_value (&zero, build_int_cst (type, 0), NULL);\n-      extract_range_from_binary_expr_1 (vr, MINUS_EXPR, type, &zero, &vr0);\n+      value_range_base zero;\n+      zero.set (build_int_cst (type, 0));\n+      extract_range_from_binary_expr (vr, MINUS_EXPR, type, &zero, &vr0);\n       return;\n     }\n   else if (code == BIT_NOT_EXPR)\n     {\n       /* ~X is simply -1 - X, so re-use existing code that also handles\n          anti-ranges fine.  */\n-      value_range minusone;\n-      set_value_range_to_value (&minusone, build_int_cst (type, -1), NULL);\n-      extract_range_from_binary_expr_1 (vr, MINUS_EXPR,\n-\t\t\t\t\ttype, &minusone, &vr0);\n+      value_range_base minusone;\n+      minusone.set (build_int_cst (type, -1));\n+      extract_range_from_binary_expr (vr, MINUS_EXPR, type, &minusone, &vr0);\n       return;\n     }\n \n@@ -2073,7 +2081,7 @@ extract_range_from_unary_expr (value_range *vr,\n       extract_range_from_unary_expr (vr, code, type, &vrtem0, op0_type);\n       if (!vrtem1.undefined_p ())\n \t{\n-\t  value_range vrres;\n+\t  value_range_base vrres;\n \t  extract_range_from_unary_expr (&vrres, code, type,\n \t\t\t\t\t &vrtem1, op0_type);\n \t  vr->union_ (&vrres);\n@@ -2096,9 +2104,9 @@ extract_range_from_unary_expr (value_range *vr,\n       if (POINTER_TYPE_P (type) || POINTER_TYPE_P (op0_type))\n \t{\n \t  if (!range_includes_zero_p (&vr0))\n-\t    set_value_range_to_nonnull (vr, type);\n+\t    vr->set_nonnull (type);\n \t  else if (range_is_null (&vr0))\n-\t    set_value_range_to_null (vr, type);\n+\t    vr->set_null (type);\n \t  else\n \t    vr->set_varying ();\n \t  return;\n@@ -2132,7 +2140,7 @@ extract_range_from_unary_expr (value_range *vr,\n \t{\n \t  tree min = wide_int_to_tree (outer_type, wmin);\n \t  tree max = wide_int_to_tree (outer_type, wmax);\n-\t  vr->set_and_canonicalize (VR_RANGE, min, max, NULL);\n+\t  vr->set_and_canonicalize (VR_RANGE, min, max);\n \t}\n       else\n \tvr->set_varying ();\n@@ -2145,9 +2153,8 @@ extract_range_from_unary_expr (value_range *vr,\n       extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n       if (wide_int_range_abs (wmin, wmax, sign, prec, vr0_min, vr0_max,\n \t\t\t      TYPE_OVERFLOW_UNDEFINED (type)))\n-\tset_value_range (vr, VR_RANGE,\n-\t\t\t wide_int_to_tree (type, wmin),\n-\t\t\t wide_int_to_tree (type, wmax), NULL);\n+\tvr->set (VR_RANGE, wide_int_to_tree (type, wmin),\n+\t\t wide_int_to_tree (type, wmax));\n       else\n \tvr->set_varying ();\n       return;\n@@ -6024,24 +6031,21 @@ value_range::intersect_helper (value_range *vr0, const value_range *vr1)\n       return;\n     }\n \n-  /* Save the original vr0 so we can return it as conservative intersection\n-     result when our worker turns things to varying.  */\n-  value_range saved (*vr0);\n-\n   value_range_kind vr0type = vr0->kind ();\n   tree vr0min = vr0->min ();\n   tree vr0max = vr0->max ();\n   intersect_ranges (&vr0type, &vr0min, &vr0max,\n \t\t    vr1->kind (), vr1->min (), vr1->max ());\n   /* Make sure to canonicalize the result though as the inversion of a\n-     VR_RANGE can still be a VR_RANGE.  */\n-  vr0->set_and_canonicalize (vr0type, vr0min, vr0max, vr0->m_equiv);\n+     VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n+     fall back to vr0 when this turns things to varying.  */\n+  value_range tem;\n+  tem.set_and_canonicalize (vr0type, vr0min, vr0max);\n   /* If that failed, use the saved original VR0.  */\n-  if (vr0->varying_p ())\n-    {\n-      *vr0 = saved;\n-      return;\n-    }\n+  if (tem.varying_p ())\n+    return;\n+  vr0->update (tem.kind (), tem.min (), tem.max ());\n+\n   /* If the result is VR_UNDEFINED there is no need to mess with\n      the equivalencies.  */\n   if (vr0->undefined_p ())\n@@ -6168,37 +6172,30 @@ value_range::union_helper (value_range *vr0, const value_range *vr1)\n       return;\n     }\n \n-  value_range saved (*vr0);\n   value_range_kind vr0type = vr0->kind ();\n   tree vr0min = vr0->min ();\n   tree vr0max = vr0->max ();\n   union_ranges (&vr0type, &vr0min, &vr0max,\n \t\tvr1->kind (), vr1->min (), vr1->max ());\n-  *vr0 = value_range (vr0type, vr0min, vr0max);\n-  if (vr0->varying_p ())\n+  /* Work on a temporary so we can still use vr0 when union returns varying.  */\n+  value_range tem;\n+  tem.set_and_canonicalize (vr0type, vr0min, vr0max);\n+  if (tem.varying_p ())\n     {\n       /* Failed to find an efficient meet.  Before giving up and setting\n \t the result to VARYING, see if we can at least derive a useful\n \t anti-range.  */\n-      if (range_includes_zero_p (&saved) == 0\n+      if (range_includes_zero_p (vr0) == 0\n \t  && range_includes_zero_p (vr1) == 0)\n \t{\n-\t  set_value_range_to_nonnull (vr0, saved.type ());\n-\n-\t  /* Since this meet operation did not result from the meeting of\n-\t     two equivalent names, VR0 cannot have any equivalences.  */\n-\t  if (vr0->m_equiv)\n-\t    bitmap_clear (vr0->m_equiv);\n+\t  vr0->set_nonnull (vr0->type ());\n \t  return;\n \t}\n \n       vr0->set_varying ();\n       return;\n     }\n-  vr0->set_and_canonicalize (vr0->kind (), vr0->min (), vr0->max (),\n-\t\t\t     vr0->equiv ());\n-  if (vr0->varying_p ())\n-    return;\n+  vr0->update (tem.kind (), tem.min (), tem.max ());\n \n   /* The resulting set of equivalences is always the intersection of\n      the two sets.  */\n@@ -6877,8 +6874,8 @@ determine_value_range_1 (value_range *vr, tree expr)\n       value_range vr0, vr1;\n       determine_value_range_1 (&vr0, TREE_OPERAND (expr, 0));\n       determine_value_range_1 (&vr1, TREE_OPERAND (expr, 1));\n-      extract_range_from_binary_expr_1 (vr, TREE_CODE (expr), TREE_TYPE (expr),\n-\t\t\t\t\t&vr0, &vr1);\n+      extract_range_from_binary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t\t      &vr0, &vr1);\n     }\n   else if (UNARY_CLASS_P (expr))\n     {\n@@ -6888,7 +6885,7 @@ determine_value_range_1 (value_range *vr, tree expr)\n \t\t\t\t     &vr0, TREE_TYPE (TREE_OPERAND (expr, 0)));\n     }\n   else if (TREE_CODE (expr) == INTEGER_CST)\n-    set_value_range_to_value (vr, expr, NULL);\n+    vr->set (expr);\n   else\n     {\n       value_range_kind kind;\n@@ -6898,8 +6895,8 @@ determine_value_range_1 (value_range *vr, tree expr)\n       if (TREE_CODE (expr) == SSA_NAME\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (expr))\n \t  && (kind = get_range_info (expr, &min, &max)) != VR_VARYING)\n-\tset_value_range (vr, kind, wide_int_to_tree (TREE_TYPE (expr), min),\n-\t\t\t wide_int_to_tree (TREE_TYPE (expr), max), NULL);\n+\tvr->set (kind, wide_int_to_tree (TREE_TYPE (expr), min),\n+\t\t wide_int_to_tree (TREE_TYPE (expr), max));\n       else\n \tvr->set_varying ();\n     }"}, {"sha": "ae7dcc7b58e3d30beac93a42458273959560acae", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -44,6 +44,11 @@ class GTY((for_user)) value_range_base\n   value_range_base ();\n   value_range_base (value_range_kind, tree, tree);\n \n+  void set (value_range_kind, tree, tree);\n+  void set (tree);\n+  void set_nonnull (tree);\n+  void set_null (tree);\n+\n   enum value_range_kind kind () const;\n   tree min () const;\n   tree max () const;\n@@ -71,7 +76,6 @@ class GTY((for_user)) value_range_base\n   void dump () const;\n \n protected:\n-  void set (value_range_kind, tree, tree);\n   void check ();\n \n   enum value_range_kind m_kind;\n@@ -96,8 +100,25 @@ class GTY((user)) value_range : public value_range_base\n  public:\n   value_range ();\n   value_range (const value_range_base &);\n+  /* Deep-copies equiv bitmap argument.  */\n   value_range (value_range_kind, tree, tree, bitmap = NULL);\n+\n+  /* Shallow-copies equiv bitmap.  */\n+  value_range (const value_range &) /* = delete */;\n+  /* Shallow-copies equiv bitmap.  */\n+  value_range& operator=(const value_range&) /* = delete */;\n+\n+  /* Move equiv bitmap from source range.  */\n+  void move (value_range *);\n+\n+  /* Leaves equiv bitmap alone.  */\n   void update (value_range_kind, tree, tree);\n+  /* Deep-copies equiv bitmap argument.  */\n+  void set (value_range_kind, tree, tree, bitmap = NULL);\n+  void set (tree);\n+  void set_nonnull (tree);\n+  void set_null (tree);\n+\n   bool operator== (const value_range &) const;\n   bool operator!= (const value_range &) const;\n   void intersect (const value_range *);\n@@ -114,12 +135,12 @@ class GTY((user)) value_range : public value_range_base\n \n   /* Misc methods.  */\n   void deep_copy (const value_range *);\n-  void set_and_canonicalize (enum value_range_kind, tree, tree, bitmap);\n+  void set_and_canonicalize (enum value_range_kind, tree, tree, bitmap = NULL);\n   void dump (FILE *) const;\n   void dump () const;\n \n  private:\n-  void set (value_range_kind, tree, tree, bitmap);\n+  /* Deep-copies bitmap argument.  */\n   void set_equiv (bitmap);\n   void check ();\n   bool equal_p (const value_range &, bool ignore_equivs) const;\n@@ -225,12 +246,6 @@ extern bool stmt_interesting_for_vrp (gimple *);\n extern bool range_includes_zero_p (const value_range_base *);\n extern bool infer_value_range (gimple *, tree, tree_code *, tree *);\n \n-extern void set_value_range_to_nonnull (value_range *, tree);\n-extern void set_value_range_to_null (value_range *, tree);\n-extern void set_value_range (value_range *, enum value_range_kind, tree,\n-\t\t\t     tree, bitmap);\n-extern void set_value_range_to_value (value_range *, tree, bitmap);\n-\n extern bool vrp_bitmap_equal_p (const_bitmap, const_bitmap);\n \n extern tree value_range_constant_singleton (const value_range_base *);\n@@ -247,14 +262,15 @@ extern int value_inside_range (tree, tree, tree);\n extern tree vrp_val_min (const_tree);\n extern tree vrp_val_max (const_tree);\n \n-extern void extract_range_from_unary_expr (value_range *vr,\n+extern void extract_range_from_unary_expr (value_range_base *vr,\n \t\t\t\t\t   enum tree_code code,\n \t\t\t\t\t   tree type,\n-\t\t\t\t\t   const value_range *vr0_,\n+\t\t\t\t\t   const value_range_base *vr0_,\n \t\t\t\t\t   tree op0_type);\n-extern void extract_range_from_binary_expr_1 (value_range *, enum tree_code,\n-\t\t\t\t\t      tree, const value_range *,\n-\t\t\t\t\t      const value_range *);\n+extern void extract_range_from_binary_expr (value_range_base *,\n+\t\t\t\t\t    enum tree_code,\n+\t\t\t\t\t    tree, const value_range_base *,\n+\t\t\t\t\t    const value_range_base *);\n \n extern bool vrp_operand_equal_p (const_tree, const_tree);\n extern enum value_range_kind intersect_range_with_nonzero_bits"}, {"sha": "86829041358b32618c069ef2baee4f855d9d3fed", "filename": "gcc/vr-values.c", "status": "modified", "additions": 99, "deletions": 89, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -118,7 +118,7 @@ vr_values::get_value_range (const_tree var)\n \t  if (POINTER_TYPE_P (TREE_TYPE (sym))\n \t      && (nonnull_arg_p (sym)\n \t\t  || get_ptr_nonnull (var)))\n-\t    set_value_range_to_nonnull (vr, TREE_TYPE (sym));\n+\t    vr->set_nonnull (TREE_TYPE (sym));\n \t  else if (INTEGRAL_TYPE_P (TREE_TYPE (sym)))\n \t    {\n \t      get_range_info (var, *vr);\n@@ -130,7 +130,7 @@ vr_values::get_value_range (const_tree var)\n \t}\n       else if (TREE_CODE (sym) == RESULT_DECL\n \t       && DECL_BY_REFERENCE (sym))\n-\tset_value_range_to_nonnull (vr, TREE_TYPE (sym));\n+\tvr->set_nonnull (TREE_TYPE (sym));\n     }\n \n   return vr;\n@@ -197,8 +197,8 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n \t  return true;\n \t}\n       else\n-\tset_value_range (old_vr, new_vr->kind (),\n-\t\t\t new_vr->min (), new_vr->max (), new_vr->equiv ());\n+\told_vr->set (new_vr->kind (),\n+\t\t     new_vr->min (), new_vr->max (), new_vr->equiv ());\n     }\n \n   new_vr->equiv_clear ();\n@@ -209,7 +209,7 @@ vr_values::update_value_range (const_tree var, value_range *new_vr)\n /* Return true if value range VR involves exactly one symbol SYM.  */\n \n static bool\n-symbolic_range_based_on_p (value_range *vr, const_tree sym)\n+symbolic_range_based_on_p (value_range_base *vr, const_tree sym)\n {\n   bool neg, min_has_symbol, max_has_symbol;\n   tree inv;\n@@ -672,7 +672,7 @@ vr_values::extract_range_from_ssa_name (value_range *vr, tree var)\n   if (!var_vr->varying_p ())\n     vr->deep_copy (var_vr);\n   else\n-    set_value_range (vr, VR_RANGE, var, var, NULL);\n+    vr->set (var);\n \n   vr->equiv_add (var, get_value_range (var), &vrp_equiv_obstack);\n }\n@@ -688,18 +688,18 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n {\n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n-  value_range vr0, vr1;\n+  value_range_base vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n-    set_value_range_to_value (&vr0, op0, NULL);\n+    vr0.set (op0);\n   else\n     vr0.set_varying ();\n \n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n-    set_value_range_to_value (&vr1, op1, NULL);\n+    vr1.set (op1);\n   else\n     vr1.set_varying ();\n \n@@ -718,7 +718,7 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n \t\t\t   vrp_val_max (expr_type));\n     }\n \n-  extract_range_from_binary_expr_1 (vr, code, expr_type, &vr0, &vr1);\n+  ::extract_range_from_binary_expr (vr, code, expr_type, &vr0, &vr1);\n \n   /* Set value_range for n in following sequence:\n      def = __builtin_memchr (arg, 0, sz)\n@@ -748,7 +748,7 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n \t      wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n \t      tree range_min = build_zero_cst (expr_type);\n \t      tree range_max = wide_int_to_tree (expr_type, wmax - 1);\n-\t      set_value_range (vr, VR_RANGE, range_min, range_max, NULL);\n+\t      vr->set (VR_RANGE, range_min, range_max);\n \t      return;\n \t    }\n      }\n@@ -769,17 +769,17 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n \n       /* Try with VR0 and [-INF, OP1].  */\n       if (is_gimple_min_invariant (minus_p ? vr0.max () : vr0.min ()))\n-\tset_value_range (&n_vr1, VR_RANGE, vrp_val_min (expr_type), op1, NULL);\n+\tn_vr1.set (VR_RANGE, vrp_val_min (expr_type), op1);\n \n       /* Try with VR0 and [OP1, +INF].  */\n       else if (is_gimple_min_invariant (minus_p ? vr0.min () : vr0.max ()))\n-\tset_value_range (&n_vr1, VR_RANGE, op1, vrp_val_max (expr_type), NULL);\n+\tn_vr1.set (VR_RANGE, op1, vrp_val_max (expr_type));\n \n       /* Try with VR0 and [OP1, OP1].  */\n       else\n-\tset_value_range (&n_vr1, VR_RANGE, op1, op1, NULL);\n+\tn_vr1.set (VR_RANGE, op1, op1);\n \n-      extract_range_from_binary_expr_1 (vr, code, expr_type, &vr0, &n_vr1);\n+      ::extract_range_from_binary_expr (vr, code, expr_type, &vr0, &n_vr1);\n     }\n \n   if (vr->varying_p ()\n@@ -793,17 +793,17 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n \n       /* Try with [-INF, OP0] and VR1.  */\n       if (is_gimple_min_invariant (minus_p ? vr1.max () : vr1.min ()))\n-\tset_value_range (&n_vr0, VR_RANGE, vrp_val_min (expr_type), op0, NULL);\n+\tn_vr0.set (VR_RANGE, vrp_val_min (expr_type), op0);\n \n       /* Try with [OP0, +INF] and VR1.  */\n       else if (is_gimple_min_invariant (minus_p ? vr1.min (): vr1.max ()))\n-\tset_value_range (&n_vr0, VR_RANGE, op0, vrp_val_max (expr_type), NULL);\n+\tn_vr0.set (VR_RANGE, op0, vrp_val_max (expr_type));\n \n       /* Try with [OP0, OP0] and VR1.  */\n       else\n-\tset_value_range (&n_vr0, VR_RANGE, op0, op0, NULL);\n+\tn_vr0.set (op0);\n \n-      extract_range_from_binary_expr_1 (vr, code, expr_type, &n_vr0, &vr1);\n+      ::extract_range_from_binary_expr (vr, code, expr_type, &n_vr0, &vr1);\n     }\n \n   /* If we didn't derive a range for MINUS_EXPR, and\n@@ -819,7 +819,7 @@ vr_values::extract_range_from_binary_expr (value_range *vr,\n \t  || (vr1.kind () == VR_ANTI_RANGE\n \t      && vr1.min () == op0\n \t      && vr1.min () == vr1.max ())))\n-      set_value_range_to_nonnull (vr, expr_type);\n+      vr->set_nonnull (expr_type);\n }\n \n /* Extract range information from a unary expression CODE OP0 based on\n@@ -830,14 +830,14 @@ void\n vr_values::extract_range_from_unary_expr (value_range *vr, enum tree_code code,\n \t\t\t\t\t  tree type, tree op0)\n {\n-  value_range vr0;\n+  value_range_base vr0;\n \n   /* Get value ranges for the operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n-    set_value_range_to_value (&vr0, op0, NULL);\n+    vr0.set (op0);\n   else\n     vr0.set_varying ();\n \n@@ -854,26 +854,28 @@ vr_values::extract_range_from_cond_expr (value_range *vr, gassign *stmt)\n   /* Get value ranges for each operand.  For constant operands, create\n      a new value range with the operand to simplify processing.  */\n   tree op0 = gimple_assign_rhs2 (stmt);\n-  value_range vr0;\n+  value_range tem0;\n+  value_range *vr0 = &tem0;\n   if (TREE_CODE (op0) == SSA_NAME)\n-    vr0 = *(get_value_range (op0));\n+    vr0 = get_value_range (op0);\n   else if (is_gimple_min_invariant (op0))\n-    set_value_range_to_value (&vr0, op0, NULL);\n+    tem0.set (op0);\n   else\n-    vr0.set_varying ();\n+    tem0.set_varying ();\n \n   tree op1 = gimple_assign_rhs3 (stmt);\n-  value_range vr1;\n+  value_range tem1;\n+  value_range *vr1 = &tem1;\n   if (TREE_CODE (op1) == SSA_NAME)\n-    vr1 = *(get_value_range (op1));\n+    vr1 = get_value_range (op1);\n   else if (is_gimple_min_invariant (op1))\n-    set_value_range_to_value (&vr1, op1, NULL);\n+    tem1.set (op1);\n   else\n-    vr1.set_varying ();\n+    tem1.set_varying ();\n \n   /* The resulting value range is the union of the operand ranges */\n-  vr->deep_copy (&vr0);\n-  vr->union_ (&vr1);\n+  vr->deep_copy (vr0);\n+  vr->union_ (vr1);\n }\n \n \n@@ -896,7 +898,7 @@ vr_values::extract_range_from_comparison (value_range *vr, enum tree_code code,\n \t type.  */\n       val = fold_convert (type, val);\n       if (is_gimple_min_invariant (val))\n-\tset_value_range_to_value (vr, val, NULL);\n+\tvr->set (val);\n       else\n \tvr->update (VR_RANGE, val, val);\n     }\n@@ -915,18 +917,18 @@ bool\n vr_values::check_for_binary_op_overflow (enum tree_code subcode, tree type,\n \t\t\t\t\t tree op0, tree op1, bool *ovf)\n {\n-  value_range vr0, vr1;\n+  value_range_base vr0, vr1;\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *get_value_range (op0);\n   else if (TREE_CODE (op0) == INTEGER_CST)\n-    set_value_range_to_value (&vr0, op0, NULL);\n+    vr0.set (op0);\n   else\n     vr0.set_varying ();\n \n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *get_value_range (op1);\n   else if (TREE_CODE (op1) == INTEGER_CST)\n-    set_value_range_to_value (&vr1, op1, NULL);\n+    vr1.set (op1);\n   else\n     vr1.set_varying ();\n \n@@ -1044,7 +1046,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t      && TREE_CODE (SSA_NAME_VAR (arg)) == PARM_DECL\n \t      && cfun->after_inlining)\n \t    {\n-\t      set_value_range_to_null (vr, type);\n+\t      vr->set_null (type);\n \t      return;\n \t    }\n \t  break;\n@@ -1185,8 +1187,8 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t  maxi = prec - 1;\n \t  goto bitop_builtin;\n \tbitop_builtin:\n-\t  set_value_range (vr, VR_RANGE, build_int_cst (type, mini),\n-\t\t\t   build_int_cst (type, maxi), NULL);\n+\t  vr->set (VR_RANGE, build_int_cst (type, mini),\n+\t\t   build_int_cst (type, maxi));\n \t  return;\n \tcase CFN_UBSAN_CHECK_ADD:\n \t  subcode = PLUS_EXPR;\n@@ -1213,10 +1215,9 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t      size = targetm.goacc.dim_limit (axis);\n \n \t    tree type = TREE_TYPE (gimple_call_lhs (stmt));\n-\t    set_value_range (vr, VR_RANGE,\n-\t\t\t     build_int_cst (type, is_pos ? 0 : 1),\n-\t\t\t     size ? build_int_cst (type, size - is_pos)\n-\t\t\t          : vrp_val_max (type), NULL);\n+\t    vr->set(VR_RANGE, build_int_cst (type, is_pos ? 0 : 1),\n+\t\t    size\n+\t\t    ? build_int_cst (type, size - is_pos) : vrp_val_max (type));\n \t  }\n \t  return;\n \tcase CFN_BUILT_IN_STRLEN:\n@@ -1230,7 +1231,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\twide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n \t\ttree range_min = build_zero_cst (type);\n \t\ttree range_max = wide_int_to_tree (type, wmax - 1);\n-\t\tset_value_range (vr, VR_RANGE, range_min, range_max, NULL);\n+\t\tvr->set (VR_RANGE, range_min, range_max);\n \t\treturn;\n \t      }\n \t  break;\n@@ -1292,8 +1293,8 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\t    {\n \t\t      /* This is the boolean return value whether compare and\n \t\t\t exchange changed anything or not.  */\n-\t\t      set_value_range (vr, VR_RANGE, build_int_cst (type, 0),\n-\t\t\t\t       build_int_cst (type, 1), NULL);\n+\t\t      vr->set (VR_RANGE, build_int_cst (type, 0),\n+\t\t\t       build_int_cst (type, 1));\n \t\t      return;\n \t\t    }\n \t\t  break;\n@@ -1309,15 +1310,13 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\t      bool ovf = false;\n \t\t      if (check_for_binary_op_overflow (subcode, type,\n \t\t\t\t\t\t\top0, op1, &ovf))\n-\t\t\tset_value_range_to_value (vr,\n-\t\t\t\t\t\t  build_int_cst (type, ovf),\n-\t\t\t\t\t\t  NULL);\n+\t\t\tvr->set (build_int_cst (type, ovf));\n \t\t      else if (TYPE_PRECISION (type) == 1\n \t\t\t       && !TYPE_UNSIGNED (type))\n \t\t\tvr->set_varying ();\n \t\t      else\n-\t\t\tset_value_range (vr, VR_RANGE, build_int_cst (type, 0),\n-\t\t\t\t\t build_int_cst (type, 1), NULL);\n+\t\t\tvr->set (VR_RANGE, build_int_cst (type, 0),\n+\t\t\t\t build_int_cst (type, 1));\n \t\t    }\n \t\t  else if (types_compatible_p (type, TREE_TYPE (op0))\n \t\t\t   && types_compatible_p (type, TREE_TYPE (op1)))\n@@ -1341,7 +1340,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n \t\t\t\t\t\t     type, op0);\n \t\t      extract_range_from_unary_expr (&vr1, NOP_EXPR,\n \t\t\t\t\t\t     type, op1);\n-\t\t      extract_range_from_binary_expr_1 (vr, subcode, type,\n+\t\t      ::extract_range_from_binary_expr (vr, subcode, type,\n \t\t\t\t\t\t\t&vr0, &vr1);\n \t\t      flag_wrapv = saved_flag_wrapv;\n \t\t    }\n@@ -1354,7 +1353,7 @@ vr_values::extract_range_basic (value_range *vr, gimple *stmt)\n       && gimple_stmt_nonnegative_warnv_p (stmt, &sop))\n     set_value_range_to_nonnegative (vr, type);\n   else if (vrp_stmt_computes_nonzero (stmt))\n-    set_value_range_to_nonnull (vr, type);\n+    vr->set_nonnull (type);\n   else\n     vr->set_varying ();\n }\n@@ -1390,7 +1389,7 @@ vr_values::extract_range_from_assignment (value_range *vr, gassign *stmt)\n \t\t\t\t   gimple_assign_rhs2 (stmt));\n   else if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS\n \t   && is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n-    set_value_range_to_value (vr, gimple_assign_rhs1 (stmt), NULL);\n+    vr->set (gimple_assign_rhs1 (stmt));\n   else\n     vr->set_varying ();\n \n@@ -1672,7 +1671,7 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n   /* Like in PR19590, scev can return a constant function.  */\n   if (is_gimple_min_invariant (chrec))\n     {\n-      set_value_range_to_value (vr, chrec, NULL);\n+      vr->set (chrec);\n       return;\n     }\n \n@@ -1751,12 +1750,12 @@ vr_values::adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t      /* Likewise if the addition did.  */\n \t      if (maxvr.kind () == VR_RANGE)\n \t\t{\n-\t\t  value_range initvr;\n+\t\t  value_range_base initvr;\n \n \t\t  if (TREE_CODE (init) == SSA_NAME)\n \t\t    initvr = *(get_value_range (init));\n \t\t  else if (is_gimple_min_invariant (init))\n-\t\t    set_value_range_to_value (&initvr, init, NULL);\n+\t\t    initvr.set (init);\n \t\t  else\n \t\t    return;\n \n@@ -1993,7 +1992,7 @@ vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n \t    }\n \t  else if (is_gimple_min_invariant (tem))\n \t    {\n-\t      set_value_range_to_value (vr, tem, NULL);\n+\t      vr->set (tem);\n \t      return;\n \t    }\n \t}\n@@ -2007,18 +2006,22 @@ vr_values::vrp_visit_assignment_or_call (gimple *stmt, tree *output_p,\n \n /* Helper that gets the value range of the SSA_NAME with version I\n    or a symbolic range containing the SSA_NAME only if the value range\n-   is varying or undefined.  */\n+   is varying or undefined.  Uses TEM as storage for the alternate range.  */\n \n-value_range\n-vr_values::get_vr_for_comparison (int i)\n+value_range *\n+vr_values::get_vr_for_comparison (int i, value_range *tem)\n {\n-  value_range vr = *get_value_range (ssa_name (i));\n+  /* Shallow-copy equiv bitmap.  */\n+  value_range *vr = get_value_range (ssa_name (i));\n \n   /* If name N_i does not have a valid range, use N_i as its own\n      range.  This allows us to compare against names that may\n      have N_i in their ranges.  */\n-  if (vr.varying_p () || vr.undefined_p ())\n-    vr = value_range (VR_RANGE, ssa_name (i), ssa_name (i), NULL);\n+  if (vr->varying_p () || vr->undefined_p ())\n+    {\n+      tem->set (ssa_name (i));\n+      return tem;\n+    }\n \n   return vr;\n }\n@@ -2038,7 +2041,7 @@ vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n   tree retval, t;\n   int used_strict_overflow;\n   bool sop;\n-  value_range equiv_vr;\n+  value_range *equiv_vr, tem_vr;\n \n   /* Get the set of equivalences for VAR.  */\n   e = get_value_range (var)->equiv ();\n@@ -2048,9 +2051,9 @@ vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n   used_strict_overflow = -1;\n \n   /* Compare vars' value range with val.  */\n-  equiv_vr = get_vr_for_comparison (SSA_NAME_VERSION (var));\n+  equiv_vr = get_vr_for_comparison (SSA_NAME_VERSION (var), &tem_vr);\n   sop = false;\n-  retval = compare_range_with_value (comp, &equiv_vr, val, &sop);\n+  retval = compare_range_with_value (comp, equiv_vr, val, &sop);\n   if (retval)\n     used_strict_overflow = sop ? 1 : 0;\n \n@@ -2074,9 +2077,9 @@ vr_values::compare_name_with_value (enum tree_code comp, tree var, tree val,\n \t  && prop_simulate_again_p (SSA_NAME_DEF_STMT (name)))\n \tcontinue;\n \n-      equiv_vr = get_vr_for_comparison (i);\n+      equiv_vr = get_vr_for_comparison (i, &tem_vr);\n       sop = false;\n-      t = compare_range_with_value (comp, &equiv_vr, val, &sop);\n+      t = compare_range_with_value (comp, equiv_vr, val, &sop);\n       if (t)\n \t{\n \t  /* If we get different answers from different members\n@@ -2173,7 +2176,8 @@ vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n       if (! ssa_name (i1))\n \tcontinue;\n \n-      value_range vr1 = get_vr_for_comparison (i1);\n+      value_range tem_vr1;\n+      value_range *vr1 = get_vr_for_comparison (i1, &tem_vr1);\n \n       t = retval = NULL_TREE;\n       EXECUTE_IF_SET_IN_BITMAP (e2, 0, i2, bi2)\n@@ -2183,9 +2187,10 @@ vr_values::compare_names (enum tree_code comp, tree n1, tree n2,\n \n \t  bool sop = false;\n \n-\t  value_range vr2 = get_vr_for_comparison (i2);\n+\t  value_range tem_vr2;\n+\t  value_range *vr2 = get_vr_for_comparison (i2, &tem_vr2);\n \n-\t  t = compare_ranges (comp, &vr1, &vr2, &sop);\n+\t  t = compare_ranges (comp, vr1, vr2, &sop);\n \t  if (t)\n \t    {\n \t      /* If we get different answers from different members\n@@ -2737,7 +2742,8 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n       if (e->flags & EDGE_EXECUTABLE)\n \t{\n \t  tree arg = PHI_ARG_DEF (phi, i);\n-\t  value_range vr_arg;\n+\t  value_range vr_arg_tem;\n+\t  value_range *vr_arg = &vr_arg_tem;\n \n \t  ++edges;\n \n@@ -2750,45 +2756,50 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t\t  && e->flags & EDGE_DFS_BACK)\n \t\tmay_simulate_backedge_again = true;\n \n-\t      vr_arg = *(get_value_range (arg));\n+\t      value_range *vr_arg_ = get_value_range (arg);\n \t      /* Do not allow equivalences or symbolic ranges to leak in from\n \t\t backedges.  That creates invalid equivalencies.\n \t\t See PR53465 and PR54767.  */\n \t      if (e->flags & EDGE_DFS_BACK)\n \t\t{\n-\t\t  if (!vr_arg.varying_p () && !vr_arg.undefined_p ())\n+\t\t  if (!vr_arg_->varying_p () && !vr_arg_->undefined_p ())\n \t\t    {\n-\t\t      vr_arg.equiv_clear ();\n-\t\t      if (vr_arg.symbolic_p ())\n-\t\t\tvr_arg.set_varying ();\n+\t\t      vr_arg_tem.set (vr_arg_->kind (), vr_arg_->min (),\n+\t\t\t\t      vr_arg_->max (), NULL);\n+\t\t      if (vr_arg_tem.symbolic_p ())\n+\t\t\tvr_arg_tem.set_varying ();\n \t\t    }\n+\t\t  else\n+\t\t    vr_arg = vr_arg_;\n \t\t}\n \t      /* If the non-backedge arguments range is VR_VARYING then\n \t\t we can still try recording a simple equivalence.  */\n-\t      else if (vr_arg.varying_p ())\n-\t\tvr_arg = value_range (VR_RANGE, arg, arg, NULL);\n+\t      else if (vr_arg_->varying_p ())\n+\t\tvr_arg_tem.set (arg);\n+\t      else\n+\t\tvr_arg = vr_arg_;\n \t    }\n \t  else\n \t    {\n \t      if (TREE_OVERFLOW_P (arg))\n \t\targ = drop_tree_overflow (arg);\n \n-\t      vr_arg = value_range (VR_RANGE, arg, arg);\n+\t      vr_arg_tem.set (arg);\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"\\t\");\n \t      print_generic_expr (dump_file, arg, dump_flags);\n \t      fprintf (dump_file, \": \");\n-\t      dump_value_range (dump_file, &vr_arg);\n+\t      dump_value_range (dump_file, vr_arg);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n \t  if (first)\n-\t    vr_result->deep_copy (&vr_arg);\n+\t    vr_result->deep_copy (vr_arg);\n \t  else\n-\t    vr_result->union_ (&vr_arg);\n+\t    vr_result->union_ (vr_arg);\n \t  first = false;\n \n \t  if (vr_result->varying_p ())\n@@ -2860,8 +2871,7 @@ vr_values::extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n \t\t\t\t   vrp_val_max (vr_result->type ()),\n \t\t\t\t   build_int_cst (vr_result->type (), 1));\n \n-      *vr_result = value_range (vr_result->kind (), new_min, new_max,\n-\t\t\t\tvr_result->equiv ());\n+      vr_result->update (vr_result->kind (), new_min, new_max);\n \n       /* If we dropped either bound to +-INF then if this is a loop\n \t PHI node SCEV may known more about its value-range.  */\n@@ -3219,22 +3229,22 @@ vr_values::simplify_bit_ops_using_ranges (gimple_stmt_iterator *gsi,\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n   tree op = NULL_TREE;\n-  value_range vr0, vr1;\n+  value_range_base vr0, vr1;\n   wide_int may_be_nonzero0, may_be_nonzero1;\n   wide_int must_be_nonzero0, must_be_nonzero1;\n   wide_int mask;\n \n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n-    set_value_range_to_value (&vr0, op0, NULL);\n+    vr0.set (op0);\n   else\n     return false;\n \n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n-    set_value_range_to_value (&vr1, op1, NULL);\n+    vr1.set (op1);\n   else\n     return false;\n "}, {"sha": "6785cb68fa76957296a1e4e803dd25bd6cb0269c", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27922d518d3c81c85df4b2d391bc54e85dab01f5/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=27922d518d3c81c85df4b2d391bc54e85dab01f5", "patch": "@@ -75,7 +75,7 @@ class vr_values\n   bool vrp_stmt_computes_nonzero (gimple *);\n   bool op_with_boolean_value_range_p (tree);\n   bool check_for_binary_op_overflow (enum tree_code, tree, tree, tree, bool *);\n-  value_range get_vr_for_comparison (int);\n+  value_range *get_vr_for_comparison (int, value_range *);\n   tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool);\n   tree compare_names (enum tree_code, tree, tree, bool *);\n   bool two_valued_val_range_p (tree, tree *, tree *);"}]}