{"sha": "b03149e1369b687b5ff9fc7d1fa831137f898018", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAzMTQ5ZTEzNjliNjg3YjVmZjlmYzdkMWZhODMxMTM3Zjg5ODAxOA==", "commit": {"author": {"name": "Jie Zhang", "email": "jie.zhang@analog.com", "date": "2006-05-31T16:46:15Z"}, "committer": {"name": "Jie Zhang", "email": "jiez@gcc.gnu.org", "date": "2006-05-31T16:46:15Z"}, "message": "bfin-protos.h (bfin_hardware_loop): Declare.\n\n\t* config/bfin/bfin-protos.h (bfin_hardware_loop): Declare.\n\t* config/bfin/bfin.c (basic-block.h): Include.\n\t(struct machine_function): New.\n\t(bfin_init_machine_status): New.\n\t(override_options): Initialize init_machine_status.\n\t(bfin_hardware_loop): New.\n\t(MAX_LOOP_DEPTH, MAX_LOOP_LENGTH): Define.\n\t(DEF_VEC_P (loop_info)): New.\n\t(DEF_VEC_ALLOC_P (loop_info,heap)): New.\n\t(struct loop_info): New.\n\t(loop_info): New typedef.\n\t(struct loop_work): New.\n\t(loop_work): New typedef.\n\t(DEF_VEC_O (loop_work)): New.\n\t(DEF_VEC_ALLOC_O (loop_work,heap)): New.\n\t(bfin_dump_loops): New.\n\t(bfin_bb_in_loop): New.\n\t(bfin_scan_loop): New.\n\t(bfin_optimize_loop): New.\n\t(bfin_reorg_loops): New.\n\t(bfin_reorg): Use bfin_reorg_loops.\n\t* config/bfin/bfin.h (FIRST_PSEUDO_REGISTER): Adjust for adding\n\tloop registers.\n\t(I_REGNO_P): Simplify.\n\t(DP_REGNO_P, DPREG_P): New macros.\n\t(REGISTER_NAMES, FIXED_REGISTERS, CALL_USED_REGISTERS,\n\tREG_ALLOC_ORDER): Add LT0, LT1, LC0, LC1, LB0, LB1.\n\t(enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS):\n\tAdd LT_REGS, LC_REGS, LB_REGS.\n\t(REG_CLASS_FROM_LETTER): Add 't' for LT_REGS, 'k' for LC_REGS,\n\t'l' for LB_REGS.\n\t(REGNO_REG_CLASS): Deal with loop registers.\n\t* config/bfin/bfin.md: Add comment for 't', 'k', 'l' constraint\n\tletters.\n\t(REG_LT0, REG_LT1, REG_LC0, REG_LC1, REG_LB0, REG_LB1):\n\tNew constants for loop registers.\n\t(UNSPEC_LSETUP_END): New.\n\t(seq_insns): New define_attr. Set it for appropriate insns.\n\t(movsi_insn): Add alternatives for move from/to\n\tloop count registers.\n\t(doloop_end): New define_expand.\n\t(loop_end): New define_insn.\n\t(define_split for bad doloop_end): New.\n\t(lsetup_with_autoinit): New define_insn.\n\t(lsetup_without_autoinit): New define_insn.\n\t(rep_movsi, rep_movhi): Clobber LT1, LC1, LB1.\n\t* config/bfin/predicates.md (lc_register_operand): New.\n\t(lt_register_operand): New.\n\t(lb_register_operand): New.\n\t(nondp_register_operand): New.\n\t(nondp_reg_or_memory_operand): New.\n        * doc/md.texi: Document Blackfin new 't', 'k', 'l' constraint letters.\n\nFrom-SVN: r114274", "tree": {"sha": "230b13d3e5a5908bbca6a831dabea1b17eca476b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/230b13d3e5a5908bbca6a831dabea1b17eca476b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b03149e1369b687b5ff9fc7d1fa831137f898018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03149e1369b687b5ff9fc7d1fa831137f898018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b03149e1369b687b5ff9fc7d1fa831137f898018", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03149e1369b687b5ff9fc7d1fa831137f898018/comments", "author": {"login": "jiez-adi", "id": 103514486, "node_id": "U_kgDOBiuBdg", "avatar_url": "https://avatars.githubusercontent.com/u/103514486?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jiez-adi", "html_url": "https://github.com/jiez-adi", "followers_url": "https://api.github.com/users/jiez-adi/followers", "following_url": "https://api.github.com/users/jiez-adi/following{/other_user}", "gists_url": "https://api.github.com/users/jiez-adi/gists{/gist_id}", "starred_url": "https://api.github.com/users/jiez-adi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jiez-adi/subscriptions", "organizations_url": "https://api.github.com/users/jiez-adi/orgs", "repos_url": "https://api.github.com/users/jiez-adi/repos", "events_url": "https://api.github.com/users/jiez-adi/events{/privacy}", "received_events_url": "https://api.github.com/users/jiez-adi/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5dd59f65cae29a0f1607598002405d488d2602a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dd59f65cae29a0f1607598002405d488d2602a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dd59f65cae29a0f1607598002405d488d2602a4"}], "stats": {"total": 1120, "additions": 1074, "deletions": 46}, "files": [{"sha": "6268ad04e09fce0c4d068c87b09b3e391ed46681", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b03149e1369b687b5ff9fc7d1fa831137f898018", "patch": "@@ -1,3 +1,58 @@\n+2006-05-31  Jie Zhang  <jie.zhang@analog.com>\n+\n+\t* config/bfin/bfin-protos.h (bfin_hardware_loop): Declare.\n+\t* config/bfin/bfin.c (basic-block.h): Include.\n+\t(struct machine_function): New.\n+\t(bfin_init_machine_status): New.\n+\t(override_options): Initialize init_machine_status.\n+\t(bfin_hardware_loop): New.\n+\t(MAX_LOOP_DEPTH, MAX_LOOP_LENGTH): Define.\n+\t(DEF_VEC_P (loop_info)): New.\n+\t(DEF_VEC_ALLOC_P (loop_info,heap)): New.\n+\t(struct loop_info): New.\n+\t(loop_info): New typedef.\n+\t(struct loop_work): New.\n+\t(loop_work): New typedef.\n+\t(DEF_VEC_O (loop_work)): New.\n+\t(DEF_VEC_ALLOC_O (loop_work,heap)): New.\n+\t(bfin_dump_loops): New.\n+\t(bfin_bb_in_loop): New.\n+\t(bfin_scan_loop): New.\n+\t(bfin_optimize_loop): New.\n+\t(bfin_reorg_loops): New.\n+\t(bfin_reorg): Use bfin_reorg_loops.\n+\t* config/bfin/bfin.h (FIRST_PSEUDO_REGISTER): Adjust for adding\n+\tloop registers.\n+\t(I_REGNO_P): Simplify.\n+\t(DP_REGNO_P, DPREG_P): New macros.\n+\t(REGISTER_NAMES, FIXED_REGISTERS, CALL_USED_REGISTERS,\n+\tREG_ALLOC_ORDER): Add LT0, LT1, LC0, LC1, LB0, LB1.\n+\t(enum reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS):\n+\tAdd LT_REGS, LC_REGS, LB_REGS.\n+\t(REG_CLASS_FROM_LETTER): Add 't' for LT_REGS, 'k' for LC_REGS,\n+\t'l' for LB_REGS.\n+\t(REGNO_REG_CLASS): Deal with loop registers.\n+\t* config/bfin/bfin.md: Add comment for 't', 'k', 'l' constraint\n+\tletters.\n+\t(REG_LT0, REG_LT1, REG_LC0, REG_LC1, REG_LB0, REG_LB1):\n+\tNew constants for loop registers.\n+\t(UNSPEC_LSETUP_END): New.\n+\t(seq_insns): New define_attr. Set it for appropriate insns.\n+\t(movsi_insn): Add alternatives for move from/to\n+\tloop count registers.\n+\t(doloop_end): New define_expand.\n+\t(loop_end): New define_insn.\n+\t(define_split for bad doloop_end): New.\n+\t(lsetup_with_autoinit): New define_insn.\n+\t(lsetup_without_autoinit): New define_insn.\n+\t(rep_movsi, rep_movhi): Clobber LT1, LC1, LB1.\n+\t* config/bfin/predicates.md (lc_register_operand): New.\n+\t(lt_register_operand): New.\n+\t(lb_register_operand): New.\n+\t(nondp_register_operand): New.\n+\t(nondp_reg_or_memory_operand): New.\n+\t* doc/md.texi: Document Blackfin new 't', 'k', 'l' constraint letters.\n+\n 2006-05-31  Jie Zhang  <jie.zhang@analog.com>\n \n \t* config/bfin/bfin.c (bfin_delegitimize_address): New."}, {"sha": "bbd1eeb7aa9c54a7c4993716a5b2ab1982fed86e", "filename": "gcc/config/bfin/bfin-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin-protos.h?ref=b03149e1369b687b5ff9fc7d1fa831137f898018", "patch": "@@ -83,6 +83,7 @@ extern void output_push_multiple (rtx, rtx *);\n extern void output_pop_multiple (rtx, rtx *);\n extern int bfin_hard_regno_rename_ok (unsigned int, unsigned int);\n extern rtx bfin_return_addr_rtx (int);\n+extern void bfin_hardware_loop (void);\n #undef  Mmode \n \n #endif"}, {"sha": "94c16784f32d6777be2e0ca566ae67d2fa6c878c", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 790, "deletions": 1, "changes": 791, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=b03149e1369b687b5ff9fc7d1fa831137f898018", "patch": "@@ -51,6 +51,14 @@\n #include \"bfin-protos.h\"\n #include \"tm-preds.h\"\n #include \"gt-bfin.h\"\n+#include \"basic-block.h\"\n+\n+/* A C structure for machine-specific, per-function data.\n+   This is added to the cfun structure.  */\n+struct machine_function GTY(())\n+{\n+  int has_hardware_loops;\n+};\n \n /* Test and compare insns in bfin.md store the information needed to\n    generate branch and scc insns here.  */\n@@ -1957,6 +1965,16 @@ bfin_handle_option (size_t code, const char *arg, int value)\n     }\n }\n \n+static struct machine_function *\n+bfin_init_machine_status (void)\n+{\n+  struct machine_function *f;\n+\n+  f = ggc_alloc_cleared (sizeof (struct machine_function));\n+\n+  return f;\n+}\n+\n /* Implement the macro OVERRIDE_OPTIONS.  */\n \n void\n@@ -1987,6 +2005,8 @@ override_options (void)\n     flag_pic = 0;\n \n   flag_schedule_insns = 0;\n+\n+  init_machine_status = bfin_init_machine_status;\n }\n \n /* Return the destination address of BRANCH.\n@@ -2704,6 +2724,771 @@ bfin_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \n   return cost;\n }\n+\n+\f\n+/* Increment the counter for the number of loop instructions in the\n+   current function.  */\n+\n+void\n+bfin_hardware_loop (void)\n+{\n+  cfun->machine->has_hardware_loops++;\n+}\n+\n+/* Maxium loop nesting depth.  */\n+#define MAX_LOOP_DEPTH 2\n+\n+/* Maxium size of a loop.  */\n+#define MAX_LOOP_LENGTH 4096\n+\n+/* We need to keep a vector of loops */\n+typedef struct loop_info *loop_info;\n+DEF_VEC_P (loop_info);\n+DEF_VEC_ALLOC_P (loop_info,heap);\n+\n+/* Information about a loop we have found (or are in the process of\n+   finding).  */\n+struct loop_info GTY (())\n+{\n+  /* loop number, for dumps */\n+  int loop_no;\n+\n+  /* Predecessor block of the loop.   This is the one that falls into\n+     the loop and contains the initialization instruction.  */\n+  basic_block predecessor;\n+\n+  /* First block in the loop.  This is the one branched to by the loop_end\n+     insn.  */\n+  basic_block head;\n+\n+  /* Last block in the loop (the one with the loop_end insn).  */\n+  basic_block tail;\n+\n+  /* The successor block of the loop.  This is the one the loop_end insn\n+     falls into.  */\n+  basic_block successor;\n+\n+  /* The last instruction in the tail.  */\n+  rtx last_insn;\n+\n+  /* The loop_end insn.  */\n+  rtx loop_end;\n+\n+  /* The iteration register.  */\n+  rtx iter_reg;\n+\n+  /* The new initialization insn.  */\n+  rtx init;\n+\n+  /* The new initialization instruction.  */\n+  rtx loop_init;\n+\n+  /* The new label placed at the beginning of the loop. */\n+  rtx start_label;\n+\n+  /* The new label placed at the end of the loop. */\n+  rtx end_label;\n+\n+  /* The length of the loop.  */\n+  int length;\n+\n+  /* The nesting depth of the loop.  Set to -1 for a bad loop.  */\n+  int depth;\n+\n+  /* True if we have visited this loop.  */\n+  int visited;\n+\n+  /* True if this loop body clobbers any of LC0, LT0, or LB0.  */\n+  int clobber_loop0;\n+\n+  /* True if this loop body clobbers any of LC1, LT1, or LB1.  */\n+  int clobber_loop1;\n+\n+  /* Next loop in the graph. */\n+  struct loop_info *next;\n+\n+  /* Immediate outer loop of this loop.  */\n+  struct loop_info *outer;\n+\n+  /* Vector of blocks only within the loop, (excluding those within\n+     inner loops).  */\n+  VEC (basic_block,heap) *blocks;\n+\n+  /* Vector of inner loops within this loop  */\n+  VEC (loop_info,heap) *loops;\n+};\n+\n+/* Information used during loop detection.  */\n+typedef struct loop_work GTY(())\n+{\n+  /* Basic block to be scanned.  */\n+  basic_block block;\n+\n+  /* Loop it will be within.  */\n+  loop_info loop;\n+} loop_work;\n+\n+/* Work list.  */\n+DEF_VEC_O (loop_work);\n+DEF_VEC_ALLOC_O (loop_work,heap);\n+\n+static void\n+bfin_dump_loops (loop_info loops)\n+{\n+  loop_info loop;\n+\n+  for (loop = loops; loop; loop = loop->next)\n+    {\n+      loop_info i;\n+      basic_block b;\n+      unsigned ix;\n+\n+      fprintf (dump_file, \";; loop %d: \", loop->loop_no);\n+      fprintf (dump_file, \"{head:%d, depth:%d}\", loop->head->index, loop->depth);\n+\n+      fprintf (dump_file, \" blocks: [ \");\n+      for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, b); ix++)\n+\tfprintf (dump_file, \"%d \", b->index);\n+      fprintf (dump_file, \"] \");\n+\n+      fprintf (dump_file, \" inner loops: [ \");\n+      for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, i); ix++)\n+\tfprintf (dump_file, \"%d \", i->loop_no);\n+      fprintf (dump_file, \"]\\n\");\n+    }\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Scan the blocks of LOOP (and its inferiors) looking for basic block\n+   BB. Return true, if we find it.  */\n+\n+static bool\n+bfin_bb_in_loop (loop_info loop, basic_block bb)\n+{\n+  unsigned ix;\n+  loop_info inner;\n+  basic_block b;\n+\n+  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, b); ix++)\n+    if (b == bb)\n+      return true;\n+\n+  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n+    if (bfin_bb_in_loop (inner, bb))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Scan the blocks of LOOP (and its inferiors) looking for uses of\n+   REG.  Return true, if we find any.  Don't count the loop's loop_end\n+   insn if it matches LOOP_END.  */\n+\n+static bool\n+bfin_scan_loop (loop_info loop, rtx reg, rtx loop_end)\n+{\n+  unsigned ix;\n+  loop_info inner;\n+  basic_block bb;\n+\n+  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n+    {\n+      rtx insn;\n+\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\t  if (insn == loop_end)\n+\t    continue;\n+\t  if (reg_mentioned_p (reg, PATTERN (insn)))\n+\t    return true;\n+\t}\n+    }\n+  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n+    if (bfin_scan_loop (inner, reg, NULL_RTX))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Optimize LOOP.  */\n+\n+static void\n+bfin_optimize_loop (loop_info loop)\n+{\n+  basic_block bb;\n+  loop_info inner, outer;\n+  rtx insn, init_insn, last_insn, nop_insn;\n+  rtx loop_init, start_label, end_label;\n+  rtx reg_lc0, reg_lc1, reg_lt0, reg_lt1, reg_lb0, reg_lb1;\n+  rtx iter_reg;\n+  rtx lc_reg, lt_reg, lb_reg;\n+  rtx seq;\n+  int length;\n+  unsigned ix;\n+  int inner_depth = 0;\n+  int inner_num;\n+  int bb_num;\n+\n+  if (loop->visited)\n+    return;\n+\n+  loop->visited = 1;\n+\n+  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n+    {\n+      if (inner->loop_no == loop->loop_no)\n+\tloop->depth = -1;\n+      else\n+\tbfin_optimize_loop (inner);\n+\n+      if (inner->depth < 0 || inner->depth > MAX_LOOP_DEPTH)\n+\t{\n+\t  inner->outer = NULL;\n+\t  VEC_ordered_remove (loop_info, loop->loops, ix);\n+\t}\n+\n+      if (inner_depth < inner->depth)\n+\tinner_depth = inner->depth;\n+\n+      loop->clobber_loop0 |= inner->clobber_loop0;\n+      loop->clobber_loop1 |= inner->clobber_loop1;\n+    }\n+\n+  if (loop->depth < 0)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d bad when found\\n\", loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  loop->depth = inner_depth + 1;\n+  if (loop->depth > MAX_LOOP_DEPTH)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d too deep\\n\", loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  /* Make sure we only have one entry point.  */\n+  if (EDGE_COUNT (loop->head->preds) == 2)\n+    {\n+      loop->predecessor = EDGE_PRED (loop->head, 0)->src;\n+      if (loop->predecessor == loop->tail)\n+\t/* We wanted the other predecessor.  */\n+\tloop->predecessor = EDGE_PRED (loop->head, 1)->src;\n+\n+      /* We can only place a loop insn on a fall through edge of a\n+\t single exit block.  */\n+      if (EDGE_COUNT (loop->predecessor->succs) != 1\n+\t  || !(EDGE_SUCC (loop->predecessor, 0)->flags & EDGE_FALLTHRU)\n+\t  /* If loop->predecessor is in loop, loop->head is not really\n+\t     the head of the loop.  */\n+\t  || bfin_bb_in_loop (loop, loop->predecessor))\n+\tloop->predecessor = NULL;\n+    }\n+\n+  if (loop->predecessor == NULL)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d has bad predecessor\\n\", loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  /* Get the loop iteration register.  */\n+  iter_reg = loop->iter_reg;\n+\n+  if (!DPREG_P (iter_reg))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d iteration count NOT in PREG or DREG\\n\",\n+\t\t loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  /* Check if start_label appears before loop_end and calculate the\n+     offset between them.  We calculate the length of instructions\n+     conservatively.  */\n+  length = 0;\n+  for (insn = loop->start_label;\n+       insn && insn != loop->loop_end;\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (JUMP_P (insn) && any_condjump_p (insn) && !optimize_size)\n+\t{\n+\t  if (TARGET_CSYNC_ANOMALY)\n+\t    length += 8;\n+\t  else if (TARGET_SPECLD_ANOMALY)\n+\t    length += 6;\n+\t}\n+      else if (LABEL_P (insn))\n+\t{\n+\t  if (TARGET_CSYNC_ANOMALY)\n+\t    length += 4;\n+\t}\n+\n+      if (INSN_P (insn))\n+\tlength += get_attr_length (insn);\n+    }\n+\n+  if (!insn)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d start_label not before loop_end\\n\",\n+\t\t loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  loop->length = length;\n+  if (loop->length > MAX_LOOP_LENGTH)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d too long\\n\", loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  /* Scan all the blocks to make sure they don't use iter_reg.  */\n+  if (bfin_scan_loop (loop, iter_reg, loop->loop_end))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d uses iterator\\n\", loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  /* Scan all the insns to see if the loop body clobber\n+     any hardware loop registers. */\n+\n+  reg_lc0 = gen_rtx_REG (SImode, REG_LC0);\n+  reg_lc1 = gen_rtx_REG (SImode, REG_LC1);\n+  reg_lt0 = gen_rtx_REG (SImode, REG_LT0);\n+  reg_lt1 = gen_rtx_REG (SImode, REG_LT1);\n+  reg_lb0 = gen_rtx_REG (SImode, REG_LB0);\n+  reg_lb1 = gen_rtx_REG (SImode, REG_LB1);\n+\n+  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n+    {\n+      rtx insn;\n+\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\n+\t  if (reg_set_p (reg_lc0, insn)\n+\t      || reg_set_p (reg_lt0, insn)\n+\t      || reg_set_p (reg_lb0, insn))\n+\t    loop->clobber_loop0 = 1;\n+\t  \n+\t  if (reg_set_p (reg_lc1, insn)\n+\t      || reg_set_p (reg_lt1, insn)\n+\t      || reg_set_p (reg_lb1, insn))\n+\t    loop->clobber_loop1 |= 1;\n+\t}\n+    }\n+\n+  if ((loop->clobber_loop0 && loop->clobber_loop1)\n+      || (loop->depth == MAX_LOOP_DEPTH && loop->clobber_loop0))\n+    {\n+      loop->depth = MAX_LOOP_DEPTH + 1;\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d no loop reg available\\n\",\n+\t\t loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  /* There should be an instruction before the loop_end instruction\n+     in the same basic block. And the instruction must not be\n+     - JUMP\n+     - CONDITIONAL BRANCH\n+     - CALL\n+     - CSYNC\n+     - SSYNC\n+     - Returns (RTS, RTN, etc.)  */\n+\n+  bb = loop->tail;\n+  last_insn = PREV_INSN (loop->loop_end);\n+\n+  while (1)\n+    {\n+      for (; last_insn != PREV_INSN (BB_HEAD (bb));\n+\t   last_insn = PREV_INSN (last_insn))\n+\tif (INSN_P (last_insn))\n+\t  break;\n+\n+      if (last_insn != PREV_INSN (BB_HEAD (bb)))\n+\tbreak;\n+\n+      if (single_pred_p (bb)\n+\t  && single_pred (bb) != ENTRY_BLOCK_PTR)\n+\t{\n+\t  bb = single_pred (bb);\n+\t  last_insn = BB_END (bb);\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  last_insn = NULL_RTX;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!last_insn)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d has no last instruction\\n\",\n+\t\t loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  if (JUMP_P (last_insn))\n+    {\n+      loop_info inner = bb->aux;\n+      if (inner\n+\t  && inner->outer == loop\n+\t  && inner->loop_end == last_insn\n+\t  && inner->depth == 1)\n+\t/* This jump_insn is the exact loop_end of an inner loop\n+\t   and to be optimized away. So use the inner's last_insn.  */\n+\tlast_insn = inner->last_insn;\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d has bad last instruction\\n\",\n+\t\t     loop->loop_no);\n+\t  goto bad_loop;\n+\t}\n+    }\n+  else if (CALL_P (last_insn)\n+\t   || get_attr_type (last_insn) == TYPE_SYNC\n+\t   || recog_memoized (last_insn) == CODE_FOR_return_internal)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d has bad last instruction\\n\",\n+\t\t loop->loop_no);\n+      goto bad_loop;\n+    }\n+\n+  if (GET_CODE (PATTERN (last_insn)) == ASM_INPUT\n+      || asm_noperands (PATTERN (last_insn)) >= 0\n+      || get_attr_seq_insns (last_insn) == SEQ_INSNS_MULTI)\n+    {\n+      nop_insn = emit_insn_after (gen_nop (), last_insn);\n+      last_insn = nop_insn;\n+    }\n+\n+  loop->last_insn = last_insn;\n+\n+  /* The loop is good for replacement.  */\n+  start_label = loop->start_label;\n+  end_label = gen_label_rtx ();\n+  iter_reg = loop->iter_reg;\n+\n+  if (loop->depth == 1 && !loop->clobber_loop1)\n+    {\n+      lc_reg = reg_lc1;\n+      lt_reg = reg_lt1;\n+      lb_reg = reg_lb1;\n+      loop->clobber_loop1 = 1;\n+    }\n+  else\n+    {\n+      lc_reg = reg_lc0;\n+      lt_reg = reg_lt0;\n+      lb_reg = reg_lb0;\n+      loop->clobber_loop0 = 1;\n+    }\n+\n+  /* If iter_reg is a DREG, we need generate an instruction to load\n+     the loop count into LC register. */\n+  if (D_REGNO_P (REGNO (iter_reg)))\n+    {\n+      init_insn = gen_movsi (lc_reg, iter_reg);\n+      loop_init = gen_lsetup_without_autoinit (lt_reg, start_label,\n+\t\t\t\t\t       lb_reg, end_label,\n+\t\t\t\t\t       lc_reg);\n+    }\n+  else if (P_REGNO_P (REGNO (iter_reg)))\n+    {\n+      init_insn = NULL_RTX;\n+      loop_init = gen_lsetup_with_autoinit (lt_reg, start_label,\n+\t\t\t\t\t    lb_reg, end_label,\n+\t\t\t\t\t    lc_reg, iter_reg);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  loop->init = init_insn;\n+  loop->end_label = end_label;\n+  loop->loop_init = loop_init;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; replacing loop %d initializer with\\n\",\n+\t       loop->loop_no);\n+      print_rtl_single (dump_file, loop->loop_init);\n+      fprintf (dump_file, \";; replacing loop %d terminator with\\n\",\n+\t       loop->loop_no);\n+      print_rtl_single (dump_file, loop->loop_end);\n+    }\n+\n+  start_sequence ();\n+\n+  if (loop->init != NULL_RTX)\n+    emit_insn (loop->init);\n+  emit_insn(loop->loop_init);\n+  emit_label (loop->start_label);\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  emit_insn_after (seq, BB_END (loop->predecessor));\n+  delete_insn (loop->loop_end);\n+\n+  /* Insert the loop end label before the last instruction of the loop.  */\n+  emit_label_before (loop->end_label, loop->last_insn);\n+\n+  return;\n+\n+bad_loop:\n+\n+  if (dump_file)\n+    fprintf (dump_file, \";; loop %d is bad\\n\", loop->loop_no);\n+\n+  /* Mark this loop bad.  */\n+  if (loop->depth <= MAX_LOOP_DEPTH)\n+    loop->depth = -1;\n+\n+  outer = loop->outer;\n+\n+  /* Move all inner loops to loop's outer loop.  */\n+  inner_num = VEC_length (loop_info, loop->loops);\n+  if (inner_num)\n+    {\n+      loop_info l;\n+\n+      if (outer)\n+\tVEC_reserve (loop_info, heap, outer->loops, inner_num);\n+\n+      for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, l); ix++)\n+\t{\n+\t  l->outer = outer;\n+\t  if (outer)\n+\t    VEC_quick_push (loop_info, outer->loops, l);\n+\t}\n+\n+      VEC_free (loop_info, heap, loop->loops);\n+    }\n+\n+  /* Move all blocks to loop's outer loop.  */\n+  bb_num = VEC_length (basic_block, loop->blocks);\n+  if (bb_num)\n+    {\n+      basic_block b;\n+\n+      if (outer)\n+\tVEC_reserve (basic_block, heap, outer->blocks, bb_num);\n+\n+      for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, b); ix++)\n+\t{\n+\t  b->aux = outer;\n+\t  if (outer)\n+\t    VEC_quick_push (basic_block, outer->blocks, b);\n+\t}\n+\n+      VEC_free (basic_block, heap, loop->blocks);\n+    }\n+\n+  if (DPREG_P (loop->iter_reg))\n+    {\n+      /* If loop->iter_reg is a DREG or PREG, we can split it here\n+\t without scratch register.  */\n+      rtx insn;\n+\n+      emit_insn_before (gen_addsi3 (loop->iter_reg,\n+\t\t\t\t    loop->iter_reg,\n+\t\t\t\t    constm1_rtx),\n+\t\t\tloop->loop_end);\n+\n+      emit_insn_before (gen_cmpsi (loop->iter_reg, const0_rtx),\n+\t\t\tloop->loop_end);\n+\n+      insn = emit_jump_insn_before (gen_bne (loop->start_label),\n+\t\t\t\t    loop->loop_end);\n+\n+      JUMP_LABEL (insn) = loop->start_label;\n+      LABEL_NUSES (loop->start_label)++;\n+      delete_insn (loop->loop_end);\n+    }\n+}\n+\n+static void\n+bfin_reorg_loops (FILE *dump_file)\n+{\n+  basic_block bb;\n+  loop_info loops = NULL;\n+  loop_info loop;\n+  int nloops = 0;\n+  unsigned dwork = 0;\n+  VEC (loop_work,heap) *works = VEC_alloc (loop_work,heap,20);\n+  loop_work *work;\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* Find all the possible loop tails.  This means searching for every\n+     loop_end instruction.  For each one found, create a loop_info\n+     structure and add the head block to the work list. */\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx tail = BB_END (bb);\n+\n+      while (GET_CODE (tail) == NOTE)\n+\ttail = PREV_INSN (tail);\n+\n+      bb->aux = NULL;\n+      if (recog_memoized (tail) == CODE_FOR_loop_end)\n+\t{\n+\t  /* A possible loop end */\n+\n+\t  loop = XNEW (struct loop_info);\n+\t  loop->next = loops;\n+\t  loops = loop;\n+\t  loop->tail = bb;\n+\t  loop->head = BRANCH_EDGE (bb)->dest;\n+\t  loop->successor = FALLTHRU_EDGE (bb)->dest;\n+\t  loop->predecessor = NULL;\n+\t  loop->loop_end = tail;\n+\t  loop->last_insn = NULL_RTX;\n+\t  loop->iter_reg = SET_DEST (XVECEXP (PATTERN (tail), 0, 1));\n+\t  loop->depth = loop->length = 0;\n+\t  loop->visited = 0;\n+\t  loop->clobber_loop0 = loop->clobber_loop1 = 0;\n+\t  loop->blocks = VEC_alloc (basic_block, heap, 20);\n+\t  VEC_quick_push (basic_block, loop->blocks, bb);\n+\t  loop->outer = NULL;\n+\t  loop->loops = NULL;\n+\t  loop->loop_no = nloops++;\n+\n+\t  loop->init = loop->loop_init = NULL_RTX;\n+\t  loop->start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (tail), 0, 0)), 1), 0);\n+\t  loop->end_label = NULL_RTX;\n+\n+\t  work = VEC_safe_push (loop_work, heap, works, NULL);\n+\t  work->block = loop->head;\n+\t  work->loop = loop;\n+\n+\t  bb->aux = loop;\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \";; potential loop %d ending at\\n\",\n+\t\t       loop->loop_no);\n+\t      print_rtl_single (dump_file, tail);\n+\t    }\n+\t}\n+    }\n+\n+  /*  Now find all the closed loops.\n+      until work list empty,\n+       if block's auxptr is set\n+         if != loop slot\n+           if block's loop's start != block\n+\t     mark loop as bad\n+\t   else\n+             append block's loop's fallthrough block to worklist\n+\t     increment this loop's depth\n+       else if block is exit block\n+         mark loop as bad\n+       else\n+\t  set auxptr\n+\t  for each target of block\n+\t    add to worklist */\n+  while (VEC_iterate (loop_work, works, dwork++, work))\n+    {\n+      loop = work->loop;\n+      bb = work->block;\n+      if (bb == EXIT_BLOCK_PTR)\n+\t/* We've reached the exit block.  The loop must be bad. */\n+\tloop->depth = -1;\n+      else if (!bb->aux)\n+\t{\n+\t  /* We've not seen this block before.  Add it to the loop's\n+\t     list and then add each successor to the work list.  */\n+\t  bb->aux = loop;\n+\t  VEC_safe_push (basic_block, heap, loop->blocks, bb);\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      if (!VEC_space (loop_work, works, 1))\n+\t\t{\n+\t\t  if (dwork)\n+\t\t    {\n+\t\t      VEC_block_remove (loop_work, works, 0, dwork);\n+\t\t      dwork = 0;\n+\t\t    }\n+\t\t  else\n+\t\t    VEC_reserve (loop_work, heap, works, 1);\n+\t\t}\n+\t      work = VEC_quick_push (loop_work, works, NULL);\n+\t      work->block = EDGE_SUCC (bb, ei.index)->dest;\n+\t      work->loop = loop;\n+\t    }\n+\t}\n+      else if (bb->aux != loop)\n+\t{\n+\t  /* We've seen this block in a different loop.  If it's not\n+\t     the other loop's head, then this loop must be bad.\n+\t     Otherwise, the other loop might be a nested loop, so\n+\t     continue from that loop's successor.  */\n+\t  loop_info other = bb->aux;\n+\n+\t  if (other->head != bb)\n+\t    loop->depth = -1;\n+\t  else\n+\t    {\n+\t      other->outer = loop;\n+\t      VEC_safe_push (loop_info, heap, loop->loops, other);\n+\t      work = VEC_safe_push (loop_work, heap, works, NULL);\n+\t      work->loop = loop;\n+\t      work->block = other->successor;\n+\t    }\n+\t}\n+    }\n+  VEC_free (loop_work, heap, works);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; All loops found:\\n\\n\");\n+      bfin_dump_loops (loops);\n+    }\n+  \n+  /* Now apply the optimizations.  */\n+  for (loop = loops; loop; loop = loop->next)\n+    bfin_optimize_loop (loop);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; After hardware loops optimization:\\n\\n\");\n+      bfin_dump_loops (loops);\n+    }\n+\n+  /* Free up the loop structures */\n+  while (loops)\n+    {\n+      loop = loops;\n+      loops = loop->next;\n+      VEC_free (loop_info, heap, loop->loops);\n+      VEC_free (basic_block, heap, loop->blocks);\n+      XDELETE (loop);\n+    }\n+\n+  if (dump_file)\n+    print_rtl (dump_file, get_insns ());\n+}\n+\n \f\n /* We use the machine specific reorg pass for emitting CSYNC instructions\n    after conditional branches as needed.\n@@ -2731,7 +3516,11 @@ bfin_reorg (void)\n   rtx insn, last_condjump = NULL_RTX;\n   int cycles_since_jump = INT_MAX;\n \n-  if (! TARGET_SPECLD_ANOMALY || ! TARGET_CSYNC_ANOMALY)\n+  /* Doloop optimization */\n+  if (cfun->machine->has_hardware_loops)\n+    bfin_reorg_loops (dump_file);\n+\n+  if (! TARGET_SPECLD_ANOMALY && ! TARGET_CSYNC_ANOMALY)\n     return;\n \n   /* First pass: find predicted-false branches; if something after them"}, {"sha": "732a9b8a74f16026e4fbb0681cbc922b198e9fe5", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=b03149e1369b687b5ff9fc7d1fa831137f898018", "patch": "@@ -268,15 +268,17 @@ extern const char *bfin_library_id_string;\n    5  return address registers RETS/I/X/N/E\n    1  arithmetic status register (ASTAT).  */\n \n-#define FIRST_PSEUDO_REGISTER 44\n+#define FIRST_PSEUDO_REGISTER 50\n \n-#define PREG_P(X) (REG_P (X) && P_REGNO_P (REGNO (X)))\n-#define IREG_P(X) (REG_P (X) && I_REGNO_P (REGNO (X)))\n-#define ADDRESS_REGNO_P(X) ((X) >= REG_P0 && (X) <= REG_M3)\n #define D_REGNO_P(X) ((X) <= REG_R7)\n #define P_REGNO_P(X) ((X) >= REG_P0 && (X) <= REG_P7)\n-#define I_REGNO_P(X) \\\n-  ((X) == REG_I0 || (X) == REG_I1 || (X) == REG_I2 || (X) == REG_I3)\n+#define I_REGNO_P(X) ((X) >= REG_I0 && (X) <= REG_I3)\n+#define DP_REGNO_P(X) (D_REGNO_P (X) || P_REGNO_P (X))\n+#define ADDRESS_REGNO_P(X) ((X) >= REG_P0 && (X) <= REG_M3)\n+#define DREG_P(X) (REG_P (X) && D_REGNO_P (REGNO (X)))\n+#define PREG_P(X) (REG_P (X) && P_REGNO_P (REGNO (X)))\n+#define IREG_P(X) (REG_P (X) && I_REGNO_P (REGNO (X)))\n+#define DPREG_P(X) (REG_P (X) && DP_REGNO_P (REGNO (X)))\n \n #define REGISTER_NAMES { \\\n   \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \\\n@@ -286,7 +288,8 @@ extern const char *bfin_library_id_string;\n   \"A0\", \"A1\", \\\n   \"CC\", \\\n   \"RETS\", \"RETI\", \"RETX\", \"RETN\", \"RETE\", \"ASTAT\", \"SEQSTAT\", \"USP\", \\\n-  \"ARGP\" \\\n+  \"ARGP\", \\\n+  \"LT0\", \"LT1\", \"LC0\", \"LC1\", \"LB0\", \"LB1\" \\\n }\n \n #define SHORT_REGISTER_NAMES { \\\n@@ -316,8 +319,10 @@ extern const char *bfin_library_id_string;\n { 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 1, 0,    \\\n /*i0 i1 i2 i3 b0 b1 b2 b3   l0 l1 l2 l3 m0 m1 m2 m3 */ \\\n   0, 0, 0, 0, 0, 0, 0, 0,   1, 1, 1, 1, 0, 0, 0, 0,    \\\n-/*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp */ \\\n-  0, 0, 0, 1, 1, 1, 1, 1,   1, 1, 1, 1\t \\\n+/*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp lt0/1 lc0/1 */ \\\n+  0, 0, 0, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,    \\\n+/*lb0/1 */ \\\n+  1, 1  \\\n }\n \n /* 1 for registers not available across function calls.\n@@ -332,8 +337,10 @@ extern const char *bfin_library_id_string;\n { 1, 1, 1, 1, 0, 0, 0, 0,   1, 1, 1, 0, 0, 0, 1, 0, \\\n /*i0 i1 i2 i3 b0 b1 b2 b3   l0 l1 l2 l3 m0 m1 m2 m3 */ \\\n   1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \\\n-/*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp */ \\\n-  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1\t \\\n+/*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp lt0/1 lc0/1 */ \\\n+  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1, \\\n+/*lb0/1 */ \\\n+  1, 1  \\\n }\n \n /* Order in which to allocate registers.  Each register must be\n@@ -350,7 +357,8 @@ extern const char *bfin_library_id_string;\n   REG_L0, REG_L1, REG_L2, REG_L3, REG_M0, REG_M1, REG_M2, REG_M3, \\\n   REG_RETS, REG_RETI, REG_RETX, REG_RETN, REG_RETE,\t\t  \\\n   REG_ASTAT, REG_SEQSTAT, REG_USP, \t\t\t\t  \\\n-  REG_CC, REG_ARGP\t\t\t\t\t\t  \\\n+  REG_CC, REG_ARGP,\t\t\t\t\t\t  \\\n+  REG_LT0, REG_LT1, REG_LC0, REG_LC1, REG_LB0, REG_LB1\t\t  \\\n }\n \n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n@@ -410,6 +418,9 @@ enum reg_class\n   IPREGS,\n   DPREGS,\n   MOST_REGS,\n+  LT_REGS,\n+  LC_REGS,\n+  LB_REGS,\n   PROLOGUE_REGS,\n   NON_A_CC_REGS,\n   ALL_REGS, LIM_REG_CLASSES\n@@ -443,6 +454,9 @@ enum reg_class\n    \"IPREGS\",\t\t\\\n    \"DPREGS\",\t\t\\\n    \"MOST_REGS\",\t\t\\\n+   \"LT_REGS\",\t\t\\\n+   \"LC_REGS\",\t\t\\\n+   \"LB_REGS\",\t\t\\\n    \"PROLOGUE_REGS\",\t\\\n    \"NON_A_CC_REGS\",\t\\\n    \"ALL_REGS\" }\n@@ -484,9 +498,12 @@ enum reg_class\n     { 0x000fff00,    0x800 },\t\t/* IPREGS */\t\\\n     { 0x0000ffff,    0x800 },\t\t/* DPREGS */   \\\n     { 0xffffffff,    0x800 },\t\t/* MOST_REGS */\\\n-    { 0x00000000,    0x7f8 },\t\t/* PROLOGUE_REGS */\\\n-    { 0xffffffff,    0xff8 },\t\t/* NON_A_CC_REGS */\\\n-    { 0xffffffff,    0xfff }}\t\t/* ALL_REGS */\n+    { 0x00000000,    0x3000 },\t\t/* LT_REGS */\\\n+    { 0x00000000,    0xc000 },\t\t/* LC_REGS */\\\n+    { 0x00000000,    0x30000 },\t\t/* LB_REGS */\\\n+    { 0x00000000,    0x3f7f8 },\t\t/* PROLOGUE_REGS */\\\n+    { 0xffffffff,    0x3fff8 },\t\t/* NON_A_CC_REGS */\\\n+    { 0xffffffff,    0x3ffff }}\t\t/* ALL_REGS */\n \n #define IREG_POSSIBLE_P(OUTER)\t\t\t\t     \\\n   ((OUTER) == POST_INC || (OUTER) == PRE_INC\t\t     \\\n@@ -535,6 +552,9 @@ enum reg_class\n    (LETTER) == 'f' ? MREGS : \t\t\\\n    (LETTER) == 'c' ? CIRCREGS :         \\\n    (LETTER) == 'C' ? CCREGS : \t\t\\\n+   (LETTER) == 't' ? LT_REGS : \t\t\\\n+   (LETTER) == 'k' ? LC_REGS : \t\t\\\n+   (LETTER) == 'l' ? LB_REGS : \t\t\\\n    (LETTER) == 'x' ? MOST_REGS :\t\\\n    (LETTER) == 'y' ? PROLOGUE_REGS :\t\\\n    (LETTER) == 'w' ? NON_A_CC_REGS :\t\\\n@@ -554,6 +574,9 @@ enum reg_class\n  : (REGNO) >= REG_B0 && (REGNO) <= REG_B3 ? BREGS\t\\\n  : (REGNO) >= REG_M0 && (REGNO) <= REG_M3 ? MREGS\t\\\n  : (REGNO) == REG_A0 || (REGNO) == REG_A1 ? AREGS\t\\\n+ : (REGNO) == REG_LT0 || (REGNO) == REG_LT1 ? LT_REGS\t\\\n+ : (REGNO) == REG_LC0 || (REGNO) == REG_LC1 ? LC_REGS\t\\\n+ : (REGNO) == REG_LB0 || (REGNO) == REG_LB1 ? LB_REGS\t\\\n  : (REGNO) == REG_CC ? CCREGS\t\t\t\t\\\n  : (REGNO) >= REG_RETS ? PROLOGUE_REGS\t\t\t\\\n  : NO_REGS)"}, {"sha": "2c6e0c7a11be0db1069da5eec2fd2e0512800594", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 158, "deletions": 30, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=b03149e1369b687b5ff9fc7d1fa831137f898018", "patch": "@@ -49,6 +49,9 @@\n ;     B\n ;     c (i0..i3,m0..m3) CIRCREGS\n ;     C (CC)            CCREGS\n+;     t  (lt0,lt1)\n+;     k  (lc0,lc1)\n+;     l  (lb0,lb1)\n ;\n \n ;; Define constants for hard registers.\n@@ -109,7 +112,14 @@\n    (REG_SEQSTAT 41)\n    (REG_USP 42)\n \n-   (REG_ARGP 43)])\n+   (REG_ARGP 43)\n+\n+   (REG_LT0 44)\n+   (REG_LT1 45)\n+   (REG_LC0 46)\n+   (REG_LC1 47)\n+   (REG_LB0 48)\n+   (REG_LB1 49)])\n \n ;; Constants used in UNSPECs and UNSPEC_VOLATILEs.\n \n@@ -124,7 +134,8 @@\n    (UNSPEC_MUL_WITH_FLAG 6)\n    (UNSPEC_MAC_WITH_FLAG 7)\n    (UNSPEC_MOVE_FDPIC 8)\n-   (UNSPEC_FUNCDESC_GOT17M4 9)])\n+   (UNSPEC_FUNCDESC_GOT17M4 9)\n+   (UNSPEC_LSETUP_END 10)])\n \n (define_constants\n   [(UNSPEC_VOLATILE_EH_RETURN 0)\n@@ -243,6 +254,12 @@\n \n \t(const_int 2)))\n \n+\n+;; Classify the insns into those that are one instruction and those that\n+;; are more than one in sequence.\n+(define_attr \"seq_insns\" \"single,multi\"\n+  (const_string \"single\"))\n+\n ;; Conditional moves\n \n (define_expand \"movsicc\"\n@@ -268,7 +285,8 @@\n     if cc %0 =%2; /* movsicc-1b */\n     if !cc %0 =%1; if cc %0=%2; /* movsicc-1 */\"\n   [(set_attr \"length\" \"2,2,4\")\n-   (set_attr \"type\" \"move\")])\n+   (set_attr \"type\" \"move\")\n+   (set_attr \"seq_insns\" \"*,*,multi\")])\n \n (define_insn \"*movsicc_insn2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=da,da,da\")\n@@ -283,7 +301,8 @@\n    if cc %0 =%1; /* movsicc-2a */\n    if cc %0 =%1; if !cc %0=%2; /* movsicc-1 */\"\n   [(set_attr \"length\" \"2,2,4\")\n-   (set_attr \"type\" \"move\")])\n+   (set_attr \"type\" \"move\")\n+   (set_attr \"seq_insns\" \"*,*,multi\")])\n \n ;; Insns to load HIGH and LO_SUM\n \n@@ -376,7 +395,8 @@\n    %0 = CC;\n    R0 = R0 | R0; CC = AC0;\"\n   [(set_attr \"type\" \"move,mvi,mcld,mcst,compare,compare,alu0\")\n-   (set_attr \"length\" \"2,2,*,*,2,2,4\")])\n+   (set_attr \"length\" \"2,2,*,*,2,2,4\")\n+   (set_attr \"seq_insns\" \"*,*,*,*,*,*,multi\")])\n \n (define_insn \"movpdi\"\n   [(set (match_operand:PDI 0 \"nonimmediate_operand\" \"=e,<,e\")\n@@ -386,7 +406,8 @@\n    %0 = %1;\n    %0 = %x1; %0 = %w1;\n    %w0 = %1; %x0 = %1;\"\n-  [(set_attr \"type\" \"move,mcst,mcld\")])\n+  [(set_attr \"type\" \"move,mcst,mcld\")\n+   (set_attr \"seq_insns\" \"*,multi,multi\")])\n \n (define_insn \"load_accumulator\"\n   [(set (match_operand:PDI 0 \"register_operand\" \"=e\")\n@@ -429,12 +450,14 @@\n ;; The first alternative is used to make reload choose a limited register\n ;; class when faced with a movsi_insn that had its input operand replaced\n ;; with a PLUS.  We generally require fewer secondary reloads this way.\n-(define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=da,x*y,da,x,x,x,da,mr\")\n-        (match_operand:SI 1 \"general_operand\" \"da,x*y,xKs7,xKsh,xKuh,ix,mr,da\"))]\n \n+(define_insn \"*movsi_insn\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=da,x*y,*k,da,da,x,x,x,da,mr\")\n+\t(match_operand:SI 1 \"general_operand\" \"da,x*y,da,*k,xKs7,xKsh,xKuh,ix,mr,da\"))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n-  \"@\n+ \"@\n+   %0 = %1;\n+   %0 = %1;\n    %0 = %1;\n    %0 = %1;\n    %0 = %1 (X);\n@@ -443,8 +466,8 @@\n    #\n    %0 = %1;\n    %0 = %1;\"\n-  [(set_attr \"type\" \"move,move,mvi,mvi,mvi,*,mcld,mcst\")\n-   (set_attr \"length\" \"2,2,2,4,4,*,*,*\")])\n+  [(set_attr \"type\" \"move,move,move,move,mvi,mvi,mvi,*,mcld,mcst\")\n+   (set_attr \"length\" \"2,2,2,2,2,4,4,*,*,*\")])\n \n (define_insn_and_split \"*movv2hi_insn\"\n   [(set (match_operand:V2HI 0 \"nonimmediate_operand\" \"=da,da,d,dm\")\n@@ -776,7 +799,8 @@\n \t\t\t(match_operand:DI 2 \"register_operand\" \"d\")))]\n   \"\"\n   \"%0 = %1 <op> %2;\\\\n\\\\t%H0 = %H1 <op> %H2;\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"*<optab>di_zesidi_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -785,7 +809,8 @@\n \t\t\t(match_operand:DI 1 \"register_operand\" \"d\")))]\n   \"\"\n   \"%0 = %1 <op>  %2;\\\\n\\\\t%H0 = <high_result>;\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"*<optab>di_sesdi_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -795,7 +820,8 @@\n    (clobber (match_scratch:SI 3 \"=&d\"))]\n   \"\"\n   \"%0 = %1 <op> %2;\\\\n\\\\t%3 = %2;\\\\n\\\\t%3 >>>= 31;\\\\n\\\\t%H0 = %H1 <op> %3;\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"negdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -804,14 +830,16 @@\n    (clobber (reg:CC REG_CC))]\n   \"\"\n   \"%2 = 0; %2 = %2 - %1; cc = ac0; cc = !cc; %2 = cc;\\\\n\\\\t%0 = -%1; %H0 = -%H1; %H0 = %H0 - %2;\"\n-  [(set_attr \"length\" \"16\")])\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (not:DI (match_operand:DI 1 \"register_operand\" \"d\")))]\n   \"\"\n   \"%0 = ~%1;\\\\n\\\\t%H0 = ~%H1;\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n ;; DImode zero and sign extend patterns\n \n@@ -833,14 +861,16 @@\n         (zero_extend:DI (match_operand:QI 1 \"register_operand\" \"d\")))]\n   \"\"\n   \"%0 = %T1 (Z);\\\\n\\\\t%H0 = 0;\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"zero_extendhidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (zero_extend:DI (match_operand:HI 1 \"register_operand\" \"d\")))]\n   \"\"\n   \"%0 = %h1 (Z);\\\\n\\\\t%H0 = 0;\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn_and_split \"extendsidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -896,7 +926,8 @@\n    %0 += %2; cc = ac0; %3 = cc; %H0 = %H0 + %3;\n    %0 = %0 + %2; cc = ac0; %3 = cc; %H0 = %H0 + %H2; %H0 = %H0 + %3;\"\n   [(set_attr \"type\" \"alu0\")\n-   (set_attr \"length\" \"10,8,10\")])\n+   (set_attr \"length\" \"10,8,10\")\n+   (set_attr \"seq_insns\" \"multi,multi,multi\")])\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n@@ -905,7 +936,8 @@\n    (clobber (reg:CC 34))]\n   \"\"\n   \"%0 = %1-%2;\\\\n\\\\tcc = ac0;\\\\n\\\\t%H0 = %H1-%H2;\\\\n\\\\tif cc jump 1f;\\\\n\\\\t%H0 += -1;\\\\n\\\\t1:\"\n-  [(set_attr \"length\" \"10\")])\n+  [(set_attr \"length\" \"10\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"*subdi_di_zesidi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -916,7 +948,8 @@\n    (clobber (reg:CC 34))]\n   \"\"\n   \"%0 = %1 - %2;\\\\n\\\\tcc = ac0;\\\\n\\\\tcc = ! cc;\\\\n\\\\t%3 = cc;\\\\n\\\\t%H0 = %H1 - %3;\"\n-  [(set_attr \"length\" \"10\")])\n+  [(set_attr \"length\" \"10\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"*subdi_zesidi_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -927,7 +960,8 @@\n    (clobber (reg:CC 34))]\n   \"\"\n   \"%0 = %2 - %1;\\\\n\\\\tcc = ac0;\\\\n\\\\tcc = ! cc;\\\\n\\\\t%3 = cc;\\\\n\\\\t%3 = -%3;\\\\n\\\\t%H0 = %3 - %H1\"\n-  [(set_attr \"length\" \"12\")])\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"*subdi_di_sesidi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -938,7 +972,8 @@\n    (clobber (reg:CC 34))]\n   \"\"\n   \"%0 = %1 - %2;\\\\n\\\\tcc = ac0;\\\\n\\\\t%3 = %2;\\\\n\\\\t%3 >>>= 31;\\\\n\\\\t%H0 = %H1 - %3;\\\\n\\\\tif cc jump 1f;\\\\n\\\\t%H0 += -1;\\\\n\\\\t1:\"\n-  [(set_attr \"length\" \"14\")])\n+  [(set_attr \"length\" \"14\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"*subdi_sesidi_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -949,7 +984,8 @@\n    (clobber (reg:CC 34))]\n   \"\"\n   \"%0 = %2 - %1;\\\\n\\\\tcc = ac0;\\\\n\\\\t%3 = %2;\\\\n\\\\t%3 >>>= 31;\\\\n\\\\t%H0 = %3 - %H1;\\\\n\\\\tif cc jump 1f;\\\\n\\\\t%H0 += -1;\\\\n\\\\t1:\"\n-  [(set_attr \"length\" \"14\")])\n+  [(set_attr \"length\" \"14\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n ;; Combined shift/add instructions\n \n@@ -1496,6 +1532,89 @@\n   \"jump (%0);\"\n   [(set_attr \"type\" \"misc\")])\n \n+;;  Hardware loop\n+\n+; operand 0 is the loop count pseudo register\n+; operand 1 is the number of loop iterations or 0 if it is unknown\n+; operand 2 is the maximum number of loop iterations\n+; operand 3 is the number of levels of enclosed loops\n+; operand 4 is the label to jump to at the top of the loop\n+(define_expand \"doloop_end\"\n+  [(parallel [(set (pc) (if_then_else\n+\t\t\t  (ne (match_operand:SI 0 \"\" \"\")\n+\t\t\t      (const_int 1))\n+\t\t\t  (label_ref (match_operand 4 \"\" \"\"))\n+\t\t\t  (pc)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (const_int -1)))\n+\t      (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n+\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  \"\"\n+  {bfin_hardware_loop ();})\n+\n+(define_insn \"loop_end\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"nonimmediate_operand\" \"+a*d,*b*h*f,m\")\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 0)\n+\t(plus (match_dup 0)\n+\t      (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n+   (clobber (match_scratch:SI 2 \"=X,&r,&r\"))]\n+  \"\"\n+  \"@\n+   /* loop end %0 %l1 */\n+   #\n+   #\"\n+  [(set_attr \"length\" \"6,10,14\")])\n+\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"nondp_reg_or_memory_operand\" \"\")\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 0)\n+\t(plus (match_dup 0)\n+\t      (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_LSETUP_END)\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 0))\n+   (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))\n+   (set (match_dup 0) (match_dup 2))\n+   (set (reg:BI REG_CC) (eq:BI (match_dup 2) (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (eq (reg:BI REG_CC)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_dup 1))\n+\t\t      (pc)))]\n+  \"\")\n+\n+(define_insn \"lsetup_with_autoinit\"\n+  [(set (match_operand:SI 0 \"lt_register_operand\" \"=t\")\n+\t(label_ref (match_operand 1 \"\" \"\")))\n+   (set (match_operand:SI 2 \"lb_register_operand\" \"=l\")\n+\t(label_ref (match_operand 3 \"\" \"\")))\n+   (set (match_operand:SI 4 \"lc_register_operand\" \"=k\")\n+\t(match_operand:SI 5 \"register_operand\" \"a\"))]\n+  \"\"\n+  \"LSETUP (%1, %3) %4 = %5;\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"lsetup_without_autoinit\"\n+  [(set (match_operand:SI 0 \"lt_register_operand\" \"=t\")\n+\t(label_ref (match_operand 1 \"\" \"\")))\n+   (set (match_operand:SI 2 \"lb_register_operand\" \"=l\")\n+\t(label_ref (match_operand 3 \"\" \"\")))\n+   (use (match_operand:SI 4 \"lc_register_operand\" \"k\"))]\n+  \"\"\n+  \"LSETUP (%1, %3) %4;\"\n+  [(set_attr \"length\" \"4\")])\n+\n ;;  Call instructions..\n \n ;; The explicit MEM inside the UNSPEC prevents the compiler from moving\n@@ -1760,11 +1879,15 @@\n    (set (mem:BLK (match_dup 3))\n \t(mem:BLK (match_dup 4)))\n    (use (match_dup 2))\n-   (clobber (match_scratch:HI 5 \"=&d\"))]\n+   (clobber (match_scratch:HI 5 \"=&d\"))\n+   (clobber (reg:SI REG_LT1))\n+   (clobber (reg:SI REG_LC1))\n+   (clobber (reg:SI REG_LB1))]\n   \"\"\n   \"%5 = [%4++]; lsetup (1f, 1f) LC1 = %2; 1: MNOP || [%3++] = %5 || %5 = [%4++]; [%3++] = %5;\"\n   [(set_attr \"type\" \"misc\")\n-   (set_attr \"length\" \"16\")])\n+   (set_attr \"length\" \"16\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_insn \"rep_movhi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&a\")\n@@ -1779,11 +1902,15 @@\n    (set (mem:BLK (match_dup 3))\n \t(mem:BLK (match_dup 4)))\n    (use (match_dup 2))\n-   (clobber (match_scratch:HI 5 \"=&d\"))]\n+   (clobber (match_scratch:HI 5 \"=&d\"))\n+   (clobber (reg:SI REG_LT1))\n+   (clobber (reg:SI REG_LC1))\n+   (clobber (reg:SI REG_LB1))]\n   \"\"\n   \"%h5 = W[%4++]; lsetup (1f, 1f) LC1 = %2; 1: MNOP || W [%3++] = %5 || %h5 = W [%4++]; W [%3++] = %5;\"\n   [(set_attr \"type\" \"misc\")\n-   (set_attr \"length\" \"16\")])\n+   (set_attr \"length\" \"16\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n (define_expand \"movmemsi\"\n   [(match_operand:BLK 0 \"general_operand\" \"\")\n@@ -2315,7 +2442,8 @@\n   \"\"\n   \"if !cc jump 4 (bp); excpt 3;\"\n   [(set_attr \"type\" \"misc\")\n-   (set_attr \"length\" \"4\")])\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"seq_insns\" \"multi\")])\n \n ;;; Vector instructions\n "}, {"sha": "1415ea0ab06b5dc4464fa3a0e3740b898344a575", "filename": "gcc/config/bfin/predicates.md", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03149e1369b687b5ff9fc7d1fa831137f898018/gcc%2Fconfig%2Fbfin%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fpredicates.md?ref=b03149e1369b687b5ff9fc7d1fa831137f898018", "patch": "@@ -76,12 +76,44 @@\n   return 1;\n })\n \n+;; Return nonzero if OP is a LC register.\n+(define_predicate \"lc_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == REG_LC0 || REGNO (op) == REG_LC1\")))\n+\n+;; Return nonzero if OP is a LT register.\n+(define_predicate \"lt_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == REG_LT0 || REGNO (op) == REG_LT1\")))\n+\n+;; Return nonzero if OP is a LB register.\n+(define_predicate \"lb_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == REG_LB0 || REGNO (op) == REG_LB1\")))\n+\n ;; Return nonzero if OP is a register or a 7 bit signed constant.\n (define_predicate \"reg_or_7bit_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (and (match_code \"const_int\")\n \t    (match_test \"CONST_7BIT_IMM_P (INTVAL (op))\"))))\n \n+;; Return nonzero if OP is a register other than DREG and PREG.\n+(define_predicate \"nondp_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || !DP_REGNO_P (regno));\n+})\n+\n+;; Return nonzero if OP is a register other than DREG and PREG, or MEM.\n+(define_predicate \"nondp_reg_or_memory_operand\"\n+  (ior (match_operand 0 \"nondp_register_operand\")\n+       (match_operand 0 \"memory_operand\")))\n+\n ;; Used for secondary reloads, this function returns 1 if OP is of the\n ;; form (plus (fp) (const_int)).\n (define_predicate \"fp_plus_const_operand\""}]}