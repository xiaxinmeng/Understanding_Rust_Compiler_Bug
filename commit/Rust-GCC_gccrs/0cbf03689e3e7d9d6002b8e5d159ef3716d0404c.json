{"sha": "0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNiZjAzNjg5ZTNlN2Q5ZDYwMDJiOGU1ZDE1OWVmMzcxNmQwNDA0Yw==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-07-26T12:20:46Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-07-26T12:32:53Z"}, "message": "PR fortran/93308/93963/94327/94331/97046 problems raised by descriptor handling\n\nFortran: Fix attributes and bounds in ISO_Fortran_binding.\n\n2021-07-26  Jos\u00e9 Rui Faustino de Sousa  <jrfsousa@gmail.com>\n\t    Tobias Burnus  <tobias@codesourcery.com>\n\n\tPR fortran/93308\n\tPR fortran/93963\n\tPR fortran/94327\n\tPR fortran/94331\n\tPR fortran/97046\n\ngcc/fortran/ChangeLog:\n\n\t* trans-decl.c (convert_CFI_desc): Only copy out the descriptor\n\tif necessary.\n\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): Updated attribute\n\thandling which reflect a previous intermediate version of the\n\tstandard. Only copy out the descriptor if necessary.\n\nlibgfortran/ChangeLog:\n\n\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc): Add code\n\tto verify the descriptor. Correct bounds calculation.\n\t(gfc_desc_to_cfi_desc): Add code to verify the descriptor.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/ISO_Fortran_binding_1.f90: Add pointer attribute,\n\tthis test is still erroneous but now it compiles.\n\t* gfortran.dg/bind_c_array_params_2.f90: Update regex to match\n\tcode changes.\n\t* gfortran.dg/PR93308.f90: New test.\n\t* gfortran.dg/PR93963.f90: New test.\n\t* gfortran.dg/PR94327.c: New test.\n\t* gfortran.dg/PR94327.f90: New test.\n\t* gfortran.dg/PR94331.c: New test.\n\t* gfortran.dg/PR94331.f90: New test.\n\t* gfortran.dg/PR97046.f90: New test.", "tree": {"sha": "954d333194e1572fb693ffbef91c6d38f558fd67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/954d333194e1572fb693ffbef91c6d38f558fd67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32f7506bdc3956762bcc7dc84133fd7c3a00bb7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32f7506bdc3956762bcc7dc84133fd7c3a00bb7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32f7506bdc3956762bcc7dc84133fd7c3a00bb7b"}], "stats": {"total": 966, "additions": 933, "deletions": 33}, "files": [{"sha": "784f7b61ce16a2ca6947e587002a3b4e652671c4", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -4539,22 +4539,28 @@ convert_CFI_desc (gfc_wrapped_block * block, gfc_symbol *sym)\n       gfc_add_expr_to_block (&outer_block, incoming);\n       incoming = gfc_finish_block (&outer_block);\n \n-\n       /* Convert the gfc descriptor back to the CFI type before going\n \t out of scope, if the CFI type was present at entry.  */\n-      gfc_init_block (&outer_block);\n-      gfc_init_block (&tmpblock);\n-\n-      tmp = gfc_build_addr_expr (ppvoid_type_node, CFI_desc_ptr);\n-      outgoing = build_call_expr_loc (input_location,\n-\t\t\tgfor_fndecl_gfc_to_cfi, 2, tmp, gfc_desc_ptr);\n-      gfc_add_expr_to_block (&tmpblock, outgoing);\n+      outgoing = NULL_TREE;\n+      if ((sym->attr.pointer || sym->attr.allocatable)\n+\t  && !sym->attr.value\n+\t  && sym->attr.intent != INTENT_IN)\n+\t{\n+\t  gfc_init_block (&outer_block);\n+\t  gfc_init_block (&tmpblock);\n \n-      outgoing = build3_v (COND_EXPR, present,\n-\t\t\t   gfc_finish_block (&tmpblock),\n-\t\t\t   build_empty_stmt (input_location));\n-      gfc_add_expr_to_block (&outer_block, outgoing);\n-      outgoing = gfc_finish_block (&outer_block);\n+\t  tmp = gfc_build_addr_expr (ppvoid_type_node, CFI_desc_ptr);\n+\t  outgoing = build_call_expr_loc (input_location,\n+\t\t\t\t\t  gfor_fndecl_gfc_to_cfi, 2,\n+\t\t\t\t\t  tmp, gfc_desc_ptr);\n+\t  gfc_add_expr_to_block (&tmpblock, outgoing);\n+\n+\t  outgoing = build3_v (COND_EXPR, present,\n+\t\t\t       gfc_finish_block (&tmpblock),\n+\t\t\t       build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&outer_block, outgoing);\n+\t  outgoing = gfc_finish_block (&outer_block);\n+\t}\n \n       /* Add the lot to the procedure init and finally blocks.  */\n       gfc_add_init_cleanup (block, incoming, outgoing);"}, {"sha": "c4291cce0790c0dd790a377341f5128c45eba524", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -5502,13 +5502,12 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \tattribute = 1;\n     }\n \n-  /* If the formal argument is assumed shape and neither a pointer nor\n-     allocatable, it is unconditionally CFI_attribute_other.  */\n-  if (fsym->as->type == AS_ASSUMED_SHAPE\n-      && !fsym->attr.pointer && !fsym->attr.allocatable)\n-   cfi_attribute = 2;\n+  if (fsym->attr.pointer)\n+    cfi_attribute = 0;\n+  else if (fsym->attr.allocatable)\n+    cfi_attribute = 1;\n   else\n-   cfi_attribute = attribute;\n+    cfi_attribute = 2;\n \n   if (e->rank != 0)\n     {\n@@ -5616,10 +5615,15 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   gfc_prepend_expr_to_block (&parmse->post, tmp);\n \n   /* Transfer values back to gfc descriptor.  */\n-  tmp = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t     gfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);\n-  gfc_prepend_expr_to_block (&parmse->post, tmp);\n+  if (cfi_attribute != 2  /* CFI_attribute_other.  */\n+      && !fsym->attr.value\n+      && fsym->attr.intent != INTENT_IN)\n+    {\n+      tmp = gfc_build_addr_expr (NULL_TREE, parmse->expr);\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t gfor_fndecl_cfi_to_gfc, 2, gfc_desc_ptr, tmp);\n+      gfc_prepend_expr_to_block (&parmse->post, tmp);\n+    }\n \n   /* Deal with an optional dummy being passed to an optional formal arg\n      by finishing the pre and post blocks and making their execution"}, {"sha": "0cf3b2cb88c355aeb1da23c54cf1b75cf3a6fe8d", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -39,7 +39,7 @@ FUNCTION c_establish(a) BIND(C, NAME=\"establish_c\") RESULT(err)\n       USE, INTRINSIC :: ISO_C_BINDING\n       import\n       INTEGER(C_INT) :: err\n-      type (T), DIMENSION(..), intent(out) :: a\n+      type (T), pointer, DIMENSION(..), intent(out) :: a\n     END FUNCTION c_establish\n \n     FUNCTION c_contiguous(a) BIND(C, NAME=\"contiguous_c\") RESULT(err)"}, {"sha": "ee116f961dee62cf7a632e6b14ac3cfbd64e367d", "filename": "gcc/testsuite/gfortran.dg/PR93308.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93308.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93308.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93308.f90?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR94331\n+!\n+! Contributed by Robin Hogan <r.j.hogan@reading.ac.uk>\n+!\n+\n+program test \n+\n+  use, intrinsic :: iso_c_binding, only: &\n+    c_int, c_float\n+\n+  implicit none\n+\n+  integer                       :: i\n+  integer,            parameter :: n = 11\n+  real(kind=c_float), parameter :: u(*) = [(real(i, kind=c_float), i=1,n)]\n+  \n+  real(kind=c_float), allocatable :: A(:)\n+  real(kind=c_float)              :: E(n)\n+  integer(kind=c_int)             :: l1, l2, l3\n+\n+  allocate(A, source=u)\n+  l1 = lbound(A, 1)\n+  call routine_bindc(A, l2) ! in gcc-9.2.1 this changes lbound of A...\n+  l3 = lbound(A, 1)\n+  if (l1 /= 1)                        stop 1\n+  if (l1 /= l2)                       stop 2\n+  if (l1 /= l3)                       stop 3\n+  if (any(abs(A(1:n)-u)>0.0_c_float)) stop 4\n+  deallocate(A)\n+  !\n+  E = u\n+  l1 = lbound(E, 1)\n+  call routine_bindc(E, l2) ! ...but does not change lbound of E\n+  l3 = lbound(E, 1)\n+  if (l1 /= 1)                        stop 5\n+  if (l1 /= l2)                       stop 6\n+  if (l1 /= l3)                       stop 7\n+  if (any(abs(E(1:n)-u)>0.0_c_float)) stop 8\n+\n+contains\n+\n+  subroutine routine_bindc(v, l) bind(c)\n+    real(kind=c_float),  intent(inout) :: v(:)\n+    integer(kind=c_int), intent(out)   :: l\n+    \n+    l = lbound(v, 1)\n+    if (any(abs(v(1:n)-u)>0.0_c_float)) stop 9\n+  end subroutine routine_bindc\n+  \n+end program test"}, {"sha": "4e1b06fd5255262831994abdfa04b64816c6cdaa", "filename": "gcc/testsuite/gfortran.dg/PR93963.f90", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93963.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93963.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR93963.f90?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -0,0 +1,150 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR93963\n+!\n+\n+function rank_p(this) result(rnk) bind(c)\n+  use, intrinsic :: iso_c_binding, only: c_int\n+\n+  implicit none\n+  \n+  integer(kind=c_int), pointer, intent(in) :: this(..)\n+  integer(kind=c_int)                      :: rnk\n+\n+  select rank(this)\n+  rank(0)\n+    rnk = 0\n+  rank(1)\n+    rnk = 1\n+  rank(2)\n+    rnk = 2\n+  rank(3)\n+    rnk = 3\n+  rank(4)\n+    rnk = 4\n+  rank(5)\n+    rnk = 5\n+  rank(6)\n+    rnk = 6\n+  rank(7)\n+    rnk = 7\n+  rank(8)\n+    rnk = 8\n+  rank(9)\n+    rnk = 9\n+  rank(10)\n+    rnk = 10\n+  rank(11)\n+    rnk = 11\n+  rank(12)\n+    rnk = 12\n+  rank(13)\n+    rnk = 13\n+  rank(14)\n+    rnk = 14\n+  rank(15)\n+    rnk = 15\n+  rank default\n+    rnk = -1000\n+  end select\n+  return\n+end function rank_p\n+\n+function rank_a(this) result(rnk) bind(c)\n+  use, intrinsic :: iso_c_binding, only: c_int\n+\n+  implicit none\n+  \n+  integer(kind=c_int), allocatable, intent(in) :: this(..)\n+  integer(kind=c_int)                          :: rnk\n+\n+  select rank(this)\n+  rank(0)\n+    rnk = 0\n+  rank(1)\n+    rnk = 1\n+  rank(2)\n+    rnk = 2\n+  rank(3)\n+    rnk = 3\n+  rank(4)\n+    rnk = 4\n+  rank(5)\n+    rnk = 5\n+  rank(6)\n+    rnk = 6\n+  rank(7)\n+    rnk = 7\n+  rank(8)\n+    rnk = 8\n+  rank(9)\n+    rnk = 9\n+  rank(10)\n+    rnk = 10\n+  rank(11)\n+    rnk = 11\n+  rank(12)\n+    rnk = 12\n+  rank(13)\n+    rnk = 13\n+  rank(14)\n+    rnk = 14\n+  rank(15)\n+    rnk = 15\n+  rank default\n+    rnk = -1000\n+  end select\n+  return\n+end function rank_a\n+\n+program selr_p\n+\n+  use, intrinsic :: iso_c_binding, only: c_int\n+\n+  implicit none\n+\n+  interface\n+    function rank_p(this) result(rnk) bind(c)\n+      use, intrinsic :: iso_c_binding, only: c_int\n+      integer(kind=c_int), pointer, intent(in) :: this(..)\n+      integer(kind=c_int)                      :: rnk\n+    end function rank_p\n+  end interface\n+\n+  interface\n+    function rank_a(this) result(rnk) bind(c)\n+      use, intrinsic :: iso_c_binding, only: c_int\n+      integer(kind=c_int), allocatable, intent(in) :: this(..)\n+      integer(kind=c_int)                          :: rnk\n+    end function rank_a\n+  end interface\n+\n+  integer(kind=c_int), parameter :: siz = 7\n+  integer(kind=c_int), parameter :: rnk = 1\n+\n+  integer(kind=c_int),     pointer :: intp(:)\n+  integer(kind=c_int), allocatable :: inta(:)\n+  integer(kind=c_int)              :: irnk\n+\n+  nullify(intp)\n+  irnk = rank_p(intp)\n+  if (irnk /= rnk)        stop 1\n+  if (irnk /= rank(intp)) stop 2\n+  !\n+  irnk = rank_a(inta)\n+  if (irnk /= rnk)        stop 3\n+  if (irnk /= rank(inta)) stop 4\n+  !\n+  allocate(intp(siz))\n+  irnk = rank_p(intp)\n+  if (irnk /= rnk)        stop 5\n+  if (irnk /= rank(intp)) stop 6\n+  deallocate(intp)\n+  nullify(intp)\n+  !\n+  allocate(inta(siz))\n+  if (irnk /= rnk)        stop 7\n+  if (irnk /= rank(inta)) stop 8\n+  deallocate(inta)\n+\n+end program selr_p"}, {"sha": "6791c37354619b746be3c502718f03fd4359061f", "filename": "gcc/testsuite/gfortran.dg/PR94327.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94327.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94327.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94327.c?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -0,0 +1,70 @@\n+/* Test the fix for PR94327.  */\n+\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+#include \"../../../libgfortran/ISO_Fortran_binding.h\"\n+\n+bool c_vrfy (const CFI_cdesc_t *restrict);\n+\n+char get_attr (const CFI_cdesc_t*restrict, bool);\n+\n+bool\n+c_vrfy (const CFI_cdesc_t *restrict auxp)\n+{\n+  CFI_index_t i, lb, ub, ex;\n+  int *ip = NULL;\n+\n+  assert (auxp);\n+  assert (auxp->base_addr);\n+  lb = auxp->dim[0].lower_bound;\n+  ex = auxp->dim[0].extent;\n+  ub = ex + lb - 1;\n+  ip = (int*)auxp->base_addr;\n+  for (i=0; i<ex; i++)\n+    if (*ip++ != i+1)\n+      return false;\n+  for (i=lb; i<ub+1; i++)\n+    {\n+      ip = (int*)CFI_address(auxp, &i);\n+      if (*ip != i-lb+1)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+char\n+get_attr (const CFI_cdesc_t *restrict auxp, bool alloc)\n+{\n+  char attr;\n+  \n+  assert (auxp);\n+  assert (auxp->elem_len == 4);\n+  assert (auxp->rank == 1);\n+  assert (auxp->type == CFI_type_int);\n+  attr = '\\0';\n+  switch (auxp->attribute)\n+    {\n+    case CFI_attribute_pointer:\n+      if (alloc && !c_vrfy (auxp))\n+\tbreak;\n+      attr = 'p';\n+      break;\n+    case CFI_attribute_allocatable:\n+      if (alloc && !c_vrfy (auxp))\n+\tbreak;\n+      attr = 'a';\n+      break;\n+    case CFI_attribute_other:\n+      assert (alloc);\n+      if (!c_vrfy (auxp))\n+\tbreak;\n+      attr = 'o';\n+      break;\n+    default:\n+      break;\n+    }\n+  return attr;\n+}\n+"}, {"sha": "3cb3ac3dda18539da6a740cae238bcc3fcbced7b", "filename": "gcc/testsuite/gfortran.dg/PR94327.f90", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94327.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94327.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94327.f90?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -0,0 +1,195 @@\n+! { dg-do run }\n+! { dg-additional-sources PR94327.c }\n+!\n+! Test the fix for PR94327\n+!\n+\n+program attr_p\n+  \n+  use, intrinsic :: iso_c_binding, only: &\n+    c_int, c_bool, c_char\n+\n+  implicit none\n+\n+  integer            :: i\n+  integer, parameter :: n = 11\n+  integer, parameter :: u(*) = [(i, i=1,n)]\n+  \n+  interface\n+    function attr_p_as(a, s) result(c) &\n+      bind(c, name=\"get_attr\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool, c_char\n+      implicit none\n+      integer(kind=c_int), pointer, intent(in) :: a(:)\n+      logical(kind=c_bool),  value, intent(in) :: s\n+      character(kind=c_char)                   :: c\n+    end function attr_p_as\n+    function attr_a_as(a, s) result(c) &\n+      bind(c, name=\"get_attr\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool, c_char\n+      implicit none\n+      integer(kind=c_int), allocatable, intent(in) :: a(:)\n+      logical(kind=c_bool),      value, intent(in) :: s\n+      character(kind=c_char)                       :: c\n+    end function attr_a_as\n+    function attr_o_as(a, s) result(c) &\n+      bind(c, name=\"get_attr\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool, c_char\n+      implicit none\n+      integer(kind=c_int),         intent(in) :: a(:)\n+      logical(kind=c_bool), value, intent(in) :: s\n+      character(kind=c_char)                  :: c\n+    end function attr_o_as\n+    function attr_p_ar(a, s) result(c) &\n+      bind(c, name=\"get_attr\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool, c_char\n+      implicit none\n+      integer(kind=c_int), pointer, intent(in) :: a(..)\n+      logical(kind=c_bool),  value, intent(in) :: s\n+      character(kind=c_char)                   :: c\n+    end function attr_p_ar\n+    function attr_a_ar(a, s) result(c) &\n+      bind(c, name=\"get_attr\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool, c_char\n+      implicit none\n+      integer(kind=c_int), allocatable, intent(in) :: a(..)\n+      logical(kind=c_bool),      value, intent(in) :: s\n+      character(kind=c_char)                       :: c\n+    end function attr_a_ar\n+    function attr_o_ar(a, s) result(c) &\n+      bind(c, name=\"get_attr\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool, c_char\n+      implicit none\n+      integer(kind=c_int),         intent(in) :: a(..)\n+      logical(kind=c_bool), value, intent(in) :: s\n+      character(kind=c_char)                  :: c\n+    end function attr_o_ar\n+  end interface\n+\n+  integer(kind=c_int),              target :: a(n)\n+  integer(kind=c_int), allocatable, target :: b(:)\n+  integer(kind=c_int),             pointer :: p(:)\n+  character(kind=c_char)                   :: c\n+\n+  a = u\n+  c = attr_p_as(a, .true._c_bool)\n+  if(c/='p')                stop 1\n+  if(any(a/=u))             stop 2\n+  !\n+  a = u\n+  c = attr_p_ar(a, .true._c_bool)\n+  if(c/='p')                stop 3\n+  if(any(a/=u))             stop 4\n+  !\n+  a = u\n+  c = attr_o_as(a, .true._c_bool)\n+  if(c/='o')                stop 5\n+  if(any(a/=u))             stop 6\n+  !\n+  a = u\n+  c = attr_o_ar(a, .true._c_bool)\n+  if(c/='o')                stop 7\n+  if(any(a/=u))             stop 8\n+  !\n+  allocate(b, source=u)\n+  c = attr_p_as(b, .true._c_bool)\n+  if(c/='p')                stop 9\n+  if(.not.allocated(b))     stop 10\n+  if(any(b/=u))             stop 11\n+  !\n+  deallocate(b)\n+  allocate(b, source=u)\n+  c = attr_p_ar(b, .true._c_bool)\n+  if(c/='p')                stop 12\n+  if(.not.allocated(b))     stop 13\n+  if(any(b/=u))             stop 14\n+  !\n+  deallocate(b)\n+  allocate(b, source=u)\n+  c = attr_a_as(b, .true._c_bool)\n+  if(c/='a')                stop 15\n+  if(.not.allocated(b))     stop 16\n+  if(any(b/=u))             stop 17\n+  !\n+  deallocate(b)\n+  allocate(b, source=u)\n+  c = attr_a_ar(b, .true._c_bool)\n+  if(c/='a')                stop 18\n+  if(.not.allocated(b))     stop 19\n+  if(any(b/=u))             stop 20\n+  !\n+  deallocate(b)\n+  allocate(b, source=u)\n+  c = attr_o_as(b, .true._c_bool)\n+  if(c/='o')                stop 21\n+  if(.not.allocated(b))     stop 22\n+  if(any(b/=u))             stop 23\n+  !\n+  deallocate(b)\n+  allocate(b, source=u)\n+  c = attr_o_ar(b, .true._c_bool)\n+  if(c/='o')                stop 24\n+  if(.not.allocated(b))     stop 25\n+  if(any(b/=u))             stop 26\n+  !\n+  deallocate(b)\n+  c = attr_a_as(b, .false._c_bool)\n+  if(c/='a')                stop 27\n+  if(allocated(b))          stop 28\n+  !\n+  c = attr_a_ar(b, .false._c_bool)\n+  if(c/='a')                stop 29\n+  if(allocated(b))          stop 30\n+  !\n+  nullify(p)\n+  p => a\n+  c = attr_p_as(p, .true._c_bool)\n+  if(c/='p')                stop 31\n+  if(.not.associated(p))    stop 32\n+  if(.not.associated(p, a)) stop 33\n+  if(any(p/=u))             stop 34\n+  !\n+  nullify(p)\n+  p => a\n+  c = attr_p_ar(p, .true._c_bool)\n+  if(c/='p')                stop 35\n+  if(.not.associated(p))    stop 36\n+  if(.not.associated(p, a)) stop 37\n+  if(any(p/=u))             stop 38\n+  !\n+  nullify(p)\n+  p => a\n+  c = attr_o_as(p, .true._c_bool)\n+  if(c/='o')                stop 39\n+  if(.not.associated(p))    stop 40\n+  if(.not.associated(p, a)) stop 41\n+  if(any(p/=u))             stop 42\n+  !\n+  nullify(p)\n+  p => a\n+  c = attr_o_ar(p, .true._c_bool)\n+  if(c/='o')                stop 43\n+  if(.not.associated(p))    stop 44\n+  if(.not.associated(p, a)) stop 45\n+  if(any(p/=u))             stop 46\n+  !\n+  nullify(p)\n+  c = attr_p_as(p, .false._c_bool)\n+  if(c/='p')                stop 47\n+  if(associated(p))         stop 48\n+  if(associated(p, a))      stop 49\n+  !\n+  nullify(p)\n+  c = attr_p_ar(p, .false._c_bool)\n+  if(c/='p')                stop 50\n+  if(associated(p))         stop 51\n+  if(associated(p, a))      stop 52\n+  stop\n+\n+end program attr_p"}, {"sha": "4e130515455dc39239c91eaff1b8089c9cfb47a6", "filename": "gcc/testsuite/gfortran.dg/PR94331.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94331.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94331.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94331.c?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -0,0 +1,73 @@\n+/* Test the fix for PR94331.  */\n+\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+#include \"../../../libgfortran/ISO_Fortran_binding.h\"\n+\n+bool c_vrfy (const CFI_cdesc_t *restrict);\n+\n+bool check_bounds(const CFI_cdesc_t*restrict, const int, const int);\n+\n+bool\n+c_vrfy (const CFI_cdesc_t *restrict auxp)\n+{\n+  CFI_index_t i, lb, ub, ex;\n+  int *ip = NULL;\n+\n+  assert (auxp);\n+  assert (auxp->base_addr);\n+  lb = auxp->dim[0].lower_bound;\n+  ex = auxp->dim[0].extent;\n+  ub = ex + lb - 1;\n+  ip = (int*)auxp->base_addr;\n+  for (i=0; i<ex; i++)\n+    if (*ip++ != i+1)\n+      return false;\n+  for (i=lb; i<ub+1; i++)\n+    {\n+      ip = (int*)CFI_address(auxp, &i);\n+      if (*ip != i-lb+1)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+bool\n+check_bounds (const CFI_cdesc_t *restrict auxp, const int lb, const int ub)\n+{\n+  CFI_index_t ex = ub-lb+1;\n+  size_t el;\n+  bool is_ok = false;\n+  \n+  assert (auxp);\n+  el = auxp->elem_len;\n+  assert (auxp->rank==1);\n+  assert (auxp->type==CFI_type_int);\n+  assert (auxp->dim[0].sm>0);\n+  assert ((size_t)auxp->dim[0].sm==el);\n+  if (auxp->dim[0].extent==ex\n+      && auxp->dim[0].lower_bound==lb)\n+    {\n+    switch(auxp->attribute)\n+      {\n+      case CFI_attribute_pointer:\n+      case CFI_attribute_allocatable:\n+\tif (!c_vrfy (auxp))\n+\t  break;\n+\tis_ok = true;\n+\tbreak;\n+      case CFI_attribute_other:\n+\tif (!c_vrfy (auxp))\n+\t  break;\n+\tis_ok = (lb==0);\n+\tbreak;\n+      default:\n+\tassert (false);\n+\tbreak;\n+      }\n+    }\n+  return is_ok;\n+}\n+"}, {"sha": "6185031afc572d6fed635c5be1ff952eba3f6435", "filename": "gcc/testsuite/gfortran.dg/PR94331.f90", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94331.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94331.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR94331.f90?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -0,0 +1,252 @@\n+! { dg-do run }\n+! { dg-additional-sources PR94331.c }\n+!\n+! Test the fix for PR94331\n+!\n+\n+program main_p\n+  \n+  use, intrinsic :: iso_c_binding, only: &\n+    c_int\n+\n+  implicit none\n+\n+  integer            :: i\n+  integer, parameter :: ex = 11\n+  integer, parameter :: lb = 11\n+  integer, parameter :: ub = ex+lb-1\n+  integer, parameter :: u(*) = [(i, i=1,ex)]\n+  \n+  interface\n+    function checkb_p_as(a, l, u) result(c) &\n+      bind(c, name=\"check_bounds\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool\n+      implicit none\n+      integer(kind=c_int), pointer, intent(in) :: a(:)\n+      integer(kind=c_int),   value, intent(in) :: l\n+      integer(kind=c_int),   value, intent(in) :: u\n+      logical(kind=c_bool)                     :: c\n+    end function checkb_p_as\n+    function checkb_a_as(a, l, u) result(c) &\n+      bind(c, name=\"check_bounds\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool\n+      implicit none\n+      integer(kind=c_int), allocatable, intent(in) :: a(:)\n+      integer(kind=c_int),       value, intent(in) :: l\n+      integer(kind=c_int),       value, intent(in) :: u\n+      logical(kind=c_bool)                         :: c\n+    end function checkb_a_as\n+    function checkb_o_as(a, l, u) result(c) &\n+      bind(c, name=\"check_bounds\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool\n+      implicit none\n+      integer(kind=c_int),        intent(in) :: a(:)\n+      integer(kind=c_int), value, intent(in) :: l\n+      integer(kind=c_int), value, intent(in) :: u\n+      logical(kind=c_bool)                   :: c\n+    end function checkb_o_as\n+    function checkb_p_ar(a, l, u) result(c) &\n+      bind(c, name=\"check_bounds\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool\n+      implicit none\n+      integer(kind=c_int), pointer, intent(in) :: a(..)\n+      integer(kind=c_int),   value, intent(in) :: l\n+      integer(kind=c_int),   value, intent(in) :: u\n+      logical(kind=c_bool)                     :: c\n+    end function checkb_p_ar\n+    function checkb_a_ar(a, l, u) result(c) &\n+      bind(c, name=\"check_bounds\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool\n+      implicit none\n+      integer(kind=c_int), allocatable, intent(in) :: a(..)\n+      integer(kind=c_int),       value, intent(in) :: l\n+      integer(kind=c_int),       value, intent(in) :: u\n+      logical(kind=c_bool)                         :: c\n+    end function checkb_a_ar\n+    function checkb_o_ar(a, l, u) result(c) &\n+      bind(c, name=\"check_bounds\")\n+      use, intrinsic :: iso_c_binding, only: &\n+        c_int, c_bool\n+      implicit none\n+      integer(kind=c_int),        intent(in) :: a(..)\n+      integer(kind=c_int), value, intent(in) :: l\n+      integer(kind=c_int), value, intent(in) :: u\n+      logical(kind=c_bool)                   :: c\n+    end function checkb_o_ar\n+  end interface\n+\n+  integer(kind=c_int),              target :: a(lb:ub)\n+  integer(kind=c_int), allocatable, target :: b(:)\n+  integer(kind=c_int),             pointer :: p(:)\n+\n+  a = u\n+  if(lbound(a,1)/=lb)             stop 1\n+  if(ubound(a,1)/=ub)             stop 2\n+  if(any(shape(a)/=[ex]))         stop 3\n+  if(.not.checkb_p_as(a, lb, ub)) stop 4\n+  if(lbound(a,1)/=lb)             stop 5\n+  if(ubound(a,1)/=ub)             stop 6\n+  if(any(shape(a)/=[ex]))         stop 7\n+  if(any(a/=u))                   stop 8\n+  !\n+  a = u\n+  if(lbound(a,1)/=lb)             stop 9\n+  if(ubound(a,1)/=ub)             stop 10\n+  if(any(shape(a)/=[ex]))         stop 11\n+  if(.not.checkb_p_ar(a, lb, ub)) stop 12\n+  if(lbound(a,1)/=lb)             stop 13\n+  if(ubound(a,1)/=ub)             stop 14\n+  if(any(shape(a)/=[ex]))         stop 15\n+  if(any(a/=u))                   stop 16\n+  !\n+  a = u\n+  if(lbound(a,1)/=lb)             stop 17\n+  if(ubound(a,1)/=ub)             stop 18\n+  if(any(shape(a)/=[ex]))         stop 19\n+  if(.not.checkb_o_as(a, 0, ex-1))stop 20\n+  if(lbound(a,1)/=lb)             stop 21\n+  if(ubound(a,1)/=ub)             stop 22\n+  if(any(shape(a)/=[ex]))         stop 23\n+  if(any(a/=u))                   stop 24\n+  !\n+  a = u\n+  if(lbound(a,1)/=lb)             stop 25\n+  if(ubound(a,1)/=ub)             stop 26\n+  if(any(shape(a)/=[ex]))         stop 27\n+  if(.not.checkb_o_ar(a, 0, ex-1))stop 28\n+  if(lbound(a,1)/=lb)             stop 29\n+  if(ubound(a,1)/=ub)             stop 30\n+  if(any(shape(a)/=[ex]))         stop 31\n+  if(any(a/=u))                   stop 32\n+  !\n+  allocate(b(lb:ub), source=u)\n+  if(lbound(b,1)/=lb)             stop 33\n+  if(ubound(b,1)/=ub)             stop 34\n+  if(any(shape(b)/=[ex]))         stop 35\n+  if(.not.checkb_p_as(b, lb, ub)) stop 36\n+  if(.not.allocated(b))           stop 37\n+  if(lbound(b,1)/=lb)             stop 38\n+  if(ubound(b,1)/=ub)             stop 39\n+  if(any(shape(b)/=[ex]))         stop 40\n+  if(any(b/=u))                   stop 41\n+  !\n+  deallocate(b)\n+  allocate(b(lb:ub), source=u)\n+  if(lbound(b,1)/=lb)             stop 42\n+  if(ubound(b,1)/=ub)             stop 43\n+  if(any(shape(b)/=[ex]))         stop 44\n+  if(.not.checkb_p_ar(b, lb, ub)) stop 45\n+  if(.not.allocated(b))           stop 46\n+  if(lbound(b,1)/=lb)             stop 47\n+  if(ubound(b,1)/=ub)             stop 48\n+  if(any(shape(b)/=[ex]))         stop 49\n+  if(any(b/=u))                   stop 50\n+  !\n+  deallocate(b)\n+  allocate(b(lb:ub), source=u)\n+  if(lbound(b,1)/=lb)             stop 51\n+  if(ubound(b,1)/=ub)             stop 52\n+  if(any(shape(b)/=[ex]))         stop 53\n+  if(.not.checkb_a_as(b, lb, ub)) stop 54\n+  if(.not.allocated(b))           stop 55\n+  if(lbound(b,1)/=lb)             stop 56\n+  if(ubound(b,1)/=ub)             stop 57\n+  if(any(shape(b)/=[ex]))         stop 58\n+  if(any(b/=u))                   stop 59\n+  !\n+  deallocate(b)\n+  allocate(b(lb:ub), source=u)\n+  if(lbound(b,1)/=lb)             stop 60\n+  if(ubound(b,1)/=ub)             stop 61\n+  if(any(shape(b)/=[ex]))         stop 62\n+  if(.not.checkb_a_ar(b, lb, ub)) stop 63\n+  if(.not.allocated(b))           stop 64\n+  if(lbound(b,1)/=lb)             stop 65\n+  if(ubound(b,1)/=ub)             stop 66\n+  if(any(shape(b)/=[ex]))         stop 67\n+  if(any(b/=u))                   stop 68\n+  !\n+  deallocate(b)\n+  allocate(b(lb:ub), source=u)\n+  if(lbound(b,1)/=lb)             stop 69\n+  if(ubound(b,1)/=ub)             stop 70\n+  if(any(shape(b)/=[ex]))         stop 71\n+  if(.not.checkb_o_as(b, 0, ex-1))stop 72\n+  if(.not.allocated(b))           stop 73\n+  if(lbound(b,1)/=lb)             stop 74\n+  if(ubound(b,1)/=ub)             stop 75\n+  if(any(shape(b)/=[ex]))         stop 76\n+  if(any(b/=u))                   stop 77\n+  !\n+  deallocate(b)\n+  allocate(b(lb:ub), source=u)\n+  if(lbound(b,1)/=lb)             stop 78\n+  if(ubound(b,1)/=ub)             stop 79\n+  if(any(shape(b)/=[ex]))         stop 80\n+  if(.not.checkb_o_ar(b, 0, ex-1))stop 81\n+  if(.not.allocated(b))           stop 82\n+  if(lbound(b,1)/=lb)             stop 83\n+  if(ubound(b,1)/=ub)             stop 84\n+  if(any(shape(b)/=[ex]))         stop 85\n+  if(any(b/=u))                   stop 86\n+  deallocate(b)\n+  !\n+  p(lb:ub) => a\n+  if(lbound(p,1)/=lb)             stop 87\n+  if(ubound(p,1)/=ub)             stop 88\n+  if(any(shape(p)/=[ex]))         stop 89\n+  if(.not.checkb_p_as(p, lb, ub)) stop 90\n+  if(.not.associated(p))          stop 91\n+  if(.not.associated(p, a))       stop 92\n+  if(lbound(p,1)/=lb)             stop 93\n+  if(ubound(p,1)/=ub)             stop 94\n+  if(any(shape(p)/=[ex]))         stop 95\n+  if(any(p/=u))                   stop 96\n+  !\n+  nullify(p)\n+  p(lb:ub) => a\n+  if(lbound(p,1)/=lb)             stop 97\n+  if(ubound(p,1)/=ub)             stop 98\n+  if(any(shape(p)/=[ex]))         stop 99\n+  if(.not.checkb_p_ar(p, lb, ub)) stop 100\n+  if(.not.associated(p))          stop 101\n+  if(.not.associated(p, a))       stop 102\n+  if(lbound(p,1)/=lb)             stop 103\n+  if(ubound(p,1)/=ub)             stop 104\n+  if(any(shape(p)/=[ex]))         stop 105\n+  if(any(p/=u))                   stop 106\n+  !\n+  nullify(p)\n+  p(lb:ub) => a\n+  if(lbound(p,1)/=lb)             stop 107\n+  if(ubound(p,1)/=ub)             stop 108\n+  if(any(shape(p)/=[ex]))         stop 109\n+  if(.not.checkb_o_as(p, 0, ex-1))stop 110\n+  if(.not.associated(p))          stop 111\n+  if(.not.associated(p, a))       stop 112\n+  if(lbound(p,1)/=lb)             stop 113\n+  if(ubound(p,1)/=ub)             stop 114\n+  if(any(shape(p)/=[ex]))         stop 115\n+  if(any(p/=u))                   stop 116\n+  !\n+  nullify(p)\n+  p(lb:ub) => a\n+  if(lbound(p,1)/=lb)             stop 117\n+  if(ubound(p,1)/=ub)             stop 118\n+  if(any(shape(p)/=[ex]))         stop 119\n+  if(.not.checkb_o_ar(p, 0, ex-1))stop 120\n+  if(.not.associated(p))          stop 121\n+  if(.not.associated(p, a))       stop 122\n+  if(lbound(p,1)/=lb)             stop 123\n+  if(ubound(p,1)/=ub)             stop 124\n+  if(any(shape(p)/=[ex]))         stop 125\n+  if(any(p/=u))                   stop 126\n+  nullify(p)\n+  stop\n+  \n+end program main_p"}, {"sha": "7d133a5ad70916d89bfd375f636698971ce1a980", "filename": "gcc/testsuite/gfortran.dg/PR97046.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR97046.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2FPR97046.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR97046.f90?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR94331\n+!\n+! Contributed by Igor Gayday <igor.gayday@mu.edu>\n+!\n+\n+MODULE FOO\n+\n+  implicit none\n+  \n+  INTEGER, parameter :: n = 11\n+\n+contains\n+  \n+  SUBROUTINE dummyc(x0) BIND(C)\n+    type(*), dimension(..) :: x0\n+    if(LBOUND(x0,1)/=1) stop 5\n+    if(UBOUND(x0,1)/=n) stop 6\n+    if(rank(x0)/=1)     stop 7\n+  END SUBROUTINE dummyc\n+  \n+  SUBROUTINE dummy(x0)\n+    type(*), dimension(..) :: x0\n+    call dummyc(x0)\n+  END SUBROUTINE dummy\n+  \n+END MODULE\n+\n+PROGRAM main\n+    USE FOO\n+    IMPLICIT NONE\n+    integer :: before(2), after(2)\n+\n+    DOUBLE PRECISION, ALLOCATABLE :: buf(:)\n+    DOUBLE PRECISION :: buf2(n)\n+\n+    ALLOCATE(buf(n))\n+    before(1) = LBOUND(buf,1)\n+    before(2) = UBOUND(buf,1)\n+    CALL dummy (buf)\n+    after(1) = LBOUND(buf,1)\n+    after(2) = UBOUND(buf,1)\n+    deallocate(buf)\n+\n+    if (before(1) .NE. after(1)) stop 1\n+    if (before(2) .NE. after(2)) stop 2\n+\n+    before(1) = LBOUND(buf2,1)\n+    before(2) = UBOUND(buf2,1)\n+    CALL dummy (buf2)\n+    after(1) = LBOUND(buf2,1)\n+    after(2) = UBOUND(buf2,1)\n+\n+    if (before(1) .NE. after(1)) stop 3\n+    if (before(2) .NE. after(2)) stop 4\n+\n+END PROGRAM"}, {"sha": "ede6eff67fa92a9d548dc07548c0a7f6e9ef4a45", "filename": "gcc/testsuite/gfortran.dg/bind_c_array_params_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -22,4 +22,4 @@ end subroutine test\n ! { dg-final { scan-assembler-times \"brasl\\t%r\\[0-9\\]*,myBindC\" 1 { target { s390*-*-* } } } }\n ! { dg-final { scan-assembler-times \"bl \\.myBindC\" 1 { target { powerpc-ibm-aix* } } } }\n ! { dg-final { scan-assembler-times \"add_u32\\t\\[sv\\]\\[0-9\\]*, \\[sv\\]\\[0-9\\]*, myBindC@rel32@lo\" 1 { target { amdgcn*-*-* } } } }\n-! { dg-final { scan-tree-dump-times \"cfi_desc_to_gfc_desc \\\\\\(&parm\\\\.\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"gfc_desc_to_cfi_desc \\\\\\(&cfi\\\\.\" 1 \"original\" } }"}, {"sha": "95e9b940f8e765e780b8523d15431ee583e3940b", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cbf03689e3e7d9d6002b8e5d159ef3716d0404c/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=0cbf03689e3e7d9d6002b8e5d159ef3716d0404c", "patch": "@@ -43,6 +43,24 @@ cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n   if (!s)\n     return;\n \n+  /* Verify descriptor.  */\n+  switch(s->attribute)\n+    {\n+    case CFI_attribute_pointer:\n+    case CFI_attribute_allocatable:\n+      break;\n+    case CFI_attribute_other:\n+      if (s->base_addr)\n+\tbreak;\n+      runtime_error (\"Nonallocatable, nonpointer actual argument to BIND(C) \"\n+\t\t     \"dummy argument where the effective argument is either \"\n+\t\t     \"not allocated or not associated\");\n+      break;\n+    default:\n+      runtime_error (\"Invalid attribute type %d in CFI_cdesc_t descriptor\",\n+\t\t     (int) s->attribute);\n+      break;\n+    }\n   GFC_DESCRIPTOR_DATA (d) = s->base_addr;\n   GFC_DESCRIPTOR_TYPE (d) = (signed char)(s->type & CFI_type_mask);\n   kind = (index_type)((s->type - (s->type & CFI_type_mask)) >> CFI_type_kind_shift);\n@@ -74,14 +92,19 @@ cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n     }\n \n   d->offset = 0;\n-  for (n = 0; n < GFC_DESCRIPTOR_RANK (d); n++)\n-    {\n-      GFC_DESCRIPTOR_LBOUND(d, n) = (index_type)s->dim[n].lower_bound;\n-      GFC_DESCRIPTOR_UBOUND(d, n) = (index_type)(s->dim[n].extent\n-\t\t\t\t\t\t+ s->dim[n].lower_bound - 1);\n-      GFC_DESCRIPTOR_STRIDE(d, n) = (index_type)(s->dim[n].sm / s->elem_len);\n-      d->offset -= GFC_DESCRIPTOR_STRIDE(d, n) * GFC_DESCRIPTOR_LBOUND(d, n);\n-    }\n+  if (GFC_DESCRIPTOR_DATA (d))\n+    for (n = 0; n < GFC_DESCRIPTOR_RANK (d); n++)\n+      {\n+\tCFI_index_t lb = 1;\n+\n+\tif (s->attribute != CFI_attribute_other)\n+\t  lb = s->dim[n].lower_bound;\n+\n+\tGFC_DESCRIPTOR_LBOUND(d, n) = (index_type)lb;\n+\tGFC_DESCRIPTOR_UBOUND(d, n) = (index_type)(s->dim[n].extent + lb - 1);\n+\tGFC_DESCRIPTOR_STRIDE(d, n) = (index_type)(s->dim[n].sm / s->elem_len);\n+\td->offset -= GFC_DESCRIPTOR_STRIDE(d, n) * GFC_DESCRIPTOR_LBOUND(d, n);\n+      }\n }\n \n extern void gfc_desc_to_cfi_desc (CFI_cdesc_t **, const gfc_array_void *);\n@@ -102,6 +125,23 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n   else\n     d = *d_ptr;\n \n+  /* Verify descriptor.  */\n+  switch (s->dtype.attribute)\n+    {\n+    case CFI_attribute_pointer:\n+    case CFI_attribute_allocatable:\n+      break;\n+    case CFI_attribute_other:\n+      if (s->base_addr)\n+\tbreak;\n+      runtime_error (\"Nonallocatable, nonpointer actual argument to BIND(C) \"\n+\t\t     \"dummy argument where the effective argument is either \"\n+\t\t     \"not allocated or not associated\");\n+      break;\n+    default:\n+      internal_error (NULL, \"Invalid attribute in gfc_array descriptor\");\n+      break;\n+    }\n   d->base_addr = GFC_DESCRIPTOR_DATA (s);\n   d->elem_len = GFC_DESCRIPTOR_SIZE (s);\n   d->version = CFI_VERSION;"}]}