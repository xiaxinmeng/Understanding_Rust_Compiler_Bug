{"sha": "78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhmNzYwN2RiNGM1M2Y4Y2ZlNDY1M2E2YzkxYzAzMjhiYzI4NTRjMw==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2019-06-22T15:14:30Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2019-06-22T15:14:30Z"}, "message": "PR c++/86476 - noexcept-specifier is a complete-class context.\n\n\tPR c++/52869\n\t* cp-tree.def (DEFAULT_ARG): Update commentary.\n\t* cp-tree.h (UNPARSED_NOEXCEPT_SPEC_P):\tNew macro.\n\t(tree_default_arg): Use tree_base instead of tree_common.\n\t(do_push_parm_decls, maybe_check_overriding_exception_spec): Declare.\n\t* decl.c (do_push_parm_decls): New function, broken out of...\n\t(store_parm_decls): ...here.  Call it.\n\t* except.c (nothrow_spec_p): Accept DEFAULT_ARG in the assert.\n\t* parser.c (cp_parser_noexcept_specification_opt,\n\tcp_parser_late_noexcept_specifier, noexcept_override_late_checks):\n\tForward-declare.\n\t(unparsed_noexcepts): New macro.\n\t(push_unparsed_function_queues): Update initializer.\n\t(cp_parser_direct_declarator): Pass FRIEND_P to\n\tcp_parser_exception_specification_opt.\n\t(inject_parm_decls): New.\n\t(pop_injected_parms): New.\n\t(cp_parser_class_specifier_1): Implement delayed parsing of\n\tnoexcept-specifiers.\n\t(cp_parser_save_noexcept): New.\n\t(cp_parser_late_noexcept_specifier): New.\n\t(noexcept_override_late_checks): New.\n\t(cp_parser_noexcept_specification_opt): Add FRIEND_P parameter.  Call\n\tcp_parser_save_noexcept instead of the normal processing if needed.\n\t(cp_parser_exception_specification_opt): Add FRIEND_P parameter and\n\tpass it to cp_parser_noexcept_specification_opt.\n\t(cp_parser_save_member_function_body): Fix comment.\n\t(cp_parser_save_default_args): Maybe save the noexcept-specifier to\n\tpost process.\n\t(cp_parser_transaction): Update call to\n\tcp_parser_noexcept_specification_opt.\n\t(cp_parser_transaction_expression): Likewise.\n\t* parser.h (cp_unparsed_functions_entry): Add new field to carry\n\ta noexcept-specifier.\n\t* pt.c (dependent_type_p_r): Handle unparsed noexcept expression.\n\t* search.c (maybe_check_overriding_exception_spec): New function, broken\n\tout of...\n\t(check_final_overrider): ...here.  Call\n\tmaybe_check_overriding_exception_spec.\n\t* tree.c (canonical_eh_spec): Handle UNPARSED_NOEXCEPT_SPEC_P.\n\t(cp_tree_equal): Handle DEFAULT_ARG.\n\n\t* g++.dg/cpp0x/noexcept45.C: New test.\n\t* g++.dg/cpp0x/noexcept46.C: New test.\n\t* g++.dg/cpp0x/noexcept47.C: New test.\n\t* g++.dg/cpp0x/noexcept48.C: New test.\n\t* g++.dg/cpp0x/noexcept49.C: New test.\n\t* g++.dg/cpp0x/noexcept50.C: New test.\n\t* g++.dg/cpp0x/noexcept51.C: New test.\n\t* g++.dg/cpp0x/noexcept52.C: New test.\n\t* g++.dg/cpp0x/noexcept53.C: New test.\n\t* g++.dg/eh/shadow1.C: Adjust dg-error.\n\nFrom-SVN: r272586", "tree": {"sha": "d8c288e122322c16f7c0c600df65e9b34feaf7c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8c288e122322c16f7c0c600df65e9b34feaf7c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f3db013dc8264e39339ee4b83900ef25d0d32aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f3db013dc8264e39339ee4b83900ef25d0d32aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f3db013dc8264e39339ee4b83900ef25d0d32aa"}], "stats": {"total": 780, "additions": 722, "deletions": 58}, "files": [{"sha": "800ae29a380594ecd9173717d5c346f9a3c99f60", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -1,5 +1,48 @@\n 2019-06-22  Marek Polacek  <polacek@redhat.com>\n \n+\tPR c++/86476 - noexcept-specifier is a complete-class context.\n+\tPR c++/52869\n+\t* cp-tree.def (DEFAULT_ARG): Update commentary.\n+\t* cp-tree.h (UNPARSED_NOEXCEPT_SPEC_P):\tNew macro.\n+\t(tree_default_arg): Use tree_base instead of tree_common.\n+\t(do_push_parm_decls, maybe_check_overriding_exception_spec): Declare.\n+\t* decl.c (do_push_parm_decls): New function, broken out of...\n+\t(store_parm_decls): ...here.  Call it.\n+\t* except.c (nothrow_spec_p): Accept DEFAULT_ARG in the assert.\n+\t* parser.c (cp_parser_noexcept_specification_opt,\n+\tcp_parser_late_noexcept_specifier, noexcept_override_late_checks):\n+\tForward-declare.\n+\t(unparsed_noexcepts): New macro.\n+\t(push_unparsed_function_queues): Update initializer.\n+\t(cp_parser_direct_declarator): Pass FRIEND_P to\n+\tcp_parser_exception_specification_opt.\n+\t(inject_parm_decls): New.\n+\t(pop_injected_parms): New.\n+\t(cp_parser_class_specifier_1): Implement delayed parsing of\n+\tnoexcept-specifiers.\n+\t(cp_parser_save_noexcept): New.\n+\t(cp_parser_late_noexcept_specifier): New.\n+\t(noexcept_override_late_checks): New.\n+\t(cp_parser_noexcept_specification_opt): Add FRIEND_P parameter.  Call\n+\tcp_parser_save_noexcept instead of the normal processing if needed.\n+\t(cp_parser_exception_specification_opt): Add FRIEND_P parameter and\n+\tpass it to cp_parser_noexcept_specification_opt.\n+\t(cp_parser_save_member_function_body): Fix comment.\n+\t(cp_parser_save_default_args): Maybe save the noexcept-specifier to\n+\tpost process.\n+\t(cp_parser_transaction): Update call to\n+\tcp_parser_noexcept_specification_opt.\n+\t(cp_parser_transaction_expression): Likewise.\n+\t* parser.h (cp_unparsed_functions_entry): Add new field to carry\n+\ta noexcept-specifier.\n+\t* pt.c (dependent_type_p_r): Handle unparsed noexcept expression.\n+\t* search.c (maybe_check_overriding_exception_spec): New function, broken\n+\tout of...\n+\t(check_final_overrider): ...here.  Call\n+\tmaybe_check_overriding_exception_spec.\n+\t* tree.c (canonical_eh_spec): Handle UNPARSED_NOEXCEPT_SPEC_P.\n+\t(cp_tree_equal): Handle DEFAULT_ARG.\n+\n \tPR c++/90881 - bogus -Wunused-value in unevaluated context.\n \t* cvt.c (convert_to_void): Don't emit unused warnings in\n \tan unevaluated context."}, {"sha": "475c584fd4cd6dd4c868733cd215623e11aad85d", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -209,7 +209,8 @@ DEFTREECODE (USING_STMT, \"using_stmt\", tcc_statement, 1)\n \n /* An un-parsed default argument.  Holds a vector of input tokens and\n    a vector of places where the argument was instantiated before\n-   parsing had occurred.  */\n+   parsing had occurred.  This is also used for delayed NSDMIs and\n+   noexcept-specifier parsing.  */\n DEFTREECODE (DEFAULT_ARG, \"default_arg\", tcc_exceptional, 0)\n \n /* An uninstantiated/unevaluated noexcept-specification.  For the"}, {"sha": "2c05e638915c48f84594ae4fb797318c70a1cd15", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -1190,7 +1190,7 @@ enum cp_identifier_kind {\n   (((struct tree_default_arg *)DEFAULT_ARG_CHECK (NODE))->instantiations)\n \n struct GTY (()) tree_default_arg {\n-  struct tree_common common;\n+  struct tree_base base;\n   struct cp_token_cache *tokens;\n   vec<tree, va_gc> *instantiations;\n };\n@@ -1206,6 +1206,9 @@ struct GTY (()) tree_default_arg {\n #define UNEVALUATED_NOEXCEPT_SPEC_P(NODE)\t\t\t\t\\\n   (DEFERRED_NOEXCEPT_SPEC_P (NODE)\t\t\t\t\t\\\n    && DEFERRED_NOEXCEPT_PATTERN (TREE_PURPOSE (NODE)) == NULL_TREE)\n+#define UNPARSED_NOEXCEPT_SPEC_P(NODE) \\\n+  ((NODE) && (TREE_PURPOSE (NODE)) \\\n+   && (TREE_CODE (TREE_PURPOSE (NODE)) == DEFAULT_ARG))\n \n struct GTY (()) tree_deferred_noexcept {\n   struct tree_base base;\n@@ -6467,6 +6470,7 @@ extern bool check_array_designated_initializer  (constructor_elt *,\n \t\t\t\t\t\t unsigned HOST_WIDE_INT);\n extern bool check_for_uninitialized_const_var   (tree, bool, tsubst_flags_t);\n extern tree build_explicit_specifier\t\t(tree, tsubst_flags_t);\n+extern void do_push_parm_decls\t\t\t(tree, tree, tree *);\n \n /* in decl2.c */\n extern void record_mangling\t\t\t(tree, bool);\n@@ -6932,6 +6936,7 @@ extern tree copied_binfo\t\t\t(tree, tree);\n extern tree original_binfo\t\t\t(tree, tree);\n extern int shared_member_p\t\t\t(tree);\n extern bool any_dependent_bases_p (tree = current_nonlambda_class_type ());\n+extern bool maybe_check_overriding_exception_spec (tree, tree);\n \n /* The representation of a deferred access check.  */\n "}, {"sha": "8a82c754ef77eab8757e488d10c6cfee85e40e31", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -15761,6 +15761,39 @@ use_eh_spec_block (tree fn)\n \t  && !DECL_DEFAULTED_FN (fn));\n }\n \n+/* Helper function to push ARGS into the current lexical scope.  DECL\n+   is the function declaration.  NONPARMS is used to handle enum\n+   constants.  */\n+\n+void\n+do_push_parm_decls (tree decl, tree args, tree *nonparms)\n+{\n+  /* If we're doing semantic analysis, then we'll call pushdecl\n+     for each of these.  We must do them in reverse order so that\n+     they end in the correct forward order.  */\n+  args = nreverse (args);\n+\n+  tree next;\n+  for (tree parm = args; parm; parm = next)\n+    {\n+      next = DECL_CHAIN (parm);\n+      if (TREE_CODE (parm) == PARM_DECL)\n+\tpushdecl (parm);\n+      else if (nonparms)\n+\t{\n+\t  /* If we find an enum constant or a type tag, put it aside for\n+\t     the moment.  */\n+\t  TREE_CHAIN (parm) = NULL_TREE;\n+\t  *nonparms = chainon (*nonparms, parm);\n+\t}\n+    }\n+\n+  /* Get the decls in their original chain order and record in the\n+     function.  This is all and only the PARM_DECLs that were\n+     pushed into scope by the loop above.  */\n+  DECL_ARGUMENTS (decl) = get_local_decls ();\n+}\n+\n /* Store the parameter declarations into the current function declaration.\n    This is called after parsing the parameter declarations, before\n    digesting the body of the function.\n@@ -15771,7 +15804,6 @@ static void\n store_parm_decls (tree current_function_parms)\n {\n   tree fndecl = current_function_decl;\n-  tree parm;\n \n   /* This is a chain of any other decls that came in among the parm\n      declarations.  If a parm is declared with  enum {foo, bar} x;\n@@ -15786,35 +15818,12 @@ store_parm_decls (tree current_function_parms)\n \t and complain if any redundant old-style parm decls were written.  */\n \n       tree specparms = current_function_parms;\n-      tree next;\n \n       /* Must clear this because it might contain TYPE_DECLs declared\n \t     at class level.  */\n       current_binding_level->names = NULL;\n \n-      /* If we're doing semantic analysis, then we'll call pushdecl\n-\t     for each of these.  We must do them in reverse order so that\n-\t     they end in the correct forward order.  */\n-      specparms = nreverse (specparms);\n-\n-      for (parm = specparms; parm; parm = next)\n-\t{\n-\t  next = DECL_CHAIN (parm);\n-\t  if (TREE_CODE (parm) == PARM_DECL)\n-\t    pushdecl (parm);\n-\t  else\n-\t    {\n-\t      /* If we find an enum constant or a type tag,\n-\t\t put it aside for the moment.  */\n-\t      TREE_CHAIN (parm) = NULL_TREE;\n-\t      nonparms = chainon (nonparms, parm);\n-\t    }\n-\t}\n-\n-      /* Get the decls in their original chain order and record in the\n-\t function.  This is all and only the PARM_DECLs that were\n-\t pushed into scope by the loop above.  */\n-      DECL_ARGUMENTS (fndecl) = get_local_decls ();\n+      do_push_parm_decls (fndecl, specparms, &nonparms);\n     }\n   else\n     DECL_ARGUMENTS (fndecl) = NULL_TREE;"}, {"sha": "1f87c5ab695b9e0e7a71724e712427aa119b8c5b", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -1245,6 +1245,7 @@ nothrow_spec_p (const_tree spec)\n \t      || TREE_VALUE (spec)\n \t      || spec == noexcept_false_spec\n \t      || TREE_PURPOSE (spec) == error_mark_node\n+\t      || UNPARSED_NOEXCEPT_SPEC_P (spec)\n \t      || processing_template_decl);\n \n   return false;"}, {"sha": "4d4d32973d937e18f2f0ff23d3c3950229f9cee0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 227, "deletions": 13, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -247,6 +247,12 @@ static void cp_lexer_stop_debugging\n \n static cp_token_cache *cp_token_cache_new\n   (cp_token *, cp_token *);\n+static tree cp_parser_noexcept_specification_opt\n+  (cp_parser *, bool, bool *, bool, bool);\n+static tree cp_parser_late_noexcept_specifier\n+  (cp_parser *, tree);\n+static void noexcept_override_late_checks\n+  (tree, tree);\n \n static void cp_parser_initial_pragma\n   (cp_token *);\n@@ -1974,11 +1980,14 @@ cp_parser_context_new (cp_parser_context* next)\n   parser->unparsed_queues->last ().nsdmis\n #define unparsed_classes \\\n   parser->unparsed_queues->last ().classes\n+#define unparsed_noexcepts \\\n+  parser->unparsed_queues->last ().noexcepts\n \n static void\n push_unparsed_function_queues (cp_parser *parser)\n {\n-  cp_unparsed_functions_entry e = {NULL, make_tree_vector (), NULL, NULL};\n+  cp_unparsed_functions_entry e = { NULL, make_tree_vector (), NULL, NULL,\n+\t\t\t\t    NULL };\n   vec_safe_push (parser->unparsed_queues, e);\n }\n \n@@ -2361,7 +2370,7 @@ static tree cp_parser_exception_declaration\n static tree cp_parser_throw_expression\n   (cp_parser *);\n static tree cp_parser_exception_specification_opt\n-  (cp_parser *);\n+  (cp_parser *, bool = false);\n static tree cp_parser_type_id_list\n   (cp_parser *);\n \n@@ -20816,7 +20825,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  tree tx_qual = cp_parser_tx_qualifier_opt (parser);\n \t\t  /* And the exception-specification.  */\n \t\t  exception_specification\n-\t\t    = cp_parser_exception_specification_opt (parser);\n+\t\t    = cp_parser_exception_specification_opt (parser, friend_p);\n \n \t\t  attrs = cp_parser_std_attribute_spec_seq (parser);\n \n@@ -23310,6 +23319,34 @@ cp_parser_class_name (cp_parser *parser,\n   return decl;\n }\n \n+/* Make sure that any member-function parameters are in scope.\n+   For instance, a function's noexcept-specifier can use the function's\n+   parameters:\n+\n+   struct S {\n+     void fn (int p) noexcept(noexcept(p));\n+   };\n+\n+   so we need to make sure name lookup can find them.  This is used\n+   when we delay parsing of the noexcept-specifier.  */\n+\n+static void\n+inject_parm_decls (tree decl)\n+{\n+  begin_scope (sk_function_parms, decl);\n+  tree args = DECL_ARGUMENTS (decl);\n+\n+  do_push_parm_decls (decl, args, /*nonparms=*/NULL);\n+}\n+\n+/* Undo the effects of inject_parm_decls.  */\n+\n+static void\n+pop_injected_parms (void)\n+{\n+  pop_bindings_and_leave_scope ();\n+}\n+\n /* Parse a class-specifier.\n \n    class-specifier:\n@@ -23620,6 +23657,60 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n       vec_safe_truncate (unparsed_classes, 0);\n       after_nsdmi_defaulted_late_checks (type);\n \n+      /* If there are noexcept-specifiers that have not yet been processed,\n+\t take care of them now.  */\n+      class_type = NULL_TREE;\n+      pushed_scope = NULL_TREE;\n+      FOR_EACH_VEC_SAFE_ELT (unparsed_noexcepts, ix, decl)\n+\t{\n+\t  tree ctx = DECL_CONTEXT (decl);\n+\t  if (class_type != ctx)\n+\t    {\n+\t      if (pushed_scope)\n+\t\tpop_scope (pushed_scope);\n+\t      class_type = ctx;\n+\t      pushed_scope = push_scope (class_type);\n+\t    }\n+\n+\t  tree spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl));\n+\t  spec = TREE_PURPOSE (spec);\n+\n+\t  /* Make sure that any template parameters are in scope.  */\n+\t  maybe_begin_member_template_processing (decl);\n+\n+\t  /* Make sure that any member-function parameters are in scope.  */\n+\t  inject_parm_decls (decl);\n+\n+\t  /* 'this' is not allowed in static member functions.  */\n+\t  unsigned char local_variables_forbidden_p\n+\t    = parser->local_variables_forbidden_p;\n+\t  if (DECL_THIS_STATIC (decl))\n+\t    parser->local_variables_forbidden_p |= THIS_FORBIDDEN;\n+\n+\t  /* Now we can parse the noexcept-specifier.  */\n+\t  spec = cp_parser_late_noexcept_specifier (parser, spec);\n+\n+\t  if (spec != error_mark_node)\n+\t    TREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl), spec);\n+\n+\t  /* Restore the state of local_variables_forbidden_p.  */\n+\t  parser->local_variables_forbidden_p = local_variables_forbidden_p;\n+\n+\t  /* The finish_struct call above performed various override checking,\n+\t     but it skipped unparsed noexcept-specifier operands.  Now that we\n+\t     have resolved them, check again.  */\n+\t  noexcept_override_late_checks (type, decl);\n+\n+\t  /* Remove any member-function parameters from the symbol table.  */\n+\t  pop_injected_parms ();\n+\n+\t  /* Remove any template parameters from the symbol table.  */\n+\t  maybe_end_member_template_processing ();\n+\t}\n+      vec_safe_truncate (unparsed_noexcepts, 0);\n+      if (pushed_scope)\n+\tpop_scope (pushed_scope);\n+\n       /* Now parse the body of the functions.  */\n       if (flag_openmp)\n \t{\n@@ -25175,6 +25266,89 @@ cp_parser_base_specifier (cp_parser* parser)\n \n /* Exception handling [gram.exception] */\n \n+/* Save the tokens that make up the noexcept-specifier for a member-function.\n+   Returns a DEFAULT_ARG.  */\n+\n+static tree\n+cp_parser_save_noexcept (cp_parser *parser)\n+{\n+  cp_token *first = parser->lexer->next_token;\n+  /* We want everything up to, including, the final ')'.  */\n+  cp_parser_cache_group (parser, CPP_CLOSE_PAREN, /*depth=*/0);\n+  cp_token *last = parser->lexer->next_token;\n+\n+  /* As with default arguments and NSDMIs, make use of DEFAULT_ARG\n+     to carry the information we will need.  */\n+  tree expr = make_node (DEFAULT_ARG);\n+  /* Save away the noexcept-specifier; we will process it when the\n+     class is complete.  */\n+  DEFARG_TOKENS (expr) = cp_token_cache_new (first, last);\n+  expr = build_tree_list (expr, NULL_TREE);\n+  return expr;\n+}\n+\n+/* Used for late processing of noexcept-specifiers of member-functions.\n+   DEFAULT_ARG is the unparsed operand of a noexcept-specifier which\n+   we saved for later; parse it now.  */\n+\n+static tree\n+cp_parser_late_noexcept_specifier (cp_parser *parser, tree default_arg)\n+{\n+  /* Make sure we've gotten something that hasn't been parsed yet.  */\n+  gcc_assert (TREE_CODE (default_arg) == DEFAULT_ARG);\n+\n+  push_unparsed_function_queues (parser);\n+\n+  /* Push the saved tokens for the noexcept-specifier onto the parser's\n+     lexer stack.  */\n+  cp_token_cache *tokens = DEFARG_TOKENS (default_arg);\n+  cp_parser_push_lexer_for_tokens (parser, tokens);\n+\n+  /* Parse the cached noexcept-specifier.  */\n+  tree parsed_arg\n+    = cp_parser_noexcept_specification_opt (parser,\n+\t\t\t\t\t    /*require_constexpr=*/true,\n+\t\t\t\t\t    /*consumed_expr=*/NULL,\n+\t\t\t\t\t    /*return_cond=*/false,\n+\t\t\t\t\t    /*friend_p=*/false);\n+\n+  /* Revert to the main lexer.  */\n+  cp_parser_pop_lexer (parser);\n+\n+  /* Restore the queue.  */\n+  pop_unparsed_function_queues (parser);\n+\n+  /* And we're done.  */\n+  return parsed_arg;\n+}\n+\n+/* Perform late checking of overriding function with respect to their\n+   noexcept-specifiers.  TYPE is the class and FNDECL is the function\n+   that potentially overrides some virtual function with the same\n+   signature.  */\n+\n+static void\n+noexcept_override_late_checks (tree type, tree fndecl)\n+{\n+  tree binfo = TYPE_BINFO (type);\n+  tree base_binfo;\n+\n+  if (DECL_STATIC_FUNCTION_P (fndecl))\n+    return;\n+\n+  for (int i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n+    {\n+      tree basetype = BINFO_TYPE (base_binfo);\n+\n+      if (!TYPE_POLYMORPHIC_P (basetype))\n+\tcontinue;\n+\n+      tree fn = look_for_overrides_here (basetype, fndecl);\n+      if (fn)\n+\tmaybe_check_overriding_exception_spec (fndecl, fn);\n+    }\n+}\n+\n /* Parse an (optional) noexcept-specification.\n \n    noexcept-specification:\n@@ -25185,13 +25359,15 @@ cp_parser_base_specifier (cp_parser* parser)\n    expression if parentheses follow noexcept, or return BOOLEAN_TRUE_NODE if\n    there are no parentheses.  CONSUMED_EXPR will be set accordingly.\n    Otherwise, returns a noexcept specification unless RETURN_COND is true,\n-   in which case a boolean condition is returned instead.  */\n+   in which case a boolean condition is returned instead.  If FRIEND_P is true,\n+   the function with this noexcept-specification had the `friend' specifier.  */\n \n static tree\n cp_parser_noexcept_specification_opt (cp_parser* parser,\n \t\t\t\t      bool require_constexpr,\n \t\t\t\t      bool* consumed_expr,\n-\t\t\t\t      bool return_cond)\n+\t\t\t\t      bool return_cond,\n+\t\t\t\t      bool friend_p)\n {\n   cp_token *token;\n   const char *saved_message;\n@@ -25203,6 +25379,27 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n   if (cp_parser_is_keyword (token, RID_NOEXCEPT))\n     {\n       tree expr;\n+\n+      /* [class.mem]/6 says that a noexcept-specifer (within the\n+\t member-specification of the class) is a complete-class context of\n+\t a class.  So, if the noexcept-specifier has the optional expression,\n+\t just save the tokens, and reparse this after we're done with the\n+\t class.  */\n+      const bool literal_p\n+\t= ((cp_lexer_nth_token_is (parser->lexer, 3, CPP_NUMBER)\n+\t    || cp_lexer_nth_token_is (parser->lexer, 3, CPP_KEYWORD))\n+\t   && cp_lexer_nth_token_is (parser->lexer, 4, CPP_CLOSE_PAREN));\n+\n+      if (cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN)\n+\t  /* No need to delay parsing for a number literal or true/false.  */\n+\t  && !literal_p\n+\t  && at_class_scope_p ()\n+\t  /* Don't delay parsing for friend member functions.  */\n+\t  && !friend_p\n+\t  && TYPE_BEING_DEFINED (current_class_type)\n+\t  && !LAMBDA_TYPE_P (current_class_type))\n+\treturn cp_parser_save_noexcept (parser);\n+\n       cp_lexer_consume_token (parser->lexer);\n \n       if (cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)\n@@ -25273,10 +25470,11 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n      throw ( type-id-list [opt] )\n \n    Returns a TREE_LIST representing the exception-specification.  The\n-   TREE_VALUE of each node is a type.  */\n+   TREE_VALUE of each node is a type.  If FRIEND_P is true, the function\n+   with this noexcept-specification had the `friend' specifier.  */\n \n static tree\n-cp_parser_exception_specification_opt (cp_parser* parser)\n+cp_parser_exception_specification_opt (cp_parser* parser, bool friend_p)\n {\n   cp_token *token;\n   tree type_id_list;\n@@ -25286,8 +25484,12 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n   token = cp_lexer_peek_token (parser->lexer);\n \n   /* Is it a noexcept-specification?  */\n-  type_id_list = cp_parser_noexcept_specification_opt (parser, true, NULL,\n-\t\t\t\t\t\t       false);\n+  type_id_list\n+    = cp_parser_noexcept_specification_opt (parser,\n+\t\t\t\t\t    /*require_constexpr=*/true,\n+\t\t\t\t\t    /*consumed_expr=*/NULL,\n+\t\t\t\t\t    /*return_cond=*/false,\n+\t\t\t\t\t    friend_p);\n   if (type_id_list != NULL_TREE)\n     return type_id_list;\n \n@@ -28435,7 +28637,7 @@ cp_parser_save_member_function_body (cp_parser* parser,\n       return error_mark_node;\n     }\n \n-  /* Remember it, if there default args to post process.  */\n+  /* Remember it, if there are default args to post process.  */\n   cp_parser_save_default_args (parser, fn);\n \n   /* Save away the tokens that make up the body of the\n@@ -28728,6 +28930,11 @@ cp_parser_save_default_args (cp_parser* parser, tree decl)\n \tvec_safe_push (unparsed_funs_with_default_args, entry);\n \tbreak;\n       }\n+\n+  /* Remember if there is a noexcept-specifier to post process.  */\n+  tree spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl));\n+  if (UNPARSED_NOEXCEPT_SPEC_P (spec))\n+    vec_safe_push (unparsed_noexcepts, decl);\n }\n \n /* DEFAULT_ARG contains the saved tokens for the initializer of DECL,\n@@ -40599,7 +40806,11 @@ cp_parser_transaction (cp_parser *parser, cp_token *token)\n       noex = NULL_TREE;\n     }\n   else\n-    noex = cp_parser_noexcept_specification_opt (parser, true, NULL, true);\n+    noex = cp_parser_noexcept_specification_opt (parser,\n+\t\t\t\t\t\t /*require_constexpr=*/true,\n+\t\t\t\t\t\t /*consumed_expr=*/NULL,\n+\t\t\t\t\t\t /*return_cond=*/true,\n+\t\t\t\t\t\t /*friend_p=*/false);\n \n   /* Keep track if we're in the lexical scope of an outer transaction.  */\n   new_in = this_in | (old_in & TM_STMT_ATTR_OUTER);\n@@ -40659,8 +40870,11 @@ cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n   parser->in_transaction = this_in;\n \n   /* Parse a noexcept specification.  */\n-  noex = cp_parser_noexcept_specification_opt (parser, false, &noex_expr,\n-\t\t\t\t\t       true);\n+  noex = cp_parser_noexcept_specification_opt (parser,\n+\t\t\t\t\t       /*require_constexpr=*/false,\n+\t\t\t\t\t       &noex_expr,\n+\t\t\t\t\t       /*return_cond=*/true,\n+\t\t\t\t\t       /*friend_p=*/false);\n \n   if (!noex || !noex_expr\n       || cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)"}, {"sha": "2890788f4899acfb5ef68eeb5915f0f7cd77fd67", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -166,6 +166,9 @@ struct GTY(()) cp_unparsed_functions_entry {\n   /* Nested classes go in this vector, so that we can do some final\n      processing after parsing any NSDMIs.  */\n   vec<tree, va_gc> *classes;\n+\n+  /* Functions with noexcept-specifiers that require post-processing.  */\n+  vec<tree, va_gc> *noexcepts;\n };\n \n "}, {"sha": "fb89b933524b98744a89f059725f3b6e500054fc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -25313,8 +25313,9 @@ dependent_type_p_r (tree type)\n \t  if (tree noex = TREE_PURPOSE (spec))\n \t    /* Treat DEFERRED_NOEXCEPT as non-dependent, since it doesn't\n \t       affect overload resolution and treating it as dependent breaks\n-\t       things.  */\n+\t       things.  Same for an unparsed noexcept expression.  */\n \t    if (TREE_CODE (noex) != DEFERRED_NOEXCEPT\n+\t\t&& TREE_CODE (noex) != DEFAULT_ARG\n \t\t&& value_dependent_expression_p (noex))\n \t      return true;\n       return false;"}, {"sha": "372c4424747b9bc28f40ecc0a2bf5979a9109dd8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -1860,6 +1860,39 @@ locate_field_accessor (tree basetype_path, tree field_decl, bool const_p)\n \t\t\t\t   NULL, &lfd);\n }\n \n+/* Check throw specifier of OVERRIDER is at least as strict as\n+   the one of BASEFN.  */\n+\n+bool\n+maybe_check_overriding_exception_spec (tree overrider, tree basefn)\n+{\n+  maybe_instantiate_noexcept (basefn);\n+  maybe_instantiate_noexcept (overrider);\n+  tree base_throw = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (basefn));\n+  tree over_throw = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (overrider));\n+\n+  if (DECL_INVALID_OVERRIDER_P (overrider))\n+    return true;\n+\n+  /* Can't check this yet.  Pretend this is fine and let\n+     noexcept_override_late_checks check this later.  */\n+  if (UNPARSED_NOEXCEPT_SPEC_P (base_throw)\n+      || UNPARSED_NOEXCEPT_SPEC_P (over_throw))\n+    return true;\n+\n+  if (!comp_except_specs (base_throw, over_throw, ce_derived))\n+    {\n+      auto_diagnostic_group d;\n+      error (\"looser exception specification on overriding virtual function \"\n+\t     \"%q+#F\", overrider);\n+      inform (DECL_SOURCE_LOCATION (basefn),\n+\t      \"overridden function is %q#F\", basefn);\n+      DECL_INVALID_OVERRIDER_P (overrider) = 1;\n+      return false;\n+    }\n+  return true;\n+}\n+\n /* Check that virtual overrider OVERRIDER is acceptable for base function\n    BASEFN. Issue diagnostic, and return zero, if unacceptable.  */\n \n@@ -1870,7 +1903,6 @@ check_final_overrider (tree overrider, tree basefn)\n   tree base_type = TREE_TYPE (basefn);\n   tree over_return = fndecl_declared_return_type (overrider);\n   tree base_return = fndecl_declared_return_type (basefn);\n-  tree over_throw, base_throw;\n \n   int fail = 0;\n \n@@ -1954,21 +1986,8 @@ check_final_overrider (tree overrider, tree basefn)\n       return 0;\n     }\n \n-  /* Check throw specifier is at least as strict.  */\n-  maybe_instantiate_noexcept (basefn);\n-  maybe_instantiate_noexcept (overrider);\n-  base_throw = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (basefn));\n-  over_throw = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (overrider));\n-\n-  if (!comp_except_specs (base_throw, over_throw, ce_derived))\n-    {\n-      auto_diagnostic_group d;\n-      error (\"looser throw specifier for %q+#F\", overrider);\n-      inform (DECL_SOURCE_LOCATION (basefn),\n-\t      \"overridden function is %q#F\", basefn);\n-      DECL_INVALID_OVERRIDER_P (overrider) = 1;\n-      return 0;\n-    }\n+  if (!maybe_check_overriding_exception_spec (overrider, basefn))\n+    return 0;\n \n   /* Check for conflicting type attributes.  But leave transaction_safe for\n      set_one_vmethod_tm_attributes.  */"}, {"sha": "ebfe362595ff8bf412012646f41470a04cb57d9a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -2546,6 +2546,7 @@ canonical_eh_spec (tree raises)\n   if (raises == NULL_TREE)\n     return raises;\n   else if (DEFERRED_NOEXCEPT_SPEC_P (raises)\n+\t   || UNPARSED_NOEXCEPT_SPEC_P (raises)\n \t   || uses_template_parms (raises)\n \t   || uses_template_parms (TREE_PURPOSE (raises)))\n     /* Keep a dependent or deferred exception specification.  */\n@@ -3656,6 +3657,7 @@ cp_tree_equal (tree t1, tree t2)\n     case IDENTIFIER_NODE:\n     case SSA_NAME:\n     case USING_DECL:\n+    case DEFAULT_ARG:\n       return false;\n \n     case BASELINK:"}, {"sha": "e38abbf7be3f42bf8d0be04f9c2227a12c1ba9d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -1,5 +1,18 @@\n 2019-06-22  Marek Polacek  <polacek@redhat.com>\n \n+\tPR c++/86476 - noexcept-specifier is a complete-class context.\n+\tPR c++/52869\n+\t* g++.dg/cpp0x/noexcept45.C: New test.\n+\t* g++.dg/cpp0x/noexcept46.C: New test.\n+\t* g++.dg/cpp0x/noexcept47.C: New test.\n+\t* g++.dg/cpp0x/noexcept48.C: New test.\n+\t* g++.dg/cpp0x/noexcept49.C: New test.\n+\t* g++.dg/cpp0x/noexcept50.C: New test.\n+\t* g++.dg/cpp0x/noexcept51.C: New test.\n+\t* g++.dg/cpp0x/noexcept52.C: New test.\n+\t* g++.dg/cpp0x/noexcept53.C: New test.\n+\t* g++.dg/eh/shadow1.C: Adjust dg-error.\n+\n \tPR c++/90881 - bogus -Wunused-value in unevaluated context.\n \t* g++.dg/cpp0x/Wunused-value1.C: New test.\n "}, {"sha": "39df4a6571ecb881ee7246a2ad5c79eff014b95f", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept45.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept45.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  virtual void f();\n+  virtual void g() noexcept;\n+  virtual void h() noexcept(false);\n+};\n+\n+struct B : A\n+{\n+  void f() noexcept(true);\n+  void g() noexcept(true);\n+  void h() noexcept(true);\n+};\n+\n+struct D : A\n+{\n+  void f() noexcept(false);\n+  void g() noexcept(false); // { dg-error \"looser exception specification\" }\n+  void h() noexcept(false);\n+};"}, {"sha": "da7490d651c6c3e158406f573d87aeb2a2026817", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept46.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept46.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept46.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept46.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+void f() noexcept(false);\n+void g() noexcept(true);\n+void h() noexcept;\n+\n+struct B {\n+  friend void f() noexcept(false);\n+  friend void g() noexcept(false); // { dg-error \"different exception specifier\" }\n+  friend void h() noexcept(false); // { dg-error \"different exception specifier\" }\n+};\n+\n+struct C {\n+  friend void f() noexcept(true); // { dg-error \"different exception specifier\" }\n+  friend void g() noexcept(true); // { dg-error \"different exception specifier\" }\n+  friend void h() noexcept(true); // { dg-error \"different exception specifier\" }\n+};\n+\n+void o() noexcept(false);\n+void p() noexcept(true);\n+void q() noexcept;\n+\n+struct D {\n+  friend void o() noexcept(true); // { dg-error \"different exception specifier\" }\n+  friend void p() noexcept(true);\n+  friend void q() noexcept(true);\n+};"}, {"sha": "0848e68f9b1dddb07ef511e2cf12076579af4b97", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept47.C", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept47.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept47.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept47.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,83 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+int fn1 ();\n+int fn2 () noexcept;\n+int fn3 () noexcept;\n+\n+void g() noexcept(noexcept (fn2()));\n+\n+struct S1 {\n+  friend void g1() noexcept(noexcept(fn2()));\n+  friend void g1() noexcept(noexcept(fn1())); // { dg-error \"different exception specifier\" }\n+};\n+\n+struct S2 {\n+  friend void g2() noexcept(noexcept(fn1()));\n+  friend void g2() noexcept(noexcept(fn1()));\n+  friend void g2() noexcept(noexcept(fn1()));\n+};\n+\n+struct S3 {\n+  friend void g3() noexcept(noexcept(fn1()));\n+  friend void g3() noexcept(noexcept(fn3())); // { dg-error \"different exception specifier\" }\n+};\n+\n+struct S4 {\n+  friend void g4() noexcept(noexcept(fn2()));\n+  friend void g4() noexcept(noexcept(fn3()));\n+};\n+\n+struct S5 {\n+  friend void g() noexcept(noexcept(fn3()));\n+};\n+\n+struct S6 {\n+  friend void g() noexcept(noexcept(fn1())); // { dg-error \"different exception specifier\" }\n+};\n+\n+struct S7 {\n+  friend void gg() noexcept(noexcept(fn3()));\n+};\n+\n+void gg() noexcept(noexcept(fn1())); // { dg-error \"different exception specifier\" }\n+\n+struct S8 {\n+  friend void g8();\n+  friend void g8() noexcept(noexcept(fn2())); // { dg-error \"different exception specifier\" }\n+};\n+\n+struct S9 {\n+  friend void g9();\n+  friend void g9() noexcept(noexcept(fn1()));\n+};\n+\n+struct S10 {\n+  friend void g10() noexcept(noexcept(fn1()));\n+  friend void g10();\n+};\n+\n+struct S11 {\n+  friend void g11() noexcept(noexcept(fn2()));\n+  friend void g11(); // { dg-error \"different exception specifier\" }\n+};\n+\n+struct S12 {\n+  friend void g12() noexcept(false);\n+  friend void g12() noexcept(noexcept(fn2())); // { dg-error \"different exception specifier\" }\n+};\n+\n+struct S13 {\n+  friend void g13() noexcept(false);\n+  friend void g13() noexcept(noexcept(fn1()));\n+};\n+\n+struct S14 {\n+  friend void g14() noexcept(noexcept(fn1()));\n+  friend void g14() noexcept(false);\n+};\n+\n+struct S15 {\n+  friend void g15() noexcept(noexcept(fn2()));\n+  friend void g15() noexcept(false); // { dg-error \"different exception specifier\" }\n+};"}, {"sha": "134212c3613db3e3b238150d92886e2958e0ccf9", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept48.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept48.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept48.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept48.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+int g;\n+\n+struct S {\n+  int b;\n+  friend void fn1(int n) noexcept(noexcept(n));\n+  friend void fn2() noexcept(noexcept(g));\n+  friend void fn3() noexcept(noexcept(b));\n+};"}, {"sha": "6da7ff3361f582ca38e09ce405feabb2d3af3085", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept49.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept49.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept49.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept49.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+#define SA(X) static_assert(X, #X)\n+\n+struct S {\n+  static void f1() noexcept(b);\n+  static constexpr auto b = true;\n+};\n+\n+S s;\n+SA(noexcept(s.f1()));"}, {"sha": "43b38c2446f07683af3b561194033ccf35505668", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept50.C", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept50.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept50.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept50.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,147 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+#define SA(X) static_assert(X, #X)\n+\n+struct S {\n+  void f1() noexcept(noexcept(i)) { }\n+  void f2() noexcept(noexcept(fn())) { }\n+  void f3() noexcept(noexcept(fnx())) { }\n+  void f4() noexcept(noexcept(i));\n+  void f5() noexcept(noexcept(fn()));\n+  void f6() noexcept(noexcept(fnx()));\n+\n+  void f7() noexcept(1);\n+  void f8() noexcept(0);\n+  void f9() noexcept(b);\n+  void f10() noexcept(!b);\n+\n+  int i;\n+  static constexpr auto b = true;\n+  void fny() noexcept(noexcept(fn()));\n+  void fn();\n+  void fnx() noexcept;\n+};\n+\n+S s;\n+SA(noexcept(s.f1()));\n+SA(!noexcept(s.f2()));\n+SA(noexcept(s.f3()));\n+SA(noexcept(s.f4()));\n+SA(!noexcept(s.f5()));\n+SA(noexcept(s.f6()));\n+SA(noexcept(s.f7()));\n+SA(!noexcept(s.f8()));\n+SA(noexcept(s.f9()));\n+SA(!noexcept(s.f10()));\n+\n+struct S2 {\n+  struct V {\n+    void f1() noexcept(noexcept(fn()));\n+    void f2() noexcept(noexcept(fnx()));\n+    void f3() noexcept(noexcept(fn())) { }\n+    void f4() noexcept(noexcept(fnx())) { }\n+    void fn();\n+    void fnx() noexcept;\n+  } v;\n+  void fn();\n+  void fnx();\n+};\n+\n+S2 s2;\n+SA(!noexcept(s2.v.f1()));\n+SA(noexcept(s2.v.f2()));\n+SA(!noexcept(s2.v.f3()));\n+SA(noexcept(s2.v.f4()));\n+\n+struct S3 {\n+  void f1() noexcept(noexcept(fn()));\n+  void f2() noexcept(noexcept(fnx()));\n+  void fn();\n+  void fnx() noexcept;\n+};\n+\n+void\n+S3::f1() noexcept(noexcept(fn()))\n+{\n+}\n+\n+void\n+S3::f2() noexcept(noexcept(fnx()))\n+{\n+}\n+\n+struct S4 {\n+  int f1 (int p) noexcept(noexcept(p)) { return p; }\n+  int f2 (int p) noexcept(noexcept(p));\n+  int f3 (int p = 10) noexcept(noexcept(p));\n+  int f4 () noexcept(noexcept(S4{}));\n+};\n+\n+S4 s4;\n+SA(noexcept(s4.f1(1)));\n+SA(noexcept(s4.f2(1)));\n+SA(noexcept(s4.f3()));\n+SA(noexcept(s4.f4()));\n+\n+template<typename T>\n+struct S5 {\n+  void f1() noexcept(noexcept(i)) { }\n+  void f2() noexcept(noexcept(fn())) { }\n+  void f3() noexcept(noexcept(fnx())) { }\n+  void f4() noexcept(noexcept(i));\n+  void f5() noexcept(noexcept(fn()));\n+  void f6() noexcept(noexcept(fnx()));\n+    \n+  int i;\n+  void fny() noexcept(noexcept(fn()));\n+  void fn();\n+  void fnx() noexcept;\n+};\n+\n+S5<int> s5;\n+SA(noexcept(s5.f1()));\n+SA(!noexcept(s5.f2()));\n+SA(noexcept(s5.f3()));\n+SA(noexcept(s5.f4()));\n+SA(!noexcept(s5.f5()));\n+SA(noexcept(s5.f6()));\n+\n+template<typename T>\n+struct S6 {\n+  void f1() noexcept(noexcept(x));\n+  T x;\n+};\n+\n+struct S7 {\n+  template<typename U>\n+  void f1 () noexcept(noexcept(U(1))) { }\n+\n+  template<int N>\n+  void f2() noexcept(noexcept(N));\n+\n+  template <typename _Up>\n+  void f3(_Up __p) noexcept(noexcept(__p));\n+};\n+\n+void glob();\n+void globx() noexcept;\n+struct S8 {\n+  void f1 () noexcept(noexcept(glob()));\n+  void f2 () noexcept(noexcept(globx()));\n+};\n+\n+S8 s8;\n+SA(!noexcept(s8.f1()));\n+SA(noexcept(s8.f2()));\n+\n+struct W {\n+  constexpr operator bool();\n+};\n+\n+template<typename T>\n+struct S9 {\n+  S9() noexcept(noexcept(w)) { }\n+  S9 &operator=(S9 &&) noexcept(T::X);\n+  W w;\n+};"}, {"sha": "a81032f28e9662e8db7e9f1b931a551b3453d948", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept51.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept51.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept51.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept51.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+void fn1(void());\n+template <typename> class A {\n+  void _M_local_data();\n+  A() noexcept(_M_local_data);\n+};\n+\n+class B {\n+  void _S_initialize();\n+  static void _S_initialize_once();\n+};\n+void B::_S_initialize() { fn1(_S_initialize_once); }"}, {"sha": "12c6d364099ad667dcd7372416d54eb7be15c45b", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept52.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept52.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept52.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept52.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+template <typename _Alloc> class A {\n+  typedef _Alloc _Alloc_traits;\n+  A &operator=(A &&) noexcept(_Alloc_traits::_S_nothrow_move);\n+  A &m_fn1(A &&) noexcept(_Alloc_traits::_S_nothrow_move);\n+  void m_fn2(A<char>) {}\n+};"}, {"sha": "b3859de9ebc9a0ef900984d9a10896e8aea8244f", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept53.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept53.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept53.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept53.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/86476 - noexcept-specifier is a complete-class context\n+// { dg-do compile { target c++11 } }\n+\n+struct S {\n+  void f1() noexcept(noexcept(fn()));\n+  void f2() noexcept(noexcept(fnx()));\n+  void fn();\n+  void fnx() noexcept;\n+};\n+\n+void\n+S::f1() noexcept // { dg-error \"different exception specifier\" }\n+{\n+}\n+\n+void\n+S::f2() // { dg-error \"different exception specifier\" }\n+{\n+}\n+\n+struct S2 {\n+  void f1() noexcept(noexcept(nosuchfn())); // { dg-error \"not declared in this scope\" }\n+  void f2() noexcept(noexcept(nothere)); // { dg-error \"not declared in this scope\" }\n+  void f3() noexcept(noexcept(nosuchfn())) { } // { dg-error \"not declared in this scope\" }\n+  void f4() noexcept(noexcept(nothere)) { } // { dg-error \"not declared in this scope\" }\n+};"}, {"sha": "6bccc704d4998a0e9464d8fadd4948bb6bb6ad2f", "filename": "gcc/testsuite/g++.dg/eh/shadow1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fshadow1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78f7607db4c53f8cfe4653a6c91c0328bc2854c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fshadow1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fshadow1.C?ref=78f7607db4c53f8cfe4653a6c91c0328bc2854c3", "patch": "@@ -18,7 +18,7 @@ struct D : private B\n \t\t\t\t// { dg-warning \"deprecated\" \"\" { target { c++11 && { ! c++17 } } } .-2 }\n struct E : public D\n {\n-  virtual void V () throw (D); // { dg-error \"looser throw\" \"\" { target { ! c++17 } } }\n+  virtual void V () throw (D); // { dg-error \"looser exception\" \"\" { target { ! c++17 } } }\n };\t\t\t       // { dg-error \"dynamic exception specification\" \"\" { target c++17 } .-1 }\n \t\t\t       // { dg-warning \"deprecated\" \"\" { target { c++11 && { ! c++17 } } } .-2 }\n B* foo (D *);"}]}