{"sha": "112cdef5e66fccce5475fabb5317805e012dc212", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEyY2RlZjVlNjZmY2NjZTU0NzVmYWJiNTMxNzgwNWUwMTJkYzIxMg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-09-18T19:19:40Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-09-18T19:19:40Z"}, "message": "darwin-c.c, [...]: Fix comment typos.\n\n\t* config/darwin-c.c, config/arc/arc.c, config/arc/arc.md,\n\tconfig/arm/README-interworking, config/arm/arm-cores.def,\n\tconfig/arm/arm.c, config/arm/arm.h, config/arm/pe.c,\n\tconfig/arm/vfp.md, config/c4x/c4x.c, config/c4x/c4x.h,\n\tconfig/cris/cris.c, config/cris/cris.h, config/fr30/fr30.c,\n\tconfig/fr30/fr30.h, config/fr30/fr30.md, config/frv/frv.c,\n\tconfig/frv/frv.md, config/i386/winnt.c,\n\tconfig/ia64/unwind-ia64.c, config/iq2000/iq2000.c,\n\tconfig/iq2000/iq2000.h, config/m68hc11/m68hc11.c,\n\tconfig/m68hc11/m68hc11.md, config/m68k/m68k.c,\n\tconfig/mcore/mcore.c, config/mips/mips.h,\n\tconfig/mn10300/mn10300.md, config/pa/pa.c,\n\tconfig/pa/pa64-regs.h, config/pdp11/pdp11.c,\n\tconfig/rs6000/rs6000.c, config/sh/symbian.c,\n\tconfig/sparc/sparc.h: Fix comment typos.  Follow spelling\n\tconventions.\n\nFrom-SVN: r87706", "tree": {"sha": "b5db05c8d76e4eb55fa3eba83d2a2eac1b12bf33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5db05c8d76e4eb55fa3eba83d2a2eac1b12bf33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/112cdef5e66fccce5475fabb5317805e012dc212", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112cdef5e66fccce5475fabb5317805e012dc212", "html_url": "https://github.com/Rust-GCC/gccrs/commit/112cdef5e66fccce5475fabb5317805e012dc212", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/112cdef5e66fccce5475fabb5317805e012dc212/comments", "author": null, "committer": null, "parents": [{"sha": "ad97f4bed6ac21187cce4f9267279d13ae56ecab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad97f4bed6ac21187cce4f9267279d13ae56ecab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad97f4bed6ac21187cce4f9267279d13ae56ecab"}], "stats": {"total": 149, "additions": 84, "deletions": 65}, "files": [{"sha": "1ede93d3fb33068c430fe437f763b88471760f1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -1,3 +1,22 @@\n+2004-09-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/darwin-c.c, config/arc/arc.c, config/arc/arc.md,\n+\tconfig/arm/README-interworking, config/arm/arm-cores.def,\n+\tconfig/arm/arm.c, config/arm/arm.h, config/arm/pe.c,\n+\tconfig/arm/vfp.md, config/c4x/c4x.c, config/c4x/c4x.h,\n+\tconfig/cris/cris.c, config/cris/cris.h, config/fr30/fr30.c,\n+\tconfig/fr30/fr30.h, config/fr30/fr30.md, config/frv/frv.c,\n+\tconfig/frv/frv.md, config/i386/winnt.c,\n+\tconfig/ia64/unwind-ia64.c, config/iq2000/iq2000.c,\n+\tconfig/iq2000/iq2000.h, config/m68hc11/m68hc11.c,\n+\tconfig/m68hc11/m68hc11.md, config/m68k/m68k.c,\n+\tconfig/mcore/mcore.c, config/mips/mips.h,\n+\tconfig/mn10300/mn10300.md, config/pa/pa.c,\n+\tconfig/pa/pa64-regs.h, config/pdp11/pdp11.c,\n+\tconfig/rs6000/rs6000.c, config/sh/symbian.c,\n+\tconfig/sparc/sparc.h: Fix comment typos.  Follow spelling\n+\tconventions.\n+\n 2004-09-18  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/17424"}, {"sha": "9773d697f339ee313ac32c92a5afd41c9fae8330", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -1971,7 +1971,7 @@ arc_final_prescan_insn (rtx insn,\n   /* BODY will hold the body of INSN.  */\n   register rtx body = PATTERN (insn);\n \n-  /* This will be 1 if trying to repeat the trick (ie: do the `else' part of\n+  /* This will be 1 if trying to repeat the trick (i.e.: do the `else' part of\n      an if/then/else), and things need to be reversed.  */\n   int reverse = 0;\n "}, {"sha": "54f252e03536c333117bf23652aaf56868f593d2", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -69,7 +69,7 @@\n ;; conditionalizing instructions.  It saves having to scan the rtl to see if\n ;; it uses or alters the condition codes.\n \n-;; USE: This insn uses the condition codes (eg: a conditional branch).\n+;; USE: This insn uses the condition codes (e.g.: a conditional branch).\n ;; CANUSE: This insn can use the condition codes (for conditional execution).\n ;; SET: All condition codes are set by this insn.\n ;; SET_ZN: the Z and N flags are set by this insn."}, {"sha": "d221e1555760ea7e9c472e2e9b3e97c08a195665", "filename": "gcc/config/arm/README-interworking", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2FREADME-interworking", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2FREADME-interworking", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2FREADME-interworking?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -78,7 +78,7 @@ then the following rules must be obeyed:\n \n \t* All externally visible functions which should be entered in\n \tThumb mode must have the .thumb_func pseudo op specified just\n-\tbefore their entry point.  eg:\n+\tbefore their entry point.  e.g.:\n \n \t\t\t.code 16\n \t\t\t.global function"}, {"sha": "e07060382a23d84c1e0ee06d8a64d152f4b7988c", "filename": "gcc/config/arm/arm-cores.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Farm-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Farm-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cores.def?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -25,7 +25,7 @@\n \n    The CORE_NAME is the name of the core, represented as a string constant.\n    The CORE_IDENT is the name of the core, represented as an identifier.\n-   ARCH is the architecture revision implemeted by the chip.\n+   ARCH is the architecture revision implemented by the chip.\n    FLAGS are the bitwise-or of the traits that apply to that core.\n    This need not include flags implied by the architecture.\n    COSTS is the name of the rtx_costs routine to use."}, {"sha": "a8934c3e475fa5022a781d17791740140a1752b6", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -2108,7 +2108,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \n        Therefore, we calculate how many insns would be required to emit\n        the constant starting from `best_start', and also starting from\n-       zero (ie with bit 31 first to be output).  If `best_start' doesn't\n+       zero (i.e. with bit 31 first to be output).  If `best_start' doesn't\n        yield a shorter sequence, we may as well use zero.  */\n     if (best_start != 0\n \t&& ((((unsigned HOST_WIDE_INT) 1) << best_start) < remainder)\n@@ -3133,7 +3133,7 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n     {\n       rtx addend = XEXP (XEXP (x, 1), 1);\n \n-      /* Don't allow ldrd post increment by register becuase it's hard\n+      /* Don't allow ldrd post increment by register because it's hard\n \t to fixup invalid register choices.  */\n       if (use_ldrd\n \t  && GET_CODE (x) == POST_MODIFY\n@@ -5051,7 +5051,7 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n     abort ();\n \n   /* Loop over the operands and check that the memory references are\n-     suitable (ie immediate offsets from the same base register).  At\n+     suitable (i.e. immediate offsets from the same base register).  At\n      the same time, extract the target register, and the memory\n      offsets.  */\n   for (i = 0; i < nops; i++)\n@@ -5280,7 +5280,7 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n     abort ();\n \n   /* Loop over the operands and check that the memory references are\n-     suitable (ie immediate offsets from the same base register).  At\n+     suitable (i.e. immediate offsets from the same base register).  At\n      the same time, extract the target register, and the memory\n      offsets.  */\n   for (i = 0; i < nops; i++)\n@@ -8844,7 +8844,7 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n       const char * return_reg;\n \n       /* If we do not have any special requirements for function exit\n-\t (eg interworking, or ISR) then we can load the return address\n+\t (e.g. interworking, or ISR) then we can load the return address\n \t directly into the PC.  Otherwise we must load it into LR.  */\n       if (really_return\n \t  && ! TARGET_INTERWORK)\n@@ -9408,7 +9408,7 @@ arm_output_epilogue (rtx sibling)\n \t{\n \t  if (saved_regs_mask & (1 << SP_REGNUM))\n \t    /* Note - write back to the stack register is not enabled\n-\t       (ie \"ldmfd sp!...\").  We know that the stack pointer is\n+\t       (i.e. \"ldmfd sp!...\").  We know that the stack pointer is\n \t       in the list of registers and if we add writeback the\n \t       instruction becomes UNPREDICTABLE.  */\n \t    print_multi_reg (f, \"ldmfd\\t%r\", SP_REGNUM, saved_regs_mask);\n@@ -10422,7 +10422,7 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'D':\n-      /* CONST_TRUE_RTX means not always -- ie never.  We shouldn't ever\n+      /* CONST_TRUE_RTX means not always -- i.e. never.  We shouldn't ever\n \t want to do that.  */\n       if (x == const_true_rtx)\n \tabort ();\n@@ -11002,7 +11002,7 @@ arm_final_prescan_insn (rtx insn)\n \t\t  else if (GET_CODE (SET_SRC (scanbody)) == IF_THEN_ELSE)\n \t\t    fail = TRUE;\n \t\t}\n-\t      /* Fail if a conditional return is undesirable (eg on a\n+\t      /* Fail if a conditional return is undesirable (e.g. on a\n \t\t StrongARM), but still allow this if optimizing for size.  */\n \t      else if (GET_CODE (scanbody) == RETURN\n \t\t       && !use_return_insn (TRUE, NULL)\n@@ -11026,7 +11026,7 @@ arm_final_prescan_insn (rtx insn)\n \t\t    }\n \t\t}\n \t      else\n-\t\tfail = TRUE;\t/* Unrecognized jump (eg epilogue).  */\n+\t\tfail = TRUE;\t/* Unrecognized jump (e.g. epilogue).  */\n \n \t      break;\n \n@@ -12650,7 +12650,7 @@ thumb_unexpanded_epilogue (void)\n   size = GET_MODE_SIZE (mode);\n \n   /* The prolog may have pushed some high registers to use as\n-     work registers.  eg the testsuite file:\n+     work registers.  e.g. the testsuite file:\n      gcc/testsuite/gcc/gcc.c-torture/execute/complex-2.c\n      compiles to produce:\n \tpush\t{r4, r5, r6, r7, lr}"}, {"sha": "beecc29e931c0ce15867564a8058a2f6f04c1278", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -1595,7 +1595,7 @@ enum reg_class\n #define CALL_SHORT\t\t0x00000002\t/* Never call indirect.  */\n \n /* These bits describe the different types of function supported\n-   by the ARM backend.  They are exclusive.  ie a function cannot be both a\n+   by the ARM backend.  They are exclusive.  i.e. a function cannot be both a\n    normal function and an interworked function, for example.  Knowing the\n    type of a function is important for determining its prologue and\n    epilogue sequences."}, {"sha": "622f7d29bd8df27673fc499561513e2abdec1782", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -96,7 +96,7 @@ arm_dllimport_name_p (symbol)\n }\n \n /* Mark a DECL as being dllexport'd.\n-   Note that we override the previous setting (eg: dllimport).  */\n+   Note that we override the previous setting (e.g.: dllimport).  */\n \n void\n arm_mark_dllexport (decl)"}, {"sha": "c6a485d8617ecf1df38b40a12b9c1485ebaee2cd", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -56,7 +56,7 @@\n (define_cpu_unit \"vfp_ls\" \"vfp11\")\n \n ;; The VFP \"type\" attributes differ from those used in the FPA model.\n-;; ffarith\tFast floating point insns, eg. abs, neg, cpy, cmp.\n+;; ffarith\tFast floating point insns, e.g. abs, neg, cpy, cmp.\n ;; farith\tMost arithmetic insns.\n ;; fmul\t\tDouble precision multiply.\n ;; fdivs\tSingle precision sqrt or division."}, {"sha": "9c9dc0ed7598f444c312f8d313c4756eb34fba22", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -3342,7 +3342,7 @@ tsrc_operand (rtx op, enum machine_mode mode)\n }\n \n \n-/* Check src operand of two operand non immedidate instructions.  */\n+/* Check src operand of two operand non immediate instructions.  */\n \n int\n nonimmediate_src_operand (rtx op, enum machine_mode mode)\n@@ -3354,7 +3354,7 @@ nonimmediate_src_operand (rtx op, enum machine_mode mode)\n }\n \n \n-/* Check logical src operand of two operand non immedidate instructions.  */\n+/* Check logical src operand of two operand non immediate instructions.  */\n \n int\n nonimmediate_lsrc_operand (rtx op, enum machine_mode mode)"}, {"sha": "18f31805d6f0977817749d2f9a92eb2ebe04c504", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -1372,7 +1372,7 @@ CUMULATIVE_ARGS;\n \n #define LEGITIMATE_DISPLACEMENT_P(X) IS_DISP8_CONST (INTVAL (X))\n \n-/* Descripting Relative Cost of Operations.  */\n+/* Describing Relative Cost of Operations.  */\n \n #define\tCANONICALIZE_COMPARISON(CODE, OP0, OP1)\t\t\\\n if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\"}, {"sha": "de306e07421d78cd050169812cb447c04fbb12af", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -3099,7 +3099,7 @@ cris_output_addr_const (FILE *file, rtx x)\n       break;\n \n     case PLUS:\n-      /* Some assemblers need integer constants to appear last (eg masm).  */\n+      /* Some assemblers need integer constants to appear last (e.g. masm).  */\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n \t{\n \t  cris_output_addr_const (file, XEXP (x, 1));"}, {"sha": "14c6a95d8eca7bb7728095448430da39f581b28e", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -336,7 +336,7 @@ extern int target_flags;\n /* Whether or not to work around multiplication instruction hardware bug\n    when generating code for models where it may be present.  From the\n    trouble report for Etrax 100 LX: \"A multiply operation may cause\n-   incorrect cache behaviour under some specific circumstances. The\n+   incorrect cache behavior under some specific circumstances. The\n    problem can occur if the instruction following the multiply instruction\n    causes a cache miss, and multiply operand 1 (source operand) bits\n    [31:27] matches the logical mapping of the mode register address"}, {"sha": "167b7958c84d231a0cf0ead4d2917d79d3f767d2", "filename": "gcc/config/darwin-c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fdarwin-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fdarwin-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-c.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -442,7 +442,7 @@ darwin_register_objc_includes (const char *sysroot, const char *iprefix,\n     {\n       char *str;\n       /* See if our directory starts with the standard prefix.\n-\t \"Translate\" them, ie. replace /usr/local/lib/gcc... with\n+\t \"Translate\" them, i.e. replace /usr/local/lib/gcc... with\n \t IPREFIX and search them first.  */\n       if (iprefix && (len = cpp_GCC_INCLUDE_DIR_len) != 0 && !sysroot\n \t  && !strncmp (fname, cpp_GCC_INCLUDE_DIR, len))"}, {"sha": "7e890346b07b5ca33fef83ea78b3d6b9c33758d6", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -709,7 +709,7 @@ int\n fr30_function_arg_partial_nregs (CUMULATIVE_ARGS cum, enum machine_mode mode,\n \t\t\t\t tree type, int named)\n {\n-  /* Unnamed arguments, ie those that are prototyped as ...\n+  /* Unnamed arguments, i.e. those that are prototyped as ...\n      are always passed on the stack.\n      Also check here to see if all the argument registers are full.  */\n   if (named == 0 || cum >= FR30_NUM_ARG_REGS)"}, {"sha": "5a2b20f199b25a11a198858a80c4eda47ef1bc8f", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -293,7 +293,7 @@ enum reg_class\n   MULTIPLY_64_REG,\t/* the MDH,MDL register pair as used by MUL and MULU */\n   LOW_REGS,\t\t/* registers 0 through 7 */\n   HIGH_REGS,\t\t/* registers 8 through 15 */\n-  REAL_REGS,\t\t/* ie all the general hardware registers on the FR30 */\n+  REAL_REGS,\t\t/* i.e. all the general hardware registers on the FR30 */\n   ALL_REGS,\n   LIM_REG_CLASSES\n };"}, {"sha": "8fc5e108eed8c87bd2686a07d3032d46c04e9731", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -370,7 +370,7 @@\n \n ;; Note - the FR30 does not have an 8 byte load/store instruction\n ;; but we have to support this pattern because some other patterns\n-;; (eg muldisi2) can produce a DImode result.\n+;; (e.g. muldisi2) can produce a DImode result.\n ;; (This code is stolen from the M32R port.)\n \n (define_expand \"movdi\"\n@@ -637,7 +637,7 @@\n )\n \n ;; We need some trickery to be able to handle the addition of\n-;; large (ie outside +/- 16) constants.  We need to be able to\n+;; large (i.e. outside +/- 16) constants.  We need to be able to\n ;; handle this because reload assumes that it can generate add\n ;; instructions with arbitrary sized constants.\n (define_expand \"addsi3\"\n@@ -1153,7 +1153,7 @@\n ;;               -256 <= pc < 256\n ;; or\n ;;\t   -256 + 256 <= pc + 256 < 256 + 256\n-;; ie\n+;; i.e.\n ;;\t\t    0 <= pc + 256 < 512 \n ;;\n ;; if we consider the displacement as an unsigned value, then negative"}, {"sha": "b4021c7706fdff663d9ce5700e18672f66033cdc", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -9551,7 +9551,7 @@ frv_int_to_acc (enum insn_code icode, int opnum, rtx opval)\n   rtx reg;\n   int i;\n \n-  /* ACCs and ACCGs are implicity global registers if media instrinsics\n+  /* ACCs and ACCGs are implicity global registers if media intrinsics\n      are being used.  We set up this lazily to avoid creating lots of\n      unnecessary call_insn rtl in non-media code.  */\n   for (i = 0; i <= ACC_MASK; i++)"}, {"sha": "a3f9453d0c1c5e4519870ac20f33f722587a958a", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -1445,7 +1445,7 @@\n \n ;; If you need to construct a sequence of assembler instructions in order\n ;; to implement a pattern be sure to escape any backslashes and double quotes\n-;; that you use, eg:\n+;; that you use, e.g.:\n ;;\n ;; (define_insn \"an example\"\n ;;   [(some rtl)]"}, {"sha": "845960eb3e93d68ea98d0141942068554fd14f77", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -231,7 +231,7 @@ i386_pe_dllimport_name_p (const char *symbol)\n }\n \n /* Mark a DECL as being dllexport'd.\n-   Note that we override the previous setting (eg: dllimport).  */\n+   Note that we override the previous setting (e.g.: dllimport).  */\n \n static void\n i386_pe_mark_dllexport (tree decl)"}, {"sha": "31b0e4cdf585b1cf22075fda32f276b6a13c04d0", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -2111,7 +2111,7 @@ uw_init_context_1 (struct _Unwind_Context *context, void *bsp)\n   uw_update_context (context, &fs);\n }\n \n-/* Install (ie longjmp to) the contents of TARGET.  */\n+/* Install (i.e. longjmp to) the contents of TARGET.  */\n \n static void __attribute__((noreturn))\n uw_install_context (struct _Unwind_Context *current __attribute__((unused)),"}, {"sha": "a93e7947870c7b7d0f26c2ad4bf1fa3d28565c6e", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -143,7 +143,7 @@ static int dslots_jump_total;\n /* # of nops needed by previous insn.  */\n static int dslots_number_nops;\n \n-/* Number of 1/2/3 word references to data items (ie, not jal's).  */\n+/* Number of 1/2/3 word references to data items (i.e., not jal's).  */\n static int num_refs[3];\n \n /* Registers to check for load delay.  */\n@@ -293,7 +293,7 @@ reg_or_0_operand (rtx op, enum machine_mode mode)\n }\n \n /* Return 1 if OP is a memory operand that fits in a single instruction\n-   (ie, register + small offset).  */\n+   (i.e., register + small offset).  */\n \n int\n simple_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)"}, {"sha": "41abc9bdc17bc02c1ff5ee4e7f40252ca962de7c", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -307,16 +307,16 @@ enum reg_class\n    `I'\tis used for the range of constants an arithmetic insn can\n \tactually contain (16 bits signed integers).\n \n-   `J'\tis used for the range which is just zero (ie, $r0).\n+   `J'\tis used for the range which is just zero (i.e., $r0).\n \n    `K'\tis used for the range of constants a logical insn can actually\n \tcontain (16 bit zero-extended integers).\n \n    `L'\tis used for the range of constants that be loaded with lui\n-\t(ie, the bottom 16 bits are zero).\n+\t(i.e., the bottom 16 bits are zero).\n \n    `M'\tis used for the range of constants that take two words to load\n-\t(ie, not matched by `I', `K', and `L').\n+\t(i.e., not matched by `I', `K', and `L').\n \n    `N'\tis used for constants 0xffffnnnn or 0xnnnnffff\n "}, {"sha": "651c642d953f4a10da99afea5bc2971cd888f5ac", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -850,7 +850,7 @@ m68hc11_reload_operands (rtx operands[])\n       /* If the offset is out of range, we have to compute the address\n          with a separate add instruction.  We try to do with with an 8-bit\n          add on the A register.  This is possible only if the lowest part\n-         of the offset (ie, big_offset % 256) is a valid constant offset\n+         of the offset (i.e., big_offset % 256) is a valid constant offset\n          with respect to the mode.  If it's not, we have to generate a\n          16-bit add on the D register.  From:\n        "}, {"sha": "4ef5cd7b5a14df4841cd362a2d657f86a8a89bbc", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -67,7 +67,7 @@\n ;; Other constraints:\n ;;\n ;; Q    an operand which is in memory but whose address is constant\n-;;      (ie, a (MEM (SYMBOL_REF x))).  This constraint is used by\n+;;      (i.e., a (MEM (SYMBOL_REF x))).  This constraint is used by\n ;;      bset/bclr instructions together with linker relaxation.  The\n ;;      operand can be translated to a page0 addressing mode if the\n ;;      symbol address is in page0 (0..255).\n@@ -157,7 +157,7 @@\n ;; an auto-inc mode.  If we do this, the reload can emit move insns\n ;; after the test or compare.  Such move will set the flags and therefore\n ;; break the comparison.  This can happen if the auto-inc register\n-;; does not happen to be a hard register (ie, reloading occurs).\n+;; does not happen to be a hard register (i.e., reloading occurs).\n ;; An offsetable memory operand should be ok.  The 'tst_operand' and\n ;; 'cmp_operand' predicates take care of this rule.\n ;;\n@@ -242,7 +242,7 @@\n ;;\n ;; tstqi_z_used, cmpqi_z_used and cmphi_z_used are patterns generated \n ;; during the Z register replacement.  They are used when an operand\n-;; uses the Z register as an index register (ie, (MEM:QI (REG:HI Z))).\n+;; uses the Z register as an index register (i.e., (MEM:QI (REG:HI Z))).\n ;; In that case, we have to preserve the values of the replacement\n ;; register (as well as the CC0 since the insns are compare insns).\n ;; To do this, the replacement register is pushed on the stack and"}, {"sha": "7a7269307205cfb05e822fa16def4171fb406a76", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -2713,8 +2713,8 @@ print_operand (FILE *file, rtx op, int letter)\n \n    This routine is responsible for distinguishing between -fpic and -fPIC \n    style relocations in an address.  When generating -fpic code the\n-   offset is output in word mode (eg movel a5@(_foo:w), a0).  When generating\n-   -fPIC code the offset is output in long mode (eg movel a5@(_foo:l), a0) */\n+   offset is output in word mode (e.g. movel a5@(_foo:w), a0).  When generating\n+   -fPIC code the offset is output in long mode (e.g. movel a5@(_foo:l), a0) */\n \n #if MOTOROLA\n #  define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\"}, {"sha": "dbd3599d60f5cd25e47d86e5509b03a239d81ded", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -321,7 +321,7 @@ mcore_print_operand_address (FILE * stream, rtx x)\n /* Print operand x (an rtx) in assembler syntax to file stream\n    according to modifier code.\n \n-   'R'  print the next register or memory location along, ie the lsw in\n+   'R'  print the next register or memory location along, i.e. the lsw in\n         a double word value\n    'O'  print a constant without the #\n    'M'  print a constant as its negative\n@@ -2782,7 +2782,7 @@ conditionalize_block (rtx first)\n       if (code != BARRIER && code != NOTE && !is_cond_candidate (insn))\n \treturn NEXT_INSN (insn);\n      \n-      /* Remember the last real insn before the label (ie end of block 2).  */\n+      /* Remember the last real insn before the label (i.e. end of block 2).  */\n       if (code == JUMP_INSN || code == INSN)\n \t{\n \t  blk_size ++;"}, {"sha": "dbae270923d7f922fc95df0f2359072dede84bab", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -835,12 +835,12 @@ extern const struct mips_cpu_info *mips_tune_info;\n    ABI for which this is true.  */\n #define ABI_HAS_64BIT_SYMBOLS\t(mips_abi == ABI_64)\n \n-/* ISA has instructions for managing 64 bit fp and gp regs (eg. mips3).  */\n+/* ISA has instructions for managing 64 bit fp and gp regs (e.g. mips3).  */\n #define ISA_HAS_64BIT_REGS\t(ISA_MIPS3\t\t\t\t\\\n \t\t\t\t || ISA_MIPS4\t\t\t\t\\\n                                  || ISA_MIPS64)\n \n-/* ISA has branch likely instructions (eg. mips2).  */\n+/* ISA has branch likely instructions (e.g. mips2).  */\n /* Disable branchlikely for tx39 until compare rewrite.  They haven't\n    been generated up to this point.  */\n #define ISA_HAS_BRANCHLIKELY\t(!ISA_MIPS1)\n@@ -1922,16 +1922,16 @@ extern enum reg_class mips_char_to_class[256];\n    `I'\tis used for the range of constants an arithmetic insn can\n \tactually contain (16 bits signed integers).\n \n-   `J'\tis used for the range which is just zero (ie, $r0).\n+   `J'\tis used for the range which is just zero (i.e., $r0).\n \n    `K'\tis used for the range of constants a logical insn can actually\n \tcontain (16 bit zero-extended integers).\n \n    `L'\tis used for the range of constants that be loaded with lui\n-\t(ie, the bottom 16 bits are zero).\n+\t(i.e., the bottom 16 bits are zero).\n \n    `M'\tis used for the range of constants that take two words to load\n-\t(ie, not matched by `I', `K', and `L').\n+\t(i.e., not matched by `I', `K', and `L').\n \n    `N'\tis used for negative 16 bit constants other than -65536.\n \n@@ -2824,7 +2824,7 @@ while (0)\n \n #define ASM_OUTPUT_ALIGNED_DECL_COMMON mips_output_aligned_decl_common\n \n-/* This says how to define a local common symbol (ie, not visible to\n+/* This says how to define a local common symbol (i.e., not visible to\n    linker).  */\n \n #ifndef ASM_OUTPUT_ALIGNED_LOCAL"}, {"sha": "8b6933b4aa62f8142dbd6fd69fd5ad6a4e9ef8b7", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -1547,7 +1547,7 @@\n       len--;\n     }\n \n-  /* If the source operand is not a reg (ie it is memory), then extract the\n+  /* If the source operand is not a reg (i.e. it is memory), then extract the\n      bits from mask that we actually want to test.  Note that the mask will\n      never cross a byte boundary.  */\n   if (!REG_P (operands[0]))"}, {"sha": "a4edfeb19cb61bfeb8a2f51a7605eb504845b810", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -3459,7 +3459,7 @@ remove_useless_addtr_insns (int check_notes)\n \t    {\n \t      rtx pattern = PATTERN (next);\n \n-\t      /* If it a reversed fp conditional branch (eg uses add,tr)\n+\t      /* If it a reversed fp conditional branch (e.g. uses add,tr)\n \t\t and CCFP dies, then reverse our conditional and the branch\n \t\t to avoid the add,tr.  */\n \t      if (GET_CODE (pattern) == SET\n@@ -6191,7 +6191,7 @@ output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)\n   int useskip = 0;\n   rtx xoperands[5];\n \n-  /* A conditional branch to the following instruction (eg the delay slot)\n+  /* A conditional branch to the following instruction (e.g. the delay slot)\n      is asking for a disaster.  This can happen when not optimizing and\n      when jump optimization fails.\n \n@@ -6500,7 +6500,7 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n   static char buf[100];\n   int useskip = 0;\n \n-  /* A conditional branch to the following instruction (eg the delay slot) is\n+  /* A conditional branch to the following instruction (e.g. the delay slot) is\n      asking for a disaster.  I do not think this can happen as this pattern\n      is only used when optimizing; jump optimization should eliminate the\n      jump.  But be prepared just in case.  */\n@@ -6645,7 +6645,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n   static char buf[100];\n   int useskip = 0;\n \n-  /* A conditional branch to the following instruction (eg the delay slot) is\n+  /* A conditional branch to the following instruction (e.g. the delay slot) is\n      asking for a disaster.  I do not think this can happen as this pattern\n      is only used when optimizing; jump optimization should eliminate the\n      jump.  But be prepared just in case.  */\n@@ -6785,7 +6785,7 @@ const char *\n output_dbra (rtx *operands, rtx insn, int which_alternative)\n {\n \n-  /* A conditional branch to the following instruction (eg the delay slot) is\n+  /* A conditional branch to the following instruction (e.g. the delay slot) is\n      asking for a disaster.  Be prepared!  */\n \n   if (next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn))\n@@ -6889,7 +6889,7 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n \t     int reverse_comparison)\n {\n \n-  /* A conditional branch to the following instruction (eg the delay slot) is\n+  /* A conditional branch to the following instruction (e.g. the delay slot) is\n      asking for a disaster.  Be prepared!  */\n \n   if (next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn))\n@@ -8553,7 +8553,7 @@ following_call (rtx insn)\n    will adhere to those rules.\n \n    So, late in the compilation process we find all the jump tables, and\n-   expand them into real code -- eg each entry in the jump table vector\n+   expand them into real code -- e.g. each entry in the jump table vector\n    will get an appropriate label followed by a jump to the final target.\n \n    Reorg and the final jump pass can then optimize these branches and"}, {"sha": "731a64b5918ee8aeb6fe8137f30a86b85adb60dc", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -146,7 +146,7 @@ Boston, MA 02111-1307, USA.  */\n    but can be less for certain modes in special long registers.\n \n    For PA64, GPRs and FPRs hold 64 bits worth (we ignore the 32bit\n-   addressability of the FPRs).  ie, we pretend each register holds\n+   addressability of the FPRs).  i.e., we pretend each register holds\n    precisely WORD_SIZE bits.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)"}, {"sha": "b0f6e3de3917c3ce518fb74ce0515d5d762c68b3", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -1691,7 +1691,7 @@ output_addr_const_pdp11 (FILE *file, rtx x)\n       break;\n \n     case PLUS:\n-      /* Some assemblers need integer constants to appear last (eg masm).  */\n+      /* Some assemblers need integer constants to appear last (e.g. masm).  */\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n \t{\n \t  output_addr_const_pdp11 (file, XEXP (x, 1));"}, {"sha": "ced21493a616408a59fb95f2ab1d448acf5f91dd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -11448,7 +11448,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t  if (j == nregs)\n \t    j = 0;\n \n-\t  /* If compiler already emited move of first word by\n+\t  /* If compiler already emitted move of first word by\n \t     store with update, no need to do anything.  */\n \t  if (j == 0 && used_update)\n \t    continue;\n@@ -11605,7 +11605,7 @@ compute_save_world_info(rs6000_stack_t *info_ptr)\n         info_ptr->vrsave_mask = compute_vrsave_mask ();\n \n       /* Because the Darwin register save/restore routines only handle\n-         F14 .. F31 and V20 .. V31 as per the ABI, perform a consistancy\n+         F14 .. F31 and V20 .. V31 as per the ABI, perform a consistency\n          check and abort if there's something worng.  */\n       if (info_ptr->first_fp_reg_save < FIRST_SAVED_FP_REGNO\n           || info_ptr->first_altivec_reg_save < FIRST_SAVED_ALTIVEC_REGNO)"}, {"sha": "e4b0d2bc225a07a49f38ebf22a83515c47ffed8e", "filename": "gcc/config/sh/symbian.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fsh%2Fsymbian.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fsh%2Fsymbian.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian.c?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -205,7 +205,7 @@ sh_symbian_dllimport_name_p (const char *symbol)\n }\n \n /* Mark a DECL as being dllexport'd.\n-   Note that we override the previous setting (eg: dllimport).  */\n+   Note that we override the previous setting (e.g.: dllimport).  */\n \n static void\n sh_symbian_mark_dllexport (tree decl)"}, {"sha": "5cf5201e0eff3183bd6743ecd85b7695cd506641", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/112cdef5e66fccce5475fabb5317805e012dc212/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=112cdef5e66fccce5475fabb5317805e012dc212", "patch": "@@ -884,7 +884,7 @@ if (TARGET_ARCH64\t\t\t\t\\\n    SPARC has 32 integer registers and 32 floating point registers.\n    64 bit SPARC has 32 additional fp regs, but the odd numbered ones are not\n    accessible.  We still account for them to simplify register computations\n-   (eg: in CLASS_MAX_NREGS).  There are also 4 fp condition code registers, so\n+   (e.g.: in CLASS_MAX_NREGS).  There are also 4 fp condition code registers, so\n    32+32+32+4 == 100.\n    Register 100 is used as the integer condition code register.\n    Register 101 is used as the soft frame pointer register.  */"}]}