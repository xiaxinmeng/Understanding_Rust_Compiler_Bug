{"sha": "36b8206084f7c4812f565e01d86ccf711e60b702", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZiODIwNjA4NGY3YzQ4MTJmNTY1ZTAxZDg2Y2NmNzExZTYwYjcwMg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2006-11-07T15:16:07Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2006-11-07T15:16:07Z"}, "message": "floatformat.c (get_field): Fix segfault with little-endian word order on 64-bit hosts.\n\n\t* floatformat.c (get_field): Fix segfault with little-endian word\n\torder on 64-bit hosts.\n\t(put_field): Likewise.\n\t(min): Move definition.\n\nFrom-SVN: r118552", "tree": {"sha": "68f2c6086b229620e7c9bd85734af43c5ce70cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68f2c6086b229620e7c9bd85734af43c5ce70cbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36b8206084f7c4812f565e01d86ccf711e60b702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36b8206084f7c4812f565e01d86ccf711e60b702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36b8206084f7c4812f565e01d86ccf711e60b702", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36b8206084f7c4812f565e01d86ccf711e60b702/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d81ecf52ff643ec879350503f0393d361162cf64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81ecf52ff643ec879350503f0393d361162cf64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d81ecf52ff643ec879350503f0393d361162cf64"}], "stats": {"total": 116, "additions": 56, "deletions": 60}, "files": [{"sha": "671d0aa619ff68ba3a2a3a554e2555c7c606ea33", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36b8206084f7c4812f565e01d86ccf711e60b702/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36b8206084f7c4812f565e01d86ccf711e60b702/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=36b8206084f7c4812f565e01d86ccf711e60b702", "patch": "@@ -1,3 +1,10 @@\n+2006-11-07  Julian Brown  <julian@codesourcery.com>\n+\n+\t* floatformat.c (get_field): Fix segfault with little-endian word\n+\torder on 64-bit hosts.\n+\t(put_field): Likewise.\n+\t(min): Move definition.\n+\n 2006-10-26  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tpex-win32.c (argv_to_cmdline): Replace xmalloc with XNEWVEC."}, {"sha": "c5abbb1f9ed19f9db127aec6be742baa9b63050c", "filename": "libiberty/floatformat.c", "status": "modified", "additions": 49, "deletions": 60, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36b8206084f7c4812f565e01d86ccf711e60b702/libiberty%2Ffloatformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36b8206084f7c4812f565e01d86ccf711e60b702/libiberty%2Ffloatformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffloatformat.c?ref=36b8206084f7c4812f565e01d86ccf711e60b702", "patch": "@@ -249,53 +249,51 @@ const struct floatformat floatformat_ia64_quad_little =\n   floatformat_always_valid\n };\n \f\n+\n+#ifndef min\n+#define min(a, b) ((a) < (b) ? (a) : (b))\n+#endif\n+\n /* Extract a field which starts at START and is LEN bits long.  DATA and\n    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */\n static unsigned long\n get_field (const unsigned char *data, enum floatformat_byteorders order,\n            unsigned int total_len, unsigned int start, unsigned int len)\n {\n-  unsigned long result;\n+  unsigned long result = 0;\n   unsigned int cur_byte;\n-  int cur_bitshift;\n+  int lo_bit, hi_bit, cur_bitshift = 0;\n+  int nextbyte = (order == floatformat_little) ? 1 : -1;\n+\n+  /* Start is in big-endian bit order!  Fix that first.  */\n+  start = total_len - (start + len);\n \n   /* Start at the least significant part of the field.  */\n-  cur_byte = (start + len) / FLOATFORMAT_CHAR_BIT;\n   if (order == floatformat_little)\n-    cur_byte = (total_len / FLOATFORMAT_CHAR_BIT) - cur_byte - 1;\n-  cur_bitshift =\n-    ((start + len) % FLOATFORMAT_CHAR_BIT) - FLOATFORMAT_CHAR_BIT;\n-  result = *(data + cur_byte) >> (-cur_bitshift);\n-  cur_bitshift += FLOATFORMAT_CHAR_BIT;\n-  if (order == floatformat_little)\n-    ++cur_byte;\n+    cur_byte = start / FLOATFORMAT_CHAR_BIT;\n   else\n-    --cur_byte;\n+    cur_byte = (total_len - start - 1) / FLOATFORMAT_CHAR_BIT;\n \n-  /* Move towards the most significant part of the field.  */\n-  while ((unsigned int) cur_bitshift < len)\n+  lo_bit = start % FLOATFORMAT_CHAR_BIT;\n+  hi_bit = min (lo_bit + len, FLOATFORMAT_CHAR_BIT);\n+  \n+  do\n     {\n-      if (len - cur_bitshift < FLOATFORMAT_CHAR_BIT)\n-\t/* This is the last byte; zero out the bits which are not part of\n-\t   this field.  */\n-\tresult |=\n-\t  (*(data + cur_byte) & ((1 << (len - cur_bitshift)) - 1))\n-\t    << cur_bitshift;\n-      else\n-\tresult |= *(data + cur_byte) << cur_bitshift;\n-      cur_bitshift += FLOATFORMAT_CHAR_BIT;\n-      if (order == floatformat_little)\n-\t++cur_byte;\n-      else\n-\t--cur_byte;\n+      unsigned int shifted = *(data + cur_byte) >> lo_bit;\n+      unsigned int bits = hi_bit - lo_bit;\n+      unsigned int mask = (1 << bits) - 1;\n+      result |= (shifted & mask) << cur_bitshift;\n+      len -= bits;\n+      cur_bitshift += bits;\n+      cur_byte += nextbyte;\n+      lo_bit = 0;\n+      hi_bit = min (len, FLOATFORMAT_CHAR_BIT);\n     }\n+  while (len != 0);\n+\n   return result;\n }\n   \n-#ifndef min\n-#define min(a, b) ((a) < (b) ? (a) : (b))\n-#endif\n-\n /* Convert from FMT to a double.\n    FROM is the address of the extended float.\n    Store the double in *TO.  */\n@@ -428,43 +426,34 @@ put_field (unsigned char *data, enum floatformat_byteorders order,\n            unsigned long stuff_to_put)\n {\n   unsigned int cur_byte;\n-  int cur_bitshift;\n+  int lo_bit, hi_bit;\n+  int nextbyte = (order == floatformat_little) ? 1 : -1;\n+\n+  /* Start is in big-endian bit order!  Fix that first.  */\n+  start = total_len - (start + len);\n \n   /* Start at the least significant part of the field.  */\n-  cur_byte = (start + len) / FLOATFORMAT_CHAR_BIT;\n-  if (order == floatformat_little)\n-    cur_byte = (total_len / FLOATFORMAT_CHAR_BIT) - cur_byte - 1;\n-  cur_bitshift =\n-    ((start + len) % FLOATFORMAT_CHAR_BIT) - FLOATFORMAT_CHAR_BIT;\n-  *(data + cur_byte) &=\n-    ~(((1 << ((start + len) % FLOATFORMAT_CHAR_BIT)) - 1) << (-cur_bitshift));\n-  *(data + cur_byte) |=\n-    (stuff_to_put & ((1 << FLOATFORMAT_CHAR_BIT) - 1)) << (-cur_bitshift);\n-  cur_bitshift += FLOATFORMAT_CHAR_BIT;\n   if (order == floatformat_little)\n-    ++cur_byte;\n+    cur_byte = start / FLOATFORMAT_CHAR_BIT;\n   else\n-    --cur_byte;\n+    cur_byte = (total_len - start - 1) / FLOATFORMAT_CHAR_BIT;\n \n-  /* Move towards the most significant part of the field.  */\n-  while ((unsigned int) cur_bitshift < len)\n+  lo_bit = start % FLOATFORMAT_CHAR_BIT;\n+  hi_bit = min (lo_bit + len, FLOATFORMAT_CHAR_BIT);\n+  \n+  do\n     {\n-      if (len - cur_bitshift < FLOATFORMAT_CHAR_BIT)\n-\t{\n-\t  /* This is the last byte.  */\n-\t  *(data + cur_byte) &=\n-\t    ~((1 << (len - cur_bitshift)) - 1);\n-\t  *(data + cur_byte) |= (stuff_to_put >> cur_bitshift);\n-\t}\n-      else\n-\t*(data + cur_byte) = ((stuff_to_put >> cur_bitshift)\n-\t\t\t      & ((1 << FLOATFORMAT_CHAR_BIT) - 1));\n-      cur_bitshift += FLOATFORMAT_CHAR_BIT;\n-      if (order == floatformat_little)\n-\t++cur_byte;\n-      else\n-\t--cur_byte;\n+      unsigned char *byte_ptr = data + cur_byte;\n+      unsigned int bits = hi_bit - lo_bit;\n+      unsigned int mask = ((1 << bits) - 1) << lo_bit;\n+      *byte_ptr = (*byte_ptr & ~mask) | ((stuff_to_put << lo_bit) & mask);\n+      stuff_to_put >>= bits;\n+      len -= bits;\n+      cur_byte += nextbyte;\n+      lo_bit = 0;\n+      hi_bit = min (len, FLOATFORMAT_CHAR_BIT);\n     }\n+  while (len != 0);\n }\n \n /* The converse: convert the double *FROM to an extended float"}]}