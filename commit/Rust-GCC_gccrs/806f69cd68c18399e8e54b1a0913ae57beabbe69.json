{"sha": "806f69cd68c18399e8e54b1a0913ae57beabbe69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA2ZjY5Y2Q2OGMxODM5OWU4ZTU0YjFhMDkxM2FlNTdiZWFiYmU2OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-13T09:50:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-13T09:50:35Z"}, "message": "[AArch64] Make aarch64_classify_vector_mode use a switch statement\n\naarch64_classify_vector_mode used properties of a mode to test whether\nthe mode was a single Advanced SIMD vector, a single SVE vector, or a\ntuple of SVE vectors.  That works well for current trunk and is simpler\nthan checking for modes by name.\n\nHowever, for the ACLE and for planned autovec improvements, we also\nneed partial SVE vector modes that hold:\n\n- half of the available 32-bit elements\n- a half or quarter of the available 16-bit elements\n- a half, quarter, or eighth of the available 8-bit elements\n\nThese should be packed in memory and unpacked in registers.  E.g.\nVNx2SI has half the number of elements of VNx4SI, and so is half the\nsize in memory.  When stored in registers, each VNx2SI element occupies\nthe low 32 bits of a VNx2DI element, with the upper bits being undefined.\n\nThe upshot is that:\n\n  GET_MODE_SIZE (VNx4SImode) == 2 * GET_MODE_SIZE (VNx2SImode)\n\nsince GET_MODE_SIZE must always be the memory size.  This in turn means\nthat for fixed-length SVE, some partial modes can have the same size as\nAdvanced SIMD modes.  We then need to be specific about which mode we're\ndealing with.\n\nThis patch prepares for that by switching based on the mode instead\nof querying properties.\n\nA later patch makes sure that Advanced SIMD modes always win over\npartial SVE vector modes in normal queries.\n\n2019-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_classify_vector_mode): Switch\n\tbased on the mode instead of testing properties of it.\n\nFrom-SVN: r274368", "tree": {"sha": "34ed0cb73f9093029219e61d11f146488bb59b04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34ed0cb73f9093029219e61d11f146488bb59b04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/806f69cd68c18399e8e54b1a0913ae57beabbe69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806f69cd68c18399e8e54b1a0913ae57beabbe69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/806f69cd68c18399e8e54b1a0913ae57beabbe69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806f69cd68c18399e8e54b1a0913ae57beabbe69/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "163b1f6ab2950553e1cc1b39a6b49293b3390e46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/163b1f6ab2950553e1cc1b39a6b49293b3390e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/163b1f6ab2950553e1cc1b39a6b49293b3390e46"}], "stats": {"total": 91, "additions": 65, "deletions": 26}, "files": [{"sha": "c77cba1858ae9cad092a67346fa464a11c60d444", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f69cd68c18399e8e54b1a0913ae57beabbe69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f69cd68c18399e8e54b1a0913ae57beabbe69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=806f69cd68c18399e8e54b1a0913ae57beabbe69", "patch": "@@ -1,3 +1,8 @@\n+2019-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_classify_vector_mode): Switch\n+\tbased on the mode instead of testing properties of it.\n+\n 2019-08-13  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* doc/md.texi: Document the x and y constraints for AArch64."}, {"sha": "487e987f9b62b88b4ce94af763dace85298cb747", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 60, "deletions": 26, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806f69cd68c18399e8e54b1a0913ae57beabbe69/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806f69cd68c18399e8e54b1a0913ae57beabbe69/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=806f69cd68c18399e8e54b1a0913ae57beabbe69", "patch": "@@ -1474,34 +1474,68 @@ aarch64_classify_vector_mode (machine_mode mode)\n   if (aarch64_sve_pred_mode_p (mode))\n     return VEC_SVE_PRED;\n \n-  scalar_mode inner = GET_MODE_INNER (mode);\n-  if (VECTOR_MODE_P (mode)\n-      && (inner == QImode\n-\t  || inner == HImode\n-\t  || inner == HFmode\n-\t  || inner == SImode\n-\t  || inner == SFmode\n-\t  || inner == DImode\n-\t  || inner == DFmode))\n-    {\n-      if (TARGET_SVE)\n-\t{\n-\t  if (known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR))\n-\t    return VEC_SVE_DATA;\n-\t  if (known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR * 2)\n-\t      || known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR * 3)\n-\t      || known_eq (GET_MODE_BITSIZE (mode), BITS_PER_SVE_VECTOR * 4))\n-\t    return VEC_SVE_DATA | VEC_STRUCT;\n-\t}\n+  /* Make the decision based on the mode's enum value rather than its\n+     properties, so that we keep the correct classification regardless\n+     of -msve-vector-bits.  */\n+  switch (mode)\n+    {\n+    /* Single SVE vectors.  */\n+    case E_VNx16QImode:\n+    case E_VNx8HImode:\n+    case E_VNx4SImode:\n+    case E_VNx2DImode:\n+    case E_VNx8HFmode:\n+    case E_VNx4SFmode:\n+    case E_VNx2DFmode:\n+      return TARGET_SVE ? VEC_SVE_DATA : 0;\n+\n+    /* x2 SVE vectors.  */\n+    case E_VNx32QImode:\n+    case E_VNx16HImode:\n+    case E_VNx8SImode:\n+    case E_VNx4DImode:\n+    case E_VNx16HFmode:\n+    case E_VNx8SFmode:\n+    case E_VNx4DFmode:\n+    /* x3 SVE vectors.  */\n+    case E_VNx48QImode:\n+    case E_VNx24HImode:\n+    case E_VNx12SImode:\n+    case E_VNx6DImode:\n+    case E_VNx24HFmode:\n+    case E_VNx12SFmode:\n+    case E_VNx6DFmode:\n+    /* x4 SVE vectors.  */\n+    case E_VNx64QImode:\n+    case E_VNx32HImode:\n+    case E_VNx16SImode:\n+    case E_VNx8DImode:\n+    case E_VNx32HFmode:\n+    case E_VNx16SFmode:\n+    case E_VNx8DFmode:\n+      return TARGET_SVE ? VEC_SVE_DATA | VEC_STRUCT : 0;\n+\n+    /* 64-bit Advanced SIMD vectors.  */\n+    case E_V8QImode:\n+    case E_V4HImode:\n+    case E_V2SImode:\n+    /* ...E_V1DImode doesn't exist.  */\n+    case E_V4HFmode:\n+    case E_V2SFmode:\n+    case E_V1DFmode:\n+    /* 128-bit Advanced SIMD vectors.  */\n+    case E_V16QImode:\n+    case E_V8HImode:\n+    case E_V4SImode:\n+    case E_V2DImode:\n+    case E_V8HFmode:\n+    case E_V4SFmode:\n+    case E_V2DFmode:\n+      return TARGET_SIMD ? VEC_ADVSIMD : 0;\n \n-      /* This includes V1DF but not V1DI (which doesn't exist).  */\n-      if (TARGET_SIMD\n-\t  && (known_eq (GET_MODE_BITSIZE (mode), 64)\n-\t      || known_eq (GET_MODE_BITSIZE (mode), 128)))\n-\treturn VEC_ADVSIMD;\n+    default:\n+      return 0;\n     }\n-\n-  return 0;\n }\n \n /* Return true if MODE is any of the data vector modes, including"}]}