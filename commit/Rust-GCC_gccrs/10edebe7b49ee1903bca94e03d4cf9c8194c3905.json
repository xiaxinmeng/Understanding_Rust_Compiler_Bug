{"sha": "10edebe7b49ee1903bca94e03d4cf9c8194c3905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlZGViZTdiNDllZTE5MDNiY2E5NGUwM2Q0Y2Y5YzgxOTRjMzkwNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-04T10:00:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-04T10:00:57Z"}, "message": "[multiple changes]\n\n2016-07-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_aggr.adb (Ctrl_Init_Expression): New routine.\n\t(Gen_Assign): Code cleanup. Perform in-place side effect removal when\n\tthe expression denotes a controlled function call.\n\t* exp_util.adb (Remove_Side_Effects): Do not remove side effects\n\ton a function call which has this behavior suppressed.\n\t* sem_aggr.adb Code cleanup.\n\t* sinfo.adb (No_Side_Effect_Removal): New routine.\n\t(Set_Side_Effect_Removal): New routine.\n\t* sinfo.ads New attribute No_Side_Effect_Removal along with\n\toccurences in nodes.\n\t(No_Side_Effect_Removal): New routine along with pragma Inline.\n\t(Set_Side_Effect_Removal): New routine along with pragma Inline.\n\n2016-07-04  Arnaud Charlet  <charlet@adacore.com>\n\n\t* opt.ads, sem_prag.adb (Universal_Addressing_On_AAMP): Removed.\n\tRemove support for pragma No_Run_Time. Update comments.\n\n2016-07-04  Pascal Obry  <obry@adacore.com>\n\n\t* g-forstr.ads: More documentation for the Formatted_String\n\tsupport.\n\n2016-07-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause, case\n\t'Address): If the address comes from an aspect specification\n\tand not a source attribute definition clause, do not remove\n\tside effects from the expression, because the expression must\n\tbe elaborated at the freeze point of the object and not at the\n\tobject declaration, because of the delayed analysis of aspect\n\tspecifications.\n\nFrom-SVN: r237959", "tree": {"sha": "8d1354391447c45564cc3f27fcc976c07d89e6bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d1354391447c45564cc3f27fcc976c07d89e6bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10edebe7b49ee1903bca94e03d4cf9c8194c3905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10edebe7b49ee1903bca94e03d4cf9c8194c3905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10edebe7b49ee1903bca94e03d4cf9c8194c3905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10edebe7b49ee1903bca94e03d4cf9c8194c3905/comments", "author": null, "committer": null, "parents": [{"sha": "15f6e0dac34a243341fba80f8ebdaeec78d766fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f6e0dac34a243341fba80f8ebdaeec78d766fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f6e0dac34a243341fba80f8ebdaeec78d766fe"}], "stats": {"total": 479, "additions": 349, "deletions": 130}, "files": [{"sha": "bcd9e52fa34c9afb816c39a0aed3e5fedf4b380c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -1,3 +1,38 @@\n+2016-07-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_aggr.adb (Ctrl_Init_Expression): New routine.\n+\t(Gen_Assign): Code cleanup. Perform in-place side effect removal when\n+\tthe expression denotes a controlled function call.\n+\t* exp_util.adb (Remove_Side_Effects): Do not remove side effects\n+\ton a function call which has this behavior suppressed.\n+\t* sem_aggr.adb Code cleanup.\n+\t* sinfo.adb (No_Side_Effect_Removal): New routine.\n+\t(Set_Side_Effect_Removal): New routine.\n+\t* sinfo.ads New attribute No_Side_Effect_Removal along with\n+\toccurences in nodes.\n+\t(No_Side_Effect_Removal): New routine along with pragma Inline.\n+\t(Set_Side_Effect_Removal): New routine along with pragma Inline.\n+\n+2016-07-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* opt.ads, sem_prag.adb (Universal_Addressing_On_AAMP): Removed.\n+\tRemove support for pragma No_Run_Time. Update comments.\n+\n+2016-07-04  Pascal Obry  <obry@adacore.com>\n+\n+\t* g-forstr.ads: More documentation for the Formatted_String\n+\tsupport.\n+\n+2016-07-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause, case\n+\t'Address): If the address comes from an aspect specification\n+\tand not a source attribute definition clause, do not remove\n+\tside effects from the expression, because the expression must\n+\tbe elaborated at the freeze point of the object and not at the\n+\tobject declaration, because of the delayed analysis of aspect\n+\tspecifications.\n+\n 2016-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/48835"}, {"sha": "f40b56d718e21a49eb2ed169e7cee9a0c7903b0c", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 184, "deletions": 49, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -1017,19 +1017,20 @@ package body Exp_Aggr is\n       ----------------\n \n       function Gen_Assign (Ind : Node_Id; Expr : Node_Id) return List_Id is\n-         L : constant List_Id := New_List;\n-         A : Node_Id;\n-\n-         New_Indexes  : List_Id;\n-         Indexed_Comp : Node_Id;\n-         Expr_Q       : Node_Id;\n-         Comp_Type    : Entity_Id := Empty;\n-\n          function Add_Loop_Actions (Lis : List_Id) return List_Id;\n          --  Collect insert_actions generated in the construction of a\n          --  loop, and prepend them to the sequence of assignments to\n          --  complete the eventual body of the loop.\n \n+         function Ctrl_Init_Expression\n+           (Comp_Typ : Entity_Id;\n+            Stmts    : List_Id) return Node_Id;\n+         --  Perform in-place side effect removal if expression Expr denotes a\n+         --  controlled function call. Return a reference to the entity which\n+         --  captures the result of the call. Comp_Typ is the expected type of\n+         --  the component. Stmts is the list of initialization statmenets. Any\n+         --  generated code is added to Stmts.\n+\n          ----------------------\n          -- Add_Loop_Actions --\n          ----------------------\n@@ -1057,6 +1058,91 @@ package body Exp_Aggr is\n             end if;\n          end Add_Loop_Actions;\n \n+         --------------------------\n+         -- Ctrl_Init_Expression --\n+         --------------------------\n+\n+         function Ctrl_Init_Expression\n+           (Comp_Typ : Entity_Id;\n+            Stmts    : List_Id) return Node_Id\n+         is\n+            Init_Expr : Node_Id;\n+            Obj_Id    : Entity_Id;\n+            Ptr_Typ   : Entity_Id;\n+\n+         begin\n+            Init_Expr := New_Copy_Tree (Expr);\n+\n+            --  Perform a preliminary analysis and resolution to determine\n+            --  what the expression denotes. Note that a function call may\n+            --  appear as an identifier or an indexed component.\n+\n+            Preanalyze_And_Resolve (Init_Expr, Comp_Typ);\n+\n+            --  The initialization expression is a controlled function call.\n+            --  Perform in-place removal of side effects to avoid creating a\n+            --  transient scope. In the end the temporary function result is\n+            --  finalized by the general finalization machinery.\n+\n+            if Nkind (Init_Expr) = N_Function_Call then\n+\n+               --  Suppress the removal of side effects by generatal analysis\n+               --  because this behavior is emulated here.\n+\n+               Set_No_Side_Effect_Removal (Init_Expr);\n+\n+               --  Generate:\n+               --    type Ptr_Typ is access all Comp_Typ;\n+\n+               Ptr_Typ := Make_Temporary (Loc, 'A');\n+\n+               Append_To (Stmts,\n+                 Make_Full_Type_Declaration (Loc,\n+                   Defining_Identifier => Ptr_Typ,\n+                   Type_Definition     =>\n+                     Make_Access_To_Object_Definition (Loc,\n+                       All_Present        => True,\n+                       Subtype_Indication =>\n+                         New_Occurrence_Of (Comp_Typ, Loc))));\n+\n+               --  Generate:\n+               --    Obj : constant Ptr_Typ := Init_Expr'Reference;\n+\n+               Obj_Id := Make_Temporary (Loc, 'R');\n+\n+               Append_To (Stmts,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Obj_Id,\n+                   Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n+                   Expression          => Make_Reference (Loc, Init_Expr)));\n+\n+               --  Generate:\n+               --    Obj.all;\n+\n+               return\n+                 Make_Explicit_Dereference (Loc,\n+                   Prefix => New_Occurrence_Of (Obj_Id, Loc));\n+\n+            --  Otherwise the initialization expression denotes a controlled\n+            --  object. There is nothing special to be done here as there is\n+            --  no possible transient scope involvement.\n+\n+            else\n+               return Init_Expr;\n+            end if;\n+         end Ctrl_Init_Expression;\n+\n+         --  Local variables\n+\n+         Stmts : constant List_Id := New_List;\n+\n+         Comp_Typ     : Entity_Id := Empty;\n+         Expr_Q       : Node_Id;\n+         Indexed_Comp : Node_Id;\n+         New_Indexes  : List_Id;\n+         Stmt         : Node_Id;\n+         Stmt_Expr    : Node_Id;\n+\n       --  Start of processing for Gen_Assign\n \n       begin\n@@ -1102,8 +1188,8 @@ package body Exp_Aggr is\n          end if;\n \n          if Present (Etype (N)) and then Etype (N) /= Any_Composite then\n-            Comp_Type := Component_Type (Etype (N));\n-            pragma Assert (Comp_Type = Ctype); --  AI-287\n+            Comp_Typ := Component_Type (Etype (N));\n+            pragma Assert (Comp_Typ = Ctype); --  AI-287\n \n          elsif Present (Next (First (New_Indexes))) then\n \n@@ -1129,15 +1215,15 @@ package body Exp_Aggr is\n                      if Nkind (P) = N_Aggregate\n                        and then Present (Etype (P))\n                      then\n-                        Comp_Type := Component_Type (Etype (P));\n+                        Comp_Typ := Component_Type (Etype (P));\n                         exit;\n \n                      else\n                         P := Parent (P);\n                      end if;\n                   end loop;\n \n-                  pragma Assert (Comp_Type = Ctype); --  AI-287\n+                  pragma Assert (Comp_Typ = Ctype); --  AI-287\n                end;\n             end if;\n          end if;\n@@ -1155,8 +1241,8 @@ package body Exp_Aggr is\n             --  the analysis of non-array aggregates now in order to get the\n             --  value of Expansion_Delayed flag for the inner aggregate ???\n \n-            if Present (Comp_Type) and then not Is_Array_Type (Comp_Type) then\n-               Analyze_And_Resolve (Expr_Q, Comp_Type);\n+            if Present (Comp_Typ) and then not Is_Array_Type (Comp_Typ) then\n+               Analyze_And_Resolve (Expr_Q, Comp_Typ);\n             end if;\n \n             if Is_Delayed_Aggregate (Expr_Q) then\n@@ -1171,9 +1257,9 @@ package body Exp_Aggr is\n                --  generated in the usual fashion, and sliding will take place.\n \n                if Nkind (Parent (N)) = N_Assignment_Statement\n-                 and then Is_Array_Type (Comp_Type)\n+                 and then Is_Array_Type (Comp_Typ)\n                  and then Present (Component_Associations (Expr_Q))\n-                 and then Must_Slide (Comp_Type, Etype (Expr_Q))\n+                 and then Must_Slide (Comp_Typ, Etype (Expr_Q))\n                then\n                   Set_Expansion_Delayed (Expr_Q, False);\n                   Set_Analyzed (Expr_Q, False);\n@@ -1201,7 +1287,7 @@ package body Exp_Aggr is\n             if Present (Base_Init_Proc (Base_Type (Ctype)))\n               or else Has_Task (Base_Type (Ctype))\n             then\n-               Append_List_To (L,\n+               Append_List_To (Stmts,\n                  Build_Initialization_Call (Loc,\n                    Id_Ref            => Indexed_Comp,\n                    Typ               => Ctype,\n@@ -1214,28 +1300,81 @@ package body Exp_Aggr is\n \n                if Has_Invariants (Ctype) then\n                   Set_Etype (Indexed_Comp, Ctype);\n-                  Append_To (L, Make_Invariant_Call (Indexed_Comp));\n+                  Append_To (Stmts, Make_Invariant_Call (Indexed_Comp));\n                end if;\n \n             elsif Is_Access_Type (Ctype) then\n-               Append_To (L,\n+               Append_To (Stmts,\n                  Make_Assignment_Statement (Loc,\n-                   Name       => Indexed_Comp,\n+                   Name       => New_Copy_Tree (Indexed_Comp),\n                    Expression => Make_Null (Loc)));\n             end if;\n \n             if Needs_Finalization (Ctype) then\n-               Append_To (L,\n+               Append_To (Stmts,\n                  Make_Init_Call\n                    (Obj_Ref => New_Copy_Tree (Indexed_Comp),\n                     Typ     => Ctype));\n             end if;\n \n          else\n-            A :=\n+            --  Handle an initialization expression of a controlled type in\n+            --  case it denotes a function call. In general such a scenario\n+            --  will produce a transient scope, but this will lead to wrong\n+            --  order of initialization, adjustment, and finalization in the\n+            --  context of aggregates.\n+\n+            --    Arr_Comp (1) := Ctrl_Func_Call;\n+\n+            --    begin                                  --  transient scope\n+            --       Trans_Obj : ... := Ctrl_Func_Call;  --  transient object\n+            --       Arr_Comp (1) := Trans_Obj;\n+            --       Finalize (Trans_Obj);\n+            --    end;\n+            --    Arr_Comp (1)._tag := ...;\n+            --    Adjust (Arr_Comp (1));\n+\n+            --  In the example above, the call to Finalize occurs too early\n+            --  and as a result it may leave the array component in a bad\n+            --  state. Finalization of the transient object should really\n+            --  happen after adjustment.\n+\n+            --  To avoid this scenario, perform in-place side effect removal\n+            --  of the function call. This eliminates the transient property\n+            --  of the function result and ensures correct order of actions.\n+            --  Note that the function result behaves as a source controlled\n+            --  object and is finalized by the general finalization mechanism.\n+\n+            --    begin\n+            --       Res : ... := Ctrl_Func_Call;\n+            --       Arr_Comp (1) := Res;\n+            --       Arr_Comp (1)._tag := ...;\n+            --       Adjust (Arr_Comp (1));\n+            --    at end\n+            --       Finalize (Res);\n+            --    end;\n+\n+            --  There is no need to perform this kind of light expansion when\n+            --  the component type is limited controlled because everything is\n+            --  already done in place.\n+\n+            if Present (Comp_Typ)\n+              and then Needs_Finalization (Comp_Typ)\n+              and then not Is_Limited_Type (Comp_Typ)\n+              and then Nkind (Expr) /= N_Aggregate\n+            then\n+               Stmt_Expr := Ctrl_Init_Expression (Comp_Typ, Stmts);\n+\n+            --  Otherwise use the initialization expression directly\n+\n+            else\n+               Stmt_Expr := New_Copy_Tree (Expr);\n+            end if;\n+\n+            Stmt :=\n               Make_OK_Assignment_Statement (Loc,\n-                Name       => Indexed_Comp,\n-                Expression => New_Copy_Tree (Expr));\n+                Name       => New_Copy_Tree (Indexed_Comp),\n+                Expression => Stmt_Expr);\n \n             --  The target of the assignment may not have been initialized,\n             --  so it is not possible to call Finalize as expected in normal\n@@ -1248,7 +1387,7 @@ package body Exp_Aggr is\n             --  actions are done manually with the proper finalization list\n             --  coming from the context.\n \n-            Set_No_Ctrl_Actions (A);\n+            Set_No_Ctrl_Actions (Stmt);\n \n             --  If this is an aggregate for an array of arrays, each\n             --  subaggregate will be expanded as well, and even with\n@@ -1260,33 +1399,31 @@ package body Exp_Aggr is\n             --  that finalization takes place for each subaggregate we wrap the\n             --  assignment in a block.\n \n-            if Present (Comp_Type)\n-              and then Needs_Finalization (Comp_Type)\n-              and then Is_Array_Type (Comp_Type)\n+            if Present (Comp_Typ)\n+              and then Needs_Finalization (Comp_Typ)\n+              and then Is_Array_Type (Comp_Typ)\n               and then Present (Expr)\n             then\n-               A :=\n+               Stmt :=\n                  Make_Block_Statement (Loc,\n                    Handled_Statement_Sequence =>\n                      Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => New_List (A)));\n+                       Statements => New_List (Stmt)));\n             end if;\n \n-            Append_To (L, A);\n+            Append_To (Stmts, Stmt);\n \n-            --  Adjust the tag if tagged (because of possible view\n-            --  conversions), unless compiling for a VM where tags\n-            --  are implicit.\n+            --  Adjust the tag due to a possible view conversion\n \n-            if Present (Comp_Type)\n-              and then Is_Tagged_Type (Comp_Type)\n+            if Present (Comp_Typ)\n+              and then Is_Tagged_Type (Comp_Typ)\n               and then Tagged_Type_Expansion\n             then\n                declare\n-                  Full_Typ : constant Entity_Id := Underlying_Type (Comp_Type);\n+                  Full_Typ : constant Entity_Id := Underlying_Type (Comp_Typ);\n \n                begin\n-                  A :=\n+                  Append_To (Stmts,\n                     Make_OK_Assignment_Statement (Loc,\n                       Name       =>\n                         Make_Selected_Component (Loc,\n@@ -1299,9 +1436,7 @@ package body Exp_Aggr is\n                         Unchecked_Convert_To (RTE (RE_Tag),\n                           New_Occurrence_Of\n                             (Node (First_Elmt (Access_Disp_Table (Full_Typ))),\n-                             Loc)));\n-\n-                  Append_To (L, A);\n+                             Loc))));\n                end;\n             end if;\n \n@@ -1316,22 +1451,22 @@ package body Exp_Aggr is\n             --  (see comments above, concerning the creation of a block to hold\n             --  inner finalization actions).\n \n-            if Present (Comp_Type)\n-              and then Needs_Finalization (Comp_Type)\n-              and then not Is_Limited_Type (Comp_Type)\n+            if Present (Comp_Typ)\n+              and then Needs_Finalization (Comp_Typ)\n+              and then not Is_Limited_Type (Comp_Typ)\n               and then not\n-                (Is_Array_Type (Comp_Type)\n-                  and then Is_Controlled (Component_Type (Comp_Type))\n+                (Is_Array_Type (Comp_Typ)\n+                  and then Is_Controlled (Component_Type (Comp_Typ))\n                   and then Nkind (Expr) = N_Aggregate)\n             then\n-               Append_To (L,\n+               Append_To (Stmts,\n                  Make_Adjust_Call\n                    (Obj_Ref => New_Copy_Tree (Indexed_Comp),\n-                    Typ     => Comp_Type));\n+                    Typ     => Comp_Typ));\n             end if;\n          end if;\n \n-         return Add_Loop_Actions (L);\n+         return Add_Loop_Actions (Stmts);\n       end Gen_Assign;\n \n       --------------"}, {"sha": "dd004a0991f15ca09c7ff38544d5d72e3b566ef8", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -136,9 +136,16 @@ package body Exp_Ch13 is\n                --  has a delayed freeze, but the address expression itself\n                --  must be elaborated at the point it appears. If the object\n                --  is controlled, additional checks apply elsewhere.\n+               --  If the attribute comes from an aspect specification it\n+               --  is being elaborated at the freeze point and side effects\n+               --  need not be removed (and shouldn't, if the expression\n+               --  depends on other entities that have delayed freeze).\n+               --  This is another consequence of the delayed analysis of\n+               --  aspects, and a real semantic difference.\n \n                elsif Nkind (Decl) = N_Object_Declaration\n                  and then not Needs_Constant_Address (Decl, Typ)\n+                 and then not From_Aspect_Specification (N)\n                then\n                   Remove_Side_Effects (Exp);\n                end if;"}, {"sha": "f3b63758e31d3392e92f2a6b0407be4d826331a0", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -7693,14 +7693,23 @@ package body Exp_Util is\n         and (Inside_A_Generic or not Full_Analysis or not GNATprove_Mode)\n       then\n          return;\n-      end if;\n \n       --  Cannot generate temporaries if the invocation to remove side effects\n       --  was issued too early and the type of the expression is not resolved\n       --  (this happens because routines Duplicate_Subexpr_XX implicitly invoke\n       --  Remove_Side_Effects).\n \n-      if No (Exp_Type) or else Ekind (Exp_Type) = E_Access_Attribute_Type then\n+      elsif No (Exp_Type)\n+        or else Ekind (Exp_Type) = E_Access_Attribute_Type\n+      then\n+         return;\n+\n+      --  Nothing to do if prior expansion determined that a function call does\n+      --  not require side effect removal.\n+\n+      elsif Nkind (Exp) = N_Function_Call\n+        and then No_Side_Effect_Removal (Exp)\n+      then\n          return;\n \n       --  No action needed for side-effect free expressions"}, {"sha": "a43ba5f7a84dd1e8865659714018ae0393e0e3f7", "filename": "gcc/ada/g-forstr.ads", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fg-forstr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fg-forstr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-forstr.ads?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2014, Free Software Foundation, Inc.           --\n+--           Copyright (C) 2014-2016, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,10 +29,22 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package add support for formatted string as supported by C printf().\n+--  This package add support for formatted string as supported by C printf()\n \n --  A simple usage is:\n-\n+--\n+--     Put_Line (-(+\"%s\" & \"a string\"));\n+--\n+--  or with a constant for the format:\n+--\n+--     declare\n+--       Format : constant Formatted_String := +\"%s\";\n+--     begin\n+--       Put_Line (-(Format & \"a string\"));\n+--     end;\n+--\n+--  Finally a more complex example:\n+--\n --     declare\n --        F : Formatted_String := +\"['%c' ; %10d]\";\n --        C : Character := 'v';"}, {"sha": "4027fab60ed6960c220680f06685c57650c371f4", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -776,8 +776,7 @@ package Opt is\n    GNAT_Encodings : Int;\n    pragma Import (C, GNAT_Encodings, \"gnat_encodings\");\n    --  Constant controlling the balance between GNAT encodings and standard\n-   --  DWARF to emit in the debug information. See aamissing.c for definitions\n-   --  for the GNAAMP back end. It accepts the following values.\n+   --  DWARF to emit in the debug information. It accepts the following values.\n \n    DWARF_GNAT_Encodings_All     : constant Int := 0;\n    DWARF_GNAT_Encodings_GDB     : constant Int := 1;\n@@ -1194,13 +1193,11 @@ package Opt is\n    Optimization_Level : Int;\n    pragma Import (C, Optimization_Level, \"optimize\");\n    --  Constant reflecting the optimization level (0,1,2,3 for -O0,-O1,-O2,-O3)\n-   --  See e.g. aamissing.c for definitions for the GNAAMP back end.\n \n    Optimize_Size : Int;\n    pragma Import (C, Optimize_Size, \"optimize_size\");\n    --  Constant reflecting setting of -Os (optimize for size). Set to nonzero\n-   --  in -Os mode and set to zero otherwise. See aamissing.c for definition\n-   --  of \"optimize_size\" for the GNAAMP backend.\n+   --  in -Os mode and set to zero otherwise.\n \n    Output_File_Name_Present : Boolean := False;\n    --  GNATBIND, GNAT, GNATMAKE\n@@ -1576,13 +1573,6 @@ package Opt is\n    --  If true, activates the circuitry for unnesting subprograms (see the spec\n    --  of Exp_Unst for full details). Currently set only by use of -gnatd.1.\n \n-   Universal_Addressing_On_AAMP : Boolean := False;\n-   --  GNAAMP\n-   --  Indicates if library-level objects should be accessed and updated using\n-   --  universal addressing instructions on the AAMP architecture. This flag is\n-   --  set to True when pragma Universal_Data is given as a configuration\n-   --  pragma.\n-\n    Unreserve_All_Interrupts : Boolean := False;\n    --  GNAT, GNATBIND\n    --  Normally set False, set True if a valid Unreserve_All_Interrupts pragma"}, {"sha": "feb1a4a2150df63f3f52825ea6990491abce635a", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -1821,6 +1821,25 @@ package body Sem_Aggr is\n          end if;\n \n          Step_2 : declare\n+            function Empty_Range (A : Node_Id) return Boolean;\n+            --  If an association covers an empty range, some warnings on the\n+            --  expression of the association can be disabled.\n+\n+            -----------------\n+            -- Empty_Range --\n+            -----------------\n+\n+            function Empty_Range (A : Node_Id) return Boolean is\n+               R : constant Node_Id := First (Choices (A));\n+            begin\n+               return No (Next (R))\n+                 and then Nkind (R) = N_Range\n+                 and then Compile_Time_Compare\n+                            (Low_Bound (R), High_Bound (R), False) = GT;\n+            end Empty_Range;\n+\n+            --  Local variables\n+\n             Low  : Node_Id;\n             High : Node_Id;\n             --  Denote the lowest and highest values in an aggregate choice\n@@ -1845,23 +1864,6 @@ package body Sem_Aggr is\n             Errors_Posted_On_Choices : Boolean := False;\n             --  Keeps track of whether any choices have semantic errors\n \n-            function Empty_Range (A : Node_Id) return Boolean;\n-            --  If an association covers an empty range, some warnings on the\n-            --  expression of the association can be disabled.\n-\n-            -----------------\n-            -- Empty_Range --\n-            -----------------\n-\n-            function Empty_Range (A : Node_Id) return Boolean is\n-               R : constant Node_Id := First (Choices (A));\n-            begin\n-               return No (Next (R))\n-                 and then Nkind (R) = N_Range\n-                 and then Compile_Time_Compare\n-                            (Low_Bound (R), High_Bound (R), False) = GT;\n-            end Empty_Range;\n-\n          --  Start of processing for Step_2\n \n          begin\n@@ -3429,10 +3431,6 @@ package body Sem_Aggr is\n       -----------------------\n \n       procedure Resolve_Aggr_Expr (Expr : Node_Id; Component : Node_Id) is\n-         Expr_Type : Entity_Id := Empty;\n-         New_C     : Entity_Id := Component;\n-         New_Expr  : Node_Id;\n-\n          function Has_Expansion_Delayed (Expr : Node_Id) return Boolean;\n          --  If the expression is an aggregate (possibly qualified) then its\n          --  expansion is delayed until the enclosing aggregate is expanded\n@@ -3442,15 +3440,6 @@ package body Sem_Aggr is\n          --  dynamic-sized aggregate in the code, something that gigi cannot\n          --  handle.\n \n-         Relocate : Boolean;\n-         --  Set to True if the resolved Expr node needs to be relocated when\n-         --  attached to the newly created association list. This node need not\n-         --  be relocated if its parent pointer is not set. In fact in this\n-         --  case Expr is the output of a New_Copy_Tree call. If Relocate is\n-         --  True then we have analyzed the expression node in the original\n-         --  aggregate and hence it needs to be relocated when moved over to\n-         --  the new association list.\n-\n          ---------------------------\n          -- Has_Expansion_Delayed --\n          ---------------------------\n@@ -3466,6 +3455,21 @@ package body Sem_Aggr is\n                         and then Has_Expansion_Delayed (Expression (Expr)));\n          end Has_Expansion_Delayed;\n \n+         --  Local variables\n+\n+         Expr_Type : Entity_Id := Empty;\n+         New_C     : Entity_Id := Component;\n+         New_Expr  : Node_Id;\n+\n+         Relocate : Boolean;\n+         --  Set to True if the resolved Expr node needs to be relocated when\n+         --  attached to the newly created association list. This node need not\n+         --  be relocated if its parent pointer is not set. In fact in this\n+         --  case Expr is the output of a New_Copy_Tree call. If Relocate is\n+         --  True then we have analyzed the expression node in the original\n+         --  aggregate and hence it needs to be relocated when moved over to\n+         --  the new association list.\n+\n       --  Start of processing for Resolve_Aggr_Expr\n \n       begin"}, {"sha": "a2392e68ee33870eddb1ce59d717c88dd25ea3c3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -44,6 +44,7 @@ with Exp_Dist;  use Exp_Dist;\n with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n+with Gnatvsn;   use Gnatvsn;\n with Lib;       use Lib;\n with Lib.Writ;  use Lib.Writ;\n with Lib.Xref;  use Lib.Xref;\n@@ -17623,28 +17624,38 @@ package body Sem_Prag is\n             Check_Valid_Configuration_Pragma;\n             Check_Arg_Count (0);\n \n-            No_Run_Time_Mode           := True;\n-            Configurable_Run_Time_Mode := True;\n+            --  Remove backward compatibility if Build_Type is FSF or GPL and\n+            --  generate a warning.\n \n-            --  Set Duration to 32 bits if word size is 32\n+            declare\n+               Ignore : constant Boolean := Build_Type in FSF .. GPL;\n+            begin\n+               if Ignore then\n+                  Error_Pragma (\"pragma% is ignored, has no effect??\");\n+               else\n+                  No_Run_Time_Mode           := True;\n+                  Configurable_Run_Time_Mode := True;\n \n-            if Ttypes.System_Word_Size = 32 then\n-               Duration_32_Bits_On_Target := True;\n-            end if;\n+                  --  Set Duration to 32 bits if word size is 32\n+\n+                  if Ttypes.System_Word_Size = 32 then\n+                     Duration_32_Bits_On_Target := True;\n+                  end if;\n \n-            --  Set appropriate restrictions\n+                  --  Set appropriate restrictions\n \n-            Set_Restriction (No_Finalization, N);\n-            Set_Restriction (No_Exception_Handlers, N);\n-            Set_Restriction (Max_Tasks, N, 0);\n-            Set_Restriction (No_Tasking, N);\n+                  Set_Restriction (No_Finalization, N);\n+                  Set_Restriction (No_Exception_Handlers, N);\n+                  Set_Restriction (Max_Tasks, N, 0);\n+                  Set_Restriction (No_Tasking, N);\n+               end if;\n+            end;\n \n-            -----------------------\n-            -- No_Tagged_Streams --\n-            -----------------------\n+         -----------------------\n+         -- No_Tagged_Streams --\n+         -----------------------\n \n-            --  pragma No_Tagged_Streams;\n-            --  pragma No_Tagged_Streams ([Entity => ]tagged_type_local_NAME);\n+         --  pragma No_Tagged_Streams [([Entity => ]tagged_type_local_NAME)];\n \n          when Pragma_No_Tagged_Streams => No_Tagged_Strms : declare\n             E    : Entity_Id;\n@@ -22338,22 +22349,7 @@ package body Sem_Prag is\n \n          when Pragma_Universal_Data =>\n             GNAT_Pragma;\n-\n-            --  If this is a configuration pragma, then set the universal\n-            --  addressing option, otherwise confirm that the pragma satisfies\n-            --  the requirements of library unit pragma placement and leave it\n-            --  to the GNAAMP back end to detect the pragma (avoids transitive\n-            --  setting of the option due to withed units).\n-\n-            if Is_Configuration_Pragma then\n-               Universal_Addressing_On_AAMP := True;\n-            else\n-               Check_Valid_Library_Unit_Pragma;\n-            end if;\n-\n-            if not AAMP_On_Target then\n-               Error_Pragma (\"??pragma% ignored (applies only to AAMP)\");\n-            end if;\n+            Error_Pragma (\"??pragma% ignored (applies only to AAMP)\");\n \n          ----------------\n          -- Unmodified --"}, {"sha": "5ea25db3ee56cc39897813f7d7297cc2a64dd26a", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2409,6 +2409,14 @@ package body Sinfo is\n       return Flag17 (N);\n    end No_Minimize_Eliminate;\n \n+   function No_Side_Effect_Removal\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Function_Call);\n+      return Flag1 (N);\n+   end No_Side_Effect_Removal;\n+\n    function No_Truncation\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5664,6 +5672,14 @@ package body Sinfo is\n       Set_Flag17 (N, Val);\n    end Set_No_Minimize_Eliminate;\n \n+   procedure Set_No_Side_Effect_Removal\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Function_Call);\n+      Set_Flag1 (N, Val);\n+   end Set_No_Side_Effect_Removal;\n+\n    procedure Set_No_Truncation\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "29feb2564017bfaf33da3114c182d41c6ed6435b", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10edebe7b49ee1903bca94e03d4cf9c8194c3905/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=10edebe7b49ee1903bca94e03d4cf9c8194c3905", "patch": "@@ -1946,6 +1946,12 @@ package Sinfo is\n    --    It is used to indicate that processing for extended overflow checking\n    --    modes is not required (this is used to prevent infinite recursion).\n \n+   --  No_Side_Effect_Removal (Flag1-Sem)\n+   --    Present in N_Function_Call nodes. Set when a function call does not\n+   --    require side effect removal. This attribute suppresses the generation\n+   --    of a temporary to capture the result of the function which eventually\n+   --    replaces the function call.\n+\n    --  No_Truncation (Flag17-Sem)\n    --    Present in N_Unchecked_Type_Conversion node. This flag has an effect\n    --    only if the RM_Size of the source is greater than the RM_Size of the\n@@ -5296,6 +5302,7 @@ package Sinfo is\n       --   actual parameter part)\n       --  First_Named_Actual (Node4-Sem)\n       --  Controlling_Argument (Node1-Sem) (set to Empty if not dispatching)\n+      --  No_Side_Effect_Removal (Flag1-Sem)\n       --  Is_Expanded_Build_In_Place_Call (Flag11-Sem)\n       --  Do_Tag_Check (Flag13-Sem)\n       --  No_Elaboration_Check (Flag14-Sem)\n@@ -9540,6 +9547,9 @@ package Sinfo is\n    function No_Minimize_Eliminate\n      (N : Node_Id) return Boolean;    -- Flag17\n \n+   function No_Side_Effect_Removal\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n    function No_Truncation\n      (N : Node_Id) return Boolean;    -- Flag17\n \n@@ -10581,6 +10591,9 @@ package Sinfo is\n    procedure Set_No_Minimize_Eliminate\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n+   procedure Set_No_Side_Effect_Removal\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n    procedure Set_No_Truncation\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n@@ -12877,6 +12890,7 @@ package Sinfo is\n    pragma Inline (No_Entities_Ref_In_Spec);\n    pragma Inline (No_Initialization);\n    pragma Inline (No_Minimize_Eliminate);\n+   pragma Inline (No_Side_Effect_Removal);\n    pragma Inline (No_Truncation);\n    pragma Inline (Non_Aliased_Prefix);\n    pragma Inline (Null_Present);\n@@ -13220,6 +13234,7 @@ package Sinfo is\n    pragma Inline (Set_No_Entities_Ref_In_Spec);\n    pragma Inline (Set_No_Initialization);\n    pragma Inline (Set_No_Minimize_Eliminate);\n+   pragma Inline (Set_No_Side_Effect_Removal);\n    pragma Inline (Set_No_Truncation);\n    pragma Inline (Set_Non_Aliased_Prefix);\n    pragma Inline (Set_Null_Excluding_Subtype);"}]}