{"sha": "b2f39494f9f2f15d096d8119066b1f2631cdafc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJmMzk0OTRmOWYyZjE1ZDA5NmQ4MTE5MDY2YjFmMjYzMWNkYWZjMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-01-18T11:20:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-01-18T11:20:51Z"}, "message": "alpha.c (alpha_split_tfmode_pair): Rename into alpha_split_tmode_pair.\n\n\t* config/alpha/alpha.c (alpha_split_tfmode_pair): Rename into\n\talpha_split_tmode_pair.  Add 'mode' and 'fixup_overlap' arguments.\n\tTest against the appropriate null constant for the mode.\n\tIf 'fixup_overlap' is true, swap the operands if they overlap.\n\t(alpha_split_tfmode_frobsign): Adjust call to alpha_split_tfmode_pair.\n\t* config/alpha/alpha-protos.h (alpha_split_tfmode_pair): Rename into\n\talpha_split_tmode_pair and adjust for above change.\n\t* config/alpha/alpha.md (movtf_internal): Adjust call to\n\talpha_split_tfmode_pair and rely on it to swap the operands.\n\t(movti_internal): New insn and post-reload splitter.\n\t(movti): New expander.\n\nFrom-SVN: r109882", "tree": {"sha": "3fabbd2d1f832606564c35679ccae185098d100c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fabbd2d1f832606564c35679ccae185098d100c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2f39494f9f2f15d096d8119066b1f2631cdafc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2f39494f9f2f15d096d8119066b1f2631cdafc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2f39494f9f2f15d096d8119066b1f2631cdafc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2f39494f9f2f15d096d8119066b1f2631cdafc1/comments", "author": null, "committer": null, "parents": [{"sha": "17dcd421bbdc9d230878b3de8d2c5a3204d22f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17dcd421bbdc9d230878b3de8d2c5a3204d22f2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17dcd421bbdc9d230878b3de8d2c5a3204d22f2c"}], "stats": {"total": 125, "additions": 110, "deletions": 15}, "files": [{"sha": "8bb03f70cc8cb51c07af2f18fd984d218aa197eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2f39494f9f2f15d096d8119066b1f2631cdafc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2f39494f9f2f15d096d8119066b1f2631cdafc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2f39494f9f2f15d096d8119066b1f2631cdafc1", "patch": "@@ -1,3 +1,17 @@\n+2006-01-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/alpha/alpha.c (alpha_split_tfmode_pair): Rename into\n+\talpha_split_tmode_pair.  Add 'mode' and 'fixup_overlap' arguments.\n+\tTest against the appropriate null constant for the mode.\n+\tIf 'fixup_overlap' is true, swap the operands if they overlap.\n+\t(alpha_split_tfmode_frobsign): Adjust call to alpha_split_tfmode_pair.\n+\t* config/alpha/alpha-protos.h (alpha_split_tfmode_pair): Rename into\n+\talpha_split_tmode_pair and adjust for above change.\n+\t* config/alpha/alpha.md (movtf_internal): Adjust call to\n+\talpha_split_tfmode_pair and rely on it to swap the operands.\n+\t(movti_internal): New insn and post-reload splitter.\n+\t(movti): New expander.\n+\n 2006-01-18  Philippe De Muyter  <phdm@macqel.be>\n \n \t* config/m68k/m68k.md (*addsi3_5200): Allow addq/subq to memory"}, {"sha": "f099b4d15e7ff24708eecff647a48881a732c5a6", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2f39494f9f2f15d096d8119066b1f2631cdafc1/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2f39494f9f2f15d096d8119066b1f2631cdafc1/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=b2f39494f9f2f15d096d8119066b1f2631cdafc1", "patch": "@@ -64,7 +64,7 @@ extern bool alpha_expand_mov_nobwx (enum machine_mode, rtx *);\n extern void alpha_expand_movmisalign (enum machine_mode, rtx *);\n extern void alpha_emit_floatuns (rtx[]);\n extern rtx alpha_emit_conditional_move (rtx, enum machine_mode);\n-extern void alpha_split_tfmode_pair (rtx[]);\n+extern void alpha_split_tmode_pair (rtx[], enum machine_mode, bool);\n extern void alpha_split_tfmode_frobsign (rtx[], rtx (*)(rtx, rtx, rtx));\n extern void alpha_expand_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, int);"}, {"sha": "c684a4cb1e26bd315154a72af1eef4a65ed76dc0", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2f39494f9f2f15d096d8119066b1f2631cdafc1/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2f39494f9f2f15d096d8119066b1f2631cdafc1/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=b2f39494f9f2f15d096d8119066b1f2631cdafc1", "patch": "@@ -3198,12 +3198,17 @@ alpha_emit_xfloating_cvt (enum rtx_code orig_code, rtx operands[])\n \t\t\t\t\t       operands[1]));\n }\n \n-/* Split a TFmode OP[1] into DImode OP[2,3] and likewise for\n-   OP[0] into OP[0,1].  Naturally, output operand ordering is\n-   little-endian.  */\n-\n+/* Split a TImode or TFmode move from OP[1] to OP[0] into a pair of\n+   DImode moves from OP[2,3] to OP[0,1].  If FIXUP_OVERLAP is true,\n+   guarantee that the sequence\n+     set (OP[0] OP[2])\n+     set (OP[1] OP[3])\n+   is valid.  Naturally, output operand ordering is little-endian.\n+   This is used by *movtf_internal and *movti_internal.  */\n+  \n void\n-alpha_split_tfmode_pair (rtx operands[4])\n+alpha_split_tmode_pair (rtx operands[4], enum machine_mode mode,\n+\t\t\tbool fixup_overlap)\n {\n   switch (GET_CODE (operands[1]))\n     {\n@@ -3217,8 +3222,9 @@ alpha_split_tfmode_pair (rtx operands[4])\n       operands[2] = adjust_address (operands[1], DImode, 0);\n       break;\n \n+    case CONST_INT:\n     case CONST_DOUBLE:\n-      gcc_assert (operands[1] == CONST0_RTX (TFmode));\n+      gcc_assert (operands[1] == CONST0_RTX (mode));\n       operands[2] = operands[3] = const0_rtx;\n       break;\n \n@@ -3241,6 +3247,13 @@ alpha_split_tfmode_pair (rtx operands[4])\n     default:\n       gcc_unreachable ();\n     }\n+\n+  if (fixup_overlap && reg_overlap_mentioned_p (operands[0], operands[3]))\n+    {\n+      rtx tmp;\n+      tmp = operands[0], operands[0] = operands[1], operands[1] = tmp;\n+      tmp = operands[2], operands[2] = operands[3], operands[3] = tmp;\n+    }\n }\n \n /* Implement negtf2 or abstf2.  Op0 is destination, op1 is source,\n@@ -3254,7 +3267,7 @@ alpha_split_tfmode_frobsign (rtx operands[3], rtx (*operation) (rtx, rtx, rtx))\n   rtx scratch;\n   int move;\n \n-  alpha_split_tfmode_pair (operands);\n+  alpha_split_tmode_pair (operands, TFmode, false);\n \n   /* Detect three flavors of operand overlap.  */\n   move = 1;"}, {"sha": "2838499fa86dfcc9cccb920c5fad5aea91639318", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 75, "deletions": 7, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2f39494f9f2f15d096d8119066b1f2631cdafc1/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2f39494f9f2f15d096d8119066b1f2631cdafc1/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=b2f39494f9f2f15d096d8119066b1f2631cdafc1", "patch": "@@ -5176,13 +5176,7 @@\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 1) (match_dup 3))]\n {\n-  alpha_split_tfmode_pair (operands);\n-  if (reg_overlap_mentioned_p (operands[0], operands[3]))\n-    {\n-      rtx tmp;\n-      tmp = operands[0], operands[0] = operands[1], operands[1] = tmp;\n-      tmp = operands[2], operands[2] = operands[3], operands[3] = tmp;\n-    }\n+  alpha_split_tmode_pair (operands, TFmode, true); \n })\n \n (define_expand \"movsf\"\n@@ -5668,6 +5662,80 @@\n     FAIL;\n })\n \n+;; We need to prevent reload from splitting TImode moves, because it\n+;; might decide to overwrite a pointer with the value it points to.\n+;; In that case we have to do the loads in the appropriate order so\n+;; that the pointer is not destroyed too early.\n+\n+(define_insn_and_split \"*movti_internal\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,o\")\n+        (match_operand:TI 1 \"input_operand\" \"roJ,rJ\"))]\n+  \"(register_operand (operands[0], TImode)\n+    /* Prevent rematerialization of constants.  */\n+    && ! CONSTANT_P (operands[1]))\n+   || reg_or_0_operand (operands[1], TImode)\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 1) (match_dup 3))]\n+{\n+  alpha_split_tmode_pair (operands, TImode, true);\n+})\n+\n+(define_expand \"movti\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! reg_or_0_operand (operands[1], TImode))\n+    operands[1] = force_reg (TImode, operands[1]);\n+\n+  if (operands[1] == const0_rtx)\n+    ;\n+  /* We must put 64-bit constants in memory.  We could keep the\n+     32-bit constants in TImode and rely on the splitter, but\n+     this doesn't seem to be worth the pain.  */\n+  else if (GET_CODE (operands[1]) == CONST_INT\n+\t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      rtx in[2], out[2], target;\n+\n+      gcc_assert (!no_new_pseudos);\n+\n+      split_double (operands[1], &in[0], &in[1]);\n+\n+      if (in[0] == const0_rtx)\n+\tout[0] = const0_rtx;\n+      else\n+\t{\n+\t  out[0] = gen_reg_rtx (DImode);\n+\t  emit_insn (gen_movdi (out[0], in[0]));\n+\t}\n+\n+      if (in[1] == const0_rtx)\n+\tout[1] = const0_rtx;\n+      else\n+\t{\n+\t  out[1] = gen_reg_rtx (DImode);\n+\t  emit_insn (gen_movdi (out[1], in[1]));\n+\t}\n+\n+      if (GET_CODE (operands[0]) != REG)\n+\ttarget = gen_reg_rtx (TImode);\n+      else\n+\ttarget = operands[0];\n+\n+      emit_insn (gen_movdi (gen_rtx_SUBREG (DImode, target, 0), out[0]));\n+      emit_insn (gen_movdi (gen_rtx_SUBREG (DImode, target, 8), out[1]));\n+\n+      if (target != operands[0])\n+\temit_insn (gen_rtx_SET (VOIDmode, operands[0], target));\n+\n+      DONE;\n+    }\n+})\n+\n ;; These are the partial-word cases.\n ;;\n ;; First we have the code to load an aligned word.  Operand 0 is the register"}]}