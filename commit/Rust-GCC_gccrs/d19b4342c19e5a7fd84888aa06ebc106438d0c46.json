{"sha": "d19b4342c19e5a7fd84888aa06ebc106438d0c46", "node_id": "C_kwDOANBUbNoAKGQxOWI0MzQyYzE5ZTVhN2ZkODQ4ODhhYTA2ZWJjMTA2NDM4ZDBjNDY", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-06-01T21:30:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-06-02T19:16:55Z"}, "message": "c++: more constexpr empty base [PR105795]\n\nFollowing on from the previous patch, for trunk let's consistently set\nctx->ctor to NULL_TREE for empty subobjects.\n\n\tPR c++/105795\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (init_subob_ctx): Clear ctx->ctor for empty subob.\n\t(cxx_eval_store_expression): Likewise.\n\t(cxx_eval_bare_aggregate): Handle null ctx->ctor.", "tree": {"sha": "f50169adef565e41d469bf87917fce67c9f6d833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f50169adef565e41d469bf87917fce67c9f6d833"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d19b4342c19e5a7fd84888aa06ebc106438d0c46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19b4342c19e5a7fd84888aa06ebc106438d0c46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19b4342c19e5a7fd84888aa06ebc106438d0c46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19b4342c19e5a7fd84888aa06ebc106438d0c46/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db4243bb681f7d4e82c15674eb3bfd9b82b0cf71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db4243bb681f7d4e82c15674eb3bfd9b82b0cf71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db4243bb681f7d4e82c15674eb3bfd9b82b0cf71"}], "stats": {"total": 65, "additions": 42, "deletions": 23}, "files": [{"sha": "1346a1d4c10ff29daf2ed6f62dcdd57560c936f8", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19b4342c19e5a7fd84888aa06ebc106438d0c46/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19b4342c19e5a7fd84888aa06ebc106438d0c46/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=d19b4342c19e5a7fd84888aa06ebc106438d0c46", "patch": "@@ -4695,9 +4695,17 @@ init_subob_ctx (const constexpr_ctx *ctx, constexpr_ctx &new_ctx,\n       else\n \tnew_ctx.object = build_ctor_subob_ref (index, type, ctx->object);\n     }\n-  tree elt = build_constructor (type, NULL);\n-  CONSTRUCTOR_NO_CLEARING (elt) = true;\n-  new_ctx.ctor = elt;\n+\n+  if (is_empty_class (type))\n+    /* Leave ctor null for an empty subobject, they aren't represented in the\n+       result of evaluation.  */\n+    new_ctx.ctor = NULL_TREE;\n+  else\n+    {\n+      tree elt = build_constructor (type, NULL);\n+      CONSTRUCTOR_NO_CLEARING (elt) = true;\n+      new_ctx.ctor = elt;\n+    }\n \n   if (TREE_CODE (value) == TARGET_EXPR)\n     /* Avoid creating another CONSTRUCTOR when we expand the TARGET_EXPR.  */\n@@ -4762,11 +4770,14 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n       ctx = &new_ctx;\n     };\n   verify_ctor_sanity (ctx, type);\n-  vec<constructor_elt, va_gc> **p = &CONSTRUCTOR_ELTS (ctx->ctor);\n-  vec_alloc (*p, vec_safe_length (v));\n-\n-  if (CONSTRUCTOR_PLACEHOLDER_BOUNDARY (t))\n-    CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ctx->ctor) = 1;\n+  vec<constructor_elt, va_gc> **p = nullptr;\n+  if (ctx->ctor)\n+    {\n+      p = &CONSTRUCTOR_ELTS (ctx->ctor);\n+      vec_alloc (*p, vec_safe_length (v));\n+      if (CONSTRUCTOR_PLACEHOLDER_BOUNDARY (t))\n+\tCONSTRUCTOR_PLACEHOLDER_BOUNDARY (ctx->ctor) = 1;\n+    }\n \n   unsigned i;\n   tree index, value;\n@@ -4814,17 +4825,19 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \t  inner->value = elt;\n \t  changed = true;\n \t}\n+      else if (no_slot)\n+\t/* This is an initializer for an empty field; now that we've\n+\t   checked that it's constant, we can ignore it.  */\n+\tchanged = true;\n       else if (index\n \t       && (TREE_CODE (index) == NOP_EXPR\n \t\t   || TREE_CODE (index) == POINTER_PLUS_EXPR))\n \t{\n-\t  /* This is an initializer for an empty base; now that we've\n-\t     checked that it's constant, we can ignore it.  */\n+\t  /* Old representation of empty bases.  FIXME remove.  */\n+\t  gcc_checking_assert (false);\n \t  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (index))));\n \t  changed = true;\n \t}\n-      else if (no_slot)\n-\tchanged = true;\n       else\n \t{\n \t  if (TREE_CODE (type) == UNION_TYPE\n@@ -4849,6 +4862,8 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n   if (*non_constant_p || !changed)\n     return t;\n   t = ctx->ctor;\n+  if (!t)\n+    t = build_constructor (type, NULL);\n   /* We're done building this CONSTRUCTOR, so now we can interpret an\n      element without an explicit initializer as value-initialized.  */\n   CONSTRUCTOR_NO_CLEARING (t) = false;\n@@ -5833,6 +5848,16 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       valp = &cep->value;\n     }\n \n+  /* For initialization of an empty base, the original target will be\n+     *(base*)this, evaluation of which resolves to the object\n+     argument, which has the derived type rather than the base type.  */\n+  if (!empty_base && !(same_type_ignoring_top_level_qualifiers_p\n+\t\t       (initialized_type (init), type)))\n+    {\n+      gcc_assert (is_empty_class (TREE_TYPE (target)));\n+      empty_base = true;\n+    }\n+\n   /* Detect modifying a constant object in constexpr evaluation.\n      We have found a const object that is being modified.  Figure out\n      if we need to issue an error.  Consider\n@@ -5901,7 +5926,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t  *valp = build_constructor (type, NULL);\n \t  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;\n \t}\n-      new_ctx.ctor = *valp;\n+      new_ctx.ctor = empty_base ? NULL_TREE : *valp;\n       new_ctx.object = target;\n       /* Avoid temporary materialization when initializing from a TARGET_EXPR.\n \t We don't need to mess with AGGR_EXPR_SLOT/VEC_INIT_EXPR_SLOT because\n@@ -5931,16 +5956,10 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \n   gcc_checking_assert (!*valp || (same_type_ignoring_top_level_qualifiers_p\n \t\t\t\t  (TREE_TYPE (*valp), type)));\n-  if (empty_base || !(same_type_ignoring_top_level_qualifiers_p\n-\t\t      (initialized_type (init), type)))\n-    {\n-      /* For initialization of an empty base, the original target will be\n-       *(base*)this, evaluation of which resolves to the object\n-       argument, which has the derived type rather than the base type.  In\n-       this situation, just evaluate the initializer and return, since\n-       there's no actual data to store, and we didn't build a CONSTRUCTOR.  */\n-      gcc_assert (is_empty_class (TREE_TYPE (target)));\n-      empty_base = true;\n+  if (empty_base)\n+    {\n+      /* Just evaluate the initializer and return, since there's no actual data\n+\t to store, and we didn't build a CONSTRUCTOR.  */\n       if (!*valp)\n \t{\n \t  /* But do make sure we have something in *valp.  */"}]}