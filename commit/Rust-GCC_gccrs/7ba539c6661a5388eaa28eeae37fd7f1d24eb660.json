{"sha": "7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JhNTM5YzY2NjFhNTM4OGVhYTI4ZWVhZTM3ZmQ3ZjFkMjRlYjY2MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-10-22T05:04:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-10-22T05:04:48Z"}, "message": "class.c (empty_base_at_nonzero_offset_p): New function.\n\n\t* class.c (empty_base_at_nonzero_offset_p): New function.\n\t(layout_nonempty_base_or_field): Do not check for conflicts when\n\tlaying out a virtual base using the GCC 3.2 ABI.\n\t(build_base_field): Correct checking for presence of empty classes\n\tat non-zero offsets when clearing CLASSTYPE_NEARLY_EMPTY_P.\n\n\t* g++.dg/abi/vbase13.C: New test.\n\t* g++.dg/abi/vbase14.C: Likewise.\n\nFrom-SVN: r58397", "tree": {"sha": "4b99387bab5f35027f255ee22e338f0031a4d558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b99387bab5f35027f255ee22e338f0031a4d558"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/comments", "author": null, "committer": null, "parents": [{"sha": "5e26e5a278abef7e0b5df09fcf54de6915fd4497", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e26e5a278abef7e0b5df09fcf54de6915fd4497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e26e5a278abef7e0b5df09fcf54de6915fd4497"}], "stats": {"total": 78, "additions": 75, "deletions": 3}, "files": [{"sha": "ed176188426ceef7fa29f392cdb77f2a3f4b1ce1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "patch": "@@ -1,5 +1,11 @@\n 2002-10-21  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (empty_base_at_nonzero_offset_p): New function.\n+\t(layout_nonempty_base_or_field): Do not check for conflicts when\n+\tlaying out a virtual base using the GCC 3.2 ABI.\n+\t(build_base_field): Correct checking for presence of empty classes\n+\tat non-zero offsets when clearing CLASSTYPE_NEARLY_EMPTY_P.\n+\n \t* class.c (include_empty_classes): Use normalize_rli.\n \t(layout_class_type): Likewise.\n "}, {"sha": "1439833b209d12f032a5f79ac21789db20a9e23a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "patch": "@@ -209,6 +209,7 @@ static bool type_requires_array_cookie PARAMS ((tree));\n static bool contains_empty_class_p (tree);\n static tree dfs_base_derived_from (tree, void *);\n static bool base_derived_from (tree, tree);\n+static int empty_base_at_nonzero_offset_p (tree, tree, splay_tree);\n \n /* Macros for dfs walking during vtt construction. See\n    dfs_ctor_vtable_bases_queue_p, dfs_build_secondary_vptr_vtt_inits\n@@ -3674,6 +3675,10 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \t empty class, have nonzero size, any overlap can happen only\n \t with a direct or indirect base-class -- it can't happen with\n \t a data member.  */\n+      /* G++ 3.2 did not check for overlaps when placing a non-empty\n+\t virtual base.  */\n+      if (!abi_version_at_least (2) && binfo && TREE_VIA_VIRTUAL (binfo))\n+\tbreak;\n       if (layout_conflict_p (type, offset, offsets, field_p))\n \t{\n \t  /* Strip off the size allocated to this field.  That puts us\n@@ -3708,6 +3713,16 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \t\t\t     t);\n }\n \n+/* Returns true if TYPE is empty and OFFSET is non-zero.  */\n+\n+static int\n+empty_base_at_nonzero_offset_p (tree type,\n+\t\t\t\ttree offset,\n+\t\t\t\tsplay_tree offsets ATTRIBUTE_UNUSED)\n+{\n+  return is_empty_class (type) && !integer_zerop (offset);\n+}\n+\n /* Layout the empty base BINFO.  EOC indicates the byte currently just\n    past the end of the class, and should be correctly aligned for a\n    class of the type indicated by BINFO; OFFSETS gives the offsets of\n@@ -3816,14 +3831,37 @@ build_base_field (record_layout_info rli, tree binfo,\n   else\n     {\n       tree eoc;\n+      bool atend;\n \n       /* On some platforms (ARM), even empty classes will not be\n \t byte-aligned.  */\n       eoc = round_up (rli_size_unit_so_far (rli),\n \t\t      CLASSTYPE_ALIGN_UNIT (basetype));\n-      if (layout_empty_base (binfo, eoc, offsets, t))\n-\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n-\n+      atend = layout_empty_base (binfo, eoc, offsets, t);\n+      /* A nearly-empty class \"has no proper base class that is empty,\n+\t not morally virtual, and at an offset other than zero.\"  */\n+      if (!TREE_VIA_VIRTUAL (binfo) && CLASSTYPE_NEARLY_EMPTY_P (t))\n+\t{\n+\t  if (atend)\n+\t    CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+\t  /* The check above (used in G++ 3.2) is insufficient  because\n+\t     an empty class placed at offset zero might itself have an\n+\t     empty base at a non-zero offset.  */\n+\t  else if (walk_subobject_offsets (basetype, \n+\t\t\t\t\t   empty_base_at_nonzero_offset_p,\n+\t\t\t\t\t   size_zero_node,\n+\t\t\t\t\t   /*offsets=*/NULL,\n+\t\t\t\t\t   /*max_offset=*/NULL_TREE,\n+\t\t\t\t\t   /*vbases_p=*/true))\n+\t    {\n+\t      if (abi_version_at_least (2))\n+\t\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+\t      else if (warn_abi)\n+\t\twarning (\"class `%T' will be considered nearly empty in a \"\n+\t\t\t \"future version of GCC\", t);\n+\t    }\n+\t}\n+\t\n       /* We do not create a FIELD_DECL for empty base classes because\n \t it might overlap some other field.  We want to be able to\n \t create CONSTRUCTORs for the class by iterating over the"}, {"sha": "314b222aa40f633e1b938f2bb03edc129e3b6bb7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "patch": "@@ -1,3 +1,8 @@\n+2002-10-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/abi/vbase13.C: New test.\n+\t* g++.dg/abi/vbase14.C: Likewise.\n+\n 2002-10-21  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/tls/pic-1.c: New test."}, {"sha": "6a0bff484d78c61c7691c3c45181c46a15efe1c7", "filename": "gcc/testsuite/g++.dg/abi/vbase13.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase13.C?ref=7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do run }\n+// { dg-options \"-fabi-version=0 -w\" }\n+\n+struct E1 {};\n+struct E2 : public E1 {};\n+struct E : public E1, public E2 {};\n+struct N : public E { virtual void f () {} };\n+\n+struct X : virtual public N {\n+};\n+\n+int main () {\n+  X x;\n+  /* N should not be the primary base of X; it is not nearly empty.  */\n+  if ((void*)&x == (void*)(N*)&x)\n+    return 1;\n+}"}, {"sha": "99290b857209f0dea75a2bd874b5f8b171c68444", "filename": "gcc/testsuite/g++.dg/abi/vbase14.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba539c6661a5388eaa28eeae37fd7f1d24eb660/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fvbase14.C?ref=7ba539c6661a5388eaa28eeae37fd7f1d24eb660", "patch": "@@ -0,0 +1,6 @@\n+// { dg-options \"-Wabi\" }\n+\n+struct E1 {};\n+struct E2 : public E1 {}; // { dg-warning \"layout\" }\n+struct E : public E1, public E2 {}; // { dg-warning \"layout|ambiguity\" }\n+struct N : public E { virtual void f () {} };  // { dg-warning \"nearly\" }"}]}