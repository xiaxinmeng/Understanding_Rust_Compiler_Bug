{"sha": "89d09f835ac586f32946dc4948f95c63b3c66c21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkMDlmODM1YWM1ODZmMzI5NDZkYzQ5NDhmOTVjNjNiM2M2NmMyMQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-06-16T16:34:04Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-06-16T16:34:04Z"}, "message": "c-format.c (dynamic_format_types): New pointer for dynamic data.\n\n\t* c-format.c (dynamic_format_types): New pointer for dynamic data.\n\t(find_length_info_modifier_index, init_dynamic_asm_fprintf_info):\n\tNew functions split out of...\n\t(handle_format_attribute): ...here.\n\nFrom-SVN: r68023", "tree": {"sha": "c94e2380668c248fde903fae2d669a32e731a58b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c94e2380668c248fde903fae2d669a32e731a58b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89d09f835ac586f32946dc4948f95c63b3c66c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d09f835ac586f32946dc4948f95c63b3c66c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d09f835ac586f32946dc4948f95c63b3c66c21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d09f835ac586f32946dc4948f95c63b3c66c21/comments", "author": null, "committer": null, "parents": [{"sha": "735cb76eba6a5558d6605aa191e04c55e1ce7e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/735cb76eba6a5558d6605aa191e04c55e1ce7e98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/735cb76eba6a5558d6605aa191e04c55e1ce7e98"}], "stats": {"total": 116, "additions": 78, "deletions": 38}, "files": [{"sha": "835ff43689bf57361c80931db65c636f7a9e8cce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d09f835ac586f32946dc4948f95c63b3c66c21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d09f835ac586f32946dc4948f95c63b3c66c21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89d09f835ac586f32946dc4948f95c63b3c66c21", "patch": "@@ -1,3 +1,10 @@\n+2003-06-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* c-format.c (dynamic_format_types): New pointer for dynamic data.\n+\t(find_length_info_modifier_index, init_dynamic_asm_fprintf_info):\n+\tNew functions split out of...\n+\t(handle_format_attribute): ...here.\n+\n 2003-06-16  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* sh.h (REG_CLASS_FROM_LETTER): Change to:"}, {"sha": "c72a803aff895730da3cbcd1e934809946df7fde", "filename": "gcc/c-format.c", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d09f835ac586f32946dc4948f95c63b3c66c21/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d09f835ac586f32946dc4948f95c63b3c66c21/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=89d09f835ac586f32946dc4948f95c63b3c66c21", "patch": "@@ -855,6 +855,8 @@ static const format_kind_info format_types_orig[] =\n    new data if necessary, while still allowing the original data to be\n    const.  */\n static const format_kind_info *format_types = format_types_orig;\n+/* We can modify this one.  */\n+static format_kind_info *dynamic_format_types;\n \n /* Structure detailing the results of checking a format function call\n    where the format expression may be a conditional expression with\n@@ -2367,6 +2369,67 @@ check_format_types (status, types)\n     }\n }\n \n+/* Given a format_length_info array FLI, and a character C, this\n+   function returns the index into the conversion_specs where that\n+   modifier's data is located.  If the character isn't found it\n+   aborts.  */\n+static unsigned int\n+find_length_info_modifier_index (const format_length_info *fli, int c)\n+{\n+  unsigned int i = 0;\n+  \n+  while (fli->name)\n+    {\n+      if (strchr (fli->name, c))\n+\treturn i;\n+      i++; fli++;\n+    }\n+  \n+  /* We shouldn't be looking for a non-existent modifier.  */\n+  abort ();\n+}\n+\n+/* Determine the type of HOST_WIDE_INT in the code being compiled for\n+   use in GCC's __asm_fprintf__ custom format attribute.  You must\n+   have set dynamic_format_types before calling this function.  */\n+static void\n+init_dynamic_asm_fprintf_info (void)\n+{\n+  static tree hwi;\n+      \n+  if (!hwi)\n+    {\n+      format_length_info *new_asm_fprintf_length_specs;\n+      unsigned int i;\n+\t  \n+      /* Find the underlying type for HOST_WIDE_INT.  For the %w\n+\t length modifier to work, one must have issued: \"typedef\n+\t HOST_WIDE_INT __gcc_host_wide_int__;\" in one's source code\n+\t prior to using that modifier.  */\n+      if (!(hwi = maybe_get_identifier (\"__gcc_host_wide_int__\"))\n+\t  || !(hwi = DECL_ORIGINAL_TYPE (identifier_global_value (hwi))))\n+\tabort ();\n+\n+      /* Create a new (writable) copy of asm_fprintf_length_specs.  */\n+      new_asm_fprintf_length_specs = xmemdup (asm_fprintf_length_specs,\n+\t\t\t\t\t      sizeof (asm_fprintf_length_specs),\n+\t\t\t\t\t      sizeof (asm_fprintf_length_specs));\n+\n+      /* HOST_WIDE_INT must be one of 'long' or 'long long'.  */\n+      i = find_length_info_modifier_index (new_asm_fprintf_length_specs, 'w');\n+      if (hwi == long_integer_type_node)\n+\tnew_asm_fprintf_length_specs[i].index = FMT_LEN_l;\n+      else if (hwi == long_long_integer_type_node)\n+\tnew_asm_fprintf_length_specs[i].index = FMT_LEN_ll;\n+      else\n+\tabort ();\n+\n+      /* Assign the new data for use.  */\n+      dynamic_format_types[asm_fprintf_format_type].length_char_specs =\n+\tnew_asm_fprintf_length_specs;\n+    }\n+}\n+\n /* Handle a \"format\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n@@ -2424,44 +2487,14 @@ handle_format_attribute (node, name, args, flags, no_add_attrs)\n      GCC's notion of HOST_WIDE_INT for checking %wd.  */\n   if (info.format_type == asm_fprintf_format_type)\n     {\n-      static tree hwi;\n-      tree orig;\n-      \n-      /* For this custom check to work, one must have issued:\n-\t \"typedef HOST_WIDE_INT __gcc_host_wide_int__;\"\n-\t in your source code prior to using this attribute.  */\n-      if (!hwi)\n-        {\n-\t  format_kind_info *new_format_types;\n-\t  format_length_info *new_asm_fprintf_length_specs;\n-\t  \n-\t  if (!(hwi = maybe_get_identifier (\"__gcc_host_wide_int__\")))\n-\t    abort ();\n-\n-\t  /* Create a new (writable) copy of asm_fprintf_length_specs.  */\n-\t  new_asm_fprintf_length_specs =\n-\t    xmalloc (sizeof (asm_fprintf_length_specs));\n-\t  memcpy (new_asm_fprintf_length_specs, asm_fprintf_length_specs,\n-\t\t  sizeof (asm_fprintf_length_specs));\n-\n-\t  /* Create a new (writable) copy of format_types.  */\n-\t  new_format_types = xmalloc (sizeof (format_types_orig));\n-\t  memcpy (new_format_types, format_types_orig, sizeof (format_types_orig));\n-\t  \n-\t  /* Find the underlying type for HOST_WIDE_INT.  */\n-\t  orig = DECL_ORIGINAL_TYPE (identifier_global_value (hwi));\n-\t  if (orig == long_integer_type_node)\n-\t    new_asm_fprintf_length_specs[1].index = FMT_LEN_l;\n-\t  else if (orig == long_long_integer_type_node)\n-\t    new_asm_fprintf_length_specs[1].index = FMT_LEN_ll;\n-\t  else\n-\t    abort ();\n-\n-\t  /* Assign the new data for use.  */\n-\t  new_format_types[asm_fprintf_format_type].length_char_specs =\n-\t    new_asm_fprintf_length_specs;\n-\t  format_types = new_format_types;\n-\t}\n+      /* Our first time through, we have to make sure that our\n+         format_type data is allocated dynamically and is modifiable.  */\n+      if (!dynamic_format_types)\n+\tformat_types = dynamic_format_types =\n+\t  xmemdup (format_types_orig, sizeof (format_types_orig),\n+\t\t   sizeof (format_types_orig));\n+\n+      init_dynamic_asm_fprintf_info();\n     }\n \n   return NULL_TREE;"}]}