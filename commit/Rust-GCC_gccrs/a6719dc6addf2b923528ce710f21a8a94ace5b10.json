{"sha": "a6719dc6addf2b923528ce710f21a8a94ace5b10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY3MTlkYzZhZGRmMmI5MjM1MjhjZTcxMGYyMWE4YTk0YWNlNWIxMA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2006-05-29T14:57:39Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-05-29T14:57:39Z"}, "message": "re PR tree-optimization/26242 (VRP is not documented in passes.texi)\n\n\n\tPR 26242\n\t* doc/passes.texi: Add documentation for pass_vrp, pass_ipa_pta,\n\tpass_fre, pass_store_ccp, pass_copy_prop,\n\tpass_store_copy_prop, pass_merge_phi, pass_nrv,\n\tpass_return_slot, pass_object_size, pass_lim,\n\tpass_linear_transform, pass_empty_loop, pass_complete_unroll,\n\tpass_loop_prefetch and pass_stdarg.\n\nFrom-SVN: r114200", "tree": {"sha": "f21e8dd04440f47bab10536a61a2b14ddefbf586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f21e8dd04440f47bab10536a61a2b14ddefbf586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6719dc6addf2b923528ce710f21a8a94ace5b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6719dc6addf2b923528ce710f21a8a94ace5b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6719dc6addf2b923528ce710f21a8a94ace5b10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6719dc6addf2b923528ce710f21a8a94ace5b10/comments", "author": null, "committer": null, "parents": [{"sha": "6614f9f559f734f3be5d10eb7a06791ec7a908a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6614f9f559f734f3be5d10eb7a06791ec7a908a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6614f9f559f734f3be5d10eb7a06791ec7a908a4"}], "stats": {"total": 160, "additions": 145, "deletions": 15}, "files": [{"sha": "facaa7191514f671fadc5a40b4c41c1cb8bb599d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6719dc6addf2b923528ce710f21a8a94ace5b10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6719dc6addf2b923528ce710f21a8a94ace5b10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6719dc6addf2b923528ce710f21a8a94ace5b10", "patch": "@@ -1,3 +1,13 @@\n+2006-05-29  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 26242\n+\t* doc/passes.texi: Add documentation for pass_vrp, pass_ipa_pta,\n+\tpass_fre, pass_store_ccp, pass_copy_prop,\n+\tpass_store_copy_prop, pass_merge_phi, pass_nrv,\n+\tpass_return_slot, pass_object_size, pass_lim,\n+\tpass_linear_transform, pass_empty_loop, pass_complete_unroll,\n+\tpass_loop_prefetch and pass_stdarg.\n+\n 2005-05-29  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.opt (mfdpic): New option."}, {"sha": "9da919152b75f80bd42a3d3bd5b06c4e7b7f979a", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 135, "deletions": 15, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6719dc6addf2b923528ce710f21a8a94ace5b10/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6719dc6addf2b923528ce710f21a8a94ace5b10/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=a6719dc6addf2b923528ce710f21a8a94ace5b10", "patch": "@@ -265,7 +265,7 @@ and is described by @code{pass_referenced_vars}.\n This pass rewrites the function such that it is in SSA form.  After\n this pass, all @code{is_gimple_reg} variables will be referenced by\n @code{SSA_NAME}, and all occurrences of other variables will be\n-annotated with @code{VDEFS} and @code{VUSES}; phi nodes will have\n+annotated with @code{VDEFS} and @code{VUSES}; PHI nodes will have\n been inserted as necessary for each basic block.  This pass is\n located in @file{tree-ssa.c} and is described by @code{pass_build_ssa}.\n \n@@ -295,9 +295,9 @@ expression simplification, and jump threading.  It is run multiple times\n throughout the optimization process.  It it located in @file{tree-ssa-dom.c}\n and is described by @code{pass_dominator}.\n \n-@item Redundant phi elimination\n+@item Redundant PHI elimination\n \n-This pass removes phi nodes for which all of the arguments are the same\n+This pass removes PHI nodes for which all of the arguments are the same\n value, excluding feedback.  Such degenerate forms are typically created\n by removing unreachable code.  The pass is run multiple times throughout\n the optimization process.  It is located in @file{tree-ssa.c} and is\n@@ -321,7 +321,7 @@ located in @file{tree-ssa-copyrename.c} and is described by\n \n @item PHI node optimizations\n \n-This pass recognizes forms of phi inputs that can be represented as\n+This pass recognizes forms of PHI inputs that can be represented as\n conditional expressions and rewrites them into straight line code.\n It is located in @file{tree-ssa-phiopt.c} and is described by\n @code{pass_phiopt}.\n@@ -336,6 +336,9 @@ update the @code{VDEF}/@code{VUSE} memory tags for non-renamable\n aggregates so that we get fewer false kills.  The pass is located\n in @file{tree-ssa-alias.c} and is described by @code{pass_may_alias}.\n \n+Interprocedural points-to information is located in\n+@file{tree-ssa-structalias.c} and described by @code{pass_ipa_pta}.\n+\n @item Profiling\n \n This pass rewrites the function in order to collect runtime block\n@@ -387,6 +390,12 @@ divisions to multiplications by the reciprocal.  The pass is located\n in @file{tree-ssa-math-opts.c} and is described by\n @code{pass_cse_reciprocal}.\n \n+@item Full redundancy elimination\n+\n+This is a simpler form of PRE that only eliminate redundancies that\n+occur an all paths.  It is located in @file{tree-ssa-pre.c} and\n+described by @code{pass_fre}.\n+\n @item Loop optimization\n \n The main driver of the pass is placed in @file{tree-ssa-loop.c}\n@@ -440,11 +449,12 @@ Analysis of data references is in @file{tree-data-ref.c}.\n @item Tree level if-conversion for vectorizer\n \n This pass applies if-conversion to simple loops to help vectorizer.\n-We identify if convertable loops, if-convert statements and merge\n+We identify if convertible loops, if-convert statements and merge\n basic blocks in one big block.  The idea is to present loop in such\n form so that vectorizer can have one to one mapping between statements\n and available vector operations.  This patch re-introduces COND_EXPR\n-at GIMPLE level.  This pass is located in @file{tree-if-conv.c}.\n+at GIMPLE level.  This pass is located in @file{tree-if-conv.c} and is\n+described by @code{pass_if_conversion}.\n \n @item Conditional constant propagation\n \n@@ -453,9 +463,38 @@ that must be constant even in the presence of conditional branches.\n The pass is located in @file{tree-ssa-ccp.c} and is described\n by @code{pass_ccp}.\n \n-@item Folding builtin functions\n+A related pass that works on memory loads and stores, and not just\n+register values, is located in @file{tree-ssa-ccp.c} and described by\n+@code{pass_store_ccp}.\n+\n+@item Conditional copy propagation\n+\n+This is similar to constant propagation but the lattice of values is\n+the ``copy-of'' relation.  It eliminates redundant copies from the\n+code.  The pass is located in @file{tree-ssa-copy.c} and described by\n+@code{pass_copy_prop}.\n+\n+A related pass that works on memory copies, and not just register\n+copies, is located in @file{tree-ssa-copy.c} and described by\n+@code{pass_store_copy_prop}.\n+\n+@item Value range propagation\n+\n+This transformation is similar to constant propagation but\n+instead of propagating single constant values, it propagates\n+known value ranges.  The implementation is based on Patterson's\n+range propagation algorithm (Accurate Static Branch Prediction by\n+Value Range Propagation, J. R. C. Patterson, PLDI '95).  In\n+contrast to Patterson's algorithm, this implementation does not\n+propagate branch probabilities nor it uses more than a single\n+range per SSA name. This means that the current implementation\n+cannot be used for branch prediction (though adapting it would\n+not be difficult).  The pass is located in @file{tree-vrp.c} and is\n+described by @code{pass_vrp}.\n+\n+@item Folding built-in functions\n \n-This pass simplifies builtin functions, as applicable, with constant\n+This pass simplifies built-in functions, as applicable, with constant\n arguments or with inferrable string lengths.  It is located in\n @file{tree-ssa-ccp.c} and is described by @code{pass_fold_builtins}.\n \n@@ -465,12 +504,6 @@ This pass identifies critical edges and inserts empty basic blocks\n such that the edge is no longer critical.  The pass is located in\n @file{tree-cfg.c} and is described by @code{pass_split_crit_edges}.\n \n-@item Partial redundancy elimination\n-\n-This pass answers the question ``given a hypothetical temporary\n-variable, what expressions could we eliminate?''  It is located\n-in @file{tree-ssa-pre.c} and is described by @code{pass_pre}.\n-\n @item Control dependence dead code elimination\n \n This pass is a stronger form of dead code elimination that can\n@@ -514,7 +547,94 @@ is described by @code{pass_mudflap_2}.\n This pass rewrites the function such that it is in normal form.  At\n the same time, we eliminate as many single-use temporaries as possible,\n so the intermediate language is no longer GIMPLE, but GENERIC@.  The\n-pass is located in @file{tree-ssa.c} and is described by @code{pass_del_ssa}.\n+pass is located in @file{tree-outof-ssa.c} and is described by\n+@code{pass_del_ssa}.\n+\n+@item Merge PHI nodes that feed into one another\n+\n+This is part of the CFG cleanup passes.  It attempts to join PHI nodes\n+from a forwarder CFG block into another block with PHI nodes.  The\n+pass is located in @file{tree-cfgcleanup.c} and is described by\n+@code{pass_merge_phi}.\n+\n+@item Return value optimization\n+\n+If a function always returns the same local variable, and that local\n+variable is an aggregate type, then the variable is replaced with the\n+return value for the function (i.e., the function's DECL_RESULT).  This\n+is equivalent to the C++ named return value optimization applied to\n+GIMPLE.  The pass is located in @file{tree-nrv.c} and is described by\n+@code{pass_nrv}.\n+\n+@item Return slot optimization\n+\n+If a function returns a memory object and is called as @code{var =\n+foo()}, this pass tries to change the call so that the address of\n+@code{var} is sent to the caller to avoid an extra memory copy.  This\n+pass is located in @code{tree-nrv.c} and is described by\n+@code{pass_return_slot}.\n+\n+@item Optimize calls to @code{__builtin_object_size}\n+\n+This is a propagation pass similar to CCP that tries to remove calls\n+to @code{__builtin_object_size} when the size of the object can be\n+computed at compile-time.  This pass is located in\n+@file{tree-object-size.c} and is described by\n+@code{pass_object_sizes}.\n+\n+@item Loop invariant motion\n+\n+This pass removes expensive loop-invariant computations out of loops.\n+The pass is located in @file{tree-ssa-loop.c} and described by\n+@code{pass_lim}.\n+\n+@item Loop nest optimizations\n+\n+This is a family of loop transformations that works on loop nests.  It\n+includes loop interchange, scaling, skewing and reversal and they are\n+all geared to the optimization of data locality in array traversals\n+and the removal of dependencies that hamper optimizations such as loop\n+parallelization and vectorization.  The pass is located in\n+@file{tree-loop-linear.c} and described by\n+@code{pass_linear_transform}.\n+\n+@item Removal of empty loops\n+\n+This pass removes loops with no code in them.  The pass is located in\n+@file{tree-ssa-loop-ivcanon.c} and described by\n+@code{pass_empty_loop}.\n+\n+@item Unrolling of small loops\n+\n+This pass completely unrolls loops with few iterations.  The pass\n+is located in @file{tree-ssa-loop-ivcanon.c} and described by\n+@code{pass_complete_unroll}.\n+\n+@item Array prefetching\n+\n+This pass issues prefetch instructions for array references inside\n+loops.  The pass is located in @file{tree-ssa-loop-prefetch.c} and\n+described by @code{pass_loop_prefetch}.\n+\n+@item Reassociation\n+\n+This pass rewrites arithmetic expressions to enable optimizations that\n+operate on them, like redundancy elimination and vectorization.  The\n+pass is located in @file{tree-ssa-reassoc.c} and described by\n+@code{pass_reassoc}.\n+\n+@item Optimization of @code{stdarg} functions\n+\n+This pass tries to avoid the saving of register arguments into the\n+stack on entry to @code{stdarg} functions.  If the function doesn't\n+use any @code{va_start} macros, no registers need to be saved.  If\n+@code{va_start} macros are used, the @code{va_list} variables don't\n+escape the function, it is only necessary to save registers that will\n+be used in @code{va_arg} macros.  For instance, if @code{va_arg} is\n+only used with integral types in the function, floating point\n+registers don't need to be saved.  This pass is located in\n+@code{tree-stdarg.c} and described by @code{pass_stdarg}.\n+\n @end itemize\n \n @node RTL passes"}]}