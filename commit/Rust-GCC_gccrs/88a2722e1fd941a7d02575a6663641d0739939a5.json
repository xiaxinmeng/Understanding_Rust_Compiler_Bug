{"sha": "88a2722e1fd941a7d02575a6663641d0739939a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhhMjcyMmUxZmQ5NDFhN2QwMjU3NWE2NjYzNjQxZDA3Mzk5MzlhNQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-09-08T09:35:50Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-09-08T09:35:50Z"}, "message": "Removed obsolete intermediate threading layer.\n\n\t* thr.c: Use __gthread_objc_xxx functions directly instead of\n\t__objc_thread_xxx ones.\n\t* objc/thr.h: Removed prototypes of no longer existing\n\t__objc_thread_xxx functions.\n\t* Makefile.in: Removed thr-objc.lo.\n\t* thr-dce.c: File removed.\n\t* thr-decosf1.c: File removed.\n\t* thr-irix.c: File removed.\n\t* thr-mach.c: File removed.\n\t* thr-objc.c: File removed.\n\t* thr-os2.c: File removed.\n\t* thr-posix.c: File removed.\n\t* thr-pthreads.c: File removed.\n\t* thr-rtems.c: File removed.\n\t* thr-single.c: File removed.\n\t* thr-solaris.c: File removed.\n\t* thr-vxworks.c: File removed.\n\t* thr-win32.c: File removed.\n\t* README.threads: File removed.\n\t* THREADS.MACH: File removed.\n\t* THREADS: Updated.\n\nFrom-SVN: r163996", "tree": {"sha": "2af7479e59d3f37ae5035d563a34809a2b4036c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2af7479e59d3f37ae5035d563a34809a2b4036c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88a2722e1fd941a7d02575a6663641d0739939a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a2722e1fd941a7d02575a6663641d0739939a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88a2722e1fd941a7d02575a6663641d0739939a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88a2722e1fd941a7d02575a6663641d0739939a5/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0db1920c3d6841fafde80b28f86d90b8ab989212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0db1920c3d6841fafde80b28f86d90b8ab989212", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0db1920c3d6841fafde80b28f86d90b8ab989212"}], "stats": {"total": 3509, "additions": 107, "deletions": 3402}, "files": [{"sha": "69af813087178d1561e9ad8227a6199e234d903f", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=88a2722e1fd941a7d02575a6663641d0739939a5", "patch": "@@ -1,3 +1,28 @@\n+2010-09-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tRemoved obsolete intermediate threading layer.\n+\t* thr.c: Use __gthread_objc_xxx functions directly instead of\n+\t__objc_thread_xxx ones.\n+\t* objc/thr.h: Removed prototypes of no longer existing\n+\t__objc_thread_xxx functions.\n+\t* Makefile.in: Removed thr-objc.lo.\n+\t* thr-dce.c: File removed.\n+\t* thr-decosf1.c: File removed.\n+\t* thr-irix.c: File removed.\n+\t* thr-mach.c: File removed.\n+\t* thr-objc.c: File removed.\n+\t* thr-os2.c: File removed.\n+\t* thr-posix.c: File removed.\n+\t* thr-pthreads.c: File removed.\n+\t* thr-rtems.c: File removed.\n+\t* thr-single.c: File removed.\n+\t* thr-solaris.c: File removed.\n+\t* thr-vxworks.c: File removed.\n+\t* thr-win32.c: File removed.\n+\t* README.threads: File removed.\n+\t* THREADS.MACH: File removed.\n+\t* THREADS: Updated.\n+\n 2010-09-07  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* Object.m (MAX_CLASS_NAME_LEN): Unused define removed."}, {"sha": "891c6609c37c449a7a1f69ba964229ee3e976828", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=88a2722e1fd941a7d02575a6663641d0739939a5", "patch": "@@ -93,7 +93,6 @@ LIBTOOL_CLEAN   = $(LIBTOOL) --mode=clean\n #LIBTOOL_UNINSTALL = $(LIBTOOL) --mode=uninstall\n \n OBJC_GCFLAGS=-DOBJC_WITH_GC=1\n-OBJC_THREAD_FILE=thr-objc\n OBJC_BOEHM_GC=@OBJC_BOEHM_GC@\n OBJC_BOEHM_GC_INCLUDES=@OBJC_BOEHM_GC_INCLUDES@\n OBJC_BOEHM_GC_LIBS=../boehm-gc/libgcjgc_convenience.la $(thread_libs_and_flags)\n@@ -153,13 +152,13 @@ OBJC_H = hash.h objc-list.h sarray.h objc.h objc-api.h \\\n OBJS =    archive.lo class.lo encoding.lo gc.lo hash.lo init.lo linking.lo \\\n \t  misc.lo nil_method.lo NXConstStr.lo Object.lo objects.lo \\\n \t  Protocol.lo sarray.lo selector.lo sendmsg.lo thr.lo \\\n-\t  $(OBJC_THREAD_FILE).lo exception.lo\n+          exception.lo\n \n OBJS_GC = archive_gc.lo class_gc.lo encoding_gc.lo gc_gc.lo hash_gc.lo \\\n \t  init_gc.lo linking_gc.lo misc_gc.lo nil_method_gc.lo \\\n \t  NXConstStr_gc.lo Object_gc.lo objects_gc.lo Protocol_gc.lo \\\n \t  sarray_gc.lo selector_gc.lo sendmsg_gc.lo thr_gc.lo \\\n-\t  $(OBJC_THREAD_FILE)_gc.lo exception_gc.lo\n+\t  exception_gc.lo\n \n runtime-info.h: \n \techo \"\" > tmp-runtime.m\n@@ -257,10 +256,6 @@ thr_gc.lo: thr.c\n \t$(LIBTOOL_COMPILE) $(CC) -c -o $@ $(ALL_CFLAGS) $(OBJC_GCFLAGS) \\\n \t\t$(INCLUDES) $<\n \n-$(OBJC_THREAD_FILE)_gc.lo: $(OBJC_THREAD_FILE).c\n-\t$(LIBTOOL_COMPILE) $(CC) -c -o $@ $(ALL_CFLAGS) $(OBJC_GCFLAGS) \\\n-\t\t$(INCLUDES) $<\n-\n exception.lo: exception.c\n \t$(LIBTOOL_COMPILE) $(CC) -c -o $@ $(ALL_CFLAGS) \\\n \t\t-fexceptions $(INCLUDES) $<"}, {"sha": "5f15bd9cb45c99ae5395fe1dad99e9816545951c", "filename": "libobjc/README.threads", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2FREADME.threads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2FREADME.threads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FREADME.threads?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,50 +0,0 @@\n-==============================================================================\n-README.threads - Wed Nov 29 15:16:24 EST 1995\n-------------------------------------------------------------------------------\n-\n-Limited documentation is available in the THREADS file.\n-\n-This version has been tested on Sun Solaris, SGI Irix, and Windows NT.\n-It should also work on any single threaded system.\n-\n-Thanks go to the following people for help test and debug the library:\n-\n-\tScott Christley, scottc@ocbi.com\n-\tAndrew McCallum, mccallum@cs.rochester.edu\n-\n-galen\n-gchunt@cs.rochester.edu\n-\n-Any questions, bug reports, etc should be directed to:\n-\n-Scott Christley, scottc@ocbi.com\n-\n-Please do not bug Galen with email as he no longer supports the code.\n-\n-==============================================================================\n-Changes from prior releases (in revered chronological order):\n-------------------------------------------------------------------------------\n-\n-* Fixed bug in copy part of sarray_realloc.  I had an < which should\n-  have been <=. (Bug report from Scott).\n-\n-------------------------------------------------------------------------------\n-\n-* Support for DEC OSF/1 is definitely broken.  My programs always\n-  seg-fault when I link with libpthreads.a.\n-\n-* Thread id's are no longer int's, but are instead of type\n-  _objc_thread_t which is typedef'ed from a void *.  An invalid thread\n-  id is denoted by NULL and not -1 as before.\n-\n-------------------------------------------------------------------------------\n-\n-* Renamed thread-winnt.c to thread-win32.c to better reflect support\n-  for the API on both Windows NT and Windows 95 platforms.  \n-  (Who knows, maybe even Win32s :-).\n-\n-* Fixed bugs in Win32 support as per report from Scott Christley.\n-\n-* Fixed bug in sarray_get as per report from Scott Christley.\n-\n-\t"}, {"sha": "5004b2cbcfe82986d9223df1330aef71901bf599", "filename": "libobjc/THREADS", "status": "modified", "additions": 33, "deletions": 71, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2FTHREADS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2FTHREADS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FTHREADS?ref=88a2722e1fd941a7d02575a6663641d0739939a5", "patch": "@@ -96,59 +96,21 @@ frontend/backend implementation.\n \n The frontend, as characterized by the files thr.h and thr.c, is a set\n of platform independent structures and functions which represent the\n-user interface.  Objective-C programs should use these structures and\n-functions for their thread and mutex work if they wish to maintain a\n-high degree of portability across platforms.\n-\n-The backend is composed of a file with the necessary code to map the ObjC\n-thread and mutex to a platform specific implementation.  For example, the\n-file thr-solaris.c contains the implementation for Solaris.\n-\n-If you are compiling libobjc as part of GCC, the thr-objc.c backend is\n-always used; this backend uses GCC's gthread code.  The thread system\n-is automatically configured when GCC is configured.  Important: make\n-sure you configure GCC using `--enable-threads' if you want threads !\n-  \n-If you want to compile libobjc standalone, then you would need to\n-modify the configure.in and makefiles for it; and you need to pick an\n-appropriate backend file for the target platform; you make this choice\n-by assigning the OBJC_THREAD_FILE make variable to the basename of the\n-backend file.  For example, OBJC_THREAD_FILE=thr-posix would indicate\n-that the generic posix backend file, thr-posix.c, should be compiled\n-with the ObjC runtime library.  If your platform does not support\n-threads then you should specify the OBJC_THREAD_FILE=thr-single\n-backend file to compile the ObjC runtime library without thread or\n-mutex support; note that programs which rely upon the ObjC thread and\n-mutex functions will compile and link correctly but attempting to\n-create a thread or mutex will result in an error.\n-  \n-It is questionable whether it is really necessary to have both a\n-frontend and backend function for all available functionality.  On the\n-one hand, it provides a clear, consistent differentiation between what\n-is public and what is private with the downside of having the overhead\n-of multiple functions calls.  For example, the function to have a\n-thread yield the processor is objc_thread_yield; in the current\n-implementation this produces a function call set:\n-\n-objc_thread_yield()  ->  __objc_thread_yield()  ->  system yield function\n-\n-This has two extra function calls over calling the platform specific function\n-explicitly, but the issue is whether only the overhead of a single function\n-is necessary.\n-\n-objc_thread_yield()  ->  system yield function\n-\n-This breaks the public/private dichotomy between the frontend/backend\n-for the sake of efficiency.  It is possible to just use a preprocessor\n-define so as to eliminate the extra function call:\n-\n-#define objc_thread_yield() __objc_thread_yield()\n-\n-This has the undesirable effect that if objc_thread_yield is actually\n-turned into a function based upon future need; then ObjC programs which\n-access the thread functions would need to be recompiled versus just\n-being relinked.\n- \n+user interface.  For example, objc_mutex_lock().  Objective-C programs\n+should use these structures and functions for their thread and mutex\n+work if they wish to maintain a high degree of portability across\n+platforms.\n+\n+The backend is currently GCC's gthread code (gthr.h and related).  For\n+example, __gthread_objc_mutex_lock().  The thread system is\n+automatically configured when GCC is configured.  On most platforms\n+this thread backend is able to automatically switch to non-multi-threaded\n+mode if the threading library is not linked in.\n+\n+If you want to compile libobjc standalone, then you would need to modify\n+the configure.in and makefiles for it and you need to import the\n+gthread code from GCC.\n+\n ******************************************************************************\n * Threads:\n \n@@ -212,34 +174,34 @@ objc_thread_get_data(void), void *\n * Backend thread functions\n * User programs should *NOT* directly call these functions.\n \n-__objc_thread_detach(void (*func)(void *arg), void *arg), objc_thread_t\n+__gthr_objc_thread_detach(void (*func)(void *arg), void *arg), objc_thread_t\n \tSpawns a new thread executing func, called by objc_thread_detach.\n \tReturn NULL if error otherwise return thread id.\n \n-__objc_thread_set_priority(int priority), int\n+__gthr_objc_thread_set_priority(int priority), int\n \tSet the thread's priority, called by objc_thread_set_priority.\n \tReturn -1 if error otherwise return 0.\n \n-__objc_thread_get_priority(void), int\n+__gthr_objc_thread_get_priority(void), int\n \tQuery a thread's priority, called by objc_thread_get_priority.\n \tReturn -1 if error otherwise return the priority.\n \n-__objc_thread_yield(void), void\n+__gthr_objc_thread_yield(void), void\n \tYields the processor, called by objc_thread_yield.\n \n-__objc_thread_exit(void), int\n+__gthr_objc_thread_exit(void), int\n \tTerminates the thread, called by objc_thread_exit.\n \tReturn -1 if error otherwise function does not return.\n \n-__objc_thread_id(void), objc_thread_t\n+__gthr_objc_thread_id(void), objc_thread_t\n \tReturns the current thread's id, called by objc_thread_id.\n \tReturn -1 if error otherwise return thread id.\n \n-__objc_thread_set_data(void *value), int\n+__gthr_objc_thread_set_data(void *value), int\n \tSet pointer for thread local storage, called by objc_thread_set_data.\n \tReturns -1 if error otherwise return 0.\n \n-__objc_thread_get_data(void), void *\n+__gthr_objc_thread_get_data(void), void *\n \tReturns the pointer to the thread's local storage.\n \tReturns NULL if error, called by objc_thread_get_data.\n \n@@ -284,23 +246,23 @@ objc_mutex_unlock(objc_mutex_t mutex), int\n * Backend mutex functions\n * User programs should *NOT* directly call these functions.\n \n-__objc_mutex_allocate(objc_mutex_t mutex), int\n+__gthr_objc_mutex_allocate(objc_mutex_t mutex), int\n \tAllocates a new mutex, called by objc_mutex_allocate.\n \tReturn -1 if error otherwise return 0.\n \n-__objc_mutex_deallocate(objc_mutex_t mutex), int\n+__gthr_objc_mutex_deallocate(objc_mutex_t mutex), int\n \tFree a mutex, called by objc_mutex_deallocate.\n \tReturn -1 if error otherwise return 0.\n \n-__objc_mutex_lock(objc_mutex_t mutex), int\n+__gthr_objc_mutex_lock(objc_mutex_t mutex), int\n \tLocks a mutex, called by objc_mutex_lock.\n \tReturn -1 if error otherwise return 0.\n \t\n-__objc_mutex_trylock(objc_mutex_t mutex), int\n+__gthr_objc_mutex_trylock(objc_mutex_t mutex), int\n \tAttempts to lock a mutex, called by objc_mutex_trylock.\n \tReturn -1 if failed to acquire lock or error otherwise return 0.\n \n-__objc_mutex_unlock(objc_mutex_t mutex), int\n+__gthr_objc_mutex_unlock(objc_mutex_t mutex), int\n \tUnlocks the mutex, called by objc_mutex_unlock.\n \tReturn -1 if error otherwise return 0.\n \n@@ -354,24 +316,24 @@ objc_condition_signal(objc_condition_t condition), int\n * User programs should *NOT* directly call these functions.\n *\n \n-__objc_condition_allocate(objc_condition_t condition), int\n+__gthr_objc_condition_allocate(objc_condition_t condition), int\n \tAllocate a condition mutex, called by objc_condition_allocate.\n \tReturn -1 if error otherwise return 0.\n \n-__objc_condition_deallocate(objc_condition_t condition), int\n+__gthr_objc_condition_deallocate(objc_condition_t condition), int\n \tDeallocate a condition, called by objc_condition_deallocate.\n \tReturn -1 if error otherwise return 0.\n \n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex), int\n+__gthr_objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex), int\n \tWait on the condition, called by objc_condition_wait.\n \tReturn -1 if error otherwise return 0 when condition is met.\n \t\n-__objc_condition_broadcast(objc_condition_t condition), int\n+__gthr_objc_condition_broadcast(objc_condition_t condition), int\n \tWake up all threads waiting on this condition.\n \tCalled by objc_condition_broadcast.\n \tReturn -1 if error otherwise return 0.\n \n-__objc_condition_signal(objc_condition_t condition), int\n+__gthr_objc_condition_signal(objc_condition_t condition), int\n \tWake up one thread waiting on this condition.\n \tCalled by objc_condition_signal.\n \tReturn -1 if error otherwise return 0."}, {"sha": "55de663786698a06b1e2ebbcde06fe62a3d3518b", "filename": "libobjc/THREADS.MACH", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2FTHREADS.MACH", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2FTHREADS.MACH", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FTHREADS.MACH?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,23 +0,0 @@\n-This readme refers to the file thr-mach.c.\n-\n-Under mach, thread priorities are kinda strange-- any given thread has\n-a MAXIMUM priority and a BASE priority.  The BASE priority is the\n-current priority of the thread and the MAXIMUM is the maximum possible\n-priority the thread can assume.  The developer can lower, but never\n-raise the maximum priority.\n-\n-The gcc concept of thread priorities is that they run at one of three\n-levels;  interactive, background, and low.\n-\n-Under mach, this is translated to:\n-\n-interactive -- set priority to maximum\n-background  -- set priority to 2/3 of maximum\n-low         -- set priority to 1/3 of maximum\n-\n-This means that it is possible for a thread with the priority of\n-interactive to actually run at a lower priority than another thread\n-with a background, or even low, priority if the developer has modified\n-the maximum priority.\n-\n-"}, {"sha": "488ca945fa902a0aa1d5658955b3f2bab1853278", "filename": "libobjc/objc/thr.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2Fobjc%2Fthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2Fobjc%2Fthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fthr.h?ref=88a2722e1fd941a7d02575a6663641d0739939a5", "patch": "@@ -108,31 +108,6 @@ objc_thread_callback objc_set_thread_callback (objc_thread_callback func);\n \n /* Backend initialization functions */\n int __objc_init_thread_system (void);\n-int __objc_fini_thread_system (void);\n-\n-/* Backend mutex functions */\n-int __objc_mutex_allocate (objc_mutex_t mutex);\n-int __objc_mutex_deallocate (objc_mutex_t mutex);\n-int __objc_mutex_lock (objc_mutex_t mutex);\n-int __objc_mutex_trylock (objc_mutex_t mutex);\n-int __objc_mutex_unlock (objc_mutex_t mutex);\n-\n-/* Backend condition mutex functions */\n-int __objc_condition_allocate (objc_condition_t condition);\n-int __objc_condition_deallocate (objc_condition_t condition);\n-int __objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex);\n-int __objc_condition_broadcast (objc_condition_t condition);\n-int __objc_condition_signal (objc_condition_t condition);\n-\n-/* Backend thread functions */\n-objc_thread_t __objc_thread_detach (void (*func) (void *arg), void *arg);\n-int __objc_thread_set_priority (int priority);\n-int __objc_thread_get_priority (void);\n-void __objc_thread_yield (void);\n-int __objc_thread_exit (void);\n-objc_thread_t __objc_thread_id (void);\n-int __objc_thread_set_data (void *value);\n-void * __objc_thread_get_data (void);\n \n #ifdef __cplusplus\n }"}, {"sha": "ad31c8b1f0901fd8df5f82c212aa23f9fa07963a", "filename": "libobjc/thr-dce.c", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-dce.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,280 +0,0 @@\n-/* GNU Objective C Runtime Thread Interface\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include <pthread.h>\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-/* Key structure for maintaining thread specific storage */\n-static pthread_key_t _objc_thread_storage;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* Initialize the thread storage key */\n-  return pthread_keycreate(&_objc_thread_storage, NULL);\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  /* Destroy the thread storage key */\n-  /* Not implemented yet */\n-  /* return pthread_key_delete(&_objc_thread_storage); */\n-  return 0;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  objc_thread_t thread_id;\n-  pthread_t new_thread_handle;\n-\n-  if (pthread_create(&new_thread_handle, pthread_attr_default,\n-\t\t     (void *)func, arg) == 0)\n-    {\n-      /* ??? May not work! (64bit) */\n-      thread_id = *(objc_thread_t *)&new_thread_handle; \n-      pthread_detach(&new_thread_handle);     /* Fully detach thread.     */\n-    }\n-  else\n-    thread_id = NULL;\n-  \n-  return thread_id;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  int sys_priority = 0;\n-\n-  switch (priority)\n-    {\n-    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-      sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n-      break;\n-    default:\n-    case OBJC_THREAD_BACKGROUND_PRIORITY:\n-      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n-      break;\n-    case OBJC_THREAD_LOW_PRIORITY:\n-      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n-      break;\n-    }\n-    \n-  /* Change the priority. */\n-  if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n-    return 0;\n-  else\n-    /* Failed */\n-    return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  int sys_priority;\n-    \n-  if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n-    if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n-      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-    if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n-      return OBJC_THREAD_BACKGROUND_PRIORITY;\n-    return OBJC_THREAD_LOW_PRIORITY;\n-  }\n-\n-  /* Failed */\n-  return -1;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  pthread_yield();\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* exit the thread */\n-  pthread_exit(&__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  pthread_t self = pthread_self();\n-\n-  return (objc_thread_t) pthread_getunique_np (&self);\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  return pthread_setspecific(_objc_thread_storage, value);\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  void *value = NULL;\n-\n-  if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n-    return value;\n-\n-  return NULL;\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), \n-\t\t\t pthread_mutexattr_default))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend))) != 1)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n-    return -1;\n-  else\n-    return 0;\n-    */\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n-  */\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n-\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n-\t\t\t   */\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n-  */\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n-  */\n-}\n-\n-/* End of File */"}, {"sha": "ad31c8b1f0901fd8df5f82c212aa23f9fa07963a", "filename": "libobjc/thr-decosf1.c", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-decosf1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-decosf1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-decosf1.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,280 +0,0 @@\n-/* GNU Objective C Runtime Thread Interface\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include <pthread.h>\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-/* Key structure for maintaining thread specific storage */\n-static pthread_key_t _objc_thread_storage;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* Initialize the thread storage key */\n-  return pthread_keycreate(&_objc_thread_storage, NULL);\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  /* Destroy the thread storage key */\n-  /* Not implemented yet */\n-  /* return pthread_key_delete(&_objc_thread_storage); */\n-  return 0;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  objc_thread_t thread_id;\n-  pthread_t new_thread_handle;\n-\n-  if (pthread_create(&new_thread_handle, pthread_attr_default,\n-\t\t     (void *)func, arg) == 0)\n-    {\n-      /* ??? May not work! (64bit) */\n-      thread_id = *(objc_thread_t *)&new_thread_handle; \n-      pthread_detach(&new_thread_handle);     /* Fully detach thread.     */\n-    }\n-  else\n-    thread_id = NULL;\n-  \n-  return thread_id;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  int sys_priority = 0;\n-\n-  switch (priority)\n-    {\n-    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-      sys_priority = (PRI_FG_MIN_NP + PRI_FG_MAX_NP) / 2;\n-      break;\n-    default:\n-    case OBJC_THREAD_BACKGROUND_PRIORITY:\n-      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n-      break;\n-    case OBJC_THREAD_LOW_PRIORITY:\n-      sys_priority = (PRI_BG_MIN_NP + PRI_BG_MAX_NP) / 2;\n-      break;\n-    }\n-    \n-  /* Change the priority. */\n-  if (pthread_setprio(pthread_self(), sys_priority) >= 0)\n-    return 0;\n-  else\n-    /* Failed */\n-    return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  int sys_priority;\n-    \n-  if ((sys_priority = pthread_getprio(pthread_self())) >= 0) {\n-    if (sys_priority >= PRI_FG_MIN_NP && sys_priority <= PRI_FG_MAX_NP)\n-      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-    if (sys_priority >= PRI_BG_MIN_NP && sys_priority <= PRI_BG_MAX_NP)\n-      return OBJC_THREAD_BACKGROUND_PRIORITY;\n-    return OBJC_THREAD_LOW_PRIORITY;\n-  }\n-\n-  /* Failed */\n-  return -1;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  pthread_yield();\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* exit the thread */\n-  pthread_exit(&__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  pthread_t self = pthread_self();\n-\n-  return (objc_thread_t) pthread_getunique_np (&self);\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  return pthread_setspecific(_objc_thread_storage, value);\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  void *value = NULL;\n-\n-  if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n-    return value;\n-\n-  return NULL;\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), \n-\t\t\t pthread_mutexattr_default))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend))) != 1)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n-    return -1;\n-  else\n-    return 0;\n-    */\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n-  */\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n-\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n-\t\t\t   */\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n-  */\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-\n-  /*\n-  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n-  */\n-}\n-\n-/* End of File */"}, {"sha": "84a5fc1da987248aa3f4a53e077e0fbe6a0895fb", "filename": "libobjc/thr-irix.c", "status": "removed", "additions": 0, "deletions": 234, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-irix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-irix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-irix.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,234 +0,0 @@\n-/* GNU Objective C Runtime Thread Interface - SGI IRIX Implementation\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include <stdlib.h>\n-#include <sys/types.h>\n-#include <sys/sysmp.h>\n-#include <sys/prctl.h>\n-#include <ulocks.h>\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-/* Key structure for maintaining thread specific storage */\n-static void * __objc_shared_arena_handle = NULL;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* Name of IRIX arena. */\n-  char arena_name[64];\n-\n-  DEBUG_PRINTF(\"__objc_init_thread_system\\n\");\n-\n-  /* Construct a temporary name for arena. */\n-  sprintf(arena_name, \"/usr/tmp/objc_%05u\", (unsigned)getpid());\n-\n-  /* Up to 256 threads.  Arena only for threads. */\n-  usconfig(CONF_INITUSERS, 256);\n-  usconfig(CONF_ARENATYPE, US_SHAREDONLY);\n-\n-  /* Initialize the arena */\n-  if (!(__objc_shared_arena_handle = usinit(arena_name)))\n-    /* Failed */\n-    return -1;\n-\n-  return 0;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  return 0;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  objc_thread_t thread_id;\n-  int sys_id;\n-\n-  if ((sys_id = sproc((void *)func, PR_SALL, arg)) >= 0)\n-    thread_id = (objc_thread_t)sys_id;\n-  else\n-    thread_id = NULL;\n-  \n-  return thread_id;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  /* Not implemented yet */\n-  return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  /* Not implemented yet */\n-  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  sginap(0);\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* IRIX only has exit. */\n-  exit(__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  /* Threads are processes. */\n-  return (objc_thread_t)get_pid();\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  *((void **)&PRDA->usr_prda) = value;\n-  return 0;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  return *((void **)&PRDA->usr_prda);\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  if (!( (ulock_t)(mutex->backend) = usnewlock(__objc_shared_arena_handle) ))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  usfreelock((ulock_t)(mutex->backend), __objc_shared_arena_handle);\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  if (ussetlock((ulock_t)(mutex->backend)) == 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  if (ustestlock((ulock_t)(mutex->backend)) == 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  usunsetlock((ulock_t)(mutex->backend));\n-  return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* End of File */"}, {"sha": "19b95db682a79f6e2fcb525d9ea88aae1f9cd9bd", "filename": "libobjc/thr-mach.c", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-mach.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,312 +0,0 @@\n-/* GNU Objective C Runtime Thread Implementation\n-   Copyright (C) 1996, 1997, 2002, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-   Modified for Mach threads by Bill Bumgarner <bbum@friday.com>\n-   Condition functions added by Mircea Oancea <mircea@first.elcom.pub.ro>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include <mach/mach.h>\n-#include <mach/cthreads.h>\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-/*\n-  Obtain the maximum thread priority that can set for t.  Under the\n-  mach threading model, it is possible for the developer to adjust the\n-  maximum priority downward only-- cannot be raised without superuser\n-  privileges.  Once lowered, it cannot be raised.\n-  */\n-static int\n-__mach_get_max_thread_priority (cthread_t t, int *base)\n-{\n-  thread_t threadP;\n-  kern_return_t error;\n-  struct thread_sched_info info;\n-  unsigned int info_count=THREAD_SCHED_INFO_COUNT;\n-    \n-  if (t == NULL)\n-    return -1;\n-\n-  threadP  = cthread_thread (t); \t/* get thread underlying */\n-\n-  error = thread_info (threadP, THREAD_SCHED_INFO, \n-\t\t       (thread_info_t) &info, &info_count);\n-\n-  if (error != KERN_SUCCESS)\n-    return -1;\n-\n-  if (base != NULL)\n-    *base = info.base_priority;\n-\n-  return info.max_priority;\n-}\n-\t\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system (void)\n-{\n-  return 0;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system (void)\n-{\n-  return 0;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach (void (*func) (void *arg), void *arg)\n-{\n-  objc_thread_t thread_id;\n-  cthread_t new_thread_handle;\n-\n-  /* create thread */\n-  new_thread_handle = cthread_fork ((cthread_fn_t) func, arg);\n-\n-  if (new_thread_handle)\n-    {\n-      /* this is not terribly portable */\n-      thread_id = *(objc_thread_t *) &new_thread_handle; \n-      cthread_detach (new_thread_handle);\n-    }\n-  else\n-    thread_id = NULL;\n-  \n-  return thread_id;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority (int priority)\n-{\n-  objc_thread_t *t = objc_thread_id ();\n-  cthread_t cT = (cthread_t) t; \n-  int maxPriority = __mach_get_max_thread_priority (cT, NULL);\n-  int sys_priority = 0;\n-\n-  if (maxPriority == -1)\n-    return -1;\n-\n-  switch (priority)\n-    {\n-    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-      sys_priority = maxPriority;\n-      break;\n-    case OBJC_THREAD_BACKGROUND_PRIORITY:\n-      sys_priority = (maxPriority * 2) / 3;\n-      break;\n-    case OBJC_THREAD_LOW_PRIORITY:\n-      sys_priority = maxPriority / 3;\n-      break;\n-    default:\n-      return -1;\n-    }\n-\n-  if (sys_priority == 0)\n-    return -1;\n-\n-  /* Change the priority */\n-  if (cthread_priority (cT, sys_priority, 0) == KERN_SUCCESS)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority (void)\n-{\n-  objc_thread_t *t = objc_thread_id ();\n-  cthread_t cT = (cthread_t) t; /* see objc_thread_id () */\n-  int basePriority;\n-  int maxPriority;\n-  int sys_priority = 0;\n-\n-  int interactiveT, backgroundT, lowT; /* thresholds */\n-\n-  maxPriority = __mach_get_max_thread_priority (cT, &basePriority);\n-\n-  if (maxPriority == -1)\n-    return -1;\n-\n-  if (basePriority > ( (maxPriority * 2) / 3))\n-    return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-\n-  if (basePriority > ( maxPriority / 3))\n-    return OBJC_THREAD_BACKGROUND_PRIORITY;\n-\n-  return OBJC_THREAD_LOW_PRIORITY;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield (void)\n-{\n-  cthread_yield ();\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit (void)\n-{\n-  /* exit the thread */\n-  cthread_exit (&__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id (void)\n-{\n-  cthread_t self = cthread_self ();\n-\n-  return *(objc_thread_t *) &self;\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data (void *value)\n-{\n-  cthread_set_data (cthread_self (), (any_t) value);\n-  return 0;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data (void)\n-{\n-  return (void *) cthread_data (cthread_self ());\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate (objc_mutex_t mutex)\n-{\n-  int err = 0;\n-  mutex->backend = objc_malloc (sizeof (struct mutex));\n-\n-  err = mutex_init ((mutex_t) (mutex->backend));\n-\n-  if (err != 0)\n-    {\n-      objc_free (mutex->backend);\n-      return -1;\n-    }\n-  else\n-    return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate (objc_mutex_t mutex)\n-{\n-  mutex_clear ((mutex_t) (mutex->backend));\n-\n-  objc_free (mutex->backend);\n-  mutex->backend = NULL;\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock (objc_mutex_t mutex)\n-{\n-  mutex_lock ((mutex_t) (mutex->backend));\n-  return 0;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock (objc_mutex_t mutex)\n-{\n-  if (mutex_try_lock ((mutex_t) (mutex->backend)) == 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock (objc_mutex_t mutex)\n-{\n-  mutex_unlock ((mutex_t) (mutex->backend));\n-  return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate (objc_condition_t condition)\n-{\n-  condition->backend = objc_malloc (sizeof (struct condition));\n-  condition_init ((condition_t) (condition->backend));\n-  return 0;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate (objc_condition_t condition)\n-{\n-  condition_clear ((condition_t) (condition->backend));\n-  objc_free (condition->backend);\n-  condition->backend = NULL;\n-  return 0;\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  condition_wait ((condition_t) (condition->backend),\n-\t\t  (mutex_t) (mutex->backend));\n-  return 0;\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast (objc_condition_t condition)\n-{\n-  condition_broadcast ((condition_t) (condition->backend));\n-  return 0;\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal (objc_condition_t condition)\n-{\n-  condition_signal ((condition_t) (condition->backend));\n-  return 0;\n-}\n-\n-/* End of File */"}, {"sha": "5cc6433c621296450dc10c30747b3b2ede4bda59", "filename": "libobjc/thr-objc.c", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-objc.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,191 +0,0 @@\n-/* GNU Objective C Runtime Thread Interface.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2009\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#define _LIBOBJC\n-/* The line below is needed for declarations of functions such as\n-   pthread_mutexattr_settype, without which gthr-posix.h may fail to\n-   compile within libobjc.  Unfortunately, this breaks compilation on\n-   Tru64 UNIX V4.0F, so disable it there.  */\n-#ifndef __osf__\n-#define _XOPEN_SOURCE 500\n-#endif\n-#include \"config.h\"\n-#include \"tconfig.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"defaults.h\"\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-#include <gthr.h>\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  return __gthread_objc_init_thread_system ();\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  return __gthread_objc_close_thread_system ();\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *), void *arg)\n-{\n-  return __gthread_objc_thread_detach (func, arg);\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  return __gthread_objc_thread_set_priority (priority);\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  return __gthread_objc_thread_get_priority ();\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  __gthread_objc_thread_yield ();\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  return __gthread_objc_thread_exit ();\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  return __gthread_objc_thread_id ();\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  return __gthread_objc_thread_set_data (value);\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  return __gthread_objc_thread_get_data ();\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  return __gthread_objc_mutex_allocate (mutex);\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  return __gthread_objc_mutex_deallocate (mutex);\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  return __gthread_objc_mutex_lock (mutex);\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  return __gthread_objc_mutex_trylock (mutex);\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  return __gthread_objc_mutex_unlock (mutex);\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  return __gthread_objc_condition_allocate (condition);\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  return __gthread_objc_condition_deallocate (condition);\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  return __gthread_objc_condition_wait (condition, mutex);\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  return __gthread_objc_condition_broadcast (condition);\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  return __gthread_objc_condition_signal (condition);\n-}\n-\n-/* End of File */"}, {"sha": "1f9e3ae5ceab9b8a924ef3e7e47bfc0b6bb784f7", "filename": "libobjc/thr-os2.c", "status": "removed", "additions": 0, "deletions": 266, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-os2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-os2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-os2.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,266 +0,0 @@\n-/* GNU Objective C Runtime Thread Interface - OS/2 emx Implementation\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Thomas Baier (baier@ci.tuwien.ac.at)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-#define INCL_DOSSEMAPHORES\n-#define INCL_DOSPROCESS\n-\n-/*\n- * conflicts with objc.h:       SEL, BOOL, id\n- * solution:  prefixing those with _OS2_ before including <os2.h>\n- */\n-#define SEL _OS2_SEL\n-#define BOOL _OS2_BOOL\n-#define id _OS2_id\n-#include <os2.h>\n-#undef id\n-#undef SEL\n-#undef BOOL\n-\n-#include <stdlib.h>\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  return 0;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  return 0;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  int thread_id = 0;\n-\n-  if ((thread_id = _beginthread (func,NULL,32768,arg)) < 0)\n-    thread_id = 0;\n-  \n-  return (objc_thread_t)thread_id;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  ULONG sys_class = 0;\n-  ULONG sys_priority = 0;\n-\n-  /* OBJC_THREAD_INTERACTIVE_PRIORITY -> PRTYC_FOREGROUNDSERVER\n-   * OBJC_THREAD_BACKGROUND_PRIORITY  -> PRTYC_REGULAR\n-   * OBJC_THREAD_LOW_PRIORITY         -> PRTYC_IDLETIME */\n-  \n-  switch (priority) {\n-  case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-    sys_class = PRTYC_REGULAR;\n-    sys_priority = 10;\n-    break;\n-  default:\n-  case OBJC_THREAD_BACKGROUND_PRIORITY:\n-    sys_class = PRTYC_IDLETIME;\n-    sys_priority = 25;\n-    break;\n-  case OBJC_THREAD_LOW_PRIORITY:\n-    sys_class = PRTYC_IDLETIME;\n-    sys_priority = 0;\n-    break;\n-  }\n-\n-  /* Change priority */\n-  if (!DosSetPriority (PRTYS_THREAD,sys_class,sys_priority,*_threadid))\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  PTIB ptib;\n-  PPIB ppib;\n-\n-  /* get information about current thread */\n-  DosGetInfoBlocks (&ptib,&ppib);\n-\n-  switch (ptib->tib_ptib2->tib2_ulpri)\n-    {\n-    case PRTYC_IDLETIME:\n-    case PRTYC_REGULAR:\n-    case PRTYC_TIMECRITICAL:\n-    case PRTYC_FOREGROUNDSERVER:\n-    default:\n-      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-    }\n-\n-  return -1;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  DosSleep (0);\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* terminate the thread, NEVER use DosExit () */\n-  _endthread ();\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  return (objc_thread_t) *_threadid;\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  *_threadstore () = value;\n-\n-  return 0;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  return *_threadstore ();\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  if (DosCreateMutexSem (NULL, (HMTX)(&(mutex->backend)),0L,0) > 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  DosCloseMutexSem ((HMTX)(mutex->backend));\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  if (DosRequestMutexSem ((HMTX)(mutex->backend),-1L) != 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  if (DosRequestMutexSem ((HMTX)(mutex->backend),0L) != 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  if (DosReleaseMutexSem((HMTX)(mutex->backend)) != 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* End of File */"}, {"sha": "6e6061457ec1a7c6534ef613a564f1daeb57e821", "filename": "libobjc/thr-posix.c", "status": "removed", "additions": 0, "deletions": 317, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-posix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-posix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-posix.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,317 +0,0 @@\n-/* GNU Objective C Runtime Thread Interface for POSIX compliant threads\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-   Modified for Linux/Pthreads by Kai-Uwe Sattler (kus@iti.cs.uni-magdeburg.de)\n-   Modified for posix compliance by Chris Ball (cball@fmco.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-#include <pthread.h>\n-\n-/* Key structure for maintaining thread specific storage */\n-static pthread_key_t _objc_thread_storage;\n-static pthread_attr_t _objc_thread_attribs;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* Initialize the thread storage key */\n-  if (pthread_key_create(&_objc_thread_storage, NULL) == 0)\n-    {\n-      /*\n-       * The normal default detach state for threads is PTHREAD_CREATE_JOINABLE\n-       * which causes threads to not die when you think they should.\n-\t   */\n-      if (pthread_attr_init(&_objc_thread_attribs) == 0)\n-        {\n-          if (pthread_attr_setdetachstate(&_objc_thread_attribs, \n-                                          PTHREAD_CREATE_DETACHED) == 0)\n-            return 0;\n-        }\n-    }\n-\n-  return -1;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  if (pthread_key_delete(_objc_thread_storage) == 0)\n-    {\n-      if (pthread_attr_destroy(&_objc_thread_attribs) == 0)\n-        return 0;\n-    }\n-\n-  return -1;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  objc_thread_t thread_id;\n-  pthread_t new_thread_handle;\n-  \n-  if (!(pthread_create(&new_thread_handle, &_objc_thread_attribs, \n-                       (void *)func, arg)))\n-    thread_id = *(objc_thread_t *)&new_thread_handle;\n-  else\n-    thread_id = NULL;\n-  \n-  return thread_id;\n-}\n-\n-/* Set the current thread's priority.\n- *\n- * Be aware that the default schedpolicy often disallows thread priorities.\n- */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  pthread_t thread_id = pthread_self();\n-  int policy;\n-  struct sched_param params;\n-  int priority_min, priority_max;\n-\n-  if (pthread_getschedparam(thread_id, &policy, &params) == 0)\n-    {\n-      if ((priority_max = sched_get_priority_max(policy)) != 0)\n-        return -1;\n-\n-      if ((priority_min = sched_get_priority_min(policy)) != 0)\n-        return -1;\n-\n-      if (priority > priority_max)\n-        priority = priority_max;\n-      else if (priority < priority_min)\n-        priority = priority_min;\n-      params.sched_priority = priority;\n-\n-      /*\n-       * The solaris 7 and several other man pages incorrectly state that\n-       * this should be a pointer to policy but pthread.h is universally\n-       * at odds with this.\n-       */\n-      if (pthread_setschedparam(thread_id, policy, &params) == 0)\n-        return 0;\n-    }\n-  return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  int policy;\n-  struct sched_param params;\n-\n-  if (pthread_getschedparam(pthread_self(), &policy, &params) == 0)\n-    return params.sched_priority;\n-  else\n-    return -1;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  sched_yield();\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* exit the thread */\n-  pthread_exit(&__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  pthread_t self = pthread_self();\n-\n-  return *(objc_thread_t *)&self;\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  if (pthread_setspecific(_objc_thread_storage, value) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  return pthread_getspecific(_objc_thread_storage);\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  mutex->backend = objc_malloc(sizeof(pthread_mutex_t));\n-\n-  if (pthread_mutex_init((pthread_mutex_t *)mutex->backend, NULL))\n-    {\n-      objc_free(mutex->backend);\n-      mutex->backend = NULL;\n-      return -1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  int count = 1;\n-\n-  /*\n-   * Posix Threads specifically require that the thread be unlocked for\n-   * pthread_mutex_destroy to work.\n-   */\n-\n-  while (count)\n-    {\n-      if ((count = pthread_mutex_unlock((pthread_mutex_t*)mutex->backend)) < 0)\n-        return -1;\n-    }\n-\n-  if (pthread_mutex_destroy((pthread_mutex_t *)mutex->backend))\n-    return -1;\n-\n-  objc_free(mutex->backend);\n-  mutex->backend = NULL;\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_lock((pthread_mutex_t *)mutex->backend) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_trylock((pthread_mutex_t *)mutex->backend) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_unlock((pthread_mutex_t *)mutex->backend) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  condition->backend = objc_malloc(sizeof(pthread_cond_t));\n-\n-  if (pthread_cond_init((pthread_cond_t *)condition->backend, NULL))\n-    {\n-      objc_free(condition->backend);\n-      condition->backend = NULL;\n-      return -1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  if (pthread_cond_destroy((pthread_cond_t *)condition->backend))\n-    return -1;\n-\n-  objc_free(condition->backend);\n-  condition->backend = NULL;\n-  return 0;\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  if (pthread_cond_wait((pthread_cond_t *)condition->backend,\n-                        (pthread_mutex_t *)mutex->backend) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  if (pthread_cond_broadcast((pthread_cond_t *)condition->backend) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  if (pthread_cond_signal((pthread_cond_t *)condition->backend) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}"}, {"sha": "d0a46f864cff8da6b9d9b4c535a3b728db959366", "filename": "libobjc/thr-pthreads.c", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-pthreads.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,217 +0,0 @@\n-/* GNU Objective C Runtime Thread Implementation for PCThreads under GNU/Linux.\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Scott Christley <scottc@net-community.com>\n-   Condition functions added by: Mircea Oancea <mircea@first.elcom.pub.ro>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include <pcthread.h>\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-/* Key structure for maintaining thread specific storage */\n-static pthread_key_t _objc_thread_storage;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* Initialize the thread storage key */\n-  return pthread_key_create(&_objc_thread_storage, NULL);\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  /* Destroy the thread storage key */\n-  /* Not implemented yet */\n-  /* return pthread_key_delete(&_objc_thread_storage); */\n-  return 0;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  objc_thread_t thread_id;\n-  pthread_t new_thread_handle;\n-\n-  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n-      thread_id = *(objc_thread_t *)&new_thread_handle;\n-  else\n-    thread_id = NULL;\n-  \n-  return thread_id;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  /* Not implemented yet */\n-  return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  /* Not implemented yet */\n-  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  pthread_yield(NULL);\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* exit the thread */\n-  pthread_exit(&__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  pthread_t self = pthread_self();\n-\n-  return *(objc_thread_t *)&self;\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  return pthread_setspecific(_objc_thread_storage, value);\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  void *value = NULL;\n-\n-  if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n-    return value;\n-\n-  return NULL;\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_init((pthread_mutex_t *)(&(mutex->backend)), NULL))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  if (pthread_mutex_destroy((pthread_mutex_t *)(&(mutex->backend))))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  return pthread_mutex_lock((pthread_mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  return pthread_mutex_trylock((pthread_mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  return pthread_mutex_unlock((pthread_mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  if (pthread_cond_init((pthread_cond_t *)(&(condition->backend)), NULL))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  return pthread_cond_destroy((pthread_cond_t *)(&(condition->backend)));\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  return pthread_cond_wait((pthread_cond_t *)(&(condition->backend)),\n-\t\t\t   (pthread_mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  return pthread_cond_broadcast((pthread_cond_t *)(&(condition->backend)));\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  return pthread_cond_signal((pthread_cond_t *)(&(condition->backend)));\n-}\n-\n-/* End of File */"}, {"sha": "cb2e68d96481c76fe868c84e61215082c2d47324", "filename": "libobjc/thr-rtems.c", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-rtems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-rtems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-rtems.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,193 +0,0 @@\n-/* GNU Objective C Runtime Thread Implementation\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-   Renamed from thr-vxworks.c to thr-rtems.c by \n-     Ralf Corsepius (corsepiu@faw.uni-ulm.de)\n-     \n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-/* Thread local storage for a single thread */\n-static void *thread_local_storage = NULL;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  /* No thread support available */\n-  return NULL;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  return;\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* No thread support available */\n-  /* Should we really exit the program */\n-  /* exit(&__objc_thread_exit_status); */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  /* No thread support, use 1. */\n-  return (objc_thread_t)1;\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  thread_local_storage = value;\n-  return 0;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  return thread_local_storage;\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  /* There can only be one thread, so we always get the lock */\n-  return 0;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  /* There can only be one thread, so we always get the lock */\n-  return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* End of File */"}, {"sha": "0074c6916f480cd560020782d75d223aff79566f", "filename": "libobjc/thr-single.c", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-single.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-single.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-single.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,191 +0,0 @@\n-/* GNU Objective C Runtime Thread Implementation\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-/* Thread local storage for a single thread */\n-static void *thread_local_storage = NULL;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  /* No thread support available */\n-  return NULL;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  return;\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* No thread support available */\n-  /* Should we really exit the program */\n-  /* exit(&__objc_thread_exit_status); */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  /* No thread support, use 1. */\n-  return (objc_thread_t)1;\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  thread_local_storage = value;\n-  return 0;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  return thread_local_storage;\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  /* There can only be one thread, so we always get the lock */\n-  return 0;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  /* There can only be one thread, so we always get the lock */\n-  return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* End of File */"}, {"sha": "a08dabe7e343bfbc83ed332dae4d0d1012893bf4", "filename": "libobjc/thr-solaris.c", "status": "removed", "additions": 0, "deletions": 258, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-solaris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-solaris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-solaris.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,258 +0,0 @@\n-/* GNU Objective C Runtime Thread Interface\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-   Conditions added by Mircea Oancea (mircea@first.elcom.pub.ro)\n-      \n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-#include <thread.h>\n-#include <synch.h>\n-#include <errno.h>\n-\n-/* Key structure for maintaining thread specific storage */\n-static thread_key_t     __objc_thread_data_key;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* Initialize the thread storage key */\n-  if (thr_keycreate(&__objc_thread_data_key, NULL) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  return 0;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  objc_thread_t thread_id;\n-  thread_t new_thread_id = 0;\n-\n-  if (thr_create(NULL, 0, (void *)func, arg,\n-                 THR_DETACHED | THR_NEW_LWP,\n-                 &new_thread_id) == 0)\n-    thread_id = *(objc_thread_t *)&new_thread_id;\n-  else\n-    thread_id = NULL;\n-  \n-  return thread_id;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  int sys_priority = 0;\n-\n-  switch (priority)\n-    {\n-    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-      sys_priority = 300;\n-      break;\n-    default:\n-    case OBJC_THREAD_BACKGROUND_PRIORITY:\n-      sys_priority = 200;\n-      break;\n-    case OBJC_THREAD_LOW_PRIORITY:\n-      sys_priority = 1000;\n-      break;\n-    }\n-\n-  /* Change priority */\n-  if (thr_setprio(thr_self(), sys_priority) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  int sys_priority;\n-                                                   \n-  if (thr_getprio(thr_self(), &sys_priority) == 0)\n-    {\n-      if (sys_priority >= 250)\n-\treturn OBJC_THREAD_INTERACTIVE_PRIORITY;\n-      else if (sys_priority >= 150)\n-\treturn OBJC_THREAD_BACKGROUND_PRIORITY;\n-      return OBJC_THREAD_LOW_PRIORITY;\n-    }\n-\n-  /* Couldn't get priority. */\n-  return -1;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  thr_yield();\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* exit the thread */\n-  thr_exit(&__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  return (objc_thread_t)thr_self();\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  if (thr_setspecific(__objc_thread_data_key, value) == 0)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  void *value = NULL;\n-\n-  if (thr_getspecific(__objc_thread_data_key, &value) == 0)\n-    return value;\n-\n-  return NULL;\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  if (mutex_init( (mutex_t *)(&(mutex->backend)), USYNC_THREAD, 0))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  mutex_destroy((mutex_t *)(&(mutex->backend)));\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  if (mutex_lock((mutex_t *)(&(mutex->backend))) != 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  if (mutex_trylock((mutex_t *)(&(mutex->backend))) != 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  if (mutex_unlock((mutex_t *)(&(mutex->backend))) != 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  return cond_init((cond_t *)(&(condition->backend)), USYNC_THREAD, NULL);\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  return cond_destroy((cond_t *)(&(condition->backend)));\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  return cond_wait((cond_t *)(&(condition->backend)),\n-\t\t   (mutex_t *)(&(mutex->backend)));\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  return cond_broadcast((cond_t *)(&(condition->backend)));\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  return cond_signal((cond_t *)(&(condition->backend)));\n-}\n-\n-/* End of File */"}, {"sha": "0074c6916f480cd560020782d75d223aff79566f", "filename": "libobjc/thr-vxworks.c", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-vxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-vxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-vxworks.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,191 +0,0 @@\n-/* GNU Objective C Runtime Thread Implementation\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-/* Thread local storage for a single thread */\n-static void *thread_local_storage = NULL;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  /* No thread support available */\n-  return NULL;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  /* No thread support available */\n-  return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  return;\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* No thread support available */\n-  /* Should we really exit the program */\n-  /* exit(&__objc_thread_exit_status); */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  /* No thread support, use 1. */\n-  return (objc_thread_t)1;\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  thread_local_storage = value;\n-  return 0;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  return thread_local_storage;\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  /* There can only be one thread, so we always get the lock */\n-  return 0;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  /* There can only be one thread, so we always get the lock */\n-  return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  return 0;\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  return 0;\n-}\n-\n-/* End of File */"}, {"sha": "2d2f31e885e2f5ca00ff2e3dfe98ce4fce534027", "filename": "libobjc/thr-win32.c", "status": "removed", "additions": 0, "deletions": 271, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1920c3d6841fafde80b28f86d90b8ab989212/libobjc%2Fthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-win32.c?ref=0db1920c3d6841fafde80b28f86d90b8ab989212", "patch": "@@ -1,271 +0,0 @@\n-/* GNU Objective C Runtime Thread Interface - Win32 Implementation\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n-   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"objc/thr.h\"\n-#include \"objc/runtime.h\"\n-\n-#ifndef __OBJC__\n-#define __OBJC__\n-#endif\n-#include <windows.h>\n-\n-/* Key structure for maintaining thread specific storage */\n-static DWORD\t__objc_data_tls = (DWORD)-1;\n-\n-/* Backend initialization functions */\n-\n-/* Initialize the threads subsystem. */\n-int\n-__objc_init_thread_system(void)\n-{\n-  /* Initialize the thread storage key */\n-  if ((__objc_data_tls = TlsAlloc()) != (DWORD)-1)\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Close the threads subsystem. */\n-int\n-__objc_close_thread_system(void)\n-{\n-  if (__objc_data_tls != (DWORD)-1)\n-    TlsFree(__objc_data_tls);\n-  return 0;\n-}\n-\n-/* Backend thread functions */\n-\n-/* Create a new thread of execution. */\n-objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n-{\n-  DWORD\tthread_id = 0;\n-  HANDLE win32_handle;\n-\n-  if (!(win32_handle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func,\n-                                   arg, 0, &thread_id)))\n-    thread_id = 0;\n-  \n-  return (objc_thread_t)(size_t) thread_id;\n-}\n-\n-/* Set the current thread's priority. */\n-int\n-__objc_thread_set_priority(int priority)\n-{\n-  int sys_priority = 0;\n-\n-  switch (priority)\n-    {\n-    case OBJC_THREAD_INTERACTIVE_PRIORITY:\n-      sys_priority = THREAD_PRIORITY_NORMAL;\n-      break;\n-    default:\n-    case OBJC_THREAD_BACKGROUND_PRIORITY:\n-      sys_priority = THREAD_PRIORITY_BELOW_NORMAL;\n-      break;\n-    case OBJC_THREAD_LOW_PRIORITY:\n-      sys_priority = THREAD_PRIORITY_LOWEST;\n-      break;\n-    }\n-\n-  /* Change priority */\n-  if (SetThreadPriority(GetCurrentThread(), sys_priority))\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Return the current thread's priority. */\n-int\n-__objc_thread_get_priority(void)\n-{\n-  int sys_priority;\n-\n-  sys_priority = GetThreadPriority(GetCurrentThread());\n-  \n-  switch (sys_priority)\n-    {\n-    case THREAD_PRIORITY_HIGHEST:\n-    case THREAD_PRIORITY_TIME_CRITICAL:\n-    case THREAD_PRIORITY_ABOVE_NORMAL:\n-    case THREAD_PRIORITY_NORMAL:\n-      return OBJC_THREAD_INTERACTIVE_PRIORITY;\n-\n-    default:\n-    case THREAD_PRIORITY_BELOW_NORMAL:\n-      return OBJC_THREAD_BACKGROUND_PRIORITY;\n-    \n-    case THREAD_PRIORITY_IDLE:\n-    case THREAD_PRIORITY_LOWEST:\n-      return OBJC_THREAD_LOW_PRIORITY;\n-    }\n-\n-  /* Couldn't get priority. */\n-  return -1;\n-}\n-\n-/* Yield our process time to another thread. */\n-void\n-__objc_thread_yield(void)\n-{\n-  Sleep(0);\n-}\n-\n-/* Terminate the current thread. */\n-int\n-__objc_thread_exit(void)\n-{\n-  /* exit the thread */\n-  ExitThread(__objc_thread_exit_status);\n-\n-  /* Failed if we reached here */\n-  return -1;\n-}\n-\n-/* Returns an integer value which uniquely describes a thread. */\n-objc_thread_t\n-__objc_thread_id(void)\n-{\n-  return (objc_thread_t)(size_t) GetCurrentThreadId();\n-}\n-\n-/* Sets the thread's local storage pointer. */\n-int\n-__objc_thread_set_data(void *value)\n-{\n-  if (TlsSetValue(__objc_data_tls, value))\n-    return 0;\n-  else\n-    return -1;\n-}\n-\n-/* Returns the thread's local storage pointer. */\n-void *\n-__objc_thread_get_data(void)\n-{\n-  return TlsGetValue(__objc_data_tls);          /* Return thread data.      */\n-}\n-\n-/* Backend mutex functions */\n-\n-/* Allocate a mutex. */\n-int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n-{\n-  if ((mutex->backend = (void *)CreateMutex(NULL, 0, NULL)) == NULL)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Deallocate a mutex. */\n-int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n-{\n-  CloseHandle((HANDLE)(mutex->backend));\n-  return 0;\n-}\n-\n-/* Grab a lock on a mutex. */\n-int\n-__objc_mutex_lock(objc_mutex_t mutex)\n-{\n-  int status;\n-\n-  status = WaitForSingleObject((HANDLE)(mutex->backend), INFINITE);\n-  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Try to grab a lock on a mutex. */\n-int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n-{\n-  int status;\n-\n-  status = WaitForSingleObject((HANDLE)(mutex->backend), 0);\n-  if (status != WAIT_OBJECT_0 && status != WAIT_ABANDONED)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Unlock the mutex */\n-int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n-{\n-  if (ReleaseMutex((HANDLE)(mutex->backend)) == 0)\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* Backend condition mutex functions */\n-\n-/* Allocate a condition. */\n-int\n-__objc_condition_allocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Deallocate a condition. */\n-int\n-__objc_condition_deallocate(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wait on the condition */\n-int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wake up all threads waiting on this condition. */\n-int\n-__objc_condition_broadcast(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* Wake up one thread waiting on this condition. */\n-int\n-__objc_condition_signal(objc_condition_t condition)\n-{\n-  /* Unimplemented. */\n-  return -1;\n-}\n-\n-/* End of File */"}, {"sha": "4bdbb5d1a2760380523af9154368e2a8658c0bff", "filename": "libobjc/thr.c", "status": "modified", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2Fthr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88a2722e1fd941a7d02575a6663641d0739939a5/libobjc%2Fthr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr.c?ref=88a2722e1fd941a7d02575a6663641d0739939a5", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Interface\n-   Copyright (C) 1996, 1997, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 2009, 2010 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n \n This file is part of GCC.\n@@ -22,9 +22,24 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+#define _LIBOBJC\n+/* The line below is needed for declarations of functions such as\n+   pthread_mutexattr_settype, without which gthr-posix.h may fail to\n+   compile within libobjc.  Unfortunately, this breaks compilation on\n+   Tru64 UNIX V4.0F, so disable it there.  */\n+#ifndef __osf__\n+#define _XOPEN_SOURCE 500\n+#endif\n+#include \"config.h\"\n+#include \"tconfig.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"defaults.h\"\n+#include \"objc/thr.h\"\n+#include \"objc/runtime.h\"\n+#include <gthr.h>\n \n #include <stdlib.h>\n-#include \"objc/runtime.h\"\n \n /* Global exit status. */\n int __objc_thread_exit_status = 0;\n@@ -61,6 +76,13 @@ objc_thread_callback objc_set_thread_callback (objc_thread_callback func)\n   considered part of the public interface.\n   */\n \n+/* Initialize the threads subsystem. */\n+int\n+__objc_init_thread_system(void)\n+{\n+  return __gthread_objc_init_thread_system ();\n+}\n+\n /*\n   First function called in a thread, starts everything else.\n \n@@ -152,8 +174,8 @@ objc_thread_detach (SEL selector, id object, id argument)\n   objc_mutex_lock (__objc_runtime_mutex);\n \n   /* Call the backend to spawn the thread */\n-  if ((thread_id = __objc_thread_detach ((void *)__objc_thread_detach_function,\n-\t\t\t\t\t istate)) == NULL)\n+  if ((thread_id = __gthread_objc_thread_detach ((void *)__objc_thread_detach_function,\n+\t\t\t\t\t\t istate)) == NULL)\n     {\n       /* failed! */\n       objc_mutex_unlock (__objc_runtime_mutex);\n@@ -173,15 +195,15 @@ int\n objc_thread_set_priority (int priority)\n {\n   /* Call the backend */\n-  return __objc_thread_set_priority (priority);\n+  return __gthread_objc_thread_set_priority (priority);\n }\n \n /* Return the current thread's priority. */\n int\n objc_thread_get_priority (void)\n {\n   /* Call the backend */\n-  return __objc_thread_get_priority ();\n+  return __gthread_objc_thread_get_priority ();\n }\n \n /*\n@@ -193,7 +215,7 @@ void\n objc_thread_yield (void)\n {\n   /* Call the backend */\n-  __objc_thread_yield ();\n+  __gthread_objc_thread_yield ();\n }\n \n /*\n@@ -209,7 +231,7 @@ objc_thread_exit (void)\n   objc_mutex_unlock (__objc_runtime_mutex);\n \n   /* Call the backend to terminate the thread */\n-  return __objc_thread_exit ();\n+  return __gthread_objc_thread_exit ();\n }\n \n /*\n@@ -220,7 +242,7 @@ objc_thread_t\n objc_thread_id (void)\n {\n   /* Call the backend */\n-  return __objc_thread_id ();\n+  return __gthread_objc_thread_id ();\n }\n \n /*\n@@ -231,7 +253,7 @@ int\n objc_thread_set_data (void *value)\n {\n   /* Call the backend */\n-  return __objc_thread_set_data (value);\n+  return __gthread_objc_thread_set_data (value);\n }\n \n /*\n@@ -241,7 +263,7 @@ void *\n objc_thread_get_data (void)\n {\n   /* Call the backend */\n-  return __objc_thread_get_data ();\n+  return __gthread_objc_thread_get_data ();\n }\n \n /* Frontend mutex functions */\n@@ -260,7 +282,7 @@ objc_mutex_allocate (void)\n     return NULL;\n \n   /* Call backend to create the mutex */\n-  if (__objc_mutex_allocate (mutex))\n+  if (__gthread_objc_mutex_allocate (mutex))\n     {\n       /* failed! */\n       objc_free (mutex);\n@@ -293,7 +315,7 @@ objc_mutex_deallocate (objc_mutex_t mutex)\n   depth = objc_mutex_lock (mutex);\n \n   /* Call backend to destroy mutex */\n-  if (__objc_mutex_deallocate (mutex))\n+  if (__gthread_objc_mutex_deallocate (mutex))\n     return -1;\n \n   /* Free the mutex structure */\n@@ -320,12 +342,12 @@ objc_mutex_lock (objc_mutex_t mutex)\n     return -1;\n \n   /* If we already own the lock then increment depth */\n-  thread_id = __objc_thread_id ();\n+  thread_id = __gthread_objc_thread_id ();\n   if (mutex->owner == thread_id)\n     return ++mutex->depth;\n \n   /* Call the backend to lock the mutex */\n-  status = __objc_mutex_lock (mutex);\n+  status = __gthread_objc_mutex_lock (mutex);\n \n   /* Failed? */\n   if (status)\n@@ -352,12 +374,12 @@ objc_mutex_trylock (objc_mutex_t mutex)\n     return -1;\n \n   /* If we already own the lock then increment depth */ \n-  thread_id = __objc_thread_id ();\n+  thread_id = __gthread_objc_thread_id ();\n   if (mutex->owner == thread_id)\n     return ++mutex->depth;\n     \n   /* Call the backend to try to lock the mutex */\n-  status = __objc_mutex_trylock (mutex);\n+  status = __gthread_objc_mutex_trylock (mutex);\n \n   /* Failed? */\n   if (status)\n@@ -387,7 +409,7 @@ objc_mutex_unlock (objc_mutex_t mutex)\n     return -1;\n \n   /* If another thread owns the lock then abort */\n-  thread_id = __objc_thread_id ();\n+  thread_id = __gthread_objc_thread_id ();\n   if (mutex->owner != thread_id)\n     return -1;\n \n@@ -400,7 +422,7 @@ objc_mutex_unlock (objc_mutex_t mutex)\n   mutex->owner = NULL;\n \n   /* Have the backend unlock the mutex */\n-  status = __objc_mutex_unlock (mutex);\n+  status = __gthread_objc_mutex_unlock (mutex);\n \n   /* Failed? */\n   if (status)\n@@ -426,7 +448,7 @@ objc_condition_allocate (void)\n     return NULL;\n \n   /* Call the backend to create the condition mutex */\n-  if (__objc_condition_allocate (condition))\n+  if (__gthread_objc_condition_allocate (condition))\n     {\n       /* failed! */\n       objc_free (condition);\n@@ -452,7 +474,7 @@ objc_condition_deallocate (objc_condition_t condition)\n     return -1;\n \n   /* Call the backend to destroy */\n-  if (__objc_condition_deallocate (condition))\n+  if (__gthread_objc_condition_deallocate (condition))\n     return -1;\n \n   /* Free the condition mutex structure */\n@@ -479,7 +501,7 @@ objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n     return -1;\n \n   /* Make sure we are owner of mutex */\n-  thread_id = __objc_thread_id ();\n+  thread_id = __gthread_objc_thread_id ();\n   if (mutex->owner != thread_id)\n     return -1;\n \n@@ -492,7 +514,7 @@ objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n   mutex->owner = (objc_thread_t)NULL;\n \n   /* Call the backend to wait */\n-  __objc_condition_wait (condition, mutex);\n+  __gthread_objc_condition_wait (condition, mutex);\n \n   /* Make ourselves owner of the mutex */\n   mutex->owner = thread_id;\n@@ -514,7 +536,7 @@ objc_condition_broadcast (objc_condition_t condition)\n   if (! condition)\n     return -1;\n \n-  return __objc_condition_broadcast (condition);\n+  return __gthread_objc_condition_broadcast (condition);\n }\n \n /*\n@@ -530,7 +552,7 @@ objc_condition_signal (objc_condition_t condition)\n   if (! condition)\n     return -1;\n \n-  return __objc_condition_signal (condition);\n+  return __gthread_objc_condition_signal (condition);\n }\n \n /* Make the objc thread system aware that a thread which is managed"}]}