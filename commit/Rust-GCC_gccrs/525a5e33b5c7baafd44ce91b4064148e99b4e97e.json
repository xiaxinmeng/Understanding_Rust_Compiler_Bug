{"sha": "525a5e33b5c7baafd44ce91b4064148e99b4e97e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI1YTVlMzNiNWM3YmFhZmQ0NGNlOTFiNDA2NDE0OGU5OWI0ZTk3ZQ==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-01-18T19:03:21Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-01-18T19:03:21Z"}, "message": "coarray_alloc_with_implicit_sync_2.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/coarray_alloc_with_implicit_sync_2.f90: New test.\n\nAlso fixed date in gcc/testsuite/ChangeLog on my previous commit.\n\ngcc/fortran/ChangeLog:\n\n2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* primary.c (caf_variable_attr): Improve figuring whether the current\n\tcomponent is the last one refed.\n\t* trans-stmt.c (gfc_trans_allocate): Do not generate sync_all calls\n\twhen allocating pointer or allocatable components.\n\nFrom-SVN: r244590", "tree": {"sha": "0e7b010f1a68af7ad7a71ad2014b55bb31002394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e7b010f1a68af7ad7a71ad2014b55bb31002394"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/525a5e33b5c7baafd44ce91b4064148e99b4e97e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/525a5e33b5c7baafd44ce91b4064148e99b4e97e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/525a5e33b5c7baafd44ce91b4064148e99b4e97e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/525a5e33b5c7baafd44ce91b4064148e99b4e97e/comments", "author": null, "committer": null, "parents": [{"sha": "29dbb95abad227198858d6cbd0315eca7b27a821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29dbb95abad227198858d6cbd0315eca7b27a821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29dbb95abad227198858d6cbd0315eca7b27a821"}], "stats": {"total": 79, "additions": 67, "deletions": 12}, "files": [{"sha": "0c59ced7c776c76d1bd5196584e6664cf7b67803", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=525a5e33b5c7baafd44ce91b4064148e99b4e97e", "patch": "@@ -1,3 +1,10 @@\n+2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* primary.c (caf_variable_attr): Improve figuring whether the current\n+\tcomponent is the last one refed.\n+\t* trans-stmt.c (gfc_trans_allocate): Do not generate sync_all calls\n+\twhen allocating pointer or allocatable components.\n+\n 2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \t* gfortran.texi: Add missing parameters to caf-API functions.  Correct"}, {"sha": "02e6dc1741554b0dc33503ac9e660587f338ec38", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=525a5e33b5c7baafd44ce91b4064148e99b4e97e", "patch": "@@ -2449,7 +2449,7 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate, bool *refs_comp)\n   gfc_clear_attr (&attr);\n \n   if (refs_comp)\n-    *refs_comp = 0;\n+    *refs_comp = false;\n \n   if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n     {\n@@ -2527,8 +2527,10 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate, bool *refs_comp)\n \t    allocatable = comp->attr.allocatable;\n \t  }\n \n-\tif (refs_comp && strcmp (comp->name, \"_data\") != 0)\n-\t  *refs_comp = 1;\n+\tif (refs_comp && strcmp (comp->name, \"_data\") != 0\n+\t    && (ref->next == NULL\n+\t\t|| (ref->next->type == REF_ARRAY && ref->next->next == NULL)))\n+\t  *refs_comp = true;\n \n \tif (pointer || attr.proc_pointer)\n \t  target = 1;"}, {"sha": "63f33049842d2646b832461753827838870ec4a3", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=525a5e33b5c7baafd44ce91b4064148e99b4e97e", "patch": "@@ -5506,8 +5506,10 @@ gfc_trans_allocate (gfc_code * code)\n   stmtblock_t block;\n   stmtblock_t post;\n   tree nelems;\n-  bool upoly_expr, tmp_expr3_len_flag = false, al_len_needs_set, is_coarray ;\n+  bool upoly_expr, tmp_expr3_len_flag = false, al_len_needs_set, is_coarray;\n+  bool needs_caf_sync, caf_refs_comp;\n   gfc_symtree *newsym = NULL;\n+  symbol_attribute caf_attr;\n \n   if (!code->ext.alloc.list)\n     return NULL_TREE;\n@@ -5516,7 +5518,7 @@ gfc_trans_allocate (gfc_code * code)\n   expr3 = expr3_vptr = expr3_len = expr3_esize = NULL_TREE;\n   label_errmsg = label_finish = errmsg = errlen = NULL_TREE;\n   e3_is = E3_UNSET;\n-  is_coarray = false;\n+  is_coarray = needs_caf_sync = false;\n \n   gfc_init_block (&block);\n   gfc_init_block (&post);\n@@ -6087,16 +6089,20 @@ gfc_trans_allocate (gfc_code * code)\n \t    /* Handle size computation of the type declared to alloc.  */\n \t    memsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (se.expr)));\n \n-\t  if (gfc_caf_attr (expr).codimension\n-\t      && flag_coarray == GFC_FCOARRAY_LIB)\n+\t  /* Store the caf-attributes for latter use.  */\n+\t  if (flag_coarray == GFC_FCOARRAY_LIB\n+\t      && (caf_attr = gfc_caf_attr (expr, true, &caf_refs_comp))\n+\t\t .codimension)\n \t    {\n \t      /* Scalar allocatable components in coarray'ed derived types make\n \t\t it here and are treated now.  */\n \t      tree caf_decl, token;\n \t      gfc_se caf_se;\n \n-\t      /* Set flag, to add synchronize after the allocate.  */\n \t      is_coarray = true;\n+\t      /* Set flag, to add synchronize after the allocate.  */\n+\t      needs_caf_sync = needs_caf_sync\n+\t\t  || caf_attr.coarray_comp || !caf_refs_comp;\n \n \t      gfc_init_se (&caf_se, NULL);\n \n@@ -6121,8 +6127,14 @@ gfc_trans_allocate (gfc_code * code)\n \t{\n \t  /* Allocating coarrays needs a sync after the allocate executed.\n \t     Set the flag to add the sync after all objects are allocated.  */\n-\t  is_coarray = is_coarray || (gfc_caf_attr (expr).codimension\n-\t\t\t\t      && flag_coarray == GFC_FCOARRAY_LIB);\n+\t  if (flag_coarray == GFC_FCOARRAY_LIB\n+\t      && (caf_attr = gfc_caf_attr (expr, true, &caf_refs_comp))\n+\t\t .codimension)\n+\t    {\n+\t      is_coarray = true;\n+\t      needs_caf_sync = needs_caf_sync\n+\t\t  || caf_attr.coarray_comp || !caf_refs_comp;\n+\t    }\n \n \t  if (expr->ts.type == BT_CHARACTER && al_len != NULL_TREE\n \t      && expr3_len != NULL_TREE)\n@@ -6401,7 +6413,7 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_add_modify (&block, se.expr, tmp);\n     }\n \n-  if (is_coarray && flag_coarray == GFC_FCOARRAY_LIB)\n+  if (needs_caf_sync)\n     {\n       /* Add a sync all after the allocation has been executed.  */\n       tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sync_all,"}, {"sha": "974f9ffaaaa8625ee32325bf0bfb897f38254f9d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=525a5e33b5c7baafd44ce91b4064148e99b4e97e", "patch": "@@ -1,4 +1,8 @@\n-2017-01-17  Andre Vehreschild  <vehre@gcc.gnu.org>\n+2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/coarray_alloc_with_implicit_sync_2.f90: New test.\n+\n+2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/70696\n \t* gfortran.dg/coarray_event_1.f08: New test."}, {"sha": "eccfde37f82266a3e6413f1b1c5dda666e0c198a", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_with_implicit_sync_2.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_with_implicit_sync_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/525a5e33b5c7baafd44ce91b4064148e99b4e97e/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_with_implicit_sync_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_with_implicit_sync_2.f90?ref=525a5e33b5c7baafd44ce91b4064148e99b4e97e", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -fdump-tree-original\" }\n+! \n+! Test that the compiler generates sync_all statements only at the required\n+! locations. This program is not supposed to run (allocating already alloced).\n+\n+program test_alloc_sync\n+\n+  type :: T\n+    integer, allocatable :: i\n+  end type T\n+  type :: T2\n+    type(T), allocatable :: o[:]\n+  end type T2\n+\n+  integer, allocatable :: caf[:]\n+  type (T) :: obj[*]\n+  type (T2) :: cafcomp\n+\n+  allocate(caf[*])             ! implicit sync_all\n+  allocate(obj%i)              ! asynchronous\n+  allocate(cafcomp%o[*])       ! sync\n+  allocate(cafcomp%o%i)        ! async\n+\n+  allocate(obj%i, cafcomp%o%i) ! async\n+  allocate(caf[*], obj%i, cafcomp%o%i) ! sync\n+\n+end program test_alloc_sync\n+\n+! { dg-final { scan-tree-dump-times \"caf_sync_all\" 3 \"original\" } }"}]}