{"sha": "bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVlNTEyMDlmNjVmMGQ4MGJjOGNmZDdhNDk0ZDFkNmM0ZjczMGMyYg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2011-11-24T22:11:12Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-11-24T22:11:12Z"}, "message": "Revert revision 181357.\n\ngcc/\n\n2011-11-24  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/51134\n\t* config/i386/i386.h (processor_costs): Revert revision 181357.\n\t* config/i386/i386.c (cost models): Likewise.\n\t(core_cost): Likewise.\n\t(promote_duplicated_reg): Likewise.\n\t(promote_duplicated_reg_to_size): Likewise.\n\t(processor_target): Likewise.\n\t(expand_set_or_movmem_via_loop_with_iter): Likewise.\n\t(expand_set_or_movmem_via_loop): Likewise.\n\t(emit_strset): Likewise.\n\t(expand_movmem_epilogue): Likewise.\n\t(expand_setmem_epilogue): Likewise.\n\t(expand_movmem_prologue): Likewise.\n\t(expand_setmem_prologue): Likewise.\n\t(expand_constant_movmem_prologue): Likewise.\n\t(expand_constant_setmem_prologue): Likewise.\n\t(decide_alg): Likewise.\n\t(decide_alignment): Likewise.\n\t(ix86_expand_movmem): Likewise.\n\t(ix86_expand_setmem): Likewise.\n\t(ix86_slow_unaligned_access): Likewise.\n\t* config/i386/i386.md (strset): Likewise.\n\t* config/i386/sse.md (vec_dupv4si): Likewise.\n\t(vec_dupv2di): Likewise.\n\ngcc/testsuite/\n\n2011-11-24  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/51134\n\t* gcc.target/i386/sw-1.c: Revert revision 181357.\n\nFrom-SVN: r181701", "tree": {"sha": "d6cef145da838165ca3bbf18a1fd20371cf033fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6cef145da838165ca3bbf18a1fd20371cf033fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f456d737215d13c9377359a2837cfca862c80f89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f456d737215d13c9377359a2837cfca862c80f89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f456d737215d13c9377359a2837cfca862c80f89"}], "stats": {"total": 1234, "additions": 288, "deletions": 946}, "files": [{"sha": "3e25864655dae74876ac09000f77b837bdeb470c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "patch": "@@ -1,3 +1,30 @@\n+2011-11-24  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/51134\n+\t* config/i386/i386.h (processor_costs): Revert revision 181357.\n+\t* config/i386/i386.c (cost models): Likewise.\n+\t(core_cost): Likewise.\n+\t(promote_duplicated_reg): Likewise.\n+\t(promote_duplicated_reg_to_size): Likewise.\n+\t(processor_target): Likewise.\n+\t(expand_set_or_movmem_via_loop_with_iter): Likewise.\n+\t(expand_set_or_movmem_via_loop): Likewise.\n+\t(emit_strset): Likewise.\n+\t(expand_movmem_epilogue): Likewise.\n+\t(expand_setmem_epilogue): Likewise.\n+\t(expand_movmem_prologue): Likewise.\n+\t(expand_setmem_prologue): Likewise.\n+\t(expand_constant_movmem_prologue): Likewise.\n+\t(expand_constant_setmem_prologue): Likewise.\n+\t(decide_alg): Likewise.\n+\t(decide_alignment): Likewise.\n+\t(ix86_expand_movmem): Likewise.\n+\t(ix86_expand_setmem): Likewise.\n+\t(ix86_slow_unaligned_access): Likewise.\n+\t* config/i386/i386.md (strset): Likewise.\n+\t* config/i386/sse.md (vec_dupv4si): Likewise.\n+\t(vec_dupv2di): Likewise.\n+\n 2011-11-24  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/avr.md (*rotlhi2.15): Set length to 4."}, {"sha": "3cc2253c3c2698ca7d2c586fe969ae8f9068754a", "filename": "gcc/config/i386/i386-opts.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fi386-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fi386-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-opts.h?ref=bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "patch": "@@ -37,8 +37,7 @@ enum stringop_alg\n    rep_prefix_8_byte,\n    loop_1_byte,\n    loop,\n-   unrolled_loop,\n-   sse_loop\n+   unrolled_loop\n };\n \n /* Available call abi.  */"}, {"sha": "409accc163395774a1de66c7253a4c295dd76816", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 252, "deletions": 914, "changes": 1166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "patch": "@@ -561,14 +561,10 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FSQRT instruction.  */\n-  {{{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n-   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n-   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}}},\n-  {{{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n-   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n-   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -636,14 +632,10 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (22),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (122),\t\t\t/* cost of FSQRT instruction.  */\n-  {{{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n-   DUMMY_STRINGOP_ALGS}},\n-  {{{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -712,14 +704,10 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (83),\t\t\t/* cost of FSQRT instruction.  */\n-  {{{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n+  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n-   DUMMY_STRINGOP_ALGS}},\n-  {{{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n+  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -786,14 +774,10 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n-  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n-  {{{libcall, {{-1, rep_prefix_4_byte}}},\n+  {{libcall, {{-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{-1, rep_prefix_4_byte}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -865,18 +849,12 @@ struct processor_costs pentiumpro_cost = {\n      noticeable win, for bigger blocks either rep movsl or rep movsb is\n      way to go.  Rep movsb has apparently more expensive startup time in CPU,\n      but after 4K the difference is down in the noise.  */\n-  {{{rep_prefix_4_byte, {{128, loop}, {1024, unrolled_loop},\n+  {{rep_prefix_4_byte, {{128, loop}, {1024, unrolled_loop},\n \t\t\t{8192, rep_prefix_4_byte}, {-1, rep_prefix_1_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{rep_prefix_4_byte, {{128, loop}, {1024, unrolled_loop},\n-\t\t\t{8192, rep_prefix_4_byte}, {-1, rep_prefix_1_byte}}},\n-   DUMMY_STRINGOP_ALGS}},\n-  {{{rep_prefix_4_byte, {{1024, unrolled_loop},\n-\t\t\t{8192, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{rep_prefix_4_byte, {{1024, unrolled_loop},\n+  \t\t\t{8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{rep_prefix_4_byte, {{1024, unrolled_loop},\n-\t\t\t{8192, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -944,14 +922,10 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (54),\t\t\t/* cost of FSQRT instruction.  */\n-  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n-  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1021,14 +995,10 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n-  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n-  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1098,14 +1068,10 @@ struct processor_costs athlon_cost = {\n   /* For some reason, Athlon deals better with REP prefix (relative to loops)\n      compared to K8. Alignment becomes important after 8 bytes for memcpy and\n      128 bytes for memset.  */\n-  {{{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n-  {{{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1180,16 +1146,11 @@ struct processor_costs k8_cost = {\n   /* K8 has optimized REP instruction for medium sized blocks, but for very\n      small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n-  {{{libcall, {{8, loop}, {24, unrolled_loop},\n+  {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1272,16 +1233,11 @@ struct processor_costs amdfam10_cost = {\n   /* AMDFAM10 has optimized REP instruction for medium sized blocks, but for\n      very small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {512, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {512, rep_prefix_8_byte}, {-1, libcall}}}}},\n-  {{{libcall, {{8, loop}, {24, unrolled_loop},\n+  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1364,16 +1320,11 @@ struct processor_costs bdver1_cost = {\n   /*  BDVER1 has optimized REP instruction for medium sized blocks, but for\n       very small blocks it is better to use loop. For large blocks, libcall\n       can do nontemporary accesses and beat inline considerably.  */\n-  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n-  {{{libcall, {{8, loop}, {24, unrolled_loop},\n+  {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1456,16 +1407,11 @@ struct processor_costs bdver2_cost = {\n   /*  BDVER2 has optimized REP instruction for medium sized blocks, but for\n       very small blocks it is better to use loop. For large blocks, libcall\n       can do nontemporary accesses and beat inline considerably.  */\n-  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n-  {{{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n+   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1543,16 +1489,11 @@ struct processor_costs btver1_cost = {\n   /* BTVER1 has optimized REP instruction for medium sized blocks, but for\n      very small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n+  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n-  {{{libcall, {{8, loop}, {24, unrolled_loop},\n+  {{libcall, {{8, loop}, {24, unrolled_loop},\n \t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n    {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1619,18 +1560,11 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (43),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  {{{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n+  {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n-   DUMMY_STRINGOP_ALGS}},\n-\n-  {{{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n+  {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n    {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n-   {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1697,22 +1631,13 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  {{{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n+  {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{32, loop}, {20000, rep_prefix_8_byte},\n \t      {100000, unrolled_loop}, {-1, libcall}}}},\n-   {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{32, loop}, {20000, rep_prefix_8_byte},\n-\t      {100000, unrolled_loop}, {-1, libcall}}}}},\n-\n-  {{{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n+  {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n    {-1, libcall}}},\n    {libcall, {{24, loop}, {64, unrolled_loop},\n \t      {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n-   {-1, libcall}}},\n-   {libcall, {{24, loop}, {64, unrolled_loop},\n-\t      {8192, rep_prefix_8_byte}, {-1, libcall}}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1779,108 +1704,13 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  /* stringop_algs for memcpy.  \n-     SSE loops works best on Atom, but fall back into non-SSE unrolled loop variant\n-     if that fails.  */\n-  {{{libcall, {{4096, unrolled_loop}, {-1, libcall}}}, /* Known alignment.  */\n-    {libcall, {{4096, unrolled_loop}, {-1, libcall}}}},\n-   {{libcall, {{2048, unrolled_loop}, {-1, libcall}}}, /* Unknown alignment.  */\n-    {libcall, {{2048, unrolled_loop},\n-\t       {-1, libcall}}}}},\n-\n-  /* stringop_algs for memset.  */\n-  {{{libcall, {{4096, unrolled_loop}, {-1, libcall}}}, /* Known alignment.  */\n-    {libcall, {{4096, unrolled_loop}, {-1, libcall}}}},\n-   {{libcall, {{1024, unrolled_loop},\t /* Unknown alignment.  */\n-\t       {-1, libcall}}},\n-    {libcall, {{2048, unrolled_loop},\n-\t       {-1, libcall}}}}},\n-  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n-  1,\t\t\t\t\t/* scalar load_cost.  */\n-  1,\t\t\t\t\t/* scalar_store_cost.  */\n-  1,\t\t\t\t\t/* vec_stmt_cost.  */\n-  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n-  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n-  1,\t\t\t\t\t/* vec_align_load_cost.  */\n-  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n-  1,\t\t\t\t\t/* vec_store_cost.  */\n-  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n-  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n-};\n-\n-/* Core should produce code tuned for core variants.  */\n-static const\n-struct processor_costs core_cost = {\n-  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n-  /* On all chips taken into consideration lea is 2 cycles and more.  With\n-     this cost however our current implementation of synth_mult results in\n-     use of unnecessary temporary registers causing regression on several\n-     SPECfp benchmarks.  */\n-  COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n-  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n-  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n-  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n-   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n-   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n-   COSTS_N_INSNS (2)},\t\t\t/*\t\t\t      other */\n-  0,\t\t\t\t\t/* cost of multiply per each bit set */\n-  {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n-   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n-   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n-   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n-   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n-  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n-  8,\t\t\t\t\t/* \"large\" insn */\n-  17,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n-\t\t\t\t\t   in QImode, HImode and SImode.\n-\t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 12},\t\t\t\t/* cost of loading fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n-\t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {8, 8},\t\t\t\t/* cost of loading MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  {8, 8},\t\t\t\t/* cost of storing MMX registers\n-\t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {8, 8, 8},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {8, 8, 8},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  5,\t\t\t\t\t/* MMX or SSE register to integer */\n-  32,\t\t\t\t\t/* size of l1 cache.  */\n-  512,\t\t\t\t\t/* size of l2 cache.  */\n-  64,\t\t\t\t\t/* size of prefetch block */\n-  6,\t\t\t\t\t/* number of parallel prefetches */\n-  /* Benchmarks shows large regressions on K8 sixtrack benchmark when this\n-     value is increased to perhaps more appropriate value of 5.  */\n-  3,\t\t\t\t\t/* Branch cost */\n-  COSTS_N_INSNS (8),\t\t\t/* cost of FADD and FSUB insns.  */\n-  COSTS_N_INSNS (8),\t\t\t/* cost of FMUL instruction.  */\n-  COSTS_N_INSNS (20),\t\t\t/* cost of FDIV instruction.  */\n-  COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n-  COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n-  COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  /* stringop_algs for memcpy.  */\n-  {{{libcall, {{16, loop}, {24, unrolled_loop}, {1024, rep_prefix_4_byte}, {-1, libcall}}}, /* Known alignment.  */\n-    {libcall, {{16, loop}, {24, unrolled_loop}, {1024, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{16, loop}, {24, unrolled_loop}, {1024, rep_prefix_4_byte}, {-1, libcall}}}, /* Unknown alignment.  */\n-    {libcall, {{16, loop}, {24, unrolled_loop}, {1024, rep_prefix_8_byte}, {-1, libcall}}}}},\n-\n-  /* stringop_algs for memset.  */\n-  {{{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}}, /* Known alignment.  */\n-    {libcall, {{256, rep_prefix_8_byte}, {-1, libcall}}}},\n-   {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}}, /* Unknown alignment.  */\n-    {libcall, {{256, rep_prefix_8_byte}, {-1, libcall}}}}},\n+  {{libcall, {{11, loop}, {-1, rep_prefix_4_byte}}},\n+   {libcall, {{32, loop}, {64, rep_prefix_4_byte},\n+\t  {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{8, loop}, {15, unrolled_loop},\n+\t  {2048, rep_prefix_4_byte}, {-1, libcall}}},\n+   {libcall, {{24, loop}, {32, unrolled_loop},\n+\t  {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1894,7 +1724,7 @@ struct processor_costs core_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-/* Generic64 should produce code tuned for Nocona, Core,  K8, Amdfam10 and buldozer.  */\n+/* Generic64 should produce code tuned for Nocona and K8.  */\n static const\n struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -1954,16 +1784,10 @@ struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-\n-  {{DUMMY_STRINGOP_ALGS,\n-    {libcall, {{16, rep_prefix_4_byte}, {128, rep_prefix_8_byte}, {4096, rep_prefix_1_byte}, {-1, libcall}}}},\n-   {DUMMY_STRINGOP_ALGS,\n-    {libcall, {{128, rep_prefix_4_byte}, {4096, rep_prefix_1_byte}, {-1, libcall}}}}},\n-\n-  {{DUMMY_STRINGOP_ALGS,\n-    {libcall, {{16, rep_prefix_4_byte}, {512, unrolled_loop}, {4096, rep_prefix_1_byte}, {-1, libcall}}}},\n-   {DUMMY_STRINGOP_ALGS,\n-    {libcall, {{16, rep_prefix_4_byte}, {512, unrolled_loop}, {4096, rep_prefix_1_byte}, {-1, libcall}}}}},\n+  {DUMMY_STRINGOP_ALGS,\n+   {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {DUMMY_STRINGOP_ALGS,\n+   {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1977,8 +1801,8 @@ struct processor_costs generic64_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n-/* Generic32 should produce code tuned for PPro, Pentium4, Nocona, Core\n-   Athlon, K8, amdfam10, buldozer.  */\n+/* Generic32 should produce code tuned for PPro, Pentium4, Nocona,\n+   Athlon and K8.  */\n static const\n struct processor_costs generic32_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n@@ -2032,16 +1856,10 @@ struct processor_costs generic32_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  /* stringop_algs for memcpy.  */\n-  {{{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n-  /* stringop_algs for memset.  */\n-  {{{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n    DUMMY_STRINGOP_ALGS},\n-   {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n-   DUMMY_STRINGOP_ALGS}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -2718,8 +2536,6 @@ static void ix86_set_current_function (tree);\n static unsigned int ix86_minimum_incoming_stack_boundary (bool);\n \n static enum calling_abi ix86_function_abi (const_tree);\n-static rtx promote_duplicated_reg (enum machine_mode, rtx);\n-static rtx promote_duplicated_reg_to_size (rtx, int, int, int);\n \n \f\n #ifndef SUBTARGET32_DEFAULT_CPU\n@@ -2766,13 +2582,13 @@ static const struct ptt processor_target_table[PROCESSOR_max] =\n   {&k8_cost, 16, 7, 16, 7, 16},\n   {&nocona_cost, 0, 0, 0, 0, 0},\n   /* Core 2 32-bit.  */\n-  {&core_cost, 16, 10, 16, 10, 16},\n+  {&generic32_cost, 16, 10, 16, 10, 16},\n   /* Core 2 64-bit.  */\n-  {&core_cost, 16, 10, 16, 10, 16},\n+  {&generic64_cost, 16, 10, 16, 10, 16},\n   /* Core i7 32-bit.  */\n-  {&core_cost, 16, 10, 16, 10, 16},\n+  {&generic32_cost, 16, 10, 16, 10, 16},\n   /* Core i7 64-bit.  */\n-  {&core_cost, 16, 10, 16, 10, 16},\n+  {&generic64_cost, 16, 10, 16, 10, 16},\n   {&generic32_cost, 16, 7, 16, 7, 16},\n   {&generic64_cost, 16, 10, 16, 10, 16},\n   {&amdfam10_cost, 32, 24, 32, 7, 32},\n@@ -21111,80 +20927,55 @@ counter_mode (rtx count_exp)\n   return SImode;\n }\n \n-/* Helper function for expand_set_or_movmem_via_loop.\n-\n-   When SRCPTR is non-NULL, output simple loop to move memory\n+/* When SRCPTR is non-NULL, output simple loop to move memory\n    pointer to SRCPTR to DESTPTR via chunks of MODE unrolled UNROLL times,\n    overall size is COUNT specified in bytes.  When SRCPTR is NULL, output the\n    equivalent loop to set memory by VALUE (supposed to be in MODE).\n \n    The size is rounded down to whole number of chunk size moved at once.\n-   SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.\n-\n-   If ITER isn't NULL, than it'll be used in the generated loop without\n-   initialization (that allows to generate several consequent loops using the\n-   same iterator).\n-   If CHANGE_PTRS is specified, DESTPTR and SRCPTR would be increased by\n-   iterator value at the end of the function (as if they iterate in the loop).\n-   Otherwise, their vaules'll stay unchanged.\n+   SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.  */\n \n-   If EXPECTED_SIZE isn't -1, than it's used to compute branch-probabilities on\n-   the loop backedge.  When expected size is unknown (it's -1), the probability\n-   is set to 80%.\n \n-   Return value is rtx of iterator, used in the loop - it could be reused in\n-   consequent calls of this function.  */\n-static rtx\n-expand_set_or_movmem_via_loop_with_iter (rtx destmem, rtx srcmem,\n-\t\t\t\t\t rtx destptr, rtx srcptr, rtx value,\n-\t\t\t\t\t rtx count, rtx iter,\n-\t\t\t\t\t enum machine_mode mode, int unroll,\n-\t\t\t\t\t int expected_size, bool change_ptrs)\n+static void\n+expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n+\t\t\t       rtx destptr, rtx srcptr, rtx value,\n+\t\t\t       rtx count, enum machine_mode mode, int unroll,\n+\t\t\t       int expected_size)\n {\n-  rtx out_label, top_label, tmp;\n+  rtx out_label, top_label, iter, tmp;\n   enum machine_mode iter_mode = counter_mode (count);\n   rtx piece_size = GEN_INT (GET_MODE_SIZE (mode) * unroll);\n   rtx piece_size_mask = GEN_INT (~((GET_MODE_SIZE (mode) * unroll) - 1));\n   rtx size;\n   rtx x_addr;\n   rtx y_addr;\n   int i;\n-  bool reuse_iter = (iter != NULL_RTX);\n \n   top_label = gen_label_rtx ();\n   out_label = gen_label_rtx ();\n+  iter = gen_reg_rtx (iter_mode);\n+\n   size = expand_simple_binop (iter_mode, AND, count, piece_size_mask,\n-\t\t               NULL, 1, OPTAB_DIRECT);\n-  if (!reuse_iter)\n+\t\t\t      NULL, 1, OPTAB_DIRECT);\n+  /* Those two should combine.  */\n+  if (piece_size == const1_rtx)\n     {\n-      iter = gen_reg_rtx (iter_mode);\n-      /* Those two should combine.  */\n-      if (piece_size == const1_rtx)\n-\t{\n-\t  emit_cmp_and_jump_insns (size, const0_rtx, EQ, NULL_RTX, iter_mode,\n-\t\t\t\t   true, out_label);\n-\t  predict_jump (REG_BR_PROB_BASE * 10 / 100);\n-\t}\n-      emit_move_insn (iter, const0_rtx);\n-    }\n-  else\n-    {\n-      emit_cmp_and_jump_insns (iter, size, GE, NULL_RTX, iter_mode,\n+      emit_cmp_and_jump_insns (size, const0_rtx, EQ, NULL_RTX, iter_mode,\n \t\t\t       true, out_label);\n+      predict_jump (REG_BR_PROB_BASE * 10 / 100);\n     }\n+  emit_move_insn (iter, const0_rtx);\n \n   emit_label (top_label);\n \n   tmp = convert_modes (Pmode, iter_mode, iter, true);\n   x_addr = gen_rtx_PLUS (Pmode, destptr, tmp);\n-  destmem =\n-    adjust_automodify_address_nv (copy_rtx (destmem), mode, x_addr, 0);\n+  destmem = change_address (destmem, mode, x_addr);\n \n   if (srcmem)\n     {\n       y_addr = gen_rtx_PLUS (Pmode, srcptr, copy_rtx (tmp));\n-      srcmem =\n-\tadjust_automodify_address_nv (copy_rtx (srcmem), mode, y_addr, 0);\n+      srcmem = change_address (srcmem, mode, y_addr);\n \n       /* When unrolling for chips that reorder memory reads and writes,\n \t we can save registers by using single temporary.\n@@ -21256,43 +21047,19 @@ expand_set_or_movmem_via_loop_with_iter (rtx destmem, rtx srcmem,\n     }\n   else\n     predict_jump (REG_BR_PROB_BASE * 80 / 100);\n-  if (change_ptrs)\n+  iter = ix86_zero_extend_to_Pmode (iter);\n+  tmp = expand_simple_binop (Pmode, PLUS, destptr, iter, destptr,\n+\t\t\t     true, OPTAB_LIB_WIDEN);\n+  if (tmp != destptr)\n+    emit_move_insn (destptr, tmp);\n+  if (srcptr)\n     {\n-      iter = ix86_zero_extend_to_Pmode (iter);\n-      tmp = expand_simple_binop (Pmode, PLUS, destptr, iter, destptr,\n+      tmp = expand_simple_binop (Pmode, PLUS, srcptr, iter, srcptr,\n \t\t\t\t true, OPTAB_LIB_WIDEN);\n-      if (tmp != destptr)\n-\temit_move_insn (destptr, tmp);\n-      if (srcptr)\n-\t{\n-\t  tmp = expand_simple_binop (Pmode, PLUS, srcptr, iter, srcptr,\n-\t\t\t\t     true, OPTAB_LIB_WIDEN);\n-\t  if (tmp != srcptr)\n-\t    emit_move_insn (srcptr, tmp);\n-\t}\n+      if (tmp != srcptr)\n+\temit_move_insn (srcptr, tmp);\n     }\n   emit_label (out_label);\n-  return iter;\n-}\n-\n-/* When SRCPTR is non-NULL, output simple loop to move memory\n-   pointer to SRCPTR to DESTPTR via chunks of MODE unrolled UNROLL times,\n-   overall size is COUNT specified in bytes.  When SRCPTR is NULL, output the\n-   equivalent loop to set memory by VALUE (supposed to be in MODE).\n-\n-   The size is rounded down to whole number of chunk size moved at once.\n-   SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.  */\n-\n-static void\n-expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n-\t\t\t       rtx destptr, rtx srcptr, rtx value,\n-\t\t\t       rtx count, enum machine_mode mode, int unroll,\n-\t\t\t       int expected_size)\n-{\n-  expand_set_or_movmem_via_loop_with_iter (destmem, srcmem,\n-\t\t\t\t destptr, srcptr, value,\n-\t\t\t\t count, NULL_RTX, mode, unroll,\n-\t\t\t\t expected_size, true);\n }\n \n /* Output \"rep; mov\" instruction.\n@@ -21396,18 +21163,7 @@ emit_strmov (rtx destmem, rtx srcmem,\n   emit_insn (gen_strmov (destptr, dest, srcptr, src));\n }\n \n-/* Emit strset instuction.  If RHS is constant, and vector mode will be used,\n-   then move this constant to a vector register before emitting strset.  */\n-static void\n-emit_strset (rtx destmem, rtx value,\n-\t     rtx destptr, enum machine_mode mode, int offset)\n-{\n-  rtx dest = adjust_automodify_address_nv (destmem, mode, destptr, offset);\n-  emit_insn (gen_strset (destptr, dest, value));\n-}\n-\n-/* Output code to copy (COUNT % MAX_SIZE) bytes from SRCPTR to DESTPTR.\n-   SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.  */\n+/* Output code to copy at most count & (max_size - 1) bytes from SRC to DEST.  */\n static void\n expand_movmem_epilogue (rtx destmem, rtx srcmem,\n \t\t\trtx destptr, rtx srcptr, rtx count, int max_size)\n@@ -21418,58 +21174,46 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n       HOST_WIDE_INT countval = INTVAL (count);\n       int offset = 0;\n \n-      int remainder_size = countval % max_size;\n-      enum machine_mode move_mode = Pmode;\n-\n-      /* Firstly, try to move data with the widest possible mode.\n-\t Remaining part we'll move using Pmode and narrower modes.  */\n-      if (TARGET_SSE)\n+      if ((countval & 0x10) && max_size > 16)\n \t{\n-\t  if (max_size >= GET_MODE_SIZE (V4SImode))\n-\t    move_mode = V4SImode;\n-\t  else if (max_size >= GET_MODE_SIZE (DImode))\n-\t    move_mode = DImode;\n-\t}\n-\n-      while (remainder_size >= GET_MODE_SIZE (move_mode))\n-\t{\n-\t  emit_strmov (destmem, srcmem, destptr, srcptr, move_mode, offset);\n-\t  offset += GET_MODE_SIZE (move_mode);\n-\t  remainder_size -= GET_MODE_SIZE (move_mode);\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset);\n+\t      emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset + 8);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t  offset += 16;\n \t}\n-\n-      /* Move the remaining part of epilogue - its size might be\n-\t a size of the widest mode.  */\n-      move_mode = Pmode;\n-      while (remainder_size >= GET_MODE_SIZE (move_mode))\n+      if ((countval & 0x08) && max_size > 8)\n \t{\n-\t  emit_strmov (destmem, srcmem, destptr, srcptr, move_mode, offset);\n-\t  offset += GET_MODE_SIZE (move_mode);\n-\t  remainder_size -= GET_MODE_SIZE (move_mode);\n+\t  if (TARGET_64BIT)\n+\t    emit_strmov (destmem, srcmem, destptr, srcptr, DImode, offset);\n+\t  else\n+\t    {\n+\t      emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset);\n+\t      emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset + 4);\n+\t    }\n+\t  offset += 8;\n \t}\n-\n-      if (remainder_size >= 4)\n+      if ((countval & 0x04) && max_size > 4)\n \t{\n-\t  emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset);\n+          emit_strmov (destmem, srcmem, destptr, srcptr, SImode, offset);\n \t  offset += 4;\n-\t  remainder_size -= 4;\n \t}\n-      if (remainder_size >= 2)\n+      if ((countval & 0x02) && max_size > 2)\n \t{\n-\t  emit_strmov (destmem, srcmem, destptr, srcptr, HImode, offset);\n+          emit_strmov (destmem, srcmem, destptr, srcptr, HImode, offset);\n \t  offset += 2;\n-\t  remainder_size -= 2;\n \t}\n-      if (remainder_size >= 1)\n+      if ((countval & 0x01) && max_size > 1)\n \t{\n-\t  emit_strmov (destmem, srcmem, destptr, srcptr, QImode, offset);\n+          emit_strmov (destmem, srcmem, destptr, srcptr, QImode, offset);\n \t  offset += 1;\n-\t  remainder_size -= 1;\n \t}\n-      gcc_assert (remainder_size == 0);\n       return;\n     }\n-  if (max_size > 16)\n+  if (max_size > 8)\n     {\n       count = expand_simple_binop (GET_MODE (count), AND, count, GEN_INT (max_size - 1),\n \t\t\t\t    count, 1, OPTAB_DIRECT);\n@@ -21484,25 +21228,6 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n    */\n   if (TARGET_SINGLE_STRINGOP)\n     {\n-      if (max_size > 8)\n-\t{\n-\t  rtx label = ix86_expand_aligntest (count, 8, true);\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      src = change_address (srcmem, DImode, srcptr);\n-\t      dest = change_address (destmem, DImode, destptr);\n-\t      emit_insn (gen_strmov (destptr, dest, srcptr, src));\n-\t    }\n-\t  else\n-\t    {\n-\t      src = change_address (srcmem, SImode, srcptr);\n-\t      dest = change_address (destmem, SImode, destptr);\n-\t      emit_insn (gen_strmov (destptr, dest, srcptr, src));\n-\t      emit_insn (gen_strmov (destptr, dest, srcptr, src));\n-\t    }\n-\t  emit_label (label);\n-\t  LABEL_NUSES (label) = 1;\n-\t}\n       if (max_size > 4)\n \t{\n \t  rtx label = ix86_expand_aligntest (count, 4, true);\n@@ -21536,35 +21261,6 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n       rtx offset = force_reg (Pmode, const0_rtx);\n       rtx tmp;\n \n-      if (max_size > 8)\n-\t{\n-\t  rtx label = ix86_expand_aligntest (count, 8, true);\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      src = change_address (srcmem, DImode, srcptr);\n-\t      dest = change_address (destmem, DImode, destptr);\n-\t      emit_move_insn (dest, src);\n-\t      tmp = expand_simple_binop (Pmode, PLUS, offset, GEN_INT (8), NULL,\n-\t\t\t\t         true, OPTAB_LIB_WIDEN);\n-\t    }\n-\t  else\n-\t    {\n-\t      src = change_address (srcmem, SImode, srcptr);\n-\t      dest = change_address (destmem, SImode, destptr);\n-\t      emit_move_insn (dest, src);\n-\t      tmp = expand_simple_binop (Pmode, PLUS, offset, GEN_INT (4), NULL,\n-\t\t\t\t         true, OPTAB_LIB_WIDEN);\n-\t      if (tmp != offset)\n-\t         emit_move_insn (offset, tmp);\n-\t      tmp = expand_simple_binop (Pmode, PLUS, offset, GEN_INT (4), NULL,\n-\t\t\t\t         true, OPTAB_LIB_WIDEN);\n-\t      emit_move_insn (dest, src);\n-\t    }\n-\t  if (tmp != offset)\n-\t    emit_move_insn (offset, tmp);\n-\t  emit_label (label);\n-\t  LABEL_NUSES (label) = 1;\n-\t}\n       if (max_size > 4)\n \t{\n \t  rtx label = ix86_expand_aligntest (count, 4, true);\n@@ -21620,132 +21316,87 @@ expand_setmem_epilogue_via_loop (rtx destmem, rtx destptr, rtx value,\n \t\t\t\t 1, max_size / 2);\n }\n \n-/* Output code to set with VALUE at most (COUNT % MAX_SIZE) bytes starting from\n-   DESTPTR.\n-   DESTMEM provides MEMrtx to feed proper aliasing info.\n-   PROMOTED_TO_GPR_VALUE is rtx representing a GPR containing broadcasted VALUE.\n-   PROMOTED_TO_VECTOR_VALUE is rtx representing a vector register containing\n-   broadcasted VALUE.\n-   PROMOTED_TO_GPR_VALUE and PROMOTED_TO_VECTOR_VALUE could be NULL if the\n-   promotion hasn't been generated before.  */\n+/* Output code to set at most count & (max_size - 1) bytes starting by DEST.  */\n static void\n-expand_setmem_epilogue (rtx destmem, rtx destptr, rtx promoted_to_vector_value,\n-\t\t\trtx promoted_to_gpr_value, rtx value, rtx count,\n-\t\t\tint max_size)\n+expand_setmem_epilogue (rtx destmem, rtx destptr, rtx value, rtx count, int max_size)\n {\n+  rtx dest;\n+\n   if (CONST_INT_P (count))\n     {\n       HOST_WIDE_INT countval = INTVAL (count);\n       int offset = 0;\n \n-      int remainder_size = countval % max_size;\n-      enum machine_mode move_mode = Pmode;\n-\n-      /* Firstly, try to move data with the widest possible mode.\n-\t Remaining part we'll move using Pmode and narrower modes.  */\n-\n-      if (promoted_to_vector_value)\n+      if ((countval & 0x10) && max_size > 16)\n \t{\n-\t  if (promoted_to_vector_value)\n-\t    {\n-\t      if (max_size >= GET_MODE_SIZE (V4SImode))\n-\t\tmove_mode = V4SImode;\n-\t      else if (max_size >= GET_MODE_SIZE (DImode))\n-\t\tmove_mode = DImode;\n-\t    }\n-\t  while (remainder_size >= GET_MODE_SIZE (move_mode))\n+\t  if (TARGET_64BIT)\n \t    {\n-\t      if (GET_MODE (destmem) != move_mode)\n-\t\tdestmem = adjust_automodify_address_nv (destmem, move_mode,\n-\t\t\t\t\t\t\tdestptr, offset);\n-\t      emit_strset (destmem,\n-\t\t\t   promoted_to_vector_value,\n-\t\t\t   destptr,\n-\t\t\t   move_mode, offset);\n-\n-\t      offset += GET_MODE_SIZE (move_mode);\n-\t      remainder_size -= GET_MODE_SIZE (move_mode);\n+\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset);\n+\t      emit_insn (gen_strset (destptr, dest, value));\n+\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset + 8);\n+\t      emit_insn (gen_strset (destptr, dest, value));\n \t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t  offset += 16;\n \t}\n-\n-      /* Move the remaining part of epilogue - its size might be\n-\t a size of the widest mode.  */\n-      while (remainder_size >= GET_MODE_SIZE (Pmode))\n+      if ((countval & 0x08) && max_size > 8)\n \t{\n-\t  if (!promoted_to_gpr_value)\n-\t    promoted_to_gpr_value = promote_duplicated_reg (Pmode, value);\n-\t  emit_strset (destmem, promoted_to_gpr_value, destptr, Pmode, offset);\n-\t  offset += GET_MODE_SIZE (Pmode);\n-\t  remainder_size -= GET_MODE_SIZE (Pmode);\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset);\n+\t      emit_insn (gen_strset (destptr, dest, value));\n+\t    }\n+\t  else\n+\t    {\n+\t      dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset);\n+\t      emit_insn (gen_strset (destptr, dest, value));\n+\t      dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset + 4);\n+\t      emit_insn (gen_strset (destptr, dest, value));\n+\t    }\n+\t  offset += 8;\n \t}\n-\n-      if (!promoted_to_gpr_value && remainder_size > 1)\n-\tpromoted_to_gpr_value = promote_duplicated_reg (remainder_size >= 4\n-\t\t\t\t\t\t\t? SImode : HImode, value);\n-      if (remainder_size >= 4)\n+      if ((countval & 0x04) && max_size > 4)\n \t{\n-\t  emit_strset (destmem, gen_lowpart (SImode, promoted_to_gpr_value), destptr,\n-\t\t       SImode, offset);\n+\t  dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset);\n+\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (SImode, value)));\n \t  offset += 4;\n-\t  remainder_size -= 4;\n \t}\n-      if (remainder_size >= 2)\n+      if ((countval & 0x02) && max_size > 2)\n \t{\n-\t  emit_strset (destmem, gen_lowpart (HImode, promoted_to_gpr_value), destptr,\n-\t\t       HImode, offset);\n-\t  offset +=2;\n-\t  remainder_size -= 2;\n+\t  dest = adjust_automodify_address_nv (destmem, HImode, destptr, offset);\n+\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (HImode, value)));\n+\t  offset += 2;\n \t}\n-      if (remainder_size >= 1)\n+      if ((countval & 0x01) && max_size > 1)\n \t{\n-\t  emit_strset (destmem,\n-\t\t       promoted_to_gpr_value ? gen_lowpart (QImode, promoted_to_gpr_value) : value,\n-\t\t        destptr,\n-\t\t       QImode, offset);\n+\t  dest = adjust_automodify_address_nv (destmem, QImode, destptr, offset);\n+\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (QImode, value)));\n \t  offset += 1;\n-\t  remainder_size -= 1;\n \t}\n-      gcc_assert (remainder_size == 0);\n       return;\n     }\n-\n-  /* count isn't const.  */\n   if (max_size > 32)\n     {\n-      expand_setmem_epilogue_via_loop (destmem, destptr, value, count,\n-\t\t\t\t       max_size);\n+      expand_setmem_epilogue_via_loop (destmem, destptr, value, count, max_size);\n       return;\n     }\n-\n-  if (!promoted_to_gpr_value)\n-    promoted_to_gpr_value = promote_duplicated_reg_to_size (value,\n-\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n-\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n-\t\t\t\t\t\t   GET_MODE_SIZE (Pmode));\n-\n   if (max_size > 16)\n     {\n       rtx label = ix86_expand_aligntest (count, 16, true);\n-      if (TARGET_SSE && promoted_to_vector_value)\n-\t{\n-\t  destmem = change_address (destmem,\n-\t\t\t\t    GET_MODE (promoted_to_vector_value),\n-\t\t\t\t    destptr);\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_vector_value));\n-\t}\n-      else if (TARGET_64BIT)\n+      if (TARGET_64BIT)\n \t{\n-\t  destmem = change_address (destmem, DImode, destptr);\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t  dest = change_address (destmem, DImode, destptr);\n+\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  emit_insn (gen_strset (destptr, dest, value));\n \t}\n       else\n \t{\n-\t  destmem = change_address (destmem, SImode, destptr);\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t  dest = change_address (destmem, SImode, destptr);\n+\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  emit_insn (gen_strset (destptr, dest, value));\n \t}\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n@@ -21755,50 +21406,39 @@ expand_setmem_epilogue (rtx destmem, rtx destptr, rtx promoted_to_vector_value,\n       rtx label = ix86_expand_aligntest (count, 8, true);\n       if (TARGET_64BIT)\n \t{\n-\t  destmem = change_address (destmem, DImode, destptr);\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n-\t}\n-      /* FIXME: When this hunk it output, IRA classifies promoted_to_vector_value\n-         as NO_REGS.  */\n-      else if (TARGET_SSE && promoted_to_vector_value && 0)\n-\t{\n-\t  destmem = change_address (destmem, V2SImode, destptr);\n-\t  emit_insn (gen_strset (destptr, destmem,\n-\t\t\t\t gen_lowpart (V2SImode, promoted_to_vector_value)));\n+\t  dest = change_address (destmem, DImode, destptr);\n+\t  emit_insn (gen_strset (destptr, dest, value));\n \t}\n       else\n \t{\n-\t  destmem = change_address (destmem, SImode, destptr);\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n-\t  emit_insn (gen_strset (destptr, destmem, promoted_to_gpr_value));\n+\t  dest = change_address (destmem, SImode, destptr);\n+\t  emit_insn (gen_strset (destptr, dest, value));\n+\t  emit_insn (gen_strset (destptr, dest, value));\n \t}\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n   if (max_size > 4)\n     {\n       rtx label = ix86_expand_aligntest (count, 4, true);\n-      destmem = change_address (destmem, SImode, destptr);\n-      emit_insn (gen_strset (destptr, destmem,\n-\t\t\t     gen_lowpart (SImode, promoted_to_gpr_value)));\n+      dest = change_address (destmem, SImode, destptr);\n+      emit_insn (gen_strset (destptr, dest, gen_lowpart (SImode, value)));\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n   if (max_size > 2)\n     {\n       rtx label = ix86_expand_aligntest (count, 2, true);\n-      destmem = change_address (destmem, HImode, destptr);\n-      emit_insn (gen_strset (destptr, destmem,\n-\t\t\t     gen_lowpart (HImode, promoted_to_gpr_value)));\n+      dest = change_address (destmem, HImode, destptr);\n+      emit_insn (gen_strset (destptr, dest, gen_lowpart (HImode, value)));\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n   if (max_size > 1)\n     {\n       rtx label = ix86_expand_aligntest (count, 1, true);\n-      destmem = change_address (destmem, QImode, destptr);\n-      emit_insn (gen_strset (destptr, destmem,\n-\t\t\t     gen_lowpart (QImode, promoted_to_gpr_value)));\n+      dest = change_address (destmem, QImode, destptr);\n+      emit_insn (gen_strset (destptr, dest, gen_lowpart (QImode, value)));\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n@@ -21814,8 +21454,8 @@ expand_movmem_prologue (rtx destmem, rtx srcmem,\n   if (align <= 1 && desired_alignment > 1)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 1, false);\n-      srcmem = adjust_automodify_address_nv (srcmem, QImode, srcptr, 0);\n-      destmem = adjust_automodify_address_nv (destmem, QImode, destptr, 0);\n+      srcmem = change_address (srcmem, QImode, srcptr);\n+      destmem = change_address (destmem, QImode, destptr);\n       emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n       ix86_adjust_counter (count, 1);\n       emit_label (label);\n@@ -21824,8 +21464,8 @@ expand_movmem_prologue (rtx destmem, rtx srcmem,\n   if (align <= 2 && desired_alignment > 2)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 2, false);\n-      srcmem = adjust_automodify_address_nv (srcmem, HImode, srcptr, 0);\n-      destmem = adjust_automodify_address_nv (destmem, HImode, destptr, 0);\n+      srcmem = change_address (srcmem, HImode, srcptr);\n+      destmem = change_address (destmem, HImode, destptr);\n       emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n       ix86_adjust_counter (count, 2);\n       emit_label (label);\n@@ -21834,34 +21474,14 @@ expand_movmem_prologue (rtx destmem, rtx srcmem,\n   if (align <= 4 && desired_alignment > 4)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 4, false);\n-      srcmem = adjust_automodify_address_nv (srcmem, SImode, srcptr, 0);\n-      destmem = adjust_automodify_address_nv (destmem, SImode, destptr, 0);\n+      srcmem = change_address (srcmem, SImode, srcptr);\n+      destmem = change_address (destmem, SImode, destptr);\n       emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n       ix86_adjust_counter (count, 4);\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n-  if (align <= 8 && desired_alignment > 8)\n-    {\n-      rtx label = ix86_expand_aligntest (destptr, 8, false);\n-      if (TARGET_64BIT || TARGET_SSE)\n-\t{\n-\t  srcmem = adjust_automodify_address_nv (srcmem, DImode, srcptr, 0);\n-\t  destmem = adjust_automodify_address_nv (destmem, DImode, destptr, 0);\n-\t  emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n-\t}\n-      else\n-\t{\n-\t  srcmem = adjust_automodify_address_nv (srcmem, SImode, srcptr, 0);\n-\t  destmem = adjust_automodify_address_nv (destmem, SImode, destptr, 0);\n-\t  emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n-\t  emit_insn (gen_strmov (destptr, destmem, srcptr, srcmem));\n-\t}\n-      ix86_adjust_counter (count, 8);\n-      emit_label (label);\n-      LABEL_NUSES (label) = 1;\n-    }\n-  gcc_assert (desired_alignment <= 16);\n+  gcc_assert (desired_alignment <= 8);\n }\n \n /* Copy enough from DST to SRC to align DST known to DESIRED_ALIGN.\n@@ -21916,47 +21536,14 @@ expand_constant_movmem_prologue (rtx dst, rtx *srcp, rtx destreg, rtx srcreg,\n       off = 4;\n       emit_insn (gen_strmov (destreg, dst, srcreg, src));\n     }\n-  if (align_bytes & 8)\n-    {\n-      if (TARGET_64BIT || TARGET_SSE)\n-\t{\n-\t  dst = adjust_automodify_address_nv (dst, DImode, destreg, off);\n-\t  src = adjust_automodify_address_nv (src, DImode, srcreg, off);\n-\t  emit_insn (gen_strmov (destreg, dst, srcreg, src));\n-\t}\n-      else\n-\t{\n-\t  dst = adjust_automodify_address_nv (dst, SImode, destreg, off);\n-\t  src = adjust_automodify_address_nv (src, SImode, srcreg, off);\n-\t  emit_insn (gen_strmov (destreg, dst, srcreg, src));\n-\t  emit_insn (gen_strmov (destreg, dst, srcreg, src));\n-\t}\n-      if (MEM_ALIGN (dst) < 8 * BITS_PER_UNIT)\n-\tset_mem_align (dst, 8 * BITS_PER_UNIT);\n-      if (src_align_bytes >= 0)\n-\t{\n-\t  unsigned int src_align = 0;\n-\t  if ((src_align_bytes & 7) == (align_bytes & 7))\n-\t    src_align = 8;\n-\t  else if ((src_align_bytes & 3) == (align_bytes & 3))\n-\t    src_align = 4;\n-\t  else if ((src_align_bytes & 1) == (align_bytes & 1))\n-\t    src_align = 2;\n-\t  if (MEM_ALIGN (src) < src_align * BITS_PER_UNIT)\n-\t    set_mem_align (src, src_align * BITS_PER_UNIT);\n-\t}\n-      off = 8;\n-    }\n   dst = adjust_automodify_address_nv (dst, BLKmode, destreg, off);\n   src = adjust_automodify_address_nv (src, BLKmode, srcreg, off);\n   if (MEM_ALIGN (dst) < (unsigned int) desired_align * BITS_PER_UNIT)\n     set_mem_align (dst, desired_align * BITS_PER_UNIT);\n   if (src_align_bytes >= 0)\n     {\n       unsigned int src_align = 0;\n-      if ((src_align_bytes & 15) == (align_bytes & 15))\n-\tsrc_align = 16;\n-      else if ((src_align_bytes & 7) == (align_bytes & 7))\n+      if ((src_align_bytes & 7) == (align_bytes & 7))\n \tsrc_align = 8;\n       else if ((src_align_bytes & 3) == (align_bytes & 3))\n \tsrc_align = 4;\n@@ -21984,7 +21571,7 @@ expand_setmem_prologue (rtx destmem, rtx destptr, rtx value, rtx count,\n   if (align <= 1 && desired_alignment > 1)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 1, false);\n-      destmem = adjust_automodify_address_nv (destmem, QImode, destptr, 0);\n+      destmem = change_address (destmem, QImode, destptr);\n       emit_insn (gen_strset (destptr, destmem, gen_lowpart (QImode, value)));\n       ix86_adjust_counter (count, 1);\n       emit_label (label);\n@@ -21993,7 +21580,7 @@ expand_setmem_prologue (rtx destmem, rtx destptr, rtx value, rtx count,\n   if (align <= 2 && desired_alignment > 2)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 2, false);\n-      destmem = adjust_automodify_address_nv (destmem, HImode, destptr, 0);\n+      destmem = change_address (destmem, HImode, destptr);\n       emit_insn (gen_strset (destptr, destmem, gen_lowpart (HImode, value)));\n       ix86_adjust_counter (count, 2);\n       emit_label (label);\n@@ -22002,23 +21589,13 @@ expand_setmem_prologue (rtx destmem, rtx destptr, rtx value, rtx count,\n   if (align <= 4 && desired_alignment > 4)\n     {\n       rtx label = ix86_expand_aligntest (destptr, 4, false);\n-      destmem = adjust_automodify_address_nv (destmem, SImode, destptr, 0);\n+      destmem = change_address (destmem, SImode, destptr);\n       emit_insn (gen_strset (destptr, destmem, gen_lowpart (SImode, value)));\n       ix86_adjust_counter (count, 4);\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n     }\n-  if (align <= 8 && desired_alignment > 8)\n-    {\n-      rtx label = ix86_expand_aligntest (destptr, 8, false);\n-      destmem = adjust_automodify_address_nv (destmem, SImode, destptr, 0);\n-      emit_insn (gen_strset (destptr, destmem, gen_lowpart (SImode, value)));\n-      emit_insn (gen_strset (destptr, destmem, gen_lowpart (SImode, value)));\n-      ix86_adjust_counter (count, 8);\n-      emit_label (label);\n-      LABEL_NUSES (label) = 1;\n-    }\n-  gcc_assert (desired_alignment <= 16);\n+  gcc_assert (desired_alignment <= 8);\n }\n \n /* Set enough from DST to align DST known to by aligned by ALIGN to\n@@ -22054,19 +21631,6 @@ expand_constant_setmem_prologue (rtx dst, rtx destreg, rtx value,\n       emit_insn (gen_strset (destreg, dst,\n \t\t\t     gen_lowpart (SImode, value)));\n     }\n-  if (align_bytes & 8)\n-    {\n-      dst = adjust_automodify_address_nv (dst, SImode, destreg, off);\n-      emit_insn (gen_strset (destreg, dst,\n-\t    gen_lowpart (SImode, value)));\n-      off = 4;\n-      dst = adjust_automodify_address_nv (dst, SImode, destreg, off);\n-      emit_insn (gen_strset (destreg, dst,\n-\t    gen_lowpart (SImode, value)));\n-      if (MEM_ALIGN (dst) < 8 * BITS_PER_UNIT)\n-\tset_mem_align (dst, 8 * BITS_PER_UNIT);\n-      off = 4;\n-    }\n   dst = adjust_automodify_address_nv (dst, BLKmode, destreg, off);\n   if (MEM_ALIGN (dst) < (unsigned int) desired_align * BITS_PER_UNIT)\n     set_mem_align (dst, desired_align * BITS_PER_UNIT);\n@@ -22078,7 +21642,7 @@ expand_constant_setmem_prologue (rtx dst, rtx destreg, rtx value,\n /* Given COUNT and EXPECTED_SIZE, decide on codegen of string operation.  */\n static enum stringop_alg\n decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n-\t    int *dynamic_check, bool align_unknown)\n+\t    int *dynamic_check)\n {\n   const struct stringop_algs * algs;\n   bool optimize_for_speed;\n@@ -22087,44 +21651,40 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n      consider such algorithms if the user has appropriated those\n      registers for their own purposes.\t*/\n   bool rep_prefix_usable = !(fixed_regs[CX_REG] || fixed_regs[DI_REG]\n-\t\t\t     || (memset\n+                             || (memset\n \t\t\t\t ? fixed_regs[AX_REG] : fixed_regs[SI_REG]));\n \n-#define ALG_USABLE_P(alg) ((rep_prefix_usable\t\t\t\\\n-\t\t\t    || (alg != rep_prefix_1_byte\t\\\n-\t\t\t        && alg != rep_prefix_4_byte      \\\n-\t\t\t        && alg != rep_prefix_8_byte))    \\\n-\t\t\t   && (TARGET_SSE2 || alg != sse_loop))\n+#define ALG_USABLE_P(alg) (rep_prefix_usable\t\t\t\\\n+\t\t\t   || (alg != rep_prefix_1_byte\t\t\\\n+\t\t\t       && alg != rep_prefix_4_byte      \\\n+\t\t\t       && alg != rep_prefix_8_byte))\n   const struct processor_costs *cost;\n \n   /* Even if the string operation call is cold, we still might spend a lot\n      of time processing large blocks.  */\n   if (optimize_function_for_size_p (cfun)\n       || (optimize_insn_for_size_p ()\n-\t  && expected_size != -1 && expected_size < 256))\n+          && expected_size != -1 && expected_size < 256))\n     optimize_for_speed = false;\n   else\n     optimize_for_speed = true;\n \n-  *dynamic_check = -1;\n-  if (!optimize)\n-    return (rep_prefix_usable ? rep_prefix_1_byte : libcall);\n-\n   cost = optimize_for_speed ? ix86_cost : &ix86_size_cost;\n \n+  *dynamic_check = -1;\n   if (memset)\n-    algs = &cost->memset[align_unknown][TARGET_64BIT != 0];\n+    algs = &cost->memset[TARGET_64BIT != 0];\n   else\n-    algs = &cost->memcpy[align_unknown][TARGET_64BIT != 0];\n+    algs = &cost->memcpy[TARGET_64BIT != 0];\n   if (ix86_stringop_alg != no_stringop && ALG_USABLE_P (ix86_stringop_alg))\n     return ix86_stringop_alg;\n   /* rep; movq or rep; movl is the smallest variant.  */\n   else if (!optimize_for_speed)\n     {\n-      if (!count || (count & 3) || memset)\n-\treturn rep_prefix_usable ? rep_prefix_1_byte : libcall;\n+      if (!count || (count & 3))\n+\treturn rep_prefix_usable ? rep_prefix_1_byte : loop_1_byte;\n       else\n-\treturn rep_prefix_usable ? rep_prefix_4_byte : libcall;\n+\treturn rep_prefix_usable ? rep_prefix_4_byte : loop;\n     }\n   /* Very tiny blocks are best handled via the loop, REP is expensive to setup.\n    */\n@@ -22178,32 +21738,30 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n       int max = -1;\n       enum stringop_alg alg;\n       int i;\n-      bool only_libcall_fits = true;\n+      bool any_alg_usable_p = true;\n \n       for (i = 0; i < MAX_STRINGOP_ALGS; i++)\n-\t{\n-\t  enum stringop_alg candidate = algs->size[i].alg;\n+        {\n+          enum stringop_alg candidate = algs->size[i].alg;\n+          any_alg_usable_p = any_alg_usable_p && ALG_USABLE_P (candidate);\n \n-\t  if (candidate != libcall && candidate\n-\t      && ALG_USABLE_P (candidate))\n-\t    {\n-\t      max = algs->size[i].max;\n-\t      only_libcall_fits = false;\n-\t    }\n-\t}\n+          if (candidate != libcall && candidate\n+              && ALG_USABLE_P (candidate))\n+              max = algs->size[i].max;\n+        }\n       /* If there aren't any usable algorithms, then recursing on\n-\t smaller sizes isn't going to find anything.  Just return the\n-\t simple byte-at-a-time copy loop.  */\n-      if (only_libcall_fits)\n-\t{\n-\t  /* Pick something reasonable.  */\n-\t  if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n-\t    *dynamic_check = 128;\n-\t  return loop_1_byte;\n-\t}\n+         smaller sizes isn't going to find anything.  Just return the\n+         simple byte-at-a-time copy loop.  */\n+      if (!any_alg_usable_p)\n+        {\n+          /* Pick something reasonable.  */\n+          if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n+            *dynamic_check = 128;\n+          return loop_1_byte;\n+        }\n       if (max == -1)\n \tmax = 4096;\n-      alg = decide_alg (count, max / 2, memset, dynamic_check, align_unknown);\n+      alg = decide_alg (count, max / 2, memset, dynamic_check);\n       gcc_assert (*dynamic_check == -1);\n       gcc_assert (alg != libcall);\n       if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n@@ -22227,14 +21785,9 @@ decide_alignment (int align,\n       case no_stringop:\n \tgcc_unreachable ();\n       case loop:\n-\tdesired_align = GET_MODE_SIZE (Pmode);\n-\tbreak;\n       case unrolled_loop:\n \tdesired_align = GET_MODE_SIZE (Pmode);\n \tbreak;\n-      case sse_loop:\n-\tdesired_align = 16;\n-\tbreak;\n       case rep_prefix_8_byte:\n \tdesired_align = 8;\n \tbreak;\n@@ -22322,11 +21875,6 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n   enum stringop_alg alg;\n   int dynamic_check;\n   bool need_zero_guard = false;\n-  bool align_unknown;\n-  unsigned int unroll_factor;\n-  enum machine_mode move_mode;\n-  rtx loop_iter = NULL_RTX;\n-  int dst_offset, src_offset;\n \n   if (CONST_INT_P (align_exp))\n     align = INTVAL (align_exp);\n@@ -22350,17 +21898,9 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n-  dst_offset = get_mem_align_offset (dst, MOVE_MAX*BITS_PER_UNIT);\n-  src_offset = get_mem_align_offset (src, MOVE_MAX*BITS_PER_UNIT);\n-  align_unknown = (dst_offset < 0\n-\t\t   || src_offset < 0\n-\t\t   || src_offset != dst_offset);\n-  alg = decide_alg (count, expected_size, false, &dynamic_check, align_unknown);\n+\n+  alg = decide_alg (count, expected_size, false, &dynamic_check);\n   desired_align = decide_alignment (align, alg, expected_size);\n-  if (align_unknown)\n-    desired_align = align;\n-  unroll_factor = 1;\n-  move_mode = Pmode;\n \n   if (!TARGET_ALIGN_STRINGOPS)\n     align = desired_align;\n@@ -22379,36 +21919,11 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       gcc_unreachable ();\n     case loop:\n       need_zero_guard = true;\n-      move_mode = Pmode;\n-      unroll_factor = 1;\n-      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n+      size_needed = GET_MODE_SIZE (Pmode);\n       break;\n     case unrolled_loop:\n       need_zero_guard = true;\n-      move_mode = Pmode;\n-      unroll_factor = 1;\n-      /* Select maximal available 1,2 or 4 unroll factor.\n-\t In 32bit we can not afford to use 4 registers inside the loop.  */\n-      if (!count)\n-\tunroll_factor = TARGET_64BIT ? 4 : 2;\n-      else\n-\twhile (GET_MODE_SIZE (move_mode) * unroll_factor * 2 < count\n-\t       && unroll_factor < (TARGET_64BIT ? 4 :2))\n-\t  unroll_factor *= 2;\n-      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n-      break;\n-    case sse_loop:\n-      need_zero_guard = true;\n-      /* Use SSE instructions, if possible.  */\n-      move_mode = V4SImode;\n-      /* Select maximal available 1,2 or 4 unroll factor.  */\n-      if (!count)\n-\tunroll_factor = 4;\n-      else\n-\twhile (GET_MODE_SIZE (move_mode) * unroll_factor * 2 < count\n-\t       && unroll_factor < 4)\n-\t  unroll_factor *= 2;\n-      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n+      size_needed = GET_MODE_SIZE (Pmode) * (TARGET_64BIT ? 4 : 2);\n       break;\n     case rep_prefix_8_byte:\n       size_needed = 8;\n@@ -22469,12 +21984,6 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t}\n       else\n \t{\n-\t  /* SSE and unrolled algs re-use iteration counter in the epilogue.  */\n-\t  if (alg == sse_loop || alg == unrolled_loop)\n-\t    {\n-\t      loop_iter = gen_reg_rtx (counter_mode (count_exp));\n-              emit_move_insn (loop_iter, const0_rtx);\n-\t    }\n \t  label = gen_label_rtx ();\n \t  emit_cmp_and_jump_insns (count_exp,\n \t\t\t\t   GEN_INT (epilogue_size_needed),\n@@ -22526,8 +22035,6 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t  dst = change_address (dst, BLKmode, destreg);\n \t  expand_movmem_prologue (dst, src, destreg, srcreg, count_exp, align,\n \t\t\t\t  desired_align);\n-\t  set_mem_align (src, desired_align*BITS_PER_UNIT);\n-\t  set_mem_align (dst, desired_align*BITS_PER_UNIT);\n \t}\n       else\n \t{\n@@ -22584,16 +22091,12 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       expand_set_or_movmem_via_loop (dst, src, destreg, srcreg, NULL,\n \t\t\t\t     count_exp, Pmode, 1, expected_size);\n       break;\n-    case sse_loop:\n     case unrolled_loop:\n-      /* In some cases we want to use the same iterator in several adjacent\n-\t loops, so here we save loop iterator rtx and don't update addresses.  */\n-      loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, src, destreg,\n-\t\t\t\t\t\t\t   srcreg, NULL,\n-\t\t\t\t\t\t\t   count_exp, loop_iter,\n-\t\t\t\t\t\t\t   move_mode,\n-\t\t\t\t\t\t\t   unroll_factor,\n-\t\t\t\t\t\t\t   expected_size, false);\n+      /* Unroll only by factor of 2 in 32bit mode, since we don't have enough\n+\t registers for 4 temporaries anyway.  */\n+      expand_set_or_movmem_via_loop (dst, src, destreg, srcreg, NULL,\n+\t\t\t\t     count_exp, Pmode, TARGET_64BIT ? 4 : 2,\n+\t\t\t\t     expected_size);\n       break;\n     case rep_prefix_8_byte:\n       expand_movmem_via_rep_mov (dst, src, destreg, srcreg, count_exp,\n@@ -22644,47 +22147,9 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       LABEL_NUSES (label) = 1;\n     }\n \n-  /* We haven't updated addresses, so we'll do it now.\n-     Also, if the epilogue seems to be big, we'll generate a loop (not\n-     unrolled) in it.  We'll do it only if alignment is unknown, because in\n-     this case in epilogue we have to perform memmove by bytes, which is very\n-     slow.  */\n-  if (alg == sse_loop || alg == unrolled_loop)\n-    {\n-      rtx tmp;\n-      int remainder_size = epilogue_size_needed;\n-\n-      /* We may not need the epilgoue loop at all when the count is known\n-\t and alignment is not adjusted.  */\n-      if (count && desired_align <= align)\n-\tremainder_size = count % epilogue_size_needed;\n-      if (remainder_size > 31)\n-\t{\n-\t  /* Reduce epilogue's size by creating not-unrolled loop.  If we won't\n-\t     do this, we can have very big epilogue - when alignment is statically\n-\t     unknown we'll have the epilogue byte by byte which may be very slow.  */\n-\t  loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, src, destreg,\n-\t      srcreg, NULL, count_exp,\n-\t      loop_iter, move_mode, 1,\n-\t      expected_size, false);\n-\t  src = change_address (src, BLKmode, srcreg);\n-\t  dst = change_address (dst, BLKmode, destreg);\n-\t  epilogue_size_needed = GET_MODE_SIZE (move_mode);\n-\t}\n-      tmp = expand_simple_binop (Pmode, PLUS, destreg, loop_iter, destreg,\n-\t\t\t       true, OPTAB_LIB_WIDEN);\n-      if (tmp != destreg)\n-\temit_move_insn (destreg, tmp);\n-\n-      tmp = expand_simple_binop (Pmode, PLUS, srcreg, loop_iter, srcreg,\n-\t\t\t       true, OPTAB_LIB_WIDEN);\n-      if (tmp != srcreg)\n-\temit_move_insn (srcreg, tmp);\n-    }\n   if (count_exp != const0_rtx && epilogue_size_needed > 1)\n     expand_movmem_epilogue (dst, src, destreg, srcreg, count_exp,\n \t\t\t    epilogue_size_needed);\n-\n   if (jump_around_label)\n     emit_label (jump_around_label);\n   return true;\n@@ -22702,37 +22167,7 @@ promote_duplicated_reg (enum machine_mode mode, rtx val)\n   rtx tmp;\n   int nops = mode == DImode ? 3 : 2;\n \n-  if (VECTOR_MODE_P (mode))\n-    {\n-      enum machine_mode inner = GET_MODE_INNER (mode);\n-      rtx promoted_val, vec_reg;\n-      if (CONST_INT_P (val))\n-\treturn ix86_build_const_vector (mode, true, val);\n-\n-      promoted_val = promote_duplicated_reg (inner, val);\n-      vec_reg = gen_reg_rtx (mode);\n-      switch (mode)\n-\t{\n-\tcase V2DImode:\n-\t  emit_insn (gen_vec_dupv2di (vec_reg, promoted_val));\n-\t  break;\n-\tcase V4SImode:\n-\t  emit_insn (gen_vec_dupv4si (vec_reg, promoted_val));\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t  break;\n-\t}\n-\n-      return vec_reg;\n-    }\n   gcc_assert (mode == SImode || mode == DImode);\n-  if (mode == DImode && !TARGET_64BIT)\n-    {\n-      rtx vec_reg = promote_duplicated_reg (V4SImode, val);\n-      vec_reg = convert_to_mode (V2DImode, vec_reg, 1);\n-      return vec_reg;\n-    }\n   if (val == const0_rtx)\n     return copy_to_mode_reg (mode, const0_rtx);\n   if (CONST_INT_P (val))\n@@ -22798,27 +22233,11 @@ promote_duplicated_reg (enum machine_mode mode, rtx val)\n static rtx\n promote_duplicated_reg_to_size (rtx val, int size_needed, int desired_align, int align)\n {\n-  rtx promoted_val = NULL_RTX;\n+  rtx promoted_val;\n \n-  if (size_needed > 8)\n-    {\n-      /* We want to promote to vector register, so we expect that at least SSE\n-\t is available.  */\n-      gcc_assert (TARGET_SSE);\n-\n-      /* In case of promotion to vector register, we expect that val is a\n-\t constant or already promoted to GPR value.  */\n-      gcc_assert (GET_MODE (val) == Pmode || CONSTANT_P (val));\n-      if (TARGET_64BIT)\n-\tpromoted_val = promote_duplicated_reg (V2DImode, val);\n-      else\n-\tpromoted_val = promote_duplicated_reg (V4SImode, val);\n-    }\n-  else if (size_needed > 4)\n-    {\n-      gcc_assert (TARGET_64BIT);\n-      promoted_val = promote_duplicated_reg (DImode, val);\n-    }\n+  if (TARGET_64BIT\n+      && (size_needed > 4 || (desired_align > align && desired_align > 4)))\n+    promoted_val = promote_duplicated_reg (DImode, val);\n   else if (size_needed > 2 || (desired_align > align && desired_align > 2))\n     promoted_val = promote_duplicated_reg (SImode, val);\n   else if (size_needed > 1 || (desired_align > align && desired_align > 1))\n@@ -22846,15 +22265,10 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   int size_needed = 0, epilogue_size_needed;\n   int desired_align = 0, align_bytes = 0;\n   enum stringop_alg alg;\n-  rtx gpr_promoted_val = NULL;\n-  rtx vec_promoted_val = NULL;\n+  rtx promoted_val = NULL;\n+  bool force_loopy_epilogue = false;\n   int dynamic_check;\n   bool need_zero_guard = false;\n-  bool align_unknown;\n-  unsigned int unroll_factor;\n-  enum machine_mode move_mode;\n-  rtx loop_iter = NULL_RTX;\n-  bool early_jump = false;\n \n   if (CONST_INT_P (align_exp))\n     align = INTVAL (align_exp);\n@@ -22874,11 +22288,8 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n \n-  align_unknown = !(CONST_INT_P (align_exp) && INTVAL (align_exp) > 0);\n-  alg = decide_alg (count, expected_size, true, &dynamic_check, align_unknown);\n+  alg = decide_alg (count, expected_size, true, &dynamic_check);\n   desired_align = decide_alignment (align, alg, expected_size);\n-  unroll_factor = 1;\n-  move_mode = Pmode;\n \n   if (!TARGET_ALIGN_STRINGOPS)\n     align = desired_align;\n@@ -22896,34 +22307,11 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n       gcc_unreachable ();\n     case loop:\n       need_zero_guard = true;\n-      move_mode = Pmode;\n-      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n+      size_needed = GET_MODE_SIZE (Pmode);\n       break;\n     case unrolled_loop:\n       need_zero_guard = true;\n-      move_mode = Pmode;\n-      unroll_factor = 1;\n-      /* Select maximal available 1,2 or 4 unroll factor.  */\n-      if (!count)\n-\tunroll_factor = 4;\n-      else\n-\twhile (GET_MODE_SIZE (move_mode) * unroll_factor * 2 < count\n-\t       && unroll_factor < 4)\n-\t  unroll_factor *= 2;\n-      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n-      break;\n-    case sse_loop:\n-      need_zero_guard = true;\n-      move_mode = TARGET_64BIT ? V2DImode : V4SImode;\n-      unroll_factor = 1;\n-      /* Select maximal available 1,2 or 4 unroll factor.  */\n-      if (!count)\n-\tunroll_factor = 4;\n-      else\n-\twhile (GET_MODE_SIZE (move_mode) * unroll_factor * 2 < count\n-\t       && unroll_factor < 4)\n-\t  unroll_factor *= 2;\n-      size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n+      size_needed = GET_MODE_SIZE (Pmode) * 4;\n       break;\n     case rep_prefix_8_byte:\n       size_needed = 8;\n@@ -22968,10 +22356,8 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n      main loop and epilogue (ie one load of the big constant in the\n      front of all code.  */\n   if (CONST_INT_P (val_exp))\n-    gpr_promoted_val = promote_duplicated_reg_to_size (val_exp,\n-\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n-\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n-\t\t\t\t\t\t   align);\n+    promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n+\t\t\t\t\t\t   desired_align, align);\n   /* Ensure that alignment prologue won't copy past end of block.  */\n   if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n     {\n@@ -22980,6 +22366,12 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t Make sure it is power of 2.  */\n       epilogue_size_needed = smallest_pow2_greater_than (epilogue_size_needed);\n \n+      /* To improve performance of small blocks, we jump around the VAL\n+\t promoting mode.  This mean that if the promoted VAL is not constant,\n+\t we might not use it in the epilogue and have to use byte\n+\t loop variant.  */\n+      if (epilogue_size_needed > 2 && !promoted_val)\n+        force_loopy_epilogue = true;\n       if (count)\n \t{\n \t  if (count < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n@@ -22994,14 +22386,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t}\n       else\n \t{\n-\t  /* SSE and unrolled_lopo algs re-use iteration counter in the epilogue.  */\n-\t  if (alg == sse_loop || alg == unrolled_loop)\n-\t    {\n-\t      loop_iter = gen_reg_rtx (counter_mode (count_exp));\n-              emit_move_insn (loop_iter, const0_rtx);\n-\t    }\n \t  label = gen_label_rtx ();\n-\t  early_jump = true;\n \t  emit_cmp_and_jump_insns (count_exp,\n \t\t\t\t   GEN_INT (epilogue_size_needed),\n \t\t\t\t   LTU, 0, counter_mode (count_exp), 1, label);\n@@ -23026,11 +22411,9 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   /* Step 2: Alignment prologue.  */\n \n   /* Do the expensive promotion once we branched off the small blocks.  */\n-  if (!gpr_promoted_val)\n-    gpr_promoted_val = promote_duplicated_reg_to_size (val_exp,\n-\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n-\t\t\t\t\t\t   GET_MODE_SIZE (Pmode),\n-\t\t\t\t\t\t   align);\n+  if (!promoted_val)\n+    promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n+\t\t\t\t\t\t   desired_align, align);\n   gcc_assert (desired_align >= 1 && align >= 1);\n \n   if (desired_align > align)\n@@ -23042,20 +22425,17 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t     the pain to maintain it for the first move, so throw away\n \t     the info early.  */\n \t  dst = change_address (dst, BLKmode, destreg);\n-\t  expand_setmem_prologue (dst, destreg, gpr_promoted_val, count_exp, align,\n+\t  expand_setmem_prologue (dst, destreg, promoted_val, count_exp, align,\n \t\t\t\t  desired_align);\n-\t  set_mem_align (dst, desired_align*BITS_PER_UNIT);\n \t}\n       else\n \t{\n \t  /* If we know how many bytes need to be stored before dst is\n \t     sufficiently aligned, maintain aliasing info accurately.  */\n-\t  dst = expand_constant_setmem_prologue (dst, destreg, gpr_promoted_val,\n+\t  dst = expand_constant_setmem_prologue (dst, destreg, promoted_val,\n \t\t\t\t\t\t desired_align, align_bytes);\n \t  count_exp = plus_constant (count_exp, -align_bytes);\n \t  count -= align_bytes;\n-\t  if (count < (unsigned HOST_WIDE_INT) size_needed)\n-\t    goto epilogue;\n \t}\n       if (need_zero_guard\n \t  && (count < (unsigned HOST_WIDE_INT) size_needed\n@@ -23083,7 +22463,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n       label = NULL;\n-      gpr_promoted_val = val_exp;\n+      promoted_val = val_exp;\n       epilogue_size_needed = 1;\n     }\n   else if (label == NULL_RTX)\n@@ -23097,40 +22477,27 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n     case no_stringop:\n       gcc_unreachable ();\n     case loop_1_byte:\n-      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, val_exp,\n+      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, promoted_val,\n \t\t\t\t     count_exp, QImode, 1, expected_size);\n       break;\n     case loop:\n-      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, gpr_promoted_val,\n+      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, promoted_val,\n \t\t\t\t     count_exp, Pmode, 1, expected_size);\n       break;\n     case unrolled_loop:\n-      loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, NULL, destreg,\n-\t\t\t\t     NULL, gpr_promoted_val, count_exp,\n-\t\t\t\t     loop_iter, move_mode, unroll_factor,\n-\t\t\t\t     expected_size, false);\n-      break;\n-    case sse_loop:\n-      vec_promoted_val =\n-\tpromote_duplicated_reg_to_size (gpr_promoted_val,\n-\t\t\t\t\tGET_MODE_SIZE (move_mode),\n-\t\t\t\t\tGET_MODE_SIZE (move_mode), align);\n-      loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, NULL, destreg,\n-\t\t\t\t     NULL, vec_promoted_val, count_exp,\n-\t\t\t\t     loop_iter, move_mode, unroll_factor,\n-\t\t\t\t     expected_size, false);\n+      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, promoted_val,\n+\t\t\t\t     count_exp, Pmode, 4, expected_size);\n       break;\n     case rep_prefix_8_byte:\n-      gcc_assert (TARGET_64BIT);\n-      expand_setmem_via_rep_stos (dst, destreg, gpr_promoted_val, count_exp,\n+      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n \t\t\t\t  DImode, val_exp);\n       break;\n     case rep_prefix_4_byte:\n-      expand_setmem_via_rep_stos (dst, destreg, gpr_promoted_val, count_exp,\n+      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n \t\t\t\t  SImode, val_exp);\n       break;\n     case rep_prefix_1_byte:\n-      expand_setmem_via_rep_stos (dst, destreg, gpr_promoted_val, count_exp,\n+      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n \t\t\t\t  QImode, val_exp);\n       break;\n     }\n@@ -23161,46 +22528,17 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t}\n       emit_label (label);\n       LABEL_NUSES (label) = 1;\n-      /* We can not rely on fact that promoved value is known.  */\n-      vec_promoted_val = 0;\n-      if (early_jump)\n-        gpr_promoted_val = 0;\n     }\n  epilogue:\n-  if (alg == unrolled_loop || alg == sse_loop)\n+  if (count_exp != const0_rtx && epilogue_size_needed > 1)\n     {\n-      rtx tmp;\n-      int remainder_size = epilogue_size_needed;\n-      if (count && desired_align <= align)\n-\tremainder_size = count % epilogue_size_needed;\n-      /* We may not need the epilgoue loop at all when the count is known\n-\t and alignment is not adjusted.  */\n-      if (remainder_size > 31 \n-\t  && (alg == sse_loop ? vec_promoted_val : gpr_promoted_val))\n-\t{\n-\t  /* Reduce epilogue's size by creating not-unrolled loop.  If we won't\n-\t     do this, we can have very big epilogue - when alignment is statically\n-\t     unknown we'll have the epilogue byte by byte which may be very slow.  */\n-\t  loop_iter = expand_set_or_movmem_via_loop_with_iter (dst, NULL, destreg,\n-\t      NULL, (alg == sse_loop ? vec_promoted_val : gpr_promoted_val), count_exp,\n-\t      loop_iter, move_mode, 1,\n-\t      expected_size, false);\n-\t  dst = change_address (dst, BLKmode, destreg);\n-\t  epilogue_size_needed = GET_MODE_SIZE (move_mode);\n-\t}\n-      tmp = expand_simple_binop (Pmode, PLUS, destreg, loop_iter, destreg,\n-\t\t\t       true, OPTAB_LIB_WIDEN);\n-      if (tmp != destreg)\n-\temit_move_insn (destreg, tmp);\n+      if (force_loopy_epilogue)\n+\texpand_setmem_epilogue_via_loop (dst, destreg, val_exp, count_exp,\n+\t\t\t\t\t epilogue_size_needed);\n+      else\n+\texpand_setmem_epilogue (dst, destreg, promoted_val, count_exp,\n+\t\t\t\tepilogue_size_needed);\n     }\n-  if (count_exp == const0_rtx || epilogue_size_needed <= 1)\n-    ;\n-  else if (!gpr_promoted_val)\n-    expand_setmem_epilogue_via_loop (dst, destreg, val_exp, count_exp,\n-\t\t\t\t     epilogue_size_needed);\n-  else\n-    expand_setmem_epilogue (dst, destreg, vec_promoted_val, gpr_promoted_val,\n-\t\t\t    val_exp, count_exp, epilogue_size_needed);\n   if (jump_around_label)\n     emit_label (jump_around_label);\n   return true;"}, {"sha": "7721c4658329085fea7d545eff33b71ffa6b7299", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "patch": "@@ -159,12 +159,8 @@ struct processor_costs {\n   const int fchs;\t\t/* cost of FCHS instruction.  */\n   const int fsqrt;\t\t/* cost of FSQRT instruction.  */\n \t\t\t\t/* Specify what algorithm\n-\t\t\t\t   to use for stringops on unknown size.\n-\t\t\t\t   First index is used to specify whether\n-\t\t\t\t   alignment is known or not.\n-\t\t\t\t   Second - to specify whether 32 or 64 bits\n-\t\t\t\t   are used.  */\n-  struct stringop_algs memcpy[2][2], memset[2][2];\n+\t\t\t\t   to use for stringops on unknown size.  */\n+  struct stringop_algs memcpy[2], memset[2];\n   const int scalar_stmt_cost;   /* Cost of any scalar operation, excluding\n \t\t\t\t   load and store.  */\n   const int scalar_load_cost;   /* Cost of scalar load.  */"}, {"sha": "6c516e7b8695f3bef761f3d1c239deccc75bba71", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "patch": "@@ -324,9 +324,6 @@ Enum(stringop_alg) String(loop) Value(loop)\n EnumValue\n Enum(stringop_alg) String(unrolled_loop) Value(unrolled_loop)\n \n-EnumValue\n-Enum(stringop_alg) String(sse_loop) Value(sse_loop)\n-\n mtls-dialect=\n Target RejectNegative Joined Var(ix86_tls_dialect) Enum(tls_dialect) Init(TLS_DIALECT_GNU)\n Use given thread-local storage dialect"}, {"sha": "8c434b79bb815987e80cf8435bf3456a17d3ea95", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "patch": "@@ -7616,16 +7616,6 @@\n    (set_attr \"prefix\" \"maybe_vex,orig,vex,maybe_vex,orig,orig\")\n    (set_attr \"mode\" \"V2SF,TI,TI,TI,V4SF,V2SF\")])\n \n-(define_expand \"vec_dupv4si\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n-\t(vec_duplicate:V4SI\n-\t  (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_SSE\"\n-{\n-  if (!TARGET_AVX)\n-    operands[1] = force_reg (V4SImode, operands[1]);\n-})\n-\n (define_insn \"*vec_dupv4si\"\n   [(set (match_operand:V4SI 0 \"register_operand\"     \"=x,x,x\")\n \t(vec_duplicate:V4SI\n@@ -7642,16 +7632,6 @@\n    (set_attr \"prefix\" \"maybe_vex,vex,orig\")\n    (set_attr \"mode\" \"TI,V4SF,V4SF\")])\n \n-(define_expand \"vec_dupv2di\"\n-  [(set (match_operand:V2DI 0 \"register_operand\" \"\")\n-\t(vec_duplicate:V2DI\n-\t  (match_operand:DI 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_SSE\"\n-{\n-  if (!TARGET_AVX)\n-    operands[1] = force_reg (V2DImode, operands[1]);\n-})\n-\n (define_insn \"*vec_dupv2di\"\n   [(set (match_operand:V2DI 0 \"register_operand\"     \"=x,x,x,x\")\n \t(vec_duplicate:V2DI"}, {"sha": "e162c0b04398d3852b058300895aa429e9000532", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "patch": "@@ -1,3 +1,8 @@\n+2011-11-24  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/51134\n+\t* gcc.target/i386/sw-1.c: Revert revision 181357.\n+\n 2011-11-24  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51218"}, {"sha": "483d117ecb73d757c210a0806de13cd840011179", "filename": "gcc/testsuite/gcc.target/i386/sw-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c?ref=bee51209f65f0d80bc8cfd7a494d1d6c4f730c2b", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fshrink-wrap -fdump-rtl-pro_and_epilogue -mstringop-strategy=rep_byte\" } */\n+/* { dg-options \"-O2 -fshrink-wrap -fdump-rtl-pro_and_epilogue\" } */\n \n #include <string.h>\n "}]}