{"sha": "21c58af545af192f00d6242179ff41f0bba47d6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFjNThhZjU0NWFmMTkyZjAwZDYyNDIxNzlmZjQxZjBiYmE0N2Q2Yg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2004-12-29T13:20:35Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-12-29T13:20:35Z"}, "message": "re PR tree-optimization/18179 (vectorizer: wrong alignment/step/initial-address computed for struct accesses)\n\n2004-12-29  Ira Rosen  <irar@il.ibm.com>\n\n        PR tree-optimization/18179\n        * tree-vectorizer.c (vect_get_base_and_offset): Rename (previous name\n        vect_get_base_and_bit_offset).\n        (vect_get_memtag_and_dr): Rename (previous name vect_get_symbl_and_dr).\n\nFrom-SVN: r92702", "tree": {"sha": "223a5b217d26544e30dc770da3e95f6a76668653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/223a5b217d26544e30dc770da3e95f6a76668653"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21c58af545af192f00d6242179ff41f0bba47d6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c58af545af192f00d6242179ff41f0bba47d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21c58af545af192f00d6242179ff41f0bba47d6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c58af545af192f00d6242179ff41f0bba47d6b/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1de6a873129a16012941fb75d8c2a1bbde736690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de6a873129a16012941fb75d8c2a1bbde736690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de6a873129a16012941fb75d8c2a1bbde736690"}], "stats": {"total": 54, "additions": 30, "deletions": 24}, "files": [{"sha": "f27b5717573f50ca26a891d0a7929e375a952ff6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c58af545af192f00d6242179ff41f0bba47d6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c58af545af192f00d6242179ff41f0bba47d6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21c58af545af192f00d6242179ff41f0bba47d6b", "patch": "@@ -1,3 +1,10 @@\n+2004-12-29  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/18179\n+\t* tree-vectorizer.c (vect_get_base_and_offset): Rename (previous name\n+\tvect_get_base_and_bit_offset).\n+\t(vect_get_memtag_and_dr): Rename (previous name vect_get_symbl_and_dr).\n+\n 2004-12-29  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/18179"}, {"sha": "53b34dd8afe149abc69af4a59287820ff5ccb417", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c58af545af192f00d6242179ff41f0bba47d6b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c58af545af192f00d6242179ff41f0bba47d6b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=21c58af545af192f00d6242179ff41f0bba47d6b", "patch": "@@ -222,15 +222,15 @@ static bool vect_can_force_dr_alignment_p (tree, unsigned int);\n static struct data_reference * vect_analyze_pointer_ref_access \n   (tree, tree, bool);\n static bool vect_can_advance_ivs_p (struct loop *);\n-static tree vect_get_base_and_bit_offset\n+static tree vect_get_base_and_offset\n   (struct data_reference *, tree, tree, loop_vec_info, tree *, bool*);\n static struct data_reference * vect_analyze_pointer_ref_access\n   (tree, tree, bool);\n static tree vect_compute_array_base_alignment (tree, tree, tree *, tree *);\n static tree vect_compute_array_ref_alignment\n   (struct data_reference *, loop_vec_info, tree, tree *);\n static tree vect_get_ptr_offset (tree, tree, tree *);\n-static tree vect_get_symbl_and_dr\n+static tree vect_get_memtag_and_dr\n   (tree, tree, bool, loop_vec_info, struct data_reference **);\n static bool vect_analyze_offset_expr (tree, struct loop *, tree, tree *, \n \t\t\t\t      tree *, tree *);\n@@ -1527,7 +1527,7 @@ vect_analyze_offset_expr (tree expr,\n }\n \n \n-/* Function vect_get_base_and_bit_offset\n+/* Function vect_get_base_and_offset\n \n    Return the BASE of the data reference EXPR.\n    If VECTYPE is given, also compute the OFFSET from BASE in bits.\n@@ -1553,12 +1553,12 @@ vect_analyze_offset_expr (tree expr,\n    then NULL_TREE is returned.  */\n \n static tree \n-vect_get_base_and_bit_offset (struct data_reference *dr, \n-\t\t\t      tree expr, \n-\t\t\t      tree vectype, \n-\t\t\t      loop_vec_info loop_vinfo,\n-\t\t\t      tree *offset,\n-\t\t\t      bool *base_aligned_p)\n+vect_get_base_and_offset (struct data_reference *dr, \n+\t\t\t  tree expr, \n+\t\t\t  tree vectype, \n+\t\t\t  loop_vec_info loop_vinfo,\n+\t\t\t  tree *offset,\n+\t\t\t  bool *base_aligned_p)\n {\n   tree this_offset = size_zero_node;\n   tree base = NULL_TREE;\n@@ -1656,11 +1656,11 @@ vect_get_base_and_bit_offset (struct data_reference *dr,\n     case MINUS_EXPR:\n       /* In case we have a PLUS_EXPR of the form\n \t (oprnd0 + oprnd1), we assume that only oprnd0 determines the base. \n-\t This is verified in  vect_get_symbl_and_dr.  */ \n+\t This is verified in  vect_get_memtag_and_dr.  */ \n       oprnd0 = TREE_OPERAND (expr, 0);\n       oprnd1 = TREE_OPERAND (expr, 1);\n \n-      base = vect_get_base_and_bit_offset \n+      base = vect_get_base_and_offset \n \t(dr, oprnd1, vectype, loop_vinfo, &this_offset, base_aligned_p);  \n       if (vectype && !base) \n \treturn NULL_TREE;\n@@ -1672,8 +1672,8 @@ vect_get_base_and_bit_offset (struct data_reference *dr,\n       return NULL_TREE;\n     }\n \n-  base = vect_get_base_and_bit_offset (dr, next_ref, vectype, \n-\t\t\t\t       loop_vinfo, offset, base_aligned_p);  \n+  base = vect_get_base_and_offset (dr, next_ref, vectype, \n+\t\t\t\t   loop_vinfo, offset, base_aligned_p);  \n \n   if (vectype && base)\n     {\n@@ -4303,7 +4303,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr,\n   else\n     dr_base = STMT_VINFO_VECT_DR_BASE (stmt_info);\n \n-  base = vect_get_base_and_bit_offset (dr, dr_base, vectype, \n+  base = vect_get_base_and_offset (dr, dr_base, vectype, \n \t\t\t  loop_vinfo, &bit_offset, &base_aligned_p);\n   if (!base)\n     {\n@@ -4946,17 +4946,16 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n }\n \n \n-/* Function vect_get_symbl_and_dr.  \n+/* Function vect_get_memtag_and_dr.  \n \n-   The function returns SYMBL - the relevant variable for\n-   memory tag (for aliasing purposes). \n-   Also data reference structure DR is created.  \n+   The function returns the relevant variable for memory tag (for aliasing \n+   purposes). Also data reference structure DR is created.  \n \n    This function handles three kinds of MEMREF:\n \n    It is called from vect_analyze_data_refs with a MEMREF that is either an \n    ARRAY_REF or an INDIRECT_REF (this is category 1 - \"recursion begins\"). \n-   It builds a DR for them using vect_get_base_and_bit_offset, and calls itself \n+   It builds a DR for them using vect_get_base_and_offset, and calls itself \n    recursively to retrieve the relevant memtag for the MEMREF, \"peeling\" the \n    MEMREF along the way. During the recursive calls, the function may be called \n    with a MEMREF for which the recursion has to continue - PLUS_EXPR, \n@@ -4980,8 +4979,8 @@ vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read)\n */ \n \n static tree\n-vect_get_symbl_and_dr (tree memref, tree stmt, bool is_read, \n-\t\t       loop_vec_info loop_vinfo, struct data_reference **dr)\n+vect_get_memtag_and_dr (tree memref, tree stmt, bool is_read, \n+\t\t\tloop_vec_info loop_vinfo, struct data_reference **dr)\n {\n   tree symbl, oprnd0, oprnd1;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -5033,7 +5032,7 @@ vect_get_symbl_and_dr (tree memref, tree stmt, bool is_read,\n \t  /* Fall through.  */\n \t\n \tcase ADDR_EXPR:\n-\t  symbl = vect_get_base_and_bit_offset ((*dr), memref, NULL_TREE, \n+\t  symbl = vect_get_base_and_offset ((*dr), memref, NULL_TREE, \n \t\t\t\t\tloop_vinfo, &offset, &base_aligned_p);\n \t  break; /* For recursive call.  */\n \n@@ -5096,7 +5095,7 @@ vect_get_symbl_and_dr (tree memref, tree stmt, bool is_read,\n   if (!symbl)\n      return NULL_TREE;\n   /* Recursive call to retrieve the relevant memtag.  */\n-  tag = vect_get_symbl_and_dr (symbl, stmt, is_read, loop_vinfo, dr);\n+  tag = vect_get_memtag_and_dr (symbl, stmt, is_read, loop_vinfo, dr);\n   return tag;\n }\n \n@@ -5185,7 +5184,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t     struct for it (DR) and find the relevant symbol for aliasing \n \t     purposes.  */\n \t  dr = NULL;\n-\t  symbl = vect_get_symbl_and_dr (memref, stmt, is_read, loop_vinfo, \n+\t  symbl = vect_get_memtag_and_dr (memref, stmt, is_read, loop_vinfo, \n \t\t\t\t\t &dr);\n \t  if (!symbl)\n \t    {"}]}