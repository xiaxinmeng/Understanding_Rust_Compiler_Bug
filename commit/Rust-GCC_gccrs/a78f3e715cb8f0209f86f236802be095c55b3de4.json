{"sha": "a78f3e715cb8f0209f86f236802be095c55b3de4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc4ZjNlNzE1Y2I4ZjAyMDlmODZmMjM2ODAyYmUwOTVjNTViM2RlNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-04-05T16:52:26Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-04-05T16:52:26Z"}, "message": "regmove.c (STACK_GROWS_DOWNWARD): Don't boolean-ize.\n\n\t* regmove.c (STACK_GROWS_DOWNWARD): Don't boolean-ize.\n\t(regmove_bb_head): Remove.\n\t(copy_src_to_dest): Don't update regmove_bb_head and BB_HEAD.\n\t(regmove_optimize): Don't do unnecessary CFG fixes for non-existing\n\tproblems with fixup_match_1.\n\tDon't initialize/free regmove_bb_head.\n\n\t(reg_is_remote_constant_p): If an insn is in the same basic block\n\tbut not before INSN, consider it remote, too.\n\nFrom-SVN: r123522", "tree": {"sha": "52736631d5c10fcdfd50b2d47b400fd06fb80ffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52736631d5c10fcdfd50b2d47b400fd06fb80ffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a78f3e715cb8f0209f86f236802be095c55b3de4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78f3e715cb8f0209f86f236802be095c55b3de4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a78f3e715cb8f0209f86f236802be095c55b3de4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78f3e715cb8f0209f86f236802be095c55b3de4/comments", "author": null, "committer": null, "parents": [{"sha": "f9ca0dee6d8f15c4bfccc0ccd2f7fbc7b7bf287f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9ca0dee6d8f15c4bfccc0ccd2f7fbc7b7bf287f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9ca0dee6d8f15c4bfccc0ccd2f7fbc7b7bf287f"}], "stats": {"total": 114, "additions": 35, "deletions": 79}, "files": [{"sha": "012ecd1a151f7ea187865b20aed20036d9343d2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78f3e715cb8f0209f86f236802be095c55b3de4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78f3e715cb8f0209f86f236802be095c55b3de4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a78f3e715cb8f0209f86f236802be095c55b3de4", "patch": "@@ -1,3 +1,15 @@\n+2007-04-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* regmove.c (STACK_GROWS_DOWNWARD): Don't boolean-ize.\n+\t(regmove_bb_head): Remove.\n+\t(copy_src_to_dest): Don't update regmove_bb_head and BB_HEAD.\n+\t(regmove_optimize): Don't do unnecessary CFG fixes for non-existing\n+\tproblems with fixup_match_1.\n+\tDon't initialize/free regmove_bb_head.\n+\n+\t(reg_is_remote_constant_p): If an insn is in the same basic block\n+\tbut not before INSN, consider it remote, too.\n+\n 2007-04-05  Anatoly Sokolov <aesok@post.ru>\n \n \tPR target/25448"}, {"sha": "416c9509392b1354ea29853a8f32369e0da02ae7", "filename": "gcc/regmove.c", "status": "modified", "additions": 23, "deletions": 79, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78f3e715cb8f0209f86f236802be095c55b3de4/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78f3e715cb8f0209f86f236802be095c55b3de4/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=a78f3e715cb8f0209f86f236802be095c55b3de4", "patch": "@@ -47,20 +47,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-pass.h\"\n \n \n-/* Turn STACK_GROWS_DOWNWARD into a boolean.  */\n-#ifdef STACK_GROWS_DOWNWARD\n-#undef STACK_GROWS_DOWNWARD\n-#define STACK_GROWS_DOWNWARD 1\n-#else\n-#define STACK_GROWS_DOWNWARD 0\n-#endif\n-\n static int perhaps_ends_bb_p (rtx);\n static int optimize_reg_copy_1 (rtx, rtx, rtx);\n static void optimize_reg_copy_2 (rtx, rtx, rtx);\n static void optimize_reg_copy_3 (rtx, rtx, rtx);\n-static void copy_src_to_dest (rtx, rtx, rtx, int);\n-static int *regmove_bb_head;\n+static void copy_src_to_dest (rtx, rtx, rtx);\n \n struct match {\n   int with[MAX_RECOG_OPERANDS];\n@@ -737,7 +728,7 @@ optimize_reg_copy_3 (rtx insn, rtx dest, rtx src)\n    instead moving the value to dest directly before the operation.  */\n \n static void\n-copy_src_to_dest (rtx insn, rtx src, rtx dest, int old_max_uid)\n+copy_src_to_dest (rtx insn, rtx src, rtx dest)\n {\n   rtx seq;\n   rtx link;\n@@ -806,18 +797,8 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest, int old_max_uid)\n       *p_move_notes = NULL_RTX;\n       *p_insn_notes = NULL_RTX;\n \n-      /* Is the insn the head of a basic block?  If so extend it.  */\n       insn_uid = INSN_UID (insn);\n       move_uid = INSN_UID (move_insn);\n-      if (insn_uid < old_max_uid)\n-\t{\n-\t  bb = regmove_bb_head[insn_uid];\n-\t  if (bb >= 0)\n-\t    {\n-\t      BB_HEAD (BASIC_BLOCK (bb)) = move_insn;\n-\t      regmove_bb_head[insn_uid] = -1;\n-\t    }\n-\t}\n \n       /* Update the various register tables.  */\n       dest_regno = REGNO (dest);\n@@ -854,8 +835,7 @@ static unsigned int max_reg_computed;\n    may increase register pressure and make reload harder.  If REG is\n    set in the same basic block as INSN, we don't worry about it,\n    because we'll probably need a register anyhow (??? but what if REG\n-   is used in a different basic block as well as this one?).  FIRST is\n-   the first insn in the function.  */\n+   is used in a different basic block as well as this one?).  */\n \n static bool\n reg_is_remote_constant_p (rtx reg, rtx insn)\n@@ -870,44 +850,27 @@ reg_is_remote_constant_p (rtx reg, rtx insn)\n       reg_set_in_bb = xcalloc (max, sizeof (*reg_set_in_bb));\n \n       FOR_EACH_BB (bb)\n-\tfor (p = BB_HEAD (bb); p != NEXT_INSN (BB_END (bb));\n-\t     p = NEXT_INSN (p))\n-\t{\n-\t  rtx s;\n-\n-\t  if (!INSN_P (p))\n-\t    continue;\n-\t  s = single_set (p);\n-\t  /* This is the instruction which sets REG.  If there is a\n-\t     REG_EQUAL note, then REG is equivalent to a constant.  */\n-\t  if (s != 0\n-\t      && REG_P (SET_DEST (s))\n-\t      && REG_N_SETS (REGNO (SET_DEST (s))) == 1\n-\t      && find_reg_note (p, REG_EQUAL, NULL_RTX))\n-\t    reg_set_in_bb[REGNO (SET_DEST (s))] = bb;\n-\t}\n+\tFOR_BB_INSNS (bb, p)\n+\t  {\n+\t    rtx s;\n+\n+\t    if (!INSN_P (p))\n+\t      continue;\n+\t    s = single_set (p);\n+\t    /* This is the instruction which sets REG.  If there is a\n+\t       REG_EQUAL note, then REG is equivalent to a constant.  */\n+\t    if (s != 0\n+\t        && REG_P (SET_DEST (s))\n+\t        && REG_N_SETS (REGNO (SET_DEST (s))) == 1\n+\t        && find_reg_note (p, REG_EQUAL, NULL_RTX))\n+\t      reg_set_in_bb[REGNO (SET_DEST (s))] = bb;\n+\t  }\n     }\n+\n   gcc_assert (REGNO (reg) < max_reg_computed);\n   if (reg_set_in_bb[REGNO (reg)] == NULL)\n     return false;\n-  if (reg_set_in_bb[REGNO (reg)] != BLOCK_FOR_INSN (insn))\n-    return true;\n-  /* Look for the set.  */\n-  for (p = BB_HEAD (BLOCK_FOR_INSN (insn)); p != insn; p = NEXT_INSN (p))\n-    {\n-      rtx s;\n-\n-      if (!INSN_P (p))\n-\tcontinue;\n-      s = single_set (p);\n-      if (s != 0\n-\t  && REG_P (SET_DEST (s)) && REGNO (SET_DEST (s)) == REGNO (reg))\n-\t{\n-\t  /* The register is set in the same basic block.  */\n-\t  return false;\n-\t}\n-    }\n-  return true;\n+  return (reg_set_in_bb[REGNO (reg)] != BLOCK_FOR_INSN (insn));\n }\n \n /* INSN is adding a CONST_INT to a REG.  We search backwards looking for\n@@ -1053,7 +1016,6 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n static void\n regmove_optimize (rtx f, int nregs)\n {\n-  int old_max_uid = get_max_uid ();\n   rtx insn;\n   struct match match;\n   int pass;\n@@ -1071,12 +1033,8 @@ regmove_optimize (rtx f, int nregs)\n   mark_flags_life_zones (discover_flags_reg ());\n \n   regno_src_regno = XNEWVEC (int, nregs);\n-  for (i = nregs; --i >= 0; ) regno_src_regno[i] = -1;\n-\n-  regmove_bb_head = XNEWVEC (int, old_max_uid + 1);\n-  for (i = old_max_uid; i >= 0; i--) regmove_bb_head[i] = -1;\n-  FOR_EACH_BB (bb)\n-    regmove_bb_head[INSN_UID (BB_HEAD (bb))] = bb->index;\n+  for (i = nregs; --i >= 0; )\n+    regno_src_regno[i] = -1;\n \n   /* A forward/backward pass.  Replace output operands with input operands.  */\n \n@@ -1500,28 +1458,14 @@ regmove_optimize (rtx f, int nregs)\n \t  /* If we weren't able to replace any of the alternatives, try an\n \t     alternative approach of copying the source to the destination.  */\n \t  if (!success && copy_src != NULL_RTX)\n-\t    copy_src_to_dest (insn, copy_src, copy_dst, old_max_uid);\n+\t    copy_src_to_dest (insn, copy_src, copy_dst);\n \n \t}\n     }\n \n-  /* In fixup_match_1, some insns may have been inserted after basic block\n-     ends.  Fix that here.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx end = BB_END (bb);\n-      rtx new = end;\n-      rtx next = NEXT_INSN (new);\n-      while (next != 0 && INSN_UID (next) >= old_max_uid\n-\t     && (bb->next_bb == EXIT_BLOCK_PTR || BB_HEAD (bb->next_bb) != next))\n-\tnew = next, next = NEXT_INSN (new);\n-      BB_END (bb) = new;\n-    }\n-\n  done:\n   /* Clean up.  */\n   free (regno_src_regno);\n-  free (regmove_bb_head);\n   if (reg_set_in_bb)\n     {\n       free (reg_set_in_bb);"}]}