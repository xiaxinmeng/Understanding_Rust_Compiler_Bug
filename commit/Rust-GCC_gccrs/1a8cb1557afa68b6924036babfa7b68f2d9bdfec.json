{"sha": "1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4Y2IxNTU3YWZhNjhiNjkyNDAzNmJhYmZhN2I2OGYyZDliZGZlYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-07-24T15:17:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-07-24T15:17:35Z"}, "message": "re PR middle-end/61268 (ICE in vt_expand_var_loc_chain, at var-tracking.c:8262)\n\ngcc/\n\tPR middle-end/61268\n\t* function.c (assign_parm_setup_reg): Prevent invalid sharing of\n\tDECL_INCOMING_RTL and entry_parm.\n\t(get_arg_pointer_save_area): Likewise arg_pointer_save_area.\n\t* calls.c (load_register_parameters): Likewise argument values.\n\t(emit_library_call_value_1, store_one_arg): Likewise argument\n\tsave areas.\n\t* config/i386/i386.c (assign_386_stack_local): Likewise the local\n\tstack slot.\n\t* explow.c (validize_mem): Modify the argument in-place.\n\nFrom-SVN: r213002", "tree": {"sha": "49d0c94109fd5b2babebf70c832b8a08a6eb1b6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49d0c94109fd5b2babebf70c832b8a08a6eb1b6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b92caa1d6e5623e3562a76976d0bba7a413b2ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b92caa1d6e5623e3562a76976d0bba7a413b2ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b92caa1d6e5623e3562a76976d0bba7a413b2ce"}], "stats": {"total": 51, "additions": 34, "deletions": 17}, "files": [{"sha": "3418ae772225791da3ea727525d9e1a87289f1d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "patch": "@@ -1,3 +1,16 @@\n+2014-07-24  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR middle-end/61268\n+\t* function.c (assign_parm_setup_reg): Prevent invalid sharing of\n+\tDECL_INCOMING_RTL and entry_parm.\n+\t(get_arg_pointer_save_area): Likewise arg_pointer_save_area.\n+\t* calls.c (load_register_parameters): Likewise argument values.\n+\t(emit_library_call_value_1, store_one_arg): Likewise argument\n+\tsave areas.\n+\t* config/i386/i386.c (assign_386_stack_local): Likewise the local\n+\tstack slot.\n+\t* explow.c (validize_mem): Modify the argument in-place.\n+\n 2014-07-24  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_popwb_single_reg): New function."}, {"sha": "e8456528a59e1c6065bc69a2db4d1e37f132bc6f", "filename": "gcc/calls.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "patch": "@@ -1937,7 +1937,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \n \t  else if (partial == 0 || args[i].pass_on_stack)\n \t    {\n-\t      rtx mem = validize_mem (args[i].value);\n+\t      rtx mem = validize_mem (copy_rtx (args[i].value));\n \n \t      /* Check for overlap with already clobbered argument area,\n \t         providing that this has non-zero size.  */\n@@ -4014,7 +4014,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t\t\t\t     argvec[argnum].locate.size.constant\n \t\t\t\t\t     );\n \n-\t\t      emit_block_move (validize_mem (argvec[argnum].save_area),\n+\t\t      emit_block_move (validize_mem\n+\t\t\t\t         (copy_rtx (argvec[argnum].save_area)),\n \t\t\t\t       stack_area,\n \t\t\t\t       GEN_INT (argvec[argnum].locate.size.constant),\n \t\t\t\t       BLOCK_OP_CALL_PARM);\n@@ -4289,7 +4290,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n \t    if (save_mode == BLKmode)\n \t      emit_block_move (stack_area,\n-\t\t\t       validize_mem (argvec[count].save_area),\n+\t\t\t       validize_mem\n+\t\t\t         (copy_rtx (argvec[count].save_area)),\n \t\t\t       GEN_INT (argvec[count].locate.size.constant),\n \t\t\t       BLOCK_OP_CALL_PARM);\n \t    else\n@@ -4433,7 +4435,8 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t\t  arg->save_area\n \t\t    = assign_temp (TREE_TYPE (arg->tree_value), 1, 1);\n \t\t  preserve_temp_slots (arg->save_area);\n-\t\t  emit_block_move (validize_mem (arg->save_area), stack_area,\n+\t\t  emit_block_move (validize_mem (copy_rtx (arg->save_area)),\n+\t\t\t\t   stack_area,\n \t\t\t\t   GEN_INT (arg->locate.size.constant),\n \t\t\t\t   BLOCK_OP_CALL_PARM);\n \t\t}"}, {"sha": "9de2035336cd08461e4538449055a3fbb4fbb8ea", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "patch": "@@ -25061,7 +25061,7 @@ assign_386_stack_local (enum machine_mode mode, enum ix86_stack_slot n)\n \n   s->next = ix86_stack_locals;\n   ix86_stack_locals = s;\n-  return validize_mem (s->rtl);\n+  return validize_mem (copy_rtx (s->rtl));\n }\n \n static void"}, {"sha": "92c4e574dcb8517edfe486b7e9bf8674b4cab6ba", "filename": "gcc/explow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "patch": "@@ -518,8 +518,9 @@ memory_address_addr_space (enum machine_mode mode, rtx x, addr_space_t as)\n   return x;\n }\n \n-/* Convert a mem ref into one with a valid memory address.\n-   Pass through anything else unchanged.  */\n+/* If REF is a MEM with an invalid address, change it into a valid address.\n+   Pass through anything else unchanged.  REF must be an unshared rtx and\n+   the function may modify it in-place.  */\n \n rtx\n validize_mem (rtx ref)\n@@ -531,8 +532,7 @@ validize_mem (rtx ref)\n \t\t\t\t   MEM_ADDR_SPACE (ref)))\n     return ref;\n \n-  /* Don't alter REF itself, since that is probably a stack slot.  */\n-  return replace_equiv_address (ref, XEXP (ref, 0));\n+  return replace_equiv_address (ref, XEXP (ref, 0), true);\n }\n \n /* If X is a memory reference to a member of an object block, try rewriting"}, {"sha": "84d6a107c703be70b2217e3da7e3e931f93ea44e", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8cb1557afa68b6924036babfa7b68f2d9bdfec/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=1a8cb1557afa68b6924036babfa7b68f2d9bdfec", "patch": "@@ -2662,13 +2662,14 @@ assign_parm_adjust_entry_rtl (struct assign_parm_data_one *data)\n       /* Handle calls that pass values in multiple non-contiguous\n \t locations.  The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (entry_parm) == PARALLEL)\n-\temit_group_store (validize_mem (stack_parm), entry_parm,\n+\temit_group_store (validize_mem (copy_rtx (stack_parm)), entry_parm,\n \t\t\t  data->passed_type,\n \t\t\t  int_size_in_bytes (data->passed_type));\n       else\n \t{\n \t  gcc_assert (data->partial % UNITS_PER_WORD == 0);\n-\t  move_block_from_reg (REGNO (entry_parm), validize_mem (stack_parm),\n+\t  move_block_from_reg (REGNO (entry_parm),\n+\t\t\t       validize_mem (copy_rtx (stack_parm)),\n \t\t\t       data->partial / UNITS_PER_WORD);\n \t}\n \n@@ -2837,7 +2838,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       else\n \tgcc_assert (!size || !(PARM_BOUNDARY % BITS_PER_WORD));\n \n-      mem = validize_mem (stack_parm);\n+      mem = validize_mem (copy_rtx (stack_parm));\n \n       /* Handle values in multiple non-contiguous locations.  */\n       if (GET_CODE (entry_parm) == PARALLEL)\n@@ -2972,7 +2973,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n      assign_parm_find_data_types and expand_expr_real_1.  */\n \n   equiv_stack_parm = data->stack_parm;\n-  validated_mem = validize_mem (data->entry_parm);\n+  validated_mem = validize_mem (copy_rtx (data->entry_parm));\n \n   need_conversion = (data->nominal_mode != data->passed_mode\n \t\t     || promoted_nominal_mode != data->promoted_mode);\n@@ -3228,7 +3229,7 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n       /* Conversion is required.  */\n       rtx tempreg = gen_reg_rtx (GET_MODE (data->entry_parm));\n \n-      emit_move_insn (tempreg, validize_mem (data->entry_parm));\n+      emit_move_insn (tempreg, validize_mem (copy_rtx (data->entry_parm)));\n \n       push_to_sequence2 (all->first_conversion_insn, all->last_conversion_insn);\n       to_conversion = true;\n@@ -3265,8 +3266,8 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \t  set_mem_attributes (data->stack_parm, parm, 1);\n \t}\n \n-      dest = validize_mem (data->stack_parm);\n-      src = validize_mem (data->entry_parm);\n+      dest = validize_mem (copy_rtx (data->stack_parm));\n+      src = validize_mem (copy_rtx (data->entry_parm));\n \n       if (MEM_P (src))\n \t{\n@@ -5261,7 +5262,7 @@ get_arg_pointer_save_area (void)\n \t generated stack slot may not be a valid memory address, so we\n \t have to check it and fix it if necessary.  */\n       start_sequence ();\n-      emit_move_insn (validize_mem (ret),\n+      emit_move_insn (validize_mem (copy_rtx (ret)),\n                       crtl->args.internal_arg_pointer);\n       seq = get_insns ();\n       end_sequence ();"}]}