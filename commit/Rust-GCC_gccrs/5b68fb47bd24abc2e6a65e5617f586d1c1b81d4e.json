{"sha": "5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "node_id": "C_kwDOANBUbNoAKDViNjhmYjQ3YmQyNGFiYzJlNmE2NWU1NjE3ZjU4NmQxYzFiODFkNGU", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2023-01-06T19:31:26Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2023-01-06T19:31:26Z"}, "message": "c: C2x semantics for __builtin_tgmath\n\n__builtin_tgmath implements <tgmath.h> semantics for integer generic\narguments that handle cases involving _FloatN / _FloatNx types as\nspecified in TS 18661-3 plus some defect fixes.\n\nC2x has further changes to the semantics for <tgmath.h> macros with\nsuch types, which should also be considered defect fixes (although\nhandled through the integration of TS 18661-3 in C2x rather than\nthrough an issue tracking process).  Specifically, the rules were\nchanged because of problems raised with using the macros with the\nevaluation format types such as float_t and _Float32_t: the older\nversion of the rules didn't allow passing _FloatN / _FloatNx types to\nthe narrowing macros returning float or double, or passing float /\ndouble / long double to the narrowing macros returning _FloatN /\n_FloatNx, which was a problem with the evaluation format types which\ncould be either kind of type depending on the value of\nFLT_EVAL_METHOD.\n\nThus the new rules allow cases of mixing types which were not allowed\nbefore - which is not itself a problem for __builtin_tgmath - and, as\npart of the changes, the handling of integer arguments was also\nchanged: if there is any _FloatNx generic argument, integer generic\narguments are treated as _Float32x (not double), while the rule about\ntreating integer arguments to narrowing macros returning _FloatN or\n_FloatNx as _Float64 not double was removed (no longer needed now\ndouble is a valid argument to such macros).\n\nImplement the changes for __builtin_tgmath.  (The changes also added a\nrule that if any argument is _DecimalNx, integer arguments are treated\nas _Decimal64x, but GCC doesn't support _DecimalNx types so nothing is\ndone about that.)\n\nI have a corresponding glibc patch to update glibc test expectations\nfor C2x and also ensure that appropriate semantics are followed when\nGCC 7 through 12 are used with <tgmath.h> (avoiding __builtin_tgmath\nin cases where it doesn't match the C2x semantics).\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/\n\t* doc/extend.texi (__builtin_tgmath): Do not restate standard rule\n\tfor handling real integer types.\n\ngcc/c/\n\t* c-parser.cc (c_parser_postfix_expression): Handle integer\n\tgeneric arguments to functions passed to __builtin_tgmath as\n\t_Float32x if any argument has _FloatNx or _Complex _FloatNx type.\n\tDo not handle integer arguments to some narrowing functions as\n\t_Float64.\n\ngcc/testsuite/\n\t* gcc.dg/builtin-tgmath-3.c: Update expectations and add more\n\ttests.", "tree": {"sha": "d5951144716ceb901447d8ef2d4449cab1f991c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5951144716ceb901447d8ef2d4449cab1f991c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3707a55acb980fbcd412ceb980b5621decb4dc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3707a55acb980fbcd412ceb980b5621decb4dc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3707a55acb980fbcd412ceb980b5621decb4dc0"}], "stats": {"total": 90, "additions": 63, "deletions": 27}, "files": [{"sha": "3a5998007a93aa62c4c614ef517d151b7bd534ea", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "patch": "@@ -10276,16 +10276,17 @@ c_parser_postfix_expression (c_parser *parser)\n \t       types are treated as _Decimal64 if any type-generic\n \t       argument is decimal, or if the only alternatives for\n \t       type-generic arguments are of decimal types, and are\n-\t       otherwise treated as double (or _Complex double for\n-\t       complex integer types, or _Float64 or _Complex _Float64\n-\t       if all the return types are the same _FloatN or\n-\t       _FloatNx type).  After that adjustment, types are\n-\t       combined following the usual arithmetic conversions.\n-\t       If the function only accepts complex arguments, a\n-\t       complex type is produced.  */\n+\t       otherwise treated as _Float32x (or _Complex _Float32x\n+\t       for complex integer types) if any type-generic argument\n+\t       has _FloatNx type, otherwise as double (or _Complex\n+\t       double for complex integer types).  After that\n+\t       adjustment, types are combined following the usual\n+\t       arithmetic conversions.  If the function only accepts\n+\t       complex arguments, a complex type is produced.  */\n \t    bool arg_complex = all_complex;\n \t    bool arg_binary = all_binary;\n \t    bool arg_int_decimal = all_decimal;\n+\t    bool arg_int_floatnx = false;\n \t    for (unsigned int j = 1; j <= nargs; j++)\n \t      {\n \t\tif (parm_kind[j] == tgmath_fixed)\n@@ -10380,20 +10381,17 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t\tgoto out;\n \t\t      }\n \t\t  }\n+\t\ttree rtype = TYPE_MAIN_VARIANT (type);\n+\t\tif (TREE_CODE (rtype) == COMPLEX_TYPE)\n+\t\t  rtype = TREE_TYPE (rtype);\n+\t\tif (SCALAR_FLOAT_TYPE_P (rtype))\n+\t\t  for (unsigned int j = 0; j < NUM_FLOATNX_TYPES; j++)\n+\t\t    if (rtype == FLOATNX_TYPE_NODE (j))\n+\t\t      {\n+\t\t\targ_int_floatnx = true;\n+\t\t\tbreak;\n+\t\t      }\n \t      }\n-\t    /* For a macro rounding its result to a narrower type, map\n-\t       integer types to _Float64 not double if the return type\n-\t       is a _FloatN or _FloatNx type.  */\n-\t    bool arg_int_float64 = false;\n-\t    if (parm_kind[0] == tgmath_fixed\n-\t\t&& SCALAR_FLOAT_TYPE_P (parm_first[0])\n-\t\t&& float64_type_node != NULL_TREE)\n-\t      for (unsigned int j = 0; j < NUM_FLOATN_NX_TYPES; j++)\n-\t\tif (parm_first[0] == FLOATN_TYPE_NODE (j))\n-\t\t  {\n-\t\t    arg_int_float64 = true;\n-\t\t    break;\n-\t\t  }\n \t    tree arg_real = NULL_TREE;\n \t    for (unsigned int j = 1; j <= nargs; j++)\n \t      {\n@@ -10406,8 +10404,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t\tif (INTEGRAL_TYPE_P (type))\n \t\t  type = (arg_int_decimal\n \t\t\t  ? dfloat64_type_node\n-\t\t\t  : arg_int_float64\n-\t\t\t  ? float64_type_node\n+\t\t\t  : arg_int_floatnx\n+\t\t\t  ? float32x_type_node\n \t\t\t  : double_type_node);\n \t\tif (arg_real == NULL_TREE)\n \t\t  arg_real = type;"}, {"sha": "1103e9936f773387ef7419090a3aa4c7b6dad91a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "patch": "@@ -13923,9 +13923,8 @@ corresponding to @var{t} for each function.\n The standard rules for @code{<tgmath.h>} macros are used to find a\n common type @var{u} from the types of the arguments for parameters\n whose types vary between the functions; complex integer types (a GNU\n-extension) are treated like @code{_Complex double} for this purpose\n-(or @code{_Complex _Float64} if all the function return types are the\n-same @code{_Float@var{n}} or @code{_Float@var{n}x} type).\n+extension) are treated like the complex type corresponding to the real\n+floating type that would be chosen for the corresponding real integer type.\n If the function return types vary, or are all the same integer type,\n the function called is the one for which @var{t} is @var{u}, and it is\n an error if there is no such function.  If the function return types"}, {"sha": "652113088a633db1bc5e93e9188d2235a6083189", "filename": "gcc/testsuite/gcc.dg/builtin-tgmath-3.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-tgmath-3.c?ref=5b68fb47bd24abc2e6a65e5617f586d1c1b81d4e", "patch": "@@ -1,10 +1,12 @@\n-/* Test __builtin_tgmath: integer arguments mapped to _Float64.  */\n+/* Test __builtin_tgmath: integer arguments with _FloatN / _FloatNx.  */\n /* { dg-do run } */\n /* { dg-options \"\" } */\n /* { dg-add-options float32 } */\n /* { dg-add-options float64 } */\n+/* { dg-add-options float32x } */\n /* { dg-require-effective-target float32_runtime } */\n /* { dg-require-effective-target float64_runtime } */\n+/* { dg-require-effective-target float32x_runtime } */\n \n extern void abort (void);\n extern void exit (int);\n@@ -18,7 +20,11 @@ extern void exit (int);\n     }\t\t\t\t\t\t\\\n   while (0)\n \n+extern double var_d;\n extern _Float32 var_f32;\n+extern _Float64 var_f64;\n+extern _Float32x var_f32x;\n+extern _Complex _Float32x var_cf32x;\n \n _Float32 t1f (float x) { return x + 1; }\n _Float32 t1d (double x) { return x + 2; }\n@@ -39,12 +45,45 @@ test_1 (void)\n   CHECK_CALL (t1v (d), 4, var_f32);\n   CHECK_CALL (t1v (ld), 6, var_f32);\n   CHECK_CALL (t1v (f64), 8, var_f32);\n-  CHECK_CALL (t1v (i), 9, var_f32);\n+  CHECK_CALL (t1v (i), 7, var_f32);\n+}\n+\n+float t2f (float x, float y) { return 10 * x + y; }\n+double t2d (double x, double y) { return 100 * x + y; }\n+long double t2l (long double x, long double y) { return 1000 * x + y; }\n+_Float32x t2f32x (_Float32x x, _Float32x y) { return 10000 * x + y; }\n+_Float64 t2f64 (_Float64 x, _Float64 y) { return 100000 * x + y; }\n+\n+_Complex _Float32x\n+ct2f32x (_Complex _Float32x x, _Complex _Float32x y)\n+{\n+  return 1000000 * x + y;\n+}\n+\n+#define t2v(x, y) __builtin_tgmath (t2f, t2d, t2l, t2f32x, t2f64, ct2f32x, x, y)\n+\n+static void\n+test_2 (void)\n+{\n+  double d = 3;\n+  _Float64 f64 = 6;\n+  _Float32x f32x = 7;\n+  int i = 5;\n+  _Complex _Float32x cf32x = 8;\n+  CHECK_CALL (t2v (f32x, i), 70005, var_f32x);\n+  CHECK_CALL (t2v (i, f32x), 50007, var_f32x);\n+  CHECK_CALL (t2v (f64, i), 600005, var_f64);\n+  CHECK_CALL (t2v (i, f64), 500006, var_f64);\n+  CHECK_CALL (t2v (d, i), 305, var_d);\n+  CHECK_CALL (t2v (i, d), 503, var_d);\n+  CHECK_CALL (t2v (cf32x, i), 8000005, var_cf32x);\n+  CHECK_CALL (t2v (i, cf32x), 5000008, var_cf32x);\n }\n \n int\n main (void)\n {\n   test_1 ();\n+  test_2 ();\n   exit (0);\n }"}]}