{"sha": "bc5612ed5640eb8e98e9f50061db7d2325113eef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM1NjEyZWQ1NjQwZWI4ZTk4ZTlmNTAwNjFkYjdkMjMyNTExM2VlZg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-07T23:42:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-07T23:42:41Z"}, "message": "dwarf2out: Move insn scanning out of final.c.\n\nThis patch is essentially Bernd's 005-scanfirst patch, updated for\nthe introduction of the dwarf2cfi.c file.\n\nWe introduce NOTE_INSN_CFI and NOTE_INSN_CFI_LABEL to hold the dwarf2\ninfo during the bulk of final.  The actual construction of these notes\nstill happens during final, right at the very beginning of the pass,\nvia the dwarf2out_frame_debug_init hook.\n\n        * dwarf2cfi.c (cfi_insn): New.\n        (dwarf2out_cfi_label): Don't emit cfi label here.\n        (add_fde_cfi): Create a NOTE_INSN_CFI.\n        (dwarf2out_frame_debug): Setup cfi_insn.\n        (dwarf2out_frame_debug_init): Loop over insns creating CFI notes.\n        (dwarf2out_cfi_begin_epilogue): Make static.\n        (dwarf2out_frame_debug_restore_state): Make static.\n        * dwarf2out.c (output_cfi_directive): Make static.\n        (dwarf2out_emit_cfi): New.\n        * dwarf2out.h: Update.\n        * final.c (final): Remove CFI notes.\n        (final_scan_insn): Don't call dwarf2out_cfi_begin_epilogue,\n        dwarf2out_frame_debug_restore_state, dwarf2out_frame_debug.\n        Handle NOTE_INSN_CFI and NOTE_INSN_CFI_LABEL.\n        * insn-notes.def (NOTE_INSN_CFI): New.\n        (NOTE_INSN_CFI_LABEL): New.\n        * rtl.h (union rtunion_def): Add rt_cfi member.\n        (XCFI, XCCFI, NOTE_CFI, NOTE_LABEL_NUMBER): New.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r176016", "tree": {"sha": "b847cd3bf525fe133a6b119fd23ec62761a5bce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b847cd3bf525fe133a6b119fd23ec62761a5bce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc5612ed5640eb8e98e9f50061db7d2325113eef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5612ed5640eb8e98e9f50061db7d2325113eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc5612ed5640eb8e98e9f50061db7d2325113eef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5612ed5640eb8e98e9f50061db7d2325113eef/comments", "author": null, "committer": null, "parents": [{"sha": "647a156710dcd42a2bccce3fcc0322f2be835cae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/647a156710dcd42a2bccce3fcc0322f2be835cae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/647a156710dcd42a2bccce3fcc0322f2be835cae"}], "stats": {"total": 198, "additions": 143, "deletions": 55}, "files": [{"sha": "104c4ac83fd0b5c08e71fa5930b3308dd091a406", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc5612ed5640eb8e98e9f50061db7d2325113eef", "patch": "@@ -1,3 +1,25 @@\n+2011-07-07  Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (cfi_insn): New.\n+\t(dwarf2out_cfi_label): Don't emit cfi label here.\n+\t(add_fde_cfi): Create a NOTE_INSN_CFI.\n+\t(dwarf2out_frame_debug): Setup cfi_insn.\n+\t(dwarf2out_frame_debug_init): Loop over insns creating CFI notes.\n+\t(dwarf2out_cfi_begin_epilogue): Make static.\n+\t(dwarf2out_frame_debug_restore_state): Make static.\n+\t* dwarf2out.c (output_cfi_directive): Make static.\n+\t(dwarf2out_emit_cfi): New.\n+\t* dwarf2out.h: Update.\n+\t* final.c (final): Remove CFI notes.\n+\t(final_scan_insn): Don't call dwarf2out_cfi_begin_epilogue,\n+\tdwarf2out_frame_debug_restore_state, dwarf2out_frame_debug.\n+\tHandle NOTE_INSN_CFI and NOTE_INSN_CFI_LABEL.\n+\t* insn-notes.def (NOTE_INSN_CFI): New.\n+\t(NOTE_INSN_CFI_LABEL): New.\n+\t* rtl.h (union rtunion_def): Add rt_cfi member.\n+\t(XCFI, XCCFI, NOTE_CFI, NOTE_LABEL_NUMBER): New.\n+\n 2011-07-07  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c: New file."}, {"sha": "3e8958fd39241ac985e39166a4b7abfd45bf2952", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 80, "deletions": 17, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=bc5612ed5640eb8e98e9f50061db7d2325113eef", "patch": "@@ -143,6 +143,19 @@ cfi_vec cie_cfi_vec;\n \n static GTY(()) unsigned long dwarf2out_cfi_label_num;\n \n+/* The insn after which a new CFI note should be emitted.  */\n+static rtx cfi_insn;\n+\n+/* True if remember_state should be emitted before following CFI directive.  */\n+static bool emit_cfa_remember;\n+\n+/* True if any CFI directives were emitted at the current insn.  */\n+static bool any_cfis_emitted;\n+\f\n+\n+static void dwarf2out_cfi_begin_epilogue (rtx insn);\n+static void dwarf2out_frame_debug_restore_state (void);\n+\n \f\n /* Hook used by __throw.  */\n \n@@ -292,18 +305,13 @@ dwarf2out_cfi_label (bool force)\n     {\n       int num = dwarf2out_cfi_label_num++;\n       ASM_GENERATE_INTERNAL_LABEL (label, \"LCFI\", num);\n-      ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LCFI\", num);\n+      cfi_insn = emit_note_after (NOTE_INSN_CFI_LABEL, cfi_insn);\n+      NOTE_LABEL_NUMBER (cfi_insn) = num;\n     }\n \n   return label;\n }\n \n-/* True if remember_state should be emitted before following CFI directive.  */\n-static bool emit_cfa_remember;\n-\n-/* True if any CFI directives were emitted at the current insn.  */\n-static bool any_cfis_emitted;\n-\n /* Add CFI to the current fde at the PC value indicated by LABEL if specified,\n    or to the CIE if LABEL is NULL.  */\n \n@@ -383,7 +391,8 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n \t        }\n \t    }\n \n-\t  output_cfi_directive (cfi);\n+\t  cfi_insn = emit_note_after (NOTE_INSN_CFI, cfi_insn);\n+\t  NOTE_CFI (cfi_insn) = cfi;\n \n \t  vec = &fde->dw_fde_cfi;\n \t  any_cfis_emitted = true;\n@@ -2301,6 +2310,9 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n   bool handled_one = false;\n   bool need_flush = false;\n \n+  /* Remember where we are to insert notes.  */\n+  cfi_insn = (after_p ? insn : PREV_INSN (insn));\n+\n   if (!NONJUMP_INSN_P (insn) || clobbers_queued_reg_save (insn))\n     dwarf2out_flush_queued_reg_saves ();\n \n@@ -2440,8 +2452,16 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n void\n dwarf2out_frame_debug_init (void)\n {\n-  /* Flush any queued register saves.  */\n-  dwarf2out_flush_queued_reg_saves ();\n+  rtx insn;\n+\n+  regs_saved_in_regs = NULL;\n+  queued_reg_saves = NULL;\n+\n+  if (barrier_args_size)\n+    {\n+      XDELETEVEC (barrier_args_size);\n+      barrier_args_size = NULL;\n+    }\n \n   /* Set up state for generating call frame debug info.  */\n   lookup_cfa (&cfa);\n@@ -2453,12 +2473,55 @@ dwarf2out_frame_debug_init (void)\n   cfa_temp.reg = -1;\n   cfa_temp.offset = 0;\n \n-  regs_saved_in_regs = NULL;\n-\n-  if (barrier_args_size)\n+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n     {\n-      XDELETEVEC (barrier_args_size);\n-      barrier_args_size = NULL;\n+      rtx pat;\n+\n+      if (BARRIER_P (insn))\n+\t{\n+\t  dwarf2out_frame_debug (insn, false);\n+\t  continue;\n+        }\n+\n+      if (NOTE_P (insn))\n+\t{\n+\t  switch (NOTE_KIND (insn))\n+\t    {\n+\t    case NOTE_INSN_EPILOGUE_BEG:\n+#if defined(HAVE_epilogue)\n+\t      dwarf2out_cfi_begin_epilogue (insn);\n+#endif\n+\t      break;\n+\t    case NOTE_INSN_CFA_RESTORE_STATE:\n+\t      cfi_insn = insn;\n+\t      dwarf2out_frame_debug_restore_state ();\n+\t      break;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      pat = PATTERN (insn);\n+      if (asm_noperands (pat) >= 0)\n+\t{\n+\t  dwarf2out_frame_debug (insn, false);\n+\t  continue;\n+\t}\n+\n+      if (GET_CODE (pat) == SEQUENCE)\n+\t{\n+\t  int i, n = XVECLEN (pat, 0);\n+\t  for (i = 1; i < n; ++i)\n+\t    dwarf2out_frame_debug (XVECEXP (pat, 0, i), false);\n+\t}\n+\n+      if (CALL_P (insn)\n+\t  || find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL))\n+\tdwarf2out_frame_debug (insn, false);\n+\n+      dwarf2out_frame_debug (insn, true);\n     }\n }\n \n@@ -2467,7 +2530,7 @@ dwarf2out_frame_debug_init (void)\n    we do need to save/restore, then emit the save now, and insert a\n    NOTE_INSN_CFA_RESTORE_STATE at the appropriate place in the stream.  */\n \n-void\n+static void\n dwarf2out_cfi_begin_epilogue (rtx insn)\n {\n   bool saw_frp = false;\n@@ -2544,7 +2607,7 @@ dwarf2out_cfi_begin_epilogue (rtx insn)\n /* A \"subroutine\" of dwarf2out_cfi_begin_epilogue.  Emit the restore\n    required.  */\n \n-void\n+static void\n dwarf2out_frame_debug_restore_state (void)\n {\n   dw_cfi_ref cfi = new_cfi ();"}, {"sha": "78e1b1a63c312241dcec61b8945b5589088a6c47", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=bc5612ed5640eb8e98e9f50061db7d2325113eef", "patch": "@@ -843,7 +843,7 @@ output_cfi (dw_cfi_ref cfi, dw_fde_ref fde, int for_eh)\n \n /* Similar, but do it via assembler directives instead.  */\n \n-void\n+static void\n output_cfi_directive (dw_cfi_ref cfi)\n {\n   unsigned long r, r2;\n@@ -942,6 +942,12 @@ output_cfi_directive (dw_cfi_ref cfi)\n     }\n }\n \n+void\n+dwarf2out_emit_cfi (dw_cfi_ref cfi)\n+{\n+  output_cfi_directive (cfi);\n+}\n+\n /* Output CFIs from VEC, up to index UPTO, to bring current FDE to the\n    same state as after executing CFIs in CFI chain.  DO_CFI_ASM is\n    true if .cfi_* directives shall be emitted, false otherwise.  If it"}, {"sha": "9342d50d37c9bb5da1a008739902df50232596ec", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=bc5612ed5640eb8e98e9f50061db7d2325113eef", "patch": "@@ -216,7 +216,6 @@ dw_loc_descr_node;\n \n /* Interface from dwarf2out.c to dwarf2cfi.c.  */\n extern dw_fde_ref current_fde (void);\n-extern void output_cfi_directive (dw_cfi_ref);\n extern struct dw_loc_descr_struct *build_cfa_loc\n   (dw_cfa_location *, HOST_WIDE_INT);\n extern struct dw_loc_descr_struct *build_cfa_aligned_loc\n@@ -244,8 +243,7 @@ extern enum dw_cfi_oprnd_type dw_cfi_oprnd2_desc\n extern void dwarf2out_decl (tree);\n extern void dwarf2out_frame_debug (rtx, bool);\n extern void dwarf2out_frame_debug_init (void);\n-extern void dwarf2out_cfi_begin_epilogue (rtx);\n-extern void dwarf2out_frame_debug_restore_state (void);\n+extern void dwarf2out_emit_cfi (dw_cfi_ref cfi);\n \n extern void debug_dwarf (void);\n struct die_struct;"}, {"sha": "835bbd502bf0ecf644950e65d95d5467cd66a75f", "filename": "gcc/final.c", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=bc5612ed5640eb8e98e9f50061db7d2325113eef", "patch": "@@ -1727,7 +1727,7 @@ dump_basic_block_info (FILE *file, rtx insn, basic_block *start_to_bb,\n void\n final (rtx first, FILE *file, int optimize_p)\n {\n-  rtx insn;\n+  rtx insn, next;\n   int max_uid = 0;\n   int seen = 0;\n \n@@ -1801,6 +1801,16 @@ final (rtx first, FILE *file, int optimize_p)\n       free (start_to_bb);\n       free (end_to_bb);\n     }\n+\n+  /* Remove CFI notes, to avoid compare-debug failures.  */\n+  for (insn = first; insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (NOTE_P (insn)\n+\t  && (NOTE_KIND (insn) == NOTE_INSN_CFI\n+\t      || NOTE_KIND (insn) == NOTE_INSN_CFI_LABEL))\n+\tdelete_insn (insn);\n+    }\n }\n \f\n const char *\n@@ -1973,16 +1983,20 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_EPILOGUE_BEG:\n-#if defined (HAVE_epilogue)\n-\t  if (dwarf2out_do_frame ())\n-\t    dwarf2out_cfi_begin_epilogue (insn);\n-#endif\n \t  (*debug_hooks->begin_epilogue) (last_linenum, last_filename);\n \t  targetm.asm_out.function_begin_epilogue (file);\n \t  break;\n \n \tcase NOTE_INSN_CFA_RESTORE_STATE:\n-\t  dwarf2out_frame_debug_restore_state ();\n+\t  break;\n+\n+\tcase NOTE_INSN_CFI:\n+\t  dwarf2out_emit_cfi (NOTE_CFI (insn));\n+\t  break;\n+\n+\tcase NOTE_INSN_CFI_LABEL:\n+\t  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LCFI\",\n+\t\t\t\t  NOTE_LABEL_NUMBER (insn));\n \t  break;\n \n \tcase NOTE_INSN_FUNCTION_BEG:\n@@ -2092,8 +2106,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n       break;\n \n     case BARRIER:\n-      if (dwarf2out_do_frame ())\n-\tdwarf2out_frame_debug (insn, false);\n       break;\n \n     case CODE_LABEL:\n@@ -2314,11 +2326,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    location_t loc;\n \t    expanded_location expanded;\n \n-\t    /* Make sure we flush any queued register saves in case this\n-\t       clobbers affected registers.  */\n-\t    if (dwarf2out_do_frame ())\n-\t      dwarf2out_frame_debug (insn, false);\n-\n \t    /* There's no telling what that did to the condition codes.  */\n \t    CC_STATUS_INIT;\n \n@@ -2364,12 +2371,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n \t    final_sequence = body;\n \n-\t    /* Record the delay slots' frame information before the branch.\n-\t       This is needed for delayed calls: see execute_cfa_program().  */\n-\t    if (dwarf2out_do_frame ())\n-\t      for (i = 1; i < XVECLEN (body, 0); i++)\n-\t\tdwarf2out_frame_debug (XVECEXP (body, 0, i), false);\n-\n \t    /* The first insn in this SEQUENCE might be a JUMP_INSN that will\n \t       force the restoration of a comparison that was previously\n \t       thought unnecessary.  If that happens, cancel this sequence\n@@ -2683,11 +2684,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n \tcurrent_output_insn = debug_insn = insn;\n \n-\tif (dwarf2out_do_frame ()\n-\t    && (CALL_P (insn)\n-\t\t|| find_reg_note (insn, REG_CFA_FLUSH_QUEUE, NULL)))\n-\t  dwarf2out_frame_debug (insn, false);\n-\n \t/* Find the proper template for this insn.  */\n \ttempl = get_insn_template (insn_code_number, insn);\n \n@@ -2767,16 +2763,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t  targetm.asm_out.final_postscan_insn (file, insn, recog_data.operand,\n \t\t\t\t\t       recog_data.n_operands);\n \n-\t/* If necessary, report the effect that the instruction has on\n-\t   the unwind info.   We've already done this for delay slots\n-\t   and call instructions.  */\n-\tif (final_sequence == 0\n-#if !defined (HAVE_prologue)\n-\t    && !ACCUMULATE_OUTGOING_ARGS\n-#endif\n-\t    && dwarf2out_do_frame ())\n-\t  dwarf2out_frame_debug (insn, true);\n-\n \tif (!targetm.asm_out.unwind_emit_before_insn\n \t    && targetm.asm_out.unwind_emit)\n \t  targetm.asm_out.unwind_emit (asm_out_file, insn);"}, {"sha": "859cdacab590c00512f06dc54268afdf0a18149f", "filename": "gcc/insn-notes.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Finsn-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Finsn-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-notes.def?ref=bc5612ed5640eb8e98e9f50061db7d2325113eef", "patch": "@@ -77,4 +77,12 @@ INSN_NOTE (SWITCH_TEXT_SECTIONS)\n    when an epilogue appears in the middle of a function.  */\n INSN_NOTE (CFA_RESTORE_STATE)\n \n+/* When emitting dwarf2 frame information, contains a directive that\n+   should be emitted.  */\n+INSN_NOTE (CFI)\n+\n+/* When emitting dwarf2 frame information, contains the number of a debug\n+   label that should be emitted.  */\n+INSN_NOTE (CFI_LABEL)\n+\n #undef INSN_NOTE"}, {"sha": "e3ceecddc2fae746ea45d19f83327d954ff89060", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5612ed5640eb8e98e9f50061db7d2325113eef/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bc5612ed5640eb8e98e9f50061db7d2325113eef", "patch": "@@ -180,6 +180,7 @@ union rtunion_def\n   mem_attrs *rt_mem;\n   reg_attrs *rt_reg;\n   struct constant_descriptor_rtx *rt_constant;\n+  struct dw_cfi_struct *rt_cfi;\n };\n typedef union rtunion_def rtunion;\n \n@@ -708,6 +709,7 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n #define XTREE(RTX, N)   (RTL_CHECK1 (RTX, N, 't').rt_tree)\n #define XBBDEF(RTX, N)\t(RTL_CHECK1 (RTX, N, 'B').rt_bb)\n #define XTMPL(RTX, N)\t(RTL_CHECK1 (RTX, N, 'T').rt_str)\n+#define XCFI(RTX, N)\t(RTL_CHECK1 (RTX, N, 'C').rt_cfi)\n \n #define XVECEXP(RTX, N, M)\tRTVEC_ELT (XVEC (RTX, N), M)\n #define XVECLEN(RTX, N)\t\tGET_NUM_ELEM (XVEC (RTX, N))\n@@ -740,6 +742,7 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n #define XCMODE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rt_type)\n #define XCTREE(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rt_tree)\n #define XCBBDEF(RTX, N, C)    (RTL_CHECKC1 (RTX, N, C).rt_bb)\n+#define XCCFI(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rt_cfi)\n #define XCCSELIB(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rt_cselib)\n \n #define XCVECEXP(RTX, N, M, C)\tRTVEC_ELT (XCVEC (RTX, N, C), M)\n@@ -883,6 +886,8 @@ extern const char * const reg_note_name[];\n #define NOTE_EH_HANDLER(INSN)\tXCINT (INSN, 4, NOTE)\n #define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 4, NOTE)\n #define NOTE_VAR_LOCATION(INSN)\tXCEXP (INSN, 4, NOTE)\n+#define NOTE_CFI(INSN)\t\tXCCFI (INSN, 4, NOTE)\n+#define NOTE_LABEL_NUMBER(INSN)\tXCINT (INSN, 4, NOTE)\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */"}]}