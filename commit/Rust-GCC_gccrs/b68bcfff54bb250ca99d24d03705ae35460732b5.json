{"sha": "b68bcfff54bb250ca99d24d03705ae35460732b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY4YmNmZmY1NGJiMjUwY2E5OWQyNGQwMzcwNWFlMzU0NjA3MzJiNQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2006-11-02T03:20:49Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2006-11-02T03:20:49Z"}, "message": "re PR middle-end/29335 (transcendental functions with constant arguments should be resolved at compile-time)\n\n\tPR middle-end/29335\n\t* builtins.c (do_mpfr_sincos): New.\n\t(fold_builtin_1): Use it to fold builtin sincos.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-math-3.c: Fix semicolons.\n\t(TESTIT_2P, TESTIT_2P_R): New macros.  Test sincos.\n\nFrom-SVN: r118409", "tree": {"sha": "db45dd5721e26aedaf2e1dfdf4235258d04202b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db45dd5721e26aedaf2e1dfdf4235258d04202b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b68bcfff54bb250ca99d24d03705ae35460732b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b68bcfff54bb250ca99d24d03705ae35460732b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b68bcfff54bb250ca99d24d03705ae35460732b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b68bcfff54bb250ca99d24d03705ae35460732b5/comments", "author": null, "committer": null, "parents": [{"sha": "1d07712df0f27a52bbf6e68c337246fab3c998a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d07712df0f27a52bbf6e68c337246fab3c998a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d07712df0f27a52bbf6e68c337246fab3c998a3"}], "stats": {"total": 147, "additions": 133, "deletions": 14}, "files": [{"sha": "74b905f131ca3dbfc19c5c1fbaeb70e6b3fd39ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68bcfff54bb250ca99d24d03705ae35460732b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68bcfff54bb250ca99d24d03705ae35460732b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b68bcfff54bb250ca99d24d03705ae35460732b5", "patch": "@@ -1,3 +1,9 @@\n+2006-11-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR middle-end/29335\n+\t* builtins.c (do_mpfr_sincos): New.\n+\t(fold_builtin_1): Use it to fold builtin sincos.\n+\n 2006-11-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/darwin.h (CPP_SPEC): Handle -pthread, transforming"}, {"sha": "64bb52b28bb47df197884a08652906cfb766ae19", "filename": "gcc/builtins.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68bcfff54bb250ca99d24d03705ae35460732b5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68bcfff54bb250ca99d24d03705ae35460732b5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b68bcfff54bb250ca99d24d03705ae35460732b5", "patch": "@@ -207,6 +207,7 @@ static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n \t\t\t  const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, bool);\n static tree do_mpfr_arg2 (tree, tree, tree,\n \t\t\t  int (*)(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mp_rnd_t));\n+static tree do_mpfr_sincos (tree, tree, tree);\n \n /* Return true if NODE should be considered for inline expansion regardless\n    of the optimization level.  This means whenever a function is invoked with\n@@ -9184,6 +9185,12 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n     CASE_FLT_FN (BUILT_IN_TAN):\n       return fold_builtin_tan (arglist, type);\n \n+    CASE_FLT_FN (BUILT_IN_SINCOS):\n+      if (validate_arglist (arglist, REAL_TYPE, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+\treturn do_mpfr_sincos (TREE_VALUE (arglist), TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t       TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))));\n+    break;\n+\n     CASE_FLT_FN (BUILT_IN_SINH):\n       if (validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n \treturn do_mpfr_arg1 (TREE_VALUE (arglist), type, mpfr_sinh,\n@@ -11594,3 +11601,58 @@ do_mpfr_arg2 (tree arg1, tree arg2, tree type,\n   \n   return result;\n }\n+\n+/* If argument ARG is a REAL_CST, call mpfr_sin_cos() on it and set\n+   the pointers *(ARG_SINP) and *(ARG_COSP) to the resulting values.\n+   The type is taken from the type of ARG and is used for setting the\n+   precision of the calculation and results.  */\n+\n+static tree\n+do_mpfr_sincos (tree arg, tree arg_sinp, tree arg_cosp)\n+{\n+  tree result = NULL_TREE;\n+  \n+  STRIP_NOPS (arg);\n+  \n+  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+    {\n+      const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg);\n+\n+      if (!real_isnan (ra) && !real_isinf (ra))\n+        {\n+\t  tree const type = TREE_TYPE (arg);\n+\t  const int prec = REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n+\t  tree result_s, result_c;\n+\t  int inexact;\n+\t  mpfr_t m, ms, mc;\n+\n+\t  mpfr_inits2 (prec, m, ms, mc, NULL);\n+\t  mpfr_from_real (m, ra);\n+\t  mpfr_clear_flags();\n+\t  inexact = mpfr_sin_cos (ms, mc, m, GMP_RNDN);\n+\t  result_s = do_mpfr_ckconv (ms, type, inexact);\n+\t  result_c = do_mpfr_ckconv (mc, type, inexact);\n+\t  mpfr_clears (m, ms, mc, NULL);\n+\t  if (result_s && result_c)\n+\t    {\n+\t      /* Dereference the sin/cos pointer arguments.  */\n+\t      arg_sinp = build_fold_indirect_ref (arg_sinp);\n+\t      arg_cosp = build_fold_indirect_ref (arg_cosp);\n+\t      /* Proceed if valid pointer type were passed in.  */\n+\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (arg_sinp)) == TYPE_MAIN_VARIANT (type)\n+\t\t  && TYPE_MAIN_VARIANT (TREE_TYPE (arg_cosp)) == TYPE_MAIN_VARIANT (type))\n+\t        {\n+\t\t  /* Set the values. */\n+\t\t  result_s = fold_build2 (MODIFY_EXPR, type, arg_sinp, result_s);\n+\t\t  TREE_SIDE_EFFECTS (result_s) = 1;\n+\t\t  result_c = fold_build2 (MODIFY_EXPR, type, arg_cosp, result_c);\n+\t\t  TREE_SIDE_EFFECTS (result_c) = 1;\n+\t\t  /* Combine the assignments into a compound expr.  */\n+\t\t  result = non_lvalue (fold_build2 (COMPOUND_EXPR, type,\n+\t\t\t\t\t\t    result_s, result_c));\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return result;\n+}"}, {"sha": "3c332b7179e559bdf5c593a57092a72dcae3fb6e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68bcfff54bb250ca99d24d03705ae35460732b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68bcfff54bb250ca99d24d03705ae35460732b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b68bcfff54bb250ca99d24d03705ae35460732b5", "patch": "@@ -1,3 +1,8 @@\n+2006-11-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-math-3.c: Fix semicolons.\n+\t(TESTIT_2P, TESTIT_2P_R): New macros.  Test sincos.\n+\n 2006-11-01  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcc.dg/fold-mod-1.c: Match the leading 0x for the"}, {"sha": "afa78dc1580d8357f7696a5ab36bbc0e66926826", "filename": "gcc/testsuite/gcc.dg/torture/builtin-math-3.c", "status": "modified", "additions": 60, "deletions": 14, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b68bcfff54bb250ca99d24d03705ae35460732b5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b68bcfff54bb250ca99d24d03705ae35460732b5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-math-3.c?ref=b68bcfff54bb250ca99d24d03705ae35460732b5", "patch": "@@ -21,7 +21,7 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n   if (__builtin_##FUNC##l(ARG##L) != RES##L) \\\n     link_error(__LINE__); \\\n-  } while (0);\n+  } while (0)\n \n /* Range test, check that (LOW) < FUNC(ARG) < (HI).  */\n #define TESTIT_R(FUNC,ARG,LOW,HI) do { \\\n@@ -31,7 +31,7 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n   if (__builtin_##FUNC##l(ARG) <= (LOW) || __builtin_##FUNC##l(ARG) >= (HI)) \\\n     link_error(__LINE__); \\\n-  } while (0);\n+  } while (0)\n \n /* Test that FUNC(ARG1, ARG2) == (RES).  */\n #define TESTIT2(FUNC,ARG1,ARG2,RES) do { \\\n@@ -41,7 +41,7 @@ extern void link_error(int);\n     link_error(__LINE__); \\\n   if (__builtin_##FUNC##l(ARG1##L, ARG2##L) != RES##L) \\\n     link_error(__LINE__); \\\n-  } while (0);\n+  } while (0)\n \n /* Range test, check that (LOW) < FUNC(ARG1,ARG2) < (HI).  */\n #define TESTIT2_R(FUNC,ARG1,ARG2,LOW,HI) do { \\\n@@ -54,10 +54,47 @@ extern void link_error(int);\n   if (__builtin_##FUNC##l(ARG1, ARG2) <= (LOW) \\\n       || __builtin_##FUNC##l(ARG1, ARG2) >= (HI)) \\\n     link_error(__LINE__); \\\n-  } while (0);\n+  } while (0)\n+\n+/* Test that for FUNC(ARG, &ARG_S, &ARG_C);\n+   assert (ARG_S == RES_S && ARG_C == RES_C);.  */\n+#define TESTIT_2P(FUNC,ARG,ARG_S,ARG_C,RES_S,RES_C) do { \\\n+  __builtin_##FUNC##f(ARG##F, &ARG_S##f, &ARG_C##f); \\\n+  if (ARG_S##f != (RES_S##F) || ARG_C##f != (RES_C##F)) \\\n+    link_error(__LINE__); \\\n+  __builtin_##FUNC(ARG, &ARG_S, &ARG_C); \\\n+  if (ARG_S != (RES_S) || ARG_C != (RES_C)) \\\n+    link_error(__LINE__); \\\n+  __builtin_##FUNC##l(ARG##L, &ARG_S##l, &ARG_C##l); \\\n+  if (ARG_S##l != (RES_S##L) || ARG_C##l != (RES_C##L)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Test that for FUNC(ARG, &ARG_S, &ARG_C);\n+   assert (LOW_S < ARG_S < HI_S && LOW_C < ARG_C < HI_C);.  */\n+#define TESTIT_2P_R(FUNC,ARG,ARG_S,ARG_C,LOW_S,HI_S,LOW_C,HI_C) do { \\\n+  __builtin_##FUNC##f(ARG##F, &ARG_S##f, &ARG_C##f); \\\n+  if (ARG_S##f <= (LOW_S##F) || ARG_S##f >= (HI_S##F) \\\n+      || ARG_C##f <= (LOW_C##F) || ARG_C##f >= (HI_C##F)) \\\n+    link_error(__LINE__); \\\n+  __builtin_##FUNC(ARG, &ARG_S, &ARG_C); \\\n+  if (ARG_S <= (LOW_S) || ARG_S >= (HI_S) \\\n+      || ARG_C <= (LOW_C) || ARG_C >= (HI_C)) \\\n+    link_error(__LINE__); \\\n+  __builtin_##FUNC##l(ARG##L, &ARG_S##l, &ARG_C##l); \\\n+  if (ARG_S##l <= (LOW_S##L) || ARG_S##l >= (HI_S##L) \\\n+      || ARG_C##l <= (LOW_C##L) || ARG_C##l >= (HI_C##L)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n \n int main (void)\n {\n+#ifdef __OPTIMIZE__\n+  float sf, cf;\n+  double s, c;\n+  long double sl, cl;\n+#endif\n+\n   TESTIT_R (asin, -1.0, -3.15/2.0, -3.14/2.0); /* asin(-1) == -pi/2 */\n   TESTIT (asin, 0.0, 0.0); /* asin(0) == 0 */\n   TESTIT (asin, -0.0, -0.0); /* asin(-0) == -0 */\n@@ -101,6 +138,15 @@ int main (void)\n   TESTIT (tan, -0.0, -0.0); /* tan(-0) == -0 */\n   TESTIT_R (tan, 1.0, 1.55, 1.56); /* tan(1) == 1.557... */\n \n+#ifdef __OPTIMIZE__\n+  /* These tests rely on propagating the variables s and c, which\n+     happens only when optimization is turned on.  */\n+  TESTIT_2P_R (sincos, -1.0, s, c, -0.85, -0.84, 0.54, 0.55); /* (s==-0.841..., c==0.5403...) */\n+  TESTIT_2P (sincos, 0.0, s, c, 0.0, 1.0); /* (s==0, c==1) */\n+  TESTIT_2P (sincos, -0.0, s, c, -0.0, 1.0); /* (s==-0, c==1) */\n+  TESTIT_2P_R (sincos, 1.0, s, c, 0.84, 0.85, 0.54, 0.55); /* (s==0.841..., c==0.5403...) */\n+#endif\n+  \n   TESTIT_R (sinh, -1.0, -1.18, -1.17); /* sinh(-1) == -1.175... */\n   TESTIT (sinh, 0.0, 0.0); /* sinh(0) == 0 */\n   TESTIT (sinh, -0.0, -0.0); /* sinh(-0) == -0 */\n@@ -207,16 +253,16 @@ int main (void)\n   TESTIT2 (hypot, -3.0, -4.0, 5.0); /* hypot(-3,-4) == 5 */\n   TESTIT2_R (hypot, 4.0, 5.0, 6.40, 6.41); /* hypot(4,5) == 6.403... */\n \n-  TESTIT2 (atan2, 0.0, 0.0, 0.0) /* atan2(0,0) == 0 */\n-  TESTIT2 (atan2, -0.0, 0.0, -0.0) /* atan2(-0,0) == -0 */\n-  TESTIT2_R (atan2, 0.0, -0.0, 3.14, 3.15) /* atan2(0,-0) == pi */\n-  TESTIT2_R (atan2, -0.0, -0.0, -3.15, -3.14) /* atan2(-0,-0) == -pi */\n-  TESTIT2_R (atan2, 0.0, -1.0, 3.14, 3.15) /* atan2(0,-1) == pi */\n-  TESTIT2_R (atan2, -0.0, -1.0, -3.15, -3.14) /* atan2(-0,-1) == -pi */\n-  TESTIT2 (atan2, 0.0, 1.0, 0.0) /* atan2(0,1) == 0 */\n-  TESTIT2 (atan2, -0.0, 1.0, -0.0) /* atan2(-0,1) == -0 */\n-  TESTIT2_R (atan2, -1.0, 0.0, -1.58, -1.57) /* atan2(-1,0) == -pi/2 */\n-  TESTIT2_R (atan2, 1.0, 0.0, 1.57, 1.58) /* atan2(1,0) == pi/2 */\n+  TESTIT2 (atan2, 0.0, 0.0, 0.0); /* atan2(0,0) == 0 */\n+  TESTIT2 (atan2, -0.0, 0.0, -0.0); /* atan2(-0,0) == -0 */\n+  TESTIT2_R (atan2, 0.0, -0.0, 3.14, 3.15); /* atan2(0,-0) == pi */\n+  TESTIT2_R (atan2, -0.0, -0.0, -3.15, -3.14); /* atan2(-0,-0) == -pi */\n+  TESTIT2_R (atan2, 0.0, -1.0, 3.14, 3.15); /* atan2(0,-1) == pi */\n+  TESTIT2_R (atan2, -0.0, -1.0, -3.15, -3.14); /* atan2(-0,-1) == -pi */\n+  TESTIT2 (atan2, 0.0, 1.0, 0.0); /* atan2(0,1) == 0 */\n+  TESTIT2 (atan2, -0.0, 1.0, -0.0); /* atan2(-0,1) == -0 */\n+  TESTIT2_R (atan2, -1.0, 0.0, -1.58, -1.57); /* atan2(-1,0) == -pi/2 */\n+  TESTIT2_R (atan2, 1.0, 0.0, 1.57, 1.58); /* atan2(1,0) == pi/2 */\n \n   return 0;\n }"}]}