{"sha": "c24f5688adae2f885279e8fdce74a030e6944b7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI0ZjU2ODhhZGFlMmY4ODUyNzllOGZkY2U3NGEwMzBlNjk0NGI3Yg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-08-19T17:00:32Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-08-19T17:00:32Z"}, "message": "[PR64164] fix regressions reported on m68k and armeb\n\nDefer stack slot address assignment for all parms that can't live in\npseudos, and accept pseudos assignments in assign_param_setup_block.\n\nfor  gcc/ChangeLog\n\n\tPR rtl-optimization/64164\n\t* cfgexpand.c (parm_maybe_byref_p): Renamed to...\n\t(parm_in_stack_slot_p): ... this.  Disregard mode, what\n\tmatters is whether the parm will live in a pseudo or a stack\n\tslot.\n\t(expand_one_ssa_partition): Deal with params without a default\n\tdef.  Disregard mode.\n\t* cfgexpand.h: Renamed function declaration.\n\t* tree-ssa-coalesce.c: Adjust.\n\t* function.c (split_complex_args): Allocate stack slot for\n\tunassigned parms before splitting.\n\t(parm_in_unassigned_mem_p): New.  Use it instead of\n\tparm_maybe_byref_p throughout this file.\n\t(assign_parm_setup_block): Use it.  Accept pseudos in the\n\texpand-assigned rtl.\n\t(assign_parm_setup_reg): Drop BLKmode requirement.\n\t(assign_parm_setup_stack): Allocate and fill in the address of\n\tunassigned MEM parms.\n\nFrom-SVN: r227015", "tree": {"sha": "31f9d298632e1c8a23bdf19a980e7ed54c790474", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31f9d298632e1c8a23bdf19a980e7ed54c790474"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c24f5688adae2f885279e8fdce74a030e6944b7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24f5688adae2f885279e8fdce74a030e6944b7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24f5688adae2f885279e8fdce74a030e6944b7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24f5688adae2f885279e8fdce74a030e6944b7b/comments", "author": null, "committer": null, "parents": [{"sha": "8dc89e4d7ed340095fa0d27de5de584156b38c0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc89e4d7ed340095fa0d27de5de584156b38c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc89e4d7ed340095fa0d27de5de584156b38c0b"}], "stats": {"total": 145, "additions": 121, "deletions": 24}, "files": [{"sha": "567d440fd6839e9a58c0fc87bff52639ea6d6ee5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c24f5688adae2f885279e8fdce74a030e6944b7b", "patch": "@@ -1,3 +1,24 @@\n+2015-08-19  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/64164\n+\t* cfgexpand.c (parm_maybe_byref_p): Renamed to...\n+\t(parm_in_stack_slot_p): ... this.  Disregard mode, what\n+\tmatters is whether the parm will live in a pseudo or a stack\n+\tslot.\n+\t(expand_one_ssa_partition): Deal with params without a default\n+\tdef.  Disregard mode.\n+\t* cfgexpand.h: Renamed function declaration.\n+\t* tree-ssa-coalesce.c: Adjust.\n+\t* function.c (split_complex_args): Allocate stack slot for\n+\tunassigned parms before splitting.\n+\t(parm_in_unassigned_mem_p): New.  Use it instead of\n+\tparm_maybe_byref_p throughout this file.\n+\t(assign_parm_setup_block): Use it.  Accept pseudos in the\n+\texpand-assigned rtl.\n+\t(assign_parm_setup_reg): Drop BLKmode requirement.\n+\t(assign_parm_setup_stack): Allocate and fill in the address of\n+\tunassigned MEM parms.\n+\n 2015-08-19  David Sherwood  <david.sherwood@arm.com>\n \n \t* genmodes.c (emit_mode_unit_size_inline): New function."}, {"sha": "d567a875dfff9754c52bc2f18420e74f633fd0c1", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c24f5688adae2f885279e8fdce74a030e6944b7b", "patch": "@@ -172,25 +172,31 @@ leader_merge (tree cur, tree next)\n   return cur;\n }\n \n-/* Return true if VAR is a PARM_DECL or a RESULT_DECL of type BLKmode.\n+/* Return true if VAR is a PARM_DECL or a RESULT_DECL that ought to be\n+   assigned to a stack slot.  We can't have expand_one_ssa_partition\n+   choose their address: the pseudo holding the address would be set\n+   up too late for assign_params to copy the parameter if needed.\n+\n    Such parameters are likely passed as a pointer to the value, rather\n    than as a value, and so we must not coalesce them, nor allocate\n    stack space for them before determining the calling conventions for\n-   them.  For their SSA_NAMEs, expand_one_ssa_partition emits RTL as\n-   MEMs with pc_rtx as the address, and then it replaces the pc_rtx\n-   with NULL so as to make sure the MEM is not used before it is\n-   adjusted in assign_parm_setup_reg.  */\n+   them.\n+\n+   For their SSA_NAMEs, expand_one_ssa_partition emits RTL as MEMs\n+   with pc_rtx as the address, and then it replaces the pc_rtx with\n+   NULL so as to make sure the MEM is not used before it is adjusted\n+   in assign_parm_setup_reg.  */\n \n bool\n-parm_maybe_byref_p (tree var)\n+parm_in_stack_slot_p (tree var)\n {\n   if (!var || VAR_P (var))\n     return false;\n \n   gcc_assert (TREE_CODE (var) == PARM_DECL\n \t      || TREE_CODE (var) == RESULT_DECL);\n \n-  return TYPE_MODE (TREE_TYPE (var)) == BLKmode;\n+  return !use_register_for_decl (var);\n }\n \n /* Return the partition of the default SSA_DEF for decl VAR.  */\n@@ -1343,17 +1349,35 @@ expand_one_ssa_partition (tree var)\n \n   if (!use_register_for_decl (var))\n     {\n-      if (parm_maybe_byref_p (SSA_NAME_VAR (var))\n-\t  && ssa_default_def_partition (SSA_NAME_VAR (var)) == part)\n+      /* We can't risk having the parm assigned to a MEM location\n+\t whose address references a pseudo, for the pseudo will only\n+\t be set up after arguments are copied to the stack slot.\n+\n+\t If the parm doesn't have a default def (e.g., because its\n+\t incoming value is unused), then we want to let assign_params\n+\t do the allocation, too.  In this case we want to make sure\n+\t SSA_NAMEs associated with the parm don't get assigned to more\n+\t than one partition, lest we'd create two unassigned stac\n+\t slots for the same parm, thus the assert at the end of the\n+\t block.  */\n+      if (parm_in_stack_slot_p (SSA_NAME_VAR (var))\n+\t  && (ssa_default_def_partition (SSA_NAME_VAR (var)) == part\n+\t      || !ssa_default_def (cfun, SSA_NAME_VAR (var))))\n \t{\n \t  expand_one_stack_var_at (var, pc_rtx, 0, 0);\n \t  rtx x = SA.partition_to_pseudo[part];\n \t  gcc_assert (GET_CODE (x) == MEM);\n-\t  gcc_assert (GET_MODE (x) == BLKmode);\n \t  gcc_assert (XEXP (x, 0) == pc_rtx);\n \t  /* Reset the address, so that any attempt to use it will\n \t     ICE.  It will be adjusted in assign_parm_setup_reg.  */\n \t  XEXP (x, 0) = NULL_RTX;\n+\t  /* If the RTL associated with the parm is not what we have\n+\t     just created, the parm has been split over multiple\n+\t     partitions.  In order for this to work, we must have a\n+\t     default def for the parm, otherwise assign_params won't\n+\t     know what to do.  */\n+\t  gcc_assert (DECL_RTL_IF_SET (SSA_NAME_VAR (var)) == x\n+\t\t      || ssa_default_def (cfun, SSA_NAME_VAR (var)));\n \t}\n       else if (defer_stack_allocation (var, true))\n \tadd_stack_var (var);"}, {"sha": "d168672408391bee18c6549903ee83cf06bf229d", "filename": "gcc/cfgexpand.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2Fcfgexpand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2Fcfgexpand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.h?ref=c24f5688adae2f885279e8fdce74a030e6944b7b", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n extern tree gimple_assign_rhs_to_tree (gimple);\n extern HOST_WIDE_INT estimated_stack_frame_size (struct cgraph_node *);\n-extern bool parm_maybe_byref_p (tree);\n+extern bool parm_in_stack_slot_p (tree);\n extern rtx get_rtl_for_parm_ssa_default_def (tree var);\n \n "}, {"sha": "2c5a6d484f6816b513f46e5d6a6b51cb00671e49", "filename": "gcc/function.c", "status": "modified", "additions": 63, "deletions": 11, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c24f5688adae2f885279e8fdce74a030e6944b7b", "patch": "@@ -153,6 +153,7 @@ static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n static rtx rtl_for_parm (struct assign_parm_data_all *, tree);\n static void maybe_reset_rtl_for_parm (tree);\n+static bool parm_in_unassigned_mem_p (tree, rtx);\n \n \f\n /* Stack of nested functions.  */\n@@ -2326,6 +2327,22 @@ split_complex_args (struct assign_parm_data_all *all, vec<tree> *args)\n \t      rtx rtl = rtl_for_parm (all, cparm);\n \t      if (rtl)\n \t\t{\n+\t\t  /* If this is parm is unassigned, assign it now: the\n+\t\t     newly-created decls wouldn't expect the need for\n+\t\t     assignment, and if they were assigned\n+\t\t     independently, they might not end up in adjacent\n+\t\t     slots, so unsplit wouldn't be able to fill in the\n+\t\t     unassigned address of the complex MEM.  */\n+\t\t  if (parm_in_unassigned_mem_p (cparm, rtl))\n+\t\t    {\n+\t\t      int align = STACK_SLOT_ALIGNMENT\n+\t\t\t(TREE_TYPE (cparm), GET_MODE (rtl), MEM_ALIGN (rtl));\n+\t\t      rtx loc = assign_stack_local\n+\t\t\t(GET_MODE (rtl), GET_MODE_SIZE (GET_MODE (rtl)),\n+\t\t\t align);\n+\t\t      XEXP (rtl, 0) = XEXP (loc, 0);\n+\t\t    }\n+\n \t\t  SET_DECL_RTL (p, read_complex_part (rtl, false));\n \t\t  SET_DECL_RTL (decl, read_complex_part (rtl, true));\n \n@@ -2934,6 +2951,27 @@ assign_parm_setup_block_p (struct assign_parm_data_one *data)\n   return false;\n }\n \n+/* Return true if FROM_EXPAND is a MEM with an address to be filled in\n+   by assign_params.  This should be the case if, and only if,\n+   parm_in_stack_slot_p holds for the parm DECL that expanded to\n+   FROM_EXPAND, so we check that, too.  */\n+\n+static bool\n+parm_in_unassigned_mem_p (tree decl, rtx from_expand)\n+{\n+  bool result = MEM_P (from_expand) && !XEXP (from_expand, 0);\n+\n+  gcc_assert (result == parm_in_stack_slot_p (decl)\n+\t      /* Maybe it was already assigned.  That's ok, especially\n+\t\t for split complex args.  */\n+\t      || (!result && MEM_P (from_expand)\n+\t\t  && (XEXP (from_expand, 0) == virtual_stack_vars_rtx\n+\t\t      || (GET_CODE (XEXP (from_expand, 0)) == PLUS\n+\t\t\t  && XEXP (XEXP (from_expand, 0), 0) == virtual_stack_vars_rtx))));\n+\n+  return result;\n+}\n+\n /* A subroutine of assign_parms.  Arrange for the parameter to be\n    present and valid in DATA->STACK_RTL.  */\n \n@@ -2956,8 +2994,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n     {\n       DECL_ALIGN (parm) = MAX (DECL_ALIGN (parm), BITS_PER_WORD);\n       rtx from_expand = rtl_for_parm (all, parm);\n-      if (from_expand && (!parm_maybe_byref_p (parm)\n-\t\t\t  || XEXP (from_expand, 0) != NULL_RTX))\n+      if (from_expand && !parm_in_unassigned_mem_p (parm, from_expand))\n \tstack_parm = copy_rtx (from_expand);\n       else\n \t{\n@@ -2968,8 +3005,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t  if (from_expand)\n \t    {\n \t      gcc_assert (GET_CODE (stack_parm) == MEM);\n-\t      gcc_assert (GET_CODE (from_expand) == MEM);\n-\t      gcc_assert (XEXP (from_expand, 0) == NULL_RTX);\n+\t      gcc_assert (parm_in_unassigned_mem_p (parm, from_expand));\n \t      XEXP (from_expand, 0) = XEXP (stack_parm, 0);\n \t      PUT_MODE (from_expand, GET_MODE (stack_parm));\n \t      stack_parm = copy_rtx (from_expand);\n@@ -3017,6 +3053,11 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       else if (size == 0)\n \t;\n \n+      /* MEM may be a REG if coalescing assigns the param's partition\n+\t to a pseudo.  */\n+      else if (REG_P (mem))\n+\temit_move_insn (mem, entry_parm);\n+\n       /* If SIZE is that of a mode no bigger than a word, just use\n \t that mode's store operation.  */\n       else if (size <= UNITS_PER_WORD)\n@@ -3121,7 +3162,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n       if (GET_MODE (parmreg) != promoted_nominal_mode)\n \tparmreg = gen_lowpart (promoted_nominal_mode, parmreg);\n     }\n-  else if (!from_expand || parm_maybe_byref_p (parm))\n+  else if (!from_expand || parm_in_unassigned_mem_p (parm, from_expand))\n     {\n       parmreg = gen_reg_rtx (promoted_nominal_mode);\n       if (!DECL_ARTIFICIAL (parm))\n@@ -3131,7 +3172,6 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t{\n \t  gcc_assert (data->passed_pointer);\n \t  gcc_assert (GET_CODE (from_expand) == MEM\n-\t\t      && GET_MODE (from_expand) == BLKmode\n \t\t      && XEXP (from_expand, 0) == NULL_RTX);\n \t  XEXP (from_expand, 0) = parmreg;\n \t}\n@@ -3349,7 +3389,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t  did_conversion = true;\n \t}\n       else if (GET_MODE (parmreg) == BLKmode)\n-\tgcc_assert (parm_maybe_byref_p (parm));\n+\tgcc_assert (parm_in_stack_slot_p (parm));\n       else\n \temit_move_insn (parmreg, src);\n \n@@ -3455,12 +3495,15 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n   if (data->entry_parm != data->stack_parm)\n     {\n       rtx src, dest;\n+      rtx from_expand = NULL_RTX;\n \n       if (data->stack_parm == 0)\n \t{\n-\t  rtx x = data->stack_parm = rtl_for_parm (all, parm);\n-\t  if (x)\n-\t    gcc_assert (GET_MODE (x) == GET_MODE (data->entry_parm));\n+\t  from_expand = rtl_for_parm (all, parm);\n+\t  if (from_expand)\n+\t    gcc_assert (GET_MODE (from_expand) == GET_MODE (data->entry_parm));\n+\t  if (from_expand && !parm_in_unassigned_mem_p (parm, from_expand))\n+\t    data->stack_parm = from_expand;\n \t}\n \n       if (data->stack_parm == 0)\n@@ -3472,7 +3515,16 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \t    = assign_stack_local (GET_MODE (data->entry_parm),\n \t\t\t\t  GET_MODE_SIZE (GET_MODE (data->entry_parm)),\n \t\t\t\t  align);\n-\t  set_mem_attributes (data->stack_parm, parm, 1);\n+\t  if (!from_expand)\n+\t    set_mem_attributes (data->stack_parm, parm, 1);\n+\t  else\n+\t    {\n+\t      gcc_assert (GET_CODE (data->stack_parm) == MEM);\n+\t      gcc_assert (parm_in_unassigned_mem_p (parm, from_expand));\n+\t      XEXP (from_expand, 0) = XEXP (data->stack_parm, 0);\n+\t      PUT_MODE (from_expand, GET_MODE (data->stack_parm));\n+\t      data->stack_parm = copy_rtx (from_expand);\n+\t    }\n \t}\n \n       dest = validize_mem (copy_rtx (data->stack_parm));"}, {"sha": "6468012aa00792abf0e65c520f803fcc2985604b", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24f5688adae2f885279e8fdce74a030e6944b7b/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=c24f5688adae2f885279e8fdce74a030e6944b7b", "patch": "@@ -1386,8 +1386,8 @@ gimple_can_coalesce_p (tree name1, tree name2)\n \t because it may be passed by reference.  */\n       return ((!var1 || VAR_P (var1)) && (!var2 || VAR_P (var2)))\n \t|| (/* The case var1 == var2 is already covered above.  */\n-\t    !parm_maybe_byref_p (var1)\n-\t    && !parm_maybe_byref_p (var2)\n+\t    !parm_in_stack_slot_p (var1)\n+\t    && !parm_in_stack_slot_p (var2)\n \t    && promote_ssa_mode (name1, NULL) == promote_ssa_mode (name2, NULL));\n     }\n "}]}