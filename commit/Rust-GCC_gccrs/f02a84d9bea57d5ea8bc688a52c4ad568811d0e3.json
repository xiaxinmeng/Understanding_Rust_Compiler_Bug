{"sha": "f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAyYTg0ZDliZWE1N2Q1ZWE4YmM2ODhhNTJjNGFkNTY4ODExZDBlMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2008-06-24T12:46:59Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2008-06-24T12:46:59Z"}, "message": "jcf-path.c (jcf_path_init): Don't name variable 'try'.\n\n\t* jcf-path.c (jcf_path_init): Don't name variable 'try'.\n\t* expr.c (add_type_assertion): Rename argument.\n\t(build_java_arrayaccess): Don't name variable 'throw'.\n\t(ARRAY_NEW_MULTI): Don't name variable 'class'.\n\t* jcf-io.c (find_class): Don't name variable 'class'.\n\t* mangle.c (compression_table_add): Don't name variable 'new'.\n\t* constants.c (cpool_for_class): Rename argument.\n\t(alloc_constant_fieldref): Likewise.\n\t* jcf-parse.c (handle_innerclass_attribute): Don't name variable\n\t'class'.\n\t(read_class): Likewise.\n\t(parse_zip_file_entries): Likewise.\n\t(process_zip_dir): Likewise.\n\t* decl.c (java_mark_class_local): Rename argument.\n\t* class.c (GEN_TABLE): Use type_name, not typename.\n\t(gen_indirect_dispatch_tables): Likewise.\n\t(add_field): Rename argument.\n\t(is_compiled_class): Likewise.\n\t(safe_layout_class): Likewise.\n\t(emit_assertion_table): Likewise.\n\t* typeck.c (has_method): Rename argument.\n\nFrom-SVN: r137069", "tree": {"sha": "354f09c5b595364bbe3a120012deb913cb611a72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/354f09c5b595364bbe3a120012deb913cb611a72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/comments", "author": null, "committer": null, "parents": [{"sha": "f9993944a43c65e41b64d93b5a1cb9f2e9160a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9993944a43c65e41b64d93b5a1cb9f2e9160a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9993944a43c65e41b64d93b5a1cb9f2e9160a94"}], "stats": {"total": 297, "additions": 162, "deletions": 135}, "files": [{"sha": "65a28f4f8530c1ef1117f8ded8bfa7a2007aef65", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -1,3 +1,27 @@\n+2008-06-24  Tom Tromey  <tromey@redhat.com>\n+\n+\t* jcf-path.c (jcf_path_init): Don't name variable 'try'.\n+\t* expr.c (add_type_assertion): Rename argument.\n+\t(build_java_arrayaccess): Don't name variable 'throw'.\n+\t(ARRAY_NEW_MULTI): Don't name variable 'class'.\n+\t* jcf-io.c (find_class): Don't name variable 'class'.\n+\t* mangle.c (compression_table_add): Don't name variable 'new'.\n+\t* constants.c (cpool_for_class): Rename argument.\n+\t(alloc_constant_fieldref): Likewise.\n+\t* jcf-parse.c (handle_innerclass_attribute): Don't name variable\n+\t'class'.\n+\t(read_class): Likewise.\n+\t(parse_zip_file_entries): Likewise.\n+\t(process_zip_dir): Likewise.\n+\t* decl.c (java_mark_class_local): Rename argument.\n+\t* class.c (GEN_TABLE): Use type_name, not typename.\n+\t(gen_indirect_dispatch_tables): Likewise.\n+\t(add_field): Rename argument.\n+\t(is_compiled_class): Likewise.\n+\t(safe_layout_class): Likewise.\n+\t(emit_assertion_table): Likewise.\n+\t* typeck.c (has_method): Rename argument.\n+\n 2008-06-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* class.c (ident_subst, mangled_classname, unmangle_classname,"}, {"sha": "ef5cc0f89565814b1361465a41fee9b416144f20", "filename": "gcc/java/class.c", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -412,11 +412,12 @@ unmangle_classname (const char *name, int name_length)\n #define GEN_TABLE(TABLE, NAME, TABLE_TYPE, TYPE)\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  const char *typename = IDENTIFIER_POINTER (mangled_classname (\"\", TYPE)); \\\n-  char *buf = (char *) alloca (strlen (typename) + strlen (#NAME \"_syms_\") + 1); \\\n+  const char *type_name = IDENTIFIER_POINTER (mangled_classname (\"\", TYPE)); \\\n+  char *buf = (char *) alloca (strlen (type_name)\t\t\t\\\n+                               + strlen (#NAME \"_syms_\") + 1);\t\t\\\n   tree decl;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  sprintf (buf, #NAME \"_%s\", typename);\t\t\t\t\t\\\n+  sprintf (buf, #NAME \"_%s\", type_name);\t\t\t\t\\\n   TYPE_## TABLE ##_DECL (type) = decl =\t\t\t\t\t\\\n     build_decl (VAR_DECL, get_identifier (buf), TABLE_TYPE);\t\t\\\n   DECL_EXTERNAL (decl) = 1;\t\t\t\t\t\t\\\n@@ -428,7 +429,7 @@ do\t\t\t\t\t\t\t\t\t\\\n   pushdecl (decl);\t\t\t\t\t\t\t\\\n   MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\t\t\t\t\\\n   DECL_OWNER (decl) = TYPE;\t\t\t\t\t\t\\\n-  sprintf (buf, #NAME \"_syms_%s\", typename);\t\t\t\t\\\n+  sprintf (buf, #NAME \"_syms_%s\", type_name);\t\t\t\t\\\n   TYPE_## TABLE ##_SYMS_DECL (TYPE) =\t\t\t\t\t\\\n     build_decl (VAR_DECL, get_identifier (buf), symbols_array_type);\t\\\n   TREE_STATIC (TYPE_## TABLE ##_SYMS_DECL (TYPE)) = 1;\t\t\t\\\n@@ -442,13 +443,14 @@ while (0)\n void\n gen_indirect_dispatch_tables (tree type)\n {\n-  const char *typename = IDENTIFIER_POINTER (mangled_classname (\"\", type));\n+  const char *type_name = IDENTIFIER_POINTER (mangled_classname (\"\", type));\n   {  \n     tree field = NULL;\n-    char *buf = (char *) alloca (strlen (typename) + strlen (\"_catch_classes_\") + 1);\n+    char *buf = (char *) alloca (strlen (type_name)\n+\t\t\t\t + strlen (\"_catch_classes_\") + 1);\n     tree catch_class_type = make_node (RECORD_TYPE);\n \n-    sprintf (buf, \"_catch_classes_%s\", typename);\n+    sprintf (buf, \"_catch_classes_%s\", type_name);\n     PUSH_FIELD (catch_class_type, field, \"address\", utf8const_ptr_type);\n     PUSH_FIELD (catch_class_type, field, \"classname\", ptr_type_node);\n     FINISH_RECORD (catch_class_type);\n@@ -837,14 +839,14 @@ add_method (tree this_class, int access_flags, tree name, tree method_sig)\n }\n \n tree\n-add_field (tree class, tree name, tree field_type, int flags)\n+add_field (tree klass, tree name, tree field_type, int flags)\n {\n   int is_static = (flags & ACC_STATIC) != 0;\n   tree field;\n   field = build_decl (is_static ? VAR_DECL : FIELD_DECL, name, field_type);\n-  TREE_CHAIN (field) = TYPE_FIELDS (class);\n-  TYPE_FIELDS (class) = field;\n-  DECL_CONTEXT (field) = class;\n+  TREE_CHAIN (field) = TYPE_FIELDS (klass);\n+  TYPE_FIELDS (klass) = field;\n+  DECL_CONTEXT (field) = klass;\n   MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (field);\n \n   if (flags & ACC_PUBLIC) FIELD_PUBLIC (field) = 1;\n@@ -871,7 +873,7 @@ add_field (tree class, tree name, tree field_type, int flags)\n \tjava_hide_decl (field);\n       /* Considered external unless we are compiling it into this\n \t object file.  */\n-      DECL_EXTERNAL (field) = (is_compiled_class (class) != 2);\n+      DECL_EXTERNAL (field) = (is_compiled_class (klass) != 2);\n     }\n \n   return field;\n@@ -2227,43 +2229,43 @@ finish_class (void)\n   rest_of_decl_compilation (TYPE_NAME (current_class), 1, 0);\n }\n \n-/* Return 2 if CLASS is compiled by this compilation job;\n-   return 1 if CLASS can otherwise be assumed to be compiled;\n-   return 0 if we cannot assume that CLASS is compiled.\n+/* Return 2 if KLASS is compiled by this compilation job;\n+   return 1 if KLASS can otherwise be assumed to be compiled;\n+   return 0 if we cannot assume that KLASS is compiled.\n    Returns 1 for primitive and 0 for array types.  */\n int\n-is_compiled_class (tree class)\n+is_compiled_class (tree klass)\n {\n   int seen_in_zip;\n-  if (TREE_CODE (class) == POINTER_TYPE)\n-    class = TREE_TYPE (class);\n-  if (TREE_CODE (class) != RECORD_TYPE)  /* Primitive types are static. */\n+  if (TREE_CODE (klass) == POINTER_TYPE)\n+    klass = TREE_TYPE (klass);\n+  if (TREE_CODE (klass) != RECORD_TYPE)  /* Primitive types are static. */\n     return 1;\n-  if (TYPE_ARRAY_P (class))\n+  if (TYPE_ARRAY_P (klass))\n     return 0;\n \n-  seen_in_zip = (TYPE_JCF (class) && JCF_SEEN_IN_ZIP (TYPE_JCF (class)));\n-  if (CLASS_FROM_CURRENTLY_COMPILED_P (class))\n+  seen_in_zip = (TYPE_JCF (klass) && JCF_SEEN_IN_ZIP (TYPE_JCF (klass)));\n+  if (CLASS_FROM_CURRENTLY_COMPILED_P (klass))\n     {\n       /* The class was seen in the current ZIP file and will be\n \t available as a compiled class in the future but may not have\n \t been loaded already. Load it if necessary. This prevent\n \t build_class_ref () from crashing. */\n \n-      if (seen_in_zip && !CLASS_LOADED_P (class) && (class != current_class))\n-        load_class (class, 1);\n+      if (seen_in_zip && !CLASS_LOADED_P (klass) && (klass != current_class))\n+        load_class (klass, 1);\n \n       /* We return 2 for class seen in ZIP and class from files\n          belonging to the same compilation unit */\n       return 2;\n     }\n \n-  if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (class)))))\n+  if (assume_compiled (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (klass)))))\n     {\n-      if (!CLASS_LOADED_P (class))\n+      if (!CLASS_LOADED_P (klass))\n \t{\n-\t  if (class != current_class)\n-\t    load_class (class, 1);\n+\t  if (klass != current_class)\n+\t    load_class (klass, 1);\n \t}\n       return 1;\n     }\n@@ -2382,12 +2384,12 @@ maybe_layout_super_class (tree super_class, tree this_class ATTRIBUTE_UNUSED)\n    about the class processed currently.  */\n \n void\n-safe_layout_class (tree class)\n+safe_layout_class (tree klass)\n {\n   tree save_current_class = current_class;\n   location_t save_location = input_location;\n \n-  layout_class (class);\n+  layout_class (klass);\n \n   current_class = save_current_class;\n   input_location = save_location;\n@@ -3010,14 +3012,14 @@ add_assertion_table_entry (void **htab_entry, void *ptr)\n   return true;\n }\n \n-/* Generate the type assertion table for CLASS, and return its DECL.  */\n+/* Generate the type assertion table for KLASS, and return its DECL.  */\n \n static tree\n-emit_assertion_table (tree class)\n+emit_assertion_table (tree klass)\n {\n   tree null_entry, ctor, table_decl;\n   tree list = NULL_TREE;\n-  htab_t assertions_htab = TYPE_ASSERTIONS (class);\n+  htab_t assertions_htab = TYPE_ASSERTIONS (klass);\n \n   /* Iterate through the hash table.  */\n   htab_traverse (assertions_htab, add_assertion_table_entry, &list);\n@@ -3035,7 +3037,7 @@ emit_assertion_table (tree class)\n   list = nreverse (list);\n   ctor = build_constructor_from_list (assertion_table_type, list);\n \n-  table_decl = build_decl (VAR_DECL, mangled_classname (\"_type_assert_\", class),\n+  table_decl = build_decl (VAR_DECL, mangled_classname (\"_type_assert_\", klass),\n \t\t\t   assertion_table_type);\n \n   TREE_STATIC (table_decl) = 1;"}, {"sha": "265557ec241d572aa931aebad0f8a4cd76f28cd7", "filename": "gcc/java/constants.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -1,6 +1,6 @@\n /* Handle the constant pool of the Java(TM) Virtual Machine.\n    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,\n-   2007  Free Software Foundation, Inc.\n+   2007, 2008  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -327,14 +327,14 @@ get_tag_node (int tag)\n /* Given a class, return its constant pool, creating one if necessary.  */\n \n CPool *\n-cpool_for_class (tree class)\n+cpool_for_class (tree klass)\n {\n-  CPool *cpool = TYPE_CPOOL (class);\n+  CPool *cpool = TYPE_CPOOL (klass);\n \n   if (cpool == NULL)\n     {\n       cpool = GGC_CNEW (struct CPool);\n-      TYPE_CPOOL (class) = cpool;\n+      TYPE_CPOOL (klass) = cpool;\n     }\n   return cpool;\n }\n@@ -370,13 +370,13 @@ find_name_and_type_constant_tree (CPool *cpool, tree name, tree type)\n }\n \n /* Look for a field ref that matches DECL in the constant pool of\n-   CLASS.  \n+   KLASS.  \n    Return the index of the entry.  */\n \n int\n-alloc_constant_fieldref (tree class, tree decl)\n+alloc_constant_fieldref (tree klass, tree decl)\n {\n-  CPool *outgoing_cpool = cpool_for_class (class);\n+  CPool *outgoing_cpool = cpool_for_class (klass);\n   int class_index \n     = find_tree_constant (outgoing_cpool, CONSTANT_Class, \n \t\t\t  DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))));"}, {"sha": "d249157371de47e7e2edd7907a940512a3a128d9", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -1899,15 +1899,15 @@ java_mark_cni_decl_local (tree decl)\n /* Use the preceding two functions and mark all members of the class.  */\n \n void\n-java_mark_class_local (tree class)\n+java_mark_class_local (tree klass)\n {\n   tree t;\n \n-  for (t = TYPE_FIELDS (class); t ; t = TREE_CHAIN (t))\n+  for (t = TYPE_FIELDS (klass); t ; t = TREE_CHAIN (t))\n     if (FIELD_STATIC (t))\n       java_mark_decl_local (t);\n \n-  for (t = TYPE_METHODS (class); t ; t = TREE_CHAIN (t))\n+  for (t = TYPE_METHODS (klass); t ; t = TREE_CHAIN (t))\n     if (!METHOD_ABSTRACT (t))\n       {\n \tif (METHOD_NATIVE (t) && !flag_jni)"}, {"sha": "c64f6d68ebacbde2a4e21fe17abca0e1f9aa75f8", "filename": "gcc/java/expr.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -457,20 +457,20 @@ type_assertion_hash (const void *p)\n }\n \n /* Add an entry to the type assertion table for the given class.  \n-   CLASS is the class for which this assertion will be evaluated by the \n+   KLASS is the class for which this assertion will be evaluated by the \n    runtime during loading/initialization.\n    ASSERTION_CODE is the 'opcode' or type of this assertion: see java-tree.h.\n    OP1 and OP2 are the operands. The tree type of these arguments may be\n    specific to each assertion_code. */\n \n void\n-add_type_assertion (tree class, int assertion_code, tree op1, tree op2)\n+add_type_assertion (tree klass, int assertion_code, tree op1, tree op2)\n {\n   htab_t assertions_htab;\n   type_assertion as;\n   void **as_pp;\n \n-  assertions_htab = TYPE_ASSERTIONS (class);\n+  assertions_htab = TYPE_ASSERTIONS (klass);\n   if (assertions_htab == NULL)\n     {\n       assertions_htab = htab_create_ggc (7, type_assertion_hash, \n@@ -893,7 +893,7 @@ build_java_indirect_ref (tree type, tree expr, int check)\n tree\n build_java_arrayaccess (tree array, tree type, tree index)\n {\n-  tree node, throw = NULL_TREE;\n+  tree node, throw_expr = NULL_TREE;\n   tree data_field;\n   tree ref;\n   tree array_type = TREE_TYPE (TREE_TYPE (array));\n@@ -921,17 +921,18 @@ build_java_arrayaccess (tree array, tree type, tree index)\n \t\t\t  len);\n       if (! integer_zerop (test))\n \t{\n-\t  throw = build2 (TRUTH_ANDIF_EXPR, int_type_node, test,\n-\t\t\t  build_java_throw_out_of_bounds_exception (index));\n+\t  throw_expr\n+\t    = build2 (TRUTH_ANDIF_EXPR, int_type_node, test,\n+\t\t      build_java_throw_out_of_bounds_exception (index));\n \t  /* allows expansion within COMPOUND */\n-\t  TREE_SIDE_EFFECTS( throw ) = 1;\n+\t  TREE_SIDE_EFFECTS( throw_expr ) = 1;\n \t}\n     }\n \n   /* If checking bounds, wrap the index expr with a COMPOUND_EXPR in order\n      to have the bounds check evaluated first. */\n-  if (throw != NULL_TREE)\n-    index = build2 (COMPOUND_EXPR, int_type_node, throw, index);\n+  if (throw_expr != NULL_TREE)\n+    index = build2 (COMPOUND_EXPR, int_type_node, throw_expr, index);\n \n   data_field = lookup_field (&array_type, get_identifier (\"data\"));\n \n@@ -3447,9 +3448,9 @@ process_jvm_instruction (int PC, const unsigned char* byte_ops,\n   }\n #define ARRAY_NEW_MULTI()\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n-    tree class = get_class_constant (current_jcf, IMMEDIATE_u2 );\t\\\n+    tree klass = get_class_constant (current_jcf, IMMEDIATE_u2 );\t\\\n     int  ndims = IMMEDIATE_u1;\t\t\t\t\t\\\n-    expand_java_multianewarray( class, ndims );\t\t\t\\\n+    expand_java_multianewarray( klass, ndims );\t\t\t\\\n   }\n \n #define UNOP(OPERAND_TYPE, OPERAND_VALUE) \\"}, {"sha": "52120971fa2b0afca82356e24409a5ffbca0e845", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -1,6 +1,6 @@\n /* Utility routines for finding and reading Java(TM) .class files.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005,\n-   2006, 2007 Free Software Foundation, Inc.\n+   2006, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -448,7 +448,7 @@ const char *\n find_class (const char *classname, int classname_length, JCF *jcf)\n {\n   int fd;\n-  int i, k, class = -1;\n+  int i, k, klass = -1;\n   struct stat class_buf;\n   char *dep_file;\n   void *entry;\n@@ -478,7 +478,7 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n   for (entry = jcf_path_start (); entry != NULL; entry = jcf_path_next (entry))\n     {\n       const char *path_name = jcf_path_name (entry);\n-      if (class != 0)\n+      if (klass != 0)\n \t{\n \t  int dir_len;\n \n@@ -521,12 +521,12 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n \t      else\n \t\tcontinue;\n \t    }\n-\t  class = caching_stat(buffer, &class_buf);\n+\t  klass = caching_stat(buffer, &class_buf);\n \t}\n     }\n \n   dep_file = buffer;\n-  if (!class)\n+  if (!klass)\n     {\n       SOURCE_FRONTEND_DEBUG ((stderr, \"[Class selected: %s]\\n\",\n \t\t\t      classname+classname_length-"}, {"sha": "8757c5b7981b9f55b8b90c11cfaaa646a94afbeb", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -1160,8 +1160,8 @@ handle_innerclass_attribute (int count, JCF *jcf, int attribute_length)\n       /* If icii is 0, don't try to read the class. */\n       if (icii >= 0)\n \t{\n-\t  tree class = get_class_constant (jcf, icii);\n-\t  tree decl = TYPE_NAME (class);\n+\t  tree klass = get_class_constant (jcf, icii);\n+\t  tree decl = TYPE_NAME (klass);\n           /* Skip reading further if ocii is null */\n           if (DECL_P (decl) && !CLASS_COMPLETE_P (decl) && ocii)\n \t    {\n@@ -1253,16 +1253,16 @@ int\n read_class (tree name)\n {\n   JCF this_jcf, *jcf;\n-  tree icv, class = NULL_TREE;\n+  tree icv, klass = NULL_TREE;\n   tree save_current_class = current_class;\n   tree save_output_class = output_class;\n   location_t save_location = input_location;\n   JCF *save_current_jcf = current_jcf;\n \n   if ((icv = IDENTIFIER_CLASS_VALUE (name)) != NULL_TREE)\n     {\n-      class = TREE_TYPE (icv);\n-      jcf = TYPE_JCF (class);\n+      klass = TREE_TYPE (icv);\n+      jcf = TYPE_JCF (klass);\n     }\n   else\n     jcf = NULL;\n@@ -1284,21 +1284,21 @@ read_class (tree name)\n \n   current_jcf = jcf;\n \n-  if (class == NULL_TREE || ! CLASS_PARSED_P (class))\n+  if (klass == NULL_TREE || ! CLASS_PARSED_P (klass))\n     {\n-      output_class = current_class = class;\n+      output_class = current_class = klass;\n       if (JCF_SEEN_IN_ZIP (current_jcf))\n \tread_zip_member(current_jcf,\n \t\t\tcurrent_jcf->zipd, current_jcf->zipd->zipf);\n       jcf_parse (current_jcf);\n       /* Parsing might change the class, in which case we have to\n \t put it back where we found it.  */\n-      if (current_class != class && icv != NULL_TREE)\n+      if (current_class != klass && icv != NULL_TREE)\n \tTREE_TYPE (icv) = current_class;\n-      class = current_class;\n+      klass = current_class;\n     }\n-  layout_class (class);\n-  load_inner_classes (class);\n+  layout_class (klass);\n+  load_inner_classes (klass);\n \n   output_class = save_output_class;\n   current_class = save_current_class;\n@@ -2025,7 +2025,7 @@ parse_zip_file_entries (void)\n   for (i = 0, zdir = (ZipDirectory *)localToFile->central_directory;\n        i < localToFile->count; i++, zdir = ZIPDIR_NEXT (zdir))\n     {\n-      tree class;\n+      tree klass;\n \n       switch (classify_zip_file (zdir))\n \t{\n@@ -2036,14 +2036,14 @@ parse_zip_file_entries (void)\n \t  {\n \t    char *class_name = compute_class_name (zdir);\n \t    int previous_alias_set = -1;\n-\t    class = lookup_class (get_identifier (class_name));\n+\t    klass = lookup_class (get_identifier (class_name));\n \t    FREE (class_name);\n-\t    current_jcf = TYPE_JCF (class);\n-\t    output_class = current_class = class;\n+\t    current_jcf = TYPE_JCF (klass);\n+\t    output_class = current_class = klass;\n \n \t    /* This is a dummy class, and now we're compiling it for\n \t       real.  */\n-\t    gcc_assert (! TYPE_DUMMY (class));\n+\t    gcc_assert (! TYPE_DUMMY (klass));\n \n \t    /* This is for a corner case where we have a superclass\n \t       but no superclass fields.\n@@ -2058,17 +2058,17 @@ parse_zip_file_entries (void)\n \t       FIXME: this really is a kludge.  We should figure out a\n \t       way to lay out the class properly before this\n \t       happens.  */\n-\t    if (TYPE_SIZE (class) && CLASSTYPE_SUPER (class)\n-\t\t&& integer_zerop (TYPE_SIZE (class)))\n+\t    if (TYPE_SIZE (klass) && CLASSTYPE_SUPER (klass)\n+\t\t&& integer_zerop (TYPE_SIZE (klass)))\n \t      {\n-\t\tTYPE_SIZE (class) = NULL_TREE;\n-\t\tprevious_alias_set = TYPE_ALIAS_SET (class);\n-\t\tTYPE_ALIAS_SET (class) = -1;\n+\t\tTYPE_SIZE (klass) = NULL_TREE;\n+\t\tprevious_alias_set = TYPE_ALIAS_SET (klass);\n+\t\tTYPE_ALIAS_SET (klass) = -1;\n \t      }\n \n-\t    if (! CLASS_LOADED_P (class))\n+\t    if (! CLASS_LOADED_P (klass))\n \t      {\n-\t\tif (! CLASS_PARSED_P (class))\n+\t\tif (! CLASS_PARSED_P (klass))\n \t\t  {\n \t\t    read_zip_member (current_jcf, zdir, localToFile);\n \t\t    jcf_parse (current_jcf);\n@@ -2078,7 +2078,7 @@ parse_zip_file_entries (void)\n \t      }\n \n \t    if (previous_alias_set != -1)\n-\t      TYPE_ALIAS_SET (class) = previous_alias_set;\n+\t      TYPE_ALIAS_SET (klass) = previous_alias_set;\n \n \t    if (TYPE_SIZE (current_class) != error_mark_node)\n \t      {\n@@ -2146,7 +2146,7 @@ process_zip_dir (FILE *finput)\n        i < localToFile->count; i++, zdir = ZIPDIR_NEXT (zdir))\n     {\n       char *class_name, *file_name, *class_name_in_zip_dir;\n-      tree class;\n+      tree klass;\n       JCF  *jcf;\n \n       class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n@@ -2163,25 +2163,25 @@ process_zip_dir (FILE *finput)\n       strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);\n       file_name [zdir->filename_length] = '\\0';\n \n-      class = lookup_class (get_identifier (class_name));\n+      klass = lookup_class (get_identifier (class_name));\n \n-      if (CLASS_FROM_CURRENTLY_COMPILED_P (class))\n+      if (CLASS_FROM_CURRENTLY_COMPILED_P (klass))\n \t{\n \t  /* We've already compiled this class.  */\n \t  duplicate_class_warning (file_name);\n \t  continue;\n \t}\n       /* This function is only called when processing a zip file seen\n \t on the command line.  */\n-      CLASS_FROM_CURRENTLY_COMPILED_P (class) = 1;\n+      CLASS_FROM_CURRENTLY_COMPILED_P (klass) = 1;\n \n       jcf->read_state  = finput;\n       jcf->filbuf      = jcf_filbuf_from_stdio;\n       jcf->classname   = class_name;\n       jcf->filename    = file_name;\n       jcf->zipd        = zdir;\n \n-      TYPE_JCF (class) = jcf;\n+      TYPE_JCF (klass) = jcf;\n     }\n }\n "}, {"sha": "7e21770ec5116be8266dee945e0ff857f8e55fbe", "filename": "gcc/java/jcf-path.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fjcf-path.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fjcf-path.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-path.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -1,6 +1,6 @@\n /* Handle CLASSPATH, -classpath, and path searching.\n    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006,\n-   2007 Free Software Foundation, Inc.\n+   2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -213,7 +213,7 @@ void\n jcf_path_init (void)\n {\n   char *cp;\n-  char *try, sep[2];\n+  char *attempt, sep[2];\n   struct stat stat_b;\n   int found = 0, len;\n \n@@ -227,56 +227,56 @@ jcf_path_init (void)\n   GET_ENVIRONMENT (cp, \"GCC_EXEC_PREFIX\");\n   if (cp)\n     {\n-      try = (char *) alloca (strlen (cp) + 50);\n+      attempt = (char *) alloca (strlen (cp) + 50);\n       /* The exec prefix can be something like\n \t /usr/local/bin/../lib/gcc-lib/.  We want to change this\n \t into a pointer to the share/java directory.  We support two\n \t configurations: one where prefix and exec-prefix are the\n \t same, and one where exec-prefix is `prefix/SOMETHING'.  */\n-      strcpy (try, cp);\n-      strcat (try, DIR_UP);\n-      strcat (try, sep);\n-      strcat (try, DIR_UP);\n-      strcat (try, sep);\n-      len = strlen (try);\n-\n-      strcpy (try + len, \"share\");\n-      strcat (try, sep);\n-      strcat (try, \"java\");\n-      strcat (try, sep);\n-      strcat (try, \"libgcj-\" DEFAULT_TARGET_VERSION \".jar\");\n-      if (! stat (try, &stat_b))\n+      strcpy (attempt, cp);\n+      strcat (attempt, DIR_UP);\n+      strcat (attempt, sep);\n+      strcat (attempt, DIR_UP);\n+      strcat (attempt, sep);\n+      len = strlen (attempt);\n+\n+      strcpy (attempt + len, \"share\");\n+      strcat (attempt, sep);\n+      strcat (attempt, \"java\");\n+      strcat (attempt, sep);\n+      strcat (attempt, \"libgcj-\" DEFAULT_TARGET_VERSION \".jar\");\n+      if (! stat (attempt, &stat_b))\n \t{\n-\t  add_entry (&sys_dirs, try, 1);\n+\t  add_entry (&sys_dirs, attempt, 1);\n \t  found = 1;\n-\t  strcpy (&try[strlen (try)\n-\t\t      - strlen (\"libgcj-\" DEFAULT_TARGET_VERSION \".jar\")],\n+\t  strcpy (&attempt[strlen (attempt)\n+\t\t\t   - strlen (\"libgcj-\" DEFAULT_TARGET_VERSION \".jar\")],\n \t\t  sep);\n-\t  strcat (try, \"ext\");\n-\t  strcat (try, sep);\n-\t  if (! stat (try, &stat_b))\n-\t    jcf_path_extdirs_arg (try);\n+\t  strcat (attempt, \"ext\");\n+\t  strcat (attempt, sep);\n+\t  if (! stat (attempt, &stat_b))\n+\t    jcf_path_extdirs_arg (attempt);\n \t}\n       else\n \t{\n-\t  strcpy (try + len, DIR_UP);\n-\t  strcat (try, sep);\n-\t  strcat (try, \"share\");\n-\t  strcat (try, sep);\n-\t  strcat (try, \"java\");\n-\t  strcat (try, sep);\n-\t  strcat (try, \"libgcj-\" DEFAULT_TARGET_VERSION \".jar\");\n-\t  if (! stat (try, &stat_b))\n+\t  strcpy (attempt + len, DIR_UP);\n+\t  strcat (attempt, sep);\n+\t  strcat (attempt, \"share\");\n+\t  strcat (attempt, sep);\n+\t  strcat (attempt, \"java\");\n+\t  strcat (attempt, sep);\n+\t  strcat (attempt, \"libgcj-\" DEFAULT_TARGET_VERSION \".jar\");\n+\t  if (! stat (attempt, &stat_b))\n \t    {\n-\t      add_entry (&sys_dirs, try, 1);\n+\t      add_entry (&sys_dirs, attempt, 1);\n \t      found = 1;\n-\t      strcpy (&try[strlen (try)\n-\t\t\t  - strlen (\"libgcj-\" DEFAULT_TARGET_VERSION \".jar\")],\n+\t      strcpy (&attempt[strlen (attempt)\n+\t\t\t       - strlen (\"libgcj-\" DEFAULT_TARGET_VERSION \".jar\")],\n \t\t      sep);\n-\t      strcat (try, \"ext\");\n-\t      strcat (try, sep);\n-\t      if (! stat (try, &stat_b))\n-\t\tjcf_path_extdirs_arg (try);\n+\t      strcat (attempt, \"ext\");\n+\t      strcat (attempt, sep);\n+\t      if (! stat (attempt, &stat_b))\n+\t\tjcf_path_extdirs_arg (attempt);\n \t    }\n \t}\n     }"}, {"sha": "61594d9b5ed234865dbb2c0910f80c0b8417dbca", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -1,6 +1,6 @@\n /* Functions related to mangling class names for the GNU compiler\n    for the Java(TM) language.\n-   Copyright (C) 1998, 1999, 2001, 2002, 2003, 2006, 2007\n+   Copyright (C) 1998, 1999, 2001, 2002, 2003, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -782,13 +782,13 @@ compression_table_add (tree type)\n {\n   if (compression_next == TREE_VEC_LENGTH (compression_table))\n     {\n-      tree new = make_tree_vec (2*compression_next);\n+      tree new_table = make_tree_vec (2*compression_next);\n       int i;\n \n       for (i = 0; i < compression_next; i++)\n-\tTREE_VEC_ELT (new, i) = TREE_VEC_ELT (compression_table, i);\n+\tTREE_VEC_ELT (new_table, i) = TREE_VEC_ELT (compression_table, i);\n \n-      compression_table = new;\n+      compression_table = new_table;\n     }\n   TREE_VEC_ELT (compression_table, compression_next++) = type;\n }"}, {"sha": "1028c73ad14c68e36a7789d5c0b3d01968956e78", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02a84d9bea57d5ea8bc688a52c4ad568811d0e3/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=f02a84d9bea57d5ea8bc688a52c4ad568811d0e3", "patch": "@@ -1,5 +1,5 @@\n /* Handle types for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2007\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -691,11 +691,11 @@ lookup_java_method (tree searched_class, tree method_name,\n \t\t    method_signature, build_java_signature);\n }\n \n-/* Return true iff CLASS (or its ancestors) has a method METHOD_NAME. \ufffd*/\n+/* Return true iff KLASS (or its ancestors) has a method METHOD_NAME. \ufffd*/\n int\n-has_method (tree class, tree method_name)\n+has_method (tree klass, tree method_name)\n {\n-  return lookup_do (class, SEARCH_INTERFACE,\n+  return lookup_do (klass, SEARCH_INTERFACE,\n \t\t    method_name, NULL_TREE,\n \t\t    build_null_signature) != NULL_TREE;\n }"}]}