{"sha": "3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E1NzVmMjUzZGNlNWNkZDNlZjczZDZlMmU2Yjk4OTBmYTE4Mjg0OQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:39Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:39Z"}, "message": "\ufffd\nMigrate from devo/gcc/ch.\n\nFrom-SVN: r22036", "tree": {"sha": "61e04c7d2081a74ee0ad3b00146aafc9fe778b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61e04c7d2081a74ee0ad3b00146aafc9fe778b3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/comments", "author": null, "committer": null, "parents": [{"sha": "a2ca17fa85bce1ba96853420c712d92f369237fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ca17fa85bce1ba96853420c712d92f369237fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ca17fa85bce1ba96853420c712d92f369237fb"}], "stats": {"total": 1799, "additions": 1799, "deletions": 0}, "files": [{"sha": "95632b04aab5311590782045f27118e59cbbeb68", "filename": "gcc/ch/Make-lang.in", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FMake-lang.in?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,209 @@\n+# Top level Makefile fragment for GNU CHILL.\n+#   Copyright (C) 1994 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+# This file provides the language dependent support in the main Makefile.\n+# Each language makefile fragment must provide the following targets:\n+#\n+# foo.all.build, foo.all.cross, foo.start.encap, foo.rest.encap,\n+# foo.info, foo.dvi,\n+# foo.install-normal, foo.install-common, foo.install-info, foo.install-man,\n+# foo.uninstall, foo.distdir,\n+# foo.mostlyclean, foo.clean, foo.distclean, foo.extraclean,\n+# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4\n+#\n+# where `foo' is the name of the language.\n+#\n+# It should also provide rules for:\n+#\n+# - making any compiler driver (eg: g++)\n+# - the compiler proper (eg: cc1plus)\n+# - define the names for selecting the language in LANGUAGES.\n+\f\n+# define version of GNUCHILL compiler. Note: maybe we have to change the\n+# mechanism\n+GNUCHILL_VERSION = 1.5.2\n+\n+# Actual names to use when installing a native compiler.\n+# (Cygnus configure overrides these when using -program-transform-name).\n+CHILL_INSTALL_NAME = chill\n+\n+# Actual names to use when installing a cross-compiler.\n+# (Cygnus configure overrides these when using -program-transform-name).\n+CHILL_CROSS_NAME = $(target_alias)-chill\n+\n+CHILL_SRCS = $(srcdir)/ch/actions.c $(srcdir)/ch/convert.c \\\n+ $(srcdir)/ch/decl.c $(srcdir)/ch/except.c $(srcdir)/ch/expr.c \\\n+ $(srcdir)/ch/grant.c $(srcdir)/ch/inout.c $(srcdir)/ch/lang.c \\\n+ $(srcdir)/ch/lex.c $(srcdir)/ch/loop.c \\\n+ $(srcdir)/ch/parse.c $(srcdir)/ch/satisfy.c \\\n+ $(srcdir)/ch/tasking.c $(srcdir)/ch/timing.c $(srcdir)/ch/tree.c \\\n+ $(srcdir)/ch/typeck.c\n+\n+# Extra flags to pass to recursive makes.\n+CHILL_FLAGS_TO_PASS = \\\n+\t\"CHILLFLAGS=$(CHILLFLAGS)\" \\\n+\t\"CHILL_FOR_TARGET=$(CHILL_FOR_TARGET)\" \\\n+\t\"CHILL_LIB=$(CHILL_LIB)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"GNUCHILL_VERSION=$(GNUCHILL_VERSION)\"\n+\f\n+# Define the names for selecting languages in LANGUAGES.\n+CHILL: chill cc1chill chill-runtime\n+\n+# handle startfile in chill script and build script to install\n+chill: $(srcdir)/ch/chill.in Makefile\n+\tthisdir=`pwd` ; \\\n+\tsed -e \"s:startfile=chillrt0:startfile=$${thisdir}/ch/runtime/chillrt0.o:\" \\\n+\t    -e \"s:libpath=chillrt:libpath=-L$${thisdir}/ch/runtime/:\" \\\n+\t    -e \"s:whatgcc=gcc:whatgcc=\\\"$${thisdir}/xgcc -B$${thisdir}/\\\":\" \\\n+\t    -e \"s:gnuchill_version=unknown:gnuchill_version=$(GNUCHILL_VERSION):\" \\\n+\t    -e \"s:gnuchill_script_flags=:gnuchill_script_flags=\\\"$(GNUCHILL_SCRIPT_FLAGS)\\\":\" $(srcdir)/ch/chill.in > chill ; \\\n+\tchmod a+x chill ; \\\n+\tif [ -f ../gcc-cross$(exeext) ]; then \\\n+\t  whatgcc=$(GCC_CROSS_NAME) ; \\\n+\telse \\\n+\t  whatgcc=$(GCC_INSTALL_NAME) ; \\\n+\tfi; \\\n+\tsed -e \"s:startfile=chillrt0:startfile=$(libsubdir)/chillrt0.o:\" \\\n+\t    -e \"s:whatgcc=gcc:whatgcc=$(bindir)/$${whatgcc}:\" \\\n+\t    -e \"s:gnuchill_version=unknown:gnuchill_version=$(GNUCHILL_VERSION):\" \\\n+\t    -e \"s:libpath=chillrt:libpath=:\" \\\n+\t    -e \"s:gnuchill_script_flags=:gnuchill_script_flags=\\\"$(GNUCHILL_SCRIPT_FLAGS)\\\":\" $(srcdir)/ch/chill.in > chill.install ; \\\n+\tchmod a+x chill.install\n+\n+# Don't depend on cc1chill, because chill-cross is always built for cross,\n+# and thus a cc1chill dependence would force cc1chill to always be built.\n+# Note that gcc-cross and g++-cross do not have cc1 or cc1plus dependencies.\n+chill-cross: $(srcdir)/ch/chill.in\n+\ttouch $@\n+\n+cc1chill: $(P) $(CHILL_SRCS) $(LIBDEPS) stamp-objlist \\\n+\tinsn-config.h insn-flags.h insn-attr.h insn-codes.h \\\n+\tc-typeck.o c-aux-info.o c-common.o c-iterate.o\n+\tcd ch; $(MAKE) $(FLAGS_TO_PASS) $(CHILL_FLAGS_TO_PASS) ../cc1chill\n+\n+chill-runtime: stmp-headers $(GCC_PASSES)\n+\tcase \"$(LANGUAGES)\" in \\\n+\t*CHILL*) if [ -f ch/runtime/Makefile -a -z \"$(CROSS)\" ] ; then \\\n+\t\t   thisdir1=`pwd`; \\\n+\t\t   cd ch/runtime; $(MAKE) $(FLAGS_TO_PASS) $(CHILL_FLAGS_TO_PASS) GCC_FOR_TARGET=\"$${thisdir1}/xgcc -B$${thisdir1}/\" all ; \\\n+\t\t else true; fi ;; \\\n+\tesac\n+\f\n+# Build hooks:\n+\n+CHILL.all.build: chill\n+CHILL.all.cross: chill-cross\n+CHILL.start.encap: chill\n+CHILL.rest.encap:\n+\n+CHILL.info: $(srcdir)/ch/chill.texi\n+\t$(MAKEINFO) -I$(srcdir)/ch $(srcdir)/ch/chill.texi -o chill.info\n+\n+chill.dvi: $(srcdir)/ch/chill.texi $(srcdir)/extend.texi $(srcdir)/invoke.texi $(srcdir)/md.texi $(srcdir)/rtl.texi $(srcdir)/tm.texi\n+\tcd ch ; \\\n+\tTEXINPUTS=${texidir}:$(srcdir):$$TEXINPUTS tex chill.texi ; \\\n+\ttexindex chill.?? ; \\\n+\tTEXINPUTS=${texidir}:$(srcdir):$$TEXINPUTS tex chill.texi\n+# FIXME: Not sure languages should do this.\n+\tcp ch/chill.dvi chill.dvi\n+\f\n+# Install hooks:\n+# cc1chill is installed elsewhere as part of $(COMPILERS).\n+\n+CHILL.install-normal: install-libchill\n+\n+# Install the CHILL run time library.\n+install-libchill: chill-runtime\n+\tif [ -f ch/runtime/libchill.a ] ; then \\\n+\t  $(INSTALL_DATA) ch/runtime/libchill.a $(libsubdir)/libchill.a; \\\n+\t  if $(RANLIB_TEST) ; then \\\n+\t    (cd $(libsubdir); $(RANLIB) libchill.a); else true; fi; \\\n+\t  chmod a-x $(libsubdir)/libchill.a; \\\n+\t  $(INSTALL_DATA) ch/runtime/chillrt0.o $(libsubdir)/chillrt0.o; \\\n+\telse true; fi\n+\n+# Install the driver program\n+CHILL.install-common:\n+\t-if [ -f cc1chill ] ; then \\\n+\t  if [ -f chill.install ] ; then \\\n+\t    if [ -f gcc-cross$(exeext) ]; then \\\n+\t      rm -f $(bindir)/$(CHILL_CROSS_NAME); \\\n+\t      $(INSTALL_PROGRAM) chill.install $(bindir)/$(CHILL_CROSS_NAME); \\\n+\t      chmod a+x $(bindir)/$(CHILL_CROSS_NAME); \\\n+\t    else \\\n+\t      rm -f $(bindir)/$(CHILL_INSTALL_NAME); \\\n+\t      $(INSTALL_PROGRAM) chill.install $(bindir)/$(CHILL_INSTALL_NAME); \\\n+\t      chmod a+x $(bindir)/$(CHILL_INSTALL_NAME); \\\n+\t    fi ; \\\n+\t  fi ; \\\n+\tfi\n+\n+CHILL.install-info:\n+\t-for i in chill.info*; do \\\n+\t  rm -f $(infodir)/$$i; \\\n+\t  $(INSTALL_DATA) $$i $(infodir)/$$i; \\\n+\tdone\n+\n+CHILL.install-man:\n+\n+CHILL.uninstall:\n+\t-rm -rf $(bindir)/$(CHILL_INSTALL_NAME)\n+\t-rm -rf $(bindir)/$(CHILL_CROSS_NAME)\n+\f\n+# Clean hooks:\n+# A lot of the ancillary files are deleted by the main makefile.\n+# We just have to delete files specific to us.\n+\n+CHILL.mostlyclean:\n+\t-rm -f chill.install ch/*.o ch/ch-version.c\n+\t-cd ch/runtime && $(MAKE) mostlyclean\n+CHILL.clean:\n+CHILL.distclean:\n+\t-rm -f ch/config.status ch/Makefile\n+CHILL.extraclean:\n+CHILL.maintainer-clean:\n+\t-rm -f ch/TAGS\n+\t-rm -f ch/chill.info* ch/chill.dvi ch/chill.??s ch/chill.*aux\n+# CYGNUS LOCAL: Delete locally created file.\n+\t-rm -f ch/hash.h\n+\f\n+# Stage hooks:\n+# The main makefile has already created stage?/ch.\n+\n+CHILL.stage1:\n+\t-mv ch/*.o stage1/ch\n+CHILL.stage2:\n+\t-mv ch/*.o stage2/ch\n+CHILL.stage3:\n+\t-mv ch/*.o stage3/ch\n+CHILL.stage4:\n+\t-mv ch/*.o stage4/ch\n+\f\n+# Maintenance hooks:\n+\n+# This target creates the files that can be rebuilt, but go in the\n+# distribution anyway.  It then copies the files to the distdir directory.\n+CHILL.distdir:\n+\tmkdir tmp/ch\n+\tcd ch ; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) hash.h\n+\tcd ch; \\\n+\tfor file in *[0-9a-zA-Z+]; do \\\n+\t  ln $$file ../tmp/ch >/dev/null 2>&1 || cp $$file ../tmp/ch; \\\n+\tdone"}, {"sha": "af8edb0c00d6a3ab0be87484cdae772d7411ad89", "filename": "gcc/ch/ch-tree.def", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fch-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fch-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fch-tree.def?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,113 @@\n+/* This file contains the definitions and documentation for the\n+   additional tree codes used in the CHILL front end (see tree.def\n+   for the standard codes).\n+   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* \n+ * CHILL types.\n+ */\n+DEFTREECODE (GRANT_TYPE, \"grant_type\", 't', 0)\n+DEFTREECODE (SEIZE_TYPE, \"seize_type\", 't', 0)\n+/* \n+ * CHILL decls.\n+ */\n+DEFTREECODE (KEYWORD_DECL, \"keyword_decl\", 'd', 0)\n+DEFTREECODE (INSTANCE_METHOD_DECL, \"instance_method_decl\", 'd', 0)\n+DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", 'd', 0)\n+\n+/* A 'SEIZE (OLD->NEW)!POSTFIX' or 'GRANT (OLD->NEW)!POSTFIX' is\n+   represented as an ALIAS_DECL where DECL_OLD_PREFIX, DECL_NEW_PREFIX,\n+   and DECL_POSTFIX points to OLD, NEW, and POSTFIX, repectively.\n+   These are IDENTIFIER_NODEs, or NULL if empty.\n+   DECL_NAME is NEW!POSTFIX.  After binding, DECL_ABSTRACT_ORIGIN\n+   (if not an error_mark) points to a decl whose DECL_NAME is OLD!POSTFIX.\n+   and which this name is linked to.\n+   For SEIZE, DECL_SEIZEFILE names the most recent use_seize_file directive.\n+   For GRANT, DECL_SEIZEFILE names the seizefile doing the granting. */\n+DEFTREECODE (ALIAS_DECL, \"alias_decl\", 'd', 0)\n+\n+/* A variable, which is BASED on a pointer variable in DECL_ABSTRACT_ORIGIN. */\n+DEFTREECODE (BASED_DECL, \"based_decl\", 'd', 0)\n+\n+/* A pseudo-variable declared by a DO WITH. */\n+DEFTREECODE (WITH_DECL, \"with_decl\", 'd', 0)\n+\n+/*\n+ * CHILL exprs.\n+ */\n+DEFTREECODE (CONCAT_EXPR, \"concat_expr\", '2', 2)\n+\n+/* A slice (sub-array or sub-string) of operand 0, where\n+   operand 1 is the start of the slice, and operand 2 is its length.\n+   Currently, only used for bitstring sclices. */\n+DEFTREECODE (SLICE_EXPR, \"slice_expr\", 'e', 3)\n+\n+/* Later, SET_IN_EXPR might be replaced by BIT_FIELD_REF or IN_EXPR. */\n+DEFTREECODE (SET_IN_EXPR, \"set_in_expr\", '2', 2)\n+\n+/* A CASE_EXPR EX implements Chill CASE expression.\n+   TREE_OPERAND (EX, 0) is a TREE_LIST representing the <case selector list>,\n+   with one node for each expression.  (Only one is supported by the\n+   current implementation.)\n+   TREE_OPERAND (EX, 1) is also a TREE_LIST, with one node for each\n+   <value case alternative>.   The TREE_VALUE of these node is the\n+   <sub expression> (case element body); the TREE_PURPOSE contains\n+   the <case label specification>.  (The TREE_PURPOSE for the\n+   optional ELSE (default) branch is NULL_TREE.)  Each <case label\n+   specification> is also represented as a list with one TREE_LIST\n+   node for each <case label list> (though only length==1 is currently\n+   supported).  And finally: each <case label list> is again a list\n+   with one TREE_LIST node for each <case label>. */\n+DEFTREECODE (CASE_EXPR, \"case_expr\", 'e', 2)\n+\n+/* Powerset and static bit array operations.\n+   Operands have same mode as result.  */\n+DEFTREECODE (SET_NOT_EXPR,  \"set_not_expr\",  '1', 1)\n+DEFTREECODE (SET_IOR_EXPR,  \"set_ior_expr\",  '2', 2)\n+DEFTREECODE (SET_XOR_EXPR,  \"set_xor_expr\",  '2', 2)\n+DEFTREECODE (SET_AND_EXPR,  \"set_and_expr\",  '2', 2)\n+DEFTREECODE (SET_DIFF_EXPR, \"set_diff_expr\", '2', 2)\n+DEFTREECODE (PAREN_EXPR,  \"paren_expr\",  '1', 1)\n+\n+DEFTREECODE (STRING_EQ_EXPR, \"string_eq_expr\", '2', 2)\n+DEFTREECODE (STRING_LT_EXPR, \"string_lt_expr\", '2', 2)\n+\n+/* Used to represent a string repetition expression, until\n+   we have a type for it;  a SET_TYPE replicator needs a\n+   TYPE_DOMAIN even if it represents the empty set */\n+DEFTREECODE (REPLICATE_EXPR, \"replicate_expr\", 'e', 2)\n+\n+/* An undefined value.  Used for the Chill operator '*',\n+   and sometimes for padding. */\n+DEFTREECODE (UNDEFINED_EXPR, \"undefined_expr\", 'e', 0)\n+\n+/* Used to represent a process instance */\n+DEFTREECODE (INSTANCE_TYPE, \"instance_type\", 't', 0)\n+\n+/* Used to represent a reference to an array of bitfields. Currently restricted\n+   to fields which are 1 bit wide.  */\n+DEFTREECODE (PACKED_ARRAY_REF, \"packed_array_ref\", 'r', 2)\n+\n+/* ALSO NOTE:  LANG_TYPE is used for two things during pass 1;\n+   such a node is converted to some other type node during satisfy.\n+   If CH_NOVELTY_FLAG is set, then this node is a logical copy of\n+   its TREE_TYPE, but with a different novelty.\n+   If TYPE_READONLY is set, then the node stands for 'READ M'\n+   where M is the TREE_TYPE.  */"}, {"sha": "2933fa83e9d56555d0798c6a1edea20f9edf73b8", "filename": "gcc/ch/runtime/abstime.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fabstime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fabstime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fabstime.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,131 @@\n+/* Implement timing-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <time.h>\n+#include \"rtltypes.h\"\n+\n+EXCEPTION (rangefail);\n+\n+#define SECOND_VALID         1\n+#define MINUTE_VALID         2\n+#define HOUR_VALID           4\n+#define DAY_VALID            8\n+#define MONTH_VALID         16\n+#define YEAR_VALID          32\n+\n+extern void __cause_ex1 (char *ex, char *file, int lineno);\n+\n+#define CAUSE_RANGEFAIL     __cause_ex1 (\"rangefail\", filename, lineno)\n+\n+/*\n+ * function _abstime\n+ *\n+ * parameters:\n+ *     mask - mask of valid values\n+ *     year\n+ *     month\n+ *     day\n+ *     hour\n+ *     minute\n+ *     second\n+ *\n+ * returns:\n+ *     unsigned long\n+ *\n+ * exceptions:\n+ *     rangefail\n+ *\n+ * abstract:\n+ *     perform the ABSTIME builtin call\n+ *\n+ */\n+\n+unsigned long\n+_abstime (mask, year, month, day, hour, minute, second,\n+\t  filename, lineno)\n+     int  mask, year, month, day, hour, minute, second;\n+     char *filename;\n+     int  lineno;\n+{\n+  struct tm   *time_str;\n+  time_t      result, current_time;\n+\n+  /* first of all get current time */\n+  if ((current_time = time (0)) == (time_t)-1)\n+    /* FIXME: what excpetion ?? */\n+    CAUSE_RANGEFAIL;\n+\n+  /* if we just have to determine the current time, we are ready.\n+     This is shown by mask == 0. */\n+  if (mask == 0)\n+    return (unsigned long)current_time;\n+\n+  /* convert current time to struct tm */\n+  time_str = localtime (&current_time);\n+\n+  if (mask & YEAR_VALID)\n+    {\n+      if (year < 1900)\n+\tCAUSE_RANGEFAIL;\n+      time_str->tm_year = year - 1900;\n+    }\n+\n+  if (mask & MONTH_VALID)\n+    {\n+      if (month < 1 || month > 12)\n+\tCAUSE_RANGEFAIL;\n+      time_str->tm_mon = month - 1;\n+    }\n+\n+  if (mask & DAY_VALID)\n+    {\n+      if (day < 1 || day > 31)\n+\tCAUSE_RANGEFAIL;\n+      time_str->tm_mday = day;\n+    }\n+\n+  if (mask & HOUR_VALID)\n+    {\n+      if (hour < 0 || hour > 23)\n+\tCAUSE_RANGEFAIL;\n+      time_str->tm_hour = hour;\n+    }\n+\n+  if (mask & MINUTE_VALID)\n+    {\n+      if (minute < 0 || minute > 59)\n+\tCAUSE_RANGEFAIL;\n+      time_str->tm_min = minute;\n+    }\n+\n+  if (mask & SECOND_VALID)\n+    {\n+      if (second < 0 || second > 59)\n+\tCAUSE_RANGEFAIL;\n+      time_str->tm_sec = second;\n+    }\n+\n+  /* do it */\n+  time_str->tm_isdst = -1;\n+  if ((result = mktime (time_str)) == (time_t)-1)\n+    CAUSE_RANGEFAIL;\n+\n+  return (unsigned long)result;\n+}"}, {"sha": "66c22eabb676c3fa64f6f6e38b20799923f9a130", "filename": "gcc/ch/runtime/allocate.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fallocate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fallocate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fallocate.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,67 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include <stdlib.h>\n+#include \"config.h\"\n+#include \"rtltypes.h\"\n+\n+extern void __cause_ex1 (char *exname, char *file, int lineno);\n+\n+/* define needed exceptions */\n+EXCEPTION (allocatefail)\n+EXCEPTION (rangefail)\n+\n+/*\n+ * function __allocate\n+ *\n+ * parameters:\n+ *  size\t\tnumber of bytes to allocate\n+ *  filename            source file which issued the call\n+ *  linenumber          line number within that source file\n+ *\n+ * returns:\n+ *  void *\n+ *\n+ * exceptions:\n+ *  allocatefail\n+ *  rangefail\n+ *\n+ * abstract:\n+ *  allocate memory from heap\n+ *\n+*/\n+\n+void *\n+__allocate (size, filename, linenumber)\n+     int size;\n+     char *filename;\n+     int   linenumber;\n+{\n+  void\t*tmp;\n+    \n+  if (size < 0)\n+    __cause_ex1 (\"rangefail\", filename, linenumber);\n+  tmp = malloc (size);\n+  if (!tmp)\n+    __cause_ex1 (\"allocatefail\", filename, linenumber);\n+  return tmp;\n+}"}, {"sha": "b549602907a5952ecadd8450044335e313ab695c", "filename": "gcc/ch/runtime/chillrt0.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fchillrt0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fchillrt0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fchillrt0.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,147 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <string.h>\n+\n+#include \"rtltypes.h\"\n+#include \"iomodes.h\"\n+\f\n+/* type definitions */\n+typedef void (*init_ptr) ();\n+typedef void (*rts_init_ptr) (int *argc, char *argv []);\n+\n+typedef struct INIT_LIST\n+{\n+  init_ptr             code;\n+  struct INIT_LIST     *forward;\n+} InitList;\n+\n+InitList    *_ch_init_list = 0;\n+\n+/* force linker to get correct RTS functions */\n+extern rts_init_ptr\t__RTS_INIT__;\n+extern init_ptr\t\t__RTS_MAIN_LOOP__;\n+extern init_ptr\t\t__RTS_FETCH_NUMBERS__;\n+extern init_ptr\t\t__RTS_FETCH_NAMES__;\n+static init_ptr\t\t*rts_dummies[4] = \n+{\n+  &__RTS_INIT__,\n+  &__RTS_MAIN_LOOP__,\n+  &__RTS_FETCH_NUMBERS__,\n+  &__RTS_FETCH_NAMES__,\n+};\n+\n+/* chill argc and argv */\n+int\t\t\tchill_argc = 0;\n+TVaryingCharType\t**chill_argv = NULL;\n+\n+/* the program name for debugging purpose */\n+char \t\t\t*progname = 0;\n+\f\n+extern void *__xmalloc_ ();\n+\n+/*\n+ * function __xrealloc_\n+ *\n+ * parameter:\n+ *   ptr\t\tpointer to reallocate\n+ *   size\t\tnew number of bytes\n+ *\n+ * returns:\n+ *  void*\n+ *\n+ * abstract:\n+ *  This is the general reallocation routine for libchill\n+ *\n+ */\n+\n+void *\n+__xrealloc_ (ptr, size)\n+void *ptr;\n+int size;\n+{\n+  void\t*tmp = realloc (ptr, size);\n+  \n+  if (!tmp)\n+    {\n+      fprintf (stderr, \"ChillLib: Out of heap space.\\n\");\n+      fflush (stderr);\n+      exit (ENOMEM);\n+    }\n+  return (tmp);\n+} /* __xrealloc_ */\n+\f\n+static void\n+setup_argc_argv (argc, argv)\n+int argc;\n+char *argv[];\n+{\n+  int\t\ti;\n+  \n+  chill_argv = __xmalloc_ ((argc + 1) * sizeof (TVaryingCharType *));\n+  for (i = 0; i < argc; i++)\n+    {\n+      chill_argv[i] = __xmalloc_ (sizeof (TVaryingCharType) + strlen (argv[i]) + 1);\n+      chill_argv[i]->len = strlen (argv[i]);\n+      strcpy (chill_argv[i]->body, argv[i]);\n+    }\n+  chill_argv[chill_argc = argc] = NULL;\n+  \n+  if ((progname = strrchr (argv[0], '/')) == 0)\n+    progname = argv[0];\n+  else\n+    progname++;\n+  \n+} /* setup_argc_argv */\n+\n+extern void __setexceptionStack ();\n+\n+/*--------- main entry for each CHILL - program ----------*/\n+int\n+main (argc, argv)\n+     int argc;\n+     char *argv [];\n+{\n+  /* call look up for tasking */\n+  (*__RTS_INIT__) (&argc, argv);\n+\n+  /* setup argc and argv */\n+  setup_argc_argv (argc, argv);\n+\n+  /* clear exception stack */\n+  __setexceptionStack (0);\n+\n+  /* now call code at module level */\n+  while (_ch_init_list)\n+    {\n+      if (_ch_init_list->code)\n+\t(*(_ch_init_list->code)) ();\n+      _ch_init_list = _ch_init_list->forward;\n+    }\n+\n+  /* if we have rts linked, something will be done, else just return */\n+  (*__RTS_MAIN_LOOP__) ();\n+  \n+  return (0);\n+  \n+} /* main */"}, {"sha": "a7e2a7bc12f49101d0a2987dc94dde4aed3a4079", "filename": "gcc/ch/runtime/chillstdio.c", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fchillstdio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fchillstdio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fchillstdio.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,210 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <string.h>\n+\n+#include \"iomodes.h\"\n+\n+/* predefined associations, accesses, and text for stdin, stdout, stderr */\n+/* stdin */\n+#define STDIO_TEXT_LENGTH 1024\n+#define STDIN_TEXT_LENGTH STDIO_TEXT_LENGTH\n+\n+static Access_Mode stdin_access;\n+\n+#ifndef STDIN_FILENO\n+#define STDIN_FILENO 0\n+#endif\n+\n+static\n+Association_Mode stdin_association =\n+{\n+  IO_EXISTING | IO_READABLE | IO_SEQUENCIBLE | IO_ISASSOCIATED,\n+  NULL,\n+  &stdin_access,\n+  STDIN_FILENO,\n+  NULL,\n+  0,\n+  ReadOnly\n+};\n+\n+static Access_Mode stdin_access = \n+{\n+  IO_TEXTIO,\n+  STDIN_TEXT_LENGTH + 2,\n+  0,\n+  0,\n+  &stdin_association,\n+  0,\n+  NULL,\n+  VaryingChars\n+};\n+\n+static\n+VARYING_STRING(STDIN_TEXT_LENGTH) stdin_text_record;\n+\n+Text_Mode chill_stdin =\n+{\n+  IO_TEXTLOCATION,\n+  (VarString *)&stdin_text_record,\n+  &stdin_access,\n+  0\n+};\n+\n+/* stdout */\n+#define STDOUT_TEXT_LENGTH STDIO_TEXT_LENGTH\n+#ifndef STDOUT_FILENO\n+#define STDOUT_FILENO 1\n+#endif\n+\n+static Access_Mode stdout_access;\n+\n+static\n+Association_Mode stdout_association =\n+{\n+  IO_EXISTING | IO_WRITEABLE | IO_SEQUENCIBLE | IO_ISASSOCIATED,\n+  NULL,\n+  &stdout_access,\n+  STDOUT_FILENO,\n+  NULL,\n+  0,\n+  WriteOnly\n+};\n+\n+static Access_Mode stdout_access = \n+{\n+  IO_TEXTIO,\n+  STDOUT_TEXT_LENGTH + 2,\n+  0,\n+  0,\n+  &stdout_association,\n+  0,\n+  NULL,\n+  VaryingChars\n+};\n+\n+static\n+VARYING_STRING(STDOUT_TEXT_LENGTH) stdout_text_record;\n+\n+Text_Mode chill_stdout =\n+{\n+  IO_TEXTLOCATION,\n+  (VarString *)&stdout_text_record,\n+  &stdout_access,\n+  0\n+};\n+\n+/* stderr */\n+#define STDERR_TEXT_LENGTH STDIO_TEXT_LENGTH\n+#ifndef STDERR_FILENO\n+#define STDERR_FILENO 2\n+#endif\n+\n+static Access_Mode stderr_access;\n+\n+static\n+Association_Mode stderr_association =\n+{\n+  IO_EXISTING | IO_WRITEABLE | IO_SEQUENCIBLE | IO_ISASSOCIATED,\n+  NULL,\n+  &stderr_access,\n+  STDERR_FILENO,\n+  NULL,\n+  0,\n+  WriteOnly\n+};\n+\n+static Access_Mode stderr_access = \n+{\n+  IO_TEXTIO,\n+  STDERR_TEXT_LENGTH + 2,\n+  0,\n+  0,\n+  &stderr_association,\n+  0,\n+  NULL,\n+  VaryingChars\n+};\n+\n+static\n+VARYING_STRING(STDIN_TEXT_LENGTH) stderr_text_record;\n+\n+Text_Mode chill_stderr =\n+{\n+  IO_TEXTLOCATION,\n+  (VarString *)&stderr_text_record,\n+  &stderr_access,\n+  0\n+};\n+\n+/*\n+ * function __xmalloc_\n+ *\n+ * parameter:\n+ *   size\t\tnumber of bytes to allocate\n+ *\n+ * returns:\n+ *  void*\n+ *\n+ * abstract:\n+ *  This is the general allocation routine for libchill\n+ *\n+ */\n+\n+void *\n+__xmalloc_ (size)\n+int size;\n+{\n+  void\t*tmp = malloc (size);\n+  \n+  if (!tmp)\n+    {\n+      fprintf (stderr, \"ChillLib: Out of heap space.\\n\");\n+      fflush (stderr);\n+      exit (ENOMEM);\n+    }\n+  return (tmp);\n+} /* __xmalloc_ */\n+\n+static char *\n+newstring (char *str)\n+{\n+  char *tmp = __xmalloc_ (strlen (str) + 1);\n+  strcpy (tmp, str);\n+  return tmp;\n+}\n+\n+static void setup_stdinout (void) __attribute__((constructor));\n+\n+static void\n+setup_stdinout ()\n+{\n+  /* allocate the names */\n+  stdin_association.pathname = newstring (\"stdin\");\n+  stdout_association.pathname = newstring (\"stdout\");\n+  stderr_association.pathname = newstring (\"stderr\");\n+\n+  /* stdin needs a readbuffer */\n+  stdin_association.bufptr = __xmalloc_ (sizeof (readbuf_t));\n+  memset (stdin_association.bufptr, 0, sizeof (readbuf_t));\n+}"}, {"sha": "3945a829743b00692c0d6b4417ed90bdfd8ea5e4", "filename": "gcc/ch/runtime/delete.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fdelete.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fdelete.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fdelete.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,42 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+   \n+   This file is part of GNU CC.\n+   \n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <unistd.h>\n+\n+#include \"fileio.h\"\n+\n+void __delete( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+\n+  if( !TEST_FLAG( the_assoc, IO_ISASSOCIATED ) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+\n+  /* forced dissociate */\n+  if( the_assoc->access )\n+    __disconnect( the_assoc->access, file, line );\n+\n+  /* delete */\n+  if( unlink( the_assoc->pathname ) )\n+    CHILLEXCEPTION( file, line, DELETEFAIL, DELETE_FAILS );\n+\n+  CLR_FLAG( the_assoc, IO_EXISTING );\n+}"}, {"sha": "2e760b0fa2b2b2449a585fde6ae9205bf0c7b9b8", "filename": "gcc/ch/runtime/diffps.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fdiffps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fdiffps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fdiffps.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,74 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __diffpowerset\n+ *\n+ * parameters:\n+ *     out\t\tresult of __diffpowerset\n+ *\tleft\t\tpowerset\n+ *\tright\t\tpowerset\n+ *\tbitlength\tlength of powerset\n+ *\n+ * returns:\n+ *\tvoid\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  makes a difference of 2 powersets (out = left - right)\n+ *\n+ */\n+void\n+__diffpowerset (out, left, right, bitlength)\n+     SET_WORD      *out;\n+     SET_WORD      *left;\n+     SET_WORD      *right;\n+     unsigned long  bitlength;\n+{\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      *((SET_CHAR *)out) = *((SET_CHAR *)left) & ~\n+                           *((SET_CHAR *)right);\n+      MASK_UNUSED_CHAR_BITS ((SET_CHAR *)out, bitlength);\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      *((SET_SHORT *)out) = *((SET_SHORT *)left) & ~\n+                            *((SET_SHORT *)right);\n+      MASK_UNUSED_SHORT_BITS ((SET_SHORT *)out, bitlength);\n+    }\n+  else\n+    {\n+      unsigned long len = BITS_TO_WORDS(bitlength);\n+      register unsigned long i;\n+    \n+      for (i = 0; i < len; i++)\n+\tout[i] = left[i] & ~right[i];\n+      MASK_UNUSED_WORD_BITS ((out + len - 1), bitlength % SET_WORD_SIZE);\n+    }\n+}"}, {"sha": "dd3f127976d0e7ad7a80d81c25f68ee73314090b", "filename": "gcc/ch/runtime/inbitstr.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Finbitstr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Finbitstr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Finbitstr.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,74 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+extern void __cause_ex1 (char *exname, char *file, int lineno);\n+\n+/*\n+ * function __inbitstring\n+ *\n+ * parameters:\n+ *\tbitno\t\tbit number within set\n+ *\tpowerset\tthe powerset\n+ *\tbitlength\tlength of powerset in bits\n+ *      minval          number of lowest bit stored\n+ *\tfname\t\tfilename of caller\n+ *\tlineno\t\tlinenumber of caller\n+ *\n+ * returns:\n+ *\tint\t\t1 .. found\n+ *\t\t\t0 .. not found\n+ *\n+ * exceptions:\n+ *  rangefail\n+ *\n+ * abstract:\n+ *  checks if a given value is included in a bitstring\n+ *\n+ */\n+int\n+__inbitstring (bitno, powerset, bitlength, minval, fname, lineno)\n+     unsigned long  bitno;\n+     SET_WORD      *powerset;\n+     unsigned long  bitlength;\n+     long           minval;\n+     char          *fname;\n+     int            lineno;\n+    \n+{\n+  if (powerset == NULL\n+      || bitno < minval \n+      || (bitno - minval) >= bitlength)\n+    __cause_ex1 (\"rangefail\", fname, lineno);\n+\n+  bitno -= minval;\n+  if (bitlength <= SET_CHAR_SIZE)\n+    return GET_BIT_IN_CHAR (*((SET_CHAR *)powerset), bitno);\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    return GET_BIT_IN_SHORT (*((SET_SHORT *)powerset), bitno);\n+  else\n+    return GET_BIT_IN_WORD (powerset[bitno / SET_WORD_SIZE],\n+\t\t\t    bitno % SET_WORD_SIZE);\n+}"}, {"sha": "dde2604379a9de3be74065863159937591910413", "filename": "gcc/ch/runtime/indexable.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Findexable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Findexable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Findexable.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,31 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__indexable( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+  if( !TEST_FLAG(the_assoc, IO_ISASSOCIATED) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+  return TEST_FLAG(the_assoc, IO_INDEXABLE) ? True : False;\n+}"}, {"sha": "7622428423ba9e5ef325aede20958c89cf1a5b9d", "filename": "gcc/ch/runtime/memmove.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fmemmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fmemmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fmemmove.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,63 @@\n+/* Implement string-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Bill Cox\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define MIN(a, b)  ((a) < (b) ? (a) : (b))\n+\n+\n+/*\n+ * function memmove\n+ *\n+ * parameters:\n+ *     S1 - pointer to destination string\n+ *     S2 - pointer to source string\n+ *     LEN - length of string\n+ *\n+ * returns:\n+ *     pointer to destination string\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     copies a string safely, where the source and dest areas may overlap.\n+ *\n+ */\n+\n+void *\n+memmove (s1, s2, n)\n+     void *s1;\n+     const void *s2;\n+     int n;\n+{\n+  char *sc1 = s1;\n+  const char *sc2 = s2;\n+\n+  if (sc2 < sc1 && (sc1 < sc2 + n))\n+    for (sc1 += n, sc2 += n; 0 < n; --n)\n+      *--sc1 = *--sc2;\n+  else\n+#if 0\n+    for (; 0 < n; --n)\n+      *sc1++ = *sc2++;\n+#else\n+    memcpy (sc1, sc2, n);\n+#endif\n+  return s1;\n+}"}, {"sha": "79e6a8f37e84dfe7856012215c529cc9c80309d6", "filename": "gcc/ch/runtime/orps.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Forps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Forps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Forps.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,75 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __orpowerset\n+ *\n+ * parameters:\n+ *\tout\t\treturn from __orpowerset\n+ *\tleft\t\tleft powerset\n+ *\tright\t\tright powerset\n+ *\tbitlength\tlength of powerset in bits\n+ *\n+ * returns:\n+ *\tvoid\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  or's two powersets.\n+ *\n+ */\n+\n+void\n+__orpowerset (out, left, right, bitlength)\n+     SET_WORD      *out;\n+     SET_WORD      *left;\n+     SET_WORD      *right;\n+     unsigned long  bitlength;\n+{\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      *((SET_CHAR *)out) = *((SET_CHAR *)left) |\n+                           *((SET_CHAR *)right);\n+      MASK_UNUSED_CHAR_BITS((SET_CHAR *)out, bitlength);\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      *((SET_SHORT *)out) = *((SET_SHORT *)left) |\n+                            *((SET_SHORT *)right);\n+      MASK_UNUSED_SHORT_BITS((SET_SHORT *)out, bitlength);\n+    }\n+  else\n+    {\n+      register unsigned long i;\n+      unsigned long len = BITS_TO_WORDS(bitlength);\n+    \n+      for (i = 0; i < len; i++)\n+\tout[i] = left[i] | right[i];\n+      MASK_UNUSED_WORD_BITS ((out + len - 1), bitlength % SET_WORD_SIZE);\n+    }\n+}"}, {"sha": "d81e95578f0b7c2ae08d8d32612ca4a5a3b7b17c", "filename": "gcc/ch/runtime/outoffile.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Foutoffile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Foutoffile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Foutoffile.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,40 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__outoffile( void* the_transfer, char* file, int line )\n+{\n+  Access_Mode* the_access;\n+\n+  if( !the_transfer )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ACCESS );\n+\n+  if( TEST_FLAG((Text_Mode*)the_transfer, IO_TEXTLOCATION ))\n+    the_access = ((Text_Mode*)the_transfer)->access_sub;\n+  else\n+    the_access = (Access_Mode*)the_transfer;\n+\n+  if( !the_access->association )\n+    CHILLEXCEPTION( file, line, NOTCONNECTED, IS_NOT_CONNECTED );\n+\n+  return TEST_FLAG( the_access, IO_OUTOFFILE ) ? True : False;\n+}"}, {"sha": "ffed8417b014001d5c765207b1bf6f425b4e233c", "filename": "gcc/ch/runtime/readable.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Freadable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Freadable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Freadable.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,32 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Boolean\n+__readable( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+  if( !TEST_FLAG(the_assoc, IO_ISASSOCIATED) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+  return TEST_FLAG(the_assoc, IO_READABLE) ? True : False;\n+}\n+"}, {"sha": "548911bb346af5340f02ce1758c17ab7100fe936", "filename": "gcc/ch/runtime/remaintime.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fremaintime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fremaintime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fremaintime.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,83 @@\n+/* Implement timing-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+   \n+   This file is part of GNU CC.\n+   \n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"rts.h\"\n+\n+/*\n+ * function __remaintime\n+ *\n+ * parameters:\n+ *      since   pointer to the  initial RtsTime\n+ *      dur     the duration value\n+ *      t       pointer to the remaining RtsTime\n+ *\n+ * returns:\n+ *      int     0 .. there is a remaining time\n+ *              1 .. there is no remaining time\n+ *\n+ * exceptions:\n+ *      none\n+ *\n+ * abstract:\n+ *      This function writes to t the remaining duration value in RtsTime format\n+ *      from a given start (since) and the current RtsTime.\n+ *\n+ */\n+\n+extern void __convert_duration_rtstime (unsigned long dur, RtsTime *t);\n+\n+int\n+  __remaintime (since, dur, t)\n+RtsTime       *since;\n+unsigned long  dur;\n+RtsTime       *t;\n+{\n+  RtsTime now, dur_in_rtstime, tmp, diff;\n+  \n+  __rtstime (&now);\n+  __convert_duration_rtstime (dur, &dur_in_rtstime);\n+  \n+  tmp.secs = since->secs;\n+  tmp.nanosecs = since->nanosecs;\n+  \n+  /* calculate the difference of absolute times */\n+  if (tmp.nanosecs > now.nanosecs)\n+    {\n+      tmp.secs--;\n+      tmp.nanosecs += 1000000000;\n+    }\n+  diff.secs = now.secs - tmp.secs;\n+  diff.nanosecs = now.nanosecs - tmp.nanosecs;\n+  \n+  /* substract diff from duration */\n+  if (diff.nanosecs > dur_in_rtstime.nanosecs)\n+    {\n+      dur_in_rtstime.secs--;\n+      dur_in_rtstime.nanosecs += 1000000000;\n+    }\n+  \n+  t->secs = dur_in_rtstime.secs - diff.secs;\n+  t->nanosecs = dur_in_rtstime.nanosecs - diff.nanosecs;\n+  \n+  if (t->secs > dur_in_rtstime.secs)\n+    return 1;\n+  else\n+    return 0;\n+}"}, {"sha": "34a2643990b382dfc96550a4c64352984381903a", "filename": "gcc/ch/runtime/settextrecord.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fsettextrecord.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fsettextrecord.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fsettextrecord.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,37 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+void\n+__settextrecord( Text_Mode* the_text,\n+                 VarString* the_text_rec,\n+                 char*      file,\n+                 int        line )\n+{\n+  if( !the_text )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_TEXT );\n+\n+  if( !the_text_rec )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_TEXTREC );  \n+\n+  the_text->text_record = the_text_rec;\n+}\n+"}, {"sha": "05b0151f0fe48a787af52aff75a65e64a241b175", "filename": "gcc/ch/runtime/waitbuffer.c", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fwaitbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fwaitbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fwaitbuffer.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,297 @@\n+/* Implement tasking-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"rtltypes.h\"\n+#include \"rts.h\"\n+\n+extern void __cause_ex1 (char *ex, char *file, int lineno);\n+\n+EXCEPTION (bufferinconsistency)\n+#define CAUSE_BUFFINCONS  __cause_ex1 (\"bufferinconsistency\", filename, lineno)\n+EXCEPTION (spacefail);\n+#define CAUSE_SPACEFAIL   __cause_ex1 (\"spacefail\", filename, lineno)\n+    \n+/*\n+ * function __wait_buffer\n+ *\n+ * parameters:\n+ *     buf_got\t   pointer to location for writing the received buffer address\n+ *     nbuf        number of buffers in RECEIVE CASE\n+ *     bufptr      array of pointers to buffer descriptor\n+ *     datap       pointer where to store data\n+ *     datalen     length of data\n+ *     ins         pointer to instance location or 0\n+ *     else_clause else specified or not\n+ *     to_loc      pointer to timesupervision value\n+ *     filename    source file name where function gets called\n+ *     lineno      linenumber in source file\n+ *\n+ * returns:\n+ *     int\t   0 .. success\n+ *                 1 .. timed out\n+ *\n+ * exceptions:\n+ *     bufferinconsistency  if something's wrong in the buffer queue's\n+ *     spacefail            out of heap space of datalength of receiver\n+ *                          less then data avilable.\n+ *\n+ * abstract:\n+ *     implement the CHILL RECEIVE buffer CASE action.\n+ */\n+\n+int\n+__wait_buffer (buf_got, nbuf, bufptr, datap, datalen, ins,\n+               else_clause, to, filename, lineno)\n+     void           **buf_got;\n+     int              nbuf;\n+     Buffer_Descr    *bufptr[];\n+     void            *datap;\n+     int              datalen;\n+     INSTANCE        *ins;\n+     int              else_clause;\n+     void            *to;\n+     char            *filename;\n+     int              lineno;\n+{\n+  int i;\n+  Buffer_Wait_Queue     *start_list;\n+  Buffer_Queue         **retval;\n+  Buffer_Queue         **highprio;\n+  int                    timed_out;\n+  \n+  /* look if there is a buffer already sent */\n+  highprio = 0;\n+  for (i = 0; i < nbuf; i++)\n+    {\n+      Buffer_Queue      *bq;\n+\n+      memcpy (&bq, bufptr[i]->buf, sizeof (Buffer_Queue *));\n+      if (bq != 0 && bq->sendqueue != 0)\n+        {\n+          if (highprio != 0)\n+            {\n+              Buffer_Queue      *bsq = *highprio;\n+              \n+              if (bq->sendqueue->priority > bsq->sendqueue->priority)\n+                highprio = bufptr[i]->buf;\n+            }\n+          else\n+            highprio = bufptr[i]->buf;\n+        }\n+    }\n+  \n+  if (highprio != 0)\n+    {\n+      Buffer_Queue      *bq;\n+\n+      memcpy (&bq, highprio, sizeof (Buffer_Queue *));\n+      if (bq != 0 && bq->sendqueue != 0)\n+        {\n+          Buffer_Send_Queue *bsq = bq->sendqueue;\n+          Buffer_Send_Queue *tmp;\n+\n+          /* check data length */\n+          if (datalen < bsq->datalen)\n+            /* something's totaly wrong. Raise exception */\n+            CAUSE_SPACEFAIL;\n+\n+          /* copy data out */\n+          memcpy (datap, bsq->dataptr, bsq->datalen);\n+\n+          /* update instance, if present */\n+          if (ins != 0)\n+            memcpy (ins, &bsq->this, sizeof (INSTANCE));\n+\n+          /* dequeue entry */\n+          tmp = bsq;\n+          bq->sendqueue = tmp->forward;\n+\n+          if (tmp->is_delayed)\n+            {\n+              /* there is an instance delayed on a send,\n+                 continue it. */\n+              __continue_that (tmp->this, tmp->priority, filename, lineno);\n+              FREE (tmp);\n+\n+              /* return the buffer we have received from */\n+\t      *buf_got = (void *)highprio;\n+              return 0;\n+            }\n+\n+          /* just decrease sendqueue length */\n+          bq->sendqueuelength--;\n+\n+          FREE (tmp);\n+\n+          /* as we got an entry free, we should continue\n+             an INSTANCE which is delayed on a send at this\n+             buffer */\n+          bsq = bq->sendqueue;\n+          while (bsq != 0)\n+            {\n+              if (bsq->is_delayed)\n+                {\n+                  bq->sendqueuelength++;\n+                  bsq->is_delayed = 0;\n+                  __continue_that (bsq->this, bsq->priority, filename, lineno);\n+                  break;\n+                }\n+              bsq = bsq->forward;\n+            }\n+          /* return the buffer we have received from */\n+          *buf_got = (void *)highprio;\n+\t  return 0;\n+        }\n+      }\n+\n+  /* if we come here, there is no buffer already sent */\n+  if (else_clause != 0)\n+    {\n+      /* in that case we return immediately */\n+      *buf_got = 0;\n+      return 0;\n+    }\n+  \n+  /* now we have to queue ourself to the wait queue(s) */\n+  start_list = 0;\n+  for (i = 0; i < nbuf; i++)\n+    {\n+      Buffer_Queue      *bq;\n+      Buffer_Wait_Queue *wrk;\n+      Buffer_Wait_Queue *bwq;\n+      Buffer_Wait_Queue *prev_queue_entry = 0;\n+      Buffer_Wait_Queue *prev_list_entry;\n+      int                j, have_done = 0;\n+      \n+      for (j = 0; j < i; j++)\n+        {\n+          if (bufptr[i]->buf == bufptr[j]->buf)\n+            {\n+              have_done = 1;\n+              break;\n+            }\n+        }\n+      if (have_done)\n+        continue;\n+      \n+      memcpy (&bq, bufptr[i]->buf, sizeof (Buffer_Queue *));\n+      if (bq == 0)\n+        {\n+          MALLOC (bq, sizeof (Buffer_Queue));\n+          memset (bq, 0, sizeof (Buffer_Queue));\n+          /* *(bufptr[i]->buf) = bq; may be unaligned */\n+\t  memcpy (bufptr[i]->buf, &bq, sizeof (Buffer_Queue *));\n+        }\n+      MALLOC (wrk, sizeof (Buffer_Wait_Queue));\n+      memset (wrk, 0, sizeof (Buffer_Wait_Queue));\n+      bwq = (Buffer_Wait_Queue *)&bq->waitqueue;\n+      \n+      wrk->this = THIS;\n+      wrk->datalen = datalen;\n+      wrk->dataptr = datap;\n+      wrk->bufferaddr = bufptr[i]->buf;\n+\n+      /* queue it at the end of buffer wait queue */\n+      while (bwq->forward != 0)\n+          bwq = bwq->forward;\n+      wrk->forward = bwq->forward;\n+      bwq->forward = wrk;\n+      \n+      /* queue it into list */\n+      wrk->startlist = start_list;\n+      if (! start_list)\n+        {\n+          start_list = wrk;\n+          prev_list_entry = wrk;\n+          wrk->startlist = start_list;\n+        }\n+      else\n+        {\n+          prev_list_entry->chain = wrk;\n+          prev_list_entry = wrk;\n+        }\n+      \n+      /* increment wait queue count */\n+      bq->waitqueuelength++;\n+    }\n+\n+  /* tell runtime system to delay this process */\n+  timed_out = __delay_this (wait_buffer_receive, to, filename, lineno);\n+  if (timed_out)\n+    {\n+      /* remove all entries from buffer queues */\n+      Buffer_Wait_Queue *listentry = start_list;\n+      \n+      while (listentry != 0)\n+        {\n+\t  Buffer_Queue *bq = *(listentry->bufferaddr);\n+\t  Buffer_Wait_Queue *prev_entry = (Buffer_Wait_Queue *)&bq->waitqueue;\n+\t  Buffer_Wait_Queue *bwq = bq->waitqueue;\n+\t  \n+\t  while (bwq != listentry)\n+\t    {\n+\t      prev_entry = bwq;\n+\t      bwq = bwq->forward;\n+\t    }\n+\t  /* dequeue it */\n+\t  prev_entry->forward = bwq->forward;\n+\t  bq->waitqueuelength--;\n+\t  listentry = listentry->chain;\n+        }\n+    }\n+  \n+  /* someone has continued us, find which buffer got ready */\n+  retval = 0;\n+\n+  while (start_list != 0)\n+    {\n+      Buffer_Wait_Queue *tmp = start_list->chain;\n+      \n+      if (start_list->is_sent)\n+        {\n+          /* this one has been sent */\n+          /* save return value */\n+          if (retval == 0)\n+              retval = start_list->bufferaddr;\n+          else\n+              /* more then one has been sent, that's wrong */\n+              CAUSE_BUFFINCONS;\n+          \n+          /* update instance, if present */\n+          if (ins != 0)\n+            memcpy (ins, &start_list->who_sent, sizeof (INSTANCE));\n+        }\n+      FREE (start_list);\n+      start_list = tmp;\n+    }\n+\n+  /* now check if there was really a buffer got */\n+  if (retval == 0 && !timed_out)\n+    /* something's totally wrong, raise an exception  */\n+    CAUSE_BUFFINCONS;\n+\n+  if (!timed_out)\n+    *buf_got = (void *)retval;\n+  return timed_out;\n+}\n+\n+/* force function __print_buffer to be linked */\n+extern void __print_buffer ();\n+static EntryPoint pev = __print_buffer;"}, {"sha": "dfe57be8a64a00319d7daf5b83b79137450d16f0", "filename": "gcc/ch/runtime/waituntil.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fwaituntil.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a575f253dce5cdd3ef73d6e2e6b9890fa182849/gcc%2Fch%2Fruntime%2Fwaituntil.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fwaituntil.c?ref=3a575f253dce5cdd3ef73d6e2e6b9890fa182849", "patch": "@@ -0,0 +1,74 @@\n+/* Implement timing-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"rtltypes.h\"\n+#include \"rts.h\"\n+\n+EXCEPTION (timerfail);\n+\n+/*\n+ * function __wait_until\n+ *\n+ * parameters:\n+ *     abstime   absolute time value\n+ *     filename\n+ *     linenumber\n+ *\n+ * returns:\n+ *     int   0 on success, 1 on failure\n+ *\n+ * exceptions:\n+ *     timerfail\n+ *\n+ * abstract:\n+ *     check for given argument is valid, calculate how long to wait in\n+ *     seconds and call os to do it.\n+ *\n+ */\n+\n+int\n+__wait_until (abstime, filename, linenumber)\n+     unsigned long  abstime;\n+     char          *filename;\n+     int            linenumber;\n+{\n+  RtsTime\tnow, delta, abs_rtstime;\n+    \n+  /* get current time */\n+  __rtstime (&now);\n+    \n+  abs_rtstime.secs = abstime;\n+  abs_rtstime.nanosecs = 0;\n+  \n+  if (abs_rtstime.nanosecs < now.nanosecs)\n+    {\n+      abs_rtstime.secs--;\n+      abs_rtstime.nanosecs += 1000000000;\n+    }\n+  \n+  delta.secs = abs_rtstime.secs - now.secs;\n+  delta.nanosecs = abs_rtstime.nanosecs - now.nanosecs;\n+  \n+  if (delta.secs > abs_rtstime.secs)\n+    /* cannot wait into past */\n+    return 1;\n+  \n+  return __delay_this (wait_wait, &delta, filename, linenumber) == 1 ? 0 : 1;\n+}"}]}