{"sha": "91ba65f2f0cacac286907b8a465f42b4e56aeda3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiYTY1ZjJmMGNhY2FjMjg2OTA3YjhhNDY1ZjQyYjRlNTZhZWRhMw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-03T21:39:18Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-03T21:39:18Z"}, "message": "re PR target/51244 ([SH] Inefficient conditional branch and code around T bit)\n\n\tPR target/51244\n\t* config/sh/sh.md (*mov_t_msb_neg): New insn and two accompanying\n\tunnamed split patterns.\n\n\tPR target/51244\n\t* gcc.target/sh/pr51244-12.c: New.\n\nFrom-SVN: r192052", "tree": {"sha": "c8f633fd47fb1e2bd8fe7df7e6bc729d92876a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8f633fd47fb1e2bd8fe7df7e6bc729d92876a86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91ba65f2f0cacac286907b8a465f42b4e56aeda3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ba65f2f0cacac286907b8a465f42b4e56aeda3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ba65f2f0cacac286907b8a465f42b4e56aeda3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ba65f2f0cacac286907b8a465f42b4e56aeda3/comments", "author": null, "committer": null, "parents": [{"sha": "9597375a25a1f993208611d1f3793d877c50d323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9597375a25a1f993208611d1f3793d877c50d323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9597375a25a1f993208611d1f3793d877c50d323"}], "stats": {"total": 124, "additions": 124, "deletions": 0}, "files": [{"sha": "0ac802f811e54ef8bc92c52cf8484314c22be51f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ba65f2f0cacac286907b8a465f42b4e56aeda3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ba65f2f0cacac286907b8a465f42b4e56aeda3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91ba65f2f0cacac286907b8a465f42b4e56aeda3", "patch": "@@ -1,3 +1,9 @@\n+2012-10-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* config/sh/sh.md (*mov_t_msb_neg): New insn and two accompanying\n+\tunnamed split patterns.\n+\n 2012-10-03  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/50457"}, {"sha": "91a09c510c0d121d05712fb672db505ae95ee24a", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ba65f2f0cacac286907b8a465f42b4e56aeda3/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ba65f2f0cacac286907b8a465f42b4e56aeda3/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=91ba65f2f0cacac286907b8a465f42b4e56aeda3", "patch": "@@ -10769,6 +10769,51 @@ label:\n \t(set (reg:SI T_REG) (const_int 1))\n \t(use (match_dup 2))])])\n \n+;; Use negc to store the T bit in a MSB of a reg in the following way:\n+;;\tT = 1: 0x80000000 -> reg\n+;;\tT = 0: 0x7FFFFFFF -> reg\n+;; This works because 0 - 0x80000000 = 0x80000000.\n+(define_insn_and_split \"*mov_t_msb_neg\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(minus:SI (const_int -2147483648)  ;; 0x80000000\n+\t\t  (match_operand 1 \"t_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(set (match_dup 2) (const_int -2147483648))\n+   (parallel [(set (match_dup 0) (minus:SI (neg:SI (match_dup 2))\n+\t\t\t\t (reg:SI T_REG)))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  operands[2] = gen_reg_rtx (SImode);\n+})\n+\n+;; These are essentially the same as above, but with the inverted T bit.\n+;; Combine recognizes the split patterns, but does not take them sometimes\n+;; if the T_REG clobber is specified.  Instead it tries to split out the\n+;; T bit negation.  Since these splits are supposed to be taken only by\n+;; combine, it will see the T_REG clobber of the *mov_t_msb_neg insn, so this\n+;; should be fine.\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(plus:SI (match_operand 1 \"negt_reg_operand\")\n+\t\t (const_int 2147483647)))]  ;; 0x7fffffff\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:SI (const_int -2147483648) (reg:SI T_REG)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(if_then_else:SI (match_operand 1 \"t_reg_operand\")\n+\t\t\t (const_int 2147483647)  ;; 0x7fffffff\n+\t\t\t (const_int -2147483648)))]  ;; 0x80000000\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:SI (const_int -2147483648) (reg:SI T_REG)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n ;; The *negnegt pattern helps the combine pass to figure out how to fold \n ;; an explicit double T bit negation.\n (define_insn_and_split \"*negnegt\""}, {"sha": "aa4ef674ba65f42b5eda2b05ba15eedb2b26c78a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ba65f2f0cacac286907b8a465f42b4e56aeda3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ba65f2f0cacac286907b8a465f42b4e56aeda3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91ba65f2f0cacac286907b8a465f42b4e56aeda3", "patch": "@@ -1,3 +1,8 @@\n+2012-10-03  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* gcc.target/sh/pr51244-12.c: New.\n+\n 2012-10-03  Dehao Chen  <dehao@google.com>\n \n \tPR middle-end/54782"}, {"sha": "ca8e2d4b3bf56edaaba3c3e52c797add5f98b133", "filename": "gcc/testsuite/gcc.target/sh/pr51244-12.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91ba65f2f0cacac286907b8a465f42b4e56aeda3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91ba65f2f0cacac286907b8a465f42b4e56aeda3/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-12.c?ref=91ba65f2f0cacac286907b8a465f42b4e56aeda3", "patch": "@@ -0,0 +1,68 @@\n+/* Check that the negc instruction is generated as expected for the cases\n+   below.  If we see a movrt or #-1 negc sequence it means that the pattern\n+   which handles the inverted case does not work properly.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-times \"negc\" 10 } } */\n+/* { dg-final { scan-assembler-not \"movrt|#-1|add|sub\" } } */\n+\n+int\n+test00 (int a, int b, int* x)\n+{\n+  return (a == b) ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test00_inv (int a, int b)\n+{\n+  return (a != b) ? 0x80000000 : 0x7FFFFFFF;\n+}\n+\n+int\n+test01 (int a, int b)\n+{\n+  return (a >= b) ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test01_inv (int a, int b)\n+{\n+  return (a < b) ? 0x80000000 : 0x7FFFFFFF;\n+}\n+\n+int\n+test02 (int a, int b)\n+{\n+  return (a > b) ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test02_inv (int a, int b)\n+{\n+  return (a <= b) ? 0x80000000 : 0x7FFFFFFF;\n+}\n+\n+int\n+test03 (int a, int b)\n+{\n+  return ((a & b) == 0) ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test03_inv (int a, int b)\n+{\n+  return ((a & b) != 0) ? 0x80000000 : 0x7FFFFFFF;\n+}\n+\n+int\n+test04 (int a)\n+{\n+  return ((a & 0x55) == 0) ? 0x7FFFFFFF : 0x80000000;\n+}\n+\n+int\n+test04_inv (int a)\n+{\n+  return ((a & 0x55) != 0) ? 0x80000000 : 0x7FFFFFFF;\n+}"}]}