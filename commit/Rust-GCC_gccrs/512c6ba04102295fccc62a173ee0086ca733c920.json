{"sha": "512c6ba04102295fccc62a173ee0086ca733c920", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyYzZiYTA0MTAyMjk1ZmNjYzYyYTE3M2VlMDA4NmNhNzMzYzkyMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-12T10:29:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-12T10:56:18Z"}, "message": "Avoid PRE insert iteration when possible\n\nThe following make sure to only iterate PRE insertion when\nnecessary - which is when AVAIL_OUT of a predecessor of a\nblock we already visited changed (that's backedge destinations).\n\nTo not regress this also makes sure to locally iterate insertion\nsince even topological sort of expressions isn't enough to\nguarantee we get all opportunities of a block in one iteration.\nThis avoids costly re-compute of the topologically sorted expression\narray (more micro-optimization is possible here).\n\n2020-11-12  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (bitmap_value_replace_in_set): Return\n\twhether we have changed anything.\n\t(do_pre_regular_insertion): Get topologically sorted array\n\tof expressions from caller.\n\t(do_pre_partial_partial_insertion): Likewise.\n\t(insert): Compute topologically sorted arrays of expressions\n\there and locally iterate actual insertion.  Iterate only\n\twhen AVAIL_OUT of an already visited block source changed.", "tree": {"sha": "674b8b35bd87e2d9461593eb1dfee207c095b28c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/674b8b35bd87e2d9461593eb1dfee207c095b28c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/512c6ba04102295fccc62a173ee0086ca733c920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/512c6ba04102295fccc62a173ee0086ca733c920", "html_url": "https://github.com/Rust-GCC/gccrs/commit/512c6ba04102295fccc62a173ee0086ca733c920", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/512c6ba04102295fccc62a173ee0086ca733c920/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f445b5d6116000f1a6527f2164836cbc7c01dee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f445b5d6116000f1a6527f2164836cbc7c01dee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f445b5d6116000f1a6527f2164836cbc7c01dee"}], "stats": {"total": 86, "additions": 57, "deletions": 29}, "files": [{"sha": "9db1b0258f74384d76bbfe7a3050ea31fc682b18", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/512c6ba04102295fccc62a173ee0086ca733c920/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/512c6ba04102295fccc62a173ee0086ca733c920/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=512c6ba04102295fccc62a173ee0086ca733c920", "patch": "@@ -524,7 +524,7 @@ static struct\n static bool do_partial_partial;\n static pre_expr bitmap_find_leader (bitmap_set_t, unsigned int);\n static void bitmap_value_insert_into_set (bitmap_set_t, pre_expr);\n-static void bitmap_value_replace_in_set (bitmap_set_t, pre_expr);\n+static bool bitmap_value_replace_in_set (bitmap_set_t, pre_expr);\n static void bitmap_set_copy (bitmap_set_t, bitmap_set_t);\n static bool bitmap_set_contains_value (bitmap_set_t, unsigned int);\n static void bitmap_insert_into_set (bitmap_set_t, pre_expr);\n@@ -974,14 +974,14 @@ bitmap_set_equal (bitmap_set_t a, bitmap_set_t b)\n }\n \n /* Replace an instance of EXPR's VALUE with EXPR in SET if it exists,\n-   and add it otherwise.  */\n+   and add it otherwise.  Return true if any changes were made.  */\n \n-static void\n+static bool\n bitmap_value_replace_in_set (bitmap_set_t set, pre_expr expr)\n {\n   unsigned int val = get_expr_value_id (expr);\n   if (value_id_constant_p (val))\n-    return;\n+    return false;\n \n   if (bitmap_set_contains_value (set, val))\n     {\n@@ -1002,13 +1002,14 @@ bitmap_value_replace_in_set (bitmap_set_t set, pre_expr expr)\n \t  if (bitmap_clear_bit (&set->expressions, i))\n \t    {\n \t      bitmap_set_bit (&set->expressions, get_expression_id (expr));\n-\t      return;\n+\t      return i != get_expression_id (expr);\n \t    }\n \t}\n       gcc_unreachable ();\n     }\n-  else\n-    bitmap_insert_into_set (set, expr);\n+\n+  bitmap_insert_into_set (set, expr);\n+  return true;\n }\n \n /* Insert EXPR into SET if EXPR's value is not already present in\n@@ -3158,14 +3159,19 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t  && expr->kind != REFERENCE)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Skipping insertion of phi for partial redundancy: Looks like an induction variable\\n\");\n+\t    fprintf (dump_file, \"Skipping insertion of phi for partial \"\n+\t\t     \"redundancy: Looks like an induction variable\\n\");\n \t  nophi = true;\n \t}\n     }\n \n   /* Make the necessary insertions.  */\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     {\n+      /* When we are not inserting a PHI node do not bother inserting\n+\t into places that do not dominate the anticipated computations.  */\n+      if (nophi && !dominated_by_p (CDI_DOMINATORS, block, pred->src))\n+\tcontinue;\n       gimple_seq stmts = NULL;\n       tree builtexpr;\n       bprime = pred->src;\n@@ -3308,15 +3314,14 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n */\n \n static bool\n-do_pre_regular_insertion (basic_block block, basic_block dom)\n+do_pre_regular_insertion (basic_block block, basic_block dom,\n+\t\t\t  vec<pre_expr> exprs)\n {\n   bool new_stuff = false;\n-  vec<pre_expr> exprs;\n   pre_expr expr;\n   auto_vec<pre_expr, 2> avail;\n   int i;\n \n-  exprs = sorted_array_from_bitmap_set (ANTIC_IN (block));\n   avail.safe_grow (EDGE_COUNT (block->preds), true);\n \n   FOR_EACH_VEC_ELT (exprs, i, expr)\n@@ -3464,7 +3469,6 @@ do_pre_regular_insertion (basic_block block, basic_block dom)\n \t}\n     }\n \n-  exprs.release ();\n   return new_stuff;\n }\n \n@@ -3476,15 +3480,14 @@ do_pre_regular_insertion (basic_block block, basic_block dom)\n    remove the later computation.  */\n \n static bool\n-do_pre_partial_partial_insertion (basic_block block, basic_block dom)\n+do_pre_partial_partial_insertion (basic_block block, basic_block dom,\n+\t\t\t\t  vec<pre_expr> exprs)\n {\n   bool new_stuff = false;\n-  vec<pre_expr> exprs;\n   pre_expr expr;\n   auto_vec<pre_expr, 2> avail;\n   int i;\n \n-  exprs = sorted_array_from_bitmap_set (PA_IN (block));\n   avail.safe_grow (EDGE_COUNT (block->preds), true);\n \n   FOR_EACH_VEC_ELT (exprs, i, expr)\n@@ -3599,7 +3602,6 @@ do_pre_partial_partial_insertion (basic_block block, basic_block dom)\n \t}\n     }\n \n-  exprs.release ();\n   return new_stuff;\n }\n \n@@ -3759,7 +3761,10 @@ insert (void)\n     NEW_SETS (bb) = bitmap_set_new ();\n \n   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n+  int *bb_rpo = XNEWVEC (int, last_basic_block_for_fn (cfun) + 1);\n   int rpo_num = pre_and_rev_post_order_compute (NULL, rpo, false);\n+  for (int i = 0; i < rpo_num; ++i)\n+    bb_rpo[rpo[i]] = i;\n \n   int num_iterations = 0;\n   bool changed;\n@@ -3783,26 +3788,47 @@ insert (void)\n \t      /* First, update the AVAIL_OUT set with anything we may have\n \t\t inserted higher up in the dominator tree.  */\n \t      newset = NEW_SETS (dom);\n-\t      if (newset)\n+\n+\t      /* Note that we need to value_replace both NEW_SETS, and\n+\t\t AVAIL_OUT. For both the case of NEW_SETS, the value may be\n+\t\t represented by some non-simple expression here that we want\n+\t\t to replace it with.  */\n+\t      bool avail_out_changed = false;\n+\t      FOR_EACH_EXPR_ID_IN_SET (newset, i, bi)\n \t\t{\n-\t\t  /* Note that we need to value_replace both NEW_SETS, and\n-\t\t     AVAIL_OUT. For both the case of NEW_SETS, the value may be\n-\t\t     represented by some non-simple expression here that we want\n-\t\t     to replace it with.  */\n-\t\t  FOR_EACH_EXPR_ID_IN_SET (newset, i, bi)\n-\t\t    {\n-\t\t      pre_expr expr = expression_for_id (i);\n-\t\t      bitmap_value_replace_in_set (NEW_SETS (block), expr);\n-\t\t      bitmap_value_replace_in_set (AVAIL_OUT (block), expr);\n-\t\t    }\n+\t\t  pre_expr expr = expression_for_id (i);\n+\t\t  bitmap_value_replace_in_set (NEW_SETS (block), expr);\n+\t\t  avail_out_changed\n+\t\t    |= bitmap_value_replace_in_set (AVAIL_OUT (block), expr);\n+\t\t}\n+\t      /* We need to iterate if AVAIL_OUT of an already processed\n+\t\t block source.  */\n+\t      if (avail_out_changed && !changed)\n+\t\t{\n+\t\t  edge_iterator ei;\n+\t\t  edge e;\n+\t\t  FOR_EACH_EDGE (e, ei, block->succs)\n+\t\t    if (bb_rpo[e->src->index] < idx)\n+\t\t      changed = true;\n \t\t}\n \n \t      /* Insert expressions for partial redundancies.  */\n \t      if (flag_tree_pre && !single_pred_p (block))\n \t\t{\n-\t\t  changed |= do_pre_regular_insertion (block, dom);\n+\t\t  vec<pre_expr> exprs\n+\t\t    = sorted_array_from_bitmap_set (ANTIC_IN (block));\n+\t\t  /* Sorting is not perfect, iterate locally.  */\n+\t\t  while (do_pre_regular_insertion (block, dom, exprs))\n+\t\t    ;\n+\t\t  exprs.release ();\n \t\t  if (do_partial_partial)\n-\t\t    changed |= do_pre_partial_partial_insertion (block, dom);\n+\t\t    {\n+\t\t      exprs = sorted_array_from_bitmap_set (PA_IN (block));\n+\t\t      while (do_pre_partial_partial_insertion (block, dom,\n+\t\t\t\t\t\t\t       exprs))\n+\t\t\t;\n+\t\t      exprs.release ();\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -3821,6 +3847,7 @@ insert (void)\n      propagate NEW_SETS from hoist insertion.  */\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n+      bitmap_set_free (NEW_SETS (bb));\n       bitmap_set_pool.remove (NEW_SETS (bb));\n       NEW_SETS (bb) = NULL;\n     }\n@@ -3840,6 +3867,7 @@ insert (void)\n       }\n \n   free (rpo);\n+  free (bb_rpo);\n }\n \n "}]}