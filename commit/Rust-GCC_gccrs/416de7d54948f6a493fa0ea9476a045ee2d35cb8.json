{"sha": "416de7d54948f6a493fa0ea9476a045ee2d35cb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE2ZGU3ZDU0OTQ4ZjZhNDkzZmEwZWE5NDc2YTA0NWVlMmQzNWNiOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-08T21:12:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-08T21:12:37Z"}, "message": "utils.c (unchecked_convert): Use a field of the right precision when converting to or from an integral type...\n\n\t* gcc-interface/utils.c (unchecked_convert): Use a field of the right\n\tprecision when converting to or from an integral type whose precision\n\tis not equal to its size.\n\nFrom-SVN: r178711", "tree": {"sha": "d576fe6f01cff202e1a0b2a1d8cea0750707bd45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d576fe6f01cff202e1a0b2a1d8cea0750707bd45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/416de7d54948f6a493fa0ea9476a045ee2d35cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416de7d54948f6a493fa0ea9476a045ee2d35cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/416de7d54948f6a493fa0ea9476a045ee2d35cb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416de7d54948f6a493fa0ea9476a045ee2d35cb8/comments", "author": null, "committer": null, "parents": [{"sha": "c3c5a1ccc0c0db8f4a1432c293135895343970d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c5a1ccc0c0db8f4a1432c293135895343970d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3c5a1ccc0c0db8f4a1432c293135895343970d5"}], "stats": {"total": 50, "additions": 38, "deletions": 12}, "files": [{"sha": "74b3cfb36504ebe7f0b1995044eb49effaaf3584", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416de7d54948f6a493fa0ea9476a045ee2d35cb8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416de7d54948f6a493fa0ea9476a045ee2d35cb8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=416de7d54948f6a493fa0ea9476a045ee2d35cb8", "patch": "@@ -1,11 +1,16 @@\n+2011-09-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (unchecked_convert): Use a field of the right\n+\tprecision when converting to or from an integral type whose precision\n+\tis not equal to its size.\n+\n 2011-09-08  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\t* traceback.c (Darwin) USE_GCC_UNWINDER for Darwin\n-\tversions >= 8.\n+\t* traceback.c (Darwin) USE_GCC_UNWINDER for Darwin versions >= 8.\n \n 2011-09-07  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\t* gcc-interface/Makefile.in (darwin): Provide powerpc64 system \n+\t* gcc-interface/Makefile.in (darwin): Provide powerpc64 system\n \timplementation.\n \t* system-darwin-ppc64.ads: New file.\n \n@@ -21,7 +26,7 @@\n \n 2011-09-06  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\t* gcc-interface/Makefile.in (x86_64 darwin arch): Adjust \n+\t* gcc-interface/Makefile.in (x86_64 darwin arch): Adjust\n \tLIBGNAT_TARGET_PAIRS for x86 and x86_64 variants.\n \n 2011-09-06  Arnaud Charlet  <charlet@adacore.com>"}, {"sha": "1a1034732b566ac2c176cddb4406894b59cb8770", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416de7d54948f6a493fa0ea9476a045ee2d35cb8/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416de7d54948f6a493fa0ea9476a045ee2d35cb8/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=416de7d54948f6a493fa0ea9476a045ee2d35cb8", "patch": "@@ -4403,39 +4403,60 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n     }\n \n   /* If we are converting to an integral type whose precision is not equal\n-     to its size, first unchecked convert to a record that contains an\n-     object of the output type.  Then extract the field. */\n+     to its size, first unchecked convert to a record type that contains an\n+     field of the given precision.  Then extract the field.  */\n   else if (INTEGRAL_TYPE_P (type)\n \t   && TYPE_RM_SIZE (type)\n \t   && 0 != compare_tree_int (TYPE_RM_SIZE (type),\n \t\t\t\t     GET_MODE_BITSIZE (TYPE_MODE (type))))\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n-      tree field = create_field_decl (get_identifier (\"OBJ\"), type, rec_type,\n-\t\t\t\t      NULL_TREE, NULL_TREE, 1, 0);\n+      unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (type));\n+      tree field_type, field;\n+\n+      if (TYPE_UNSIGNED (type))\n+\tfield_type = make_unsigned_type (prec);\n+      else\n+\tfield_type = make_signed_type (prec);\n+      SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (type));\n+\n+      field = create_field_decl (get_identifier (\"OBJ\"), field_type, rec_type,\n+\t\t\t\t NULL_TREE, NULL_TREE, 1, 0);\n \n       TYPE_FIELDS (rec_type) = field;\n       layout_type (rec_type);\n \n       expr = unchecked_convert (rec_type, expr, notrunc_p);\n       expr = build_component_ref (expr, NULL_TREE, field, false);\n+      expr = fold_build1 (NOP_EXPR, type, expr);\n     }\n \n-  /* Similarly if we are converting from an integral type whose precision\n-     is not equal to its size.  */\n+  /* Similarly if we are converting from an integral type whose precision is\n+     not equal to its size, first copy into a field of the given precision\n+     and unchecked convert the record type.  */\n   else if (INTEGRAL_TYPE_P (etype)\n \t   && TYPE_RM_SIZE (etype)\n \t   && 0 != compare_tree_int (TYPE_RM_SIZE (etype),\n \t\t\t\t     GET_MODE_BITSIZE (TYPE_MODE (etype))))\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n-      tree field = create_field_decl (get_identifier (\"OBJ\"), etype, rec_type,\n-\t\t\t\t      NULL_TREE, NULL_TREE, 1, 0);\n+      unsigned HOST_WIDE_INT prec = TREE_INT_CST_LOW (TYPE_RM_SIZE (etype));\n       VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 1);\n+      tree field_type, field;\n+\n+      if (TYPE_UNSIGNED (etype))\n+\tfield_type = make_unsigned_type (prec);\n+      else\n+\tfield_type = make_signed_type (prec);\n+      SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (etype));\n+\n+      field = create_field_decl (get_identifier (\"OBJ\"), field_type, rec_type,\n+\t\t\t\t NULL_TREE, NULL_TREE, 1, 0);\n \n       TYPE_FIELDS (rec_type) = field;\n       layout_type (rec_type);\n \n+      expr = fold_build1 (NOP_EXPR, field_type, expr);\n       CONSTRUCTOR_APPEND_ELT (v, field, expr);\n       expr = gnat_build_constructor (rec_type, v);\n       expr = unchecked_convert (type, expr, notrunc_p);"}]}