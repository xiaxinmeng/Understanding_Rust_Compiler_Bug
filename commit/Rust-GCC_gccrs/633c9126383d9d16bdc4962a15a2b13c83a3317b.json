{"sha": "633c9126383d9d16bdc4962a15a2b13c83a3317b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMzYzkxMjYzODNkOWQxNmJkYzQ5NjJhMTVhMmIxM2M4M2EzMzE3Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2011-03-29T22:49:00Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2011-03-29T22:49:00Z"}, "message": "re PR bootstrap/48327 (Bootstrap comparison failure with ada since r171622)\n\n\tPR bootstrap/48327\n\t* tree-ssa-threadupdate.c (struct redirection_data): Remove\n\tdo_not_duplicate field.\n\t(lookup_redirection_data): Corresponding changes.\n\t(create_duplicates): Always create a template block.\n\t(redirect_edges): Remove code which reused the original block\n\twhen it was going to become unreachable code.\n\t(thread_block): Don't set do_not_duplicate field.\n\nFrom-SVN: r171703", "tree": {"sha": "aa4ec0cd595705077050806cb569da4dfacf4191", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa4ec0cd595705077050806cb569da4dfacf4191"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/633c9126383d9d16bdc4962a15a2b13c83a3317b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/633c9126383d9d16bdc4962a15a2b13c83a3317b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/633c9126383d9d16bdc4962a15a2b13c83a3317b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/633c9126383d9d16bdc4962a15a2b13c83a3317b/comments", "author": null, "committer": null, "parents": [{"sha": "eb50f63aff735be65ee1fe087130c0961ceea01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb50f63aff735be65ee1fe087130c0961ceea01c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb50f63aff735be65ee1fe087130c0961ceea01c"}], "stats": {"total": 79, "additions": 22, "deletions": 57}, "files": [{"sha": "d456e441b2b60c769eb0a7935b55970f48657575", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/633c9126383d9d16bdc4962a15a2b13c83a3317b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/633c9126383d9d16bdc4962a15a2b13c83a3317b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=633c9126383d9d16bdc4962a15a2b13c83a3317b", "patch": "@@ -1,3 +1,14 @@\n+2011-03-29  Jeff Law  <law@redhat.com>\n+\n+\tPR bootstrap/48327\n+\t* tree-ssa-threadupdate.c (struct redirection_data): Remove\n+\tdo_not_duplicate field.\n+\t(lookup_redirection_data): Corresponding changes.\n+\t(create_duplicates): Always create a template block.\n+\t(redirect_edges): Remove code which reused the original block\n+\twhen it was going to become unreachable code.\n+\t(thread_block): Don't set do_not_duplicate field.\n+\n 2011-03-29  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lto-opts.c (register_user_option_p, lto_register_user_option):"}, {"sha": "fdb8601a9fe2994e1bfc53ff2a3cdfd37ab72abc", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 11, "deletions": 57, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/633c9126383d9d16bdc4962a15a2b13c83a3317b/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/633c9126383d9d16bdc4962a15a2b13c83a3317b/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=633c9126383d9d16bdc4962a15a2b13c83a3317b", "patch": "@@ -69,9 +69,16 @@ along with GCC; see the file COPYING3.  If not see\n \n    Note that block duplication can be minimized by first collecting the\n    set of unique destination blocks that the incoming edges should\n-   be threaded to.  Block duplication can be further minimized by using\n-   B instead of creating B' for one destination if all edges into B are\n-   going to be threaded to a successor of B.\n+   be threaded to.\n+\n+   Block duplication can be further minimized by using B instead of \n+   creating B' for one destination if all edges into B are going to be\n+   threaded to a successor of B.  We had code to do this at one time, but\n+   I'm not convinced it is correct with the changes to avoid mucking up\n+   the loop structure (which may cancel threading requests, thus a block\n+   which we thought was going to become unreachable may still be reachable).\n+   This code was also going to get ugly with the introduction of the ability\n+   for a single jump thread request to bypass multiple blocks. \n \n    We further reduce the number of edges and statements we create by\n    not copying all the outgoing edges and the control statement in\n@@ -117,11 +124,6 @@ struct redirection_data\n   /* A list of incoming edges which we want to thread to\n      OUTGOING_EDGE->dest.  */\n   struct el *incoming_edges;\n-\n-  /* Flag indicating whether or not we should create a duplicate block\n-     for this thread destination.  This is only true if we are threading\n-     all incoming edges and thus are using BB itself as a duplicate block.  */\n-  bool do_not_duplicate;\n };\n \n /* Main data structure to hold information for duplicates of BB.  */\n@@ -249,7 +251,6 @@ lookup_redirection_data (edge e, edge incoming_edge, enum insert_option insert)\n   elt = XNEW (struct redirection_data);\n   elt->outgoing_edge = e;\n   elt->dup_block = NULL;\n-  elt->do_not_duplicate = false;\n   elt->incoming_edges = NULL;\n \n   slot = htab_find_slot (redirection_data, elt, insert);\n@@ -338,11 +339,6 @@ create_duplicates (void **slot, void *data)\n   struct redirection_data *rd = (struct redirection_data *) *slot;\n   struct local_info *local_info = (struct local_info *)data;\n \n-  /* If this entry should not have a duplicate created, then there's\n-     nothing to do.  */\n-  if (rd->do_not_duplicate)\n-    return 1;\n-\n   /* Create a template block if we have not done so already.  Otherwise\n      use the template to create a new block.  */\n   if (local_info->template_block == NULL)\n@@ -433,31 +429,6 @@ redirect_edges (void **slot, void *data)\n \t  gcc_assert (e == e2);\n \t  flush_pending_stmts (e2);\n \t}\n-      else\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n-\t\t     e->src->index, e->dest->index, local_info->bb->index);\n-\n-\t  /* We are using BB as the duplicate.  Remove the unnecessary\n-\t     outgoing edges and statements from BB.  */\n-\t  remove_ctrl_stmt_and_useless_edges (local_info->bb,\n-\t\t\t\t\t      rd->outgoing_edge->dest);\n-\n-\t  /* If we are threading beyond the immediate successors of\n-\t     the duplicate, then BB will have no edges, create one.  */\n-\t  if (EDGE_COUNT (local_info->bb->succs) == 0)\n-\t    create_edge_and_update_destination_phis (rd, local_info->bb);\n-\n-\t  /* Fixup the flags on the single remaining edge.  */\n-\t  single_succ_edge (local_info->bb)->flags\n-\t    &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_ABNORMAL);\n-\t  single_succ_edge (local_info->bb)->flags |= EDGE_FALLTHRU;\n-\n-\t  /* And adjust count and frequency on BB.  */\n-\t  local_info->bb->count = e->count;\n-\t  local_info->bb->frequency = EDGE_FREQUENCY (e);\n-\t}\n     }\n \n   /* Indicate that we actually threaded one or more jumps.  */\n@@ -526,10 +497,6 @@ thread_block (basic_block bb, bool noloop_only)\n   struct local_info local_info;\n   struct loop *loop = bb->loop_father;\n \n-  /* ALL indicates whether or not all incoming edges into BB should\n-     be threaded to a duplicate of BB.  */\n-  bool all = true;\n-\n   /* To avoid scanning a linear array for the element we need we instead\n      use a hash table.  For normal code there should be no noticeable\n      difference.  However, if we have a block with a large number of\n@@ -566,10 +533,7 @@ thread_block (basic_block bb, bool noloop_only)\n \t  || (noloop_only\n \t      && bb == bb->loop_father->header\n \t      && !loop_exit_edge_p (bb->loop_father, e2)))\n-\t{\n-\t  all = false;\n-\t  continue;\n-\t}\n+\tcontinue;\n \n       if (e->dest == e2->src)\n \tupdate_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n@@ -580,16 +544,6 @@ thread_block (basic_block bb, bool noloop_only)\n       lookup_redirection_data (e2, e, INSERT);\n     }\n \n-  /* If we are going to thread all incoming edges to an outgoing edge, then\n-     BB will become unreachable.  Rather than just throwing it away, use\n-     it for one of the duplicates.  Mark the first incoming edge with the\n-     DO_NOT_DUPLICATE attribute.  */\n-  if (all)\n-    {\n-      edge e = (edge) EDGE_PRED (bb, 0)->aux;\n-      lookup_redirection_data (e, NULL, NO_INSERT)->do_not_duplicate = true;\n-    }\n-\n   /* We do not update dominance info.  */\n   free_dominance_info (CDI_DOMINATORS);\n "}]}