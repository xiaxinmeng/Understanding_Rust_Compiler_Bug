{"sha": "c575a65f66db572f4fbec024465544dbdd647685", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU3NWE2NWY2NmRiNTcyZjRmYmVjMDI0NDY1NTQ0ZGJkZDY0NzY4NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-10-28T10:32:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-28T10:32:03Z"}, "message": "combine.c (set_nonzero_bits_and_sign_copies): Use unsigned arithmetics in masking operations.\n\n\t* combine.c (set_nonzero_bits_and_sign_copies): Use unsigned\n\tarithmetics in masking operations.\n\t(contains_muldiv): Likewise.\n\t(try_combine): Likewise.\n\t(find_split_point): Likewise.\n\t(combine_simplify_rtx): Likewise.\n\t(simplify_if_then_else): Likewise.\n\t(simplify_set): Likewise.\n\t(expand_compound_operation): Likewise.\n\t(expand_field_assignment): Likewise.\n\t(make_extraction): Likewise.\n\t(extract_left_shift): Likewise.\n\t(make_compound_operation): Likewise.\n\t(force_to_mode): Likewise.\n\t(make_field_assignment): Likewise.\n\t(reg_nonzero_bits_for_combine): Likewise.\n\t(simplify_shift_const_1): Likewise.\n\t(simplify_comparison): Likewise.\n\nFrom-SVN: r166027", "tree": {"sha": "55015449f71fc5bb6714771b4207bea7931cf4de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55015449f71fc5bb6714771b4207bea7931cf4de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c575a65f66db572f4fbec024465544dbdd647685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c575a65f66db572f4fbec024465544dbdd647685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c575a65f66db572f4fbec024465544dbdd647685", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c575a65f66db572f4fbec024465544dbdd647685/comments", "author": null, "committer": null, "parents": [{"sha": "f228e2ae59f04b71593e448cf4e654f51fe1318a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f228e2ae59f04b71593e448cf4e654f51fe1318a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f228e2ae59f04b71593e448cf4e654f51fe1318a"}], "stats": {"total": 243, "additions": 133, "deletions": 110}, "files": [{"sha": "2437bfd50496f55aa0e09377d22cf79c703c2764", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575a65f66db572f4fbec024465544dbdd647685/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575a65f66db572f4fbec024465544dbdd647685/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c575a65f66db572f4fbec024465544dbdd647685", "patch": "@@ -1,3 +1,24 @@\n+2010-10-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* combine.c (set_nonzero_bits_and_sign_copies): Use unsigned\n+\tarithmetics in masking operations.\n+\t(contains_muldiv): Likewise.\n+\t(try_combine): Likewise.\n+\t(find_split_point): Likewise.\n+\t(combine_simplify_rtx): Likewise.\n+\t(simplify_if_then_else): Likewise.\n+\t(simplify_set): Likewise.\n+\t(expand_compound_operation): Likewise.\n+\t(expand_field_assignment): Likewise.\n+\t(make_extraction): Likewise.\n+\t(extract_left_shift): Likewise.\n+\t(make_compound_operation): Likewise.\n+\t(force_to_mode): Likewise.\n+\t(make_field_assignment): Likewise.\n+\t(reg_nonzero_bits_for_combine): Likewise.\n+\t(simplify_shift_const_1): Likewise.\n+\t(simplify_comparison): Likewise.\n+\n 2010-10-27  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/ia64/ia64-protos.h (ia64_function_arg): Delete."}, {"sha": "88b3ca5e15f0dfe9241a0ee66531f9f7fd9ee99b", "filename": "gcc/combine.c", "status": "modified", "additions": 112, "deletions": 110, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575a65f66db572f4fbec024465544dbdd647685/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575a65f66db572f4fbec024465544dbdd647685/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c575a65f66db572f4fbec024465544dbdd647685", "patch": "@@ -1594,11 +1594,11 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n \t  if (GET_MODE_BITSIZE (GET_MODE (x)) < BITS_PER_WORD\n \t      && CONST_INT_P (src)\n \t      && INTVAL (src) > 0\n-\t      && 0 != (INTVAL (src)\n-\t\t       & ((HOST_WIDE_INT) 1\n+\t      && 0 != (UINTVAL (src)\n+\t\t       & ((unsigned HOST_WIDE_INT) 1\n \t\t\t  << (GET_MODE_BITSIZE (GET_MODE (x)) - 1))))\n-\t    src = GEN_INT (INTVAL (src)\n-\t\t\t   | ((HOST_WIDE_INT) (-1)\n+\t    src = GEN_INT (UINTVAL (src)\n+\t\t\t   | ((unsigned HOST_WIDE_INT) (-1)\n \t\t\t      << GET_MODE_BITSIZE (GET_MODE (x))));\n #endif\n \n@@ -2091,7 +2091,7 @@ contains_muldiv (rtx x)\n \n     case MULT:\n       return ! (CONST_INT_P (XEXP (x, 1))\n-\t\t&& exact_log2 (INTVAL (XEXP (x, 1))) >= 0);\n+\t\t&& exact_log2 (UINTVAL (XEXP (x, 1))) >= 0);\n     default:\n       if (BINARY_P (x))\n \treturn contains_muldiv (XEXP (x, 0))\n@@ -3486,7 +3486,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t  if (split_code == MULT\n \t      && CONST_INT_P (XEXP (*split, 1))\n \t      && INTVAL (XEXP (*split, 1)) > 0\n-\t      && (i = exact_log2 (INTVAL (XEXP (*split, 1)))) >= 0)\n+\t      && (i = exact_log2 (UINTVAL (XEXP (*split, 1)))) >= 0)\n \t    {\n \t      SUBST (*split, gen_rtx_ASHIFT (split_mode,\n \t\t\t\t\t     XEXP (*split, 0), GEN_INT (i)));\n@@ -4576,7 +4576,8 @@ find_split_point (rtx *loc, rtx insn, bool set_src)\n \t  unsigned HOST_WIDE_INT src = INTVAL (SET_SRC (x));\n \t  rtx dest = XEXP (SET_DEST (x), 0);\n \t  enum machine_mode mode = GET_MODE (dest);\n-\t  unsigned HOST_WIDE_INT mask = ((HOST_WIDE_INT) 1 << len) - 1;\n+\t  unsigned HOST_WIDE_INT mask\n+\t    = ((unsigned HOST_WIDE_INT) 1 << len) - 1;\n \t  rtx or_mask;\n \n \t  if (BITS_BIG_ENDIAN)\n@@ -4621,7 +4622,7 @@ find_split_point (rtx *loc, rtx insn, bool set_src)\n \n \t  if (CONST_INT_P (XEXP (SET_SRC (x), 1))\n \t      && REG_P (XEXP (SET_SRC (x), 0))\n-\t      && (pos = exact_log2 (INTVAL (XEXP (SET_SRC (x), 1)))) >= 7\n+\t      && (pos = exact_log2 (UINTVAL (XEXP (SET_SRC (x), 1)))) >= 7\n \t      && REG_P (SET_DEST (x))\n \t      && (split = find_single_use (SET_DEST (x), insn, (rtx*) 0)) != 0\n \t      && (GET_CODE (*split) == EQ || GET_CODE (*split) == NE)\n@@ -4713,7 +4714,8 @@ find_split_point (rtx *loc, rtx insn, bool set_src)\n \t\t\t\t  gen_rtx_LSHIFTRT\n \t\t\t\t  (mode, gen_lowpart (mode, inner),\n \t\t\t\t   GEN_INT (pos)),\n-\t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << len) - 1)));\n+\t\t\t\t  GEN_INT (((unsigned HOST_WIDE_INT) 1 << len)\n+\t\t\t\t\t   - 1)));\n \n \t      split = find_split_point (&SET_SRC (x), insn, true);\n \t      if (split && split != &SET_SRC (x))\n@@ -5471,7 +5473,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t whose value is a comparison can be replaced with a subreg if\n \t STORE_FLAG_VALUE permits.  */\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0\n+\t  && (STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0\n \t  && (temp = get_last_value (XEXP (x, 0)))\n \t  && COMPARISON_P (temp))\n \treturn gen_lowpart (mode, XEXP (x, 0));\n@@ -5506,13 +5508,13 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t  && CONST_INT_P (XEXP (x, 1))\n \t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n \t  && INTVAL (XEXP (x, 1)) == -INTVAL (XEXP (XEXP (x, 0), 1))\n-\t  && ((i = exact_log2 (INTVAL (XEXP (XEXP (x, 0), 1)))) >= 0\n-\t      || (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n+\t  && ((i = exact_log2 (UINTVAL (XEXP (XEXP (x, 0), 1)))) >= 0\n+\t      || (i = exact_log2 (UINTVAL (XEXP (x, 1)))) >= 0)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && ((GET_CODE (XEXP (XEXP (x, 0), 0)) == AND\n \t       && CONST_INT_P (XEXP (XEXP (XEXP (x, 0), 0), 1))\n-\t       && (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n-\t\t   == ((HOST_WIDE_INT) 1 << (i + 1)) - 1))\n+\t       && (UINTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n+\t\t   == ((unsigned HOST_WIDE_INT) 1 << (i + 1)) - 1))\n \t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) == ZERO_EXTEND\n \t\t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (XEXP (x, 0), 0), 0)))\n \t\t      == (unsigned int) i + 1))))\n@@ -5564,7 +5566,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t (and <foo> (const_int pow2-1))  */\n       if (GET_CODE (XEXP (x, 1)) == AND\n \t  && CONST_INT_P (XEXP (XEXP (x, 1), 1))\n-\t  && exact_log2 (-INTVAL (XEXP (XEXP (x, 1), 1))) >= 0\n+\t  && exact_log2 (-UINTVAL (XEXP (XEXP (x, 1), 1))) >= 0\n \t  && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n \treturn simplify_and_const_int (NULL_RTX, mode, XEXP (x, 0),\n \t\t\t\t       -INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n@@ -5598,7 +5600,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       /* If this is a divide by a power of two, treat it as a shift if\n \t its first operand is a shift.  */\n       if (CONST_INT_P (XEXP (x, 1))\n-\t  && (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0\n+\t  && (i = exact_log2 (UINTVAL (XEXP (x, 1)))) >= 0\n \t  && (GET_CODE (XEXP (x, 0)) == ASHIFT\n \t      || GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t      || GET_CODE (XEXP (x, 0)) == ASHIFTRT\n@@ -5798,7 +5800,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n       else if (SHIFT_COUNT_TRUNCATED && !REG_P (XEXP (x, 1)))\n \tSUBST (XEXP (x, 1),\n \t       force_to_mode (XEXP (x, 1), GET_MODE (XEXP (x, 1)),\n-\t\t\t      ((HOST_WIDE_INT) 1\n+\t\t\t      ((unsigned HOST_WIDE_INT) 1\n \t\t\t       << exact_log2 (GET_MODE_BITSIZE (GET_MODE (x))))\n \t\t\t      - 1,\n \t\t\t      0));\n@@ -6129,10 +6131,10 @@ simplify_if_then_else (rtx x)\n   if (true_code == NE && XEXP (cond, 1) == const0_rtx\n       && false_rtx == const0_rtx && CONST_INT_P (true_rtx)\n       && ((1 == nonzero_bits (XEXP (cond, 0), mode)\n-\t   && (i = exact_log2 (INTVAL (true_rtx))) >= 0)\n+\t   && (i = exact_log2 (UINTVAL (true_rtx))) >= 0)\n \t  || ((num_sign_bit_copies (XEXP (cond, 0), mode)\n \t       == GET_MODE_BITSIZE (mode))\n-\t      && (i = exact_log2 (-INTVAL (true_rtx))) >= 0)))\n+\t      && (i = exact_log2 (-UINTVAL (true_rtx))) >= 0)))\n     return\n       simplify_shift_const (NULL_RTX, ASHIFT, mode,\n \t\t\t    gen_lowpart (mode, XEXP (cond, 0)), i);\n@@ -6141,9 +6143,9 @@ simplify_if_then_else (rtx x)\n   if (true_code == NE && XEXP (cond, 1) == const0_rtx\n       && false_rtx == const0_rtx && CONST_INT_P (true_rtx)\n       && GET_MODE (XEXP (cond, 0)) == mode\n-      && (INTVAL (true_rtx) & GET_MODE_MASK (mode))\n+      && (UINTVAL (true_rtx) & GET_MODE_MASK (mode))\n \t  == nonzero_bits (XEXP (cond, 0), mode)\n-      && (i = exact_log2 (INTVAL (true_rtx) & GET_MODE_MASK (mode))) >= 0)\n+      && (i = exact_log2 (UINTVAL (true_rtx) & GET_MODE_MASK (mode))) >= 0)\n     return XEXP (cond, 0);\n \n   return x;\n@@ -6172,7 +6174,7 @@ simplify_set (rtx x)\n   if (GET_MODE_CLASS (mode) == MODE_INT\n       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n-      src = force_to_mode (src, mode, ~(HOST_WIDE_INT) 0, 0);\n+      src = force_to_mode (src, mode, ~(unsigned HOST_WIDE_INT) 0, 0);\n       SUBST (SET_SRC (x), src);\n     }\n \n@@ -6717,8 +6719,7 @@ expand_compound_operation (rtx x)\n \t  && COMPARISON_P (XEXP (XEXP (x, 0), 0))\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t      <= HOST_BITS_PER_WIDE_INT)\n-\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE\n-\t      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n+\t  && (STORE_FLAG_VALUE & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn XEXP (XEXP (x, 0), 0);\n \n       /* Likewise for (zero_extend:DI (subreg:SI foo:DI 0)).  */\n@@ -6728,8 +6729,7 @@ expand_compound_operation (rtx x)\n \t  && COMPARISON_P (SUBREG_REG (XEXP (x, 0)))\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t      <= HOST_BITS_PER_WIDE_INT)\n-\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE\n-\t      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n+\t  && (STORE_FLAG_VALUE & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn SUBREG_REG (XEXP (x, 0));\n \n     }\n@@ -6766,7 +6766,7 @@ expand_compound_operation (rtx x)\n \t\t\t\t  simplify_shift_const (NULL_RTX, LSHIFTRT,\n \t\t\t\t\t\t\tGET_MODE (x),\n \t\t\t\t\t\t\tXEXP (x, 0), pos),\n-\t\t\t\t  ((HOST_WIDE_INT) 1 << len) - 1);\n+\t\t\t\t  ((unsigned HOST_WIDE_INT) 1 << len) - 1);\n   else\n     /* Any other cases we can't handle.  */\n     return x;\n@@ -6887,7 +6887,7 @@ expand_field_assignment (const_rtx x)\n       /* Now compute the equivalent expression.  Make a copy of INNER\n \t for the SET_DEST in case it is a MEM into which we will substitute;\n \t we don't want shared RTL in that case.  */\n-      mask = GEN_INT (((HOST_WIDE_INT) 1 << len) - 1);\n+      mask = GEN_INT (((unsigned HOST_WIDE_INT) 1 << len) - 1);\n       cleared = simplify_gen_binary (AND, compute_mode,\n \t\t\t\t     simplify_gen_unary (NOT, compute_mode,\n \t\t\t\t       simplify_gen_binary (ASHIFT,\n@@ -6963,7 +6963,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n   else if (GET_CODE (inner) == ASHIFT\n \t   && CONST_INT_P (XEXP (inner, 1))\n \t   && pos_rtx == 0 && pos == 0\n-\t   && len > (unsigned HOST_WIDE_INT) INTVAL (XEXP (inner, 1)))\n+\t   && len > UINTVAL (XEXP (inner, 1)))\n     {\n       /* We're extracting the least significant bits of an rtx\n \t (ashift X (const_int C)), where LEN > C.  Extract the\n@@ -7369,7 +7369,8 @@ extract_left_shift (rtx x, int count)\n       /* If we can safely shift this constant and we find the inner shift,\n \t make a new operation.  */\n       if (CONST_INT_P (XEXP (x, 1))\n-\t  && (INTVAL (XEXP (x, 1)) & ((((HOST_WIDE_INT) 1 << count)) - 1)) == 0\n+\t  && (UINTVAL (XEXP (x, 1))\n+\t      & ((((unsigned HOST_WIDE_INT) 1 << count)) - 1)) == 0\n \t  && (tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n \treturn simplify_gen_binary (code, mode, tem,\n \t\t\t\t    GEN_INT (INTVAL (XEXP (x, 1)) >> count));\n@@ -7519,7 +7520,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n       /* If the constant is a power of two minus one and the first operand\n \t is a logical right shift, make an extraction.  */\n       if (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n-\t  && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n+\t  && (i = exact_log2 (UINTVAL (XEXP (x, 1)) + 1)) >= 0)\n \t{\n \t  new_rtx = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n \t  new_rtx = make_extraction (mode, new_rtx, 0, XEXP (XEXP (x, 0), 1), i, 1,\n@@ -7530,7 +7531,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n       else if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t       && subreg_lowpart_p (XEXP (x, 0))\n \t       && GET_CODE (SUBREG_REG (XEXP (x, 0))) == LSHIFTRT\n-\t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n+\t       && (i = exact_log2 (UINTVAL (XEXP (x, 1)) + 1)) >= 0)\n \t{\n \t  new_rtx = make_compound_operation (XEXP (SUBREG_REG (XEXP (x, 0)), 0),\n \t\t\t\t\t next_code);\n@@ -7543,7 +7544,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t\t|| GET_CODE (XEXP (x, 0)) == IOR)\n \t       && GET_CODE (XEXP (XEXP (x, 0), 0)) == LSHIFTRT\n \t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == LSHIFTRT\n-\t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n+\t       && (i = exact_log2 (UINTVAL (XEXP (x, 1)) + 1)) >= 0)\n \t{\n \t  /* Apply the distributive law, and then try to make extractions.  */\n \t  new_rtx = gen_rtx_fmt_ee (GET_CODE (XEXP (x, 0)), mode,\n@@ -7559,7 +7560,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \n       else if (GET_CODE (XEXP (x, 0)) == ROTATE\n \t       && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n-\t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0\n+\t       && (i = exact_log2 (UINTVAL (XEXP (x, 1)) + 1)) >= 0\n \t       && i <= INTVAL (XEXP (XEXP (x, 0), 1)))\n \t{\n \t  new_rtx = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n@@ -7595,7 +7596,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t representable by an extraction even if no shift is present.\n \t If it doesn't end up being a ZERO_EXTEND, we will ignore it unless\n \t we are in a COMPARE.  */\n-      else if ((i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n+      else if ((i = exact_log2 (UINTVAL (XEXP (x, 1)) + 1)) >= 0)\n \tnew_rtx = make_extraction (mode,\n \t\t\t       make_compound_operation (XEXP (x, 0),\n \t\t\t\t\t\t\tnext_code),\n@@ -7604,7 +7605,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n       /* If we are in a comparison and this is an AND with a power of two,\n \t convert this into the appropriate bit extract.  */\n       else if (in_code == COMPARE\n-\t       && (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n+\t       && (i = exact_log2 (UINTVAL (XEXP (x, 1)))) >= 0)\n \tnew_rtx = make_extraction (mode,\n \t\t\t       make_compound_operation (XEXP (x, 0),\n \t\t\t\t\t\t\tnext_code),\n@@ -7685,7 +7686,8 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t    && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (inner))\n \t    && subreg_lowpart_p (x))\n \t  {\n-\t    rtx newer = force_to_mode (tem, mode, ~(HOST_WIDE_INT) 0, 0);\n+\t    rtx newer\n+\t      = force_to_mode (tem, mode, ~(unsigned HOST_WIDE_INT) 0, 0);\n \n \t    /* If we have something other than a SUBREG, we might have\n \t       done an expansion, so rerun ourselves.  */\n@@ -8047,16 +8049,17 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t      && GET_MODE_MASK (GET_MODE (x)) != mask\n \t      && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      HOST_WIDE_INT cval = (INTVAL (XEXP (x, 1))\n-\t\t\t\t    | (GET_MODE_MASK (GET_MODE (x)) & ~mask));\n+\t      unsigned HOST_WIDE_INT cval\n+\t\t= UINTVAL (XEXP (x, 1))\n+\t\t  | (GET_MODE_MASK (GET_MODE (x)) & ~mask);\n \t      int width = GET_MODE_BITSIZE (GET_MODE (x));\n \t      rtx y;\n \n \t      /* If MODE is narrower than HOST_WIDE_INT and CVAL is a negative\n \t\t number, sign extend it.  */\n \t      if (width > 0 && width < HOST_BITS_PER_WIDE_INT\n-\t\t  && (cval & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n-\t\tcval |= (HOST_WIDE_INT) -1 << width;\n+\t\t  && (cval & ((unsigned HOST_WIDE_INT) 1 << (width - 1))) != 0)\n+\t\tcval |= (unsigned HOST_WIDE_INT) -1 << width;\n \n \t      y = simplify_gen_binary (AND, GET_MODE (x),\n \t\t\t\t       XEXP (x, 0), GEN_INT (cval));\n@@ -8084,8 +8087,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t   number, sign extend it.  */\n \n \tif (width < HOST_BITS_PER_WIDE_INT\n-\t    && (smask & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n-\t  smask |= (HOST_WIDE_INT) -1 << width;\n+\t    && (smask & ((unsigned HOST_WIDE_INT) 1 << (width - 1))) != 0)\n+\t  smask |= (unsigned HOST_WIDE_INT) (-1) << width;\n \n \tif (CONST_INT_P (XEXP (x, 1))\n \t    && exact_log2 (- smask) >= 0\n@@ -8121,8 +8124,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* Similarly, if C contains every bit in the fuller_mask, then we may\n \t replace with (not Y).  */\n       if (CONST_INT_P (XEXP (x, 0))\n-\t  && ((INTVAL (XEXP (x, 0)) | (HOST_WIDE_INT) fuller_mask)\n-\t      == INTVAL (XEXP (x, 0))))\n+\t  && ((UINTVAL (XEXP (x, 0)) | fuller_mask) == UINTVAL (XEXP (x, 0))))\n \t{\n \t  x = simplify_gen_unary (NOT, GET_MODE (x),\n \t\t\t\t  XEXP (x, 1), GET_MODE (x));\n@@ -8147,7 +8149,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \t  && ((INTVAL (XEXP (XEXP (x, 0), 1))\n \t       + floor_log2 (INTVAL (XEXP (x, 1))))\n \t      < GET_MODE_BITSIZE (GET_MODE (x)))\n-\t  && (INTVAL (XEXP (x, 1))\n+\t  && (UINTVAL (XEXP (x, 1))\n \t      & ~nonzero_bits (XEXP (x, 0), GET_MODE (x))) == 0)\n \t{\n \t  temp = GEN_INT ((INTVAL (XEXP (x, 1)) & mask)\n@@ -8294,7 +8296,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n \t  if (GET_MODE_BITSIZE (GET_MODE (x)) > HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      nonzero = ~(HOST_WIDE_INT) 0;\n+\t      nonzero = ~(unsigned HOST_WIDE_INT) 0;\n \n \t      /* GET_MODE_BITSIZE (GET_MODE (x)) - INTVAL (XEXP (x, 1))\n \t\t is the number of bits a full-width mask would have set.\n@@ -8425,7 +8427,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n       /* (and (ne FOO 0) CONST) can be (and FOO CONST) if CONST is included\n \t in STORE_FLAG_VALUE and FOO has a single bit that might be nonzero,\n \t which is equal to STORE_FLAG_VALUE.  */\n-      if ((mask & ~STORE_FLAG_VALUE) == 0 && XEXP (x, 1) == const0_rtx\n+      if ((mask & ~STORE_FLAG_VALUE) == 0\n+\t  && XEXP (x, 1) == const0_rtx\n \t  && GET_MODE (XEXP (x, 0)) == mode\n \t  && exact_log2 (nonzero_bits (XEXP (x, 0), mode)) >= 0\n \t  && (nonzero_bits (XEXP (x, 0), mode)\n@@ -9014,8 +9017,8 @@ make_field_assignment (rtx x)\n       && INTVAL (XEXP (assign, 1)) < HOST_BITS_PER_WIDE_INT\n       && GET_CODE (src) == AND\n       && CONST_INT_P (XEXP (src, 1))\n-      && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (src, 1))\n-\t  == ((unsigned HOST_WIDE_INT) 1 << INTVAL (XEXP (assign, 1))) - 1))\n+      && UINTVAL (XEXP (src, 1))\n+\t == ((unsigned HOST_WIDE_INT) 1 << INTVAL (XEXP (assign, 1))) - 1)\n     src = XEXP (src, 0);\n \n   return gen_rtx_SET (VOIDmode, assign, src);\n@@ -9417,11 +9420,11 @@ reg_nonzero_bits_for_combine (const_rtx x, enum machine_mode mode,\n       if (GET_MODE_BITSIZE (GET_MODE (x)) < GET_MODE_BITSIZE (mode)\n \t  && CONST_INT_P (tem)\n \t  && INTVAL (tem) > 0\n-\t  && 0 != (INTVAL (tem)\n-\t\t   & ((HOST_WIDE_INT) 1\n+\t  && 0 != (UINTVAL (tem)\n+\t\t   & ((unsigned HOST_WIDE_INT) 1\n \t\t      << (GET_MODE_BITSIZE (GET_MODE (x)) - 1))))\n-\ttem = GEN_INT (INTVAL (tem)\n-\t\t       | ((HOST_WIDE_INT) (-1)\n+\ttem = GEN_INT (UINTVAL (tem)\n+\t\t       | ((unsigned HOST_WIDE_INT) (-1)\n \t\t\t  << GET_MODE_BITSIZE (GET_MODE (x))));\n #endif\n       return tem;\n@@ -9815,8 +9818,8 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n       if (GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_WIDE_INT\n \t  && code == ASHIFTRT\n \t  && ((nonzero_bits (varop, shift_mode)\n-\t       & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (shift_mode) - 1)))\n-\t      == 0))\n+\t       & ((unsigned HOST_WIDE_INT) 1\n+\t\t  << (GET_MODE_BITSIZE (shift_mode) - 1))) == 0))\n \tcode = LSHIFTRT;\n \n       if (((code == LSHIFTRT\n@@ -9889,27 +9892,27 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t     is cheaper.  But it is still better on those machines to\n \t     merge two shifts into one.  */\n \t  if (CONST_INT_P (XEXP (varop, 1))\n-\t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n+\t      && exact_log2 (UINTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n \t\t= simplify_gen_binary (ASHIFT, GET_MODE (varop),\n \t\t\t\t       XEXP (varop, 0),\n \t\t\t\t       GEN_INT (exact_log2 (\n-\t\t\t\t\t\tINTVAL (XEXP (varop, 1)))));\n+\t\t\t\t\t\tUINTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n \n \tcase UDIV:\n \t  /* Similar, for when divides are cheaper.  */\n \t  if (CONST_INT_P (XEXP (varop, 1))\n-\t      && exact_log2 (INTVAL (XEXP (varop, 1))) >= 0)\n+\t      && exact_log2 (UINTVAL (XEXP (varop, 1))) >= 0)\n \t    {\n \t      varop\n \t\t= simplify_gen_binary (LSHIFTRT, GET_MODE (varop),\n \t\t\t\t       XEXP (varop, 0),\n \t\t\t\t       GEN_INT (exact_log2 (\n-\t\t\t\t\t\tINTVAL (XEXP (varop, 1)))));\n+\t\t\t\t\t\tUINTVAL (XEXP (varop, 1)))));\n \t      continue;\n \t    }\n \t  break;\n@@ -9961,8 +9964,8 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t\t{\n \t\t  /* C3 has the low-order C1 bits zero.  */\n \n-\t\t  mask = (GET_MODE_MASK (mode)\n-\t\t\t  & ~(((HOST_WIDE_INT) 1 << first_count) - 1));\n+\t\t  mask = GET_MODE_MASK (mode)\n+\t\t\t & ~(((unsigned HOST_WIDE_INT) 1 << first_count) - 1);\n \n \t\t  varop = simplify_and_const_int (NULL_RTX, result_mode,\n \t\t\t\t\t\t  XEXP (varop, 0), mask);\n@@ -10184,8 +10187,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n \t      && STORE_FLAG_VALUE == -1\n \t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1\n-\t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n-\t\t\t\t  (HOST_WIDE_INT) 1, result_mode,\n+\t      && merge_outer_ops (&outer_op, &outer_const, XOR, 1, result_mode,\n \t\t\t\t  &complement_p))\n \t    {\n \t      varop = XEXP (varop, 0);\n@@ -10209,8 +10211,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t  /* NEG commutes with ASHIFT since it is multiplication.  Move the\n \t     NEG outside to allow shifts to combine.  */\n \t  if (code == ASHIFT\n-\t      && merge_outer_ops (&outer_op, &outer_const, NEG,\n-\t\t\t\t  (HOST_WIDE_INT) 0, result_mode,\n+\t      && merge_outer_ops (&outer_op, &outer_const, NEG, 0, result_mode,\n \t\t\t\t  &complement_p))\n \t    {\n \t      varop = XEXP (varop, 0);\n@@ -10226,8 +10227,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t      && count == (GET_MODE_BITSIZE (result_mode) - 1)\n \t      && XEXP (varop, 1) == constm1_rtx\n \t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1\n-\t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n-\t\t\t\t  (HOST_WIDE_INT) 1, result_mode,\n+\t      && merge_outer_ops (&outer_op, &outer_const, XOR, 1, result_mode,\n \t\t\t\t  &complement_p))\n \t    {\n \t      count = 0;\n@@ -10951,7 +10951,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  else if (const_op == 0\n \t\t   && mode_width <= HOST_BITS_PER_WIDE_INT\n \t\t   && (nonzero_bits (op0, mode)\n-\t\t       & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)\n+\t\t       & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t\t         == 0)\n \t    code = EQ;\n \t  break;\n \n@@ -10981,7 +10982,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  else if (const_op == 0\n \t\t   && mode_width <= HOST_BITS_PER_WIDE_INT\n \t\t   && (nonzero_bits (op0, mode)\n-\t\t       & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)\n+\t\t       & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t\t       == 0)\n \t    code = NE;\n \t  break;\n \n@@ -10996,8 +10998,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    }\n \n \t  /* (unsigned) < 0x80000000 is equivalent to >= 0.  */\n-\t  else if ((mode_width <= HOST_BITS_PER_WIDE_INT)\n-\t\t   && (const_op == (HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t  else if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t\t   && (unsigned HOST_WIDE_INT) const_op\n+\t\t      == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1))\n \t    {\n \t      const_op = 0, op1 = const0_rtx;\n \t      code = GE;\n@@ -11012,8 +11015,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    code = EQ;\n \n \t  /* (unsigned) <= 0x7fffffff is equivalent to >= 0.  */\n-\t  else if ((mode_width <= HOST_BITS_PER_WIDE_INT)\n-\t\t   && (const_op == ((HOST_WIDE_INT) 1 << (mode_width - 1)) - 1))\n+\t  else if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t\t   && (unsigned HOST_WIDE_INT) const_op\n+\t\t      == ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n \t    {\n \t      const_op = 0, op1 = const0_rtx;\n \t      code = GE;\n@@ -11031,8 +11035,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    }\n \n \t  /* (unsigned) >= 0x80000000 is equivalent to < 0.  */\n-\t  else if ((mode_width <= HOST_BITS_PER_WIDE_INT)\n-\t\t   && (const_op == (HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t  else if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t\t   && (unsigned HOST_WIDE_INT) const_op\n+\t\t      == (unsigned HOST_WIDE_INT) 1 << (mode_width - 1))\n \t    {\n \t      const_op = 0, op1 = const0_rtx;\n \t      code = LT;\n@@ -11047,8 +11052,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    code = NE;\n \n \t  /* (unsigned) > 0x7fffffff is equivalent to < 0.  */\n-\t  else if ((mode_width <= HOST_BITS_PER_WIDE_INT)\n-\t\t   && (const_op == ((HOST_WIDE_INT) 1 << (mode_width - 1)) - 1))\n+\t  else if (mode_width <= HOST_BITS_PER_WIDE_INT\n+\t\t   && (unsigned HOST_WIDE_INT) const_op\n+\t\t      == ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)) - 1)\n \t    {\n \t      const_op = 0, op1 = const0_rtx;\n \t      code = LT;\n@@ -11071,8 +11077,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n       if (sign_bit_comparison_p\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \top0 = force_to_mode (op0, mode,\n-\t\t\t     ((HOST_WIDE_INT) 1\n-\t\t\t      << (GET_MODE_BITSIZE (mode) - 1)),\n+\t\t\t     (unsigned HOST_WIDE_INT) 1\n+\t\t\t     << (GET_MODE_BITSIZE (mode) - 1),\n \t\t\t     0);\n \n       /* Now try cases based on the opcode of OP0.  If none of the cases\n@@ -11092,7 +11098,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && CONST_INT_P (XEXP (op0, 0))\n \t      && XEXP (op0, 1) == const1_rtx\n \t      && equality_comparison_p && const_op == 0\n-\t      && (i = exact_log2 (INTVAL (XEXP (op0, 0)))) >= 0)\n+\t      && (i = exact_log2 (UINTVAL (XEXP (op0, 0)))) >= 0)\n \t    {\n \t      if (BITS_BIG_ENDIAN)\n \t\t{\n@@ -11168,7 +11174,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && (GET_CODE (XEXP (op0, 0)) == ABS\n \t\t  || (mode_width <= HOST_BITS_PER_WIDE_INT\n \t\t      && (nonzero_bits (XEXP (op0, 0), mode)\n-\t\t\t  & ((HOST_WIDE_INT) 1 << (mode_width - 1))) == 0)))\n+\t\t\t  & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t\t\t == 0)))\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      code = (code == LT ? NE : EQ);\n@@ -11205,7 +11212,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n-\t\t\t\t\t    ((HOST_WIDE_INT) 1\n+\t\t\t\t\t    ((unsigned HOST_WIDE_INT) 1\n \t\t\t\t\t     << (mode_width - 1\n \t\t\t\t\t\t - INTVAL (XEXP (op0, 1)))));\n \t      code = (code == LT ? NE : EQ);\n@@ -11382,8 +11389,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     of bits in X minus 1, is one iff X > 0.  */\n \t  if (sign_bit_comparison_p && GET_CODE (XEXP (op0, 0)) == ASHIFTRT\n \t      && CONST_INT_P (XEXP (XEXP (op0, 0), 1))\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (op0, 0), 1))\n-\t\t == mode_width - 1\n+\t      && UINTVAL (XEXP (XEXP (op0, 0), 1)) == mode_width - 1\n \t      && rtx_equal_p (XEXP (XEXP (op0, 0), 0), XEXP (op0, 1)))\n \t    {\n \t      op0 = XEXP (op0, 1);\n@@ -11429,7 +11435,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      || (GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n \t\t  && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n \t\t  && (STORE_FLAG_VALUE\n-\t\t      & (((HOST_WIDE_INT) 1\n+\t\t      & (((unsigned HOST_WIDE_INT) 1\n \t\t\t  << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1))))\n \t\t  && (code == LT || code == GE)))\n \t    {\n@@ -11469,11 +11475,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && GET_CODE (XEXP (op0, 0)) == ASHIFT\n \t      && XEXP (XEXP (op0, 0), 0) == const1_rtx)\n \t    {\n-\t      op0 = simplify_and_const_int\n-\t\t(NULL_RTX, mode, gen_rtx_LSHIFTRT (mode,\n-\t\t\t\t\t\t   XEXP (op0, 1),\n-\t\t\t\t\t\t   XEXP (XEXP (op0, 0), 1)),\n-\t\t (HOST_WIDE_INT) 1);\n+\t      op0 = gen_rtx_LSHIFTRT (mode, XEXP (op0, 1),\n+\t\t\t\t      XEXP (XEXP (op0, 0), 1));\n+\t      op0 = simplify_and_const_int (NULL_RTX, mode, op0, 1);\n \t      continue;\n \t    }\n \n@@ -11530,7 +11534,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     transformation is invalid.  */\n \t  if ((equality_comparison_p || unsigned_comparison_p)\n \t      && CONST_INT_P (XEXP (op0, 1))\n-\t      && (i = exact_log2 ((INTVAL (XEXP (op0, 1))\n+\t      && (i = exact_log2 ((UINTVAL (XEXP (op0, 1))\n \t\t\t\t   & GET_MODE_MASK (mode))\n \t\t\t\t  + 1)) >= 0\n \t      && const_op >> i == 0\n@@ -11590,8 +11594,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && XEXP (op0, 1) == const1_rtx\n \t      && GET_CODE (XEXP (op0, 0)) == NOT)\n \t    {\n-\t      op0 = simplify_and_const_int\n-\t\t(NULL_RTX, mode, XEXP (XEXP (op0, 0), 0), (HOST_WIDE_INT) 1);\n+\t      op0 = simplify_and_const_int (NULL_RTX, mode,\n+\t\t\t\t\t    XEXP (XEXP (op0, 0), 0), 1);\n \t      code = (code == NE ? EQ : NE);\n \t      continue;\n \t    }\n@@ -11611,13 +11615,13 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t      && CONST_INT_P (XEXP (shift_op, 1))\n \t\t      && CONST_INT_P (shift_count)\n \t\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t\t      && (INTVAL (XEXP (shift_op, 1))\n-\t\t\t  == (HOST_WIDE_INT) 1 << INTVAL (shift_count))))\n+\t\t      && (UINTVAL (XEXP (shift_op, 1))\n+\t\t\t  == (unsigned HOST_WIDE_INT) 1\n+\t\t\t       << INTVAL (shift_count))))\n \t\t{\n-\t\t  op0 = simplify_and_const_int\n-\t\t    (NULL_RTX, mode,\n-\t\t     gen_rtx_LSHIFTRT (mode, XEXP (shift_op, 0), shift_count),\n-\t\t     (HOST_WIDE_INT) 1);\n+\t\t  op0\n+\t\t    = gen_rtx_LSHIFTRT (mode, XEXP (shift_op, 0), shift_count);\n+\t\t  op0 = simplify_and_const_int (NULL_RTX, mode, op0, 1);\n \t\t  code = (code == NE ? EQ : NE);\n \t\t  continue;\n \t\t}\n@@ -11634,8 +11638,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && INTVAL (XEXP (op0, 1)) >= 0\n \t      && ((INTVAL (XEXP (op0, 1)) + ! equality_comparison_p)\n \t\t  < HOST_BITS_PER_WIDE_INT)\n-\t      && ((const_op\n-\t\t   & (((HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1))) - 1)) == 0)\n+\t      && (((unsigned HOST_WIDE_INT) const_op\n+\t\t   & (((unsigned HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1)))\n+\t\t      - 1)) == 0)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && (nonzero_bits (XEXP (op0, 0), mode)\n \t\t  & ~(mask >> (INTVAL (XEXP (op0, 1))\n@@ -11657,7 +11662,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n-\t\t\t\t\t    ((HOST_WIDE_INT) 1\n+\t\t\t\t\t    ((unsigned HOST_WIDE_INT) 1\n \t\t\t\t\t     << (mode_width - 1\n \t\t\t\t\t\t - INTVAL (XEXP (op0, 1)))));\n \t      code = (code == LT ? NE : EQ);\n@@ -11669,11 +11674,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t     low-order bit.  */\n \t  if (const_op == 0 && equality_comparison_p\n \t      && CONST_INT_P (XEXP (op0, 1))\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1))\n-\t\t == mode_width - 1)\n+\t      && UINTVAL (XEXP (op0, 1)) == mode_width - 1)\n \t    {\n-\t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0),\n-\t\t\t\t\t    (HOST_WIDE_INT) 1);\n+\t      op0 = simplify_and_const_int (NULL_RTX, mode, XEXP (op0, 0), 1);\n \t      continue;\n \t    }\n \t  break;\n@@ -11780,8 +11783,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  if (const_op == 0\n \t      && (equality_comparison_p || sign_bit_comparison_p)\n \t      && CONST_INT_P (XEXP (op0, 1))\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1))\n-\t\t == mode_width - 1)\n+\t      && UINTVAL (XEXP (op0, 1)) == mode_width - 1)\n \t    {\n \t      op0 = XEXP (op0, 0);\n \t      code = (code == NE || code == GT ? LT : GE);\n@@ -11878,7 +11880,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    {\n \t      op0 = simplify_gen_binary (AND, tmode,\n \t\t\t\t\t gen_lowpart (tmode, op0),\n-\t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t GEN_INT ((unsigned HOST_WIDE_INT) 1\n \t\t\t\t\t\t  << (GET_MODE_BITSIZE (mode)\n \t\t\t\t\t\t      - 1)));\n \t      code = (code == LT) ? NE : EQ;"}]}