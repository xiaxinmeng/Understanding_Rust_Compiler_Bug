{"sha": "c8ef728f432bcc51464d574189ef68f515ea3ef7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhlZjcyOGY0MzJiY2M1MTQ2NGQ1NzQxODllZjY4ZjUxNWVhM2VmNw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-02-15T09:38:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:38:39Z"}, "message": "re PR ada/25885 (Tree checking failure on ASIS)\n\n2006-02-13  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch6.adb (Expand_Inlined_Call): Handle calls to functions that\n\treturn unconstrained arrays.\n\tUpdate comments.\n\t(Expand_Call):  An indirect call through an access parameter of a\n\tprotected operation is not a protected call.\n\tAdd circuit to raise CE in Ada 2005 mode following call\n\tto Raise_Exception.\n\t(Register_DT_Entry): Do nothing if\n\tthe run-time does not give support to abstract interfaces.\n\t(Freeze_Subprogram): In case of dispatching operations, do not generate\n\tcode to register the operation in the dispatch table if the source\n\tis compiled with No_Dispatching_Calls.\n\t(Register_Predefined_DT_Entry): Generate code that calls the new\n\trun-time subprogram Set_Predefined_Prim_Op_Address instead of\n\tSet_Prim_Op_Address.\n\n\t* sem_ch5.adb (Analyze_Assignment_Statement): Do not apply length checks\n\ton array assignments if the right-hand side is a function call that has\n\tbeen inlined. Check is performed on the assignment in the block.\n\t(Process_Bounds): If bounds and range are overloaded, apply preference\n\trule for root operations to disambiguate, and diagnose true ambiguity.\n\t(Analyze_Assignment): Propagate the tag for a class-wide assignment with\n\ta tag-indeterminate right-hand side even when Expander_Active is True.\n\tNeeded to ensure that dispatching calls to T'Input are allowed and\n\tget the tag of the target class-wide object.\n\n\t* sem_ch6.adb (New_Overloaded_Entity): Handle entities that override\n\tan inherited primitive operation that already overrides several\n\tabstract interface primitives. For transitivity, the new entity must\n\talso override all the abstract interface primitives covered by the\n\tinherited overriden primitive.\n\tEmit warning if new entity differs from homograph in same scope only in\n\tthat one has an access parameter and the other one has a parameter of\n\ta general access type with the same designated type, at the same\n\tposition in the signature.\n\t(Make_Inequality_Operator): Use source locations of parameters and\n\tsubtype marks from corresponding equality operator when creating the\n\ttree structure for the implicit declaration of \"/=\". This does not\n\tchange anything in behaviour except that the decoration of the\n\tcomponents of the subtree created for \"/=\" allows ASIS to get the\n\tstring images of the corresponding identifiers.\n\t(Analyze_Return_Statement): Remove '!' in warning message.\n\t(Check_Statement_Sequence): Likewise.\n\t(Analyze_Subprogram_Body): For an access parameter whose designated type\n\tis an incomplete type imported through a limited_with clause, use the\n\ttype of the corresponding formal in the body.\n\t(Check_Returns): Implicit return in No_Return procedure now raises\n\tProgram_Error with a compile time warning, instead of beging illegal.\n\t(Has_Single_Return):  Function returning unconstrained type cannot be\n\tinlined if expression in unique return statement is not an identifier.\n\t(Build_Body_To_Inline): It is possible to inline a function call that\n\treturns an unconstrained type if all return statements in the function\n\treturn the same local variable. Subsidiary procedure Has_Single_Return\n\tverifies that the body conforms to this restriction.\n\n\t* sem_res.adb (Resolve_Equality_Op): If the operands do not have the\n\tsame type, and  one of them is of an anonymous access type, convert\n\tthe other operand to it, so that this is a valid binary operation for\n\tgigi.\n\t(Resolve_Type_Conversion): Handle subtypes of protected types and\n\ttask types when accessing to the corresponding record type.\n\t(Resolve_Allocator): Add '\\' in 2-line warning message.\n\tRemove '!' in warning message.\n\t(Resolve_Call): Add '\\' in 2-line warning message.\n\t(Valid_Conversion): Likewise.\n\t(Resolve_Overloaded_Selected_Component): If disambiguation succeeds, the\n\tresulting type may be an access type with an implicit dereference.\n\tObtain the proper component from the designated type.\n\t(Make_Call_Into_Operator): Handle properly a call to predefined equality\n\tgiven by an expanded name with prefix Standard, when the operands are\n\tof an anonymous access type.\n\t(Check_Fully_Declared_Prefix): New procedure, subsidiary of Resolve_\n\tExplicit_Dereference and Resolve_Selected_Component, to verify that the\n\tprefix of the expression is not of an incomplete type. Allows full\n\tdiagnoses of all semantic errors.\n\t(Resolve_Actuals): If the actual is an allocator whose directly\n\tdesignated type is a class-wide interface we build an anonymous\n\taccess type to use it as the type of the allocator. Later, when\n\tthe subprogram call is expanded, if the interface has a secondary\n\tdispatch table the expander will add a type conversion to force\n\tthe displacement of the pointer.\n\t(Resolve_Call): If a function that returns an unconstrained type is\n\tmarked Inlined_Always and inlined, the call will be inlined and does\n\tnot require the creation of a transient scope.\n\t(Check_Direct_Boolean_Op): Removed\n\t(Resolve_Comparison_Op): Remove call to above\n\t(Resolve_Equality_Op): Remove call to above\n\t(Resolve_Logical_Op): Inline above, since this is only call.\n\t(Valid_Conversion): Handle properly conversions between arrays of\n\tconvertible anonymous access types.\n\n\tPR ada/25885\n\n\t(Set_Literal_String_Subtype): If the lower bound is not static, wrap\n\tthe literal in an unchecked conversion, because GCC 4.x needs a static\n\tvalue for a string bound.\n\nFrom-SVN: r111062", "tree": {"sha": "86b131e587cad55fa1f0ddb0bfb764a92d7a4288", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86b131e587cad55fa1f0ddb0bfb764a92d7a4288"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8ef728f432bcc51464d574189ef68f515ea3ef7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8ef728f432bcc51464d574189ef68f515ea3ef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8ef728f432bcc51464d574189ef68f515ea3ef7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8ef728f432bcc51464d574189ef68f515ea3ef7/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ec9c97a3597abdbf370dd4ebb5806fd64369370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec9c97a3597abdbf370dd4ebb5806fd64369370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ec9c97a3597abdbf370dd4ebb5806fd64369370"}], "stats": {"total": 1251, "additions": 950, "deletions": 301}, "files": [{"sha": "c42b1f3c6cf0b85e3791f9de0ccec3aa24ea641e", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 209, "deletions": 42, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ef728f432bcc51464d574189ef68f515ea3ef7/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ef728f432bcc51464d574189ef68f515ea3ef7/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=c8ef728f432bcc51464d574189ef68f515ea3ef7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -698,6 +698,11 @@ package body Exp_Ch6 is\n          --  Processing for OUT or IN OUT parameter\n \n          else\n+            --  Kill current value indications for the temporary variable we\n+            --  created, since we just passed it as an OUT parameter.\n+\n+            Kill_Current_Values (Temp);\n+\n             --  If type conversion, use reverse conversion on exit\n \n             if Nkind (Actual) = N_Type_Conversion then\n@@ -1265,7 +1270,7 @@ package body Exp_Ch6 is\n             Set_First_Named_Actual (N, Actual_Expr);\n \n             if No (Prev) then\n-               if not Present (Parameter_Associations (N)) then\n+               if No (Parameter_Associations (N)) then\n                   Set_Parameter_Associations (N, New_List);\n                   Append (Insert_Param, Parameter_Associations (N));\n                end if;\n@@ -1830,11 +1835,10 @@ package body Exp_Ch6 is\n             Check_Valid_Lvalue_Subscripts (Actual);\n          end if;\n \n-         --  Mark any scalar OUT parameter that is a simple variable\n-         --  as no longer known to be valid (unless the type is always\n-         --  valid). This reflects the fact that if an OUT parameter\n-         --  is never set in a procedure, then it can become invalid\n-         --  on return from the procedure.\n+         --  Mark any scalar OUT parameter that is a simple variable as no\n+         --  longer known to be valid (unless the type is always valid). This\n+         --  reflects the fact that if an OUT parameter is never set in a\n+         --  procedure, then it can become invalid on the procedure return.\n \n          if Ekind (Formal) = E_Out_Parameter\n            and then Is_Entity_Name (Actual)\n@@ -1844,14 +1848,15 @@ package body Exp_Ch6 is\n             Set_Is_Known_Valid (Entity (Actual), False);\n          end if;\n \n-         --  For an OUT or IN OUT parameter of an access type, if the\n-         --  actual is an entity, then it is no longer known to be non-null.\n+         --  For an OUT or IN OUT parameter, if the actual is an entity, then\n+         --  clear current values, since they can be clobbered. We are probably\n+         --  doing this in more places than we need to, but better safe than\n+         --  sorry when it comes to retaining bad current values!\n \n          if Ekind (Formal) /= E_In_Parameter\n            and then Is_Entity_Name (Actual)\n-           and then Is_Access_Type (Etype (Actual))\n          then\n-            Set_Is_Known_Non_Null (Entity (Actual), False);\n+            Kill_Current_Values (Entity (Actual));\n          end if;\n \n          --  If the formal is class wide and the actual is an aggregate, force\n@@ -1894,11 +1899,11 @@ package body Exp_Ch6 is\n          Next_Formal (Formal);\n       end loop;\n \n-      --  If we are expanding a rhs of an assignement we need to check if\n-      --  tag propagation is needed. This code belongs theorically in Analyze\n-      --  Assignment but has to be done earlier (bottom-up) because the\n-      --  assignment might be transformed into a declaration for an uncons-\n-      --  trained value, if the expression is classwide.\n+      --  If we are expanding a rhs of an assignment we need to check if tag\n+      --  propagation is needed. You might expect this processing to be in\n+      --  Analyze_Assignment but has to be done earlier (bottom-up) because the\n+      --  assignment might be transformed to a declaration for an unconstrained\n+      --  value if the expression is classwide.\n \n       if Nkind (N) = N_Function_Call\n         and then Is_Tag_Indeterminate (N)\n@@ -2016,6 +2021,8 @@ package body Exp_Ch6 is\n             end loop;\n          end if;\n \n+         --  The below setting of Entity is suspect, see F109-018 discussion???\n+\n          Set_Entity (Name (N), Parent_Subp);\n \n          if Is_Abstract (Parent_Subp)\n@@ -2337,10 +2344,16 @@ package body Exp_Ch6 is\n       --  call, or a protected function call. Protected procedure calls are\n       --  rewritten as entry calls and handled accordingly.\n \n+      --  In Ada 2005, this may be an indirect call to an access parameter\n+      --  that is an access_to_subprogram. In that case the anonymous type\n+      --  has a scope that is a protected operation, but the call is a\n+      --  regular one.\n+\n       Scop := Scope (Subp);\n \n       if Nkind (N) /= N_Entry_Call_Statement\n         and then Is_Protected_Type (Scop)\n+        and then Ekind (Subp) /= E_Subprogram_Type\n       then\n          --  If the call is an internal one, it is rewritten as a call to\n          --  to the corresponding unprotected subprogram.\n@@ -2498,6 +2511,28 @@ package body Exp_Ch6 is\n             end if;\n          end;\n       end if;\n+\n+      --  Special processing for Ada 2005 AI-329, which requires a call to\n+      --  Raise_Exception to raise Constraint_Error if the Exception_Id is\n+      --  null. Note that we never need to do this in GNAT mode, or if the\n+      --  parameter to Raise_Exception is a use of Identity, since in these\n+      --  cases we know that the parameter is never null.\n+\n+      if Ada_Version >= Ada_05\n+        and then not GNAT_Mode\n+        and then Is_RTE (Subp, RE_Raise_Exception)\n+        and then (Nkind (First_Actual (N)) /= N_Attribute_Reference\n+                   or else Attribute_Name (First_Actual (N)) /= Name_Identity)\n+      then\n+         declare\n+            RCE : constant Node_Id :=\n+                    Make_Raise_Constraint_Error (Loc,\n+                      Reason => CE_Null_Exception_Id);\n+         begin\n+            Insert_After (N, RCE);\n+            Analyze (RCE);\n+         end;\n+      end if;\n    end Expand_Call;\n \n    --------------------------\n@@ -2519,6 +2554,7 @@ package body Exp_Ch6 is\n       Blk      : Node_Id;\n       Bod      : Node_Id;\n       Decl     : Node_Id;\n+      Decls    : constant List_Id := New_List;\n       Exit_Lab : Entity_Id := Empty;\n       F        : Entity_Id;\n       A        : Node_Id;\n@@ -2528,9 +2564,23 @@ package body Exp_Ch6 is\n       Num_Ret  : Int := 0;\n       Ret_Type : Entity_Id;\n       Targ     : Node_Id;\n+      Targ1    : Node_Id;\n       Temp     : Entity_Id;\n       Temp_Typ : Entity_Id;\n \n+      Is_Unc : constant Boolean :=\n+                    Is_Array_Type (Etype (Subp))\n+                      and then not Is_Constrained (Etype (Subp));\n+      --  If the type returned by the function is unconstrained and the\n+      --  call can be inlined, special processing is required.\n+\n+      procedure Find_Result;\n+      --  For a function that returns an unconstrained type, retrieve the\n+      --  name of the single variable that is the expression of a return\n+      --  statement in the body of the function. Build_Body_To_Inline has\n+      --  verified that this variable is unique, even in the presence of\n+      --  multiple return statements.\n+\n       procedure Make_Exit_Label;\n       --  Build declaration for exit label to be used in Return statements\n \n@@ -2557,6 +2607,50 @@ package body Exp_Ch6 is\n       function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean;\n       --  Determine whether a formal parameter is used only once in Orig_Bod\n \n+      -----------------\n+      -- Find_Result --\n+      -----------------\n+\n+      procedure Find_Result is\n+         Decl : Node_Id;\n+         Id   : Node_Id;\n+\n+         function Get_Return (N : Node_Id) return Traverse_Result;\n+         --  Recursive function to locate return statements in body.\n+\n+         function Get_Return (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Return_Statement then\n+               Id := Expression (N);\n+               return Abandon;\n+            else\n+               return OK;\n+            end if;\n+         end Get_Return;\n+\n+         procedure Find_It is new Traverse_Proc (Get_Return);\n+\n+      --  Start of processing for Find_Result\n+\n+      begin\n+         Find_It (Handled_Statement_Sequence (Orig_Bod));\n+\n+         --  At this point the body is unanalyzed. Traverse the list of\n+         --  declarations to locate the defining_identifier for it.\n+\n+         Decl := First (Declarations (Blk));\n+\n+         while Present (Decl) loop\n+            if Chars (Defining_Identifier (Decl)) = Chars (Id) then\n+               Targ1 := Defining_Identifier (Decl);\n+               exit;\n+\n+            else\n+               Next (Decl);\n+            end if;\n+         end loop;\n+      end Find_Result;\n+\n       ---------------------\n       -- Make_Exit_Label --\n       ---------------------\n@@ -2746,7 +2840,11 @@ package body Exp_Ch6 is\n             Insert_After (Parent (Entity (N)), Blk);\n \n          elsif Nkind (Parent (N)) = N_Assignment_Statement\n-           and then Is_Entity_Name (Name (Parent (N)))\n+           and then\n+            (Is_Entity_Name (Name (Parent (N)))\n+               or else\n+                  (Nkind (Name (Parent (N))) = N_Explicit_Dereference\n+                    and then Is_Entity_Name (Prefix (Name (Parent (N))))))\n          then\n             --  Replace assignment with the block\n \n@@ -2770,6 +2868,9 @@ package body Exp_Ch6 is\n          elsif Nkind (Parent (N)) = N_Object_Declaration then\n             Set_Expression (Parent (N), Empty);\n             Insert_After (Parent (N), Blk);\n+\n+         elsif Is_Unc then\n+            Insert_Before (Parent (N), Blk);\n          end if;\n       end Rewrite_Function_Call;\n \n@@ -2907,6 +3008,13 @@ package body Exp_Ch6 is\n          Set_Declarations (Blk, New_List);\n       end if;\n \n+      --  For the unconstrained case, capture the name of the local\n+      --  variable that holds the result.\n+\n+      if Is_Unc then\n+         Find_Result;\n+      end if;\n+\n       --  If this is a derived function, establish the proper return type\n \n       if Present (Orig_Subp)\n@@ -3022,7 +3130,7 @@ package body Exp_Ch6 is\n                    Name                => New_A);\n             end if;\n \n-            Prepend (Decl, Declarations (Blk));\n+            Append (Decl, Decls);\n             Set_Renamed_Object (F, Temp);\n          end if;\n \n@@ -3034,34 +3142,60 @@ package body Exp_Ch6 is\n       --  declaration, create a temporary as a target. The declaration for\n       --  the temporary may be subsequently optimized away if the body is a\n       --  single expression, or if the left-hand side of the assignment is\n-      --  simple enough.\n+      --  simple enough, i.e. an entity or an explicit dereference of one.\n \n       if Ekind (Subp) = E_Function then\n          if Nkind (Parent (N)) = N_Assignment_Statement\n            and then Is_Entity_Name (Name (Parent (N)))\n          then\n             Targ := Name (Parent (N));\n \n+         elsif Nkind (Parent (N)) = N_Assignment_Statement\n+           and then Nkind (Name (Parent (N))) = N_Explicit_Dereference\n+           and then Is_Entity_Name (Prefix (Name (Parent (N))))\n+         then\n+            Targ := Name (Parent (N));\n+\n          else\n             --  Replace call with temporary and create its declaration\n \n             Temp :=\n               Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n             Set_Is_Internal (Temp);\n \n-            Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp,\n-                Object_Definition =>\n-                  New_Occurrence_Of (Ret_Type, Loc));\n+            --  For the unconstrained case. the generated temporary has the\n+            --  same constrained declaration as the result variable.\n+            --  It may eventually be possible to remove that temporary and\n+            --  use the result variable directly.\n+\n+            if Is_Unc then\n+               Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Object_Definition =>\n+                     New_Copy_Tree (Object_Definition (Parent (Targ1))));\n+\n+               Replace_Formals (Decl);\n+\n+            else\n+               Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Object_Definition =>\n+                     New_Occurrence_Of (Ret_Type, Loc));\n+\n+               Set_Etype (Temp, Ret_Type);\n+            end if;\n \n             Set_No_Initialization (Decl);\n-            Insert_Action (N, Decl);\n+            Append (Decl, Decls);\n             Rewrite (N, New_Occurrence_Of (Temp, Loc));\n             Targ := Temp;\n          end if;\n       end if;\n \n+      Insert_Actions (N, Decls);\n+\n       --  Traverse the tree and replace formals with actuals or their thunks.\n       --  Attach block to tree before analysis and rewriting.\n \n@@ -3122,6 +3256,18 @@ package body Exp_Ch6 is\n          Rewrite_Procedure_Call (N, Blk);\n       else\n          Rewrite_Function_Call (N, Blk);\n+\n+         --  For the unconstrained case, the replacement of the call has been\n+         --  made prior to the complete analysis of the generated declarations.\n+         --  Propagate the proper type now.\n+\n+         if Is_Unc then\n+            if Nkind (N) = N_Identifier then\n+               Set_Etype (N, Etype (Entity (N)));\n+            else\n+               Set_Etype (N, Etype (Targ1));\n+            end if;\n+         end if;\n       end if;\n \n       Restore_Env;\n@@ -3280,8 +3426,8 @@ package body Exp_Ch6 is\n \n                      Proc := Entity (Name (Parent (N)));\n \n-                     F    := First_Formal (Proc);\n-                     A    := First_Actual (Parent (N));\n+                     F := First_Formal (Proc);\n+                     A := First_Actual (Parent (N));\n                      while A /= N loop\n                         Next_Formal (F);\n                         Next_Actual (A);\n@@ -4133,8 +4279,7 @@ package body Exp_Ch6 is\n       --  (Ada 2005): Register an interface primitive in a secondary dispatch\n       --  table. If Prim overrides an ancestor primitive of its associated\n       --  tagged-type then Ancestor_Iface_Prim indicates the entity of that\n-      --  immediate ancestor associated with the interface; otherwise Prim and\n-      --  Ancestor_Iface_Prim have the same info.\n+      --  immediate ancestor associated with the interface.\n \n       procedure Register_Predefined_DT_Entry (Prim : Entity_Id);\n       --  (Ada 2005): Register a predefined primitive in all the secondary\n@@ -4192,7 +4337,7 @@ package body Exp_Ch6 is\n                                 Skip_Controlling_Formals => True)\n                     and then DT_Position (Prim_Op) = DT_Position (E)\n                     and then Etype (DTC_Entity (Prim_Op)) = RTE (RE_Tag)\n-                    and then not Present (Abstract_Interface_Alias (Prim_Op))\n+                    and then No (Abstract_Interface_Alias (Prim_Op))\n                   then\n                      if Overriden_Op = Empty then\n                         Overriden_Op := Prim_Op;\n@@ -4268,7 +4413,14 @@ package body Exp_Ch6 is\n          Thunk_Id     : Entity_Id;\n \n       begin\n-         if not Present (Ancestor_Iface_Prim) then\n+         --  Nothing to do if the run-time does not give support to abstract\n+         --  interfaces.\n+\n+         if not (RTE_Available (RE_Interface_Tag)) then\n+            return;\n+         end if;\n+\n+         if No (Ancestor_Iface_Prim) then\n             Prim_Typ  := Scope (DTC_Entity (Alias (Prim)));\n             Iface_Typ := Scope (DTC_Entity (Abstract_Interface_Alias (Prim)));\n \n@@ -4373,8 +4525,9 @@ package body Exp_Ch6 is\n       begin\n          Prim_Typ := Scope (DTC_Entity (Prim));\n \n-         if not Present (Access_Disp_Table (Prim_Typ))\n-           or else not Present (Abstract_Interfaces (Prim_Typ))\n+         if No (Access_Disp_Table (Prim_Typ))\n+           or else No (Abstract_Interfaces (Prim_Typ))\n+           or else not RTE_Available (RE_Interface_Tag)\n          then\n             return;\n          end if;\n@@ -4404,7 +4557,7 @@ package body Exp_Ch6 is\n                Insert_After (N, New_Thunk);\n                Insert_After (New_Thunk,\n                  Make_DT_Access_Action (Node (Iface_Typ),\n-                   Action => Set_Prim_Op_Address,\n+                   Action => Set_Predefined_Prim_Op_Address,\n                    Args   => New_List (\n                      Unchecked_Convert_To (RTE (RE_Tag),\n                        New_Reference_To (Node (Iface_DT_Ptr), Loc)),\n@@ -4438,18 +4591,29 @@ package body Exp_Ch6 is\n       then\n          Check_Overriding_Operation (E);\n \n+         --  Ada 95 case: Register the subprogram in the primary dispatch table\n+\n          if Ada_Version < Ada_05 then\n-            Insert_After (N,\n-              Fill_DT_Entry (Sloc (N), Prim => E));\n+\n+            --  Do not register the subprogram in the dispatch table if we\n+            --  are compiling with the No_Dispatching_Calls restriction.\n+\n+            if not Restriction_Active (No_Dispatching_Calls) then\n+               Insert_After (N,\n+                 Fill_DT_Entry (Sloc (N), Prim => E));\n+            end if;\n+\n+         --  Ada 2005 case: Register the subprogram in the secondary dispatch\n+         --  tables associated with abstract interfaces.\n \n          else\n             declare\n                Typ : constant Entity_Id := Scope (DTC_Entity (E));\n \n             begin\n                --  There is no dispatch table associated with abstract\n-               --  interface types; each type implementing interfaces\n-               --  will fill the associated secondary DT entries.\n+               --  interface types. Each type implementing interfaces will\n+               --  fill the associated secondary DT entries.\n \n                if not Is_Interface (Typ)\n                  or else Present (Alias (E))\n@@ -4465,12 +4629,15 @@ package body Exp_Ch6 is\n                   else\n                      --  Generate thunks for all the predefined operations\n \n-                     if Is_Predefined_Dispatching_Operation (E) then\n-                        Register_Predefined_DT_Entry (E);\n+                     if not Restriction_Active (No_Dispatching_Calls) then\n+                        if Is_Predefined_Dispatching_Operation (E) then\n+                           Register_Predefined_DT_Entry (E);\n+                        end if;\n+\n+                        Insert_After (N,\n+                          Fill_DT_Entry (Sloc (N), Prim => E));\n                      end if;\n \n-                     Insert_After (N,\n-                       Fill_DT_Entry (Sloc (N), Prim => E));\n                      Check_Overriding_Inherited_Interfaces (E);\n                   end if;\n                end if;"}, {"sha": "241b838eb7ea5e2ecae7f93ab542bed93baecc5c", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 146, "deletions": 29, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ef728f432bcc51464d574189ef68f515ea3ef7/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ef728f432bcc51464d574189ef68f515ea3ef7/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c8ef728f432bcc51464d574189ef68f515ea3ef7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,12 +81,17 @@ package body Sem_Ch5 is\n       T1   : Entity_Id;\n       T2   : Entity_Id;\n       Decl : Node_Id;\n-      Ent  : Entity_Id;\n \n       procedure Diagnose_Non_Variable_Lhs (N : Node_Id);\n       --  N is the node for the left hand side of an assignment, and it\n       --  is not a variable. This routine issues an appropriate diagnostic.\n \n+      procedure Kill_Lhs;\n+      --  This is called to kill current value settings of a simple variable\n+      --  on the left hand side. We call it if we find any error in analyzing\n+      --  the assignment, and at the end of processing before setting any new\n+      --  current values in place.\n+\n       procedure Set_Assignment_Type\n         (Opnd      : Node_Id;\n          Opnd_Type : in out Entity_Id);\n@@ -159,6 +164,23 @@ package body Sem_Ch5 is\n          end if;\n       end Diagnose_Non_Variable_Lhs;\n \n+      --------------\n+      -- Kill_LHS --\n+      --------------\n+\n+      procedure Kill_Lhs is\n+      begin\n+         if Is_Entity_Name (Lhs) then\n+            declare\n+               Ent : constant Entity_Id := Entity (Lhs);\n+            begin\n+               if Present (Ent) then\n+                  Kill_Current_Values (Ent);\n+               end if;\n+            end;\n+         end if;\n+      end Kill_Lhs;\n+\n       -------------------------\n       -- Set_Assignment_Type --\n       -------------------------\n@@ -225,6 +247,9 @@ package body Sem_Ch5 is\n    begin\n       Analyze (Rhs);\n       Analyze (Lhs);\n+\n+      --  Start type analysis for assignment\n+\n       T1 := Etype (Lhs);\n \n       --  In the most general case, both Lhs and Rhs can be overloaded, and we\n@@ -305,6 +330,7 @@ package body Sem_Ch5 is\n          if T1 = Any_Type then\n             Error_Msg_N\n               (\"no valid types for left-hand side for assignment\", Lhs);\n+            Kill_Lhs;\n             return;\n          end if;\n       end if;\n@@ -350,6 +376,7 @@ package body Sem_Ch5 is\n         and then Ekind (T1) = E_Incomplete_Type\n       then\n          Error_Msg_N (\"invalid use of incomplete type\", Lhs);\n+         Kill_Lhs;\n          return;\n       end if;\n \n@@ -361,13 +388,15 @@ package body Sem_Ch5 is\n       --  Remaining steps are skipped if Rhs was syntactically in error\n \n       if Rhs = Error then\n+         Kill_Lhs;\n          return;\n       end if;\n \n       T2 := Etype (Rhs);\n \n       if not Covers (T1, T2) then\n          Wrong_Type (Rhs, Etype (Lhs));\n+         Kill_Lhs;\n          return;\n       end if;\n \n@@ -395,6 +424,7 @@ package body Sem_Ch5 is\n       end if;\n \n       if T1 = Any_Type or else T2 = Any_Type then\n+         Kill_Lhs;\n          return;\n       end if;\n \n@@ -411,13 +441,10 @@ package body Sem_Ch5 is\n          Error_Msg_N (\"dynamically tagged expression required!\", Rhs);\n       end if;\n \n-      --  Tag propagation is done only in semantics mode only. If expansion\n-      --  is on, the rhs tag indeterminate function call has been expanded\n-      --  and tag propagation would have happened too late, so the\n-      --  propagation take place in expand_call instead.\n+      --  Propagate the tag from a class-wide target to the rhs when the rhs\n+      --  is a tag-indeterminate call.\n \n-      if not Expander_Active\n-        and then Is_Class_Wide_Type (T1)\n+      if Is_Class_Wide_Type (T1)\n         and then Is_Tag_Indeterminate (Rhs)\n       then\n          Propagate_Tag (Lhs, Rhs);\n@@ -457,10 +484,18 @@ package body Sem_Ch5 is\n       if Is_Scalar_Type (T1) then\n          Apply_Scalar_Range_Check (Rhs, Etype (Lhs));\n \n+      --  For array types, verify that lengths match. If the right hand side\n+      --  if a function call that has been inlined, the assignment has been\n+      --  rewritten as a block, and the constraint check will be applied to the\n+      --  assignment within the block.\n+\n       elsif Is_Array_Type (T1)\n         and then\n           (Nkind (Rhs) /= N_Type_Conversion\n-             or else Is_Constrained (Etype (Rhs)))\n+            or else Is_Constrained (Etype (Rhs)))\n+        and then\n+          (Nkind (Rhs) /= N_Function_Call\n+            or else Nkind (N) /= N_Block_Statement)\n       then\n          --  Assignment verifies that the length of the Lsh and Rhs are equal,\n          --  but of course the indices do not have to match. If the right-hand\n@@ -520,33 +555,59 @@ package body Sem_Ch5 is\n          Error_Msg_CRT (\"composite assignment\", N);\n       end if;\n \n-      --  One more step. Let's see if we have a simple assignment of a\n-      --  known at compile time value to a simple variable. If so, we\n-      --  can record the value as the current value providing that:\n+      --  Final step. If left side is an entity, then we may be able to\n+      --  reset the current tracked values to new safe values. We only have\n+      --  something to do if the left side is an entity name, and expansion\n+      --  has not modified the node into something other than an assignment,\n+      --  and of course we only capture values if it is safe to do so.\n \n-      --    We still have a simple assignment statement (no expansion\n-      --    activity has modified it in some peculiar manner)\n+      if Is_Entity_Name (Lhs)\n+        and then Nkind (N) = N_Assignment_Statement\n+      then\n+         declare\n+            Ent : constant Entity_Id := Entity (Lhs);\n \n-      --    The type is a discrete type\n+         begin\n+            if Safe_To_Capture_Value (N, Ent) then\n \n-      --    The assignment is to a named entity\n+               --  If we are assigning an access type and the left side is an\n+               --  entity, then make sure that the Is_Known_[Non_]Null flags\n+               --  properly reflect the state of the entity after assignment.\n \n-      --    The value is known at compile time\n+               if Is_Access_Type (T1) then\n+                  if Known_Non_Null (Rhs) then\n+                     Set_Is_Known_Non_Null (Ent, True);\n \n-      if Nkind (N) /= N_Assignment_Statement\n-        or else not Is_Discrete_Type (T1)\n-        or else not Is_Entity_Name (Lhs)\n-        or else not Compile_Time_Known_Value (Rhs)\n-      then\n-         return;\n-      end if;\n+                  elsif Known_Null (Rhs)\n+                    and then not Can_Never_Be_Null (Ent)\n+                  then\n+                     Set_Is_Known_Null (Ent, True);\n+\n+                  else\n+                     Set_Is_Known_Null (Ent, False);\n \n-      Ent := Entity (Lhs);\n+                     if not Can_Never_Be_Null (Ent) then\n+                        Set_Is_Known_Non_Null (Ent, False);\n+                     end if;\n+                  end if;\n \n-      --  Capture value if safe to do so\n+               --  For discrete types, we may be able to set the current value\n+               --  if the value is known at compile time.\n \n-      if Safe_To_Capture_Value (N, Ent) then\n-         Set_Current_Value (Ent, Rhs);\n+               elsif Is_Discrete_Type (T1)\n+                 and then Compile_Time_Known_Value (Rhs)\n+               then\n+                  Set_Current_Value (Ent, Rhs);\n+               else\n+                  Set_Current_Value (Ent, Empty);\n+               end if;\n+\n+            --  If not safe to capture values, kill them\n+\n+            else\n+               Kill_Lhs;\n+            end if;\n+         end;\n       end if;\n    end Analyze_Assignment;\n \n@@ -1193,6 +1254,7 @@ package body Sem_Ch5 is\n          New_Lo_Bound : Node_Id := Empty;\n          New_Hi_Bound : Node_Id := Empty;\n          Typ          : Entity_Id;\n+         Save_Analysis : Boolean;\n \n          function One_Bound\n            (Original_Bound : Node_Id;\n@@ -1268,9 +1330,64 @@ package body Sem_Ch5 is\n \n       begin\n          --  Determine expected type of range by analyzing separate copy\n+         --  Do the analysis and resolution of the copy of the bounds with\n+         --  expansion disabled, to prevent the generation of finalization\n+         --  actions on each bound. This prevents memory leaks when the\n+         --  bounds contain calls to functions returning controlled arrays.\n \n          Set_Parent (R_Copy, Parent (R));\n-         Pre_Analyze_And_Resolve (R_Copy);\n+         Save_Analysis := Full_Analysis;\n+         Full_Analysis := False;\n+         Expander_Mode_Save_And_Set (False);\n+\n+         Analyze (R_Copy);\n+\n+         if Is_Overloaded (R_Copy) then\n+\n+            --  Apply preference rules for range of predefined integer types,\n+            --  or diagnose true ambiguity.\n+\n+            declare\n+               I     : Interp_Index;\n+               It    : Interp;\n+               Found : Entity_Id := Empty;\n+\n+            begin\n+               Get_First_Interp (R_Copy, I, It);\n+               while Present (It.Typ) loop\n+                  if Is_Discrete_Type (It.Typ) then\n+                     if No (Found) then\n+                        Found := It.Typ;\n+                     else\n+                        if Scope (Found) = Standard_Standard then\n+                           null;\n+\n+                        elsif Scope (It.Typ) = Standard_Standard then\n+                           Found := It.Typ;\n+\n+                        else\n+                           --  Both of them are user-defined\n+\n+                           Error_Msg_N\n+                             (\"ambiguous bounds in range of iteration\",\n+                               R_Copy);\n+                           Error_Msg_N (\"\\possible interpretations:\", R_Copy);\n+                           Error_Msg_NE (\"\\} \", R_Copy, Found);\n+                           Error_Msg_NE (\"\\} \", R_Copy, It.Typ);\n+                           exit;\n+                        end if;\n+                     end if;\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end;\n+         end if;\n+\n+         Resolve (R_Copy);\n+         Expander_Mode_Restore;\n+         Full_Analysis := Save_Analysis;\n+\n          Typ := Etype (R_Copy);\n \n          --  If the type of the discrete range is Universal_Integer, then"}, {"sha": "66a24306a855273a2b520b5177b6ad014b9bada3", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 291, "deletions": 81, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ef728f432bcc51464d574189ef68f515ea3ef7/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ef728f432bcc51464d574189ef68f515ea3ef7/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c8ef728f432bcc51464d574189ef68f515ea3ef7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -77,6 +77,16 @@ with Validsw;  use Validsw;\n \n package body Sem_Ch6 is\n \n+   --  The following flag is used to indicate that two formals in two\n+   --  subprograms being checked for conformance differ only in that one is\n+   --  an access parameter while the other is of a general access type with\n+   --  the same designated type. In this case, if the rest of the signatures\n+   --  match, a call to either subprogram may be ambiguous, which is worth\n+   --  a warning. The flag is set in Compatible_Types, and the warning emitted\n+   --  in New_Overloaded_Entity.\n+\n+   May_Hide_Profile : Boolean := False;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -141,14 +151,17 @@ package body Sem_Ch6 is\n    procedure Check_Returns\n      (HSS  : Node_Id;\n       Mode : Character;\n-      Err  : out Boolean);\n-   --  Called to check for missing return statements in a function body, or\n-   --  for returns present in a procedure body which has No_Return set. L is\n-   --  the handled statement sequence for the subprogram body. This procedure\n-   --  checks all flow paths to make sure they either have return (Mode = 'F')\n-   --  or do not have a return (Mode = 'P'). The flag Err is set if there are\n-   --  any control paths not explicitly terminated by a return in the function\n-   --  case, and is True otherwise.\n+      Err  : out Boolean;\n+      Proc : Entity_Id := Empty);\n+   --  Called to check for missing return statements in a function body, or for\n+   --  returns present in a procedure body which has No_Return set. L is the\n+   --  handled statement sequence for the subprogram body. This procedure\n+   --  checks all flow paths to make sure they either have return (Mode = 'F',\n+   --  used for functions) or do not have a return (Mode = 'P', used for\n+   --  No_Return procedures). The flag Err is set if there are any control\n+   --  paths not explicitly terminated by a return in the function case, and is\n+   --  True otherwise. Proc is the entity for the procedure case and is used\n+   --  in posting the warning message.\n \n    function Conforming_Types\n      (T1       : Entity_Id;\n@@ -790,7 +803,7 @@ package body Sem_Ch6 is\n                Error_Msg_N\n                  (\"cannot return a local value by reference?\", N);\n                Error_Msg_NE\n-                 (\"& will be raised at run time?!\",\n+                 (\"\\& will be raised at run time?\",\n                   N, Standard_Program_Error);\n             end if;\n \n@@ -1328,7 +1341,38 @@ package body Sem_Ch6 is\n                    (Etype (First_Entity (Spec_Id))));\n             end if;\n \n-            --  Comment needed here, since this is not Ada 2005 stuff! ???\n+            --  Ada 2005: A formal that is an access parameter may have a\n+            --  designated type imported through a limited_with clause, while\n+            --  the body has a regular with clause. Update the types of the\n+            --  formals accordingly, so that the non-limited view of each type\n+            --  is available in the body. We have already verified that the\n+            --  declarations are type-conformant.\n+\n+            if Ada_Version >= Ada_05 then\n+               declare\n+                  F_Spec : Entity_Id;\n+                  F_Body : Entity_Id;\n+\n+               begin\n+                  F_Spec := First_Formal (Spec_Id);\n+                  F_Body := First_Formal (Body_Id);\n+\n+                  while Present (F_Spec) loop\n+                     if Ekind (Etype (F_Spec)) = E_Anonymous_Access_Type\n+                       and then\n+                         From_With_Type (Designated_Type (Etype (F_Spec)))\n+                     then\n+                        Set_Etype (F_Spec, Etype (F_Body));\n+                     end if;\n+\n+                     Next_Formal (F_Spec);\n+                     Next_Formal (F_Body);\n+                  end loop;\n+               end;\n+            end if;\n+\n+            --  Now make the formals visible, and place subprogram\n+            --  on scope stack.\n \n             Install_Formals (Spec_Id);\n             Last_Formal := Last_Entity (Spec_Id);\n@@ -1508,7 +1552,7 @@ package body Sem_Ch6 is\n         and then Present (Spec_Id)\n         and then No_Return (Spec_Id)\n       then\n-         Check_Returns (HSS, 'P', Missing_Ret);\n+         Check_Returns (HSS, 'P', Missing_Ret, Spec_Id);\n       end if;\n \n       --  Now we are going to check for variables that are never modified in\n@@ -1873,6 +1917,13 @@ package body Sem_Ch6 is\n       --  conflict with subsequent inlinings, so that it is unsafe to try to\n       --  inline in such a case.\n \n+      function Has_Single_Return return Boolean;\n+      --  In general we cannot inline functions that return unconstrained\n+      --  type. However, we can handle such functions if all return statements\n+      --  return a local variable that is the only declaration in the body\n+      --  of the function. In that case the call can be replaced by that\n+      --  local variable as is done for other inlined calls.\n+\n       procedure Remove_Pragmas;\n       --  A pragma Unreferenced that mentions a formal parameter has no\n       --  meaning when the body is inlined and the formals are rewritten.\n@@ -2064,6 +2115,57 @@ package body Sem_Ch6 is\n          return False;\n       end Has_Pending_Instantiation;\n \n+      ------------------------\n+      --  Has_Single_Return --\n+      ------------------------\n+\n+      function Has_Single_Return return Boolean is\n+         Return_Statement : Node_Id := Empty;\n+\n+         function Check_Return (N : Node_Id) return Traverse_Result;\n+\n+         ------------------\n+         -- Check_Return --\n+         ------------------\n+\n+         function Check_Return (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Return_Statement then\n+               if Present (Expression (N))\n+                 and then Is_Entity_Name (Expression (N))\n+               then\n+                  if No (Return_Statement) then\n+                     Return_Statement := N;\n+                     return OK;\n+\n+                  elsif Chars (Expression (N)) =\n+                        Chars (Expression (Return_Statement))\n+                  then\n+                     return OK;\n+\n+                  else\n+                     return Abandon;\n+                  end if;\n+\n+               else\n+                  --  Expression has wrong form\n+\n+                  return Abandon;\n+               end if;\n+\n+            else\n+               return OK;\n+            end if;\n+         end Check_Return;\n+\n+         function Check_All_Returns is new Traverse_Func (Check_Return);\n+\n+      --  Start of processing for Has_Single_Return\n+\n+      begin\n+         return Check_All_Returns (N) = OK;\n+      end Has_Single_Return;\n+\n       --------------------\n       -- Remove_Pragmas --\n       --------------------\n@@ -2138,6 +2240,7 @@ package body Sem_Ch6 is\n         and then not Is_Scalar_Type (Etype (Subp))\n         and then not Is_Access_Type (Etype (Subp))\n         and then not Is_Constrained (Etype (Subp))\n+        and then not Has_Single_Return\n       then\n          Cannot_Inline\n            (\"cannot inline & (unconstrained return type)?\", N, Subp);\n@@ -2963,7 +3066,8 @@ package body Sem_Ch6 is\n    procedure Check_Returns\n      (HSS  : Node_Id;\n       Mode : Character;\n-      Err  : out Boolean)\n+      Err  : out Boolean;\n+      Proc : Entity_Id := Empty)\n    is\n       Handler : Node_Id;\n \n@@ -3040,6 +3144,9 @@ package body Sem_Ch6 is\n             --  missing return curious, and raising Program_Error does not\n             --  seem such a bad behavior if this does occur.\n \n+            --  Note that in the Ada 2005 case for Raise_Exception, the actual\n+            --  behavior will be to raise Constraint_Error (see AI-329).\n+\n             if Is_RTE (Entity (Name (Last_Stm)), RE_Raise_Exception)\n                  or else\n                Is_RTE (Entity (Name (Last_Stm)), RE_Reraise_Occurrence)\n@@ -3208,10 +3315,9 @@ package body Sem_Ch6 is\n          --  If we fall through, issue appropriate message\n \n          if Mode = 'F' then\n-\n             if not Raise_Exception_Call then\n                Error_Msg_N\n-                 (\"?RETURN statement missing following this statement!\",\n+                 (\"?RETURN statement missing following this statement\",\n                   Last_Stm);\n                Error_Msg_N\n                  (\"\\?Program_Error may be raised at run time\",\n@@ -3225,10 +3331,24 @@ package body Sem_Ch6 is\n \n             Err := True;\n \n+         --  Otherwise we have the case of a procedure marked No_Return\n+\n          else\n             Error_Msg_N\n-              (\"implied return after this statement not allowed (No_Return)\",\n+              (\"?implied return after this statement will raise Program_Error\",\n                Last_Stm);\n+            Error_Msg_NE\n+              (\"?procedure & is marked as No_Return\",\n+               Last_Stm, Proc);\n+\n+            declare\n+               RE : constant Node_Id :=\n+                      Make_Raise_Program_Error (Sloc (Last_Stm),\n+                        Reason => PE_Implicit_Return);\n+            begin\n+               Insert_After (Last_Stm, RE);\n+               Analyze (RE);\n+            end;\n          end if;\n       end Check_Statement_Sequence;\n \n@@ -3598,6 +3718,17 @@ package body Sem_Ch6 is\n       --  Otherwise definitely no match\n \n       else\n+         if ((Ekind (Type_1) = E_Anonymous_Access_Type\n+               and then Is_Access_Type (Type_2))\n+            or else (Ekind (Type_2) = E_Anonymous_Access_Type\n+                       and then Is_Access_Type (Type_1)))\n+           and then\n+             Conforming_Types\n+               (Designated_Type (Type_1), Designated_Type (Type_2), Ctype)\n+         then\n+            May_Hide_Profile := True;\n+         end if;\n+\n          return False;\n       end if;\n    end Conforming_Types;\n@@ -3739,7 +3870,7 @@ package body Sem_Ch6 is\n                or else\n               Explicit_Suppress (Scope (E), Accessibility_Check))\n            and then\n-             (not Present (P_Formal)\n+             (No (P_Formal)\n                or else Present (Extra_Accessibility (P_Formal)))\n          then\n             --  Temporary kludge: for now we avoid creating the extra formal\n@@ -4403,7 +4534,6 @@ package body Sem_Ch6 is\n \n    procedure Install_Entity (E : Entity_Id) is\n       Prev : constant Entity_Id := Current_Entity (E);\n-\n    begin\n       Set_Is_Immediately_Visible (E);\n       Set_Current_Entity (E);\n@@ -4416,10 +4546,8 @@ package body Sem_Ch6 is\n \n    procedure Install_Formals (Id : Entity_Id) is\n       F : Entity_Id;\n-\n    begin\n       F := First_Formal (Id);\n-\n       while Present (F) loop\n          Install_Entity (F);\n          Next_Formal (F);\n@@ -4555,7 +4683,7 @@ package body Sem_Ch6 is\n             Next_Formal (Formal);\n          end loop;\n \n-         if not Present (G_Typ) and then Ekind (Prev_E) = E_Function then\n+         if No (G_Typ) and then Ekind (Prev_E) = E_Function then\n             G_Typ := Get_Generic_Parent_Type (Base_Type (Etype (Prev_E)));\n          end if;\n \n@@ -4611,8 +4739,8 @@ package body Sem_Ch6 is\n                      --  formal ancestor type, so the new subprogram is\n                      --  overriding.\n \n-                     if not Present (P_Formal)\n-                       and then not Present (N_Formal)\n+                     if No (P_Formal)\n+                       and then No (N_Formal)\n                        and then (Ekind (New_E) /= E_Function\n                                   or else\n                                  Types_Correspond\n@@ -4651,67 +4779,77 @@ package body Sem_Ch6 is\n       Formals : List_Id;\n       Op_Name : Entity_Id;\n \n-      A : Entity_Id;\n-      B : Entity_Id;\n+      FF : constant Entity_Id := First_Formal (S);\n+      NF : constant Entity_Id := Next_Formal (FF);\n \n    begin\n-      --  Check that equality was properly defined\n+      --  Check that equality was properly defined, ignore call if not\n \n-      if  No (Next_Formal (First_Formal (S))) then\n+      if No (NF) then\n          return;\n       end if;\n \n-      A := Make_Defining_Identifier (Loc, Chars (First_Formal (S)));\n-      B := Make_Defining_Identifier (Loc,\n-             Chars (Next_Formal (First_Formal (S))));\n-\n-      Op_Name := Make_Defining_Operator_Symbol (Loc, Name_Op_Ne);\n-\n-      Formals := New_List (\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => A,\n-          Parameter_Type =>\n-            New_Reference_To (Etype (First_Formal (S)), Loc)),\n-\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => B,\n-          Parameter_Type =>\n-            New_Reference_To (Etype (Next_Formal (First_Formal (S))), Loc)));\n-\n-      Decl :=\n-        Make_Subprogram_Declaration (Loc,\n-          Specification =>\n-            Make_Function_Specification (Loc,\n-              Defining_Unit_Name => Op_Name,\n-              Parameter_Specifications => Formals,\n-              Result_Definition => New_Reference_To (Standard_Boolean, Loc)));\n-\n-      --  Insert inequality right after equality if it is explicit or after\n-      --  the derived type when implicit. These entities are created only for\n-      --  visibility purposes, and eventually replaced in the course of\n-      --  expansion, so they do not need to be attached to the tree and seen\n-      --  by the back-end. Keeping them internal also avoids spurious freezing\n-      --  problems. The declaration is inserted in the tree for analysis, and\n-      --  removed afterwards. If the equality operator comes from an explicit\n-      --  declaration, attach the inequality immediately after. Else the\n-      --  equality is inherited from a derived type declaration, so insert\n-      --  inequality after that declaration.\n-\n-      if No (Alias (S)) then\n-         Insert_After (Unit_Declaration_Node (S), Decl);\n-      elsif Is_List_Member (Parent (S)) then\n-         Insert_After (Parent (S), Decl);\n-      else\n-         Insert_After (Parent (Etype (First_Formal (S))), Decl);\n-      end if;\n+      declare\n+         A : constant Entity_Id :=\n+               Make_Defining_Identifier (Sloc (FF),\n+                 Chars => Chars (FF));\n+\n+         B  : constant Entity_Id :=\n+                Make_Defining_Identifier (Sloc (NF),\n+                  Chars => Chars (NF));\n+\n+      begin\n+         Op_Name := Make_Defining_Operator_Symbol (Loc, Name_Op_Ne);\n+\n+         Formals := New_List (\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => A,\n+             Parameter_Type      =>\n+               New_Reference_To (Etype (First_Formal (S)),\n+                 Sloc (Etype (First_Formal (S))))),\n+\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => B,\n+             Parameter_Type      =>\n+               New_Reference_To (Etype (Next_Formal (First_Formal (S))),\n+                 Sloc (Etype (Next_Formal (First_Formal (S)))))));\n+\n+         Decl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Make_Function_Specification (Loc,\n+                 Defining_Unit_Name       => Op_Name,\n+                 Parameter_Specifications => Formals,\n+                 Result_Definition        =>\n+                   New_Reference_To (Standard_Boolean, Loc)));\n+\n+         --  Insert inequality right after equality if it is explicit or after\n+         --  the derived type when implicit. These entities are created only\n+         --  for visibility purposes, and eventually replaced in the course of\n+         --  expansion, so they do not need to be attached to the tree and seen\n+         --  by the back-end. Keeping them internal also avoids spurious\n+         --  freezing problems. The declaration is inserted in the tree for\n+         --  analysis, and removed afterwards. If the equality operator comes\n+         --  from an explicit declaration, attach the inequality immediately\n+         --  after. Else the equality is inherited from a derived type\n+         --  declaration, so insert inequality after that declaration.\n+\n+         if No (Alias (S)) then\n+            Insert_After (Unit_Declaration_Node (S), Decl);\n+         elsif Is_List_Member (Parent (S)) then\n+            Insert_After (Parent (S), Decl);\n+         else\n+            Insert_After (Parent (Etype (First_Formal (S))), Decl);\n+         end if;\n \n-      Mark_Rewrite_Insertion (Decl);\n-      Set_Is_Intrinsic_Subprogram (Op_Name);\n-      Analyze (Decl);\n-      Remove (Decl);\n-      Set_Has_Completion (Op_Name);\n-      Set_Corresponding_Equality (Op_Name, S);\n-      Set_Is_Abstract (Op_Name, Is_Abstract (S));\n+         Mark_Rewrite_Insertion (Decl);\n+         Set_Is_Intrinsic_Subprogram (Op_Name);\n+         Analyze (Decl);\n+         Remove (Decl);\n+         Set_Has_Completion (Op_Name);\n+         Set_Corresponding_Equality (Op_Name, S);\n+         Set_Is_Abstract (Op_Name, Is_Abstract (S));\n+      end;\n    end Make_Inequality_Operator;\n \n    ----------------------\n@@ -5074,6 +5212,14 @@ package body Sem_Ch6 is\n \n             elsif not Is_Alias_Interface\n               and then Type_Conformant (E, S)\n+\n+               --  Ada 2005 (AI-251): Do not consider here entities that cover\n+               --  abstract interface primitives. They will be handled after\n+               --  the overriden entity is found (see comments bellow inside\n+               --  this subprogram).\n+\n+              and then not (Is_Subprogram (E)\n+                              and then Present (Abstract_Interface_Alias (E)))\n             then\n                --  If the old and new entities have the same profile and one\n                --  is not the body of the other, then this is an error, unless\n@@ -5159,7 +5305,7 @@ package body Sem_Ch6 is\n \n                   if Is_Non_Overriding_Operation (E, S) then\n                      Enter_Overloaded_Entity (S);\n-                     if not Present (Derived_Type)\n+                     if No (Derived_Type)\n                        or else Is_Tagged_Type (Derived_Type)\n                      then\n                         Check_Dispatching_Operation (S, Empty);\n@@ -5289,7 +5435,7 @@ package body Sem_Ch6 is\n                      --  E is inherited.\n \n                      if Comes_From_Source (S) then\n-                        if  Present (Alias (E)) then\n+                        if Present (Alias (E)) then\n                            Set_Overridden_Operation (S, Alias (E));\n                         else\n                            Set_Overridden_Operation (S, E);\n@@ -5344,6 +5490,27 @@ package body Sem_Ch6 is\n \n                         Check_Dispatching_Operation (S, E);\n \n+                        --  AI-251: Handle the case in which the entity\n+                        --  overrides a primitive operation that covered\n+                        --  several abstract interface primitives.\n+\n+                        declare\n+                           E1 : Entity_Id;\n+                        begin\n+                           E1 := Current_Entity_In_Scope (S);\n+                           while Present (E1) loop\n+                              if Is_Subprogram (E1)\n+                                and then Present\n+                                           (Abstract_Interface_Alias (E1))\n+                                and then Alias (E1) = E\n+                              then\n+                                 Set_Alias (E1, S);\n+                              end if;\n+\n+                              E1 := Homonym (E1);\n+                           end loop;\n+                        end;\n+\n                      else\n                         Check_Dispatching_Operation (S, Empty);\n                      end if;\n@@ -5389,7 +5556,48 @@ package body Sem_Ch6 is\n                end if;\n \n             else\n-               null;\n+               --  If one subprogram has an access parameter and the other\n+               --  a parameter of an access type, calls to either might be\n+               --  ambiguous. Verify that parameters match except for the\n+               --  access parameter.\n+\n+               if May_Hide_Profile then\n+                  declare\n+                     F1    : Entity_Id;\n+                     F2    : Entity_Id;\n+                  begin\n+                     F1 := First_Formal (S);\n+                     F2 := First_Formal (E);\n+                     while Present (F1) and then Present (F2) loop\n+                        if Is_Access_Type (Etype (F1)) then\n+                           if not Is_Access_Type (Etype (F2))\n+                              or else not Conforming_Types\n+                                (Designated_Type (Etype (F1)),\n+                                 Designated_Type (Etype (F2)),\n+                                 Type_Conformant)\n+                           then\n+                              May_Hide_Profile := False;\n+                           end if;\n+\n+                        elsif\n+                          not Conforming_Types\n+                            (Etype (F1), Etype (F2), Type_Conformant)\n+                        then\n+                           May_Hide_Profile := False;\n+                        end if;\n+\n+                        Next_Formal (F1);\n+                        Next_Formal (F2);\n+                     end loop;\n+\n+                     if May_Hide_Profile\n+                       and then No (F1)\n+                       and then No (F2)\n+                     then\n+                        Error_Msg_NE (\"calls to& may be ambiguous?\", S, S);\n+                     end if;\n+                  end;\n+               end if;\n             end if;\n \n             Prev_Vis := E;\n@@ -5407,7 +5615,7 @@ package body Sem_Ch6 is\n          --  operation was dispatching), so we don't call\n          --  Check_Dispatching_Operation in that case.\n \n-         if not Present (Derived_Type)\n+         if No (Derived_Type)\n            or else Is_Tagged_Type (Derived_Type)\n          then\n             Check_Dispatching_Operation (S, Empty);\n@@ -5922,6 +6130,8 @@ package body Sem_Ch6 is\n    is\n       Result : Boolean;\n    begin\n+      May_Hide_Profile := False;\n+\n       Check_Conformance\n         (New_Id, Old_Id, Type_Conformant, False, Result,\n          Skip_Controlling_Formals => Skip_Controlling_Formals);"}, {"sha": "1a8766ae8645f25a6e12f6223c62678a971e75f8", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 304, "deletions": 149, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8ef728f432bcc51464d574189ef68f515ea3ef7/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8ef728f432bcc51464d574189ef68f515ea3ef7/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c8ef728f432bcc51464d574189ef68f515ea3ef7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -90,11 +90,6 @@ package body Sem_Res is\n    --  Give list of candidate interpretations when a character literal cannot\n    --  be resolved.\n \n-   procedure Check_Direct_Boolean_Op (N : Node_Id);\n-   --  N is a binary operator node which may possibly operate on Boolean\n-   --  operands. If the operator does have Boolean operands, then a call is\n-   --  made to check the restriction No_Direct_Boolean_Operators.\n-\n    procedure Check_Discriminant_Use (N : Node_Id);\n    --  Enforce the restrictions on the use of discriminants when constraining\n    --  a component of a discriminated type (record or concurrent type).\n@@ -105,6 +100,11 @@ package body Sem_Res is\n    --  universal must be checked for visibility during resolution\n    --  because their type is not determinable based on their operands.\n \n+   procedure Check_Fully_Declared_Prefix\n+     (Typ  : Entity_Id;\n+      Pref : Node_Id);\n+   --  Check that the type of the prefix of a dereference is not incomplete\n+\n    function Check_Infinite_Recursion (N : Node_Id) return Boolean;\n    --  Given a call node, N, which is known to occur immediately within the\n    --  subprogram being called, determines whether it is a detectable case of\n@@ -346,19 +346,6 @@ package body Sem_Res is\n       end if;\n    end Analyze_And_Resolve;\n \n-   -----------------------------\n-   -- Check_Direct_Boolean_Op --\n-   -----------------------------\n-\n-   procedure Check_Direct_Boolean_Op (N : Node_Id) is\n-   begin\n-      if Nkind (N) in N_Op\n-        and then Root_Type (Etype (Left_Opnd (N))) = Standard_Boolean\n-      then\n-         Check_Restriction (No_Direct_Boolean_Operators, N);\n-      end if;\n-   end Check_Direct_Boolean_Op;\n-\n    ----------------------------\n    -- Check_Discriminant_Use --\n    ----------------------------\n@@ -472,7 +459,7 @@ package body Sem_Res is\n                --  Check that it is the high bound\n \n                if N /= High_Bound (PN)\n-                 or else not Present (Discriminant_Default_Value (Disc))\n+                 or else No (Discriminant_Default_Value (Disc))\n                then\n                   goto No_Danger;\n                end if;\n@@ -600,6 +587,54 @@ package body Sem_Res is\n       end if;\n    end Check_For_Visible_Operator;\n \n+   ----------------------------------\n+   --  Check_Fully_Declared_Prefix --\n+   ----------------------------------\n+\n+   procedure Check_Fully_Declared_Prefix\n+     (Typ  : Entity_Id;\n+      Pref : Node_Id)\n+   is\n+   begin\n+      --  Check that the designated type of the prefix of a dereference is\n+      --  not an incomplete type. This cannot be done unconditionally, because\n+      --  dereferences of private types are legal in default expressions. This\n+      --  case is taken care of in Check_Fully_Declared, called below. There\n+      --  are also 2005 cases where it is legal for the prefix to be unfrozen.\n+\n+      --  This consideration also applies to similar checks for allocators,\n+      --  qualified expressions, and type conversions.\n+\n+      --  An additional exception concerns other per-object expressions that\n+      --  are not directly related to component declarations, in particular\n+      --  representation pragmas for tasks. These will be per-object\n+      --  expressions if they depend on discriminants or some global entity.\n+      --  If the task has access discriminants, the designated type may be\n+      --  incomplete at the point the expression is resolved. This resolution\n+      --  takes place within the body of the initialization procedure, where\n+      --  the discriminant is replaced by its discriminal.\n+\n+      if Is_Entity_Name (Pref)\n+        and then Ekind (Entity (Pref)) = E_In_Parameter\n+      then\n+         null;\n+\n+      --  Ada 2005 (AI-326): Tagged incomplete types allowed. The wrong usages\n+      --  are handled by Analyze_Access_Attribute, Analyze_Assignment,\n+      --  Analyze_Object_Renaming, and Freeze_Entity.\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Is_Entity_Name (Pref)\n+        and then Ekind (Directly_Designated_Type (Etype (Pref))) =\n+                                                       E_Incomplete_Type\n+        and then Is_Tagged_Type (Directly_Designated_Type (Etype (Pref)))\n+      then\n+         null;\n+      else\n+         Check_Fully_Declared (Typ, Parent (Pref));\n+      end if;\n+   end Check_Fully_Declared_Prefix;\n+\n    ------------------------------\n    -- Check_Infinite_Recursion --\n    ------------------------------\n@@ -1156,6 +1191,15 @@ package body Sem_Res is\n                Error := True;\n             end if;\n \n+         --  Ada 2005, AI-420:  Predefined equality on Universal_Access\n+         --  is available.\n+\n+         elsif Ada_Version >= Ada_05\n+           and then (Op_Name = Name_Op_Eq or else Op_Name = Name_Op_Ne)\n+           and then Ekind (Etype (Act1)) = E_Anonymous_Access_Type\n+         then\n+            null;\n+\n          else\n             Opnd_Type := Base_Type (Etype (Right_Opnd (Op_Node)));\n \n@@ -1899,7 +1943,7 @@ package body Sem_Res is\n \n             --  Move to next interpretation\n \n-            exit Interp_Loop when not Present (It.Typ);\n+            exit Interp_Loop when No (It.Typ);\n \n             Get_Next_Interp (I, It);\n          end loop Interp_Loop;\n@@ -2512,7 +2556,7 @@ package body Sem_Res is\n             Set_First_Named_Actual (N, Actval);\n \n             if No (Prev) then\n-               if not Present (Parameter_Associations (N)) then\n+               if No (Parameter_Associations (N)) then\n                   Set_Parameter_Associations (N, New_List (Assoc));\n                else\n                   Append (Assoc, Parameter_Associations (N));\n@@ -2594,7 +2638,7 @@ package body Sem_Res is\n             --  the tag check to occur and no temporary will be needed (no\n             --  representation change can occur) and the parameter is passed by\n             --  reference, so we go ahead and resolve the type conversion.\n-            --  Another excpetion is the case of reference to component or\n+            --  Another exception is the case of reference to component or\n             --  subcomponent of a bit-packed array, in which case we want to\n             --  defer expansion to the point the in and out assignments are\n             --  performed.\n@@ -2666,6 +2710,33 @@ package body Sem_Res is\n                   end if;\n                end if;\n \n+               --  (Ada 2005: AI-251): If the actual is an allocator whose\n+               --  directly designated type is a class-wide interface, we build\n+               --  an anonymous access type to use it as the type of the\n+               --  allocator. Later, when the subprogram call is expanded, if\n+               --  the interface has a secondary dispatch table the expander\n+               --  will add a type conversion to force the correct displacement\n+               --  of the pointer.\n+\n+               if Nkind (A) = N_Allocator then\n+                  declare\n+                     DDT : constant Entity_Id :=\n+                             Directly_Designated_Type (Base_Type (Etype (F)));\n+                     New_Itype : Entity_Id;\n+                  begin\n+                     if Is_Class_Wide_Type (DDT)\n+                       and then Is_Interface (DDT)\n+                     then\n+                        New_Itype := Create_Itype (E_Anonymous_Access_Type, A);\n+                        Set_Etype       (New_Itype, Etype (A));\n+                        Init_Size_Align (New_Itype);\n+                        Set_Directly_Designated_Type (New_Itype,\n+                          Directly_Designated_Type (Etype (A)));\n+                        Set_Etype (A, New_Itype);\n+                     end if;\n+                  end;\n+               end if;\n+\n                Resolve (A, Etype (F));\n             end if;\n \n@@ -3090,7 +3161,8 @@ package body Sem_Res is\n                if In_Instance_Body then\n                   Error_Msg_N (\"?type in allocator has deeper level than\" &\n                                \" designated class-wide type\", E);\n-                  Error_Msg_N (\"?Program_Error will be raised at run time\", E);\n+                  Error_Msg_N (\"\\?Program_Error will be raised at run time\",\n+                               E);\n                   Rewrite (N,\n                     Make_Raise_Program_Error (Sloc (N),\n                       Reason => PE_Accessibility_Check_Failed));\n@@ -3109,8 +3181,8 @@ package body Sem_Res is\n          declare\n             Loc : constant Source_Ptr := Sloc (N);\n          begin\n-            Error_Msg_N (\"?allocation from empty storage pool!\", N);\n-            Error_Msg_N (\"?Storage_Error will be raised at run time!\", N);\n+            Error_Msg_N (\"?allocation from empty storage pool\", N);\n+            Error_Msg_N (\"\\?Storage_Error will be raised at run time\", N);\n             Insert_Action (N,\n               Make_Raise_Storage_Error (Loc,\n                 Reason => SE_Empty_Storage_Pool));\n@@ -3708,8 +3780,7 @@ package body Sem_Res is\n            and then not Is_Controlling_Limited_Procedure (Nam)\n          then\n             Error_Msg_N\n-             (\"entry call, entry renaming or dispatching primitive \" &\n-              \"of limited or synchronized interface required\", N);\n+             (\"entry call or dispatching primitive of interface required\", N);\n          end if;\n       end if;\n \n@@ -3869,7 +3940,7 @@ package body Sem_Res is\n                then\n                   Set_Has_Recursive_Call (Nam);\n                   Error_Msg_N (\"possible infinite recursion?\", N);\n-                  Error_Msg_N (\"Storage_Error may be raised at run time?\", N);\n+                  Error_Msg_N (\"\\Storage_Error may be raised at run time?\", N);\n                end if;\n \n                exit;\n@@ -3909,7 +3980,18 @@ package body Sem_Res is\n       --  for it, precisely because we will not do it within the init proc\n       --  itself.\n \n-      if Expander_Active\n+      --  If the subprogram is marked Inlined_Always, then even if it returns\n+      --  an unconstrained type the call does not require use of the secondary\n+      --  stack.\n+\n+      if Is_Inlined (Nam)\n+        and then Present (First_Rep_Item (Nam))\n+        and then Nkind (First_Rep_Item (Nam)) = N_Pragma\n+        and then Chars (First_Rep_Item (Nam)) = Name_Inline_Always\n+      then\n+         null;\n+\n+      elsif Expander_Active\n         and then Is_Type (Etype (Nam))\n         and then Requires_Transient_Scope (Etype (Nam))\n         and then Ekind (Nam) /= E_Enumeration_Literal\n@@ -4120,7 +4202,6 @@ package body Sem_Res is\n             Check_Unset_Reference (R);\n             Generate_Operator_Reference (N, T);\n             Eval_Relational_Op (N);\n-            Check_Direct_Boolean_Op (N);\n          end if;\n       end if;\n    end Resolve_Comparison_Op;\n@@ -4875,7 +4956,31 @@ package body Sem_Res is\n             Error_Msg_NE (\"cannot call abstract subprogram &!\", N, Entity (N));\n          end if;\n \n-         Check_Direct_Boolean_Op (N);\n+         --  Ada 2005:  If one operand is an anonymous access type, convert\n+         --  the other operand to it, to ensure that the underlying types\n+         --  match in the back-end.\n+         --  We apply the same conversion in the case one of the operands is\n+         --  a private subtype of the type of the other.\n+\n+         if Ekind (T) =  E_Anonymous_Access_Type\n+           or else Is_Private_Type (T)\n+         then\n+            if Etype (L) /= T then\n+               Rewrite (L,\n+                 Make_Unchecked_Type_Conversion (Sloc (L),\n+                   Subtype_Mark => New_Occurrence_Of (T, Sloc (L)),\n+                   Expression   => Relocate_Node (L)));\n+               Analyze_And_Resolve (L, T);\n+            end if;\n+\n+            if (Etype (R)) /= T then\n+               Rewrite (R,\n+                  Make_Unchecked_Type_Conversion (Sloc (R),\n+                    Subtype_Mark => New_Occurrence_Of (Etype (L), Sloc (R)),\n+                    Expression   => Relocate_Node (R)));\n+               Analyze_And_Resolve (R, T);\n+            end if;\n+         end if;\n       end if;\n    end Resolve_Equality_Op;\n \n@@ -4891,42 +4996,7 @@ package body Sem_Res is\n       It    : Interp;\n \n    begin\n-      --  Now that we know the type, check that this is not dereference of an\n-      --  uncompleted type. Note that this is not entirely correct, because\n-      --  dereferences of private types are legal in default expressions. This\n-      --  exception is taken care of in Check_Fully_Declared.\n-\n-      --  This consideration also applies to similar checks for allocators,\n-      --  qualified expressions, and type conversions.\n-\n-      --  An additional exception concerns other per-object expressions that\n-      --  are not directly related to component declarations, in particular\n-      --  representation pragmas for tasks. These will be per-object\n-      --  expressions if they depend on discriminants or some global entity.\n-      --  If the task has access discriminants, the designated type may be\n-      --  incomplete at the point the expression is resolved. This resolution\n-      --  takes place within the body of the initialization procedure, where\n-      --  the discriminant is replaced by its discriminal.\n-\n-      if Is_Entity_Name (Prefix (N))\n-        and then Ekind (Entity (Prefix (N))) = E_In_Parameter\n-      then\n-         null;\n-\n-      --  Ada 2005 (AI-326): Tagged incomplete types allowed. The wrong usages\n-      --  are handled by Analyze_Access_Attribute, Analyze_Assignment, Analyze_\n-      --  Object_Renaming, and Freeze_Entity.\n-\n-      elsif Ada_Version >= Ada_05\n-        and then Is_Entity_Name (Prefix (N))\n-        and then Ekind (Directly_Designated_Type (Etype (Prefix (N))))\n-                   = E_Incomplete_Type\n-        and then Is_Tagged_Type (Directly_Designated_Type (Etype (Prefix (N))))\n-      then\n-         null;\n-      else\n-         Check_Fully_Declared (Typ, N);\n-      end if;\n+      Check_Fully_Declared_Prefix (Typ, P);\n \n       if Is_Overloaded (P) then\n \n@@ -5239,6 +5309,7 @@ package body Sem_Res is\n \n    procedure Resolve_Logical_Op (N : Node_Id; Typ : Entity_Id) is\n       B_Typ : Entity_Id;\n+      N_Opr : constant Node_Kind := Nkind (N);\n \n    begin\n       --  Predefined operations on scalar types yield the base type. On the\n@@ -5283,7 +5354,15 @@ package body Sem_Res is\n       Set_Etype (N, B_Typ);\n       Generate_Operator_Reference (N, B_Typ);\n       Eval_Logical_Op (N);\n-      Check_Direct_Boolean_Op (N);\n+\n+      --  Check for violation of restriction No_Direct_Boolean_Operators\n+      --  if the operator was not eliminated by the Eval_Logical_Op call.\n+\n+      if Nkind (N) = N_Opr\n+        and then Root_Type (Etype (Left_Opnd (N))) = Standard_Boolean\n+      then\n+         Check_Restriction (No_Direct_Boolean_Operators, N);\n+      end if;\n    end Resolve_Logical_Op;\n \n    ---------------------------\n@@ -5319,7 +5398,7 @@ package body Sem_Res is\n       --      type I is interface;\n       --      type T is tagged ...\n \n-      --      function Test (O : in I'Class) is\n+      --      function Test (O : I'Class) is\n       --      begin\n       --         return O in T'Class.\n       --      end Test;\n@@ -5994,12 +6073,21 @@ package body Sem_Res is\n                         else\n                            It1 := It;\n \n-                           if Scope (Comp1) /= It1.Typ then\n+                           --  There may be an implicit dereference. Retrieve\n+                           --  designated record type.\n+\n+                           if Is_Access_Type (It1.Typ) then\n+                              T := Designated_Type (It1.Typ);\n+                           else\n+                              T := It1.Typ;\n+                           end if;\n+\n+                           if Scope (Comp1) /= T then\n \n                               --  Resolution chooses the new interpretation.\n                               --  Find the component with the right name.\n \n-                              Comp1 := First_Entity (It1.Typ);\n+                              Comp1 := First_Entity (T);\n                               while Present (Comp1)\n                                 and then Chars (Comp1) /= Chars (S)\n                               loop\n@@ -6030,12 +6118,13 @@ package body Sem_Res is\n          Resolve (P, T);\n       end if;\n \n-      --  If prefix is an access type, the node will be transformed into\n-      --  an explicit dereference during expansion. The type of the node\n-      --  is the designated type of that of the prefix.\n+      --  If prefix is an access type, the node will be transformed into an\n+      --  explicit dereference during expansion. The type of the node is the\n+      --  designated type of that of the prefix.\n \n       if Is_Access_Type (Etype (P)) then\n          T := Designated_Type (Etype (P));\n+         Check_Fully_Declared_Prefix (T, P);\n       else\n          T := Etype (P);\n       end if;\n@@ -6183,11 +6272,11 @@ package body Sem_Res is\n          Apply_Access_Check (N);\n          Array_Type := Designated_Type (Array_Type);\n \n-         --  If the prefix is an access to an unconstrained array, we must\n-         --  use the actual subtype of the object to perform the index checks.\n-         --  The object denoted by the prefix is implicit in the node, so we\n-         --  build an explicit representation for it in order to compute the\n-         --  actual subtype.\n+         --  If the prefix is an access to an unconstrained array, we must use\n+         --  the actual subtype of the object to perform the index checks. The\n+         --  object denoted by the prefix is implicit in the node, so we build\n+         --  an explicit representation for it in order to compute the actual\n+         --  subtype.\n \n          if not Is_Constrained (Array_Type) then\n             Remove_Side_Effects (Prefix (N));\n@@ -6214,8 +6303,8 @@ package body Sem_Res is\n \n       Set_Etype (N, Array_Type);\n \n-      --  If the range is specified by a subtype mark, no resolution\n-      --  is necessary. Else resolve the bounds, and apply needed checks.\n+      --  If the range is specified by a subtype mark, no resolution is\n+      --  necessary. Else resolve the bounds, and apply needed checks.\n \n       if not Is_Entity_Name (Drange) then\n          Index := First_Index (Array_Type);\n@@ -6246,13 +6335,13 @@ package body Sem_Res is\n    begin\n       --  For a string appearing in a concatenation, defer creation of the\n       --  string_literal_subtype until the end of the resolution of the\n-      --  concatenation, because the literal may be constant-folded away.\n-      --  This is a useful optimization for long concatenation expressions.\n+      --  concatenation, because the literal may be constant-folded away. This\n+      --  is a useful optimization for long concatenation expressions.\n \n-      --  If the string is an aggregate built for a single character  (which\n+      --  If the string is an aggregate built for a single character (which\n       --  happens in a non-static context) or a is null string to which special\n-      --  checks may apply, we build the subtype. Wide strings must also get\n-      --  a string subtype if they come from a one character aggregate. Strings\n+      --  checks may apply, we build the subtype. Wide strings must also get a\n+      --  string subtype if they come from a one character aggregate. Strings\n       --  generated by attributes might be static, but it is often hard to\n       --  determine whether the enclosing context is static, so we generate\n       --  subtypes for them as well, thus losing some rarer optimizations ???\n@@ -6311,15 +6400,15 @@ package body Sem_Res is\n       if Strlen = 0 then\n          return;\n \n-      --  Always accept string literal with component type Any_Character,\n-      --  which occurs in error situations and in comparisons of literals,\n-      --  both of which should accept all literals.\n+      --  Always accept string literal with component type Any_Character, which\n+      --  occurs in error situations and in comparisons of literals, both of\n+      --  which should accept all literals.\n \n       elsif R_Typ = Any_Character then\n          return;\n \n-      --  If the type is bit-packed, then we always tranform the string\n-      --  literal into a full fledged aggregate.\n+      --  If the type is bit-packed, then we always tranform the string literal\n+      --  into a full fledged aggregate.\n \n       elsif Is_Bit_Packed_Array (Typ) then\n          null;\n@@ -6335,14 +6424,14 @@ package body Sem_Res is\n          if R_Typ = Standard_Wide_Wide_Character then\n             null;\n \n-         --  For the case of Standard.String, or any other type whose\n-         --  component type is Standard.Character, we must make sure that\n-         --  there are no wide characters in the string, i.e. that it is\n-         --  entirely composed of characters in range of type Character.\n+         --  For the case of Standard.String, or any other type whose component\n+         --  type is Standard.Character, we must make sure that there are no\n+         --  wide characters in the string, i.e. that it is entirely composed\n+         --  of characters in range of type Character.\n \n-         --  If the string literal is the result of a static concatenation,\n-         --  the test has already been performed on the components, and need\n-         --  not be repeated.\n+         --  If the string literal is the result of a static concatenation, the\n+         --  test has already been performed on the components, and need not be\n+         --  repeated.\n \n          elsif R_Typ = Standard_Character\n            and then Nkind (Original_Node (N)) /= N_Op_Concat\n@@ -6398,11 +6487,11 @@ package body Sem_Res is\n             null;\n          end if;\n \n-         --  See if the component type of the array corresponding to the\n-         --  string has compile time known bounds. If yes we can directly\n-         --  check whether the evaluation of the string will raise constraint\n-         --  error. Otherwise we need to transform the string literal into\n-         --  the corresponding character aggregate and let the aggregate\n+         --  See if the component type of the array corresponding to the string\n+         --  has compile time known bounds. If yes we can directly check\n+         --  whether the evaluation of the string will raise constraint error.\n+         --  Otherwise we need to transform the string literal into the\n+         --  corresponding character aggregate and let the aggregate\n          --  code do the checking.\n \n          if R_Typ = Standard_Character\n@@ -6457,9 +6546,9 @@ package body Sem_Res is\n          C    : Char_Code;\n \n       begin\n-         --  Build the character literals, we give them source locations\n-         --  that correspond to the string positions, which is a bit tricky\n-         --  given the possible presence of wide character escape sequences.\n+         --  Build the character literals, we give them source locations that\n+         --  correspond to the string positions, which is a bit tricky given\n+         --  the possible presence of wide character escape sequences.\n \n          for J in 1 .. Strlen loop\n             C := Get_String_Char (Str, J);\n@@ -6666,6 +6755,14 @@ package body Sem_Res is\n                   Opnd_Type := Etype (Opnd_Type);\n                end if;\n \n+               --  Handle subtypes\n+\n+               if Ekind (Opnd_Type) = E_Protected_Subtype\n+                 or else Ekind (Opnd_Type) = E_Task_Subtype\n+               then\n+                  Opnd_Type := Etype (Opnd_Type);\n+               end if;\n+\n                if not Interface_Present_In_Ancestor\n                         (Typ   => Opnd_Type,\n                          Iface => Target_Type)\n@@ -6686,20 +6783,7 @@ package body Sem_Res is\n                   end if;\n \n                else\n-                  --  If a conversion to an interface type appears as an actual\n-                  --  in a source call, it will be expanded when the enclosing\n-                  --  call itself is examined in Expand_Interface_Formals.\n-                  --  Otherwise, generate the proper conversion code now, using\n-                  --  the tag of the interface.\n-\n-                  if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n-                        or else Nkind (Parent (N)) = N_Function_Call)\n-                    and then Comes_From_Source (N)\n-                  then\n-                     null;\n-                  else\n-                     Expand_Interface_Conversion (N);\n-                  end if;\n+                  Expand_Interface_Conversion (N);\n                end if;\n             end;\n          end if;\n@@ -6989,29 +7073,85 @@ package body Sem_Res is\n    --------------------------------\n \n    procedure Set_String_Literal_Subtype (N : Node_Id; Typ : Entity_Id) is\n+      Loc        : constant Source_Ptr := Sloc (N);\n+      Low_Bound  : constant Node_Id :=\n+                        Type_Low_Bound (Etype (First_Index (Typ)));\n       Subtype_Id : Entity_Id;\n \n    begin\n       if Nkind (N) /= N_String_Literal then\n          return;\n-      else\n-         Subtype_Id := Create_Itype (E_String_Literal_Subtype, N);\n       end if;\n \n+      Subtype_Id := Create_Itype (E_String_Literal_Subtype, N);\n       Set_String_Literal_Length (Subtype_Id, UI_From_Int\n                                                (String_Length (Strval (N))));\n-      Set_Etype                 (Subtype_Id, Base_Type (Typ));\n-      Set_Is_Constrained        (Subtype_Id);\n+      Set_Etype          (Subtype_Id, Base_Type (Typ));\n+      Set_Is_Constrained (Subtype_Id);\n+      Set_Etype          (N, Subtype_Id);\n+\n+      if Is_OK_Static_Expression (Low_Bound) then\n \n       --  The low bound is set from the low bound of the corresponding\n       --  index type. Note that we do not store the high bound in the\n-      --  string literal subtype, but it can be deduced if necssary\n+      --  string literal subtype, but it can be deduced if necessary\n       --  from the length and the low bound.\n \n-      Set_String_Literal_Low_Bound\n-        (Subtype_Id, Type_Low_Bound (Etype (First_Index (Typ))));\n+         Set_String_Literal_Low_Bound (Subtype_Id, Low_Bound);\n \n-      Set_Etype (N, Subtype_Id);\n+      else\n+         Set_String_Literal_Low_Bound\n+           (Subtype_Id, Make_Integer_Literal (Loc, 1));\n+         Set_Etype (String_Literal_Low_Bound (Subtype_Id), Standard_Positive);\n+\n+         --  Build bona fide subtypes for the string, and wrap it in an\n+         --  unchecked conversion, because the backend expects  the\n+         --  String_Literal_Subtype to have a static lower bound.\n+\n+         declare\n+            Index_List    : constant List_Id    := New_List;\n+            Index_Type    : constant Entity_Id := Etype (First_Index (Typ));\n+            High_Bound    : constant Node_Id :=\n+                               Make_Op_Add (Loc,\n+                                  Left_Opnd => New_Copy_Tree (Low_Bound),\n+                                  Right_Opnd =>\n+                                    Make_Integer_Literal (Loc,\n+                                      String_Length (Strval (N)) - 1));\n+            Array_Subtype : Entity_Id;\n+            Index_Subtype : Entity_Id;\n+            Drange        : Node_Id;\n+            Index         : Node_Id;\n+\n+         begin\n+            Index_Subtype :=\n+              Create_Itype (Subtype_Kind (Ekind (Index_Type)), N);\n+            Drange := Make_Range (Loc, Low_Bound, High_Bound);\n+            Set_Scalar_Range (Index_Subtype, Drange);\n+            Set_Parent (Drange, N);\n+            Analyze_And_Resolve (Drange, Index_Type);\n+\n+            Set_Etype        (Index_Subtype, Index_Type);\n+            Set_Size_Info    (Index_Subtype, Index_Type);\n+            Set_RM_Size      (Index_Subtype, RM_Size (Index_Type));\n+\n+            Array_Subtype := Create_Itype (E_Array_Subtype, N);\n+\n+            Index := New_Occurrence_Of (Index_Subtype, Loc);\n+            Set_Etype (Index, Index_Subtype);\n+            Append (Index, Index_List);\n+\n+            Set_First_Index    (Array_Subtype, Index);\n+            Set_Etype          (Array_Subtype, Base_Type (Typ));\n+            Set_Is_Constrained (Array_Subtype, True);\n+            Init_Size_Align    (Array_Subtype);\n+\n+            Rewrite (N,\n+              Make_Unchecked_Type_Conversion (Loc,\n+                Subtype_Mark => New_Occurrence_Of (Array_Subtype, Loc),\n+                Expression => Relocate_Node (N)));\n+            Set_Etype (N, Array_Subtype);\n+         end;\n+      end if;\n    end Set_String_Literal_Subtype;\n \n    -----------------------------\n@@ -7349,19 +7489,35 @@ package body Sem_Res is\n                   Next_Index (Opnd_Index);\n                end loop;\n \n-               if Base_Type (Target_Comp_Type) /=\n-                 Base_Type (Opnd_Comp_Type)\n-               then\n-                  Error_Msg_N\n-                    (\"incompatible component types for array conversion\",\n-                     Operand);\n-                  return False;\n+               declare\n+                  BT : constant Entity_Id := Base_Type (Target_Comp_Type);\n+                  BO : constant Entity_Id := Base_Type (Opnd_Comp_Type);\n \n-               elsif\n-                  Is_Constrained (Target_Comp_Type)\n-                    /= Is_Constrained (Opnd_Comp_Type)\n-                  or else not Subtypes_Statically_Match\n-                                (Target_Comp_Type, Opnd_Comp_Type)\n+               begin\n+                  if BT = BO then\n+                     null;\n+\n+                  elsif\n+                    (Ekind (BT) = E_Anonymous_Access_Type\n+                       or else Ekind (BT) = E_Anonymous_Access_Subprogram_Type)\n+                    and then Ekind (BO) = Ekind (BT)\n+                    and then Subtypes_Statically_Match\n+                               (Target_Comp_Type,  Opnd_Comp_Type)\n+                  then\n+                     null;\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"incompatible component types for array conversion\",\n+                        Operand);\n+                     return False;\n+                  end if;\n+               end;\n+\n+               if Is_Constrained (Target_Comp_Type) /=\n+                    Is_Constrained (Opnd_Comp_Type)\n+                 or else not Subtypes_Statically_Match\n+                               (Target_Comp_Type, Opnd_Comp_Type)\n                then\n                   Error_Msg_N\n                     (\"component subtypes must statically match\", Operand);\n@@ -7396,8 +7552,7 @@ package body Sem_Res is\n                     (\"?cannot convert local pointer to non-local access type\",\n                      Operand);\n                   Error_Msg_N\n-                    (\"?Program_Error will be raised at run time\", Operand);\n-\n+                    (\"\\?Program_Error will be raised at run time\", Operand);\n                else\n                   Error_Msg_N\n                     (\"cannot convert local pointer to non-local access type\",\n@@ -7417,8 +7572,8 @@ package body Sem_Res is\n                --  handles checking the prefix of the operand for this case.)\n \n                if Nkind (Operand) = N_Selected_Component\n-                 and then Object_Access_Level (Operand)\n-                   > Type_Access_Level (Target_Type)\n+                 and then Object_Access_Level (Operand) >\n+                            Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we\n                   --  know will fail, so generate an appropriate warning.\n@@ -7429,8 +7584,7 @@ package body Sem_Res is\n                        (\"?cannot convert access discriminant to non-local\" &\n                         \" access type\", Operand);\n                      Error_Msg_N\n-                       (\"?Program_Error will be raised at run time\", Operand);\n-\n+                       (\"\\?Program_Error will be raised at run time\", Operand);\n                   else\n                      Error_Msg_N\n                        (\"cannot convert access discriminant to non-local\" &\n@@ -7499,7 +7653,7 @@ package body Sem_Res is\n                     (\"?cannot convert local pointer to non-local access type\",\n                      Operand);\n                   Error_Msg_N\n-                    (\"?Program_Error will be raised at run time\", Operand);\n+                    (\"\\?Program_Error will be raised at run time\", Operand);\n \n                else\n                   Error_Msg_N\n@@ -7533,7 +7687,8 @@ package body Sem_Res is\n                        (\"?cannot convert access discriminant to non-local\" &\n                         \" access type\", Operand);\n                      Error_Msg_N\n-                       (\"?Program_Error will be raised at run time\", Operand);\n+                       (\"\\?Program_Error will be raised at run time\",\n+                        Operand);\n \n                   else\n                      Error_Msg_N"}]}