{"sha": "909e2256221436f25d53bd2fec7cf85634cdb8ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA5ZTIyNTYyMjE0MzZmMjVkNTNiZDJmZWM3Y2Y4NTYzNGNkYjhlYw==", "commit": {"author": {"name": "Jon Grimm", "email": "jgrimm2@us.ibm.com", "date": "2005-12-02T02:30:42Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2005-12-02T02:30:42Z"}, "message": "dfp.h, dfp.c: New files.\n\n2005-12-02  Jon Grimm  <jgrimm2@us.ibm.com>\n\t    Janis Johnson  <janis187@us.ibm.com>\n\t    David Edelsohn  <dje@watson.ibm.com>\n\t    Ben Elliston  <bje@au.ibm.com>\n\n\t* dfp.h, dfp.c: New files.\n\t* Makefile.in (DECNUM, DECNUMINC, LIBDECNUMBER): New variables.\n\t(DECNUM_H): Likewise.\n\t(LIBDEPS, LIBS, BACKEND): Append $(LIBDECNUMBER).\n\t(INCLUDES): Append $(DECNUMINC).\n\t(OBJS-common): Add dfp.o.\n\t(dfp.o): New rule.\n\t* real.h (EXP_BITS): Pinch one bit to ..\n\t(struct real_value): Add decimal field.\n\t(real_format): Change table size, update documentation.\n\t(REAL_MODE_FORMAT): Update for to handle float, decimal float.\n\t(real_from_string3): Declare.\n\t(decimal_single_format): Declare.\n\t(decimal_double_format): Declare.\n\t(decimal_quad_format): Declare.\n\t(REAL_VALUE_TO_TARGET_DECIMAL32): New.\n\t(REAL_VALUE_TO_TARGET_DECIMAL64): New.\n\t(REAL_VALUE_TO_TARGET_DECIMAL128): New.\n\t* real.c: Include dfp.h.\n\t(normalize): Early return for decimal floats.\n\t(do_add): Zero decimal field.\n\t(do_compare): Call do_decimal_compare for decimal floats.\n\t(do_fix_trunc): Likewise, call decimal_do_fix_trunc.\n\t(real_arithmetic): Call decimal_real_arithmetic for decimal\n\tfloating point operands.\n\t(real_identical): If a and b are of differing radix, return false.\n\t(real_to_integer): Call decimal_real_to_integer if the value is a\n\tdecimal float.\n\t(real_to_integer2): Likewise, call decimal_real_to_integer2.\n\t(real_to_decimal): Likewise, call decimal_real_to_decimal.\n\t(real_to_hexadecimal): Place \"N/A\" in the return string for\n\tdecimal float.\n\t(real_from_string3): New variant, given a mode.\n\t(real_maxval): Use decimal_real_maxval for decimal floats.\n\t(round_for_format): Use decimal_round_for_format for decimals.\n\t(real_convert): Use decimal_real_convert where appropriate.\n\t(significand_size): Handle base 10.\n\t(encode_decimal_single, decode_decimal_single,\n\tencode_decimal_double, decode_decimal_double, encode_decimal_quad,\n\tdecode_decimal_quad): New functions.\n\t(decimal_single_format): New.\n\t(decimal_double_format): New.\n\t(decimal_quad_format): New.\n\t* machmode.def: Add SD, DD and TD decimal floating point modes.\n\t* machmode.h (FLOAT_MODE_P, SCALAR_FLOAT_MODE_P, MODES_WIDEN_P):\n\tInclude MODE_DECIMAL_FLOAT.\n\t(DECIMAL_FLOAT_MODE_P): New.\n\t* mode-classes.def (MODE_DECIMAL_FLOAT): New mode class.\n\t* genmodes.c (struct mode_data): Add counter field.\n\t(struct mode_data): Update comment for format.\n\t(blank_mode): Initialise counter field.\n\t(new_mode): Increment counter field for each mode defined.\n\t(complete_mode): Handle MODE_DECIMAL_FLOAT, update check for mode\n\tusing a format.\n\t(make_complex_modes): Handle modes containing `D'.\n\t(DECIMAL_FLOAT_MODE, FRACTIONAL_DECIMAL_FLOAT_MODE): New.\n\t(make_decimal_float_mode): New.\n\t(reset_float_format): Handle MODE_DECIMAL_FLOAT.\n\t(cmp_modes): Compare counter field if other characteristics\n\tsimilar.\n\t(emit_real_format_for_mode): Support formats for decimal floats.\n\t* doc/rtl.texi (Machine Modes): Document SD, DD and TDmodes.\n\tDocument MODE_DECIMAL_FLOAT.\n\nCo-Authored-By: Ben Elliston <bje@au.ibm.com>\nCo-Authored-By: David Edelsohn <dje@watson.ibm.com>\nCo-Authored-By: Janis Johnson <janis187@us.ibm.com>\n\nFrom-SVN: r107861", "tree": {"sha": "50f43816a8c573b7d0fa0fd8a2d390dce801a672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50f43816a8c573b7d0fa0fd8a2d390dce801a672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/909e2256221436f25d53bd2fec7cf85634cdb8ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909e2256221436f25d53bd2fec7cf85634cdb8ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/909e2256221436f25d53bd2fec7cf85634cdb8ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/909e2256221436f25d53bd2fec7cf85634cdb8ec/comments", "author": null, "committer": null, "parents": [{"sha": "8da15291d0387b0391e4842e841561d63ea636de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da15291d0387b0391e4842e841561d63ea636de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da15291d0387b0391e4842e841561d63ea636de"}], "stats": {"total": 1198, "additions": 1165, "deletions": 33}, "files": [{"sha": "ea64c3b95e80433a208a716e1e9a24270764321e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -1,3 +1,72 @@\n+2005-12-02  Jon Grimm  <jgrimm2@us.ibm.com>\n+\t    Janis Johnson  <janis187@us.ibm.com>\n+\t    David Edelsohn  <dje@watson.ibm.com>\n+\t    Ben Elliston  <bje@au.ibm.com>\n+\n+\t* dfp.h, dfp.c: New files.\n+\t* Makefile.in (DECNUM, DECNUMINC, LIBDECNUMBER): New variables.\n+\t(DECNUM_H): Likewise.\n+\t(LIBDEPS, LIBS, BACKEND): Append $(LIBDECNUMBER).\n+\t(INCLUDES): Append $(DECNUMINC).\n+\t(OBJS-common): Add dfp.o.\n+\t(dfp.o): New rule.\n+\t* real.h (EXP_BITS): Pinch one bit to ..\n+\t(struct real_value): Add decimal field.\n+\t(real_format): Change table size, update documentation.\n+\t(REAL_MODE_FORMAT): Update for to handle float, decimal float.\n+\t(real_from_string3): Declare.\n+\t(decimal_single_format): Declare.\n+\t(decimal_double_format): Declare.\n+\t(decimal_quad_format): Declare.\n+\t(REAL_VALUE_TO_TARGET_DECIMAL32): New.\n+\t(REAL_VALUE_TO_TARGET_DECIMAL64): New.\n+\t(REAL_VALUE_TO_TARGET_DECIMAL128): New.\n+\t* real.c: Include dfp.h.\n+\t(normalize): Early return for decimal floats.\n+\t(do_add): Zero decimal field.\n+\t(do_compare): Call do_decimal_compare for decimal floats.\n+\t(do_fix_trunc): Likewise, call decimal_do_fix_trunc.\n+\t(real_arithmetic): Call decimal_real_arithmetic for decimal\n+\tfloating point operands.\n+\t(real_identical): If a and b are of differing radix, return false.\n+\t(real_to_integer): Call decimal_real_to_integer if the value is a\n+\tdecimal float.\n+\t(real_to_integer2): Likewise, call decimal_real_to_integer2.\n+\t(real_to_decimal): Likewise, call decimal_real_to_decimal.\n+\t(real_to_hexadecimal): Place \"N/A\" in the return string for\n+\tdecimal float.\n+\t(real_from_string3): New variant, given a mode.\n+\t(real_maxval): Use decimal_real_maxval for decimal floats.\n+\t(round_for_format): Use decimal_round_for_format for decimals.\n+\t(real_convert): Use decimal_real_convert where appropriate.\n+\t(significand_size): Handle base 10.\n+\t(encode_decimal_single, decode_decimal_single,\n+\tencode_decimal_double, decode_decimal_double, encode_decimal_quad,\n+\tdecode_decimal_quad): New functions.\n+\t(decimal_single_format): New.\n+\t(decimal_double_format): New.\n+\t(decimal_quad_format): New.\n+\t* machmode.def: Add SD, DD and TD decimal floating point modes.\n+\t* machmode.h (FLOAT_MODE_P, SCALAR_FLOAT_MODE_P, MODES_WIDEN_P):\n+\tInclude MODE_DECIMAL_FLOAT.\n+\t(DECIMAL_FLOAT_MODE_P): New.\n+\t* mode-classes.def (MODE_DECIMAL_FLOAT): New mode class.\n+\t* genmodes.c (struct mode_data): Add counter field.\n+\t(struct mode_data): Update comment for format.\n+\t(blank_mode): Initialise counter field.\n+\t(new_mode): Increment counter field for each mode defined.\n+\t(complete_mode): Handle MODE_DECIMAL_FLOAT, update check for mode\n+\tusing a format.\n+\t(make_complex_modes): Handle modes containing `D'.\n+\t(DECIMAL_FLOAT_MODE, FRACTIONAL_DECIMAL_FLOAT_MODE): New.\n+\t(make_decimal_float_mode): New.\n+\t(reset_float_format): Handle MODE_DECIMAL_FLOAT.\n+\t(cmp_modes): Compare counter field if other characteristics\n+\tsimilar.\n+\t(emit_real_format_for_mode): Support formats for decimal floats.\n+\t* doc/rtl.texi (Machine Modes): Document SD, DD and TDmodes.\n+\tDocument MODE_DECIMAL_FLOAT.\n+\n 2005-12-02  Alan Modra  <amodra@bigpond.net.au>\n \n \t* simplify-rtx.c (simplify_plus_minus): Do simplify constants."}, {"sha": "a464dd23e27d3be8729618facd587990394eb3ff", "filename": "gcc/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -298,6 +298,11 @@ GMPINC = @GMPINC@\n CPPLIB = ../libcpp/libcpp.a\n CPPINC = -I$(srcdir)/../libcpp/include\n \n+# Where to find decNumber\n+DECNUM = $(srcdir)/../libdecnumber\n+DECNUMINC = -I$(DECNUM)\n+LIBDECNUMBER = ../libdecnumber/libdecnumber.a\n+\n # Substitution type for target's getgroups 2nd arg.\n TARGET_GETGROUPS_T = @TARGET_GETGROUPS_T@\n \n@@ -766,6 +771,8 @@ SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h\n PREDICT_H = predict.h predict.def\n CPPLIB_H = $(srcdir)/../libcpp/include/line-map.h \\\n \t$(srcdir)/../libcpp/include/cpplib.h\n+DECNUM_H = $(DECNUM)/decContext.h $(DECNUM)/decDPD.h $(DECNUM)/decNumber.h \\\n+\t$(DECNUM)/decimal32.h $(DECNUM)/decimal64.h $(DECNUM)/decimal128.h\n MKDEPS_H = $(srcdir)/../libcpp/include/mkdeps.h\n SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h\n CPP_ID_DATA_H = $(CPPLIB_H) $(srcdir)/../libcpp/include/cpp-id-data.h\n@@ -806,15 +813,15 @@ LIBIBERTY = ../libiberty/libiberty.a\n BUILD_LIBIBERTY = $(build_objdir)/libiberty/libiberty.a\n \n # Dependencies on the intl and portability libraries.\n-LIBDEPS= $(CPPLIB) $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP)\n+LIBDEPS= $(CPPLIB) $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP) $(LIBDECNUMBER)\n \n # Likewise, for use in the tools that must run on this machine\n # even if we are cross-building GCC.\n BUILD_LIBDEPS= $(BUILD_LIBIBERTY)\n \n # How to link with both our special library facilities\n # and the system's installed libraries.\n-LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY)\n+LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER)\n \n # Any system libraries needed just for GNAT.\n SYSLIBS = @GNAT_LIBEXC@\n@@ -844,7 +851,7 @@ BUILD_VARRAY = build/varray.o\n # libintl.h will be found in ../intl if we are using the included libintl.\n INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \\\n \t   -I$(srcdir)/../include @INCINTL@ \\\n-\t   $(CPPINC) $(GMPINC)\n+\t   $(CPPINC) $(GMPINC) $(DECNUMINC)\n \n .c.o:\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)\n@@ -963,7 +970,7 @@ OBJS-common = \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n  cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o \t   \\\n  dbxout.o ddg.o tree-ssa-loop-ch.o loop-invariant.o tree-ssa-loop-im.o\t   \\\n- debug.o df.o diagnostic.o dojump.o dominance.o loop-doloop.o\t\t   \\\n+ debug.o df.o dfp.o diagnostic.o dojump.o dominance.o loop-doloop.o\t   \\\n  dwarf2asm.o dwarf2out.o emit-rtl.o except.o explow.o loop-iv.o\t\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n  genrtl.o ggc-common.o global.o graph.o gtype-desc.o\t\t\t   \\\n@@ -997,7 +1004,7 @@ OBJS = $(OBJS-common) $(out_object_file) $(OBJS-archive)\n \n OBJS-onestep = libbackend.o $(OBJS-archive)\n \n-BACKEND = main.o @TREEBROWSER@ libbackend.a $(CPPLIB)\n+BACKEND = main.o @TREEBROWSER@ libbackend.a $(CPPLIB) $(LIBDECNUMBER)\n \n # Files to be copied after each stage in building.\n STAGECOPYSTUFF = insn-flags.h insn-config.h insn-codes.h \\\n@@ -2146,6 +2153,8 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h tree-pass.h gt-emit-rtl.h\n real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    toplev.h $(TM_P_H) real.h\n+dfp.o : dfp.c dfp.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t$(TREE_H) \\\n+   toplev.h $(TM_P_H) real.h $(DECNUM_H)\n integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) $(FLAGS_H) debug.h $(INTEGRATE_H) insn-config.h \\\n    $(EXPR_H) real.h $(REGS_H) intl.h function.h output.h $(RECOG_H) \\"}, {"sha": "ab0575174807aca269545c6ecc0f29a4a321a490", "filename": "gcc/dfp.c", "status": "added", "additions": 725, "deletions": 0, "changes": 725, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fdfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fdfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.c?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -0,0 +1,725 @@\n+/* Decimal floating point support.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"toplev.h\"\n+#include \"real.h\"\n+#include \"tm_p.h\"\n+#include \"dfp.h\"\n+\n+/* The order of the following headers is important for making sure\n+   decNumber structure is large enough to hold decimal128 digits.  */\n+\n+#include \"decimal128.h\"\n+#include \"decimal64.h\"\n+#include \"decimal32.h\"\n+#include \"decNumber.h\"\n+\n+static unsigned long\n+dfp_byte_swap (unsigned long in)\n+{\n+  unsigned long out;\n+  unsigned char *p = (unsigned char *) &out;\n+  union {\n+    unsigned long i;\n+    unsigned char b[4];\n+  } u;\n+\n+  u.i = in;\n+  p[0] = u.b[3];\n+  p[1] = u.b[2];\n+  p[2] = u.b[1];\n+  p[3] = u.b[0];\n+\n+  return out;\n+}\n+\n+/* Initialize R (a real with the decimal flag set) from DN.  Can\n+   utilize status passed in via CONTEXT, if a previous operation had\n+   interesting status.  */\n+\n+static void\n+decimal_from_decnumber (REAL_VALUE_TYPE *r, decNumber *dn, decContext *context)\n+{\n+  memset (r, 0, sizeof (REAL_VALUE_TYPE));\n+\n+  r->cl = rvc_normal;\n+  if (decNumberIsZero (dn))\n+    r->cl = rvc_zero;\n+  if (decNumberIsNaN (dn))\n+    r->cl = rvc_nan;\n+  if (decNumberIsInfinite (dn))\n+    r->cl = rvc_inf;\n+  if (context->status & DEC_Overflow)\n+    r->cl = rvc_inf;\n+  if (decNumberIsNegative (dn))\n+    r->sign = 1;\n+  r->decimal = 1;\n+\n+  if (r->cl != rvc_normal)\n+    return;\n+\n+  decContextDefault (context, DEC_INIT_DECIMAL128);\n+  context->traps = 0;\n+\n+  decimal128FromNumber ((decimal128 *) r->sig, dn, context);\n+}\n+\n+/* Create decimal encoded R from string S.  */\n+\n+void\n+decimal_real_from_string (REAL_VALUE_TYPE *r, const char *s)\n+{\n+  decNumber dn;\n+  decContext set;\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  decNumberFromString (&dn, (char *) s, &set);\n+\n+  /* It would be more efficient to store directly in decNumber format,\n+     but that is impractical from current data structure size.\n+     Encoding as a decimal128 is much more compact.  */\n+  decimal_from_decnumber (r, &dn, &set);\n+}\n+\n+/* Initialize a decNumber from a REAL_VALUE_TYPE.  */\n+\n+static void\n+decimal_to_decnumber (const REAL_VALUE_TYPE *r, decNumber *dn)\n+{\n+  decContext set;\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  switch (r->cl)\n+    {\n+    case rvc_zero:\n+      decNumberZero (dn);\n+      break;\n+    case rvc_inf:\n+      decNumberFromString (dn, (char *)\"Infinity\", &set);\n+      break;\n+    case rvc_nan:\n+      if (r->signalling)\n+        decNumberFromString (dn, (char *)\"snan\", &set);\n+      else\n+        decNumberFromString (dn, (char *)\"nan\", &set);\n+      break;\n+    case rvc_normal:\n+      gcc_assert (r->decimal);\n+      decimal128ToNumber ((decimal128 *) r->sig, dn);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Fix up sign bit.  */\n+  if (r->sign != decNumberIsNegative (dn))\n+    decNumberNegate (dn);\n+}\n+\n+/* Encode a real into an IEEE 754R decimal32 type.  */\n+\n+void \n+encode_decimal32 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t  long *buf, const REAL_VALUE_TYPE *r)\n+{\n+  decNumber dn;\n+  decimal32 d32;\n+  decContext set;\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  decimal_to_decnumber (r, &dn); \n+  decimal32FromNumber (&d32, &dn, &set);\n+\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    buf[0] = *(uint32_t *) d32.bytes;\n+  else\n+    buf[0] = dfp_byte_swap (*(uint32_t *) d32.bytes);\n+}\n+\n+/* Decode an IEEE 754R decimal32 type into a real.  */\n+\n+void decode_decimal32 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t       REAL_VALUE_TYPE *r, const long *buf)\n+{\n+  decNumber dn;\n+  decimal32 d32;\n+  decContext set;\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    *((uint32_t *) d32.bytes) = (uint32_t) buf[0];\n+  else\n+    *((uint32_t *) d32.bytes) = dfp_byte_swap ((uint32_t) buf[0]);\n+\n+  decimal32ToNumber (&d32, &dn);\n+  decimal_from_decnumber (r, &dn, &set); \n+}\n+\n+/* Encode a real into an IEEE 754R decimal64 type.  */\n+\n+void \n+encode_decimal64 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t  long *buf, const REAL_VALUE_TYPE *r)\n+{\n+  decNumber dn;\n+  decimal64 d64;\n+  decContext set;\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  decimal_to_decnumber (r, &dn);\n+  decimal64FromNumber (&d64, &dn, &set);\n+\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      buf[0] = *(uint32_t *) &d64.bytes[0];\n+      buf[1] = *(uint32_t *) &d64.bytes[4];\n+    }\n+  else\n+    {\n+      buf[1] = dfp_byte_swap (*(uint32_t *) &d64.bytes[0]);\n+      buf[0] = dfp_byte_swap (*(uint32_t *) &d64.bytes[4]);\n+    }\n+}\n+\n+/* Decode an IEEE 754R decimal64 type into a real.  */\n+\n+void \n+decode_decimal64 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t  REAL_VALUE_TYPE *r, const long *buf)\n+{ \n+  decNumber dn;\n+  decimal64 d64;\n+  decContext set;\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      *((uint32_t *) &d64.bytes[0]) = (uint32_t) buf[0];\n+      *((uint32_t *) &d64.bytes[4]) = (uint32_t) buf[1];\n+    }\n+  else\n+    {\n+      *((uint32_t *) &d64.bytes[0]) = dfp_byte_swap ((uint32_t) buf[1]);\n+      *((uint32_t *) &d64.bytes[4]) = dfp_byte_swap ((uint32_t) buf[0]); \n+    }\n+\n+  decimal64ToNumber (&d64, &dn);\n+  decimal_from_decnumber (r, &dn, &set); \n+}\n+\n+/* Encode a real into an IEEE 754R decimal128 type.  */\n+\n+void \n+encode_decimal128 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t   long *buf, const REAL_VALUE_TYPE *r)\n+{\n+  decNumber dn;\n+  decContext set;\n+  decimal128 d128;\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  decimal_to_decnumber (r, &dn);\n+  decimal128FromNumber (&d128, &dn, &set);\n+\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      buf[0] = *(uint32_t *) &d128.bytes[0];\n+      buf[1] = *(uint32_t *) &d128.bytes[4];\n+      buf[2] = *(uint32_t *) &d128.bytes[8];\n+      buf[3] = *(uint32_t *) &d128.bytes[12];\n+    }\n+  else\n+    {\n+      buf[0] = dfp_byte_swap (*(uint32_t *) &d128.bytes[12]);\n+      buf[1] = dfp_byte_swap (*(uint32_t *) &d128.bytes[8]);\n+      buf[2] = dfp_byte_swap (*(uint32_t *) &d128.bytes[4]);\n+      buf[3] = dfp_byte_swap (*(uint32_t *) &d128.bytes[0]);\n+    }\n+}\n+\n+/* Decode an IEEE 754R decimal128 type into a real.  */\n+\n+void \n+decode_decimal128 (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t   REAL_VALUE_TYPE *r, const long *buf)\n+{\n+  decNumber dn;\n+  decimal128 d128;\n+  decContext set;\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  if (FLOAT_WORDS_BIG_ENDIAN)\n+    {\n+      *((uint32_t *) &d128.bytes[0])  = (uint32_t) buf[0];\n+      *((uint32_t *) &d128.bytes[4])  = (uint32_t) buf[1];\n+      *((uint32_t *) &d128.bytes[8])  = (uint32_t) buf[2];\n+      *((uint32_t *) &d128.bytes[12]) = (uint32_t) buf[3];\n+    }\n+  else\n+    {\n+      *((uint32_t *) &d128.bytes[0])  = dfp_byte_swap ((uint32_t) buf[3]);\n+      *((uint32_t *) &d128.bytes[4])  = dfp_byte_swap ((uint32_t) buf[2]);\n+      *((uint32_t *) &d128.bytes[8])  = dfp_byte_swap ((uint32_t) buf[1]);\n+      *((uint32_t *) &d128.bytes[12]) = dfp_byte_swap ((uint32_t) buf[0]);\n+    }\n+\n+  decimal128ToNumber (&d128, &dn);\n+  decimal_from_decnumber (r, &dn, &set); \n+}\n+\n+/* Helper function to convert from a binary real internal\n+   representation.  */\n+\n+static void\n+decimal_to_binary (REAL_VALUE_TYPE *to, const REAL_VALUE_TYPE *from,\n+\t\t   enum machine_mode mode)\n+{\n+  char string[256];\n+  decimal128 *d128;\n+  d128 = (decimal128 *) from->sig;\n+\n+  decimal128ToString (d128, string);\n+  real_from_string3 (to, string, mode);\n+}\n+\n+\n+/* Helper function to convert from a binary real internal\n+   representation.  */\n+\n+static void\n+decimal_from_binary (REAL_VALUE_TYPE *to, const REAL_VALUE_TYPE *from)\n+{\n+  char string[256];\n+\n+  /* We convert to string, then to decNumber then to decimal128.  */\n+  real_to_decimal (string, from, sizeof (string), 0, 1);\n+  decimal_real_from_string (to, string);\n+}\n+\n+/* Helper function to real.c:do_compare() to handle decimal internal\n+   represenation including when one of the operands is still in the\n+   binary internal representation.  */\n+\n+int\n+decimal_do_compare (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b,\n+\t\t    int nan_result)\n+{\n+  decContext set;\n+  decNumber dn, dn2, dn3;\n+  REAL_VALUE_TYPE a1, b1;\n+\n+  /* If either operand is non-decimal, create temporary versions.  */\n+  if (!a->decimal)\n+    {\n+      decimal_from_binary (&a1, a);\n+      a = &a1;\n+    }\n+  if (!b->decimal)\n+    {\n+      decimal_from_binary (&b1, b);\n+      b = &b1;\n+    }\n+    \n+  /* Convert into decNumber form for comparison operation.  */\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;  \n+  decimal128ToNumber ((decimal128 *) a->sig, &dn2);\n+  decimal128ToNumber ((decimal128 *) b->sig, &dn3);\n+\n+  /* Finally, do the comparison.  */\n+  decNumberCompare (&dn, &dn2, &dn3, &set);\n+\n+  /* Return the comparison result.  */\n+  if (decNumberIsNaN (&dn))\n+    return nan_result;\n+  else if (decNumberIsZero (&dn))\n+    return 0;\n+  else if (decNumberIsNegative (&dn))\n+    return -1;\n+  else \n+    return 1;\n+}\n+\n+/* Helper to round_for_format, handling decimal float types.  */\n+\n+void\n+decimal_round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n+{\n+  decNumber dn;\n+  decContext set;\n+\n+  /* Real encoding occurs later.  */\n+  if (r->cl != rvc_normal)\n+    return;\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+  decimal128ToNumber ((decimal128 *) r->sig, &dn);\n+\n+  if (fmt == &decimal_quad_format)\n+    {\n+      /* The internal format is already in this format.  */\n+      return;\n+    }\n+  else if (fmt == &decimal_single_format)\n+    {\n+      decimal32 d32;\n+      decContextDefault (&set, DEC_INIT_DECIMAL32);\n+      set.traps = 0;\n+\n+      decimal32FromNumber (&d32, &dn, &set);\n+      decimal32ToNumber (&d32, &dn);\n+    }\n+  else if (fmt == &decimal_double_format)\n+    {\n+      decimal64 d64;\n+      decContextDefault (&set, DEC_INIT_DECIMAL64);\n+      set.traps = 0;\n+\n+      decimal64FromNumber (&d64, &dn, &set);\n+      decimal64ToNumber (&d64, &dn);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  decimal_from_decnumber (r, &dn, &set);\n+}\n+\n+/* Extend or truncate to a new mode.  Handles conversions between\n+   binary and decimal types.  */\n+\n+void\n+decimal_real_convert (REAL_VALUE_TYPE *r, enum machine_mode mode, \n+\t\t      const REAL_VALUE_TYPE *a)\n+{\n+  const struct real_format *fmt = REAL_MODE_FORMAT (mode);\n+\n+  if (a->decimal && fmt->b == 10)\n+    return;\n+  if (a->decimal)\n+      decimal_to_binary (r, a, mode);\n+  else\n+      decimal_from_binary (r, a);\n+}\n+\n+/* Render R_ORIG as a decimal floating point constant.  Emit DIGITS\n+   significant digits in the result, bounded by BUF_SIZE.  If DIGITS\n+   is 0, choose the maximum for the representation.  If\n+   CROP_TRAILING_ZEROS, strip trailing zeros.  Currently, not honoring\n+   DIGITS or CROP_TRAILING_ZEROS.  */\n+\n+void decimal_real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig,\n+\t\t\t      size_t buf_size,\n+\t\t\t      size_t digits ATTRIBUTE_UNUSED,\n+\t\t\t      int crop_trailing_zeros ATTRIBUTE_UNUSED)\n+{\n+  decimal128 *d128 = (decimal128*) r_orig->sig;\n+\n+  /* decimal128ToString requires space for at least 24 characters;\n+     Require two more for suffix.  */\n+  gcc_assert (buf_size >= 24);\n+  decimal128ToString (d128, str);\n+}\n+\n+static bool\n+decimal_do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0,\n+\t\tconst REAL_VALUE_TYPE *op1, int subtract_p)\n+{\n+  decNumber dn;\n+  decContext set;\n+  decNumber dn2, dn3;\n+\n+  decimal_to_decnumber (op0, &dn2);\n+  decimal_to_decnumber (op1, &dn3);\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  if (subtract_p)\n+    decNumberSubtract (&dn, &dn2, &dn3, &set);\n+  else \n+    decNumberAdd (&dn, &dn2, &dn3, &set);\n+\n+  decimal_from_decnumber (r, &dn, &set);\n+\n+  /* Return true, if inexact.  */\n+  return (set.status & DEC_Inexact);\n+}\n+\n+/* Compute R = OP0 * OP1.  */\n+\n+static bool\n+decimal_do_multiply (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0,\n+\t\t     const REAL_VALUE_TYPE *op1)\n+{\n+  decContext set;\n+  decNumber dn, dn2, dn3;\n+\n+  decimal_to_decnumber (op0, &dn2);\n+  decimal_to_decnumber (op1, &dn3);\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  decNumberMultiply (&dn, &dn2, &dn3, &set);\n+  decimal_from_decnumber (r, &dn, &set);\n+\n+  /* Return true, if inexact.  */\n+  return (set.status & DEC_Inexact);\n+}\n+\n+/* Compute R = OP0 / OP1.  */\n+\n+static bool\n+decimal_do_divide (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *op0,\n+\t\t   const REAL_VALUE_TYPE *op1)\n+{\n+  decContext set;\n+  decNumber dn, dn2, dn3;\n+\n+  decimal_to_decnumber (op0, &dn2);\n+  decimal_to_decnumber (op1, &dn3);\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+\n+  decNumberDivide (&dn, &dn2, &dn3, &set);\n+  decimal_from_decnumber (r, &dn, &set);\n+\n+  /* Return true, if inexact.  */\n+  return (set.status & DEC_Inexact);\n+}\n+\n+/* Set R to A truncated to an integral value toward zero (decimal\n+   floating point).  */\n+\n+void\n+decimal_do_fix_trunc (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n+{\n+  decNumber dn, dn2;\n+  decContext set;\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+  set.round = DEC_ROUND_DOWN;\n+  decimal128ToNumber ((decimal128 *) a->sig, &dn2);\n+\n+  decNumberToIntegralValue (&dn, &dn2, &set);\n+  decimal_from_decnumber (r, &dn, &set);\n+}\n+\n+/* Render decimal float value R as an integer.  */\n+\n+HOST_WIDE_INT\n+decimal_real_to_integer (const REAL_VALUE_TYPE *r)\n+{\n+  decContext set;\n+  decNumber dn, dn2, dn3;\n+  REAL_VALUE_TYPE to;\n+  char string[256];\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+  set.round = DEC_ROUND_DOWN;\n+  decimal128ToNumber ((decimal128 *) r->sig, &dn);\n+\n+  decNumberToIntegralValue (&dn2, &dn, &set);\n+  decNumberZero (&dn3);\n+  decNumberRescale (&dn, &dn2, &dn3, &set);\n+\n+  /* Convert to REAL_VALUE_TYPE and call appropriate conversion\n+     function.  */\n+  decNumberToString (&dn, string);\n+  real_from_string (&to, string);\n+  return real_to_integer (&to);\n+}\n+\n+/* Likewise, but to an integer pair, HI+LOW.  */\n+\n+void\n+decimal_real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n+\t\t\t  const REAL_VALUE_TYPE *r)\n+{\n+  decContext set;\n+  decNumber dn, dn2, dn3;\n+  REAL_VALUE_TYPE to;\n+  char string[256];\n+\n+  decContextDefault (&set, DEC_INIT_DECIMAL128);\n+  set.traps = 0;\n+  set.round = DEC_ROUND_DOWN;\n+  decimal128ToNumber ((decimal128 *) r->sig, &dn);\n+\n+  decNumberToIntegralValue (&dn2, &dn, &set);\n+  decNumberZero (&dn3);\n+  decNumberRescale (&dn, &dn2, &dn3, &set);\n+\n+  /* Conver to REAL_VALUE_TYPE and call appropriate conversion\n+     function.  */\n+  decNumberToString (&dn, string);\n+  real_from_string (&to, string);\n+  real_to_integer2 (plow, phigh, &to);\n+}\n+\n+/* Perform the decimal floating point operation described by COODE.\n+   For a unary operation, leave OP1 NULL.  This function returns true\n+   if the result may be inexact due to loss of precision.  */\n+\n+bool\n+decimal_real_arithmetic (REAL_VALUE_TYPE *r, int icode,\n+\t\t\t const REAL_VALUE_TYPE *op0,\n+\t\t\t const REAL_VALUE_TYPE *op1)\n+{\n+  enum tree_code code = icode;\n+  REAL_VALUE_TYPE a1;\n+  REAL_VALUE_TYPE b1;\n+\n+  /* If either op is not a decimal, create a temporary decimal\n+     versions.  */\n+  if (!op0->decimal)\n+    {\n+      decimal_from_binary (&a1, op0);\n+      op0 = &a1;\n+    }\n+  if (op1 && !op1->decimal)\n+    {\n+      decimal_from_binary (&b1, op1);\n+      op1 = &b1;\n+    }\n+\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      (void) decimal_do_add (r, op0, op1, 0);\n+      break;\n+\n+    case MINUS_EXPR:\n+      (void) decimal_do_add (r, op0, op1, 1);\n+      break;\n+\n+    case MULT_EXPR:\n+      (void) decimal_do_multiply (r, op0, op1);\n+      break;\n+\n+    case RDIV_EXPR:\n+      (void) decimal_do_divide (r, op0, op1);\n+      break;\n+\n+    case MIN_EXPR:\n+      if (op1->cl == rvc_nan)\n+        *r = *op1;\n+      else if (real_compare (UNLT_EXPR, op0, op1))\n+        *r = *op0;\n+      else\n+        *r = *op1;\n+      break;\n+\n+    case MAX_EXPR:\n+      if (op1->cl == rvc_nan)\n+        *r = *op1;\n+      else if (real_compare (LT_EXPR, op0, op1))\n+        *r = *op1;\n+      else\n+        *r = *op0;\n+      break;\n+\n+    case NEGATE_EXPR:\n+      {\n+\tdecimal128 *d128;\n+\t*r = *op0;\n+\td128 = (decimal128 *) r->sig;\n+\t/* Flip high bit.  */\n+\td128->bytes[0] ^= 1 << 7;\n+\t/* Keep sign field in sync.  */\n+\tr->sign ^= 1;\n+      }\n+      break;\n+\n+    case ABS_EXPR:\n+      {\n+        decimal128 *d128;\n+        *r = *op0;\n+        d128 = (decimal128 *) r->sig;\n+\t/* Clear high bit.  */\n+        d128->bytes[0] &= 0x7f;\n+\t/* Keep sign field in sync.  */\n+\tr->sign = 0;\n+      }\n+      break;\n+\n+    case FIX_TRUNC_EXPR:\n+      decimal_do_fix_trunc (r, op0);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* FIXME: Indicate all operations as inexact for now due to unknown\n+     working precision.  */\n+  return true;\n+}\n+\n+/* Fills R with the largest finite value representable in mode MODE.\n+   If SIGN is nonzero, R is set to the most negative finite value.  */\n+\n+void\n+decimal_real_maxval (REAL_VALUE_TYPE *r, int sign, enum machine_mode mode)\n+{ \n+  char *max;\n+\n+  switch (mode)\n+    {\n+    case SDmode:\n+      max = (char *) \"9.999999E96\";\n+      break;\n+    case DDmode:\n+      max = (char *) \"9.999999999999999E384\";\n+      break;\n+    case TDmode:\n+      max = (char *) \"9.999999999999999999999999999999999E6144\";\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  decimal_real_from_string (r, max);\n+  if (sign)\n+    r->sig[0] |= 0x80000000;\n+}"}, {"sha": "d7f5b01cc7dd02fd2d43499f9ba5dabb23d2765d", "filename": "gcc/dfp.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fdfp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fdfp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdfp.h?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -0,0 +1,47 @@\n+/* Decimal floating point support functions for GNU compiler.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#ifndef GCC_DFP_H\n+#define GCC_DFP_H\n+\n+/* Encode REAL_VALUE_TYPEs into 32/64/128-bit IEEE 754R encoded values.  */\n+void encode_decimal32  (const struct real_format *fmt, long *, const REAL_VALUE_TYPE *);\n+void encode_decimal64  (const struct real_format *fmt, long *, const REAL_VALUE_TYPE *);\n+void decode_decimal128 (const struct real_format *, REAL_VALUE_TYPE *, const long *);\n+\n+/* Decode 32/64/128-bit IEEE 754R encoded values into REAL_VALUE_TYPEs.  */\n+void decode_decimal32  (const struct real_format *, REAL_VALUE_TYPE *, const long *);\n+void decode_decimal64  (const struct real_format *, REAL_VALUE_TYPE *, const long *);\n+void encode_decimal128 (const struct real_format *fmt, long *, const REAL_VALUE_TYPE *);\n+\n+/* Arithmetic and conversion functions.  */\n+int  decimal_do_compare (const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *, int);\n+void decimal_real_from_string (REAL_VALUE_TYPE *, const char *);\n+void decimal_round_for_format (const struct real_format *, REAL_VALUE_TYPE *);\n+void decimal_real_convert (REAL_VALUE_TYPE *, enum machine_mode, const REAL_VALUE_TYPE *);\n+void decimal_real_to_decimal (char *, const REAL_VALUE_TYPE *, size_t, size_t, int);\n+void decimal_do_fix_trunc (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n+bool decimal_real_arithmetic (REAL_VALUE_TYPE *, int, const REAL_VALUE_TYPE *,\n+\t\t\t      const REAL_VALUE_TYPE *);\n+void decimal_real_maxval (REAL_VALUE_TYPE *, int, enum machine_mode);\n+void decimal_real_to_integer2 (HOST_WIDE_INT *, HOST_WIDE_INT *, const REAL_VALUE_TYPE *);\n+HOST_WIDE_INT decimal_real_to_integer (const REAL_VALUE_TYPE *);\n+\n+#endif /* GCC_DFP_H */"}, {"sha": "d8ba5df01484c5fdb2d23d3e93cf301d5a7f8e85", "filename": "gcc/genmodes.c", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -60,7 +60,7 @@ struct mode_data\n   unsigned int bytesize;\t/* storage size in addressable units */\n   unsigned int ncomponents;\t/* number of subunits */\n   unsigned int alignment;\t/* mode alignment */\n-  const char *format;\t\t/* floating point format - MODE_FLOAT only */\n+  const char *format;\t\t/* floating point format - float modes only */\n \n   struct mode_data *component;\t/* mode of components */\n   struct mode_data *wider;\t/* next wider mode */\n@@ -72,6 +72,7 @@ struct mode_data\n \n   const char *file;\t\t/* file and line of definition, */\n   unsigned int line;\t\t/* for error reporting */\n+  unsigned int counter;\t\t/* Rank ordering of modes */\n };\n \n static struct mode_data *modes[MAX_MODE_CLASS];\n@@ -82,7 +83,7 @@ static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   -1U, -1U, -1U, -1U,\n   0, 0, 0, 0, 0, 0,\n-  \"<unknown>\", 0\n+  \"<unknown>\", 0, 0\n };\n \n static htab_t modes_by_name;\n@@ -146,6 +147,7 @@ new_mode (enum mode_class cl, const char *name,\n \t  const char *file, unsigned int line)\n {\n   struct mode_data *m;\n+  static unsigned int count = 0;\n \n   m = find_mode (name);\n   if (m)\n@@ -163,6 +165,7 @@ new_mode (enum mode_class cl, const char *name,\n   if (file)\n     m->file = trim_filename (file);\n   m->line = line;\n+  m->counter = count++;\n \n   m->next = modes[cl];\n   modes[cl] = m;\n@@ -323,11 +326,12 @@ complete_mode (struct mode_data *m)\n \n     case MODE_INT:\n     case MODE_FLOAT:\n+    case MODE_DECIMAL_FLOAT:\n       /* A scalar mode must have a byte size, may have a bit size,\n \t and must not have components.   A float mode must have a\n          format.  */\n       validate_mode (m, OPTIONAL, SET, UNSET, UNSET,\n-\t\t     m->cl == MODE_FLOAT ? SET : UNSET);\n+\t\t     m->cl != MODE_INT ? SET : UNSET);\n \n       m->ncomponents = 1;\n       m->component = 0;\n@@ -429,17 +433,22 @@ make_complex_modes (enum mode_class cl,\n          This inconsistency should be eliminated.  */\n       if (cl == MODE_FLOAT)\n \t{\n-\t  char *p;\n+\t  char *p, *q = 0;\n \t  strncpy (buf, m->name, sizeof buf);\n \t  p = strchr (buf, 'F');\n \t  if (p == 0)\n+\t    q = strchr (buf, 'D');\n+\t  if (p == 0 && q == 0)\n \t    {\n-\t      error (\"%s:%d: float mode \\\"%s\\\" has no 'F'\",\n+\t      error (\"%s:%d: float mode \\\"%s\\\" has no 'F' or 'D'\",\n \t\t     m->file, m->line, m->name);\n \t      continue;\n \t    }\n \n-\t  *p = 'C';\n+\t  if (p != 0)\n+\t    *p = 'C';\n+\t  else\n+\t    snprintf (buf, sizeof buf, \"C%s\", m->name);\n \t}\n       else\n \tsnprintf (buf, sizeof buf, \"C%s\", m->name);\n@@ -540,6 +549,23 @@ make_float_mode (const char *name,\n   m->format = format;\n }\n \n+#define DECIMAL_FLOAT_MODE(N, Y, F)\t\\\n+\tFRACTIONAL_DECIMAL_FLOAT_MODE (N, -1U, Y, F)\n+#define FRACTIONAL_DECIMAL_FLOAT_MODE(N, B, Y, F)\t\\\n+  make_decimal_float_mode (#N, B, Y, #F, __FILE__, __LINE__)\n+\n+static void\n+make_decimal_float_mode (const char *name,\n+\t\t\t unsigned int precision, unsigned int bytesize,\n+\t\t\t const char *format,\n+\t\t\t const char *file, unsigned int line)\n+{\n+  struct mode_data *m = new_mode (MODE_DECIMAL_FLOAT, name, file, line);\n+  m->bytesize = bytesize;\n+  m->precision = precision;\n+  m->format = format;\n+}\n+\n #define RESET_FLOAT_FORMAT(N, F) \\\n   reset_float_format (#N, #F, __FILE__, __LINE__)\n static void ATTRIBUTE_UNUSED\n@@ -552,9 +578,9 @@ reset_float_format (const char *name, const char *format,\n       error (\"%s:%d: no mode \\\"%s\\\"\", file, line, name);\n       return;\n     }\n-  if (m->cl != MODE_FLOAT)\n+  if (m->cl != MODE_FLOAT && m->cl != MODE_DECIMAL_FLOAT)\n     {\n-      error (\"%s:%d: mode \\\"%s\\\" is not class FLOAT\", file, line, name);\n+      error (\"%s:%d: mode \\\"%s\\\" is not a FLOAT class\", file, line, name);\n       return;\n     }\n   m->format = format;\n@@ -675,7 +701,12 @@ cmp_modes (const void *a, const void *b)\n     return -1;\n \n   if (!m->component && !n->component)\n-    return 0;\n+    {\n+      if (m->counter < n->counter)\n+\treturn -1;\n+      else\n+\treturn 1;\n+    }\n \n   if (m->component->bytesize > n->component->bytesize)\n     return 1;\n@@ -687,7 +718,10 @@ cmp_modes (const void *a, const void *b)\n   else if (m->component->precision < n->component->precision)\n     return -1;\n \n-  return 0;\n+  if (m->counter < n->counter)\n+    return -1;\n+  else\n+    return 1;\n }\n \n static void\n@@ -1083,15 +1117,24 @@ emit_real_format_for_mode (void)\n \t\t\t  format);\n #else\n   print_decl (\"struct real_format *\\n\", \"real_format_for_mode\",\n-\t      \"MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1\");\n+\t      \"MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1 \"\n+\t      \"+ MAX_MODE_DECIMAL_FLOAT - MIN_MODE_DECIMAL_FLOAT + 1\");\n #endif\n \n+  /* The beginning of the table is entries for float modes.  */\n   for (m = modes[MODE_FLOAT]; m; m = m->next)\n     if (!strcmp (m->format, \"0\"))\n       tagged_printf (\"%s\", m->format, m->name);\n     else\n       tagged_printf (\"&%s\", m->format, m->name);\n \n+  /* The end of the table is entries for decimal float modes.  */\n+  for (m = modes[MODE_DECIMAL_FLOAT]; m; m = m->next)\n+    if (!strcmp (m->format, \"0\"))\n+      tagged_printf (\"%s\", m->format, m->name);\n+    else\n+      tagged_printf (\"&%s\", m->format, m->name);\n+\n   print_closer ();\n }\n "}, {"sha": "ffb675d14f0354c0f6d70d8310e7815a1b8af1d0", "filename": "gcc/machmode.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -87,6 +87,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \tusing floating point format FORMAT.\n \tAll of the bits of its representation are significant.\n \n+     DECIMAL FLOAT_MODE (MODE, BYTESIZE);\n+\tdeclares MODE to be of class DECIMAL_FLOAT and BYTESIZE bytes\n+\twide.  All of the bits of its representation are significant.\n+\n      FRACTIONAL_FLOAT_MODE (MODE, PRECISION, BYTESIZE, FORMAT);\n         declares MODE to be of class FLOAT, BYTESIZE bytes wide in\n \tstorage, but with only PRECISION significant bits, using\n@@ -186,6 +190,11 @@ CC_MODE (CC);\n COMPLEX_MODES (INT);\n COMPLEX_MODES (FLOAT);\n \n+/* Decimal floating point modes.  */\n+DECIMAL_FLOAT_MODE (SD, 4, decimal_single_format);\n+DECIMAL_FLOAT_MODE (DD, 8, decimal_double_format);\n+DECIMAL_FLOAT_MODE (TD, 16, decimal_quad_format);\n+\n /* The symbol Pmode stands for one of the above machine modes (usually SImode).\n    The tm.h file specifies which one.  It is not a distinct mode.  */\n "}, {"sha": "3948fc9388b4d067c16fe1a7c89b24a8fcdd9b4e", "filename": "gcc/machmode.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -54,6 +54,7 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n /* Nonzero if MODE is a floating-point mode.  */\n #define FLOAT_MODE_P(MODE)\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_DECIMAL_FLOAT \\\n    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT \\\n    || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n \n@@ -74,12 +75,18 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n \n /* Nonzero if MODE is a scalar floating point mode.  */\n #define SCALAR_FLOAT_MODE_P(MODE)\t\t\\\n-  (GET_MODE_CLASS (MODE) == MODE_FLOAT)\n+  (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_DECIMAL_FLOAT)\n+\n+/* Nonzero if MODE is a decimal floating point mode.  */\n+#define DECIMAL_FLOAT_MODE_P(MODE)\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_DECIMAL_FLOAT)\n \n /* Nonzero if CLASS modes can be widened.  */\n #define CLASS_HAS_WIDER_MODES_P(CLASS)         \\\n   (CLASS == MODE_INT                           \\\n    || CLASS == MODE_FLOAT                      \\\n+   || CLASS == MODE_DECIMAL_FLOAT              \\\n    || CLASS == MODE_COMPLEX_FLOAT)\n \n /* Get the size in bytes and bits of an object of mode MODE.  */"}, {"sha": "7fc7a9b3c80b4efda2f7182b923843c5b94f7ca2", "filename": "gcc/mode-classes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fmode-classes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Fmode-classes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-classes.def?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -25,6 +25,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n   DEF_MODE_CLASS (MODE_INT),\t\t/* integer */\t\t\t   \\\n   DEF_MODE_CLASS (MODE_PARTIAL_INT),\t/* integer with padding bits */\t   \\\n   DEF_MODE_CLASS (MODE_FLOAT),\t\t/* floating point */\t\t   \\\n+  DEF_MODE_CLASS (MODE_DECIMAL_FLOAT),\t/* decimal floating point */\t   \\\n   DEF_MODE_CLASS (MODE_COMPLEX_INT), \t/* complex numbers */\t\t   \\\n   DEF_MODE_CLASS (MODE_COMPLEX_FLOAT),\t\t\t\t\t   \\\n   DEF_MODE_CLASS (MODE_VECTOR_INT),\t/* SIMD vectors */\t\t   \\"}, {"sha": "043270c4c7d39610aea5acf2e82f44ac0d082a84", "filename": "gcc/real.c", "status": "modified", "additions": 206, "deletions": 11, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -29,6 +29,7 @@\n #include \"toplev.h\"\n #include \"real.h\"\n #include \"tm_p.h\"\n+#include \"dfp.h\"\n \n /* The floating point model used internally is not exactly IEEE 754\n    compliant, and close to the description in the ISO C99 standard,\n@@ -480,6 +481,9 @@ normalize (REAL_VALUE_TYPE *r)\n   int shift = 0, exp;\n   int i, j;\n \n+  if (r->decimal)\n+    return;\n+\n   /* Find the first word that is nonzero.  */\n   for (i = SIGSZ - 1; i >= 0; i--)\n     if (r->sig[i] == 0)\n@@ -643,6 +647,7 @@ do_add (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a,\n   /* Zero out the remaining fields.  */\n   r->signalling = 0;\n   r->canonical = 0;\n+  r->decimal = 0;\n \n   /* Re-normalize the result.  */\n   normalize (r);\n@@ -938,6 +943,9 @@ do_compare (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b,\n   if (a->sign != b->sign)\n     return -a->sign - -b->sign;\n \n+  if (a->decimal || b->decimal)\n+    return decimal_do_compare (a, b, nan_result);\n+\n   if (REAL_EXP (a) > REAL_EXP (b))\n     ret = 1;\n   else if (REAL_EXP (a) < REAL_EXP (b))\n@@ -963,6 +971,11 @@ do_fix_trunc (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *a)\n       break;\n \n     case rvc_normal:\n+      if (r->decimal)\n+\t{\n+\t  decimal_do_fix_trunc (r, a);\n+\t  return;\n+\t}\n       if (REAL_EXP (r) <= 0)\n \tget_zero (r, r->sign);\n       else if (REAL_EXP (r) < SIGNIFICAND_BITS)\n@@ -984,6 +997,9 @@ real_arithmetic (REAL_VALUE_TYPE *r, int icode, const REAL_VALUE_TYPE *op0,\n {\n   enum tree_code code = icode;\n \n+  if (op0->decimal || (op1 && op1->decimal))\n+    return decimal_real_arithmetic (r, icode, op0, op1);\n+\n   switch (code)\n     {\n     case PLUS_EXPR:\n@@ -1187,6 +1203,8 @@ real_identical (const REAL_VALUE_TYPE *a, const REAL_VALUE_TYPE *b)\n       return true;\n \n     case rvc_normal:\n+      if (a->decimal != b->decimal)\n+        return false;\n       if (REAL_EXP (a) != REAL_EXP (b))\n \treturn false;\n       break;\n@@ -1269,6 +1287,9 @@ real_to_integer (const REAL_VALUE_TYPE *r)\n       return i;\n \n     case rvc_normal:\n+      if (r->decimal)\n+\treturn decimal_real_to_integer (r);\n+\n       if (REAL_EXP (r) <= 0)\n \tgoto underflow;\n       /* Only force overflow for unsigned overflow.  Signed overflow is\n@@ -1330,6 +1351,12 @@ real_to_integer2 (HOST_WIDE_INT *plow, HOST_WIDE_INT *phigh,\n       break;\n \n     case rvc_normal:\n+      if (r->decimal)\n+\t{ \n+\t  decimal_real_to_integer2 (plow, phigh, r);\n+\t  return;\n+\t}\n+\t\n       exp = REAL_EXP (r);\n       if (exp <= 0)\n \tgoto underflow;\n@@ -1448,6 +1475,12 @@ real_to_decimal (char *str, const REAL_VALUE_TYPE *r_orig, size_t buf_size,\n       gcc_unreachable ();\n     }\n \n+  if (r.decimal)\n+    {\n+      decimal_real_to_decimal (str, &r, buf_size, digits, crop_trailing_zeros);\n+      return;\n+    }\n+\n   /* Bound the number of digits printed by the size of the representation.  */\n   max_digits = SIGNIFICAND_BITS * M_LOG10_2;\n   if (digits == 0 || digits > max_digits)\n@@ -1714,6 +1747,13 @@ real_to_hexadecimal (char *str, const REAL_VALUE_TYPE *r, size_t buf_size,\n       gcc_unreachable ();\n     }\n \n+  if (r->decimal)\n+    {\n+      /* Hexadecimal format for decimal floats is not interesting. */\n+      strcpy (str, \"N/A\");\n+      return;\n+    }\n+\n   if (digits == 0)\n     digits = SIGNIFICAND_BITS / 4;\n \n@@ -1957,6 +1997,20 @@ real_from_string2 (const char *s, enum machine_mode mode)\n   return r;\n }\n \n+/* Initialize R from string S and desired MODE. */\n+\n+void \n+real_from_string3 (REAL_VALUE_TYPE *r, const char *s, enum machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode))\n+    decimal_real_from_string (r, s);\n+  else\n+    real_from_string (r, s);\n+\n+  if (mode != VOIDmode)\n+    real_convert (r, mode, r);  \n+} \n+\n /* Initialize R from the integer pair HIGH+LOW.  */\n \n void\n@@ -2202,16 +2256,20 @@ real_maxval (REAL_VALUE_TYPE *r, int sign, enum machine_mode mode)\n \n   fmt = REAL_MODE_FORMAT (mode);\n   gcc_assert (fmt);\n+  memset (r, 0, sizeof (*r));\n+  \n+  if (fmt->b == 10)\n+    decimal_real_maxval (r, sign, mode);\n+  else\n+    {\n+      r->cl = rvc_normal;\n+      r->sign = sign;\n+      SET_REAL_EXP (r, fmt->emax * fmt->log2_b);\n \n-  r->cl = rvc_normal;\n-  r->sign = sign;\n-  r->signalling = 0;\n-  r->canonical = 0;\n-  SET_REAL_EXP (r, fmt->emax * fmt->log2_b);\n-\n-  np2 = SIGNIFICAND_BITS - fmt->p * fmt->log2_b;\n-  memset (r->sig, -1, SIGSZ * sizeof (unsigned long));\n-  clear_significand_below (r, np2);\n+      np2 = SIGNIFICAND_BITS - fmt->p * fmt->log2_b;\n+      memset (r->sig, -1, SIGSZ * sizeof (unsigned long));\n+      clear_significand_below (r, np2);\n+    }\n }\n \n /* Fills R with 2**N.  */\n@@ -2243,6 +2301,20 @@ round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n   bool guard, lsb;\n   int emin2m1, emax2;\n \n+  if (r->decimal)\n+    {\n+      if (fmt->b == 10)\n+\t{\n+\t  decimal_round_for_format (fmt, r);\n+\t  return;\n+\t}\n+      /* FIXME. We can come here via fp_easy_constant\n+\t (e.g. -O0 on '_Decimal32 x = 1.0 + 2.0dd'), but have not\n+\t investigated whether this convert needs to be here, or\n+\t something else is missing. */\n+      decimal_real_convert (r, DFmode, r);\n+    }\n+\n   p2 = fmt->p * fmt->log2_b;\n   emin2m1 = (fmt->emin - 1) * fmt->log2_b;\n   emax2 = fmt->emax * fmt->log2_b;\n@@ -2277,7 +2349,10 @@ round_for_format (const struct real_format *fmt, REAL_VALUE_TYPE *r)\n      the true base.  */\n   if (fmt->log2_b != 1)\n     {\n-      int shift = REAL_EXP (r) & (fmt->log2_b - 1);\n+      int shift;\n+\n+      gcc_assert (fmt->b != 10);\n+      shift = REAL_EXP (r) & (fmt->log2_b - 1);\n       if (shift)\n \t{\n \t  shift = fmt->log2_b - shift;\n@@ -2377,6 +2452,10 @@ real_convert (REAL_VALUE_TYPE *r, enum machine_mode mode,\n   gcc_assert (fmt);\n \n   *r = *a;\n+\n+  if (a->decimal || fmt->b == 10)\n+    decimal_real_convert (r, mode, a);\n+\n   round_for_format (fmt, r);\n \n   /* round_for_format de-normalizes denormals.  Undo just that part.  */\n@@ -2476,7 +2555,8 @@ real_from_target (REAL_VALUE_TYPE *r, const long *buf, enum machine_mode mode)\n   (*fmt->decode) (fmt, r, buf);\n }\n \n-/* Return the number of bits in the significand for MODE.  */\n+/* Return the number of bits of the largest binary value that the\n+   significand of MODE will hold.  */\n /* ??? Legacy.  Should get access to real_format directly.  */\n \n int\n@@ -2488,6 +2568,15 @@ significand_size (enum machine_mode mode)\n   if (fmt == NULL)\n     return 0;\n \n+  if (fmt->b == 10)\n+    {\n+      /* Return the size in bits of the largest binary value that can be\n+\t held by the decimal coefficient for this mode.  This is one more\n+\t than the number of bits required to hold the largest coefficient\n+\t of this mode.  */\n+      double log2_10 = 3.3219281;\n+      return fmt->p * log2_10;\n+    }\n   return fmt->p * fmt->log2_b;\n }\n \n@@ -4234,6 +4323,112 @@ const struct real_format i370_double_format =\n     false\n   };\n \f\n+static void\n+encode_decimal_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+                       long *buf ATTRIBUTE_UNUSED, \n+\t\t       const REAL_VALUE_TYPE *r ATTRIBUTE_UNUSED)\n+{\n+  encode_decimal32 (fmt, buf, r);\n+}\n+\n+static void \n+decode_decimal_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t       REAL_VALUE_TYPE *r ATTRIBUTE_UNUSED, \n+\t\t       const long *buf ATTRIBUTE_UNUSED)\n+{\n+  decode_decimal32 (fmt, r, buf);\n+}\n+\n+static void \n+encode_decimal_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t       long *buf ATTRIBUTE_UNUSED, \n+\t\t       const REAL_VALUE_TYPE *r ATTRIBUTE_UNUSED)\n+{\n+  encode_decimal64 (fmt, buf, r);\n+}\n+\n+static void \n+decode_decimal_double (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t       REAL_VALUE_TYPE *r ATTRIBUTE_UNUSED, \n+\t\t       const long *buf ATTRIBUTE_UNUSED)\n+{\n+  decode_decimal64 (fmt, r, buf);\n+}\n+\n+static void \n+encode_decimal_quad (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t     long *buf ATTRIBUTE_UNUSED,\n+\t\t     const REAL_VALUE_TYPE *r ATTRIBUTE_UNUSED)\n+{\n+  encode_decimal128 (fmt, buf, r);\n+}\n+\n+static void \n+decode_decimal_quad (const struct real_format *fmt ATTRIBUTE_UNUSED,\n+\t\t     REAL_VALUE_TYPE *r ATTRIBUTE_UNUSED,\n+\t\t     const long *buf ATTRIBUTE_UNUSED)\n+{\n+  decode_decimal128 (fmt, r, buf);\n+}\n+\n+/* Proposed IEEE 754r decimal floating point. */\n+const struct real_format decimal_single_format =\n+  {\n+    encode_decimal_single,\n+    decode_decimal_single,\n+    10, \n+    1,  /* log10 */\n+    7,\n+    7,\n+    -95,\n+    96,\n+    31,\n+    31,\n+    true,\n+    true,\n+    true,\n+    true, \n+    true\n+  };\n+\n+const struct real_format decimal_double_format =\n+  {\n+    encode_decimal_double,\n+    decode_decimal_double,\n+    10,\n+    1,  /* log10 */\n+    16,\n+    16,\n+    -383,\n+    384,\n+    63,\n+    63,\n+    true,\n+    true,\n+    true,\n+    true,\n+    true\n+  };\n+\n+const struct real_format decimal_quad_format =\n+  {\n+    encode_decimal_quad,\n+    decode_decimal_quad,\n+    10,\n+    1,  /* log10 */\n+    34,\n+    34,\n+    -6414,\n+    6413,\n+    127,\n+    127,\n+    true,\n+    true,\n+    true, \n+    true, \n+    true\n+  };\n+\f\n /* The \"twos-complement\" c4x format is officially defined as\n \n \tx = s(~s).f * 2**e"}, {"sha": "3eecb92fbcdb187cf7d11ca50ef74933d4314cdf", "filename": "gcc/real.h", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/909e2256221436f25d53bd2fec7cf85634cdb8ec/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=909e2256221436f25d53bd2fec7cf85634cdb8ec", "patch": "@@ -35,7 +35,7 @@ enum real_value_class {\n };\n \n #define SIGNIFICAND_BITS\t(128 + HOST_BITS_PER_LONG)\n-#define EXP_BITS\t\t(32 - 5)\n+#define EXP_BITS\t\t(32 - 6)\n #define MAX_EXP\t\t\t((1 << (EXP_BITS - 1)) - 1)\n #define SIGSZ\t\t\t(SIGNIFICAND_BITS / HOST_BITS_PER_LONG)\n #define SIG_MSB\t\t\t((unsigned long)1 << (HOST_BITS_PER_LONG - 1))\n@@ -46,6 +46,7 @@ struct real_value GTY(())\n      sure they're packed together, otherwise REAL_VALUE_TYPE_SIZE will\n      be miscomputed.  */\n   unsigned int /* ENUM_BITFIELD (real_value_class) */ cl : 2;\n+  unsigned int decimal : 1;\n   unsigned int sign : 1;\n   unsigned int signalling : 1;\n   unsigned int canonical : 1;\n@@ -155,12 +156,20 @@ struct real_format\n };\n \n \n-/* The target format used for each floating floating point mode.\n-   Indexed by MODE - QFmode.  */\n+/* The target format used for each floating point mode.\n+   Float modes are followed by decimal float modes, with entries for\n+   float modes indexed by (MODE - first float mode), and entries for\n+   decimal float modes indexed by (MODE - first decimal float mode) +\n+   the number of float modes.  */\n extern const struct real_format *\n-  real_format_for_mode[MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1];\n+  real_format_for_mode[MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1\n+\t\t       + MAX_MODE_DECIMAL_FLOAT - MIN_MODE_DECIMAL_FLOAT + 1];\n \n-#define REAL_MODE_FORMAT(MODE) (real_format_for_mode[(MODE) - MIN_MODE_FLOAT])\n+#define REAL_MODE_FORMAT(MODE)\t\t\t\t\t\t\\\n+  (real_format_for_mode[DECIMAL_FLOAT_MODE_P (MODE)\t\t\t\\\n+\t\t\t? ((MODE - MIN_MODE_DECIMAL_FLOAT)\t\t\\\n+\t\t\t   + (MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1))\t\\\n+\t\t\t: (MODE - MIN_MODE_FLOAT)])\n \n /* The following macro determines whether the floating point format is\n    composite, i.e. may contain non-consecutive mantissa bits, in which\n@@ -214,6 +223,8 @@ extern void real_to_integer2 (HOST_WIDE_INT *, HOST_WIDE_INT *,\n \n /* Initialize R from a decimal or hexadecimal string.  */\n extern void real_from_string (REAL_VALUE_TYPE *, const char *);\n+/* Wrapper to allow different internal representation for decimal floats. */\n+extern void real_from_string3 (REAL_VALUE_TYPE *, const char *, enum machine_mode);\n \n /* Initialize R from an integer pair HIGH/LOW.  */\n extern void real_from_integer (REAL_VALUE_TYPE *, enum machine_mode,\n@@ -260,6 +271,9 @@ extern const struct real_format i370_double_format;\n extern const struct real_format c4x_single_format;\n extern const struct real_format c4x_extended_format;\n extern const struct real_format real_internal_format;\n+extern const struct real_format decimal_single_format;\n+extern const struct real_format decimal_double_format;\n+extern const struct real_format decimal_quad_format;\n \n \n /* ====================================================================== */\n@@ -302,6 +316,19 @@ extern const struct real_format real_internal_format;\n #define REAL_VALUE_FROM_UNSIGNED_INT(r, lo, hi, mode) \\\n   real_from_integer (&(r), mode, lo, hi, 1)\n \n+/* Real values to IEEE 754R decimal floats.  */\n+\n+/* IN is a REAL_VALUE_TYPE.  OUT is an array of longs.  */\n+#define REAL_VALUE_TO_TARGET_DECIMAL128(IN, OUT) \\\n+  real_to_target (OUT, &(IN), mode_for_size (128, MODE_DECIMAL_FLOAT, 0))\n+\n+#define REAL_VALUE_TO_TARGET_DECIMAL64(IN, OUT) \\\n+  real_to_target (OUT, &(IN), mode_for_size (64, MODE_DECIMAL_FLOAT, 0))\n+\n+/* IN is a REAL_VALUE_TYPE.  OUT is a long.  */\n+#define REAL_VALUE_TO_TARGET_DECIMAL32(IN, OUT) \\\n+  ((OUT) = real_to_target (NULL, &(IN), mode_for_size (32, MODE_DECIMAL_FLOAT, 0)))\n+\n extern REAL_VALUE_TYPE real_value_truncate (enum machine_mode,\n \t\t\t\t\t    REAL_VALUE_TYPE);\n "}]}