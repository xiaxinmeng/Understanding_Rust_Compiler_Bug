{"sha": "17b658af6686e89568ef734aca6ff46248203a81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdiNjU4YWY2Njg2ZTg5NTY4ZWY3MzRhY2E2ZmY0NjI0ODIwM2E4MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-07-09T21:11:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-07-09T21:11:28Z"}, "message": "re PR tree-optimization/66718 (Non-invariant ADDR_EXPR not vectorized)\n\n\tPR tree-optimization/66718\n\t* tree-vect-stmts.c (struct simd_call_arg_info): Add simd_lane_linear\n\tfield.\n\t(vect_simd_lane_linear): New function.\n\t(vectorizable_simd_clone_call): Support using linear arguments for\n\taddresses of arrays elements indexed by GOMP_SIMD_LANE result.\n\nFrom-SVN: r225637", "tree": {"sha": "1f53806bf5d746d8d3607a06b995c4b98f12f5f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f53806bf5d746d8d3607a06b995c4b98f12f5f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17b658af6686e89568ef734aca6ff46248203a81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b658af6686e89568ef734aca6ff46248203a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17b658af6686e89568ef734aca6ff46248203a81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b658af6686e89568ef734aca6ff46248203a81/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d1ab2d63e2346284757dbe57c7cc44dfd4a5f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1ab2d63e2346284757dbe57c7cc44dfd4a5f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d1ab2d63e2346284757dbe57c7cc44dfd4a5f9e"}], "stats": {"total": 117, "additions": 110, "deletions": 7}, "files": [{"sha": "eaf7f7df902162aceffdb16ebfb2d4475ff263e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b658af6686e89568ef734aca6ff46248203a81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b658af6686e89568ef734aca6ff46248203a81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17b658af6686e89568ef734aca6ff46248203a81", "patch": "@@ -1,3 +1,12 @@\n+2015-07-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/66718\n+\t* tree-vect-stmts.c (struct simd_call_arg_info): Add simd_lane_linear\n+\tfield.\n+\t(vect_simd_lane_linear): New function.\n+\t(vectorizable_simd_clone_call): Support using linear arguments for\n+\taddresses of arrays elements indexed by GOMP_SIMD_LANE result.\n+\n 2015-07-09  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/66821"}, {"sha": "f06e57c6974c1f69078b502fca06d897961ac82d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 101, "deletions": 7, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b658af6686e89568ef734aca6ff46248203a81/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b658af6686e89568ef734aca6ff46248203a81/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=17b658af6686e89568ef734aca6ff46248203a81", "patch": "@@ -2629,8 +2629,79 @@ struct simd_call_arg_info\n   enum vect_def_type dt;\n   HOST_WIDE_INT linear_step;\n   unsigned int align;\n+  bool simd_lane_linear;\n };\n \n+/* Helper function of vectorizable_simd_clone_call.  If OP, an SSA_NAME,\n+   is linear within simd lane (but not within whole loop), note it in\n+   *ARGINFO.  */\n+\n+static void\n+vect_simd_lane_linear (tree op, struct loop *loop,\n+\t\t       struct simd_call_arg_info *arginfo)\n+{\n+  gimple def_stmt = SSA_NAME_DEF_STMT (op);\n+\n+  if (!is_gimple_assign (def_stmt)\n+      || gimple_assign_rhs_code (def_stmt) != POINTER_PLUS_EXPR\n+      || !is_gimple_min_invariant (gimple_assign_rhs1 (def_stmt)))\n+    return;\n+\n+  tree base = gimple_assign_rhs1 (def_stmt);\n+  HOST_WIDE_INT linear_step = 0;\n+  tree v = gimple_assign_rhs2 (def_stmt);\n+  while (TREE_CODE (v) == SSA_NAME)\n+    {\n+      tree t;\n+      def_stmt = SSA_NAME_DEF_STMT (v);\n+      if (is_gimple_assign (def_stmt))\n+\tswitch (gimple_assign_rhs_code (def_stmt))\n+\t  {\n+\t  case PLUS_EXPR:\n+\t    t = gimple_assign_rhs2 (def_stmt);\n+\t    if (linear_step || TREE_CODE (t) != INTEGER_CST)\n+\t      return;\n+\t    base = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (base), base, t);\n+\t    v = gimple_assign_rhs1 (def_stmt);\n+\t    continue;\n+\t  case MULT_EXPR:\n+\t    t = gimple_assign_rhs2 (def_stmt);\n+\t    if (linear_step || !tree_fits_shwi_p (t) || integer_zerop (t))\n+\t      return;\n+\t    linear_step = tree_to_shwi (t);\n+\t    v = gimple_assign_rhs1 (def_stmt);\n+\t    continue;\n+\t  CASE_CONVERT:\n+\t    t = gimple_assign_rhs1 (def_stmt);\n+\t    if (TREE_CODE (TREE_TYPE (t)) != INTEGER_TYPE\n+\t\t|| (TYPE_PRECISION (TREE_TYPE (v))\n+\t\t    < TYPE_PRECISION (TREE_TYPE (t))))\n+\t      return;\n+\t    if (!linear_step)\n+\t      linear_step = 1;\n+\t    v = t;\n+\t    continue;\n+\t  default:\n+\t    return;\n+\t  }\n+      else if (is_gimple_call (def_stmt)\n+\t       && gimple_call_internal_p (def_stmt)\n+\t       && gimple_call_internal_fn (def_stmt) == IFN_GOMP_SIMD_LANE\n+\t       && loop->simduid\n+\t       && TREE_CODE (gimple_call_arg (def_stmt, 0)) == SSA_NAME\n+\t       && (SSA_NAME_VAR (gimple_call_arg (def_stmt, 0))\n+\t\t   == loop->simduid))\n+\t{\n+\t  if (!linear_step)\n+\t    linear_step = 1;\n+\t  arginfo->linear_step = linear_step;\n+\t  arginfo->op = base;\n+\t  arginfo->simd_lane_linear = true;\n+\t  return;\n+\t}\n+    }\n+}\n+\n /* Function vectorizable_simd_clone_call.\n \n    Check if STMT performs a function call that can be vectorized\n@@ -2713,6 +2784,7 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n       thisarginfo.linear_step = 0;\n       thisarginfo.align = 0;\n       thisarginfo.op = NULL_TREE;\n+      thisarginfo.simd_lane_linear = false;\n \n       op = gimple_call_arg (stmt, i);\n       if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n@@ -2735,21 +2807,24 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \n       /* For linear arguments, the analyze phase should have saved\n \t the base and step in STMT_VINFO_SIMD_CLONE_INFO.  */\n-      if (i * 2 + 3 <= STMT_VINFO_SIMD_CLONE_INFO (stmt_info).length ()\n-\t  && STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 2 + 2])\n+      if (i * 3 + 4 <= STMT_VINFO_SIMD_CLONE_INFO (stmt_info).length ()\n+\t  && STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 3 + 2])\n \t{\n \t  gcc_assert (vec_stmt);\n \t  thisarginfo.linear_step\n-\t    = tree_to_shwi (STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 2 + 2]);\n+\t    = tree_to_shwi (STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 3 + 2]);\n \t  thisarginfo.op\n-\t    = STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 2 + 1];\n+\t    = STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 3 + 1];\n+\t  thisarginfo.simd_lane_linear\n+\t    = (STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 3 + 3]\n+\t       == boolean_true_node);\n \t  /* If loop has been peeled for alignment, we need to adjust it.  */\n \t  tree n1 = LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo);\n \t  tree n2 = LOOP_VINFO_NITERS (loop_vinfo);\n-\t  if (n1 != n2)\n+\t  if (n1 != n2 && !thisarginfo.simd_lane_linear)\n \t    {\n \t      tree bias = fold_build2 (MINUS_EXPR, TREE_TYPE (n1), n1, n2);\n-\t      tree step = STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 2 + 2];\n+\t      tree step = STMT_VINFO_SIMD_CLONE_INFO (stmt_info)[i * 3 + 2];\n \t      tree opt = TREE_TYPE (thisarginfo.op);\n \t      bias = fold_convert (TREE_TYPE (step), bias);\n \t      bias = fold_build2 (MULT_EXPR, TREE_TYPE (step), bias, step);\n@@ -2775,6 +2850,17 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t|| thisarginfo.dt == vect_external_def)\n \t       && POINTER_TYPE_P (TREE_TYPE (op)))\n \tthisarginfo.align = get_pointer_alignment (op) / BITS_PER_UNIT;\n+      /* Addresses of array elements indexed by GOMP_SIMD_LANE are\n+\t linear too.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (op))\n+\t  && !thisarginfo.linear_step\n+\t  && !vec_stmt\n+\t  && thisarginfo.dt != vect_constant_def\n+\t  && thisarginfo.dt != vect_external_def\n+\t  && loop_vinfo\n+\t  && !slp_node\n+\t  && TREE_CODE (op) == SSA_NAME)\n+\tvect_simd_lane_linear (op, loop, &thisarginfo);\n \n       arginfo.quick_push (thisarginfo);\n     }\n@@ -2906,13 +2992,16 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \tif (bestn->simdclone->args[i].arg_type\n \t    == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)\n \t  {\n-\t    STMT_VINFO_SIMD_CLONE_INFO (stmt_info).safe_grow_cleared (i * 2\n+\t    STMT_VINFO_SIMD_CLONE_INFO (stmt_info).safe_grow_cleared (i * 3\n \t\t\t\t\t\t\t\t\t+ 1);\n \t    STMT_VINFO_SIMD_CLONE_INFO (stmt_info).safe_push (arginfo[i].op);\n \t    tree lst = POINTER_TYPE_P (TREE_TYPE (arginfo[i].op))\n \t\t       ? size_type_node : TREE_TYPE (arginfo[i].op);\n \t    tree ls = build_int_cst (lst, arginfo[i].linear_step);\n \t    STMT_VINFO_SIMD_CLONE_INFO (stmt_info).safe_push (ls);\n+\t    tree sll = arginfo[i].simd_lane_linear\n+\t\t       ? boolean_true_node : boolean_false_node;\n+\t    STMT_VINFO_SIMD_CLONE_INFO (stmt_info).safe_push (sll);\n \t  }\n       STMT_VINFO_TYPE (stmt_info) = call_simd_clone_vec_info_type;\n       if (dump_enabled_p ())\n@@ -3050,6 +3139,11 @@ vectorizable_simd_clone_call (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n \t\t      gcc_assert (!new_bb);\n \t\t    }\n+\t\t  if (arginfo[i].simd_lane_linear)\n+\t\t    {\n+\t\t      vargs.safe_push (arginfo[i].op);\n+\t\t      break;\n+\t\t    }\n \t\t  tree phi_res = copy_ssa_name (op);\n \t\t  gphi *new_phi = create_phi_node (phi_res, loop->header);\n \t\t  set_vinfo_for_stmt (new_phi,"}]}