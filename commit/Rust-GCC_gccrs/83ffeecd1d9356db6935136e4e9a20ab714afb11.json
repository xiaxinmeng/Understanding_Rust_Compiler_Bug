{"sha": "83ffeecd1d9356db6935136e4e9a20ab714afb11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNmZmVlY2QxZDkzNTZkYjY5MzUxMzZlNGU5YTIwYWI3MTRhZmIxMQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2000-04-08T14:47:04Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-04-08T14:47:04Z"}, "message": "thumb.md: Delete.\n\n* arm/thumb.md: Delete.\n* arm/thumb-protos.h: Delete.\n\nFrom-SVN: r33029", "tree": {"sha": "0932b41723ea72db713a4aa4ff45dcc439b9adff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0932b41723ea72db713a4aa4ff45dcc439b9adff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83ffeecd1d9356db6935136e4e9a20ab714afb11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ffeecd1d9356db6935136e4e9a20ab714afb11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83ffeecd1d9356db6935136e4e9a20ab714afb11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83ffeecd1d9356db6935136e4e9a20ab714afb11/comments", "author": null, "committer": null, "parents": [{"sha": "d5b7b3ae33022fb55255375d3ec9745217d95c96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5b7b3ae33022fb55255375d3ec9745217d95c96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5b7b3ae33022fb55255375d3ec9745217d95c96"}], "stats": {"total": 1288, "additions": 5, "deletions": 1283}, "files": [{"sha": "87194541bedf48f8050579f12ce0a8c4b6f7666a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83ffeecd1d9356db6935136e4e9a20ab714afb11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83ffeecd1d9356db6935136e4e9a20ab714afb11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83ffeecd1d9356db6935136e4e9a20ab714afb11", "patch": "@@ -1,3 +1,8 @@\n+2000-04-08  Richard Earnshaw (rearnsha@arm.com)\n+\n+\t* arm/thumb.md: Delete.\n+\t* arm/thumb-protos.h: Delete.\n+\n 2000-04-08  Richard Earnshaw (rearnsha@arm.com)\n \n \tMerge changes from merged-arm-thumb-backend-branch onto trunk."}, {"sha": "42d23a7de05ef4dcd57c44a105b4533638933df9", "filename": "gcc/config/arm/thumb-protos.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fthumb-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fthumb-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb-protos.h?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,70 +0,0 @@\n-/* Prototypes for exported functions defined in thumb.c\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Nick Clifton (nickc@cygnus.com)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-extern int    thumb_shiftable_const\tPARAMS ((HOST_WIDE_INT));\n-extern int    thumb_trivial_epilogue\tPARAMS ((void));\n-extern void   thumb_finalize_pic\tPARAMS ((void));\n-extern int    far_jump_used_p\t\tPARAMS ((void));\n-extern char * output_return\t\tPARAMS ((void));\n-extern void   thumb_function_prologue\tPARAMS ((FILE *, int));\n-extern void   thumb_init_expanders\tPARAMS ((void));\n-extern void   thumb_expand_prologue\tPARAMS ((void));\n-extern void   thumb_expand_epilogue\tPARAMS ((void));\n-extern void   thumb_function_epilogue\tPARAMS ((FILE *, int));\n-extern char * thumb_unexpanded_epilogue\tPARAMS ((void));\n-extern int    thumb_epilogue_size\tPARAMS ((void));\n-extern void   thumb_override_options\tPARAMS ((void));\n-\n-#ifdef AOF_ASSEMBLER\n-extern char * aof_text_section\t\tPARAMS ((int));\n-extern char * aof_data_section\t\tPARAMS ((void));\n-extern void   thumb_aof_add_import\tPARAMS ((char *));\n-extern void   thumb_aof_delete_import\tPARAMS ((char *));\n-extern void   thumb_aof_dump_imports\tPARAMS ((FILE *));\n-#endif /* AOF_ASSEMBLER */\n-\n-#ifdef TREE_CODE\n-extern int    is_called_in_ARM_mode\tPARAMS ((tree));\n-extern int    thumb_return_in_memory\tPARAMS ((tree));\n-#ifdef THUMB_PE\n-extern int    arm_valid_machine_decl_attribute PARAMS ((tree, tree, tree));\n-#endif /* THUMB_PE */\n-#endif /* TREE_CODE */\n-\n-#ifdef RTX_CODE\n-extern int    thumb_symbol_mentioned_p\tPARAMS ((rtx));\n-extern int    label_mentioned_p\t\tPARAMS ((rtx));\n-extern int    is_pic\t\t\tPARAMS ((rtx));\n-extern void   thumb_reorg\t\tPARAMS ((rtx));\n-extern rtx    thumb_return_addr\t\tPARAMS ((int));\n-extern void   thumb_expand_movstrqi\tPARAMS ((rtx *));\n-extern void   thumb_reload_out_si\tPARAMS ((rtx));\n-extern void   thumb_final_prescan_insn\tPARAMS ((rtx));\n-extern char * thumb_load_double_from_address PARAMS ((rtx *));\n-extern char * output_move_mem_multiple\tPARAMS ((int, rtx *));\n-extern void   thumb_print_operand\tPARAMS ((FILE *, rtx, int));\n-\n-#ifdef HAVE_MACHINE_MODES\n-extern int    reload_memory_operand\tPARAMS ((rtx, enum machine_mode));\n-extern int    thumb_cmp_operand\t\tPARAMS ((rtx, enum machine_mode));\n-extern rtx    legitimize_pic_address\tPARAMS ((rtx, enum machine_mode, rtx));\n-#endif /* HAVE_MACHINE_MODES */\n-#endif /* RTX_CODE */"}, {"sha": "7539889cad0b4372130f9721136e8f492a40a0ab", "filename": "gcc/config/arm/thumb.md", "status": "removed", "additions": 0, "deletions": 1213, "changes": 1213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fthumb.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5b7b3ae33022fb55255375d3ec9745217d95c96/gcc%2Fconfig%2Farm%2Fthumb.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.md?ref=d5b7b3ae33022fb55255375d3ec9745217d95c96", "patch": "@@ -1,1213 +0,0 @@\n-;; thumb.md\tMachine description for ARM/Thumb processors\n-;; Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n-;; The basis of this contribution was generated by\n-;;\t\tRichard Earnshaw, Advanced RISC Machines Ltd\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-;; LENGTH of an instruction is 2 bytes\n-(define_attr \"length\" \"\" (const_int 2))\n-\n-;; CONDS is set to UNCHANGED when an insn does not affect the condition codes\n-;; Most insns change the condition codes\n-(define_attr \"conds\" \"changed,unchanged\" (const_string \"changed\"))\n-\n-;; FAR_JUMP is \"yes\" if a BL instruction is used to generate a branch to a\n-;; distant label.\n-(define_attr \"far_jump\" \"yes,no\" (const_string \"no\"))\n-\n-;; Start with move insns\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-  if (! (reload_in_progress || reload_completed))\n-    {\n-      if (GET_CODE (operands[0]) != REG)\n-\toperands[1] = force_reg (SImode, operands[1]);\n-    }\n-  if (CONSTANT_P (operands[1]) && flag_pic)\n-    operands[1] = legitimize_pic_address (operands[1], SImode,\n-\t\t\t\t\t  ((reload_in_progress\n-\t\t\t\t\t    || reload_completed)\n-\t\t\t\t\t   ? operands[0] : 0));\n-\")\n-\n-(define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=l,l,l,l,l,>,l,m,*r,*h\")\n-\t(match_operand:SI 1 \"general_operand\" \"l,I,J,K,>,l,mi,l,*h,*r\"))]\n-  \"register_operand (operands[0], SImode) \n-   || register_operand (operands[1], SImode)\"\n-  \"@\n-   add\\\\t%0, %1, #0\n-   mov\\\\t%0, %1\n-   #\n-   #\n-   ldmia\\\\t%1, {%0}\n-   stmia\\\\t%0, {%1}\n-   ldr\\\\t%0, %1\n-   str\\\\t%1, %0\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\"\n-[(set_attr \"length\" \"2,2,4,4,2,2,2,2,2,2\")])\n-\n-(define_split \n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n-  \"thumb_shiftable_const (INTVAL (operands[1]))\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))]\n-  \"\n-{\n-  unsigned HOST_WIDE_INT val = INTVAL (operands[1]);\n-  unsigned HOST_WIDE_INT mask = 0xff;\n-  int i;\n-  for (i = 0; i < 25; i++)\n-    if ((val & (mask << i)) == val)\n-      break;\n-\n-  if (i == 0)\n-    FAIL;\n-\n-  operands[1] = GEN_INT (val >> i);\n-  operands[2] = GEN_INT (i);\n-}\")\n-\n-(define_split \n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n-  \"INTVAL (operands[1]) < 0 && INTVAL (operands[1]) > -256\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 0) (neg:SI (match_dup 0)))]\n-  \"\n-  operands[1] = GEN_INT (- INTVAL (operands[1]));\n-\")\n-\n-;;(define_expand \"reload_outsi\"\n-;;  [(set (match_operand:SI 2 \"register_operand\" \"=&l\")\n-;;\t(match_operand:SI 1 \"register_operand\" \"h\"))\n-;;   (set (match_operand:SI 0 \"reload_memory_operand\" \"=o\")\n-;;\t(match_dup 2))]\n-;;  \"\"\n-;;  \"\n-;;/*  thumb_reload_out_si (operands);\n-;;  DONE; */\n-;;\")\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! (reload_in_progress || reload_completed))\n-    {\n-      if (GET_CODE (operands[0]) != REG)\n-\toperands[1] = force_reg (HImode, operands[1]);\n-\n-      /* ??? We shouldn't really get invalid addresses here, but this can\n-\t happen if we are passed a SP (never OK for HImode/QImode) or virtual\n-\tregister (rejected by GO_IF_LEGITIMATE_ADDRESS for HImode/QImode)\n-\trelative address.  */\n-      /* ??? This should perhaps be fixed elsewhere, for instance, in\n-\t fixup_stack_1, by checking for other kinds of invalid addresses,\n-\t e.g. a bare reference to a virtual register.  This may confuse the\n-\t alpha though, which must handle this case differently.  */\n-      if (GET_CODE (operands[0]) == MEM\n-\t  && ! memory_address_p (GET_MODE (operands[0]),\n-\t\t\t\t XEXP (operands[0], 0)))\n-\t{\n-\t  rtx temp = copy_to_reg (XEXP (operands[0], 0));\n-\t  operands[0] = change_address (operands[0], VOIDmode, temp);\n-\t}\n-      if (GET_CODE (operands[1]) == MEM\n-\t  && ! memory_address_p (GET_MODE (operands[1]),\n-\t\t\t\t XEXP (operands[1], 0)))\n-\t{\n-\t  rtx temp = copy_to_reg (XEXP (operands[1], 0));\n-\t  operands[1] = change_address (operands[1], VOIDmode, temp);\n-\t}\n-    }\n-  /* Handle loading a large integer during reload */\n-  else if (GET_CODE (operands[1]) == CONST_INT\n-\t   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n-    {\n-      /* Writing a constant to memory needs a scratch, which should\n-\t be handled with SECONDARY_RELOADs.  */\n-      if (GET_CODE (operands[0]) != REG)\n-\tabort ();\n-\n-      operands[0] = gen_rtx (SUBREG, SImode, operands[0], 0);\n-      emit_insn (gen_movsi (operands[0], operands[1]));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"*movhi_insn\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=l,l,m,*r,*h,l\")\n-\t(match_operand:HI 1 \"general_operand\"       \"l,m,l,*h,*r,I\"))]\n-  \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\"\n-  \"@\n-   add\\\\t%0, %1, #0\n-   ldrh\\\\t%0, %1\n-   strh\\\\t%1, %0\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\")\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! (reload_in_progress || reload_completed))\n-    {\n-      if (GET_CODE (operands[0]) != REG)\n-\toperands[1] = force_reg (QImode, operands[1]);\n-\n-      /* ??? We shouldn't really get invalid addresses here, but this can\n-\t happen if we are passed a SP (never OK for HImode/QImode) or virtual\n-\tregister (rejected by GO_IF_LEGITIMATE_ADDRESS for HImode/QImode)\n-\trelative address.  */\n-      /* ??? This should perhaps be fixed elsewhere, for instance, in\n-\t fixup_stack_1, by checking for other kinds of invalid addresses,\n-\t e.g. a bare reference to a virtual register.  This may confuse the\n-\t alpha though, which must handle this case differently.  */\n-      if (GET_CODE (operands[0]) == MEM\n-\t  && ! memory_address_p (GET_MODE (operands[0]),\n-\t\t\t\t XEXP (operands[0], 0)))\n-\t{\n-\t  rtx temp = copy_to_reg (XEXP (operands[0], 0));\n-\t  operands[0] = change_address (operands[0], VOIDmode, temp);\n-\t}\n-      if (GET_CODE (operands[1]) == MEM\n-\t  && ! memory_address_p (GET_MODE (operands[1]),\n-\t\t\t\t XEXP (operands[1], 0)))\n-\t{\n-\t  rtx temp = copy_to_reg (XEXP (operands[1], 0));\n-\t  operands[1] = change_address (operands[1], VOIDmode, temp);\n-\t}\n-    }\n-  /* Handle loading a large integer during reload */\n-  else if (GET_CODE (operands[1]) == CONST_INT\n-\t   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n-    {\n-      /* Writing a constant to memory needs a scratch, which should\n-\t be handled with SECONDARY_RELOADs.  */\n-      if (GET_CODE (operands[0]) != REG)\n-\tabort ();\n-\n-      operands[0] = gen_rtx (SUBREG, SImode, operands[0], 0);\n-      emit_insn (gen_movsi (operands[0], operands[1]));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"*movqi_insn\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=l,l,m,*r,*h,l\")\n-\t(match_operand:QI 1 \"general_operand\" \"l,m,l,*h,*r,I\"))]\n-  \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\"\n-  \"@\n-   add\\\\t%0, %1, #0\n-   ldrb\\\\t%0, %1\n-   strb\\\\t%1, %0\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\")\n-\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-  if (! (reload_in_progress || reload_completed))\n-    {\n-      if (GET_CODE (operands[0]) != REG)\n-\toperands[1] = force_reg (DImode, operands[1]);\n-    }\n-\")\n-\n-;;; ??? This should have alternatives for constants.\n-;;; ??? This was originally identical to the movdf_insn pattern.\n-;;; ??? The 'i' constraint looks funny, but it should always be replaced by\n-;;; thumb_reorg with a memory reference.\n-(define_insn \"*movdi_insn\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=l,l,l,l,>,l,m,*r\")\n-\t(match_operand:DI 1 \"general_operand\" \"l,I,J,>,l,mi,l,*r\"))]\n-  \"register_operand (operands[0], DImode)\n-   || register_operand (operands[1], DImode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      abort ();\n-    case 0:\n-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n-\treturn \\\"add\\\\t%0, %1, #0\\;add\\\\t%H0, %H1, #0\\\";\n-      return \\\"add\\\\t%H0, %H1, #0\\;add\\\\t%0, %1, #0\\\";\n-    case 1:\n-      return \\\"mov\\\\t%Q0, %1\\;mov\\\\t%R0, #0\\\";\n-    case 2:\n-      operands[1] = GEN_INT (- INTVAL (operands[1]));\n-      return \\\"mov\\\\t%Q0, %1\\;neg\\\\t%Q0, %Q0\\;asr\\\\t%R0, %Q0, #31\\\";\n-    case 3:\n-      return \\\"ldmia\\\\t%1, {%0, %H0}\\\";\n-    case 4:\n-      return \\\"stmia\\\\t%0, {%1, %H1}\\\";\n-    case 5:\n-      return thumb_load_double_from_address (operands);\n-    case 6:\n-      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[0], 0), 4));\n-      output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n-      return \\\"\\\";\n-    case 7:\n-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n-\treturn \\\"mov\\\\t%0, %1\\;mov\\\\t%H0, %H1\\\";\n-      return \\\"mov\\\\t%H0, %H1\\;mov\\\\t%0, %1\\\";\n-    }\n-}\"[(set_attr \"length\" \"4,4,6,2,2,6,4,4\")])\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-  if (! (reload_in_progress || reload_completed))\n-    {\n-      if (GET_CODE (operands[0]) != REG)\n-\toperands[1] = force_reg (DFmode, operands[1]);\n-    }\n-\")\n-\n-;;; ??? This should have alternatives for constants.\n-;;; ??? This was originally identical to the movdi_insn pattern.\n-;;; ??? The 'F' constraint looks funny, but it should always be replaced by\n-;;; thumb_reorg with a memory reference.\n-(define_insn \"*movdf_insn\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=l,l,>,l,m,*r\")\n-\t(match_operand:DF 1 \"general_operand\"  \"l,>,l,mF,l,*r\"))]\n-  \"register_operand (operands[0], DFmode)\n-   || register_operand (operands[1], DFmode)\"\n-  \"*\n-  switch (which_alternative)\n-    {\n-    default:\n-      abort ();\n-    case 0:\n-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n-\treturn \\\"add\\\\t%0, %1, #0\\;add\\\\t%H0, %H1, #0\\\";\n-      return \\\"add\\\\t%H0, %H1, #0\\;add\\\\t%0, %1, #0\\\";\n-    case 1:\n-      return \\\"ldmia\\\\t%1, {%0, %H0}\\\";\n-    case 2:\n-      return \\\"stmia\\\\t%0, {%1, %H1}\\\";\n-    case 3:\n-      return thumb_load_double_from_address (operands);\n-    case 4:\n-      operands[2] = gen_rtx (MEM, SImode, plus_constant (XEXP (operands[0], 0), 4));\n-      output_asm_insn (\\\"str\\\\t%1, %0\\;str\\\\t%H1, %2\\\", operands);\n-      return \\\"\\\";\n-    case 5:\n-      if (REGNO (operands[1]) == REGNO (operands[0]) + 1)\n-\treturn \\\"mov\\\\t%0, %1\\;mov\\\\t%H0, %H1\\\";\n-      return \\\"mov\\\\t%H0, %H1\\;mov\\\\t%0, %1\\\";\n-    }\n-\"[(set_attr \"length\" \"4,2,2,6,4,4\")])\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-  if (! (reload_in_progress || reload_completed))\n-    {\n-      if (GET_CODE (operands[0]) != REG)\n-\toperands[1] = force_reg (SFmode, operands[1]);\n-    }\n-\")\n-\n-;;; ??? This should have alternatives for constants.\n-(define_insn \"*movsf_insn\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=l,l,>,l,m,*r,*h\")\n-\t(match_operand:SF 1 \"general_operand\"       \"l,>,l,mF,l,*h,*r\"))]\n-  \"register_operand (operands[0], SFmode) \n-   || register_operand (operands[1], SFmode)\"\n-  \"@\n-   add\\\\t%0, %1, #0\n-   ldmia\\\\t%1, {%0}\n-   stmia\\\\t%0, {%1}\n-   ldr\\\\t%0, %1\n-   str\\\\t%1, %0\n-   mov\\\\t%0, %1\n-   mov\\\\t%0, %1\")\n-\n-;; Widening move insns\n-\n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-  if (GET_CODE (operands[1]) != MEM)\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      \n-      operands[1] = force_reg (HImode, operands[1]);\n-      operands[1] = gen_lowpart (SImode, operands[1]);\n-      emit_insn (gen_ashlsi3 (temp, operands[1], GEN_INT (16)));\n-      emit_insn (gen_lshrsi3 (operands[0], temp, GEN_INT (16)));\n-      DONE;\n-    }\n-\")\n-\n-(define_insn \"*zero_extendhisi2_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldrh\\\\t%0, %1\")\n-\n-(define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-  if (GET_CODE (operands[1]) != MEM)\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-\n-      operands[1] = force_reg (QImode, operands[1]);\n-      operands[1] = gen_lowpart (SImode, operands[1]);\n-      emit_insn (gen_ashlsi3 (temp, operands[1], GEN_INT (24)));\n-      emit_insn (gen_lshrsi3 (operands[0], temp, GEN_INT (24)));\n-      DONE;\n-    }\n-\")\n-\n-(define_insn \"*zero_extendqisi2_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldrb\\\\t%0, %1\")\n-\n-(define_expand \"extendhisi2\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))\n-\t      (clobber (match_scratch:SI 2 \"\"))])]\n-  \"\"\n-  \"\n-  if (GET_CODE (operands[1]) != MEM)\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      \n-      operands[1] = force_reg (HImode, operands[1]);\n-      operands[1] = gen_lowpart (SImode, operands[1]);\n-      emit_insn (gen_ashlsi3 (temp, operands[1], GEN_INT (16)));\n-      emit_insn (gen_ashrsi3 (operands[0], temp, GEN_INT (16)));\n-      DONE;\n-    }\n-\")\n-\n-(define_insn \"*extendhisi2_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:SI 2 \"=&l\"))]\n-  \"\"\n-  \"*\n-{\n-  rtx ops[4];\n-  /* This code used to try to use 'V', and fix the address only if it was\n-     offsettable, but this fails for e.g. REG+48 because 48 is outside the\n-     range of QImode offsets, and offsettable_address_p does a QImode\n-     address check.  */\n-\n-  if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n-    {\n-      ops[1] = XEXP (XEXP (operands[1], 0), 0);\n-      ops[2] = XEXP (XEXP (operands[1], 0), 1);\n-    }\n-  else\n-    {\n-      ops[1] = XEXP (operands[1], 0);\n-      ops[2] = const0_rtx;\n-    }\n-  if (GET_CODE (ops[2]) == REG)\n-    return \\\"ldrsh\\\\t%0, %1\\\";\n-\n-  ops[0] = operands[0];\n-  ops[3] = operands[2];\n-  output_asm_insn (\\\"mov\\\\t%3, %2\\;ldrsh\\\\t%0, [%1, %3]\\\", ops);\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"length\" \"4\")])\n-\n-(define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-  if (GET_CODE (operands[1]) != MEM)\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-\n-      operands[1] = force_reg (QImode, operands[1]);\n-      operands[1] = gen_lowpart (SImode, operands[1]);\n-      emit_insn (gen_ashlsi3 (temp, operands[1], GEN_INT (24)));\n-      emit_insn (gen_ashrsi3 (operands[0], temp, GEN_INT (24)));\n-      DONE;\n-    }\n-\")\n-\n-(define_insn \"*extendqisi2_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"V,m\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx ops[3];\n-\n-  if (which_alternative == 0)\n-    return \\\"ldrsb\\\\t%0, %1\\\";\n-  ops[0] = operands[0];\n-  if (GET_CODE (XEXP (operands[1], 0)) == PLUS)\n-    {\n-      ops[1] = XEXP (XEXP (operands[1], 0), 0);\n-      ops[2] = XEXP (XEXP (operands[1], 0), 1);\n-      \n-      if (GET_CODE (ops[1]) == REG && GET_CODE (ops[2]) == REG)\n-        output_asm_insn (\\\"ldrsb\\\\t%0, [%1, %2]\\\", ops);\n-      else if (GET_CODE (ops[1]) == REG)\n-        {\n-          if (REGNO (ops[1]) == REGNO (operands[0]))\n-            output_asm_insn (\\\"ldrb\\\\t%0, [%1, %2]\\;lsl\\\\t%0, %0, #24\\;asr\\\\t%0, %0, #24\\\", ops);\n-\t  else\n-            output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-\t}\n-      else\n-        {\n-          if (REGNO (ops[2]) == REGNO (operands[0]))\n-            output_asm_insn (\\\"ldrb\\\\t%0, [%2, %1]\\;lsl\\\\t%0, %0, #24\\;asr\\\\t%0, %0, #24\\\", ops);\n-\t  else\n-            output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-        }\n-    }\n-  else if (REGNO (operands[0]) == REGNO (XEXP (operands[1], 0)))\n-    {\n-      output_asm_insn (\\\"ldrb\\\\t%0, [%0, #0]\\;lsl\\\\t%0, %0, #24\\;asr\\\\t%0, %0, #24\\\", ops);\n-    }\n-  else\n-    {\n-      ops[1] = XEXP (operands[1], 0);\n-      ops[2] = const0_rtx;\n-      output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-    }\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"length\" \"2,6\")])\n-\n-;; We don't really have extzv, but defining this using shifts helps\n-;; to reduce register pressure later on.\n-\n-(define_expand \"extzv\"\n-  [(set (match_dup 4)\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lshiftrt:SI (match_dup 4)\n-\t\t     (match_operand:SI 3 \"const_int_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  HOST_WIDE_INT lshift = 32 - INTVAL (operands[2]) - INTVAL (operands[3]);\n-  HOST_WIDE_INT rshift = 32 - INTVAL (operands[2]);\n-  operands[3] = GEN_INT (rshift);\n-  if (lshift == 0)\n-    {\n-      emit_insn (gen_lshrsi3 (operands[0], operands[1], operands[3]));\n-      DONE;\n-    }\n-  operands[2] = GEN_INT (lshift);\n-  operands[4] = gen_reg_rtx (SImode);\n-}\n-\")\n-\n-;; Block-move insns\n-\n-(define_expand \"movstrqi\"\n-  [(match_operand:BLK 0 \"general_operand\" \"\")\n-   (match_operand:BLK 1 \"general_operand\" \"\")\n-   (match_operand:SI 2 \"\" \"\")\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"\"\n-  \"\n-  if (INTVAL (operands[3]) != 4\n-      || GET_CODE (operands[2]) != CONST_INT\n-      || INTVAL (operands[2]) > 48)\n-    FAIL;\n-\n-  thumb_expand_movstrqi (operands);\n-  DONE;\n-\")\n-\n-(define_insn \"movmem12b\"\n-  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"+&l\"))\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"+&l\")))\n-   (set (mem:SI (plus:SI (match_dup 0) (const_int 4)))\n-\t(mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-   (set (mem:SI (plus:SI (match_dup 0) (const_int 8)))\n-\t(mem:SI (plus:SI (match_dup 1) (const_int 8))))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (const_int 12)))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 12)))\n-   (clobber (match_scratch:SI 2 \"=&l\"))\n-   (clobber (match_scratch:SI 3 \"=&l\"))\n-   (clobber (match_scratch:SI 4 \"=&l\"))]\n-  \"\"\n-  \"* return output_move_mem_multiple (3, operands);\"\n-[(set_attr \"length\" \"4\")])\n-\n-(define_insn \"movmem8b\"\n-  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"+&l\"))\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"+&l\")))\n-   (set (mem:SI (plus:SI (match_dup 0) (const_int 4)))\n-\t(mem:SI (plus:SI (match_dup 1) (const_int 4))))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (const_int 8)))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 8)))\n-   (clobber (match_scratch:SI 2 \"=&l\"))\n-   (clobber (match_scratch:SI 3 \"=&l\"))]\n-  \"\"\n-  \"* return output_move_mem_multiple (2, operands);\"\n-[(set_attr \"length\" \"4\")])\n-\n-;; Arithmetic insns\n-\n-(define_insn \"negdi2\"\n-  [(set (match_operand:DI         0 \"register_operand\" \"=&l\")\n-\t(neg:DI (match_operand:DI 1 \"register_operand\"   \"l\")))]\n-  \"\"\n-  \"neg\\\\t%Q0, %Q1\\;mov\\\\t%R0, #0\\;sbc\\\\t%R0, %R1\"\n-  [(set_attr \"conds\" \"changed\")\n-   (set_attr \"length\" \"6\")]\n-)\n-\n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"add\\\\t%Q0, %Q0, %Q2\\;adc\\\\t%R0, %R0, %R2\"\n-[(set_attr \"conds\" \"changed\")\n- (set_attr \"length\" \"4\")])\n-\n-;; register group 'k' is a single register group containing only the stack\n-;; register.  Trying to reload it will always fail catastrophically,\n-;; so never allow those alternatives to match if reloading is needed.\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=l,l,l,*r,*h,l,!k\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,l,*0,*0,!k,!k\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"I,J,lL,*h,*r,!M,!O\")))]\n-  \"\"\n-  \"*\n-   static char *asms[] = \n-{\n-  \\\"add\\\\t%0, %0, %2\\\",\n-  \\\"sub\\\\t%0, %0, #%n2\\\",\n-  \\\"add\\\\t%0, %1, %2\\\",\n-  \\\"add\\\\t%0, %0, %2\\\",\n-  \\\"add\\\\t%0, %0, %2\\\",\n-  \\\"add\\\\t%0, %1, %2\\\",\n-  \\\"add\\\\t%0, %1, %2\\\"\n-};\n-  if (which_alternative == 2 && GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) < 0)\n-    return \\\"sub\\\\t%0, %1, #%n2\\\";\n-  return asms[which_alternative];\n-\")\n-\n-; reloading and elimination of the frame pointer can sometimes cause this\n-; optimization to be missed.\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"M\"))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0) (match_operand:SI 2 \"register_operand\" \"k\")))]\n-  \"REGNO (operands[2]) == STACK_POINTER_REGNUM \n-   && (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) < 1024\n-   && (INTVAL (operands[1]) & 3) == 0\"\n-  \"add\\\\t%0, %2, %1\")\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"sub\\\\t%Q0, %Q0, %Q2\\;sbc\\\\t%R0, %R0, %R2\"\n-[(set_attr \"conds\" \"changed\")\n- (set_attr \"length\" \"4\")])\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"l\")\n-\t\t  (match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"sub\\\\t%0, %1, %2\")\n-\n-;; We must ensure that one input matches the output, and that the other input\n-;; does not match the output.  Using 0 satisfies the first, and using &\n-;; satisfies the second.  Unfortunately, this fails when operands 1 and 2\n-;; are the same, because reload will make operand 0 match operand 1 without\n-;; realizing that this conflicts with operand 2.  We fix this by adding another\n-;; alternative to match this case, and then `reload' it ourselves.  This\n-;; alternative must come first.\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&l,&l,&l\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%l,*h,0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"l,l,l\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative < 2)\n-    return \\\"mov\\\\t%0, %1\\;mul\\\\t%0, %0, %2\\\";\n-  else\n-    return \\\"mul\\\\t%0, %0, %2\\\";\n-}\"\n-  [(set_attr \"length\" \"4,4,2\")])\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"neg\\\\t%0, %1\")\n-\n-;; Logical insns\n-\n-(define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = force_reg (SImode, operands[2]);\n-  else\n-    {\n-      int i;\n-      if (((unsigned HOST_WIDE_INT) ~ INTVAL (operands[2])) < 256)\n-\t{\n-\t  operands[2] = force_reg (SImode, GEN_INT (~INTVAL (operands[2])));\n-\t  emit_insn (gen_bicsi3 (operands[0], operands[2], operands[1]));\n-\t  DONE;\n-\t}\n-\n-      for (i = 9; i <= 31; i++)\n-\tif ((((HOST_WIDE_INT) 1) << i) - 1 == INTVAL (operands[2]))\n-\t  {\n-\t    emit_insn (gen_extzv (operands[0], operands[1], GEN_INT (i),\n-\t\t\t\t  const0_rtx));\n-\t    DONE;\n-\t  }\n-\telse if ((((HOST_WIDE_INT) 1) << i) - 1 == ~ INTVAL (operands[2]))\n-\t  {\n-\t    rtx shift = GEN_INT (i);\n-\t    rtx reg = gen_reg_rtx (SImode);\n-\t    emit_insn (gen_lshrsi3 (reg, operands[1], shift));\n-\t    emit_insn (gen_ashlsi3 (operands[0], reg, shift));\n-\t    DONE;\n-\t  }\n-\n-      operands[2] = force_reg (SImode, operands[2]);\n-    }\n-\")\n-\n-(define_insn \"*andsi3_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"and\\\\t%0, %0, %2\")\n-\n-(define_insn \"bicsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"l\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"bic\\\\t%0, %0, %1\")\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"orr\\\\t%0, %0, %2\")\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"eor\\\\t%0, %0, %2\")\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"mvn\\\\t%0, %1\")\n-\n-;; Shift and rotation insns\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n-  \"\"\n-  \"@\n-   lsl\\\\t%0, %1, %2\n-   lsl\\\\t%0, %0, %2\")\n-\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n-  \"\"\n-  \"@\n-   asr\\\\t%0, %1, %2\n-   asr\\\\t%0, %0, %2\")\n-\n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"l,0\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"N,l\")))]\n-  \"\"\n-  \"@\n-   lsr\\\\t%0, %1, %2\n-   lsr\\\\t%0, %0, %2\")\n-\n-(define_insn \"rotrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"register_operand\" \"l\")))]\n-  \"\"\n-  \"ror\\\\t%0, %0, %2\")\n-\n-;; Comparison insns\n-\n-(define_expand \"cmpsi\"\n-  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t       (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-  if (GET_CODE (operands[1]) != REG && GET_CODE (operands[1]) != SUBREG)\n-    {\n-      if (GET_CODE (operands[1]) != CONST_INT\n-\t  || (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) >= 256)\n-\t{\n-\t  if (GET_CODE (operands[1]) != CONST_INT\n-\t      || INTVAL (operands[1]) < -255\n-\t      || INTVAL (operands[1]) > 0)\n-\t    operands[1] = force_reg (SImode, operands[1]);\n-\t  else\n-\t    {\n-\t      operands[1] = force_reg (SImode, \n-\t\t\t\t       GEN_INT (- INTVAL (operands[1])));\n-\t      emit_insn (gen_cmnsi (operands[0], operands[1]));\n-\t      DONE;\n-\t    }\n-        }\n-    }\n-\")\n-\n-(define_insn \"*cmpsi_insn\"\n-  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"l,*r,*h\")\n-\t\t       (match_operand:SI 1 \"thumb_cmp_operand\" \"lI,*h,*r\")))]\n-  \"\"\n-  \"@\n-   cmp\\\\t%0, %1\n-   cmp\\\\t%0, %1\n-   cmp\\\\t%0, %1\")\n-\n-(define_insn \"tstsi\"\n-  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"l\"))]\n-  \"\"\n-  \"cmp\\\\t%0, #0\")\n-\n-(define_insn \"cmnsi\"\n-  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"l\")\n-\t\t       (neg:SI (match_operand:SI 1 \"register_operand\" \"l\"))))]\n-  \"\"\n-  \"cmn\\\\t%0, %1\")\n-\n-;; Jump insns\n-\n-(define_insn \"jump\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"*\n-  if (get_attr_length (insn) == 2)\n-    return \\\"b\\\\t%l0\\\";\n-  return \\\"bl\\\\t%l0\\\\t%@ far jump\\\";\n-\"[(set (attr \"far_jump\")\n-       (if_then_else (eq_attr \"length\" \"4\")\n-\t\t     (const_string \"yes\")\n-\t\t     (const_string \"no\")))\n-  (set (attr \"length\") \n-       (if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2048))\n-\t\t\t  (le (minus (match_dup 0) (pc)) (const_int 2044)))\n-\t\t     (const_int 2)\n-\t\t     (const_int 4)))])\n-\n-\n-(define_expand \"beq\"\n-  [(set (pc) (if_then_else (eq (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bne\"\n-  [(set (pc) (if_then_else (ne (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bge\"\n-  [(set (pc) (if_then_else (ge (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"ble\"\n-  [(set (pc) (if_then_else (le (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc) (if_then_else (gt (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"blt\"\n-  [(set (pc) (if_then_else (lt (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc) (if_then_else (geu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc) (if_then_else (leu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc) (if_then_else (gtu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc) (if_then_else (ltu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*cond_branch\"\n-  [(set (pc) (if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t    [(cc0) (const_int 0)])\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n-\t\t\t   (pc)))]\n-  \"\"\n-  \"*\n-  switch (get_attr_length (insn))\n-    {\n-    case 2:  return \\\"b%d1\\\\t%l0\\\\t%@cond_branch\\\";\n-    case 4:  return \\\"b%D1\\\\t.LCB%=\\;b\\\\t%l0\\\\t%@long jump\\\\n.LCB%=:\\\";\n-    default: return \\\"b%D1\\\\t.LCB%=\\;bl\\\\t%l0\\\\t%@far jump\\\\n.LCB%=:\\\";\n-    }\n-\"[(set (attr \"far_jump\")\n-       (if_then_else (eq_attr \"length\" \"6\")\n-\t\t     (const_string \"yes\")\n-\t\t     (const_string \"no\")))\n-  (set (attr \"length\") \n-       (if_then_else\n-\t(and (ge (minus (match_dup 0) (pc)) (const_int -252))\n-\t     (le (minus (match_dup 0) (pc)) (const_int 254)))\n-\t(const_int 2)\n-\t(if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2044))\n-\t\t\t   (le (minus (match_dup 0) (pc)) (const_int 2044)))\n-\t\t      (const_int 4)\n-\t\t      (const_int 6))))])\n-\n-(define_insn \"*cond_branch_reversed\"\n-  [(set (pc) (if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t    [(cc0) (const_int 0)])\n-\t\t\t   (pc)\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  switch (get_attr_length (insn))\n-    {\n-    case 2:  return \\\"b%D1\\\\t%l0\\\\t%@cond_branch_reversed\\\";\n-    case 4:  return \\\"b%d1\\\\t.LCBR%=\\;b\\\\t%l0\\\\t%@long jump\\\\n.LCBR%=:\\\";\n-    default: return \\\"b%d1\\\\t.LCBR%=\\;bl\\\\t%l0\\\\t%@far jump\\\\n.LCBR%=:\\\";\n-    }\n-  return \\\"\\\";\n-\"[(set (attr \"far_jump\")\n-       (if_then_else (eq_attr \"length\" \"6\")\n-\t\t     (const_string \"yes\")\n-\t\t     (const_string \"no\")))\n-   (set (attr \"length\") \n-       (if_then_else\n-\t(and (ge (minus (match_dup 0) (pc)) (const_int -252))\n-\t     (le (minus (match_dup 0) (pc)) (const_int 254)))\n-\t(const_int 2)\n-\t(if_then_else (and (ge (minus (match_dup 0) (pc)) (const_int -2044))\n-\t\t\t   (le (minus (match_dup 0) (pc)) (const_int 2044)))\n-\t\t      (const_int 4)\n-\t\t      (const_int 6))))])\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"l*r\"))]\n-  \"\"\n-  \"mov\\\\tpc, %0\")\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"l*r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"mov\\\\tpc, %0\")\n-\n-(define_insn \"return\"\n-  [(return)]\n-  \"USE_RETURN\"\n-  \"* return output_return ();\"\n-[(set_attr \"length\" \"18\")])\n-\n-;; Call insns\n-\n-(define_expand \"call\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"\")\n-\t (match_operand 1 \"\" \"\"))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*call_indirect\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n-\t (match_operand 1 \"\" \"\"))]\n-  \"! TARGET_CALLER_INTERWORKING\"\n-  \"bl\\\\t%__call_via_%0\"\n-[(set_attr \"length\" \"4\")])\n-;; The non THUMB_INTERWORK, non TARGET_CALLER_INTERWORKING version\n-;; used to be: \"mov\\\\tlr,pc\\;bx\\\\t%0\", but the mov does not set\n-;; the bottom bit of lr so that a function return (using bx)\n-;; would switch back into ARM mode...\n-\n-(define_insn \"*call_indirect_interwork\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n-\t (match_operand 1 \"\" \"\"))]\n-  \"TARGET_CALLER_INTERWORKING\"\n-  \"bl\\\\t%__interwork_call_via_%0\"\n-[(set_attr \"length\" \"4\")])\n-\n-(define_expand \"call_value\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (match_operand 1 \"memory_operand\" \"\")\n-\t      (match_operand 2 \"\" \"\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*call_value_indirect\"\n-  [(set (match_operand 0 \"\" \"=l\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n-\t      (match_operand 2 \"\" \"\")))]\n-  \"! TARGET_CALLER_INTERWORKING\"\n-  \"bl\\\\t%__call_via_%1\"\n-[(set_attr \"length\" \"4\")])\n-;; See comment for call_indirect pattern\n-\n-(define_insn \"*call_value_indirect_interwork\"\n-  [(set (match_operand 0 \"\" \"=l\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n-\t      (match_operand 2 \"\" \"\")))]\n-  \"TARGET_CALLER_INTERWORKING\"\n-  \"bl\\\\t%__interwork_call_via_%1\"\n-[(set_attr \"length\" \"4\")])\n-\n-\n-(define_insn \"*call_insn\"\n-  [(call (mem:SI (match_operand:SI 0 \"\" \"X\"))\n-\t (match_operand:SI 1 \"\" \"\"))]\n-  \"GET_CODE (operands[0]) == SYMBOL_REF\"\n-  \"bl\\\\t%a0\"\n-[(set_attr \"length\" \"4\")])\n-\n-(define_insn \"*call_value_insn\"\n-  [(set (match_operand 0 \"register_operand\" \"=l\")\n-\t(call (mem:SI (match_operand 1 \"\" \"X\"))\n-\t      (match_operand 2 \"\" \"\")))]\n-  \"GET_CODE (operands[1]) == SYMBOL_REF\"\n-  \"bl\\\\t%a1\"\n-[(set_attr \"length\" \"4\")])\n-\n-;; Untyped call not required, since all funcs return in r0\n-\n-;; Miscellaneous patterns\n-\n-(define_insn \"nop\"\n-  [(clobber (const_int 0))]\n-  \"\"\n-  \"mov\\\\tr8, r8\")\n-\n-(define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n-  \"\"\n-  \"\"\n-  [(set_attr \"length\" \"0\")])\n-\n-(define_expand \"prologue\"\n-  [(const_int 0)]\n-  \"\"\n-  \"\n-  thumb_expand_prologue ();\n-  DONE;\n-\")\n-\n-(define_expand \"epilogue\"\n-  [(unspec_volatile [(return)] 1)]\n-  \"! thumb_trivial_epilogue ()\"\n-  \"\n-  thumb_expand_epilogue ();\n-  emit_jump_insn (gen_rtx_UNSPEC_VOLATILE (VOIDmode,\n-\tgen_rtvec (1, gen_rtx_RETURN (VOIDmode)), 1));\n-  DONE;\n-\")\n-\n-(define_insn \"*epilogue_insns\"\n-  [(unspec_volatile [(return)] 1)]\n-  \"\"\n-  \"*\n-  return thumb_unexpanded_epilogue ();\n-\"\n-[(set_attr \"length\" \"42\")])\n-\n-;; Special patterns for dealing with the constant pool\n-\n-(define_insn \"consttable_4\"\n- [(unspec_volatile [(match_operand 0 \"\" \"\")] 2)]\n- \"\"\n- \"*\n-{\n-  making_const_table = TRUE;\n-  switch (GET_MODE_CLASS (GET_MODE (operands[0])))\n-    {\n-    case MODE_FLOAT:\n-    {\n-      union real_extract u;\n-      bcopy ((char *) &CONST_DOUBLE_LOW (operands[0]), (char *) &u, sizeof u);\n-      assemble_real (u.d, GET_MODE (operands[0]));\n-      break;\n-    }\n-    default:\n-      assemble_integer (operands[0], 4, 1);\n-      break;\n-    }\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"length\" \"4\")])\n-\n-(define_insn \"consttable_8\"\n- [(unspec_volatile [(match_operand 0 \"\" \"\")] 3)]\n- \"\"\n- \"*\n-{\n-  making_const_table = TRUE;\n-  switch (GET_MODE_CLASS (GET_MODE (operands[0])))\n-    {\n-    case MODE_FLOAT:\n-    {\n-      union real_extract u;\n-      bcopy ((char *) &CONST_DOUBLE_LOW (operands[0]), (char *) &u, sizeof u);\n-      assemble_real (u.d, GET_MODE (operands[0]));\n-      break;\n-    }\n-    default:\n-      assemble_integer (operands[0], 8, 1);\n-      break;\n-    }\n-  return \\\"\\\";\n-}\"\n-[(set_attr \"length\" \"8\")])\n-\n-(define_insn \"consttable_end\"\n-  [(unspec_volatile [(const_int 0)] 4)]\n-  \"\"\n-  \"*\n-  making_const_table = FALSE;\n-  return \\\"\\\";\n-\")\n-\n-(define_insn \"align_4\"\n- [(unspec_volatile [(const_int 0)] 5)]\n- \"\"\n- \"*\n-   extern void assemble_align ();\n-   assemble_align (32);\n-   return \\\"\\\";\n-\")\n-\n-/* When generating pic, we need to load the symbol offset into a register.\n-   So that the optimizer does not confuse this with a normal symbol load\n-   we use an unspec.  The offset will be loaded from a constant pool entry,\n-   since that is the only type of relocation we can use.  */\n-\n-(define_insn \"pic_load_addr\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec:SI [(match_operand 1 \"\" \"\")] 3))]\n-  \"flag_pic\"\n-  \"ldr\\\\t%0, %a1\")\n-\n-(define_insn \"pic_add_dot_plus_four\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"+r\")\n-\t(plus:SI (match_dup 0) (const (plus:SI (pc) (const_int 4)))))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"flag_pic\"\n-  \"*\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n-\t\t\t     CODE_LABEL_NUMBER (operands[1]));\n-  return \\\"add\\\\t%0, %|pc\\\";\n-\")\n-"}]}