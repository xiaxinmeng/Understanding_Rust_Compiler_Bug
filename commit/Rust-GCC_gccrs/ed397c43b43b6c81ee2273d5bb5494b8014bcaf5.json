{"sha": "ed397c43b43b6c81ee2273d5bb5494b8014bcaf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQzOTdjNDNiNDNiNmM4MWVlMjI3M2Q1YmI1NDk0YjgwMTRiY2FmNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-25T19:12:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-25T19:12:02Z"}, "message": "tree-inline.c (remap_type): Arrange to have just one pointer type for each type, mode, and 'can alias' value.\n\n\t* tree-inline.c (remap_type): Arrange to have just one pointer type\n\tfor each type, mode, and 'can alias' value.\n\t(setup_one_parameter): Remap type when making VAR_DECL for PARM_DECL.\n\t(estimate_num_insns_1): Minor code reformatting.\n\t(inline_forbidden_p_1): Likewise; add; missing return statement.\n\nFrom-SVN: r83672", "tree": {"sha": "01920aa4382433c5fc68edcab47ac5116b0f0dcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01920aa4382433c5fc68edcab47ac5116b0f0dcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed397c43b43b6c81ee2273d5bb5494b8014bcaf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed397c43b43b6c81ee2273d5bb5494b8014bcaf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed397c43b43b6c81ee2273d5bb5494b8014bcaf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed397c43b43b6c81ee2273d5bb5494b8014bcaf5/comments", "author": null, "committer": null, "parents": [{"sha": "0fe0c61499096286867bcee0df3dfbba3d3f7cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe0c61499096286867bcee0df3dfbba3d3f7cba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe0c61499096286867bcee0df3dfbba3d3f7cba"}], "stats": {"total": 59, "additions": 39, "deletions": 20}, "files": [{"sha": "1544bd23cf4ae550812092a1c59c712a1b1624cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed397c43b43b6c81ee2273d5bb5494b8014bcaf5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed397c43b43b6c81ee2273d5bb5494b8014bcaf5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed397c43b43b6c81ee2273d5bb5494b8014bcaf5", "patch": "@@ -1,3 +1,11 @@\n+2004-06-24  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree-inline.c (remap_type): Arrange to have just one pointer type\n+\tfor each type, mode, and 'can alias' value.\n+\t(setup_one_parameter): Remap type when making VAR_DECL for PARM_DECL.\n+\t(estimate_num_insns_1): Minor code reformatting.\n+\t(inline_forbidden_p_1): Likewise; add; missing return statement.\n+\n 2004-06-25  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/15825"}, {"sha": "e9bb3001555132666aeb4a21309da2867dfe4b1b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed397c43b43b6c81ee2273d5bb5494b8014bcaf5/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed397c43b43b6c81ee2273d5bb5494b8014bcaf5/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ed397c43b43b6c81ee2273d5bb5494b8014bcaf5", "patch": "@@ -250,8 +250,28 @@ remap_type (tree type, inline_data *id)\n       return type;\n     }\n   \n-  /* We do need a copy.  build and register it now.  */\n-  new = copy_node (type);\n+  /* We do need a copy.  build and register it now.  If this is a pointer or\n+     reference type, remap the designated type and make a new pointer or\n+     reference type.  */\n+  if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      new = build_pointer_type_for_mode (remap_type (TREE_TYPE (type), id),\n+\t\t\t\t\t TYPE_MODE (type),\n+\t\t\t\t\t TYPE_REF_CAN_ALIAS_ALL (type));\n+      insert_decl_map (id, type, new);\n+      return new;\n+    }\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      new = build_reference_type_for_mode (remap_type (TREE_TYPE (type), id),\n+\t\t\t\t\t    TYPE_MODE (type),\n+\t\t\t\t\t    TYPE_REF_CAN_ALIAS_ALL (type));\n+      insert_decl_map (id, type, new);\n+      return new;\n+    }\n+  else\n+    new = copy_node (type);\n+\n   insert_decl_map (id, type, new);\n \n   /* This is a new type, not a copy of an old type.  Need to reassociate\n@@ -290,19 +310,6 @@ remap_type (tree type, inline_data *id)\n         walk_tree (&TYPE_MAX_VALUE (new), copy_body_r, id, NULL);\n       return new;\n     \n-    case POINTER_TYPE:\n-      TREE_TYPE (new) = t = remap_type (TREE_TYPE (new), id);\n-      TYPE_NEXT_PTR_TO (new) = TYPE_POINTER_TO (t);\n-      TYPE_POINTER_TO (t) = new;\n-      return new;\n-\n-    case REFERENCE_TYPE:\n-      TREE_TYPE (new) = t = remap_type (TREE_TYPE (new), id);\n-      TYPE_NEXT_REF_TO (new) = TYPE_REFERENCE_TO (t);\n-      TYPE_REFERENCE_TO (t) = new;\n-      return new;\n-\n-    case METHOD_TYPE:\n     case FUNCTION_TYPE:\n       TREE_TYPE (new) = remap_type (TREE_TYPE (new), id);\n       walk_tree (&TYPE_ARG_TYPES (new), copy_body_r, id, NULL);\n@@ -733,8 +740,9 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n \t}\n     }\n \n-  /* Make an equivalent VAR_DECL.  */\n+  /* Make an equivalent VAR_DECL with the remapped type.  */\n   var = copy_decl_for_inlining (p, fn, VARRAY_TREE (id->fns, 0));\n+  TREE_TYPE (var) = remap_type (TREE_TYPE (var), id);\n \n   /* See if the frontend wants to pass this by invisible reference.  If\n      so, our new VAR_DECL will have REFERENCE_TYPE, and we need to\n@@ -1048,6 +1056,7 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t  inline_forbidden_reason\n \t    = N_(\"%Jfunction '%F' can never be inlined \"\n \t\t \"because it receives a non-local goto\");\n+\t  return node;\n \t}\n       break;\n \n@@ -1084,8 +1093,9 @@ static tree\n inline_forbidden_p (tree fndecl)\n {\n   location_t saved_loc = input_location;\n-  tree ret = walk_tree_without_duplicates\n-\t\t(&DECL_SAVED_TREE (fndecl), inline_forbidden_p_1, fndecl);\n+  tree ret = walk_tree_without_duplicates (&DECL_SAVED_TREE (fndecl),\n+\t\t\t\t\t   inline_forbidden_p_1, fndecl);\n+\n   input_location = saved_loc;\n   return ret;\n }\n@@ -1180,9 +1190,10 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n   /* Assume that constants and references counts nothing.  These should\n      be majorized by amount of operations among them we count later\n      and are common target of CSE and similar optimizations.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (x)) == 'c'\n-      || TREE_CODE_CLASS (TREE_CODE (x)) == 'r')\n+  else if (TREE_CODE_CLASS (TREE_CODE (x)) == 'c'\n+\t   || TREE_CODE_CLASS (TREE_CODE (x)) == 'r')\n     return NULL;\n+\n   switch (TREE_CODE (x))\n     { \n     /* Containers have no cost.  */"}]}