{"sha": "5826cacf19dceb35b0f176d1165cadc4363ab8ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgyNmNhY2YxOWRjZWIzNWIwZjE3NmQxMTY1Y2FkYzQzNjNhYjhmZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "1999-12-06T17:28:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1999-12-06T17:28:18Z"}, "message": "fold-const.c (optimize_bit_field_compare): Only use one mode for both RHS and LHS in non-constant case.\n\n\t* fold-const.c (optimize_bit_field_compare): Only use one mode\n\tfor both RHS and LHS in non-constant case.\n\nFrom-SVN: r30800", "tree": {"sha": "a0bff444b2dc83cdd65c21c6cc185a61cccd79e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0bff444b2dc83cdd65c21c6cc185a61cccd79e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5826cacf19dceb35b0f176d1165cadc4363ab8ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5826cacf19dceb35b0f176d1165cadc4363ab8ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5826cacf19dceb35b0f176d1165cadc4363ab8ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5826cacf19dceb35b0f176d1165cadc4363ab8ff/comments", "author": null, "committer": null, "parents": [{"sha": "d593d1d2b8519bb9acf53566f7798dfb6c4c384b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d593d1d2b8519bb9acf53566f7798dfb6c4c384b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d593d1d2b8519bb9acf53566f7798dfb6c4c384b"}], "stats": {"total": 62, "additions": 25, "deletions": 37}, "files": [{"sha": "a223d3303d1108cd3450b7ecdc5a0569fca53443", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5826cacf19dceb35b0f176d1165cadc4363ab8ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5826cacf19dceb35b0f176d1165cadc4363ab8ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5826cacf19dceb35b0f176d1165cadc4363ab8ff", "patch": "@@ -1,3 +1,8 @@\n+Mon Dec  6 12:24:52 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* fold-const.c (optimize_bit_field_compare): Only use one mode\n+\tfor both RHS and LHS in non-constant case.\n+\n 1999-12-06  Nathan Sidwell  <nathan@acm.org>\n \n \t* frame.c (start_fde_sort): Only allocate erratic array, if"}, {"sha": "c13b907192bc555cd873ba3d1dad8cf8098d7bf2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5826cacf19dceb35b0f176d1165cadc4363ab8ff/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5826cacf19dceb35b0f176d1165cadc4363ab8ff/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5826cacf19dceb35b0f176d1165cadc4363ab8ff", "patch": "@@ -2809,12 +2809,11 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n      tree compare_type;\n      tree lhs, rhs;\n {\n-  int lbitpos, lbitsize, rbitpos, rbitsize;\n-  int lnbitpos, lnbitsize, rnbitpos = 0, rnbitsize = 0;\n+  int lbitpos, lbitsize, rbitpos, rbitsize, nbitpos, nbitsize;\n   tree type = TREE_TYPE (lhs);\n   tree signed_type, unsigned_type;\n   int const_p = TREE_CODE (rhs) == INTEGER_CST;\n-  enum machine_mode lmode, rmode, lnmode, rnmode = VOIDmode;\n+  enum machine_mode lmode, rmode, nmode;\n   int lunsignedp, runsignedp;\n   int lvolatilep = 0, rvolatilep = 0;\n   int alignment;\n@@ -2848,67 +2847,51 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n \n   /* See if we can find a mode to refer to this field.  We should be able to,\n      but fail if we can't.  */\n-  lnmode = get_best_mode (lbitsize, lbitpos,\n-\t\t\t  TYPE_ALIGN (TREE_TYPE (linner)), word_mode,\n-\t\t\t  lvolatilep);\n-  if (lnmode == VOIDmode)\n+  nmode = get_best_mode (lbitsize, lbitpos,\n+\t\t\t const_p ? TYPE_ALIGN (TREE_TYPE (linner))\n+\t\t\t : MIN (TYPE_ALIGN (TREE_TYPE (linner)),\n+\t\t\t\tTYPE_ALIGN (TREE_TYPE (rinner))),\n+\t\t\t word_mode, lvolatilep || rvolatilep);\n+  if (nmode == VOIDmode)\n     return 0;\n \n   /* Set signed and unsigned types of the precision of this mode for the\n      shifts below.  */\n-  signed_type = type_for_mode (lnmode, 0);\n-  unsigned_type = type_for_mode (lnmode, 1);\n+  signed_type = type_for_mode (nmode, 0);\n+  unsigned_type = type_for_mode (nmode, 1);\n \n-  if (! const_p)\n-    {\n-      rnmode = get_best_mode (rbitsize, rbitpos, \n-\t\t\t      TYPE_ALIGN (TREE_TYPE (rinner)), word_mode,\n-\t\t\t      rvolatilep);\n-      if (rnmode == VOIDmode)\n-\treturn 0;\n-    }\n-    \n   /* Compute the bit position and size for the new reference and our offset\n      within it. If the new reference is the same size as the original, we\n      won't optimize anything, so return zero.  */\n-  lnbitsize = GET_MODE_BITSIZE (lnmode);\n-  lnbitpos = lbitpos & ~ (lnbitsize - 1);\n-  lbitpos -= lnbitpos;\n-  if (lnbitsize == lbitsize)\n+  nbitsize = GET_MODE_BITSIZE (nmode);\n+  nbitpos = lbitpos & ~ (nbitsize - 1);\n+  lbitpos -= nbitpos;\n+  if (nbitsize == lbitsize)\n     return 0;\n \n-  if (! const_p)\n-    {\n-      rnbitsize = GET_MODE_BITSIZE (rnmode);\n-      rnbitpos = rbitpos & ~ (rnbitsize - 1);\n-      rbitpos -= rnbitpos;\n-      if (rnbitsize == rbitsize)\n-\treturn 0;\n-    }\n-\n   if (BYTES_BIG_ENDIAN)\n-    lbitpos = lnbitsize - lbitsize - lbitpos;\n+    lbitpos = nbitsize - lbitsize - lbitpos;\n \n   /* Make the mask to be used against the extracted field.  */\n   mask = build_int_2 (~0, ~0);\n   TREE_TYPE (mask) = unsigned_type;\n   force_fit_type (mask, 0);\n   mask = convert (unsigned_type, mask);\n-  mask = const_binop (LSHIFT_EXPR, mask, size_int (lnbitsize - lbitsize), 0);\n+  mask = const_binop (LSHIFT_EXPR, mask, size_int (nbitsize - lbitsize), 0);\n   mask = const_binop (RSHIFT_EXPR, mask,\n-\t\t      size_int (lnbitsize - lbitsize - lbitpos), 0);\n+\t\t      size_int (nbitsize - lbitsize - lbitpos), 0);\n \n   if (! const_p)\n     /* If not comparing with constant, just rework the comparison\n        and return.  */\n     return build (code, compare_type,\n \t\t  build (BIT_AND_EXPR, unsigned_type,\n \t\t\t make_bit_field_ref (linner, unsigned_type,\n-\t\t\t\t\t     lnbitsize, lnbitpos, 1),\n+\t\t\t\t\t     nbitsize, nbitpos, 1),\n \t\t\t mask),\n \t\t  build (BIT_AND_EXPR, unsigned_type,\n \t\t\t make_bit_field_ref (rinner, unsigned_type,\n-\t\t\t\t\t     rnbitsize, rnbitpos, 1),\n+\t\t\t\t\t     nbitsize, nbitpos, 1),\n \t\t\t mask));\n \n   /* Otherwise, we are handling the constant case. See if the constant is too\n@@ -2957,7 +2940,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n   /* Make a new bitfield reference, shift the constant over the\n      appropriate number of bits and mask it with the computed mask\n      (in case this was a signed field).  If we changed it, make a new one.  */\n-  lhs = make_bit_field_ref (linner, unsigned_type, lnbitsize, lnbitpos, 1);\n+  lhs = make_bit_field_ref (linner, unsigned_type, nbitsize, nbitpos, 1);\n   if (lvolatilep)\n     {\n       TREE_SIDE_EFFECTS (lhs) = 1;"}]}