{"sha": "bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNjN2UzNDZiZjliNWRjNzc3OTdlYTk0OWQ2YWRjNzQwZGViMzBjYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-16T10:40:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-16T10:40:23Z"}, "message": "Optionally pick the cheapest loop_vec_info\n\nThis patch adds a mode in which the vectoriser tries each available\nbase vector mode and picks the one with the lowest cost.  The new\nbehaviour is selected by autovectorize_vector_modes.\n\nThe patch keeps the current behaviour of preferring a VF of\nloop->simdlen over any larger or smaller VF, regardless of costs\nor target preferences.\n\n2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.h (VECT_COMPARE_COSTS): New constant.\n\t* target.def (autovectorize_vector_modes): Return a bitmask of flags.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_autovectorize_vector_modes): Update accordingly.\n\t* targhooks.c (default_autovectorize_vector_modes): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_autovectorize_vector_modes):\n\tLikewise.\n\t* config/arc/arc.c (arc_autovectorize_vector_modes): Likewise.\n\t* config/arm/arm.c (arm_autovectorize_vector_modes): Likewise.\n\t* config/i386/i386.c (ix86_autovectorize_vector_modes): Likewise.\n\t* config/mips/mips.c (mips_autovectorize_vector_modes): Likewise.\n\t* tree-vectorizer.h (_loop_vec_info::vec_outside_cost)\n\t(_loop_vec_info::vec_inside_cost): New member variables.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize them.\n\t(vect_better_loop_vinfo_p, vect_joust_loop_vinfos): New functions.\n\t(vect_analyze_loop): When autovectorize_vector_modes returns\n\tVECT_COMPARE_COSTS, try vectorizing the loop with each available\n\tvector mode and picking the one with the lowest cost.\n\t(vect_estimate_min_profitable_iters): Record the computed costs\n\tin the loop_vec_info.\n\nFrom-SVN: r278336", "tree": {"sha": "5423a73f6ef55339cc766316b3d0e9113cf70129", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5423a73f6ef55339cc766316b3d0e9113cf70129"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f884cd2fea62eebe71b422e1c97e550958dd42ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f884cd2fea62eebe71b422e1c97e550958dd42ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f884cd2fea62eebe71b422e1c97e550958dd42ae"}], "stats": {"total": 238, "additions": 219, "deletions": 19}, "files": [{"sha": "f809def56c4b4cf0541c4be560183bed511bb0b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -1,3 +1,26 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.h (VECT_COMPARE_COSTS): New constant.\n+\t* target.def (autovectorize_vector_modes): Return a bitmask of flags.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_autovectorize_vector_modes): Update accordingly.\n+\t* targhooks.c (default_autovectorize_vector_modes): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_autovectorize_vector_modes):\n+\tLikewise.\n+\t* config/arc/arc.c (arc_autovectorize_vector_modes): Likewise.\n+\t* config/arm/arm.c (arm_autovectorize_vector_modes): Likewise.\n+\t* config/i386/i386.c (ix86_autovectorize_vector_modes): Likewise.\n+\t* config/mips/mips.c (mips_autovectorize_vector_modes): Likewise.\n+\t* tree-vectorizer.h (_loop_vec_info::vec_outside_cost)\n+\t(_loop_vec_info::vec_inside_cost): New member variables.\n+\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize them.\n+\t(vect_better_loop_vinfo_p, vect_joust_loop_vinfos): New functions.\n+\t(vect_analyze_loop): When autovectorize_vector_modes returns\n+\tVECT_COMPARE_COSTS, try vectorizing the loop with each available\n+\tvector mode and picking the one with the lowest cost.\n+\t(vect_estimate_min_profitable_iters): Record the computed costs\n+\tin the loop_vec_info.\n+\n 2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (can_duplicate_and_interleave_p): Take an"}, {"sha": "e2251a2ef324c9464164f8e1ab312cb652d3fb11", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -15935,7 +15935,7 @@ aarch64_preferred_simd_mode (scalar_mode mode)\n \n /* Return a list of possible vector sizes for the vectorizer\n    to iterate over.  */\n-static void\n+static unsigned int\n aarch64_autovectorize_vector_modes (vector_modes *modes, bool)\n {\n   if (TARGET_SVE)\n@@ -15961,6 +15961,8 @@ aarch64_autovectorize_vector_modes (vector_modes *modes, bool)\n      TODO: We could similarly support limited forms of V2QImode and V2HImode\n      for this case.  */\n   modes->safe_push (V2SImode);\n+\n+  return 0;\n }\n \n /* Implement TARGET_MANGLE_TYPE.  */"}, {"sha": "115500e56da445aa79e3b474b7f5da9683e3d7bc", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -609,14 +609,15 @@ arc_preferred_simd_mode (scalar_mode mode)\n /* Implements target hook\n    TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES.  */\n \n-static void\n+static unsigned int\n arc_autovectorize_vector_modes (vector_modes *modes, bool)\n {\n   if (TARGET_PLUS_QMACW)\n     {\n       modes->quick_push (V4HImode);\n       modes->quick_push (V2HImode);\n     }\n+  return 0;\n }\n \n "}, {"sha": "1fd30c238cdb4c0c7db9966a78e41e8bb9d34140", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -288,7 +288,7 @@ static bool arm_builtin_support_vector_misalignment (machine_mode mode,\n static void arm_conditional_register_usage (void);\n static enum flt_eval_method arm_excess_precision (enum excess_precision_type);\n static reg_class_t arm_preferred_rename_class (reg_class_t rclass);\n-static void arm_autovectorize_vector_modes (vector_modes *, bool);\n+static unsigned int arm_autovectorize_vector_modes (vector_modes *, bool);\n static int arm_default_branch_cost (bool, bool);\n static int arm_cortex_a5_branch_cost (bool, bool);\n static int arm_cortex_m_branch_cost (bool, bool);\n@@ -29015,14 +29015,15 @@ arm_vector_alignment (const_tree type)\n   return align;\n }\n \n-static void\n+static unsigned int\n arm_autovectorize_vector_modes (vector_modes *modes, bool)\n {\n   if (!TARGET_NEON_VECTORIZE_DOUBLE)\n     {\n       modes->safe_push (V16QImode);\n       modes->safe_push (V8QImode);\n     }\n+  return 0;\n }\n \n static bool"}, {"sha": "bb5dc1441753ce39968d1142d5b8bf1d2fcf3a46", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -21384,7 +21384,7 @@ ix86_preferred_simd_mode (scalar_mode mode)\n    vectors.  If AVX512F is enabled then try vectorizing with 512bit,\n    256bit and 128bit vectors.  */\n \n-static void\n+static unsigned int\n ix86_autovectorize_vector_modes (vector_modes *modes, bool all)\n {\n   if (TARGET_AVX512F && !TARGET_PREFER_AVX256)\n@@ -21414,6 +21414,8 @@ ix86_autovectorize_vector_modes (vector_modes *modes, bool all)\n \n   if (TARGET_MMX_WITH_SSE)\n     modes->safe_push (V8QImode);\n+\n+  return 0;\n }\n \n /* Implemenation of targetm.vectorize.get_mask_mode.  */"}, {"sha": "6341216d1bc008f32990e12c8161d0f28ddb78b8", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -13455,11 +13455,12 @@ mips_preferred_simd_mode (scalar_mode mode)\n \n /* Implement TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES.  */\n \n-static void\n+static unsigned int\n mips_autovectorize_vector_modes (vector_modes *modes, bool)\n {\n   if (ISA_HAS_MSA)\n     modes->safe_push (V16QImode);\n+  return 0;\n }\n \n /* Implement TARGET_INIT_LIBFUNCS.  */"}, {"sha": "a3eba282464b842093248b015be0f2e99834a94d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -6008,7 +6008,7 @@ against lower halves of vectors recursively until the specified mode is\n reached.  The default is @var{mode} which means no splitting.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES (vector_modes *@var{modes}, bool @var{all})\n+@deftypefn {Target Hook} {unsigned int} TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES (vector_modes *@var{modes}, bool @var{all})\n If using the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}\n is not the only approach worth considering, this hook should add one mode to\n @var{modes} for each useful alternative approach.  These modes are then\n@@ -6024,9 +6024,19 @@ element mode.\n If @var{all} is true, add suitable vector modes even when they are generally\n not expected to be worthwhile.\n \n+The hook returns a bitmask of flags that control how the modes in\n+@var{modes} are used.  The flags are:\n+@table @code\n+@item VECT_COMPARE_COSTS\n+Tells the loop vectorizer to try all the provided modes and pick the one\n+with the lowest cost.  By default the vectorizer will choose the first\n+mode that works.\n+@end table\n+\n The hook does not need to do anything if the vector returned by\n @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is the only one relevant\n-for autovectorization.  The default implementation does nothing.\n+for autovectorization.  The default implementation adds no modes and\n+returns 0.\n @end deftypefn\n \n @deftypefn {Target Hook} opt_machine_mode TARGET_VECTORIZE_RELATED_MODE (machine_mode @var{vector_mode}, scalar_mode @var{element_mode}, poly_uint64 @var{nunits})"}, {"sha": "e705c5d14d9f36f3784a1bd8dd06861d8ebdbf79", "filename": "gcc/target.def", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -1925,10 +1925,20 @@ element mode.\\n\\\n If @var{all} is true, add suitable vector modes even when they are generally\\n\\\n not expected to be worthwhile.\\n\\\n \\n\\\n+The hook returns a bitmask of flags that control how the modes in\\n\\\n+@var{modes} are used.  The flags are:\\n\\\n+@table @code\\n\\\n+@item VECT_COMPARE_COSTS\\n\\\n+Tells the loop vectorizer to try all the provided modes and pick the one\\n\\\n+with the lowest cost.  By default the vectorizer will choose the first\\n\\\n+mode that works.\\n\\\n+@end table\\n\\\n+\\n\\\n The hook does not need to do anything if the vector returned by\\n\\\n @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is the only one relevant\\n\\\n-for autovectorization.  The default implementation does nothing.\",\n- void,\n+for autovectorization.  The default implementation adds no modes and\\n\\\n+returns 0.\",\n+ unsigned int,\n  (vector_modes *modes, bool all),\n  default_autovectorize_vector_modes)\n "}, {"sha": "2c5b59be851102ef9513510a8689aab7229702fe", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -218,6 +218,14 @@ enum omp_device_kind_arch_isa {\n   omp_device_isa\n };\n \n+/* Flags returned by TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES:\n+\n+   VECT_COMPARE_COSTS\n+       Tells the loop vectorizer to try all the provided modes and\n+       pick the one with the lowest cost.  By default the vectorizer\n+       will choose the first mode that works.  */\n+const unsigned int VECT_COMPARE_COSTS = 1U << 0;\n+\n /* The target structure.  This holds all the backend hooks.  */\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME) PARAMS;"}, {"sha": "fd8e43565c3088b61a35740853ef15cac56c653d", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -1300,9 +1300,10 @@ default_split_reduction (machine_mode mode)\n \n /* By default only the preferred vector mode is tried.  */\n \n-void\n+unsigned int\n default_autovectorize_vector_modes (vector_modes *, bool)\n {\n+  return 0;\n }\n \n /* The default implementation of TARGET_VECTORIZE_RELATED_MODE.  */"}, {"sha": "e041291347ba36d19737044155845d9f4eb50310", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -113,7 +113,7 @@ default_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t     int, bool);\n extern machine_mode default_preferred_simd_mode (scalar_mode mode);\n extern machine_mode default_split_reduction (machine_mode);\n-extern void default_autovectorize_vector_modes (vector_modes *, bool);\n+extern unsigned int default_autovectorize_vector_modes (vector_modes *, bool);\n extern opt_machine_mode default_vectorize_related_mode (machine_mode,\n \t\t\t\t\t\t\tscalar_mode,\n \t\t\t\t\t\t\tpoly_uint64);"}, {"sha": "7a58dfc323a051fe21cfac7e780c85f4f520e20d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 141, "deletions": 7, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -829,6 +829,8 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     scan_map (NULL),\n     slp_unrolling_factor (1),\n     single_scalar_iteration_cost (0),\n+    vec_outside_cost (0),\n+    vec_inside_cost (0),\n     vectorizable (false),\n     can_fully_mask_p (true),\n     fully_masked_p (false),\n@@ -2374,6 +2376,80 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   goto start_over;\n }\n \n+/* Return true if vectorizing a loop using NEW_LOOP_VINFO appears\n+   to be better than vectorizing it using OLD_LOOP_VINFO.  Assume that\n+   OLD_LOOP_VINFO is better unless something specifically indicates\n+   otherwise.\n+\n+   Note that this deliberately isn't a partial order.  */\n+\n+static bool\n+vect_better_loop_vinfo_p (loop_vec_info new_loop_vinfo,\n+\t\t\t  loop_vec_info old_loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (new_loop_vinfo);\n+  gcc_assert (LOOP_VINFO_LOOP (old_loop_vinfo) == loop);\n+\n+  poly_int64 new_vf = LOOP_VINFO_VECT_FACTOR (new_loop_vinfo);\n+  poly_int64 old_vf = LOOP_VINFO_VECT_FACTOR (old_loop_vinfo);\n+\n+  /* Always prefer a VF of loop->simdlen over any other VF.  */\n+  if (loop->simdlen)\n+    {\n+      bool new_simdlen_p = known_eq (new_vf, loop->simdlen);\n+      bool old_simdlen_p = known_eq (old_vf, loop->simdlen);\n+      if (new_simdlen_p != old_simdlen_p)\n+\treturn new_simdlen_p;\n+    }\n+\n+  /* Limit the VFs to what is likely to be the maximum number of iterations,\n+     to handle cases in which at least one loop_vinfo is fully-masked.  */\n+  HOST_WIDE_INT estimated_max_niter = likely_max_stmt_executions_int (loop);\n+  if (estimated_max_niter != -1)\n+    {\n+      if (known_le (estimated_max_niter, new_vf))\n+\tnew_vf = estimated_max_niter;\n+      if (known_le (estimated_max_niter, old_vf))\n+\told_vf = estimated_max_niter;\n+    }\n+\n+  /* Check whether the (fractional) cost per scalar iteration is lower\n+     or higher: new_inside_cost / new_vf vs. old_inside_cost / old_vf.  */\n+  poly_widest_int rel_new = (new_loop_vinfo->vec_inside_cost\n+\t\t\t     * poly_widest_int (old_vf));\n+  poly_widest_int rel_old = (old_loop_vinfo->vec_inside_cost\n+\t\t\t     * poly_widest_int (new_vf));\n+  if (maybe_lt (rel_old, rel_new))\n+    return false;\n+  if (known_lt (rel_new, rel_old))\n+    return true;\n+\n+  /* If there's nothing to choose between the loop bodies, see whether\n+     there's a difference in the prologue and epilogue costs.  */\n+  if (new_loop_vinfo->vec_outside_cost != old_loop_vinfo->vec_outside_cost)\n+    return new_loop_vinfo->vec_outside_cost < old_loop_vinfo->vec_outside_cost;\n+\n+  return false;\n+}\n+\n+/* Decide whether to replace OLD_LOOP_VINFO with NEW_LOOP_VINFO.  Return\n+   true if we should.  */\n+\n+static bool\n+vect_joust_loop_vinfos (loop_vec_info new_loop_vinfo,\n+\t\t\tloop_vec_info old_loop_vinfo)\n+{\n+  if (!vect_better_loop_vinfo_p (new_loop_vinfo, old_loop_vinfo))\n+    return false;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"***** Preferring vector mode %s to vector mode %s\\n\",\n+\t\t     GET_MODE_NAME (new_loop_vinfo->vector_mode),\n+\t\t     GET_MODE_NAME (old_loop_vinfo->vector_mode));\n+  return true;\n+}\n+\n /* Function vect_analyze_loop.\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n@@ -2385,8 +2461,9 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n   auto_vector_modes vector_modes;\n \n   /* Autodetect first vector size we try.  */\n-  targetm.vectorize.autovectorize_vector_modes (&vector_modes,\n-\t\t\t\t\t\tloop->simdlen != 0);\n+  unsigned int autovec_flags\n+    = targetm.vectorize.autovectorize_vector_modes (&vector_modes,\n+\t\t\t\t\t\t    loop->simdlen != 0);\n   unsigned int mode_i = 0;\n \n   DUMP_VECT_SCOPE (\"analyze_loop_nest\");\n@@ -2409,6 +2486,8 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n   machine_mode next_vector_mode = VOIDmode;\n   poly_uint64 lowest_th = 0;\n   unsigned vectorized_loops = 0;\n+  bool pick_lowest_cost_p = ((autovec_flags & VECT_COMPARE_COSTS)\n+\t\t\t     && !unlimited_cost_model (loop));\n \n   bool vect_epilogues = false;\n   opt_result res = opt_result::success ();\n@@ -2429,6 +2508,34 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \n       bool fatal = false;\n \n+      /* When pick_lowest_cost_p is true, we should in principle iterate\n+\t over all the loop_vec_infos that LOOP_VINFO could replace and\n+\t try to vectorize LOOP_VINFO under the same conditions.\n+\t E.g. when trying to replace an epilogue loop, we should vectorize\n+\t LOOP_VINFO as an epilogue loop with the same VF limit.  When trying\n+\t to replace the main loop, we should vectorize LOOP_VINFO as a main\n+\t loop too.\n+\n+\t However, autovectorize_vector_modes is usually sorted as follows:\n+\n+\t - Modes that naturally produce lower VFs usually follow modes that\n+\t   naturally produce higher VFs.\n+\n+\t - When modes naturally produce the same VF, maskable modes\n+\t   usually follow unmaskable ones, so that the maskable mode\n+\t   can be used to vectorize the epilogue of the unmaskable mode.\n+\n+\t This order is preferred because it leads to the maximum\n+\t epilogue vectorization opportunities.  Targets should only use\n+\t a different order if they want to make wide modes available while\n+\t disparaging them relative to earlier, smaller modes.  The assumption\n+\t in that case is that the wider modes are more expensive in some\n+\t way that isn't reflected directly in the costs.\n+\n+\t There should therefore be few interesting cases in which\n+\t LOOP_VINFO fails when treated as an epilogue loop, succeeds when\n+\t treated as a standalone loop, and ends up being genuinely cheaper\n+\t than FIRST_LOOP_VINFO.  */\n       if (vect_epilogues)\n \tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = first_loop_vinfo;\n \n@@ -2476,13 +2583,34 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t      LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = NULL;\n \t      simdlen = 0;\n \t    }\n+\t  else if (pick_lowest_cost_p && first_loop_vinfo)\n+\t    {\n+\t      /* Keep trying to roll back vectorization attempts while the\n+\t\t loop_vec_infos they produced were worse than this one.  */\n+\t      vec<loop_vec_info> &vinfos = first_loop_vinfo->epilogue_vinfos;\n+\t      while (!vinfos.is_empty ()\n+\t\t     && vect_joust_loop_vinfos (loop_vinfo, vinfos.last ()))\n+\t\t{\n+\t\t  gcc_assert (vect_epilogues);\n+\t\t  delete vinfos.pop ();\n+\t\t}\n+\t      if (vinfos.is_empty ()\n+\t\t  && vect_joust_loop_vinfos (loop_vinfo, first_loop_vinfo))\n+\t\t{\n+\t\t  delete first_loop_vinfo;\n+\t\t  first_loop_vinfo = opt_loop_vec_info::success (NULL);\n+\t\t  LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = NULL;\n+\t\t}\n+\t    }\n \n \t  if (first_loop_vinfo == NULL)\n \t    {\n \t      first_loop_vinfo = loop_vinfo;\n \t      lowest_th = LOOP_VINFO_VERSIONING_THRESHOLD (first_loop_vinfo);\n \t    }\n-\t  else if (vect_epilogues)\n+\t  else if (vect_epilogues\n+\t\t   /* For now only allow one epilogue loop.  */\n+\t\t   && first_loop_vinfo->epilogue_vinfos.is_empty ())\n \t    {\n \t      first_loop_vinfo->epilogue_vinfos.safe_push (loop_vinfo);\n \t      poly_uint64 th = LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo);\n@@ -2506,12 +2634,14 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t\t\t    && param_vect_epilogues_nomask\n \t\t\t    && LOOP_VINFO_PEELING_FOR_NITER (first_loop_vinfo)\n \t\t\t    && !loop->simduid\n-\t\t\t    /* For now only allow one epilogue loop.  */\n-\t\t\t    && first_loop_vinfo->epilogue_vinfos.is_empty ());\n+\t\t\t    /* For now only allow one epilogue loop, but allow\n+\t\t\t       pick_lowest_cost_p to replace it.  */\n+\t\t\t    && (first_loop_vinfo->epilogue_vinfos.is_empty ()\n+\t\t\t\t|| pick_lowest_cost_p));\n \n \t  /* Commit to first_loop_vinfo if we have no reason to try\n \t     alternatives.  */\n-\t  if (!simdlen && !vect_epilogues)\n+\t  if (!simdlen && !vect_epilogues && !pick_lowest_cost_p)\n \t    break;\n \t}\n       else\n@@ -3509,7 +3639,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t       &vec_inside_cost, &vec_epilogue_cost);\n \n   vec_outside_cost = (int)(vec_prologue_cost + vec_epilogue_cost);\n-  \n+\n+  /* Stash the costs so that we can compare two loop_vec_infos.  */\n+  loop_vinfo->vec_inside_cost = vec_inside_cost;\n+  loop_vinfo->vec_outside_cost = vec_outside_cost;\n+\n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");"}, {"sha": "0eac5bdef888a1f8216cd0566d12b4e489057bbc", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc7e346bf9b5dc77797ea949d6adc740deb30ca/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bcc7e346bf9b5dc77797ea949d6adc740deb30ca", "patch": "@@ -601,6 +601,13 @@ typedef class _loop_vec_info : public vec_info {\n   /* Cost of a single scalar iteration.  */\n   int single_scalar_iteration_cost;\n \n+  /* The cost of the vector prologue and epilogue, including peeled\n+     iterations and set-up code.  */\n+  int vec_outside_cost;\n+\n+  /* The cost of the vector loop body.  */\n+  int vec_inside_cost;\n+\n   /* Is the loop vectorizable? */\n   bool vectorizable;\n "}]}