{"sha": "2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEzZDU2YmZjNDg5MGYwYjVlODEwNzg4M2JhMzQzNmE4ZTZmYjZhOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-31T19:25:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-31T19:25:40Z"}, "message": "dwarf2out.h (enum dw_val_class): Add dw_val_class_loclistsptr.\n\n\t* dwarf2out.h (enum dw_val_class): Add dw_val_class_loclistsptr.\n\t* dwarf2out.c (struct dw_loc_list_struct): Change emitted field\n\tfrom bool to 1-bit uchar bitfield.  Add num_assigned and\n\toffset_emitted bitfields.\n\t(dw_val_equal_p): Compare v.val_lbl_id rather than v.val_unsigned\n\tfor dw_val_class_lineptr and dw_val_class_macptr.  Handle\n\tdw_val_class_loclistsptr.\n\t(new_addr_loc_descr): Fix up formatting.\n\t(DEBUG_LOCLISTS_SECTION, DEBUG_DWO_LOCLISTS_SECTION): Define.\n\t(add_AT_low_high_pc): Fix up formatting.\n\t(add_AT_loclistsptr): New function.\n\t(AT_lbl): Allow dw_val_class_loclistsptr.\n\t(print_dw_val, attr_checksum, attr_checksum_ordered, same_dw_val_p):\n\tHandle dw_val_class_loclistsptr.\n\t(loc_list_idx): New variable.\n\t(output_loclists_offsets, assign_location_list_indexes): New\n\tfunctions.\n\t(size_of_die): For dw_val_class_loc_list -gsplit-dwarf -gdwarf-5\n\tadd size_of_uleb128 of the index.  Drop never used\n\tdwarf_split_debug_info AT_index handling.  Handle\n\tdw_val_class_loclistsptr.\n\t(value_format): Return DW_FORM_loclistsx for dw_val_class_loc_list\n\tif -gsplit-dwarf -gdwarf-5.  Handle dw_val_class_loclistsptr.\n\t(output_loc_list): Handle DWARF 5 .debug_loclists* format.\n\t(output_loc_list_offset): Handle -gsplit-dwarf -gdwarf-5\n\tDW_FORM_loclistx indexes.\n\t(output_attr_index_or_value): Fix up formatting.  Don't handle\n\tdw_val_class_loc_list here.\n\t(output_die): Formatting fixes.  Handle dw_val_class_loclistsptr.\n\tFor dw_val_class_loc_list call output_loc_list_offset rather than\n\toutput_attr_index_or_value.\n\t(init_sections_and_labels): For -gdwarf-5 use .debug_loclists\n\tor .debug_loclists.dwo section name for debug_loc_section.\n\t(resolve_addr_in_expr): Formatting fix.\n\t(index_location_lists): Likewise.\n\t(dwarf2out_finish): If there are any location lists, for\n\t-gsplit-dwarf -gdwarf-5 add DW_AT_loclists_base attribute.  Call\n\tindex_location_lists only if have_location_lists.  Call\n\tassign_location_list_indexes for -gsplit-dwarf -gdwarf-5.  Emit\n\t.debug_loclists{,.dwo} section header for -gdwarf-5, for -gdwarf-5\n\t-gsplit-dwarf also emit offset table.\n\nFrom-SVN: r241718", "tree": {"sha": "dfd3fee6edbb159f4cef1a0caae1b1c59537e354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfd3fee6edbb159f4cef1a0caae1b1c59537e354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25f409344c22aedf9eb2d939b79d8750d0b00163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25f409344c22aedf9eb2d939b79d8750d0b00163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25f409344c22aedf9eb2d939b79d8750d0b00163"}], "stats": {"total": 461, "additions": 390, "deletions": 71}, "files": [{"sha": "5023cf9ddbccf9a109b21f83fcbdd099f2b44ce4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "patch": "@@ -1,5 +1,47 @@\n 2016-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.h (enum dw_val_class): Add dw_val_class_loclistsptr.\n+\t* dwarf2out.c (struct dw_loc_list_struct): Change emitted field\n+\tfrom bool to 1-bit uchar bitfield.  Add num_assigned and\n+\toffset_emitted bitfields.\n+\t(dw_val_equal_p): Compare v.val_lbl_id rather than v.val_unsigned\n+\tfor dw_val_class_lineptr and dw_val_class_macptr.  Handle\n+\tdw_val_class_loclistsptr.\n+\t(new_addr_loc_descr): Fix up formatting.\n+\t(DEBUG_LOCLISTS_SECTION, DEBUG_DWO_LOCLISTS_SECTION): Define.\n+\t(add_AT_low_high_pc): Fix up formatting.\n+\t(add_AT_loclistsptr): New function.\n+\t(AT_lbl): Allow dw_val_class_loclistsptr.\n+\t(print_dw_val, attr_checksum, attr_checksum_ordered, same_dw_val_p):\n+\tHandle dw_val_class_loclistsptr.\n+\t(loc_list_idx): New variable.\n+\t(output_loclists_offsets, assign_location_list_indexes): New\n+\tfunctions.\n+\t(size_of_die): For dw_val_class_loc_list -gsplit-dwarf -gdwarf-5\n+\tadd size_of_uleb128 of the index.  Drop never used\n+\tdwarf_split_debug_info AT_index handling.  Handle\n+\tdw_val_class_loclistsptr.\n+\t(value_format): Return DW_FORM_loclistsx for dw_val_class_loc_list\n+\tif -gsplit-dwarf -gdwarf-5.  Handle dw_val_class_loclistsptr.\n+\t(output_loc_list): Handle DWARF 5 .debug_loclists* format.\n+\t(output_loc_list_offset): Handle -gsplit-dwarf -gdwarf-5\n+\tDW_FORM_loclistx indexes.\n+\t(output_attr_index_or_value): Fix up formatting.  Don't handle\n+\tdw_val_class_loc_list here.\n+\t(output_die): Formatting fixes.  Handle dw_val_class_loclistsptr.\n+\tFor dw_val_class_loc_list call output_loc_list_offset rather than\n+\toutput_attr_index_or_value.\n+\t(init_sections_and_labels): For -gdwarf-5 use .debug_loclists\n+\tor .debug_loclists.dwo section name for debug_loc_section.\n+\t(resolve_addr_in_expr): Formatting fix.\n+\t(index_location_lists): Likewise.\n+\t(dwarf2out_finish): If there are any location lists, for\n+\t-gsplit-dwarf -gdwarf-5 add DW_AT_loclists_base attribute.  Call\n+\tindex_location_lists only if have_location_lists.  Call\n+\tassign_location_list_indexes for -gsplit-dwarf -gdwarf-5.  Emit\n+\t.debug_loclists{,.dwo} section header for -gdwarf-5, for -gdwarf-5\n+\t-gsplit-dwarf also emit offset table.\n+\n \t* dwarf2out.c (DWARF_LARGEST_DATA_FORM_BITS): Define.\n \t(size_of_die, value_format, output_die): Use\n \tDW_FORM_data16 for 128-bit dw_val_class_const_double or"}, {"sha": "788ad6a1abbeda36d7facff0f6b15c0b6ba4bb70", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 347, "deletions": 71, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "patch": "@@ -1276,7 +1276,13 @@ typedef struct GTY(()) dw_loc_list_struct {\n   bool resolved_addr;\n   /* True if this list has been replaced by dw_loc_next.  */\n   bool replaced;\n-  bool emitted;\n+  /* True if it has been emitted into .debug_loc* / .debug_loclists*\n+     section.  */\n+  unsigned char emitted : 1;\n+  /* True if hash field is index rather than hash value.  */\n+  unsigned char num_assigned : 1;\n+  /* True if .debug_loclists.dwo offset has been emitted for it already.  */\n+  unsigned char offset_emitted : 1;\n   /* True if the range should be emitted even if begin and end\n      are the same.  */\n   bool force;\n@@ -1366,8 +1372,6 @@ dw_val_equal_p (dw_val_node *a, dw_val_node *b)\n     case dw_val_class_unsigned_const_implicit:\n     case dw_val_class_const_implicit:\n     case dw_val_class_range_list:\n-    case dw_val_class_lineptr:\n-    case dw_val_class_macptr:\n       /* These are all HOST_WIDE_INT, signed or unsigned.  */\n       return a->v.val_unsigned == b->v.val_unsigned;\n \n@@ -1380,6 +1384,9 @@ dw_val_equal_p (dw_val_node *a, dw_val_node *b)\n     case dw_val_class_fde_ref:\n       return a->v.val_fde_index == b->v.val_fde_index;\n     case dw_val_class_lbl_id:\n+    case dw_val_class_lineptr:\n+    case dw_val_class_macptr:\n+    case dw_val_class_loclistsptr:\n     case dw_val_class_high_pc:\n       return strcmp (a->v.val_lbl_id, b->v.val_lbl_id) == 0;\n     case dw_val_class_str:\n@@ -3310,6 +3317,8 @@ static inline rtx AT_addr (dw_attr_node *);\n static void add_AT_lbl_id (dw_die_ref, enum dwarf_attribute, const char *);\n static void add_AT_lineptr (dw_die_ref, enum dwarf_attribute, const char *);\n static void add_AT_macptr (dw_die_ref, enum dwarf_attribute, const char *);\n+static void add_AT_loclistsptr (dw_die_ref, enum dwarf_attribute,\n+\t\t\t\tconst char *);\n static void add_AT_offset (dw_die_ref, enum dwarf_attribute,\n \t\t\t   unsigned HOST_WIDE_INT);\n static void add_AT_range_list (dw_die_ref, enum dwarf_attribute,\n@@ -3610,8 +3619,8 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n   ref->dtprel = dtprel;\n   if (dwarf_split_debug_info)\n     ref->dw_loc_oprnd1.val_entry\n-        = add_addr_table_entry (addr,\n-                                dtprel ? ate_kind_rtx_dtprel : ate_kind_rtx);\n+      = add_addr_table_entry (addr,\n+\t\t\t      dtprel ? ate_kind_rtx_dtprel : ate_kind_rtx);\n   else\n     ref->dw_loc_oprnd1.val_entry = NULL;\n \n@@ -3662,6 +3671,12 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n #ifndef DEBUG_DWO_LOC_SECTION\n #define DEBUG_DWO_LOC_SECTION  \".debug_loc.dwo\"\n #endif\n+#ifndef DEBUG_LOCLISTS_SECTION\n+#define DEBUG_LOCLISTS_SECTION\t\".debug_loclists\"\n+#endif\n+#ifndef DEBUG_DWO_LOCLISTS_SECTION\n+#define DEBUG_DWO_LOCLISTS_SECTION  \".debug_loclists.dwo\"\n+#endif\n #ifndef DEBUG_PUBNAMES_SECTION\n #define DEBUG_PUBNAMES_SECTION\t\\\n   ((debug_generate_pub_sections == 2) \\\n@@ -4165,7 +4180,7 @@ add_AT_low_high_pc (dw_die_ref die, const char *lbl_low, const char *lbl_high,\n   attr.dw_attr_val.v.val_lbl_id = lbl_id;\n   if (dwarf_split_debug_info && !force_direct)\n     attr.dw_attr_val.val_entry\n-        = add_addr_table_entry (lbl_id, ate_kind_label);\n+      = add_addr_table_entry (lbl_id, ate_kind_label);\n   else\n     attr.dw_attr_val.val_entry = NULL;\n   add_dwarf_attr (die, &attr);\n@@ -4180,7 +4195,7 @@ add_AT_low_high_pc (dw_die_ref die, const char *lbl_low, const char *lbl_high,\n   if (attr.dw_attr_val.val_class == dw_val_class_lbl_id\n       && dwarf_split_debug_info && !force_direct)\n     attr.dw_attr_val.val_entry\n-        = add_addr_table_entry (lbl_id, ate_kind_label);\n+      = add_addr_table_entry (lbl_id, ate_kind_label);\n   else\n     attr.dw_attr_val.val_entry = NULL;\n   add_dwarf_attr (die, &attr);\n@@ -4714,6 +4729,22 @@ add_AT_lineptr (dw_die_ref die, enum dwarf_attribute attr_kind,\n   add_dwarf_attr (die, &attr);\n }\n \n+/* Add a section offset attribute value to a DIE, an offset into the\n+   debug_loclists section.  */\n+\n+static inline void\n+add_AT_loclistsptr (dw_die_ref die, enum dwarf_attribute attr_kind,\n+\t\t    const char *label)\n+{\n+  dw_attr_node attr;\n+\n+  attr.dw_attr = attr_kind;\n+  attr.dw_attr_val.val_class = dw_val_class_loclistsptr;\n+  attr.dw_attr_val.val_entry = NULL;\n+  attr.dw_attr_val.v.val_lbl_id = xstrdup (label);\n+  add_dwarf_attr (die, &attr);\n+}\n+\n /* Add a section offset attribute value to a DIE, an offset into the\n    debug_macinfo section.  */\n \n@@ -4796,6 +4827,7 @@ AT_lbl (dw_attr_node *a)\n   gcc_assert (a && (AT_class (a) == dw_val_class_lbl_id\n \t\t    || AT_class (a) == dw_val_class_lineptr\n \t\t    || AT_class (a) == dw_val_class_macptr\n+\t\t    || AT_class (a) == dw_val_class_loclistsptr\n \t\t    || AT_class (a) == dw_val_class_high_pc));\n   return a->dw_attr_val.v.val_lbl_id;\n }\n@@ -5795,6 +5827,7 @@ print_dw_val (dw_val_node *val, bool recurse, FILE *outfile)\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n+    case dw_val_class_loclistsptr:\n     case dw_val_class_high_pc:\n       fprintf (outfile, \"label: %s\", val->v.val_lbl_id);\n       break;\n@@ -6187,6 +6220,7 @@ attr_checksum (dw_attr_node *at, struct md5_ctx *ctx, int *mark)\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n+    case dw_val_class_loclistsptr:\n     case dw_val_class_high_pc:\n       break;\n \n@@ -6482,6 +6516,7 @@ attr_checksum_ordered (enum dwarf_tag tag, dw_attr_node *at,\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n+    case dw_val_class_loclistsptr:\n     case dw_val_class_high_pc:\n       break;\n \n@@ -6978,6 +7013,7 @@ same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n+    case dw_val_class_loclistsptr:\n     case dw_val_class_high_pc:\n       return 1;\n \n@@ -8259,6 +8295,59 @@ output_location_lists (dw_die_ref die)\n   FOR_EACH_CHILD (die, c, output_location_lists (c));\n }\n \n+/* During assign_location_list_indexes and output_loclists_offset the\n+   current index, after it the number of assigned indexes (i.e. how\n+   large the .debug_loclists* offset table should be).  */\n+static unsigned int loc_list_idx;\n+\n+/* Output all location list offsets for the DIE and its children.  */\n+\n+static void\n+output_loclists_offsets (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+  dw_attr_node *a;\n+  unsigned ix;\n+\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+    if (AT_class (a) == dw_val_class_loc_list)\n+      {\n+\tdw_loc_list_ref l = AT_loc_list (a);\n+\tif (l->offset_emitted)\n+\t  continue;\n+\tdw2_asm_output_delta (DWARF_OFFSET_SIZE, l->ll_symbol,\n+\t\t\t      loc_section_label, NULL);\n+\tgcc_assert (l->hash == loc_list_idx);\n+\tloc_list_idx++;\n+\tl->offset_emitted = true;\n+      }\n+\n+  FOR_EACH_CHILD (die, c, output_loclists_offsets (c));\n+}\n+\n+/* Recursively set indexes of location lists.  */\n+\n+static void\n+assign_location_list_indexes (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+  dw_attr_node *a;\n+  unsigned ix;\n+\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+    if (AT_class (a) == dw_val_class_loc_list)\n+      {\n+\tdw_loc_list_ref list = AT_loc_list (a);\n+\tif (!list->num_assigned)\n+\t  {\n+\t    list->num_assigned = true;\n+\t    list->hash = loc_list_idx++;\n+\t  }\n+      }\n+\n+  FOR_EACH_CHILD (die, c, assign_location_list_indexes (c));\n+}\n+\n /* We want to limit the number of external references, because they are\n    larger than local references: a relocation takes multiple words, and\n    even a sig8 reference is always eight bytes, whereas a local reference\n@@ -8728,11 +8817,11 @@ size_of_die (dw_die_ref die)\n \t  }\n \t  break;\n \tcase dw_val_class_loc_list:\n-          if (dwarf_split_debug_info && AT_index (a) != NOT_INDEXED)\n-            {\n-              gcc_assert (AT_index (a) != NO_INDEX_ASSIGNED);\n-              size += size_of_uleb128 (AT_index (a));\n-            }\n+\t  if (dwarf_split_debug_info && dwarf_version >= 5)\n+\t    {\n+\t      gcc_assert (AT_loc_list (a)->num_assigned);\n+\t      size += size_of_uleb128 (AT_loc_list (a)->hash);\n+\t    }\n           else\n             size += DWARF_OFFSET_SIZE;\n \t  break;\n@@ -8820,7 +8909,8 @@ size_of_die (dw_die_ref die)\n \t  break;\n \tcase dw_val_class_lineptr:\n \tcase dw_val_class_macptr:\n-          size += DWARF_OFFSET_SIZE;\n+\tcase dw_val_class_loclistsptr:\n+\t  size += DWARF_OFFSET_SIZE;\n \t  break;\n \tcase dw_val_class_str:\n           form = AT_string_form (a);\n@@ -9085,8 +9175,13 @@ value_format (dw_attr_node *a)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-    case dw_val_class_range_list:\n     case dw_val_class_loc_list:\n+      if (dwarf_split_debug_info\n+\t  && dwarf_version >= 5\n+\t  && AT_loc_list (a)->num_assigned)\n+\treturn DW_FORM_loclistx;\n+      /* FALLTHRU */\n+    case dw_val_class_range_list:\n       if (dwarf_version >= 4)\n \treturn DW_FORM_sec_offset;\n       /* FALLTHRU */\n@@ -9215,6 +9310,7 @@ value_format (dw_attr_node *a)\n               ? DW_FORM_addr : DW_FORM_GNU_addr_index);\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n+    case dw_val_class_loclistsptr:\n       return dwarf_version >= 4 ? DW_FORM_sec_offset : DW_FORM_data;\n     case dw_val_class_str:\n       return AT_string_form (a);\n@@ -9392,14 +9488,18 @@ gen_llsym (dw_loc_list_ref list)\n static void\n output_loc_list (dw_loc_list_ref list_head)\n {\n-  dw_loc_list_ref curr = list_head;\n-\n   if (list_head->emitted)\n     return;\n   list_head->emitted = true;\n \n   ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);\n \n+  dw_loc_list_ref curr = list_head;\n+#ifdef HAVE_AS_LEB128\n+  const char *last_section = NULL;\n+  const char *base_label = NULL;\n+#endif\n+\n   /* Walk the location list, and output each range + expression.  */\n   for (curr = list_head; curr != NULL; curr = curr->dw_loc_next)\n     {\n@@ -9414,23 +9514,142 @@ output_loc_list (dw_loc_list_ref list_head)\n \t in a single range are unlikely very useful.  */\n       if (size > 0xffff)\n \tcontinue;\n-      if (dwarf_split_debug_info)\n-        {\n-          dw2_asm_output_data (1, DW_LLE_GNU_start_length_entry,\n-                               \"Location list start/length entry (%s)\",\n-                               list_head->ll_symbol);\n-          dw2_asm_output_data_uleb128 (curr->begin_entry->index,\n-                                       \"Location list range start index (%s)\",\n-                                       curr->begin);\n-          /* The length field is 4 bytes.  If we ever need to support\n-            an 8-byte length, we can add a new DW_LLE code or fall back\n-            to DW_LLE_GNU_start_end_entry.  */\n-          dw2_asm_output_delta (4, curr->end, curr->begin,\n-                                \"Location list range length (%s)\",\n-                                list_head->ll_symbol);\n-        }\n+      if (dwarf_version >= 5)\n+\t{\n+\t  if (dwarf_split_debug_info)\n+\t    {\n+\t      /* For -gsplit-dwarf, emit DW_LLE_starx_length, which has\n+\t\t uleb128 index into .debug_addr and uleb128 length.  */\n+\t      dw2_asm_output_data (1, DW_LLE_startx_length,\n+\t\t\t\t   \"DW_LLE_startx_length (%s)\",\n+\t\t\t\t   list_head->ll_symbol);\n+\t      dw2_asm_output_data_uleb128 (curr->begin_entry->index,\n+\t\t\t\t\t   \"Location list range start index \"\n+\t\t\t\t\t   \"(%s)\", curr->begin);\n+\t      /* FIXME: This will ICE ifndef HAVE_AS_LEB128.\n+\t\t For that case we probably need to emit DW_LLE_startx_endx,\n+\t\t but we'd need 2 .debug_addr entries rather than just one.  */\n+\t      dw2_asm_output_delta_uleb128 (curr->end, curr->begin,\n+\t\t\t\t\t    \"Location list length (%s)\",\n+\t\t\t\t\t    list_head->ll_symbol);\n+\t    }\n+#ifdef HAVE_AS_LEB128\n+\t  else if (!have_multiple_function_sections)\n+\t    {\n+\t      /* If all code is in .text section, the base address is\n+\t\t already provided by the CU attributes.  Use\n+\t\t DW_LLE_offset_pair where both addresses are uleb128 encoded\n+\t\t offsets against that base.  */\n+\t      dw2_asm_output_data (1, DW_LLE_offset_pair,\n+\t\t\t\t   \"DW_LLE_offset_pair (%s)\",\n+\t\t\t\t   list_head->ll_symbol);\n+\t      dw2_asm_output_delta_uleb128 (curr->begin, curr->section,\n+\t\t\t\t\t    \"Location list begin address (%s)\",\n+\t\t\t\t\t    list_head->ll_symbol);\n+\t      dw2_asm_output_delta_uleb128 (curr->end, curr->section,\n+\t\t\t\t\t    \"Location list end address (%s)\",\n+\t\t\t\t\t    list_head->ll_symbol);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, find out how many consecutive entries could share\n+\t\t the same base entry.  If just one, emit DW_LLE_start_length,\n+\t\t otherwise emit DW_LLE_base_address for the base address\n+\t\t followed by a series of DW_LLE_offset_pair.  */\n+\t      if (last_section == NULL || curr->section != last_section)\n+\t\t{\n+\t\t  dw_loc_list_ref curr2;\n+\t\t  for (curr2 = curr->dw_loc_next; curr2 != NULL;\n+\t\t       curr2 = curr2->dw_loc_next)\n+\t\t    {\n+\t\t      if (strcmp (curr2->begin, curr2->end) == 0\n+\t\t\t  && !curr2->force)\n+\t\t\tcontinue;\n+\t\t      if ((unsigned long) size_of_locs (curr2->expr) > 0xffff)\n+\t\t\tcontinue;\n+\t\t      break;\n+\t\t    }\n+\t\t  if (curr2 == NULL || curr->section != curr2->section)\n+\t\t    last_section = NULL;\n+\t\t  else\n+\t\t    {\n+\t\t      last_section = curr->section;\n+\t\t      base_label = curr->begin;\n+\t\t      dw2_asm_output_data (1, DW_LLE_base_address,\n+\t\t\t\t\t   \"DW_LLE_base_address (%s)\",\n+\t\t\t\t\t   list_head->ll_symbol);\n+\t\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, base_label,\n+\t\t\t\t\t   \"Base address (%s)\",\n+\t\t\t\t\t   list_head->ll_symbol);\n+\t\t    }\n+\t\t}\n+\t      /* Only one entry with the same base address.  Use\n+\t\t DW_LLE_start_length with absolute address and uleb128\n+\t\t length.  */\n+\t      if (last_section == NULL)\n+\t\t{\n+\t\t  dw2_asm_output_data (1, DW_LLE_start_length,\n+\t\t\t\t       \"DW_LLE_start_length (%s)\",\n+\t\t\t\t       list_head->ll_symbol);\n+\t\t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr->begin,\n+\t\t\t\t       \"Location list begin address (%s)\",\n+\t\t\t\t       list_head->ll_symbol);\n+\t\t  dw2_asm_output_delta_uleb128 (curr->end, curr->begin,\n+\t\t\t\t\t\t\"Location list length \"\n+\t\t\t\t\t\t\"(%s)\", list_head->ll_symbol);\n+\t\t}\n+\t      /* Otherwise emit DW_LLE_offset_pair, relative to above emitted\n+\t\t DW_LLE_base_address.  */\n+\t      else\n+\t\t{\n+\t\t  dw2_asm_output_data (1, DW_LLE_offset_pair,\n+\t\t\t\t       \"DW_LLE_offset_pair (%s)\",\n+\t\t\t\t       list_head->ll_symbol);\n+\t\t  dw2_asm_output_delta_uleb128 (curr->begin, base_label,\n+\t\t\t\t\t\t\"Location list begin address \"\n+\t\t\t\t\t\t\"(%s)\", list_head->ll_symbol);\n+\t\t  dw2_asm_output_delta_uleb128 (curr->end, base_label,\n+\t\t\t\t\t\t\"Location list end address \"\n+\t\t\t\t\t\t\"(%s)\", list_head->ll_symbol);\n+\t\t}\n+\t    }\n+#else\n+\t  /* The assembler does not support .uleb128 directive.  Emit\n+\t     DW_LLE_start_end with a pair of absolute addresses.  */\n+\t  else\n+\t    {\n+\t      dw2_asm_output_data (1, DW_LLE_start_end,\n+\t\t\t\t   \"DW_LLE_start_end (%s)\",\n+\t\t\t\t   list_head->ll_symbol);\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr->begin,\n+\t\t\t\t   \"Location list begin address (%s)\",\n+\t\t\t\t   list_head->ll_symbol);\n+\t      dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr->end,\n+\t\t\t\t   \"Location list end address (%s)\",\n+\t\t\t\t   list_head->ll_symbol);\n+\t    }\n+#endif\n+\t}\n+      else if (dwarf_split_debug_info)\n+\t{\n+\t  /* For -gsplit-dwarf -gdwarf-{2,3,4} emit index into .debug_addr\n+\t     and 4 byte length.  */\n+\t  dw2_asm_output_data (1, DW_LLE_GNU_start_length_entry,\n+\t\t\t       \"Location list start/length entry (%s)\",\n+\t\t\t       list_head->ll_symbol);\n+\t  dw2_asm_output_data_uleb128 (curr->begin_entry->index,\n+\t\t\t\t       \"Location list range start index (%s)\",\n+\t\t\t\t       curr->begin);\n+\t  /* The length field is 4 bytes.  If we ever need to support\n+\t     an 8-byte length, we can add a new DW_LLE code or fall back\n+\t     to DW_LLE_GNU_start_end_entry.  */\n+\t  dw2_asm_output_delta (4, curr->end, curr->begin,\n+\t\t\t\t\"Location list range length (%s)\",\n+\t\t\t\tlist_head->ll_symbol);\n+\t}\n       else if (!have_multiple_function_sections)\n \t{\n+\t  /* Pair of relative addresses against start of text section.  */\n \t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, curr->begin, curr->section,\n \t\t\t\t\"Location list begin address (%s)\",\n \t\t\t\tlist_head->ll_symbol);\n@@ -9440,6 +9659,7 @@ output_loc_list (dw_loc_list_ref list_head)\n \t}\n       else\n \t{\n+\t  /* Pair of absolute addresses.  */\n \t  dw2_asm_output_addr (DWARF2_ADDR_SIZE, curr->begin,\n \t\t\t       \"Location list begin address (%s)\",\n \t\t\t       list_head->ll_symbol);\n@@ -9455,18 +9675,22 @@ output_loc_list (dw_loc_list_ref list_head)\n       output_loc_sequence (curr->expr, -1);\n     }\n \n-  if (dwarf_split_debug_info)\n+  /* And finally list termination.  */\n+  if (dwarf_version >= 5)\n+    dw2_asm_output_data (1, DW_LLE_end_of_list,\n+\t\t\t \"DW_LLE_end_of_list (%s)\", list_head->ll_symbol);\n+  else if (dwarf_split_debug_info)\n     dw2_asm_output_data (1, DW_LLE_GNU_end_of_list_entry,\n-                         \"Location list terminator (%s)\",\n-                         list_head->ll_symbol);\n+\t\t\t \"Location list terminator (%s)\",\n+\t\t\t list_head->ll_symbol);\n   else\n     {\n       dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,\n-                           \"Location list terminator begin (%s)\",\n-                           list_head->ll_symbol);\n+\t\t\t   \"Location list terminator begin (%s)\",\n+\t\t\t   list_head->ll_symbol);\n       dw2_asm_output_data (DWARF2_ADDR_SIZE, 0,\n-                           \"Location list terminator end (%s)\",\n-                           list_head->ll_symbol);\n+\t\t\t   \"Location list terminator end (%s)\",\n+\t\t\t   list_head->ll_symbol);\n     }\n }\n \n@@ -9500,12 +9724,19 @@ output_loc_list_offset (dw_attr_node *a)\n   char *sym = AT_loc_list (a)->ll_symbol;\n \n   gcc_assert (sym);\n-  if (dwarf_split_debug_info)\n-    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,\n-                          \"%s\", dwarf_attr_name (a->dw_attr));\n-  else\n+  if (!dwarf_split_debug_info)\n     dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, debug_loc_section,\n                            \"%s\", dwarf_attr_name (a->dw_attr));\n+  else if (dwarf_version >= 5)\n+    {\n+      gcc_assert (AT_loc_list (a)->num_assigned);\n+      dw2_asm_output_data_uleb128 (AT_loc_list (a)->hash, \"%s (%s)\",\n+\t\t\t\t   dwarf_attr_name (a->dw_attr),\n+\t\t\t\t   sym);\n+    }\n+  else\n+    dw2_asm_output_delta (DWARF_OFFSET_SIZE, sym, loc_section_label,\n+\t\t\t  \"%s\", dwarf_attr_name (a->dw_attr));\n }\n \n /* Output an attribute's index or value appropriately.  */\n@@ -9522,18 +9753,15 @@ output_attr_index_or_value (dw_attr_node *a)\n     }\n   switch (AT_class (a))\n     {\n-      case dw_val_class_addr:\n-        dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, AT_addr (a), \"%s\", name);\n-        break;\n-      case dw_val_class_high_pc:\n-      case dw_val_class_lbl_id:\n-        dw2_asm_output_addr (DWARF2_ADDR_SIZE, AT_lbl (a), \"%s\", name);\n-        break;\n-      case dw_val_class_loc_list:\n-        output_loc_list_offset (a);\n-        break;\n-      default:\n-        gcc_unreachable ();\n+    case dw_val_class_addr:\n+      dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, AT_addr (a), \"%s\", name);\n+      break;\n+    case dw_val_class_high_pc:\n+    case dw_val_class_lbl_id:\n+      dw2_asm_output_addr (DWARF2_ADDR_SIZE, AT_lbl (a), \"%s\", name);\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n }\n \n@@ -9738,16 +9966,16 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tcase dw_val_class_loc_list:\n-          output_attr_index_or_value (a);\n+\t  output_loc_list_offset (a);\n \t  break;\n \n \tcase dw_val_class_die_ref:\n \t  if (AT_ref_external (a))\n \t    {\n \t      if (AT_ref (a)->comdat_type_p)\n \t        {\n-\t\t  comdat_type_node *type_node =\n-\t            AT_ref (a)->die_id.die_type_node;\n+\t\t  comdat_type_node *type_node\n+\t\t    = AT_ref (a)->die_id.die_type_node;\n \n \t          gcc_assert (type_node);\n \t          output_signature (type_node->signature, name);\n@@ -9801,7 +10029,7 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tcase dw_val_class_lbl_id:\n-          output_attr_index_or_value (a);\n+\t  output_attr_index_or_value (a);\n \t  break;\n \n \tcase dw_val_class_lineptr:\n@@ -9814,6 +10042,11 @@ output_die (dw_die_ref die)\n \t\t\t\t debug_macinfo_section, \"%s\", name);\n \t  break;\n \n+\tcase dw_val_class_loclistsptr:\n+\t  dw2_asm_output_offset (DWARF_OFFSET_SIZE, AT_lbl (a),\n+\t\t\t\t debug_loc_section, \"%s\", name);\n+\t  break;\n+\n \tcase dw_val_class_str:\n           if (a->dw_attr_val.v.val_str->form == DW_FORM_strp)\n             dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n@@ -26023,7 +26256,9 @@ init_sections_and_labels (void)\n                                         SECTION_DEBUG, NULL);\n       debug_abbrev_section = get_section (DEBUG_ABBREV_SECTION,\n                                           SECTION_DEBUG, NULL);\n-      debug_loc_section = get_section (DEBUG_LOC_SECTION,\n+      debug_loc_section = get_section (dwarf_version >= 5\n+\t\t\t\t       ? DEBUG_LOCLISTS_SECTION\n+\t\t\t\t       : DEBUG_LOC_SECTION,\n                                        SECTION_DEBUG, NULL);\n       debug_macinfo_section_name\n \t= (dwarf_strict && dwarf_version < 5)\n@@ -26059,7 +26294,9 @@ init_sections_and_labels (void)\n                                                NULL);\n       ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_info_section_label,\n                                    DEBUG_SKELETON_INFO_SECTION_LABEL, 0);\n-      debug_loc_section = get_section (DEBUG_DWO_LOC_SECTION,\n+      debug_loc_section = get_section (dwarf_version >= 5\n+\t\t\t\t       ? DEBUG_DWO_LOCLISTS_SECTION\n+\t\t\t\t       : DEBUG_DWO_LOC_SECTION,\n                                        SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n       debug_str_dwo_section = get_section (DEBUG_STR_DWO_SECTION,\n                                            DEBUG_STR_DWO_SECTION_FLAGS, NULL);\n@@ -27160,8 +27397,8 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n             if (!resolve_one_addr (&rtl))\n               return false;\n             remove_addr_table_entry (loc->dw_loc_oprnd1.val_entry);\n-            loc->dw_loc_oprnd1.val_entry =\n-                add_addr_table_entry (rtl, ate_kind_rtx);\n+\t    loc->dw_loc_oprnd1.val_entry\n+\t      = add_addr_table_entry (rtl, ate_kind_rtx);\n           }\n \tbreak;\n       case DW_OP_const4u:\n@@ -28248,8 +28485,7 @@ index_location_lists (dw_die_ref die)\n               continue;\n \n             curr->begin_entry\n-                = add_addr_table_entry (xstrdup (curr->begin),\n-                                        ate_kind_label);\n+\t      = add_addr_table_entry (xstrdup (curr->begin), ate_kind_label);\n           }\n       }\n \n@@ -28458,12 +28694,18 @@ dwarf2out_finish (const char *)\n \n   if (dwarf_split_debug_info)\n     {\n-      /* optimize_location_lists calculates the size of the lists,\n-         so index them first, and assign indices to the entries.\n-         Although optimize_location_lists will remove entries from\n-         the table, it only does so for duplicates, and therefore\n-         only reduces ref_counts to 1.  */\n-      index_location_lists (comp_unit_die ());\n+      if (have_location_lists)\n+\t{\n+\t  if (dwarf_version >= 5)\n+\t    add_AT_loclistsptr (comp_unit_die (), DW_AT_loclists_base,\n+\t\t\t\tloc_section_label);\n+\t  /* optimize_location_lists calculates the size of the lists,\n+\t     so index them first, and assign indices to the entries.\n+\t     Although optimize_location_lists will remove entries from\n+\t     the table, it only does so for duplicates, and therefore\n+\t     only reduces ref_counts to 1.  */\n+\t  index_location_lists (comp_unit_die ());\n+\t}\n \n       if (addr_index_table != NULL)\n         {\n@@ -28474,8 +28716,14 @@ dwarf2out_finish (const char *)\n         }\n     }\n \n+  loc_list_idx = 0;\n   if (have_location_lists)\n-    optimize_location_lists (comp_unit_die ());\n+    {\n+      optimize_location_lists (comp_unit_die ());\n+      /* And finally assign indexes to the entries for -gsplit-dwarf.  */\n+      if (dwarf_version >= 5 && dwarf_split_debug_info)\n+\tassign_location_list_indexes (comp_unit_die ());\n+    }\n \n   save_macinfo_strings ();\n \n@@ -28573,10 +28821,38 @@ dwarf2out_finish (const char *)\n   /* Output location list section if necessary.  */\n   if (have_location_lists)\n     {\n+      char l1[MAX_ARTIFICIAL_LABEL_BYTES];\n+      char l2[MAX_ARTIFICIAL_LABEL_BYTES];\n       /* Output the location lists info.  */\n       switch_to_section (debug_loc_section);\n+      if (dwarf_version >= 5)\n+\t{\n+\t  ASM_GENERATE_INTERNAL_LABEL (l1, DEBUG_LOC_SECTION_LABEL, 1);\n+\t  ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_LOC_SECTION_LABEL, 2);\n+\t  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+\t    dw2_asm_output_data (4, 0xffffffff,\n+\t\t\t\t \"Initial length escape value indicating \"\n+\t\t\t\t \"64-bit DWARF extension\");\n+\t  dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t    \"Length of Location Lists\");\n+\t  ASM_OUTPUT_LABEL (asm_out_file, l1);\n+\t  dw2_asm_output_data (2, dwarf_version, \"DWARF Version\");\n+\t  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, \"Address Size\");\n+\t  dw2_asm_output_data (1, 0, \"Segment Size\");\n+\t  dw2_asm_output_data (4, dwarf_split_debug_info ? loc_list_idx : 0,\n+\t\t\t       \"Offset Entry Count\");\n+\t}\n       ASM_OUTPUT_LABEL (asm_out_file, loc_section_label);\n+      if (dwarf_version >= 5 && dwarf_split_debug_info)\n+\t{\n+\t  unsigned int save_loc_list_idx = loc_list_idx;\n+\t  loc_list_idx = 0;\n+\t  output_loclists_offsets (comp_unit_die ());\n+\t  gcc_assert (save_loc_list_idx == loc_list_idx);\n+\t}\n       output_location_lists (comp_unit_die ());\n+      if (dwarf_version >= 5)\n+\tASM_OUTPUT_LABEL (asm_out_file, l2);\n     }\n \n   output_pubtables ();"}, {"sha": "78ba05cf783fdadabdcab442e845fd19a2ba07a1", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=2a3d56bfc4890f0b5e8107883ba3436a8e6fb6a8", "patch": "@@ -147,6 +147,7 @@ enum dw_val_class\n   dw_val_class_lineptr,\n   dw_val_class_str,\n   dw_val_class_macptr,\n+  dw_val_class_loclistsptr,\n   dw_val_class_file,\n   dw_val_class_data8,\n   dw_val_class_decl_ref,"}]}