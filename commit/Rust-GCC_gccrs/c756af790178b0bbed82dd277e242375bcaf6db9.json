{"sha": "c756af790178b0bbed82dd277e242375bcaf6db9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc1NmFmNzkwMTc4YjBiYmVkODJkZDI3N2UyNDIzNzViY2FmNmRiOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-04T10:11:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-04T10:11:22Z"}, "message": "fold-const.c (force_fit_type): Cope with types larger than 2 HWI.\n\n        * fold-const.c (force_fit_type): Cope with types larger than 2 HWI.\n        (fold_convert_const_int_from_int, fold_convert_const_int_from_real,\n        fold_convert_const_real_from_real): Split out from ...\n        (fold_convert_const): ... here.\n\nFrom-SVN: r92890", "tree": {"sha": "deaf652d11e786430a95a4e80be1c3fc85f3cd94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deaf652d11e786430a95a4e80be1c3fc85f3cd94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c756af790178b0bbed82dd277e242375bcaf6db9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c756af790178b0bbed82dd277e242375bcaf6db9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c756af790178b0bbed82dd277e242375bcaf6db9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c756af790178b0bbed82dd277e242375bcaf6db9/comments", "author": null, "committer": null, "parents": [{"sha": "d30c94610f659937c248c3ee06f789fb2200fd38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30c94610f659937c248c3ee06f789fb2200fd38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d30c94610f659937c248c3ee06f789fb2200fd38"}], "stats": {"total": 287, "additions": 156, "deletions": 131}, "files": [{"sha": "19e9aed72c4c1f1f067039d722ba76ea1d3c43a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c756af790178b0bbed82dd277e242375bcaf6db9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c756af790178b0bbed82dd277e242375bcaf6db9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c756af790178b0bbed82dd277e242375bcaf6db9", "patch": "@@ -1,3 +1,10 @@\n+2005-01-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* fold-const.c (force_fit_type): Cope with types larger than 2 HWI.\n+\t(fold_convert_const_int_from_int, fold_convert_const_int_from_real,\n+\tfold_convert_const_real_from_real): Split out from ...\n+\t(fold_convert_const): ... here.\n+\n 2005-01-03  Richard Henderson  <rth@redhat.com>\n \n \tPR target/19235"}, {"sha": "cd7b95be483b8a0a37af9b42fd98fe0f73b19335", "filename": "gcc/fold-const.c", "status": "modified", "additions": 149, "deletions": 131, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c756af790178b0bbed82dd277e242375bcaf6db9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c756af790178b0bbed82dd277e242375bcaf6db9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c756af790178b0bbed82dd277e242375bcaf6db9", "patch": "@@ -89,8 +89,6 @@ static tree negate_expr (tree);\n static tree split_tree (tree, enum tree_code, tree *, tree *, tree *, int);\n static tree associate_trees (tree, tree, enum tree_code, tree);\n static tree const_binop (enum tree_code, tree, tree, int);\n-static tree build_zero_vector (tree);\n-static tree fold_convert_const (enum tree_code, tree, tree);\n static enum tree_code invert_tree_comparison (enum tree_code, bool);\n static enum comparison_code comparison_to_compcode (enum tree_code);\n static enum tree_code compcode_to_comparison (enum comparison_code);\n@@ -225,7 +223,7 @@ force_fit_type (tree t, int overflowable,\n \n   /* First clear all bits that are beyond the type's precision.  */\n \n-  if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n+  if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n     ;\n   else if (prec > HOST_BITS_PER_WIDE_INT)\n     high &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n@@ -238,7 +236,7 @@ force_fit_type (tree t, int overflowable,\n \n   if (!sign_extended_type)\n     /* No sign extension */;\n-  else if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n+  else if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n     /* Correct width already.  */;\n   else if (prec > HOST_BITS_PER_WIDE_INT)\n     {\n@@ -1686,174 +1684,194 @@ size_diffop (tree arg0, tree arg1)\n \t\t\t\t\t\t\targ1, arg0)));\n }\n \f\n-/* Construct a vector of zero elements of vector type TYPE.  */\n+/* A subroutine of fold_convert_const handling conversions of an\n+   INTEGER_CST to another integer type.  */\n \n static tree\n-build_zero_vector (tree type)\n+fold_convert_const_int_from_int (tree type, tree arg1)\n {\n-  tree elem, list;\n-  int i, units;\n+  tree t;\n \n-  elem = fold_convert_const (NOP_EXPR, TREE_TYPE (type), integer_zero_node);\n-  units = TYPE_VECTOR_SUBPARTS (type);\n+  /* Given an integer constant, make new constant with new type,\n+     appropriately sign-extended or truncated.  */\n+  t = build_int_cst_wide (type, TREE_INT_CST_LOW (arg1),\n+\t\t\t  TREE_INT_CST_HIGH (arg1));\n+\n+  t = force_fit_type (t,\n+\t\t      /* Don't set the overflow when\n+\t\t      \t converting a pointer  */\n+\t\t      !POINTER_TYPE_P (TREE_TYPE (arg1)),\n+\t\t      (TREE_INT_CST_HIGH (arg1) < 0\n+\t\t       && (TYPE_UNSIGNED (type)\n+\t\t\t   < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n+\t\t      | TREE_OVERFLOW (arg1),\n+\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n \n-  list = NULL_TREE;\n-  for (i = 0; i < units; i++)\n-    list = tree_cons (NULL_TREE, elem, list);\n-  return build_vector (type, list);\n+  return t;\n }\n \n-\n-/* Attempt to fold type conversion operation CODE of expression ARG1 to\n-   type TYPE.  If no simplification can be done return NULL_TREE.  */\n+/* A subroutine of fold_convert_const handling conversions a REAL_CST\n+   to an integer type.  */\n \n static tree\n-fold_convert_const (enum tree_code code, tree type, tree arg1)\n+fold_convert_const_int_from_real (enum tree_code code, tree type, tree arg1)\n {\n   int overflow = 0;\n   tree t;\n \n-  if (TREE_TYPE (arg1) == type)\n-    return arg1;\n+  /* The following code implements the floating point to integer\n+     conversion rules required by the Java Language Specification,\n+     that IEEE NaNs are mapped to zero and values that overflow\n+     the target precision saturate, i.e. values greater than\n+     INT_MAX are mapped to INT_MAX, and values less than INT_MIN\n+     are mapped to INT_MIN.  These semantics are allowed by the\n+     C and C++ standards that simply state that the behavior of\n+     FP-to-integer conversion is unspecified upon overflow.  */\n \n-  if (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type))\n+  HOST_WIDE_INT high, low;\n+  REAL_VALUE_TYPE r;\n+  REAL_VALUE_TYPE x = TREE_REAL_CST (arg1);\n+\n+  switch (code)\n     {\n-      if (TREE_CODE (arg1) == INTEGER_CST)\n-\t{\n-\t  /* If we would build a constant wider than GCC supports,\n-\t     leave the conversion unfolded.  */\n-\t  if (TYPE_PRECISION (type) > 2 * HOST_BITS_PER_WIDE_INT)\n-\t    return NULL_TREE;\n-\n-\t  /* Given an integer constant, make new constant with new type,\n-\t     appropriately sign-extended or truncated.  */\n-\t  t = build_int_cst_wide (type, TREE_INT_CST_LOW (arg1),\n-\t\t\t\t  TREE_INT_CST_HIGH (arg1));\n-\n-\t  t = force_fit_type (t,\n-\t\t\t      /* Don't set the overflow when\n-\t\t\t      \t converting a pointer  */\n-\t\t\t      !POINTER_TYPE_P (TREE_TYPE (arg1)),\n-\t\t\t      (TREE_INT_CST_HIGH (arg1) < 0\n-\t\t\t       && (TYPE_UNSIGNED (type)\n-\t\t\t\t   < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n-\t\t\t      | TREE_OVERFLOW (arg1),\n-\t\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n-\t  return t;\n-\t}\n-      else if (TREE_CODE (arg1) == REAL_CST)\n-\t{\n-\t  /* The following code implements the floating point to integer\n-\t     conversion rules required by the Java Language Specification,\n-\t     that IEEE NaNs are mapped to zero and values that overflow\n-\t     the target precision saturate, i.e. values greater than\n-\t     INT_MAX are mapped to INT_MAX, and values less than INT_MIN\n-\t     are mapped to INT_MIN.  These semantics are allowed by the\n-\t     C and C++ standards that simply state that the behavior of\n-\t     FP-to-integer conversion is unspecified upon overflow.  */\n+    case FIX_TRUNC_EXPR:\n+      real_trunc (&r, VOIDmode, &x);\n+      break;\n \n-\t  HOST_WIDE_INT high, low;\n-\t  REAL_VALUE_TYPE r;\n-\t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg1);\n+    case FIX_CEIL_EXPR:\n+      real_ceil (&r, VOIDmode, &x);\n+      break;\n \n-\t  switch (code)\n-\t    {\n-\t    case FIX_TRUNC_EXPR:\n-\t      real_trunc (&r, VOIDmode, &x);\n-\t      break;\n+    case FIX_FLOOR_EXPR:\n+      real_floor (&r, VOIDmode, &x);\n+      break;\n \n-\t    case FIX_CEIL_EXPR:\n-\t      real_ceil (&r, VOIDmode, &x);\n-\t      break;\n+    case FIX_ROUND_EXPR:\n+      real_round (&r, VOIDmode, &x);\n+      break;\n \n-\t    case FIX_FLOOR_EXPR:\n-\t      real_floor (&r, VOIDmode, &x);\n-\t      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-\t    case FIX_ROUND_EXPR:\n-\t      real_round (&r, VOIDmode, &x);\n-\t      break;\n+  /* If R is NaN, return zero and show we have an overflow.  */\n+  if (REAL_VALUE_ISNAN (r))\n+    {\n+      overflow = 1;\n+      high = 0;\n+      low = 0;\n+    }\n \n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n+  /* See if R is less than the lower bound or greater than the\n+     upper bound.  */\n+\n+  if (! overflow)\n+    {\n+      tree lt = TYPE_MIN_VALUE (type);\n+      REAL_VALUE_TYPE l = real_value_from_int_cst (NULL_TREE, lt);\n+      if (REAL_VALUES_LESS (r, l))\n+\t{\n+\t  overflow = 1;\n+\t  high = TREE_INT_CST_HIGH (lt);\n+\t  low = TREE_INT_CST_LOW (lt);\n+\t}\n+    }\n \n-\t  /* If R is NaN, return zero and show we have an overflow.  */\n-\t  if (REAL_VALUE_ISNAN (r))\n+  if (! overflow)\n+    {\n+      tree ut = TYPE_MAX_VALUE (type);\n+      if (ut)\n+\t{\n+\t  REAL_VALUE_TYPE u = real_value_from_int_cst (NULL_TREE, ut);\n+\t  if (REAL_VALUES_LESS (u, r))\n \t    {\n \t      overflow = 1;\n-\t      high = 0;\n-\t      low = 0;\n+\t      high = TREE_INT_CST_HIGH (ut);\n+\t      low = TREE_INT_CST_LOW (ut);\n \t    }\n+\t}\n+    }\n \n-\t  /* See if R is less than the lower bound or greater than the\n-\t     upper bound.  */\n+  if (! overflow)\n+    REAL_VALUE_TO_INT (&low, &high, r);\n \n-\t  if (! overflow)\n-\t    {\n-\t      tree lt = TYPE_MIN_VALUE (type);\n-\t      REAL_VALUE_TYPE l = real_value_from_int_cst (NULL_TREE, lt);\n-\t      if (REAL_VALUES_LESS (r, l))\n-\t\t{\n-\t\t  overflow = 1;\n-\t\t  high = TREE_INT_CST_HIGH (lt);\n-\t\t  low = TREE_INT_CST_LOW (lt);\n-\t\t}\n-\t    }\n+  t = build_int_cst_wide (type, low, high);\n \n-\t  if (! overflow)\n-\t    {\n-\t      tree ut = TYPE_MAX_VALUE (type);\n-\t      if (ut)\n-\t\t{\n-\t\t  REAL_VALUE_TYPE u = real_value_from_int_cst (NULL_TREE, ut);\n-\t\t  if (REAL_VALUES_LESS (u, r))\n-\t\t    {\n-\t\t      overflow = 1;\n-\t\t      high = TREE_INT_CST_HIGH (ut);\n-\t\t      low = TREE_INT_CST_LOW (ut);\n-\t\t    }\n-\t\t}\n-\t    }\n+  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg1),\n+\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n+  return t;\n+}\n \n-\t  if (! overflow)\n-\t    REAL_VALUE_TO_INT (&low, &high, r);\n+/* A subroutine of fold_convert_const handling conversions a REAL_CST\n+   to another floating point type.  */\n \n-\t  t = build_int_cst_wide (type, low, high);\n+static tree\n+fold_convert_const_real_from_real (tree type, tree arg1)\n+{\n+  tree t;\n \n-\t  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg1),\n-\t\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n-\t  return t;\n-\t}\n+  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n+    {\n+      /* We make a copy of ARG1 so that we don't modify an\n+\t existing constant tree.  */\n+      t = copy_node (arg1);\n+      TREE_TYPE (t) = type;\n+      return t;\n+    }\n+\n+  t = build_real (type,\n+\t\t  real_value_truncate (TYPE_MODE (type),\n+\t\t\t\t       TREE_REAL_CST (arg1)));\n+\n+  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);\n+  TREE_CONSTANT_OVERFLOW (t)\n+    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n+  return t;\n+}\n+\n+/* Attempt to fold type conversion operation CODE of expression ARG1 to\n+   type TYPE.  If no simplification can be done return NULL_TREE.  */\n+\n+static tree\n+fold_convert_const (enum tree_code code, tree type, tree arg1)\n+{\n+  if (TREE_TYPE (arg1) == type)\n+    return arg1;\n+\n+  if (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type))\n+    {\n+      if (TREE_CODE (arg1) == INTEGER_CST)\n+\treturn fold_convert_const_int_from_int (type, arg1);\n+      else if (TREE_CODE (arg1) == REAL_CST)\n+\treturn fold_convert_const_int_from_real (code, type, arg1);\n     }\n   else if (TREE_CODE (type) == REAL_TYPE)\n     {\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \treturn build_real_from_int_cst (type, arg1);\n       if (TREE_CODE (arg1) == REAL_CST)\n-\t{\n-\t  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n-\t    {\n-\t      /* We make a copy of ARG1 so that we don't modify an\n-\t\t existing constant tree.  */\n-\t      t = copy_node (arg1);\n-\t      TREE_TYPE (t) = type;\n-\t      return t;\n-\t    }\n-\n-\t  t = build_real (type,\n-\t\t\t  real_value_truncate (TYPE_MODE (type),\n-\t\t\t\t\t       TREE_REAL_CST (arg1)));\n-\n-\t  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);\n-\t  TREE_CONSTANT_OVERFLOW (t)\n-\t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n-\t  return t;\n-\t}\n+\treturn fold_convert_const_real_from_real (type, arg1);\n     }\n   return NULL_TREE;\n }\n \n+/* Construct a vector of zero elements of vector type TYPE.  */\n+\n+static tree\n+build_zero_vector (tree type)\n+{\n+  tree elem, list;\n+  int i, units;\n+\n+  elem = fold_convert_const (NOP_EXPR, TREE_TYPE (type), integer_zero_node);\n+  units = TYPE_VECTOR_SUBPARTS (type);\n+  \n+  list = NULL_TREE;\n+  for (i = 0; i < units; i++)\n+    list = tree_cons (NULL_TREE, elem, list);\n+  return build_vector (type, list);\n+}\n+\n /* Convert expression ARG to type TYPE.  Used by the middle-end for\n    simple conversions in preference to calling the front-end's convert.  */\n "}]}