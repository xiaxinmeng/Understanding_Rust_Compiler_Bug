{"sha": "a336b719a34c07effb7e1ba9e72f8c270ea362ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMzNmI3MTlhMzRjMDdlZmZiN2UxYmE5ZTcyZjhjMjcwZWEzNjJlZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-08-21T13:49:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-08-21T13:49:07Z"}, "message": "re PR tree-optimization/62091 (ice in before_dom_children)\n\n\n\tPR tree-optimization/62091\n\t* g++.dg/ipa/devirt-37.C: Update template.\n\t* g++.dg/ipa/devirt-40.C: New testcase.\n\t* ipa-devirt.c (ipa_polymorphic_call_context::restrict_to_inner_type):\n\thandle correctly arrays.\n\t(extr_type_from_vtbl_ptr_store): Add debug output; handle multiple\n\tinheritance binfos.\n\t(record_known_type): Walk into inner type.\n\t(ipa_polymorphic_call_context::get_dynamic_type): Likewise; strenghten\n\tcondition on no type changes.\n\nFrom-SVN: r214271", "tree": {"sha": "28584c8124114195615453c501e911bdccec1199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28584c8124114195615453c501e911bdccec1199"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a336b719a34c07effb7e1ba9e72f8c270ea362ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a336b719a34c07effb7e1ba9e72f8c270ea362ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a336b719a34c07effb7e1ba9e72f8c270ea362ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a336b719a34c07effb7e1ba9e72f8c270ea362ee/comments", "author": null, "committer": null, "parents": [{"sha": "2903befbec9fb56ce7883952bf040daa80041ae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2903befbec9fb56ce7883952bf040daa80041ae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2903befbec9fb56ce7883952bf040daa80041ae8"}], "stats": {"total": 211, "additions": 175, "deletions": 36}, "files": [{"sha": "6a366d3ee7a3d758412e4580067747c6cfee8c36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a336b719a34c07effb7e1ba9e72f8c270ea362ee", "patch": "@@ -1,3 +1,14 @@\n+2014-08-21  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR tree-optimization/62091\n+\t* ipa-devirt.c (ipa_polymorphic_call_context::restrict_to_inner_type):\n+\thandle correctly arrays.\n+\t(extr_type_from_vtbl_ptr_store): Add debug output; handle multiple\n+\tinheritance binfos.\n+\t(record_known_type): Walk into inner type.\n+\t(ipa_polymorphic_call_context::get_dynamic_type): Likewise; strenghten\n+\tcondition on no type changes.\n+\n 2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n \n \t* genattrtab.c (write_attr_get): Within the generated get_attr_"}, {"sha": "2e74ca61c5086c936f165ff4e373c3b0775afa02", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 133, "deletions": 31, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=a336b719a34c07effb7e1ba9e72f8c270ea362ee", "patch": "@@ -2015,8 +2015,10 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n \t  tree subtype = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n \n \t  /* Give up if we don't know array size.  */\n-\t  if (!tree_fits_shwi_p (TYPE_SIZE (subtype))\n-\t      || !tree_to_shwi (TYPE_SIZE (subtype)) <= 0)\n+\t  if (!TYPE_SIZE (subtype)\n+\t      || !tree_fits_shwi_p (TYPE_SIZE (subtype))\n+\t      || tree_to_shwi (TYPE_SIZE (subtype)) <= 0\n+\t      || !contains_polymorphic_type_p (subtype))\n \t    goto give_up;\n \t  cur_offset = cur_offset % tree_to_shwi (TYPE_SIZE (subtype));\n \t  type = subtype;\n@@ -2630,7 +2632,7 @@ extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci,\n \t\t\t       HOST_WIDE_INT *type_offset)\n {\n   HOST_WIDE_INT offset, size, max_size;\n-  tree lhs, rhs, base, binfo;\n+  tree lhs, rhs, base;\n \n   if (!gimple_assign_single_p (stmt))\n     return NULL_TREE;\n@@ -2639,7 +2641,11 @@ extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci,\n   rhs = gimple_assign_rhs1 (stmt);\n   if (TREE_CODE (lhs) != COMPONENT_REF\n       || !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n-    return NULL_TREE;\n+     {\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"  LHS is not virtual table.\\n\");\n+\treturn NULL_TREE;\n+     }\n \n   if (tci->vtbl_ptr_ref && operand_equal_p (lhs, tci->vtbl_ptr_ref, 0))\n     ;\n@@ -2649,33 +2655,80 @@ extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci,\n       if (offset != tci->offset\n \t  || size != POINTER_SIZE\n \t  || max_size != POINTER_SIZE)\n-\treturn NULL_TREE;\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    wrong offset %i!=%i or size %i\\n\",\n+\t\t     (int)offset, (int)tci->offset, (int)size);\n+\t  return NULL_TREE;\n+\t}\n       if (DECL_P (tci->instance))\n \t{\n \t  if (base != tci->instance)\n-\t    return NULL_TREE;\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"    base:\");\n+\t\t  print_generic_expr (dump_file, base, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" does not match instance:\");\n+\t\t  print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      return NULL_TREE;\n+\t    }\n \t}\n       else if (TREE_CODE (base) == MEM_REF)\n \t{\n \t  if (!operand_equal_p (tci->instance, TREE_OPERAND (base, 0), 0)\n \t      || !integer_zerop (TREE_OPERAND (base, 1)))\n-\t    return NULL_TREE;\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"    base mem ref:\");\n+\t\t  print_generic_expr (dump_file, base, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" has nonzero offset or does not match instance:\");\n+\t\t  print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      return NULL_TREE;\n+\t    }\n \t}\n       else if (!operand_equal_p (tci->instance, base, 0)\n \t       || tci->offset)\n-\treturn NULL_TREE;\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"    base:\");\n+\t      print_generic_expr (dump_file, base, TDF_SLIM);\n+\t      fprintf (dump_file, \" does not match instance:\");\n+\t      print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n+\t      fprintf (dump_file, \" with offset %i\\n\", (int)tci->offset);\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n     }\n \n-  binfo = vtable_pointer_value_to_binfo (rhs);\n+  tree vtable;\n+  unsigned HOST_WIDE_INT offset2;\n \n+  if (!vtable_pointer_value_to_vtable (rhs, &vtable, &offset2))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"    Failed to lookup binfo\\n\");\n+      return NULL;\n+    }\n+\n+  tree binfo = subbinfo_with_vtable_at_offset (TYPE_BINFO (DECL_CONTEXT (vtable)),\n+\t\t\t\t\t       offset2, vtable);\n   if (!binfo)\n-    return NULL;\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"    Construction vtable used\\n\");\n+      /* FIXME: We should suport construction contextes.  */\n+      return NULL;\n+    }\n+ \n   *type_offset = tree_to_shwi (BINFO_OFFSET (binfo)) * BITS_PER_UNIT;\n-  if (TYPE_BINFO (BINFO_TYPE (binfo)) == binfo)\n-    return BINFO_TYPE (binfo);\n-\n-  /* TODO: Figure out the type containing BINFO.  */\n-  return NULL;\n+  return DECL_CONTEXT (vtable);\n }\n \n /* Record dynamic type change of TCI to TYPE.  */\n@@ -2694,11 +2747,43 @@ record_known_type (struct type_change_info *tci, tree type, HOST_WIDE_INT offset\n      else\n        fprintf (dump_file, \"  Recording unknown type\\n\");\n     }\n+\n+  /* If we found a constructor of type that is not polymorphic or\n+     that may contain the type in question as a field (not as base),\n+     restrict to the inner class first to make type matching bellow\n+     happier.  */\n+  if (type\n+      && (offset\n+          || (TREE_CODE (type) != RECORD_TYPE\n+\t      || !polymorphic_type_binfo_p (TYPE_BINFO (type)))))\n+    {\n+      ipa_polymorphic_call_context context;\n+\n+      context.offset = offset;\n+      context.outer_type = type;\n+      context.maybe_in_construction = false;\n+      context.maybe_derived_type = false;\n+      /* If we failed to find the inner type, we know that the call\n+\t would be undefined for type produced here.  */\n+      if (!context.restrict_to_inner_class (tci->otr_type))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Ignoring; does not contain otr_type\\n\");\n+\t  return;\n+\t}\n+      /* Watch for case we reached an POD type and anticipate placement\n+\t new.  */\n+      if (!context.maybe_derived_type)\n+\t{\n+          type = context.outer_type;\n+          offset = context.offset;\n+\t}\n+    }\n   if (tci->type_maybe_changed\n-      && (type != tci->known_current_type\n+      && (!types_same_for_odr (type, tci->known_current_type)\n \t  || offset != tci->known_current_offset))\n     tci->multiple_types_encountered = true;\n-  tci->known_current_type = type;\n+  tci->known_current_type = TYPE_MAIN_VARIANT (type);\n   tci->known_current_offset = offset;\n   tci->type_maybe_changed = true;\n }\n@@ -2846,6 +2931,20 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n   bool function_entry_reached = false;\n   tree instance_ref = NULL;\n   gimple stmt = call;\n+  /* Remember OFFSET before it is modified by restrict_to_inner_class.\n+     This is because we do not update INSTANCE when walking inwards.  */\n+  HOST_WIDE_INT instance_offset = offset;\n+\n+  otr_type = TYPE_MAIN_VARIANT (otr_type);\n+\n+  /* Walk into inner type. This may clear maybe_derived_type and save us\n+     from useless work.  It also makes later comparsions with static type\n+     easier.  */\n+  if (outer_type)\n+    {\n+      if (!restrict_to_inner_class (otr_type))\n+        return false;\n+    }\n \n   if (!maybe_in_construction && !maybe_derived_type)\n     return false;\n@@ -2900,11 +2999,11 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \t\t     or from INSTANCE with offset OFFSET.  */\n \t\t  if (base_ref\n \t\t      && ((TREE_CODE (base_ref) == MEM_REF\n-\t\t           && ((offset2 == offset\n+\t\t           && ((offset2 == instance_offset\n \t\t                && TREE_OPERAND (base_ref, 0) == instance)\n \t\t\t       || (!offset2 && TREE_OPERAND (base_ref, 0) == otr_object)))\n \t\t\t  || (DECL_P (instance) && base_ref == instance\n-\t\t\t      && offset2 == offset)))\n+\t\t\t      && offset2 == instance_offset)))\n \t\t    {\n \t\t      stmt = SSA_NAME_DEF_STMT (ref);\n \t\t      instance_ref = ref_exp;\n@@ -3010,7 +3109,13 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n      only if there was dyanmic type store that may affect given variable\n      (seen_unanalyzed_store)  */\n \n-  if (!tci.type_maybe_changed)\n+  if (!tci.type_maybe_changed\n+      || (outer_type\n+\t  && !tci.seen_unanalyzed_store\n+\t  && !tci.multiple_types_encountered\n+\t  && offset == tci.offset\n+\t  && types_same_for_odr (tci.known_current_type,\n+\t\t\t\t outer_type)))\n     {\n       if (!outer_type || tci.seen_unanalyzed_store)\n \treturn false;\n@@ -3025,16 +3130,9 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n       && !function_entry_reached\n       && !tci.multiple_types_encountered)\n     {\n-      if (!tci.speculative\n-\t  /* Again in instances located in static storage we are interested only\n-\t     in constructor stores.  */\n-\t  || (outer_type\n-\t      && !tci.seen_unanalyzed_store\n-\t      && offset == tci.offset\n-\t      && types_same_for_odr (tci.known_current_type,\n-\t\t\t\t     outer_type)))\n+      if (!tci.speculative)\n \t{\n-\t  outer_type = tci.known_current_type;\n+\t  outer_type = TYPE_MAIN_VARIANT (tci.known_current_type);\n \t  offset = tci.known_current_offset;\n \t  maybe_in_construction = false;\n \t  maybe_derived_type = false;\n@@ -3044,15 +3142,19 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n       else if (!speculative_outer_type\n \t       || speculative_maybe_derived_type)\n \t{\n-\t  speculative_outer_type = tci.known_current_type;\n+\t  speculative_outer_type = TYPE_MAIN_VARIANT (tci.known_current_type);\n \t  speculative_offset = tci.known_current_offset;\n \t  speculative_maybe_derived_type = false;\n \t  if (dump_file)\n \t    fprintf (dump_file, \"  Determined speculative dynamic type.\\n\");\n \t}\n     }\n   else if (dump_file)\n-    fprintf (dump_file, \"  Found multiple types.\\n\");\n+    {\n+      fprintf (dump_file, \"  Found multiple types%s%s\\n\",\n+\t       function_entry_reached ? \" (function entry reached)\" : \"\",\n+\t       function_entry_reached ? \" (multiple types encountered)\" : \"\");\n+    }\n \n   return true;\n }"}, {"sha": "62444ed2364ebe29a19c675de47811a443a2e57d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=a336b719a34c07effb7e1ba9e72f8c270ea362ee", "patch": "@@ -3244,10 +3244,7 @@ do_whole_program_analysis (void)\n   cgraph_state = CGRAPH_STATE_IPA_SSA;\n \n   execute_ipa_pass_list (g->get_passes ()->all_regular_ipa_passes);\n-#ifdef ENABLE_CHECKING\n-  /* Verify that IPA passes cleans up after themselves.  */\n-  gcc_assert (!symtab_remove_unreachable_nodes (false, dump_file));\n-#endif\n+  symtab_remove_unreachable_nodes (false, dump_file);\n \n   if (cgraph_dump_file)\n     {"}, {"sha": "72a1feee8175f7cfd9896f5d860dea206213d1ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a336b719a34c07effb7e1ba9e72f8c270ea362ee", "patch": "@@ -1,3 +1,9 @@\n+2014-08-21  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR tree-optimization/62091\n+\t* g++.dg/ipa/devirt-37.C: Update template.\n+\t* g++.dg/ipa/devirt-40.C: New testcase.\n+\n 2014-08-21  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/62112"}, {"sha": "0dc4d27bbe242f9813d967a3ebce19eebc67844c", "filename": "gcc/testsuite/g++.dg/ipa/devirt-37.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-37.C?ref=a336b719a34c07effb7e1ba9e72f8c270ea362ee", "patch": "@@ -30,7 +30,7 @@ t()\n /* After inlining the call within constructor needs to be checked to not go into a basetype.\n    We should see the vtbl store and we should notice extcall as possibly clobbering the\n    type but ignore it because b is in static storage.  */\n-/* { dg-final { scan-tree-dump \"Determined dynamic type.\"  \"fre2\"  } } */\n+/* { dg-final { scan-tree-dump \"No dynamic type change found.\"  \"fre2\"  } } */\n /* { dg-final { scan-tree-dump \"Checking vtbl store:\"  \"fre2\"  } } */\n /* { dg-final { scan-tree-dump \"Function call may change dynamic type:extcall\"  \"fre2\"  } } */\n /* { dg-final { scan-tree-dump \"converting indirect call to function virtual void\"  \"fre2\"  } } */"}, {"sha": "852e369472de35917b5da3d32a17d0721c28eb14", "filename": "gcc/testsuite/g++.dg/ipa/devirt-40.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336b719a34c07effb7e1ba9e72f8c270ea362ee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-40.C?ref=a336b719a34c07effb7e1ba9e72f8c270ea362ee", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-options \"-O2 -fdump-tree-fre2-details\"  } */\n+typedef enum\n+{\n+} UErrorCode;\n+class UnicodeString\n+{\n+public:\n+  UnicodeString ();\n+  virtual ~UnicodeString ();\n+};\n+class A\n+{\n+  UnicodeString &m_fn1 (UnicodeString &, int &p2, UErrorCode &) const;\n+};\n+UnicodeString::UnicodeString () {}\n+UnicodeString &\n+A::m_fn1 (UnicodeString &, int &p2, UErrorCode &) const\n+{\n+  UnicodeString a[2];\n+}\n+\n+/* { dg-final { scan-tree-dump \"converting indirect call to function virtual UnicodeString\" \"fre2\"  } } */\n+/* { dg-final { cleanup-tree-dump \"fre2\" } } */"}]}