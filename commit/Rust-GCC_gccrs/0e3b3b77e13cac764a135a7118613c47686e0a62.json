{"sha": "0e3b3b77e13cac764a135a7118613c47686e0a62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzYjNiNzdlMTNjYWM3NjRhMTM1YTcxMTg2MTNjNDc2ODZlMGE2Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-05-24T14:50:51Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-05-24T14:50:51Z"}, "message": "OpenMP/Fortran: Handle polymorphic scalars in data-sharing FIRSTPRIVATE [PR86470]\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/86470\n\t* trans-expr.c (gfc_copy_class_to_class): Add unshare_expr.\n\t* trans-openmp.c (gfc_is_polymorphic_nonptr,\n\tgfc_is_unlimited_polymorphic_nonptr): New.\n\t(gfc_omp_clause_copy_ctor, gfc_omp_clause_dtor): Handle\n\tpolymorphic scalars.\n\nlibgomp/ChangeLog:\n\n\tPR fortran/86470\n\t* testsuite/libgomp.fortran/class-firstprivate-1.f90: New test.\n\t* testsuite/libgomp.fortran/class-firstprivate-2.f90: New test.\n\t* testsuite/libgomp.fortran/class-firstprivate-3.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/86470\n\t* gfortran.dg/gomp/class-firstprivate-1.f90: New test.\n\t* gfortran.dg/gomp/class-firstprivate-2.f90: New test.\n\t* gfortran.dg/gomp/class-firstprivate-3.f90: New test.\n\t* gfortran.dg/gomp/class-firstprivate-4.f90: New test.", "tree": {"sha": "b15486edfb13513d5f4dfe56b86ccc61a2e85fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b15486edfb13513d5f4dfe56b86ccc61a2e85fdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e3b3b77e13cac764a135a7118613c47686e0a62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3b3b77e13cac764a135a7118613c47686e0a62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3b3b77e13cac764a135a7118613c47686e0a62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3b3b77e13cac764a135a7118613c47686e0a62/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b326f495218a213079f572bd9960903b3425da74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b326f495218a213079f572bd9960903b3425da74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b326f495218a213079f572bd9960903b3425da74"}], "stats": {"total": 1376, "additions": 1374, "deletions": 2}, "files": [{"sha": "00690fe9ed41725be5696a4078eadff97661e068", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -1561,7 +1561,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \t{\n \t  vec_safe_push (args, from_len);\n \t  vec_safe_push (args, to_len);\n-\t  extcopy = build_call_vec (fcn_type, fcn, args);\n+\t  extcopy = build_call_vec (fcn_type, unshare_expr (fcn), args);\n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t logical_type_node, from_len,\n \t\t\t\t build_zero_cst (TREE_TYPE (from_len)));"}, {"sha": "44542d9ab1add464cc065b8fbd9e562bdc444272", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 161, "deletions": 1, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -360,6 +360,39 @@ gfc_has_alloc_comps (tree type, tree decl)\n   return false;\n }\n \n+/* Return true if TYPE is polymorphic but not with pointer attribute.  */\n+\n+static bool\n+gfc_is_polymorphic_nonptr (tree type)\n+{\n+  if (POINTER_TYPE_P (type))\n+    type = TREE_TYPE (type);\n+  return GFC_CLASS_TYPE_P (type);\n+}\n+\n+/* Return true if TYPE is unlimited polymorphic but not with pointer attribute;\n+   unlimited means also intrinsic types are handled and _len is used.  */\n+\n+static bool\n+gfc_is_unlimited_polymorphic_nonptr (tree type)\n+{\n+  if (POINTER_TYPE_P (type))\n+    type = TREE_TYPE (type);\n+  if (!GFC_CLASS_TYPE_P (type))\n+    return false;\n+\n+  tree field = TYPE_FIELDS (type); /* _data */\n+  gcc_assert (field);\n+  field = DECL_CHAIN (field); /* _vptr */\n+  gcc_assert (field);\n+  field = DECL_CHAIN (field);\n+  if (!field)\n+    return false;\n+  gcc_assert (strcmp (\"_len\", IDENTIFIER_POINTER (DECL_NAME (field))) == 0);\n+  return true;\n+}\n+\n+\n /* Return true if DECL in private clause needs\n    OMP_CLAUSE_PRIVATE_OUTER_REF on the private clause.  */\n bool\n@@ -743,12 +776,88 @@ tree\n gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n {\n   tree type = TREE_TYPE (dest), ptr, size, call;\n+  tree decl_type = TREE_TYPE (OMP_CLAUSE_DECL (clause));\n   tree cond, then_b, else_b;\n   stmtblock_t block, cond_block;\n \n   gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_FIRSTPRIVATE\n \t      || OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LINEAR);\n \n+  if (DECL_ARTIFICIAL (OMP_CLAUSE_DECL (clause))\n+      && DECL_LANG_SPECIFIC (OMP_CLAUSE_DECL (clause))\n+      && GFC_DECL_SAVED_DESCRIPTOR (OMP_CLAUSE_DECL (clause)))\n+    decl_type\n+      = TREE_TYPE (GFC_DECL_SAVED_DESCRIPTOR (OMP_CLAUSE_DECL (clause)));\n+\n+  if (gfc_is_polymorphic_nonptr (decl_type))\n+    {\n+      if (POINTER_TYPE_P (decl_type))\n+\tdecl_type = TREE_TYPE (decl_type);\n+      decl_type = TREE_TYPE (TYPE_FIELDS (decl_type));\n+      if (GFC_DESCRIPTOR_TYPE_P (decl_type) || GFC_ARRAY_TYPE_P (decl_type))\n+\tfatal_error (input_location,\n+\t\t     \"Sorry, polymorphic arrays not yet supported for \"\n+\t\t     \"firstprivate\");\n+      tree src_len;\n+      tree nelems = build_int_cst (size_type_node, 1);  /* Scalar.  */\n+      tree src_data = gfc_class_data_get (unshare_expr (src));\n+      tree dest_data = gfc_class_data_get (unshare_expr (dest));\n+      bool unlimited = gfc_is_unlimited_polymorphic_nonptr (type);\n+\n+      gfc_start_block (&block);\n+      gfc_add_modify (&block, gfc_class_vptr_get (dest),\n+\t\t      gfc_class_vptr_get (src));\n+      gfc_init_block (&cond_block);\n+\n+      if (unlimited)\n+\t{\n+\t  src_len = gfc_class_len_get (src);\n+\t  gfc_add_modify (&cond_block, gfc_class_len_get (unshare_expr (dest)), src_len);\n+\t}\n+\n+      /* Use: size = class._vtab._size * (class._len > 0 ? class._len : 1).  */\n+      size = fold_convert (size_type_node, gfc_class_vtab_size_get (src));\n+      if (unlimited)\n+\t{\n+\t  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t\t  unshare_expr (src_len),\n+\t\t\t\t  build_zero_cst (TREE_TYPE (src_len)));\n+\t  cond = build3_loc (input_location, COND_EXPR, size_type_node, cond,\n+\t\t\t     fold_convert (size_type_node,\n+\t\t\t\t\t   unshare_expr (src_len)),\n+\t\t\t     build_int_cst (size_type_node, 1));\n+\t  size = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t\t  size, cond);\n+\t}\n+\n+      /* Malloc memory + call class->_vpt->_copy.  */\n+      call = builtin_decl_explicit (BUILT_IN_MALLOC);\n+      call = build_call_expr_loc (input_location, call, 1, size);\n+      gfc_add_modify (&cond_block, dest_data,\n+\t\t      fold_convert (TREE_TYPE (dest_data), call));\n+      gfc_add_expr_to_block (&cond_block,\n+\t\t\t     gfc_copy_class_to_class (src, dest, nelems,\n+\t\t\t\t\t\t      unlimited));\n+\n+      gcc_assert (TREE_CODE (dest_data) == COMPONENT_REF);\n+      if (!GFC_DECL_GET_SCALAR_ALLOCATABLE (TREE_OPERAND (dest_data, 1)))\n+\t{\n+\t  gfc_add_block_to_block (&block, &cond_block);\n+\t}\n+      else\n+\t{\n+\t  /* Create: if (class._data != 0) <cond_block> else class._data = NULL; */\n+\t  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t  src_data, null_pointer_node);\n+\t  gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n+\t\t\t\t void_type_node, cond,\n+\t\t\t\t gfc_finish_block (&cond_block),\n+\t\t\t\t fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t\t unshare_expr (dest_data), null_pointer_node)));\n+\t}\n+      return gfc_finish_block (&block);\n+    }\n+\n   if ((! GFC_DESCRIPTOR_TYPE_P (type)\n        || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n       && (!GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause))\n@@ -773,7 +882,7 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n \n   gfc_init_block (&cond_block);\n \n-  gfc_add_modify (&cond_block, dest, src);\n+  gfc_add_modify (&cond_block, dest, fold_convert (TREE_TYPE (dest), src));\n   if (GFC_DESCRIPTOR_TYPE_P (type))\n     {\n       tree rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n@@ -1185,6 +1294,57 @@ tree\n gfc_omp_clause_dtor (tree clause, tree decl)\n {\n   tree type = TREE_TYPE (decl), tem;\n+  tree decl_type = TREE_TYPE (OMP_CLAUSE_DECL (clause));\n+\n+  if (DECL_ARTIFICIAL (OMP_CLAUSE_DECL (clause))\n+      && DECL_LANG_SPECIFIC (OMP_CLAUSE_DECL (clause))\n+      && GFC_DECL_SAVED_DESCRIPTOR (OMP_CLAUSE_DECL (clause)))\n+    decl_type\n+\t= TREE_TYPE (GFC_DECL_SAVED_DESCRIPTOR (OMP_CLAUSE_DECL (clause)));\n+  if (gfc_is_polymorphic_nonptr (decl_type))\n+    {\n+      if (POINTER_TYPE_P (decl_type))\n+\tdecl_type = TREE_TYPE (decl_type);\n+      decl_type = TREE_TYPE (TYPE_FIELDS (decl_type));\n+      if (GFC_DESCRIPTOR_TYPE_P (decl_type) || GFC_ARRAY_TYPE_P (decl_type))\n+\tfatal_error (input_location,\n+\t\t     \"Sorry, polymorphic arrays not yet supported for \"\n+\t\t     \"firstprivate\");\n+      stmtblock_t block, cond_block;\n+      gfc_start_block (&block);\n+      gfc_init_block (&cond_block);\n+      tree final = gfc_class_vtab_final_get (decl);\n+      tree size = fold_convert (size_type_node, gfc_class_vtab_size_get (decl));\n+      gfc_se se;\n+      gfc_init_se (&se, NULL);\n+      symbol_attribute attr = {};\n+      tree data = gfc_class_data_get (decl);\n+      tree desc = gfc_conv_scalar_to_descriptor (&se, data, attr);\n+\n+      /* Call class->_vpt->_finalize + free.  */\n+      tree call = build_fold_indirect_ref (final);\n+      call = build_call_expr_loc (input_location, call, 3,\n+\t\t\t\t  gfc_build_addr_expr (NULL, desc),\n+\t\t\t\t  size, boolean_false_node);\n+      gfc_add_block_to_block (&cond_block, &se.pre);\n+      gfc_add_expr_to_block (&cond_block, fold_convert (void_type_node, call));\n+      gfc_add_block_to_block (&cond_block, &se.post);\n+      /* Create: if (_vtab && _final) <cond_block>  */\n+      tree cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   gfc_class_vptr_get (decl),\n+\t\t\t\t   null_pointer_node);\n+      tree cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   final, null_pointer_node);\n+      cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t      boolean_type_node, cond, cond2);\n+      gfc_add_expr_to_block (&block, build3_loc (input_location, COND_EXPR,\n+\t\t\t\t void_type_node, cond,\n+\t\t\t\t gfc_finish_block (&cond_block), NULL_TREE));\n+      call = builtin_decl_explicit (BUILT_IN_FREE);\n+      call = build_call_expr_loc (input_location, call, 1, data);\n+      gfc_add_expr_to_block (&block, fold_convert (void_type_node, call));\n+      return gfc_finish_block (&block);\n+    }\n \n   if ((! GFC_DESCRIPTOR_TYPE_P (type)\n        || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)"}, {"sha": "0ff851db390f23d64ab29642825b6deacb1bee5a", "filename": "gcc/testsuite/gfortran.dg/gomp/class-firstprivate-1.f90", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-1.f90?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -0,0 +1,62 @@\n+! { dg-do compile }\n+! { dg-prune-output \"compilation terminated.\" }\n+!\n+! FIRSTPRIVATE + class array\n+!\n+! For now: Expected to give \"Sorry\" for polymorphic arrays.\n+!\n+! Polymorphic arrays are tricky - at least if not allocatable, they become:\n+!   var.0 = var._data.data\n+! which needs to be handled properly.\n+!\n+!\n+program select_type_openmp\n+  use iso_c_binding\n+  !use omp_lib\n+  implicit none\n+  integer :: i\n+  integer :: A(4)\n+  type(c_ptr) :: B(4)\n+\n+  B = [(c_null_ptr, i=1,4)]\n+  A = [1,2,3,4]\n+  call sub(A, B)\n+contains\n+  subroutine sub(val1, val2)\n+    class(*) :: val1(4)\n+    type(c_ptr) :: val2(2:5)\n+\n+    !$OMP PARALLEL firstprivate(val2)\n+      do i = 2, 5\n+        if (c_associated (val2(i))) stop 123\n+      end do\n+    !$OMP END PARALLEL\n+\n+    !$OMP PARALLEL firstprivate(val1)  ! { dg-error \"Sorry, polymorphic arrays not yet supported for firstprivate\" }\n+      select type (val1)\n+        type is (integer)\n+          if (size(val1) /= 4) stop 33\n+          if (any (val1 /= [1, 2, 3, 4])) stop 4549\n+          val1 = [32,6,48,28]\n+        class default\n+          stop 99\n+      end select\n+      select type (val1)\n+        type is (integer)\n+          if (size(val1) /= 4) stop 33\n+          if (any (val1 /= [32,6,48,28])) stop 4512\n+        class default\n+          stop 99\n+      end select\n+    !$OMP END PARALLEL\n+\n+    select type (val1)\n+      type is (integer)\n+        if (size(val1) /= 4) stop 33\n+        if (any (val1 /= [1, 2, 3, 4])) stop 454\n+      class default\n+        stop 99\n+    end select\n+    print *, \"PASS!\"\n+  end subroutine\n+end program select_type_openmp"}, {"sha": "354223741f7563d95ce5a61ee5a4aeefb91048e2", "filename": "gcc/testsuite/gfortran.dg/gomp/class-firstprivate-2.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-2.f90?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do compile }\n+! { dg-prune-output \"compilation terminated.\" }\n+!\n+! FIRSTPRIVATE + class array\n+!\n+! For now: Expected to give \"Sorry\" for polymorphic arrays.\n+!\n+! Polymorphic arrays are tricky - at least if not allocatable, they become:\n+!   var.0 = var._data.data\n+! which needs to be handled properly.\n+!\n+!\n+program select_type_openmp\n+  !use omp_lib\n+  implicit none\n+  class(*), allocatable :: B(:)\n+\n+ allocate(B, source=[\"abcdef\",\"cdefi2\"])\n+ allocate(B, source=[1,2,3])\n+ call sub(B)\n+contains\n+  subroutine sub(val2)\n+    class(*), allocatable :: val2(:)\n+\n+    !$OMP PARALLEL firstprivate(val2)  ! { dg-error \"Sorry, polymorphic arrays not yet supported for firstprivate\" }\n+      if (.not.allocated(val2)) stop 3\n+      select type (val2)\n+        type is (character(len=*))\n+          if (len(val2) /= 6) stop 44\n+          if (val2(1) /= \"abcdef\" .or. val2(2) /= \"cdefi2\") stop 4545\n+          val2 = [\"123456\", \"789ABC\"]\n+        class default\n+          stop 991\n+      end select\n+      select type (val2)\n+        type is (character(len=*))\n+          if (len(val2) /= 6) stop 44\n+          if (val2(1) /= \"123456\" .or. val2(2) /= \"789ABC\") stop 453\n+        class default\n+          stop 991\n+      end select\n+    !$OMP END PARALLEL\n+\n+    if (.not.allocated(val2)) stop 3\n+    select type (val2)\n+      type is (character(len=*))\n+        if (len(val2) /= 6) stop 44\n+        if (val2(1) /= \"abcdef\" .or. val2(2) /= \"cdefi2\") stop 456\n+      class default\n+        stop 991\n+    end select\n+    print *, \"PASS!\"\n+  end subroutine\n+end program select_type_openmp"}, {"sha": "c83bf29751197f2872c9762b885f3c2b5a0cf7ab", "filename": "gcc/testsuite/gfortran.dg/gomp/class-firstprivate-3.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-3.f90?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do compile }\n+! { dg-prune-output \"compilation terminated.\" }\n+!\n+! FIRSTPRIVATE + class array\n+!\n+! For now: Expected to give \"Sorry\" for polymorphic arrays.\n+!\n+! Polymorphic arrays are tricky - at least if not allocatable, they become:\n+!   var.0 = var._data.data\n+! which needs to be handled properly.\n+!\n+!\n+program select_type_openmp\n+  use iso_c_binding\n+  !use omp_lib\n+  implicit none\n+  call sub\n+contains\n+  subroutine sub\n+    integer :: i\n+    class(*), allocatable :: val1(:)\n+    type(c_ptr), allocatable :: val2(:)\n+ \n+    allocate(val1, source=[1, 2, 3, 4])\n+    allocate(val2(2:5))\n+    val2 = c_null_ptr\n+\n+    !$OMP PARALLEL firstprivate(val2)\n+      do i = 2, 5\n+        if (c_associated (val2(i))) stop 123\n+      end do\n+    !$OMP END PARALLEL\n+\n+    !$OMP PARALLEL firstprivate(val1)  ! { dg-error \"Sorry, polymorphic arrays not yet supported for firstprivate\" }\n+      select type (val1)\n+        type is (integer)\n+          if (size(val1) /= 4) stop 33\n+          if (any (val1 /= [1, 2, 3, 4])) stop 4549\n+          val1 = [32,6,48,28]\n+        class default\n+          stop 99\n+      end select\n+      select type (val1)\n+        type is (integer)\n+          if (size(val1) /= 4) stop 33\n+          if (any (val1 /= [32,6,48,28])) stop 4512\n+        class default\n+          stop 99\n+      end select\n+    !$OMP END PARALLEL\n+\n+    select type (val1)\n+      type is (integer)\n+        if (size(val1) /= 4) stop 33\n+        if (any (val1 /= [1, 2, 3, 4])) stop 454\n+      class default\n+        stop 99\n+    end select\n+    print *, \"PASS!\"\n+  end subroutine\n+end program select_type_openmp"}, {"sha": "237c6c535f7481acd6d1116f57479bb47f10b6df", "filename": "gcc/testsuite/gfortran.dg/gomp/class-firstprivate-4.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fclass-firstprivate-4.f90?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+! { dg-prune-output \"compilation terminated.\" }\n+!\n+! FIRSTPRIVATE + class array\n+!\n+! For now: Expected to give \"Sorry\" for polymorphic arrays.\n+!\n+! Polymorphic arrays are tricky - at least if not allocatable, they become:\n+!   var.0 = var._data.data\n+! which needs to be handled properly.\n+!\n+!\n+program select_type_openmp\n+  use iso_c_binding\n+  !use omp_lib\n+  implicit none\n+  integer x(4)\n+  x = [1, 2, 3, 4]\n+  call sub(x)\n+  if (any (x /= [1,2,3,4])) stop 3\n+contains\n+  subroutine sub(val1)\n+    integer :: i\n+    class(*) :: val1(4)\n+ \n+    !$OMP PARALLEL firstprivate(val1)  ! { dg-error \"Sorry, polymorphic arrays not yet supported for firstprivate\" }\n+      select type (val1)\n+        type is (integer)\n+          if (size(val1) /= 4) stop 33\n+          if (any (val1 /= [1, 2, 3, 4])) stop 4549\n+          val1 = [32,6,48,28]\n+        class default\n+          stop 99\n+      end select\n+      select type (val1)\n+        type is (integer)\n+          if (size(val1) /= 4) stop 34\n+          if (any (val1 /= [32,6,48,28])) stop 4512\n+        class default\n+          stop 98\n+      end select\n+    !$OMP END PARALLEL\n+  end\n+end"}, {"sha": "b77117ec61101bd67ebe27639b58d096d5c36a91", "filename": "libgomp/testsuite/libgomp.fortran/class-firstprivate-1.f90", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-1.f90?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -0,0 +1,323 @@\n+! FIRSTPRIVATE: CLASS(*) + intrinsic types\n+program select_type_openmp\n+  implicit none\n+  class(*), allocatable :: val1, val1a, val2, val3\n+\n+  call sub() ! local var\n+\n+  call sub2(val1, val1a, val2, val3) ! allocatable args\n+\n+  allocate(val1, source=7)\n+  allocate(val1a, source=7)\n+  allocate(val2, source=\"abcdef\")\n+  allocate(val3, source=4_\"zyx4\")\n+  call sub3(val1, val1a, val2, val3)  ! nonallocatable vars\n+  deallocate(val1, val1a, val2, val3)\n+contains\n+subroutine sub()\n+  class(*), allocatable :: val1, val1a, val2, val3\n+  allocate(val1a, source=7)\n+  allocate(val2, source=\"abcdef\")\n+  allocate(val3, source=4_\"zyx4\")\n+\n+  if (allocated(val1)) stop 1\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    if (allocated(val1)) stop 2\n+    if (.not.allocated(val1a)) stop 3\n+    if (.not.allocated(val2)) stop 4\n+    if (.not.allocated(val3)) stop 5\n+\n+    allocate(val1, source=7)\n+\n+    select type (val1)\n+      type is (integer)\n+        if (val1 /= 7) stop 6\n+        val1 = 8\n+      class default\n+        stop 7\n+    end select\n+\n+    select type (val1a)\n+      type is (integer)\n+        if (val1a /= 7) stop 8\n+        val1a = 8\n+      class default\n+        stop 9\n+    end select\n+\n+    select type (val2)\n+      type is (character(len=*))\n+        if (len(val2) /= 6) stop 10\n+        if (val2 /= \"abcdef\") stop 11\n+        val2 = \"123456\"\n+      class default\n+        stop 12\n+    end select\n+\n+    select type (val3)\n+      type is (character(len=*, kind=4))\n+        if (len(val3) /= 4) stop 13\n+        if (val3 /= 4_\"zyx4\") stop 14\n+        val3 = 4_\"AbCd\"\n+      class default\n+        stop 15\n+    end select\n+\n+    select type (val3)\n+      type is (character(len=*, kind=4))\n+        if (len(val3) /= 4) stop 16\n+        if (val3 /= 4_\"AbCd\") stop 17\n+        val3 = 4_\"1ab2\"\n+      class default\n+        stop 18\n+    end select\n+\n+    select type (val2)\n+      type is (character(len=*))\n+        if (len(val2) /= 6) stop 19\n+        if (val2 /= \"123456\") stop 20\n+        val2 = \"A2C4E6\"\n+      class default\n+        stop 21\n+    end select\n+\n+    select type (val1)\n+      type is (integer)\n+        if (val1 /= 8) stop 22\n+        val1 = 9\n+      class default\n+        stop 23\n+    end select\n+\n+    select type (val1a)\n+      type is (integer)\n+        if (val1a /= 8) stop 24\n+        val1a = 9\n+      class default\n+        stop 25\n+    end select\n+  !$OMP END PARALLEL\n+\n+  if (allocated(val1)) stop 26\n+  if (.not. allocated(val1a)) stop 27\n+  if (.not. allocated(val2)) stop 28\n+\n+  select type (val2)\n+    type is (character(len=*))\n+      if (len(val2) /= 6) stop 29\n+      if (val2 /= \"abcdef\") stop 30\n+    class default\n+      stop 31\n+  end select\n+  select type (val3)\n+    type is (character(len=*,kind=4))\n+      if (len(val3) /= 4) stop 32\n+      if (val3 /= 4_\"zyx4\") stop 33\n+    class default\n+      stop 34\n+  end select\n+  deallocate(val1a, val2, val3)\n+end subroutine sub\n+\n+subroutine sub2(val1, val1a, val2, val3)\n+  class(*), allocatable :: val1, val1a, val2, val3\n+  optional :: val1a\n+  allocate(val1a, source=7)\n+  allocate(val2, source=\"abcdef\")\n+  allocate(val3, source=4_\"zyx4\")\n+ \n+  if (allocated(val1)) stop 35\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    if (allocated(val1)) stop 36\n+    if (.not.allocated(val1a)) stop 37\n+    if (.not.allocated(val2)) stop 38\n+    if (.not.allocated(val3)) stop 39\n+\n+    allocate(val1, source=7)\n+\n+    select type (val1)\n+      type is (integer)\n+        if (val1 /= 7) stop 40\n+        val1 = 8\n+      class default\n+        stop 41\n+    end select\n+\n+    select type (val1a)\n+      type is (integer)\n+        if (val1a /= 7) stop 42\n+        val1a = 8\n+      class default\n+        stop 43\n+    end select\n+\n+    select type (val2)\n+      type is (character(len=*))\n+        if (len(val2) /= 6) stop 44\n+        if (val2 /= \"abcdef\") stop 45\n+        val2 = \"123456\"\n+      class default\n+        stop 46\n+    end select\n+\n+    select type (val3)\n+      type is (character(len=*, kind=4))\n+        if (len(val3) /= 4) stop 47\n+        if (val3 /= 4_\"zyx4\") stop 48\n+        val3 = \"AbCd\"\n+      class default\n+        stop 49\n+    end select\n+\n+    select type (val3)\n+      type is (character(len=*, kind=4))\n+        if (len(val3) /= 4) stop 50\n+        if (val3 /= 4_\"AbCd\") stop 51\n+        val3 = 4_\"1ab2\"\n+      class default\n+        stop 52\n+    end select\n+\n+    select type (val2)\n+      type is (character(len=*))\n+        if (len(val2) /= 6) stop 53\n+        if (val2 /= \"123456\") stop 54\n+        val2 = \"A2C4E6\"\n+      class default\n+        stop 55\n+    end select\n+\n+    select type (val1)\n+      type is (integer)\n+        if (val1 /= 8) stop 56\n+        val1 = 9\n+      class default\n+        stop 57\n+    end select\n+\n+    select type (val1a)\n+      type is (integer)\n+        if (val1a /= 8) stop 58\n+        val1a = 9\n+      class default\n+        stop 59\n+    end select\n+  !$OMP END PARALLEL\n+\n+  if (allocated(val1)) stop 60\n+  if (.not. allocated(val1a)) stop 61\n+  if (.not. allocated(val2)) stop 62\n+\n+  select type (val2)\n+    type is (character(len=*))\n+      if (len(val2) /= 6) stop 63\n+      if (val2 /= \"abcdef\") stop 64\n+    class default\n+        stop 65\n+  end select\n+\n+  select type (val3)\n+    type is (character(len=*, kind=4))\n+      if (len(val3) /= 4) stop 66\n+      if (val3 /= 4_\"zyx4\") stop 67\n+      val3 = 4_\"AbCd\"\n+    class default\n+      stop 68\n+  end select\n+  deallocate(val1a, val2, val3)\n+end subroutine sub2\n+\n+subroutine sub3(val1, val1a, val2, val3)\n+  class(*) :: val1, val1a, val2, val3\n+  optional :: val1a\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    select type (val1)\n+      type is (integer)\n+        if (val1 /= 7) stop 69\n+        val1 = 8\n+      class default\n+        stop 70\n+    end select\n+\n+    select type (val1a)\n+      type is (integer)\n+        if (val1a /= 7) stop 71\n+        val1a = 8\n+      class default\n+        stop 72\n+    end select\n+\n+    select type (val2)\n+      type is (character(len=*))\n+        if (len(val2) /= 6) stop 73\n+        if (val2 /= \"abcdef\") stop 74\n+        val2 = \"123456\"\n+      class default\n+        stop 75\n+    end select\n+\n+    select type (val3)\n+      type is (character(len=*, kind=4))\n+        if (len(val3) /= 4) stop 76\n+        if (val3 /= 4_\"zyx4\") stop 77\n+        val3 = 4_\"AbCd\"\n+      class default\n+        stop 78\n+    end select\n+\n+    select type (val3)\n+      type is (character(len=*, kind=4))\n+        if (len(val3) /= 4) stop 79\n+        if (val3 /= 4_\"AbCd\") stop 80\n+        val3 = 4_\"1ab2\"\n+      class default\n+        stop 81\n+    end select\n+\n+    select type (val2)\n+      type is (character(len=*))\n+        if (len(val2) /= 6) stop 82\n+        if (val2 /= \"123456\") stop 83\n+        val2 = \"A2C4E6\"\n+      class default\n+        stop 84\n+    end select\n+\n+    select type (val1)\n+      type is (integer)\n+        if (val1 /= 8) stop 85\n+        val1 = 9\n+      class default\n+        stop 86\n+    end select\n+\n+    select type (val1a)\n+      type is (integer)\n+        if (val1a /= 8) stop 87\n+        val1a = 9\n+      class default\n+        stop 88\n+    end select\n+  !$OMP END PARALLEL\n+\n+  select type (val2)\n+    type is (character(len=*))\n+      if (len(val2) /= 6) stop 89\n+      if (val2 /= \"abcdef\") stop 90\n+    class default\n+      stop 91\n+  end select\n+\n+  select type (val3)\n+    type is (character(len=*, kind=4))\n+      if (len(val3) /= 4) stop 92\n+      if (val3 /= 4_\"zyx4\") stop 93\n+      val3 = 4_\"AbCd\"\n+    class default\n+      stop 94\n+  end select\n+end subroutine sub3\n+end program select_type_openmp"}, {"sha": "7528d32e8dbe597026587c089abcc941a0f3213b", "filename": "libgomp/testsuite/libgomp.fortran/class-firstprivate-2.f90", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-2.f90?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -0,0 +1,334 @@\n+! FIRSTPRIVATE: CLASS(t) + derived types\n+program select_type_openmp\n+  implicit none\n+  type t\n+  end type t\n+  type, extends(t) :: t_int\n+    integer :: i\n+  end type \n+  type, extends(t) :: t_char1\n+    character(len=:, kind=1), allocatable :: str\n+  end type \n+  type, extends(t) :: t_char4\n+    character(len=:, kind=4), allocatable :: str\n+  end type \n+  class(t), allocatable :: val1, val1a, val2, val3\n+\n+  call sub() ! local var\n+\n+  call sub2(val1, val1a, val2, val3) ! allocatable args\n+\n+  allocate(val1, source=t_int(7))\n+  allocate(val1a, source=t_int(7))\n+  allocate(val2, source=t_char1(\"abcdef\"))\n+  allocate(val3, source=t_char4(4_\"zyx4\"))\n+  call sub3(val1, val1a, val2, val3)  ! nonallocatable vars\n+  deallocate(val1, val1a, val2, val3)\n+contains\n+subroutine sub()\n+  class(t), allocatable :: val1, val1a, val2, val3\n+  allocate(val1a, source=t_int(7))\n+  allocate(val2, source=t_char1(\"abcdef\"))\n+  allocate(val3, source=t_char4(4_\"zyx4\"))\n+\n+  if (allocated(val1)) stop 1\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    if (allocated(val1)) stop 2\n+    if (.not.allocated(val1a)) stop 3\n+    if (.not.allocated(val2)) stop 4\n+    if (.not.allocated(val3)) stop 5\n+\n+    allocate(val1, source=t_int(7))\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 7) stop 6\n+        val1%i = 8\n+      class default\n+        stop 7\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 7) stop 8\n+        val1a%i = 8\n+      class default\n+        stop 9\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 10\n+        if (val2%str /= \"abcdef\") stop 11\n+        val2%str = \"123456\"\n+      class default\n+        stop 12\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 13\n+        if (val3%str /= 4_\"zyx4\") stop 14\n+        val3%str = 4_\"AbCd\"\n+      class default\n+        stop 15\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 16\n+        if (val3%str /= 4_\"AbCd\") stop 17\n+        val3%str = 4_\"1ab2\"\n+      class default\n+        stop 18\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 19\n+        if (val2%str /= \"123456\") stop 20\n+        val2%str = \"A2C4E6\"\n+      class default\n+        stop 21\n+    end select\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 8) stop 22\n+        val1%i = 9\n+      class default\n+        stop 23\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 8) stop 24\n+        val1a%i = 9\n+      class default\n+        stop 25\n+    end select\n+  !$OMP END PARALLEL\n+\n+  if (allocated(val1)) stop 26\n+  if (.not. allocated(val1a)) stop 27\n+  if (.not. allocated(val2)) stop 28\n+\n+  select type (val2)\n+    type is (t_char1)\n+      if (len(val2%str) /= 6) stop 29\n+      if (val2%str /= \"abcdef\") stop 30\n+    class default\n+      stop 31\n+  end select\n+  select type (val3)\n+    type is (t_char4)\n+      if (len(val3%str) /= 4) stop 32\n+      if (val3%str /= 4_\"zyx4\") stop 33\n+    class default\n+      stop 34\n+  end select\n+  deallocate(val1a,val2, val3)\n+end subroutine sub\n+\n+subroutine sub2(val1, val1a, val2, val3)\n+  class(t), allocatable :: val1, val1a, val2, val3\n+  optional :: val1a\n+  allocate(val1a, source=t_int(7))\n+  allocate(val2, source=t_char1(\"abcdef\"))\n+  allocate(val3, source=t_char4(4_\"zyx4\"))\n+ \n+  if (allocated(val1)) stop 35\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    if (allocated(val1)) stop 36\n+    if (.not.allocated(val1a)) stop 37\n+    if (.not.allocated(val2)) stop 38\n+    if (.not.allocated(val3)) stop 39\n+\n+    allocate(val1, source=t_int(7))\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 7) stop 40\n+        val1%i = 8\n+      class default\n+        stop 41\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 7) stop 42\n+        val1a%i = 8\n+      class default\n+        stop 43\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 44\n+        if (val2%str /= \"abcdef\") stop 45\n+        val2%str = \"123456\"\n+      class default\n+        stop 46\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 47\n+        if (val3%str /= 4_\"zyx4\") stop 48\n+        val3%str = \"AbCd\"\n+      class default\n+        stop 49\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 50\n+        if (val3%str /= 4_\"AbCd\") stop 51\n+        val3%str = 4_\"1ab2\"\n+      class default\n+        stop 52\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 53\n+        if (val2%str /= \"123456\") stop 54\n+        val2%str = \"A2C4E6\"\n+      class default\n+        stop 55\n+    end select\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 8) stop 56\n+        val1%i = 9\n+      class default\n+        stop 57\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 8) stop 58\n+        val1a%i = 9\n+      class default\n+        stop 59\n+    end select\n+  !$OMP END PARALLEL\n+\n+  if (allocated(val1)) stop 60\n+  if (.not. allocated(val1a)) stop 61\n+  if (.not. allocated(val2)) stop 62\n+\n+  select type (val2)\n+    type is (t_char1)\n+      if (len(val2%str) /= 6) stop 63\n+      if (val2%str /= \"abcdef\") stop 64\n+    class default\n+        stop 65\n+  end select\n+\n+  select type (val3)\n+    type is (t_char4)\n+      if (len(val3%str) /= 4) stop 66\n+      if (val3%str /= 4_\"zyx4\") stop 67\n+      val3%str = 4_\"AbCd\"\n+    class default\n+      stop 68\n+  end select\n+  deallocate(val1a, val2, val3)\n+end subroutine sub2\n+\n+subroutine sub3(val1, val1a, val2, val3)\n+  class(t) :: val1, val1a, val2, val3\n+  optional :: val1a\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 7) stop 69\n+        val1%i = 8\n+      class default\n+        stop 70\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 7) stop 71\n+        val1a%i = 8\n+      class default\n+        stop 72\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 73\n+        if (val2%str /= \"abcdef\") stop 74\n+        val2%str = \"123456\"\n+      class default\n+        stop 75\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 76\n+        if (val3%str /= 4_\"zyx4\") stop 77\n+        val3%str = 4_\"AbCd\"\n+      class default\n+        stop 78\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 79\n+        if (val3%str /= 4_\"AbCd\") stop 80\n+        val3%str = 4_\"1ab2\"\n+      class default\n+        stop 81\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 82\n+        if (val2%str /= \"123456\") stop 83\n+        val2%str = \"A2C4E6\"\n+      class default\n+        stop 84\n+    end select\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 8) stop 85\n+        val1%i = 9\n+      class default\n+        stop 86\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 8) stop 87\n+        val1a%i = 9\n+      class default\n+        stop 88\n+    end select\n+  !$OMP END PARALLEL\n+\n+  select type (val2)\n+    type is (t_char1)\n+      if (len(val2%str) /= 6) stop 89\n+      if (val2%str /= \"abcdef\") stop 90\n+    class default\n+      stop 91\n+  end select\n+\n+  select type (val3)\n+    type is (t_char4)\n+      if (len(val3%str) /= 4) stop 92\n+      if (val3%str /= 4_\"zyx4\") stop 93\n+      val3%str = 4_\"AbCd\"\n+    class default\n+      stop 94\n+  end select\n+end subroutine sub3\n+end program select_type_openmp"}, {"sha": "a450fdee1ac760c54cab6b26eb40c474011fab0f", "filename": "libgomp/testsuite/libgomp.fortran/class-firstprivate-3.f90", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3b3b77e13cac764a135a7118613c47686e0a62/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3b3b77e13cac764a135a7118613c47686e0a62/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fclass-firstprivate-3.f90?ref=0e3b3b77e13cac764a135a7118613c47686e0a62", "patch": "@@ -0,0 +1,334 @@\n+! FIRSTPRIVATE: CLASS(*) + derived types\n+program select_type_openmp\n+  implicit none\n+  type t\n+  end type t\n+  type, extends(t) :: t_int\n+    integer :: i\n+  end type \n+  type, extends(t) :: t_char1\n+    character(len=:, kind=1), allocatable :: str\n+  end type \n+  type, extends(t) :: t_char4\n+    character(len=:, kind=4), allocatable :: str\n+  end type \n+  class(*), allocatable :: val1, val1a, val2, val3\n+\n+  call sub() ! local var\n+\n+  call sub2(val1, val1a, val2, val3) ! allocatable args\n+\n+  allocate(val1, source=t_int(7))\n+  allocate(val1a, source=t_int(7))\n+  allocate(val2, source=t_char1(\"abcdef\"))\n+  allocate(val3, source=t_char4(4_\"zyx4\"))\n+  call sub3(val1, val1a, val2, val3)  ! nonallocatable vars\n+  deallocate(val1, val1a, val2, val3)\n+contains\n+subroutine sub()\n+  class(*), allocatable :: val1, val1a, val2, val3\n+  allocate(val1a, source=t_int(7))\n+  allocate(val2, source=t_char1(\"abcdef\"))\n+  allocate(val3, source=t_char4(4_\"zyx4\"))\n+\n+  if (allocated(val1)) stop 1\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    if (allocated(val1)) stop 2\n+    if (.not.allocated(val1a)) stop 3\n+    if (.not.allocated(val2)) stop 4\n+    if (.not.allocated(val3)) stop 5\n+\n+    allocate(val1, source=t_int(7))\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 7) stop 6\n+        val1%i = 8\n+      class default\n+        stop 7\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 7) stop 8\n+        val1a%i = 8\n+      class default\n+        stop 9\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 10\n+        if (val2%str /= \"abcdef\") stop 11\n+        val2%str = \"123456\"\n+      class default\n+        stop 12\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 13\n+        if (val3%str /= 4_\"zyx4\") stop 14\n+        val3%str = 4_\"AbCd\"\n+      class default\n+        stop 15\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 16\n+        if (val3%str /= 4_\"AbCd\") stop 17\n+        val3%str = 4_\"1ab2\"\n+      class default\n+        stop 18\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 19\n+        if (val2%str /= \"123456\") stop 20\n+        val2%str = \"A2C4E6\"\n+      class default\n+        stop 21\n+    end select\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 8) stop 22\n+        val1%i = 9\n+      class default\n+        stop 23\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 8) stop 24\n+        val1a%i = 9\n+      class default\n+        stop 25\n+    end select\n+  !$OMP END PARALLEL\n+\n+  if (allocated(val1)) stop 26\n+  if (.not. allocated(val1a)) stop 27\n+  if (.not. allocated(val2)) stop 28\n+\n+  select type (val2)\n+    type is (t_char1)\n+      if (len(val2%str) /= 6) stop 29\n+      if (val2%str /= \"abcdef\") stop 30\n+    class default\n+      stop 31\n+  end select\n+  select type (val3)\n+    type is (t_char4)\n+      if (len(val3%str) /= 4) stop 32\n+      if (val3%str /= 4_\"zyx4\") stop 33\n+    class default\n+      stop 34\n+  end select\n+  deallocate(val1a,val2, val3)\n+end subroutine sub\n+\n+subroutine sub2(val1, val1a, val2, val3)\n+  class(*), allocatable :: val1, val1a, val2, val3\n+  optional :: val1a\n+  allocate(val1a, source=t_int(7))\n+  allocate(val2, source=t_char1(\"abcdef\"))\n+  allocate(val3, source=t_char4(4_\"zyx4\"))\n+ \n+  if (allocated(val1)) stop 35\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    if (allocated(val1)) stop 36\n+    if (.not.allocated(val1a)) stop 37\n+    if (.not.allocated(val2)) stop 38\n+    if (.not.allocated(val3)) stop 39\n+\n+    allocate(val1, source=t_int(7))\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 7) stop 40\n+        val1%i = 8\n+      class default\n+        stop 41\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 7) stop 42\n+        val1a%i = 8\n+      class default\n+        stop 43\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 44\n+        if (val2%str /= \"abcdef\") stop 45\n+        val2%str = \"123456\"\n+      class default\n+        stop 46\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 47\n+        if (val3%str /= 4_\"zyx4\") stop 48\n+        val3%str = \"AbCd\"\n+      class default\n+        stop 49\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 50\n+        if (val3%str /= 4_\"AbCd\") stop 51\n+        val3%str = 4_\"1ab2\"\n+      class default\n+        stop 52\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 53\n+        if (val2%str /= \"123456\") stop 54\n+        val2%str = \"A2C4E6\"\n+      class default\n+        stop 55\n+    end select\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 8) stop 56\n+        val1%i = 9\n+      class default\n+        stop 57\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 8) stop 58\n+        val1a%i = 9\n+      class default\n+        stop 59\n+    end select\n+  !$OMP END PARALLEL\n+\n+  if (allocated(val1)) stop 60\n+  if (.not. allocated(val1a)) stop 61\n+  if (.not. allocated(val2)) stop 62\n+\n+  select type (val2)\n+    type is (t_char1)\n+      if (len(val2%str) /= 6) stop 63\n+      if (val2%str /= \"abcdef\") stop 64\n+    class default\n+        stop 65\n+  end select\n+\n+  select type (val3)\n+    type is (t_char4)\n+      if (len(val3%str) /= 4) stop 66\n+      if (val3%str /= 4_\"zyx4\") stop 67\n+      val3%str = 4_\"AbCd\"\n+    class default\n+      stop 68\n+  end select\n+  deallocate(val1a, val2, val3)\n+end subroutine sub2\n+\n+subroutine sub3(val1, val1a, val2, val3)\n+  class(*) :: val1, val1a, val2, val3\n+  optional :: val1a\n+\n+  !$OMP PARALLEL firstprivate(val1, val1a, val2, val3)\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 7) stop 69\n+        val1%i = 8\n+      class default\n+        stop 70\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 7) stop 71\n+        val1a%i = 8\n+      class default\n+        stop 72\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 73\n+        if (val2%str /= \"abcdef\") stop 74\n+        val2%str = \"123456\"\n+      class default\n+        stop 75\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 76\n+        if (val3%str /= 4_\"zyx4\") stop 77\n+        val3%str = 4_\"AbCd\"\n+      class default\n+        stop 78\n+    end select\n+\n+    select type (val3)\n+      type is (t_char4)\n+        if (len(val3%str) /= 4) stop 79\n+        if (val3%str /= 4_\"AbCd\") stop 80\n+        val3%str = 4_\"1ab2\"\n+      class default\n+        stop 81\n+    end select\n+\n+    select type (val2)\n+      type is (t_char1)\n+        if (len(val2%str) /= 6) stop 82\n+        if (val2%str /= \"123456\") stop 83\n+        val2%str = \"A2C4E6\"\n+      class default\n+        stop 84\n+    end select\n+\n+    select type (val1)\n+      type is (t_int)\n+        if (val1%i /= 8) stop 85\n+        val1%i = 9\n+      class default\n+        stop 86\n+    end select\n+\n+    select type (val1a)\n+      type is (t_int)\n+        if (val1a%i /= 8) stop 87\n+        val1a%i = 9\n+      class default\n+        stop 88\n+    end select\n+  !$OMP END PARALLEL\n+\n+  select type (val2)\n+    type is (t_char1)\n+      if (len(val2%str) /= 6) stop 89\n+      if (val2%str /= \"abcdef\") stop 90\n+    class default\n+      stop 91\n+  end select\n+\n+  select type (val3)\n+    type is (t_char4)\n+      if (len(val3%str) /= 4) stop 92\n+      if (val3%str /= 4_\"zyx4\") stop 93\n+      val3%str = 4_\"AbCd\"\n+    class default\n+      stop 94\n+  end select\n+end subroutine sub3\n+end program select_type_openmp"}]}