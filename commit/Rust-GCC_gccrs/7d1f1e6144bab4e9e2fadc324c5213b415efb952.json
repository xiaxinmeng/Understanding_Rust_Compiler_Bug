{"sha": "7d1f1e6144bab4e9e2fadc324c5213b415efb952", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QxZjFlNjE0NGJhYjRlOWUyZmFkYzMyNGM1MjEzYjQxNWVmYjk1Mg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-07-29T20:44:09Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-07-29T20:44:09Z"}, "message": "trans-expr.c (conv_parent_component_references): New function to build missing parent references.\n\n2008-07-29  Paul Thomas  <pault@gcc.gnu.org>\n\nfortran/\t\n\t* trans-expr.c (conv_parent_component_references): New function\n\tto build missing parent references.\n\t(gfc_conv_variable): Call it\n\t* symbol.c (gfc_add_component): Check that component name in a\n\tderived type extension does not appear in parent.\n\t(gfc_find_component): For a derived type extension, check if\n\tthe component appears in the parent derived type by calling\n\tself. Separate errors for private components and private types.\n\t* decl.c (match_data_constant): Add extra arg to call to\n\tgfc_match_structure_constructor.\n\t(check_extended_derived_type): New function to check that a\n\tparent derived type exists and that it is OK for exension.\n\t(gfc_get_type_attr_spec): Add extra argument 'name' and return\n\tit if extends is specified.\n\t(gfc_match_derived_decl): Match derived type extension and\n\tbuild a first component of the parent derived type if OK. Add\n\tthe f2k namespace if not present.\n\t* gfortran.h : Add the extension attribute.\n\t* module.c : Handle attribute 'extension'.\n\t* match.h : Modify prototypes for gfc_get_type_attr_spec and\n\tgfc_match_structure_constructor.\n\t* primary.c (build_actual_constructor): New function extracted\n\tfrom gfc_match_structure_constructor and modified to call self\n\titeratively to build derived type extensions, when f2k named\n\tcomponents are used.\n\t(gfc_match_structure_constructor): Do not throw error for too\n\tmany components if a parent type is being handled. Use\n\tgfc_find_component to generate errors for non-existent or\n\tprivate components.  Iteratively call self for derived type\n\textensions so that parent constructor is built.  If extension\n\tand components left over, throw error.\n\t(gfc_match_rvalue): Add extra arg to call to\n\tgfc_match_structure_constructor.\n\t* trans-array.c (gfc_conv_resolve_dependencies): If lhs and rhs\n\tare the same symbol, aliassing does not matter.\ntestsuite/\n\t* gfortran.dg/extends_1.f03: New test.\n\t* gfortran.dg/extends_2.f03: New test.\n\t* gfortran.dg/extends_3.f03: New test.\n\t* gfortran.dg/extends_4.f03: New test.\n\t* gfortran.dg/extends_5.f03: New test.\n\t* gfortran.dg/extends_6.f03: New test.\n\t* gfortran.dg/private_type_6.f90: Modify error message.\n\t* gfortran.dg/structure_constructor_7.f03: Modify error message.\n\t* gfortran.dg/structure_constructor_8.f03: Modify error message.\n\nFrom-SVN: r138275", "tree": {"sha": "1d8aa1d99f6217a1f9fdc2522ae987cc7d2f9586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d8aa1d99f6217a1f9fdc2522ae987cc7d2f9586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d1f1e6144bab4e9e2fadc324c5213b415efb952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d1f1e6144bab4e9e2fadc324c5213b415efb952", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d1f1e6144bab4e9e2fadc324c5213b415efb952", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d1f1e6144bab4e9e2fadc324c5213b415efb952/comments", "author": null, "committer": null, "parents": [{"sha": "e54cf1573e36c71c5277d59fd1c1915984b06432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54cf1573e36c71c5277d59fd1c1915984b06432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e54cf1573e36c71c5277d59fd1c1915984b06432"}], "stats": {"total": 849, "additions": 717, "deletions": 132}, "files": [{"sha": "e8ce99b446171e67ab8d7920952f58c0c1813a02", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -1,3 +1,42 @@\n+2008-07-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* trans-expr.c (conv_parent_component_references): New function\n+\tto build missing parent references.\n+\t(gfc_conv_variable): Call it\n+\t* symbol.c (gfc_add_component): Check that component name in a\n+\tderived type extension does not appear in parent.\n+\t(gfc_find_component): For a derived type extension, check if\n+\tthe component appears in the parent derived type by calling\n+\tself. Separate errors for private components and private types.\n+\t* decl.c (match_data_constant): Add extra arg to call to\n+\tgfc_match_structure_constructor.\n+\t(check_extended_derived_type): New function to check that a\n+\tparent derived type exists and that it is OK for exension.\n+\t(gfc_get_type_attr_spec): Add extra argument 'name' and return\n+\tit if extends is specified.\n+\t(gfc_match_derived_decl): Match derived type extension and\n+\tbuild a first component of the parent derived type if OK. Add\n+\tthe f2k namespace if not present.\n+\t* gfortran.h : Add the extension attribute.\n+\t* module.c : Handle attribute 'extension'.\n+\t* match.h : Modify prototypes for gfc_get_type_attr_spec and\n+\tgfc_match_structure_constructor.\n+\t* primary.c (build_actual_constructor): New function extracted\n+\tfrom gfc_match_structure_constructor and modified to call self\n+\titeratively to build derived type extensions, when f2k named\n+\tcomponents are used.\n+\t(gfc_match_structure_constructor): Do not throw error for too\n+\tmany components if a parent type is being handled. Use\n+\tgfc_find_component to generate errors for non-existent or\n+\tprivate components.  Iteratively call self for derived type\n+\textensions so that parent constructor is built.  If extension\n+\tand components left over, throw error.\n+\t(gfc_match_rvalue): Add extra arg to call to\n+\tgfc_match_structure_constructor.\n+\n+\t* trans-array.c (gfc_conv_resolve_dependencies): If lhs and rhs\n+\tare the same symbol, aliassing does not matter.\n+\n 2008-07-29  Jan Hubicka  <jh@suse.cz>\n \n \t* options.c (gfc_post_options): Do not set flag_no_inline."}, {"sha": "8b9b8c0e868f44c59fc5fa434025fdeffe771e47", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 88, "deletions": 3, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -367,7 +367,7 @@ match_data_constant (gfc_expr **result)\n       return MATCH_ERROR;\n     }\n   else if (sym->attr.flavor == FL_DERIVED)\n-    return gfc_match_structure_constructor (sym, result);\n+    return gfc_match_structure_constructor (sym, result, false);\n \n   /* Check to see if the value is an initialization array expression.  */\n   if (sym->value->expr_type == EXPR_ARRAY)\n@@ -6250,14 +6250,57 @@ gfc_match_modproc (void)\n }\n \n \n+/* Check a derived type that is being extended.  */\n+static gfc_symbol*\n+check_extended_derived_type (char *name)\n+{\n+  gfc_symbol *extended;\n+\n+  if (gfc_find_symbol (name, gfc_current_ns, 1, &extended))\n+    {\n+      gfc_error (\"Ambiguous symbol in TYPE definition at %C\");\n+      return NULL;\n+    }\n+\n+  if (!extended)\n+    {\n+      gfc_error (\"No such symbol in TYPE definition at %C\");\n+      return NULL;\n+    }\n+\n+  if (extended->attr.flavor != FL_DERIVED)\n+    {\n+      gfc_error (\"'%s' in EXTENDS expression at %C is not a \"\n+\t\t \"derived type\", name);\n+      return NULL;\n+    }\n+\n+  if (extended->attr.is_bind_c)\n+    {\n+      gfc_error (\"'%s' cannot be extended at %C because it \"\n+\t\t \"is BIND(C)\", extended->name);\n+      return NULL;\n+    }\n+\n+  if (extended->attr.sequence)\n+    {\n+      gfc_error (\"'%s' cannot be extended at %C because it \"\n+\t\t \"is a SEQUENCE type\", extended->name);\n+      return NULL;\n+    }\n+\n+  return extended;\n+}\n+\n+\n /* Match the optional attribute specifiers for a type declaration.\n    Return MATCH_ERROR if an error is encountered in one of the handled\n    attributes (public, private, bind(c)), MATCH_NO if what's found is\n    not a handled attribute, and MATCH_YES otherwise.  TODO: More error\n    checking on attribute conflicts needs to be done.  */\n \n match\n-gfc_get_type_attr_spec (symbol_attribute *attr)\n+gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n {\n   /* See if the derived type is marked as private.  */\n   if (gfc_match (\" , private\") == MATCH_YES)\n@@ -6295,6 +6338,12 @@ gfc_get_type_attr_spec (symbol_attribute *attr)\n \n       /* TODO: attr conflicts need to be checked, probably in symbol.c.  */\n     }\n+  else if (name && gfc_match(\" , extends ( %n )\", name) == MATCH_YES)\n+    {\n+      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: derived type \"\n+\t    \"extended at %C\") == FAILURE)\n+\treturn MATCH_ERROR;\n+    }\n   else\n     return MATCH_NO;\n \n@@ -6311,26 +6360,38 @@ match\n gfc_match_derived_decl (void)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n+  char parent[GFC_MAX_SYMBOL_LEN + 1];\n   symbol_attribute attr;\n   gfc_symbol *sym;\n+  gfc_symbol *extended;\n   match m;\n   match is_type_attr_spec = MATCH_NO;\n   bool seen_attr = false;\n \n   if (gfc_current_state () == COMP_DERIVED)\n     return MATCH_NO;\n \n+  name[0] = '\\0';\n+  parent[0] = '\\0';\n   gfc_clear_attr (&attr);\n+  extended = NULL;\n \n   do\n     {\n-      is_type_attr_spec = gfc_get_type_attr_spec (&attr);\n+      is_type_attr_spec = gfc_get_type_attr_spec (&attr, parent);\n       if (is_type_attr_spec == MATCH_ERROR)\n \treturn MATCH_ERROR;\n       if (is_type_attr_spec == MATCH_YES)\n \tseen_attr = true;\n     } while (is_type_attr_spec == MATCH_YES);\n \n+  /* Deal with derived type extensions.  */\n+  if (parent[0])\n+    extended = check_extended_derived_type (parent);\n+\n+  if (parent[0] && !extended)\n+    return MATCH_ERROR;\n+\n   if (gfc_match (\" ::\") != MATCH_YES && seen_attr)\n     {\n       gfc_error (\"Expected :: in TYPE definition at %C\");\n@@ -6383,10 +6444,34 @@ gfc_match_derived_decl (void)\n   if (attr.is_bind_c != 0)\n     sym->attr.is_bind_c = attr.is_bind_c;\n \n+\n   /* Construct the f2k_derived namespace if it is not yet there.  */\n   if (!sym->f2k_derived)\n     sym->f2k_derived = gfc_get_namespace (NULL, 0);\n \n+  \n+  if (extended && !sym->components)\n+    {\n+      gfc_component *p;\n+      gfc_symtree *st;\n+\n+      /* Add the extended derived type as the first component.  */\n+      gfc_add_component (sym, parent, &p);\n+      sym->attr.extension = 1;\n+      extended->refs++;\n+      gfc_set_sym_referenced (extended);\n+\n+      p->ts.type = BT_DERIVED;\n+      p->ts.derived = extended;\n+      p->initializer = gfc_default_initializer (&p->ts);\n+\n+      /* Provide the links between the extended type and its extension.  */\n+      if (!extended->f2k_derived)\n+\textended->f2k_derived = gfc_get_namespace (NULL, 0);\n+      st = gfc_new_symtree (&extended->f2k_derived->sym_root, sym->name);\n+      st->n.sym = sym;\n+    }\n+\n   gfc_new_block = sym;\n \n   return MATCH_YES;"}, {"sha": "51192481326ee0593f369809cbda61f1d88d2fae", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -638,6 +638,7 @@ typedef struct\n   unsigned untyped:1;           /* No implicit type could be found.  */\n \n   unsigned is_bind_c:1;\t\t/* say if is bound to C */\n+  unsigned extension:1;\t\t/* extends a derived type */\n \n   /* These flags are both in the typespec and attribute.  The attribute\n      list is what gets read from/written to a module file.  The typespec\n@@ -1016,9 +1017,6 @@ typedef struct gfc_symbol\n \n   gfc_formal_arglist *formal;\n   struct gfc_namespace *formal_ns;\n-\n-  /* The namespace containing type-associated procedure symbols.  */\n-  /* TODO: Make this union with formal?  */\n   struct gfc_namespace *f2k_derived;\n \n   struct gfc_expr *value;\t/* Parameter/Initializer value */"}, {"sha": "9c9d206822cf9755c3a8e27ce26a1f5d3d62f24b", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -182,10 +182,10 @@ gfc_try get_bind_c_idents (void);\n match gfc_match_bind_c_stmt (void);\n match gfc_match_suffix (gfc_symbol *, gfc_symbol **);\n match gfc_match_bind_c (gfc_symbol *, bool);\n-match gfc_get_type_attr_spec (symbol_attribute *);\n+match gfc_get_type_attr_spec (symbol_attribute *, char*);\n \n /* primary.c.  */\n-match gfc_match_structure_constructor (gfc_symbol *, gfc_expr **);\n+match gfc_match_structure_constructor (gfc_symbol *, gfc_expr **, bool);\n match gfc_match_variable (gfc_expr **, int);\n match gfc_match_equiv_variable (gfc_expr **);\n match gfc_match_actual_arglist (int, gfc_actual_arglist **);"}, {"sha": "ed575f9574f18e0640400d7d86dc210e55768425", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -1648,7 +1648,8 @@ typedef enum\n   AB_ELEMENTAL, AB_PURE, AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT,\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP,\n   AB_POINTER_COMP, AB_PRIVATE_COMP, AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n-  AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP\n+  AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n+  AB_EXTENSION\n }\n ab_attribute;\n \n@@ -1688,6 +1689,7 @@ static const mstring attr_bits[] =\n     minit (\"ZERO_COMP\", AB_ZERO_COMP),\n     minit (\"PROTECTED\", AB_PROTECTED),\n     minit (\"ABSTRACT\", AB_ABSTRACT),\n+    minit (\"EXTENSION\", AB_EXTENSION),\n     minit (NULL, -1)\n };\n \n@@ -1801,6 +1803,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_PRIVATE_COMP, attr_bits);\n       if (attr->zero_comp)\n \tMIO_NAME (ab_attribute) (AB_ZERO_COMP, attr_bits);\n+      if (attr->extension)\n+\tMIO_NAME (ab_attribute) (AB_EXTENSION, attr_bits);\n \n       mio_rparen ();\n \n@@ -1919,6 +1923,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_ZERO_COMP:\n \t      attr->zero_comp = 1;\n \t      break;\n+\t    case AB_EXTENSION:\n+\t      attr->extension = 1;\n+\t      break;\n \t    }\n \t}\n     }"}, {"sha": "dfea043d6e3a6333f259d5daaee2e44ac9c8b6ef", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 145, "deletions": 105, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -1984,22 +1984,114 @@ gfc_free_structure_ctor_component (gfc_structure_ctor_component *comp)\n   gfc_free_expr (comp->val);\n }\n \n-match\n-gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n+\n+/* Translate the component list into the actual constructor by sorting it in\n+   the order required; this also checks along the way that each and every\n+   component actually has an initializer and handles default initializers\n+   for components without explicit value given.  */\n+static gfc_try\n+build_actual_constructor (gfc_structure_ctor_component **comp_head,\n+\t\t\t  gfc_constructor **ctor_head, gfc_symbol *sym)\n {\n-  gfc_structure_ctor_component *comp_head, *comp_tail;\n   gfc_structure_ctor_component *comp_iter;\n+  gfc_constructor *ctor_tail = NULL;\n+  gfc_component *comp;\n+\n+  for (comp = sym->components; comp; comp = comp->next)\n+    {\n+      gfc_structure_ctor_component **next_ptr;\n+      gfc_expr *value = NULL;\n+\n+      /* Try to find the initializer for the current component by name.  */\n+      next_ptr = comp_head;\n+      for (comp_iter = *comp_head; comp_iter; comp_iter = comp_iter->next)\n+\t{\n+\t  if (!strcmp (comp_iter->name, comp->name))\n+\t    break;\n+\t  next_ptr = &comp_iter->next;\n+\t}\n+\n+      /* If an extension, try building the parent derived type by building\n+\t a value expression for the parent derived type and calling self.  */\n+      if (!comp_iter && comp == sym->components && sym->attr.extension)\n+\t{\n+\t  value = gfc_get_expr ();\n+\t  value->expr_type = EXPR_STRUCTURE;\n+\t  value->value.constructor = NULL;\n+\t  value->ts = comp->ts;\n+\t  value->where = gfc_current_locus;\n+\n+\t  if (build_actual_constructor (comp_head, &value->value.constructor,\n+\t\t\t\t\tcomp->ts.derived) == FAILURE)\n+\t    {\n+\t      gfc_free_expr (value);\n+\t      return FAILURE;\n+\t    }\n+\t  *ctor_head = ctor_tail = gfc_get_constructor ();\n+\t  ctor_tail->expr = value;\n+\t  continue;\n+\t}\n+\n+      /* If it was not found, try the default initializer if there's any;\n+\t otherwise, it's an error.  */\n+      if (!comp_iter)\n+\t{\n+\t  if (comp->initializer)\n+\t    {\n+\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Structure\"\n+\t\t\t\t  \" constructor with missing optional arguments\"\n+\t\t\t\t  \" at %C\") == FAILURE)\n+\t\treturn FAILURE;\n+\t      value = gfc_copy_expr (comp->initializer);\n+\t    }\n+\t  else\n+\t    {\n+\t      gfc_error (\"No initializer for component '%s' given in the\"\n+\t\t\t \" structure constructor at %C!\", comp->name);\n+\t      return FAILURE;\n+\t    }\n+\t}\n+      else\n+\tvalue = comp_iter->val;\n+\n+      /* Add the value to the constructor chain built.  */\n+      if (ctor_tail)\n+\t{\n+\t  ctor_tail->next = gfc_get_constructor ();\n+\t  ctor_tail = ctor_tail->next;\n+\t}\n+      else\n+\t*ctor_head = ctor_tail = gfc_get_constructor ();\n+      gcc_assert (value);\n+      ctor_tail->expr = value;\n+\n+      /* Remove the entry from the component list.  We don't want the expression\n+\t value to be free'd, so set it to NULL.  */\n+      if (comp_iter)\n+\t{\n+\t  *next_ptr = comp_iter->next;\n+\t  comp_iter->val = NULL;\n+\t  gfc_free_structure_ctor_component (comp_iter);\n+\t}\n+    }\n+  return SUCCESS;\n+}\n+\n+match\n+gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result, bool parent)\n+{\n+  gfc_structure_ctor_component *comp_tail, *comp_head, *comp_iter;\n   gfc_constructor *ctor_head, *ctor_tail;\n   gfc_component *comp; /* Is set NULL when named component is first seen */\n   gfc_expr *e;\n   locus where;\n   match m;\n   const char* last_name = NULL;\n \n-  comp_head = comp_tail = NULL;\n+  comp_tail = comp_head = NULL;\n   ctor_head = ctor_tail = NULL;\n \n-  if (gfc_match_char ('(') != MATCH_YES)\n+  if (!parent && gfc_match_char ('(') != MATCH_YES)\n     goto syntax;\n \n   where = gfc_current_locus;\n@@ -2047,7 +2139,7 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n \t\t  if (last_name)\n \t\t    gfc_error (\"Component initializer without name after\"\n \t\t\t       \" component named %s at %C!\", last_name);\n-\t\t  else\n+\t\t  else if (!parent)\n \t\t    gfc_error (\"Too many components in structure constructor at\"\n \t\t\t       \" %C!\");\n \t\t  goto cleanup;\n@@ -2057,39 +2149,20 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n \t      strncpy (comp_tail->name, comp->name, GFC_MAX_SYMBOL_LEN + 1);\n \t    }\n \n-\t  /* Find the current component in the structure definition; this is\n-\t     needed to get its access attribute in the private check below.  */\n+\t  /* Find the current component in the structure definition and check its\n+\t     access is not private.  */\n \t  if (comp)\n-\t    this_comp = comp;\n+\t    this_comp = gfc_find_component (sym, comp->name);\n \t  else\n \t    {\n-\t      for (comp = sym->components; comp; comp = comp->next)\n-\t\tif (!strcmp (comp->name, comp_tail->name))\n-\t\t  {\n-\t\t    this_comp = comp;\n-\t\t    break;\n-\t\t  }\n+\t      this_comp = gfc_find_component (sym, (const char *)comp_tail->name);\n \t      comp = NULL; /* Reset needed!  */\n-\n-\t      /* Here we can check if a component name is given which does not\n-\t\t correspond to any component of the defined structure.  */\n-\t      if (!this_comp)\n-\t\t{\n-\t\t  gfc_error (\"Component '%s' in structure constructor at %C\"\n-\t\t\t     \" does not correspond to any component in the\"\n-\t\t\t     \" constructed structure!\", comp_tail->name);\n-\t\t  goto cleanup;\n-\t\t}\n \t    }\n-\t  gcc_assert (this_comp);\n \n-\t  /* Check the current component's access status.  */\n-\t  if (sym->attr.use_assoc && this_comp->access == ACCESS_PRIVATE)\n-\t    {\n-\t      gfc_error (\"Component '%s' is PRIVATE in structure constructor\"\n-\t\t\t \" at %C!\", comp_tail->name);\n-\t      goto cleanup;\n-\t    }\n+\t  /* Here we can check if a component name is given which does not\n+\t     correspond to any component of the defined structure.  */\n+\t  if (!this_comp)\n+\t    goto cleanup;\n \n \t  /* Check if this component is already given a value.  */\n \t  for (comp_iter = comp_head; comp_iter != comp_tail; \n@@ -2111,89 +2184,56 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result)\n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n \n-\t  if (comp)\n-\t    comp = comp->next;\n-\t}\n-      while (gfc_match_char (',') == MATCH_YES);\n+\t  /* If not explicitly a parent constructor, gather up the components\n+\t     and build one.  */\n+\t  if (comp && comp == sym->components\n+\t\t&& sym->attr.extension\n+\t\t&& (comp_tail->val->ts.type != BT_DERIVED\n+\t\t      ||\n+\t\t    comp_tail->val->ts.derived != this_comp->ts.derived))\n+\t    {\n+\t      gfc_current_locus = where;\n+\t      gfc_free_expr (comp_tail->val);\n \n-      if (gfc_match_char (')') != MATCH_YES)\n-\tgoto syntax;\n-\t\n-      /* If there were components given and all components are private, error\n-\t out at this place.  */\n-      if (sym->attr.use_assoc && sym->component_access == ACCESS_PRIVATE)\n-\t{\n-\t  gfc_error (\"All components of '%s' are PRIVATE in structure\"\n-\t\t     \" constructor at %C\", sym->name);\n-\t  goto cleanup;\n-\t}\n-    }\n+\t      m = gfc_match_structure_constructor (comp->ts.derived, \n+\t\t\t\t\t\t   &comp_tail->val, true);\n+\t      if (m == MATCH_NO)\n+\t\tgoto syntax;\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto cleanup;\n+\t    }\n \n-  /* Translate the component list into the actual constructor by sorting it in\n-     the order required; this also checks along the way that each and every\n-     component actually has an initializer and handles default initializers\n-     for components without explicit value given.  */\n-  for (comp = sym->components; comp; comp = comp->next)\n-    {\n-      gfc_structure_ctor_component **next_ptr;\n-      gfc_expr *value = NULL;\n+ \t  if (comp)\n+\t    comp = comp->next;\n \n-      /* Try to find the initializer for the current component by name.  */\n-      next_ptr = &comp_head;\n-      for (comp_iter = comp_head; comp_iter; comp_iter = comp_iter->next)\n-\t{\n-\t  if (!strcmp (comp_iter->name, comp->name))\n+\t  if (parent && !comp)\n \t    break;\n-\t  next_ptr = &comp_iter->next;\n-\t}\n-\n-      /* If it was not found, try the default initializer if there's any;\n-\t otherwise, it's an error.  */\n-      if (!comp_iter)\n-\t{\n-\t  if (comp->initializer)\n-\t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Structure\"\n-\t\t\t\t  \" constructor with missing optional arguments\"\n-\t\t\t\t  \" at %C\") == FAILURE)\n-\t\tgoto cleanup;\n-\t      value = gfc_copy_expr (comp->initializer);\n-\t    }\n-\t  else\n-\t    {\n-\t      gfc_error (\"No initializer for component '%s' given in the\"\n-\t\t\t \" structure constructor at %C!\", comp->name);\n-\t      goto cleanup;\n-\t    }\n \t}\n-      else\n-\tvalue = comp_iter->val;\n \n-      /* Add the value to the constructor chain built.  */\n-      if (ctor_tail)\n-\t{\n-\t  ctor_tail->next = gfc_get_constructor ();\n-\t  ctor_tail = ctor_tail->next;\n-\t}\n-      else\n-\tctor_head = ctor_tail = gfc_get_constructor ();\n-      gcc_assert (value);\n-      ctor_tail->expr = value;\n+      while (gfc_match_char (',') == MATCH_YES);\n \n-      /* Remove the entry from the component list.  We don't want the expression\n-\t value to be free'd, so set it to NULL.  */\n-      if (comp_iter)\n-\t{\n-\t  *next_ptr = comp_iter->next;\n-\t  comp_iter->val = NULL;\n-\t  gfc_free_structure_ctor_component (comp_iter);\n-\t}\n+      if (!parent && gfc_match_char (')') != MATCH_YES)\n+\tgoto syntax;\n     }\n \n+  if (build_actual_constructor (&comp_head, &ctor_head, sym) == FAILURE)\n+    goto cleanup;\n+\n   /* No component should be left, as this should have caused an error in the\n      loop constructing the component-list (name that does not correspond to any\n      component in the structure definition).  */\n-  gcc_assert (!comp_head);\n+  if (comp_head && sym->attr.extension)\n+    {\n+      for (comp_iter = comp_head; comp_iter; comp_iter = comp_iter->next)\n+\t{\n+\t  gfc_error (\"component '%s' at %L has already been set by a \"\n+\t\t     \"parent derived type constructor\", comp_iter->name,\n+\t\t     &comp_iter->where);\n+\t}\n+      goto cleanup;\n+    }\n+  else\n+    gcc_assert (!comp_head);\n \n   e = gfc_get_expr ();\n \n@@ -2396,7 +2436,7 @@ gfc_match_rvalue (gfc_expr **result)\n       if (sym == NULL)\n \tm = MATCH_ERROR;\n       else\n-\tm = gfc_match_structure_constructor (sym, &e);\n+\tm = gfc_match_structure_constructor (sym, &e, false);\n       break;\n \n     /* If we're here, then the name is known to be the name of a"}, {"sha": "d4cbd0b66842dea99b54833fdb36017f9fec497a", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -1701,6 +1701,14 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n       tail = p;\n     }\n \n+  if (sym->attr.extension\n+\t&& gfc_find_component (sym->components->ts.derived, name))\n+    {\n+      gfc_error (\"Component '%s' at %C already in the parent type \"\n+\t\t \"at %L\", name, &sym->components->ts.derived->declared_at);\n+      return FAILURE;\n+    }\n+\n   /* Allocate a new component.  */\n   p = gfc_get_component ();\n \n@@ -1830,17 +1838,36 @@ gfc_find_component (gfc_symbol *sym, const char *name)\n     if (strcmp (p->name, name) == 0)\n       break;\n \n+  if (p == NULL\n+\t&& sym->attr.extension\n+\t&& sym->components->ts.type == BT_DERIVED)\n+    {\n+      p = gfc_find_component (sym->components->ts.derived, name);\n+      /* Do not overwrite the error.  */\n+      if (p == NULL)\n+\treturn p;\n+    }\n+\n   if (p == NULL)\n     gfc_error (\"'%s' at %C is not a member of the '%s' structure\",\n \t       name, sym->name);\n-  else\n+\n+  else if (sym->attr.use_assoc)\n     {\n-      if (sym->attr.use_assoc && (sym->component_access == ACCESS_PRIVATE\n-\t\t\t\t  || p->access == ACCESS_PRIVATE))\n+      if (p->access == ACCESS_PRIVATE)\n \t{\n \t  gfc_error (\"Component '%s' at %C is a PRIVATE component of '%s'\",\n \t\t     name, sym->name);\n-\t  p = NULL;\n+\t  return NULL;\n+\t}\n+\t\n+      /* If there were components given and all components are private, error\n+\t out at this place.  */\n+      if (p->access != ACCESS_PUBLIC && sym->component_access == ACCESS_PRIVATE)\n+\t{\n+\t  gfc_error (\"All components of '%s' are PRIVATE in structure\"\n+\t\t     \" constructor at %C\", sym->name);\n+\t  return NULL;\n \t}\n     }\n "}, {"sha": "6c6845daf4eb0f43f281564ef709e88829d25e64", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -3257,14 +3257,16 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n       if (ss->type != GFC_SS_SECTION)\n \tcontinue;\n \n-      if (gfc_could_be_alias (dest, ss)\n-\t    || gfc_are_equivalenced_arrays (dest->expr, ss->expr))\n+      if (dest->expr->symtree->n.sym != ss->expr->symtree->n.sym)\n \t{\n-\t  nDepend = 1;\n-\t  break;\n+\t  if (gfc_could_be_alias (dest, ss)\n+\t\t|| gfc_are_equivalenced_arrays (dest->expr, ss->expr))\n+\t    {\n+\t      nDepend = 1;\n+\t      break;\n+\t    }\n \t}\n-\n-      if (dest->expr->symtree->n.sym == ss->expr->symtree->n.sym)\n+      else\n \t{\n \t  lref = dest->expr->ref;\n \t  rref = ss->expr->ref;"}, {"sha": "94b912f6d4cd3c703254099a53183091fc1ecbd2", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -1,6 +1,6 @@\n /* Expression translation\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n \n@@ -395,6 +395,40 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n }\n \n \n+/* This function deals with component references to components of the\n+   parent type for derived type extensons.  */\n+static void\n+conv_parent_component_references (gfc_se * se, gfc_ref * ref)\n+{\n+  gfc_component *c;\n+  gfc_component *cmp;\n+  gfc_symbol *dt;\n+  gfc_ref parent;\n+\n+  dt = ref->u.c.sym;\n+  c = ref->u.c.component;\n+\n+  /* Build a gfc_ref to recursively call gfc_conv_component_ref.  */\n+  parent.type = REF_COMPONENT;\n+  parent.next = NULL;\n+  parent.u.c.sym = dt;\n+  parent.u.c.component = dt->components;\n+\n+  if (dt->attr.extension && dt->components)\n+    {\n+      /* Return if the component is not in the parent type.  */\n+      for (cmp = dt->components->next; cmp; cmp = cmp->next)\n+\tif (strcmp (c->name, cmp->name) == 0)\n+\t  return;\n+\t\n+      /* Otherwise build the reference and call self.  */\n+      gfc_conv_component_ref (se, &parent);\n+      parent.u.c.sym = dt->components->ts.derived;\n+      parent.u.c.component = c;\n+      conv_parent_component_references (se, &parent);\n+    }\n+}\n+\n /* Return the contents of a variable. Also handles reference/pointer\n    variables (all Fortran pointer references are implicit).  */\n \n@@ -561,6 +595,9 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  break;\n \n \tcase REF_COMPONENT:\n+\t  if (ref->u.c.sym->attr.extension)\n+\t    conv_parent_component_references (se, ref);\n+\n \t  gfc_conv_component_ref (se, ref);\n \t  break;\n "}, {"sha": "6d63ecdf7421d47489c92d46ec5f201123e2381e", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -1,6 +1,6 @@\n /* IO Code translation/library interface\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n This file is part of GCC."}, {"sha": "5836949f3eece61cb9700718abdef6bb9b53c60b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -1,3 +1,15 @@\n+2008-07-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/extends_1.f03: New test.\n+\t* gfortran.dg/extends_2.f03: New test.\n+\t* gfortran.dg/extends_3.f03: New test.\n+\t* gfortran.dg/extends_4.f03: New test.\n+\t* gfortran.dg/extends_5.f03: New test.\n+\t* gfortran.dg/extends_6.f03: New test.\n+\t* gfortran.dg/private_type_6.f90: Modify error message.\n+\t* gfortran.dg/structure_constructor_7.f03: Modify error message.\n+\t* gfortran.dg/structure_constructor_8.f03: Modify error message.\n+\n 2008-07-29  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36945"}, {"sha": "57a50732c559d4e952f4270c1d1e34e9ddd851a8", "filename": "gcc/testsuite/gfortran.dg/extends_1.f03", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_1.f03?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -0,0 +1,73 @@\n+! { dg-do run }\n+! A basic functional test of derived type extension.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module persons\n+  type :: person\n+    character(24) :: name = \"\"\n+    integer :: ss = 1\n+  end type person\n+end module persons\n+\n+module person_education\n+  use persons\n+  type, extends(person) :: education\n+    integer ::  attainment = 0\n+    character(24) :: institution = \"\"\n+  end type education\n+end module person_education\n+\n+  use person_education\n+  type, extends(education) :: service\n+    integer :: personnel_number = 0\n+    character(24) :: department = \"\"\n+  end type service\n+  \n+  type, extends(service) :: person_record\n+    type (person_record), pointer :: supervisor => NULL ()\n+  end type person_record\n+  \n+  type(person_record), pointer :: recruit, supervisor\n+  \n+! Check that references by ultimate component work\n+\n+  allocate (supervisor)\n+  supervisor%name = \"Joe Honcho\"\n+  supervisor%ss = 123455\n+  supervisor%attainment = 100\n+  supervisor%institution = \"Celestial University\"\n+  supervisor%personnel_number = 1\n+  supervisor%department = \"Directorate\"\n+\n+  recruit => entry (\"John Smith\", 123456, 1, \"Bog Hill High School\", &\n+                    99, \"Records\", supervisor)\n+\n+  if (trim (recruit%name) /= \"John Smith\") call abort\n+  if (recruit%name /= recruit%service%name) call abort\n+  if (recruit%supervisor%ss /= 123455) call abort\n+  if (recruit%supervisor%ss /= supervisor%person%ss) call abort\n+\n+  deallocate (supervisor)\n+  deallocate (recruit)\n+contains\n+  function entry (name, ss, attainment, institution, &\n+                  personnel_number, department, supervisor) result (new_person)\n+    integer :: ss, attainment, personnel_number\n+    character (*) :: name, institution, department\n+    type (person_record), pointer :: supervisor, new_person\n+\n+    allocate (new_person)\n+\n+! Check mixtures of references\n+    new_person%person%name = name\n+    new_person%service%education%person%ss = ss\n+    new_person%service%attainment = attainment\n+    new_person%education%institution = institution\n+    new_person%personnel_number = personnel_number\n+    new_person%service%department = department\n+    new_person%supervisor => supervisor\n+  end function\n+end\n+\n+! { dg-final { cleanup-modules \"persons person_education\" } }"}, {"sha": "aabbf662a4ff2e5aed22fd500f2cfbc362c8fc81", "filename": "gcc/testsuite/gfortran.dg/extends_2.f03", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_2.f03?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+! A test of f95 style constructors with derived type extension.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module persons\n+  type :: person\n+    character(24) :: name = \"\"\n+    integer :: ss = 1\n+  end type person\n+end module persons\n+\n+module person_education\n+  use persons\n+  type, extends(person) :: education\n+    integer ::  attainment = 0\n+    character(24) :: institution = \"\"\n+  end type education\n+end module person_education\n+\n+  use person_education\n+  type, extends(education) :: service\n+    integer :: personnel_number = 0\n+    character(24) :: department = \"\"\n+  end type service\n+\n+  type, extends(service) :: person_record\n+    type (person_record), pointer :: supervisor => NULL ()\n+  end type person_record\n+\n+  type(person_record), pointer :: recruit, supervisor\n+\n+! Check that simple constructor works\n+  allocate (supervisor)\n+  supervisor%service = service (\"Joe Honcho\", 123455, 100, &\n+                                \"Celestial University\", 1, &\n+                                \"Directorate\")\n+\n+  recruit => entry (\"John Smith\", 123456, 1, \"Bog Hill High School\", &\n+                    99, \"Records\", supervisor)\n+\n+  if (trim (recruit%name) /= \"John Smith\") call abort\n+  if (recruit%name /= recruit%service%name) call abort\n+  if (recruit%supervisor%ss /= 123455) call abort\n+  if (recruit%supervisor%ss /= supervisor%person%ss) call abort\n+\n+  deallocate (supervisor)\n+  deallocate (recruit)\n+contains\n+  function entry (name, ss, attainment, institution, &\n+                  personnel_number, department, supervisor) result (new_person)\n+    integer :: ss, attainment, personnel_number\n+    character (*) :: name, institution, department\n+    type (person_record), pointer :: supervisor, new_person\n+\n+    allocate (new_person)\n+\n+! Check nested constructors\n+    new_person = person_record (education (person (name, ss), &\n+                                attainment, institution), &\n+                                personnel_number, department, &\n+                                supervisor)\n+  end function\n+end\n+\n+! { dg-final { cleanup-modules \"persons person_education\" } }"}, {"sha": "27ae670d95ff5a4114648d4aba652870ccbb1c4e", "filename": "gcc/testsuite/gfortran.dg/extends_3.f03", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_3.f03?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+! A test of f2k style constructors with derived type extension.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module persons\n+  type :: person\n+    character(24) :: name = \"\"\n+    integer :: ss = 1\n+  end type person\n+end module persons\n+\n+module person_education\n+  use persons\n+  type, extends(person) :: education\n+    integer ::  attainment = 0\n+    character(24) :: institution = \"\"\n+  end type education\n+end module person_education\n+\n+  use person_education\n+  type, extends(education) :: service\n+    integer :: personnel_number = 0\n+    character(24) :: department = \"\"\n+  end type service\n+\n+  type, extends(service) :: person_record\n+    type (person_record), pointer :: supervisor => NULL ()\n+  end type person_record\n+\n+  type(person_record), pointer :: recruit, supervisor\n+  \n+! Check that F2K constructor with missing entries works\n+  allocate (supervisor)\n+  supervisor%service = service (NAME = \"Joe Honcho\", SS= 123455)\n+\n+  recruit => entry (\"John Smith\", 123456, 1, \"Bog Hill High School\", &\n+                    99, \"Records\", supervisor)\n+\n+  if (supervisor%ss /= 123455) call abort\n+  if (trim (supervisor%name) /= \"Joe Honcho\") call abort\n+  if (trim (supervisor%institution) /= \"\") call abort\n+  if (supervisor%attainment /= 0) call abort\n+\n+  if (trim (recruit%name) /= \"John Smith\") call abort\n+  if (recruit%name /= recruit%service%name) call abort\n+  if (recruit%supervisor%ss /= 123455) call abort\n+  if (recruit%supervisor%ss /= supervisor%person%ss) call abort\n+\n+  deallocate (supervisor)\n+  deallocate (recruit)\n+contains\n+  function entry (name, ss, attainment, institution, &\n+                  personnel_number, department, supervisor) result (new_person)\n+    integer :: ss, attainment, personnel_number\n+    character (*) :: name, institution, department\n+    type (person_record), pointer :: supervisor, new_person\n+\n+    allocate (new_person)\n+\n+! Check F2K constructor with order shuffled a bit\n+    new_person = person_record (NAME = name, SS =ss, &\n+                                DEPARTMENT = department, &\n+                                INSTITUTION = institution, &\n+                                PERSONNEL_NUMBER = personnel_number, &\n+                                ATTAINMENT = attainment, &\n+                                SUPERVISOR = supervisor)\n+  end function\n+end\n+\n+! { dg-final { cleanup-modules \"persons person_education\" } }"}, {"sha": "941a6639213ad14e20d2f3cbf88a4907d22f734f", "filename": "gcc/testsuite/gfortran.dg/extends_4.f03", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_4.f03?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+! Check that derived type extension is compatible with renaming\n+! the parent type and that allocatable components are OK.  At\n+! the same time, private type and components are checked.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module mymod\n+  type :: a\n+    real, allocatable :: x(:)\n+    integer, private :: ia = 0\n+  end type a\n+  type :: b\n+    private\n+    real, allocatable :: x(:)\n+    integer :: i\n+  end type b\n+contains\n+  function set_b () result (res)\n+    type(b) :: res\n+    allocate (res%x(2))\n+    res%x = [10.0, 20.0]\n+    res%i = 1\n+  end function\n+  subroutine check_b (arg)\n+    type(b) :: arg\n+    if (any (arg%x /= [10.0, 20.0])) call abort\n+    if (arg%i /= 1) call abort\n+  end subroutine\n+end module mymod\n+\n+  use mymod, e => a\n+  type, extends(e) :: f\n+    integer :: if\n+  end type f\n+  type, extends(b) :: d\n+    integer :: id\n+  end type d\n+\n+  type(f) :: p\n+  type(d) :: q\n+\n+  p = f (x = [1.0, 2.0], if = 3)\n+  if (any (p%e%x /= [1.0, 2.0])) call abort\n+\n+  q%b = set_b ()\n+  call check_b (q%b)\n+  q = d (b = set_b (), id = 99)\n+  call check_b (q%b)\n+end\n+\n+! { dg-final { cleanup-modules \"persons person_education\" } }"}, {"sha": "5146d456355bd7197490ad324e24b689cec2e13b", "filename": "gcc/testsuite/gfortran.dg/extends_5.f03", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_5.f03?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! Some errors for derived type extension.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module m\n+  use iso_c_binding\n+  type :: date\n+    sequence\n+    integer :: yr, mon\n+    integer,public :: day\n+  end type\n+  type, bind(c) :: dt\n+    integer(c_int) :: yr, mon\n+    integer(c_int) :: day\n+  end type\n+end module m\n+\n+  use m\n+  type, extends(date) :: datetime ! { dg-error \"because it is a SEQUENCE type\" }\n+  end type ! { dg-error \"Expecting END PROGRAM\" }\n+\n+  type, extends(dt) :: dt_type ! { dg-error \"because it is BIND\" }\n+  end type ! { dg-error \"Expecting END PROGRAM\" }\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "866fbbd1c50f70092f688fa1ee762c8a2277345c", "filename": "gcc/testsuite/gfortran.dg/extends_6.f03", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_6.f03?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+! Some errors pointed out in the development of the patch.\n+!\n+! Contributed by Tobias Burnus  <burnus@net-b.de>\n+!\n+module m\n+  type :: date\n+    private\n+    integer :: yr, mon\n+    integer,public :: day\n+  end type\n+  type :: dt\n+    integer :: yr, mon\n+    integer :: day\n+  end type\n+end module m\n+\n+  use m\n+  type, extends(date) :: datetime\n+    integer :: hr, min, sec\n+  end type\n+  type(datetime) :: o_dt\n+\n+  type :: one\n+    integer :: i\n+  end type one\n+\n+  type, extends(one) :: two\n+    real :: r\n+  end type two\n+\n+  o_dt%day = 5  ! VALID but failed in first version of EXTENDS patch\n+  o_dt%yr  = 5  ! { dg-error \"All components of 'date' are PRIVATE\" }\n+\n+  t = two(one = one(4), i = 5, r=4.4) ! { dg-error \"has already been set\" }\n+\n+  call foo\n+contains\n+  subroutine foo\n+    use m, date_type => dt\n+    type, extends(date_type) :: dt_type\n+    end type\n+    type (dt_type) :: foo_dt\n+    foo_dt%date_type%day = 1\n+    foo_dt%dt%day = 1 ! { dg-error \"not a member\" }\n+  end subroutine\n+end\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "5e13ed534778f51457195f4dd2b1b429526201fa", "filename": "gcc/testsuite/gfortran.dg/private_type_6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprivate_type_6.f90?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -19,7 +19,7 @@ program foo_test\n   TYPE(footype) :: foo\n   TYPE(bartype) :: foo2\n   foo  = footype(1) ! { dg-error \"All components of 'footype' are PRIVATE\" }\n-  foo2 = bartype(1,2) ! { dg-error \"'dummy2' is PRIVATE\" }\n+  foo2 = bartype(1,2) ! { dg-error \"is a PRIVATE component\" }\n   foo2%dummy2 = 5 ! { dg-error \"is a PRIVATE component\" }\n end program foo_test\n ! { dg-final { cleanup-modules \"foomod\" } }"}, {"sha": "5388e8805ebc9d4be9b3fd7083bd0f8d596b4a82", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_7.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_7.f03?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -13,6 +13,6 @@ PROGRAM test\n   TYPE(basics_t) :: basics\n \n   basics = basics_t (42, 1.5, 1000) ! { dg-error \"Too many components\" }\n-  basics = basics_t (42, xxx = 1000) ! { dg-error \"Component 'xxx'\" }\n+  basics = basics_t (42, xxx = 1000) ! { dg-error \"is not a member\" }\n \n END PROGRAM test"}, {"sha": "520b52853d59900d97939ce395fdfaae6ee10792", "filename": "gcc/testsuite/gfortran.dg/structure_constructor_8.f03", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d1f1e6144bab4e9e2fadc324c5213b415efb952/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstructure_constructor_8.f03?ref=7d1f1e6144bab4e9e2fadc324c5213b415efb952", "patch": "@@ -47,8 +47,8 @@ PROGRAM test\n   struct2 = allpriv_t ()\n \n   ! These should fail\n-  struct1 = haspriv_t (1, 2) ! { dg-error \"'b' is PRIVATE\" }\n-  struct1 = haspriv_t (b = 2, a = 1) ! { dg-error \"'b' is PRIVATE\" }\n+  struct1 = haspriv_t (1, 2) ! { dg-error \"is a PRIVATE component\" }\n+  struct1 = haspriv_t (b = 2, a = 1) ! { dg-error \"is a PRIVATE component\" }\n \n   ! This should fail as all components are private\n   struct2 = allpriv_t (5) ! { dg-error \"of 'allpriv_t' are PRIVATE\" }"}]}