{"sha": "390b17c28c10ab2b6752cb94b150c831762575fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwYjE3YzI4YzEwYWIyYjY3NTJjYjk0YjE1MGM4MzE3NjI1NzVmYw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2009-08-06T14:27:45Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2009-08-06T14:27:45Z"}, "message": "Merge ARM/hard_vfp_branch to trunk\n\nFrom-SVN: r150525", "tree": {"sha": "df1d57c0d8628c4ee8c6416e133ab90912496374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df1d57c0d8628c4ee8c6416e133ab90912496374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/390b17c28c10ab2b6752cb94b150c831762575fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390b17c28c10ab2b6752cb94b150c831762575fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/390b17c28c10ab2b6752cb94b150c831762575fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390b17c28c10ab2b6752cb94b150c831762575fc/comments", "author": null, "committer": null, "parents": [{"sha": "5b62ee8ae37494be0187ded458072c66414304ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b62ee8ae37494be0187ded458072c66414304ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b62ee8ae37494be0187ded458072c66414304ce"}], "stats": {"total": 2071, "additions": 1943, "deletions": 128}, "files": [{"sha": "5fb34a87dee95d07e2c308fbf1886c542aba75e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -1,3 +1,139 @@\n+2009-08-06  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tMerge ARM/hard_vfp_branch to trunk.\n+\n+\t2009-08-04  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (libcall_eq): New function.\n+\t(libcall_hash): New function.\n+\t(add_libcall): New function.\n+\t(arm_libcall_uses_aapcs_base): New function.\n+\t(arm_libcall_value): Use arm_libcall_uses_aapcs_base to check for\n+\tlibcalls using the base PCS.\n+\t(arm_init_cumulative_args): Likewise.\n+\n+\t2009-07-20  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_libcall_value, arm_init_cumulative_args):\n+\tUse base ABI for conversion libfuncs between HFmode and SFmode.\n+\n+\t2009-05-12  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/arm/arm.c (aapcs_vfp_sub_candidate): Use V2SImode and\n+\tV4SImode as representatives of all 64-bit and 128-bit vector\n+\ttypes.  Allow vector types without vector modes.\n+\t(aapcs_vfp_is_call_or_return_candidate): Handle vector types\n+\twithout vector modes like BLKmode.\n+\t(aapcs_vfp_allocate): Handle TImode for non-TARGET_NEON like\n+\tBLKmode.  Avoid unsupported vector modes or TImode moves for\n+\tnon-TARGET_NEON.\n+\t(aapcs_vfp_allocate_return_reg): Likewise.\n+\t(arm_vector_mode_supported_p): Only support V2SImode, V4HImode and\n+\tV8QImode if TARGET_NEON || TARGET_IWMMXT.\n+\n+\t2009-05-12  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_handle_pcs_attribute): New.\n+\t(arm_get_pcs_model): Pass attribute arguments to\n+\tarm_pcs_from_attribute.\n+\t(arm_init_cumulative_args): Use base AAPCS for conversions from\n+\tfloating-point types to DImode.\n+\t(arm_attribute_table): Add pcs attribute.\n+\t(arm_handle_pcs_attribute): New.\n+\t* config/arm/bpabi.h (DECLARE_LIBRARY_RENAMES): When renaming\n+\tconversions from floating-point types to DImode, also declare them\n+\tto use base AAPCS and declare functions they call to use base\n+\tAAPCS and their RTABI names.\n+\n+\t2009-05-12  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* doc/invoke.texi (-mfloat-abi=@var{name}): Remove statement about\n+\t-mfloat-abi=hard not being supported for VFP.\n+\n+\t2009-05-11  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/sparc/sparc.c (sparc_emit_float_lib_cmp): Pass a libcall\n+\tSYMBOL_REF to hard_libcall_value.\n+\n+\t2009-03-05  Joseph Myers  <joseph@codesourcery.com>\n+\t    Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (aapcs_layout_arg): Once a co-processor argument\n+\thas been put on the stack, all remaining co-processory arguments for\n+\tthat co-processor also go on the stack.\n+\n+\t2009-03-05  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_return_in_memory): Handle returning\n+\tvectors of suitable size in registers also for AAPCS case.\n+\n+\t2009-01-13  Richard Earnshaw <rearnsha@arm.com>\n+\n+\t* doc/tm.texi (TARGET_LIBCALL_VALUE): Add missing end statement.\n+\n+\t2008-12-09  Richard Earnshaw <rearnsha@arm.com>\n+\n+\tARM Hard-VFP calling convention\n+\t* target-def.h (TARGET_LIBCALL_VALUE): New hook.\n+\t* target.h (gcc_target): Add libcall_value to table of call hooks.\n+\t* targhooks.h (default_libcall_value): Default implementation.\n+\t* targhooks.c (default_libcall_value): Likewise.\n+\t* doc/tm.texi (TARGET_LIBCALL_VALUE): Document it.\n+\t* optabs.c (expand_unop): Use it.\n+\t* expr.h (hard_libcall_value): Pass the function RTX through.\n+\t* calls.c (emit_library_call_value_1): Update call to \n+\thard_libcall_value.\n+\t* explow.c (hard_libcall_value): Use new target hook.\n+\t* testsuite/lib/target-supports.exp\n+\t(check_effective_target_arm_hard_vfp_ok): New hook.\n+\t(check_effective_target_arm_neon_ok): Improve test for neon\n+\tavailability.\n+\t* testsuite/gcc.target/arm/eabi1.c: Only run test in base variant.\n+\t* config/arm/arm.c: Include cgraph.h\n+\t(TARGET_FUNCTION_VALUE): Override default hook.\n+\t(arm_pcs_default): New variable.\n+\t(arm_override_options): Don't fault hard calling convention with VFP.\n+\tAdd support for AAPCS variants.\n+\t(arm_function_value): Make static.  Handle AAPCS variants.\n+\t(arm_libcall_value): New function.\n+\t(arm_apply_result_size): Handle VFP registers in results.\n+\t(arm_return_in_memory): Rework all AAPCS variants; handle hard-vfp\n+\tconventions.\n+\t(pcs_attribute_args): New variable.\n+\t(arm_pcs_from_attribute): New function.\n+\t(arm_get_pcs_model): New function.\n+\t(aapcs_vfp_cum_init): New function.\n+\t(aapcs_vfp_sub_candidate): New function.\n+\t(aapcs_vfp_is_return_candidate): New function.\n+\t(aapcs_vfp_is_call_candidate): New function.\n+\t(aapcs_vfp_allocate): New function.\n+\t(aapcs_vfp_allocate_return_reg): New function.\n+\t(aapcs_vfp_advance): New function.\n+\t(aapcs_cp_arg_layout): New variable.\n+\t(aapcs_select_call_coproc): New function.\n+\t(aapcs_select_return_coproc): New function.\n+\t(aapcs_allocate_return_reg): New function.\n+\t(aapcs_libcall_value): New function.\n+\t(aapcs_layout_arg): New function.\n+\t(arm_init_cumulative_args): Initialize AAPCS args data.\n+\t(arm_function_arg): Handle AAPCS variants using new interface.\n+\t(arm_arg_parital_bytes): Likewise.\n+\t(arm_function_arg_advance): New function.\n+\t(arm_function_ok_for_sibcall): Ensure that sibling calls agree on\n+\tcalling conventions.\n+\t(arm_setup_incoming_varargs): Handle new AAPCS args data.\n+\t* arm.h (NUM_VFP_ARG_REGS): Define.\n+\t(LIBCALL_VALUE): Update.\n+\t(FUNCTION_VALUE): Delete.\n+\t(FUNCTION_VALUE_REGNO_P): Add VFP regs.\n+\t(arm_pcs): New enum.\n+\t(CUMULATIVE_ARGS): New data to support AAPCS argument marshalling.\n+\t(FUNCTION_ARG_ADVANCE): Call arm_function_arg_advance.\n+\t(FUNCTION_ARG_REGNO_P): Add VFP regs.\n+\t* arm-protos.h (arm_function_arg_advance): Add.\n+\t(aapcs_libcall_value): Add.\n+\t(arm_function_value): Delete.\n+\n 2009-08-06  Uros Bizjak  <ubizjak@gmail.com>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "7ad5b099db1f26680e73aafdbf357227236bad25", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -3805,7 +3805,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n      cse'ing of library calls could delete a call and leave the pop.  */\n   NO_DEFER_POP;\n   valreg = (mem_value == 0 && outmode != VOIDmode\n-\t    ? hard_libcall_value (outmode) : NULL_RTX);\n+\t    ? hard_libcall_value (outmode, orgfun) : NULL_RTX);\n \n   /* Stack must be properly aligned now.  */\n   gcc_assert (!(stack_pointer_delta"}, {"sha": "ed70926e9a28972008fd6f44e9bdb8143ce078dd", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -151,13 +151,15 @@ extern bool arm_output_addr_const_extra (FILE *, rtx);\n \n #if defined TREE_CODE\n extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern void arm_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t      tree, bool);\n extern void arm_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern bool arm_pad_arg_upward (enum machine_mode, const_tree);\n extern bool arm_pad_reg_upward (enum machine_mode, tree, int);\n extern bool arm_needs_doubleword_align (enum machine_mode, tree);\n-extern rtx arm_function_value(const_tree, const_tree);\n #endif\n extern int arm_apply_result_size (void);\n+extern rtx aapcs_libcall_value (enum machine_mode);\n \n #endif /* RTX_CODE */\n "}, {"sha": "1af75f19dd922557a79a563938d34b324e63916f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1021, "deletions": 44, "changes": 1065, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -43,6 +43,7 @@\n #include \"optabs.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n+#include \"cgraph.h\"\n #include \"ggc.h\"\n #include \"except.h\"\n #include \"c-pragma.h\"\n@@ -112,6 +113,7 @@ static unsigned long arm_compute_save_reg_mask (void);\n static unsigned long arm_isr_value (tree);\n static unsigned long arm_compute_func_type (void);\n static tree arm_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n+static tree arm_handle_pcs_attribute (tree *, tree, tree, int, bool *);\n static tree arm_handle_isr_attribute (tree *, tree, tree, int, bool *);\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n static tree arm_handle_notshared_attribute (tree *, tree, tree, int, bool *);\n@@ -125,8 +127,13 @@ static int arm_adjust_cost (rtx, rtx, rtx, int);\n static int count_insns_for_constant (HOST_WIDE_INT, int);\n static int arm_get_strip_length (int);\n static bool arm_function_ok_for_sibcall (tree, tree);\n-static enum machine_mode arm_promote_function_mode (const_tree, enum machine_mode,\n-\t\t\t\t\t\t    int *, const_tree, int);\n+static enum machine_mode arm_promote_function_mode (const_tree,\n+\t\t\t\t\t\t    enum machine_mode, int *,\n+\t\t\t\t\t\t    const_tree, int);\n+static bool arm_return_in_memory (const_tree, const_tree);\n+static rtx arm_function_value (const_tree, const_tree, bool);\n+static rtx arm_libcall_value (enum machine_mode, rtx);\n+\n static void arm_internal_label (FILE *, const char *, unsigned long);\n static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t tree);\n@@ -152,6 +159,9 @@ static void emit_constant_insn (rtx cond, rtx pattern);\n static rtx emit_set_insn (rtx, rtx);\n static int arm_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, bool);\n+static rtx aapcs_allocate_return_reg (enum machine_mode, const_tree,\n+\t\t\t\t      const_tree);\n+static int aapcs_select_return_coproc (const_tree, const_tree);\n \n #ifdef OBJECT_FORMAT_ELF\n static void arm_elf_asm_constructor (rtx, int) ATTRIBUTE_UNUSED;\n@@ -220,6 +230,8 @@ static const struct attribute_spec arm_attribute_table[] =\n   /* Whereas these functions are always known to reside within the 26 bit\n      addressing range.  */\n   { \"short_call\",   0, 0, false, true,  true,  NULL },\n+  /* Specify the procedure call conventions for a function.  */\n+  { \"pcs\",          1, 1, false, true,  true,  arm_handle_pcs_attribute },\n   /* Interrupt Service Routines have special prologue and epilogue requirements.  */\n   { \"isr\",          0, 1, false, false, false, arm_handle_isr_attribute },\n   { \"interrupt\",    0, 1, false, false, false, arm_handle_isr_attribute },\n@@ -305,6 +317,12 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef  TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL arm_function_ok_for_sibcall\n \n+#undef  TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE arm_function_value\n+\n+#undef  TARGET_LIBCALL_VALUE\n+#define TARGET_LIBCALL_VALUE arm_libcall_value\n+\n #undef  TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK arm_output_mi_thunk\n #undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n@@ -656,6 +674,8 @@ static int after_arm_reorg = 0;\n /* The maximum number of insns to be used when loading a constant.  */\n static int arm_constant_limit = 3;\n \n+static enum arm_pcs arm_pcs_default;\n+\n /* For an explanation of these variables, see final_prescan_insn below.  */\n int arm_ccfsm_state;\n /* arm_current_cc is also used for Thumb-2 cond_exec blocks.  */\n@@ -1644,9 +1664,6 @@ arm_override_options (void)\n   else\n     arm_float_abi = TARGET_DEFAULT_FLOAT_ABI;\n \n-  if (arm_float_abi == ARM_FLOAT_ABI_HARD && TARGET_VFP)\n-    sorry (\"-mfloat-abi=hard and VFP\");\n-\n   if (TARGET_AAPCS_BASED\n       && (arm_fp_model == ARM_FP_MODEL_FPA))\n     error (\"FPA is unsupported in the AAPCS\");\n@@ -1678,6 +1695,28 @@ arm_override_options (void)\n   if (TARGET_SOFT_FLOAT)\n     arm_fpu_arch = FPUTYPE_NONE;\n \n+  if (TARGET_AAPCS_BASED)\n+    {\n+      if (arm_abi == ARM_ABI_IWMMXT)\n+\tarm_pcs_default = ARM_PCS_AAPCS_IWMMXT;\n+      else if (arm_float_abi == ARM_FLOAT_ABI_HARD\n+\t       && TARGET_HARD_FLOAT\n+\t       && TARGET_VFP)\n+\tarm_pcs_default = ARM_PCS_AAPCS_VFP;\n+      else\n+\tarm_pcs_default = ARM_PCS_AAPCS;\n+    }\n+  else\n+    {\n+      if (arm_float_abi == ARM_FLOAT_ABI_HARD && TARGET_VFP)\n+\tsorry (\"-mfloat-abi=hard and VFP\");\n+\n+      if (arm_abi == ARM_ABI_APCS)\n+\tarm_pcs_default = ARM_PCS_APCS;\n+      else\n+\tarm_pcs_default = ARM_PCS_ATPCS;\n+    }\n+\n   /* For arm2/3 there is no need to do any scheduling if there is only\n      a floating point emulator, or we are doing software floating-point.  */\n   if ((TARGET_SOFT_FLOAT\n@@ -3071,14 +3110,19 @@ arm_canonicalize_comparison (enum rtx_code code, enum machine_mode mode,\n \n /* Define how to find the value returned by a function.  */\n \n-rtx\n-arm_function_value(const_tree type, const_tree func)\n+static rtx\n+arm_function_value(const_tree type, const_tree func,\n+\t\t   bool outgoing ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode;\n   int unsignedp ATTRIBUTE_UNUSED;\n   rtx r ATTRIBUTE_UNUSED;\n \n   mode = TYPE_MODE (type);\n+\n+  if (TARGET_AAPCS_BASED)\n+    return aapcs_allocate_return_reg (mode, type, func);\n+\n   /* Promote integer types.  */\n   if (INTEGRAL_TYPE_P (type))\n     mode = arm_promote_function_mode (type, mode, &unsignedp, func, 1);\n@@ -3095,7 +3139,88 @@ arm_function_value(const_tree type, const_tree func)\n \t}\n     }\n \n-  return LIBCALL_VALUE(mode);\n+  return LIBCALL_VALUE (mode);\n+}\n+\n+static int\n+libcall_eq (const void *p1, const void *p2)\n+{\n+  return rtx_equal_p ((const_rtx) p1, (const_rtx) p2);\n+}\n+\n+static hashval_t\n+libcall_hash (const void *p1)\n+{\n+  return hash_rtx ((const_rtx) p1, VOIDmode, NULL, NULL, FALSE);\n+}\n+\n+static void\n+add_libcall (htab_t htab, rtx libcall)\n+{\n+  *htab_find_slot (htab, libcall, INSERT) = libcall;\n+}\n+\n+static bool\n+arm_libcall_uses_aapcs_base (rtx libcall)\n+{\n+  static bool init_done = false;\n+  static htab_t libcall_htab;\n+\n+  if (!init_done)\n+    {\n+      init_done = true;\n+\n+      libcall_htab = htab_create (31, libcall_hash, libcall_eq,\n+\t\t\t\t  NULL);\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (sfloat_optab, SFmode, SImode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (sfloat_optab, DFmode, SImode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (sfloat_optab, SFmode, DImode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (sfloat_optab, DFmode, DImode));\n+      \n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (ufloat_optab, SFmode, SImode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (ufloat_optab, DFmode, SImode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (ufloat_optab, SFmode, DImode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (ufloat_optab, DFmode, DImode));\n+\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (sext_optab, SFmode, HFmode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (trunc_optab, HFmode, SFmode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (sfix_optab, DImode, DFmode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (ufix_optab, DImode, DFmode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (sfix_optab, DImode, SFmode));\n+      add_libcall (libcall_htab,\n+\t\t   convert_optab_libfunc (ufix_optab, DImode, SFmode));\n+    }\n+\n+  return libcall && htab_find (libcall_htab, libcall) != NULL;\n+}\n+\n+rtx\n+arm_libcall_value (enum machine_mode mode, rtx libcall)\n+{\n+  if (TARGET_AAPCS_BASED && arm_pcs_default != ARM_PCS_AAPCS\n+      && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    {\n+      /* The following libcalls return their result in integer registers,\n+\t even though they return a floating point value.  */\n+      if (arm_libcall_uses_aapcs_base (libcall))\n+\treturn gen_rtx_REG (mode, ARG_REGISTER(1));\n+\n+    }\n+\n+  return LIBCALL_VALUE (mode);\n }\n \n /* Determine the amount of memory needed to store the possible return\n@@ -3105,10 +3230,12 @@ arm_apply_result_size (void)\n {\n   int size = 16;\n \n-  if (TARGET_ARM)\n+  if (TARGET_32BIT)\n     {\n       if (TARGET_HARD_FLOAT_ABI)\n \t{\n+\t  if (TARGET_VFP)\n+\t    size += 32;\n \t  if (TARGET_FPA)\n \t    size += 12;\n \t  if (TARGET_MAVERICK)\n@@ -3121,27 +3248,56 @@ arm_apply_result_size (void)\n   return size;\n }\n \n-/* Decide whether a type should be returned in memory (true)\n-   or in a register (false).  This is called as the target hook\n-   TARGET_RETURN_IN_MEMORY.  */\n+/* Decide whether TYPE should be returned in memory (true)\n+   or in a register (false).  FNTYPE is the type of the function making\n+   the call.  */\n static bool\n-arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n+arm_return_in_memory (const_tree type, const_tree fntype)\n {\n   HOST_WIDE_INT size;\n \n-  size = int_size_in_bytes (type);\n+  size = int_size_in_bytes (type);  /* Negative if not fixed size.  */\n+\n+  if (TARGET_AAPCS_BASED)\n+    {\n+      /* Simple, non-aggregate types (ie not including vectors and\n+\t complex) are always returned in a register (or registers).\n+\t We don't care about which register here, so we can short-cut\n+\t some of the detail.  */\n+      if (!AGGREGATE_TYPE_P (type)\n+\t  && TREE_CODE (type) != VECTOR_TYPE\n+\t  && TREE_CODE (type) != COMPLEX_TYPE)\n+\treturn false;\n+\n+      /* Any return value that is no larger than one word can be\n+\t returned in r0.  */\n+      if (((unsigned HOST_WIDE_INT) size) <= UNITS_PER_WORD)\n+\treturn false;\n+\n+      /* Check any available co-processors to see if they accept the\n+\t type as a register candidate (VFP, for example, can return\n+\t some aggregates in consecutive registers).  These aren't\n+\t available if the call is variadic.  */\n+      if (aapcs_select_return_coproc (type, fntype) >= 0)\n+\treturn false;\n+\n+      /* Vector values should be returned using ARM registers, not\n+\t memory (unless they're over 16 bytes, which will break since\n+\t we only have four call-clobbered registers to play with).  */\n+      if (TREE_CODE (type) == VECTOR_TYPE)\n+\treturn (size < 0 || size > (4 * UNITS_PER_WORD));\n+\n+      /* The rest go in memory.  */\n+      return true;\n+    }\n \n-  /* Vector values should be returned using ARM registers, not memory (unless\n-     they're over 16 bytes, which will break since we only have four\n-     call-clobbered registers to play with).  */\n   if (TREE_CODE (type) == VECTOR_TYPE)\n     return (size < 0 || size > (4 * UNITS_PER_WORD));\n \n   if (!AGGREGATE_TYPE_P (type) &&\n-      !(TARGET_AAPCS_BASED && TREE_CODE (type) == COMPLEX_TYPE))\n-    /* All simple types are returned in registers.\n-       For AAPCS, complex types are treated the same as aggregates.  */\n-    return 0;\n+      (TREE_CODE (type) != VECTOR_TYPE))\n+    /* All simple types are returned in registers.  */\n+    return false;\n \n   if (arm_abi != ARM_ABI_APCS)\n     {\n@@ -3158,7 +3314,7 @@ arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n      the aggregate is either huge or of variable size, and in either case\n      we will want to return it via memory and not in a register.  */\n   if (size < 0 || size > UNITS_PER_WORD)\n-    return 1;\n+    return true;\n \n   if (TREE_CODE (type) == RECORD_TYPE)\n     {\n@@ -3178,18 +3334,18 @@ arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \tcontinue;\n \n       if (field == NULL)\n-\treturn 0; /* An empty structure.  Allowed by an extension to ANSI C.  */\n+\treturn false; /* An empty structure.  Allowed by an extension to ANSI C.  */\n \n       /* Check that the first field is valid for returning in a register.  */\n \n       /* ... Floats are not allowed */\n       if (FLOAT_TYPE_P (TREE_TYPE (field)))\n-\treturn 1;\n+\treturn true;\n \n       /* ... Aggregates that are not themselves valid for returning in\n \t a register are not allowed.  */\n       if (arm_return_in_memory (TREE_TYPE (field), NULL_TREE))\n-\treturn 1;\n+\treturn true;\n \n       /* Now check the remaining fields, if any.  Only bitfields are allowed,\n \t since they are not addressable.  */\n@@ -3201,10 +3357,10 @@ arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \t    continue;\n \n \t  if (!DECL_BIT_FIELD_TYPE (field))\n-\t    return 1;\n+\t    return true;\n \t}\n \n-      return 0;\n+      return false;\n     }\n \n   if (TREE_CODE (type) == UNION_TYPE)\n@@ -3221,18 +3377,18 @@ arm_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \t    continue;\n \n \t  if (FLOAT_TYPE_P (TREE_TYPE (field)))\n-\t    return 1;\n+\t    return true;\n \n \t  if (arm_return_in_memory (TREE_TYPE (field), NULL_TREE))\n-\t    return 1;\n+\t    return true;\n \t}\n \n-      return 0;\n+      return false;\n     }\n #endif /* not ARM_WINCE */\n \n   /* Return all other types in memory.  */\n-  return 1;\n+  return true;\n }\n \n /* Indicate whether or not words of a double are in big-endian order.  */\n@@ -3257,14 +3413,749 @@ arm_float_words_big_endian (void)\n   return 1;\n }\n \n+const struct pcs_attribute_arg\n+{\n+  const char *arg;\n+  enum arm_pcs value;\n+} pcs_attribute_args[] =\n+  {\n+    {\"aapcs\", ARM_PCS_AAPCS},\n+    {\"aapcs-vfp\", ARM_PCS_AAPCS_VFP},\n+    {\"aapcs-iwmmxt\", ARM_PCS_AAPCS_IWMMXT},\n+    {\"atpcs\", ARM_PCS_ATPCS},\n+    {\"apcs\", ARM_PCS_APCS},\n+    {NULL, ARM_PCS_UNKNOWN}\n+  };\n+\n+static enum arm_pcs\n+arm_pcs_from_attribute (tree attr)\n+{\n+  const struct pcs_attribute_arg *ptr;\n+  const char *arg;\n+\n+  /* Get the value of the argument.  */\n+  if (TREE_VALUE (attr) == NULL_TREE\n+      || TREE_CODE (TREE_VALUE (attr)) != STRING_CST)\n+    return ARM_PCS_UNKNOWN;\n+\n+  arg = TREE_STRING_POINTER (TREE_VALUE (attr));\n+\n+  /* Check it against the list of known arguments.  */\n+  for (ptr = pcs_attribute_args; ptr->arg != NULL; ptr++)\n+    if (streq (arg, ptr->arg))\n+      return ptr->value;\n+\n+  /* An unrecognized interrupt type.  */\n+  return ARM_PCS_UNKNOWN;\n+}\n+\n+/* Get the PCS variant to use for this call.  TYPE is the function's type\n+   specification, DECL is the specific declartion.  DECL may be null if\n+   the call could be indirect or if this is a library call.  */\n+static enum arm_pcs\n+arm_get_pcs_model (const_tree type, const_tree decl)\n+{\n+  bool user_convention = false;\n+  enum arm_pcs user_pcs = arm_pcs_default;\n+  tree attr;\n+\n+  gcc_assert (type);\n+\n+  attr = lookup_attribute (\"pcs\", TYPE_ATTRIBUTES (type));\n+  if (attr)\n+    {\n+      user_pcs = arm_pcs_from_attribute (TREE_VALUE (attr));\n+      user_convention = true;\n+    }\n+\n+  if (TARGET_AAPCS_BASED)\n+    {\n+      /* Detect varargs functions.  These always use the base rules\n+\t (no argument is ever a candidate for a co-processor\n+\t register).  */\n+      bool base_rules = (TYPE_ARG_TYPES (type) != 0\n+\t\t\t && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (type)))\n+\t\t\t     != void_type_node));\n+      \n+      if (user_convention)\n+\t{\n+\t  if (user_pcs > ARM_PCS_AAPCS_LOCAL)\n+\t    sorry (\"Non-AAPCS derived PCS variant\");\n+\t  else if (base_rules && user_pcs != ARM_PCS_AAPCS)\n+\t    error (\"Variadic functions must use the base AAPCS variant\");\n+\t}\n+\n+      if (base_rules)\n+\treturn ARM_PCS_AAPCS;\n+      else if (user_convention)\n+\treturn user_pcs;\n+      else if (decl && flag_unit_at_a_time)\n+\t{\n+\t  /* Local functions never leak outside this compilation unit,\n+\t     so we are free to use whatever conventions are\n+\t     appropriate.  */\n+\t  /* FIXME: remove CONST_CAST_TREE when cgraph is constified.  */\n+\t  struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));\n+\t  if (i && i->local)\n+\t    return ARM_PCS_AAPCS_LOCAL;\n+\t}\n+    }\n+  else if (user_convention && user_pcs != arm_pcs_default)\n+    sorry (\"PCS variant\");\n+\n+  /* For everything else we use the target's default.  */\n+  return arm_pcs_default;\n+}\n+\n+\n+static void\n+aapcs_vfp_cum_init (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,\n+\t\t    const_tree fntype ATTRIBUTE_UNUSED,\n+\t\t    rtx libcall ATTRIBUTE_UNUSED, \n+\t\t    const_tree fndecl ATTRIBUTE_UNUSED)\n+{\n+  /* Record the unallocated VFP registers.  */\n+  pcum->aapcs_vfp_regs_free = (1 << NUM_VFP_ARG_REGS) - 1;\n+  pcum->aapcs_vfp_reg_alloc = 0;\n+}\n+\n+/* Walk down the type tree of TYPE counting consecutive base elements.\n+   If *MODEP is VOIDmode, then set it to the first valid floating point\n+   type.  If a non-floating point type is found, or if a floating point\n+   type that doesn't match a non-VOIDmode *MODEP is found, then return -1,\n+   otherwise return the count in the sub-tree.  */\n+static int\n+aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n+{\n+  enum machine_mode mode;\n+  HOST_WIDE_INT size;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case REAL_TYPE:\n+      mode = TYPE_MODE (type);\n+      if (mode != DFmode && mode != SFmode)\n+\treturn -1;\n+\n+      if (*modep == VOIDmode)\n+\t*modep = mode;\n+\n+      if (*modep == mode)\n+\treturn 1;\n+\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      mode = TYPE_MODE (TREE_TYPE (type));\n+      if (mode != DFmode && mode != SFmode)\n+\treturn -1;\n+\n+      if (*modep == VOIDmode)\n+\t*modep = mode;\n+\n+      if (*modep == mode)\n+\treturn 2;\n+\n+      break;\n+\n+    case VECTOR_TYPE:\n+      /* Use V2SImode and V4SImode as representatives of all 64-bit\n+\t and 128-bit vector types, whether or not those modes are\n+\t supported with the present options.  */\n+      size = int_size_in_bytes (type);\n+      switch (size)\n+\t{\n+\tcase 8:\n+\t  mode = V2SImode;\n+\t  break;\n+\tcase 16:\n+\t  mode = V4SImode;\n+\t  break;\n+\tdefault:\n+\t  return -1;\n+\t}\n+\n+      if (*modep == VOIDmode)\n+\t*modep = mode;\n+\n+      /* Vector modes are considered to be opaque: two vectors are\n+\t equivalent for the purposes of being homogeneous aggregates\n+\t if they are the same size.  */\n+      if (*modep == mode)\n+\treturn 1;\n+\n+      break;\n+\n+    case ARRAY_TYPE:\n+      {\n+\tint count;\n+\ttree index = TYPE_DOMAIN (type);\n+\n+\t/* Can't handle incomplete types.  */\n+\tif (!COMPLETE_TYPE_P(type))\n+\t  return -1;\n+\n+\tcount = aapcs_vfp_sub_candidate (TREE_TYPE (type), modep);\n+\tif (count == -1\n+\t    || !index\n+\t    || !TYPE_MAX_VALUE (index)\n+\t    || !host_integerp (TYPE_MAX_VALUE (index), 1)\n+\t    || !TYPE_MIN_VALUE (index)\n+\t    || !host_integerp (TYPE_MIN_VALUE (index), 1)\n+\t    || count < 0)\n+\t  return -1;\n+\n+\tcount *= (1 + tree_low_cst (TYPE_MAX_VALUE (index), 1)\n+\t\t      - tree_low_cst (TYPE_MIN_VALUE (index), 1));\n+\n+\t/* There must be no padding.  */\n+\tif (!host_integerp (TYPE_SIZE (type), 1)\n+\t    || (tree_low_cst (TYPE_SIZE (type), 1)\n+\t\t!= count * GET_MODE_BITSIZE (*modep)))\n+\t  return -1;\n+\n+\treturn count;\n+      }\n+      \n+    case RECORD_TYPE:\n+      {\n+\tint count = 0;\n+\tint sub_count;\n+\ttree field;\n+\n+\t/* Can't handle incomplete types.  */\n+\tif (!COMPLETE_TYPE_P(type))\n+\t  return -1;\n+\n+\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  {\n+\t    if (TREE_CODE (field) != FIELD_DECL)\n+\t      continue;\n+\n+\t    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep);\n+\t    if (sub_count < 0)\n+\t      return -1;\n+\t    count += sub_count;\n+\t  }\n+\n+\t/* There must be no padding.  */\n+\tif (!host_integerp (TYPE_SIZE (type), 1)\n+\t    || (tree_low_cst (TYPE_SIZE (type), 1)\n+\t\t!= count * GET_MODE_BITSIZE (*modep)))\n+\t  return -1;\n+\n+\treturn count;\n+      }\n+\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\t/* These aren't very interesting except in a degenerate case.  */\n+\tint count = 0;\n+\tint sub_count;\n+\ttree field;\n+\n+\t/* Can't handle incomplete types.  */\n+\tif (!COMPLETE_TYPE_P(type))\n+\t  return -1;\n+\n+\tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t  {\n+\t    if (TREE_CODE (field) != FIELD_DECL)\n+\t      continue;\n+\n+\t    sub_count = aapcs_vfp_sub_candidate (TREE_TYPE (field), modep);\n+\t    if (sub_count < 0)\n+\t      return -1;\n+\t    count = count > sub_count ? count : sub_count;\n+\t  }\n+\n+\t/* There must be no padding.  */\n+\tif (!host_integerp (TYPE_SIZE (type), 1)\n+\t    || (tree_low_cst (TYPE_SIZE (type), 1)\n+\t\t!= count * GET_MODE_BITSIZE (*modep)))\n+\t  return -1;\n+\n+\treturn count;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  return -1;\n+}\n+\n+static bool\n+aapcs_vfp_is_call_or_return_candidate (enum machine_mode mode, const_tree type,\n+\t\t\t\t       int *base_mode,\n+\t\t\t\t       int *count)\n+{\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      || GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+      || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+    {\n+      *count = 1;\n+      *base_mode = mode;\n+      return true;\n+    }\n+  else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+    {\n+      *count = 2;\n+      *base_mode = (mode == DCmode ? DFmode : SFmode);\n+      return true;\n+    }\n+  else if (type && (mode == BLKmode || TREE_CODE (type) == VECTOR_TYPE))\n+    {\n+      enum machine_mode aggregate_mode = VOIDmode;\n+      int ag_count = aapcs_vfp_sub_candidate (type, &aggregate_mode);\n+\n+      if (ag_count > 0 && ag_count <= 4)\n+\t{\n+\t  *count = ag_count;\n+\t  *base_mode = aggregate_mode;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+static bool\n+aapcs_vfp_is_return_candidate (enum arm_pcs pcs_variant,\n+\t\t\t       enum machine_mode mode, const_tree type)\n+{\n+  int count ATTRIBUTE_UNUSED;\n+  int ag_mode ATTRIBUTE_UNUSED;\n+\n+  if (!(pcs_variant == ARM_PCS_AAPCS_VFP\n+\t|| (pcs_variant == ARM_PCS_AAPCS_LOCAL\n+\t    && TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT)))\n+    return false;\n+  return aapcs_vfp_is_call_or_return_candidate (mode, type, &ag_mode, &count);\n+}\n+\n+static bool\n+aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, enum machine_mode mode, \n+\t\t\t     const_tree type)\n+{\n+  if (!(pcum->pcs_variant == ARM_PCS_AAPCS_VFP\n+\t|| (pcum->pcs_variant == ARM_PCS_AAPCS_LOCAL\n+\t    && TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT)))\n+    return false;\n+  return aapcs_vfp_is_call_or_return_candidate (mode, type,\n+\t\t\t\t\t\t&pcum->aapcs_vfp_rmode,\n+\t\t\t\t\t\t&pcum->aapcs_vfp_rcount);\n+}\n+\n+static bool\n+aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+\t\t    const_tree type  ATTRIBUTE_UNUSED)\n+{\n+  int shift = GET_MODE_SIZE (pcum->aapcs_vfp_rmode) / GET_MODE_SIZE (SFmode);\n+  unsigned mask = (1 << (shift * pcum->aapcs_vfp_rcount)) - 1;\n+  int regno;\n+  \n+  for (regno = 0; regno < NUM_VFP_ARG_REGS; regno += shift)\n+    if (((pcum->aapcs_vfp_regs_free >> regno) & mask) == mask)\n+      {\n+\tpcum->aapcs_vfp_reg_alloc = mask << regno;\n+\tif (mode == BLKmode || (mode == TImode && !TARGET_NEON))\n+\t  {\n+\t    int i;\n+\t    int rcount = pcum->aapcs_vfp_rcount;\n+\t    int rshift = shift;\n+\t    enum machine_mode rmode = pcum->aapcs_vfp_rmode;\n+\t    rtx par;\n+\t    if (!TARGET_NEON)\n+\t      {\n+\t\t/* Avoid using unsupported vector modes.  */\n+\t\tif (rmode == V2SImode)\n+\t\t  rmode = DImode;\n+\t\telse if (rmode == V4SImode)\n+\t\t  {\n+\t\t    rmode = DImode;\n+\t\t    rcount *= 2;\n+\t\t    rshift /= 2;\n+\t\t  }\n+\t      }\n+\t    par = gen_rtx_PARALLEL (mode, rtvec_alloc (rcount));\n+\t    for (i = 0; i < rcount; i++)\n+\t      {\n+\t\trtx tmp = gen_rtx_REG (rmode, \n+\t\t\t\t       FIRST_VFP_REGNUM + regno + i * rshift);\n+\t\ttmp = gen_rtx_EXPR_LIST\n+\t\t  (VOIDmode, tmp, \n+\t\t   GEN_INT (i * GET_MODE_SIZE (rmode)));\n+\t\tXVECEXP (par, 0, i) = tmp;\n+\t      }\n+\n+\t    pcum->aapcs_reg = par;\n+\t  }\n+\telse\n+\t  pcum->aapcs_reg = gen_rtx_REG (mode, FIRST_VFP_REGNUM + regno);\n+\treturn true;\n+      }\n+  return false;\n+}\n+\n+static rtx\n+aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n+\t\t\t       enum machine_mode mode,\n+\t\t\t       const_tree type ATTRIBUTE_UNUSED)\n+{\n+  if (!(pcs_variant == ARM_PCS_AAPCS_VFP\n+\t|| (pcs_variant == ARM_PCS_AAPCS_LOCAL\n+\t    && TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT)))\n+    return false;\n+  if (mode == BLKmode || (mode == TImode && !TARGET_NEON))\n+    {\n+      int count;\n+      int ag_mode;\n+      int i;\n+      rtx par;\n+      int shift;\n+      \n+      aapcs_vfp_is_call_or_return_candidate (mode, type, &ag_mode, &count);\n+\n+      if (!TARGET_NEON)\n+\t{\n+\t  if (ag_mode == V2SImode)\n+\t    ag_mode = DImode;\n+\t  else if (ag_mode == V4SImode)\n+\t    {\n+\t      ag_mode = DImode;\n+\t      count *= 2;\n+\t    }\n+\t}\n+      shift = GET_MODE_SIZE(ag_mode) / GET_MODE_SIZE(SFmode);\n+      par = gen_rtx_PARALLEL (mode, rtvec_alloc (count));\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  rtx tmp = gen_rtx_REG (ag_mode, FIRST_VFP_REGNUM + i * shift);\n+\t  tmp = gen_rtx_EXPR_LIST (VOIDmode, tmp, \n+\t\t\t\t   GEN_INT (i * GET_MODE_SIZE (ag_mode)));\n+\t  XVECEXP (par, 0, i) = tmp;\n+\t}\n+\n+      return par;\n+    }\n+\n+  return gen_rtx_REG (mode, FIRST_VFP_REGNUM);\n+}\n+\n+static void\n+aapcs_vfp_advance (CUMULATIVE_ARGS *pcum  ATTRIBUTE_UNUSED,\n+\t\t   enum machine_mode mode  ATTRIBUTE_UNUSED,\n+\t\t   const_tree type  ATTRIBUTE_UNUSED)\n+{\n+  pcum->aapcs_vfp_regs_free &= ~pcum->aapcs_vfp_reg_alloc;\n+  pcum->aapcs_vfp_reg_alloc = 0;\n+  return;\n+}\n+\n+#define AAPCS_CP(X)\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    aapcs_ ## X ## _cum_init,\t\t\t\\\n+    aapcs_ ## X ## _is_call_candidate,\t\t\\\n+    aapcs_ ## X ## _allocate,\t\t\t\\\n+    aapcs_ ## X ## _is_return_candidate,\t\\\n+    aapcs_ ## X ## _allocate_return_reg,\t\\\n+    aapcs_ ## X ## _advance\t\t\t\\\n+  }\n+\n+/* Table of co-processors that can be used to pass arguments in\n+   registers.  Idealy no arugment should be a candidate for more than\n+   one co-processor table entry, but the table is processed in order\n+   and stops after the first match.  If that entry then fails to put\n+   the argument into a co-processor register, the argument will go on\n+   the stack.  */\n+static struct \n+{\n+  /* Initialize co-processor related state in CUMULATIVE_ARGS structure.  */\n+  void (*cum_init) (CUMULATIVE_ARGS *, const_tree, rtx, const_tree);\n+\n+  /* Return true if an argument of mode MODE (or type TYPE if MODE is\n+     BLKmode) is a candidate for this co-processor's registers; this\n+     function should ignore any position-dependent state in\n+     CUMULATIVE_ARGS and only use call-type dependent information.  */\n+  bool (*is_call_candidate) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);\n+\n+  /* Return true if the argument does get a co-processor register; it\n+     should set aapcs_reg to an RTX of the register allocated as is\n+     required for a return from FUNCTION_ARG.  */\n+  bool (*allocate) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);\n+\n+  /* Return true if a result of mode MODE (or type TYPE if MODE is\n+     BLKmode) is can be returned in this co-processor's registers.  */\n+  bool (*is_return_candidate) (enum arm_pcs, enum machine_mode, const_tree);\n+\n+  /* Allocate and return an RTX element to hold the return type of a\n+     call, this routine must not fail and will only be called if\n+     is_return_candidate returned true with the same parameters.  */\n+  rtx (*allocate_return_reg) (enum arm_pcs, enum machine_mode, const_tree);\n+\n+  /* Finish processing this argument and prepare to start processing\n+     the next one.  */\n+  void (*advance) (CUMULATIVE_ARGS *, enum machine_mode, const_tree);\n+} aapcs_cp_arg_layout[ARM_NUM_COPROC_SLOTS] =\n+  {\n+    AAPCS_CP(vfp)\n+  };\n+\n+#undef AAPCS_CP\n+\n+static int\n+aapcs_select_call_coproc (CUMULATIVE_ARGS *pcum, enum machine_mode mode, \n+\t\t\t  tree type)\n+{\n+  int i;\n+\n+  for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)\n+    if (aapcs_cp_arg_layout[i].is_call_candidate (pcum, mode, type))\n+      return i;\n+\n+  return -1;\n+}\n+\n+static int\n+aapcs_select_return_coproc (const_tree type, const_tree fntype)\n+{\n+  /* We aren't passed a decl, so we can't check that a call is local.\n+     However, it isn't clear that that would be a win anyway, since it\n+     might limit some tail-calling opportunities.  */\n+  enum arm_pcs pcs_variant;\n+\n+  if (fntype)\n+    {\n+      const_tree fndecl = NULL_TREE;\n+\n+      if (TREE_CODE (fntype) == FUNCTION_DECL)\n+\t{\n+\t  fndecl = fntype;\n+\t  fntype = TREE_TYPE (fntype);\n+\t}\n+\n+      pcs_variant = arm_get_pcs_model (fntype, fndecl);\n+    }\n+  else\n+    pcs_variant = arm_pcs_default;\n+\n+  if (pcs_variant != ARM_PCS_AAPCS)\n+    {\n+      int i;\n+\n+      for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)\n+\tif (aapcs_cp_arg_layout[i].is_return_candidate (pcs_variant, \n+\t\t\t\t\t\t\tTYPE_MODE (type),\n+\t\t\t\t\t\t\ttype))\n+\t  return i;\n+    }\n+  return -1;\n+}\n+\n+static rtx\n+aapcs_allocate_return_reg (enum machine_mode mode, const_tree type,\n+\t\t\t   const_tree fntype)\n+{\n+  /* We aren't passed a decl, so we can't check that a call is local.\n+     However, it isn't clear that that would be a win anyway, since it\n+     might limit some tail-calling opportunities.  */\n+  enum arm_pcs pcs_variant;\n+  int unsignedp ATTRIBUTE_UNUSED;\n+\n+  if (fntype)\n+    {\n+      const_tree fndecl = NULL_TREE;\n+\n+      if (TREE_CODE (fntype) == FUNCTION_DECL)\n+\t{\n+\t  fndecl = fntype;\n+\t  fntype = TREE_TYPE (fntype);\n+\t}\n+\n+      pcs_variant = arm_get_pcs_model (fntype, fndecl);\n+    }\n+  else\n+    pcs_variant = arm_pcs_default;\n+\n+  /* Promote integer types.  */\n+  if (type && INTEGRAL_TYPE_P (type))\n+    mode = arm_promote_function_mode (type, mode, &unsignedp, fntype, 1);\n+\n+  if (pcs_variant != ARM_PCS_AAPCS)\n+    {\n+      int i;\n+\n+      for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)\n+\tif (aapcs_cp_arg_layout[i].is_return_candidate (pcs_variant, mode,\n+\t\t\t\t\t\t\ttype))\n+\t  return aapcs_cp_arg_layout[i].allocate_return_reg (pcs_variant,\n+\t\t\t\t\t\t\t     mode, type);\n+    }\n+\n+  /* Promotes small structs returned in a register to full-word size\n+     for big-endian AAPCS.  */\n+  if (type && arm_return_in_msb (type))\n+    {\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      if (size % UNITS_PER_WORD != 0)\n+\t{\n+\t  size += UNITS_PER_WORD - size % UNITS_PER_WORD;\n+\t  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n+\t}\n+    }\n+\n+  return gen_rtx_REG (mode, R0_REGNUM);\n+}\n+\n+rtx\n+aapcs_libcall_value (enum machine_mode mode)\n+{\n+  return aapcs_allocate_return_reg (mode, NULL_TREE, NULL_TREE);\n+}\n+\n+/* Lay out a function argument using the AAPCS rules.  The rule\n+   numbers referred to here are those in the AAPCS.  */\n+static void\n+aapcs_layout_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+\t\t  tree type, int named)\n+{\n+  int nregs, nregs2;\n+  int ncrn;\n+\n+  /* We only need to do this once per argument.  */\n+  if (pcum->aapcs_arg_processed)\n+    return;\n+\n+  pcum->aapcs_arg_processed = true;\n+\n+  /* Special case: if named is false then we are handling an incoming\n+     anonymous argument which is on the stack.  */\n+  if (!named)\n+    return;\n+  \n+  /* Is this a potential co-processor register candidate?  */\n+  if (pcum->pcs_variant != ARM_PCS_AAPCS)\n+    {\n+      int slot = aapcs_select_call_coproc (pcum, mode, type);\n+      pcum->aapcs_cprc_slot = slot;\n+\n+      /* We don't have to apply any of the rules from part B of the\n+\t preparation phase, these are handled elsewhere in the\n+\t compiler.  */\n+\n+      if (slot >= 0)\n+\t{\n+\t  /* A Co-processor register candidate goes either in its own\n+\t     class of registers or on the stack.  */\n+\t  if (!pcum->aapcs_cprc_failed[slot])\n+\t    {\n+\t      /* C1.cp - Try to allocate the argument to co-processor\n+\t\t registers.  */\n+\t      if (aapcs_cp_arg_layout[slot].allocate (pcum, mode, type))\n+\t\treturn;\n+\n+\t      /* C2.cp - Put the argument on the stack and note that we\n+\t\t can't assign any more candidates in this slot.  We also\n+\t\t need to note that we have allocated stack space, so that\n+\t\t we won't later try to split a non-cprc candidate between\n+\t\t core registers and the stack.  */\n+\t      pcum->aapcs_cprc_failed[slot] = true;\n+\t      pcum->can_split = false;\n+\t    }\n+\n+\t  /* We didn't get a register, so this argument goes on the\n+\t     stack.  */\n+\t  gcc_assert (pcum->can_split == false);\n+\t  return;\n+\t}\n+    }\n+\n+  /* C3 - For double-word aligned arguments, round the NCRN up to the\n+     next even number.  */\n+  ncrn = pcum->aapcs_ncrn;\n+  if ((ncrn & 1) && arm_needs_doubleword_align (mode, type))\n+    ncrn++;\n+\n+  nregs = ARM_NUM_REGS2(mode, type);\n+\n+  /* Sigh, this test should really assert that nregs > 0, but a GCC\n+     extension allows empty structs and then gives them empty size; it\n+     then allows such a structure to be passed by value.  For some of\n+     the code below we have to pretend that such an argument has\n+     non-zero size so that we 'locate' it correctly either in\n+     registers or on the stack.  */\n+  gcc_assert (nregs >= 0);\n+\n+  nregs2 = nregs ? nregs : 1;\n+\n+  /* C4 - Argument fits entirely in core registers.  */\n+  if (ncrn + nregs2 <= NUM_ARG_REGS)\n+    {\n+      pcum->aapcs_reg = gen_rtx_REG (mode, ncrn);\n+      pcum->aapcs_next_ncrn = ncrn + nregs;\n+      return;\n+    }\n+\n+  /* C5 - Some core registers left and there are no arguments already\n+     on the stack: split this argument between the remaining core\n+     registers and the stack.  */\n+  if (ncrn < NUM_ARG_REGS && pcum->can_split)\n+    {\n+      pcum->aapcs_reg = gen_rtx_REG (mode, ncrn);\n+      pcum->aapcs_next_ncrn = NUM_ARG_REGS;\n+      pcum->aapcs_partial = (NUM_ARG_REGS - ncrn) * UNITS_PER_WORD;\n+      return;\n+    }\n+\n+  /* C6 - NCRN is set to 4.  */\n+  pcum->aapcs_next_ncrn = NUM_ARG_REGS;\n+\n+  /* C7,C8 - arugment goes on the stack.  We have nothing to do here.  */\n+  return;\n+}\n+\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is NULL.  */\n void\n arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n-\t\t\t  rtx libname  ATTRIBUTE_UNUSED,\n+\t\t\t  rtx libname,\n \t\t\t  tree fndecl ATTRIBUTE_UNUSED)\n {\n+  /* Long call handling.  */\n+  if (fntype)\n+    pcum->pcs_variant = arm_get_pcs_model (fntype, fndecl);\n+  else\n+    pcum->pcs_variant = arm_pcs_default;\n+\n+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n+    {\n+      if (arm_libcall_uses_aapcs_base (libname))\n+\tpcum->pcs_variant = ARM_PCS_AAPCS;\n+ \n+      pcum->aapcs_ncrn = pcum->aapcs_next_ncrn = 0;\n+      pcum->aapcs_reg = NULL_RTX;\n+      pcum->aapcs_partial = 0;\n+      pcum->aapcs_arg_processed = false;\n+      pcum->aapcs_cprc_slot = -1;\n+      pcum->can_split = true;\n+\n+      if (pcum->pcs_variant != ARM_PCS_AAPCS)\n+\t{\n+\t  int i;\n+\n+\t  for (i = 0; i < ARM_NUM_COPROC_SLOTS; i++)\n+\t    {\n+\t      pcum->aapcs_cprc_failed[i] = false;\n+\t      aapcs_cp_arg_layout[i].cum_init (pcum, fntype, libname, fndecl);\n+\t    }\n+\t}\n+      return;\n+    }\n+\n+  /* Legacy ABIs */\n+\n   /* On the ARM, the offset starts at 0.  */\n   pcum->nregs = 0;\n   pcum->iwmmxt_nregs = 0;\n@@ -3318,6 +4209,17 @@ arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n {\n   int nregs;\n \n+  /* Handle the special case quickly.  Pick an arbitrary value for op2 of\n+     a call insn (op3 of a call_value insn).  */\n+  if (mode == VOIDmode)\n+    return const0_rtx;\n+\n+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n+    {\n+      aapcs_layout_arg (pcum, mode, type, named);\n+      return pcum->aapcs_reg;\n+    }\n+\n   /* Varargs vectors are treated the same as long long.\n      named_count avoids having to change the way arm handles 'named' */\n   if (TARGET_IWMMXT_ABI\n@@ -3359,10 +4261,16 @@ arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n \n static int\n arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n-\t\t       tree type, bool named ATTRIBUTE_UNUSED)\n+\t\t       tree type, bool named)\n {\n   int nregs = pcum->nregs;\n \n+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n+    {\n+      aapcs_layout_arg (pcum, mode, type, named);\n+      return pcum->aapcs_partial;\n+    }\n+\n   if (TARGET_IWMMXT_ABI && arm_vector_mode_supported_p (mode))\n     return 0;\n \n@@ -3374,6 +4282,39 @@ arm_arg_partial_bytes (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n   return 0;\n }\n \n+void\n+arm_function_arg_advance (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n+\t\t\t  tree type, bool named)\n+{\n+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n+    {\n+      aapcs_layout_arg (pcum, mode, type, named);\n+\n+      if (pcum->aapcs_cprc_slot >= 0)\n+\t{\n+\t  aapcs_cp_arg_layout[pcum->aapcs_cprc_slot].advance (pcum, mode,\n+\t\t\t\t\t\t\t      type);\n+\t  pcum->aapcs_cprc_slot = -1;\n+\t}\n+\n+      /* Generic stuff.  */\n+      pcum->aapcs_arg_processed = false;\n+      pcum->aapcs_ncrn = pcum->aapcs_next_ncrn;\n+      pcum->aapcs_reg = NULL_RTX;\n+      pcum->aapcs_partial = 0;\n+    }\n+  else\n+    {\n+      pcum->nargs += 1;\n+      if (arm_vector_mode_supported_p (mode)\n+\t  && pcum->named_count > pcum->nargs\n+\t  && TARGET_IWMMXT_ABI)\n+\tpcum->iwmmxt_nregs += 1;\n+      else\n+\tpcum->nregs += ARM_NUM_REGS2 (mode, type);\n+    }\n+}\n+\n /* Variable sized types are passed by reference.  This is a GCC\n    extension to the ARM ABI.  */\n \n@@ -3490,6 +4431,21 @@ arm_handle_isr_attribute (tree *node, tree name, tree args, int flags,\n   return NULL_TREE;\n }\n \n+/* Handle a \"pcs\" attribute; arguments as in struct\n+   attribute_spec.handler.  */\n+static tree\n+arm_handle_pcs_attribute (tree *node ATTRIBUTE_UNUSED, tree name, tree args,\n+\t\t\t  int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n+{\n+  if (arm_pcs_from_attribute (args) == ARM_PCS_UNKNOWN)\n+    {\n+      warning (OPT_Wattributes, \"%qs attribute ignored\",\n+\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  return NULL_TREE;\n+}\n+\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n /* Handle the \"notshared\" attribute.  This attribute is another way of\n    requesting hidden visibility.  ARM's compiler supports\n@@ -3651,7 +4607,7 @@ arm_is_long_call_p (tree decl)\n \n /* Return nonzero if it is ok to make a tail-call to DECL.  */\n static bool\n-arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n+arm_function_ok_for_sibcall (tree decl, tree exp)\n {\n   unsigned long func_type;\n \n@@ -3684,6 +4640,21 @@ arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n   if (IS_INTERRUPT (func_type))\n     return false;\n \n+  if (!VOID_TYPE_P (TREE_TYPE (DECL_RESULT (cfun->decl))))\n+    {\n+      /* Check that the return value locations are the same.  For\n+\t example that we aren't returning a value from the sibling in\n+\t a VFP register but then need to transfer it to a core\n+\t register.  */\n+      rtx a, b;\n+\n+      a = arm_function_value (TREE_TYPE (exp), decl, false);\n+      b = arm_function_value (TREE_TYPE (DECL_RESULT (cfun->decl)),\n+\t\t\t      cfun->decl, false);\n+      if (!rtx_equal_p (a, b))\n+\treturn false;\n+    }\n+\n   /* Never tailcall if function may be called with a misaligned SP.  */\n   if (IS_STACKALIGN (func_type))\n     return false;\n@@ -18948,19 +19919,24 @@ arm_output_load_gr (rtx *operands)\n    that way.  */\n \n static void\n-arm_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n+arm_setup_incoming_varargs (CUMULATIVE_ARGS *pcum,\n \t\t\t    enum machine_mode mode,\n \t\t\t    tree type,\n \t\t\t    int *pretend_size,\n \t\t\t    int second_time ATTRIBUTE_UNUSED)\n {\n-  int nregs = cum->nregs;\n-  if (nregs & 1\n-      && ARM_DOUBLEWORD_ALIGN\n-      && arm_needs_doubleword_align (mode, type))\n-    nregs++;\n-\n+  int nregs;\n+  \n   cfun->machine->uses_anonymous_args = 1;\n+  if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n+    {\n+      nregs = pcum->aapcs_ncrn;\n+      if ((nregs & 1) && arm_needs_doubleword_align (mode, type))\n+\tnregs++;\n+    }\n+  else\n+    nregs = pcum->nregs;\n+  \n   if (nregs < NUM_ARG_REGS)\n     *pretend_size = (NUM_ARG_REGS - nregs) * UNITS_PER_WORD;\n }\n@@ -19357,9 +20333,10 @@ arm_vector_mode_supported_p (enum machine_mode mode)\n       || mode == V16QImode || mode == V4SFmode || mode == V2DImode))\n     return true;\n \n-  if ((mode == V2SImode)\n-      || (mode == V4HImode)\n-      || (mode == V8QImode))\n+  if ((TARGET_NEON || TARGET_IWMMXT)\n+      && ((mode == V2SImode)\n+\t  || (mode == V4HImode)\n+\t  || (mode == V8QImode)))\n     return true;\n \n   return false;"}, {"sha": "59d35dd6833fec9597f15a000b37aad9914fc1d9", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -893,6 +893,9 @@ extern int arm_structure_size_boundary;\n /* The number of (integer) argument register available.  */\n #define NUM_ARG_REGS\t\t4\n \n+/* And similarly for the VFP.  */\n+#define NUM_VFP_ARG_REGS\t16\n+\n /* Return the register number of the N'th (integer) argument.  */\n #define ARG_REGISTER(N) \t(N - 1)\n \n@@ -1502,9 +1505,10 @@ do {\t\t\t\t\t\t\t\t\t      \\\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE)  \\\n-  (TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_FPA\t\t\t\\\n-   && GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n+#define LIBCALL_VALUE(MODE)  \t\t\t\t\t\t\\\n+  (TARGET_AAPCS_BASED ? aapcs_libcall_value (MODE)\t\t\t\\\n+   : (TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_FPA\t\t\\\n+      && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\t\\\n    ? gen_rtx_REG (MODE, FIRST_FPA_REGNUM)\t\t\t\t\\\n    : TARGET_32BIT && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK\t\t\\\n      && GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n@@ -1513,22 +1517,16 @@ do {\t\t\t\t\t\t\t\t\t      \\\n    ? gen_rtx_REG (MODE, FIRST_IWMMXT_REGNUM) \t\t\t\t\\\n    : gen_rtx_REG (MODE, ARG_REGISTER (1)))\n \n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  arm_function_value (VALTYPE, FUNC);\n-\n-/* 1 if N is a possible register number for a function value.\n-   On the ARM, only r0 and f0 can return results.  */\n-/* On a Cirrus chip, mvf0 can return results.  */\n-#define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n-  ((REGNO) == ARG_REGISTER (1) \\\n-   || (TARGET_32BIT && ((REGNO) == FIRST_CIRRUS_FP_REGNUM)\t\t\\\n-       && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK)\t\t\t\\\n-   || ((REGNO) == FIRST_IWMMXT_REGNUM && TARGET_IWMMXT_ABI) \\\n-   || (TARGET_32BIT && ((REGNO) == FIRST_FPA_REGNUM)\t\t\t\\\n+/* 1 if REGNO is a possible register number for a function value.  */\n+#define FUNCTION_VALUE_REGNO_P(REGNO)\t\t\t\t\\\n+  ((REGNO) == ARG_REGISTER (1)\t\t\t\t\t\\\n+   || (TARGET_AAPCS_BASED && TARGET_32BIT \t\t\t\\\n+       && TARGET_VFP && TARGET_HARD_FLOAT\t\t\t\\\n+       && (REGNO) == FIRST_VFP_REGNUM)\t\t\t\t\\\n+   || (TARGET_32BIT && ((REGNO) == FIRST_CIRRUS_FP_REGNUM)\t\\\n+       && TARGET_HARD_FLOAT_ABI && TARGET_MAVERICK)\t\t\\\n+   || ((REGNO) == FIRST_IWMMXT_REGNUM && TARGET_IWMMXT_ABI)\t\\\n+   || (TARGET_32BIT && ((REGNO) == FIRST_FPA_REGNUM)\t\t\\\n        && TARGET_HARD_FLOAT_ABI && TARGET_FPA))\n \n /* Amount of memory needed for an untyped call to save all possible return\n@@ -1631,9 +1629,27 @@ machine_function;\n    that is in text_section.  */\n extern GTY(()) rtx thumb_call_via_label[14];\n \n+/* The number of potential ways of assigning to a co-processor.  */\n+#define ARM_NUM_COPROC_SLOTS 1\n+\n+/* Enumeration of procedure calling standard variants.  We don't really \n+   support all of these yet.  */\n+enum arm_pcs\n+{\n+  ARM_PCS_AAPCS,\t/* Base standard AAPCS.  */\n+  ARM_PCS_AAPCS_VFP,\t/* Use VFP registers for floating point values.  */\n+  ARM_PCS_AAPCS_IWMMXT, /* Use iWMMXT registers for vectors.  */\n+  /* This must be the last AAPCS variant.  */\n+  ARM_PCS_AAPCS_LOCAL,\t/* Private call within this compilation unit.  */\n+  ARM_PCS_ATPCS,\t/* ATPCS.  */\n+  ARM_PCS_APCS,\t\t/* APCS (legacy Linux etc).  */\n+  ARM_PCS_UNKNOWN\n+};\n+\n+/* We can't define this inside a generator file because it needs enum\n+   machine_mode.  */\n /* A C type for declaring a variable that is used as the first argument of\n-   `FUNCTION_ARG' and other related values.  For some target machines, the\n-   type `int' suffices and can hold the number of bytes of argument so far.  */\n+   `FUNCTION_ARG' and other related values.  */\n typedef struct\n {\n   /* This is the number of registers of arguments scanned so far.  */\n@@ -1642,9 +1658,33 @@ typedef struct\n   int iwmmxt_nregs;\n   int named_count;\n   int nargs;\n-  int can_split;\n+  /* Which procedure call variant to use for this call.  */\n+  enum arm_pcs pcs_variant;\n+\n+  /* AAPCS related state tracking.  */\n+  int aapcs_arg_processed;  /* No need to lay out this argument again.  */\n+  int aapcs_cprc_slot;      /* Index of co-processor rules to handle\n+\t\t\t       this argument, or -1 if using core\n+\t\t\t       registers.  */\n+  int aapcs_ncrn;\n+  int aapcs_next_ncrn;\n+  rtx aapcs_reg;\t    /* Register assigned to this argument.  */\n+  int aapcs_partial;\t    /* How many bytes are passed in regs (if\n+\t\t\t       split between core regs and stack.\n+\t\t\t       Zero otherwise.  */\n+  int aapcs_cprc_failed[ARM_NUM_COPROC_SLOTS];\n+  int can_split;\t    /* Argument can be split between core regs\n+\t\t\t       and the stack.  */\n+  /* Private data for tracking VFP register allocation */\n+  unsigned aapcs_vfp_regs_free;\n+  unsigned aapcs_vfp_reg_alloc;\n+  int aapcs_vfp_rcount;\n+  /* Can't include insn-modes.h because this header is needed before we\n+     generate it.  */\n+  int /* enum machine_mode */ aapcs_vfp_rmode;\n } CUMULATIVE_ARGS;\n \n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -1688,13 +1728,7 @@ typedef struct\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  (CUM).nargs += 1;\t\t\t\t\t\\\n-  if (arm_vector_mode_supported_p (MODE)\t\t\\\n-      && (CUM).named_count > (CUM).nargs\t\t\\\n-      && TARGET_IWMMXT_ABI)\t\t\t\t\\\n-    (CUM).iwmmxt_nregs += 1;\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    (CUM).nregs += ARM_NUM_REGS2 (MODE, TYPE)\n+  arm_function_arg_advance (&(CUM), (MODE), (TYPE), (NAMED))\n \n /* If defined, a C expression that gives the alignment boundary, in bits, of an\n    argument with the specified mode and type.  If it is not defined,\n@@ -1706,9 +1740,11 @@ typedef struct\n \n /* 1 if N is a possible register number for function argument passing.\n    On the ARM, r0-r3 are used to pass args.  */\n-#define FUNCTION_ARG_REGNO_P(REGNO)\t\\\n-   (IN_RANGE ((REGNO), 0, 3)\t\t\\\n-    || (TARGET_IWMMXT_ABI\t\t\\\n+#define FUNCTION_ARG_REGNO_P(REGNO)\t\t\t\t\t\\\n+   (IN_RANGE ((REGNO), 0, 3)\t\t\t\t\t\t\\\n+    || (TARGET_AAPCS_BASED && TARGET_VFP && TARGET_HARD_FLOAT\t\t\\\n+\t&& IN_RANGE ((REGNO), FIRST_VFP_REGNUM, FIRST_VFP_REGNUM + 15))\t\\\n+    || (TARGET_IWMMXT_ABI\t\t\t\t\t\t\\\n \t&& IN_RANGE ((REGNO), FIRST_IWMMXT_REGNUM, FIRST_IWMMXT_REGNUM + 9)))\n \n \f"}, {"sha": "bc0c62f401ecc504c8c40cc64a40b1d30fd0fe3b", "filename": "gcc/config/arm/bpabi.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Fbpabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Fbpabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fbpabi.h?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -90,16 +90,22 @@\n #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (muldi3, lmul)\n #endif\n #ifdef L_fixdfdi\n-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixdfdi, d2lz)\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixdfdi, d2lz) \\\n+  extern DWtype __fixdfdi (DFtype) __attribute__((pcs(\"aapcs\"))); \\\n+  extern UDWtype __fixunsdfdi (DFtype) __asm__(\"__aeabi_d2ulz\") __attribute__((pcs(\"aapcs\")));\n #endif\n #ifdef L_fixunsdfdi\n-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunsdfdi, d2ulz)\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunsdfdi, d2ulz) \\\n+  extern UDWtype __fixunsdfdi (DFtype) __attribute__((pcs(\"aapcs\")));\n #endif\n #ifdef L_fixsfdi\n-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfdi, f2lz)\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfdi, f2lz) \\\n+  extern DWtype __fixsfdi (SFtype) __attribute__((pcs(\"aapcs\"))); \\\n+  extern UDWtype __fixunssfdi (SFtype) __asm__(\"__aeabi_f2ulz\") __attribute__((pcs(\"aapcs\")));\n #endif\n #ifdef L_fixunssfdi\n-#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfdi, f2ulz)\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfdi, f2ulz) \\\n+  extern UDWtype __fixunssfdi (SFtype) __attribute__((pcs(\"aapcs\")));\n #endif\n #ifdef L_floatdidf\n #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatdidf, l2d)"}, {"sha": "8be87c8d947b9bda473becc034a06b964ca6228f", "filename": "gcc/config/arm/t-arm-elf", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Ft-arm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Farm%2Ft-arm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-elf?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -46,6 +46,13 @@ MULTILIB_MATCHES     =\n #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4\n #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3\n \n+# Not quite true.  We can support hard-vfp calling in Thumb2, but how do we\n+# express that here?  Also, we really need architecture v5e or later\n+# (mcrr etc).\n+MULTILIB_OPTIONS       += mfloat-abi=hard\n+MULTILIB_DIRNAMES      += fpu\n+MULTILIB_EXCEPTIONS    += *mthumb/*mfloat-abi=hard*\n+\n # MULTILIB_OPTIONS    += mcpu=ep9312\n # MULTILIB_DIRNAMES   += ep9312\n # MULTILIB_EXCEPTIONS += *mthumb/*mcpu=ep9312*"}, {"sha": "033980bd441d9074ab2eec4204eb27d2d0fbb989", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -6255,7 +6255,7 @@ rtx\n sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n {\n   const char *qpfunc;\n-  rtx slot0, slot1, result, tem, tem2;\n+  rtx slot0, slot1, result, tem, tem2, libfunc;\n   enum machine_mode mode;\n   enum rtx_code new_comparison;\n \n@@ -6318,15 +6318,17 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n \t  emit_move_insn (slot1, y);\n \t}\n \n-      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), LCT_NORMAL,\n+      libfunc = gen_rtx_SYMBOL_REF (Pmode, qpfunc);\n+      emit_library_call (libfunc, LCT_NORMAL,\n \t\t\t DImode, 2,\n \t\t\t XEXP (slot0, 0), Pmode,\n \t\t\t XEXP (slot1, 0), Pmode);\n       mode = DImode;\n     }\n   else\n     {\n-      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), LCT_NORMAL,\n+      libfunc = gen_rtx_SYMBOL_REF (Pmode, qpfunc);\n+      emit_library_call (libfunc, LCT_NORMAL,\n \t\t\t SImode, 2,\n \t\t\t x, TFmode, y, TFmode);\n       mode = SImode;\n@@ -6337,7 +6339,7 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n      register so reload doesn't clobber the value if it needs\n      the return register for a spill reg.  */\n   result = gen_reg_rtx (mode);\n-  emit_move_insn (result, hard_libcall_value (mode));\n+  emit_move_insn (result, hard_libcall_value (mode, libfunc));\n \n   switch (comparison)\n     {"}, {"sha": "774e602b06deeb454a015aa81ac52ee74fe00c24", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -9322,11 +9322,6 @@ instructions, but still uses the soft-float calling conventions.\n @samp{hard} allows generation of floating-point instructions\n and uses FPU-specific calling conventions.\n \n-Using @option{-mfloat-abi=hard} with VFP coprocessors is not supported.\n-Use @option{-mfloat-abi=softfp} with the appropriate @option{-mfpu} option\n-to allow the compiler to generate code that makes use of the hardware\n-floating-point capabilities for these CPUs.\n-\n The default depends on the specific target configuration.  Note that\n the hard-float and soft-float ABIs are not link-compatible; you must\n compile your entire program with the same ABI, and link with a"}, {"sha": "34c81c9e15c234f8395d85c52780d2e9a5990fe7", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -4387,6 +4387,18 @@ specially by the compiler and was not mentioned in the C code being\n compiled.\n @end defmac\n \n+@deftypefn {Target Hook} rtx TARGET_LIBCALL_VALUE (enum machine_mode\n+@var{mode}, rtx @var{fun})\n+Define this hook if the back-end needs to know the name of the libcall\n+function in order to determine where the result should be returned.  \n+\n+The mode of the result is given by @var{mode} and the name of the called\n+library function is given by @var{fun}.  The hook should return an RTX \n+representing the place where the library function result will be returned.\n+\n+If this hook is not defined, then LIBCALL_VALUE will be used.\n+@end deftypefn\n+\n @defmac FUNCTION_VALUE_REGNO_P (@var{regno})\n A C expression that is nonzero if @var{regno} is the number of a hard\n register in which the values of called function may come back."}, {"sha": "7388a455b1dfcfa8cf3bc15fbbbacde722125648", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -1529,9 +1529,9 @@ hard_function_value (const_tree valtype, const_tree func, const_tree fntype,\n    in which a scalar value of mode MODE was returned by a library call.  */\n \n rtx\n-hard_libcall_value (enum machine_mode mode)\n+hard_libcall_value (enum machine_mode mode, rtx fun)\n {\n-  return LIBCALL_VALUE (mode);\n+  return targetm.calls.libcall_value (mode, fun);\n }\n \n /* Look up the tree code for a given rtx code"}, {"sha": "7058354a86677422dc46f31c5cc5c36af1a88e72", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -762,7 +762,7 @@ extern void probe_stack_range (HOST_WIDE_INT, rtx);\n \n /* Return an rtx that refers to the value returned by a library call\n    in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_libcall_value (enum machine_mode);\n+extern rtx hard_libcall_value (enum machine_mode, rtx);\n \n /* Return the mode desired by operand N of a particular bitfield\n    insert/extract insn, or MAX_MACHINE_MODE if no such insn is"}, {"sha": "fcc1649caf32d598d8440f0be814f8dd53609aa2", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -3278,7 +3278,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       if (unoptab == ffs_optab || unoptab == clz_optab || unoptab == ctz_optab\n \t  || unoptab == popcount_optab || unoptab == parity_optab)\n \toutmode\n-\t    = GET_MODE (hard_libcall_value (TYPE_MODE (integer_type_node)));\n+\t  = GET_MODE (hard_libcall_value (TYPE_MODE (integer_type_node),\n+\t\t\t\t\t  optab_libfunc (unoptab, mode)));\n \n       start_sequence ();\n "}, {"sha": "8ad6b8a52eff5cccbda9e6dc2008320c9db61fd5", "filename": "gcc/target-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -598,6 +598,7 @@\n #define TARGET_ARG_PARTIAL_BYTES hook_int_CUMULATIVE_ARGS_mode_tree_bool_0\n \n #define TARGET_FUNCTION_VALUE default_function_value\n+#define TARGET_LIBCALL_VALUE default_libcall_value\n #define TARGET_INTERNAL_ARG_POINTER default_internal_arg_pointer\n #define TARGET_UPDATE_STACK_BOUNDARY NULL\n #define TARGET_GET_DRAP_RTX NULL\n@@ -620,6 +621,7 @@\n    TARGET_ARG_PARTIAL_BYTES,\t\t\t\t\t\\\n    TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN,\t\t\t\\\n    TARGET_FUNCTION_VALUE,\t\t\t\t\t\\\n+   TARGET_LIBCALL_VALUE,\t\t\t\t\t\\\n    TARGET_INTERNAL_ARG_POINTER,\t\t\t\t\t\\\n    TARGET_UPDATE_STACK_BOUNDARY,\t\t\t\t\\\n    TARGET_GET_DRAP_RTX,\t\t\t\t\t\t\\"}, {"sha": "7c60cfb139ba26817863e245e3b6c1727df26de4", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -892,6 +892,10 @@ struct gcc_target\n     rtx (*function_value) (const_tree ret_type, const_tree fn_decl_or_type,\n \t\t\t   bool outgoing);\n \n+    /* Return the rtx for the result of a libcall of mode MODE,\n+       calling the function FN_NAME.  */\n+    rtx (*libcall_value) (enum machine_mode, rtx);\n+\n     /* Return an rtx for the argument pointer incoming to the\n        current function.  */\n     rtx (*internal_arg_pointer) (void);"}, {"sha": "58a9aeea4031248c1c2c07350aa7e8cb7773cda0", "filename": "gcc/targhooks.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -605,6 +605,12 @@ default_function_value (const_tree ret_type ATTRIBUTE_UNUSED,\n #endif\n }\n \n+rtx\n+default_libcall_value (enum machine_mode mode, rtx fun ATTRIBUTE_UNUSED)\n+{\n+  return LIBCALL_VALUE (mode);\n+}\n+\n rtx\n default_internal_arg_pointer (void)\n {"}, {"sha": "4e5f631e76ccf8f1ffb0009f266c758d0d95848c", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -94,6 +94,7 @@ extern const char *hook_invalid_arg_for_unprototyped_fn\n   (const_tree, const_tree, const_tree);\n extern bool hook_bool_const_rtx_commutative_p (const_rtx, int);\n extern rtx default_function_value (const_tree, const_tree, bool);\n+extern rtx default_libcall_value (enum machine_mode, rtx);\n extern rtx default_internal_arg_pointer (void);\n extern enum reg_class default_branch_target_register_class (void);\n #ifdef IRA_COVER_CLASSES"}, {"sha": "260f0db86ec4136e5d7c599a9afe35ae39ce0b00", "filename": "gcc/testsuite/ChangeLog.ARM", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2FChangeLog.ARM", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2FChangeLog.ARM", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog.ARM?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,26 @@\n+2009-08-04  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* gcc.target/arm/mmx-1.c: Skip if using -mfloat-abi=hard.\n+\t* gcc.dg/builtin-apply2.c: Skip for ARM if using -mfloat-abi=hard.\n+\n+2009-05-12  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.target/arm/eabi1.c: Do not skip for non-base ABI variants.\n+\t(PCS): Define macro to use base AAPCS.\n+\t(decl_float, __aeabi_d2f, __aeabi_f2d): Use PCS macro.\n+\n+2009-05-11  Daniel Jacobowitz  <dan@codesourcery.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_arm_neon_ok):\n+\tCorrect arm_neon.h typo.\n+\n+2009-03-06  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_hard_vfp_ok): Make\n+\tthis a linkage test.\n+\t* gcc.target/arm/aapcs/aapcs.exp: New framework for testing AAPCS\n+\targument marshalling.\n+\t* abitest.h: New file.\n+\t* vfp1.c, vfp2.c, vfp3.c, vfp4.c, vfp5.c, vfp6.c, vfp7.c: New tests.\n+\t* vfp8.c, vfp9.c, vfp10.c, vfp11.c, vfp12.c, vfp13.c, vfp14.c: New.\n+"}, {"sha": "a303e3ddb79b9c6e8f0f6743fe455a9682052f51", "filename": "gcc/testsuite/gcc.dg/builtin-apply2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do run } */\n /* { dg-skip-if \"Variadic funcs have all args on stack. Normal funcs have args in registers.\" { \"avr-*-*\" } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.\" { \"arm*-*-*\" } { \"-mfloat-abi=hard\" } { \"\" } } */\n \n /* PR target/12503 */\n /* Origin: <pierre.nguyen-tuong@asim.lip6.fr> */"}, {"sha": "fcc4333464c01ac26a163472a75346ab977f7cff", "filename": "gcc/testsuite/gcc.target/arm/aapcs/aapcs.exp", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Faapcs.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Faapcs.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Faapcs.exp?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,35 @@\n+# Copyright (C) 1997, 2004, 2006, 2007 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an ARM target.\n+if ![istarget arm*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cCS\\]]] \\\n+\t\"\" \"\"\n+\n+# All done.\n+dg-finish"}, {"sha": "f6474a988a0904031bfbf2540c648603c823e6f9", "filename": "gcc/testsuite/gcc.target/arm/aapcs/abitest.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fabitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fabitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fabitest.h?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,118 @@\n+#define IN_FRAMEWORK\n+\n+#ifdef VFP\n+#define D0\t0\n+#define D1\t8\n+#define D2\t16\n+#define D3\t24\n+#define D4\t32\n+#define D5\t40\n+#define D6\t48\n+#define D7\t56\n+\n+#define S0\t64\n+#define S1\t68\n+#define S2\t72\n+#define S3\t76\n+#define S4\t80\n+#define S5\t84\n+#define S6\t88\n+#define S7\t92\n+#define S8      86\n+#define S9\t100\n+#define S10\t104\n+#define S11\t108\n+#define S12\t112\n+#define S13\t116\n+#define S14\t120\n+#define S15\t124\n+\n+#define R0\t128\n+#define R1\t132\n+#define R2\t136\n+#define R3\t140\n+\n+#define STACK\t144\n+\n+#else\n+\n+#define R0\t0\n+#define R1\t4\n+#define R2\t8\n+#define R3\t12\n+\n+#define STACK   16\n+\n+#endif\n+\n+extern void abort (void);\n+\n+__attribute__((naked))  void dumpregs () __asm(\"myfunc\");\n+__attribute__((naked))  void dumpregs ()\n+{\n+  asm(\n+      \"mov\tip, sp\\n\\t\"\n+      \"stmfd\tsp!, {r0-r3}\\n\\t\"\n+#ifdef VFP\n+      \"fstmdbs\tsp!, {s0-s15}\\n\\t\"\n+      \"fstmdbd\tsp!, {d0-d7}\\n\\t\"\n+#endif\n+      \"mov\tr0, sp\\n\\t\"\n+      \"stmfd\tsp!, {ip, r14}\\n\\t\"\n+      \"bl\ttestfunc\\n\\t\"\n+      \"ldmfd\tsp!, {r0, r14}\\n\\t\"\n+      \"mov\tsp, r0\\n\\t\"\n+      \"bx\tlr\");\n+}\n+\n+\n+#define LAST_ARG(type,val,offset) { type __x = val; if (memcmp(&__x, stack+offset, sizeof(type)) != 0) abort(); }\n+#define ARG(type,val,offset) LAST_ARG(type, val, offset)\n+#define ANON(type,val,offset) LAST_ARG(type, val, offset)\n+#define LAST_ANON(type,val,offset) LAST_ARG(type, val, offset)\n+#define DOTS\n+\n+void testfunc(char* stack)\n+{\n+#include TESTFILE\n+  return;\n+}\n+\n+#undef LAST_ARG\n+#undef ARG\n+#undef DOTS\n+#undef ANON\n+#undef LAST_ANON\n+#define LAST_ARG(type,val,offset) type\n+#define ARG(type,val,offset) LAST_ARG(type, val, offset),\n+#define DOTS ...\n+#define ANON(type,val, offset)\n+#define LAST_ANON(type,val, offset)\n+\n+#ifndef MYFUNCTYPE\n+#define MYFUNCTYPE void\n+#endif\n+\n+MYFUNCTYPE myfunc(\n+#include TESTFILE\n+);\n+\n+#undef LAST_ARG\n+#undef ARG\n+#undef DOTS\n+#undef ANON\n+#undef LAST_ANON\n+#define LAST_ARG(type,val,offset) val\n+#define ARG(type,val,offset) LAST_ARG(type, val, offset),\n+#define DOTS\n+#define LAST_ANON(type,val,offset) LAST_ARG(type, val, offset)\n+#define ANON(type,val,offset) LAST_ARG(type, val, offset),\n+\n+\n+int main()\n+{\n+  myfunc(\n+#include TESTFILE\n+);\n+  return 0;\n+}"}, {"sha": "380a3244dd4b65b361215eb30dc66eaf41bed513", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp1.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,17 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp1.c\"\n+#include \"abitest.h\"\n+\n+#else\n+  ARG(int, 4, R0)\n+  ARG(double, 4.0, D0)\n+  LAST_ARG(int, 3, R1)\n+#endif"}, {"sha": "58561aac9fcf5e2654fb6a2ae123d783a80f70ec", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp10.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp10.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,38 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp10.c\"\n+\n+__complex__ x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+struct z\n+{\n+  double x[4];\n+};\n+\n+struct z a = { 5.0, 6.0, 7.0, 8.0 };\n+struct z b = { 9.0, 10.0, 11.0, 12.0 };\n+\n+#include \"abitest.h\"\n+#else\n+  /* A variadic function passes using the base ABI */\n+  ARG(double, 11.0, R0)\n+  DOTS\n+  ANON(struct z, a, R2)\n+  ANON(struct z, b, STACK+24)\n+  LAST_ANON(double, 0.5, STACK+56)\n+#endif"}, {"sha": "2c143bafb06f639b6da54090e302e47d04f114ed", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp11.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp11.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,39 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp11.c\"\n+\n+__complex__ x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+struct z\n+{\n+  double x[4];\n+};\n+\n+struct z a = { 5.0, 6.0, 7.0, 8.0 };\n+struct z b = { 9.0, 10.0, 11.0, 12.0 };\n+\n+#define MYFUNCTYPE struct y\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(int, 7, R1)\n+  ARG(struct y, v, R2)\n+  ARG(struct z, a, D0)\n+  ARG(struct z, b, D4)\n+  LAST_ARG(double, 0.5, STACK+8)\n+#endif"}, {"sha": "7b6b4cd54aa8b27bd8b5465ea72b8fd7b3b67eab", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp12.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp12.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,38 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp12.c\"\n+\n+__complex__ x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+struct z\n+{\n+  double x[4];\n+};\n+\n+struct z a = { 5.0, 6.0, 7.0, 8.0 };\n+struct z b = { 9.0, 10.0, 11.0, 12.0 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(int, 7, R0)\n+  ARG(struct y, v, R1)\n+  ARG(struct z, a, D0)\n+  ARG(double, 1.0, D4)\n+  ARG(struct z, b, STACK+8)\n+  LAST_ARG(double, 0.5, STACK+40)\n+#endif"}, {"sha": "ca0c5be7c3a5423051aeb68932b244a89ef02051", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp13.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp13.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,39 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp13.c\"\n+\n+__complex__ x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+struct z\n+{\n+  double x[4];\n+};\n+\n+struct z a = { 5.0, 6.0, 7.0, 8.0 };\n+struct z b = { 9.0, 10.0, 11.0, 12.0 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(int, 7, R0)\n+  ARG(int, 9, R1)\n+  ARG(struct z, a, D0)\n+  ARG(double, 1.0, D4)\n+  ARG(struct z, b, STACK)\n+  ARG(int, 4, R2)\n+  LAST_ARG(double, 0.5, STACK+32)\n+#endif"}, {"sha": "b5131d7fcff55c71910b10c4fcaed6a731614387", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp14.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp14.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,24 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp14.c\"\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(double, 1.0, D0)\n+  ARG(double, 2.0, D1)\n+  ARG(double, 3.0, D2)\n+  ARG(double, 4.0, D3)\n+  ARG(double, 5.0, D4)\n+  ARG(double, 6.0, D5)\n+  ARG(double, 7.0, D6)\n+  ARG(double, 8.0, D7)\n+  ARG(double, 9.0, STACK)\n+  LAST_ARG(double, 10.0, STACK+8)\n+#endif"}, {"sha": "a2db349e4a2fd171d9345d0d58a03347e3068df1", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp2.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,19 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp2.c\"\n+#include \"abitest.h\"\n+\n+#else\n+  ARG(float, 1.0f, S0)\n+  ARG(double, 4.0, D1)\n+  ARG(float, 2.0f, S1)\n+  ARG(double, 5.0, D2)\n+  LAST_ARG(int, 3, R0)\n+#endif"}, {"sha": "807292b572154c1d9e833262fd0fcf7caf776c9d", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp3.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,21 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp3.c\"\n+\n+__complex__ x = 1.0+2.0i;\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(float, 1.0f, S0)\n+  ARG(__complex__ double, x, D1)\n+  ARG(float, 2.0f, S1)\n+  ARG(double, 5.0, D3)\n+  LAST_ARG(int, 3, R0)\n+#endif"}, {"sha": "8bb2a5678b9136784f79ae60006a94b395139394", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp4.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,20 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp4.c\"\n+\n+__complex__ float x = 1.0f + 2.0fi;\n+#include \"abitest.h\"\n+#else\n+  ARG(float, 1.0f, S0)\n+  ARG(__complex__ float, x, S1)\n+  ARG(float, 2.0f, S3)\n+  ARG(double, 5.0, D2)\n+  LAST_ARG(int, 3, R0)\n+#endif"}, {"sha": "0adc17fde118520d7d7708b7e84fa292609be3d5", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp5.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp5.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,30 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp5.c\"\n+\n+__complex__ float x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(float, 1.0f, S0)\n+  ARG(__complex__ float, x, S1)\n+  ARG(float, 2.0f, S3)\n+  ARG(double, 5.0, D2)\n+  ARG(struct y, v, R0)\n+  LAST_ARG(int, 3, STACK)\n+#endif"}, {"sha": "6d8df0d62ac1016935b37f01aa8719d96bc48b44", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp6.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp6.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,30 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp6.c\"\n+\n+__complex__ float x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(struct y, v, R0)\n+  ARG(float, 1.0f, S0)\n+  ARG(__complex__ float, x, S1)\n+  ARG(float, 2.0f, S3)\n+  ARG(double, 5.0, D2)\n+  LAST_ARG(int, 3, STACK)\n+#endif"}, {"sha": "de4bdb4c421cf708880c697036d627bb2a25262d", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp7.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp7.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,37 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp7.c\"\n+\n+__complex__ x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+struct z\n+{\n+  double x[4];\n+};\n+\n+struct z a = { 5.0, 6.0, 7.0, 8.0 };\n+struct z b = { 9.0, 10.0, 11.0, 12.0 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(struct z, a, D0)\n+  ARG(struct z, b, D4)\n+  ARG(double, 0.5, STACK)\n+  ARG(int, 7, R0)\n+  LAST_ARG(struct y, v, STACK+8)\n+#endif"}, {"sha": "7865844ebbc803a46f283134bd174d439418b362", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp8.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp8.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,37 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp8.c\"\n+\n+__complex__ x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+struct z\n+{\n+  double x[4];\n+};\n+\n+struct z a = { 5.0, 6.0, 7.0, 8.0 };\n+struct z b = { 9.0, 10.0, 11.0, 12.0 };\n+\n+#include \"abitest.h\"\n+#else\n+  ARG(int, 7, R0)\n+  ARG(struct y, v, R1)\n+  ARG(struct z, a, D0)\n+  ARG(struct z, b, D4)\n+  LAST_ARG(double, 0.5, STACK+8)\n+#endif"}, {"sha": "f9aa2960ca8680cbe0a805e8a7122ee3f5a283a7", "filename": "gcc/testsuite/gcc.target/arm/aapcs/vfp9.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Faapcs%2Fvfp9.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -0,0 +1,38 @@\n+/* Test AAPCS layout (VFP variant) */\n+\n+/* { dg-do run { target arm*-*-eabi* } } */\n+/* { dg-require-effective-target arm_hard_vfp_ok } */\n+/* { dg-require-effective-target arm32 } */\n+/* { dg-options \"-O -mfpu=vfp -mfloat-abi=hard\" } */\n+\n+#ifndef IN_FRAMEWORK\n+#define VFP\n+#define TESTFILE \"vfp9.c\"\n+\n+__complex__ x = 1.0+2.0i;\n+\n+struct y\n+{\n+  int p;\n+  int q;\n+  int r;\n+  int s;\n+} v = { 1, 2, 3, 4 };\n+\n+struct z\n+{\n+  double x[4];\n+};\n+\n+struct z a = { 5.0, 6.0, 7.0, 8.0 };\n+struct z b = { 9.0, 10.0, 11.0, 12.0 };\n+\n+#include \"abitest.h\"\n+#else\n+  /* A variadic function passes using the base ABI */\n+  ARG(int, 7, R0)\n+  DOTS\n+  ANON(struct z, a, R2)\n+  ANON(struct z, b, STACK+24)\n+  LAST_ANON(double, 0.5, STACK+56)\n+#endif"}, {"sha": "c90f5ff08563c18c22a5d05c96b9286672f2c37f", "filename": "gcc/testsuite/gcc.target/arm/eabi1.c", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Feabi1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Feabi1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Feabi1.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -30,43 +30,48 @@\n #include <stdlib.h>\n #include <math.h>\n \n-#define decl_float(code, type)\t\t\t\t\t\\\n-  extern type __aeabi_ ## code ## add (type, type);\t\t\\\n-  extern type __aeabi_ ## code ## div (type, type);\t\t\\\n-  extern type __aeabi_ ## code ## mul (type, type);\t\t\\\n-  extern type __aeabi_ ## code ## neg (type);\t\t\t\\\n-  extern type __aeabi_ ## code ## rsub (type, type);\t\t\\\n-  extern type __aeabi_ ## code ## sub (type, type);\t\t\\\n-  extern int __aeabi_ ## code ## cmpeq (type, type);\t\t\\\n-  extern int __aeabi_ ## code ## cmplt (type, type);\t\t\\\n-  extern int __aeabi_ ## code ## cmple (type, type);\t\t\\\n-  extern int __aeabi_ ## code ## cmpge (type, type);\t\t\\\n-  extern int __aeabi_ ## code ## cmpgt (type, type);\t\t\\\n-  extern int __aeabi_ ## code ## cmpun (type, type);\t\t\\\n-  extern int __aeabi_ ## code ## 2iz (type);\t\t\t\\\n-  extern unsigned int __aeabi_ ## code ## 2uiz (type);\t\t\\\n-  extern long long __aeabi_ ## code ## 2lz (type);\t\t\\\n-  extern unsigned long long __aeabi_ ## code ## 2ulz (type);\t\\\n-  extern type __aeabi_i2 ## code (int);\t\t\t\t\\\n-  extern type __aeabi_ui2 ## code (int);\t\t\t\\\n-  extern type __aeabi_l2 ## code (long long);\t\t\t\\\n-  extern type __aeabi_ul2 ## code (unsigned long long);\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  type code ## zero = 0.0;\t\t\t\t\t\\\n-  type code ## one = 1.0;\t\t\t\t\t\\\n-  type code ## two = 2.0;\t\t\t\t\t\\\n-  type code ## four = 4.0;\t\t\t\t\t\\\n-  type code ## minus_one = -1.0;\t\t\t\t\\\n-  type code ## minus_two = -2.0;\t\t\t\t\\\n-  type code ## minus_four = -4.0;\t\t\t\t\\\n-  type code ## epsilon = 1E-32;\t\t\t\t\t\\\n-  type code ## NaN = 0.0 / 0.0;\t\t\t\t\n+/* All these functions are defined to use the base ABI, so use the\n+   attribute to ensure the tests use the base ABI to call them even\n+   when the VFP ABI is otherwise in effect.  */\n+#define PCS __attribute__((pcs(\"aapcs\")))\n+\n+#define decl_float(code, type)\t\t\t\t\t\t\\\n+  extern type __aeabi_ ## code ## add (type, type) PCS;\t\t\t\\\n+  extern type __aeabi_ ## code ## div (type, type) PCS;\t\t\t\\\n+  extern type __aeabi_ ## code ## mul (type, type) PCS;\t\t\t\\\n+  extern type __aeabi_ ## code ## neg (type) PCS;\t\t\t\\\n+  extern type __aeabi_ ## code ## rsub (type, type) PCS;\t\t\\\n+  extern type __aeabi_ ## code ## sub (type, type) PCS;\t\t\t\\\n+  extern int __aeabi_ ## code ## cmpeq (type, type) PCS;\t\t\\\n+  extern int __aeabi_ ## code ## cmplt (type, type) PCS;\t\t\\\n+  extern int __aeabi_ ## code ## cmple (type, type) PCS;\t\t\\\n+  extern int __aeabi_ ## code ## cmpge (type, type) PCS;\t\t\\\n+  extern int __aeabi_ ## code ## cmpgt (type, type) PCS;\t\t\\\n+  extern int __aeabi_ ## code ## cmpun (type, type) PCS;\t\t\\\n+  extern int __aeabi_ ## code ## 2iz (type) PCS;\t\t\t\\\n+  extern unsigned int __aeabi_ ## code ## 2uiz (type) PCS;\t\t\\\n+  extern long long __aeabi_ ## code ## 2lz (type) PCS;\t\t\t\\\n+  extern unsigned long long __aeabi_ ## code ## 2ulz (type) PCS;\t\\\n+  extern type __aeabi_i2 ## code (int) PCS;\t\t\t\t\\\n+  extern type __aeabi_ui2 ## code (int) PCS;\t\t\t\t\\\n+  extern type __aeabi_l2 ## code (long long) PCS;\t\t\t\\\n+  extern type __aeabi_ul2 ## code (unsigned long long) PCS;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  type code ## zero = 0.0;\t\t\t\t\t\t\\\n+  type code ## one = 1.0;\t\t\t\t\t\t\\\n+  type code ## two = 2.0;\t\t\t\t\t\t\\\n+  type code ## four = 4.0;\t\t\t\t\t\t\\\n+  type code ## minus_one = -1.0;\t\t\t\t\t\\\n+  type code ## minus_two = -2.0;\t\t\t\t\t\\\n+  type code ## minus_four = -4.0;\t\t\t\t\t\\\n+  type code ## epsilon = 1E-32;\t\t\t\t\t\t\\\n+  type code ## NaN = 0.0 / 0.0;\n \n decl_float (d, double)\n decl_float (f, float)\n \n-extern float __aeabi_d2f (double);\n-extern double __aeabi_f2d (float);\n+extern float __aeabi_d2f (double) PCS;\n+extern double __aeabi_f2d (float) PCS;\n extern long long __aeabi_lmul (long long, long long);\n extern long long __aeabi_llsl (long long, int);\n extern long long __aeabi_llsr (long long, int);"}, {"sha": "5d51bd7b31d2ccc529aa132796a783589475a1ff", "filename": "gcc/testsuite/gcc.target/arm/mmx-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmmx-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmmx-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmmx-1.c?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -4,6 +4,7 @@\n /* { dg-skip-if \"Test is specific to the iWMMXt\" { arm*-*-* } { \"-mcpu=*\" } { \"-mcpu=iwmmxt\" } } */\n /* { dg-skip-if \"Test is specific to the iWMMXt\" { arm*-*-* } { \"-mabi=*\" } { \"-mabi=iwmmxt\" } } */\n /* { dg-skip-if \"Test is specific to the iWMMXt\" { arm*-*-* } { \"-mfloat-abi=softfp\" } { \"\" } } */\n+/* { dg-skip-if \"Test is specific to the iWMMXt\" { arm*-*-* } { \"-mfloat-abi=hard\" } { \"\" } } */\n /* { dg-skip-if \"Test is specific to the iWMMXt\" { arm*-*-* } { \"-march=*\" } { \"-march=iwmmxt\" } } */\n /* { dg-options \"-O -mno-apcs-frame -mcpu=iwmmxt -mabi=iwmmxt\" } */\n /* { dg-require-effective-target arm32 } */"}, {"sha": "27a537c6a086df1b8d3ce7fd1147437d2b7c1eaf", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390b17c28c10ab2b6752cb94b150c831762575fc/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=390b17c28c10ab2b6752cb94b150c831762575fc", "patch": "@@ -1511,13 +1511,28 @@ proc check_effective_target_arm_vfp_ok { } {\n     }\n }\n \n+# Return 1 if this is an ARM target supporting -mfpu=vfp\n+# -mfloat-abi=hard.  Some multilibs may be incompatible with these\n+# options.\n+\n+proc check_effective_target_arm_hard_vfp_ok { } {\n+    if { [check_effective_target_arm32] } {\n+\treturn [check_no_compiler_messages arm_hard_vfp_ok executable {\n+\t    int main() { return 0;}\n+\t} \"-mfpu=vfp -mfloat-abi=hard\"]\n+    } else {\n+\treturn 0\n+    }\n+}\n+\n # Return 1 if this is an ARM target supporting -mfpu=neon\n # -mfloat-abi=softfp.  Some multilibs may be incompatible with these\n # options.\n \n proc check_effective_target_arm_neon_ok { } {\n     if { [check_effective_target_arm32] } {\n         return [check_no_compiler_messages arm_neon_ok object {\n+\t    #include \"arm_neon.h\"\n             int dummy;\n         } \"-mfpu=neon -mfloat-abi=softfp\"]\n     } else {"}]}