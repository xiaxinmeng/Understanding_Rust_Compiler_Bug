{"sha": "0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0ZDMzM2UwMWNlMWU4MGQ5MGRkNmNjZmQ5OWM5MmFjZWMyYTYyZQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-02-16T11:49:46Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-02-16T11:49:46Z"}, "message": "[multiple changes]\n\nThu Jan 28 11:50:11 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* jcf-parse.c (jcf_parse): Don't parse the same class file twice.\n\t* parse.y (patch_cast): Allow a boolean to be cast into a\n \tboolean.\nWed Jan 27 10:19:29 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* parse.y: (class_declaration:): Fixed indentation.\n\t(class_member_declaration:): Extra `;' after field declaration now\n \taccepted.\n\t(interface_declaration:): Removed debug messages in error reports.\n\t(patch_binop): Nodes created and returned inherit the orignal\n \tnode's COMPOUND_ASSIGN_P flag value.\n\t(patch_cast): Fix cast from char to floating point.\n\nFrom-SVN: r25244", "tree": {"sha": "6369f1ced645b4d07caddd1543ec935f191657a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6369f1ced645b4d07caddd1543ec935f191657a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/comments", "author": null, "committer": null, "parents": [{"sha": "4393e10527c91ec9238ce2fdef4f731b8f56bed8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4393e10527c91ec9238ce2fdef4f731b8f56bed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4393e10527c91ec9238ce2fdef4f731b8f56bed8"}], "stats": {"total": 3439, "additions": 1728, "deletions": 1711}, "files": [{"sha": "1912ea723b893a03fa3c04e085efd9806dc4437e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e", "patch": "@@ -154,6 +154,22 @@ Thu Jan 28 14:45:39 1999  Per Bothner  <bothner@cygnus.com>\n \tHandle TRUTH_AND_EXPR, TRUTH_OR_EXPR, and TRUTH_XOR_EXPR.\n \t* jcf-write.c (generate_bytecode_insns):  Likewise.\n \n+Thu Jan 28 11:50:11 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* jcf-parse.c (jcf_parse): Don't parse the same class file twice.\n+\t* parse.y (patch_cast): Allow a boolean to be cast into a\n+ \tboolean.\n+\n+Wed Jan 27 10:19:29 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y: (class_declaration:): Fixed indentation.\n+\t(class_member_declaration:): Extra `;' after field declaration now\n+ \taccepted.\n+\t(interface_declaration:): Removed debug messages in error reports.\n+\t(patch_binop): Nodes created and returned inherit the orignal\n+ \tnode's COMPOUND_ASSIGN_P flag value.\n+\t(patch_cast): Fix cast from char to floating point.\n+\n Mon Jan 25 17:39:19 1999  Andrew Haley  <aph@cygnus.com>\n \n         * except.c, java-except.h (expand_resume_after_catch): new"}, {"sha": "3dcb25b9c6686c2d4caa8345495d90ecaac117fd", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e", "patch": "@@ -605,6 +605,8 @@ jcf_parse (jcf)\n   if (! quiet_flag && TYPE_NAME (current_class))\n     fprintf (stderr, \" class %s\",\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))));\n+  if (CLASS_LOADED_P (current_class))\n+    return;\n   CLASS_LOADED_P (current_class) = 1;\n \n   for (i = 1; i < JPOOL_SIZE(jcf); i++)"}, {"sha": "bdecb2e2a3dbae8234d9350c7eb87581e8ebc3a6", "filename": "gcc/java/parse.c", "status": "modified", "additions": 1679, "deletions": 1704, "changes": 3383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e"}, {"sha": "4358dc123c92ded6d9b3801731f5e14e79c77b0e", "filename": "gcc/java/parse.y", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=0b4d333e01ce1e80d90dd6ccfd99c92acec2a62e", "patch": "@@ -671,7 +671,10 @@ class_declaration:\n |\tCLASS_TK error\n \t\t{yyerror (\"Missing class name\"); RECOVER;}\n |       CLASS_TK identifier error\n-\t\t{if (!ctxp->class_err) yyerror (\"'{' expected\"); DRECOVER(class1);}\n+\t\t{\n+\t\t  if (!ctxp->class_err) yyerror (\"'{' expected\"); \n+\t\t  DRECOVER(class1);\n+\t\t}\n |       modifiers CLASS_TK identifier error\n \t\t{if (!ctxp->class_err) yyerror (\"'{' expected\"); RECOVER;}\n ;\n@@ -734,6 +737,8 @@ class_body_declaration:\n \n class_member_declaration:\n \tfield_declaration\n+|\tfield_declaration SC_TK\n+\t\t{ $$ = $1; }\n |\tmethod_declaration\n |\tclass_declaration\t/* Added, JDK1.1 inner classes */\n \t\t{ $$ = parse_jdk1_1_error (\"inner classe declaration\"); }\n@@ -1044,9 +1049,9 @@ interface_declaration:\n \t\t  $$ = $6;\n \t\t}\n |\tINTERFACE_TK identifier error\n-\t\t{yyerror (\"(here)'{' expected\"); RECOVER;}\n+\t\t{yyerror (\"'{' expected\"); RECOVER;}\n |\tmodifiers INTERFACE_TK identifier error\n-\t\t{yyerror (\"(there)'{' expected\"); RECOVER;}\n+\t\t{yyerror (\"'{' expected\"); RECOVER;}\n ;\n \n extends_interfaces:\n@@ -8903,10 +8908,16 @@ patch_binop (node, wfl_op1, wfl_op2)\n       /* Change the division operator if necessary */\n       if (code == RDIV_EXPR && TREE_CODE (prom_type) == INTEGER_TYPE)\n \tTREE_SET_CODE (node, TRUNC_DIV_EXPR);\n-      /* This one is more complicated. FLOATs are processed by a function\n-\t call to soft_fmod. */\n+\n+      /* This one is more complicated. FLOATs are processed by a\n+\t function call to soft_fmod. Duplicate the value of the\n+\t COMPOUND_ASSIGN_P flag. */\n       if (code == TRUNC_MOD_EXPR)\n-\treturn build_java_binop (TRUNC_MOD_EXPR, prom_type, op1, op2);\n+\t{\n+\t  tree mod = build_java_binop (TRUNC_MOD_EXPR, prom_type, op1, op2);\n+\t  COMPOUND_ASSIGN_P (mod) = COMPOUND_ASSIGN_P (node);\n+\t  return mod;\n+\t}\n       break;\n \n     /* 15.17 Additive Operators */\n@@ -8981,13 +8992,17 @@ patch_binop (node, wfl_op1, wfl_op2)\n       /* The >>> operator is a >> operating on unsigned quantities */\n       if (code == URSHIFT_EXPR && ! flag_emit_class_files)\n \t{\n+\t  tree to_return;\n           tree utype = unsigned_type (prom_type);\n           op1 = convert (utype, op1);\n \t  TREE_SET_CODE (node, RSHIFT_EXPR);\n           TREE_OPERAND (node, 0) = op1;\n           TREE_OPERAND (node, 1) = op2;\n           TREE_TYPE (node) = utype;\n-          return convert (prom_type, node);\n+\t  to_return = convert (prom_type, node);\n+\t  /* Copy the original value of the COMPOUND_ASSIGN_P flag */\n+\t  COMPOUND_ASSIGN_P (to_return) = COMPOUND_ASSIGN_P (node);\n+\t  return to_return;\n \t}\n       break;\n \n@@ -9656,12 +9671,21 @@ patch_cast (node, wfl_operator)\n       if (cast_type == op_type)\n \treturn node;\n \n+      /* float and double type are converted to the original type main\n+\t variant and then to the target type. */\n+      if (JFLOAT_TYPE_P (op_type) && TREE_CODE (cast_type) == CHAR_TYPE)\n+\top = convert (integer_type_node, op);\n+\n       /* Try widening/narowwing convertion. Potentially, things need\n \t to be worked out in gcc so we implement the extreme cases\n \t correctly. fold_convert() needs to be fixed. */\n       return convert (cast_type, op);\n     }\n \n+  /* It's also valid to cast a boolean into a boolean */\n+  if (op_type == boolean_type_node && cast_type == boolean_type_node)\n+    return node;\n+\n   /* null can be casted to references */\n   if (op == null_pointer_node && JREFERENCE_TYPE_P (cast_type))\n     return build_null_of_type (cast_type);"}]}