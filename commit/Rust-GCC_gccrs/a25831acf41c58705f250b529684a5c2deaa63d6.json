{"sha": "a25831acf41c58705f250b529684a5c2deaa63d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1ODMxYWNmNDFjNTg3MDVmMjUwYjUyOTY4NGE1YzJkZWFhNjNkNg==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2018-07-19T13:59:17Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2018-07-19T13:59:17Z"}, "message": "[AArch64][PATCH 1/2] Fix addressing printing of LDP/STP\n\ngcc/ChangeLog\n2018-07-19  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\t* config/aarch64/aarch64-simd.md (aarch64_simd_mov<VQ:mode>): Replace\n\tUmq with Umn.\n\t(store_pair_lanes<mode>): Likewise.\n\t* config/aarch64/aarch64-protos.h (aarch64_addr_query_type): Add new\n\tenum value 'ADDR_QUERY_LDP_STP_N'.\n\t* config/aarch64/aarch64.c (aarch64_addr_query_type): Likewise.\n\t(aarch64_print_address_internal): Add declaration.\n\t(aarch64_print_ldpstp_address): Remove.\n\t(aarch64_classify_address): Adapt mode for 'ADDR_QUERY_LDP_STP_N'.\n\t(aarch64_print_operand): Change printing of 'y'.\n\t* config/aarch64/predicates.md (aarch64_mem_pair_lanes_operand): Use\n\tnew enum value 'ADDR_QUERY_LDP_STP_N', don't hardcode mode and use\n\t'true' rather than '1'.\n\t* gcc/config/aarch64/constraints.md (Uml): Likewise.\n\t(Uml): Rename to Umn.\n\t(Umq): Remove.\n\nFrom-SVN: r262880", "tree": {"sha": "f9928aff384a9abaa0c1b435535e604036b392d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9928aff384a9abaa0c1b435535e604036b392d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a25831acf41c58705f250b529684a5c2deaa63d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25831acf41c58705f250b529684a5c2deaa63d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25831acf41c58705f250b529684a5c2deaa63d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25831acf41c58705f250b529684a5c2deaa63d6/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "851fd3661346f314bf33d846bb9b88194523857e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851fd3661346f314bf33d846bb9b88194523857e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/851fd3661346f314bf33d846bb9b88194523857e"}], "stats": {"total": 82, "additions": 50, "deletions": 32}, "files": [{"sha": "0393db3a4611a9ef3ddec94659df8e48c3b67203", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a25831acf41c58705f250b529684a5c2deaa63d6", "patch": "@@ -1,3 +1,22 @@\n+2018-07-19  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\t* config/aarch64/aarch64-simd.md (aarch64_simd_mov<VQ:mode>): Replace\n+\tUmq with Umn.\n+\t(store_pair_lanes<mode>): Likewise.\n+\t* config/aarch64/aarch64-protos.h (aarch64_addr_query_type): Add new\n+\tenum value 'ADDR_QUERY_LDP_STP_N'.\n+\t* config/aarch64/aarch64.c (aarch64_addr_query_type): Likewise.\n+\t(aarch64_print_address_internal): Add declaration.\n+\t(aarch64_print_ldpstp_address): Remove.\n+\t(aarch64_classify_address): Adapt mode for 'ADDR_QUERY_LDP_STP_N'.\n+\t(aarch64_print_operand): Change printing of 'y'.\n+\t* config/aarch64/predicates.md (aarch64_mem_pair_lanes_operand): Use\n+\tnew enum value 'ADDR_QUERY_LDP_STP_N', don't hardcode mode and use\n+\t'true' rather than '1'.\n+\t* gcc/config/aarch64/constraints.md (Uml): Likewise.\n+\t(Uml): Rename to Umn.\n+\t(Umq): Remove.\n+\n 2018-07-19  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.h (struct vn_phi_s): Make phiargs member"}, {"sha": "5d07583cce34813654b84f597269fab6b265413c", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=a25831acf41c58705f250b529684a5c2deaa63d6", "patch": "@@ -120,6 +120,10 @@ enum aarch64_symbol_type\n    ADDR_QUERY_LDP_STP\n       Query what is valid for a load/store pair.\n \n+   ADDR_QUERY_LDP_STP_N\n+      Query what is valid for a load/store pair, but narrow the incoming mode\n+      for address checking.  This is used for the store_pair_lanes patterns.\n+\n    ADDR_QUERY_ANY\n       Query what is valid for at least one memory constraint, which may\n       allow things that \"m\" doesn't.  For example, the SVE LDR and STR\n@@ -128,6 +132,7 @@ enum aarch64_symbol_type\n enum aarch64_addr_query_type {\n   ADDR_QUERY_M,\n   ADDR_QUERY_LDP_STP,\n+  ADDR_QUERY_LDP_STP_N,\n   ADDR_QUERY_ANY\n };\n "}, {"sha": "f1784d72e55c412d076de43f2f7aad4632d55ecb", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=a25831acf41c58705f250b529684a5c2deaa63d6", "patch": "@@ -131,7 +131,7 @@\n \n (define_insn \"*aarch64_simd_mov<VQ:mode>\"\n   [(set (match_operand:VQ 0 \"nonimmediate_operand\"\n-\t\t\"=w, Umq,  m,  w, ?r, ?w, ?r, w\")\n+\t\t\"=w, Umn,  m,  w, ?r, ?w, ?r, w\")\n \t(match_operand:VQ 1 \"general_operand\"\n \t\t\"m,  Dz, w,  w,  w,  r,  r, Dn\"))]\n   \"TARGET_SIMD\n@@ -3088,7 +3088,7 @@\n )\n \n (define_insn \"store_pair_lanes<mode>\"\n-  [(set (match_operand:<VDBL> 0 \"aarch64_mem_pair_lanes_operand\" \"=Uml, Uml\")\n+  [(set (match_operand:<VDBL> 0 \"aarch64_mem_pair_lanes_operand\" \"=Umn, Umn\")\n \t(vec_concat:<VDBL>\n \t   (match_operand:VDC 1 \"register_operand\" \"w, r\")\n \t   (match_operand:VDC 2 \"register_operand\" \"w, r\")))]"}, {"sha": "046195c8262fadf9aac3738426e7816d8b7a7827", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a25831acf41c58705f250b529684a5c2deaa63d6", "patch": "@@ -206,7 +206,8 @@ static bool aarch64_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t\t\t int misalignment,\n \t\t\t\t\t\t\t bool is_packed);\n static machine_mode aarch64_simd_container_mode (scalar_mode, poly_int64);\n-static bool aarch64_print_ldpstp_address (FILE *, machine_mode, rtx);\n+static bool aarch64_print_address_internal (FILE*, machine_mode, rtx,\n+\t\t\t\t\t    aarch64_addr_query_type);\n \n /* Major revision number of the ARM Architecture implemented by the target.  */\n unsigned aarch64_architecture_version;\n@@ -5742,10 +5743,18 @@ aarch64_classify_address (struct aarch64_address_info *info,\n   unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n   bool advsimd_struct_p = (vec_flags == (VEC_ADVSIMD | VEC_STRUCT));\n   bool load_store_pair_p = (type == ADDR_QUERY_LDP_STP\n+\t\t\t    || type == ADDR_QUERY_LDP_STP_N\n \t\t\t    || mode == TImode\n \t\t\t    || mode == TFmode\n \t\t\t    || (BYTES_BIG_ENDIAN && advsimd_struct_p));\n \n+  /* If we are dealing with ADDR_QUERY_LDP_STP_N that means the incoming mode\n+     corresponds to the actual size of the memory being loaded/stored and the\n+     mode of the corresponding addressing mode is half of that.  */\n+  if (type == ADDR_QUERY_LDP_STP_N\n+      && known_eq (GET_MODE_SIZE (mode), 16))\n+    mode = DFmode;\n+\n   bool allow_reg_index_p = (!load_store_pair_p\n \t\t\t    && (known_lt (GET_MODE_SIZE (mode), 16)\n \t\t\t\t|| vec_flags == VEC_ADVSIMD\n@@ -7122,13 +7131,10 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n \t    return;\n \t  }\n \n-\tif (code == 'y')\n-\t  /* LDP/STP which uses a single double-width memory operand.\n-\t     Adjust the mode to appear like a typical LDP/STP.\n-\t     Currently this is supported for 16-byte accesses only.  */\n-\t  mode = DFmode;\n-\n-\tif (!aarch64_print_ldpstp_address (f, mode, XEXP (x, 0)))\n+\tif (!aarch64_print_address_internal (f, mode, XEXP (x, 0),\n+\t\t\t\t\t    code == 'y'\n+\t\t\t\t\t    ? ADDR_QUERY_LDP_STP_N\n+\t\t\t\t\t    : ADDR_QUERY_LDP_STP))\n \t  output_operand_lossage (\"invalid operand prefix '%%%c'\", code);\n       }\n       break;\n@@ -7251,13 +7257,6 @@ aarch64_print_address_internal (FILE *f, machine_mode mode, rtx x,\n   return false;\n }\n \n-/* Print address 'x' of a LDP/STP with mode 'mode'.  */\n-static bool\n-aarch64_print_ldpstp_address (FILE *f, machine_mode mode, rtx x)\n-{\n-  return aarch64_print_address_internal (f, mode, x, ADDR_QUERY_LDP_STP);\n-}\n-\n /* Print address 'x' of a memory access with mode 'mode'.  */\n static void\n aarch64_print_operand_address (FILE *f, machine_mode mode, rtx x)"}, {"sha": "72cacdabdac52dcb40b480f7a5bfbf4997c742d8", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=a25831acf41c58705f250b529684a5c2deaa63d6", "patch": "@@ -218,29 +218,23 @@\n  (and (match_code \"mem\")\n       (match_test \"REG_P (XEXP (op, 0))\")))\n \n-(define_memory_constraint \"Umq\"\n-  \"@internal\n-   A memory address which uses a base register with an offset small enough for\n-   a load/store pair operation in DI mode.\"\n-   (and (match_code \"mem\")\n-\t(match_test \"aarch64_legitimate_address_p (DImode, XEXP (op, 0), false,\n-\t\t\t\t\t\t   ADDR_QUERY_LDP_STP)\")))\n-\n (define_memory_constraint \"Ump\"\n   \"@internal\n   A memory address suitable for a load/store pair operation.\"\n   (and (match_code \"mem\")\n        (match_test \"aarch64_legitimate_address_p (GET_MODE (op), XEXP (op, 0),\n \t\t\t\t\t\t  true, ADDR_QUERY_LDP_STP)\")))\n \n-;; Used for storing two 64-bit values in an AdvSIMD register using an STP\n-;; as a 128-bit vec_concat.\n-(define_memory_constraint \"Uml\"\n+;; Used for storing or loading pairs in an AdvSIMD register using an STP/LDP\n+;; as a vector-concat.  The address mode uses the same constraints as if it\n+;; were for a single value.\n+(define_memory_constraint \"Umn\"\n   \"@internal\n   A memory address suitable for a load/store pair operation.\"\n   (and (match_code \"mem\")\n-       (match_test \"aarch64_legitimate_address_p (DFmode, XEXP (op, 0), 1,\n-\t\t\t\t\t\t  ADDR_QUERY_LDP_STP)\")))\n+       (match_test \"aarch64_legitimate_address_p (GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t\t  true,\n+\t\t\t\t\t\t  ADDR_QUERY_LDP_STP_N)\")))\n \n (define_memory_constraint \"Utr\"\n   \"@internal"}, {"sha": "b5a3ee4e1473dc355c3957a2fca0166f835e727f", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25831acf41c58705f250b529684a5c2deaa63d6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=a25831acf41c58705f250b529684a5c2deaa63d6", "patch": "@@ -226,8 +226,9 @@\n ;; as a 128-bit vec_concat.\n (define_predicate \"aarch64_mem_pair_lanes_operand\"\n   (and (match_code \"mem\")\n-       (match_test \"aarch64_legitimate_address_p (DFmode, XEXP (op, 0), 1,\n-\t\t\t\t\t\t  ADDR_QUERY_LDP_STP)\")))\n+       (match_test \"aarch64_legitimate_address_p (GET_MODE (op), XEXP (op, 0),\n+\t\t\t\t\t\t  true,\n+\t\t\t\t\t\t  ADDR_QUERY_LDP_STP_N)\")))\n \n (define_predicate \"aarch64_prefetch_operand\"\n   (match_test \"aarch64_address_valid_for_prefetch_p (op, false)\"))"}]}