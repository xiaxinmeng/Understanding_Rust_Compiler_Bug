{"sha": "ee4eee0a542378923db1978ac6cee9fe1dfd693e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU0ZWVlMGE1NDIzNzg5MjNkYjE5NzhhYzZjZWU5ZmUxZGZkNjkzZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T10:06:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T10:06:00Z"}, "message": "[multiple changes]\n\n2014-07-18  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb, g-memdum.ads, i-cstrea.ads: Minor reformatting.\n\n2014-07-18  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb (Has_Static_Predicate): New function.\n\t(Set_Has_Static_Predicate): New procedure.\n\t* einfo.ads (Has_Static_Predicate): New flag.\n\t* sem_ch13.adb (Is_Predicate_Static): New function\n\t(Build_Predicate_Functions): Use Is_Predicate_Static to reorganize\n\t(Add_Call): Minor change in Sloc of generated expression\n\t(Add_Predicates): Remove setting of Static_Pred, no longer used.\n\t* sem_ch4.adb (Has_Static_Predicate): Removed this function,\n\treplace by use of the entity flag Has_Static_Predicate_Aspect.\n\t* sem_eval.adb (Eval_Static_Predicate_Check): Check real case\n\tand issue warning that predicate is not checked for now.\n\t* sem_eval.ads (Eval_Static_Predicate_Check): Fix comments in\n\tspec.\n\t* sem_util.adb (Check_Expression_Against_Static_Predicate):\n\tCarry out check for any case where there is a static predicate,\n\tand output appropriate message.\n\t* sinfo.ads: Minor comment corrections.\n\n2014-07-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Expand_Freeze_Record_Type): If the type is derived\n\tfrom an untagged private type whose full view is tagged, the type\n\tis marked tagged for layout reasons, but it has no dispatch table,\n\tso Set_All_DT_Position must not be called.\n\t* exp_ch13.adb: If the freeze node is for a type internal to a\n\trecord declaration, as is the case for a class-wide subtype\n\tof a parent component, the relevant scope is the scope of the\n\tenclosing record.\n\nFrom-SVN: r212804", "tree": {"sha": "8944821564e7f6c276ac0ab7ce725cb86bbac4f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8944821564e7f6c276ac0ab7ce725cb86bbac4f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee4eee0a542378923db1978ac6cee9fe1dfd693e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee4eee0a542378923db1978ac6cee9fe1dfd693e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee4eee0a542378923db1978ac6cee9fe1dfd693e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee4eee0a542378923db1978ac6cee9fe1dfd693e/comments", "author": null, "committer": null, "parents": [{"sha": "3b8481cb9a266deed774ae75d579b7243c3f1cc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8481cb9a266deed774ae75d579b7243c3f1cc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8481cb9a266deed774ae75d579b7243c3f1cc4"}], "stats": {"total": 768, "additions": 543, "deletions": 225}, "files": [{"sha": "d6a5c0af5ee56b93d67fff98460ef4bbe30cb40f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -1,3 +1,38 @@\n+2014-07-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb, g-memdum.ads, i-cstrea.ads: Minor reformatting.\n+\n+2014-07-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb (Has_Static_Predicate): New function.\n+\t(Set_Has_Static_Predicate): New procedure.\n+\t* einfo.ads (Has_Static_Predicate): New flag.\n+\t* sem_ch13.adb (Is_Predicate_Static): New function\n+\t(Build_Predicate_Functions): Use Is_Predicate_Static to reorganize\n+\t(Add_Call): Minor change in Sloc of generated expression\n+\t(Add_Predicates): Remove setting of Static_Pred, no longer used.\n+\t* sem_ch4.adb (Has_Static_Predicate): Removed this function,\n+\treplace by use of the entity flag Has_Static_Predicate_Aspect.\n+\t* sem_eval.adb (Eval_Static_Predicate_Check): Check real case\n+\tand issue warning that predicate is not checked for now.\n+\t* sem_eval.ads (Eval_Static_Predicate_Check): Fix comments in\n+\tspec.\n+\t* sem_util.adb (Check_Expression_Against_Static_Predicate):\n+\tCarry out check for any case where there is a static predicate,\n+\tand output appropriate message.\n+\t* sinfo.ads: Minor comment corrections.\n+\n+2014-07-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_Freeze_Record_Type): If the type is derived\n+\tfrom an untagged private type whose full view is tagged, the type\n+\tis marked tagged for layout reasons, but it has no dispatch table,\n+\tso Set_All_DT_Position must not be called.\n+\t* exp_ch13.adb: If the freeze node is for a type internal to a\n+\trecord declaration, as is the case for a class-wide subtype\n+\tof a parent component, the relevant scope is the scope of the\n+\tenclosing record.\n+\n 2014-07-18  Thomas Quinot  <quinot@adacore.com>\n \n \t* g-memdum.adb, g-memdum.ads: Code clean ups."}, {"sha": "39342a1e2765f337b40ad3bb38eb8bf5c9640d0a", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -415,7 +415,7 @@ package body Einfo is\n    --    Has_Aliased_Components          Flag135\n    --    No_Strict_Aliasing              Flag136\n    --    Is_Machine_Code_Subprogram      Flag137\n-   --    Is_Packed_Array_Impl_Type            Flag138\n+   --    Is_Packed_Array_Impl_Type       Flag138\n    --    Has_Biased_Representation       Flag139\n    --    Has_Complex_Representation      Flag140\n \n@@ -559,12 +559,12 @@ package body Einfo is\n    --    SPARK_Aux_Pragma_Inherited      Flag266\n    --    Has_Shift_Operator              Flag267\n    --    Is_Independent                  Flag268\n+   --    Has_Static_Predicate            Flag269\n \n    --    (unused)                        Flag1\n    --    (unused)                        Flag2\n    --    (unused)                        Flag3\n \n-   --    (unused)                        Flag269\n    --    (unused)                        Flag270\n \n    --    (unused)                        Flag271\n@@ -1719,6 +1719,12 @@ package body Einfo is\n       return Flag211 (Id);\n    end Has_Static_Discriminants;\n \n+   function Has_Static_Predicate (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag269 (Id);\n+   end Has_Static_Predicate;\n+\n    function Has_Static_Predicate_Aspect (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -4436,6 +4442,12 @@ package body Einfo is\n       Set_Flag211 (Id, V);\n    end Set_Has_Static_Discriminants;\n \n+   procedure Set_Has_Static_Predicate (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag269 (Id, V);\n+   end Set_Has_Static_Predicate;\n+\n    procedure Set_Has_Static_Predicate_Aspect (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -8243,6 +8255,7 @@ package body Einfo is\n       W (\"Has_Specified_Stream_Read\",       Flag192 (Id));\n       W (\"Has_Specified_Stream_Write\",      Flag193 (Id));\n       W (\"Has_Static_Discriminants\",        Flag211 (Id));\n+      W (\"Has_Static_Predicate\",            Flag269 (Id));\n       W (\"Has_Static_Predicate_Aspect\",     Flag259 (Id));\n       W (\"Has_Storage_Size_Clause\",         Flag23  (Id));\n       W (\"Has_Stream_Size_Clause\",          Flag184 (Id));\n@@ -8325,7 +8338,7 @@ package body Einfo is\n       W (\"Is_Optional_Parameter\",           Flag134 (Id));\n       W (\"Is_Package_Body_Entity\",          Flag160 (Id));\n       W (\"Is_Packed\",                       Flag51  (Id));\n-      W (\"Is_Packed_Array_Impl_Type\",            Flag138 (Id));\n+      W (\"Is_Packed_Array_Impl_Type\",       Flag138 (Id));\n       W (\"Is_Potentially_Use_Visible\",      Flag9   (Id));\n       W (\"Is_Predicate_Function\",           Flag255 (Id));\n       W (\"Is_Predicate_Function_M\",         Flag256 (Id));"}, {"sha": "73ec037fc80eec8b01cf9c49f6c18d5521d0c822", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -1511,11 +1511,18 @@ package Einfo is\n \n --    Has_Dynamic_Predicate_Aspect (Flag258)\n --       Defined in all types and subtypes. Set if a Dynamic_Predicate aspect\n---       applies to the type. Note that we can tell if a dynamic predicate is\n---       present by looking at Has_Predicates and Static_Predicate, but that\n---       could have come from a Predicate aspect or pragma, and we need to\n---       record the difference so that we can use the right set of check\n---       policies to figure out if the predicate is active.\n+--       was explicitly applied to the type. Generally we treat predicates as\n+--       static if possible, regardless of whether they are specified using\n+--       Predicate, Static_Predicate, or Dynamic_Predicate. And if a predicate\n+--       can be treated as static (i.e. its expression is predicate-static),\n+--       then the flag Has_Static_Predicate will be set True. But there are\n+--       cases where legality is affected by the presence of an explicit\n+--       Dynamic_Predicate aspect. For example, even if a predicate looks\n+--       static, you can't use it in a case statement if there is an explicit\n+--       Dynamic_Predicate aspect specified. So test Has_Static_Predicate if\n+--       you just want to know if the predicate can be evaluated statically,\n+--       but test Has_Dynamic_Predicate_Aspect to enforce legality rules about\n+--       the use of dynamic predicates.\n \n --    Has_Entries (synthesized)\n --       Applies to concurrent types. True if any entries are declared\n@@ -1870,13 +1877,23 @@ package Einfo is\n --       case of a variant record, the component list can be trimmed down to\n --       include only the components corresponding to these discriminants.\n \n+--    Has_Static_Predicate (Flag269)\n+--       Defined in all types and subtypes. Set if the type (which must be\n+--       a discrete, real, or string subtype) has a static predicate, i.e. a\n+--       predicate whose expression is predicate-static. This can result from\n+--       use of a Predicate, Static_Predicate or Dynamic_Predicate aspect. We\n+--       can distinguish these cases by testing Has_Static_Predicate_Aspect\n+--       and Has_Dynamic_Predicate_Aspect. See description of the latter flag\n+--       for further information on dynamic predicates which are also static.\n+\n --    Has_Static_Predicate_Aspect (Flag259)\n --       Defined in all types and subtypes. Set if a Static_Predicate aspect\n --       applies to the type. Note that we can tell if a static predicate is\n---       present by looking at Has_Predicates and Static_Predicate, but that\n---       could have come from a Predicate aspect or pragma, and we need to\n---       record the difference so that we can use the right set of check\n---       policies to figure out if the predicate is active.\n+--       present by looking at Has_Static_Predicate, but this could have come\n+--       from a Predicate aspect or pragma or even from a Dynamic_Predicate\n+--       aspect. When we need to know the difference (e.g. to know what set of\n+--       check policies apply, use this flag and Has_Dynamic_Predicate_Aspect\n+--       to determine which case we have.\n \n --    Has_Storage_Size_Clause (Flag23) [implementation base type only]\n --       Defined in task types and access types. It is set if a Storage_Size\n@@ -3873,15 +3890,15 @@ package Einfo is\n --       the corresponding parameter entities in the spec.\n \n --    Static_Predicate (List25)\n---       Defined in discrete types/subtypes with predicates (Has_Predicates\n---       set). Set if the type/subtype has a static predicate. Points to a\n---       list of expression and N_Range nodes that represent the predicate\n---       in canonical form. The canonical form has entries sorted in ascending\n---       order, with duplicates eliminated, and adjacent ranges coalesced, so\n---       that there is always a gap in the values between successive entries.\n---       The entries in this list are fully analyzed and typed with the base\n---       type of the subtype. Note that all entries are static and have values\n---       within the subtype range.\n+--       Defined in discrete types/subtypes with static predicates (with the\n+--       two flags Has_Predicates set and Has_Static_Predicate set). Set if the\n+--       type/subtype has a static predicate. Points to a list of expression\n+--       and N_Range nodes that represent the predicate in canonical form. The\n+--       canonical form has entries sorted in ascending order, with duplicates\n+--       eliminated, and adjacent ranges coalesced, so that there is always a\n+--       gap in the values between successive entries. The entries in this list\n+--       are fully analyzed and typed with the base type of the subtype. Note\n+--       that all entries are static and have values within the subtype range.\n \n --    Status_Flag_Or_Transient_Decl (Node15)\n --       Defined in variables and constants. Applies to objects that require\n@@ -5188,6 +5205,7 @@ package Einfo is\n    --    Has_Specified_Stream_Output         (Flag191)\n    --    Has_Specified_Stream_Read           (Flag192)\n    --    Has_Specified_Stream_Write          (Flag193)\n+   --    Has_Static_Predicate                (Flag269)\n    --    Has_Static_Predicate_Aspect         (Flag259)\n    --    Has_Task                            (Flag30)   (base type only)\n    --    Has_Unchecked_Union                 (Flag123)  (base type only)\n@@ -6540,6 +6558,7 @@ package Einfo is\n    function Has_Specified_Stream_Read           (Id : E) return B;\n    function Has_Specified_Stream_Write          (Id : E) return B;\n    function Has_Static_Discriminants            (Id : E) return B;\n+   function Has_Static_Predicate                (Id : E) return B;\n    function Has_Static_Predicate_Aspect         (Id : E) return B;\n    function Has_Storage_Size_Clause             (Id : E) return B;\n    function Has_Stream_Size_Clause              (Id : E) return B;\n@@ -7166,6 +7185,7 @@ package Einfo is\n    procedure Set_Has_Specified_Stream_Read       (Id : E; V : B := True);\n    procedure Set_Has_Specified_Stream_Write      (Id : E; V : B := True);\n    procedure Set_Has_Static_Discriminants        (Id : E; V : B := True);\n+   procedure Set_Has_Static_Predicate            (Id : E; V : B := True);\n    procedure Set_Has_Static_Predicate_Aspect     (Id : E; V : B := True);\n    procedure Set_Has_Storage_Size_Clause         (Id : E; V : B := True);\n    procedure Set_Has_Stream_Size_Clause          (Id : E; V : B := True);\n@@ -7905,6 +7925,7 @@ package Einfo is\n    pragma Inline (Has_Specified_Stream_Read);\n    pragma Inline (Has_Specified_Stream_Write);\n    pragma Inline (Has_Static_Discriminants);\n+   pragma Inline (Has_Static_Predicate);\n    pragma Inline (Has_Static_Predicate_Aspect);\n    pragma Inline (Has_Storage_Size_Clause);\n    pragma Inline (Has_Stream_Size_Clause);\n@@ -8378,6 +8399,7 @@ package Einfo is\n    pragma Inline (Set_Has_Specified_Stream_Read);\n    pragma Inline (Set_Has_Specified_Stream_Write);\n    pragma Inline (Set_Has_Static_Discriminants);\n+   pragma Inline (Set_Has_Static_Predicate);\n    pragma Inline (Set_Has_Static_Predicate_Aspect);\n    pragma Inline (Set_Has_Storage_Size_Clause);\n    pragma Inline (Set_Has_Stream_Size_Clause);"}, {"sha": "096365ccb40e7fe4b589777d986f931f88c536e4", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -443,6 +443,17 @@ package body Exp_Ch13 is\n          return;\n       end if;\n \n+      --  The entity may be a subtype declared for a constrained record\n+      --  component, in which case the relevant scope is the scope of\n+      --  the record. This happens for class-wide subtypes created for\n+      --  a constrained type extension with inherited discriminants.\n+\n+      if Is_Type (E_Scope)\n+        and then Ekind (E_Scope) not in Concurrent_Kind\n+      then\n+         E_Scope := Scope (E_Scope);\n+      end if;\n+\n       --  Remember that we are processing a freezing entity and its freezing\n       --  nodes. This flag (non-zero = set) is used to avoid the need of\n       --  climbing through the tree while processing the freezing actions (ie."}, {"sha": "b24a20439c3336d22b156249ff916899a8ed0f40", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 72, "deletions": 74, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -1356,7 +1356,7 @@ package body Exp_Ch3 is\n \n             elsif Is_Scalar_Type (Component_Type (Etype (Comp)))\n                and then\n-                 (not Compile_Time_Known_Value (Type_Low_Bound (Comp_Type))\n+                 (not Compile_Time_Known_Value (Type_Low_Bound  (Comp_Type))\n                    or else\n                   not Compile_Time_Known_Value (Type_High_Bound (Comp_Type)))\n             then\n@@ -1620,7 +1620,7 @@ package body Exp_Ch3 is\n                --  to the appropriate formal parameter.\n \n                if Nkind (Arg) = N_Identifier\n-                  and then Ekind (Entity (Arg)) = E_Discriminant\n+                 and then Ekind (Entity (Arg)) = E_Discriminant\n                then\n                   Arg := New_Occurrence_Of (Discriminal (Entity (Arg)), Loc);\n \n@@ -2042,7 +2042,7 @@ package body Exp_Ch3 is\n                --  Append it to the list\n \n                if Nkind (Arg) = N_Identifier\n-                  and then Ekind (Entity (Arg)) = E_Discriminant\n+                 and then Ekind (Entity (Arg)) = E_Discriminant\n                then\n                   Append_To (Args,\n                     New_Occurrence_Of (Discriminal (Entity (Arg)), Loc));\n@@ -2530,8 +2530,8 @@ package body Exp_Ch3 is\n \n                   Ins_Nod := First (Body_Stmts);\n                   while Present (Next (Ins_Nod))\n-                     and then (Nkind (Ins_Nod) /= N_Procedure_Call_Statement\n-                                or else not Is_Init_Proc (Name (Ins_Nod)))\n+                    and then (Nkind (Ins_Nod) /= N_Procedure_Call_Statement\n+                               or else not Is_Init_Proc (Name (Ins_Nod)))\n                   loop\n                      Next (Ins_Nod);\n                   end loop;\n@@ -3421,7 +3421,7 @@ package body Exp_Ch3 is\n             return False;\n \n          elsif (Has_Discriminants (Rec_Id)\n-                  and then not Is_Unchecked_Union (Rec_Id))\n+                 and then not Is_Unchecked_Union (Rec_Id))\n            or else Is_Tagged_Type (Rec_Id)\n            or else Is_Concurrent_Record_Type (Rec_Id)\n            or else Has_Task (Rec_Id)\n@@ -3595,9 +3595,7 @@ package body Exp_Ch3 is\n                Typ      : constant Entity_Id := Etype (Comp);\n \n             begin\n-               if Is_Array_Type (Typ)\n-                 and then Is_Itype (Typ)\n-               then\n+               if Is_Array_Type (Typ) and then Is_Itype (Typ) then\n                   Ref := Make_Itype_Reference (Loc);\n                   Set_Itype (Ref, Typ);\n                   Append_Freeze_Action (Rec_Type, Ref);\n@@ -3624,9 +3622,7 @@ package body Exp_Ch3 is\n             --  The aggregate may have been rewritten as a Raise node, in which\n             --  case there are no relevant itypes.\n \n-            if Present (Agg)\n-              and then Nkind (Agg) = N_Aggregate\n-            then\n+            if Present (Agg) and then Nkind (Agg) = N_Aggregate then\n                Set_Static_Initialization (Proc_Id, Agg);\n \n                declare\n@@ -5045,8 +5041,8 @@ package body Exp_Ch3 is\n         and then Is_Library_Level_Entity (Def_Id)\n         and then Is_Library_Level_Tagged_Type (Base_Typ)\n         and then (Ekind (Base_Typ) = E_Record_Type\n-                    or else Ekind (Base_Typ) = E_Protected_Type\n-                    or else Ekind (Base_Typ) = E_Task_Type)\n+                   or else Ekind (Base_Typ) = E_Protected_Type\n+                   or else Ekind (Base_Typ) = E_Task_Type)\n         and then not Has_Dispatch_Table (Base_Typ)\n       then\n          declare\n@@ -5186,17 +5182,17 @@ package body Exp_Ch3 is\n \n          if Has_Non_Null_Base_Init_Proc (Typ)\n \n-            --  Suppress call if No_Initialization set on declaration\n+           --  Suppress call if No_Initialization set on declaration\n \n-            and then not No_Initialization (N)\n+           and then not No_Initialization (N)\n \n-            --  Suppress call for special case of value type for VM\n+           --  Suppress call for special case of value type for VM\n \n-            and then not Is_Value_Type (Typ)\n+           and then not Is_Value_Type (Typ)\n \n-            --  Suppress call if initialization suppressed for the type\n+           --  Suppress call if initialization suppressed for the type\n \n-            and then not Initialization_Suppressed (Typ)\n+           and then not Initialization_Suppressed (Typ)\n          then\n             --  Return without initializing when No_Default_Initialization\n             --  applies. Note that the actual restriction check occurs later,\n@@ -5346,8 +5342,7 @@ package body Exp_Ch3 is\n \n            and then not\n              (Nkind (Obj_Def) = N_Identifier\n-               and then\n-                 Present (Equivalent_Type (Entity (Obj_Def))))\n+               and then Present (Equivalent_Type (Entity (Obj_Def))))\n          then\n             pragma Assert (Is_Class_Wide_Type (Typ));\n \n@@ -5357,9 +5352,7 @@ package body Exp_Ch3 is\n             --  case, the expansion of the return statement will take care of\n             --  creating the object (via allocator) and initializing it.\n \n-            if Is_Return_Object (Def_Id)\n-              and then Is_Limited_View (Typ)\n-            then\n+            if Is_Return_Object (Def_Id) and then Is_Limited_View (Typ) then\n                null;\n \n             elsif Tagged_Type_Expansion then\n@@ -5417,24 +5410,23 @@ package body Exp_Ch3 is\n                     and then Interface_Present_In_Ancestor (Expr_Typ, Typ)\n                     and then (Expr_Typ = Etype (Expr_Typ)\n                                or else not\n-                              Is_Variable_Size_Record (Etype (Expr_Typ)))\n+                                 Is_Variable_Size_Record (Etype (Expr_Typ)))\n                   then\n                      --  Copy the object\n \n                      Insert_Action (N,\n                        Make_Object_Declaration (Loc,\n                          Defining_Identifier => Obj_Id,\n-                         Object_Definition =>\n+                         Object_Definition   =>\n                            New_Occurrence_Of (Expr_Typ, Loc),\n-                         Expression =>\n-                           Relocate_Node (Expr_N)));\n+                         Expression          => Relocate_Node (Expr_N)));\n \n                      --  Statically reference the tag associated with the\n                      --  interface\n \n                      Tag_Comp :=\n                        Make_Selected_Component (Loc,\n-                         Prefix => New_Occurrence_Of (Obj_Id, Loc),\n+                         Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n                          Selector_Name =>\n                            New_Occurrence_Of\n                              (Find_Interface_Tag (Expr_Typ, Iface), Loc));\n@@ -5747,10 +5739,10 @@ package body Exp_Ch3 is\n          --  is too much trouble ???\n \n          if (Is_Possibly_Unaligned_Slice (Expr)\n-               or else (Is_Possibly_Unaligned_Object (Expr)\n-                          and then not Represented_As_Scalar (Etype (Expr))))\n+              or else (Is_Possibly_Unaligned_Object (Expr)\n+                        and then not Represented_As_Scalar (Etype (Expr))))\n            and then not (Is_Array_Type (Etype (Expr))\n-                           and then not Is_Constrained (Etype (Expr)))\n+                          and then not Is_Constrained (Etype (Expr)))\n          then\n             declare\n                Stat : constant Node_Id :=\n@@ -6053,9 +6045,9 @@ package body Exp_Ch3 is\n             if Is_Itype (Base)\n               and then Nkind (Associated_Node_For_Itype (Base)) =\n                                                     N_Object_Declaration\n-              and then (Present (Expression (Associated_Node_For_Itype (Base)))\n-                          or else\n-                        No_Initialization (Associated_Node_For_Itype (Base)))\n+              and then\n+                (Present (Expression (Associated_Node_For_Itype (Base)))\n+                  or else No_Initialization (Associated_Node_For_Itype (Base)))\n             then\n                null;\n \n@@ -6064,7 +6056,7 @@ package body Exp_Ch3 is\n             --  initialize scalars mode, and these types are treated specially\n             --  and do not need initialization procedures.\n \n-            elsif Root_Type (Base) = Standard_String\n+            elsif     Root_Type (Base) = Standard_String\n               or else Root_Type (Base) = Standard_Wide_String\n               or else Root_Type (Base) = Standard_Wide_Wide_String\n             then\n@@ -6108,7 +6100,7 @@ package body Exp_Ch3 is\n       --  Normalize_Scalars and there better be a public Init_Proc for it.\n \n       elsif (Present (Init_Proc (Component_Type (Base)))\n-               and then No (Base_Init_Proc (Base)))\n+              and then No (Base_Init_Proc (Base)))\n         or else (Init_Or_Norm_Scalars and then Base = Typ)\n         or else Is_Public (Typ)\n       then\n@@ -6765,6 +6757,16 @@ package body Exp_Ch3 is\n               or else Is_Tagged_Type (Etype (Def_Id))\n             then\n                Set_All_DT_Position (Def_Id);\n+\n+            --  If this is a type derived from an untagged private type whose\n+            --  full view is tagged, the type is marked tagged for layout\n+            --  reasons, but it has no dispatch table.\n+\n+            elsif Is_Derived_Type (Def_Id)\n+              and then Is_Private_Type (Etype (Def_Id))\n+              and then not Is_Tagged_Type (Etype (Def_Id))\n+            then\n+               return;\n             end if;\n \n             --  Create and decorate the tags. Suppress their creation when\n@@ -6925,16 +6927,16 @@ package body Exp_Ch3 is\n       if Is_Tagged_Type (Def_Id)\n         and then not Is_Interface (Def_Id)\n       then\n-         --  Do not add the body of predefined primitives in case of\n-         --  CPP tagged type derivations that have convention CPP.\n+         --  Do not add the body of predefined primitives in case of CPP tagged\n+         --  type derivations that have convention CPP.\n \n          if Is_CPP_Class (Root_Type (Def_Id))\n            and then Convention (Def_Id) = Convention_CPP\n          then\n             null;\n \n-         --  Do not add the body of predefined primitives in case of\n-         --  CIL and Java tagged types.\n+         --  Do not add the body of predefined primitives in case of CIL and\n+         --  Java tagged types.\n \n          elsif Convention (Def_Id) = Convention_CIL\n            or else Convention (Def_Id) = Convention_Java\n@@ -7087,8 +7089,8 @@ package body Exp_Ch3 is\n          end;\n       end if;\n \n-      --  Check whether individual components have a defined invariant,\n-      --  and add the corresponding component invariant checks.\n+      --  Check whether individual components have a defined invariant, and add\n+      --  the corresponding component invariant checks.\n \n       Insert_Component_Invariant_Checks\n         (N, Def_Id, Build_Record_Invariant_Proc (Def_Id, N));\n@@ -7569,16 +7571,16 @@ package body Exp_Ch3 is\n    --  Start of processing for Get_Simple_Init_Val\n \n    begin\n-      --  For a private type, we should always have an underlying type\n-      --  (because this was already checked in Needs_Simple_Initialization).\n-      --  What we do is to get the value for the underlying type and then do\n-      --  an Unchecked_Convert to the private type.\n+      --  For a private type, we should always have an underlying type (because\n+      --  this was already checked in Needs_Simple_Initialization). What we do\n+      --  is to get the value for the underlying type and then do an unchecked\n+      --  conversion to the private type.\n \n       if Is_Private_Type (T) then\n          Val := Get_Simple_Init_Val (Underlying_Type (T), N, Size);\n \n          --  A special case, if the underlying value is null, then qualify it\n-         --  with the underlying type, so that the null is properly typed\n+         --  with the underlying type, so that the null is properly typed.\n          --  Similarly, if it is an aggregate it must be qualified, because an\n          --  unchecked conversion does not provide a context for it.\n \n@@ -7603,7 +7605,7 @@ package body Exp_Ch3 is\n          return Result;\n \n       --  Scalars with Default_Value aspect. The first subtype may now be\n-      --   private, so retrieve value from underlying type.\n+      --  private, so retrieve value from underlying type.\n \n       elsif Is_Scalar_Type (T) and then Has_Default_Aspect (T) then\n          if Is_Private_Type (First_Subtype (T)) then\n@@ -7841,9 +7843,10 @@ package body Exp_Ch3 is\n       else\n          return First_Rep_Item (T) /= First_Rep_Item (Root_Type (T));\n \n-         --  May need a more precise check here: the First_Rep_Item may\n-         --  be a stream attribute, which does not affect the representation\n-         --  of the type ???\n+         --  May need a more precise check here: the First_Rep_Item may be a\n+         --  stream attribute, which does not affect the representation of the\n+         --  type ???\n+\n       end if;\n    end Has_New_Non_Standard_Rep;\n \n@@ -7955,7 +7958,7 @@ package body Exp_Ch3 is\n                         if Ekind (Comp) = E_Discriminant\n                           or else\n                             (Nkind (Parent (Comp)) = N_Component_Declaration\n-                               and then Present (Expression (Parent (Comp))))\n+                              and then Present (Expression (Parent (Comp))))\n                         then\n                            Warning_Needed := True;\n                            exit;\n@@ -7988,10 +7991,10 @@ package body Exp_Ch3 is\n       Formals : List_Id;\n \n    begin\n-      --  First parameter is always _Init : in out typ. Note that we need\n-      --  this to be in/out because in the case of the task record value,\n-      --  there are default record fields (_Priority, _Size, -Task_Info)\n-      --  that may be referenced in the generated initialization routine.\n+      --  First parameter is always _Init : in out typ. Note that we need this\n+      --  to be in/out because in the case of the task record value, there\n+      --  are default record fields (_Priority, _Size, -Task_Info) that may\n+      --  be referenced in the generated initialization routine.\n \n       Formals := New_List (\n         Make_Parameter_Specification (Loc,\n@@ -8085,8 +8088,7 @@ package body Exp_Ch3 is\n          Offset_To_Top_Comp : Entity_Id := Empty;\n \n       begin\n-         --  Initialize the pointer to the secondary DT associated with the\n-         --  interface.\n+         --  Initialize pointer to secondary DT associated with the interface\n \n          if not Is_Ancestor (Iface, Typ, Use_Full_View => True) then\n             Append_To (Stmts_List,\n@@ -8157,8 +8159,8 @@ package body Exp_Ch3 is\n                                   (DT_Offset_To_Top_Func (Tag_Comp), Loc),\n                       Attribute_Name => Name_Address)))));\n \n-            --  In this case the next component stores the value of the\n-            --  offset to the top.\n+            --  In this case the next component stores the value of the offset\n+            --  to the top.\n \n             Offset_To_Top_Comp := Next_Entity (Tag_Comp);\n             pragma Assert (Present (Offset_To_Top_Comp));\n@@ -8304,11 +8306,11 @@ package body Exp_Ch3 is\n                      then\n                         exit when\n                           (Is_Record_Type (Comp_Typ)\n-                             and then Is_Variable_Size_Record\n-                                        (Base_Type (Comp_Typ)))\n+                            and then Is_Variable_Size_Record\n+                                       (Base_Type (Comp_Typ)))\n                          or else\n                            (Is_Array_Type (Comp_Typ)\n-                              and then Is_Variable_Size_Array (Comp_Typ));\n+                             and then Is_Variable_Size_Array (Comp_Typ));\n                      end if;\n \n                      Next_Entity (Comp);\n@@ -8892,9 +8894,7 @@ package body Exp_Ch3 is\n          while Present (Elmt) loop\n             Prim := Node (Elmt);\n \n-            if Is_User_Defined_Equality (Prim)\n-              and then No (Alias (Prim))\n-            then\n+            if Is_User_Defined_Equality (Prim) and then No (Alias (Prim)) then\n                if No (Renaming_Prim) then\n                   pragma Assert (No (Eq_Prim));\n                   Eq_Prim := Prim;\n@@ -9489,9 +9489,9 @@ package body Exp_Ch3 is\n \n       elsif Consider_IS_NS\n         and then\n-          (Root_Type (T) = Standard_String\n-             or else Root_Type (T) = Standard_Wide_String\n-             or else Root_Type (T) = Standard_Wide_Wide_String)\n+          (Root_Type (T) = Standard_String      or else\n+           Root_Type (T) = Standard_Wide_String or else\n+           Root_Type (T) = Standard_Wide_Wide_String)\n         and then\n           (not Is_Itype (T)\n             or else Nkind (Associated_Node_For_Itype (T)) /= N_Aggregate)\n@@ -9971,9 +9971,7 @@ package body Exp_Ch3 is\n       --  attribute has been specified or Write (resp. Read) is available for\n       --  an ancestor type. The last condition only applies under Ada 2005.\n \n-      if Is_Limited_Type (Typ)\n-        and then Is_Tagged_Type (Typ)\n-      then\n+      if Is_Limited_Type (Typ) and then Is_Tagged_Type (Typ) then\n          if Operation = TSS_Stream_Read then\n             Has_Predefined_Or_Specified_Stream_Attribute :=\n               Has_Specified_Stream_Read (Typ);"}, {"sha": "0d56e2189e93bf01e4dff211e9271a417d6a1838", "filename": "gcc/ada/g-memdum.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fg-memdum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fg-memdum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-memdum.ads?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -49,9 +49,9 @@ package GNAT.Memory_Dump is\n    --  like the AAMP, where the storage unit is not 8 bits). The output is one\n    --  or more lines in the following format, which is for the case of 32-bit\n    --  addresses (64-bit addresses are handled appropriately):\n-\n+   --\n    --    0234_3368: 66 67 68 . . .  73 74 75 \"fghijklmnopqstuv\"\n-\n+   --\n    --  All but the last line have 16 bytes. A question mark is used in the\n    --  string data to indicate a non-printable character.\n \n@@ -63,15 +63,15 @@ package GNAT.Memory_Dump is\n    --  If Prefix is set to Absolute_Address, the output is identical to the\n    --  above version, each line starting with the absolute address of the\n    --  first dumped storage element.\n-\n+   --\n    --  If Prefix is set to Offset, then instead each line starts with the\n    --  indication of the offset relative to Addr:\n-\n+   --\n    --    00: 66 67 68 . . .  73 74 75 \"fghijklmnopqstuv\"\n-\n+   --\n    --  Finally if Prefix is set to None, the prefix is suppressed altogether,\n    --  and only the memory contents are displayed:\n-\n+   --\n    --    66 67 68 . . .  73 74 75 \"fghijklmnopqstuv\"\n \n end GNAT.Memory_Dump;"}, {"sha": "ed2a5593ade7caec695374e5ef9036a608e9f0dd", "filename": "gcc/ada/i-cstrea.ads", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fi-cstrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fi-cstrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrea.ads?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -221,21 +221,18 @@ package Interfaces.C_Streams is\n    -- Control of Text/Binary Mode --\n    ---------------------------------\n \n-   --  If text_translation_required is true, then the following functions may\n-   --  be used to dynamically switch a file from binary to text mode or vice\n-   --  versa. These functions have no effect if text_translation_required is\n-   --  false (i.e. in normal unix mode). Use fileno to get a stream handle.\n-\n    procedure set_binary_mode (handle : int);\n    procedure set_text_mode   (handle : int);\n-\n-   --  set_wide_text_mode is as set_text_mode but switches the translation to\n-   --  16-bit wide-character instead of 8-bit character. Again, this routine\n-   --  has no effect if text_translation_required is false. On Windows this\n-   --  is used to have proper 16-bit wide-string output on the console for\n-   --  example.\n+   --  If text_translation_required is true, then these two functions may\n+   --  be used to dynamically switch a file from binary to text mode or vice\n+   --  versa. These functions have no effect if text_translation_required is\n+   --  false (e.g. in normal unix mode). Use fileno to get a stream handle.\n \n    procedure set_wide_text_mode (handle : int);\n+   --  This is similar to set_text_mode but switches the translation to 16-bit\n+   --  wide-character instead of 8-bit character. Again, this routine has no\n+   --  effect if text_translation_required is false. On Windows this is used\n+   --  to have proper 16-bit wide-string output on the console for example.\n \n    ----------------------------\n    -- Full Path Name support --"}, {"sha": "de0fe2c1f84ba015841be0802a47ce57d12f7dd9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 298, "deletions": 49, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -134,6 +134,34 @@ package body Sem_Ch13 is\n    --  that do not specify a representation characteristic are operational\n    --  attributes.\n \n+   function Is_Predicate_Static\n+     (Expr : Node_Id;\n+      Nam  : Name_Id) return Boolean;\n+   --  Given predicate expression Expr, tests if Expr is predicate-static in\n+   --  the sense of the rules in (RM 3.2.4 (15-24)). Occurrences of the type\n+   --  name in the predicate expression have been replaced by references to\n+   --  an identifier whose Chars field is Nam. This name is unique, so any\n+   --  identifier with Chars matching Nam must be a reference to the type.\n+   --  Returns True if the expression is predicate-static and False otherwise,\n+   --  but is not in the business of setting flags or issuing error messages.\n+   --\n+   --  Only scalar types can have static predicates, so False is always\n+   --  returned for non-scalar types.\n+   --\n+   --  Note: the RM seems to suggest that string types can also have static\n+   --  predicates. But that really makes lttle sense as very few useful\n+   --  predicates can be constructed for strings. Remember that:\n+   --\n+   --     \"ABC\" < \"DEF\"\n+   --\n+   --  is not a static expression. So even though the clearly faulty RM wording\n+   --  allows the following:\n+   --\n+   --     subtype S is String with Static_Predicate => S < \"DEF\"\n+   --\n+   --  We can't allow this, otherwise we have predicate-static applying to a\n+   --  larger class than static expressions, which was never intended.\n+\n    procedure New_Stream_Subprogram\n      (N    : Node_Id;\n       Ent  : Entity_Id;\n@@ -7509,9 +7537,6 @@ package body Sem_Ch13 is\n       Raise_Expression_Present : Boolean := False;\n       --  Set True if Expr has at least one Raise_Expression\n \n-      Static_Predic : Node_Id := Empty;\n-      --  Set to N_Pragma node for a static predicate if one is encountered\n-\n       procedure Add_Call (T : Entity_Id);\n       --  Includes a call to the predicate function for type T in Expr if T\n       --  has predicates and Predicate_Function (T) is non-empty.\n@@ -7557,9 +7582,10 @@ package body Sem_Ch13 is\n \n             if No (Expr) then\n                Expr := Exp;\n+\n             else\n                Expr :=\n-                 Make_And_Then (Loc,\n+                 Make_And_Then (Sloc (Expr),\n                    Left_Opnd  => Relocate_Node (Expr),\n                    Right_Opnd => Exp);\n             end if;\n@@ -7630,16 +7656,6 @@ package body Sem_Ch13 is\n             if Nkind (Ritem) = N_Pragma\n               and then Pragma_Name (Ritem) = Name_Predicate\n             then\n-               --  Save the static predicate of the type for diagnostics and\n-               --  error reporting purposes.\n-\n-               if Present (Corresponding_Aspect (Ritem))\n-                 and then Chars (Identifier (Corresponding_Aspect (Ritem))) =\n-                            Name_Static_Predicate\n-               then\n-                  Static_Predic := Ritem;\n-               end if;\n-\n                --  Acquire arguments\n \n                Arg1 := First (Pragma_Argument_Associations (Ritem));\n@@ -7963,51 +7979,80 @@ package body Sem_Ch13 is\n             end;\n          end if;\n \n-         if Is_Discrete_Type (Typ) then\n+         --  See if we have a static predicate. Note that the answer may be\n+         --  yes even if we have an explicit Dynamic_Predicate present.\n \n-            --  Attempt to build a static predicate for a discrete subtype.\n-            --  This action may fail because the actual expression may not be\n-            --  static. Note that the presence of an inherited or explicitly\n-            --  declared dynamic predicate is orthogonal to this check because\n-            --  we are only interested in the static predicate.\n+         declare\n+            PS : constant Boolean := Is_Predicate_Static (Expr, Object_Name);\n+            EN : Node_Id;\n \n-            Build_Discrete_Static_Predicate (Typ, Expr, Object_Name);\n+         begin\n+            --  Case where we have a predicate static aspect\n \n-            --  Emit an error when the predicate is categorized as static\n-            --  but its expression is dynamic.\n+            if PS then\n \n-            if Present (Static_Predic)\n-              and then No (Static_Predicate (Typ))\n-            then\n-               Error_Msg_F\n-                 (\"expression does not have required form for \"\n-                  & \"static predicate\",\n-                  Next (First (Pragma_Argument_Associations\n-                    (Static_Predic))));\n-            end if;\n+               --  We don't set Has_Static_Predicate_Aspect, since we can have\n+               --  any of the three cases (Predicate, Dynamic_Predicate, or\n+               --  Static_Predicate) generating a predicate with an expression\n+               --  that is predicate static. We just indicate that we have a\n+               --  predicate that can be treated as static.\n \n-         --  If a static predicate applies on other types, that's an error:\n-         --  either the type is scalar but non-static, or it's not even a\n-         --  scalar type. We do not issue an error on generated types, as\n-         --  these may be duplicates of the same error on a source type.\n+               Set_Has_Static_Predicate (Typ);\n \n-         elsif Present (Static_Predic) and then Comes_From_Source (Typ) then\n-            if Is_Real_Type (Typ) then\n-               Error_Msg_FE\n-                 (\"static predicates not implemented for real type&\",\n-                  Typ, Typ);\n+               --  For discrete subtype, build the static predicate list\n \n-            elsif Is_Scalar_Type (Typ) then\n-               Error_Msg_FE\n-                 (\"static predicate not allowed for non-static type&\",\n-                  Typ, Typ);\n+               if Is_Discrete_Type (Typ) then\n+                  Build_Discrete_Static_Predicate (Typ, Expr, Object_Name);\n+\n+                  --  If we don't get a static predicate list, it means that we\n+                  --  have a case where this is not possible, most typically in\n+                  --  the case where we inherit a dynamic predicate. We do not\n+                  --  consider this an error, we just leave the predicate as\n+                  --  dynamic. But if we do succeed in building the list, then\n+                  --  we mark the predicate as static.\n+\n+                  if No (Static_Predicate (Typ)) then\n+                     Set_Has_Static_Predicate (Typ, False);\n+                  end if;\n+               end if;\n+\n+            --  Case of dynamic predicate (expression is not predicate-static)\n \n             else\n-               Error_Msg_FE\n-                 (\"static predicate not allowed for non-scalar type&\",\n-                  Typ, Typ);\n+               --  Again, we don't set Has_Dynamic_Predicate_Aspect, since that\n+               --  is only set if we have an explicit Dynamic_Predicate aspect\n+               --  given. Here we may simply have a Predicate aspect where the\n+               --  expression happens not to be predicate-static.\n+\n+               --  Emit an error when the predicate is categorized as static\n+               --  but its expression is not predicate-static.\n+\n+               --  First a little fiddling to get a nice location for the\n+               --  message. If the expression is of the form (A and then B),\n+               --  then use the left operand for the Sloc. This avoids getting\n+               --  confused by a call to a higher level predicate with a less\n+               --  convenient source location.\n+\n+               EN := Expr;\n+               while Nkind (EN) = N_And_Then loop\n+                  EN := Left_Opnd (EN);\n+               end loop;\n+\n+               --  Now post appropriate message\n+\n+               if Has_Static_Predicate_Aspect (Typ) then\n+                  if Is_Scalar_Type (Typ) then\n+                     Error_Msg_F\n+                       (\"expression is not predicate-static (RM 4.3.2(16-22))\",\n+                        EN);\n+                  else\n+                     Error_Msg_FE\n+                       (\"static predicate not allowed for non-scalar type&\",\n+                        EN, Typ);\n+                  end if;\n+               end if;\n             end if;\n-         end if;\n+         end;\n       end if;\n    end Build_Predicate_Functions;\n \n@@ -10293,6 +10338,210 @@ package body Sem_Ch13 is\n       end if;\n    end Is_Operational_Item;\n \n+   -------------------------\n+   -- Is_Predicate_Static --\n+   -------------------------\n+\n+   function Is_Predicate_Static\n+     (Expr : Node_Id;\n+      Nam  : Name_Id) return Boolean\n+   is\n+      function All_Static_Case_Alternatives (L : List_Id) return Boolean;\n+      --  Given a list of case expression alternatives, returns True if\n+      --  all the alternative are static (have all static choices, and a\n+      --  static expression).\n+\n+      function All_Static_Choices (L : List_Id) return Boolean;\n+      --  Returns true if all elements of the list are ok static choices\n+      --  as defined below for Is_Static_Choice. Used for case expression\n+      --  alternatives and for the right operand of a membership test.\n+\n+      function Is_Static_Choice (N : Node_Id) return Boolean;\n+      --  Returns True if N represents a static choice (static subtype, or\n+      --  static subtype indication, or static expression or static range).\n+      --\n+      --  Note that this is a bit more inclusive than we actually need\n+      --  (in particular membership tests do not allow the use of subtype\n+      --  indications. But that doesn't matter, we have already checked\n+      --  that the construct is legal to get this far.\n+\n+      function Is_Type_Ref (N : Node_Id) return Boolean;\n+      pragma Inline (Is_Type_Ref);\n+      --  Returns if True if N is a reference to the type for the predicate in\n+      --  the expression (i.e. if it is an identifier whose Chars field matches\n+      --  the Nam given in the call). N must not be parenthesized, if the type\n+      --  name appears in parens, this routine will return False.\n+\n+      ----------------------------------\n+      -- All_Static_Case_Alternatives --\n+      ----------------------------------\n+\n+      function All_Static_Case_Alternatives (L : List_Id) return Boolean is\n+         N : Node_Id;\n+\n+      begin\n+         N := First (L);\n+         while Present (N) loop\n+            if not (All_Static_Choices (Discrete_Choices (N))\n+                     and then Is_OK_Static_Expression (Expression (N)))\n+            then\n+               return False;\n+            end if;\n+\n+            Next (N);\n+         end loop;\n+\n+         return True;\n+      end All_Static_Case_Alternatives;\n+\n+      ------------------------\n+      -- All_Static_Choices --\n+      ------------------------\n+\n+      function All_Static_Choices (L : List_Id) return Boolean is\n+         N : Node_Id;\n+\n+      begin\n+         N := First (L);\n+         while Present (N) loop\n+            if not Is_Static_Choice (N) then\n+               return False;\n+            end if;\n+\n+            Next (N);\n+         end loop;\n+\n+         return True;\n+      end All_Static_Choices;\n+\n+      ----------------------\n+      -- Is_Static_Choice --\n+      ----------------------\n+\n+      function Is_Static_Choice (N : Node_Id) return Boolean is\n+      begin\n+         return Is_OK_Static_Expression (N)\n+           or else (Is_Entity_Name (N) and then Is_Type (Entity (N))\n+                     and then Is_OK_Static_Subtype (Entity (N)))\n+           or else (Nkind (N) = N_Subtype_Indication\n+                     and then Is_OK_Static_Subtype (Entity (N)))\n+           or else (Nkind (N) = N_Range and then Is_OK_Static_Range (N));\n+      end Is_Static_Choice;\n+\n+      -----------------\n+      -- Is_Type_Ref --\n+      -----------------\n+\n+      function Is_Type_Ref (N : Node_Id) return Boolean is\n+      begin\n+         return Nkind (N) = N_Identifier\n+           and then Chars (N) = Nam\n+           and then Paren_Count (N) = 0;\n+      end Is_Type_Ref;\n+\n+   --  Start of processing for Is_Predicate_Static\n+\n+   begin\n+      --  Only scalar types can be predicate static\n+\n+      if not Is_Scalar_Type (Etype (Expr)) then\n+         return False;\n+      end if;\n+\n+      --  Predicate_Static means one of the following holds. Numbers are the\n+      --  corresponding paragraph numbers in (RM 3.2.4(16-22)).\n+\n+      --  16: A static expression\n+\n+      if Is_OK_Static_Expression (Expr) then\n+         return True;\n+\n+      --  17: A membership test whose simple_expression is the current\n+      --  instance, and whose membership_choice_list meets the requirements\n+      --  for a static membership test.\n+\n+      elsif Nkind (Expr) in N_Membership_Test\n+        and then ((Present (Right_Opnd (Expr))\n+                    and then Is_Static_Choice (Right_Opnd (Expr)))\n+                  or else\n+                    (Present (Alternatives (Expr))\n+                      and then All_Static_Choices (Alternatives (Expr))))\n+      then\n+         return True;\n+\n+      --  18. A case_expression whose selecting_expression is the current\n+      --  instance, and whose dependent expressions are static expressions.\n+\n+      elsif Nkind (Expr) = N_Case_Expression\n+        and then Is_Type_Ref (Expression (Expr))\n+        and then All_Static_Case_Alternatives (Alternatives (Expr))\n+      then\n+         return True;\n+\n+      --  19. A call to a predefined equality or ordering operator, where one\n+      --  operand is the current instance, and the other is a static\n+      --  expression.\n+\n+      elsif Nkind (Expr) in N_Op_Compare\n+        and then ((Is_Type_Ref (Left_Opnd (Expr))\n+                    and then Is_OK_Static_Expression (Right_Opnd (Expr)))\n+                  or else\n+                    (Is_Type_Ref (Right_Opnd (Expr))\n+                      and then Is_OK_Static_Expression (Left_Opnd (Expr))))\n+      then\n+         return True;\n+\n+      --  20. A call to a predefined boolean logical operator, where each\n+      --  operand is predicate-static.\n+\n+      elsif (Nkind_In (Expr, N_Op_And, N_Op_Or, N_Op_Xor)\n+              and then Is_Predicate_Static (Left_Opnd (Expr), Nam)\n+              and then Is_Predicate_Static (Right_Opnd (Expr), Nam))\n+        or else\n+            (Nkind (Expr) = N_Op_Not\n+              and then Is_Predicate_Static (Right_Opnd (Expr), Nam))\n+      then\n+         return True;\n+\n+      --  21. A short-circuit control form where both operands are\n+      --  predicate-static.\n+\n+      elsif Nkind (Expr) in N_Short_Circuit\n+        and then Is_Predicate_Static (Left_Opnd (Expr), Nam)\n+        and then Is_Predicate_Static (Right_Opnd (Expr), Nam)\n+      then\n+         return True;\n+\n+      --  22. A parenthesized predicate-static expression. This does not\n+      --  require any special test, since we just ignore paren levels in\n+      --  all the cases above.\n+\n+      --  One more test that is an implementation artifact caused by the fact\n+      --  that we are analyzing not the original expresesion, but the generated\n+      --  expression in the body of the predicate function. This can include\n+      --  refereces to inherited predicates, so that the expression we are\n+      --  processing looks like:\n+\n+      --    expression and then xxPredicate (typ (Inns))\n+\n+      --  Where the call is to a Predicate function for an inherited predicate.\n+      --  We simply ignore such a call (which could be to either a dynamic or\n+      --  a static predicate, but remember that we can have Static_Predicate\n+      --  for a non-static subtype).\n+\n+      elsif Nkind (Expr) = N_Function_Call\n+        and then Is_Predicate_Function (Entity (Name (Expr)))\n+      then\n+         return True;\n+\n+      --  That's an exhaustive list of tests, all other cases are not\n+      --  predicate static, so we return False.\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Predicate_Static;\n+\n    ---------------------\n    -- Kill_Rep_Clause --\n    ---------------------"}, {"sha": "1f89f2e9b9e59d6576a626d1cef8c251725fa050", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -13618,8 +13618,8 @@ package body Sem_Ch3 is\n                  Base_Type (Full_View (Id_Type)) = Base_Type (Parent_Type))\n            or else\n              (Ada_Version >= Ada_2012\n-                and then Ekind (Id_Type) = E_Incomplete_Type\n-                and then Full_View (Id_Type) = Parent_Type)\n+               and then Ekind (Id_Type) = E_Incomplete_Type\n+               and then Full_View (Id_Type) = Parent_Type)\n          then\n             --  Constraint checks on formals are generated during expansion,\n             --  based on the signature of the original subprogram. The bounds"}, {"sha": "3dc457d59565c3b19eec7d658c6e67652ef73c55", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -1331,9 +1331,6 @@ package body Sem_Ch4 is\n    -----------------------------\n \n    procedure Analyze_Case_Expression (N : Node_Id) is\n-      function Has_Static_Predicate (Subtyp : Entity_Id) return Boolean;\n-      --  Determine whether subtype Subtyp has aspect Static_Predicate\n-\n       procedure Non_Static_Choice_Error (Choice : Node_Id);\n       --  Error routine invoked by the generic instantiation below when\n       --  the case expression has a non static choice.\n@@ -1350,28 +1347,6 @@ package body Sem_Ch4 is\n            Process_Associated_Node   => No_OP);\n       use Case_Choices_Checking;\n \n-      --------------------------\n-      -- Has_Static_Predicate --\n-      --------------------------\n-\n-      function Has_Static_Predicate (Subtyp : Entity_Id) return Boolean is\n-         Item : Node_Id;\n-\n-      begin\n-         Item := First_Rep_Item (Subtyp);\n-         while Present (Item) loop\n-            if Nkind (Item) = N_Aspect_Specification\n-              and then Chars (Identifier (Item)) = Name_Static_Predicate\n-            then\n-               return True;\n-            end if;\n-\n-            Next_Rep_Item (Item);\n-         end loop;\n-\n-         return False;\n-      end Has_Static_Predicate;\n-\n       -----------------------------\n       -- Non_Static_Choice_Error --\n       -----------------------------\n@@ -1493,7 +1468,7 @@ package body Sem_Ch4 is\n       --  to bogus errors.\n \n       if Is_Static_Subtype (Exp_Type)\n-        and then Has_Static_Predicate (Exp_Type)\n+        and then Has_Static_Predicate_Aspect (Exp_Type)\n         and then In_Spec_Expression\n       then\n          null;"}, {"sha": "67e43e1042428c3ad77a646eded0074a3fe59b03", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -3306,28 +3306,42 @@ package body Sem_Eval is\n       Typ : Entity_Id) return Boolean\n    is\n       Loc  : constant Source_Ptr := Sloc (N);\n-      Pred : constant List_Id := Static_Predicate (Typ);\n-      Test : Node_Id;\n \n    begin\n-      if No (Pred) then\n-         return True;\n-      end if;\n+      --  Discrete type case\n+\n+      if Is_Discrete_Type (Typ) then\n+         declare\n+            Pred : constant List_Id := Static_Predicate (Typ);\n+            Test : Node_Id;\n \n-      --  The static predicate is a list of alternatives in the proper format\n-      --  for an Ada 2012 membership test. If the argument is a literal, the\n-      --  membership test can be evaluated statically. The caller transforms\n-      --  a result of False into a static contraint error.\n+         begin\n+            pragma Assert (Present (Pred));\n+\n+            --  The static predicate is a list of alternatives in the proper\n+            --  format for an Ada 2012 membership test. If the argument is a\n+            --  literal, the membership test can be evaluated statically. This\n+            --  is easier than running a full intepretation of the predicate\n+            --  expression, and more efficient in some cases.\n+\n+            Test :=\n+              Make_In (Loc,\n+                Left_Opnd    => New_Copy_Tree (N),\n+                Right_Opnd   => Empty,\n+                Alternatives => Pred);\n+            Analyze_And_Resolve (Test, Standard_Boolean);\n+\n+            return Nkind (Test) = N_Identifier\n+              and then Entity (Test) = Standard_True;\n+         end;\n \n-      Test :=\n-        Make_In (Loc,\n-          Left_Opnd    => New_Copy_Tree (N),\n-          Right_Opnd   => Empty,\n-          Alternatives => Pred);\n-      Analyze_And_Resolve (Test, Standard_Boolean);\n+      --  Real type case\n \n-      return Nkind (Test) = N_Identifier\n-        and then Entity (Test) = Standard_True;\n+      else\n+         pragma Assert (Is_Real_Type (Typ));\n+         Error_Msg_N (\"??real predicate not applied\", N);\n+         return True;\n+      end if;\n    end Eval_Static_Predicate_Check;\n \n    -------------------------"}, {"sha": "461bbdbd2348189d75d2ad34ad449c59dcfca346", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -248,7 +248,7 @@ package Sem_Eval is\n    --  In general we take a pessimistic view. False does not mean the value\n    --  could not be known at compile time, but True means that absolutely\n    --  definition it is known at compile time and it is safe to call\n-   --  Expr_Value on the expression Op.\n+   --  Expr_Value[_XX] on the expression Op.\n    --\n    --  Note that we don't define precisely the set of expressions that return\n    --  True. Callers should not make any assumptions regarding the value that\n@@ -365,9 +365,11 @@ package Sem_Eval is\n    procedure Eval_Unchecked_Conversion   (N : Node_Id);\n \n    function Eval_Static_Predicate_Check\n-     (N  : Node_Id;\n-     Typ : Entity_Id) return Boolean;\n-   --  Evaluate a static predicate check applied to a scalar literal\n+     (N   : Node_Id;\n+      Typ : Entity_Id) return Boolean;\n+   --  Evaluate a static predicate check applied to a known at compile time\n+   --  value N, which can be of a discrete, real or string type. The caller\n+   --  has checked that a static predicate does apply to Typ.\n \n    procedure Fold_Str (N : Node_Id; Val : String_Id; Static : Boolean);\n    --  Rewrite N with a new N_String_Literal node as the result of the compile"}, {"sha": "ded1d401a907aada83ab2fc2670b328390778d53", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -1695,13 +1695,13 @@ package body Sem_Util is\n    begin\n       --  When the predicate is static and the value of the expression is known\n       --  at compile time, evaluate the predicate check. A type is non-static\n-      --  when it has aspect Dynamic_Predicate.\n+      --  when it has aspect Dynamic_Predicate, but if the dynamic predicate\n+      --  was predicate-static, we still check it statically. After all this\n+      --  is only a warning, not an error.\n \n       if Compile_Time_Known_Value (Expr)\n         and then Has_Predicates (Typ)\n-        and then Is_Discrete_Type (Typ)\n-        and then Present (Static_Predicate (Typ))\n-        and then not Has_Dynamic_Predicate_Aspect (Typ)\n+        and then Has_Static_Predicate (Typ)\n       then\n          --  Either -gnatc is enabled or the expression is ok\n \n@@ -1710,12 +1710,14 @@ package body Sem_Util is\n          then\n             null;\n \n-         --  The expression is prohibited by the static predicate\n+         --  The expression is prohibited by the static predicate. There has\n+         --  been some debate if this is an illegality (in the case where\n+         --  the static predicate was explicitly given as such), but that\n+         --  discussion decided this was not illegal, just a warning situation.\n \n          else\n             Error_Msg_NE\n-              (\"??static expression fails static predicate check on &\",\n-               Expr, Typ);\n+              (\"??static expression fails predicate check on &\", Expr, Typ);\n          end if;\n       end if;\n    end Check_Expression_Against_Static_Predicate;"}, {"sha": "31c61e5b1b7ce1798fbc10e6b563aeba0f81aa37", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee4eee0a542378923db1978ac6cee9fe1dfd693e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=ee4eee0a542378923db1978ac6cee9fe1dfd693e", "patch": "@@ -4022,13 +4022,13 @@ package Sinfo is\n       --  to deal with, and diagnose a simple expression other than a name for\n       --  the right operand. This simplifies error recovery in the parser.\n \n-      --  The Alternatives field below is present only if there is more\n-      --  than one Membership_Choice present (which is legitimate only in\n-      --  Ada 2012 mode) in which case Right_Opnd is Empty, and Alternatives\n-      --  contains the list of choices. In the tree passed to the back end,\n-      --  Alternatives is always No_List, and Right_Opnd is set (i.e. the\n-      --  expansion circuitry expands out the complex set membership case\n-      --  using simple membership operations).\n+      --  The Alternatives field below is present only if there is more than\n+      --  one Membership_Choice present (which is legitimate only in Ada 2012\n+      --  mode) in which case Right_Opnd is Empty, and Alternatives contains\n+      --  the list of choices. In the tree passed to the back end, Alternatives\n+      --  is always No_List, and Right_Opnd is set (i.e. the expansion circuit\n+      --  expands out the complex set membership case using simple membership\n+      --  and equality operations).\n \n       --  Should we rename Alternatives here to Membership_Choices ???\n \n@@ -4271,7 +4271,7 @@ package Sinfo is\n       --  CASE_EXPRESSION ::=\n       --    case SELECTING_EXPRESSION is\n       --      CASE_EXPRESSION_ALTERNATIVE\n-      --      {CASE_EXPRESSION_ALTERNATIVE}\n+      --      {,CASE_EXPRESSION_ALTERNATIVE}\n \n       --  Note that the Alternatives cannot include pragmas (this contrasts\n       --  with the situation of case statements where pragmas are allowed)."}]}