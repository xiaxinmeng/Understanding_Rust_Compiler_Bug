{"sha": "47da5198766256be658b4c321cecfd6039b0b91b", "node_id": "C_kwDOANBUbNoAKDQ3ZGE1MTk4NzY2MjU2YmU2NThiNGMzMjFjZWNmZDYwMzliMGI5MWI", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-02-25T19:07:15Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-03-18T18:07:58Z"}, "message": "c++: using lookup within class defn [PR104476]\n\nThe problem in both PR92918 and PR104476 is overloading of base member\nfunctions brought in by 'using' with direct member functions during parsing\nof the class body.  To this point they've had a troublesome coexistence\nwhich was resolved by set_class_bindings when the class is complete, but we\nalso need to handle lookup within the class body, such as in a trailing\nreturn type.\n\nThe problem was that push_class_level_binding would either clobber the\nusing-decl with the direct members or vice-versa.  In older versions of GCC\nwe only pushed dependent usings, and preferring the dependent using made\nsense, as it expresses a type-dependent overload set that we can't do\nanything useful with.  But when we started keeping non-dependent usings\naround, push_class_level_binding in particular wasn't adjusted accordingly.\n\nThis patch makes that adjustment, and pushes the functions imported by a\nnon-dependent using immediately from finish_member_declaration.  This made\ndiagnosing redundant using-decls a bit awkward, since we no longer push the\nusing-decl itself; I handle that by noticing when we try to add the same\nfunction again and searching TYPE_FIELDS for the previous using-decl.\n\n\tPR c++/92918\n\tPR c++/104476\n\ngcc/cp/ChangeLog:\n\n\t* class.cc (add_method): Avoid adding the same used function twice.\n\t(handle_using_decl): Don't add_method.\n\t(finish_struct): Don't using op= if we have one already.\n\t(maybe_push_used_methods): New.\n\t* semantics.cc (finish_member_declaration): Call it.\n\t* name-lookup.cc (diagnose_name_conflict): No longer static.\n\t(push_class_level_binding): Revert 92918 patch, limit\n\tto dependent using.\n\t* cp-tree.h: Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/pr85070.C: Remove expected error.\n\t* g++.dg/lookup/using66a.C: New test.\n\t* g++.dg/lookup/using67.C: New test.", "tree": {"sha": "cf04525e4d62c0579f27fdaba87433023f92400d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf04525e4d62c0579f27fdaba87433023f92400d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47da5198766256be658b4c321cecfd6039b0b91b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47da5198766256be658b4c321cecfd6039b0b91b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47da5198766256be658b4c321cecfd6039b0b91b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47da5198766256be658b4c321cecfd6039b0b91b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32ca611c42658948f1b8883994796f35e8b4e74d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ca611c42658948f1b8883994796f35e8b4e74d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ca611c42658948f1b8883994796f35e8b4e74d"}], "stats": {"total": 205, "additions": 142, "deletions": 63}, "files": [{"sha": "40e17140db5ed12d124d9f0409ddfb64d801d34a", "filename": "gcc/cp/class.cc", "status": "modified", "additions": 81, "deletions": 55, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Fcp%2Fclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Fcp%2Fclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.cc?ref=47da5198766256be658b4c321cecfd6039b0b91b", "patch": "@@ -1049,7 +1049,12 @@ add_method (tree type, tree method, bool via_using)\n       if (via_using && iter.using_p ()\n \t  /* Except handle inherited constructors specially.  */\n \t  && ! DECL_CONSTRUCTOR_P (fn))\n-\tcontinue;\n+\t{\n+\t  if (fn == method)\n+\t    /* Don't add the same one twice.  */\n+\t    return false;\n+\t  continue;\n+\t}\n \n       /* [over.load] Member function declarations with the\n \t same name and the same parameter types cannot be\n@@ -1212,10 +1217,11 @@ add_method (tree type, tree method, bool via_using)\n       if (via_using)\n \t/* Defer to the local function.  */\n \treturn false;\n-      else if (flag_new_inheriting_ctors\n-\t       && DECL_INHERITED_CTOR (fn))\n+      else if (iter.using_p ()\n+\t       ||  (flag_new_inheriting_ctors\n+\t\t    && DECL_INHERITED_CTOR (fn)))\n \t{\n-\t  /* Remove the inherited constructor.  */\n+\t  /* Remove the inherited function.  */\n \t  current_fns = iter.remove_node (current_fns);\n \t  continue;\n \t}\n@@ -1299,21 +1305,65 @@ declared_access (tree decl)\n \t  : access_public_node);\n }\n \n+/* If DECL is a non-dependent using of non-ctor function members, push them\n+   and return true, otherwise return false.  Called from\n+   finish_member_declaration.  */\n+\n+bool\n+maybe_push_used_methods (tree decl)\n+{\n+  if (TREE_CODE (decl) != USING_DECL)\n+    return false;\n+  tree used = strip_using_decl (decl);\n+  if (!used || !is_overloaded_fn (used))\n+    return false;\n+\n+  /* Add the functions to CLASSTYPE_MEMBER_VEC so that overload resolution\n+     works within the class body.  */\n+  for (tree f : ovl_range (used))\n+    {\n+      if (DECL_CONSTRUCTOR_P (f))\n+\t/* Inheriting constructors are handled separately.  */\n+\treturn false;\n+\n+      bool added = add_method (current_class_type, f, true);\n+\n+      if (added)\n+\talter_access (current_class_type, f, current_access_specifier);\n+\n+      /* If add_method returns false because f was already declared, look\n+\t for a duplicate using-declaration.  */\n+      else\n+\tfor (tree d = TYPE_FIELDS (current_class_type); d; d = DECL_CHAIN (d))\n+\t  if (TREE_CODE (d) == USING_DECL\n+\t      && DECL_NAME (d) == DECL_NAME (decl)\n+\t      && same_type_p (USING_DECL_SCOPE (d), USING_DECL_SCOPE (decl)))\n+\t    {\n+\t      diagnose_name_conflict (decl, d);\n+\t      break;\n+\t    }\n+    }\n+  return true;\n+}\n+\n /* Process the USING_DECL, which is a member of T.  */\n \n static void\n handle_using_decl (tree using_decl, tree t)\n {\n   tree decl = USING_DECL_DECLS (using_decl);\n-  tree name = DECL_NAME (using_decl);\n-  tree access = declared_access (using_decl);\n-  tree flist = NULL_TREE;\n-  tree old_value;\n \n   gcc_assert (!processing_template_decl && decl);\n \n-  old_value = lookup_member (t, name, /*protect=*/0, /*want_type=*/false,\n-\t\t\t     tf_warning_or_error);\n+  cp_emit_debug_info_for_using (decl, t);\n+\n+  if (is_overloaded_fn (decl))\n+    /* Handled in maybe_push_used_methods.  */\n+    return;\n+\n+  tree name = DECL_NAME (using_decl);\n+  tree old_value = lookup_member (t, name, /*protect=*/0, /*want_type=*/false,\n+\t\t\t\t  tf_warning_or_error);\n   if (old_value)\n     {\n       old_value = OVL_FIRST (old_value);\n@@ -1324,27 +1374,16 @@ handle_using_decl (tree using_decl, tree t)\n \told_value = NULL_TREE;\n     }\n \n-  cp_emit_debug_info_for_using (decl, t);\n-\n-  if (is_overloaded_fn (decl))\n-    flist = decl;\n-\n   if (! old_value)\n     ;\n   else if (is_overloaded_fn (old_value))\n     {\n-      if (flist)\n-\t/* It's OK to use functions from a base when there are functions with\n-\t   the same name already present in the current class.  */;\n-      else\n-\t{\n-\t  error_at (DECL_SOURCE_LOCATION (using_decl), \"%qD invalid in %q#T \"\n-\t\t    \"because of local method %q#D with same name\",\n-\t\t    using_decl, t, old_value);\n-\t  inform (DECL_SOURCE_LOCATION (old_value),\n-\t\t  \"local method %q#D declared here\", old_value);\n-\t  return;\n-\t}\n+      error_at (DECL_SOURCE_LOCATION (using_decl), \"%qD invalid in %q#T \"\n+\t\t\"because of local method %q#D with same name\",\n+\t\tusing_decl, t, old_value);\n+      inform (DECL_SOURCE_LOCATION (old_value),\n+\t      \"local method %q#D declared here\", old_value);\n+      return;\n     }\n   else if (!DECL_ARTIFICIAL (old_value))\n     {\n@@ -1357,23 +1396,17 @@ handle_using_decl (tree using_decl, tree t)\n     }\n \n   iloc_sentinel ils (DECL_SOURCE_LOCATION (using_decl));\n+  tree access = declared_access (using_decl);\n \n   /* Make type T see field decl FDECL with access ACCESS.  */\n-  if (flist)\n-    for (tree f : ovl_range (flist))\n-      {\n-\tadd_method (t, f, true);\n-\talter_access (t, f, access);\n-      }\n-  else if (USING_DECL_UNRELATED_P (using_decl))\n+  if (USING_DECL_UNRELATED_P (using_decl))\n     {\n       /* C++20 using enum can import non-inherited enumerators into class\n \t scope.  We implement that by making a copy of the CONST_DECL for which\n \t CONST_DECL_USING_P is true.  */\n       gcc_assert (TREE_CODE (decl) == CONST_DECL);\n \n-      auto cas = make_temp_override (current_access_specifier);\n-      set_current_access_from_decl (using_decl);\n+      auto cas = make_temp_override (current_access_specifier, access);\n       tree copy = copy_decl (decl);\n       DECL_CONTEXT (copy) = t;\n       DECL_ARTIFICIAL (copy) = true;\n@@ -7672,18 +7705,8 @@ finish_struct (tree t, tree attributes)\n     {\n       tree x;\n \n-      /* We need to add the target functions of USING_DECLS, so that\n-\t they can be found when the using declaration is not\n-\t instantiated yet.  */\n       for (x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n-\tif (TREE_CODE (x) == USING_DECL)\n-\t  {\n-\t    tree fn = strip_using_decl (x);\n-  \t    if (OVL_P (fn))\n-\t      for (lkp_iterator iter (fn); iter; ++iter)\n-\t\tadd_method (t, *iter, true);\n-\t  }\n-\telse if (DECL_DECLARES_FUNCTION_P (x))\n+\tif (DECL_DECLARES_FUNCTION_P (x))\n \t  {\n \t    DECL_IN_AGGR_P (x) = false;\n \t    if (DECL_VIRTUAL_P (x))\n@@ -7700,14 +7723,17 @@ finish_struct (tree t, tree attributes)\n \t lookup not to fail or recurse into bases.  This isn't added\n \t to the template decl list so we drop this at instantiation\n \t time.  */\n-      tree ass_op = build_lang_decl (USING_DECL, assign_op_identifier,\n-\t\t\t\t     NULL_TREE);\n-      DECL_CONTEXT (ass_op) = t;\n-      USING_DECL_SCOPE (ass_op) = t;\n-      DECL_DEPENDENT_P (ass_op) = true;\n-      DECL_ARTIFICIAL (ass_op) = true;\n-      DECL_CHAIN (ass_op) = TYPE_FIELDS (t);\n-      TYPE_FIELDS (t) = ass_op;\n+      if (!get_class_binding_direct (t, assign_op_identifier, false))\n+\t{\n+\t  tree ass_op = build_lang_decl (USING_DECL, assign_op_identifier,\n+\t\t\t\t\t NULL_TREE);\n+\t  DECL_CONTEXT (ass_op) = t;\n+\t  USING_DECL_SCOPE (ass_op) = t;\n+\t  DECL_DEPENDENT_P (ass_op) = true;\n+\t  DECL_ARTIFICIAL (ass_op) = true;\n+\t  DECL_CHAIN (ass_op) = TYPE_FIELDS (t);\n+\t  TYPE_FIELDS (t) = ass_op;\n+\t}\n \n       TYPE_SIZE (t) = bitsize_zero_node;\n       TYPE_SIZE_UNIT (t) = size_zero_node;"}, {"sha": "1bd7bc6fca2876ef12d2e5e18ffa6e19c28309df", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=47da5198766256be658b4c321cecfd6039b0b91b", "patch": "@@ -6677,6 +6677,7 @@ extern tree build_vfn_ref\t\t\t(tree, tree);\n extern tree get_vtable_decl\t\t\t(tree, int);\n extern bool add_method\t\t\t\t(tree, tree, bool);\n extern tree declared_access\t\t\t(tree);\n+extern bool maybe_push_used_methods\t\t(tree);\n extern tree currently_open_class\t\t(tree);\n extern tree currently_open_derived_class\t(tree);\n extern tree outermost_open_class\t\t(void);\n@@ -8241,6 +8242,7 @@ extern tree fold_builtin_source_location\t(location_t);\n \n /* in name-lookup.cc */\n extern tree strip_using_decl                    (tree);\n+extern void diagnose_name_conflict\t\t(tree, tree);\n \n /* Tell the binding oracle what kind of binding we are looking for.  */\n "}, {"sha": "323f96bcd24196e226309ade1089647761e3cf29", "filename": "gcc/cp/name-lookup.cc", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Fcp%2Fname-lookup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Fcp%2Fname-lookup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.cc?ref=47da5198766256be658b4c321cecfd6039b0b91b", "patch": "@@ -1715,7 +1715,6 @@ static void consider_binding_level (tree name,\n \t\t\t\t    cp_binding_level *lvl,\n \t\t\t\t    bool look_within_fields,\n \t\t\t\t    enum lookup_name_fuzzy_kind kind);\n-static void diagnose_name_conflict (tree, tree);\n \n /* ADL lookup of NAME.  FNS is the result of regular lookup, and we\n    don't add duplicates to it.  ARGS is the vector of call\n@@ -2711,9 +2710,13 @@ supplement_binding (cxx_binding *binding, tree decl)\n   return ok;\n }\n \n-/* Diagnose a name conflict between DECL and BVAL.  */\n+/* Diagnose a name conflict between DECL and BVAL.\n \n-static void\n+   This is non-static so maybe_push_used_methods can use it and avoid changing\n+   the diagnostic for inherit/using4.C; otherwise it should not be used from\n+   outside this file.  */\n+\n+void\n diagnose_name_conflict (tree decl, tree bval)\n {\n   if (TREE_CODE (decl) == TREE_CODE (bval)\n@@ -5480,13 +5483,18 @@ push_class_level_binding (tree name, tree x)\n \t       && DECL_DEPENDENT_P (bval))\n \treturn true;\n       else if (TREE_CODE (decl) == USING_DECL\n+\t       && DECL_DEPENDENT_P (decl)\n \t       && OVL_P (target_bval))\n+\t/* The new dependent using beats an old overload.  */\n \told_decl = bval;\n       else if (TREE_CODE (bval) == USING_DECL\n+\t       && DECL_DEPENDENT_P (bval)\n \t       && OVL_P (target_decl))\n-\told_decl = bval;\n+\t/* The old dependent using beats a new overload.  */\n+\treturn true;\n       else if (OVL_P (target_decl)\n \t       && OVL_P (target_bval))\n+\t/* The new overload set contains the old one.  */\n \told_decl = bval;\n \n       if (old_decl && binding->scope == class_binding_level)"}, {"sha": "a7f6449dafd2e0451a53e4117b8e65888d56c4b7", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=47da5198766256be658b4c321cecfd6039b0b91b", "patch": "@@ -3549,8 +3549,8 @@ finish_member_declaration (tree decl)\n     }\n \n   if (TREE_CODE (decl) == USING_DECL)\n-    /* For now, ignore class-scope USING_DECLS, so that debugging\n-       backends do not see them. */\n+    /* Avoid debug info for class-scope USING_DECLS for now, we'll\n+       call cp_emit_debug_info_for_using later. */\n     DECL_IGNORED_P (decl) = 1;\n \n   /* Check for bare parameter packs in the non-static data member\n@@ -3578,6 +3578,7 @@ finish_member_declaration (tree decl)\n   /* Enter the DECL into the scope of the class, if the class\n      isn't a closure (whose fields are supposed to be unnamed).  */\n   else if (CLASSTYPE_LAMBDA_EXPR (current_class_type)\n+\t   || maybe_push_used_methods (decl)\n \t   || pushdecl_class_level (decl))\n     add = true;\n "}, {"sha": "5083cbd494019fad0bcd1b618299a8c99fe28a4b", "filename": "gcc/testsuite/g++.dg/cpp0x/pr85070.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr85070.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr85070.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr85070.C?ref=47da5198766256be658b4c321cecfd6039b0b91b", "patch": "@@ -4,10 +4,10 @@ struct A;\n \n struct B\n {\n-  constexpr A & operator= (const A &);  // { dg-warning \"used\" \"\" { target c++14 } }\n+  constexpr A & operator= (const A &);\n };\n \n-struct A : B  // { dg-error \"cannot be overloaded\" \"\" { target c++14 } }\n+struct A : B\n {\n   using B::operator=;\n } a { a = a };"}, {"sha": "84ddd87dcd2395d592832feaee39dcfadf7fccbb", "filename": "gcc/testsuite/g++.dg/lookup/using66a.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing66a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing66a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing66a.C?ref=47da5198766256be658b4c321cecfd6039b0b91b", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/92918\n+// { dg-do compile { target c++11 } }\n+\n+struct Base03\n+{\n+    static void impl();\n+};\n+\n+struct ThisDoesNotCompileOnGCC : Base03\n+{\n+    using Base03::impl;\n+    static int impl(char const *);\n+\n+    auto f(const char *t) const\n+    -> decltype(impl(t))\n+    {\n+        return impl(t);\n+    }\n+};\n+\n+ThisDoesNotCompileOnGCC t;\n+int i = t.f(\"42\");"}, {"sha": "310d4ee9fd9fb67c05da463d0a0a5da78139d01d", "filename": "gcc/testsuite/g++.dg/lookup/using67.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing67.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47da5198766256be658b4c321cecfd6039b0b91b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing67.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing67.C?ref=47da5198766256be658b4c321cecfd6039b0b91b", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/104476\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  static void f();\n+  static void f2();\n+};\n+\n+struct B : A\n+{\n+  static void f(int);\n+  using A::f;\n+  auto g() -> decltype(f());\n+  auto ga() -> decltype(f(2));\n+\n+  using A::f2;\n+  static void f2(int);\n+  auto g2() -> decltype(f2());\n+  auto g2a() -> decltype(f2(2));\n+};"}]}