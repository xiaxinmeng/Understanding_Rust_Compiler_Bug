{"sha": "76d9871594d5eac8a78a3434f6ab9761da339cd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZkOTg3MTU5NGQ1ZWFjOGE3OGEzNDM0ZjZhYjk3NjFkYTMzOWNkMA==", "commit": {"author": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2021-08-03T13:32:19Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2021-08-03T15:55:22Z"}, "message": "ast: Merge both Module kinds in one class", "tree": {"sha": "9be245d3c389eaffcb9030058ad79a4292fa75e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9be245d3c389eaffcb9030058ad79a4292fa75e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76d9871594d5eac8a78a3434f6ab9761da339cd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76d9871594d5eac8a78a3434f6ab9761da339cd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76d9871594d5eac8a78a3434f6ab9761da339cd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76d9871594d5eac8a78a3434f6ab9761da339cd0/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c707190b29e1e5b2d20fa9d68dcd7f043659aed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c707190b29e1e5b2d20fa9d68dcd7f043659aed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c707190b29e1e5b2d20fa9d68dcd7f043659aed4"}], "stats": {"total": 351, "additions": 170, "deletions": 181}, "files": [{"sha": "7644dfe240cd910f9720d8b012f13fb1bd27135f", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76d9871594d5eac8a78a3434f6ab9761da339cd0/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76d9871594d5eac8a78a3434f6ab9761da339cd0/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=76d9871594d5eac8a78a3434f6ab9761da339cd0", "patch": "@@ -182,8 +182,6 @@ struct Visibility;\n class Method;\n class VisItem;\n class Module;\n-class ModuleBodied;\n-class ModuleNoBody;\n class ExternCrate;\n class UseTree;\n class UseTreeGlob;"}, {"sha": "32fb56f41fe9bbb1c564a46aa1c8ea1698d1fe89", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 170, "deletions": 179, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76d9871594d5eac8a78a3434f6ab9761da339cd0/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76d9871594d5eac8a78a3434f6ab9761da339cd0/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=76d9871594d5eac8a78a3434f6ab9761da339cd0", "patch": "@@ -57,7 +57,7 @@ class TypeParam : public GenericParam\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   // bool has_type;\n@@ -78,8 +78,8 @@ class TypeParam : public GenericParam\n   bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n \n   TypeParam (Identifier type_representation, Location locus = Location (),\n-\t     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds\n-\t     = std::vector<std::unique_ptr<TypeParamBound> > (),\n+\t     std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds\n+\t     = std::vector<std::unique_ptr<TypeParamBound>> (),\n \t     std::unique_ptr<Type> type = nullptr,\n \t     Attribute outer_attr = Attribute::create_empty ())\n     : GenericParam (Analysis::Mappings::get ()->get_next_node_id ()),\n@@ -144,11 +144,11 @@ class TypeParam : public GenericParam\n   }\n \n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -224,7 +224,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   // should this store location info?\n@@ -238,7 +238,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   TypeBoundWhereClauseItem (\n     std::vector<LifetimeParam> for_lifetimes, std::unique_ptr<Type> bound_type,\n-    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds)\n+    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds)\n     : for_lifetimes (std::move (for_lifetimes)),\n       bound_type (std::move (bound_type)),\n       type_param_bounds (std::move (type_param_bounds))\n@@ -284,11 +284,11 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n   }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -306,13 +306,12 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n struct WhereClause\n {\n private:\n-  std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items;\n+  std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items;\n \n   // should this store location info?\n \n public:\n-  WhereClause (\n-    std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items)\n+  WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items)\n     : where_clause_items (std::move (where_clause_items))\n   {}\n \n@@ -341,7 +340,7 @@ struct WhereClause\n   // Creates a WhereClause with no items.\n   static WhereClause create_empty ()\n   {\n-    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem> > ());\n+    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> ());\n   }\n \n   // Returns whether the WhereClause has no items.\n@@ -350,11 +349,11 @@ struct WhereClause\n   std::string as_string () const;\n \n   // TODO: this mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<WhereClauseItem> > &get_items ()\n+  std::vector<std::unique_ptr<WhereClauseItem>> &get_items ()\n   {\n     return where_clause_items;\n   }\n-  const std::vector<std::unique_ptr<WhereClauseItem> > &get_items () const\n+  const std::vector<std::unique_ptr<WhereClauseItem>> &get_items () const\n   {\n     return where_clause_items;\n   }\n@@ -698,7 +697,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   SelfParam self_param;\n \n@@ -731,7 +730,7 @@ class Method : public InherentImplItem, public TraitImplItem\n   static Method create_error ()\n   {\n     return Method (\"\", FunctionQualifiers (FunctionQualifiers::NONE, true),\n-\t\t   std::vector<std::unique_ptr<GenericParam> > (),\n+\t\t   std::vector<std::unique_ptr<GenericParam>> (),\n \t\t   SelfParam::create_error (), std::vector<FunctionParam> (),\n \t\t   nullptr, WhereClause::create_empty (), nullptr,\n \t\t   Visibility::create_error (), std::vector<Attribute> (), {});\n@@ -754,7 +753,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   Method (Identifier method_name, FunctionQualifiers qualifiers,\n-\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t  SelfParam self_param, std::vector<FunctionParam> function_params,\n \t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n@@ -853,11 +852,11 @@ class Method : public InherentImplItem, public TraitImplItem\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -961,134 +960,127 @@ class VisItem : public Item\n // Rust module item - abstract base class\n class Module : public VisItem\n {\n-  Identifier module_name;\n-  Location locus;\n-\n-protected:\n-  // Protected constructor\n-  Module (Identifier module_name, Visibility visibility, Location locus,\n-\t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : VisItem (std::move (visibility), std::move (outer_attrs)),\n-      module_name (module_name), locus (locus)\n-  {}\n-\n public:\n-  std::string as_string () const override;\n-\n-  Location get_locus () const { return locus; }\n+  // Type of the current module. A module can be either loaded or unloaded,\n+  // meaning that the items of the module can already be present or not. For\n+  // example, the following module would be loaded: `mod foo { fn bar() {} }`.\n+  // However, the module would be unloaded if it refers to an external file (i.e\n+  // `mod foo;`) and then become loaded upon expansion.\n+  enum ModuleKind\n+  {\n+    LOADED,\n+    UNLOADED,\n+  };\n \n-  // Invalid if name is empty, so base stripping on that.\n-  void mark_for_strip () override { module_name = \"\"; }\n-  bool is_marked_for_strip () const override { return module_name.empty (); }\n-};\n+private:\n+  Identifier module_name;\n+  Location locus;\n+  ModuleKind kind;\n \n-// Module with a body, defined in file\n-class ModuleBodied : public Module\n-{\n   // bool has_inner_attrs;\n   std::vector<Attribute> inner_attrs;\n   // bool has_items;\n-  std::vector<std::unique_ptr<Item> > items;\n+  std::vector<std::unique_ptr<Item>> items;\n \n-public:\n-  std::string as_string () const override;\n+  void clone_items (const std::vector<std::unique_ptr<Item>> &other_items)\n+  {\n+    items.reserve (other_items.size ());\n+    for (const auto &e : other_items)\n+      items.push_back (e->clone_item ());\n+  }\n \n+public:\n   // Returns whether the module has items in its body.\n   bool has_items () const { return !items.empty (); }\n \n   // Returns whether the module has any inner attributes.\n   bool has_inner_attrs () const { return !inner_attrs.empty (); }\n \n-  // Full constructor\n-  ModuleBodied (Identifier name, Location locus,\n-\t\tstd::vector<std::unique_ptr<Item> > items\n-\t\t= std::vector<std::unique_ptr<Item> > (),\n-\t\tVisibility visibility = Visibility::create_error (),\n-\t\tstd::vector<Attribute> inner_attrs = std::vector<Attribute> (),\n-\t\tstd::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : Module (std::move (name), std::move (visibility), locus,\n-\t      std::move (outer_attrs)),\n+  // Unloaded module constructor\n+  Module (Identifier module_name, Visibility visibility,\n+\t  std::vector<Attribute> outer_attrs, Location locus)\n+    : VisItem (std::move (visibility), std::move (outer_attrs)),\n+      module_name (module_name), locus (locus), kind (ModuleKind::UNLOADED),\n+      inner_attrs (std::vector<Attribute> ()),\n+      items (std::vector<std::unique_ptr<Item>> ())\n+  {}\n+\n+  // Loaded module constructor, with items\n+  Module (Identifier name, Location locus,\n+\t  std::vector<std::unique_ptr<Item>> items,\n+\t  Visibility visibility = Visibility::create_error (),\n+\t  std::vector<Attribute> inner_attrs = std::vector<Attribute> (),\n+\t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n+    : VisItem (std::move (visibility), std::move (outer_attrs)),\n+      module_name (name), locus (locus), kind (ModuleKind::LOADED),\n       inner_attrs (std::move (inner_attrs)), items (std::move (items))\n   {}\n \n   // Copy constructor with vector clone\n-  ModuleBodied (ModuleBodied const &other)\n-    : Module (other), inner_attrs (other.inner_attrs)\n-  {\n-    items.reserve (other.items.size ());\n-    for (const auto &e : other.items)\n-      items.push_back (e->clone_item ());\n+  Module (Module const &other)\n+    : VisItem (other), module_name (other.module_name), locus (other.locus),\n+      kind (other.kind), inner_attrs (other.inner_attrs)\n+  {\n+    // We need to check whether we are copying a loaded module or an unloaded\n+    // one. In the second case, clear the `items` vector.\n+    if (other.kind == LOADED)\n+      clone_items (other.items);\n+    else\n+      items.clear ();\n   }\n \n   // Overloaded assignment operator with vector clone\n-  ModuleBodied &operator= (ModuleBodied const &other)\n+  Module &operator= (Module const &other)\n   {\n-    Module::operator= (other);\n+    VisItem::operator= (other);\n+\n+    module_name = other.module_name;\n+    locus = other.locus;\n+    kind = other.kind;\n     inner_attrs = other.inner_attrs;\n \n-    items.reserve (other.items.size ());\n-    for (const auto &e : other.items)\n-      items.push_back (e->clone_item ());\n+    // Likewise, we need to clear the `items` vector in case the other module is\n+    // unloaded\n+    if (kind == LOADED)\n+      clone_items (other.items);\n+    else\n+      items.clear ();\n \n     return *this;\n   }\n \n-  // move constructors\n-  ModuleBodied (ModuleBodied &&other) = default;\n-  ModuleBodied &operator= (ModuleBodied &&other) = default;\n-\n   void accept_vis (ASTVisitor &vis) override;\n \n   /* Override that runs the function recursively on all items contained within\n    * the module. */\n   void add_crate_name (std::vector<std::string> &names) const override;\n \n+  // Returns the kind of the module\n+  enum ModuleKind get_kind () const { return kind; }\n+\n   // TODO: think of better way to do this - mutable getter seems dodgy\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  const std::vector<std::unique_ptr<Item> > &get_items () const\n-  {\n-    return items;\n-  }\n-  std::vector<std::unique_ptr<Item> > &get_items () { return items; }\n+  const std::vector<std::unique_ptr<Item>> &get_items () const { return items; }\n+  std::vector<std::unique_ptr<Item>> &get_items () { return items; }\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  ModuleBodied *clone_item_impl () const override\n-  {\n-    return new ModuleBodied (*this);\n-  }\n-};\n+  // move constructors\n+  Module (Module &&other) = default;\n+  Module &operator= (Module &&other) = default;\n \n-// Module without a body, loaded from external file\n-class ModuleNoBody : public Module\n-{\n-  /* TODO: are modules loaded from file unique? As in, can you load the same\n-   * file into two different other files? Because this may make the difference\n-   * between simply replacing this with the module\n-   * \"definition\" (as loaded from another file) vs this having to \"reference\" a\n-   * module with body. */\n-public:\n   std::string as_string () const override;\n \n-  // Full constructor\n-  ModuleNoBody (Identifier name, Visibility visibility,\n-\t\tstd::vector<Attribute> outer_attrs, Location locus)\n-    : Module (std::move (name), std::move (visibility), locus,\n-\t      std::move (outer_attrs))\n-  {}\n+  Location get_locus () const { return locus; }\n \n-  void accept_vis (ASTVisitor &vis) override;\n+  // Invalid if name is empty, so base stripping on that.\n+  void mark_for_strip () override { module_name = \"\"; }\n+  bool is_marked_for_strip () const override { return module_name.empty (); }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n-  ModuleNoBody *clone_item_impl () const override\n-  {\n-    return new ModuleNoBody (*this);\n-  }\n+  Module *clone_item_impl () const override { return new Module (*this); }\n };\n \n // Rust extern crate declaration AST node\n@@ -1242,11 +1234,11 @@ class UseTreeList : public UseTree\n   PathType path_type;\n   SimplePath path;\n \n-  std::vector<std::unique_ptr<UseTree> > trees;\n+  std::vector<std::unique_ptr<UseTree>> trees;\n \n public:\n   UseTreeList (PathType path_type, SimplePath path,\n-\t       std::vector<std::unique_ptr<UseTree> > trees, Location locus)\n+\t       std::vector<std::unique_ptr<UseTree>> trees, Location locus)\n     : UseTree (locus), path_type (path_type), path (std::move (path)),\n       trees (std::move (trees))\n   {\n@@ -1430,7 +1422,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_function_params;\n   // FunctionParams function_params;\n@@ -1463,7 +1455,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   Function (Identifier function_name, FunctionQualifiers qualifiers,\n-\t    std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t    std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t    std::vector<FunctionParam> function_params,\n \t    std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t    std::unique_ptr<BlockExpr> function_body, Visibility vis,\n@@ -1554,11 +1546,11 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -1615,7 +1607,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1635,7 +1627,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   TypeAlias (Identifier new_type_name,\n-\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t     WhereClause where_clause, std::unique_ptr<Type> existing_type,\n \t     Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -1697,11 +1689,11 @@ class TypeAlias : public VisItem, public TraitImplItem\n     return existing_type == nullptr;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -1744,7 +1736,7 @@ class Struct : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1769,11 +1761,11 @@ class Struct : public VisItem\n \n   Identifier get_struct_name () const { return struct_name; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -1789,7 +1781,7 @@ class Struct : public VisItem\n \n protected:\n   Struct (Identifier struct_name,\n-\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t  WhereClause where_clause, Visibility vis, Location locus,\n \t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -1941,7 +1933,7 @@ class StructStruct : public Struct\n \n   // Mega-constructor with all possible fields\n   StructStruct (std::vector<StructField> fields, Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\tWhereClause where_clause, bool is_unit, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -1952,7 +1944,7 @@ class StructStruct : public Struct\n \n   // Unit struct constructor\n   StructStruct (Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\tWhereClause where_clause, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -2092,7 +2084,7 @@ class TupleStruct : public Struct\n \n   // Mega-constructor with all possible fields\n   TupleStruct (std::vector<TupleField> fields, Identifier struct_name,\n-\t       std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t       std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t       WhereClause where_clause, Visibility vis,\n \t       std::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -2304,12 +2296,12 @@ class Enum : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::vector<std::unique_ptr<EnumItem> > items;\n+  std::vector<std::unique_ptr<EnumItem>> items;\n \n   Location locus;\n \n@@ -2328,8 +2320,8 @@ class Enum : public VisItem\n \n   // Mega-constructor\n   Enum (Identifier enum_name, Visibility vis,\n-\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n-\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem> > items,\n+\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem>> items,\n \tstd::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       enum_name (std::move (enum_name)),\n@@ -2386,17 +2378,17 @@ class Enum : public VisItem\n   bool is_marked_for_strip () const override { return enum_name.empty (); }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  std::vector<std::unique_ptr<EnumItem> > &get_variants () { return items; }\n-  const std::vector<std::unique_ptr<EnumItem> > &get_variants () const\n+  std::vector<std::unique_ptr<EnumItem>> &get_variants () { return items; }\n+  const std::vector<std::unique_ptr<EnumItem>> &get_variants () const\n   {\n     return items;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -2421,7 +2413,7 @@ class Union : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -2440,7 +2432,7 @@ class Union : public VisItem\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n   Union (Identifier union_name, Visibility vis,\n-\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t WhereClause where_clause, std::vector<StructField> variants,\n \t std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -2502,11 +2494,11 @@ class Union : public VisItem\n       }\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -2757,7 +2749,7 @@ struct TraitFunctionDecl\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_params;\n   // FunctionParams function_params;\n@@ -2788,7 +2780,7 @@ struct TraitFunctionDecl\n \n   // Mega-constructor\n   TraitFunctionDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\t     std::vector<FunctionParam> function_params,\n \t\t     std::unique_ptr<Type> return_type,\n \t\t     WhereClause where_clause)\n@@ -2854,11 +2846,11 @@ struct TraitFunctionDecl\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -2979,7 +2971,7 @@ struct TraitMethodDecl\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   SelfParam self_param;\n \n@@ -3012,7 +3004,7 @@ struct TraitMethodDecl\n \n   // Mega-constructor\n   TraitMethodDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t   std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\t   std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\t   SelfParam self_param,\n \t\t   std::vector<FunctionParam> function_params,\n \t\t   std::unique_ptr<Type> return_type, WhereClause where_clause)\n@@ -3081,11 +3073,11 @@ struct TraitMethodDecl\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -3315,7 +3307,7 @@ class TraitItemType : public TraitItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   Location locus;\n@@ -3324,10 +3316,9 @@ class TraitItemType : public TraitItem\n   // Returns whether trait item type has type param bounds.\n   bool has_type_param_bounds () const { return !type_param_bounds.empty (); }\n \n-  TraitItemType (\n-    Identifier name,\n-    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n-    std::vector<Attribute> outer_attrs, Location locus)\n+  TraitItemType (Identifier name,\n+\t\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+\t\t std::vector<Attribute> outer_attrs, Location locus)\n     : TraitItem (), outer_attrs (std::move (outer_attrs)),\n       name (std::move (name)),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n@@ -3378,11 +3369,11 @@ class TraitItemType : public TraitItem\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -3403,11 +3394,11 @@ class Trait : public VisItem\n {\n   bool has_unsafe;\n   Identifier name;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params;\n-  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<GenericParam>> generic_params;\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n   WhereClause where_clause;\n   std::vector<Attribute> inner_attrs;\n-  std::vector<std::unique_ptr<TraitItem> > trait_items;\n+  std::vector<std::unique_ptr<TraitItem>> trait_items;\n   Location locus;\n \n public:\n@@ -3434,10 +3425,10 @@ class Trait : public VisItem\n \n   // Mega-constructor\n   Trait (Identifier name, bool is_unsafe,\n-\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n-\t std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n \t WhereClause where_clause,\n-\t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n+\t std::vector<std::unique_ptr<TraitItem>> trait_items, Visibility vis,\n \t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n \t Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -3509,29 +3500,29 @@ class Trait : public VisItem\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  const std::vector<std::unique_ptr<TraitItem> > &get_trait_items () const\n+  const std::vector<std::unique_ptr<TraitItem>> &get_trait_items () const\n   {\n     return trait_items;\n   }\n-  std::vector<std::unique_ptr<TraitItem> > &get_trait_items ()\n+  std::vector<std::unique_ptr<TraitItem>> &get_trait_items ()\n   {\n     return trait_items;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n \n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -3561,7 +3552,7 @@ class Impl : public VisItem\n protected:\n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   std::unique_ptr<Type> trait_type;\n \n@@ -3595,11 +3586,11 @@ class Impl : public VisItem\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -3620,7 +3611,7 @@ class Impl : public VisItem\n \n protected:\n   // Mega-constructor\n-  Impl (std::vector<std::unique_ptr<GenericParam> > generic_params,\n+  Impl (std::vector<std::unique_ptr<GenericParam>> generic_params,\n \tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n \tVisibility vis, std::vector<Attribute> inner_attrs,\n \tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -3675,7 +3666,7 @@ class Impl : public VisItem\n class InherentImpl : public Impl\n {\n   // bool has_impl_items;\n-  std::vector<std::unique_ptr<InherentImplItem> > impl_items;\n+  std::vector<std::unique_ptr<InherentImplItem>> impl_items;\n \n public:\n   std::string as_string () const override;\n@@ -3684,8 +3675,8 @@ class InherentImpl : public Impl\n   bool has_impl_items () const { return !impl_items.empty (); }\n \n   // Mega-constructor\n-  InherentImpl (std::vector<std::unique_ptr<InherentImplItem> > impl_items,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+  InherentImpl (std::vector<std::unique_ptr<InherentImplItem>> impl_items,\n+\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n \t\tVisibility vis, std::vector<Attribute> inner_attrs,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -3722,11 +3713,11 @@ class InherentImpl : public Impl\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items () const\n+  const std::vector<std::unique_ptr<InherentImplItem>> &get_impl_items () const\n   {\n     return impl_items;\n   }\n-  std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items ()\n+  std::vector<std::unique_ptr<InherentImplItem>> &get_impl_items ()\n   {\n     return impl_items;\n   }\n@@ -3748,7 +3739,7 @@ class TraitImpl : public Impl\n   TypePath trait_path;\n \n   // bool has_impl_items;\n-  std::vector<std::unique_ptr<TraitImplItem> > impl_items;\n+  std::vector<std::unique_ptr<TraitImplItem>> impl_items;\n \n public:\n   std::string as_string () const override;\n@@ -3758,8 +3749,8 @@ class TraitImpl : public Impl\n \n   // Mega-constructor\n   TraitImpl (TypePath trait_path, bool is_unsafe, bool has_exclam,\n-\t     std::vector<std::unique_ptr<TraitImplItem> > impl_items,\n-\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t     std::vector<std::unique_ptr<TraitImplItem>> impl_items,\n+\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t     std::unique_ptr<Type> trait_type, WhereClause where_clause,\n \t     Visibility vis, std::vector<Attribute> inner_attrs,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n@@ -3805,11 +3796,11 @@ class TraitImpl : public Impl\n   bool is_exclam () const { return has_exclam; }\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items () const\n+  const std::vector<std::unique_ptr<TraitImplItem>> &get_impl_items () const\n   {\n     return impl_items;\n   }\n-  std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items ()\n+  std::vector<std::unique_ptr<TraitImplItem>> &get_impl_items ()\n   {\n     return impl_items;\n   }\n@@ -4116,7 +4107,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_return_type;\n   // FunctionReturnType return_type;\n@@ -4158,7 +4149,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   ExternalFunctionItem (\n     Identifier item_name,\n-    std::vector<std::unique_ptr<GenericParam> > generic_params,\n+    std::vector<std::unique_ptr<GenericParam>> generic_params,\n     std::unique_ptr<Type> return_type, WhereClause where_clause,\n     std::vector<NamedFunctionParam> function_params, bool has_variadics,\n     std::vector<Attribute> variadic_outer_attrs, Visibility vis,\n@@ -4246,11 +4237,11 @@ class ExternalFunctionItem : public ExternalItem\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -4290,7 +4281,7 @@ class ExternBlock : public VisItem\n   std::vector<Attribute> inner_attrs;\n \n   // bool has_extern_items;\n-  std::vector<std::unique_ptr<ExternalItem> > extern_items;\n+  std::vector<std::unique_ptr<ExternalItem>> extern_items;\n \n   Location locus;\n \n@@ -4312,7 +4303,7 @@ class ExternBlock : public VisItem\n   std::string get_abi () const { return abi; }\n \n   ExternBlock (std::string abi,\n-\t       std::vector<std::unique_ptr<ExternalItem> > extern_items,\n+\t       std::vector<std::unique_ptr<ExternalItem>> extern_items,\n \t       Visibility vis, std::vector<Attribute> inner_attrs,\n \t       std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)), abi (std::move (abi)),\n@@ -4359,11 +4350,11 @@ class ExternBlock : public VisItem\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<ExternalItem> > &get_extern_items () const\n+  const std::vector<std::unique_ptr<ExternalItem>> &get_extern_items () const\n   {\n     return extern_items;\n   }\n-  std::vector<std::unique_ptr<ExternalItem> > &get_extern_items ()\n+  std::vector<std::unique_ptr<ExternalItem>> &get_extern_items ()\n   {\n     return extern_items;\n   }"}]}