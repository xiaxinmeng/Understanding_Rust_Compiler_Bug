{"sha": "8236f02792de3882bb662d8a2f5915c1625bbc38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzNmYwMjc5MmRlMzg4MmJiNjYyZDhhMmY1OTE1YzE2MjViYmMzOA==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2007-12-13T10:42:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:42:54Z"}, "message": "a-cohase.ads, [...]: Document which generic formal operations are called for each operation.\n\n2007-12-06  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cohase.ads, a-cihama.ads, a-cihase.ads, a-cohama.ads: Document\n\twhich generic formal operations are called for each operation.\n\nFrom-SVN: r130873", "tree": {"sha": "4c8dfedb8a9e5c3bc46db83d3470b46145310470", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c8dfedb8a9e5c3bc46db83d3470b46145310470"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8236f02792de3882bb662d8a2f5915c1625bbc38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8236f02792de3882bb662d8a2f5915c1625bbc38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8236f02792de3882bb662d8a2f5915c1625bbc38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8236f02792de3882bb662d8a2f5915c1625bbc38/comments", "author": null, "committer": null, "parents": [{"sha": "a2ad1f7960d5b070f377c8979867c7bc97785304", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ad1f7960d5b070f377c8979867c7bc97785304", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ad1f7960d5b070f377c8979867c7bc97785304"}], "stats": {"total": 658, "additions": 626, "deletions": 32}, "files": [{"sha": "5e0aea0119ac5007d9c50e8a3b198ce01b4d05aa", "filename": "gcc/ada/a-cihama.ads", "status": "modified", "additions": 113, "deletions": 8, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8236f02792de3882bb662d8a2f5915c1625bbc38/gcc%2Fada%2Fa-cihama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8236f02792de3882bb662d8a2f5915c1625bbc38/gcc%2Fada%2Fa-cihama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.ads?ref=8236f02792de3882bb662d8a2f5915c1625bbc38", "patch": "@@ -34,9 +34,9 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n-with Ada.Containers.Hash_Tables;\n-with Ada.Streams;\n-with Ada.Finalization;\n+private with Ada.Containers.Hash_Tables;\n+private with Ada.Streams;\n+private with Ada.Finalization;\n \n generic\n    type Key_Type (<>) is private;\n@@ -57,95 +57,198 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n    pragma Preelaborable_Initialization (Cursor);\n \n    Empty_Map  : constant Map;\n+   --  Map objects declared without an initialization expression are\n+   --  initialized to the value Empty_Map.\n+\n    No_Element : constant Cursor;\n+   --  Cursor objects declared without an initialization expression are\n+   --  initialized to the value No_Element.\n \n    function \"=\" (Left, Right : Map) return Boolean;\n+   --  For each key/element pair in Left, equality attempts to find the key in\n+   --  Right; if a search fails the equality returns False. The search works by\n+   --  calling Hash to find the bucket in the Right map that corresponds to the\n+   --  Left key. If bucket is non-empty, then equality calls Equivalent_Keys\n+   --  to compare the key (in Left) to the key of each node in the bucket (in\n+   --  Right); if the keys are equivalent, then the equality test for this\n+   --  key/element pair (in Left) completes by calling the element equality\n+   --  operator to compare the element (in Left) to the element of the node\n+   --  (in Right) whose key matched.\n \n    function Capacity (Container : Map) return Count_Type;\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Map;\n-      Capacity  : Count_Type);\n+   --  Returns the current capacity of the map. Capacity is the maximum length\n+   --  before which rehashing in guaranteed not to occur.\n+\n+   procedure Reserve_Capacity (Container : in out Map; Capacity : Count_Type);\n+   --  Adjusts the current capacity, by allocating a new buckets array. If the\n+   --  requested capacity is less than the current capacity, then the capacity\n+   --  is contracted (to a value not less than the curent length). If the\n+   --  requested capacity is greater than the current capacity, then the\n+   --  capacity is expanded (to a value not less than what is requested). In\n+   --  either case, the nodes are rehashed from the old buckets array onto the\n+   --  new buckets array (Hash is called once for each existing key in order to\n+   --  compute the new index), and then the old buckets array is deallocated.\n \n    function Length (Container : Map) return Count_Type;\n+   --  Returns the number of items in the map\n \n    function Is_Empty (Container : Map) return Boolean;\n+   --  Equivalent to Length (Container) = 0\n \n    procedure Clear (Container : in out Map);\n+   --  Removes all of the items from the map\n \n    function Key (Position : Cursor) return Key_Type;\n+   --  Returns the key of the node designated by the cursor\n \n    function Element (Position : Cursor) return Element_Type;\n+   --  Returns the element of the node designated by the cursor\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n+   --  Assigns the value New_Item to the element designated by the cursor\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Key     : Key_Type;\n                                             Element : Element_Type));\n+   --  Calls Process with the key and element (both having only a constant\n+   --  view) of the node designed by the cursor.\n \n    procedure Update_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       Process   : not null access procedure (Key     : Key_Type;\n-                                            Element : in out Element_Type));\n+                                             Element : in out Element_Type));\n+   --  Calls Process with the key (with only a constant view) and element (with\n+   --  a variable view) of the node designed by the cursor.\n \n    procedure Move (Target : in out Map; Source : in out Map);\n+   --  Clears Target (if it's not empty), and then moves (not copies) the\n+   --  buckets array and nodes from Source to Target.\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n+   --  Conditionally inserts New_Item into the map. If Key is already in the\n+   --  map, then Inserted returns False and Position designates the node\n+   --  containing the existing key/element pair (neither of which is modified).\n+   --  If Key is not already in the map, the Inserted returns True and Position\n+   --  designates the newly-inserted node container Key and New_Item. The\n+   --  search for the key works as follows. Hash is called to determine Key's\n+   --  bucket; if the bucket is non-empty, then Equivalent_Keys is called to\n+   --  compare Key to each node in that bucket. If the bucket is empty, or\n+   --  there were no matching keys in the bucket, the search \"fails\" and the\n+   --  key/item pair is inserted in the map (and Inserted returns True);\n+   --  otherwise, the search \"succeeds\" (and Inserted returns False).\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n+   --  Attempts to insert Key into the map, performing the usual search (which\n+   --  involves calling both Hash and Equivalent_Keys); if the search succeeds\n+   --  (because Key is already in the map), then it raises Constraint_Error.\n+   --  (This version of Insert is similar to Replace, but having the opposite\n+   --  exception behavior. It is intended for use when you want to assert that\n+   --  Key is not already in the map.)\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n+   --  Attempts to insert Key into the map. If Key is already in the map, then\n+   --  both the existing key and element are assigned the values of Key and\n+   --  New_Item, respectively. (This version of Insert only raises an exception\n+   --  if cursor tampering occurs. It is intended for use when you want to\n+   --  insert the key/element pair in the map, and you don't care whether Key\n+   --  is already present.)\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n+   --  Searches for Key in the map; if the search fails (because Key was not in\n+   --  the map), then it raises Constraint_Error. Otherwise, both the existing\n+   --  key and element are assigned the values of Key and New_Item rsp. (This\n+   --  is similar to Insert, but with the opposite exception behavior. It is\n+   --  intended for use when you want to assert that Key is already in the\n+   --  map.)\n \n    procedure Exclude (Container : in out Map; Key : Key_Type);\n+   --  Searches for Key in the map, and if found, removes its node from the map\n+   --  and then deallocates it. The search works as follows. The operation\n+   --  calls Hash to determine the key's bucket; if the bucket is not empty, it\n+   --  calls Equivalent_Keys to compare Key to each key in the bucket. (This is\n+   --  the deletion analog of Include. It is intended for use when you want to\n+   --  remove the item from the map, but don't care whether the key is already\n+   --  in the map.)\n \n    procedure Delete (Container : in out Map; Key : Key_Type);\n+   --  Searches for Key in the map (which involves calling both Hash and\n+   --  Equivalent_Keys). If the search fails, then the operation raises\n+   --  Constraint_Eror. Otherwise it removes the node from the map and then\n+   --  deallocates it. (This is the deletion analog of non-conditional\n+   --  Insert. It is intended for use when you want to assert that the item is\n+   --  already in the map.)\n \n    procedure Delete (Container : in out Map; Position : in out Cursor);\n+   --  Removes the node designated by Position from the map, and then\n+   --  deallocates the node. The operation calls Hash to determine the bucket,\n+   --  and then compares Position to each node in the bucket until there's a\n+   --  match (it does not call Equivalent_Keys).\n \n    function First (Container : Map) return Cursor;\n+   --  Returns a cursor that designates the first non-empty bucket, by\n+   --  searching from the beginning of the buckets array.\n \n    function Next (Position : Cursor) return Cursor;\n+   --  Returns a cursor that designates the node that follows the current one\n+   --  designated by Position. If Position designates the last node in its\n+   --  bucket, the operation calls Hash to compute the index of this bucket,\n+   --  and searches the buckets array for the first non-empty bucket, starting\n+   --  from that index; otherwise, it simply follows the link to the next node\n+   --  in the same bucket.\n \n    procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n \n    function Find (Container : Map; Key : Key_Type) return Cursor;\n+   --  Searches for Key in the map. Find calls Hash to determine the key's\n+   --  bucket; if the bucket is not empty, it calls Equivalent_Keys to compare\n+   --  Key to each key in the bucket. If the search succeeds, Find returns a\n+   --  cursor designating the matching node; otherwise, it returns No_Element.\n \n    function Contains (Container : Map; Key : Key_Type) return Boolean;\n+   --  Equivalent to Find (Container, Key) /= No_Element\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type;\n+   --  Equivalent to Element (Find (Container, Key))\n \n    function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n \n    function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with the keys of the nodes\n+   --  designated by cursors Left and Right.\n \n    function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with key of the node\n+   --  designated by Left and key Right.\n \n    function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with key Left and the node\n+   --  designated by Right.\n \n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process for each node in the map\n \n private\n    pragma Inline (\"=\");\n@@ -186,8 +289,10 @@ private\n    use Ada.Finalization;\n    use Ada.Streams;\n \n+   overriding\n    procedure Adjust (Container : in out Map);\n \n+   overriding\n    procedure Finalize (Container : in out Map);\n \n    type Map_Access is access constant Map;"}, {"sha": "aaf183b01c88fcefbf8cc1101eb025453a639d0a", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 197, "deletions": 7, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8236f02792de3882bb662d8a2f5915c1625bbc38/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8236f02792de3882bb662d8a2f5915c1625bbc38/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=8236f02792de3882bb662d8a2f5915c1625bbc38", "patch": "@@ -59,114 +59,270 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n    pragma Preelaborable_Initialization (Cursor);\n \n    Empty_Set : constant Set;\n+   --  Set objects declared without an initialization expression are\n+   --  initialized to the value Empty_Set.\n \n    No_Element : constant Cursor;\n+   --  Cursor objects declared without an initialization expression are\n+   --  initialized to the value No_Element.\n \n    function \"=\" (Left, Right : Set) return Boolean;\n+   --  For each element in Left, set equality attempts to find the equal\n+   --  element in Right; if a search fails, then set equality immediately\n+   --  returns False. The search works by calling Hash to find the bucket in\n+   --  the Right set that corresponds to the Left element. If the bucket is\n+   --  non-empty, the search calls the generic formal element equality operator\n+   --  to compare the element (in Left) to the element of each node in the\n+   --  bucket (in Right); the search terminates when a matching node in the\n+   --  bucket is found, or the nodes in the bucket are exhausted. (Note that\n+   --  element equality is called here, not Equivalent_Elements. Set equality\n+   --  is the only operation in which element equality is used. Compare set\n+   --  equality to Equivalent_Sets, which does call Equivalent_Elements.)\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n+   --  Similar to set equality, with the difference that the element in Left is\n+   --  compared to the elements in Right using the generic formal\n+   --  Equivalent_Elements operation instead of element equality.\n \n    function To_Set (New_Item : Element_Type) return Set;\n+   --  Constructs a singleton set comprising New_Element. To_Set calls Hash to\n+   --  determine the bucket for New_Item.\n \n    function Capacity (Container : Set) return Count_Type;\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : Count_Type);\n+   --  Returns the current capacity of the set. Capacity is the maximum length\n+   --  before which rehashing in guaranteed not to occur.\n+\n+   procedure Reserve_Capacity (Container : in out Set; Capacity : Count_Type);\n+   --  Adjusts the current capacity, by allocating a new buckets array. If the\n+   --  requested capacity is less than the current capacity, then the capacity\n+   --  is contracted (to a value not less than the current length). If the\n+   --  requested capacity is greater than the current capacity, then the\n+   --  capacity is expanded (to a value not less than what is requested). In\n+   --  either case, the nodes are rehashed from the old buckets array onto the\n+   --  new buckets array (Hash is called once for each existing element in\n+   --  order to compute the new index), and then the old buckets array is\n+   --  deallocated.\n \n    function Length (Container : Set) return Count_Type;\n+   --  Returns the number of items in the set\n \n    function Is_Empty (Container : Set) return Boolean;\n+   --  Equivalent to Length (Container) = 0\n \n    procedure Clear (Container : in out Set);\n+   --  Removes all of the items from the set\n \n    function Element (Position : Cursor) return Element_Type;\n+   --  Returns the element of the node designated by the cursor\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n+   --  If New_Item is equivalent (as determined by calling Equivalent_Elements)\n+   --  to the element of the node designated by Position, then New_Element is\n+   --  assigned to that element. Otherwise, it calls Hash to determine the\n+   --  bucket for New_Item. If the bucket is not empty, then it calls\n+   --  Equivalent_Elements for each node in that bucket to determine whether\n+   --  New_Item is equivalent to an element in that bucket. If\n+   --  Equivalent_Elements returns True then Program_Error is raised (because\n+   --  an element may appear only once in the set); otherwise, New_Item is\n+   --  assigned to the node designated by Position, and the node is moved to\n+   --  its new bucket.\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n+   --  Calls Process with the element (having only a constant view) of the node\n+   --  designed by the cursor.\n \n-   procedure Move\n-     (Target : in out Set;\n-      Source : in out Set);\n+   procedure Move (Target : in out Set; Source : in out Set);\n+   --  Clears Target (if it's not empty), and then moves (not copies) the\n+   --  buckets array and nodes from Source to Target.\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n+   --  Conditionally inserts New_Item into the set. If New_Item is already in\n+   --  the set, then Inserted returns False and Position designates the node\n+   --  containing the existing element (which is not modified). If New_Item is\n+   --  not already in the set, then Inserted returns True and Position\n+   --  designates the newly-inserted node containing New_Item. The search for\n+   --  an existing element works as follows. Hash is called to determine\n+   --  New_Item's bucket; if the bucket is non-empty, then Equivalent_Elements\n+   --  is called to compare New_Item to the element of each node in that\n+   --  bucket. If the bucket is empty, or there were no equivalent elements in\n+   --  the bucket, the search \"fails\" and the New_Item is inserted in the set\n+   --  (and Inserted returns True); otherwise, the search \"succeeds\" (and\n+   --  Inserted returns False).\n \n    procedure Insert  (Container : in out Set; New_Item : Element_Type);\n+   --  Attempts to insert New_Item into the set, performing the usual insertion\n+   --  search (which involves calling both Hash and Equivalent_Elements); if\n+   --  the search succeeds (New_Item is equivalent to an element already in the\n+   --  set, and so was not inserted), then this operation raises\n+   --  Constraint_Error. (This version of Insert is similar to Replace, but\n+   --  having the opposite exception behavior. It is intended for use when you\n+   --  want to assert that the item is not already in the set.)\n \n    procedure Include (Container : in out Set; New_Item : Element_Type);\n+   --  Attempts to insert New_Item into the set. If an element equivalent to\n+   --  New_Item is already in the set (the insertion search succeeded, and\n+   --  hence New_Item was not inserted), then the value of New_Item is assigned\n+   --  to the existing element. (This insertion operation only raises an\n+   --  exception if cursor tampering occurs. It is intended for use when you\n+   --  want to insert the item in the set, and you don't care whether an\n+   --  equivalent element is already present.)\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type);\n+   --  Searches for New_Item in the set; if the search fails (because an\n+   --  equivalent element was not in the set), then it raises\n+   --  Constraint_Error. Otherwise, the existing element is assigned the value\n+   --  New_Item. (This is similar to Insert, but with the opposite exception\n+   --  behavior. It is intended for use when you want to assert that the item\n+   --  is already in the set.)\n \n    procedure Exclude (Container : in out Set; Item : Element_Type);\n+   --  Searches for Item in the set, and if found, removes its node from the\n+   --  set and then deallocates it. The search works as follows. The operation\n+   --  calls Hash to determine the item's bucket; if the bucket is not empty,\n+   --  it calls Equivalent_Elements to compare Item to the element of each node\n+   --  in the bucket. (This is the deletion analog of Include. It is intended\n+   --  for use when you want to remove the item from the set, but don't care\n+   --  whether the item is already in the set.)\n \n    procedure Delete  (Container : in out Set; Item : Element_Type);\n+   --  Searches for Item in the set (which involves calling both Hash and\n+   --  Equivalent_Elements). If the search fails, then the operation raises\n+   --  Constraint_Error. Otherwise it removes the node from the set and then\n+   --  deallocates it. (This is the deletion analog of non-conditional\n+   --  Insert. It is intended for use when you want to assert that the item is\n+   --  already in the set.)\n \n    procedure Delete (Container : in out Set; Position  : in out Cursor);\n+   --  Removes the node designated by Position from the set, and then\n+   --  deallocates the node. The operation calls Hash to determine the bucket,\n+   --  and then compares Position to each node in the bucket until there's a\n+   --  match (it does not call Equivalent_Elements).\n \n    procedure Union (Target : in out Set; Source : Set);\n+   --  The operation first calls Reserve_Capacity if the current capacity is\n+   --  less than the sum of the lengths of Source and Target. It then iterates\n+   --  over the Source set, and conditionally inserts each element into Target.\n \n    function Union (Left, Right : Set) return Set;\n+   --  The operation first copies the Left set to the result, and then iterates\n+   --  over the Right set to conditionally insert each element into the result.\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n    procedure Intersection (Target : in out Set; Source : Set);\n+   --  Iterates over the Target set (calling First and Next), calling Find to\n+   --  determine whether the element is in Source. If an equivalent element is\n+   --  not found in Source, the element is deleted from Target.\n \n    function Intersection (Left, Right : Set) return Set;\n+   --  Iterates over the Left set, calling Find to determine whether the\n+   --  element is in Right. If an equivalent element is found, it is inserted\n+   --  into the result set.\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n    procedure Difference (Target : in out Set; Source : Set);\n+   --  Iterates over the Source (calling First and Next), calling Find to\n+   --  determine whether the element is in Target. If an equivalent element is\n+   --  found, it is deleted from Target.\n \n    function Difference (Left, Right : Set) return Set;\n+   --  Iterates over the Left set, calling Find to determine whether the\n+   --  element is in the Right set. If an equivalent element is not found, the\n+   --  element is inserted into the result set.\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+   --  The operation first calls Reserve_Capacity if the current capacity is\n+   --  less than the sum of the lengths of Source and Target. It then iterates\n+   --  over the Source set, searching for the element in Target (calling Hash\n+   --  and Equivalent_Elements). If an equivalent element is found, it is\n+   --  removed from Target; otherwise it is inserted into Target.\n \n    function Symmetric_Difference (Left, Right : Set) return Set;\n+   --  The operation first iterates over the Left set. It calls Find to\n+   --  determine whether the element is in the Right set. If no equivalent\n+   --  element is found, the element from Left is inserted into the result. The\n+   --  operation then iterates over the Right set, to determine whether the\n+   --  element is in the Left set. If no equivalent element is found, the Right\n+   --  element is inserted into the result.\n \n    function \"xor\" (Left, Right : Set) return Set\n      renames Symmetric_Difference;\n \n    function Overlap (Left, Right : Set) return Boolean;\n+   --  Iterates over the Left set (calling First and Next), calling Find to\n+   --  determine whether the element is in the Right set. If an equivalent\n+   --  element is found, the operation immediately returns True. The operation\n+   --  returns False if the iteration over Left terminates without finding any\n+   --  equivalent element in Right.\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+   --  Iterates over Subset (calling First and Next), calling Find to determine\n+   --  whether the element is in Of_Set. If no equivalent element is found in\n+   --  Of_Set, the operation immediately returns False. The operation returns\n+   --  True if the iteration over Subset terminates without finding an element\n+   --  not in Of_Set (that is, every element in Subset is equivalent to an\n+   --  element in Of_Set).\n \n    function First (Container : Set) return Cursor;\n+   --  Returns a cursor that designates the first non-empty bucket, by\n+   --  searching from the beginning of the buckets array.\n \n    function Next (Position : Cursor) return Cursor;\n+   --  Returns a cursor that designates the node that follows the current one\n+   --  designated by Position. If Position designates the last node in its\n+   --  bucket, the operation calls Hash to compute the index of this bucket,\n+   --  and searches the buckets array for the first non-empty bucket, starting\n+   --  from that index; otherwise, it simply follows the link to the next node\n+   --  in the same bucket.\n \n    procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n \n    function Find (Container : Set; Item : Element_Type) return Cursor;\n+   --  Searches for Item in the set. Find calls Hash to determine the item's\n+   --  bucket; if the bucket is not empty, it calls Equivalent_Elements to\n+   --  compare Item to each element in the bucket. If the search succeeds, Find\n+   --  returns a cursor designating the node containing the equivalent element;\n+   --  otherwise, it returns No_Element.\n \n    function Contains (Container : Set; Item : Element_Type) return Boolean;\n+   --  Equivalent to Find (Container, Item) /= No_Element\n \n    function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n \n    function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with the elements of\n+   --  the nodes designated by cursors Left and Right.\n \n    function Equivalent_Elements\n      (Left  : Cursor;\n       Right : Element_Type) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with element of the\n+   --  node designated by Left and element Right.\n \n    function Equivalent_Elements\n      (Left  : Element_Type;\n       Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with element Left and\n+   --  the element of the node designated by Right.\n \n    procedure Iterate\n      (Container : Set;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process for each node in the set\n \n    generic\n       type Key_Type (<>) is private;\n@@ -180,27 +336,61 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n    package Generic_Keys is\n \n       function Key (Position : Cursor) return Key_Type;\n+      --  Applies generic formal operation Key to the element of the node\n+      --  designated by Position.\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n+      --  Searches (as per the key-based Find) for the node containing Key, and\n+      --  returns the associated element.\n \n       procedure Replace\n         (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type);\n+      --  Searches (as per the key-based Find) for the node containing Key, and\n+      --  then replaces the element of that node (as per the element-based\n+      --  Replace_Element).\n \n       procedure Exclude (Container : in out Set; Key : Key_Type);\n+      --  Searches for Key in the set, and if found, removes its node from the\n+      --  set and then deallocates it. The search works by first calling Hash\n+      --  (on Key) to determine the bucket; if the bucket is not empty, it\n+      --  calls Equivalent_Keys to compare parameter Key to the value of\n+      --  generic formal operation Key applied to element of each node in the\n+      --  bucket.\n \n       procedure Delete (Container : in out Set; Key : Key_Type);\n+      --  Deletes the node containing Key as per Exclude, with the difference\n+      --  that Constraint_Error is raised if Key is not found.\n \n       function Find (Container : Set; Key : Key_Type) return Cursor;\n+      --  Searches for the node containing Key, and returns a cursor\n+      --  designating the node. The search works by first calling Hash (on Key)\n+      --  to determine the bucket. If the bucket is not empty, the search\n+      --  compares Key to the element of each node in the bucket, and returns\n+      --  the matching node. The comparison itself works by applying the\n+      --  generic formal Key operation to the element of the node, and then\n+      --  calling generic formal operation Equivalent_Keys.\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean;\n+      --  Equivalent to Find (Container, Key) /= No_Element\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n                        procedure (Element : in out Element_Type));\n+      --  Calls Process with the element of the node designated by Position,\n+      --  but with the restriction that the key-value of the element is not\n+      --  modified. The operation first makes a copy of the value returned by\n+      --  applying generic formal operation Key on the element of the node, and\n+      --  then calls Process with the element. The operation verifies that the\n+      --  key-part has not been modified by calling generic formal operation\n+      --  Equivalent_Keys to compare the saved key-value to the value returned\n+      --  by applying generic formal operation Key to the post-Process value of\n+      --  element. If the key values compare equal then the operation\n+      --  completes. Otherwise, the node is removed from the map and\n+      --  Program_Error is raised.\n \n    end Generic_Keys;\n "}, {"sha": "9fa6f01b508c4b9491937d3987bcb645974bbc47", "filename": "gcc/ada/a-cohama.ads", "status": "modified", "additions": 114, "deletions": 7, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8236f02792de3882bb662d8a2f5915c1625bbc38/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8236f02792de3882bb662d8a2f5915c1625bbc38/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=8236f02792de3882bb662d8a2f5915c1625bbc38", "patch": "@@ -33,9 +33,9 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n-with Ada.Containers.Hash_Tables;\n-with Ada.Streams;\n-with Ada.Finalization;\n+private with Ada.Containers.Hash_Tables;\n+private with Ada.Streams;\n+private with Ada.Finalization;\n \n generic\n    type Key_Type is private;\n@@ -56,101 +56,206 @@ package Ada.Containers.Hashed_Maps is\n    pragma Preelaborable_Initialization (Cursor);\n \n    Empty_Map : constant Map;\n+   --  Map objects declared without an initialization expression are\n+   --  initialized to the value Empty_Map.\n \n    No_Element : constant Cursor;\n+   --  Cursor objects declared without an initialization expression are\n+   --  initialized to the value No_Element.\n \n    function \"=\" (Left, Right : Map) return Boolean;\n+   --  For each key/element pair in Left, equality attempts to find the key in\n+   --  Right; if a search fails the equality returns False. The search works by\n+   --  calling Hash to find the bucket in the Right map that corresponds to the\n+   --  Left key. If bucket is non-empty, then equality calls Equivalent_Keys\n+   --  to compare the key (in Left) to the key of each node in the bucket (in\n+   --  Right); if the keys are equivalent, then the equality test for this\n+   --  key/element pair (in Left) completes by calling the element equality\n+   --  operator to compare the element (in Left) to the element of the node\n+   --  (in Right) whose key matched.\n \n    function Capacity (Container : Map) return Count_Type;\n-\n-   procedure Reserve_Capacity (Container : in out Map;\n-                               Capacity  : Count_Type);\n+   --  Returns the current capacity of the map. Capacity is the maximum length\n+   --  before which rehashing in guaranteed not to occur.\n+\n+   procedure Reserve_Capacity (Container : in out Map; Capacity : Count_Type);\n+   --  Adjusts the current capacity, by allocating a new buckets array. If the\n+   --  requested capacity is less than the current capacity, then the capacity\n+   --  is contracted (to a value not less than the curent length). If the\n+   --  requested capacity is greater than the current capacity, then the\n+   --  capacity is expanded (to a value not less than what is requested). In\n+   --  either case, the nodes are rehashed from the old buckets array onto the\n+   --  new buckets array (Hash is called once for each existing key in order to\n+   --  compute the new index), and then the old buckets array is deallocated.\n \n    function Length (Container : Map) return Count_Type;\n+   --  Returns the number of items in the map\n \n    function Is_Empty (Container : Map) return Boolean;\n+   --  Equivalent to Length (Container) = 0\n \n    procedure Clear (Container : in out Map);\n+   --  Removes all of the items from the map\n \n    function Key (Position : Cursor) return Key_Type;\n+   --  Returns the key of the node designated by the cursor\n \n    function Element (Position : Cursor) return Element_Type;\n+   --  Returns the element of the node designated by the cursor\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n+   --  Assigns the value New_Item to the element designated by the cursor\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access\n                    procedure (Key : Key_Type; Element : Element_Type));\n+   --  Calls Process with the key and element (both having only a constant\n+   --  view) of the node designed by the cursor.\n \n    procedure Update_Element\n      (Container : in out Map;\n       Position  : Cursor;\n       Process   : not null access\n-                   procedure (Key : Key_Type; Element : in out Element_Type));\n+                    procedure (Key : Key_Type; Element : in out Element_Type));\n+   --  Calls Process with the key (with only a constant view) and element (with\n+   --  a variable view) of the node designed by the cursor.\n \n    procedure Move (Target : in out Map; Source : in out Map);\n+   --  Clears Target (if it's not empty), and then moves (not copies) the\n+   --  buckets array and nodes from Source to Target.\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n+   --  Conditionally inserts New_Item into the map. If Key is already in the\n+   --  map, then Inserted returns False and Position designates the node\n+   --  containing the existing key/element pair (neither of which is modified).\n+   --  If Key is not already in the map, the Inserted returns True and Position\n+   --  designates the newly-inserted node container Key and New_Item. The\n+   --  search for the key works as follows. Hash is called to determine Key's\n+   --  bucket; if the bucket is non-empty, then Equivalent_Keys is called to\n+   --  compare Key to each node in that bucket. If the bucket is empty, or\n+   --  there were no matching keys in the bucket, the search \"fails\" and the\n+   --  key/item pair is inserted in the map (and Inserted returns True);\n+   --  otherwise, the search \"succeeds\" (and Inserted returns False).\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n+   --  The same as the (conditional) Insert that accepts an element parameter,\n+   --  with the difference that if Inserted returns True, then the element of\n+   --  the newly-inserted node is initialized to its default value.\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n+   --  Attempts to insert Key into the map, performing the usual search (which\n+   --  involves calling both Hash and Equivalent_Keys); if the search succeeds\n+   --  (because Key is already in the map), then it raises Constraint_Error.\n+   --  (This version of Insert is similar to Replace, but having the opposite\n+   --  exception behavior. It is intended for use when you want to assert that\n+   --  Key is not already in the map.)\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n+   --  Attempts to insert Key into the map. If Key is already in the map, then\n+   --  both the existing key and element are assigned the values of Key and\n+   --  New_Item, respectively. (This version of Insert only raises an exception\n+   --  if cursor tampering occurs. It is intended for use when you want to\n+   --  insert the key/element pair in the map, and you don't care whether Key\n+   --  is already present.)\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type);\n+   --  Searches for Key in the map; if the search fails (because Key was not in\n+   --  the map), then it raises Constraint_Error. Otherwise, both the existing\n+   --  key and element are assigned the values of Key and New_Item rsp. (This\n+   --  is similar to Insert, but with the opposite exception behavior. It is to\n+   --  be used when you want to assert that Key is already in the map.)\n \n    procedure Exclude (Container : in out Map; Key : Key_Type);\n+   --  Searches for Key in the map, and if found, removes its node from the map\n+   --  and then deallocates it. The search works as follows. The operation\n+   --  calls Hash to determine the key's bucket; if the bucket is not empty, it\n+   --  calls Equivalent_Keys to compare Key to each key in the bucket. (This is\n+   --  the deletion analog of Include. It is intended for use when you want to\n+   --  remove the item from the map, but don't care whether the key is already\n+   --  in the map.)\n \n    procedure Delete (Container : in out Map; Key : Key_Type);\n+   --  Searches for Key in the map (which involves calling both Hash and\n+   --  Equivalent_Keys). If the search fails, then the operation raises\n+   --  Constraint_Eror. Otherwise it removes the node from the map and then\n+   --  deallocates it. (This is the deletion analog of non-conditional\n+   --  Insert. It is intended for use when you want to assert that the item is\n+   --  already in the map.)\n \n    procedure Delete (Container : in out Map; Position : in out Cursor);\n+   --  Removes the node designated by Position from the map, and then\n+   --  deallocates the node. The operation calls Hash to determine the bucket,\n+   --  and then compares Position to each node in the bucket until there's a\n+   --  match (it does not call Equivalent_Keys).\n \n    function First (Container : Map) return Cursor;\n+   --  Returns a cursor that designates the first non-empty bucket, by\n+   --  searching from the beginning of the buckets array.\n \n    function Next (Position : Cursor) return Cursor;\n+   --  Returns a cursor that designates the node that follows the current one\n+   --  designated by Position. If Position designates the last node in its\n+   --  bucket, the operation calls Hash to compute the index of this bucket,\n+   --  and searches the buckets array for the first non-empty bucket, starting\n+   --  from that index; otherwise, it simply follows the link to the next node\n+   --  in the same bucket.\n \n    procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n \n    function Find (Container : Map; Key : Key_Type) return Cursor;\n+   --  Searches for Key in the map. Find calls Hash to determine the key's\n+   --  bucket; if the bucket is not empty, it calls Equivalent_Keys to compare\n+   --  Key to each key in the bucket. If the search succeeds, Find returns a\n+   --  cursor designating the matching node; otherwise, it returns No_Element.\n \n    function Contains (Container : Map; Key : Key_Type) return Boolean;\n+   --  Equivalent to Find (Container, Key) /= No_Element\n \n    function Element (Container : Map; Key : Key_Type) return Element_Type;\n+   --  Equivalent to Element (Find (Container, Key))\n \n    function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n \n    function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with the keys of the nodes\n+   --  designated by cursors Left and Right.\n \n    function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with key of the node\n+   --  designated by Left and key Right.\n \n    function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with key Left and the node\n+   --  designated by Right.\n \n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process for each node in the map\n \n private\n    pragma Inline (\"=\");\n@@ -187,8 +292,10 @@ private\n    use HT_Types;\n    use Ada.Finalization;\n \n+   overriding\n    procedure Adjust (Container : in out Map);\n \n+   overriding\n    procedure Finalize (Container : in out Map);\n \n    use Ada.Streams;"}, {"sha": "e1600ff73731dc93a21d144f8c9b7d4442d9fbef", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 202, "deletions": 10, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8236f02792de3882bb662d8a2f5915c1625bbc38/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8236f02792de3882bb662d8a2f5915c1625bbc38/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=8236f02792de3882bb662d8a2f5915c1625bbc38", "patch": "@@ -58,114 +58,272 @@ package Ada.Containers.Hashed_Sets is\n    pragma Preelaborable_Initialization (Cursor);\n \n    Empty_Set : constant Set;\n+   --  Set objects declared without an initialization expression are\n+   --  initialized to the value Empty_Set.\n \n    No_Element : constant Cursor;\n+   --  Cursor objects declared without an initialization expression are\n+   --  initialized to the value No_Element.\n \n    function \"=\" (Left, Right : Set) return Boolean;\n+   --  For each element in Left, set equality attempts to find the equal\n+   --  element in Right; if a search fails, then set equality immediately\n+   --  returns False. The search works by calling Hash to find the bucket in\n+   --  the Right set that corresponds to the Left element. If the bucket is\n+   --  non-empty, the search calls the generic formal element equality operator\n+   --  to compare the element (in Left) to the element of each node in the\n+   --  bucket (in Right); the search terminates when a matching node in the\n+   --  bucket is found, or the nodes in the bucket are exhausted. (Note that\n+   --  element equality is called here, not Equivalent_Elements. Set equality\n+   --  is the only operation in which element equality is used. Compare set\n+   --  equality to Equivalent_Sets, which does call Equivalent_Elements.)\n \n    function Equivalent_Sets (Left, Right : Set) return Boolean;\n+   --  Similar to set equality, with the difference that the element in Left is\n+   --  compared to the elements in Right using the generic formal\n+   --  Equivalent_Elements operation instead of element equality.\n \n    function To_Set (New_Item : Element_Type) return Set;\n+   --  Constructs a singleton set comprising New_Element. To_Set calls Hash to\n+   --  determine the bucket for New_Item.\n \n    function Capacity (Container : Set) return Count_Type;\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : Count_Type);\n+   --  Returns the current capacity of the set. Capacity is the maximum length\n+   --  before which rehashing in guaranteed not to occur.\n+\n+   procedure Reserve_Capacity (Container : in out Set; Capacity : Count_Type);\n+   --  Adjusts the current capacity, by allocating a new buckets array. If the\n+   --  requested capacity is less than the current capacity, then the capacity\n+   --  is contracted (to a value not less than the current length). If the\n+   --  requested capacity is greater than the current capacity, then the\n+   --  capacity is expanded (to a value not less than what is requested). In\n+   --  either case, the nodes are rehashed from the old buckets array onto the\n+   --  new buckets array (Hash is called once for each existing element in\n+   --  order to compute the new index), and then the old buckets array is\n+   --  deallocated.\n \n    function Length (Container : Set) return Count_Type;\n+   --  Returns the number of items in the set\n \n    function Is_Empty (Container : Set) return Boolean;\n+   --  Equivalent to Length (Container) = 0\n \n    procedure Clear (Container : in out Set);\n+   --  Removes all of the items from the set\n \n    function Element (Position : Cursor) return Element_Type;\n+   --  Returns the element of the node designated by the cursor\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n       New_Item  : Element_Type);\n+   --  If New_Item is equivalent (as determined by calling Equivalent_Elements)\n+   --  to the element of the node designated by Position, then New_Element is\n+   --  assigned to that element. Otherwise, it calls Hash to determine the\n+   --  bucket for New_Item. If the bucket is not empty, then it calls\n+   --  Equivalent_Elements for each node in that bucket to determine whether\n+   --  New_Item is equivalent to an element in that bucket. If\n+   --  Equivalent_Elements returns True then Program_Error is raised (because\n+   --  an element may appear only once in the set); otherwise, New_Item is\n+   --  assigned to the node designated by Position, and the node is moved to\n+   --  its new bucket.\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type));\n+   --  Calls Process with the element (having only a constant view) of the node\n+   --  designed by the cursor.\n \n    procedure Move (Target : in out Set; Source : in out Set);\n+   --  Clears Target (if it's not empty), and then moves (not copies) the\n+   --  buckets array and nodes from Source to Target.\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n       Inserted  : out Boolean);\n+   --  Conditionally inserts New_Item into the set. If New_Item is already in\n+   --  the set, then Inserted returns False and Position designates the node\n+   --  containing the existing element (which is not modified). If New_Item is\n+   --  not already in the set, then Inserted returns True and Position\n+   --  designates the newly-inserted node containing New_Item. The search for\n+   --  an existing element works as follows. Hash is called to determine\n+   --  New_Item's bucket; if the bucket is non-empty, then Equivalent_Elements\n+   --  is called to compare New_Item to the element of each node in that\n+   --  bucket. If the bucket is empty, or there were no equivalent elements in\n+   --  the bucket, the search \"fails\" and the New_Item is inserted in the set\n+   --  (and Inserted returns True); otherwise, the search \"succeeds\" (and\n+   --  Inserted returns False).\n \n    procedure Insert  (Container : in out Set; New_Item : Element_Type);\n+   --  Attempts to insert New_Item into the set, performing the usual insertion\n+   --  search (which involves calling both Hash and Equivalent_Elements); if\n+   --  the search succeeds (New_Item is equivalent to an element already in the\n+   --  set, and so was not inserted), then this operation raises\n+   --  Constraint_Error. (This version of Insert is similar to Replace, but\n+   --  having the opposite exception behavior. It is intended for use when you\n+   --  want to assert that the item is not already in the set.)\n \n    procedure Include (Container : in out Set; New_Item : Element_Type);\n+   --  Attempts to insert New_Item into the set. If an element equivalent to\n+   --  New_Item is already in the set (the insertion search succeeded, and\n+   --  hence New_Item was not inserted), then the value of New_Item is assigned\n+   --  to the existing element. (This insertion operation only raises an\n+   --  exception if cursor tampering occurs. It is intended for use when you\n+   --  want to insert the item in the set, and you don't care whether an\n+   --  equivalent element is already present.)\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type);\n-\n-   procedure Exclude (Container : in out Set; Item     : Element_Type);\n-\n-   procedure Delete  (Container : in out Set; Item     : Element_Type);\n-\n-   procedure Delete (Container : in out Set; Position  : in out Cursor);\n+   --  Searches for New_Item in the set; if the search fails (because an\n+   --  equivalent element was not in the set), then it raises\n+   --  Constraint_Error. Otherwise, the existing element is assigned the value\n+   --  New_Item. (This is similar to Insert, but with the opposite exception\n+   --  behavior. It is intended for use when you want to assert that the item\n+   --  is already in the set.)\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type);\n+   --  Searches for Item in the set, and if found, removes its node from the\n+   --  set and then deallocates it. The search works as follows. The operation\n+   --  calls Hash to determine the item's bucket; if the bucket is not empty,\n+   --  it calls Equivalent_Elements to compare Item to the element of each node\n+   --  in the bucket. (This is the deletion analog of Include. It is intended\n+   --  for use when you want to remove the item from the set, but don't care\n+   --  whether the item is already in the set.)\n+\n+   procedure Delete  (Container : in out Set; Item : Element_Type);\n+   --  Searches for Item in the set (which involves calling both Hash and\n+   --  Equivalent_Elements). If the search fails, then the operation raises\n+   --  Constraint_Error. Otherwise it removes the node from the set and then\n+   --  deallocates it. (This is the deletion analog of non-conditional\n+   --  Insert. It is intended for use when you want to assert that the item is\n+   --  already in the set.)\n+\n+   procedure Delete (Container : in out Set; Position : in out Cursor);\n+   --  Removes the node designated by Position from the set, and then\n+   --  deallocates the node. The operation calls Hash to determine the bucket,\n+   --  and then compares Position to each node in the bucket until there's a\n+   --  match (it does not call Equivalent_Elements).\n \n    procedure Union (Target : in out Set; Source : Set);\n+   --  The operation first calls Reserve_Capacity if the current capacity is\n+   --  less than the sum of the lengths of Source and Target. It then iterates\n+   --  over the Source set, and conditionally inserts each element into Target.\n \n    function Union (Left, Right : Set) return Set;\n+   --  The operation first copies the Left set to the result, and then iterates\n+   --  over the Right set to conditionally insert each element into the result.\n \n    function \"or\" (Left, Right : Set) return Set renames Union;\n \n    procedure Intersection (Target : in out Set; Source : Set);\n+   --  Iterates over the Target set (calling First and Next), calling Find to\n+   --  determine whether the element is in Source. If an equivalent element is\n+   --  not found in Source, the element is deleted from Target.\n \n    function Intersection (Left, Right : Set) return Set;\n+   --  Iterates over the Left set, calling Find to determine whether the\n+   --  element is in Right. If an equivalent element is found, it is inserted\n+   --  into the result set.\n \n    function \"and\" (Left, Right : Set) return Set renames Intersection;\n \n    procedure Difference (Target : in out Set; Source : Set);\n+   --  Iterates over the Source (calling First and Next), calling Find to\n+   --  determine whether the element is in Target. If an equivalent element is\n+   --  found, it is deleted from Target.\n \n    function Difference (Left, Right : Set) return Set;\n+   --  Iterates over the Left set, calling Find to determine whether the\n+   --  element is in the Right set. If an equivalent element is not found, the\n+   --  element is inserted into the result set.\n \n    function \"-\" (Left, Right : Set) return Set renames Difference;\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+   --  The operation first calls Reserve_Capacity if the current capacity is\n+   --  less than the sum of the lengths of Source and Target. It then iterates\n+   --  over the Source set, searching for the element in Target (calling Hash\n+   --  and Equivalent_Elements). If an equivalent element is found, it is\n+   --  removed from Target; otherwise it is inserted into Target.\n \n    function Symmetric_Difference (Left, Right : Set) return Set;\n+   --  The operation first iterates over the Left set. It calls Find to\n+   --  determine whether the element is in the Right set. If no equivalent\n+   --  element is found, the element from Left is inserted into the result. The\n+   --  operation then iterates over the Right set, to determine whether the\n+   --  element is in the Left set. If no equivalent element is found, the Right\n+   --  element is inserted into the result.\n \n    function \"xor\" (Left, Right : Set) return Set\n      renames Symmetric_Difference;\n \n    function Overlap (Left, Right : Set) return Boolean;\n+   --  Iterates over the Left set (calling First and Next), calling Find to\n+   --  determine whether the element is in the Right set. If an equivalent\n+   --  element is found, the operation immediately returns True. The operation\n+   --  returns False if the iteration over Left terminates without finding any\n+   --  equivalent element in Right.\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+   --  Iterates over Subset (calling First and Next), calling Find to determine\n+   --  whether the element is in Of_Set. If no equivalent element is found in\n+   --  Of_Set, the operation immediately returns False. The operation returns\n+   --  True if the iteration over Subset terminates without finding an element\n+   --  not in Of_Set (that is, every element in Subset is equivalent to an\n+   --  element in Of_Set).\n \n    function First (Container : Set) return Cursor;\n+   --  Returns a cursor that designates the first non-empty bucket, by\n+   --  searching from the beginning of the buckets array.\n \n    function Next (Position : Cursor) return Cursor;\n+   --  Returns a cursor that designates the node that follows the current one\n+   --  designated by Position. If Position designates the last node in its\n+   --  bucket, the operation calls Hash to compute the index of this bucket,\n+   --  and searches the buckets array for the first non-empty bucket, starting\n+   --  from that index; otherwise, it simply follows the link to the next node\n+   --  in the same bucket.\n \n    procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n \n    function Find\n      (Container : Set;\n       Item      : Element_Type) return Cursor;\n+   --  Searches for Item in the set. Find calls Hash to determine the item's\n+   --  bucket; if the bucket is not empty, it calls Equivalent_Elements to\n+   --  compare Item to each element in the bucket. If the search succeeds, Find\n+   --  returns a cursor designating the node containing the equivalent element;\n+   --  otherwise, it returns No_Element.\n \n    function Contains (Container : Set; Item : Element_Type) return Boolean;\n+   --  Equivalent to Find (Container, Item) /= No_Element\n \n    function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n \n    function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with the elements of\n+   --  the nodes designated by cursors Left and Right.\n \n    function Equivalent_Elements\n      (Left  : Cursor;\n       Right : Element_Type) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with element of the\n+   --  node designated by Left and element Right.\n \n    function Equivalent_Elements\n      (Left  : Element_Type;\n       Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with element Left and\n+   --  the element of the node designated by Right.\n \n    procedure Iterate\n      (Container : Set;\n       Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process for each node in the set\n \n    generic\n       type Key_Type (<>) is private;\n@@ -179,27 +337,61 @@ package Ada.Containers.Hashed_Sets is\n    package Generic_Keys is\n \n       function Key (Position : Cursor) return Key_Type;\n+      --  Applies generic formal operation Key to the element of the node\n+      --  designated by Position.\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type;\n+      --  Searches (as per the key-based Find) for the node containing Key, and\n+      --  returns the associated element.\n \n       procedure Replace\n         (Container : in out Set;\n          Key       : Key_Type;\n          New_Item  : Element_Type);\n+      --  Searches (as per the key-based Find) for the node containing Key, and\n+      --  then replaces the element of that node (as per the element-based\n+      --  Replace_Element).\n \n       procedure Exclude (Container : in out Set; Key : Key_Type);\n+      --  Searches for Key in the set, and if found, removes its node from the\n+      --  set and then deallocates it. The search works by first calling Hash\n+      --  (on Key) to determine the bucket; if the bucket is not empty, it\n+      --  calls Equivalent_Keys to compare parameter Key to the value of\n+      --  generic formal operation Key applied to element of each node in the\n+      --  bucket.\n \n       procedure Delete (Container : in out Set; Key : Key_Type);\n+      --  Deletes the node containing Key as per Exclude, with the difference\n+      --  that Constraint_Error is raised if Key is not found.\n \n       function Find (Container : Set; Key : Key_Type) return Cursor;\n+      --  Searches for the node containing Key, and returns a cursor\n+      --  designating the node. The search works by first calling Hash (on Key)\n+      --  to determine the bucket. If the bucket is not empty, the search\n+      --  compares Key to the element of each node in the bucket, and returns\n+      --  the matching node. The comparison itself works by applying the\n+      --  generic formal Key operation to the element of the node, and then\n+      --  calling generic formal operation Equivalent_Keys.\n \n       function Contains (Container : Set; Key : Key_Type) return Boolean;\n+      --  Equivalent to Find (Container, Key) /= No_Element\n \n       procedure Update_Element_Preserving_Key\n         (Container : in out Set;\n          Position  : Cursor;\n          Process   : not null access\n                        procedure (Element : in out Element_Type));\n+      --  Calls Process with the element of the node designated by Position,\n+      --  but with the restriction that the key-value of the element is not\n+      --  modified. The operation first makes a copy of the value returned by\n+      --  applying generic formal operation Key on the element of the node, and\n+      --  then calls Process with the element. The operation verifies that the\n+      --  key-part has not been modified by calling generic formal operation\n+      --  Equivalent_Keys to compare the saved key-value to the value returned\n+      --  by applying generic formal operation Key to the post-Process value of\n+      --  element. If the key values compare equal then the operation\n+      --  completes. Otherwise, the node is removed from the map and\n+      --  Program_Error is raised.\n \n    end Generic_Keys;\n "}]}