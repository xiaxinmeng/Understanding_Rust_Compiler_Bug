{"sha": "2afe03827a683d96021100c6d04d72e13f34d582", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFmZTAzODI3YTY4M2Q5NjAyMTEwMGM2ZDA0ZDcyZTEzZjM0ZDU4Mg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-11-02T09:34:13Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-11-02T09:34:13Z"}, "message": "re PR c++/29234 (Call to operator() of temporary object wrongly parsed)\n\n/cp\n2013-11-02  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/29234\n\tPR c++/56037\n\t* parser.c (cp_parser_cast_expression): If we aren't looking at\n\ta cast-expression don't call cp_parser_type_id.\n\t(cp_parser_postfix_expression): Likewise for compound-literal.\n\t(cp_parser_tokens_start_cast_expression): Adjust.\n\n/testsuite\n2013-11-02  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/29234\n\tPR c++/56037\n\t* g++.dg/parse/pr29234.C: New.\n\t* g++.dg/parse/pr56037.C: Likewise.\n\nFrom-SVN: r204312", "tree": {"sha": "f5d284712d0345b3d7ead702b9101dd5431050d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5d284712d0345b3d7ead702b9101dd5431050d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2afe03827a683d96021100c6d04d72e13f34d582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2afe03827a683d96021100c6d04d72e13f34d582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2afe03827a683d96021100c6d04d72e13f34d582", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2afe03827a683d96021100c6d04d72e13f34d582/comments", "author": null, "committer": null, "parents": [{"sha": "ef86cd2bf2d80ce31161335ae1ae1ae65e895c5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef86cd2bf2d80ce31161335ae1ae1ae65e895c5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef86cd2bf2d80ce31161335ae1ae1ae65e895c5e"}], "stats": {"total": 132, "additions": 101, "deletions": 31}, "files": [{"sha": "694aaae6de361f223c818884fcae1de2050acd88", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2afe03827a683d96021100c6d04d72e13f34d582", "patch": "@@ -1,3 +1,12 @@\n+2013-11-02  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/29234\n+\tPR c++/56037\n+\t* parser.c (cp_parser_cast_expression): If we aren't looking at\n+\ta cast-expression don't call cp_parser_type_id.\n+\t(cp_parser_postfix_expression): Likewise for compound-literal.\n+\t(cp_parser_tokens_start_cast_expression): Adjust.\n+\n 2013-11-01  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tPR c++/58708"}, {"sha": "4e06e8af0b66500348a7e88f96b9fe135a1343c6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2afe03827a683d96021100c6d04d72e13f34d582", "patch": "@@ -5817,31 +5817,45 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n \t  {\n \t    tree initializer = NULL_TREE;\n-\t    bool saved_in_type_id_in_expr_p;\n+\t    bool compound_literal_p;\n \n \t    cp_parser_parse_tentatively (parser);\n \t    /* Consume the `('.  */\n \t    cp_lexer_consume_token (parser->lexer);\n-\t    /* Parse the type.  */\n-\t    saved_in_type_id_in_expr_p = parser->in_type_id_in_expr_p;\n-\t    parser->in_type_id_in_expr_p = true;\n-\t    type = cp_parser_type_id (parser);\n-\t    parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n-\t    /* Look for the `)'.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+\t    /* Avoid calling cp_parser_type_id pointlessly, see comment\n+\t       in cp_parser_cast_expression about c++/29234.  */\n+\t    cp_lexer_save_tokens (parser->lexer);\n+\n+\t    compound_literal_p\n+\t      = (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n+\t\t\t\t\t\t\t/*consume_paren=*/true)\n+\t\t && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE));\n+\n+\t    /* Roll back the tokens we skipped.  */\n+\t    cp_lexer_rollback_tokens (parser->lexer);\n+\n+\t    if (!compound_literal_p)\n+\t      cp_parser_simulate_error (parser);\n+\t    else\n+\t      {\n+\t\t/* Parse the type.  */\n+\t\tbool saved_in_type_id_in_expr_p = parser->in_type_id_in_expr_p;\n+\t\tparser->in_type_id_in_expr_p = true;\n+\t\ttype = cp_parser_type_id (parser);\n+\t\tparser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n+\t\t/* Look for the `)'.  */\n+\t\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t      }\n+\n \t    /* If things aren't going well, there's no need to\n \t       keep going.  */\n \t    if (!cp_parser_error_occurred (parser))\n \t      {\n-\t\tif (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n-\t\t  {\n-\t\t    bool non_constant_p;\n-\t\t    /* Parse the brace-enclosed initializer list.  */\n-\t\t    initializer = cp_parser_braced_list (parser,\n-\t\t\t\t\t\t\t &non_constant_p);\n-\t\t  }\n-\t\telse\n-\t\t  cp_parser_simulate_error (parser);\n+\t\tbool non_constant_p;\n+\t\t/* Parse the brace-enclosed initializer list.  */\n+\t\tinitializer = cp_parser_braced_list (parser,\n+\t\t\t\t\t\t     &non_constant_p);\n \t      }\n \t    /* If that worked, we're definitely looking at a\n \t       compound-literal expression.  */\n@@ -7509,6 +7523,7 @@ cp_parser_tokens_start_cast_expression (cp_parser *parser)\n     case CPP_CLOSE_SQUARE:\n     case CPP_CLOSE_PAREN:\n     case CPP_CLOSE_BRACE:\n+    case CPP_OPEN_BRACE:\n     case CPP_DOT:\n     case CPP_DOT_STAR:\n     case CPP_DEREF:\n@@ -7576,7 +7591,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n     {\n       tree type = NULL_TREE;\n       tree expr = NULL_TREE;\n-      bool compound_literal_p;\n+      bool cast_expression_p;\n       const char *saved_message;\n \n       /* There's no way to know yet whether or not this is a cast.\n@@ -7599,26 +7614,38 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t will commit to the parse at that point, because we cannot\n \t undo the action that is done when creating a new class.  So,\n \t then we cannot back up and do a postfix-expression.\n+\t Another tricky case is the following (c++/29234):\n+\n+         struct S { void operator () (); };\n+\n+         void foo ()\n+         {\n+           ( S()() );\n+         }\n+\n+\t As a type-id we parse the parenthesized S()() as a function\n+\t returning a function, groktypename complains and we cannot\n+\t back up in this case either.\n \n \t Therefore, we scan ahead to the closing `)', and check to see\n-\t if the token after the `)' is a `{'.  If so, we are not\n-\t looking at a cast-expression.\n+\t if the tokens after the `)' can start a cast-expression.  Otherwise\n+\t we are dealing with an unary-expression, a postfix-expression\n+\t or something else.\n \n \t Save tokens so that we can put them back.  */\n       cp_lexer_save_tokens (parser->lexer);\n-      /* Skip tokens until the next token is a closing parenthesis.\n-\t If we find the closing `)', and the next token is a `{', then\n-\t we are looking at a compound-literal.  */\n-      compound_literal_p\n+\n+      /* We may be looking at a cast-expression.  */\n+      cast_expression_p\n \t= (cp_parser_skip_to_closing_parenthesis (parser, false, false,\n \t\t\t\t\t\t  /*consume_paren=*/true)\n-\t   && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE));\n+\t   && cp_parser_tokens_start_cast_expression (parser));\n+\n       /* Roll back the tokens we skipped.  */\n       cp_lexer_rollback_tokens (parser->lexer);\n-      /* If we were looking at a compound-literal, simulate an error\n-\t so that the call to cp_parser_parse_definitely below will\n-\t fail.  */\n-      if (compound_literal_p)\n+      /* If we aren't looking at a cast-expression, simulate an error so\n+\t that the call to cp_parser_parse_definitely below will fail.  */\n+      if (!cast_expression_p)\n \tcp_parser_simulate_error (parser);\n       else\n \t{\n@@ -7637,8 +7664,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n       /* At this point this can only be either a cast or a\n \t parenthesized ctor such as `(T ())' that looks like a cast to\n \t function returning T.  */\n-      if (!cp_parser_error_occurred (parser)\n-\t  && cp_parser_tokens_start_cast_expression (parser))\n+      if (!cp_parser_error_occurred (parser))\n \t{\n \t  cp_parser_parse_definitely (parser);\n \t  expr = cp_parser_cast_expression (parser,"}, {"sha": "1abd7c1007545fa96db44ec6629ff68020c0b6b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2afe03827a683d96021100c6d04d72e13f34d582", "patch": "@@ -1,3 +1,10 @@\n+2013-11-02  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/29234\n+\tPR c++/56037\n+\t* g++.dg/parse/pr29234.C: New.\n+\t* g++.dg/parse/pr56037.C: Likewise.\n+\n 2013-11-01  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* gcc.dg/cilk-plus/cilk-plus.exp: Loaded libcilkrts library path and"}, {"sha": "d2dc735f226bf16e2955c584c6ba4f0d4310f148", "filename": "gcc/testsuite/g++.dg/parse/pr29234.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr29234.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr29234.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr29234.C?ref=2afe03827a683d96021100c6d04d72e13f34d582", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/29234\n+\n+struct S { void operator()(); };\n+\n+void foo ()\n+{\n+  ( S()() );\n+}\n+\n+struct C { void operator[](C); };\n+\n+void bar ()\n+{\n+  C x;\n+  ( C()[x] );\n+}"}, {"sha": "10f145ae5eed5dc26401fee213c5adc810f93902", "filename": "gcc/testsuite/g++.dg/parse/pr56037.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr56037.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2afe03827a683d96021100c6d04d72e13f34d582/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr56037.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpr56037.C?ref=2afe03827a683d96021100c6d04d72e13f34d582", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/56037\n+\n+struct T\n+{\n+  T(int, int);\n+};\n+\n+int main()\n+{\n+  static const int zero = 0;\n+  (T(int(zero), int(zero)));\n+}"}]}