{"sha": "dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "node_id": "C_kwDOANBUbNoAKGRjMjQ0Y2RjMDVhMGNjNGE3YzQwYzVjNTAyN2MxMmNjMWRjNmU0ZDM", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2023-02-17T12:51:14Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2023-02-22T12:29:16Z"}, "message": "RISC-V: Add floating-point RVV C/C++ api\n\nAdd RVV floating-point C/C++ api tests.\nThe api unit-tests are all passed but not commit.\nThey are located at RISC-V foundation repo:\nhttps://github.com/riscv-collab/riscv-gcc/tree/rvv-submission-v1\n\ngcc/ChangeLog:\n\n\t* config/riscv/iterators.md: New iterator.\n\t* config/riscv/riscv-vector-builtins-bases.cc (class widen_binop): New class.\n\t(enum ternop_type): New enum.\n\t(class vmacc): New class.\n\t(class imac): Ditto.\n\t(class vnmsac): Ditto.\n\t(enum widen_ternop_type): New enum.\n\t(class vmadd): Ditto.\n\t(class vnmsub): Ditto.\n\t(class iwmac): Ditto.\n\t(class vwmacc): Ditto.\n\t(class vwmaccu): Ditto.\n\t(class vwmaccsu): Ditto.\n\t(class vwmaccus): Ditto.\n\t(class reverse_binop): Ditto.\n\t(class vfmacc): Ditto.\n\t(class vfnmsac): Ditto.\n\t(class vfmadd): Ditto.\n\t(class vfnmsub): Ditto.\n\t(class vfnmacc): Ditto.\n\t(class vfmsac): Ditto.\n\t(class vfnmadd): Ditto.\n\t(class vfmsub): Ditto.\n\t(class vfwmacc): Ditto.\n\t(class vfwnmacc): Ditto.\n\t(class vfwmsac): Ditto.\n\t(class vfwnmsac): Ditto.\n\t(class float_misc): Ditto.\n\t(class fcmp): Ditto.\n\t(class vfclass): Ditto.\n\t(class vfcvt_x): Ditto.\n\t(class vfcvt_rtz_x): Ditto.\n\t(class vfcvt_f): Ditto.\n\t(class vfwcvt_x): Ditto.\n\t(class vfwcvt_rtz_x): Ditto.\n\t(class vfwcvt_f): Ditto.\n\t(class vfncvt_x): Ditto.\n\t(class vfncvt_rtz_x): Ditto.\n\t(class vfncvt_f): Ditto.\n\t(class vfncvt_rod_f): Ditto.\n\t(BASE): Ditto.\n\t* config/riscv/riscv-vector-builtins-bases.h:\n\t* config/riscv/riscv-vector-builtins-functions.def (vzext): Ditto.\n\t(vsext): Ditto.\n\t(vfadd): Ditto.\n\t(vfsub): Ditto.\n\t(vfrsub): Ditto.\n\t(vfwadd): Ditto.\n\t(vfwsub): Ditto.\n\t(vfmul): Ditto.\n\t(vfdiv): Ditto.\n\t(vfrdiv): Ditto.\n\t(vfwmul): Ditto.\n\t(vfmacc): Ditto.\n\t(vfnmsac): Ditto.\n\t(vfmadd): Ditto.\n\t(vfnmsub): Ditto.\n\t(vfnmacc): Ditto.\n\t(vfmsac): Ditto.\n\t(vfnmadd): Ditto.\n\t(vfmsub): Ditto.\n\t(vfwmacc): Ditto.\n\t(vfwnmacc): Ditto.\n\t(vfwmsac): Ditto.\n\t(vfwnmsac): Ditto.\n\t(vfsqrt): Ditto.\n\t(vfrsqrt7): Ditto.\n\t(vfrec7): Ditto.\n\t(vfmin): Ditto.\n\t(vfmax): Ditto.\n\t(vfsgnj): Ditto.\n\t(vfsgnjn): Ditto.\n\t(vfsgnjx): Ditto.\n\t(vfneg): Ditto.\n\t(vfabs): Ditto.\n\t(vmfeq): Ditto.\n\t(vmfne): Ditto.\n\t(vmflt): Ditto.\n\t(vmfle): Ditto.\n\t(vmfgt): Ditto.\n\t(vmfge): Ditto.\n\t(vfclass): Ditto.\n\t(vfmerge): Ditto.\n\t(vfmv_v): Ditto.\n\t(vfcvt_x): Ditto.\n\t(vfcvt_xu): Ditto.\n\t(vfcvt_rtz_x): Ditto.\n\t(vfcvt_rtz_xu): Ditto.\n\t(vfcvt_f): Ditto.\n\t(vfwcvt_x): Ditto.\n\t(vfwcvt_xu): Ditto.\n\t(vfwcvt_rtz_x): Ditto.\n\t(vfwcvt_rtz_xu): Ditto.\n\t(vfwcvt_f): Ditto.\n\t(vfncvt_x): Ditto.\n\t(vfncvt_xu): Ditto.\n\t(vfncvt_rtz_x): Ditto.\n\t(vfncvt_rtz_xu): Ditto.\n\t(vfncvt_f): Ditto.\n\t(vfncvt_rod_f): Ditto.\n\t* config/riscv/riscv-vector-builtins-shapes.cc (struct alu_def): Ditto.\n\t(struct move_def): Ditto.\n\t* config/riscv/riscv-vector-builtins-types.def (DEF_RVV_WEXTF_OPS): New macro.\n\t(DEF_RVV_CONVERT_I_OPS): Ditto.\n\t(DEF_RVV_CONVERT_U_OPS): Ditto.\n\t(DEF_RVV_WCONVERT_I_OPS): Ditto.\n\t(DEF_RVV_WCONVERT_U_OPS): Ditto.\n\t(DEF_RVV_WCONVERT_F_OPS): Ditto.\n\t(vfloat64m1_t): Ditto.\n\t(vfloat64m2_t): Ditto.\n\t(vfloat64m4_t): Ditto.\n\t(vfloat64m8_t): Ditto.\n\t(vint32mf2_t): Ditto.\n\t(vint32m1_t): Ditto.\n\t(vint32m2_t): Ditto.\n\t(vint32m4_t): Ditto.\n\t(vint32m8_t): Ditto.\n\t(vint64m1_t): Ditto.\n\t(vint64m2_t): Ditto.\n\t(vint64m4_t): Ditto.\n\t(vint64m8_t): Ditto.\n\t(vuint32mf2_t): Ditto.\n\t(vuint32m1_t): Ditto.\n\t(vuint32m2_t): Ditto.\n\t(vuint32m4_t): Ditto.\n\t(vuint32m8_t): Ditto.\n\t(vuint64m1_t): Ditto.\n\t(vuint64m2_t): Ditto.\n\t(vuint64m4_t): Ditto.\n\t(vuint64m8_t): Ditto.\n\t* config/riscv/riscv-vector-builtins.cc (DEF_RVV_CONVERT_I_OPS): Ditto.\n\t(DEF_RVV_CONVERT_U_OPS): Ditto.\n\t(DEF_RVV_WCONVERT_I_OPS): Ditto.\n\t(DEF_RVV_WCONVERT_U_OPS): Ditto.\n\t(DEF_RVV_WCONVERT_F_OPS): Ditto.\n\t(DEF_RVV_F_OPS): Ditto.\n\t(DEF_RVV_WEXTF_OPS): Ditto.\n\t(required_extensions_p): Adjust for floating-point support.\n\t(check_required_extensions): Ditto.\n\t(unsigned_base_type_p): Ditto.\n\t(get_mode_for_bitsize): Ditto.\n\t(rvv_arg_type_info::get_base_vector_type): Ditto.\n\t(rvv_arg_type_info::get_tree_type): Ditto.\n\t* config/riscv/riscv-vector-builtins.def (v_f): New define.\n\t(f): New define.\n\t(f_v): New define.\n\t(xu_v): New define.\n\t(f_w): New define.\n\t(xu_w): New define.\n\t* config/riscv/riscv-vector-builtins.h (enum rvv_base_type): New enum.\n\t(function_expander::arg_mode): New function.\n\t* config/riscv/vector-iterators.md (sof): New iterator.\n\t(vfrecp): Ditto.\n\t(copysign): Ditto.\n\t(n): Ditto.\n\t(msac): Ditto.\n\t(msub): Ditto.\n\t(fixuns_trunc): Ditto.\n\t(floatuns): Ditto.\n\t* config/riscv/vector.md (@pred_broadcast<mode>): New pattern.\n\t(@pred_<optab><mode>): Ditto.\n\t(@pred_<optab><mode>_scalar): Ditto.\n\t(@pred_<optab><mode>_reverse_scalar): Ditto.\n\t(@pred_<copysign><mode>): Ditto.\n\t(@pred_<copysign><mode>_scalar): Ditto.\n\t(@pred_mul_<optab><mode>): Ditto.\n\t(pred_mul_<optab><mode>_undef_merge): Ditto.\n\t(*pred_<madd_nmsub><mode>): Ditto.\n\t(*pred_<macc_nmsac><mode>): Ditto.\n\t(*pred_mul_<optab><mode>): Ditto.\n\t(@pred_mul_<optab><mode>_scalar): Ditto.\n\t(*pred_mul_<optab><mode>_undef_merge_scalar): Ditto.\n\t(*pred_<madd_nmsub><mode>_scalar): Ditto.\n\t(*pred_<macc_nmsac><mode>_scalar): Ditto.\n\t(*pred_mul_<optab><mode>_scalar): Ditto.\n\t(@pred_neg_mul_<optab><mode>): Ditto.\n\t(pred_neg_mul_<optab><mode>_undef_merge): Ditto.\n\t(*pred_<nmadd_msub><mode>): Ditto.\n\t(*pred_<nmacc_msac><mode>): Ditto.\n\t(*pred_neg_mul_<optab><mode>): Ditto.\n\t(@pred_neg_mul_<optab><mode>_scalar): Ditto.\n\t(*pred_neg_mul_<optab><mode>_undef_merge_scalar): Ditto.\n\t(*pred_<nmadd_msub><mode>_scalar): Ditto.\n\t(*pred_<nmacc_msac><mode>_scalar): Ditto.\n\t(*pred_neg_mul_<optab><mode>_scalar): Ditto.\n\t(@pred_<misc_op><mode>): Ditto.\n\t(@pred_class<mode>): Ditto.\n\t(@pred_dual_widen_<optab><mode>): Ditto.\n\t(@pred_dual_widen_<optab><mode>_scalar): Ditto.\n\t(@pred_single_widen_<plus_minus:optab><mode>): Ditto.\n\t(@pred_single_widen_<plus_minus:optab><mode>_scalar): Ditto.\n\t(@pred_widen_mul_<optab><mode>): Ditto.\n\t(@pred_widen_mul_<optab><mode>_scalar): Ditto.\n\t(@pred_widen_neg_mul_<optab><mode>): Ditto.\n\t(@pred_widen_neg_mul_<optab><mode>_scalar): Ditto.\n\t(@pred_cmp<mode>): Ditto.\n\t(*pred_cmp<mode>): Ditto.\n\t(*pred_cmp<mode>_narrow): Ditto.\n\t(@pred_cmp<mode>_scalar): Ditto.\n\t(*pred_cmp<mode>_scalar): Ditto.\n\t(*pred_cmp<mode>_scalar_narrow): Ditto.\n\t(@pred_eqne<mode>_scalar): Ditto.\n\t(*pred_eqne<mode>_scalar): Ditto.\n\t(*pred_eqne<mode>_scalar_narrow): Ditto.\n\t(@pred_merge<mode>_scalar): Ditto.\n\t(@pred_fcvt_x<v_su>_f<mode>): Ditto.\n\t(@pred_<fix_cvt><mode>): Ditto.\n\t(@pred_<float_cvt><mode>): Ditto.\n\t(@pred_widen_fcvt_x<v_su>_f<mode>): Ditto.\n\t(@pred_widen_<fix_cvt><mode>): Ditto.\n\t(@pred_widen_<float_cvt><mode>): Ditto.\n\t(@pred_extend<mode>): Ditto.\n\t(@pred_narrow_fcvt_x<v_su>_f<mode>): Ditto.\n\t(@pred_narrow_<fix_cvt><mode>): Ditto.\n\t(@pred_narrow_<float_cvt><mode>): Ditto.\n\t(@pred_trunc<mode>): Ditto.\n\t(@pred_rod_trunc<mode>): Ditto.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/riscv/rvv/base/ternop_vv_constraint-3.c: New test.\n\t* gcc.target/riscv/rvv/base/ternop_vv_constraint-4.c: New test.\n\t* gcc.target/riscv/rvv/base/ternop_vv_constraint-5.c: New test.\n\t* gcc.target/riscv/rvv/base/ternop_vv_constraint-6.c: New test.\n\t* gcc.target/riscv/rvv/base/ternop_vx_constraint-8.c: New test.\n\t* gcc.target/riscv/rvv/base/ternop_vx_constraint-9.c: New test.", "tree": {"sha": "66a35c82701fbfbb33395525266a3eb5eabc773e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66a35c82701fbfbb33395525266a3eb5eabc773e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c57fbdd6f11de2916fd0df6553e35117d3d12c5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57fbdd6f11de2916fd0df6553e35117d3d12c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c57fbdd6f11de2916fd0df6553e35117d3d12c5a"}], "stats": {"total": 3683, "additions": 3472, "deletions": 211}, "files": [{"sha": "5b70ab2075812b01d872a1bda785a1cecd0e3681", "filename": "gcc/config/riscv/iterators.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fiterators.md?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -175,7 +175,9 @@\n \t\t     (gt \"\") (gtu \"u\")\n \t\t     (ge \"\") (geu \"u\")\n \t\t     (lt \"\") (ltu \"u\")\n-\t\t     (le \"\") (leu \"u\")])\n+\t\t     (le \"\") (leu \"u\")\n+\t\t     (fix \"\") (unsigned_fix \"u\")\n+\t\t     (float \"\") (unsigned_float \"u\")])\n \n ;; <su> is like <u>, but the signed form expands to \"s\" rather than \"\".\n (define_code_attr su [(sign_extend \"s\") (zero_extend \"u\")])\n@@ -204,6 +206,8 @@\n \t\t\t (mult \"mul\")\n \t\t\t (not \"one_cmpl\")\n \t\t\t (neg \"neg\")\n+\t\t\t (abs \"abs\")\n+\t\t\t (sqrt \"sqrt\")\n \t\t\t (ss_plus \"ssadd\")\n \t\t\t (us_plus \"usadd\")\n \t\t\t (ss_minus \"sssub\")\n@@ -235,6 +239,8 @@\n \t\t\t(mult \"mul\")\n \t\t\t(not \"not\")\n \t\t\t(neg \"neg\")\n+\t\t\t(abs \"abs\")\n+\t\t\t(sqrt \"sqrt\")\n \t\t\t(ss_plus \"sadd\")\n \t\t\t(us_plus \"saddu\")\n \t\t\t(ss_minus \"ssub\")"}, {"sha": "bfcfab55bb999b9b348ef08dd3c9a5d196bc0d28", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 664, "deletions": 113, "changes": 777, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -155,8 +155,11 @@ class loadstore : public function_base\n };\n \n /* Implements\n- * vadd/vsub/vand/vor/vxor/vsll/vsra/vsrl/vmin/vmax/vminu/vmaxu/vdiv/vrem/vdivu/vremu/vsadd/vsaddu/vssub/vssubu.\n- */\n+   vadd/vsub/vand/vor/vxor/vsll/vsra/vsrl/\n+   vmin/vmax/vminu/vmaxu/vdiv/vrem/vdivu/\n+   vremu/vsadd/vsaddu/vssub/vssubu\n+   vfadd/vfsub/\n+*/\n template<rtx_code CODE>\n class binop : public function_base\n {\n@@ -166,6 +169,7 @@ class binop : public function_base\n     switch (e.op_info->op)\n       {\n       case OP_TYPE_vx:\n+      case OP_TYPE_vf:\n \treturn e.use_exact_insn (code_for_pred_scalar (CODE, e.vector_mode ()));\n       case OP_TYPE_vv:\n \treturn e.use_exact_insn (code_for_pred (CODE, e.vector_mode ()));\n@@ -239,8 +243,8 @@ class vmulh : public function_base\n   }\n };\n \n-/* Implements vwadd/vwsub/vwmul.  */\n-template<rtx_code CODE1, rtx_code CODE2>\n+/* Implements vwadd/vwsub/vwmul/vfwadd/vfwsub/vfwmul.  */\n+template<rtx_code CODE1, rtx_code CODE2 = FLOAT_EXTEND>\n class widen_binop : public function_base\n {\n public:\n@@ -265,6 +269,31 @@ class widen_binop : public function_base\n       }\n   }\n };\n+template<rtx_code CODE>\n+class widen_binop<CODE, FLOAT_EXTEND> : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+      case OP_TYPE_vv:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_dual_widen (CODE, e.vector_mode ()));\n+      case OP_TYPE_vf:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_dual_widen_scalar (CODE, e.vector_mode ()));\n+      case OP_TYPE_wv:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_single_widen (CODE, e.vector_mode ()));\n+      case OP_TYPE_wf:\n+\treturn e.use_exact_insn (\n+\t  code_for_pred_single_widen_scalar (CODE, e.vector_mode ()));\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n \n /* Implements vwmulsu.  */\n class vwmulsu : public function_base\n@@ -426,7 +455,7 @@ class vncvt_x : public function_base\n   }\n };\n \n-/* Implements vmerge.  */\n+/* Implements vmerge/vfmerge.  */\n class vmerge : public function_base\n {\n public:\n@@ -439,14 +468,15 @@ class vmerge : public function_base\n       case OP_TYPE_vvm:\n \treturn e.use_exact_insn (code_for_pred_merge (e.vector_mode ()));\n       case OP_TYPE_vxm:\n+      case OP_TYPE_vfm:\n \treturn e.use_exact_insn (code_for_pred_merge_scalar (e.vector_mode ()));\n       default:\n \tgcc_unreachable ();\n       }\n   }\n };\n \n-/* Implements vmv.v.x/vmv.v.v.  */\n+/* Implements vmv.v.x/vmv.v.v/vfmv.v.f.  */\n class vmv_v : public function_base\n {\n public:\n@@ -457,6 +487,7 @@ class vmv_v : public function_base\n       case OP_TYPE_v:\n \treturn e.use_exact_insn (code_for_pred_mov (e.vector_mode ()));\n       case OP_TYPE_x:\n+      case OP_TYPE_f:\n \treturn e.use_exact_insn (code_for_pred_broadcast (e.vector_mode ()));\n       default:\n \tgcc_unreachable ();\n@@ -539,132 +570,144 @@ class icmp : public function_base\n   }\n };\n \n-/* Enumerates types of ternary operations.\n-   We have 2 types ternop:\n-     - 1. accumulator is vd:\n-        vmacc.vv vd,vs1,vs2 # vd = vs1 * vs2 + vd.\n-     - 2. accumulator is vs2:\n-        vmadd.vv vd,vs1,vs2 # vd = vs1 * vd + vs2.  */\n-enum ternop_type\n+/* Implements vmacc/vnmsac/vmadd/vnmsub.  */\n+class vmacc : public function_base\n {\n-  TERNOP_VMACC,\n-  TERNOP_VNMSAC,\n-  TERNOP_VMADD,\n-  TERNOP_VNMSUB,\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vx)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_mul_scalar (PLUS,\n+\t\t\t\t\t\t\t  e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_mul (PLUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n };\n \n-/* Implements vmacc/vnmsac/vmadd/vnmsub.  */\n-template<ternop_type TERNOP_TYPE>\n-class imac : public function_base\n+class vnmsac : public function_base\n {\n public:\n   bool has_merge_operand_p () const override { return false; }\n \n   rtx expand (function_expander &e) const override\n   {\n-    switch (TERNOP_TYPE)\n-      {\n-      case TERNOP_VMACC:\n-\tif (e.op_info->op == OP_TYPE_vx)\n-\t  return e.use_ternop_insn (\n-\t    true, code_for_pred_mul_scalar (PLUS, e.vector_mode ()));\n-\tif (e.op_info->op == OP_TYPE_vv)\n-\t  return e.use_ternop_insn (true,\n-\t\t\t\t    code_for_pred_mul (PLUS, e.vector_mode ()));\n-\tbreak;\n-      case TERNOP_VNMSAC:\n-\tif (e.op_info->op == OP_TYPE_vx)\n-\t  return e.use_ternop_insn (\n-\t    true, code_for_pred_mul_scalar (MINUS, e.vector_mode ()));\n-\tif (e.op_info->op == OP_TYPE_vv)\n-\t  return e.use_ternop_insn (true, code_for_pred_mul (MINUS,\n-\t\t\t\t\t\t\t     e.vector_mode ()));\n-\tbreak;\n-      case TERNOP_VMADD:\n-\tif (e.op_info->op == OP_TYPE_vx)\n-\t  return e.use_ternop_insn (\n-\t    false, code_for_pred_mul_scalar (PLUS, e.vector_mode ()));\n-\tif (e.op_info->op == OP_TYPE_vv)\n-\t  return e.use_ternop_insn (false,\n-\t\t\t\t    code_for_pred_mul (PLUS, e.vector_mode ()));\n-\tbreak;\n-      case TERNOP_VNMSUB:\n-\tif (e.op_info->op == OP_TYPE_vx)\n-\t  return e.use_ternop_insn (\n-\t    false, code_for_pred_mul_scalar (MINUS, e.vector_mode ()));\n-\tif (e.op_info->op == OP_TYPE_vv)\n-\t  return e.use_ternop_insn (false,\n-\t\t\t\t    code_for_pred_mul (MINUS,\n-\t\t\t\t\t\t       e.vector_mode ()));\n-\tbreak;\n-      default:\n-\tbreak;\n-      }\n+    if (e.op_info->op == OP_TYPE_vx)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_mul_scalar (MINUS,\n+\t\t\t\t\t\t\t  e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_mul (MINUS, e.vector_mode ()));\n     gcc_unreachable ();\n   }\n };\n \n-/* Enumerates types of widen ternary operations.\n-   We have 4 types ternop:\n-     - 1. vwmacc.\n-     - 2. vwmaccu.\n-     - 3. vwmaccsu.\n-     - 4. vwmaccus.  */\n-enum widen_ternop_type\n+class vmadd : public function_base\n {\n-  WIDEN_TERNOP_VWMACC,\n-  WIDEN_TERNOP_VWMACCU,\n-  WIDEN_TERNOP_VWMACCSU,\n-  WIDEN_TERNOP_VWMACCUS,\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vx)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_mul_scalar (PLUS,\n+\t\t\t\t\t\t\t  e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_mul (PLUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n };\n \n+class vnmsub : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vx)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_mul_scalar (MINUS,\n+\t\t\t\t\t\t\t  e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_mul (MINUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+\n /* Implements vwmacc<su><su>.  */\n-template<widen_ternop_type WIDEN_TERNOP_TYPE>\n-class iwmac : public function_base\n+class vwmacc : public function_base\n {\n public:\n   bool has_merge_operand_p () const override { return false; }\n \n   rtx expand (function_expander &e) const override\n   {\n-    switch (WIDEN_TERNOP_TYPE)\n-      {\n-      case WIDEN_TERNOP_VWMACC:\n-\tif (e.op_info->op == OP_TYPE_vx)\n-\t  return e.use_widen_ternop_insn (\n-\t    code_for_pred_widen_mul_plus_scalar (SIGN_EXTEND,\n-\t\t\t\t\t\t e.vector_mode ()));\n-\tif (e.op_info->op == OP_TYPE_vv)\n-\t  return e.use_widen_ternop_insn (\n-\t    code_for_pred_widen_mul_plus (SIGN_EXTEND, e.vector_mode ()));\n-\tbreak;\n-      case WIDEN_TERNOP_VWMACCU:\n-\tif (e.op_info->op == OP_TYPE_vx)\n-\t  return e.use_widen_ternop_insn (\n-\t    code_for_pred_widen_mul_plus_scalar (ZERO_EXTEND,\n-\t\t\t\t\t\t e.vector_mode ()));\n-\tif (e.op_info->op == OP_TYPE_vv)\n-\t  return e.use_widen_ternop_insn (\n-\t    code_for_pred_widen_mul_plus (ZERO_EXTEND, e.vector_mode ()));\n-\tbreak;\n-      case WIDEN_TERNOP_VWMACCSU:\n-\tif (e.op_info->op == OP_TYPE_vx)\n-\t  return e.use_widen_ternop_insn (\n-\t    code_for_pred_widen_mul_plussu_scalar (e.vector_mode ()));\n-\tif (e.op_info->op == OP_TYPE_vv)\n-\t  return e.use_widen_ternop_insn (\n-\t    code_for_pred_widen_mul_plussu (e.vector_mode ()));\n-\tbreak;\n-      case WIDEN_TERNOP_VWMACCUS:\n-\treturn e.use_widen_ternop_insn (\n-\t  code_for_pred_widen_mul_plusus_scalar (e.vector_mode ()));\n-      default:\n-\tbreak;\n-      }\n+    if (e.op_info->op == OP_TYPE_vx)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul_plus_scalar (SIGN_EXTEND, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul_plus (SIGN_EXTEND, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vwmaccu : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vx)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul_plus_scalar (ZERO_EXTEND, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul_plus (ZERO_EXTEND, e.vector_mode ()));\n     gcc_unreachable ();\n   }\n };\n \n+class vwmaccsu : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vx)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul_plussu_scalar (e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul_plussu (e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vwmaccus : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_widen_ternop_insn (\n+      code_for_pred_widen_mul_plusus_scalar (e.vector_mode ()));\n+  }\n+};\n+\n /* Implements vmand/vmnand/vmandn/vmxor/vmor/vmnor/vmorn/vmxnor  */\n template<rtx_code CODE>\n class mask_logic : public function_base\n@@ -844,6 +887,402 @@ class vid : public function_base\n   }\n };\n \n+/* Implements vfrsub/vfrdiv.  */\n+template<rtx_code CODE>\n+class reverse_binop : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (\n+      code_for_pred_reverse_scalar (CODE, e.vector_mode ()));\n+  }\n+};\n+\n+class vfmacc : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_mul_scalar (PLUS,\n+\t\t\t\t\t\t\t  e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_mul (PLUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfnmsac : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_mul_scalar (MINUS,\n+\t\t\t\t\t\t\t  e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_mul (MINUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfmadd : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_mul_scalar (PLUS,\n+\t\t\t\t\t\t\t  e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_mul (PLUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfnmsub : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_mul_scalar (MINUS,\n+\t\t\t\t\t\t\t  e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_mul (MINUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfnmacc : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_ternop_insn (\n+\ttrue, code_for_pred_neg_mul_scalar (PLUS, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (true,\n+\t\t\t\tcode_for_pred_neg_mul (PLUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfmsac : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_ternop_insn (\n+\ttrue, code_for_pred_neg_mul_scalar (MINUS, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (true, code_for_pred_neg_mul (MINUS,\n+\t\t\t\t\t\t\t     e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfnmadd : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_ternop_insn (\n+\tfalse, code_for_pred_neg_mul_scalar (PLUS, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_neg_mul (PLUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfmsub : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_ternop_insn (\n+\tfalse, code_for_pred_neg_mul_scalar (MINUS, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_ternop_insn (false,\n+\t\t\t\tcode_for_pred_neg_mul (MINUS,\n+\t\t\t\t\t\t       e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfwmacc : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul_scalar (PLUS, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul (PLUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfwnmacc : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_neg_mul_scalar (PLUS, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_neg_mul (PLUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfwmsac : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_neg_mul_scalar (MINUS, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_neg_mul (MINUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfwnmsac : public function_base\n+{\n+public:\n+  bool has_merge_operand_p () const override { return false; }\n+\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul_scalar (MINUS, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv)\n+      return e.use_widen_ternop_insn (\n+\tcode_for_pred_widen_mul (MINUS, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+/* Implements vfsqrt7/vfrec7/vfclass/vfsgnj/vfsgnjn/vfsgnjx.  */\n+template<int UNSPEC>\n+class float_misc : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_vf)\n+      return e.use_exact_insn (code_for_pred_scalar (UNSPEC, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_vv || e.op_info->op == OP_TYPE_v)\n+      return e.use_exact_insn (code_for_pred (UNSPEC, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+/* Implements vmfeq/vmfne/vmflt/vmfgt/vmfle/vmfge.  */\n+template<rtx_code CODE>\n+class fcmp : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    switch (e.op_info->op)\n+      {\n+\tcase OP_TYPE_vf: {\n+\t  if (CODE == EQ || CODE == NE)\n+\t    return e.use_compare_insn (CODE, code_for_pred_eqne_scalar (\n+\t\t\t\t\t       e.vector_mode ()));\n+\t  else\n+\t    return e.use_compare_insn (CODE, code_for_pred_cmp_scalar (\n+\t\t\t\t\t       e.vector_mode ()));\n+\t}\n+\tcase OP_TYPE_vv: {\n+\t  return e.use_compare_insn (CODE,\n+\t\t\t\t     code_for_pred_cmp (e.vector_mode ()));\n+\t}\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+};\n+\n+/* Implements vfclass.  */\n+class vfclass : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_class (e.arg_mode (0)));\n+  }\n+};\n+\n+/* Implements vfcvt.x.  */\n+template<int UNSPEC>\n+class vfcvt_x : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_fcvt_x_f (UNSPEC, e.arg_mode (0)));\n+  }\n+};\n+\n+/* Implements vfcvt.rtz.x.  */\n+template<rtx_code CODE>\n+class vfcvt_rtz_x : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred (CODE, e.arg_mode (0)));\n+  }\n+};\n+\n+class vfcvt_f : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_x_v)\n+      return e.use_exact_insn (code_for_pred (FLOAT, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_xu_v)\n+      return e.use_exact_insn (\n+\tcode_for_pred (UNSIGNED_FLOAT, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+/* Implements vfwcvt.x.  */\n+template<int UNSPEC>\n+class vfwcvt_x : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (\n+      code_for_pred_widen_fcvt_x_f (UNSPEC, e.vector_mode ()));\n+  }\n+};\n+\n+/* Implements vfwcvt.rtz.x.  */\n+template<rtx_code CODE>\n+class vfwcvt_rtz_x : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_widen (CODE, e.vector_mode ()));\n+  }\n+};\n+\n+class vfwcvt_f : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_f_v)\n+      return e.use_exact_insn (code_for_pred_extend (e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_x_v)\n+      return e.use_exact_insn (code_for_pred_widen (FLOAT, e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_xu_v)\n+      return e.use_exact_insn (\n+\tcode_for_pred_widen (UNSIGNED_FLOAT, e.vector_mode ()));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+/* Implements vfncvt.x.  */\n+template<int UNSPEC>\n+class vfncvt_x : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (\n+      code_for_pred_narrow_fcvt_x_f (UNSPEC, e.arg_mode (0)));\n+  }\n+};\n+\n+/* Implements vfncvt.rtz.x.  */\n+template<rtx_code CODE>\n+class vfncvt_rtz_x : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_narrow (CODE, e.vector_mode ()));\n+  }\n+};\n+\n+class vfncvt_f : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    if (e.op_info->op == OP_TYPE_f_w)\n+      return e.use_exact_insn (code_for_pred_trunc (e.vector_mode ()));\n+    if (e.op_info->op == OP_TYPE_x_w)\n+      return e.use_exact_insn (code_for_pred_narrow (FLOAT, e.arg_mode (0)));\n+    if (e.op_info->op == OP_TYPE_xu_w)\n+      return e.use_exact_insn (\n+\tcode_for_pred_narrow (UNSIGNED_FLOAT, e.arg_mode (0)));\n+    gcc_unreachable ();\n+  }\n+};\n+\n+class vfncvt_rod_f : public function_base\n+{\n+public:\n+  rtx expand (function_expander &e) const override\n+  {\n+    return e.use_exact_insn (code_for_pred_rod_trunc (e.vector_mode ()));\n+  }\n+};\n+\n static CONSTEXPR const vsetvl<false> vsetvl_obj;\n static CONSTEXPR const vsetvl<true> vsetvlmax_obj;\n static CONSTEXPR const loadstore<false, LST_UNIT_STRIDE, false> vle_obj;\n@@ -921,14 +1360,14 @@ static CONSTEXPR const icmp<LTU> vmsltu_obj;\n static CONSTEXPR const icmp<GTU> vmsgtu_obj;\n static CONSTEXPR const icmp<LEU> vmsleu_obj;\n static CONSTEXPR const icmp<GEU> vmsgeu_obj;\n-static CONSTEXPR const imac<TERNOP_VMACC> vmacc_obj;\n-static CONSTEXPR const imac<TERNOP_VNMSAC> vnmsac_obj;\n-static CONSTEXPR const imac<TERNOP_VMADD> vmadd_obj;\n-static CONSTEXPR const imac<TERNOP_VNMSUB> vnmsub_obj;\n-static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACC> vwmacc_obj;\n-static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCU> vwmaccu_obj;\n-static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCSU> vwmaccsu_obj;\n-static CONSTEXPR const iwmac<WIDEN_TERNOP_VWMACCUS> vwmaccus_obj;\n+static CONSTEXPR const vmacc vmacc_obj;\n+static CONSTEXPR const vnmsac vnmsac_obj;\n+static CONSTEXPR const vmadd vmadd_obj;\n+static CONSTEXPR const vnmsub vnmsub_obj;\n+static CONSTEXPR const vwmacc vwmacc_obj;\n+static CONSTEXPR const vwmaccu vwmaccu_obj;\n+static CONSTEXPR const vwmaccsu vwmaccsu_obj;\n+static CONSTEXPR const vwmaccus vwmaccus_obj;\n static CONSTEXPR const binop<SS_PLUS> vsadd_obj;\n static CONSTEXPR const binop<SS_MINUS> vssub_obj;\n static CONSTEXPR const binop<US_PLUS> vsaddu_obj;\n@@ -961,6 +1400,62 @@ static CONSTEXPR const mask_misc<UNSPEC_VMSIF> vmsif_obj;\n static CONSTEXPR const mask_misc<UNSPEC_VMSOF> vmsof_obj;\n static CONSTEXPR const viota viota_obj;\n static CONSTEXPR const vid vid_obj;\n+static CONSTEXPR const binop<PLUS> vfadd_obj;\n+static CONSTEXPR const binop<MINUS> vfsub_obj;\n+static CONSTEXPR const reverse_binop<MINUS> vfrsub_obj;\n+static CONSTEXPR const widen_binop<PLUS> vfwadd_obj;\n+static CONSTEXPR const widen_binop<MINUS> vfwsub_obj;\n+static CONSTEXPR const binop<MULT> vfmul_obj;\n+static CONSTEXPR const binop<DIV> vfdiv_obj;\n+static CONSTEXPR const reverse_binop<DIV> vfrdiv_obj;\n+static CONSTEXPR const widen_binop<MULT> vfwmul_obj;\n+static CONSTEXPR const vfmacc vfmacc_obj;\n+static CONSTEXPR const vfnmsac vfnmsac_obj;\n+static CONSTEXPR const vfmadd vfmadd_obj;\n+static CONSTEXPR const vfnmsub vfnmsub_obj;\n+static CONSTEXPR const vfnmacc vfnmacc_obj;\n+static CONSTEXPR const vfmsac vfmsac_obj;\n+static CONSTEXPR const vfnmadd vfnmadd_obj;\n+static CONSTEXPR const vfmsub vfmsub_obj;\n+static CONSTEXPR const vfwmacc vfwmacc_obj;\n+static CONSTEXPR const vfwnmacc vfwnmacc_obj;\n+static CONSTEXPR const vfwmsac vfwmsac_obj;\n+static CONSTEXPR const vfwnmsac vfwnmsac_obj;\n+static CONSTEXPR const unop<SQRT> vfsqrt_obj;\n+static CONSTEXPR const float_misc<UNSPEC_VFRSQRT7> vfrsqrt7_obj;\n+static CONSTEXPR const float_misc<UNSPEC_VFREC7> vfrec7_obj;\n+static CONSTEXPR const binop<SMIN> vfmin_obj;\n+static CONSTEXPR const binop<SMAX> vfmax_obj;\n+static CONSTEXPR const float_misc<UNSPEC_VCOPYSIGN> vfsgnj_obj;\n+static CONSTEXPR const float_misc<UNSPEC_VNCOPYSIGN> vfsgnjn_obj;\n+static CONSTEXPR const float_misc<UNSPEC_VXORSIGN> vfsgnjx_obj;\n+static CONSTEXPR const unop<NEG> vfneg_obj;\n+static CONSTEXPR const unop<ABS> vfabs_obj;\n+static CONSTEXPR const fcmp<EQ> vmfeq_obj;\n+static CONSTEXPR const fcmp<NE> vmfne_obj;\n+static CONSTEXPR const fcmp<LT> vmflt_obj;\n+static CONSTEXPR const fcmp<GT> vmfgt_obj;\n+static CONSTEXPR const fcmp<LE> vmfle_obj;\n+static CONSTEXPR const fcmp<GE> vmfge_obj;\n+static CONSTEXPR const vfclass vfclass_obj;\n+static CONSTEXPR const vmerge vfmerge_obj;\n+static CONSTEXPR const vmv_v vfmv_v_obj;\n+static CONSTEXPR const vfcvt_x<UNSPEC_VFCVT> vfcvt_x_obj;\n+static CONSTEXPR const vfcvt_x<UNSPEC_UNSIGNED_VFCVT> vfcvt_xu_obj;\n+static CONSTEXPR const vfcvt_rtz_x<FIX> vfcvt_rtz_x_obj;\n+static CONSTEXPR const vfcvt_rtz_x<UNSIGNED_FIX> vfcvt_rtz_xu_obj;\n+static CONSTEXPR const vfcvt_f vfcvt_f_obj;\n+static CONSTEXPR const vfwcvt_x<UNSPEC_VFCVT> vfwcvt_x_obj;\n+static CONSTEXPR const vfwcvt_x<UNSPEC_UNSIGNED_VFCVT> vfwcvt_xu_obj;\n+static CONSTEXPR const vfwcvt_rtz_x<FIX> vfwcvt_rtz_x_obj;\n+static CONSTEXPR const vfwcvt_rtz_x<UNSIGNED_FIX> vfwcvt_rtz_xu_obj;\n+static CONSTEXPR const vfwcvt_f vfwcvt_f_obj;\n+static CONSTEXPR const vfncvt_x<UNSPEC_VFCVT> vfncvt_x_obj;\n+static CONSTEXPR const vfncvt_x<UNSPEC_UNSIGNED_VFCVT> vfncvt_xu_obj;\n+static CONSTEXPR const vfncvt_rtz_x<FIX> vfncvt_rtz_x_obj;\n+static CONSTEXPR const vfncvt_rtz_x<UNSIGNED_FIX> vfncvt_rtz_xu_obj;\n+static CONSTEXPR const vfncvt_f vfncvt_f_obj;\n+static CONSTEXPR const vfncvt_rod_f vfncvt_rod_f_obj;\n \n /* Declare the function base NAME, pointing it to an instance\n    of class <NAME>_obj.  */\n@@ -1084,5 +1579,61 @@ BASE (vmsif)\n BASE (vmsof)\n BASE (viota)\n BASE (vid)\n+BASE (vfadd)\n+BASE (vfsub)\n+BASE (vfrsub)\n+BASE (vfwadd)\n+BASE (vfwsub)\n+BASE (vfmul)\n+BASE (vfdiv)\n+BASE (vfrdiv)\n+BASE (vfwmul)\n+BASE (vfmacc)\n+BASE (vfnmsac)\n+BASE (vfmadd)\n+BASE (vfnmsub)\n+BASE (vfnmacc)\n+BASE (vfmsac)\n+BASE (vfnmadd)\n+BASE (vfmsub)\n+BASE (vfwmacc)\n+BASE (vfwnmacc)\n+BASE (vfwmsac)\n+BASE (vfwnmsac)\n+BASE (vfsqrt)\n+BASE (vfrsqrt7)\n+BASE (vfrec7)\n+BASE (vfmin)\n+BASE (vfmax)\n+BASE (vfsgnj)\n+BASE (vfsgnjn)\n+BASE (vfsgnjx)\n+BASE (vfneg)\n+BASE (vfabs)\n+BASE (vmfeq)\n+BASE (vmfne)\n+BASE (vmflt)\n+BASE (vmfgt)\n+BASE (vmfle)\n+BASE (vmfge)\n+BASE (vfclass)\n+BASE (vfmerge)\n+BASE (vfmv_v)\n+BASE (vfcvt_x)\n+BASE (vfcvt_xu)\n+BASE (vfcvt_rtz_x)\n+BASE (vfcvt_rtz_xu)\n+BASE (vfcvt_f)\n+BASE (vfwcvt_x)\n+BASE (vfwcvt_xu)\n+BASE (vfwcvt_rtz_x)\n+BASE (vfwcvt_rtz_xu)\n+BASE (vfwcvt_f)\n+BASE (vfncvt_x)\n+BASE (vfncvt_xu)\n+BASE (vfncvt_rtz_x)\n+BASE (vfncvt_rtz_xu)\n+BASE (vfncvt_f)\n+BASE (vfncvt_rod_f)\n \n } // end namespace riscv_vector"}, {"sha": "5583dda3a08ce53324464d7359c88eb31ed693d2", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.h", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.h?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -143,6 +143,66 @@ extern const function_base *const vmsif;\n extern const function_base *const vmsof;\n extern const function_base *const viota;\n extern const function_base *const vid;\n+extern const function_base *const vfadd;\n+extern const function_base *const vfadd;\n+extern const function_base *const vfsub;\n+extern const function_base *const vfsub;\n+extern const function_base *const vfrsub;\n+extern const function_base *const vfwadd;\n+extern const function_base *const vfwsub;\n+extern const function_base *const vfmul;\n+extern const function_base *const vfmul;\n+extern const function_base *const vfdiv;\n+extern const function_base *const vfdiv;\n+extern const function_base *const vfrdiv;\n+extern const function_base *const vfwmul;\n+extern const function_base *const vfmacc;\n+extern const function_base *const vfnmsac;\n+extern const function_base *const vfmadd;\n+extern const function_base *const vfnmsub;\n+extern const function_base *const vfnmacc;\n+extern const function_base *const vfmsac;\n+extern const function_base *const vfnmadd;\n+extern const function_base *const vfmsub;\n+extern const function_base *const vfwmacc;\n+extern const function_base *const vfwnmacc;\n+extern const function_base *const vfwmsac;\n+extern const function_base *const vfwnmsac;\n+extern const function_base *const vfsqrt;\n+extern const function_base *const vfrsqrt7;\n+extern const function_base *const vfrec7;\n+extern const function_base *const vfmin;\n+extern const function_base *const vfmax;\n+extern const function_base *const vfsgnj;\n+extern const function_base *const vfsgnjn;\n+extern const function_base *const vfsgnjx;\n+extern const function_base *const vfneg;\n+extern const function_base *const vfabs;\n+extern const function_base *const vmfeq;\n+extern const function_base *const vmfne;\n+extern const function_base *const vmflt;\n+extern const function_base *const vmfgt;\n+extern const function_base *const vmfle;\n+extern const function_base *const vmfge;\n+extern const function_base *const vfclass;\n+extern const function_base *const vfmerge;\n+extern const function_base *const vfmv_v;\n+extern const function_base *const vfcvt_x;\n+extern const function_base *const vfcvt_xu;\n+extern const function_base *const vfcvt_rtz_x;\n+extern const function_base *const vfcvt_rtz_xu;\n+extern const function_base *const vfcvt_f;\n+extern const function_base *const vfwcvt_x;\n+extern const function_base *const vfwcvt_xu;\n+extern const function_base *const vfwcvt_rtz_x;\n+extern const function_base *const vfwcvt_rtz_xu;\n+extern const function_base *const vfwcvt_f;\n+extern const function_base *const vfncvt_x;\n+extern const function_base *const vfncvt_xu;\n+extern const function_base *const vfncvt_rtz_x;\n+extern const function_base *const vfncvt_rtz_xu;\n+extern const function_base *const vfncvt_f;\n+extern const function_base *const vfncvt_rod_f;\n }\n \n } // end namespace riscv_vector"}, {"sha": "1ca0537216bf495594c8d692e5072b6d5a81b009", "filename": "gcc/config/riscv/riscv-vector-builtins-functions.def", "status": "modified", "additions": 139, "deletions": 7, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-functions.def?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -105,12 +105,12 @@ DEF_RVV_FUNCTION (vwcvt_x, alu, full_preds, i_x_x_v_ops)\n DEF_RVV_FUNCTION (vwcvtu_x, alu, full_preds, u_x_x_v_ops)\n \n // 11.3. Vector Integer Extension\n-DEF_RVV_FUNCTION (vzext, alu, full_preds, u_vf2_ops)\n-DEF_RVV_FUNCTION (vzext, alu, full_preds, u_vf4_ops)\n-DEF_RVV_FUNCTION (vzext, alu, full_preds, u_vf8_ops)\n-DEF_RVV_FUNCTION (vsext, alu, full_preds, i_vf2_ops)\n-DEF_RVV_FUNCTION (vsext, alu, full_preds, i_vf4_ops)\n-DEF_RVV_FUNCTION (vsext, alu, full_preds, i_vf8_ops)\n+DEF_RVV_FUNCTION (vzext, widen_alu, full_preds, u_vf2_ops)\n+DEF_RVV_FUNCTION (vzext, widen_alu, full_preds, u_vf4_ops)\n+DEF_RVV_FUNCTION (vzext, widen_alu, full_preds, u_vf8_ops)\n+DEF_RVV_FUNCTION (vsext, widen_alu, full_preds, i_vf2_ops)\n+DEF_RVV_FUNCTION (vsext, widen_alu, full_preds, i_vf4_ops)\n+DEF_RVV_FUNCTION (vsext, widen_alu, full_preds, i_vf8_ops)\n \n // 11.4. Vector Integer Add-with-Carry/Subtract-with-Borrow Instructions\n DEF_RVV_FUNCTION (vadc, no_mask_policy, none_tu_preds, iu_vvvm_ops)\n@@ -275,7 +275,139 @@ DEF_RVV_FUNCTION (vnclipu, narrow_alu, full_preds, u_narrow_shift_vwx_ops)\n DEF_RVV_FUNCTION (vnclip, narrow_alu, full_preds, i_narrow_shift_vwv_ops)\n DEF_RVV_FUNCTION (vnclip, narrow_alu, full_preds, i_narrow_shift_vwx_ops)\n \n-/* TODO: 13. Vector Floating-Point Instructions.  */\n+/* 13. Vector Floating-Point Instructions.  */\n+\n+// 13.2. Vector Single-Width Floating-Point Add/Subtract Instructions\n+DEF_RVV_FUNCTION (vfadd, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfadd, alu, full_preds, f_vvf_ops)\n+DEF_RVV_FUNCTION (vfsub, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfsub, alu, full_preds, f_vvf_ops)\n+DEF_RVV_FUNCTION (vfrsub, alu, full_preds, f_vvf_ops)\n+\n+// 13.3. Vector Widening Floating-Point Add/Subtract Instructions\n+DEF_RVV_FUNCTION (vfwadd, widen_alu, full_preds, f_wvv_ops)\n+DEF_RVV_FUNCTION (vfwadd, widen_alu, full_preds, f_wvf_ops)\n+DEF_RVV_FUNCTION (vfwsub, widen_alu, full_preds, f_wvv_ops)\n+DEF_RVV_FUNCTION (vfwsub, widen_alu, full_preds, f_wvf_ops)\n+DEF_RVV_FUNCTION (vfwadd, widen_alu, full_preds, f_wwv_ops)\n+DEF_RVV_FUNCTION (vfwadd, widen_alu, full_preds, f_wwf_ops)\n+DEF_RVV_FUNCTION (vfwsub, widen_alu, full_preds, f_wwv_ops)\n+DEF_RVV_FUNCTION (vfwsub, widen_alu, full_preds, f_wwf_ops)\n+\n+// 13.4. Vector Single-Width Floating-Point Multiply/Divide Instructions\n+DEF_RVV_FUNCTION (vfmul, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfmul, alu, full_preds, f_vvf_ops)\n+DEF_RVV_FUNCTION (vfdiv, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfdiv, alu, full_preds, f_vvf_ops)\n+DEF_RVV_FUNCTION (vfrdiv, alu, full_preds, f_vvf_ops)\n+\n+// 13.5. Vector Widening Floating-Point Multiply\n+DEF_RVV_FUNCTION (vfwmul, alu, full_preds, f_wvv_ops)\n+DEF_RVV_FUNCTION (vfwmul, alu, full_preds, f_wvf_ops)\n+\n+// 13.6. Vector Single-Width Floating-Point Fused Multiply-Add Instructions\n+DEF_RVV_FUNCTION (vfmacc, alu, full_preds, f_vvvv_ops)\n+DEF_RVV_FUNCTION (vfmacc, alu, full_preds, f_vvfv_ops)\n+DEF_RVV_FUNCTION (vfnmsac, alu, full_preds, f_vvvv_ops)\n+DEF_RVV_FUNCTION (vfnmsac, alu, full_preds, f_vvfv_ops)\n+DEF_RVV_FUNCTION (vfmadd, alu, full_preds, f_vvvv_ops)\n+DEF_RVV_FUNCTION (vfmadd, alu, full_preds, f_vvfv_ops)\n+DEF_RVV_FUNCTION (vfnmsub, alu, full_preds, f_vvvv_ops)\n+DEF_RVV_FUNCTION (vfnmsub, alu, full_preds, f_vvfv_ops)\n+DEF_RVV_FUNCTION (vfnmacc, alu, full_preds, f_vvvv_ops)\n+DEF_RVV_FUNCTION (vfnmacc, alu, full_preds, f_vvfv_ops)\n+DEF_RVV_FUNCTION (vfmsac, alu, full_preds, f_vvvv_ops)\n+DEF_RVV_FUNCTION (vfmsac, alu, full_preds, f_vvfv_ops)\n+DEF_RVV_FUNCTION (vfnmadd, alu, full_preds, f_vvvv_ops)\n+DEF_RVV_FUNCTION (vfnmadd, alu, full_preds, f_vvfv_ops)\n+DEF_RVV_FUNCTION (vfmsub, alu, full_preds, f_vvvv_ops)\n+DEF_RVV_FUNCTION (vfmsub, alu, full_preds, f_vvfv_ops)\n+\n+// 13.7. Vector Widening Floating-Point Fused Multiply-Add Instructions\n+DEF_RVV_FUNCTION (vfwmacc, alu, full_preds, f_wwvv_ops)\n+DEF_RVV_FUNCTION (vfwmacc, alu, full_preds, f_wwfv_ops)\n+DEF_RVV_FUNCTION (vfwnmacc, alu, full_preds, f_wwvv_ops)\n+DEF_RVV_FUNCTION (vfwnmacc, alu, full_preds, f_wwfv_ops)\n+DEF_RVV_FUNCTION (vfwmsac, alu, full_preds, f_wwvv_ops)\n+DEF_RVV_FUNCTION (vfwmsac, alu, full_preds, f_wwfv_ops)\n+DEF_RVV_FUNCTION (vfwnmsac, alu, full_preds, f_wwvv_ops)\n+DEF_RVV_FUNCTION (vfwnmsac, alu, full_preds, f_wwfv_ops)\n+\n+// 13.8. Vector Floating-Point Square-Root Instruction\n+DEF_RVV_FUNCTION (vfsqrt, alu, full_preds, f_v_ops)\n+\n+// 13.9. Vector Floating-Point Reciprocal Square-Root Estimate Instruction\n+DEF_RVV_FUNCTION (vfrsqrt7, alu, full_preds, f_v_ops)\n+\n+// 13.10. Vector Floating-Point Reciprocal Estimate Instruction\n+DEF_RVV_FUNCTION (vfrec7, alu, full_preds, f_v_ops)\n+\n+// 13.11. Vector Floating-Point MIN/MAX Instructions\n+DEF_RVV_FUNCTION (vfmin, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfmin, alu, full_preds, f_vvf_ops)\n+DEF_RVV_FUNCTION (vfmax, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfmax, alu, full_preds, f_vvf_ops)\n+\n+// 13.12. Vector Floating-Point Sign-Injection Instructions\n+DEF_RVV_FUNCTION (vfsgnj, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfsgnj, alu, full_preds, f_vvf_ops)\n+DEF_RVV_FUNCTION (vfsgnjn, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfsgnjn, alu, full_preds, f_vvf_ops)\n+DEF_RVV_FUNCTION (vfsgnjx, alu, full_preds, f_vvv_ops)\n+DEF_RVV_FUNCTION (vfsgnjx, alu, full_preds, f_vvf_ops)\n+DEF_RVV_FUNCTION (vfneg, alu, full_preds, f_v_ops)\n+DEF_RVV_FUNCTION (vfabs, alu, full_preds, f_v_ops)\n+\n+// 13.13. Vector Floating-Point Compare Instructions\n+DEF_RVV_FUNCTION (vmfeq, return_mask, none_m_mu_preds, f_mvv_ops)\n+DEF_RVV_FUNCTION (vmfeq, return_mask, none_m_mu_preds, f_mvf_ops)\n+DEF_RVV_FUNCTION (vmfne, return_mask, none_m_mu_preds, f_mvv_ops)\n+DEF_RVV_FUNCTION (vmfne, return_mask, none_m_mu_preds, f_mvf_ops)\n+DEF_RVV_FUNCTION (vmflt, return_mask, none_m_mu_preds, f_mvv_ops)\n+DEF_RVV_FUNCTION (vmflt, return_mask, none_m_mu_preds, f_mvf_ops)\n+DEF_RVV_FUNCTION (vmfle, return_mask, none_m_mu_preds, f_mvv_ops)\n+DEF_RVV_FUNCTION (vmfle, return_mask, none_m_mu_preds, f_mvf_ops)\n+DEF_RVV_FUNCTION (vmfgt, return_mask, none_m_mu_preds, f_mvv_ops)\n+DEF_RVV_FUNCTION (vmfgt, return_mask, none_m_mu_preds, f_mvf_ops)\n+DEF_RVV_FUNCTION (vmfge, return_mask, none_m_mu_preds, f_mvv_ops)\n+DEF_RVV_FUNCTION (vmfge, return_mask, none_m_mu_preds, f_mvf_ops)\n+\n+// 13.14. Vector Floating-Point Classify Instruction\n+DEF_RVV_FUNCTION (vfclass, alu, full_preds, f_to_u_v_ops)\n+\n+// 13.15. Vector Floating-Point Merge Instruction\n+DEF_RVV_FUNCTION (vfmerge, no_mask_policy, none_tu_preds, f_vvfm_ops)\n+\n+// 13.16. Vector Floating-Point Move Instruction\n+DEF_RVV_FUNCTION (vfmv_v, move, none_tu_preds, f_f_ops)\n+\n+// 13.17. Single-Width Floating-Point/Integer Type-Convert Instructions\n+DEF_RVV_FUNCTION (vfcvt_x, alu, full_preds, f_to_i_f_v_ops)\n+DEF_RVV_FUNCTION (vfcvt_xu, alu, full_preds, f_to_u_f_v_ops)\n+DEF_RVV_FUNCTION (vfcvt_rtz_x, alu, full_preds, f_to_i_f_v_ops)\n+DEF_RVV_FUNCTION (vfcvt_rtz_xu, alu, full_preds, f_to_u_f_v_ops)\n+DEF_RVV_FUNCTION (vfcvt_f, alu, full_preds, i_to_f_x_v_ops)\n+DEF_RVV_FUNCTION (vfcvt_f, alu, full_preds, u_to_f_xu_v_ops)\n+\n+// 13.18. Widening Floating-Point/Integer Type-Convert Instructions\n+DEF_RVV_FUNCTION (vfwcvt_x, alu, full_preds, f_to_wi_f_v_ops)\n+DEF_RVV_FUNCTION (vfwcvt_xu, alu, full_preds, f_to_wu_f_v_ops)\n+DEF_RVV_FUNCTION (vfwcvt_rtz_x, alu, full_preds, f_to_wi_f_v_ops)\n+DEF_RVV_FUNCTION (vfwcvt_rtz_xu, alu, full_preds, f_to_wu_f_v_ops)\n+DEF_RVV_FUNCTION (vfwcvt_f, alu, full_preds, i_to_wf_x_v_ops)\n+DEF_RVV_FUNCTION (vfwcvt_f, alu, full_preds, u_to_wf_xu_v_ops)\n+DEF_RVV_FUNCTION (vfwcvt_f, alu, full_preds, f_to_wf_f_v_ops)\n+\n+// 13.19. Narrowing Floating-Point/Integer Type-Convert Instructions\n+DEF_RVV_FUNCTION (vfncvt_x, narrow_alu, full_preds, f_to_ni_f_w_ops)\n+DEF_RVV_FUNCTION (vfncvt_xu, narrow_alu, full_preds, f_to_nu_f_w_ops)\n+DEF_RVV_FUNCTION (vfncvt_rtz_x, narrow_alu, full_preds, f_to_ni_f_w_ops)\n+DEF_RVV_FUNCTION (vfncvt_rtz_xu, narrow_alu, full_preds, f_to_nu_f_w_ops)\n+DEF_RVV_FUNCTION (vfncvt_f, narrow_alu, full_preds, i_to_nf_x_w_ops)\n+DEF_RVV_FUNCTION (vfncvt_f, narrow_alu, full_preds, u_to_nf_xu_w_ops)\n+DEF_RVV_FUNCTION (vfncvt_f, narrow_alu, full_preds, f_to_nf_f_w_ops)\n+DEF_RVV_FUNCTION (vfncvt_rod_f, narrow_alu, full_preds, f_to_nf_f_w_ops)\n+\n /* TODO: 14. Vector Reduction Operations.  */\n \n /* 15. Vector Mask Instructions.  */"}, {"sha": "1fbf0f4e902ece05b5dd5c515c1318d5f2ef50c3", "filename": "gcc/config/riscv/riscv-vector-builtins-shapes.cc", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-shapes.cc?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -197,22 +197,12 @@ struct alu_def : public build_base\n \n     b.append_base_name (instance.base_name);\n \n-    /* vop<sew> --> vop<sew>_<op>. According to rvv-intrinsic-doc, _vv/_vx/_v\n-       API doesn't have OP suffix in overloaded function name, otherwise, we\n-       always append OP suffix in function name. For example, vsext_vf2.  */\n-    if (instance.op_info->op == OP_TYPE_vv || instance.op_info->op == OP_TYPE_vx\n-\t|| instance.op_info->op == OP_TYPE_v\n-\t|| instance.op_info->op == OP_TYPE_x_v)\n-      {\n-\tif (!overloaded_p)\n-\t  b.append_name (operand_suffixes[instance.op_info->op]);\n-      }\n-    else\n-      b.append_name (operand_suffixes[instance.op_info->op]);\n-\n     /* vop<sew>_<op> --> vop<sew>_<op>_<type>.  */\n     if (!overloaded_p)\n-      b.append_name (type_suffixes[instance.type.index].vector);\n+      {\n+\tb.append_name (operand_suffixes[instance.op_info->op]);\n+\tb.append_name (type_suffixes[instance.type.index].vector);\n+      }\n \n     /* According to rvv-intrinsic-doc, it does not add \"_m\" suffix\n        for vop_m C++ overloaded API.  */\n@@ -333,9 +323,9 @@ struct move_def : public build_base\n   char *get_name (function_builder &b, const function_instance &instance,\n \t\t  bool overloaded_p) const override\n   {\n-    /* vmv.v.x (PRED_none) can not be overloaded.  */\n-    if (instance.op_info->op == OP_TYPE_x && overloaded_p\n-\t&& instance.pred == PRED_TYPE_none)\n+    /* vmv.v.x/vfmv.v.f (PRED_none) can not be overloaded.  */\n+    if ((instance.op_info->op == OP_TYPE_x || instance.op_info->op == OP_TYPE_f)\n+\t&& overloaded_p && instance.pred == PRED_TYPE_none)\n       return nullptr;\n \n     b.append_base_name (instance.base_name);"}, {"sha": "bb3811d2d904e25837c6862fc0135100ab951b84", "filename": "gcc/config/riscv/riscv-vector-builtins-types.def", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-types.def?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -92,6 +92,47 @@ along with GCC; see the file COPYING3. If not see\n #define DEF_RVV_FULL_V_U_OPS(TYPE, REQUIRE)\n #endif\n \n+/* Use \"DEF_RVV_WEXTF_OPS\" macro include Double-Widening float which\n+   will be iterated and registered as intrinsic functions.  */\n+#ifndef DEF_RVV_WEXTF_OPS\n+#define DEF_RVV_WEXTF_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_CONVERT_I_OPS\" macro include all integer that will be converted\n+   in the float with same nunits which will be iterated and registered as\n+   intrinsic functions.  */\n+#ifndef DEF_RVV_CONVERT_I_OPS\n+#define DEF_RVV_CONVERT_I_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_CONVERT_U_OPS\" macro include all unsigned integer that will be\n+   converted in the float with same nunits which will be iterated and registered\n+   as intrinsic functions.  */\n+#ifndef DEF_RVV_CONVERT_U_OPS\n+#define DEF_RVV_CONVERT_U_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_WCONVERT_I_OPS\" macro include all integer that will be widen\n+   converted in the float with same nunits which will be iterated and registered\n+   as intrinsic functions.  */\n+#ifndef DEF_RVV_WCONVERT_I_OPS\n+#define DEF_RVV_WCONVERT_I_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_WCONVERT_U_OPS\" macro include all unsigned integer that will be\n+   widen converted in the float with same nunits which will be iterated and\n+   registered as intrinsic functions.  */\n+#ifndef DEF_RVV_WCONVERT_U_OPS\n+#define DEF_RVV_WCONVERT_U_OPS(TYPE, REQUIRE)\n+#endif\n+\n+/* Use \"DEF_RVV_WCONVERT_F_OPS\" macro include all unsigned integer that will be\n+   widen converted in the float with same nunits which will be iterated and\n+   registered as intrinsic functions.  */\n+#ifndef DEF_RVV_WCONVERT_F_OPS\n+#define DEF_RVV_WCONVERT_F_OPS(TYPE, REQUIRE)\n+#endif\n+\n DEF_RVV_I_OPS (vint8mf8_t, RVV_REQUIRE_ZVE64)\n DEF_RVV_I_OPS (vint8mf4_t, 0)\n DEF_RVV_I_OPS (vint8mf2_t, 0)\n@@ -264,6 +305,46 @@ DEF_RVV_FULL_V_U_OPS (vuint64m2_t, RVV_REQUIRE_FULL_V)\n DEF_RVV_FULL_V_U_OPS (vuint64m4_t, RVV_REQUIRE_FULL_V)\n DEF_RVV_FULL_V_U_OPS (vuint64m8_t, RVV_REQUIRE_FULL_V)\n \n+DEF_RVV_WEXTF_OPS (vfloat64m1_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_WEXTF_OPS (vfloat64m2_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_WEXTF_OPS (vfloat64m4_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_WEXTF_OPS (vfloat64m8_t, RVV_REQUIRE_ELEN_FP_64)\n+\n+DEF_RVV_CONVERT_I_OPS (vint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_CONVERT_I_OPS (vint32m1_t, 0)\n+DEF_RVV_CONVERT_I_OPS (vint32m2_t, 0)\n+DEF_RVV_CONVERT_I_OPS (vint32m4_t, 0)\n+DEF_RVV_CONVERT_I_OPS (vint32m8_t, 0)\n+DEF_RVV_CONVERT_I_OPS (vint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_CONVERT_I_OPS (vint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_CONVERT_I_OPS (vint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_CONVERT_I_OPS (vint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_CONVERT_U_OPS (vuint32mf2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_CONVERT_U_OPS (vuint32m1_t, 0)\n+DEF_RVV_CONVERT_U_OPS (vuint32m2_t, 0)\n+DEF_RVV_CONVERT_U_OPS (vuint32m4_t, 0)\n+DEF_RVV_CONVERT_U_OPS (vuint32m8_t, 0)\n+DEF_RVV_CONVERT_U_OPS (vuint64m1_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_CONVERT_U_OPS (vuint64m2_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_CONVERT_U_OPS (vuint64m4_t, RVV_REQUIRE_ZVE64)\n+DEF_RVV_CONVERT_U_OPS (vuint64m8_t, RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_WCONVERT_I_OPS (vint64m1_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+DEF_RVV_WCONVERT_I_OPS (vint64m2_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+DEF_RVV_WCONVERT_I_OPS (vint64m4_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+DEF_RVV_WCONVERT_I_OPS (vint64m8_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_WCONVERT_U_OPS (vuint64m1_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+DEF_RVV_WCONVERT_U_OPS (vuint64m2_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+DEF_RVV_WCONVERT_U_OPS (vuint64m4_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+DEF_RVV_WCONVERT_U_OPS (vuint64m8_t, RVV_REQUIRE_ELEN_FP_32 | RVV_REQUIRE_ZVE64)\n+\n+DEF_RVV_WCONVERT_F_OPS (vfloat64m1_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_WCONVERT_F_OPS (vfloat64m2_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_WCONVERT_F_OPS (vfloat64m4_t, RVV_REQUIRE_ELEN_FP_64)\n+DEF_RVV_WCONVERT_F_OPS (vfloat64m8_t, RVV_REQUIRE_ELEN_FP_64)\n+\n #undef DEF_RVV_I_OPS\n #undef DEF_RVV_U_OPS\n #undef DEF_RVV_F_OPS\n@@ -276,3 +357,9 @@ DEF_RVV_FULL_V_U_OPS (vuint64m8_t, RVV_REQUIRE_FULL_V)\n #undef DEF_RVV_OEXTU_OPS\n #undef DEF_RVV_FULL_V_I_OPS\n #undef DEF_RVV_FULL_V_U_OPS\n+#undef DEF_RVV_WEXTF_OPS\n+#undef DEF_RVV_CONVERT_I_OPS\n+#undef DEF_RVV_CONVERT_U_OPS\n+#undef DEF_RVV_WCONVERT_I_OPS\n+#undef DEF_RVV_WCONVERT_U_OPS\n+#undef DEF_RVV_WCONVERT_F_OPS"}, {"sha": "7858a6d0e8662dde03a49a4f1cbe9944310f3e42", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 374, "deletions": 34, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -147,12 +147,42 @@ static const rvv_type_info full_v_u_ops[] = {\n #include \"riscv-vector-builtins-types.def\"\n   {NUM_VECTOR_TYPES, 0}};\n \n-/* A list of all signed integer will be registered for intrinsic functions.  */\n+/* A list of all unsigned integer will be registered for intrinsic functions.  */\n static const rvv_type_info u_ops[] = {\n #define DEF_RVV_U_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n #include \"riscv-vector-builtins-types.def\"\n   {NUM_VECTOR_TYPES, 0}};\n \n+/* A list of all signed integer will be registered for intrinsic functions.  */\n+static const rvv_type_info convert_i_ops[] = {\n+#define DEF_RVV_CONVERT_I_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of all unsigned integer will be registered for intrinsic functions.  */\n+static const rvv_type_info convert_u_ops[] = {\n+#define DEF_RVV_CONVERT_U_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of all signed integer will be registered for intrinsic functions.  */\n+static const rvv_type_info wconvert_i_ops[] = {\n+#define DEF_RVV_WCONVERT_I_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of all unsigned integer will be registered for intrinsic functions. */\n+static const rvv_type_info wconvert_u_ops[] = {\n+#define DEF_RVV_WCONVERT_U_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n+/* A list of all floating-point will be registered for intrinsic functions. */\n+static const rvv_type_info wconvert_f_ops[] = {\n+#define DEF_RVV_WCONVERT_F_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n /* A list of all integer will be registered for intrinsic functions.  */\n static const rvv_type_info iu_ops[] = {\n #define DEF_RVV_I_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n@@ -174,13 +204,26 @@ static const rvv_type_info b_ops[] = {\n #include \"riscv-vector-builtins-types.def\"\n   {NUM_VECTOR_TYPES, 0}};\n \n+/* A list of all float will be registered for intrinsic functions.  */\n+static const rvv_type_info f_ops[] = {\n+#define DEF_RVV_F_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n /* A list of Double-Widening signed integer will be registered for intrinsic\n  * functions.  */\n static const rvv_type_info wexti_ops[] = {\n #define DEF_RVV_WEXTI_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n #include \"riscv-vector-builtins-types.def\"\n   {NUM_VECTOR_TYPES, 0}};\n \n+/* A list of Double-Widening float will be registered for intrinsic functions.\n+ */\n+static const rvv_type_info wextf_ops[] = {\n+#define DEF_RVV_WEXTF_OPS(TYPE, REQUIRE) {VECTOR_TYPE_##TYPE, REQUIRE},\n+#include \"riscv-vector-builtins-types.def\"\n+  {NUM_VECTOR_TYPES, 0}};\n+\n /* A list of Quad-Widening signed integer will be registered for intrinsic\n  * functions.  */\n static const rvv_type_info qexti_ops[] = {\n@@ -375,6 +418,19 @@ static CONSTEXPR const rvv_arg_type_info shift_wv_args[]\n static CONSTEXPR const rvv_arg_type_info v_args[]\n   = {rvv_arg_type_info (RVV_BASE_vector), rvv_arg_type_info_end};\n \n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info f_v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_float_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info trunc_f_v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_float_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info w_v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n+\n /* A list of args for vector_type func (vector_type) function.  */\n static CONSTEXPR const rvv_arg_type_info m_args[]\n   = {rvv_arg_type_info (RVV_BASE_mask), rvv_arg_type_info_end};\n@@ -479,6 +535,24 @@ static CONSTEXPR const rvv_arg_type_info vf8_args[]\n static CONSTEXPR const rvv_arg_type_info x_x_v_args[]\n   = {rvv_arg_type_info (RVV_BASE_double_trunc_vector), rvv_arg_type_info_end};\n \n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info x_v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_signed_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info xu_v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_unsigned_vector), rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info w_x_v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_signed_vector),\n+     rvv_arg_type_info_end};\n+\n+/* A list of args for vector_type func (vector_type) function.  */\n+static CONSTEXPR const rvv_arg_type_info w_xu_v_args[]\n+  = {rvv_arg_type_info (RVV_BASE_double_trunc_unsigned_vector),\n+     rvv_arg_type_info_end};\n+\n /* A list of none preds that will be registered for intrinsic functions.  */\n static CONSTEXPR const predication_type_index none_preds[]\n   = {PRED_TYPE_none, NUM_PRED_TYPES};\n@@ -707,6 +781,22 @@ static CONSTEXPR const rvv_op_info iu_vvxv_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      vxv_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, vector_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info f_vvvv_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, scalar_type,\n+ * vector_type) function registration. */\n+static CONSTEXPR const rvv_op_info f_vvfv_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vxv_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, vector_type,\n  * mask_type) function registration. */\n static CONSTEXPR const rvv_op_info iu_vvvm_ops\n@@ -731,6 +821,14 @@ static CONSTEXPR const rvv_op_info iu_vvxm_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      vxm_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, scalar_type,\n+ * mask_type) function registration. */\n+static CONSTEXPR const rvv_op_info f_vvfm_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vfm,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vxm_args /* Args */};\n+\n /* A static operand information for mask_type func (vector_type, vector_type,\n  * mask_type) function registration. */\n static CONSTEXPR const rvv_op_info iu_mvvm_ops\n@@ -771,6 +869,14 @@ static CONSTEXPR const rvv_op_info u_mvv_ops\n      rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n      vv_args /* Args */};\n \n+/* A static operand information for mask_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_mvv_ops\n+  = {f_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vv_args /* Args */};\n+\n /* A static operand information for mask_type func (vector_type, scalar_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info iu_mvx_ops\n@@ -795,6 +901,14 @@ static CONSTEXPR const rvv_op_info u_mvx_ops\n      rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n      vx_args /* Args */};\n \n+/* A static operand information for mask_type func (vector_type, scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_mvf_ops\n+  = {f_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vf,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_mask), /* Return type */\n+     vx_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, vector_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info i_vvv_ops\n@@ -811,6 +925,22 @@ static CONSTEXPR const rvv_op_info u_vvv_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      vv_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_vvv_ops\n+  = {f_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vv,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_vvf_ops\n+  = {f_ops,\t\t\t\t/* Types */\n+     OP_TYPE_vf,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     vx_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, vector_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info full_v_i_vvv_ops\n@@ -940,6 +1070,135 @@ static CONSTEXPR const rvv_op_info iu_v_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      v_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_v_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_u_v_ops\n+  = {convert_u_ops,\t\t\t  /* Types */\n+     OP_TYPE_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     f_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_i_f_v_ops\n+  = {convert_i_ops,\t\t\t  /* Types */\n+     OP_TYPE_f_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     f_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_wi_f_v_ops\n+  = {wconvert_i_ops,\t\t\t  /* Types */\n+     OP_TYPE_f_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     trunc_f_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_ni_f_w_ops\n+  = {f_ops,\t\t\t\t\t\t      /* Types */\n+     OP_TYPE_f_w,\t\t\t\t\t      /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_signed_vector), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_nu_f_w_ops\n+  = {f_ops,\t  /* Types */\n+     OP_TYPE_f_w, /* Suffix */\n+     rvv_arg_type_info (\n+       RVV_BASE_double_trunc_unsigned_vector), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_to_f_x_v_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_x_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     x_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_to_f_xu_v_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_xu_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     xu_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_to_wf_x_v_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_x_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     w_x_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_to_wf_xu_v_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_xu_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     w_xu_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info i_to_nf_x_w_ops\n+  = {wconvert_i_ops,\t\t\t\t\t     /* Types */\n+     OP_TYPE_x_w,\t\t\t\t\t     /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_float_vector), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info u_to_nf_xu_w_ops\n+  = {wconvert_u_ops,\t\t\t\t\t     /* Types */\n+     OP_TYPE_xu_w,\t\t\t\t\t     /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_float_vector), /* Return type */\n+     v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_u_f_v_ops\n+  = {convert_u_ops,\t\t\t  /* Types */\n+     OP_TYPE_f_v,\t\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     f_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_wu_f_v_ops\n+  = {wconvert_u_ops,\t\t\t  /* Types */\n+     OP_TYPE_f_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     trunc_f_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_wf_f_v_ops\n+  = {f_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_f_v,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     w_v_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_to_nf_f_w_ops\n+  = {wconvert_f_ops,\t\t\t\t\t     /* Types */\n+     OP_TYPE_f_w,\t\t\t\t\t     /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_double_trunc_float_vector), /* Return type */\n+     v_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info all_v_ops\n@@ -956,6 +1215,14 @@ static CONSTEXPR const rvv_op_info iu_x_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      x_args /* Args */};\n \n+/* A static operand information for vector_type func (scalar_type)\n+ * function registration. */\n+static CONSTEXPR const rvv_op_info f_f_ops\n+  = {f_ops,\t\t\t/* Types */\n+     OP_TYPE_f,\t\t\t/* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     x_args /* Args */};\n+\n /* A static operand information for vector_type func (double demote type)\n  * function registration. */\n static CONSTEXPR const rvv_op_info i_vf2_ops\n@@ -1012,6 +1279,14 @@ static CONSTEXPR const rvv_op_info i_wvv_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      wvv_args /* Args */};\n \n+/* A static operand information for vector_type func (double demote type, double\n+ * demote type) function registration. */\n+static CONSTEXPR const rvv_op_info f_wvv_ops\n+  = {wextf_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wvv_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, double demote\n  * type, double demote type) function registration. */\n static CONSTEXPR const rvv_op_info i_wwvv_ops\n@@ -1028,6 +1303,22 @@ static CONSTEXPR const rvv_op_info i_wwxv_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      wwxv_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, double demote\n+ * type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info f_wwvv_ops\n+  = {wextf_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwvv_args /* Args */};\n+\n+/* A static operand information for vector_type func (vector_type, double demote\n+ * scalar_type, double demote type) function registration. */\n+static CONSTEXPR const rvv_op_info f_wwfv_ops\n+  = {wextf_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwxv_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, double demote\n  * type, double demote type) function registration. */\n static CONSTEXPR const rvv_op_info u_wwvv_ops\n@@ -1092,6 +1383,14 @@ static CONSTEXPR const rvv_op_info i_wvx_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      wvx_args /* Args */};\n \n+/* A static operand information for vector_type func (double demote type, double\n+ * demote scalar_type) function registration. */\n+static CONSTEXPR const rvv_op_info f_wvf_ops\n+  = {wextf_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_vf,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wvx_args /* Args */};\n+\n /* A static operand information for vector_type func (signed double demote type,\n  * unsigned double demote scalar_type) function registration. */\n static CONSTEXPR const rvv_op_info i_su_wvx_ops\n@@ -1108,6 +1407,14 @@ static CONSTEXPR const rvv_op_info i_wwv_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      wwv_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, double\n+ * demote type) function registration. */\n+static CONSTEXPR const rvv_op_info f_wwv_ops\n+  = {wextf_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_wv,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwv_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, double\n  * demote scalar_type) function registration. */\n static CONSTEXPR const rvv_op_info i_wwx_ops\n@@ -1116,6 +1423,14 @@ static CONSTEXPR const rvv_op_info i_wwx_ops\n      rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n      wwx_args /* Args */};\n \n+/* A static operand information for vector_type func (vector_type, double\n+ * demote scalar_type) function registration. */\n+static CONSTEXPR const rvv_op_info f_wwf_ops\n+  = {wextf_ops,\t\t\t\t  /* Types */\n+     OP_TYPE_wf,\t\t\t  /* Suffix */\n+     rvv_arg_type_info (RVV_BASE_vector), /* Return type */\n+     wwx_args /* Args */};\n+\n /* A static operand information for vector_type func (vector_type, double\n  * demote type) function registration. */\n static CONSTEXPR const rvv_op_info u_wwv_ops\n@@ -1388,9 +1703,11 @@ register_vector_type (vector_type_index type)\n static bool\n required_extensions_p (enum rvv_base_type type)\n {\n-  return type == RVV_BASE_vector || type == RVV_BASE_uint8_index\n-\t || type == RVV_BASE_uint16_index || type == RVV_BASE_uint32_index\n-\t || type == RVV_BASE_uint64_index;\n+  return type == RVV_BASE_uint8_index || type == RVV_BASE_uint16_index\n+\t || type == RVV_BASE_uint32_index || type == RVV_BASE_uint64_index\n+\t || type == RVV_BASE_float_vector\n+\t || type == RVV_BASE_double_trunc_float_vector\n+\t || type == RVV_BASE_double_trunc_vector;\n }\n \n /* Check whether all the RVV_REQUIRE_* values in REQUIRED_EXTENSIONS are\n@@ -1410,7 +1727,7 @@ check_required_extensions (const function_instance &instance)\n       enum vector_type_index vector_type\n \t= op_info->args[i].get_base_vector_type (type);\n       if (vector_type == NUM_VECTOR_TYPES)\n-\tcontinue;\n+\treturn false;\n       required_extensions |= op_info->types[vector_type].required_extensions;\n \n       /* According to RVV ISA, EEW=64 index of indexed loads/stores require\n@@ -1474,68 +1791,89 @@ get_mask_policy_for_pred (enum predication_type_index pred)\n   return gen_int_mode (get_prefer_mask_policy (), Pmode);\n }\n \n+static bool\n+unsigned_base_type_p (rvv_base_type base_type)\n+{\n+  return base_type == RVV_BASE_double_trunc_unsigned_vector\n+\t || base_type == RVV_BASE_double_trunc_unsigned_scalar\n+\t || base_type == RVV_BASE_unsigned_vector\n+\t || base_type == RVV_BASE_uint8_index\n+\t || base_type == RVV_BASE_uint16_index\n+\t || base_type == RVV_BASE_uint32_index\n+\t || base_type == RVV_BASE_uint64_index\n+\t || base_type == RVV_BASE_shift_vector;\n+}\n+\n+static machine_mode\n+get_mode_for_bitsize (poly_int64 bitsize, bool float_mode_p)\n+{\n+  if (float_mode_p)\n+    return float_mode_for_size (bitsize).require ();\n+  else\n+    return int_mode_for_size (bitsize, 0).require ();\n+}\n+\n vector_type_index\n rvv_arg_type_info::get_base_vector_type (tree type) const\n {\n   if (!type)\n     return NUM_VECTOR_TYPES;\n+\n   poly_int64 nunits = GET_MODE_NUNITS (TYPE_MODE (type));\n   machine_mode inner_mode = GET_MODE_INNER (TYPE_MODE (type));\n+  poly_int64 bitsize = GET_MODE_BITSIZE (inner_mode);\n+\n   bool unsigned_p = TYPE_UNSIGNED (type);\n-  if (base_type == RVV_BASE_double_trunc_unsigned_vector\n-      || base_type == RVV_BASE_double_trunc_unsigned_scalar)\n+  if (unsigned_base_type_p (base_type))\n     unsigned_p = true;\n+\n   switch (base_type)\n     {\n     case RVV_BASE_mask:\n       inner_mode = E_BImode;\n       break;\n     case RVV_BASE_uint8_index:\n       inner_mode = E_QImode;\n-      unsigned_p = true;\n       break;\n     case RVV_BASE_uint16_index:\n       inner_mode = E_HImode;\n-      unsigned_p = true;\n       break;\n     case RVV_BASE_uint32_index:\n       inner_mode = E_SImode;\n-      unsigned_p = true;\n       break;\n     case RVV_BASE_uint64_index:\n       inner_mode = E_DImode;\n-      unsigned_p = true;\n       break;\n     case RVV_BASE_shift_vector:\n       inner_mode = GET_MODE_INNER (TYPE_MODE (type));\n-      unsigned_p = true;\n       break;\n     case RVV_BASE_double_trunc_vector:\n     case RVV_BASE_double_trunc_scalar:\n+      inner_mode = get_mode_for_bitsize (exact_div (bitsize, 2),\n+\t\t\t\t\t FLOAT_MODE_P (inner_mode));\n+      break;\n     case RVV_BASE_double_trunc_unsigned_vector:\n     case RVV_BASE_double_trunc_unsigned_scalar:\n-      if (inner_mode == DImode)\n-\tinner_mode = SImode;\n-      else if (inner_mode == SImode)\n-\tinner_mode = HImode;\n-      else if (inner_mode == HImode)\n-\tinner_mode = QImode;\n-      else\n-\tgcc_unreachable ();\n+    case RVV_BASE_double_trunc_signed_vector:\n+      inner_mode = int_mode_for_size (exact_div (bitsize, 2), 0).require ();\n       break;\n     case RVV_BASE_quad_trunc_vector:\n-      if (inner_mode == DImode)\n-\tinner_mode = HImode;\n-      else if (inner_mode == SImode)\n-\tinner_mode = QImode;\n-      else\n-\tgcc_unreachable ();\n+      inner_mode = get_mode_for_bitsize (exact_div (bitsize, 4),\n+\t\t\t\t\t FLOAT_MODE_P (inner_mode));\n       break;\n     case RVV_BASE_oct_trunc_vector:\n-      if (inner_mode == DImode)\n-\tinner_mode = QImode;\n-      else\n-\tgcc_unreachable ();\n+      inner_mode = get_mode_for_bitsize (exact_div (bitsize, 8),\n+\t\t\t\t\t FLOAT_MODE_P (inner_mode));\n+      break;\n+    case RVV_BASE_float_vector:\n+      inner_mode = float_mode_for_size (bitsize).require ();\n+      break;\n+    case RVV_BASE_double_trunc_float_vector:\n+      inner_mode = float_mode_for_size (exact_div (bitsize, 2)).require ();\n+      break;\n+    case RVV_BASE_signed_vector:\n+    case RVV_BASE_unsigned_vector:\n+      inner_mode = int_mode_for_mode (inner_mode).require ();\n       break;\n     default:\n       return NUM_VECTOR_TYPES;\n@@ -1552,7 +1890,7 @@ rvv_arg_type_info::get_base_vector_type (tree type) const\n       if (!vector_type)\n \tcontinue;\n \n-      if (GET_MODE_CLASS (TYPE_MODE (vector_type)) != MODE_VECTOR_BOOL\n+      if (GET_MODE_CLASS (TYPE_MODE (vector_type)) == MODE_VECTOR_INT\n \t  && TYPE_UNSIGNED (vector_type) != unsigned_p)\n \tcontinue;\n \n@@ -1581,9 +1919,6 @@ rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n        type is always the signed type + 1 (They have same SEW and LMUL).\n        For example 'vuint8mf8_t' enum = 'vint8mf8_t' enum + 1.\n        Note: We dont't allow type_idx to be unsigned type.  */\n-    case RVV_BASE_unsigned_vector:\n-      gcc_assert (!TYPE_UNSIGNED (builtin_types[type_idx].vector));\n-      return builtin_types[type_idx + 1].vector;\n     case RVV_BASE_unsigned_scalar:\n       gcc_assert (!TYPE_UNSIGNED (builtin_types[type_idx].scalar));\n       return builtin_types[type_idx + 1].scalar;\n@@ -1621,8 +1956,13 @@ rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n     case RVV_BASE_double_trunc_vector:\n     case RVV_BASE_quad_trunc_vector:\n     case RVV_BASE_oct_trunc_vector:\n+    case RVV_BASE_double_trunc_signed_vector:\n     case RVV_BASE_double_trunc_unsigned_vector:\n     case RVV_BASE_mask:\n+    case RVV_BASE_float_vector:\n+    case RVV_BASE_double_trunc_float_vector:\n+    case RVV_BASE_signed_vector:\n+    case RVV_BASE_unsigned_vector:\n       if (get_base_vector_type (builtin_types[type_idx].vector)\n \t  != NUM_VECTOR_TYPES)\n \treturn builtin_types[get_base_vector_type ("}, {"sha": "bb672f3b449f64a328f89377f1b4eb184f158d41", "filename": "gcc/config/riscv/riscv-vector-builtins.def", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -288,7 +288,11 @@ DEF_RVV_OP_TYPE (vf)\n DEF_RVV_OP_TYPE (vm)\n DEF_RVV_OP_TYPE (wf)\n DEF_RVV_OP_TYPE (vfm)\n-DEF_RVV_OP_TYPE (v_f)\n+DEF_RVV_OP_TYPE (f)\n+DEF_RVV_OP_TYPE (f_v)\n+DEF_RVV_OP_TYPE (xu_v)\n+DEF_RVV_OP_TYPE (f_w)\n+DEF_RVV_OP_TYPE (xu_w)\n \n DEF_RVV_PRED_TYPE (ta)\n DEF_RVV_PRED_TYPE (tu)"}, {"sha": "db6ab389e647c9464cc04d31786dbdb4b83688d8", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -141,6 +141,7 @@ enum rvv_base_type\n   RVV_BASE_vector,\n   RVV_BASE_scalar,\n   RVV_BASE_mask,\n+  RVV_BASE_signed_vector,\n   RVV_BASE_unsigned_vector,\n   RVV_BASE_unsigned_scalar,\n   RVV_BASE_vector_ptr,\n@@ -160,8 +161,11 @@ enum rvv_base_type\n   RVV_BASE_quad_trunc_vector,\n   RVV_BASE_oct_trunc_vector,\n   RVV_BASE_double_trunc_scalar,\n+  RVV_BASE_double_trunc_signed_vector,\n   RVV_BASE_double_trunc_unsigned_vector,\n   RVV_BASE_double_trunc_unsigned_scalar,\n+  RVV_BASE_float_vector,\n+  RVV_BASE_double_trunc_float_vector,\n   NUM_BASE_TYPES\n };\n \n@@ -343,6 +347,7 @@ class function_expander : public function_call_info\n \n   machine_mode vector_mode (void) const;\n   machine_mode index_mode (void) const;\n+  machine_mode arg_mode (int) const;\n \n   rtx use_exact_insn (insn_code);\n   rtx use_contiguous_load_insn (insn_code);\n@@ -492,6 +497,13 @@ function_expander::index_mode (void) const\n   return TYPE_MODE (op_info->args[1].get_tree_type (type.index));\n }\n \n+/* Return the machine_mode of the corresponding arg type.  */\n+inline machine_mode\n+function_expander::arg_mode (int idx) const\n+{\n+  return TYPE_MODE (op_info->args[idx].get_tree_type (type.index));\n+}\n+\n /* Default implementation of function_base::call_properties, with conservatively\n    correct behavior for floating-point instructions.  */\n inline unsigned int"}, {"sha": "127e1b07fcf05fcde19666205fb1a0d2eb3fb005", "filename": "gcc/config/riscv/vector-iterators.md", "status": "modified", "additions": 96, "deletions": 5, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -54,6 +54,18 @@\n   UNSPEC_VMSIF\n   UNSPEC_VMSOF\n   UNSPEC_VIOTA\n+\n+  UNSPEC_VFRSQRT7\n+  UNSPEC_VFREC7\n+  UNSPEC_VFCLASS\n+\n+  UNSPEC_VCOPYSIGN\n+  UNSPEC_VNCOPYSIGN\n+  UNSPEC_VXORSIGN\n+\n+  UNSPEC_VFCVT\n+  UNSPEC_UNSIGNED_VFCVT\n+  UNSPEC_ROD\n ])\n \n (define_mode_iterator V [\n@@ -81,6 +93,18 @@\n   (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n ])\n \n+(define_mode_iterator VF [\n+  (VNx1SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx2SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx4SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx8SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx16SF \"TARGET_VECTOR_ELEN_FP_32 && TARGET_MIN_VLEN > 32\")\n+  (VNx1DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx2DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx4DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx8DF \"TARGET_VECTOR_ELEN_FP_64\")\n+])\n+\n (define_mode_iterator VFULLI [\n   VNx1QI VNx2QI VNx4QI VNx8QI VNx16QI VNx32QI (VNx64QI \"TARGET_MIN_VLEN > 32\")\n   VNx1HI VNx2HI VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n@@ -210,6 +234,20 @@\n   (VNx4DI \"TARGET_MIN_VLEN > 32\") (VNx8DI \"TARGET_MIN_VLEN > 32\")\n ])\n \n+(define_mode_iterator VWEXTF [\n+  (VNx1DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx2DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx4DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx8DF \"TARGET_VECTOR_ELEN_FP_64\")\n+])\n+\n+(define_mode_iterator VWCONVERTI [\n+  (VNx1DI \"TARGET_MIN_VLEN > 32 && TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx2DI \"TARGET_MIN_VLEN > 32 && TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx4DI \"TARGET_MIN_VLEN > 32 && TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx8DI \"TARGET_MIN_VLEN > 32 && TARGET_VECTOR_ELEN_FP_32\")\n+])\n+\n (define_mode_iterator VQEXTI [\n   VNx1SI VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n   (VNx1DI \"TARGET_MIN_VLEN > 32\") (VNx2DI \"TARGET_MIN_VLEN > 32\")\n@@ -266,15 +304,16 @@\n ])\n \n (define_mode_attr V_DOUBLE_TRUNC [\n-  (VNx1HI \"VNx1QI\") (VNx2HI \"VNx2QI\")  (VNx4HI \"VNx4QI\")  (VNx8HI \"VNx8QI\")  \n+  (VNx1HI \"VNx1QI\") (VNx2HI \"VNx2QI\")  (VNx4HI \"VNx4QI\")  (VNx8HI \"VNx8QI\")\n   (VNx16HI \"VNx16QI\") (VNx32HI \"VNx32QI\")\n-  (VNx1SI \"VNx1HI\") (VNx2SI \"VNx2HI\") (VNx4SI \"VNx4HI\") (VNx8SI \"VNx8HI\") \n+  (VNx1SI \"VNx1HI\") (VNx2SI \"VNx2HI\") (VNx4SI \"VNx4HI\") (VNx8SI \"VNx8HI\")\n   (VNx16SI \"VNx16HI\")\n   (VNx1DI \"VNx1SI\") (VNx2DI \"VNx2SI\") (VNx4DI \"VNx4SI\") (VNx8DI \"VNx8SI\")\n+  (VNx1DF \"VNx1SF\") (VNx2DF \"VNx2SF\") (VNx4DF \"VNx4SF\") (VNx8DF \"VNx8SF\")\n ])\n \n (define_mode_attr V_QUAD_TRUNC [\n-  (VNx1SI \"VNx1QI\") (VNx2SI \"VNx2QI\") (VNx4SI \"VNx4QI\") (VNx8SI \"VNx8QI\") \n+  (VNx1SI \"VNx1QI\") (VNx2SI \"VNx2QI\") (VNx4SI \"VNx4QI\") (VNx8SI \"VNx8QI\")\n   (VNx16SI \"VNx16QI\")\n   (VNx1DI \"VNx1HI\") (VNx2DI \"VNx2HI\")\n   (VNx4DI \"VNx4HI\") (VNx8DI \"VNx8HI\")\n@@ -284,6 +323,17 @@\n   (VNx1DI \"VNx1QI\") (VNx2DI \"VNx2QI\") (VNx4DI \"VNx4QI\") (VNx8DI \"VNx8QI\")\n ])\n \n+(define_mode_attr VCONVERT [\n+  (VNx1SF \"VNx1SI\") (VNx2SF \"VNx2SI\") (VNx4SF \"VNx4SI\") (VNx8SF \"VNx8SI\") (VNx16SF \"VNx16SI\")\n+  (VNx1DF \"VNx1DI\") (VNx2DF \"VNx2DI\") (VNx4DF \"VNx4DI\") (VNx8DF \"VNx8DI\")\n+])\n+\n+(define_mode_attr VNCONVERT [\n+  (VNx1SF \"VNx1HI\") (VNx2SF \"VNx2HI\") (VNx4SF \"VNx4HI\") (VNx8SF \"VNx8HI\") (VNx16SF \"VNx16HI\")\n+  (VNx1DI \"VNx1SF\") (VNx2DI \"VNx2SF\") (VNx4DI \"VNx4SF\") (VNx8DI \"VNx8SF\")\n+  (VNx1DF \"VNx1SI\") (VNx2DF \"VNx2SI\") (VNx4DF \"VNx4SI\") (VNx8DF \"VNx8SI\")\n+])\n+\n (define_int_iterator ORDER [UNSPEC_ORDERED UNSPEC_UNORDERED])\n \n (define_int_iterator VMULH [UNSPEC_VMULHS UNSPEC_VMULHU UNSPEC_VMULHSU])\n@@ -300,12 +350,17 @@\n \n (define_int_iterator VMISC [UNSPEC_VMSBF UNSPEC_VMSIF UNSPEC_VMSOF])\n \n+(define_int_iterator VFMISC [UNSPEC_VFRSQRT7 UNSPEC_VFREC7])\n+\n+(define_int_iterator VFCVTS [UNSPEC_VFCVT UNSPEC_UNSIGNED_VFCVT])\n+\n (define_int_attr order [\n   (UNSPEC_ORDERED \"o\") (UNSPEC_UNORDERED \"u\")\n ])\n \n (define_int_attr v_su [(UNSPEC_VMULHS \"\") (UNSPEC_VMULHU \"u\") (UNSPEC_VMULHSU \"su\")\n-\t\t       (UNSPEC_VNCLIP \"\") (UNSPEC_VNCLIPU \"u\")])\n+\t\t       (UNSPEC_VNCLIP \"\") (UNSPEC_VNCLIPU \"u\")\n+\t\t       (UNSPEC_VFCVT \"\") (UNSPEC_UNSIGNED_VFCVT \"u\")])\n (define_int_attr sat_op [(UNSPEC_VAADDU \"aaddu\") (UNSPEC_VAADD \"aadd\")\n \t\t\t (UNSPEC_VASUBU \"asubu\") (UNSPEC_VASUB \"asub\")\n \t\t\t (UNSPEC_VSMUL \"smul\") (UNSPEC_VSSRL \"ssrl\")\n@@ -316,7 +371,19 @@\n \t\t\t \t(UNSPEC_VSSRA \"vsshift\") (UNSPEC_VNCLIP \"vnclip\")\n \t\t\t\t(UNSPEC_VNCLIPU \"vnclip\")])\n \n-(define_int_attr misc_op [(UNSPEC_VMSBF \"sbf\") (UNSPEC_VMSIF \"sif\") (UNSPEC_VMSOF \"sof\")])\n+(define_int_attr misc_op [(UNSPEC_VMSBF \"sbf\") (UNSPEC_VMSIF \"sif\") (UNSPEC_VMSOF \"sof\")\n+\t\t\t  (UNSPEC_VFRSQRT7 \"rsqrt7\") (UNSPEC_VFREC7 \"rec7\")])\n+\n+(define_int_attr float_insn_type [(UNSPEC_VFRSQRT7 \"vfsqrt\") (UNSPEC_VFREC7 \"vfrecp\")])\n+\n+(define_int_iterator VCOPYSIGNS [UNSPEC_VCOPYSIGN UNSPEC_VNCOPYSIGN UNSPEC_VXORSIGN])\n+\n+(define_int_attr copysign [(UNSPEC_VCOPYSIGN \"copysign\")\n+\t\t\t   (UNSPEC_VNCOPYSIGN \"ncopysign\")\n+\t\t\t   (UNSPEC_VXORSIGN \"xorsign\")])\n+\n+(define_int_attr nx [(UNSPEC_VCOPYSIGN \"\") (UNSPEC_VNCOPYSIGN \"n\")\n+\t\t     (UNSPEC_VXORSIGN \"x\")])\n \n (define_code_iterator any_int_binop [plus minus and ior xor ashift ashiftrt lshiftrt\n   smax umax smin umin mult div udiv mod umod\n@@ -339,8 +406,21 @@\n \n (define_code_attr macc_nmsac [(plus \"macc\") (minus \"nmsac\")])\n (define_code_attr madd_nmsub [(plus \"madd\") (minus \"nmsub\")])\n+(define_code_attr nmacc_msac [(plus \"nmacc\") (minus \"msac\")])\n+(define_code_attr nmadd_msub [(plus \"nmadd\") (minus \"msub\")])\n \n (define_code_iterator and_ior [and ior])\n+\n+(define_code_iterator any_float_binop [plus mult smax smin minus div])\n+(define_code_iterator commutative_float_binop [plus mult smax smin])\n+(define_code_iterator non_commutative_float_binop [minus div])\n+(define_code_iterator any_float_unop [neg abs sqrt])\n+\n+(define_code_iterator any_fix [fix unsigned_fix])\n+(define_code_iterator any_float [float unsigned_float])\n+(define_code_attr fix_cvt [(fix \"fix_trunc\") (unsigned_fix \"fixuns_trunc\")])\n+(define_code_attr float_cvt [(float \"float\") (unsigned_float \"floatuns\")])\n+\n (define_code_attr ninsn [(and \"nand\") (ior \"nor\") (xor \"xnor\")])\n \n (define_code_attr binop_rhs1_predicate [\n@@ -459,6 +539,17 @@\n \t\t\t(minus \"walu\")\n \t\t\t(mult \"wmul\")])\n \n+(define_code_attr float_insn_type [\n+\t\t\t(plus \"vfalu\")\n+\t\t\t(mult \"vfmul\")\n+\t\t\t(smax \"vfminmax\")\n+\t\t\t(smin \"vfminmax\")\n+\t\t\t(minus \"vfalu\")\n+\t\t\t(div \"vfdiv\")\n+\t\t\t(neg \"vfsgnj\")\n+\t\t\t(abs \"vfsgnj\")\n+\t\t\t(sqrt \"vfsqrt\")])\n+\n ;; <binop_vi_variant_insn> expands to the insn name of binop matching constraint rhs1 is immediate.\n ;; minus is negated as vadd and ss_minus is negated as vsadd, others remain <insn>.\n (define_code_attr binop_vi_variant_insn [(ashift \"sll.vi\")"}, {"sha": "51647386e0e8dbb3d44ec768737b58bc60e7110c", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 1547, "deletions": 33, "changes": 1580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -147,7 +147,11 @@\n \t\t\t  vext,viwalu,viwmul,vicalu,vnshift,\\\n \t\t\t  vimuladd,vimerge,vaalu,vsmul,vsshift,\\\n \t\t\t  vnclip,viminmax,viwmuladd,vmpop,vmffs,vmsfs,\\\n-\t\t\t  vmiota,vmidx\")\n+\t\t\t  vmiota,vmidx,vfalu,vfmul,vfminmax,vfdiv,\\\n+\t\t\t  vfwalu,vfwmul,vfsqrt,vfrecp,vfsgnj,vfcmp,\\\n+\t\t\t  vfmerge,vfcvtitof,vfcvtftoi,vfwcvtitof,\\\n+\t\t\t  vfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,\\\n+\t\t\t  vfncvtftof,vfmuladd,vfwmuladd,vfclass\")\n \t   (const_int INVALID_ATTRIBUTE)\n \t (eq_attr \"mode\" \"VNx1QI,VNx1BI\")\n \t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1QImode)\")\n@@ -200,20 +204,24 @@\n \t(cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vldm,vlds,vmalu,vldux,vldox,vicmp,\\\n \t\t\t\tvialu,vshift,viminmax,vimul,vidiv,vsalu,vext,viwalu,\\\n \t\t\t\tviwmul,vnshift,vaalu,vsmul,vsshift,vnclip,vmsfs,\\\n-\t\t\t\tvmiota,vmidx\")\n+\t\t\t\tvmiota,vmidx,vfalu,vfmul,vfminmax,vfdiv,vfwalu,vfwmul,\\\n+\t\t\t\tvfsqrt,vfrecp,vfsgnj,vfcmp,vfcvtitof,vfcvtftoi,vfwcvtitof,\\\n+\t\t\t\tvfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,vfclass\")\n \t       (const_int 2)\n \n-\t       (eq_attr \"type\" \"vimerge\")\n+\t       (eq_attr \"type\" \"vimerge,vfmerge\")\n \t       (const_int 1)\n \n-\t       (eq_attr \"type\" \"vimuladd,viwmuladd\")\n+\t       (eq_attr \"type\" \"vimuladd,viwmuladd,vfmuladd,vfwmuladd\")\n \t       (const_int 5)]\n \t(const_int INVALID_ATTRIBUTE)))\n \n ;; The index of operand[] to get the avl op.\n (define_attr \"vl_op_idx\" \"\"\n   (cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vldm,vstm,vmalu,vsts,vstux,\\\n-\t\t\t  vstox,vext,vmsfs,vmiota\")\n+\t\t\t  vstox,vext,vmsfs,vmiota,vfsqrt,vfrecp,vfcvtitof,\\\n+\t\t\t  vfcvtftoi,vfwcvtitof,vfwcvtftoi,vfwcvtftof,vfncvtitof,\\\n+\t\t\t  vfncvtftoi,vfncvtftof,vfclass\")\n \t   (const_int 4)\n \n \t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n@@ -225,10 +233,11 @@\n \n \t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n \t\t\t  viwalu,viwmul,vnshift,vimerge,vaalu,vsmul,\\\n-\t\t\t  vsshift,vnclip\")\n+\t\t\t  vsshift,vnclip,vfalu,vfmul,vfminmax,vfdiv,vfwalu,vfwmul,\\\n+\t\t\t  vfsgnj,vfmerge\")\n \t   (const_int 5)\n \n-\t (eq_attr \"type\" \"vicmp,vimuladd,viwmuladd\")\n+\t (eq_attr \"type\" \"vicmp,vimuladd,viwmuladd,vfcmp,vfmuladd,vfwmuladd\")\n \t   (const_int 6)\n \n \t (eq_attr \"type\" \"vmpop,vmffs,vmidx\")\n@@ -237,7 +246,9 @@\n \n ;; The tail policy op value.\n (define_attr \"ta\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vext,vmiota\")\n+  (cond [(eq_attr \"type\" \"vlde,vimov,vfmov,vext,vmiota,vfsqrt,vfrecp,\\\n+\t\t\t  vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,vfwcvtftof,\\\n+\t\t\t  vfncvtitof,vfncvtftoi,vfncvtftof,vfclass\")\n \t   (symbol_ref \"riscv_vector::get_ta(operands[5])\")\n \n \t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n@@ -249,10 +260,11 @@\n \n \t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n \t\t\t  viwalu,viwmul,vnshift,vimerge,vaalu,vsmul,\\\n-\t\t\t  vsshift,vnclip\")\n+\t\t\t  vsshift,vnclip,vfalu,vfmul,vfminmax,vfdiv,\\\n+\t\t\t  vfwalu,vfwmul,vfsgnj,vfmerge\")\n \t   (symbol_ref \"riscv_vector::get_ta(operands[6])\")\n \n-\t (eq_attr \"type\" \"vimuladd,viwmuladd\")\n+\t (eq_attr \"type\" \"vimuladd,viwmuladd,vfmuladd,vfwmuladd\")\n \t   (symbol_ref \"riscv_vector::get_ta(operands[7])\")\n \n \t (eq_attr \"type\" \"vmidx\")\n@@ -261,7 +273,9 @@\n \n ;; The mask policy op value.\n (define_attr \"ma\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vext,vmiota\")\n+  (cond [(eq_attr \"type\" \"vlde,vext,vmiota,vfsqrt,vfrecp,vfcvtitof,vfcvtftoi,\\\n+\t\t\t  vfwcvtitof,vfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,\\\n+\t\t\t  vfncvtftof,vfclass\")\n \t   (symbol_ref \"riscv_vector::get_ma(operands[6])\")\n \n \t ;; If operands[3] of \"vlds\" is not vector mode, it is pred_broadcast.\n@@ -273,10 +287,11 @@\n \n \t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n \t\t\t  viwalu,viwmul,vnshift,vaalu,vsmul,vsshift,\\\n-\t\t\t  vnclip,vicmp\")\n+\t\t\t  vnclip,vicmp,vfalu,vfmul,vfminmax,vfdiv,\\\n+\t\t\t  vfwalu,vfwmul,vfsgnj,vfcmp\")\n \t   (symbol_ref \"riscv_vector::get_ma(operands[7])\")\n \n-\t (eq_attr \"type\" \"vimuladd,viwmuladd\")\n+\t (eq_attr \"type\" \"vimuladd,viwmuladd,vfmuladd,vfwmuladd\")\n \t   (symbol_ref \"riscv_vector::get_ma(operands[8])\")\n \n \t (eq_attr \"type\" \"vmsfs,vmidx\")\n@@ -285,7 +300,9 @@\n \n ;; The avl type value.\n (define_attr \"avl_type\" \"\"\n-  (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov,vext,vimerge\")\n+  (cond [(eq_attr \"type\" \"vlde,vlde,vste,vimov,vimov,vimov,vfmov,vext,vimerge,\\\n+\t\t\t  vfsqrt,vfrecp,vfmerge,vfcvtitof,vfcvtftoi,vfwcvtitof,\\\n+\t\t\t  vfwcvtftoi,vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,vfclass\")\n \t   (symbol_ref \"INTVAL (operands[7])\")\n \t (eq_attr \"type\" \"vldm,vstm,vimov,vmalu,vmalu\")\n \t   (symbol_ref \"INTVAL (operands[5])\")\n@@ -299,12 +316,13 @@\n \n \t (eq_attr \"type\" \"vldux,vldox,vialu,vshift,viminmax,vimul,vidiv,vsalu,\\\n \t\t\t  viwalu,viwmul,vnshift,vimuladd,vaalu,vsmul,vsshift,\\\n-\t\t\t  vnclip,vicmp\")\n+\t\t\t  vnclip,vicmp,vfalu,vfmul,vfminmax,vfdiv,vfwalu,vfwmul,\\\n+\t\t\t  vfsgnj,vfcmp,vfmuladd\")\n \t   (symbol_ref \"INTVAL (operands[8])\")\n \t (eq_attr \"type\" \"vstux,vstox\")\n \t   (symbol_ref \"INTVAL (operands[5])\")\n \n-\t (eq_attr \"type\" \"vimuladd,viwmuladd\")\n+\t (eq_attr \"type\" \"vimuladd,viwmuladd,vfwmuladd\")\n \t   (symbol_ref \"INTVAL (operands[9])\")\n \n \t (eq_attr \"type\" \"vmsfs,vmidx\")\n@@ -974,32 +992,31 @@\n ;; To use LICM optimization, we postpone generation of vlse.v to split stage since\n ;; a memory access instruction can not be optimized by LICM (Loop invariant).\n (define_insn_and_split \"@pred_broadcast<mode>\"\n-  [(set (match_operand:V 0 \"register_operand\"                 \"=vr,  vr,  vr,  vr\")\n-\t(if_then_else:V\n+  [(set (match_operand:VI 0 \"register_operand\"                \"=vr,   vr,  vr\")\n+\t(if_then_else:VI\n \t  (unspec:<VM>\n-\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \" Wc1, Wc1, vm, Wc1\")\n-\t     (match_operand 4 \"vector_length_operand\"         \" rK,  rK,  rK,  rK\")\n-\t     (match_operand 5 \"const_int_operand\"             \"  i,   i,   i,   i\")\n-\t     (match_operand 6 \"const_int_operand\"             \"  i,   i,   i,   i\")\n-\t     (match_operand 7 \"const_int_operand\"             \"  i,   i,   i,   i\")\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \" Wc1,  vm, Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"         \" rK,   rK,  rK\")\n+\t     (match_operand 5 \"const_int_operand\"             \"  i,    i,   i\")\n+\t     (match_operand 6 \"const_int_operand\"             \"  i,    i,   i\")\n+\t     (match_operand 7 \"const_int_operand\"             \"  i,    i,   i\")\n \t     (reg:SI VL_REGNUM)\n \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n-\t  (vec_duplicate:V\n-\t    (match_operand:<VEL> 3 \"direct_broadcast_operand\" \"  r,   f, Wdm, Wdm\"))\n-\t  (match_operand:V 2 \"vector_merge_operand\"           \"0vu, 0vu, 0vu, 0vu\")))]\n+\t  (vec_duplicate:VI\n+\t    (match_operand:<VEL> 3 \"direct_broadcast_operand\"  \"  r, Wdm, Wdm\"))\n+\t  (match_operand:VI 2 \"vector_merge_operand\"           \"0vu, 0vu, 0vu\")))]\n   \"TARGET_VECTOR\"\n   \"@\n    vmv.v.x\\t%0,%3\n-   vfmv.v.f\\t%0,%3\n    vlse<sew>.v\\t%0,%3,zero,%1.t\n    vlse<sew>.v\\t%0,%3,zero\"\n-  \"!FLOAT_MODE_P (<MODE>mode) && register_operand (operands[3], <VEL>mode)\n+  \"register_operand (operands[3], <VEL>mode)\n   && GET_MODE_BITSIZE (<VEL>mode) > GET_MODE_BITSIZE (Pmode)\"\n   [(set (match_dup 0)\n-\t(if_then_else:V (unspec:<VM> [(match_dup 1) (match_dup 4)\n+\t(if_then_else:VI (unspec:<VM> [(match_dup 1) (match_dup 4)\n \t     (match_dup 5) (match_dup 6) (match_dup 7)\n \t     (reg:SI VL_REGNUM) (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n-\t  (vec_duplicate:V (match_dup 3))\n+\t  (vec_duplicate:VI (match_dup 3))\n \t  (match_dup 2)))]\n   {\n     gcc_assert (can_create_pseudo_p ());\n@@ -1010,7 +1027,29 @@\n     m = gen_rtx_MEM (<VEL>mode, force_reg (Pmode, XEXP (m, 0)));\n     operands[3] = m;\n   }\n-  [(set_attr \"type\" \"vimov,vfmov,vlds,vlds\")\n+  [(set_attr \"type\" \"vimov,vlds,vlds\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_broadcast<mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"                \"=vr,   vr,  vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \" Wc1,  vm, Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"         \" rK,   rK,  rK\")\n+\t     (match_operand 5 \"const_int_operand\"             \"  i,    i,   i\")\n+\t     (match_operand 6 \"const_int_operand\"             \"  i,    i,   i\")\n+\t     (match_operand 7 \"const_int_operand\"             \"  i,    i,   i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (vec_duplicate:VF\n+\t    (match_operand:<VEL> 3 \"direct_broadcast_operand\"  \"  f, Wdm, Wdm\"))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"           \"0vu, 0vu, 0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vfmv.v.f\\t%0,%3\n+   vlse<sew>.v\\t%0,%3,zero,%1.t\n+   vlse<sew>.v\\t%0,%3,zero\"\n+  [(set_attr \"type\" \"vfmov\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; -------------------------------------------------------------------------------\n@@ -3242,7 +3281,7 @@\n    (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n \n ;; -------------------------------------------------------------------------------\n-;; ---- Predicated comparison operations\n+;; ---- Predicated integer comparison operations\n ;; -------------------------------------------------------------------------------\n ;; Includes:\n ;; - 11.8 Vector Integer Comparision Instructions\n@@ -4352,7 +4391,7 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; -------------------------------------------------------------------------------\n-;; ---- Predicated integer ternary operations\n+;; ---- Predicated widen integer ternary operations\n ;; -------------------------------------------------------------------------------\n ;; Includes:\n ;; - 11.14 Vector Widening Integer Multiply-Add Instructions\n@@ -4667,3 +4706,1478 @@\n   \"vid.v\\t%0%p1\"\n   [(set_attr \"type\" \"vmidx\")\n    (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point binary operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.2 Vector Single-Width Floating-Point Add/Subtract Instructions\n+;; - 13.4 Vector Single-Width Floating-Point Multiply/Divide Instructions\n+;; - 13.11 Vector Floating-Point MIN/MAX Instructions\n+;; - 13.12 Vector Floating-Point Sign-Injection Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_<optab><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_float_binop:VF\n+\t    (match_operand:VF 3 \"register_operand\"       \" vr, vr\")\n+\t    (match_operand:VF 4 \"register_operand\"       \" vr, vr\"))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"     \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vf<insn>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"<float_insn_type>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_<optab><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (commutative_float_binop:VF\n+\t    (vec_duplicate:VF\n+\t      (match_operand:<VEL> 4 \"register_operand\"  \"  r,  r\"))\n+\t    (match_operand:VF 3 \"register_operand\"       \" vr, vr\"))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"     \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vf<insn>.vf\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"<float_insn_type>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_<optab><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (non_commutative_float_binop:VF\n+\t    (match_operand:VF 3 \"register_operand\"       \" vr, vr\")\n+\t    (vec_duplicate:VF\n+\t      (match_operand:<VEL> 4 \"register_operand\"  \"  r,  r\")))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"     \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vf<insn>.vf\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"<float_insn_type>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_<optab><mode>_reverse_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (non_commutative_float_binop:VF\n+\t    (vec_duplicate:VF\n+\t      (match_operand:<VEL> 4 \"register_operand\"  \"  r,  r\"))\n+\t    (match_operand:VF 3 \"register_operand\"       \" vr, vr\"))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"     \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfr<insn>.vf\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"<float_insn_type>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_<copysign><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VF\n+\t    [(match_operand:VF 3 \"register_operand\"       \" vr, vr\")\n+\t     (match_operand:VF 4 \"register_operand\"       \" vr, vr\")] VCOPYSIGNS)\n+\t  (match_operand:VF 2 \"vector_merge_operand\"     \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfsgnj<nx>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vfsgnj\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_<copysign><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VF\n+\t    [(match_operand:VF 3 \"register_operand\"      \" vr, vr\")\n+\t\t (vec_duplicate:VF\n+\t       (match_operand:<VEL> 4 \"register_operand\" \"  f,  f\"))] VCOPYSIGNS)\n+\t  (match_operand:VF 2 \"vector_merge_operand\"     \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfsgnj<nx>.vf\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vfsgnj\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point ternary operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.6 Vector Single-Width Floating-Point Fused Multiply-Add Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_expand \"@pred_mul_<optab><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (match_operand 9 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (match_operand:VF 2 \"register_operand\")\n+\t      (match_operand:VF 3 \"register_operand\"))\n+\t    (match_operand:VF 4 \"register_operand\"))\n+\t  (match_operand:VF 5 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{\n+  /* Swap the multiplication operands if the fallback value is the\n+     second of the two.  */\n+  if (rtx_equal_p (operands[3], operands[5]))\n+    std::swap (operands[2], operands[3]);\n+})\n+\n+(define_insn \"pred_mul_<optab><mode>_undef_merge\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr, vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1, vm,Wc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"    \" rK, rK, rK, rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (match_operand:VF 2 \"register_operand\"     \" %0,  0, vr, vr,   vr\")\n+\t      (match_operand:VF 3 \"register_operand\"     \" vr, vr, vr, vr,   vr\"))\n+\t    (match_operand:VF 4 \"register_operand\"       \" vr, vr,  0,  0,   vr\"))\n+\t  (match_operand:VF 5 \"vector_undef_operand\"     \" vu, vu, vu, vu,   vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<madd_nmsub>.vv\\t%0,%3,%4%p1\n+   vf<madd_nmsub>.vv\\t%0,%3,%4%p1\n+   vf<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   vf<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;vf<macc_nmsac>.vv\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_<madd_nmsub><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (match_operand:VF 2 \"register_operand\"     \"  0,  0,   vr\")\n+\t      (match_operand:VF 3 \"register_operand\"     \" vr, vr,   vr\"))\n+\t    (match_operand:VF 4 \"register_operand\"       \" vr, vr,   vr\"))\n+\t  (match_dup 2)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<madd_nmsub>.vv\\t%0,%3,%4%p1\n+   vf<madd_nmsub>.vv\\t%0,%3,%4%p1\n+   vmv.v.v\\t%0,%2\\;vf<madd_nmsub>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"4\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn \"*pred_<macc_nmsac><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (match_operand:VF 2 \"register_operand\"     \" vr, vr,   vr\")\n+\t      (match_operand:VF 3 \"register_operand\"     \" vr, vr,   vr\"))\n+\t    (match_operand:VF 4 \"register_operand\"       \"  0,  0,   vr\"))\n+\t  (match_dup 4)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   vf<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;vf<macc_nmsac>.vv\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"2\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn_and_rewrite \"*pred_mul_<optab><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"            \"=&vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"    \"   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"        \"    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"    i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"        \"    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (match_operand:VF 2 \"register_operand\"     \"   vr,   vr\")\n+\t      (match_operand:VF 3 \"register_operand\"     \"   vr,   vr\"))\n+\t    (match_operand:VF 4 \"vector_arith_operand\"   \"   vr,   vr\"))\n+\t  (match_operand:VF 5 \"register_operand\"         \"    0,   vr\")))]\n+  \"TARGET_VECTOR\n+   && !rtx_equal_p (operands[2], operands[5])\n+   && !rtx_equal_p (operands[3], operands[5])\n+   && !rtx_equal_p (operands[4], operands[5])\"\n+  \"@\n+   vmv.v.v\\t%0,%4\\;vf<macc_nmsac>.vv\\t%0,%2,%3%p1\n+   #\"\n+  \"&& reload_completed\n+   && !rtx_equal_p (operands[0], operands[5])\"\n+  {\n+    emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+\t\t\toperands[5], operands[4], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+    operands[5] = operands[4] = operands[0];\n+  }\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (match_operand 9 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (vec_duplicate:VF\n+\t        (match_operand:<VEL> 2 \"register_operand\"))\n+\t      (match_operand:VF 3 \"register_operand\"))\n+\t    (match_operand:VF 4 \"register_operand\"))\n+\t  (match_operand:VF 5 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{})\n+\n+(define_insn \"*pred_mul_<optab><mode>_undef_merge_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"             \"=vd, vr, vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"   \" vm,Wc1, vm,Wc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"      \" rK, rK, rK, rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (vec_duplicate:VF\n+\t        (match_operand:<VEL> 2 \"register_operand\" \"   f,  f,  f,  f,    f\"))\n+\t      (match_operand:VF 3 \"register_operand\"       \"  0,  0, vr, vr,   vr\"))\n+\t    (match_operand:VF 4 \"register_operand\"         \" vr, vr,  0,  0,   vr\"))\n+\t  (match_operand:VF 5 \"vector_undef_operand\"       \" vu, vu, vu, vu,   vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<madd_nmsub>.vf\\t%0,%2,%4%p1\n+   vf<madd_nmsub>.vf\\t%0,%2,%4%p1\n+   vf<macc_nmsac>.vf\\t%0,%2,%3%p1\n+   vf<macc_nmsac>.vf\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;vf<macc_nmsac>.vf\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_<madd_nmsub><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"            \"=vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (vec_duplicate:VF\n+\t        (match_operand:<VEL> 2 \"register_operand\" \"  f,  f,   vr\"))\n+\t      (match_operand:VF 3 \"register_operand\"      \"  0,  0,   vr\"))\n+\t    (match_operand:VF 4 \"register_operand\"        \" vr, vr,   vr\"))\n+\t  (match_dup 3)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<madd_nmsub>.vf\\t%0,%2,%4%p1\n+   vf<madd_nmsub>.vf\\t%0,%2,%4%p1\n+   vmv.v.v\\t%0,%2\\;vf<madd_nmsub>.vf\\t%0,%2,%4%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"4\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn \"*pred_<macc_nmsac><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"            \"=vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"  \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"     \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"         \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (vec_duplicate:VF\n+\t        (match_operand:<VEL> 2 \"register_operand\" \"  f,  f,   vr\"))\n+\t      (match_operand:VF 3 \"register_operand\"      \" vr, vr,   vr\"))\n+\t    (match_operand:VF 4 \"register_operand\"        \"  0,  0,   vr\"))\n+\t  (match_dup 4)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<macc_nmsac>.vf\\t%0,%2,%3%p1\n+   vf<macc_nmsac>.vf\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;vf<macc_nmsac>.vf\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"2\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn_and_rewrite \"*pred_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"            \"=&vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"    \"   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"        \"    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"    i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"        \"    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VF\n+\t    (mult:VF\n+\t      (vec_duplicate:VF\n+\t        (match_operand:<VEL> 2 \"register_operand\" \"    f,   f\"))\n+\t      (match_operand:VF 3 \"register_operand\"      \"   vr,  vr\"))\n+\t    (match_operand:VF 4 \"vector_arith_operand\"    \"   vr,  vr\"))\n+\t  (match_operand:VF 5 \"register_operand\"          \"    0,  vr\")))]\n+  \"TARGET_VECTOR\n+   && !rtx_equal_p (operands[3], operands[5])\n+   && !rtx_equal_p (operands[4], operands[5])\"\n+  \"@\n+   vmv.v.v\\t%0,%4\\;vf<macc_nmsac>.vf\\t%0,%2,%3%p1\n+   #\"\n+  \"&& reload_completed\n+   && !rtx_equal_p (operands[0], operands[5])\"\n+  {\n+    emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+\t\t\toperands[5], operands[4], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+    operands[5] = operands[4] = operands[0];\n+  }\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_neg_mul_<optab><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (match_operand 9 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"register_operand\")\n+\t      (mult:VF\n+\t        (match_operand:VF 2 \"register_operand\")\n+\t        (match_operand:VF 3 \"register_operand\"))))\n+\t  (match_operand:VF 5 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{\n+  /* Swap the multiplication operands if the fallback value is the\n+     second of the two.  */\n+  if (rtx_equal_p (operands[3], operands[5]))\n+    std::swap (operands[2], operands[3]);\n+})\n+\n+(define_insn \"pred_neg_mul_<optab><mode>_undef_merge\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr, vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1, vm,Wc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"    \" rK, rK, rK, rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"        \"  i,  i,  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"register_operand\"     \" vr, vr,  0,  0,   vr\")\n+\t      (mult:VF\n+\t        (match_operand:VF 2 \"register_operand\"   \" %0,  0, vr, vr,   vr\")\n+\t        (match_operand:VF 3 \"register_operand\"   \" vr, vr, vr, vr,   vr\"))))\n+\t  (match_operand:VF 5 \"vector_undef_operand\"     \" vu, vu, vu, vu,   vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<nmadd_msub>.vv\\t%0,%3,%4%p1\n+   vf<nmadd_msub>.vv\\t%0,%3,%4%p1\n+   vf<nmacc_msac>.vv\\t%0,%2,%3%p1\n+   vf<nmacc_msac>.vv\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;vf<nmacc_msac>.vv\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_<nmadd_msub><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"register_operand\"     \" vr, vr,   vr\")\n+\t      (mult:VF\n+\t        (match_operand:VF 2 \"register_operand\"   \"  0,  0,   vr\")\n+\t        (match_operand:VF 3 \"register_operand\"   \" vr, vr,   vr\"))))\n+\t  (match_dup 2)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<nmadd_msub>.vv\\t%0,%3,%4%p1\n+   vf<nmadd_msub>.vv\\t%0,%3,%4%p1\n+   vmv.v.v\\t%0,%2\\;vf<nmadd_msub>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"4\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn \"*pred_<nmacc_msac><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"    \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"register_operand\"     \"  0,  0,   vr\")\n+\t      (mult:VF\n+\t        (match_operand:VF 2 \"register_operand\"   \" vr, vr,   vr\")\n+\t        (match_operand:VF 3 \"register_operand\"   \" vr, vr,   vr\"))))\n+\t  (match_dup 4)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<nmacc_msac>.vv\\t%0,%2,%3%p1\n+   vf<nmacc_msac>.vv\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;vf<nmacc_msac>.vv\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"2\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn_and_rewrite \"*pred_neg_mul_<optab><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"            \"=&vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \"vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"    \"   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"        \"    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"        \"    i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"        \"    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"vector_arith_operand\" \"   vr,   vr\")\n+\t      (mult:VF\n+\t        (match_operand:VF 2 \"register_operand\"   \"   vr,   vr\")\n+\t        (match_operand:VF 3 \"register_operand\"   \"   vr,   vr\"))))\n+\t  (match_operand:VF 5 \"register_operand\"         \"    0,   vr\")))]\n+  \"TARGET_VECTOR\n+   && !rtx_equal_p (operands[2], operands[5])\n+   && !rtx_equal_p (operands[3], operands[5])\n+   && !rtx_equal_p (operands[4], operands[5])\"\n+  \"@\n+   vmv.v.v\\t%0,%4\\;vf<nmacc_msac>.vv\\t%0,%2,%3%p1\n+   #\"\n+  \"&& reload_completed\n+   && !rtx_equal_p (operands[0], operands[5])\"\n+  {\n+    emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+\t\t\toperands[5], operands[4], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+    operands[5] = operands[4] = operands[0];\n+  }\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_neg_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (match_operand 9 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"register_operand\")\n+\t      (mult:VF\n+\t        (vec_duplicate:VF\n+\t          (match_operand:<VEL> 2 \"register_operand\"))\n+\t        (match_operand:VF 3 \"register_operand\"))))\n+\t  (match_operand:VF 5 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+{})\n+\n+(define_insn \"*pred_neg_mul_<optab><mode>_undef_merge_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"             \"=vd, vr, vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"   \" vm,Wc1, vm,Wc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"      \" rK, rK, rK, rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"          \"  i,  i,  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"register_operand\"         \" vr, vr,  0,  0,   vr\")\n+\t      (mult:VF\n+\t        (vec_duplicate:VF\n+\t          (match_operand:<VEL> 2 \"register_operand\"  \"  f,  f,  f,  f,    f\"))\n+\t        (match_operand:VF 3 \"register_operand\"       \"  0,  0, vr, vr,   vr\"))))\n+\t  (match_operand:VF 5 \"vector_undef_operand\"       \" vu, vu, vu, vu,   vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<nmadd_msub>.vf\\t%0,%2,%4%p1\n+   vf<nmadd_msub>.vf\\t%0,%2,%4%p1\n+   vf<nmacc_msac>.vf\\t%0,%2,%3%p1\n+   vf<nmacc_msac>.vf\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;vf<nmacc_msac>.vf\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*pred_<nmadd_msub><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"              \"=vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"    \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"       \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"           \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"           \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"           \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"register_operand\"        \" vr, vr,   vr\")\n+\t      (mult:VF\n+\t        (vec_duplicate:VF\n+\t          (match_operand:<VEL> 2 \"register_operand\" \"  f,  f,   vr\"))\n+\t        (match_operand:VF 3 \"register_operand\"      \"  0,  0,   vr\"))))\n+\t  (match_dup 3)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<nmadd_msub>.vf\\t%0,%2,%4%p1\n+   vf<nmadd_msub>.vf\\t%0,%2,%4%p1\n+   vmv.v.v\\t%0,%2\\;vf<nmadd_msub>.vf\\t%0,%2,%4%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"4\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn \"*pred_<nmacc_msac><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"              \"=vd, vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"    \" vm,Wc1,vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"       \" rK, rK,   rK\")\n+\t     (match_operand 6 \"const_int_operand\"           \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"           \"  i,  i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"           \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"register_operand\"        \"  0,  0,   vr\")\n+\t      (mult:VF\n+\t        (vec_duplicate:VF\n+\t          (match_operand:<VEL> 2 \"register_operand\" \"  f,  f,   vr\"))\n+\t        (match_operand:VF 3 \"register_operand\"      \" vr, vr,   vr\"))))\n+\t  (match_dup 4)))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vf<nmacc_msac>.vf\\t%0,%2,%3%p1\n+   vf<nmacc_msac>.vf\\t%0,%2,%3%p1\n+   vmv.v.v\\t%0,%4\\;vf<nmacc_msac>.vf\\t%0,%2,%3%p1\"\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"merge_op_idx\" \"2\")\n+   (set_attr \"vl_op_idx\" \"5\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[6])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[7])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[8])\"))])\n+\n+(define_insn_and_rewrite \"*pred_neg_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"              \"=&vr, ?&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"   \"vmWc1,vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"      \"   rK,   rK\")\n+\t     (match_operand 7 \"const_int_operand\"          \"    i,    i\")\n+\t     (match_operand 8 \"const_int_operand\"          \"    i,    i\")\n+\t     (match_operand 9 \"const_int_operand\"          \"    i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VF\n+\t    (plus_minus:VF\n+\t      (match_operand:VF 4 \"vector_arith_operand\"    \"   vr,  vr\")\n+\t      (mult:VF\n+\t        (vec_duplicate:VF\n+\t          (match_operand:<VEL> 2 \"register_operand\" \"    f,   f\"))\n+\t        (match_operand:VF 3 \"register_operand\"      \"   vr,  vr\"))))\n+\t  (match_operand:VF 5 \"register_operand\"            \"    0,  vr\")))]\n+  \"TARGET_VECTOR\n+   && !rtx_equal_p (operands[3], operands[5])\n+   && !rtx_equal_p (operands[4], operands[5])\"\n+  \"@\n+   vmv.v.v\\t%0,%4\\;vf<nmacc_msac>.vf\\t%0,%2,%3%p1\n+   #\"\n+  \"&& reload_completed\n+   && !rtx_equal_p (operands[0], operands[5])\"\n+  {\n+    emit_insn (gen_pred_merge<mode> (operands[0], RVV_VUNDEF (<MODE>mode),\n+\t\t\toperands[5], operands[4], operands[1], operands[6],\n+\t\t\toperands[7], operands[9]));\n+    operands[5] = operands[4] = operands[0];\n+  }\n+  [(set_attr \"type\" \"vfmuladd\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point unary operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.8 Vector Floating-Point Square-Root Instruction\n+;; - 13.9 Vector Floating-Point Reciprocal Square-Root Estimate Instruction\n+;; - 13.10 Vector Floating-Point Reciprocal Estimate Instruction\n+;; - 13.12 Vector Floating-Point Sign-Injection Instructions (vfneg.v/vfabs.v)\n+;; - 13.14 Vector Floating-Point Classify Instruction\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_<optab><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \" rK, rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_float_unop:VF\n+\t    (match_operand:VF 3 \"register_operand\"       \" vr, vr\"))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"     \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vf<insn>.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"<float_insn_type>\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"vl_op_idx\" \"4\")\n+   (set (attr \"ta\") (symbol_ref \"riscv_vector::get_ta(operands[5])\"))\n+   (set (attr \"ma\") (symbol_ref \"riscv_vector::get_ma(operands[6])\"))\n+   (set (attr \"avl_type\") (symbol_ref \"INTVAL (operands[7])\"))])\n+\n+(define_insn \"@pred_<misc_op><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"           \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm,Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"    \" rK, rK\")\n+\t     (match_operand 5 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 6 \"const_int_operand\"        \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"        \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VF\n+\t    [(match_operand:VF 3 \"register_operand\"       \" vr, vr\")] VFMISC)\n+\t  (match_operand:VF 2 \"vector_merge_operand\"     \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vf<misc_op>.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"<float_insn_type>\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_class<mode>\"\n+  [(set (match_operand:<VCONVERT> 0 \"register_operand\"   \"=vd, vr\")\n+\t(if_then_else:<VCONVERT>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"     \" vm,Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"        \" rK, rK\")\n+\t     (match_operand 5 \"const_int_operand\"            \"  i,  i\")\n+\t     (match_operand 6 \"const_int_operand\"            \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"            \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:<VCONVERT>\n+\t    [(match_operand:VF 3 \"register_operand\"          \" vr, vr\")] UNSPEC_VFCLASS)\n+\t  (match_operand:<VCONVERT> 2 \"vector_merge_operand\" \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfclass.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfclass\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point widen binary operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.3 Vector Widening Floating-Point Add/Subtract Instructions\n+;; - 13.5 Vector Widening Floating-Point Multiply\n+;; -------------------------------------------------------------------------------\n+\n+;; Vector Widening Add/Subtract/Multiply.\n+(define_insn \"@pred_dual_widen_<optab><mode>\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                  \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"           \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"              \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                  \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_widen_binop:VWEXTF\n+\t    (float_extend:VWEXTF\n+\t      (match_operand:<V_DOUBLE_TRUNC> 3 \"register_operand\" \"   vr\"))\n+\t    (float_extend:VWEXTF\n+\t      (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))\n+\t  (match_operand:VWEXTF 2 \"vector_merge_operand\"           \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfw<insn>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vf<widen_binop_insn_type>\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_dual_widen_<optab><mode>_scalar\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                  \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"           \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"              \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                  \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_widen_binop:VWEXTF\n+\t    (float_extend:VWEXTF\n+\t      (match_operand:<V_DOUBLE_TRUNC> 3 \"register_operand\" \"   vr\"))\n+\t    (float_extend:VWEXTF\n+\t      (vec_duplicate:<V_DOUBLE_TRUNC>\n+\t\t(match_operand:<VSUBEL> 4 \"register_operand\"       \"    f\"))))\n+\t  (match_operand:VWEXTF 2 \"vector_merge_operand\"           \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfw<insn>.vf\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vf<widen_binop_insn_type>\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_single_widen_<plus_minus:optab><mode>\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                  \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"           \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"              \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                  \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VWEXTF\n+\t    (match_operand:VWEXTF 3 \"register_operand\"             \"   vr\")\n+\t    (float_extend:VWEXTF\n+\t      (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))\n+\t  (match_operand:VWEXTF 2 \"vector_merge_operand\"           \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfw<insn>.wv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vf<widen_binop_insn_type>\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_single_widen_<plus_minus:optab><mode>_scalar\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                  \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"           \"vmWc1\")\n+\t     (match_operand 5 \"vector_length_operand\"              \"   rK\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                  \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VWEXTF\n+\t    (match_operand:VWEXTF 3 \"register_operand\"             \"   vr\")\n+\t    (float_extend:VWEXTF\n+\t      (vec_duplicate:<V_DOUBLE_TRUNC>\n+\t\t(match_operand:<VSUBEL> 4 \"register_operand\"       \"    f\"))))\n+\t  (match_operand:VWEXTF 2 \"vector_merge_operand\"           \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfw<insn>.wf\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vf<widen_binop_insn_type>\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated widen floating-point ternary operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.7 Vector Widening Floating-Point Fused Multiply-Add Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_widen_mul_<optab><mode>\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                    \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"             \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                    \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VWEXTF\n+\t    (match_operand:VWEXTF 2 \"register_operand\"               \"    0\")\n+\t    (mult:VWEXTF\n+\t      (float_extend:VWEXTF\n+\t        (match_operand:<V_DOUBLE_TRUNC> 3 \"register_operand\" \"   vr\"))\n+\t      (float_extend:VWEXTF\n+\t        (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\"))))\n+\t  (match_operand:VWEXTF 5 \"vector_merge_operand\"             \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfw<macc_nmsac>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vfwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_widen_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                    \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"             \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                    \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                    \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (plus_minus:VWEXTF\n+\t    (match_operand:VWEXTF 2 \"register_operand\"               \"    0\")\n+\t    (mult:VWEXTF\n+\t      (float_extend:VWEXTF\n+\t        (vec_duplicate:<V_DOUBLE_TRUNC>\n+\t          (match_operand:<VSUBEL> 3 \"register_operand\"       \"    r\")))\n+\t      (float_extend:VWEXTF\n+\t        (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\"))))\n+\t  (match_operand:VWEXTF 5 \"vector_merge_operand\"             \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfw<macc_nmsac>.vf\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vfwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_widen_neg_mul_<optab><mode>\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                      \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"               \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                  \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                      \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                      \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                      \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VWEXTF\n+\t    (plus_minus:VWEXTF\n+\t      (match_operand:VWEXTF 2 \"register_operand\"               \"    0\")\n+\t      (mult:VWEXTF\n+\t        (float_extend:VWEXTF\n+\t          (match_operand:<V_DOUBLE_TRUNC> 3 \"register_operand\" \"   vr\"))\n+\t        (float_extend:VWEXTF\n+\t          (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))))\n+\t  (match_operand:VWEXTF 5 \"vector_merge_operand\"               \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfw<nmacc_msac>.vv\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vfwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_widen_neg_mul_<optab><mode>_scalar\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                      \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"               \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"                  \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"                      \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"                      \"    i\")\n+\t     (match_operand 9 \"const_int_operand\"                      \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (neg:VWEXTF\n+\t    (plus_minus:VWEXTF\n+\t      (match_operand:VWEXTF 2 \"register_operand\"               \"    0\")\n+\t      (mult:VWEXTF\n+\t        (float_extend:VWEXTF\n+\t          (vec_duplicate:<V_DOUBLE_TRUNC>\n+\t            (match_operand:<VSUBEL> 3 \"register_operand\"       \"    r\")))\n+\t        (float_extend:VWEXTF\n+\t          (match_operand:<V_DOUBLE_TRUNC> 4 \"register_operand\" \"   vr\")))))\n+\t  (match_operand:VWEXTF 5 \"vector_merge_operand\"               \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfw<nmacc_msac>.vf\\t%0,%3,%4%p1\"\n+  [(set_attr \"type\" \"vfwmuladd\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point comparison operations\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.13 Vector Floating-Point Compare Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_expand \"@pred_cmp<mode>\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"signed_order_operator\"\n+\t     [(match_operand:VF 4 \"register_operand\")\n+\t      (match_operand:VF 5 \"register_operand\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {})\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_cmp<mode>\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"signed_order_operator\"\n+\t     [(match_operand:VF 4 \"register_operand\"          \"   vr\")\n+\t      (match_operand:VF 5 \"register_operand\"          \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vmf%B3.vv\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vfcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_cmp<mode>_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"               \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"signed_order_operator\"\n+\t     [(match_operand:VF 4 \"register_operand\"          \"   vr\")\n+\t      (match_operand:VF 5 \"register_operand\"          \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vmf%B3.vv\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vfcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_cmp<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"signed_order_operator\"\n+\t     [(match_operand:VF 4 \"register_operand\")\n+\t      (vec_duplicate:VF\n+\t        (match_operand:<VEL> 5 \"register_operand\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {})\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_cmp<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"signed_order_operator\"\n+\t     [(match_operand:VF 4 \"register_operand\"          \"   vr\")\n+\t      (vec_duplicate:VF\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vmf%B3.vf\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vfcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_cmp<mode>_scalar_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"               \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"signed_order_operator\"\n+\t     [(match_operand:VF 4 \"register_operand\"          \"   vr\")\n+\t      (vec_duplicate:VF\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vmf%B3.vf\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vfcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"@pred_eqne<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+\t     (match_operand 6 \"vector_length_operand\")\n+\t     (match_operand 7 \"const_int_operand\")\n+\t     (match_operand 8 \"const_int_operand\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VF\n+\t        (match_operand:<VEL> 5 \"register_operand\"))\n+\t      (match_operand:VF 4 \"register_operand\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\")))]\n+  \"TARGET_VECTOR\"\n+  {})\n+\n+;; We don't use early-clobber for LMUL <= 1 to get better codegen.\n+(define_insn \"*pred_eqne<mode>_scalar\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"                \"=vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VF\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))\n+\t      (match_operand:VF 4 \"register_operand\"          \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_le (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vmf%B3.vf\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vfcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We use early-clobber for source LMUL > dest LMUL.\n+(define_insn \"*pred_eqne<mode>_scalar_narrow\"\n+  [(set (match_operand:<VM> 0 \"register_operand\"               \"=&vr\")\n+\t(if_then_else:<VM>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 6 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 8 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (match_operator:<VM> 3 \"equality_operator\"\n+\t     [(vec_duplicate:VF\n+\t        (match_operand:<VEL> 5 \"register_operand\"     \"    r\"))\n+\t      (match_operand:VF 4 \"register_operand\"          \"   vr\")])\n+\t  (match_operand:<VM> 2 \"vector_merge_operand\"        \"  0vu\")))]\n+  \"TARGET_VECTOR && known_gt (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR)\"\n+  \"vmf%B3.vf\\t%0,%4,%5%p1\"\n+  [(set_attr \"type\" \"vfcmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point merge\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.15 Vector Floating-Point Merge Instruction\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_merge<mode>_scalar\"\n+  [(set (match_operand:VF 0 \"register_operand\"      \"=vd\")\n+    (if_then_else:VF\n+      (match_operand:<VM> 4 \"register_operand\"      \" vm\")\n+      (if_then_else:VF\n+        (unspec:<VM>\n+          [(match_dup 4)\n+           (match_operand 5 \"vector_length_operand\" \" rK\")\n+           (match_operand 6 \"const_int_operand\"     \"  i\")\n+           (match_operand 7 \"const_int_operand\"     \"  i\")\n+           (reg:SI VL_REGNUM)\n+           (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+        (vec_duplicate:VF\n+          (match_operand:<VEL> 3 \"register_operand\" \"  f\"))\n+        (match_operand:VF 2 \"register_operand\"      \" vr\"))\n+      (match_operand:VF 1 \"vector_merge_operand\"    \"0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfmerge.vfm\\t%0,%2,%3,%4\"\n+  [(set_attr \"type\" \"vfmerge\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point conversions\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.17 Single-Width Floating-Point/Integer Type-Convert Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_fcvt_x<v_su>_f<mode>\"\n+  [(set (match_operand:<VCONVERT> 0 \"register_operand\"       \"=vd, vr\")\n+\t(if_then_else:<VCONVERT>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"     \" vm,Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"        \" rK, rK\")\n+\t     (match_operand 5 \"const_int_operand\"            \"  i,  i\")\n+\t     (match_operand 6 \"const_int_operand\"            \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"            \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:<VCONVERT>\n+\t     [(match_operand:VF 3 \"register_operand\"         \" vr, vr\")] VFCVTS)\n+\t  (match_operand:<VCONVERT> 2 \"vector_merge_operand\" \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfcvt.x<v_su>.f.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfcvtftoi\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_<fix_cvt><mode>\"\n+  [(set (match_operand:<VCONVERT> 0 \"register_operand\"       \"=vd, vr\")\n+\t(if_then_else:<VCONVERT>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"     \" vm,Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"        \" rK, rK\")\n+\t     (match_operand 5 \"const_int_operand\"            \"  i,  i\")\n+\t     (match_operand 6 \"const_int_operand\"            \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"            \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_fix:<VCONVERT>\n+\t     (match_operand:VF 3 \"register_operand\"          \" vr, vr\"))\n+\t  (match_operand:<VCONVERT> 2 \"vector_merge_operand\" \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfcvt.rtz.x<u>.f.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfcvtftoi\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"@pred_<float_cvt><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"              \"=vd, vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"    \" vm,Wc1\")\n+\t     (match_operand 4 \"vector_length_operand\"       \" rK, rK\")\n+\t     (match_operand 5 \"const_int_operand\"           \"  i,  i\")\n+\t     (match_operand 6 \"const_int_operand\"           \"  i,  i\")\n+\t     (match_operand 7 \"const_int_operand\"           \"  i,  i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_float:VF\n+\t     (match_operand:<VCONVERT> 3 \"register_operand\" \" vr, vr\"))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"        \"0vu,0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfcvt.f.x<u>.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfcvtitof\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point widen conversions\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.18 Widening Floating-Point/Integer Type-Convert Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_widen_fcvt_x<v_su>_f<mode>\"\n+  [(set (match_operand:VWCONVERTI 0 \"register_operand\"         \"=&vr\")\n+\t(if_then_else:VWCONVERTI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"         \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 6 \"const_int_operand\"             \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"             \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:VWCONVERTI\n+\t     [(match_operand:<VNCONVERT> 3 \"register_operand\" \"   vr\")] VFCVTS)\n+\t  (match_operand:VWCONVERTI 2 \"vector_merge_operand\"  \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfwcvt.x<v_su>.f.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfwcvtftoi\")\n+   (set_attr \"mode\" \"<VNCONVERT>\")])\n+\n+(define_insn \"@pred_widen_<fix_cvt><mode>\"\n+  [(set (match_operand:VWCONVERTI 0 \"register_operand\"        \"=&vr\")\n+\t(if_then_else:VWCONVERTI\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"     \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"        \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"            \"    i\")\n+\t     (match_operand 6 \"const_int_operand\"            \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"            \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_fix:VWCONVERTI\n+\t     (match_operand:<VNCONVERT> 3 \"register_operand\" \"   vr\"))\n+\t  (match_operand:VWCONVERTI 2 \"vector_merge_operand\" \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfwcvt.rtz.x<u>.f.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfwcvtftoi\")\n+   (set_attr \"mode\" \"<VNCONVERT>\")])\n+\n+(define_insn \"@pred_widen_<float_cvt><mode>\"\n+  [(set (match_operand:VF 0 \"register_operand\"                \"=&vr\")\n+\t(if_then_else:VF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"     \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"        \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"            \"    i\")\n+\t     (match_operand 6 \"const_int_operand\"            \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"            \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_float:VF\n+\t     (match_operand:<VNCONVERT> 3 \"register_operand\" \"   vr\"))\n+\t  (match_operand:VF 2 \"vector_merge_operand\"         \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfwcvt.f.x<u>.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfwcvtitof\")\n+   (set_attr \"mode\" \"<VNCONVERT>\")])\n+\n+(define_insn \"@pred_extend<mode>\"\n+  [(set (match_operand:VWEXTF 0 \"register_operand\"                 \"=&vr\")\n+\t(if_then_else:VWEXTF\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"          \"vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"             \"   rK\")\n+\t     (match_operand 5 \"const_int_operand\"                 \"    i\")\n+\t     (match_operand 6 \"const_int_operand\"                 \"    i\")\n+\t     (match_operand 7 \"const_int_operand\"                 \"    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (float_extend:VWEXTF\n+\t     (match_operand:<V_DOUBLE_TRUNC> 3 \"register_operand\" \"   vr\"))\n+\t  (match_operand:VWEXTF 2 \"vector_merge_operand\"          \"  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfwcvt.f.f.v\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfwcvtftof\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated floating-point narrow conversions\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 13.19 Narrowing Floating-Point/Integer Type-Convert Instructions\n+;; -------------------------------------------------------------------------------\n+\n+(define_insn \"@pred_narrow_fcvt_x<v_su>_f<mode>\"\n+  [(set (match_operand:<VNCONVERT> 0 \"register_operand\"        \"=vd, vr, ?&vr\")\n+\t(if_then_else:<VNCONVERT>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"       \" vm,Wc1,vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"          \" rK, rK,   rK\")\n+\t     (match_operand 5 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (match_operand 6 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"              \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:<VNCONVERT>\n+\t     [(match_operand:VF 3 \"register_operand\"           \"  0,  0,   vr\")] VFCVTS)\n+\t  (match_operand:<VNCONVERT> 2 \"vector_merge_operand\"  \"0vu,0vu,  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfncvt.x<v_su>.f.w\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfncvtftoi\")\n+   (set_attr \"mode\" \"<VNCONVERT>\")])\n+\n+(define_insn \"@pred_narrow_<fix_cvt><mode>\"\n+  [(set (match_operand:<VNCONVERT> 0 \"register_operand\"        \"=vd, vr, ?&vr\")\n+\t(if_then_else:<VNCONVERT>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \"  vm,Wc1,vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"         \"  rK, rK,   rK\")\n+\t     (match_operand 5 \"const_int_operand\"             \"   i,  i,    i\")\n+\t     (match_operand 6 \"const_int_operand\"             \"   i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"             \"   i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_fix:<VNCONVERT>\n+\t     (match_operand:VF 3 \"register_operand\"           \"   0,  0,   vr\"))\n+\t  (match_operand:<VNCONVERT> 2 \"vector_merge_operand\" \" 0vu,0vu,  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfncvt.rtz.x<u>.f.w\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfncvtftoi\")\n+   (set_attr \"mode\" \"<VNCONVERT>\")])\n+\n+(define_insn \"@pred_narrow_<float_cvt><mode>\"\n+  [(set (match_operand:<VNCONVERT> 0 \"register_operand\"       \"=vd, vr, ?&vr\")\n+\t(if_then_else:<VNCONVERT>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"      \" vm,Wc1,vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"         \" rK, rK,   rK\")\n+\t     (match_operand 5 \"const_int_operand\"             \"  i,  i,    i\")\n+\t     (match_operand 6 \"const_int_operand\"             \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"             \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (any_float:<VNCONVERT>\n+\t     (match_operand:VWCONVERTI 3 \"register_operand\"   \"  0,  0,   vr\"))\n+\t  (match_operand:<VNCONVERT> 2 \"vector_merge_operand\" \"0vu,0vu,  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfncvt.f.x<u>.w\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfncvtitof\")\n+   (set_attr \"mode\" \"<VNCONVERT>\")])\n+\n+(define_insn \"@pred_trunc<mode>\"\n+  [(set (match_operand:<V_DOUBLE_TRUNC> 0 \"register_operand\"       \"=vd, vr, ?&vr\")\n+\t(if_then_else:<V_DOUBLE_TRUNC>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"           \" vm,Wc1,vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"              \" rK, rK,   rK\")\n+\t     (match_operand 5 \"const_int_operand\"                  \"  i,  i,    i\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (float_truncate:<V_DOUBLE_TRUNC>\n+\t     (match_operand:VWEXTF 3 \"register_operand\"            \"  0,  0,   vr\"))\n+\t  (match_operand:<V_DOUBLE_TRUNC> 2 \"vector_merge_operand\" \"0vu,0vu,  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfncvt.f.f.w\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfncvtftof\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])\n+\n+(define_insn \"@pred_rod_trunc<mode>\"\n+  [(set (match_operand:<V_DOUBLE_TRUNC> 0 \"register_operand\"       \"=vd, vr, ?&vr\")\n+\t(if_then_else:<V_DOUBLE_TRUNC>\n+\t  (unspec:<VM>\n+\t    [(match_operand:<VM> 1 \"vector_mask_operand\"           \" vm,Wc1,vmWc1\")\n+\t     (match_operand 4 \"vector_length_operand\"              \" rK, rK,   rK\")\n+\t     (match_operand 5 \"const_int_operand\"                  \"  i,  i,    i\")\n+\t     (match_operand 6 \"const_int_operand\"                  \"  i,  i,    i\")\n+\t     (match_operand 7 \"const_int_operand\"                  \"  i,  i,    i\")\n+\t     (reg:SI VL_REGNUM)\n+\t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+\t  (unspec:<V_DOUBLE_TRUNC>\n+\t    [(float_truncate:<V_DOUBLE_TRUNC>\n+\t       (match_operand:VWEXTF 3 \"register_operand\"            \"  0,  0,   vr\"))] UNSPEC_ROD)\n+\t  (match_operand:<V_DOUBLE_TRUNC> 2 \"vector_merge_operand\" \"0vu,0vu,  0vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"vfncvt.rod.f.f.w\\t%0,%3%p1\"\n+  [(set_attr \"type\" \"vfncvtftof\")\n+   (set_attr \"mode\" \"<V_DOUBLE_TRUNC>\")])"}, {"sha": "5ff07da1146b7b9bf2e6c244cb0a2890a55372a1", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/ternop_vv_constraint-3.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-3.c?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+#include \"riscv_vector.h\"\n+\n+/*\n+** f1:\n+**\tvsetivli\\tzero,4,e32,m1,ta,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f1 (void * in, void * in2, void *out)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmacc_vv_f32m1 (v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmacc_vv_f32m1(v3, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1 (v4, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1 (v4, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1 (v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f2:\n+**\tvsetivli\\tzero,4,e32,m1,tu,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f2 (void * in, void * in2, void *out)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmacc_vv_f32m1_tu (v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmacc_vv_f32m1_tu(v3, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1_tu (v4, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1_tu (v4, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1_tu (v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f3:\n+**\tvsetivli\\tzero,4,e32,m1,ta,ma\n+**\tvlm\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f3 (void * in, void * in2, void * in3, void *out)\n+{\n+    vbool32_t m = __riscv_vlm_v_b32 (in3, 4);\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmacc_vv_f32m1_m (m, v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmacc_vv_f32m1_m(m, v3, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1_m (m, v4, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1_m (m, v4, v2, v2, 4);\n+    v4 = __riscv_vfmacc_vv_f32m1_m (m, v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/* { dg-final { scan-assembler-not {vmv} } } */"}, {"sha": "c280d97824ff22b2af1006e8c2175aa34d71c7f8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/ternop_vv_constraint-4.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-4.c?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+#include \"riscv_vector.h\"\n+\n+/*\n+** f1:\n+**\tvsetivli\\tzero,4,e32,m1,ta,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f1 (void * in, void * in2, void *out)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmadd_vv_f32m1 (v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmadd_vv_f32m1(v3, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1 (v4, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1 (v4, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1 (v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f2:\n+**\tvsetivli\\tzero,4,e32,m1,tu,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f2 (void * in, void * in2, void *out)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmadd_vv_f32m1_tu (v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmadd_vv_f32m1_tu(v3, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1_tu (v4, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1_tu (v4, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1_tu (v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f3:\n+**\tvsetivli\\tzero,4,e32,m1,ta,ma\n+**\tvlm\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f3 (void * in, void * in2, void * in3, void *out)\n+{\n+    vbool32_t m = __riscv_vlm_v_b32 (in3, 4);\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmadd_vv_f32m1_m (m, v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmadd_vv_f32m1_m(m, v3, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1_m (m, v4, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1_m (m, v4, v2, v2, 4);\n+    v4 = __riscv_vfmadd_vv_f32m1_m (m, v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/* { dg-final { scan-assembler-not {vmv} } } */"}, {"sha": "1f71aa867c209e5b9eac8e9ba4370b0d660accba", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/ternop_vv_constraint-5.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-5.c?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+#include \"riscv_vector.h\"\n+\n+/*\n+** f1:\n+**\tvsetivli\\tzero,4,e32,m1,ta,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f1 (void * in, void * in2, void *out)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmacc_vv_f32m1 (v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmacc_vv_f32m1(v3, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1 (v4, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1 (v4, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1 (v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f2:\n+**\tvsetivli\\tzero,4,e32,m1,tu,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f2 (void * in, void * in2, void *out)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmacc_vv_f32m1_tu (v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmacc_vv_f32m1_tu(v3, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1_tu (v4, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1_tu (v4, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1_tu (v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f3:\n+**\tvsetivli\\tzero,4,e32,m1,ta,ma\n+**\tvlm\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f3 (void * in, void * in2, void * in3, void *out)\n+{\n+    vbool32_t m = __riscv_vlm_v_b32 (in3, 4);\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmacc_vv_f32m1_m (m, v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmacc_vv_f32m1_m(m, v3, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1_m (m, v4, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1_m (m, v4, v2, v2, 4);\n+    v4 = __riscv_vfnmacc_vv_f32m1_m (m, v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/* { dg-final { scan-assembler-not {vmv} } } */"}, {"sha": "2d2ed66143439302b0c1c2a33aa231b798b9c9df", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/ternop_vv_constraint-6.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vv_constraint-6.c?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+#include \"riscv_vector.h\"\n+\n+/*\n+** f1:\n+**\tvsetivli\\tzero,4,e32,m1,ta,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f1 (void * in, void * in2, void *out)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmadd_vv_f32m1 (v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmadd_vv_f32m1(v3, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1 (v4, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1 (v4, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1 (v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f2:\n+**\tvsetivli\\tzero,4,e32,m1,tu,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f2 (void * in, void * in2, void *out)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmadd_vv_f32m1_tu (v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmadd_vv_f32m1_tu(v3, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1_tu (v4, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1_tu (v4, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1_tu (v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f3:\n+**\tvsetivli\\tzero,4,e32,m1,ta,ma\n+**\tvlm\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvfnma[c-d][c-d]\\.vv\\tv[0-9]+,\\s*v[0-9]+,\\s*v[0-9]+,v0.t\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f3 (void * in, void * in2, void * in3, void *out)\n+{\n+    vbool32_t m = __riscv_vlm_v_b32 (in3, 4);\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmadd_vv_f32m1_m (m, v, v2, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmadd_vv_f32m1_m(m, v3, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1_m (m, v4, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1_m (m, v4, v2, v2, 4);\n+    v4 = __riscv_vfnmadd_vv_f32m1_m (m, v4, v2, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/* { dg-final { scan-assembler-not {vmv} } } */"}, {"sha": "82e14734056d7bbe8a7ba7e17b2b33a6f2491aac", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/ternop_vx_constraint-8.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vx_constraint-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vx_constraint-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vx_constraint-8.c?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+#include \"riscv_vector.h\"\n+\n+/*\n+** f1:\n+**\tvsetivli\\tzero,4,e32,m1,tu,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f1 (void * in, void * in2, void *out, float x)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmacc_vf_f32m1 (v, x, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmacc_vf_f32m1_tu (v3, x, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f2:\n+**\tvsetvli\\t[a-x0-9]+,zero,e8,mf4,ta,ma\n+**\tvlm.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvsetivli\\tzero,4,e32,m1,tu,ma\n+**\tvle32.v\\tv[0-9]+,0\\([a-x0-9]+\\),v0.t\n+**\tvle32.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvse32.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f2 (void * in, void * in2, void *out, float x)\n+{\n+    vbool32_t mask = *(vbool32_t*)in;\n+    asm volatile (\"\":::\"memory\");\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1_m (mask, in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmacc_vf_f32m1 (v, x, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmacc_vf_f32m1_tu (v3, x, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f3:\n+**\tvsetvli\\t[a-x0-9]+,zero,e8,mf4,ta,ma\n+**\tvlm.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvsetivli\\tzero,4,e32,m1,tu,mu\n+**\tvle32.v\\tv[0-9]+,0\\([a-x0-9]+\\),v0.t\n+**\tvle32.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvfma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+,v0.t\n+**\tvse32.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f3 (void * in, void * in2, void *out, float x)\n+{\n+    vbool32_t mask = *(vbool32_t*)in;\n+    asm volatile (\"\":::\"memory\");\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1_m (mask, in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfmacc_vf_f32m1 (v, x, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfmacc_vf_f32m1_tumu (mask, v3, x, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/* { dg-final { scan-assembler-not {vmv} } } */"}, {"sha": "1beed49d9ac2019c64874b5b96e5d4b67d72e809", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/ternop_vx_constraint-9.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vx_constraint-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vx_constraint-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fternop_vx_constraint-9.c?ref=dc244cdc05a0cc4a7c40c5c5027c12cc1dc6e4d3", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+#include \"riscv_vector.h\"\n+\n+/*\n+** f1:\n+**\tvsetivli\\tzero,4,e32,m1,tu,ma\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvle32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvse32\\.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f1 (void * in, void * in2, void *out, float x)\n+{\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1 (in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmacc_vf_f32m1 (v, x, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmacc_vf_f32m1_tu (v3, x, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f2:\n+**\tvsetvli\\t[a-x0-9]+,zero,e8,mf4,ta,ma\n+**\tvlm.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvsetivli\\tzero,4,e32,m1,tu,ma\n+**\tvle32.v\\tv[0-9]+,0\\([a-x0-9]+\\),v0.t\n+**\tvle32.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvse32.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f2 (void * in, void * in2, void *out, float x)\n+{\n+    vbool32_t mask = *(vbool32_t*)in;\n+    asm volatile (\"\":::\"memory\");\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1_m (mask, in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmacc_vf_f32m1 (v, x, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmacc_vf_f32m1_tu (v3, x, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/*\n+** f3:\n+**\tvsetvli\\t[a-x0-9]+,zero,e8,mf4,ta,ma\n+**\tvlm.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvsetivli\\tzero,4,e32,m1,tu,mu\n+**\tvle32.v\\tv[0-9]+,0\\([a-x0-9]+\\),v0.t\n+**\tvle32.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tvfnma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+\n+**\tvfnma[c-d][c-d]\\.vf\\tv[0-9]+,\\s*[a-x0-9]+,\\s*v[0-9]+,v0.t\n+**\tvse32.v\\tv[0-9]+,0\\([a-x0-9]+\\)\n+**\tret\n+*/\n+void f3 (void * in, void * in2, void *out, float x)\n+{\n+    vbool32_t mask = *(vbool32_t*)in;\n+    asm volatile (\"\":::\"memory\");\n+    vfloat32m1_t v = __riscv_vle32_v_f32m1 (in, 4);\n+    vfloat32m1_t v2 = __riscv_vle32_v_f32m1_m (mask, in2, 4);\n+    vfloat32m1_t v3 = __riscv_vfnmacc_vf_f32m1 (v, x, v2, 4);\n+    vfloat32m1_t v4 = __riscv_vfnmacc_vf_f32m1_tumu (mask, v3, x, v2, 4);\n+    __riscv_vse32_v_f32m1 (out, v4, 4);\n+}\n+\n+/* { dg-final { scan-assembler-not {vmv} } } */"}]}