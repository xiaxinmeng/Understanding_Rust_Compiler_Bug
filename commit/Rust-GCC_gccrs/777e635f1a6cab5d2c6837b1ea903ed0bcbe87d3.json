{"sha": "777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3ZTYzNWYxYTZjYWI1ZDJjNjgzN2IxZWE5MDNlZDBiY2JlODdkMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-06-11T16:58:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-06-11T16:58:35Z"}, "message": "system.h (REG_CLASS_FROM_CONSTRAINT): Poison.\n\ngcc/\n\t* system.h (REG_CLASS_FROM_CONSTRAINT): Poison.\n\t(REG_CLASS_FOR_CONSTRAINT, EXTRA_CONSTRAINT_STR): Likewise.\n\t(EXTRA_MEMORY_CONSTRAINT, EXTRA_ADDRESS_CONSTRAINT): Likewise.\n\t* genpreds.c (print_type_tree): New function.\n\t(write_tm_preds_h): Remove REG_CLASS_FROM_CONSTRAINT,\n\tREG_CLASS_FOR_CONSTRAINT, EXTRA_MEMORY_CONSTRAINT,\n\tEXTRA_ADDRESS_CONSTRAINT and EXTRA_CONSTRAINT_STR.\n\tWrite out enum constraint_type and get_constraint_type.\n\t* lra-constraints.c (satisfies_memory_constraint_p): Take a\n\tconstraint_num rather than a constraint string.\n\t(satisfies_address_constraint_p): Likewise.\n\t(reg_class_from_constraints): Avoid old constraint macros.\n\t(process_alt_operands, process_address_1): Likewise.\n\t(curr_insn_transform): Likewise.\n\t* ira-costs.c (record_reg_classes): Likewise.\n\t(record_operand_costs): Likewise.\n\t* ira-lives.c (single_reg_class): Likewise.\n\t(ira_implicitly_set_insn_hard_regs): Likewise.\n\t* ira.c (ira_setup_alts, ira_get_dup_out_num): Likewise.\n\t* postreload.c (reload_cse_simplify_operands): Likewise.\n\t* recog.c (asm_operand_ok, preprocess_constraints): Likewise.\n\t(constrain_operands, peep2_find_free_register): Likewise.\n\t* reload.c (push_secondary_reload, scratch_reload_class): Likewise.\n\t(find_reloads, alternative_allows_const_pool_ref): Likewise.\n\t* reload1.c (maybe_fix_stack_asms): Likewise.\n\t* stmt.c (parse_output_constraint, parse_input_constraint): Likewise.\n\t* targhooks.c (default_secondary_reload): Likewise.\n\t* config/m32c/m32c.c (m32c_matches_constraint_p): Avoid reference\n\tto EXTRA_CONSTRAINT_STR.\n\t* config/sparc/constraints.md (U): Likewise REG_CLASS_FROM_CONSTRAINT.\n\nFrom-SVN: r211471", "tree": {"sha": "923092a0e7d4f3ea66962e54661707bc328d5327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/923092a0e7d4f3ea66962e54661707bc328d5327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e6b7874141cf74a8eb0786d7265296f671feac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e6b7874141cf74a8eb0786d7265296f671feac4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e6b7874141cf74a8eb0786d7265296f671feac4"}], "stats": {"total": 638, "additions": 350, "deletions": 288}, "files": [{"sha": "f79e6ab20cdf050f8655cffa55bd29176cf7401b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -1,3 +1,36 @@\n+2014-06-11  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* system.h (REG_CLASS_FROM_CONSTRAINT): Poison.\n+\t(REG_CLASS_FOR_CONSTRAINT, EXTRA_CONSTRAINT_STR): Likewise.\n+\t(EXTRA_MEMORY_CONSTRAINT, EXTRA_ADDRESS_CONSTRAINT): Likewise.\n+\t* genpreds.c (print_type_tree): New function.\n+\t(write_tm_preds_h): Remove REG_CLASS_FROM_CONSTRAINT,\n+\tREG_CLASS_FOR_CONSTRAINT, EXTRA_MEMORY_CONSTRAINT,\n+\tEXTRA_ADDRESS_CONSTRAINT and EXTRA_CONSTRAINT_STR.\n+\tWrite out enum constraint_type and get_constraint_type.\n+\t* lra-constraints.c (satisfies_memory_constraint_p): Take a\n+\tconstraint_num rather than a constraint string.\n+\t(satisfies_address_constraint_p): Likewise.\n+\t(reg_class_from_constraints): Avoid old constraint macros.\n+\t(process_alt_operands, process_address_1): Likewise.\n+\t(curr_insn_transform): Likewise.\n+\t* ira-costs.c (record_reg_classes): Likewise.\n+\t(record_operand_costs): Likewise.\n+\t* ira-lives.c (single_reg_class): Likewise.\n+\t(ira_implicitly_set_insn_hard_regs): Likewise.\n+\t* ira.c (ira_setup_alts, ira_get_dup_out_num): Likewise.\n+\t* postreload.c (reload_cse_simplify_operands): Likewise.\n+\t* recog.c (asm_operand_ok, preprocess_constraints): Likewise.\n+\t(constrain_operands, peep2_find_free_register): Likewise.\n+\t* reload.c (push_secondary_reload, scratch_reload_class): Likewise.\n+\t(find_reloads, alternative_allows_const_pool_ref): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms): Likewise.\n+\t* stmt.c (parse_output_constraint, parse_input_constraint): Likewise.\n+\t* targhooks.c (default_secondary_reload): Likewise.\n+\t* config/m32c/m32c.c (m32c_matches_constraint_p): Avoid reference\n+\tto EXTRA_CONSTRAINT_STR.\n+\t* config/sparc/constraints.md (U): Likewise REG_CLASS_FROM_CONSTRAINT.\n+\n 2014-06-11  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* genpreds.c (write_constraint_satisfied_p_1): Replace with..."}, {"sha": "69b9c55e534c4cfbcfc089a50b5a5cf690d78578", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -854,7 +854,7 @@ m32c_cannot_change_mode_class (enum machine_mode from,\n \n #define A0_OR_PSEUDO(x) (IS_REG(x, A0_REGNO) || REGNO (x) >= FIRST_PSEUDO_REGISTER)\n \n-/* Implements EXTRA_CONSTRAINT_STR (see next function too).  'S' is\n+/* Implements matching for constraints (see next function too).  'S' is\n    for memory constraints, plus \"Rpa\" for PARALLEL rtx's we use for\n    call return values.  */\n bool"}, {"sha": "587bf371b4f402f574e2617caf79c1cfbb88e262", "filename": "gcc/config/sparc/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fconstraints.md?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -171,7 +171,7 @@\n ;; define_register_constraint would.  This currently means that we cannot\n ;; use LRA on Sparc, since the constraint processing of LRA really depends\n ;; upon whether an extra constraint is for registers or not.  It uses\n-;; REG_CLASS_FROM_CONSTRAINT, and checks it against NO_REGS.\n+;; reg_class_for_constraint, and checks it against NO_REGS.\n (define_constraint \"U\"\n  \"Pseudo-register or hard even-numbered integer register\"\n  (and (match_test \"TARGET_ARCH32\")"}, {"sha": "1613d25f3aa968fe284c13e329f76a37cab1125c", "filename": "gcc/genpreds.c", "status": "modified", "additions": 50, "deletions": 23, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -1232,6 +1232,33 @@ write_range_function (const char *name, unsigned int start, unsigned int end)\n \t    \"}\\n\\n\", name);\n }\n \n+/* VEC is a list of key/value pairs, with the keys being lower bounds\n+   of a range.  Output a decision tree that handles the keys covered by\n+   [VEC[START], VEC[END]), returning FALLBACK for keys lower then VEC[START]'s.\n+   INDENT is the number of spaces to indent the code.  */\n+static void\n+print_type_tree (const vec <std::pair <unsigned int, const char *> > &vec,\n+\t\t unsigned int start, unsigned int end, const char *fallback,\n+\t\t unsigned int indent)\n+{\n+  while (start < end)\n+    {\n+      unsigned int mid = (start + end) / 2;\n+      printf (\"%*sif (c >= CONSTRAINT_%s)\\n\",\n+\t      indent, \"\", enum_order[vec[mid].first]->c_name);\n+      if (mid + 1 == end)\n+\tprint_type_tree (vec, mid + 1, end, vec[mid].second, indent + 2);\n+      else\n+\t{\n+\t  printf (\"%*s{\\n\", indent + 2, \"\");\n+\t  print_type_tree (vec, mid + 1, end, vec[mid].second, indent + 4);\n+\t  printf (\"%*s}\\n\", indent + 2, \"\");\n+\t}\n+      end = mid;\n+    }\n+  printf (\"%*sreturn %s;\\n\", indent, \"\", fallback);\n+}\n+\n /* Write tm-preds.h.  Unfortunately, it is impossible to forward-declare\n    an enumeration in portable C, so we have to condition all these\n    prototypes on HAVE_MACHINE_MODES.  */\n@@ -1321,21 +1348,13 @@ write_tm_preds_h (void)\n \t      \"  if (insn_extra_register_constraint (c))\\n\"\n \t      \"    return reg_class_for_constraint_1 (c);\\n\"\n \t      \"  return NO_REGS;\\n\"\n-\t      \"}\\n\"\n-\t      \"\\n\"\n-\t      \"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) \\\\\\n\"\n-\t      \"    reg_class_for_constraint (lookup_constraint (s_))\\n\"\n-\t      \"#define REG_CLASS_FOR_CONSTRAINT(x_) \\\\\\n\"\n-\t      \"    reg_class_for_constraint (x_)\\n\");\n+\t      \"}\\n\");\n       else\n \tputs (\"static inline enum reg_class\\n\"\n \t      \"reg_class_for_constraint (enum constraint_num)\\n\"\n \t      \"{\\n\"\n \t      \"  return NO_REGS;\\n\"\n-\t      \"}\\n\\n\"\n-\t      \"#define REG_CLASS_FROM_CONSTRAINT(c_,s_) NO_REGS\\n\"\n-\t      \"#define REG_CLASS_FOR_CONSTRAINT(x_) \\\\\\n\"\n-\t      \"    NO_REGS\\n\");\n+\t      \"}\\n\");\n       if (have_const_int_constraints)\n \tputs (\"extern bool insn_const_int_ok_for_constraint \"\n \t      \"(HOST_WIDE_INT, enum constraint_num);\\n\"\n@@ -1347,19 +1366,27 @@ write_tm_preds_h (void)\n \t      \"    constraint_satisfied_p (v_, lookup_constraint (s_))\\n\");\n       else\n \tputs (\"#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(v_,c_,s_) 0\\n\");\n-      if (have_extra_constraints)\n-\tputs (\"#define EXTRA_CONSTRAINT_STR(v_,c_,s_) \\\\\\n\"\n-\t      \"    constraint_satisfied_p (v_, lookup_constraint (s_))\\n\");\n-      if (have_memory_constraints)\n-\tputs (\"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) \"\n-\t      \"insn_extra_memory_constraint (lookup_constraint (s_))\\n\");\n-      else\n-\tputs (\"#define EXTRA_MEMORY_CONSTRAINT(c_,s_) false\\n\");\n-      if (have_address_constraints)\n-\tputs (\"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) \"\n-\t      \"insn_extra_address_constraint (lookup_constraint (s_))\\n\");\n-      else\n-\tputs (\"#define EXTRA_ADDRESS_CONSTRAINT(c_,s_) false\\n\");\n+\n+      puts (\"enum constraint_type\\n\"\n+\t    \"{\\n\"\n+\t    \"  CT_REGISTER,\\n\"\n+\t    \"  CT_MEMORY,\\n\"\n+\t    \"  CT_ADDRESS,\\n\"\n+\t    \"  CT_FIXED_FORM\\n\"\n+\t    \"};\\n\"\n+\t    \"\\n\"\n+\t    \"static inline enum constraint_type\\n\"\n+\t    \"get_constraint_type (enum constraint_num c)\\n\"\n+\t    \"{\");\n+      auto_vec <std::pair <unsigned int, const char *>, 3> values;\n+      if (memory_start != memory_end)\n+\tvalues.safe_push (std::make_pair (memory_start, \"CT_MEMORY\"));\n+      if (address_start != address_end)\n+\tvalues.safe_push (std::make_pair (address_start, \"CT_ADDRESS\"));\n+      if (address_end != num_constraints)\n+\tvalues.safe_push (std::make_pair (address_end, \"CT_FIXED_FORM\"));\n+      print_type_tree (values, 0, values.length (), \"CT_REGISTER\", 2);\n+      puts (\"}\");\n     }\n \n   puts (\"#endif /* tm-preds.h */\");"}, {"sha": "a93985b185593b44b3155c7c3378d3fb2fc91501", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -753,25 +753,28 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  break;\n \n \t\tdefault:\n-\t\t  if (REG_CLASS_FROM_CONSTRAINT (c, p) != NO_REGS)\n-\t\t    classes[i] = ira_reg_class_subunion[classes[i]]\n-\t\t                 [REG_CLASS_FROM_CONSTRAINT (c, p)];\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\t  else if (EXTRA_CONSTRAINT_STR (op, c, p))\n-\t\t    win = 1;\n-\n-\t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n+\t\t  enum constraint_num cn = lookup_constraint (p);\n+\t\t  enum reg_class cl;\n+\t\t  switch (get_constraint_type (cn))\n \t\t    {\n+\t\t    case CT_REGISTER:\n+\t\t      cl = reg_class_for_constraint (cn);\n+\t\t      if (cl != NO_REGS)\n+\t\t\tclasses[i] = ira_reg_class_subunion[classes[i]][cl];\n+\t\t      break;\n+\n+\t\t    case CT_MEMORY:\n \t\t      /* Every MEM can be reloaded to fit.  */\n \t\t      insn_allows_mem[i] = allows_mem[i] = 1;\n \t\t      if (MEM_P (op))\n \t\t\twin = 1;\n-\t\t    }\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t\t    {\n+\t\t      break;\n+\n+\t\t    case CT_ADDRESS:\n \t\t      /* Every address can be reloaded to fit.  */\n \t\t      allows_addr = 1;\n-\t\t      if (address_operand (op, GET_MODE (op)))\n+\t\t      if (address_operand (op, GET_MODE (op))\n+\t\t\t  || constraint_satisfied_p (op, cn))\n \t\t\twin = 1;\n \t\t      /* We know this operand is an address, so we\n \t\t\t want it to be allocated to a hard register\n@@ -781,8 +784,13 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\t= ira_reg_class_subunion[classes[i]]\n \t\t\t  [base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t\t\t   ADDRESS, SCRATCH)];\n+\t\t      break;\n+\n+\t\t    case CT_FIXED_FORM:\n+\t\t      if (constraint_satisfied_p (op, cn))\n+\t\t\twin = 1;\n+\t\t      break;\n \t\t    }\n-#endif\n \t\t  break;\n \t\t}\n \t      p += CONSTRAINT_LEN (c, p);\n@@ -1275,8 +1283,8 @@ record_operand_costs (rtx insn, enum reg_class *pref)\n \t\t\t     XEXP (recog_data.operand[i], 0),\n \t\t\t     0, MEM, SCRATCH, frequency * 2);\n       else if (constraints[i][0] == 'p'\n-\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0],\n-\t\t\t\t\t    constraints[i]))\n+\t       || (insn_extra_address_constraint\n+\t\t   (lookup_constraint (constraints[i]))))\n \trecord_address_regs (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t     recog_data.operand[i], 0, ADDRESS, SCRATCH,\n \t\t\t     frequency * 2);"}, {"sha": "e173ae36712215160aca353f68ae7ea45a218b55", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -759,6 +759,7 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n {\n   int c;\n   enum reg_class cl, next_cl;\n+  enum constraint_num cn;\n \n   cl = NO_REGS;\n   alternative_mask enabled = recog_data.enabled_alternatives;\n@@ -849,20 +850,19 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \tcase 'A': case 'B': case 'C': case 'D':\n \tcase 'Q': case 'R': case 'S': case 'T': case 'U':\n \tcase 'W': case 'Y': case 'Z':\n-#ifdef EXTRA_CONSTRAINT_STR\n \t  /* ??? Is this the best way to handle memory constraints?  */\n-\t  if (EXTRA_MEMORY_CONSTRAINT (c, constraints)\n-\t      || EXTRA_ADDRESS_CONSTRAINT (c, constraints))\n+\t  cn = lookup_constraint (constraints);\n+\t  if (insn_extra_memory_constraint (cn)\n+\t      || insn_extra_address_constraint (cn))\n \t    return NO_REGS;\n-\t  if (EXTRA_CONSTRAINT_STR (op, c, constraints)\n+\t  if (constraint_satisfied_p (op, cn)\n \t      || (equiv_const != NULL_RTX\n \t\t  && CONSTANT_P (equiv_const)\n-\t\t  && EXTRA_CONSTRAINT_STR (equiv_const, c, constraints)))\n+\t\t  && constraint_satisfied_p (equiv_const, cn)))\n \t    return NO_REGS;\n-#endif\n \t  next_cl = (c == 'r'\n \t\t     ? GENERAL_REGS\n-\t\t     : REG_CLASS_FROM_CONSTRAINT (c, constraints));\n+\t\t     : reg_class_for_constraint (cn));\n \t  if (next_cl == NO_REGS)\n \t    break;\n \t  if (cl == NO_REGS\n@@ -950,7 +950,7 @@ ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n \t\tcase 'W': case 'Y': case 'Z':\n \t\t  cl = (c == 'r'\n \t\t\t? GENERAL_REGS\n-\t\t\t: REG_CLASS_FROM_CONSTRAINT (c, p));\n+\t\t\t: reg_class_for_constraint (lookup_constraint (p)));\n \t\t  if (cl != NO_REGS)\n \t\t    {\n \t\t      /* There is no register pressure problem if all of the"}, {"sha": "2b63a999d217fe21496dbc631368d59818c85ae3", "filename": "gcc/ira.c", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -1922,24 +1922,29 @@ ira_setup_alts (rtx insn, HARD_REG_SET &alts)\n \t\t    break;\n \t\t    \n \t\t  case 'o':\n+\t\t  case 'r':\n \t\t    goto op_success;\n \t\t    break;\n \t\t    \n \t\t  default:\n \t\t    {\n-\t\t      enum reg_class cl;\n-\t\t      \n-\t\t      cl = (c == 'r' ? GENERAL_REGS : REG_CLASS_FROM_CONSTRAINT (c, p));\n-\t\t      if (cl != NO_REGS)\n-\t\t\tgoto op_success;\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\t      else if (EXTRA_CONSTRAINT_STR (op, c, p))\n-\t\t\tgoto op_success;\n-\t\t      else if (EXTRA_MEMORY_CONSTRAINT (c, p))\n-\t\t\tgoto op_success;\n-\t\t      else if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t\t\tgoto op_success;\n-#endif\n+\t\t      enum constraint_num cn = lookup_constraint (p);\n+\t\t      switch (get_constraint_type (cn))\n+\t\t\t{\n+\t\t\tcase CT_REGISTER:\n+\t\t\t  if (reg_class_for_constraint (cn) != NO_REGS)\n+\t\t\t    goto op_success;\n+\t\t\t  break;\n+\n+\t\t\tcase CT_ADDRESS:\n+\t\t\tcase CT_MEMORY:\n+\t\t\t  goto op_success;\n+\n+\t\t\tcase CT_FIXED_FORM:\n+\t\t\t  if (constraint_satisfied_p (op, cn))\n+\t\t\t    goto op_success;\n+\t\t\t  break;\n+\t\t\t}\n \t\t      break;\n \t\t    }\n \t\t  }\n@@ -1972,9 +1977,6 @@ ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n   int curr_alt, c, original, dup;\n   bool ignore_p, use_commut_op_p;\n   const char *str;\n-#ifdef EXTRA_CONSTRAINT_STR\n-  rtx op;\n-#endif\n \n   if (op_num < 0 || recog_data.n_alternatives == 0)\n     return -1;\n@@ -1985,9 +1987,7 @@ ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n   use_commut_op_p = false;\n   for (;;)\n     {\n-#ifdef EXTRA_CONSTRAINT_STR\n-      op = recog_data.operand[op_num];\n-#endif\n+      rtx op = recog_data.operand[op_num];\n       \n       for (curr_alt = 0, ignore_p = !TEST_HARD_REG_BIT (alts, curr_alt),\n \t   original = -1;;)\n@@ -2010,6 +2010,9 @@ ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n \t      case 'g':\n \t\tgoto fail;\n \t      case 'r':\n+\t\tif (!targetm.class_likely_spilled_p (GENERAL_REGS))\n+\t\t  goto fail;\n+\t\tbreak;\n \t      case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n \t      case 'h': case 'j': case 'k': case 'l':\n \t      case 'q': case 't': case 'u':\n@@ -2018,19 +2021,13 @@ ira_get_dup_out_num (int op_num, HARD_REG_SET &alts)\n \t      case 'Q': case 'R': case 'S': case 'T': case 'U':\n \t      case 'W': case 'Y': case 'Z':\n \t\t{\n-\t\t  enum reg_class cl;\n-\t\t  \n-\t\t  cl = (c == 'r'\n-\t\t\t? GENERAL_REGS : REG_CLASS_FROM_CONSTRAINT (c, str));\n-\t\t  if (cl != NO_REGS)\n-\t\t    {\n-\t\t      if (! targetm.class_likely_spilled_p (cl))\n-\t\t\tgoto fail;\n-\t\t    }\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\t  else if (EXTRA_CONSTRAINT_STR (op, c, str))\n+\t\t  enum constraint_num cn = lookup_constraint (str);\n+\t\t  enum reg_class cl = reg_class_for_constraint (cn);\n+\t\t  if (cl != NO_REGS\n+\t\t      && !targetm.class_likely_spilled_p (cl))\n+\t\t    goto fail;\n+\t\t  if (constraint_satisfied_p (op, cn))\n \t\t    goto fail;\n-#endif\n \t\t  break;\n \t\t}\n \t\t"}, {"sha": "8342a0a3e3c304348a8040d1197c31516bcd0996", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 61, "deletions": 87, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -394,40 +394,38 @@ valid_address_p (struct address_info *ad)\n   return valid_address_p (ad->mode, *ad->outer, ad->as);\n }\n \n-#ifdef EXTRA_CONSTRAINT_STR\n /* Return true if the eliminated form of memory reference OP satisfies\n    extra memory constraint CONSTRAINT.  */\n static bool\n-satisfies_memory_constraint_p (rtx op, const char *constraint)\n+satisfies_memory_constraint_p (rtx op, enum constraint_num constraint)\n {\n   struct address_info ad;\n \n   decompose_mem_address (&ad, op);\n   address_eliminator eliminator (&ad);\n-  return EXTRA_CONSTRAINT_STR (op, *constraint, constraint);\n+  return constraint_satisfied_p (op, constraint);\n }\n \n /* Return true if the eliminated form of address AD satisfies extra\n    address constraint CONSTRAINT.  */\n static bool\n satisfies_address_constraint_p (struct address_info *ad,\n-\t\t\t\tconst char *constraint)\n+\t\t\t\tenum constraint_num constraint)\n {\n   address_eliminator eliminator (ad);\n-  return EXTRA_CONSTRAINT_STR (*ad->outer, *constraint, constraint);\n+  return constraint_satisfied_p (*ad->outer, constraint);\n }\n \n /* Return true if the eliminated form of address OP satisfies extra\n    address constraint CONSTRAINT.  */\n static bool\n-satisfies_address_constraint_p (rtx op, const char *constraint)\n+satisfies_address_constraint_p (rtx op, enum constraint_num constraint)\n {\n   struct address_info ad;\n \n   decompose_lea_address (&ad, &op);\n   return satisfies_address_constraint_p (&ad, constraint);\n }\n-#endif\n \n /* Initiate equivalences for LRA.  As we keep original equivalences\n    before any elimination, we need to make copies otherwise any change\n@@ -982,21 +980,20 @@ reg_class_from_constraints (const char *p)\n \tbreak;\n \n       default:\n-\tif (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS)\n+\tenum constraint_num cn = lookup_constraint (p);\n+\tenum reg_class cl = reg_class_for_constraint (cn);\n+\tif (cl == NO_REGS)\n \t  {\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t    if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n+\t    if (insn_extra_address_constraint (cn))\n \t      op_class\n \t\t= (reg_class_subunion\n \t\t   [op_class][base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t\t\t      ADDRESS, SCRATCH)]);\n-#endif\n \t    break;\n \t  }\n \n-\top_class\n-\t  = reg_class_subunion[op_class][REG_CLASS_FROM_CONSTRAINT (c, p)];\n-\tbreak;\n+\top_class = reg_class_subunion[op_class][cl];\n+ \tbreak;\n       }\n   while ((p += len), c);\n   return op_class;\n@@ -1712,6 +1709,7 @@ process_alt_operands (int only_alternative)\n \t  bool this_alternative_offmemok;\n \t  bool scratch_p;\n \t  enum machine_mode mode;\n+\t  enum constraint_num cn;\n \n \t  opalt_num = nalt * n_operands + nop;\n \t  if (curr_static_id->operand_alternative[opalt_num].anything_ok)\n@@ -2030,76 +2028,55 @@ process_alt_operands (int only_alternative)\n \t\t  /* Drop through into 'r' case.  */\n \n \t\tcase 'r':\n-\t\t  this_alternative\n-\t\t    = reg_class_subunion[this_alternative][GENERAL_REGS];\n-\t\t  IOR_HARD_REG_SET (this_alternative_set,\n-\t\t\t\t    reg_class_contents[GENERAL_REGS]);\n-\t\t  if (costly_p)\n-\t\t    {\n-\t\t      this_costly_alternative\n-\t\t\t= (reg_class_subunion\n-\t\t\t   [this_costly_alternative][GENERAL_REGS]);\n-\t\t      IOR_HARD_REG_SET (this_costly_alternative_set,\n-\t\t\t\t\treg_class_contents[GENERAL_REGS]);\n-\t\t    }\n+\t\t  cl = GENERAL_REGS;\n \t\t  goto reg;\n \n \t\tdefault:\n-\t\t  if (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS)\n+\t\t  cn = lookup_constraint (p);\n+\t\t  switch (get_constraint_type (cn))\n \t\t    {\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\t      if (EXTRA_MEMORY_CONSTRAINT (c, p))\n-\t\t\t{\n-\t\t\t  if (MEM_P (op)\n-\t\t\t      && satisfies_memory_constraint_p (op, p))\n-\t\t\t    win = true;\n-\t\t\t  else if (spilled_pseudo_p (op))\n-\t\t\t    win = true;\n-\n-\t\t\t  /* If we didn't already win, we can reload\n-\t\t\t     constants via force_const_mem or put the\n-\t\t\t     pseudo value into memory, or make other\n-\t\t\t     memory by reloading the address like for\n-\t\t\t     'o'.  */\n-\t\t\t  if (CONST_POOL_OK_P (mode, op)\n-\t\t\t      || MEM_P (op) || REG_P (op))\n-\t\t\t    badop = false;\n-\t\t\t  constmemok = true;\n-\t\t\t  offmemok = true;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t\t\t{\n-\t\t\t  if (satisfies_address_constraint_p (op, p))\n-\t\t\t    win = true;\n-\n-\t\t\t  /* If we didn't already win, we can reload\n-\t\t\t     the address into a base register.\t*/\n-\t\t\t  cl = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t\t       ADDRESS, SCRATCH);\n-\t\t\t  this_alternative\n-\t\t\t    = reg_class_subunion[this_alternative][cl];\n-\t\t\t  IOR_HARD_REG_SET (this_alternative_set,\n-\t\t\t\t\t    reg_class_contents[cl]);\n-\t\t\t  if (costly_p)\n-\t\t\t    {\n-\t\t\t      this_costly_alternative\n-\t\t\t\t= (reg_class_subunion\n-\t\t\t\t   [this_costly_alternative][cl]);\n-\t\t\t      IOR_HARD_REG_SET (this_costly_alternative_set,\n-\t\t\t\t\t\treg_class_contents[cl]);\n-\t\t\t    }\n-\t\t\t  badop = false;\n-\t\t\t  break;\n-\t\t\t}\n+\t\t    case CT_REGISTER:\n+\t\t      cl = reg_class_for_constraint (cn);\n+\t\t      if (cl != NO_REGS)\n+\t\t\tgoto reg;\n+\t\t      break;\n \n-\t\t      if (EXTRA_CONSTRAINT_STR (op, c, p))\n+\t\t    case CT_MEMORY:\n+\t\t      if (MEM_P (op)\n+\t\t\t  && satisfies_memory_constraint_p (op, cn))\n+\t\t\twin = true;\n+\t\t      else if (spilled_pseudo_p (op))\n+\t\t\twin = true;\n+\n+\t\t      /* If we didn't already win, we can reload constants\n+\t\t\t via force_const_mem or put the pseudo value into\n+\t\t\t memory, or make other memory by reloading the\n+\t\t\t address like for 'o'.  */\n+\t\t      if (CONST_POOL_OK_P (mode, op)\n+\t\t\t  || MEM_P (op) || REG_P (op))\n+\t\t\tbadop = false;\n+\t\t      constmemok = true;\n+\t\t      offmemok = true;\n+\t\t      break;\n+\n+\t\t    case CT_ADDRESS:\n+\t\t      /* If we didn't already win, we can reload the address\n+\t\t\t into a base register.  */\n+\t\t      if (satisfies_address_constraint_p (op, cn))\n+\t\t\twin = true;\n+\t\t      cl = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t   ADDRESS, SCRATCH);\n+\t\t      badop = false;\n+\t\t      goto reg;\n+\n+\t\t    case CT_FIXED_FORM:\n+\t\t      if (constraint_satisfied_p (op, cn))\n \t\t\twin = true;\n-#endif\n \t\t      break;\n \t\t    }\n+\t\t  break;\n \n-\t\t  cl = REG_CLASS_FROM_CONSTRAINT (c, p);\n+\t\treg:\n \t\t  this_alternative = reg_class_subunion[this_alternative][cl];\n \t\t  IOR_HARD_REG_SET (this_alternative_set,\n \t\t\t\t    reg_class_contents[cl]);\n@@ -2110,7 +2087,6 @@ process_alt_operands (int only_alternative)\n \t\t      IOR_HARD_REG_SET (this_costly_alternative_set,\n \t\t\t\t\treg_class_contents[cl]);\n \t\t    }\n-\t\treg:\n \t\t  if (mode == BLKmode)\n \t\t    break;\n \t\t  winreg = true;\n@@ -2856,10 +2832,11 @@ process_address_1 (int nop, rtx *before, rtx *after)\n   rtx new_reg;\n   rtx op = *curr_id->operand_loc[nop];\n   const char *constraint = curr_static_id->operand[nop].constraint;\n+  enum constraint_num cn = lookup_constraint (constraint);\n   bool change_p;\n \n   if (constraint[0] == 'p'\n-      || EXTRA_ADDRESS_CONSTRAINT (constraint[0], constraint))\n+      || insn_extra_address_constraint (cn))\n     decompose_lea_address (&ad, curr_id->operand_loc[nop]);\n   else if (MEM_P (op))\n     decompose_mem_address (&ad, op);\n@@ -2888,14 +2865,12 @@ process_address_1 (int nop, rtx *before, rtx *after)\n       && process_addr_reg (ad.index_term, before, NULL, INDEX_REG_CLASS))\n     change_p = true;\n \n-#ifdef EXTRA_CONSTRAINT_STR\n-  /* Target hooks sometimes reject extra constraint addresses -- use\n-     EXTRA_CONSTRAINT_STR for the validation.  */\n+  /* Target hooks sometimes don't treat extra-constraint addresses as\n+     legitimate address_operands, so handle them specially.  */\n   if (constraint[0] != 'p'\n-      && EXTRA_ADDRESS_CONSTRAINT (constraint[0], constraint)\n-      && satisfies_address_constraint_p (&ad, constraint))\n+      && insn_extra_address_constraint (cn)\n+      && satisfies_address_constraint_p (&ad, cn))\n     return change_p;\n-#endif\n \n   /* There are three cases where the shape of *AD.INNER may now be invalid:\n \n@@ -3617,11 +3592,10 @@ curr_insn_transform (void)\n \t      {\n \t\tif (c == TARGET_MEM_CONSTRAINT || c == 'o')\n \t\t  break;\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\tif (EXTRA_MEMORY_CONSTRAINT (c, constraint)\n-\t\t    && satisfies_memory_constraint_p (tem, constraint))\n+\t\tenum constraint_num cn = lookup_constraint (constraint);\n+\t\tif (insn_extra_memory_constraint (cn)\n+\t\t    && satisfies_memory_constraint_p (tem, cn))\n \t\t  break;\n-#endif\n \t      }\n \t    if (c == '\\0' || c == ',' || c == '#')\n \t      continue;"}, {"sha": "5b18fc74792008ff648a20866fe1cfb8baf8b35c", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -574,8 +574,8 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\tdefault:\n \t\t  rclass\n \t\t    = (reg_class_subunion\n-\t\t       [(int) rclass]\n-\t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n+\t\t       [rclass]\n+\t\t       [reg_class_for_constraint (lookup_constraint (p))]);\n \t\t  break;\n \n \t\tcase ',': case '\\0':"}, {"sha": "94cdeec1fa462453f3fa9fae4e5482cd3754d7d6", "filename": "gcc/recog.c", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -1729,6 +1729,7 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \n   while (*constraint)\n     {\n+      enum constraint_num cn;\n       char c = *constraint;\n       int len;\n       switch (c)\n@@ -1902,27 +1903,37 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \t    result = 1;\n \t  break;\n \n+\tcase 'r':\n+\treg:\n+\t  if (!result\n+\t      && GET_MODE (op) != BLKmode\n+\t      && register_operand (op, VOIDmode))\n+\t    result = 1;\n+\t  break;\n+\n \tdefault:\n-\t  /* For all other letters, we first check for a register class,\n-\t     otherwise it is an EXTRA_CONSTRAINT.  */\n-\t  if (REG_CLASS_FROM_CONSTRAINT (c, constraint) != NO_REGS)\n+\t  cn = lookup_constraint (constraint);\n+\t  switch (get_constraint_type (cn))\n \t    {\n-\t    case 'r':\n-\t      if (GET_MODE (op) == BLKmode)\n-\t\tbreak;\n-\t      if (register_operand (op, VOIDmode))\n-\t\tresult = 1;\n+\t    case CT_REGISTER:\n+\t      if (reg_class_for_constraint (cn) != NO_REGS)\n+\t\tgoto reg;\n+\t      break;\n+\n+\t    case CT_MEMORY:\n+\t      /* Every memory operand can be reloaded to fit.  */\n+\t      result = result || memory_operand (op, VOIDmode);\n+\t      break;\n+\n+\t    case CT_ADDRESS:\n+\t      /* Every address operand can be reloaded to fit.  */\n+\t      result = result || address_operand (op, VOIDmode);\n+\t      break;\n+\n+\t    case CT_FIXED_FORM:\n+\t      result = result || constraint_satisfied_p (op, cn);\n+\t      break;\n \t    }\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t  else if (EXTRA_MEMORY_CONSTRAINT (c, constraint))\n-\t    /* Every memory operand can be reloaded to fit.  */\n-\t    result = result || memory_operand (op, VOIDmode);\n-\t  else if (EXTRA_ADDRESS_CONSTRAINT (c, constraint))\n-\t    /* Every address operand can be reloaded to fit.  */\n-\t    result = result || address_operand (op, VOIDmode);\n-\t  else if (EXTRA_CONSTRAINT_STR (op, c, constraint))\n-\t    result = 1;\n-#endif\n \t  break;\n \t}\n       len = CONSTRAINT_LEN (c, constraint);\n@@ -2434,26 +2445,32 @@ preprocess_constraints (int n_operands, int n_alternatives,\n \t\t  break;\n \n \t\tdefault:\n-\t\t  if (EXTRA_MEMORY_CONSTRAINT (c, p))\n+\t\t  enum constraint_num cn = lookup_constraint (p);\n+\t\t  enum reg_class cl;\n+\t\t  switch (get_constraint_type (cn))\n \t\t    {\n+\t\t    case CT_REGISTER:\n+\t\t      cl = reg_class_for_constraint (cn);\n+\t\t      if (cl != NO_REGS)\n+\t\t\top_alt[i].cl = reg_class_subunion[op_alt[i].cl][cl];\n+\t\t      break;\n+\n+\t\t    case CT_MEMORY:\n \t\t      op_alt[i].memory_ok = 1;\n \t\t      break;\n-\t\t    }\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t\t    {\n+\n+\t\t    case CT_ADDRESS:\n \t\t      op_alt[i].is_address = 1;\n \t\t      op_alt[i].cl\n \t\t\t= (reg_class_subunion\n \t\t\t   [(int) op_alt[i].cl]\n \t\t\t   [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t\t\t\t  ADDRESS, SCRATCH)]);\n \t\t      break;\n-\t\t    }\n \n-\t\t  op_alt[i].cl\n-\t\t    = (reg_class_subunion\n-\t\t       [(int) op_alt[i].cl]\n-\t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n+\t\t    case CT_FIXED_FORM:\n+\t\t      break;\n+\t\t    }\n \t\t  break;\n \t\t}\n \t      p += CONSTRAINT_LEN (c, p);\n@@ -2846,9 +2863,12 @@ constrain_operands (int strict)\n \t      default:\n \t\t{\n \t\t  enum reg_class cl;\n+\t\t  enum constraint_num cn = (c == 'r'\n+\t\t\t\t\t    ? CONSTRAINT__UNKNOWN\n+\t\t\t\t\t    : lookup_constraint (p));\n \n \t\t  cl = (c == 'r'\n-\t\t\t   ? GENERAL_REGS : REG_CLASS_FROM_CONSTRAINT (c, p));\n+\t\t\t? GENERAL_REGS : reg_class_for_constraint (cn));\n \t\t  if (cl != NO_REGS)\n \t\t    {\n \t\t      if (strict < 0\n@@ -2860,11 +2880,11 @@ constrain_operands (int strict)\n \t\t\t      && reg_fits_class_p (op, cl, offset, mode)))\n \t\t        win = 1;\n \t\t    }\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\t  else if (EXTRA_CONSTRAINT_STR (op, c, p))\n+\n+\t\t  else if (constraint_satisfied_p (op, cn))\n \t\t    win = 1;\n \n-\t\t  else if (EXTRA_MEMORY_CONSTRAINT (c, p)\n+\t\t  else if (insn_extra_memory_constraint (cn)\n \t\t\t   /* Every memory operand can be reloaded to fit.  */\n \t\t\t   && ((strict < 0 && MEM_P (op))\n \t\t\t       /* Before reload, accept what reload can turn\n@@ -2874,7 +2894,7 @@ constrain_operands (int strict)\n \t\t\t       || (reload_in_progress && REG_P (op)\n \t\t\t\t   && REGNO (op) >= FIRST_PSEUDO_REGISTER)))\n \t\t    win = 1;\n-\t\t  else if (EXTRA_ADDRESS_CONSTRAINT (c, p)\n+\t\t  else if (insn_extra_address_constraint (cn)\n \t\t\t   /* Every address operand can be reloaded to fit.  */\n \t\t\t   && strict < 0)\n \t\t    win = 1;\n@@ -2885,10 +2905,9 @@ constrain_operands (int strict)\n \t\t\t   && REGNO (op) >= FIRST_PSEUDO_REGISTER\n \t\t\t   && reg_renumber[REGNO (op)] < 0\n \t\t\t   && reg_equiv_mem (REGNO (op)) != 0\n-\t\t\t   && EXTRA_CONSTRAINT_STR\n-\t\t\t      (reg_equiv_mem (REGNO (op)), c, p))\n+\t\t\t   && constraint_satisfied_p\n+\t\t\t      (reg_equiv_mem (REGNO (op)), cn))\n \t\t    win = 1;\n-#endif\n \t\t  break;\n \t\t}\n \t      }\n@@ -3283,7 +3302,7 @@ peep2_find_free_register (int from, int to, const char *class_str,\n     }\n \n   cl = (class_str[0] == 'r' ? GENERAL_REGS\n-\t   : REG_CLASS_FROM_CONSTRAINT (class_str[0], class_str));\n+\t: reg_class_for_constraint (lookup_constraint (class_str)));\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {"}, {"sha": "e4614bb3210a9ff4e78368e6aa941fc74b61499d", "filename": "gcc/reload.c", "status": "modified", "additions": 68, "deletions": 64, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -401,8 +401,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \tscratch_constraint++;\n       letter = *scratch_constraint;\n       scratch_class = (letter == 'r' ? GENERAL_REGS\n-\t\t       : REG_CLASS_FROM_CONSTRAINT ((unsigned char) letter,\n-\t\t\t\t\t\t   scratch_constraint));\n+\t\t       : (reg_class_for_constraint\n+\t\t\t  (lookup_constraint (scratch_constraint))));\n \n       rclass = scratch_class;\n       mode = insn_data[(int) icode].operand[2].mode;\n@@ -560,8 +560,7 @@ scratch_reload_class (enum insn_code icode)\n   scratch_letter = *scratch_constraint;\n   if (scratch_letter == 'r')\n     return GENERAL_REGS;\n-  rclass = REG_CLASS_FROM_CONSTRAINT ((unsigned char) scratch_letter,\n-\t\t\t\t     scratch_constraint);\n+  rclass = reg_class_for_constraint (lookup_constraint (scratch_constraint));\n   gcc_assert (rclass != NO_REGS);\n   return rclass;\n }\n@@ -2852,7 +2851,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t/* Ignore things like match_operator operands.  */\n \t;\n       else if (constraints[i][0] == 'p'\n-\t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0], constraints[i]))\n+\t       || (insn_extra_address_constraint\n+\t\t   (lookup_constraint (constraints[i]))))\n \t{\n \t  address_operand_reloaded[i]\n \t    = find_reloads_address (recog_data.operand_mode[i], (rtx*) 0,\n@@ -3094,6 +3094,8 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t operand.  */\n \t      int constmemok = 0;\n \t      int earlyclobber = 0;\n+\t      enum constraint_num cn;\n+\t      enum reg_class cl;\n \n \t      /* If the predicate accepts a unary operator, it means that\n \t\t we need to reload the operand, but do not do this for\n@@ -3489,71 +3491,74 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t    /* Drop through into 'r' case.  */\n \n \t\t  case 'r':\n-\t\t    this_alternative[i]\n-\t\t      = reg_class_subunion[this_alternative[i]][(int) GENERAL_REGS];\n+\t\t    cl = GENERAL_REGS;\n \t\t    goto reg;\n \n \t\t  default:\n-\t\t    if (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS)\n+\t\t    cn = lookup_constraint (p);\n+\t\t    switch (get_constraint_type (cn))\n \t\t      {\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\t\tif (EXTRA_MEMORY_CONSTRAINT (c, p))\n-\t\t\t  {\n-\t\t\t    if (force_reload)\n-\t\t\t      break;\n-\t\t\t    if (EXTRA_CONSTRAINT_STR (operand, c, p))\n-\t\t\t      win = 1;\n-\t\t\t    /* If the address was already reloaded,\n-\t\t\t       we win as well.  */\n-\t\t\t    else if (MEM_P (operand)\n-\t\t\t\t     && address_reloaded[i] == 1)\n-\t\t\t      win = 1;\n-\t\t\t    /* Likewise if the address will be reloaded because\n-\t\t\t       reg_equiv_address is nonzero.  For reg_equiv_mem\n-\t\t\t       we have to check.  */\n-\t\t\t    else if (REG_P (operand)\n-\t\t\t\t     && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t\t\t\t     && reg_renumber[REGNO (operand)] < 0\n-\t\t\t\t     && ((reg_equiv_mem (REGNO (operand)) != 0\n-\t\t\t\t\t  && EXTRA_CONSTRAINT_STR (reg_equiv_mem (REGNO (operand)), c, p))\n-\t\t\t\t\t || (reg_equiv_address (REGNO (operand)) != 0)))\n-\t\t\t      win = 1;\n-\n-\t\t\t    /* If we didn't already win, we can reload\n-\t\t\t       constants via force_const_mem, and other\n-\t\t\t       MEMs by reloading the address like for 'o'.  */\n-\t\t\t    if (CONST_POOL_OK_P (operand_mode[i], operand)\n-\t\t\t\t|| MEM_P (operand))\n-\t\t\t      badop = 0;\n-\t\t\t    constmemok = 1;\n-\t\t\t    offmemok = 1;\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t\tif (EXTRA_ADDRESS_CONSTRAINT (c, p))\n-\t\t\t  {\n-\t\t\t    if (EXTRA_CONSTRAINT_STR (operand, c, p))\n-\t\t\t      win = 1;\n-\n-\t\t\t    /* If we didn't already win, we can reload\n-\t\t\t       the address into a base register.  */\n-\t\t\t    this_alternative[i]\n-\t\t\t      = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t\t\tADDRESS, SCRATCH);\n-\t\t\t    badop = 0;\n-\t\t\t    break;\n-\t\t\t  }\n+\t\t      case CT_REGISTER:\n+\t\t\tcl = reg_class_for_constraint (cn);\n+\t\t\tif (cl != NO_REGS)\n+\t\t\t  goto reg;\n+\t\t\tbreak;\n \n-\t\t\tif (EXTRA_CONSTRAINT_STR (operand, c, p))\n+\t\t      case CT_MEMORY:\n+\t\t\tif (force_reload)\n+\t\t\t  break;\n+\t\t\tif (constraint_satisfied_p (operand, cn))\n+\t\t\t  win = 1;\n+\t\t\t/* If the address was already reloaded,\n+\t\t\t   we win as well.  */\n+\t\t\telse if (MEM_P (operand) && address_reloaded[i] == 1)\n+\t\t\t  win = 1;\n+\t\t\t/* Likewise if the address will be reloaded because\n+\t\t\t   reg_equiv_address is nonzero.  For reg_equiv_mem\n+\t\t\t   we have to check.  */\n+\t\t\telse if (REG_P (operand)\n+\t\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t\t && reg_renumber[REGNO (operand)] < 0\n+\t\t\t\t && ((reg_equiv_mem (REGNO (operand)) != 0\n+\t\t\t\t      && (constraint_satisfied_p\n+\t\t\t\t\t  (reg_equiv_mem (REGNO (operand)),\n+\t\t\t\t\t   cn)))\n+\t\t\t\t     || (reg_equiv_address (REGNO (operand))\n+\t\t\t\t\t != 0)))\n+\t\t\t  win = 1;\n+\n+\t\t\t/* If we didn't already win, we can reload\n+\t\t\t   constants via force_const_mem, and other\n+\t\t\t   MEMs by reloading the address like for 'o'.  */\n+\t\t\tif (CONST_POOL_OK_P (operand_mode[i], operand)\n+\t\t\t    || MEM_P (operand))\n+\t\t\t  badop = 0;\n+\t\t\tconstmemok = 1;\n+\t\t\toffmemok = 1;\n+\t\t\tbreak;\n+\n+\t\t      case CT_ADDRESS:\n+\t\t\tif (constraint_satisfied_p (operand, cn))\n+\t\t\t  win = 1;\n+\n+\t\t\t/* If we didn't already win, we can reload\n+\t\t\t   the address into a base register.  */\n+\t\t\tthis_alternative[i]\n+\t\t\t  = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t    ADDRESS, SCRATCH);\n+\t\t\tbadop = 0;\n+\t\t\tbreak;\n+\n+\t\t      case CT_FIXED_FORM:\n+\t\t\tif (constraint_satisfied_p (operand, cn))\n \t\t\t  win = 1;\n-#endif\n \t\t\tbreak;\n \t\t      }\n+\t\t    break;\n \n-\t\t    this_alternative[i]\n-\t\t      = (reg_class_subunion\n-\t\t\t [this_alternative[i]]\n-\t\t\t [(int) REG_CLASS_FROM_CONSTRAINT (c, p)]);\n \t\t  reg:\n+\t\t    this_alternative[i]\n+\t\t      = reg_class_subunion[this_alternative[i]][cl];\n \t\t    if (GET_MODE (operand) == BLKmode)\n \t\t      break;\n \t\t    winreg = 1;\n@@ -4687,11 +4692,10 @@ alternative_allows_const_pool_ref (rtx mem ATTRIBUTE_UNUSED,\n     {\n       if (c == TARGET_MEM_CONSTRAINT || c == 'o')\n \treturn true;\n-#ifdef EXTRA_CONSTRAINT_STR\n-      if (EXTRA_MEMORY_CONSTRAINT (c, constraint)\n-\t  && (mem == NULL || EXTRA_CONSTRAINT_STR (mem, c, constraint)))\n+      enum constraint_num cn = lookup_constraint (constraint);\n+      if (insn_extra_memory_constraint (cn)\n+\t  && (mem == NULL || constraint_satisfied_p (mem, cn)))\n \treturn true;\n-#endif\n     }\n   return false;\n }"}, {"sha": "83e383fe501518b92ad2587bd43295448160673e", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -1437,13 +1437,15 @@ maybe_fix_stack_asms (void)\n \t\t  break;\n \n \t\tdefault:\n-\t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n+\t\t  enum constraint_num cn = lookup_constraint (p);\n+\t\t  if (insn_extra_address_constraint (cn))\n \t\t    cls = (int) reg_class_subunion[cls]\n \t\t      [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t\t\t     ADDRESS, SCRATCH)];\n \t\t  else\n \t\t    cls = (int) reg_class_subunion[cls]\n-\t\t      [(int) REG_CLASS_FROM_CONSTRAINT (c, p)];\n+\t\t      [reg_class_for_constraint (cn)];\n+\t\t  break;\n \t\t}\n \t      p += CONSTRAINT_LEN (c, p);\n \t    }"}, {"sha": "1cbf7e9fdf43bd843d17f39de1452e9ac6cc9389", "filename": "gcc/stmt.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -322,12 +322,11 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n       default:\n \tif (!ISALPHA (*p))\n \t  break;\n-\tif (REG_CLASS_FROM_CONSTRAINT (*p, p) != NO_REGS)\n+\tenum constraint_num cn = lookup_constraint (p);\n+\tif (reg_class_for_constraint (cn) != NO_REGS\n+\t    || insn_extra_address_constraint (cn))\n \t  *allows_reg = true;\n-#ifdef EXTRA_CONSTRAINT_STR\n-\telse if (EXTRA_ADDRESS_CONSTRAINT (*p, p))\n-\t  *allows_reg = true;\n-\telse if (EXTRA_MEMORY_CONSTRAINT (*p, p))\n+\telse if (insn_extra_memory_constraint (cn))\n \t  *allows_mem = true;\n \telse\n \t  {\n@@ -337,7 +336,6 @@ parse_output_constraint (const char **constraint_p, int operand_num,\n \t    *allows_reg = true;\n \t    *allows_mem = true;\n \t  }\n-#endif\n \tbreak;\n       }\n \n@@ -454,13 +452,11 @@ parse_input_constraint (const char **constraint_p, int input_num,\n \t    error (\"invalid punctuation %qc in constraint\", constraint[j]);\n \t    return false;\n \t  }\n-\tif (REG_CLASS_FROM_CONSTRAINT (constraint[j], constraint + j)\n-\t    != NO_REGS)\n+\tenum constraint_num cn = lookup_constraint (constraint + j);\n+\tif (reg_class_for_constraint (cn) != NO_REGS\n+\t    || insn_extra_address_constraint (cn))\n \t  *allows_reg = true;\n-#ifdef EXTRA_CONSTRAINT_STR\n-\telse if (EXTRA_ADDRESS_CONSTRAINT (constraint[j], constraint + j))\n-\t  *allows_reg = true;\n-\telse if (EXTRA_MEMORY_CONSTRAINT (constraint[j], constraint + j))\n+\telse if (insn_extra_memory_constraint (cn))\n \t  *allows_mem = true;\n \telse\n \t  {\n@@ -470,7 +466,6 @@ parse_input_constraint (const char **constraint_p, int input_num,\n \t    *allows_reg = true;\n \t    *allows_mem = true;\n \t  }\n-#endif\n \tbreak;\n       }\n "}, {"sha": "b0be80cac6a84a7681d6f39cede1ca162f6c0712", "filename": "gcc/system.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -930,7 +930,10 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n         GO_IF_MODE_DEPENDENT_ADDRESS DELAY_SLOTS_FOR_EPILOGUE              \\\n         ELIGIBLE_FOR_EPILOGUE_DELAY TARGET_C99_FUNCTIONS TARGET_HAS_SINCOS \\\n \tREG_CLASS_FROM_LETTER CONST_OK_FOR_LETTER_P\t\t\t   \\\n-\tCONST_DOUBLE_OK_FOR_LETTER_P EXTRA_CONSTRAINT\n+\tCONST_DOUBLE_OK_FOR_LETTER_P EXTRA_CONSTRAINT\t\t\t   \\\n+\tREG_CLASS_FROM_CONSTRAINT REG_CLASS_FOR_CONSTRAINT\t\t   \\\n+\tEXTRA_CONSTRAINT_STR EXTRA_MEMORY_CONSTRAINT\t\t\t   \\\n+\tEXTRA_ADDRESS_CONSTRAINT\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}, {"sha": "667a8c51d630f9ced6fa33c322e45e6b9f1b80d0", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=777e635f1a6cab5d2c6837b1ea903ed0bcbe87d3", "patch": "@@ -936,8 +936,8 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n \t      insn_letter = *insn_constraint;\n \t      insn_class\n \t\t= (insn_letter == 'r' ? GENERAL_REGS\n-\t\t   : REG_CLASS_FROM_CONSTRAINT ((unsigned char) insn_letter,\n-\t\t\t\t\t\tinsn_constraint));\n+\t\t   : (reg_class_for_constraint\n+\t\t      (lookup_constraint (insn_constraint))));\n \t      gcc_assert (insn_class != NO_REGS);\n \t    }\n \n@@ -954,8 +954,8 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n \t  scratch_letter = *scratch_constraint;\n \t  scratch_class\n \t    = (scratch_letter == 'r' ? GENERAL_REGS\n-\t       : REG_CLASS_FROM_CONSTRAINT ((unsigned char) scratch_letter,\n-\t\t\t\t\t    scratch_constraint));\n+\t       : (reg_class_for_constraint\n+\t\t  (lookup_constraint (scratch_constraint))));\n \n \t  if (reg_class_subset_p (reload_class, insn_class))\n \t    {"}]}