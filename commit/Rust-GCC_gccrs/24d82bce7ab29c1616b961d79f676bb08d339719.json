{"sha": "24d82bce7ab29c1616b961d79f676bb08d339719", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRkODJiY2U3YWIyOWMxNjE2Yjk2MWQ3OWY2NzZiYjA4ZDMzOTcxOQ==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-03-19T23:10:55Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-03-19T23:10:55Z"}, "message": "class.c (assume_compiled_node_struct): Rename type to class_flag_node_struct, as it is now also used for enable_assertions.\n\n\n\n\t* class.c (assume_compiled_node_struct):  Rename type to\n\tclass_flag_node_struct, as it is now also used for enable_assertions.\n\tRename assume_compiled_node typedef.  Rename excludep field to value.\n\t(find_assume_compiled_node):  Rename function to find_class_flag_node.\n\tMinor optimization - avoid needless strlen.\n\t(add_assume_compiled):  Some tweaking and optimization.\n\tRename and generalize to add_class_flag takem an extra parameter.\n\t(add_assume_compled):  New just calls add_class_flag.\n\t(add_enable_assert, enable_assertions):  New functions.\n\t(enable_assert_tree):  New static.\n\t* java-tree.h (add_enable_assert, enable_assertions): New declarations.\n\t* lang.opt (fenable-assertions, fenable-assertions=,\n\tfdisable-assertions, fdisable-assertions=):  New options.\n\t* lang.c (java_handle_option):  Handle new options.\n\t* parse.y (build_incomplete_class_ref):  Handle class$ in an inner\n\tclass in an interface - create helper class nested in outer interface.\n        (build_assertion):  Short-circuit if enable_assertions is false.\n\nFrom-SVN: r79710", "tree": {"sha": "33b8d368112dad1721fb1c8b1717ab2dd33584f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33b8d368112dad1721fb1c8b1717ab2dd33584f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24d82bce7ab29c1616b961d79f676bb08d339719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d82bce7ab29c1616b961d79f676bb08d339719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24d82bce7ab29c1616b961d79f676bb08d339719", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d82bce7ab29c1616b961d79f676bb08d339719/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "73c4ab99de2a48eb748c61ddcce1adef752eb702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c4ab99de2a48eb748c61ddcce1adef752eb702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73c4ab99de2a48eb748c61ddcce1adef752eb702"}], "stats": {"total": 230, "additions": 170, "deletions": 60}, "files": [{"sha": "0c73353188dd7d1fe7b96e3d48be890598bdfc8c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=24d82bce7ab29c1616b961d79f676bb08d339719", "patch": "@@ -1,3 +1,23 @@\n+2004-03-19  Per Bothner  <per@bothner.com>\n+\n+\t* class.c (assume_compiled_node_struct):  Rename type to\n+\tclass_flag_node_struct, as it is now also used for enable_assertions.\n+\tRename assume_compiled_node typedef.  Rename excludep field to value.\n+\t(find_assume_compiled_node):  Rename function to find_class_flag_node.\n+\tMinor optimization - avoid needless strlen.\n+\t(add_assume_compiled):  Some tweaking and optimization.\n+\tRename and generalize to add_class_flag takem an extra parameter.\n+\t(add_assume_compled):  New just calls add_class_flag.\n+\t(add_enable_assert, enable_assertions):  New functions.\n+\t(enable_assert_tree):  New static.\n+\t* java-tree.h (add_enable_assert, enable_assertions): New declarations.\n+\t* lang.opt (fenable-assertions, fenable-assertions=,\n+\tfdisable-assertions, fdisable-assertions=):  New options.\n+\t* lang.c (java_handle_option):  Handle new options.\n+\t* parse.y (build_incomplete_class_ref):  Handle class$ in an inner\n+\tclass in an interface - create helper class nested in outer interface.\n+        (build_assertion):  Short-circuit if enable_assertions is false.\n+\n 2004-03-18  Richard Kenner <kenner@vlsi1.ultra.nyu.edu>\n \n \t* java-tree.h: Changes throughout to add checking to macros"}, {"sha": "dc1659cf5ee5850a90a020bb33309ad38c43907e", "filename": "gcc/java/class.c", "status": "modified", "additions": 92, "deletions": 49, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=24d82bce7ab29c1616b961d79f676bb08d339719", "patch": "@@ -70,30 +70,32 @@ struct obstack temporary_obstack;\n    it can assume certain classes have been compiled down to native\n    code or not.  The compiler options -fassume-compiled= and\n    -fno-assume-compiled= are used to create a tree of\n-   assume_compiled_node objects.  This tree is queried to determine if\n+   class_flag_node objects.  This tree is queried to determine if\n    a class is assume to be compiled or not.  Each node in the tree\n    represents either a package or a specific class.  */\n \n-typedef struct assume_compiled_node_struct\n+typedef struct class_flag_node_struct\n {\n   /* The class or package name.  */\n   const char *ident;\n \n   /* Nonzero if this represents an exclusion.  */\n-  int excludep;\n+  int value;\n \n   /* Pointers to other nodes in the tree.  */\n-  struct assume_compiled_node_struct *parent;\n-  struct assume_compiled_node_struct *sibling;\n-  struct assume_compiled_node_struct *child;\n-} assume_compiled_node;\n+  struct class_flag_node_struct *parent;\n+  struct class_flag_node_struct *sibling;\n+  struct class_flag_node_struct *child;\n+} class_flag_node;\n \n-static assume_compiled_node *find_assume_compiled_node (assume_compiled_node *,\n-\t\t\t\t\t\t\tconst char *);\n+static class_flag_node *find_class_flag_node (class_flag_node *, const char *);\n+static void add_class_flag (class_flag_node **, const char *, int);\n \n /* This is the root of the include/exclude tree.  */\n \n-static assume_compiled_node *assume_compiled_tree;\n+static class_flag_node *assume_compiled_tree;\n+\n+static class_flag_node *enable_assert_tree;\n \n static GTY(()) tree class_roots[5];\n #define registered_class class_roots[0]\n@@ -103,11 +105,11 @@ static GTY(()) tree class_roots[5];\n #define class_dtable_decl class_roots[4]\n \n /* Return the node that most closely represents the class whose name\n-   is IDENT.  Start the search from NODE.  Return NULL if an\n-   appropriate node does not exist.  */\n+   is IDENT.  Start the search from NODE (followed by its siblings).\n+   Return NULL if an appropriate node does not exist.  */\n \n-static assume_compiled_node *\n-find_assume_compiled_node (assume_compiled_node *node, const char *ident)\n+static class_flag_node *\n+find_class_flag_node (class_flag_node *node, const char *ident)\n {\n   while (node)\n     {\n@@ -120,14 +122,13 @@ find_assume_compiled_node (assume_compiled_node *node, const char *ident)\n \n       if (node_ident_length == 0\n \t  || (strncmp (ident, node->ident, node_ident_length) == 0\n-\t      && (strlen (ident) == node_ident_length\n+\t      && (ident[node_ident_length] == '\\0'\n \t\t  || ident[node_ident_length] == '.')))\n \t{\n \t  /* We've found a match, however, there might be a more\n              specific match.  */\n \n-\t  assume_compiled_node *found = find_assume_compiled_node (node->child,\n-\t\t\t\t\t\t\t\t   ident);\n+\t  class_flag_node *found = find_class_flag_node (node->child, ident);\n \t  if (found)\n \t    return found;\n \t  else\n@@ -142,54 +143,77 @@ find_assume_compiled_node (assume_compiled_node *node, const char *ident)\n   return NULL;\n }\n \n-/* Add a new IDENT to the include/exclude tree.  It's an exclusion\n-   if EXCLUDEP is nonzero.  */\n-\n void\n-add_assume_compiled (const char *ident, int excludep)\n+add_class_flag (class_flag_node **rootp, const char *ident, int value)\n {\n-  int len;\n-  assume_compiled_node *parent;\n-  assume_compiled_node *node = xmalloc (sizeof (assume_compiled_node));\n-\n-  node->ident = xstrdup (ident);\n-  node->excludep = excludep;\n-  node->child = NULL;\n+  class_flag_node *root = *rootp;\n+  class_flag_node *parent, *node;\n \n   /* Create the root of the tree if it doesn't exist yet.  */\n \n-  if (NULL == assume_compiled_tree)\n+  if (NULL == root)\n     {\n-      assume_compiled_tree = xmalloc (sizeof (assume_compiled_node));\n-      assume_compiled_tree->ident = \"\";\n-      assume_compiled_tree->excludep = 0;\n-      assume_compiled_tree->sibling = NULL;\n-      assume_compiled_tree->child = NULL;\n-      assume_compiled_tree->parent = NULL;\n+      root = xmalloc (sizeof (class_flag_node));\n+      root->ident = \"\";\n+      root->value = 0;\n+      root->sibling = NULL;\n+      root->child = NULL;\n+      root->parent = NULL;\n+      *rootp = root;\n     }\n \n   /* Calling the function with the empty string means we're setting\n-     excludep for the root of the hierarchy.  */\n+     value for the root of the hierarchy.  */\n \n   if (0 == ident[0])\n     {\n-      assume_compiled_tree->excludep = excludep;\n+      root->value = value;\n       return;\n     }\n \n   /* Find the parent node for this new node.  PARENT will either be a\n      class or a package name.  Adjust PARENT accordingly.  */\n \n-  parent = find_assume_compiled_node (assume_compiled_tree, ident);\n-  len = strlen (parent->ident);\n-  if (parent->ident[len] && parent->ident[len] != '.')\n-    parent = parent->parent;\n+  parent = find_class_flag_node (root, ident);\n+  if (strcmp (ident, parent->ident) == 0)\n+    parent->value = value;\n+  else\n+    {\n+      /* Insert new node into the tree.  */\n+      node = xmalloc (sizeof (class_flag_node));\n \n-  /* Insert NODE into the tree.  */\n+      node->ident = xstrdup (ident);\n+      node->value = value;\n+      node->child = NULL;\n \n-  node->parent = parent;\n-  node->sibling = parent->child;\n-  parent->child = node;\n+      node->parent = parent;\n+      node->sibling = parent->child;\n+      parent->child = node;\n+    }\n+}\n+\n+/* Add a new IDENT to the include/exclude tree.  It's an exclusion\n+   if EXCLUDEP is nonzero.  */\n+\n+void\n+add_assume_compiled (const char *ident, int excludep)\n+{\n+  add_class_flag (&assume_compiled_tree, ident, excludep);\n+}\n+\n+/* The default value returned by enable_asserstions. */\n+\n+#define DEFAULT_ENABLE_ASSERT (flag_emit_class_files || optimize == 0)\n+\n+/* Enter IDENT (a class or package name) into the enable-assertions table.\n+   VALUE is true to enable and false to disable. */\n+\n+void\n+add_enable_assert (const char *ident, int value)\n+{\n+  if (enable_assert_tree == NULL)\n+    add_class_flag (&enable_assert_tree, \"\", DEFAULT_ENABLE_ASSERT);\n+  add_class_flag (&enable_assert_tree, ident, value);\n }\n \n /* Returns nonzero if IDENT is the name of a class that the compiler\n@@ -198,20 +222,39 @@ add_assume_compiled (const char *ident, int excludep)\n static int\n assume_compiled (const char *ident)\n {\n-  assume_compiled_node *i;\n+  class_flag_node *i;\n   int result;\n   \n   if (NULL == assume_compiled_tree)\n     return 1;\n \n-  i = find_assume_compiled_node (assume_compiled_tree,\n-\t\t\t\t ident);\n+  i = find_class_flag_node (assume_compiled_tree, ident);\n \n-  result = ! i->excludep;\n+  result = ! i->value;\n   \n   return (result);\n }\n \n+/* Return true if we should generate code to check assertions within KLASS. */\n+\n+bool\n+enable_assertions (tree klass)\n+{\n+  /* Check if command-line specifies whether we should check asserrtions. */\n+\n+  if (klass != NULL_TREE && DECL_NAME (klass) && enable_assert_tree != NULL)\n+    {\n+      const char *ident = IDENTIFIER_POINTER (DECL_NAME (klass));\n+      class_flag_node *node\n+\t= find_class_flag_node (enable_assert_tree, ident);\n+      return node->value;\n+    }\n+\n+  /* The default is to enable assertions if generating class files,\n+     or not optimizing. */\n+  return DEFAULT_ENABLE_ASSERT;\n+}\n+\n /* Return an IDENTIFIER_NODE the same as (OLD_NAME, OLD_LENGTH).\n    except that characters matching OLD_CHAR are substituted by NEW_CHAR.\n    Also, PREFIX is prepended, and SUFFIX is appended. */"}, {"sha": "169f0ad4007213fd23c07b497b2c39c1de91f3b6", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=24d82bce7ab29c1616b961d79f676bb08d339719", "patch": "@@ -1127,6 +1127,8 @@ extern tree java_signed_type (tree);\n extern tree java_signed_or_unsigned_type (int, tree);\n extern tree java_truthvalue_conversion (tree);\n extern void add_assume_compiled (const char *, int);\n+extern void add_enable_assert (const char *, int);\n+extern bool enable_assertions (tree);\n extern tree lookup_class (tree);\n extern tree lookup_java_constructor (tree, tree);\n extern tree lookup_java_method (tree, tree, tree);"}, {"sha": "20afb504e7268569087be8e86cb4892be463dad5", "filename": "gcc/java/lang.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=24d82bce7ab29c1616b961d79f676bb08d339719", "patch": "@@ -354,6 +354,22 @@ java_handle_option (size_t scode, const char *arg, int value)\n       flag_assert = value;\n       break;\n \n+    case OPT_fenable_assertions_:\n+      add_enable_assert (arg, value);\n+      break;\n+\n+    case OPT_fenable_assertions:\n+      add_enable_assert (\"\", value);\n+      break;\n+\n+    case OPT_fdisable_assertions_:\n+      add_enable_assert (arg, !value);\n+      break;\n+\n+    case OPT_fdisable_assertions:\n+      add_enable_assert (\"\", !value);\n+      break;\n+\n     case OPT_fassume_compiled_:\n       add_assume_compiled (arg, !value);\n       break;"}, {"sha": "3e9cdf1250a0a5ca38de69819374abd6bbb65b59", "filename": "gcc/java/lang.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.opt?ref=24d82bce7ab29c1616b961d79f676bb08d339719", "patch": "@@ -90,6 +90,18 @@ Java\n fassume-compiled=\n Java JoinedOrMissing\n \n+fenable-assertions\n+Java\n+\n+fenable-assertions=\n+Java JoinedOrMissing\n+\n+fdisable-assertions\n+Java\n+\n+fdisable-assertions=\n+Java JoinedOrMissing\n+\n fbootclasspath=\n Java JoinedOrMissing RejectNegative\n --bootclasspath=<path>\tReplace system path"}, {"sha": "a21fc2a09195edc132ec7e41e62f81b0e95221dc", "filename": "gcc/java/parse.y", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24d82bce7ab29c1616b961d79f676bb08d339719/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=24d82bce7ab29c1616b961d79f676bb08d339719", "patch": "@@ -13992,25 +13992,32 @@ build_incomplete_class_ref (int location, tree class_name)\n       && !JPRIMITIVE_TYPE_P (class_name)\n       && !(TREE_CODE (class_name) == VOID_TYPE))\n     {\n+      tree cpc_list = GET_CPC_LIST();\n+      tree cpc = cpc_list;\n       tree target_class;\n \n-      if (CLASS_INTERFACE (TYPE_NAME (this_class)))\n+      /* For inner classes, add a 'class$' method to their outermost\n+\t context, creating it if necessary.  */\n+      \n+      while (GET_NEXT_ENCLOSING_CPC(cpc))\n+\tcpc = GET_NEXT_ENCLOSING_CPC(cpc);\n+      class_decl = TREE_VALUE (cpc);\n+\n+      target_class = TREE_TYPE (class_decl);\n+\n+      if (CLASS_INTERFACE (TYPE_NAME (target_class)))\n \t{\n \t  /* For interfaces, adding a static 'class$' method directly \n \t     is illegal.  So create an inner class to contain the new\n \t     method.  Empirically this matches the behavior of javac.  */\n-\t  tree t = build_wfl_node (DECL_NAME (TYPE_NAME (object_type_node)));\n-\t  tree inner = create_anonymous_class (0, t);\n+\t  tree t, inner;\n+\t  /* We want the generated inner class inside the outermost class. */\n+\t  GET_CPC_LIST() = cpc;\n+\t  t = build_wfl_node (DECL_NAME (TYPE_NAME (object_type_node)));\n+\t  inner = create_anonymous_class (0, t);\n \t  target_class = TREE_TYPE (inner);\n \t  end_class_declaration (1);\n-\t}\n-      else\n-\t{\n-\t  /* For inner classes, add a 'class$' method to their outermost\n-\t     context, creating it if necessary.  */\n-\t  while (INNER_CLASS_DECL_P (class_decl))\n-\t    class_decl = DECL_CONTEXT (class_decl);\n-\t  target_class = TREE_TYPE (class_decl);\n+\t  GET_CPC_LIST() = cpc_list;\n \t}\n \n       if (TYPE_DOT_CLASS (target_class) == NULL_TREE)\n@@ -15299,6 +15306,16 @@ build_assertion (int location, tree condition, tree value)\n   tree node;\n   tree klass = GET_CPC ();\n \n+  if (! enable_assertions (klass))\n+    {\n+      condition = build (TRUTH_ANDIF_EXPR, NULL_TREE,\n+\t\t\t boolean_false_node, condition);\n+      if (value == NULL_TREE)\n+\tvalue = empty_stmt_node;\n+      return build_if_else_statement (location, condition,\n+\t\t\t\t      value, NULL_TREE);\n+    }\n+\n   if (! CLASS_USES_ASSERTIONS (klass))\n     {\n       tree field, classdollar, id, call;"}]}