{"sha": "d476245d13ed33424ae4e59ed48a45a236885cb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ3NjI0NWQxM2VkMzM0MjRhZTRlNTllZDQ4YTQ1YTIzNjg4NWNiMw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2014-11-12T00:29:33Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2014-11-12T00:29:33Z"}, "message": "VRP: Simplify logic for checking if any asserts need to be inserted\n\n2014-11-11  Patrick Palka  <ppalka@gcc.gnu.org>\n\n\t* tree-vrp.c (register_edge_assert_for_2): Change return type to\n\tvoid and adjust accordingly.\n\t(register_edge_assert_for_1): Likewise.\n\t(register_edge_assert_for): Likewise.\n\t(find_conditional_asserts): Likewise.\n\t(find_switch_asserts): Likewise.\n\t(find_assert_locations_1): Likewise.\n\t(find_assert_locations): Likewise.\n\t(insert_range_insertions): Inspect the need_assert_for bitmap.\n\nFrom-SVN: r217400", "tree": {"sha": "fc7a4057c719ecfaa5654e774ac2f6dc47326a5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc7a4057c719ecfaa5654e774ac2f6dc47326a5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d476245d13ed33424ae4e59ed48a45a236885cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d476245d13ed33424ae4e59ed48a45a236885cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d476245d13ed33424ae4e59ed48a45a236885cb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d476245d13ed33424ae4e59ed48a45a236885cb3/comments", "author": null, "committer": null, "parents": [{"sha": "6dc37e0d9d2aabd7d6736b3bb013c5886f7ba569", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc37e0d9d2aabd7d6736b3bb013c5886f7ba569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc37e0d9d2aabd7d6736b3bb013c5886f7ba569"}], "stats": {"total": 169, "additions": 61, "deletions": 108}, "files": [{"sha": "6c6a32541b6c3339862ecd97aa5e291981ecce72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d476245d13ed33424ae4e59ed48a45a236885cb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d476245d13ed33424ae4e59ed48a45a236885cb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d476245d13ed33424ae4e59ed48a45a236885cb3", "patch": "@@ -1,3 +1,15 @@\n+2014-11-11  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\t* tree-vrp.c (register_edge_assert_for_2): Change return type to\n+\tvoid and adjust accordingly.\n+\t(register_edge_assert_for_1): Likewise.\n+\t(register_edge_assert_for): Likewise.\n+\t(find_conditional_asserts): Likewise.\n+\t(find_switch_asserts): Likewise.\n+\t(find_assert_locations_1): Likewise.\n+\t(find_assert_locations): Likewise.\n+\t(insert_range_insertions): Inspect the need_assert_for bitmap.\n+\n 2014-11-11  Andrew Pinski  <apinski@cavium.com>\n \n \tBug target/61997"}, {"sha": "f0a4382f5d82ec5272a18231bb2197826a322c2f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 49, "deletions": 108, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d476245d13ed33424ae4e59ed48a45a236885cb3/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d476245d13ed33424ae4e59ed48a45a236885cb3/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d476245d13ed33424ae4e59ed48a45a236885cb3", "patch": "@@ -4977,32 +4977,27 @@ masked_increment (const wide_int &val_in, const wide_int &mask,\n \n /* Try to register an edge assertion for SSA name NAME on edge E for\n    the condition COND contributing to the conditional jump pointed to by BSI.\n-   Invert the condition COND if INVERT is true.\n-   Return true if an assertion for NAME could be registered.  */\n+   Invert the condition COND if INVERT is true.  */\n \n-static bool\n+static void\n register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t\t\t    enum tree_code cond_code,\n \t\t\t    tree cond_op0, tree cond_op1, bool invert)\n {\n   tree val;\n   enum tree_code comp_code;\n-  bool retval = false;\n \n   if (!extract_code_and_val_from_cond_with_ops (name, cond_code,\n \t\t\t\t\t\tcond_op0,\n \t\t\t\t\t\tcond_op1,\n \t\t\t\t\t\tinvert, &comp_code, &val))\n-    return false;\n+    return;\n \n   /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n      reachable from E.  */\n   if (live_on_edge (e, name)\n       && !has_single_use (name))\n-    {\n-      register_new_assert_for (name, name, comp_code, val, NULL, e, bsi);\n-      retval = true;\n-    }\n+    register_new_assert_for (name, name, comp_code, val, NULL, e, bsi);\n \n   /* In the case of NAME <= CST and NAME being defined as\n      NAME = (unsigned) NAME2 + CST2 we can assert NAME2 >= -CST2\n@@ -5063,8 +5058,6 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t    }\n \n \t  register_new_assert_for (name3, tmp, comp_code, val, NULL, e, bsi);\n-\n-\t  retval = true;\n \t}\n \n       /* If name2 is used later, create an ASSERT_EXPR for it.  */\n@@ -5094,8 +5087,6 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t    }\n \n \t  register_new_assert_for (name2, tmp, comp_code, val, NULL, e, bsi);\n-\n-\t  retval = true;\n \t}\n     }\n \n@@ -5133,7 +5124,6 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t      cst = int_const_binop (code, val, cst);\n \t      register_new_assert_for (name2, name2, comp_code, cst,\n \t\t\t\t       NULL, e, bsi);\n-\t      retval = true;\n \t    }\n \t}\n     }\n@@ -5197,8 +5187,6 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \n \t      register_new_assert_for (name2, tmp, new_comp_code, cst, NULL,\n \t\t\t\t       e, bsi);\n-\n-\t      retval = true;\n \t    }\n \t}\n \n@@ -5276,7 +5264,6 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \n \t      register_new_assert_for (name2, tmp, new_comp_code, new_val,\n \t\t\t\t       NULL, e, bsi);\n-\t      retval = true;\n \t    }\n \t}\n \n@@ -5297,8 +5284,7 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \t      && TREE_CODE (TREE_TYPE (val)) == INTEGER_TYPE\n \t      && TYPE_UNSIGNED (TREE_TYPE (val))\n \t      && TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (def_stmt)))\n-\t\t > prec\n-\t      && !retval))\n+\t\t > prec))\n \t{\n \t  name2 = gimple_assign_rhs1 (def_stmt);\n \t  if (rhs_code == BIT_AND_EXPR)\n@@ -5522,13 +5508,10 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n \n \t\t    register_new_assert_for (names[i], tmp, LE_EXPR,\n \t\t\t\t\t     new_val, NULL, e, bsi);\n-\t\t    retval = true;\n \t\t  }\n \t    }\n \t}\n     }\n-\n-  return retval;\n }\n \n /* OP is an operand of a truth value expression which is known to have\n@@ -5538,18 +5521,17 @@ register_edge_assert_for_2 (tree name, edge e, gimple_stmt_iterator bsi,\n    If CODE is EQ_EXPR, then we want to register OP is zero (false),\n    if CODE is NE_EXPR, then we want to register OP is nonzero (true).   */\n \n-static bool\n+static void\n register_edge_assert_for_1 (tree op, enum tree_code code,\n \t\t\t    edge e, gimple_stmt_iterator bsi)\n {\n-  bool retval = false;\n   gimple op_def;\n   tree val;\n   enum tree_code rhs_code;\n \n   /* We only care about SSA_NAMEs.  */\n   if (TREE_CODE (op) != SSA_NAME)\n-    return false;\n+    return;\n \n   /* We know that OP will have a zero or nonzero value.  If OP is used\n      more than once go ahead and register an assert for OP.  */\n@@ -5558,15 +5540,14 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n     {\n       val = build_int_cst (TREE_TYPE (op), 0);\n       register_new_assert_for (op, op, code, val, NULL, e, bsi);\n-      retval = true;\n     }\n \n   /* Now look at how OP is set.  If it's set from a comparison,\n      a truth operation or some bit operations, then we may be able\n      to register information about the operands of that assignment.  */\n   op_def = SSA_NAME_DEF_STMT (op);\n   if (gimple_code (op_def) != GIMPLE_ASSIGN)\n-    return retval;\n+    return;\n \n   rhs_code = gimple_assign_rhs_code (op_def);\n \n@@ -5577,11 +5558,9 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       tree op1 = gimple_assign_rhs2 (op_def);\n \n       if (TREE_CODE (op0) == SSA_NAME)\n-        retval |= register_edge_assert_for_2 (op0, e, bsi, rhs_code, op0, op1,\n-\t\t\t\t\t      invert);\n+        register_edge_assert_for_2 (op0, e, bsi, rhs_code, op0, op1, invert);\n       if (TREE_CODE (op1) == SSA_NAME)\n-        retval |= register_edge_assert_for_2 (op1, e, bsi, rhs_code, op0, op1,\n-\t\t\t\t\t      invert);\n+        register_edge_assert_for_2 (op1, e, bsi, rhs_code, op0, op1, invert);\n     }\n   else if ((code == NE_EXPR\n \t    && gimple_assign_rhs_code (op_def) == BIT_AND_EXPR)\n@@ -5593,24 +5572,22 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       tree op1 = gimple_assign_rhs2 (op_def);\n       if (TREE_CODE (op0) == SSA_NAME\n \t  && has_single_use (op0))\n-\tretval |= register_edge_assert_for_1 (op0, code, e, bsi);\n+\tregister_edge_assert_for_1 (op0, code, e, bsi);\n       if (TREE_CODE (op1) == SSA_NAME\n \t  && has_single_use (op1))\n-\tretval |= register_edge_assert_for_1 (op1, code, e, bsi);\n+\tregister_edge_assert_for_1 (op1, code, e, bsi);\n     }\n   else if (gimple_assign_rhs_code (op_def) == BIT_NOT_EXPR\n \t   && TYPE_PRECISION (TREE_TYPE (gimple_assign_lhs (op_def))) == 1)\n     {\n       /* Recurse, flipping CODE.  */\n       code = invert_tree_comparison (code, false);\n-      retval |= register_edge_assert_for_1 (gimple_assign_rhs1 (op_def),\n-\t\t\t\t\t    code, e, bsi);\n+      register_edge_assert_for_1 (gimple_assign_rhs1 (op_def), code, e, bsi);\n     }\n   else if (gimple_assign_rhs_code (op_def) == SSA_NAME)\n     {\n       /* Recurse through the copy.  */\n-      retval |= register_edge_assert_for_1 (gimple_assign_rhs1 (op_def),\n-\t\t\t\t\t    code, e, bsi);\n+      register_edge_assert_for_1 (gimple_assign_rhs1 (op_def), code, e, bsi);\n     }\n   else if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (op_def)))\n     {\n@@ -5620,40 +5597,37 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       if (INTEGRAL_TYPE_P (TREE_TYPE (rhs))\n \t  && (TYPE_PRECISION (TREE_TYPE (rhs))\n \t      <= TYPE_PRECISION (TREE_TYPE (op))))\n-\tretval |= register_edge_assert_for_1 (rhs, code, e, bsi);\n+\tregister_edge_assert_for_1 (rhs, code, e, bsi);\n     }\n-\n-  return retval;\n }\n \n /* Try to register an edge assertion for SSA name NAME on edge E for\n-   the condition COND contributing to the conditional jump pointed to by SI.\n-   Return true if an assertion for NAME could be registered.  */\n+   the condition COND contributing to the conditional jump pointed to by\n+   SI.  */\n \n-static bool\n+static void\n register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n \t\t\t  enum tree_code cond_code, tree cond_op0,\n \t\t\t  tree cond_op1)\n {\n   tree val;\n   enum tree_code comp_code;\n-  bool retval = false;\n   bool is_else_edge = (e->flags & EDGE_FALSE_VALUE) != 0;\n \n   /* Do not attempt to infer anything in names that flow through\n      abnormal edges.  */\n   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n-    return false;\n+    return;\n \n   if (!extract_code_and_val_from_cond_with_ops (name, cond_code,\n \t\t\t\t\t\tcond_op0, cond_op1,\n \t\t\t\t\t\tis_else_edge,\n \t\t\t\t\t\t&comp_code, &val))\n-    return false;\n+    return;\n \n   /* Register ASSERT_EXPRs for name.  */\n-  retval |= register_edge_assert_for_2 (name, e, si, cond_code, cond_op0,\n-\t\t\t\t\tcond_op1, is_else_edge);\n+  register_edge_assert_for_2 (name, e, si, cond_code, cond_op0,\n+\t\t\t      cond_op1, is_else_edge);\n \n \n   /* If COND is effectively an equality test of an SSA_NAME against\n@@ -5673,8 +5647,8 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n \t{\n \t  tree op0 = gimple_assign_rhs1 (def_stmt);\n \t  tree op1 = gimple_assign_rhs2 (def_stmt);\n-\t  retval |= register_edge_assert_for_1 (op0, NE_EXPR, e, si);\n-\t  retval |= register_edge_assert_for_1 (op1, NE_EXPR, e, si);\n+\t  register_edge_assert_for_1 (op0, NE_EXPR, e, si);\n+\t  register_edge_assert_for_1 (op1, NE_EXPR, e, si);\n \t}\n     }\n \n@@ -5695,12 +5669,10 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n \t{\n \t  tree op0 = gimple_assign_rhs1 (def_stmt);\n \t  tree op1 = gimple_assign_rhs2 (def_stmt);\n-\t  retval |= register_edge_assert_for_1 (op0, EQ_EXPR, e, si);\n-\t  retval |= register_edge_assert_for_1 (op1, EQ_EXPR, e, si);\n+\t  register_edge_assert_for_1 (op0, EQ_EXPR, e, si);\n+\t  register_edge_assert_for_1 (op1, EQ_EXPR, e, si);\n \t}\n     }\n-\n-  return retval;\n }\n \n \n@@ -5712,17 +5684,15 @@ register_edge_assert_for (tree name, edge e, gimple_stmt_iterator si,\n    the predicate operands, an assert location node is added to the\n    list of assertions for the corresponding operands.  */\n \n-static bool\n+static void\n find_conditional_asserts (basic_block bb, gimple last)\n {\n-  bool need_assert;\n   gimple_stmt_iterator bsi;\n   tree op;\n   edge_iterator ei;\n   edge e;\n   ssa_op_iter iter;\n \n-  need_assert = false;\n   bsi = gsi_for_stmt (last);\n \n   /* Look for uses of the operands in each of the sub-graphs\n@@ -5737,15 +5707,11 @@ find_conditional_asserts (basic_block bb, gimple last)\n       /* Register the necessary assertions for each operand in the\n \t conditional predicate.  */\n       FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n-\t{\n-\t  need_assert |= register_edge_assert_for (op, e, bsi,\n-\t\t\t\t\t\t   gimple_cond_code (last),\n-\t\t\t\t\t\t   gimple_cond_lhs (last),\n-\t\t\t\t\t\t   gimple_cond_rhs (last));\n-\t}\n+\tregister_edge_assert_for (op, e, bsi,\n+\t\t\t\t  gimple_cond_code (last),\n+\t\t\t\t  gimple_cond_lhs (last),\n+\t\t\t\t  gimple_cond_rhs (last));\n     }\n-\n-  return need_assert;\n }\n \n struct case_info\n@@ -5790,10 +5756,9 @@ compare_case_labels (const void *p1, const void *p2)\n    the predicate operands, an assert location node is added to the\n    list of assertions for the corresponding operands.  */\n \n-static bool\n+static void\n find_switch_asserts (basic_block bb, gimple last)\n {\n-  bool need_assert;\n   gimple_stmt_iterator bsi;\n   tree op;\n   edge e;\n@@ -5806,11 +5771,10 @@ find_switch_asserts (basic_block bb, gimple last)\n   volatile unsigned int idx;\n #endif\n \n-  need_assert = false;\n   bsi = gsi_for_stmt (last);\n   op = gimple_switch_index (last);\n   if (TREE_CODE (op) != SSA_NAME)\n-    return false;\n+    return;\n \n   /* Build a vector of case labels sorted by destination label.  */\n   ci = XNEWVEC (struct case_info, n);\n@@ -5857,22 +5821,15 @@ find_switch_asserts (basic_block bb, gimple last)\n \n       /* Register the necessary assertions for the operand in the\n \t SWITCH_EXPR.  */\n-      need_assert |= register_edge_assert_for (op, e, bsi,\n-\t\t\t\t\t       max ? GE_EXPR : EQ_EXPR,\n-\t\t\t\t\t       op,\n-\t\t\t\t\t       fold_convert (TREE_TYPE (op),\n-\t\t\t\t\t\t\t     min));\n+      register_edge_assert_for (op, e, bsi,\n+\t\t\t\tmax ? GE_EXPR : EQ_EXPR,\n+\t\t\t\top, fold_convert (TREE_TYPE (op), min));\n       if (max)\n-\t{\n-\t  need_assert |= register_edge_assert_for (op, e, bsi, LE_EXPR,\n-\t\t\t\t\t\t   op,\n-\t\t\t\t\t\t   fold_convert (TREE_TYPE (op),\n-\t\t\t\t\t\t\t\t max));\n-\t}\n+\tregister_edge_assert_for (op, e, bsi, LE_EXPR, op,\n+\t\t\t\t  fold_convert (TREE_TYPE (op), max));\n     }\n \n   XDELETEVEC (ci);\n-  return need_assert;\n }\n \n \n@@ -5933,20 +5890,14 @@ find_switch_asserts (basic_block bb, gimple last)\n    registered assertions to prevent adding unnecessary assertions.\n    For instance, if a pointer P_4 is dereferenced more than once in a\n    dominator tree, only the location dominating all the dereference of\n-   P_4 will receive an ASSERT_EXPR.\n-\n-   If this function returns true, then it means that there are names\n-   for which we need to generate ASSERT_EXPRs.  Those assertions are\n-   inserted by process_assert_insertions.  */\n+   P_4 will receive an ASSERT_EXPR.  */\n \n-static bool\n+static void\n find_assert_locations_1 (basic_block bb, sbitmap live)\n {\n   gimple_stmt_iterator si;\n   gimple last;\n-  bool need_assert;\n \n-  need_assert = false;\n   last = last_stmt (bb);\n \n   /* If BB's last statement is a conditional statement involving integer\n@@ -5955,14 +5906,14 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n       && gimple_code (last) == GIMPLE_COND\n       && !fp_predicate (last)\n       && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n-    need_assert |= find_conditional_asserts (bb, last);\n+    find_conditional_asserts (bb, last);\n \n   /* If BB's last statement is a switch statement involving integer\n      operands, determine if we need to add ASSERT_EXPRs.  */\n   if (last\n       && gimple_code (last) == GIMPLE_SWITCH\n       && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n-    need_assert |= find_switch_asserts (bb, last);\n+    find_switch_asserts (bb, last);\n \n   /* Traverse all the statements in BB marking used names and looking\n      for statements that may infer assertions for their used operands.  */\n@@ -6019,16 +5970,12 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n \t\t\t operand of the NOP_EXPR after SI, not after the\n \t\t\t conversion.  */\n \t\t      if (! has_single_use (t))\n-\t\t\t{\n-\t\t\t  register_new_assert_for (t, t, comp_code, value,\n-\t\t\t\t\t\t   bb, NULL, si);\n-\t\t\t  need_assert = true;\n-\t\t\t}\n+\t\t\tregister_new_assert_for (t, t, comp_code, value,\n+\t\t\t\t\t\t bb, NULL, si);\n \t\t    }\n \t\t}\n \n \t      register_new_assert_for (op, op, comp_code, value, bb, NULL, si);\n-\t      need_assert = true;\n \t    }\n \t}\n \n@@ -6059,22 +6006,18 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n \n       bitmap_clear_bit (live, SSA_NAME_VERSION (res));\n     }\n-\n-  return need_assert;\n }\n \n /* Do an RPO walk over the function computing SSA name liveness\n-   on-the-fly and deciding on assert expressions to insert.\n-   Returns true if there are assert expressions to be inserted.  */\n+   on-the-fly and deciding on assert expressions to insert.  */\n \n-static bool\n+static void\n find_assert_locations (void)\n {\n   int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   int *bb_rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n   int *last_rpo = XCNEWVEC (int, last_basic_block_for_fn (cfun));\n   int rpo_cnt, i;\n-  bool need_asserts;\n \n   live = XCNEWVEC (sbitmap, last_basic_block_for_fn (cfun));\n   rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);\n@@ -6108,7 +6051,6 @@ find_assert_locations (void)\n \t}\n     }\n \n-  need_asserts = false;\n   for (i = rpo_cnt - 1; i >= 0; --i)\n     {\n       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, rpo[i]);\n@@ -6123,7 +6065,7 @@ find_assert_locations (void)\n \n       /* Process BB and update the live information with uses in\n          this block.  */\n-      need_asserts |= find_assert_locations_1 (bb, live[rpo[i]]);\n+      find_assert_locations_1 (bb, live[rpo[i]]);\n \n       /* Merge liveness into the predecessor blocks and free it.  */\n       if (!bitmap_empty_p (live[rpo[i]]))\n@@ -6174,8 +6116,6 @@ find_assert_locations (void)\n     if (live[i])\n       sbitmap_free (live[i]);\n   XDELETEVEC (live);\n-\n-  return need_asserts;\n }\n \n /* Create an ASSERT_EXPR for NAME and insert it in the location\n@@ -6311,7 +6251,8 @@ insert_range_assertions (void)\n \n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  if (find_assert_locations ())\n+  find_assert_locations ();\n+  if (!bitmap_empty_p (need_assert_for))\n     {\n       process_assert_insertions ();\n       update_ssa (TODO_update_ssa_no_phi);"}]}