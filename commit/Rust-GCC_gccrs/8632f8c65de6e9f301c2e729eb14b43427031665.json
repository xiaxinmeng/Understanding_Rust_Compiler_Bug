{"sha": "8632f8c65de6e9f301c2e729eb14b43427031665", "node_id": "C_kwDOANBUbNoAKDg2MzJmOGM2NWRlNmU5ZjMwMWMyZTcyOWViMTRiNDM0MjcwMzE2NjU", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-23T15:36:01Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-23T15:36:01Z"}, "message": "Remove duplicated param valud in modref tree\n\nModref tree template stores its own copy of param_moderf_max_bases, *_max_refs\nand *_max_accesses values.  This was done before we had per-function limits and\neven back then it was bit dubious, so this patch removes it.\n\ngcc/ChangeLog:\n\n\t* ipa-modref-tree.h (struct modref_tree): Remove max_bases, max_refs\n\tand max_accesses.\n\t(modref_tree::modref_tree): Remove parametr.\n\t(modref_tree::insert_base): Add max_bases parameter.\n\t(modref_tree::insert): Add max_bases, max_refs, max_accesses\n\tparameters.\n\t(modref_tree::insert): New member function.\n\t(modref_tree::merge): Add max_bases, max_refs, max_accesses\n\tparameters.\n\t(modref_tree::insert): New member function.\n\t* ipa-modref-tree.c (test_insert_search_collapse): Update.\n\t(test_merge): Update.\n\t* ipa-modref.c (dump_records): Don't dump max_refs and max_bases.\n\t(dump_lto_records): Likewise.\n\t(modref_summary::finalize): Fix whitespace.\n\t(get_modref_function_summary): Likewise.\n\t(modref_access_analysis::record_access): Update.\n\t(modref_access_analysis::record_access_lto): Update.\n\t(modref_access_analysis::process_fnspec): Update.\n\t(analyze_function): Update.\n\t(modref_summaries::duplicate): Update.\n\t(modref_summaries_lto::duplicate): Update.\n\t(write_modref_records): Update.\n\t(read_modref_records): Update.\n\t(read_section): Update.\n\t(propagate_unknown_call): Update.\n\t(modref_propagate_in_scc): Update.\n\t(ipa_merge_modref_summary_after_inlining): Update.", "tree": {"sha": "a6e9bb0c753ed0947a237064661c0a83e5711ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6e9bb0c753ed0947a237064661c0a83e5711ba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8632f8c65de6e9f301c2e729eb14b43427031665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8632f8c65de6e9f301c2e729eb14b43427031665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8632f8c65de6e9f301c2e729eb14b43427031665", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8632f8c65de6e9f301c2e729eb14b43427031665/comments", "author": null, "committer": null, "parents": [{"sha": "5459fa132a99e6037e5ccf1b49d617677a584ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5459fa132a99e6037e5ccf1b49d617677a584ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5459fa132a99e6037e5ccf1b49d617677a584ff8"}], "stats": {"total": 264, "additions": 137, "deletions": 127}, "files": [{"sha": "0671fa761998d285c224ffbd46dbeb335c87affb", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8632f8c65de6e9f301c2e729eb14b43427031665/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8632f8c65de6e9f301c2e729eb14b43427031665/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=8632f8c65de6e9f301c2e729eb14b43427031665", "patch": "@@ -874,11 +874,11 @@ test_insert_search_collapse ()\n   modref_ref_node<alias_set_type> *ref_node;\n   modref_access_node a = unspecified_modref_access_node;\n \n-  modref_tree<alias_set_type> *t = new modref_tree<alias_set_type>(1, 2, 2);\n+  modref_tree<alias_set_type> *t = new modref_tree<alias_set_type>();\n   ASSERT_FALSE (t->every_base);\n \n   /* Insert into an empty tree.  */\n-  t->insert (1, 2, a, false);\n+  t->insert (1, 2, 2, 1, 2, a, false);\n   ASSERT_NE (t->bases, NULL);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_FALSE (t->every_base);\n@@ -896,7 +896,7 @@ test_insert_search_collapse ()\n   ASSERT_EQ (ref_node->ref, 2);\n \n   /* Insert when base exists but ref does not.  */\n-  t->insert (1, 3, a, false);\n+  t->insert (1, 2, 2, 1, 3, a, false);\n   ASSERT_NE (t->bases, NULL);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_EQ (t->search (1), base_node);\n@@ -909,42 +909,42 @@ test_insert_search_collapse ()\n \n   /* Insert when base and ref exist, but access is not dominated by nor\n      dominates other accesses.  */\n-  t->insert (1, 2, a, false);\n+  t->insert (1, 2, 2, 1, 2, a, false);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_EQ (t->search (1), base_node);\n \n   ref_node = base_node->search (2);\n   ASSERT_NE (ref_node, NULL);\n \n   /* Insert when base and ref exist and access is dominated.  */\n-  t->insert (1, 2, a, false);\n+  t->insert (1, 2, 2, 1, 2, a, false);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->search (2), ref_node);\n \n   /* Insert ref to trigger ref list collapse for base 1.  */\n-  t->insert (1, 4, a, false);\n+  t->insert (1, 2, 2, 1, 4, a, false);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->refs, NULL);\n   ASSERT_EQ (base_node->search (2), NULL);\n   ASSERT_EQ (base_node->search (3), NULL);\n   ASSERT_TRUE (base_node->every_ref);\n \n   /* Further inserts to collapsed ref list are ignored.  */\n-  t->insert (1, 5, a, false);\n+  t->insert (1, 2, 2, 1, 5, a, false);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->refs, NULL);\n   ASSERT_EQ (base_node->search (2), NULL);\n   ASSERT_EQ (base_node->search (3), NULL);\n   ASSERT_TRUE (base_node->every_ref);\n \n   /* Insert base to trigger base list collapse.  */\n-  t->insert (5, 0, a, false);\n+  t->insert (1, 2, 2, 5, 0, a, false);\n   ASSERT_TRUE (t->every_base);\n   ASSERT_EQ (t->bases, NULL);\n   ASSERT_EQ (t->search (1), NULL);\n \n   /* Further inserts to collapsed base list are ignored.  */\n-  t->insert (7, 8, a, false);\n+  t->insert (1, 2, 2, 7, 8, a, false);\n   ASSERT_TRUE (t->every_base);\n   ASSERT_EQ (t->bases, NULL);\n   ASSERT_EQ (t->search (1), NULL);\n@@ -959,23 +959,23 @@ test_merge ()\n   modref_base_node<alias_set_type> *base_node;\n   modref_access_node a = unspecified_modref_access_node;\n \n-  t1 = new modref_tree<alias_set_type>(3, 4, 1);\n-  t1->insert (1, 1, a, false);\n-  t1->insert (1, 2, a, false);\n-  t1->insert (1, 3, a, false);\n-  t1->insert (2, 1, a, false);\n-  t1->insert (3, 1, a, false);\n-\n-  t2 = new modref_tree<alias_set_type>(10, 10, 10);\n-  t2->insert (1, 2, a, false);\n-  t2->insert (1, 3, a, false);\n-  t2->insert (1, 4, a, false);\n-  t2->insert (3, 2, a, false);\n-  t2->insert (3, 3, a, false);\n-  t2->insert (3, 4, a, false);\n-  t2->insert (3, 5, a, false);\n-\n-  t1->merge (t2, NULL, NULL, false);\n+  t1 = new modref_tree<alias_set_type>();\n+  t1->insert (3, 4, 1, 1, 1, a, false);\n+  t1->insert (3, 4, 1, 1, 2, a, false);\n+  t1->insert (3, 4, 1, 1, 3, a, false);\n+  t1->insert (3, 4, 1, 2, 1, a, false);\n+  t1->insert (3, 4, 1, 3, 1, a, false);\n+\n+  t2 = new modref_tree<alias_set_type>();\n+  t2->insert (10, 10, 10, 1, 2, a, false);\n+  t2->insert (10, 10, 10, 1, 3, a, false);\n+  t2->insert (10, 10, 10, 1, 4, a, false);\n+  t2->insert (10, 10, 10, 3, 2, a, false);\n+  t2->insert (10, 10, 10, 3, 3, a, false);\n+  t2->insert (10, 10, 10, 3, 4, a, false);\n+  t2->insert (10, 10, 10, 3, 5, a, false);\n+\n+  t1->merge (3, 4, 1, t2, NULL, NULL, false);\n \n   ASSERT_FALSE (t1->every_base);\n   ASSERT_NE (t1->bases, NULL);"}, {"sha": "35190c212ca3ea2048c7549bb0dcb88e6075df93", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 54, "deletions": 22, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8632f8c65de6e9f301c2e729eb14b43427031665/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8632f8c65de6e9f301c2e729eb14b43427031665/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=8632f8c65de6e9f301c2e729eb14b43427031665", "patch": "@@ -304,24 +304,20 @@ template <typename T>\n struct GTY((user)) modref_tree\n {\n   vec <modref_base_node <T> *, va_gc> *bases;\n-  size_t max_bases;\n-  size_t max_refs;\n-  size_t max_accesses;\n   bool every_base;\n \n-  modref_tree (size_t max_bases, size_t max_refs, size_t max_accesses):\n+  modref_tree ():\n     bases (NULL),\n-    max_bases (max_bases),\n-    max_refs (max_refs),\n-    max_accesses (max_accesses),\n     every_base (false) {}\n \n   /* Insert BASE; collapse tree if there are more than MAX_REFS.\n      Return inserted base and if CHANGED is non-null set it to true if\n      something changed.\n      If table gets full, try to insert REF instead.  */\n \n-  modref_base_node <T> *insert_base (T base, T ref, bool *changed = NULL)\n+  modref_base_node <T> *insert_base (T base, T ref,\n+\t\t\t\t     unsigned int max_bases,\n+\t\t\t\t     bool *changed = NULL)\n   {\n     modref_base_node <T> *base_node;\n \n@@ -367,7 +363,10 @@ struct GTY((user)) modref_tree\n \n   /* Insert memory access to the tree.\n      Return true if something changed.  */\n-  bool insert (T base, T ref, modref_access_node a,\n+  bool insert (unsigned int max_bases,\n+\t       unsigned int max_refs,\n+\t       unsigned int max_accesses,\n+\t       T base, T ref, modref_access_node a,\n \t       bool record_adjustments)\n   {\n     if (every_base)\n@@ -412,7 +411,8 @@ struct GTY((user)) modref_tree\n \treturn true;\n       }\n \n-    modref_base_node <T> *base_node = insert_base (base, ref, &changed);\n+    modref_base_node <T> *base_node\n+      = insert_base (base, ref, max_bases, &changed);\n     base = base_node->base;\n     /* If table got full we may end up with useless base.  */\n     if (!base && !ref && !a.useful_p ())\n@@ -431,8 +431,8 @@ struct GTY((user)) modref_tree\n \treturn true;\n       }\n \n-    modref_ref_node <T> *ref_node = base_node->insert_ref (ref, max_refs,\n-\t\t\t\t\t\t\t   &changed);\n+    modref_ref_node <T> *ref_node\n+\t    = base_node->insert_ref (ref, max_refs, &changed);\n     ref = ref_node->ref;\n \n     if (ref_node->every_access)\n@@ -458,6 +458,18 @@ struct GTY((user)) modref_tree\n     return changed;\n   }\n \n+  /* Insert memory access to the tree.\n+     Return true if something changed.  */\n+  bool insert (tree fndecl,\n+\t       T base, T ref, const modref_access_node &a,\n+\t       bool record_adjustments)\n+  {\n+     return insert (opt_for_fn (fndecl, param_modref_max_bases),\n+\t\t    opt_for_fn (fndecl, param_modref_max_refs),\n+\t\t    opt_for_fn (fndecl, param_modref_max_accesses),\n+\t\t    base, ref, a, record_adjustments);\n+  }\n+\n  /* Remove tree branches that are not useful (i.e. they will always pass).  */\n \n  void cleanup ()\n@@ -506,7 +518,10 @@ struct GTY((user)) modref_tree\n      PARM_MAP, if non-NULL, maps parm indexes of callee to caller.\n      Similar CHAIN_MAP, if non-NULL, maps static chain of callee to caller.\n      Return true if something has changed.  */\n-  bool merge (modref_tree <T> *other, vec <modref_parm_map> *parm_map,\n+  bool merge (unsigned int max_bases,\n+\t      unsigned int max_refs,\n+\t      unsigned int max_accesses,\n+\t      modref_tree <T> *other, vec <modref_parm_map> *parm_map,\n \t      modref_parm_map *static_chain_map,\n \t      bool record_accesses)\n   {\n@@ -530,15 +545,16 @@ struct GTY((user)) modref_tree\n     if (other == this)\n       {\n \trelease = true;\n-\tother = modref_tree<T>::create_ggc (max_bases, max_refs, max_accesses);\n+\tother = modref_tree<T>::create_ggc ();\n \tother->copy_from (this);\n       }\n \n     FOR_EACH_VEC_SAFE_ELT (other->bases, i, base_node)\n       {\n \tif (base_node->every_ref)\n \t  {\n-\t    my_base_node = insert_base (base_node->base, 0, &changed);\n+\t    my_base_node = insert_base (base_node->base, 0,\n+\t\t\t\t\tmax_bases, &changed);\n \t    if (my_base_node && !my_base_node->every_ref)\n \t      {\n \t\tmy_base_node->collapse ();\n@@ -551,7 +567,8 @@ struct GTY((user)) modref_tree\n \t    {\n \t      if (ref_node->every_access)\n \t\t{\n-\t\t  changed |= insert (base_node->base,\n+\t\t  changed |= insert (max_bases, max_refs, max_accesses,\n+\t\t\t\t     base_node->base,\n \t\t\t\t     ref_node->ref,\n \t\t\t\t     unspecified_modref_access_node,\n \t\t\t\t     record_accesses);\n@@ -578,8 +595,9 @@ struct GTY((user)) modref_tree\n \t\t\t    a.parm_index = m.parm_index;\n \t\t\t  }\n \t\t      }\n-\t\t    changed |= insert (base_node->base, ref_node->ref, a,\n-\t\t\t\t       record_accesses);\n+\t\t    changed |= insert (max_bases, max_refs, max_accesses,\n+\t\t\t\t       base_node->base, ref_node->ref,\n+\t\t\t\t       a, record_accesses);\n \t\t  }\n \t    }\n       }\n@@ -588,10 +606,25 @@ struct GTY((user)) modref_tree\n     return changed;\n   }\n \n+  /* Merge OTHER into the tree.\n+     PARM_MAP, if non-NULL, maps parm indexes of callee to caller.\n+     Similar CHAIN_MAP, if non-NULL, maps static chain of callee to caller.\n+     Return true if something has changed.  */\n+  bool merge (tree fndecl,\n+\t      modref_tree <T> *other, vec <modref_parm_map> *parm_map,\n+\t      modref_parm_map *static_chain_map,\n+\t      bool record_accesses)\n+  {\n+     return merge (opt_for_fn (fndecl, param_modref_max_bases),\n+\t\t   opt_for_fn (fndecl, param_modref_max_refs),\n+\t\t   opt_for_fn (fndecl, param_modref_max_accesses),\n+\t\t   other, parm_map, static_chain_map, record_accesses);\n+  }\n+\n   /* Copy OTHER to THIS.  */\n   void copy_from (modref_tree <T> *other)\n   {\n-    merge (other, NULL, NULL, false);\n+    merge (INT_MAX, INT_MAX, INT_MAX, other, NULL, NULL, false);\n   }\n \n   /* Search BASE in tree; return NULL if failed.  */\n@@ -633,11 +666,10 @@ struct GTY((user)) modref_tree\n   /* Return ggc allocated instance.  We explicitly call destructors via\n      ggc_delete and do not want finalizers to be registered and\n      called at the garbage collection time.  */\n-  static modref_tree<T> *create_ggc (size_t max_bases, size_t max_refs,\n-\t\t\t\t     size_t max_accesses)\n+  static modref_tree<T> *create_ggc ()\n   {\n     return new (ggc_alloc_no_dtor<modref_tree<T>> ())\n-\t modref_tree<T> (max_bases, max_refs, max_accesses);\n+\t modref_tree<T> ();\n   }\n \n   /* Remove all records and mark tree to alias with everything.  */"}, {"sha": "79d7d774715ecd204fe345d8dac2b12c6e3a3234", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 57, "deletions": 79, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8632f8c65de6e9f301c2e729eb14b43427031665/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8632f8c65de6e9f301c2e729eb14b43427031665/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=8632f8c65de6e9f301c2e729eb14b43427031665", "patch": "@@ -423,8 +423,6 @@ modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n static void\n dump_records (modref_records *tt, FILE *out)\n {\n-  fprintf (out, \"    Limits: %i bases, %i refs\\n\",\n-\t   (int)tt->max_bases, (int)tt->max_refs);\n   if (tt->every_base)\n     {\n       fprintf (out, \"    Every base\\n\");\n@@ -466,8 +464,6 @@ dump_records (modref_records *tt, FILE *out)\n static void\n dump_lto_records (modref_records_lto *tt, FILE *out)\n {\n-  fprintf (out, \"    Limits: %i bases, %i refs\\n\",\n-\t   (int)tt->max_bases, (int)tt->max_refs);\n   if (tt->every_base)\n     {\n       fprintf (out, \"    Every base\\n\");\n@@ -693,7 +689,7 @@ modref_summary::finalize (tree fun)\n       try_dse = true;\n       size_t i, j, k;\n       int num_tests = 0, max_tests\n-       \t= opt_for_fn (fun, param_modref_max_tests);\n+\t= opt_for_fn (fun, param_modref_max_tests);\n       modref_base_node <alias_set_type> *base_node;\n       modref_ref_node <alias_set_type> *ref_node;\n       modref_access_node *access_node;\n@@ -768,7 +764,7 @@ get_modref_function_summary (gcall *call, bool *interposed)\n   modref_summary *r = get_modref_function_summary (node);\n   if (interposed && r)\n     *interposed = r->calls_interposable\n-\t    \t  || !node->binds_to_current_def_p ();\n+\t\t  || !node->binds_to_current_def_p ();\n   return r;\n }\n \n@@ -996,7 +992,7 @@ modref_access_analysis::record_access (modref_records *tt,\n \t\tbase_set, ref_set);\n        a.dump (dump_file);\n     }\n-  tt->insert (base_set, ref_set, a, false);\n+  tt->insert (current_function_decl, base_set, ref_set, a, false);\n }\n \n /* IPA version of record_access_tree.  */\n@@ -1062,7 +1058,7 @@ modref_access_analysis::record_access_lto (modref_records_lto *tt, ao_ref *ref,\n        a.dump (dump_file);\n     }\n \n-  tt->insert (base_type, ref_type, a, false);\n+  tt->insert (current_function_decl, base_type, ref_type, a, false);\n }\n \n /* Returns true if and only if we should store the access to EXPR.\n@@ -1277,12 +1273,15 @@ modref_access_analysis::merge_call_side_effects\n     }\n \n   /* Merge in loads.  */\n-  changed |= m_summary->loads->merge (callee_summary->loads, &parm_map,\n-\t\t\t\t      &chain_map, record_adjustments);\n+  changed |= m_summary->loads->merge (current_function_decl,\n+\t\t\t\t      callee_summary->loads,\n+\t\t\t\t      &parm_map, &chain_map,\n+\t\t\t\t      record_adjustments);\n   /* Merge in stores.  */\n   if (!ignore_stores_p (current_function_decl, flags))\n     {\n-      changed |= m_summary->stores->merge (callee_summary->stores,\n+      changed |= m_summary->stores->merge (current_function_decl,\n+\t\t\t\t\t   callee_summary->stores,\n \t\t\t\t\t   &parm_map, &chain_map,\n \t\t\t\t\t   record_adjustments);\n       if (!m_summary->writes_errno\n@@ -1395,9 +1394,10 @@ modref_access_analysis::process_fnspec (gcall *call)\n \t    if (a.parm_index == MODREF_LOCAL_MEMORY_PARM)\n \t      continue;\n \t    if (m_summary)\n-\t      m_summary->loads->insert (0, 0, a, false);\n+\t      m_summary->loads->insert (current_function_decl, 0, 0, a, false);\n \t    if (m_summary_lto)\n-\t      m_summary_lto->loads->insert (0, 0, a, false);\n+\t      m_summary_lto->loads->insert (current_function_decl, 0, 0, a,\n+\t\t\t\t\t    false);\n \t  }\n     }\n   if (ignore_stores_p (current_function_decl, flags))\n@@ -1426,9 +1426,10 @@ modref_access_analysis::process_fnspec (gcall *call)\n \t    if (a.parm_index == MODREF_LOCAL_MEMORY_PARM)\n \t      continue;\n \t    if (m_summary)\n-\t      m_summary->stores->insert (0, 0, a, false);\n+\t      m_summary->stores->insert (current_function_decl, 0, 0, a, false);\n \t    if (m_summary_lto)\n-\t      m_summary_lto->stores->insert (0, 0, a, false);\n+\t      m_summary_lto->stores->insert (current_function_decl,\n+\t\t\t\t\t     0, 0, a, false);\n \t  }\n       if (fnspec.errno_maybe_written_p () && flag_errno_math)\n \t{\n@@ -3024,13 +3025,9 @@ analyze_function (function *f, bool ipa)\n   if (nolto)\n     {\n       gcc_assert (!summary->loads);\n-      summary->loads = modref_records::create_ggc (param_modref_max_bases,\n-\t\t\t\t\t\t   param_modref_max_refs,\n-\t\t\t\t\t\t   param_modref_max_accesses);\n+      summary->loads = modref_records::create_ggc ();\n       gcc_assert (!summary->stores);\n-      summary->stores = modref_records::create_ggc (param_modref_max_bases,\n-\t\t\t\t\t\t    param_modref_max_refs,\n-\t\t\t\t\t\t    param_modref_max_accesses);\n+      summary->stores = modref_records::create_ggc ();\n       summary->writes_errno = false;\n       summary->side_effects = false;\n       summary->nondeterministic = false;\n@@ -3039,15 +3036,9 @@ analyze_function (function *f, bool ipa)\n   if (lto)\n     {\n       gcc_assert (!summary_lto->loads);\n-      summary_lto->loads = modref_records_lto::create_ggc\n-\t\t\t\t (param_modref_max_bases,\n-\t\t\t\t  param_modref_max_refs,\n-\t\t\t\t  param_modref_max_accesses);\n+      summary_lto->loads = modref_records_lto::create_ggc ();\n       gcc_assert (!summary_lto->stores);\n-      summary_lto->stores = modref_records_lto::create_ggc\n-\t\t\t\t (param_modref_max_bases,\n-\t\t\t\t  param_modref_max_refs,\n-\t\t\t\t  param_modref_max_accesses);\n+      summary_lto->stores = modref_records_lto::create_ggc ();\n       summary_lto->writes_errno = false;\n       summary_lto->side_effects = false;\n       summary_lto->nondeterministic = false;\n@@ -3287,15 +3278,9 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n       optimization_summaries->remove (dst);\n       return;\n     }\n-  dst_data->stores = modref_records::create_ggc\n-\t\t\t(src_data->stores->max_bases,\n-\t\t\t src_data->stores->max_refs,\n-\t\t\t src_data->stores->max_accesses);\n+  dst_data->stores = modref_records::create_ggc ();\n   dst_data->stores->copy_from (src_data->stores);\n-  dst_data->loads = modref_records::create_ggc\n-\t\t\t(src_data->loads->max_bases,\n-\t\t\t src_data->loads->max_refs,\n-\t\t\t src_data->loads->max_accesses);\n+  dst_data->loads = modref_records::create_ggc ();\n   dst_data->loads->copy_from (src_data->loads);\n   dst_data->kills.reserve_exact (src_data->kills.length ());\n   dst_data->kills.splice (src_data->kills);\n@@ -3319,15 +3304,9 @@ modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n   /* Be sure that no further cloning happens after ipa-modref.  If it does\n      we will need to update signatures for possible param changes.  */\n   gcc_checking_assert (!((modref_summaries_lto *)summaries_lto)->propagated);\n-  dst_data->stores = modref_records_lto::create_ggc\n-\t\t\t(src_data->stores->max_bases,\n-\t\t\t src_data->stores->max_refs,\n-\t\t\t src_data->stores->max_accesses);\n+  dst_data->stores = modref_records_lto::create_ggc ();\n   dst_data->stores->copy_from (src_data->stores);\n-  dst_data->loads = modref_records_lto::create_ggc\n-\t\t\t(src_data->loads->max_bases,\n-\t\t\t src_data->loads->max_refs,\n-\t\t\t src_data->loads->max_accesses);\n+  dst_data->loads = modref_records_lto::create_ggc ();\n   dst_data->loads->copy_from (src_data->loads);\n   dst_data->kills.reserve_exact (src_data->kills.length ());\n   dst_data->kills.splice (src_data->kills);\n@@ -3379,10 +3358,6 @@ class pass_modref : public gimple_opt_pass\n static void\n write_modref_records (modref_records_lto *tt, struct output_block *ob)\n {\n-  streamer_write_uhwi (ob, tt->max_bases);\n-  streamer_write_uhwi (ob, tt->max_refs);\n-  streamer_write_uhwi (ob, tt->max_accesses);\n-\n   streamer_write_uhwi (ob, tt->every_base);\n   streamer_write_uhwi (ob, vec_safe_length (tt->bases));\n   for (auto base_node : tt->bases)\n@@ -3410,20 +3385,19 @@ write_modref_records (modref_records_lto *tt, struct output_block *ob)\n    LTO streaming is expected or not.  */\n \n static void\n-read_modref_records (lto_input_block *ib, struct data_in *data_in,\n+read_modref_records (tree decl,\n+\t\t     lto_input_block *ib, struct data_in *data_in,\n \t\t     modref_records **nolto_ret,\n \t\t     modref_records_lto **lto_ret)\n {\n-  size_t max_bases = streamer_read_uhwi (ib);\n-  size_t max_refs = streamer_read_uhwi (ib);\n-  size_t max_accesses = streamer_read_uhwi (ib);\n+  size_t max_bases = opt_for_fn (decl, param_modref_max_bases);\n+  size_t max_refs = opt_for_fn (decl, param_modref_max_refs);\n+  size_t max_accesses = opt_for_fn (decl, param_modref_max_accesses);\n \n   if (lto_ret)\n-    *lto_ret = modref_records_lto::create_ggc (max_bases, max_refs,\n-\t\t\t\t\t       max_accesses);\n+    *lto_ret = modref_records_lto::create_ggc ();\n   if (nolto_ret)\n-    *nolto_ret = modref_records::create_ggc (max_bases, max_refs,\n-\t\t\t\t\t     max_accesses);\n+    *nolto_ret = modref_records::create_ggc ();\n   gcc_checking_assert (lto_ret || nolto_ret);\n \n   size_t every_base = streamer_read_uhwi (ib);\n@@ -3461,9 +3435,9 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n       if (nolto_ret)\n \tnolto_base_node = (*nolto_ret)->insert_base (base_tree\n \t\t\t\t\t\t     ? get_alias_set (base_tree)\n-\t\t\t\t\t\t     : 0, 0);\n+\t\t\t\t\t\t     : 0, 0, INT_MAX);\n       if (lto_ret)\n-\tlto_base_node = (*lto_ret)->insert_base (base_tree, 0);\n+\tlto_base_node = (*lto_ret)->insert_base (base_tree, 0, max_bases);\n       size_t every_ref = streamer_read_uhwi (ib);\n       size_t nref = streamer_read_uhwi (ib);\n \n@@ -3743,10 +3717,10 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n       if (modref_sum_lto)\n \tmodref_sum_lto->static_chain_flags = flags;\n \n-      read_modref_records (&ib, data_in,\n+      read_modref_records (node->decl, &ib, data_in,\n \t\t\t   modref_sum ? &modref_sum->loads : NULL,\n \t\t\t   modref_sum_lto ? &modref_sum_lto->loads : NULL);\n-      read_modref_records (&ib, data_in,\n+      read_modref_records (node->decl, &ib, data_in,\n \t\t\t   modref_sum ? &modref_sum->stores : NULL,\n \t\t\t   modref_sum_lto ? &modref_sum_lto->stores : NULL);\n       int j = streamer_read_uhwi (&ib);\n@@ -4425,10 +4399,12 @@ propagate_unknown_call (cgraph_node *node,\n \t\t}\n \t      if (cur_summary)\n \t\tchanged |= cur_summary->loads->insert\n-\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map), false);\n+\t\t  (node->decl, 0, 0,\n+\t\t   get_access_for_fnspec (e, fnspec, i, map), false);\n \t      if (cur_summary_lto)\n \t\tchanged |= cur_summary_lto->loads->insert\n-\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map), false);\n+\t\t  (node->decl, 0, 0,\n+\t\t   get_access_for_fnspec (e, fnspec, i, map), false);\n \t    }\n \t}\n       if (ignore_stores_p (node->decl, ecf_flags))\n@@ -4455,10 +4431,12 @@ propagate_unknown_call (cgraph_node *node,\n \t\t}\n \t      if (cur_summary)\n \t\tchanged |= cur_summary->stores->insert\n-\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map), false);\n+\t\t  (node->decl, 0, 0,\n+\t\t   get_access_for_fnspec (e, fnspec, i, map), false);\n \t      if (cur_summary_lto)\n \t\tchanged |= cur_summary_lto->stores->insert\n-\t\t  (0, 0, get_access_for_fnspec (e, fnspec, i, map), false);\n+\t\t  (node->decl, 0, 0,\n+\t\t   get_access_for_fnspec (e, fnspec, i, map), false);\n \t    }\n \t}\n       if (fnspec.errno_maybe_written_p () && flag_errno_math)\n@@ -4703,13 +4681,13 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      if (callee_summary)\n \t\t{\n \t\t  changed |= cur_summary->loads->merge\n-\t\t\t\t  (callee_summary->loads, &parm_map,\n-\t\t\t\t   &chain_map, !first);\n+\t\t\t\t  (node->decl, callee_summary->loads,\n+\t\t\t\t   &parm_map, &chain_map, !first);\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary->stores->merge\n-\t\t\t\t      (callee_summary->stores, &parm_map,\n-\t\t\t\t       &chain_map, !first);\n+\t\t\t\t      (node->decl, callee_summary->stores,\n+\t\t\t\t       &parm_map, &chain_map, !first);\n \t\t      if (!cur_summary->writes_errno\n \t\t\t  && callee_summary->writes_errno)\n \t\t\t{\n@@ -4721,13 +4699,13 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      if (callee_summary_lto)\n \t\t{\n \t\t  changed |= cur_summary_lto->loads->merge\n-\t\t\t\t  (callee_summary_lto->loads, &parm_map,\n-\t\t\t\t   &chain_map, !first);\n+\t\t\t\t  (node->decl, callee_summary_lto->loads,\n+\t\t\t\t   &parm_map, &chain_map, !first);\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary_lto->stores->merge\n-\t\t\t\t      (callee_summary_lto->stores, &parm_map,\n-\t\t\t\t       &chain_map, !first);\n+\t\t\t\t      (node->decl, callee_summary_lto->stores,\n+\t\t\t\t       &parm_map, &chain_map, !first);\n \t\t      if (!cur_summary_lto->writes_errno\n \t\t\t  && callee_summary_lto->writes_errno)\n \t\t\t{\n@@ -5114,20 +5092,20 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n       if (!ignore_stores)\n \t{\n \t  if (to_info && callee_info)\n-\t    to_info->stores->merge (callee_info->stores, &parm_map,\n+\t    to_info->stores->merge (to->decl, callee_info->stores, &parm_map,\n \t\t\t\t    &chain_map, false);\n \t  if (to_info_lto && callee_info_lto)\n-\t    to_info_lto->stores->merge (callee_info_lto->stores, &parm_map,\n-\t\t\t\t\t&chain_map, false);\n+\t    to_info_lto->stores->merge (to->decl, callee_info_lto->stores,\n+\t\t\t\t\t&parm_map, &chain_map, false);\n \t}\n       if (!(flags & (ECF_CONST | ECF_NOVOPS)))\n \t{\n \t  if (to_info && callee_info)\n-\t    to_info->loads->merge (callee_info->loads, &parm_map,\n+\t    to_info->loads->merge (to->decl, callee_info->loads, &parm_map,\n \t\t\t\t   &chain_map, false);\n \t  if (to_info_lto && callee_info_lto)\n-\t    to_info_lto->loads->merge (callee_info_lto->loads, &parm_map,\n-\t\t\t\t       &chain_map, false);\n+\t    to_info_lto->loads->merge (to->decl, callee_info_lto->loads,\n+\t\t\t\t       &parm_map, &chain_map, false);\n \t}\n     }\n "}]}