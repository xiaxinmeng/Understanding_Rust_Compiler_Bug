{"sha": "ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMwNjhjOTRlNzYzMzlkOWI5NWRjZWY4YjQxYTZlMzRlOGJmOTBmNQ==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2018-08-15T20:29:04Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2018-08-15T20:29:04Z"}, "message": "fold-vec-splat-char.c: New.\n\n[testsuite]\n\n2018-08-13  Will Schmidt  <will_schmidt@vnet.ibm.com>\n\n\t* gcc.target/powerpc/fold-vec-splat-char.c: New.\n\t* gcc.target/powerpc/fold-vec-splat-floatdouble.c: New.\n\t* gcc.target/powerpc/fold-vec-splat-int.c: New.\n\t* gcc.target/powerpc/fold-vec-splat-longlong.c: New.\n\t* gcc.target/powerpc/fold-vec-splat-pixel.c: New.\n\t* gcc.target/powerpc/fold-vec-splat-short.c: New.\n\nFrom-SVN: r263570", "tree": {"sha": "0f5666a03e834cbe12f864d73824427a53d60348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f5666a03e834cbe12f864d73824427a53d60348"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e0ad3e6bd66b1c025cf2666f23596cefc8cde695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ad3e6bd66b1c025cf2666f23596cefc8cde695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ad3e6bd66b1c025cf2666f23596cefc8cde695"}], "stats": {"total": 296, "additions": 296, "deletions": 0}, "files": [{"sha": "cee05611a6c965747e8b383defe74965a29aacef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "patch": "@@ -1,3 +1,12 @@\n+2018-08-15  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/fold-vec-splat-char.c: New.\n+\t* gcc.target/powerpc/fold-vec-splat-floatdouble.c: New.\n+\t* gcc.target/powerpc/fold-vec-splat-int.c: New.\n+\t* gcc.target/powerpc/fold-vec-splat-longlong.c: New.\n+\t* gcc.target/powerpc/fold-vec-splat-pixel.c: New.\n+\t* gcc.target/powerpc/fold-vec-splat-short.c: New.\n+\n 2018-08-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* g++.dg/diagnostic/aka3.C: New test."}, {"sha": "d50d073979f372d58ed972032eca64d08647b7ab", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-splat-char.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-char.c?ref=ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "patch": "@@ -0,0 +1,55 @@\n+/* Verify that overloaded built-ins for vec_splat with char\n+   inputs produce the right code.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector bool char testb_0  (vector bool char x) { return vec_splat (x, 0b00000); }\n+vector bool char testb_1  (vector bool char x) { return vec_splat (x, 0b00001); }\n+vector bool char testb_2  (vector bool char x) { return vec_splat (x, 0b00010); }\n+vector bool char testb_4  (vector bool char x) { return vec_splat (x, 0b00100); }\n+vector bool char testb_8  (vector bool char x) { return vec_splat (x, 0b01000); }\n+vector bool char testb_10 (vector bool char x) { return vec_splat (x, 0b10000); }\n+vector bool char testb_1e (vector bool char x) { return vec_splat (x, 0b11110); }\n+vector bool char testb_1f (vector bool char x) { return vec_splat (x, 0b11111); }\n+\n+vector signed char tests_0  (vector signed char x) { return vec_splat (x, 0b00000); }\n+vector signed char tests_1  (vector signed char x) { return vec_splat (x, 0b00001); }\n+vector signed char tests_2  (vector signed char x) { return vec_splat (x, 0b00010); }\n+vector signed char tests_4  (vector signed char x) { return vec_splat (x, 0b00100); }\n+vector signed char tests_8  (vector signed char x) { return vec_splat (x, 0b01000); }\n+vector signed char tests_10 (vector signed char x) { return vec_splat (x, 0b10000); }\n+vector signed char tests_1e (vector signed char x) { return vec_splat (x, 0b11110); }\n+vector signed char tests_1f (vector signed char x) { return vec_splat (x, 0b11111); }\n+\n+vector unsigned char testu_0  (vector unsigned char x) { return vec_splat (x, 0b00000); }\n+vector unsigned char testu_1  (vector unsigned char x) { return vec_splat (x, 0b00001); }\n+vector unsigned char testu_2  (vector unsigned char x) { return vec_splat (x, 0b00010); }\n+vector unsigned char testu_4  (vector unsigned char x) { return vec_splat (x, 0b00100); }\n+vector unsigned char testu_8  (vector unsigned char x) { return vec_splat (x, 0b01000); }\n+vector unsigned char testu_10 (vector unsigned char x) { return vec_splat (x, 0b10000); }\n+vector unsigned char testu_1e (vector unsigned char x) { return vec_splat (x, 0b11110); }\n+vector unsigned char testu_1f (vector unsigned char x) { return vec_splat (x, 0b11111); }\n+\n+/* Similar tests as above, but the source vector is a known constant. */\n+const vector bool char by = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p'};\n+const vector signed char sy = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p'};\n+const vector unsigned char uy = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p'};\n+\n+vector bool char test_bc (vector bool char x) { return vec_splat (by, 0b00010); }\n+vector signed char test_sc (vector signed char x) { return vec_splat (sy, 0b00011); }\n+vector unsigned char test_uc (vector unsigned char x) { return vec_splat (uy, 0b00110); }\n+\n+/* Similar tests as above, mask is greater than number of elements in the\n+ source vector.  */\n+vector bool char test_obc (vector bool char x) { return vec_splat (by, 0b10010); }\n+vector signed char test_osc (vector signed char x) { return vec_splat (sy, 0b10011); }\n+vector unsigned char test_ouc (vector unsigned char x) { return vec_splat (uy, 0b10110); }\n+\n+// vec_splat() using variable vectors should generate the vspltb instruction.\n+/* { dg-final { scan-assembler-times \"vspltb\" 24 } } */\n+// vec_splat() using a constant vector should generate a load.\n+/* { dg-final { scan-assembler-times {\\mlvx\\M|\\mlxvw4x\\M} 6 } } */"}, {"sha": "fd74002bb1f062f34fba0fd2b0a95ecaadb781e5", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-splat-floatdouble.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-floatdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-floatdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-floatdouble.c?ref=ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "patch": "@@ -0,0 +1,46 @@\n+/* Verify that overloaded built-ins for vec_splat with float and\n+   double inputs produce the right code.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector float testf_00 (vector float x) { return vec_splat (x, 0b00000); }\n+vector float testf_01 (vector float x) { return vec_splat (x, 0b00001); }\n+vector float testf_02 (vector float x) { return vec_splat (x, 0b00010); }\n+vector float testf_04 (vector float x) { return vec_splat (x, 0b00100); }\n+vector float testf_08 (vector float x) { return vec_splat (x, 0b01000); }\n+vector float testf_0f (vector float x) { return vec_splat (x, 0b01111); }\n+vector float testf_10 (vector float x) { return vec_splat (x, 0b10000); }\n+vector float testf_1e (vector float x) { return vec_splat (x, 0b11110); }\n+vector float testf_1f (vector float x) { return vec_splat (x, 0b11111); }\n+\n+vector double testd_00 (vector double x) { return vec_splat (x, 0b00000); }\n+vector double testd_01 (vector double x) { return vec_splat (x, 0b00001); }\n+vector double testd_02 (vector double x) { return vec_splat (x, 0b00010); }\n+vector double testd_04 (vector double x) { return vec_splat (x, 0b00100); }\n+vector double testd_08 (vector double x) { return vec_splat (x, 0b01000); }\n+vector double testd_0f (vector double x) { return vec_splat (x, 0b01111); }\n+vector double testd_10 (vector double x) { return vec_splat (x, 0b10000); }\n+vector double testd_1e (vector double x) { return vec_splat (x, 0b11110); }\n+vector double testd_1f (vector double x) { return vec_splat (x, 0b11111); }\n+\n+/* Similar tests as above, but the source vector is a known constant. */\n+vector float test_fc () { const vector float y = { 7.1, 8.2, 9.3, 10.4}; return vec_splat (y, 0b00010); }\n+vector double test_dc () { const vector double y = { 3.0, 5.0 }; return vec_splat (y, 0b00010); }\n+\n+/* Similar tests as above, mask is greater than number of elements in the\n+ source vector.  */\n+vector float test_ofc () { const vector float y = { 7.1, 8.2, 9.3, 10.4}; return vec_splat (y, 0b10010); }\n+vector double test_odc () { const vector double y = { 3.0, 5.0 }; return vec_splat (y, 0b10010); }\n+\n+/* lvx or lxvd2x for loading of the constants.  */\n+/* vspltw or xxspltw for non-constants with the float type.  */\n+/* xxpermdi for non-constants with the double type.  */\n+\n+/* { dg-final { scan-assembler-times {\\mlvx\\M|\\mlxvd2x\\M} 4 } } */\n+/* { dg-final { scan-assembler-times \"vspltw|xxspltw\" 9 } } */\n+/* { dg-final { scan-assembler-times \"xxpermdi\" 9 } } */\n+"}, {"sha": "7697853f75abe42bc8e3ab5b1a7cc85ce1621395", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-splat-int.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-int.c?ref=ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "patch": "@@ -0,0 +1,50 @@\n+/* Verify that overloaded built-ins for vec_splat with int\n+   inputs produce the right code.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector bool int testb_0  (vector bool int x) { return vec_splat (x, 0b00000); }\n+vector bool int testb_1  (vector bool int x) { return vec_splat (x, 0b00001); }\n+vector bool int testb_2  (vector bool int x) { return vec_splat (x, 0b00010); }\n+vector bool int testb_4  (vector bool int x) { return vec_splat (x, 0b00100); }\n+vector bool int testb_8  (vector bool int x) { return vec_splat (x, 0b01000); }\n+vector bool int testb_10 (vector bool int x) { return vec_splat (x, 0b10000); }\n+vector bool int testb_1e (vector bool int x) { return vec_splat (x, 0b11110); }\n+vector bool int testb_1f (vector bool int x) { return vec_splat (x, 0b11111); }\n+\n+vector signed int tests_0  (vector signed int x) { return vec_splat (x, 0b00000); }\n+vector signed int tests_1  (vector signed int x) { return vec_splat (x, 0b00001); }\n+vector signed int tests_2  (vector signed int x) { return vec_splat (x, 0b00010); }\n+vector signed int tests_4  (vector signed int x) { return vec_splat (x, 0b00100); }\n+vector signed int tests_8  (vector signed int x) { return vec_splat (x, 0b01000); }\n+vector signed int tests_10 (vector signed int x) { return vec_splat (x, 0b10000); }\n+vector signed int tests_1e (vector signed int x) { return vec_splat (x, 0b11110); }\n+vector signed int tests_1f (vector signed int x) { return vec_splat (x, 0b11111); }\n+\n+vector unsigned int testu_0  (vector unsigned int x) { return vec_splat (x, 0b00000); }\n+vector unsigned int testu_1  (vector unsigned int x) { return vec_splat (x, 0b00001); }\n+vector unsigned int testu_2  (vector unsigned int x) { return vec_splat (x, 0b00010); }\n+vector unsigned int testu_4  (vector unsigned int x) { return vec_splat (x, 0b00100); }\n+vector unsigned int testu_8  (vector unsigned int x) { return vec_splat (x, 0b01000); }\n+vector unsigned int testu_10 (vector unsigned int x) { return vec_splat (x, 0b10000); }\n+vector unsigned int testu_1e (vector unsigned int x) { return vec_splat (x, 0b11110); }\n+vector unsigned int testu_1f (vector unsigned int x) { return vec_splat (x, 0b11111); }\n+\n+/* Similar test as above, but the source vector is a known constant. */\n+vector bool int test_bic () { const vector bool int y = { 1,2,3,4}; return vec_splat (y, 0b00010); }\n+vector signed int test_sic () { const vector signed int y = { 1,2,3,4}; return vec_splat (y, 0b00010); }\n+vector unsigned int test_uic () { const vector unsigned int y = { 1,2,3,4}; return vec_splat (y, 0b00010); }\n+\n+/* Similar tests as above, mask is greater than number of elements in the\n+ source vector.  */\n+vector bool int test_obic () { const vector bool int y = { 1,2,3,4}; return vec_splat (y, 0b10010); }\n+vector signed int test_osic () { const vector signed int y = { 1,2,3,4}; return vec_splat (y, 0b10010); }\n+vector unsigned int test_ouic () { const vector unsigned int y = { 1,2,3,4}; return vec_splat (y, 0b10010); }\n+\n+/* { dg-final { scan-assembler-times \"vspltisw\" 6 } } */\n+/* { dg-final { scan-assembler-times \"vspltw|xxspltw\" 24 } } */\n+"}, {"sha": "0720e20a116a80b158af7355d5182782e5261d41", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-splat-longlong.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-longlong.c?ref=ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "patch": "@@ -0,0 +1,60 @@\n+/* Verify that overloaded built-ins for vec_splat with long long\n+   inputs produce the right code.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector bool long long testb_00 (vector bool long long x) { return vec_splat (x, 0b00000); }\n+vector bool long long testb_01 (vector bool long long x) { return vec_splat (x, 0b00001); }\n+vector bool long long testb_02 (vector bool long long x) { return vec_splat (x, 0b00010); }\n+vector bool long long testb_04 (vector bool long long x) { return vec_splat (x, 0b00100); }\n+vector bool long long testb_08 (vector bool long long x) { return vec_splat (x, 0b01000); }\n+vector bool long long testb_10 (vector bool long long x) { return vec_splat (x, 0b10000); }\n+vector bool long long testb_1e (vector bool long long x) { return vec_splat (x, 0b11110); }\n+vector bool long long testb_1f (vector bool long long x) { return vec_splat (x, 0b11111); }\n+\n+vector signed long long tests_00 (vector signed long long x) { return vec_splat (x, 0b00000); }\n+vector signed long long tests_01 (vector signed long long x) { return vec_splat (x, 0b00001); }\n+vector signed long long tests_02 (vector signed long long x) { return vec_splat (x, 0b00010); }\n+vector signed long long tests_04 (vector signed long long x) { return vec_splat (x, 0b00100); }\n+vector signed long long tests_08 (vector signed long long x) { return vec_splat (x, 0b01000); }\n+vector signed long long tests_10 (vector signed long long x) { return vec_splat (x, 0b10000); }\n+vector signed long long tests_1e (vector signed long long x) { return vec_splat (x, 0b11110); }\n+vector signed long long tests_1f (vector signed long long x) { return vec_splat (x, 0b11111); }\n+\n+vector unsigned long long testu_00 (vector unsigned long long x) { return vec_splat (x, 0b00000); }\n+vector unsigned long long testu_01 (vector unsigned long long x) { return vec_splat (x, 0b00001); }\n+vector unsigned long long testu_02 (vector unsigned long long x) { return vec_splat (x, 0b00010); }\n+vector unsigned long long testu_04 (vector unsigned long long x) { return vec_splat (x, 0b00100); }\n+vector unsigned long long testu_08 (vector unsigned long long x) { return vec_splat (x, 0b01000); }\n+vector unsigned long long testu_10 (vector unsigned long long x) { return vec_splat (x, 0b10000); }\n+vector unsigned long long testu_1e (vector unsigned long long x) { return vec_splat (x, 0b11110); }\n+vector unsigned long long testu_1f (vector unsigned long long x) { return vec_splat (x, 0b11111); }\n+\n+/* Similar test as above, but the source vector is a known constant. */\n+vector bool long long test_bll () { const vector bool long long y = {12, 23}; return vec_splat (y, 0b00010); }\n+vector signed long long test_sll () { const vector signed long long y = {34, 45}; return vec_splat (y, 0b00010); }\n+vector unsigned long long test_ull () { const vector unsigned long long y = {56, 67}; return vec_splat (y, 0b00010); }\n+\n+/* Similar tests as above, mask is greater than number of elements in the\n+ source vector.  */\n+vector bool long long test_obll () { const vector bool long long y = {12, 23}; return vec_splat (y, 0b10010); }\n+vector signed long long test_osll () { const vector signed long long y = {34, 45}; return vec_splat (y, 0b10010); }\n+vector unsigned long long test_oull () { const vector unsigned long long y = {56, 67}; return vec_splat (y, 0b10010); }\n+\n+/* lvx for the initialization with known constants. */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M|\\mlxvd2x\\M} 6 } } */\n+\n+/* xxpermdi for vec_splat of long long vectors.\n+   At the time of this writing, the number of xxpermdi instructions\n+   generated could be 24 or 26 or 27, ultimately depending on the\n+   platform and whether or not folding is enabled.\n+   Roughly:\n+\t24 occurrences on older targets (power5) regardless of folding state.\n+\t26 occurrences with gimple folding enabled (through power9).\n+\t27 occurrences with gimple folding disabled (through power9).\n+  So, ensure we have at least one hit.  */\n+/* { dg-final { scan-assembler \"xxpermdi\" } } */"}, {"sha": "7170588f5685bef23aaa4d442ee149d8a087b086", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-splat-pixel.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-pixel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-pixel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-pixel.c?ref=ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "patch": "@@ -0,0 +1,27 @@\n+/* Verify that overloaded built-ins for vec_splat with pixel\n+   inputs produce the right code.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-mvsx -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector pixel test1_00 (vector pixel x) { return vec_splat (x, 0b00000); }\n+vector pixel test1_01 (vector pixel x) { return vec_splat (x, 0b00001); }\n+vector pixel test1_02 (vector pixel x) { return vec_splat (x, 0b00010); }\n+vector pixel test1_04 (vector pixel x) { return vec_splat (x, 0b00100); }\n+vector pixel test1_08 (vector pixel x) { return vec_splat (x, 0b01000); }\n+vector pixel test1_10 (vector pixel x) { return vec_splat (x, 0b10000); }\n+vector pixel test1_1e (vector pixel x) { return vec_splat (x, 0b11110); }\n+vector pixel test1_1f (vector pixel x) { return vec_splat (x, 0b11111); }\n+\n+/* Similar test as above, but the source vector is a known constant. */\n+vector pixel test_p () { const vector pixel y = { 1,2,3,4}; return vec_splat (y, 0b00010); }\n+\n+/* Similar tests as above, mask is greater than number of elements in the\n+ source vector.  */\n+vector pixel test_op () { const vector pixel y = { 1,2,3,4}; return vec_splat (y, 0b10010); }\n+\n+/* { dg-final { scan-assembler-times \"vspltish\" 2 } } */\n+/* { dg-final { scan-assembler-times \"vsplth\" 8 } } */"}, {"sha": "96c553f124f1001ab07233ef949ea94a19bb95a7", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-splat-short.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac068c94e76339d9b95dcef8b41a6e34e8bf90f5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-splat-short.c?ref=ac068c94e76339d9b95dcef8b41a6e34e8bf90f5", "patch": "@@ -0,0 +1,49 @@\n+/* Verify that overloaded built-ins for vec_splat with short\n+   inputs produce the right results.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec -O2\" } */\n+\n+#include <altivec.h>\n+\n+vector bool short testb_00 (vector bool short x) { return vec_splat (x, 0b00000); }\n+vector bool short testb_01 (vector bool short x) { return vec_splat (x, 0b00001); }\n+vector bool short testb_02 (vector bool short x) { return vec_splat (x, 0b00010); }\n+vector bool short testb_04 (vector bool short x) { return vec_splat (x, 0b00100); }\n+vector bool short testb_08 (vector bool short x) { return vec_splat (x, 0b01000); }\n+vector bool short testb_10 (vector bool short x) { return vec_splat (x, 0b10000); }\n+vector bool short testb_1e (vector bool short x) { return vec_splat (x, 0b11110); }\n+vector bool short testb_1f (vector bool short x) { return vec_splat (x, 0b11111); }\n+\n+vector signed short tests_00 (vector signed short x) { return vec_splat (x, 0b00000); }\n+vector signed short tests_01 (vector signed short x) { return vec_splat (x, 0b00001); }\n+vector signed short tests_02 (vector signed short x) { return vec_splat (x, 0b00010); }\n+vector signed short tests_04 (vector signed short x) { return vec_splat (x, 0b00100); }\n+vector signed short tests_08 (vector signed short x) { return vec_splat (x, 0b01000); }\n+vector signed short tests_10 (vector signed short x) { return vec_splat (x, 0b10000); }\n+vector signed short tests_1e (vector signed short x) { return vec_splat (x, 0b11110); }\n+vector signed short tests_1f (vector signed short x) { return vec_splat (x, 0b11111); }\n+\n+vector unsigned short testu_00 (vector unsigned short x) { return vec_splat (x, 0b00000); }\n+vector unsigned short testu_01 (vector unsigned short x) { return vec_splat (x, 0b00001); }\n+vector unsigned short testu_02 (vector unsigned short x) { return vec_splat (x, 0b00010); }\n+vector unsigned short testu_04 (vector unsigned short x) { return vec_splat (x, 0b00100); }\n+vector unsigned short testu_08 (vector unsigned short x) { return vec_splat (x, 0b01000); }\n+vector unsigned short testu_10 (vector unsigned short x) { return vec_splat (x, 0b10000); }\n+vector unsigned short testu_1e (vector unsigned short x) { return vec_splat (x, 0b11110); }\n+vector unsigned short testu_1f (vector unsigned short x) { return vec_splat (x, 0b11111); }\n+\n+/* Similar test as above, but the source vector is a known constant. */\n+vector bool short test_bs () { const vector bool short y = {1, 2, 3, 4, 5, 6, 7, 8}; return vec_splat (y, 0b00010); }\n+vector signed short test_ss () { const vector signed short y = {1, 2, 3, 4, 5, 6, 7, 8}; return vec_splat (y, 0b00010); }\n+vector unsigned short test_us () { const vector unsigned short y = {1, 2, 3, 4, 5, 6, 7, 8}; return vec_splat (y, 0b00010); }\n+\n+/* Similar tests as above, mask is greater than number of elements in the\n+ source vector.  */\n+vector bool short test_obs () { const vector bool short y = {1, 2, 3, 4, 5, 6, 7, 8}; return vec_splat (y, 0b10010); }\n+vector signed short test_oss () { const vector signed short y = {1, 2, 3, 4, 5, 6, 7, 8}; return vec_splat (y, 0b10010); }\n+vector unsigned short test_ous () { const vector unsigned short y = {1, 2, 3, 4, 5, 6, 7, 8}; return vec_splat (y, 0b10010); }\n+\n+/* { dg-final { scan-assembler-times \"vspltish\" 6 } } */\n+/* { dg-final { scan-assembler-times \"vsplth\" 24 } } */"}]}