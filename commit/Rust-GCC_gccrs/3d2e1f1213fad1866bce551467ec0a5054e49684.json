{"sha": "3d2e1f1213fad1866bce551467ec0a5054e49684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QyZTFmMTIxM2ZhZDE4NjZiY2U1NTE0NjdlYzBhNTA1NGU0OTY4NA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-08-01T07:38:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-01T07:38:36Z"}, "message": "gnatchop.adb: Minor reformatting\n\n2008-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* gnatchop.adb: Minor reformatting\n\nFrom-SVN: r138462", "tree": {"sha": "884dc7020ed9d633483c263b851ec9576650210c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/884dc7020ed9d633483c263b851ec9576650210c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d2e1f1213fad1866bce551467ec0a5054e49684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d2e1f1213fad1866bce551467ec0a5054e49684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d2e1f1213fad1866bce551467ec0a5054e49684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d2e1f1213fad1866bce551467ec0a5054e49684/comments", "author": null, "committer": null, "parents": [{"sha": "e3a6d7372b5ff073e00749770008d818ac4f1b5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3a6d7372b5ff073e00749770008d818ac4f1b5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3a6d7372b5ff073e00749770008d818ac4f1b5c"}], "stats": {"total": 60, "additions": 27, "deletions": 33}, "files": [{"sha": "7c17beb5802fbb694d19e080f62958e1576f5f29", "filename": "gcc/ada/gnatchop.adb", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d2e1f1213fad1866bce551467ec0a5054e49684/gcc%2Fada%2Fgnatchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d2e1f1213fad1866bce551467ec0a5054e49684/gcc%2Fada%2Fgnatchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatchop.adb?ref=3d2e1f1213fad1866bce551467ec0a5054e49684", "patch": "@@ -63,9 +63,9 @@ procedure Gnatchop is\n    --  Arguments used in Gnat_Cmd call\n \n    EOF : constant Character := Character'Val (26);\n-   --  Special character to signal end of file. Not required in input\n-   --  files, but properly treated if present. Not generated in output\n-   --  files except as a result of copying input file.\n+   --  Special character to signal end of file. Not required in input files,\n+   --  but properly treated if present. Not generated in output files except\n+   --  as a result of copying input file.\n \n    --------------------\n    -- File arguments --\n@@ -152,8 +152,8 @@ procedure Gnatchop is\n       --  Index of unit in sorted unit list\n \n       Bufferg : String_Access;\n-      --  Pointer to buffer containing configuration pragmas to be\n-      --  prepended. Null if no pragmas to be prepended.\n+      --  Pointer to buffer containing configuration pragmas to be prepended.\n+      --  Null if no pragmas to be prepended.\n    end record;\n \n    --  The following table stores the unit offset information\n@@ -1018,9 +1018,9 @@ procedure Gnatchop is\n       Contents := new String (1 .. Read_Ptr);\n       Contents.all := Buffer (1 .. Read_Ptr);\n \n-      --  Things aren't simple on VMS due to the plethora of file types\n-      --  and organizations. It seems clear that there shouldn't be more\n-      --  bytes read than are contained in the file though.\n+      --  Things aren't simple on VMS due to the plethora of file types and\n+      --  organizations. It seems clear that there shouldn't be more bytes\n+      --  read than are contained in the file though.\n \n       if Hostparm.OpenVMS then\n          Success := Read_Ptr <= Length + 1;\n@@ -1249,7 +1249,6 @@ procedure Gnatchop is\n             F : constant String := File.Table (File_Num).Name.all;\n \n          begin\n-\n             if Is_Directory (F) then\n                Error_Msg (F & \" is a directory, cannot be chopped\");\n                return False;\n@@ -1277,7 +1276,6 @@ procedure Gnatchop is\n          end if;\n \n          return False;\n-\n    end Scan_Arguments;\n \n    ----------------\n@@ -1636,11 +1634,11 @@ procedure Gnatchop is\n       --  Returns in OS_Name the proper name for the OS when used with the\n       --  returned Encoding value. For example on Windows this will return the\n       --  UTF-8 encoded name into OS_Name and set Encoding to encoding=utf8\n-      --  (form parameter Stream_IO).\n+      --  (the form parameter for Stream_IO).\n+      --\n       --  Name is the filename and W_Name the same filename in Unicode 16 bits\n-      --  (this corresponds to Win32 Unicode ISO/IEC 10646). N_Length and\n-      --  E_Length are the length returned in OS_Name and Encoding\n-      --  respectively.\n+      --  (this corresponds to Win32 Unicode ISO/IEC 10646). N_Length/E_Length\n+      --  are the length returned in OS_Name/Encoding respectively.\n \n       Info     : Unit_Info renames Unit.Table (Num);\n       Name     : aliased constant String := Info.File_Name.all & ASCII.NUL;\n@@ -1676,6 +1674,7 @@ procedure Gnatchop is\n          C_Name      : aliased constant String := E_Name & ASCII.NUL;\n          OS_Encoding : constant String := Encoding (1 .. E_Length);\n          File        : Stream_IO.File_Type;\n+\n       begin\n          begin\n             if not Overwrite_Files and then Exists (E_Name) then\n@@ -1685,6 +1684,7 @@ procedure Gnatchop is\n                  (File, Stream_IO.Out_File, E_Name, OS_Encoding);\n                Success := True;\n             end if;\n+\n          exception\n             when Stream_IO.Name_Error | Stream_IO.Use_Error =>\n                Error_Msg (\"cannot create \" & Info.File_Name.all);\n@@ -1705,7 +1705,6 @@ procedure Gnatchop is\n \n          if Success and then Info.Bufferg /= null then\n             Write_Source_Reference_Pragma (Info, 1, File, EOL, Success);\n-\n             String'Write (Stream_IO.Stream (File), Info.Bufferg.all);\n          end if;\n \n@@ -1742,10 +1741,9 @@ procedure Gnatchop is\n --  Start of processing for gnatchop\n \n begin\n-   --  Add the directory where gnatchop is invoked in front of the\n-   --  path, if gnatchop is invoked with directory information.\n-   --  Only do this if the platform is not VMS, where the notion of path\n-   --  does not really exist.\n+   --  Add the directory where gnatchop is invoked in front of the path, if\n+   --  gnatchop is invoked with directory information. Only do this if the\n+   --  platform is not VMS, where the notion of path does not really exist.\n \n    if not Hostparm.OpenVMS then\n       declare\n@@ -1758,12 +1756,10 @@ begin\n                   Absolute_Dir : constant String :=\n                                    Normalize_Pathname\n                                      (Command (Command'First .. Index));\n-\n                   PATH         : constant String :=\n-                                   Absolute_Dir &\n-                  Path_Separator &\n-                  Getenv (\"PATH\").all;\n-\n+                                   Absolute_Dir\n+                                   & Path_Separator\n+                                   & Getenv (\"PATH\").all;\n                begin\n                   Setenv (\"PATH\", PATH);\n                end;\n@@ -1813,26 +1809,24 @@ begin\n \n    Sort_Units;\n \n-   --  Check if any duplicate files would be created. If so, emit\n-   --  a warning if Overwrite_Files is true, otherwise generate an error.\n+   --  Check if any duplicate files would be created. If so, emit a warning if\n+   --  Overwrite_Files is true, otherwise generate an error.\n \n    if Report_Duplicate_Units and then not Overwrite_Files then\n       goto No_Files_Written;\n    end if;\n \n-   --  Check if any files exist, if so do not write anything\n-   --  Because all files have been parsed and checked already,\n-   --  there won't be any duplicates\n+   --  Check if any files exist, if so do not write anything Because all files\n+   --  have been parsed and checked already, there won't be any duplicates\n \n    if not Overwrite_Files and then Files_Exist then\n       goto No_Files_Written;\n    end if;\n \n-   --  After this point, all source files are read in succession\n-   --  and chopped into their destination files.\n+   --  After this point, all source files are read in succession and chopped\n+   --  into their destination files.\n \n-   --  As the Source_File_Name pragmas are handled as logical file 0,\n-   --  write it first.\n+   --  Source_File_Name pragmas are handled as logical file 0 so write it first\n \n    for F in 1 .. File.Last loop\n       if not Write_Chopped_Files (F) then"}]}