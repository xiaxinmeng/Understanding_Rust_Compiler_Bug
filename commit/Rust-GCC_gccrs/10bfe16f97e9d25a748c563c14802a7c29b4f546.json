{"sha": "10bfe16f97e9d25a748c563c14802a7c29b4f546", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiZmUxNmY5N2U5ZDI1YTc0OGM1NjNjMTQ4MDJhN2MyOWI0ZjU0Ng==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2017-08-24T17:19:50Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-08-24T17:19:50Z"}, "message": "target-supports.exp: Group together target-dependant checks.\n\n\t* lib/target-supports.exp: Group together target-dependant checks.\n\nFrom-SVN: r251338", "tree": {"sha": "775ad731bf62cf1618e93724a0c650d9307b1cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/775ad731bf62cf1618e93724a0c650d9307b1cb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10bfe16f97e9d25a748c563c14802a7c29b4f546", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bfe16f97e9d25a748c563c14802a7c29b4f546", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10bfe16f97e9d25a748c563c14802a7c29b4f546", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bfe16f97e9d25a748c563c14802a7c29b4f546/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "142ff60219724cac948be5bef9fc4e6d1bfb8cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142ff60219724cac948be5bef9fc4e6d1bfb8cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/142ff60219724cac948be5bef9fc4e6d1bfb8cfb"}], "stats": {"total": 318, "additions": 165, "deletions": 153}, "files": [{"sha": "908212fcf035b0da59e3a460b1582236bb72e8e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bfe16f97e9d25a748c563c14802a7c29b4f546/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bfe16f97e9d25a748c563c14802a7c29b4f546/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10bfe16f97e9d25a748c563c14802a7c29b4f546", "patch": "@@ -1,3 +1,7 @@\n+2017-08-24  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* lib/target-supports.exp: Group together target-dependant checks.\n+\n 2017-08-24  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/81913"}, {"sha": "3ddc92ee27374e76b623619cdd76eb27aa5a1255", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 161, "deletions": 153, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10bfe16f97e9d25a748c563c14802a7c29b4f546/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10bfe16f97e9d25a748c563c14802a7c29b4f546/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=10bfe16f97e9d25a748c563c14802a7c29b4f546", "patch": "@@ -1571,30 +1571,6 @@ proc check_linker_plugin_available { } {\n   } \"-flto -fuse-linker-plugin\"]\n }\n \n-# Return 1 if the target supports executing 750CL paired-single instructions, 0\n-# otherwise.  Cache the result.\n-\n-proc check_750cl_hw_available { } {\n-    return [check_cached_effective_target 750cl_hw_available {\n-\t# If this is not the right target then we can skip the test.\n-\tif { ![istarget powerpc-*paired*] } {\n-\t    expr 0\n-\t} else {\n-\t    check_runtime_nocache 750cl_hw_available {\n-\t\t int main()\n-\t\t {\n-\t\t #ifdef __MACH__\n-\t\t   asm volatile (\"ps_mul v0,v0,v0\");\n-\t\t #else\n-\t\t   asm volatile (\"ps_mul 0,0,0\");\n-\t\t #endif\n-\t\t   return 0;\n-\t\t }\n-\t    } \"-mpaired\"\n-\t}\n-    }]\n-}\n-\n # Return 1 if the target OS supports running SSE executables, 0\n # otherwise.  Cache the result.\n \n@@ -1635,7 +1611,7 @@ proc check_avx_os_support_available { } {\n \t\t  unsigned int eax, edx;\n \n \t\t  asm (\"xgetbv\" : \"=a\" (eax), \"=d\" (edx) : \"c\" (0));\n-\t\t  return (eax & 6) != 6;\n+\t\t  return (eax & 0x06) != 0x06;\n \t\t}\n \t    } \"\"\n \t}\n@@ -1679,92 +1655,16 @@ proc check_sse_hw_available { } {\n \t\tint main ()\n \t\t{\n \t\t  unsigned int eax, ebx, ecx, edx;\n-\t\t  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n-\t\t    return !(edx & bit_SSE);\n-\t\t  return 1;\n-\t\t}\n-\t    } \"\"\n-\t}\n-    }]\n-}\n-\n-# Return 1 if the target supports executing MIPS Paired-Single instructions,\n-# 0 otherwise.  Cache the result.\n-\n-proc check_mpaired_single_hw_available { } {\n-    return [check_cached_effective_target mpaired_single_hw_available {\n-\t# If this is not the right target then we can skip the test.\n-\tif { !([istarget mips*-*-*]) } {\n-\t    expr 0\n-\t} else {\n-\t    check_runtime_nocache mpaired_single_hw_available {\n-\t      int main()\n-\t      {\n-\t\tasm volatile (\"pll.ps $f2,$f4,$f6\");\n-\t\treturn 0;\n-\t      }\n-\t    } \"\"\n-\t}\n-    }]\n-}\n-\n-# Return 1 if the target supports executing Loongson vector instructions,\n-# 0 otherwise.  Cache the result.\n+\t\t  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+\t\t    return 1;\n \n-proc check_mips_loongson_hw_available { } {\n-    return [check_cached_effective_target mips_loongson_hw_available {\n-\t# If this is not the right target then we can skip the test.\n-\tif { !([istarget mips*-*-*]) } {\n-\t    expr 0\n-\t} else {\n-\t    check_runtime_nocache mips_loongson_hw_available {\n-\t      #include <loongson.h>\n-\t      int main()\n-\t      {\n-\t\tasm volatile (\"paddw $f2,$f4,$f6\");\n-\t\treturn 0;\n-\t      }\n+\t\t  return !(edx & bit_SSE);\n+\t\t}\n \t    } \"\"\n \t}\n     }]\n }\n \n-# Return 1 if the target supports executing MIPS MSA instructions, 0\n-# otherwise.  Cache the result.\n-\n-proc check_mips_msa_hw_available { } {\n-  return [check_cached_effective_target mips_msa_hw_available {\n-    # If this is not the right target then we can skip the test.\n-    if { !([istarget mips*-*-*]) } {\n-      expr 0\n-    } else {\n-      check_runtime_nocache mips_msa_hw_available {\n-\t#if !defined(__mips_msa)\n-\t#error \"MSA NOT AVAIL\"\n-\t#else\n-\t#if !(((__mips == 64) || (__mips == 32)) && (__mips_isa_rev >= 2))\n-\t#error \"MSA NOT AVAIL FOR ISA REV < 2\"\n-\t#endif\n-\t#if !defined(__mips_hard_float)\n-\t#error \"MSA HARD_FLOAT REQUIRED\"\n-\t#endif\n-\t#if __mips_fpr != 64\n-\t#error \"MSA 64-bit FPR REQUIRED\"\n-\t#endif\n-\t#include <msa.h>\n-\n-\tint main()\n-\t{\n-\t  v8i16 v = __builtin_msa_ldi_h (0);\n-\t  v[0] = 0;\n-\t  return v[0];\n-\t}\n-\t#endif\n-      } \"-mmsa\"\n-    }\n-  }]\n-}\n-\n # Return 1 if the target supports executing SSE2 instructions, 0\n # otherwise.  Cache the result.\n \n@@ -1779,9 +1679,10 @@ proc check_sse2_hw_available { } {\n \t\tint main ()\n \t\t{\n \t\t  unsigned int eax, ebx, ecx, edx;\n-\t\t  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n-\t\t    return !(edx & bit_SSE2);\n-\t\t  return 1;\n+\t\t  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+\t\t    return 1;\n+\n+\t\t  return !(edx & bit_SSE2);\n \t\t}\n \t    } \"\"\n \t}\n@@ -1802,9 +1703,10 @@ proc check_sse4_hw_available { } {\n \t\tint main ()\n \t\t{\n \t\t  unsigned int eax, ebx, ecx, edx;\n-\t\t  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n-\t\t    return !(ecx & bit_SSE4_2);\n-\t\t  return 1;\n+\t\t  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+\t\t    return 1;\n+\n+\t\t  return !(ecx & bit_SSE4_2);\n \t\t}\n \t    } \"\"\n \t}\n@@ -1825,10 +1727,11 @@ proc check_avx_hw_available { } {\n \t\tint main ()\n \t\t{\n \t\t  unsigned int eax, ebx, ecx, edx;\n-\t\t  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n-\t\t    return ((ecx & (bit_AVX | bit_OSXSAVE))\n-\t\t\t    != (bit_AVX | bit_OSXSAVE));\n-\t\t  return 1;\n+\t\t  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))\n+\t\t    return 1;\n+\n+\t\t  return ((ecx & (bit_AVX | bit_OSXSAVE))\n+\t\t\t  != (bit_AVX | bit_OSXSAVE));\n \t\t}\n \t    } \"\"\n \t}\n@@ -1850,16 +1753,18 @@ proc check_avx2_hw_available { } {\n \t\tint main ()\n \t\t{\n \t\t  unsigned int eax, ebx, ecx, edx;\n-\t\t  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx)\n-\t\t      || ((ecx & bit_OSXSAVE) != bit_OSXSAVE))\n-\t\t    return 1;\n \n \t\t  if (__get_cpuid_max (0, NULL) < 7)\n \t\t    return 1;\n \n+\t\t  __cpuid (1, eax, ebx, ecx, edx);\n+\n+\t\t  if (!(ecx & bit_OSXSAVE))\n+\t\t    return 1;\n+\n \t\t  __cpuid_count (7, 0, eax, ebx, ecx, edx);\n \n-\t\t  return (ebx & bit_AVX2) != bit_AVX2;\n+\t\t  return !(ebx & bit_AVX2);\n \t\t}\n \t    } \"\"\n \t}\n@@ -1881,13 +1786,15 @@ proc check_avx512f_hw_available { } {\n \t\tint main ()\n \t\t{\n \t\t  unsigned int eax, ebx, ecx, edx;\n-\t\t  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx)\n-\t\t      || !(ecx & bit_OSXSAVE))\n-\t\t    return 1;\n \n \t\t  if (__get_cpuid_max (0, NULL) < 7)\n \t\t    return 1;\n \n+\t\t  __cpuid (1, eax, ebx, ecx, edx);\n+\n+\t\t  if (!(ecx & bit_OSXSAVE))\n+\t\t    return 1;\n+\n \t\t  __cpuid_count (7, 0, eax, ebx, ecx, edx);\n \n \t\t  return !(ebx & bit_AVX512F);\n@@ -1930,37 +1837,6 @@ proc check_effective_target_sse4_runtime { } {\n     return 0\n }\n \n-# Return 1 if the target supports running MIPS Paired-Single\n-# executables, 0 otherwise.\n-\n-proc check_effective_target_mpaired_single_runtime { } {\n-    if { [check_effective_target_mpaired_single]\n-\t && [check_mpaired_single_hw_available] } {\n-\treturn 1\n-    }\n-    return 0\n-}\n-\n-# Return 1 if the target supports running Loongson executables, 0 otherwise.\n-\n-proc check_effective_target_mips_loongson_runtime { } {\n-    if { [check_effective_target_mips_loongson]\n-\t && [check_mips_loongson_hw_available] } {\n-\treturn 1\n-    }\n-    return 0\n-}\n-\n-# Return 1 if the target supports running MIPS MSA executables, 0 otherwise.\n-\n-proc check_effective_target_mips_msa_runtime { } {\n-  if { [check_effective_target_mips_msa]\n-       && [check_mips_msa_hw_available] } {\n-    return 1\n-  }\n-  return 0\n-}\n-\n # Return 1 if the target supports running AVX executables, 0 otherwise.\n \n proc check_effective_target_avx_runtime { } {\n@@ -1994,6 +1870,114 @@ proc check_effective_target_avx512f_runtime { } {\n     return 0\n }\n \n+# Return 1 if the target supports executing MIPS Paired-Single instructions,\n+# 0 otherwise.  Cache the result.\n+\n+proc check_mpaired_single_hw_available { } {\n+    return [check_cached_effective_target mpaired_single_hw_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { !([istarget mips*-*-*]) } {\n+\t    expr 0\n+\t} else {\n+\t    check_runtime_nocache mpaired_single_hw_available {\n+\t      int main()\n+\t      {\n+\t\tasm volatile (\"pll.ps $f2,$f4,$f6\");\n+\t\treturn 0;\n+\t      }\n+\t    } \"\"\n+\t}\n+    }]\n+}\n+\n+# Return 1 if the target supports executing Loongson vector instructions,\n+# 0 otherwise.  Cache the result.\n+\n+proc check_mips_loongson_hw_available { } {\n+    return [check_cached_effective_target mips_loongson_hw_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { !([istarget mips*-*-*]) } {\n+\t    expr 0\n+\t} else {\n+\t    check_runtime_nocache mips_loongson_hw_available {\n+\t      #include <loongson.h>\n+\t      int main()\n+\t      {\n+\t\tasm volatile (\"paddw $f2,$f4,$f6\");\n+\t\treturn 0;\n+\t      }\n+\t    } \"\"\n+\t}\n+    }]\n+}\n+\n+# Return 1 if the target supports executing MIPS MSA instructions, 0\n+# otherwise.  Cache the result.\n+\n+proc check_mips_msa_hw_available { } {\n+  return [check_cached_effective_target mips_msa_hw_available {\n+    # If this is not the right target then we can skip the test.\n+    if { !([istarget mips*-*-*]) } {\n+      expr 0\n+    } else {\n+      check_runtime_nocache mips_msa_hw_available {\n+\t#if !defined(__mips_msa)\n+\t#error \"MSA NOT AVAIL\"\n+\t#else\n+\t#if !(((__mips == 64) || (__mips == 32)) && (__mips_isa_rev >= 2))\n+\t#error \"MSA NOT AVAIL FOR ISA REV < 2\"\n+\t#endif\n+\t#if !defined(__mips_hard_float)\n+\t#error \"MSA HARD_FLOAT REQUIRED\"\n+\t#endif\n+\t#if __mips_fpr != 64\n+\t#error \"MSA 64-bit FPR REQUIRED\"\n+\t#endif\n+\t#include <msa.h>\n+\n+\tint main()\n+\t{\n+\t  v8i16 v = __builtin_msa_ldi_h (0);\n+\t  v[0] = 0;\n+\t  return v[0];\n+\t}\n+\t#endif\n+      } \"-mmsa\"\n+    }\n+  }]\n+}\n+\n+# Return 1 if the target supports running MIPS Paired-Single\n+# executables, 0 otherwise.\n+\n+proc check_effective_target_mpaired_single_runtime { } {\n+    if { [check_effective_target_mpaired_single]\n+\t && [check_mpaired_single_hw_available] } {\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n+# Return 1 if the target supports running Loongson executables, 0 otherwise.\n+\n+proc check_effective_target_mips_loongson_runtime { } {\n+    if { [check_effective_target_mips_loongson]\n+\t && [check_mips_loongson_hw_available] } {\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n+# Return 1 if the target supports running MIPS MSA executables, 0 otherwise.\n+\n+proc check_effective_target_mips_msa_runtime { } {\n+  if { [check_effective_target_mips_msa]\n+       && [check_mips_msa_hw_available] } {\n+    return 1\n+  }\n+  return 0\n+}\n+\n # Return 1 if we are compiling for 64-bit PowerPC but we do not use direct\n # move instructions for moves from GPR to FPR.\n \n@@ -2038,6 +2022,30 @@ proc check_ppc_cpu_supports_hw_available { } {\n     }]\n }\n \n+# Return 1 if the target supports executing 750CL paired-single instructions, 0\n+# otherwise.  Cache the result.\n+\n+proc check_750cl_hw_available { } {\n+    return [check_cached_effective_target 750cl_hw_available {\n+\t# If this is not the right target then we can skip the test.\n+\tif { ![istarget powerpc-*paired*] } {\n+\t    expr 0\n+\t} else {\n+\t    check_runtime_nocache 750cl_hw_available {\n+\t\t int main()\n+\t\t {\n+\t\t #ifdef __MACH__\n+\t\t   asm volatile (\"ps_mul v0,v0,v0\");\n+\t\t #else\n+\t\t   asm volatile (\"ps_mul 0,0,0\");\n+\t\t #endif\n+\t\t   return 0;\n+\t\t }\n+\t    } \"-mpaired\"\n+\t}\n+    }]\n+}\n+\n # Return 1 if the target supports executing power8 vector instructions, 0\n # otherwise.  Cache the result.\n "}]}