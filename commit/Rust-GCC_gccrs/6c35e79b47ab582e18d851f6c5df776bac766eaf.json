{"sha": "6c35e79b47ab582e18d851f6c5df776bac766eaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMzNWU3OWI0N2FiNTgyZTE4ZDg1MWY2YzVkZjc3NmJhYzc2NmVhZg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-02-24T15:16:23Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-02-24T15:16:23Z"}, "message": "slp: fix accidental resource re-use of slp_tree (PR99220)\n\nThe attached testcase shows a bug where two nodes end up with the same pointer.\nDuring the loop that analyzes all the instances\nin optimize_load_redistribution_1 we do\n\n      if (value)\n        {\n          SLP_TREE_REF_COUNT (value)++;\n          SLP_TREE_CHILDREN (root)[i] = value;\n          vect_free_slp_tree (node);\n        }\n\nwhen doing a replacement.  When this is done and the refcount for the node\nreaches 0, the node is removed, which allows the libc to return the pointer\nagain in the next call to new, which it does..\n\nFirst instance\n\nnote:   node 0x5325f48 (max_nunits=1, refcnt=2)\nnote:   op: VEC_PERM_EXPR\nnote:           { }\nnote:           lane permutation { 0[0] 1[1] 0[2] 1[3] }\nnote:           children 0x5325db0 0x5325200\n\nSecond instance\n\nnote:   node 0x5325f48 (max_nunits=1, refcnt=1)\nnote:   op: VEC_PERM_EXPR\nnote:           { }\nnote:           lane permutation { 0[0] 1[1] }\nnote:           children 0x53255b8 0x5325530\n\nThis will end up with the illegal construction of\n\nnote:   node 0x53258e8 (max_nunits=2, refcnt=2)\nnote:   op template: slp_patt_57 = .COMPLEX_MUL (_16, _16);\nnote:           stmt 0 _16 = _14 - _15;\nnote:           stmt 1 _23 = _17 + _22;\nnote:           children 0x53257d8 0x5325d28\nnote:   node 0x53257d8 (max_nunits=2, refcnt=3)\nnote:   op template: l$b_4 = MEM[(const struct a &)_3].b;\nnote:           stmt 0 l$b_4 = MEM[(const struct a &)_3].b;\nnote:           stmt 1 l$c_5 = MEM[(const struct a &)_3].c;\nnote:           load permutation { 0 1 }\nnote:   node 0x5325d28 (max_nunits=2, refcnt=8)\nnote:   op template: l$b_4 = MEM[(const struct a &)_3].b;\nnote:           stmt 0 l$b_4 = MEM[(const struct a &)_3].b;\nnote:           stmt 1 l$c_5 = MEM[(const struct a &)_3].c;\nnote:           stmt 2 l$b_4 = MEM[(const struct a &)_3].b;\nnote:           stmt 3 l$c_5 = MEM[(const struct a &)_3].c;\nnote:           load permutation { 0 1 0 1 }\n\nTo prevent this we remove the node from the load_map if it's\nabout to be deleted.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/99220\n\t* tree-vect-slp.c (optimize_load_redistribution_1): Remove\n\tnode from cache when it's about to be deleted.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/99220\n\t* g++.dg/vect/pr99220.cc: New test.", "tree": {"sha": "da2dfd4ef7eefdae3ad54ac60d77ed616d9ee263", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da2dfd4ef7eefdae3ad54ac60d77ed616d9ee263"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c35e79b47ab582e18d851f6c5df776bac766eaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c35e79b47ab582e18d851f6c5df776bac766eaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c35e79b47ab582e18d851f6c5df776bac766eaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c35e79b47ab582e18d851f6c5df776bac766eaf/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96c5a8589e0dd22819bae34cac3381ad381d3989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96c5a8589e0dd22819bae34cac3381ad381d3989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96c5a8589e0dd22819bae34cac3381ad381d3989"}], "stats": {"total": 41, "additions": 41, "deletions": 0}, "files": [{"sha": "b41b2d4f0ee401732073321645f3f1f958da842d", "filename": "gcc/testsuite/g++.dg/vect/pr99220.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c35e79b47ab582e18d851f6c5df776bac766eaf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99220.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c35e79b47ab582e18d851f6c5df776bac766eaf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99220.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99220.cc?ref=6c35e79b47ab582e18d851f6c5df776bac766eaf", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target { aarch64*-*-* } } } */\n+/* { dg-additional-options \"-w -O3 -march=armv8.3-a\" } */\n+\n+class a {\n+  float b;\n+  float c;\n+\n+public:\n+  a(float d, float e) : b(d), c(e) {}\n+  a operator+(a d) { return a(b + d.b, c + d.c); }\n+  a operator-(a d) { return a(b - d.b, c - d.c); }\n+  a operator*(a d) { return a(b * b - c * c, b * c + c * d.b); }\n+};\n+long f;\n+a *g;\n+class {\n+  a *h;\n+  long i;\n+  a *j;\n+\n+public:\n+  void k() {\n+    a l = h[0], m = g[i], n = l * g[1], o = l * j[8];\n+    g[i] = m + n;\n+    g[i + 1] = m - n;\n+    j[f] = o;\n+  }\n+} p;\n+main() { p.k(); }"}, {"sha": "c55c01a4a94d4479ce75b8301a70125e5e4728da", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c35e79b47ab582e18d851f6c5df776bac766eaf/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c35e79b47ab582e18d851f6c5df776bac766eaf/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6c35e79b47ab582e18d851f6c5df776bac766eaf", "patch": "@@ -2351,6 +2351,12 @@ optimize_load_redistribution_1 (scalar_stmts_to_slp_tree_map_t *bst_map,\n \t{\n \t  SLP_TREE_REF_COUNT (value)++;\n \t  SLP_TREE_CHILDREN (root)[i] = value;\n+\t  /* ???  We know the original leafs of the replaced nodes will\n+\t    be referenced by bst_map, only the permutes created by\n+\t  pattern matching are not.  */\n+\t  if (SLP_TREE_REF_COUNT (node) == 1)\n+\t    load_map->remove (node);\n+\n \t  vect_free_slp_tree (node);\n \t}\n     }\n@@ -2383,6 +2389,12 @@ optimize_load_redistribution (scalar_stmts_to_slp_tree_map_t *bst_map,\n \t{\n \t  SLP_TREE_REF_COUNT (value)++;\n \t  SLP_TREE_CHILDREN (root)[i] = value;\n+\t  /* ???  We know the original leafs of the replaced nodes will\n+\t     be referenced by bst_map, only the permutes created by\n+\t     pattern matching are not.  */\n+\t  if (SLP_TREE_REF_COUNT (node) == 1)\n+\t    load_map->remove (node);\n+\n \t  vect_free_slp_tree (node);\n \t}\n     }"}]}