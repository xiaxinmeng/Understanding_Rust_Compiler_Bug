{"sha": "cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q5YzFjYTg2NmI2YWE1MDQxYTM1MmUwZWQwN2FlNWY5MWUyMzVlNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-05-30T00:33:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-05-30T00:33:46Z"}, "message": "cfgcleanup.c (try_crossjump_to_edge): Only skip past NOTE_INSN_BASIC_BLOCK.\n\n\t* cfgcleanup.c (try_crossjump_to_edge): Only skip past\n\tNOTE_INSN_BASIC_BLOCK.\n\t* cfglayout.c (duplicate_insn_chain): Copy epilogue insn marks.\n\tDuplicate NOTE_INSN_EPILOGUE_BEG notes.\n\t* cfgrtl.c (can_delete_note_p): Allow NOTE_INSN_EPILOGUE_BEG\n\tto be deleted.\n\t* dwarf2out.c (struct cfa_loc): Change indirect field to bitfield,\n\tadd in_use field.\n\t(add_cfi): Disable check redefining cfa away from drap.\n\t(lookup_cfa_1): Add remember argument; handle remember/restore.\n\t(lookup_cfa): Pass remember argument.\n\t(cfa_remember): New.\n\t(compute_barrier_args_size_1): Remove sibcall check.\n\t(dwarf2out_frame_debug_def_cfa): New.\n\t(dwarf2out_frame_debug_adjust_cfa): New.\n\t(dwarf2out_frame_debug_cfa_offset): New.\n\t(dwarf2out_frame_debug_cfa_register): New.\n\t(dwarf2out_frame_debug_cfa_restore): New.\n\t(dwarf2out_frame_debug): Handle REG_CFA_* notes.\n\t(dwarf2out_begin_epilogue): New.\n\t(dwarf2out_frame_debug_restore_state): New.\n\t(dw_cfi_oprnd1_desc): Handle DW_CFA_remember_state,\n\tDW_CFA_restore_state.\n\t(output_cfi_directive): Likewise.\n\t(convert_cfa_to_fb_loc_list): Likewise.\n\t(dw_cfi_oprnd1_desc): Handle DW_CFA_restore.\n\t* dwarf2out.h: Update.\n\t* emit-rtl.c (try_split): Don't split RTX_FRAME_RELATED_P.\n\t(copy_insn_1): Early out for null.\n\t* final.c (final_scan_insn): Call dwarf2out_begin_epilogue\n\tand dwarf2out_frame_debug_restore_state.\n\t* function.c (prologue, epilogue, sibcall_epilogue): Remove.\n\t(prologue_insn_hash, epilogue_insn_hash): New.\n\t(free_after_compilation): Adjust freeing accordingly.\n\t(record_insns): Create hash table if needed; push insns into\n\thash instead of array.\n\t(maybe_copy_epilogue_insn): New.\n\t(contains): Search hash table instead of array.\n\t(sibcall_epilogue_contains): Remove.\n\t(thread_prologue_and_epilogue_insns): Split eh_return insns\n\tand mark them as epilogues.\n\t(reposition_prologue_and_epilogue_notes): Rewrite epilogue\n\tscanning in terms of basic blocks.\n\t* insn-notes.def (CFA_RESTORE_STATE): New.\n\t* jump.c (returnjump_p_1): Accept EH_RETURN.\n\t(eh_returnjump_p_1, eh_returnjump_p): New.\n\t* reg-notes.def (CFA_DEF_CFA, CFA_ADJUST_CFA, CFA_OFFSET,\n\tCFA_REGISTER, CFA_RESTORE): New.\n\t* rtl.def (EH_RETURN): New.\n\t* rtl.h (eh_returnjump_p, maybe_copy_epilogue_insn): Declare.\n\n\t* config/bfin/bfin.md (UNSPEC_VOLATILE_EH_RETURN): Remove.\n\t(eh_return_internal): Use eh_return rtx; split w/ epilogue.\n\n\t* config/i386/i386.c (gen_push): Update cfa state.\n\t(pro_epilogue_adjust_stack): Add set_cfa argument.  When true,\n\tadd a CFA_ADJUST_CFA note.\n\t(ix86_dwarf_handle_frame_unspec): Remove.\n\t(ix86_expand_prologue): Update cfa state.\n\t(ix86_emit_restore_reg_using_pop): New.\n\t(ix86_emit_restore_regs_using_pop): New.\n\t(ix86_emit_leave): New.\n\t(ix86_emit_restore_regs_using_mov): Add CFA_RESTORE notes.\n\t(ix86_expand_epilogue): Add notes for unwinding the epilogue.\n\t* config/i386/i386.h (struct machine_cfa_state): New.\n\t(ix86_cfa_state): New.\n\t* config/i386/i386.md (UNSPEC_EH_RETURN): Remove.\n\t(eh_return_internal): Merge from eh_return_<mode>,\n\tuse eh_return rtx, split w/ epilogue.\n\nFrom-SVN: r147995", "tree": {"sha": "f977a6cde3ef60ef5e2fd7e916cfad3c81f71215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f977a6cde3ef60ef5e2fd7e916cfad3c81f71215"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/comments", "author": null, "committer": null, "parents": [{"sha": "36bac386ae2339359ebcee2473192c4171c5c7df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36bac386ae2339359ebcee2473192c4171c5c7df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36bac386ae2339359ebcee2473192c4171c5c7df"}], "stats": {"total": 1165, "additions": 926, "deletions": 239}, "files": [{"sha": "db9a447ec459f5b88527fe3feb45185604abc220", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -1,3 +1,75 @@\n+2009-05-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* cfgcleanup.c (try_crossjump_to_edge): Only skip past\n+\tNOTE_INSN_BASIC_BLOCK.\n+\t* cfglayout.c (duplicate_insn_chain): Copy epilogue insn marks.\n+\tDuplicate NOTE_INSN_EPILOGUE_BEG notes.\n+\t* cfgrtl.c (can_delete_note_p): Allow NOTE_INSN_EPILOGUE_BEG\n+\tto be deleted.\n+\t* dwarf2out.c (struct cfa_loc): Change indirect field to bitfield,\n+\tadd in_use field.\n+\t(add_cfi): Disable check redefining cfa away from drap.\n+\t(lookup_cfa_1): Add remember argument; handle remember/restore.\n+\t(lookup_cfa): Pass remember argument.\n+\t(cfa_remember): New.\n+\t(compute_barrier_args_size_1): Remove sibcall check.\n+\t(dwarf2out_frame_debug_def_cfa): New.\n+\t(dwarf2out_frame_debug_adjust_cfa): New.\n+\t(dwarf2out_frame_debug_cfa_offset): New.\n+\t(dwarf2out_frame_debug_cfa_register): New.\n+\t(dwarf2out_frame_debug_cfa_restore): New.\n+\t(dwarf2out_frame_debug): Handle REG_CFA_* notes.\n+\t(dwarf2out_begin_epilogue): New.\n+\t(dwarf2out_frame_debug_restore_state): New.\n+\t(dw_cfi_oprnd1_desc): Handle DW_CFA_remember_state,\n+\tDW_CFA_restore_state.\n+\t(output_cfi_directive): Likewise.\n+\t(convert_cfa_to_fb_loc_list): Likewise.\n+\t(dw_cfi_oprnd1_desc): Handle DW_CFA_restore.\n+\t* dwarf2out.h: Update.\n+\t* emit-rtl.c (try_split): Don't split RTX_FRAME_RELATED_P.\n+\t(copy_insn_1): Early out for null.\n+\t* final.c (final_scan_insn): Call dwarf2out_begin_epilogue\n+\tand dwarf2out_frame_debug_restore_state.\n+\t* function.c (prologue, epilogue, sibcall_epilogue): Remove.\n+\t(prologue_insn_hash, epilogue_insn_hash): New.\n+\t(free_after_compilation): Adjust freeing accordingly.\n+\t(record_insns): Create hash table if needed; push insns into\n+\thash instead of array.\n+\t(maybe_copy_epilogue_insn): New.\n+\t(contains): Search hash table instead of array.\n+\t(sibcall_epilogue_contains): Remove.\n+\t(thread_prologue_and_epilogue_insns): Split eh_return insns\n+\tand mark them as epilogues.\n+\t(reposition_prologue_and_epilogue_notes): Rewrite epilogue\n+\tscanning in terms of basic blocks.\n+\t* insn-notes.def (CFA_RESTORE_STATE): New.\n+\t* jump.c (returnjump_p_1): Accept EH_RETURN.\n+\t(eh_returnjump_p_1, eh_returnjump_p): New.\n+\t* reg-notes.def (CFA_DEF_CFA, CFA_ADJUST_CFA, CFA_OFFSET,\n+\tCFA_REGISTER, CFA_RESTORE): New.\n+\t* rtl.def (EH_RETURN): New.\n+\t* rtl.h (eh_returnjump_p, maybe_copy_epilogue_insn): Declare.\n+\n+\t* config/bfin/bfin.md (UNSPEC_VOLATILE_EH_RETURN): Remove.\n+\t(eh_return_internal): Use eh_return rtx; split w/ epilogue.\n+\n+\t* config/i386/i386.c (gen_push): Update cfa state.\n+\t(pro_epilogue_adjust_stack): Add set_cfa argument.  When true,\n+\tadd a CFA_ADJUST_CFA note.\n+\t(ix86_dwarf_handle_frame_unspec): Remove.\n+\t(ix86_expand_prologue): Update cfa state.\n+\t(ix86_emit_restore_reg_using_pop): New.\n+\t(ix86_emit_restore_regs_using_pop): New.\n+\t(ix86_emit_leave): New.\n+\t(ix86_emit_restore_regs_using_mov): Add CFA_RESTORE notes.\n+\t(ix86_expand_epilogue): Add notes for unwinding the epilogue.\n+\t* config/i386/i386.h (struct machine_cfa_state): New.\n+\t(ix86_cfa_state): New.\n+\t* config/i386/i386.md (UNSPEC_EH_RETURN): Remove.\n+\t(eh_return_internal): Merge from eh_return_<mode>,\n+\tuse eh_return rtx, split w/ epilogue.\n+\n 2009-05-29  Ian Lance Taylor  <iant@google.com>\n \n \t* builtins.c (validate_gimple_arglist): Don't use va_arg with"}, {"sha": "8da967a4ee0efa4efc68941b6ae8c54814d64ad6", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -1672,8 +1672,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   /* Skip possible basic block header.  */\n   if (LABEL_P (newpos1))\n     newpos1 = NEXT_INSN (newpos1);\n-\n-  if (NOTE_P (newpos1))\n+  if (NOTE_INSN_BASIC_BLOCK_P (newpos1))\n     newpos1 = NEXT_INSN (newpos1);\n \n   redirect_from = split_block (src1, PREV_INSN (newpos1))->src;"}, {"sha": "d93b84542fc5f150f31065f99f0bbe907b5b0b71", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -1112,7 +1112,7 @@ cfg_layout_can_duplicate_bb_p (const_basic_block bb)\n rtx\n duplicate_insn_chain (rtx from, rtx to)\n {\n-  rtx insn, last;\n+  rtx insn, last, copy;\n \n   /* Avoid updating of boundaries of previous basic block.  The\n      note will get removed from insn stream in fixup.  */\n@@ -1133,7 +1133,8 @@ duplicate_insn_chain (rtx from, rtx to)\n \t  if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n \t    break;\n-\t  emit_copy_of_insn_after (insn, get_last_insn ());\n+\t  copy = emit_copy_of_insn_after (insn, get_last_insn ());\n+          maybe_copy_epilogue_insn (insn, copy);\n \t  break;\n \n \tcase CODE_LABEL:\n@@ -1153,23 +1154,18 @@ duplicate_insn_chain (rtx from, rtx to)\n \t    case NOTE_INSN_DELETED:\n \t    case NOTE_INSN_DELETED_LABEL:\n \t      /* No problem to strip these.  */\n-\t    case NOTE_INSN_EPILOGUE_BEG:\n-\t      /* Debug code expect these notes to exist just once.\n-\t\t Keep them in the master copy.\n-\t\t ??? It probably makes more sense to duplicate them for each\n-\t\t epilogue copy.  */\n \t    case NOTE_INSN_FUNCTION_BEG:\n \t      /* There is always just single entry to function.  */\n \t    case NOTE_INSN_BASIC_BLOCK:\n \t      break;\n \n+\t    case NOTE_INSN_EPILOGUE_BEG:\n \t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t      emit_note_copy (insn);\n \t      break;\n \n \t    default:\n-\t      /* All other notes should have already been eliminated.\n-\t       */\n+\t      /* All other notes should have already been eliminated.  */\n \t      gcc_unreachable ();\n \t    }\n \t  break;"}, {"sha": "040d4184e61423b75254b25d7b22aea01c222918", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -86,8 +86,16 @@ static void rtl_make_forwarder_block (edge);\n static int\n can_delete_note_p (const_rtx note)\n {\n-  return (NOTE_KIND (note) == NOTE_INSN_DELETED\n-\t  || NOTE_KIND (note) == NOTE_INSN_BASIC_BLOCK);\n+  switch (NOTE_KIND (note))\n+    {\n+    case NOTE_INSN_DELETED:\n+    case NOTE_INSN_BASIC_BLOCK:\n+    case NOTE_INSN_EPILOGUE_BEG:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n }\n \n /* True if a given label can be deleted.  */"}, {"sha": "a3638700a53b8e42b0cbc58b698d82556e000e9e", "filename": "gcc/config/bfin/bfin.md", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fconfig%2Fbfin%2Fbfin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fconfig%2Fbfin%2Fbfin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.md?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -141,8 +141,7 @@\n    (UNSPEC_ONES 12)])\n \n (define_constants\n-  [(UNSPEC_VOLATILE_EH_RETURN 0)\n-   (UNSPEC_VOLATILE_CSYNC 1)\n+  [(UNSPEC_VOLATILE_CSYNC 1)\n    (UNSPEC_VOLATILE_SSYNC 2)\n    (UNSPEC_VOLATILE_LOAD_FUNCDESC 3)\n    (UNSPEC_VOLATILE_STORE_EH_HANDLER 4)\n@@ -2573,8 +2572,7 @@\n   \"bfin_expand_epilogue (0, 0, 1); DONE;\")\n \n (define_expand \"eh_return\"\n-  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"\")]\n-\t\t    UNSPEC_VOLATILE_EH_RETURN)]\n+  [(use (match_operand:SI 0 \"register_operand\" \"\"))]\n   \"\"\n {\n   emit_insn (gen_eh_store_handler (EH_RETURN_HANDLER_RTX, operands[0]));\n@@ -2592,11 +2590,10 @@\n   [(set_attr \"type\" \"mcst\")])\n \n (define_insn_and_split \"eh_return_internal\"\n-  [(set (pc)\n-\t(unspec_volatile [(reg:SI REG_P2)] UNSPEC_VOLATILE_EH_RETURN))]\n+  [(eh_return)]\n   \"\"\n   \"#\"\n-  \"reload_completed\"\n+  \"epilogue_completed\"\n   [(const_int 1)]\n   \"bfin_expand_epilogue (1, 1, 0); DONE;\")\n "}, {"sha": "bf7fa0ce3bab2c86f7c01e4e5cefd71f568f92d9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 232, "deletions": 76, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -7609,6 +7609,9 @@ output_set_got (rtx dest, rtx label ATTRIBUTE_UNUSED)\n static rtx\n gen_push (rtx arg)\n {\n+  if (ix86_cfa_state->reg == stack_pointer_rtx)\n+    ix86_cfa_state->offset += UNITS_PER_WORD;\n+\n   return gen_rtx_SET (VOIDmode,\n \t\t      gen_rtx_MEM (Pmode,\n \t\t\t\t   gen_rtx_PRE_DEC (Pmode,\n@@ -7668,8 +7671,7 @@ ix86_save_reg (unsigned int regno, int maybe_eh_return)\n \t}\n     }\n \n-  if (crtl->drap_reg\n-      && regno == REGNO (crtl->drap_reg))\n+  if (crtl->drap_reg && regno == REGNO (crtl->drap_reg))\n     return 1;\n \n   return (df_regs_ever_live_p (regno)\n@@ -8005,7 +8007,8 @@ ix86_emit_save_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n    otherwise.  */\n \n static void\n-pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset, int style)\n+pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n+\t\t\t   int style, bool set_cfa)\n {\n   rtx insn;\n \n@@ -8023,13 +8026,23 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset, int style)\n       gcc_assert (style);\n       r11 = gen_rtx_REG (DImode, R11_REG);\n       insn = emit_insn (gen_rtx_SET (DImode, r11, offset));\n-      if (style < 0)\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n       insn = emit_insn (gen_pro_epilogue_adjust_stack_rex64_2 (dest, src, r11,\n \t\t\t\t\t\t\t       offset));\n     }\n-  if (style < 0)\n-    RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  if (set_cfa)\n+    {\n+      rtx r;\n+\n+      gcc_assert (ix86_cfa_state->reg == src);\n+      ix86_cfa_state->offset += INTVAL (offset);\n+      ix86_cfa_state->reg = dest;\n+    \n+      r = gen_rtx_PLUS (Pmode, src, offset);\n+      r = gen_rtx_SET (VOIDmode, dest, r);\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, r);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n }\n \n /* Find an available register to be used as dynamic realign argument\n@@ -8164,30 +8177,6 @@ ix86_internal_arg_pointer (void)\n   return virtual_incoming_args_rtx;\n }\n \n-/* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.\n-   This is called from dwarf2out.c to emit call frame instructions\n-   for frame-related insns containing UNSPECs and UNSPEC_VOLATILEs. */\n-static void\n-ix86_dwarf_handle_frame_unspec (const char *label, rtx pattern, int index)\n-{\n-  rtx unspec = SET_SRC (pattern);\n-  gcc_assert (GET_CODE (unspec) == UNSPEC);\n-\n-  switch (index)\n-    {\n-    case UNSPEC_REG_SAVE:\n-      dwarf2out_reg_save_reg (label, XVECEXP (unspec, 0, 0),\n-\t\t\t      SET_DEST (pattern));\n-      break;\n-    case UNSPEC_DEF_CFA:\n-      dwarf2out_def_cfa (label, REGNO (SET_DEST (pattern)),\n-\t\t\t INTVAL (XVECEXP (unspec, 0, 0)));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n /* Finalize stack_realign_needed flag, which will guide prologue/epilogue\n    to be generated in correct form.  */\n static void \n@@ -8231,6 +8220,10 @@ ix86_expand_prologue (void)\n   /* DRAP should not coexist with stack_realign_fp */\n   gcc_assert (!(crtl->drap_reg && stack_realign_fp));\n \n+  /* Initialize CFA state for before the prologue.  */\n+  ix86_cfa_state->reg = stack_pointer_rtx;\n+  ix86_cfa_state->offset = INCOMING_FRAME_SP_OFFSET;\n+\n   ix86_compute_frame_layout (&frame);\n \n   /* Emit prologue code to adjust stack alignment and setup DRAP, in case\n@@ -8260,6 +8253,7 @@ ix86_expand_prologue (void)\n \n       insn = emit_insn (gen_rtx_SET (VOIDmode, y, x));\n       RTX_FRAME_RELATED_P (insn) = 1; \n+      ix86_cfa_state->reg = crtl->drap_reg;\n \n       /* Align the stack.  */\n       insn = emit_insn ((*ix86_gen_andsp) (stack_pointer_rtx,\n@@ -8288,6 +8282,9 @@ ix86_expand_prologue (void)\n \n       insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      if (ix86_cfa_state->reg == stack_pointer_rtx)\n+        ix86_cfa_state->reg = hard_frame_pointer_rtx;\n     }\n \n   if (stack_realign_fp)\n@@ -8326,7 +8323,8 @@ ix86_expand_prologue (void)\n     ;\n   else if (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT)\n     pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (-allocate), -1);\n+\t\t\t       GEN_INT (-allocate), -1,\n+\t\t\t       ix86_cfa_state->reg == stack_pointer_rtx);\n   else\n     {\n       /* Only valid for Win32.  */\n@@ -8354,10 +8352,15 @@ ix86_expand_prologue (void)\n       else\n \tinsn = gen_allocate_stack_worker_32 (eax, eax);\n       insn = emit_insn (insn);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-allocate));\n-      t = gen_rtx_SET (VOIDmode, stack_pointer_rtx, t);\n-      add_reg_note (insn, REG_FRAME_RELATED_EXPR, t);\n+\n+      if (ix86_cfa_state->reg == stack_pointer_rtx)\n+\t{\n+\t  ix86_cfa_state->offset += allocate;\n+\t  t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-allocate));\n+\t  t = gen_rtx_SET (VOIDmode, stack_pointer_rtx, t);\n+\t  add_reg_note (insn, REG_CFA_ADJUST_CFA, t);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n \n       if (eax_live)\n \t{\n@@ -8464,18 +8467,96 @@ ix86_expand_prologue (void)\n     emit_insn (gen_cld ());\n }\n \n+/* Emit code to restore REG using a POP insn.  */\n+\n+static void\n+ix86_emit_restore_reg_using_pop (rtx reg)\n+{\n+  rtx insn = emit_insn (ix86_gen_pop1 (reg));\n+\n+  if (ix86_cfa_state->reg == crtl->drap_reg\n+      && REGNO (reg) == REGNO (crtl->drap_reg))\n+    {\n+      /* Previously we'd represented the CFA as an expression\n+\t like *(%ebp - 8).  We've just popped that value from\n+\t the stack, which means we need to reset the CFA to\n+\t the drap register.  This will remain until we restore\n+\t the stack pointer.  */\n+      add_reg_note (insn, REG_CFA_DEF_CFA, reg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      return;\n+    }\n+\n+  if (ix86_cfa_state->reg == stack_pointer_rtx)\n+    {\n+      ix86_cfa_state->offset -= UNITS_PER_WORD;\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 1)));\n+    }\n+\n+  /* When the frame pointer is the CFA, and we pop it, we are\n+     swapping back to the stack pointer as the CFA.  This happens\n+     for stack frames that don't allocate other data, so we assume\n+     the stack pointer is now pointing at the return address, i.e.\n+     the function entry state, which makes the offset be 1 word.  */\n+  else if (ix86_cfa_state->reg == hard_frame_pointer_rtx\n+\t   && reg == hard_frame_pointer_rtx)\n+    {\n+      ix86_cfa_state->reg = stack_pointer_rtx;\n+      ix86_cfa_state->offset = UNITS_PER_WORD;\n+\n+      add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t    gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (UNITS_PER_WORD)));\n+    }\n+\n+  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n+/* Emit code to restore saved registers using POP insns.  */\n+\n+static void\n+ix86_emit_restore_regs_using_pop (void)\n+{\n+  int regno;\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, false))\n+      ix86_emit_restore_reg_using_pop (gen_rtx_REG (Pmode, regno));\n+}\n+\n+/* Emit code and notes for the LEAVE instruction.  */\n+\n+static void\n+ix86_emit_leave (void)\n+{\n+  rtx insn = emit_insn (ix86_gen_leave ());\n+\n+  if (ix86_cfa_state->reg == hard_frame_pointer_rtx)\n+    {\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA, \n+\t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 0)));\n+      add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n /* Emit code to restore saved registers using MOV insns.  First register\n    is restored from POINTER + OFFSET.  */\n static void\n ix86_emit_restore_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n \t\t\t\t  int maybe_eh_return)\n {\n-  int regno;\n+  unsigned int regno;\n   rtx base_address = gen_rtx_MEM (Pmode, pointer);\n+  rtx insn;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n       {\n+\trtx reg = gen_rtx_REG (Pmode, regno);\n+\n \t/* Ensure that adjust_address won't be forced to produce pointer\n \t   out of range allowed by x86-64 instruction set.  */\n \tif (TARGET_64BIT && offset != trunc_int_for_mode (offset, SImode))\n@@ -8488,9 +8569,23 @@ ix86_emit_restore_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n \t    base_address = gen_rtx_MEM (Pmode, r11);\n \t    offset = 0;\n \t  }\n-\temit_move_insn (gen_rtx_REG (Pmode, regno),\n-\t                adjust_address (base_address, Pmode, offset));\n+\tinsn = emit_move_insn (reg,\n+\t\t\t       adjust_address (base_address, Pmode, offset));\n \toffset += UNITS_PER_WORD;\n+\n+        if (ix86_cfa_state->reg == crtl->drap_reg\n+\t    && regno == REGNO (crtl->drap_reg))\n+\t  {\n+\t    /* Previously we'd represented the CFA as an expression\n+\t       like *(%ebp - 8).  We've just popped that value from\n+\t       the stack, which means we need to reset the CFA to\n+\t       the drap register.  This will remain until we restore\n+\t       the stack pointer.  */\n+\t    add_reg_note (insn, REG_CFA_DEF_CFA, reg);\n+\t  }\n+\telse\n+\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n       }\n }\n \n@@ -8502,11 +8597,13 @@ ix86_emit_restore_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n {\n   int regno;\n   rtx base_address = gen_rtx_MEM (TImode, pointer);\n-  rtx mem;\n+  rtx mem, insn;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (SSE_REGNO_P (regno) && ix86_save_reg (regno, maybe_eh_return))\n       {\n+\trtx reg = gen_rtx_REG (TImode, regno);\n+\n \t/* Ensure that adjust_address won't be forced to produce pointer\n \t   out of range allowed by x86-64 instruction set.  */\n \tif (TARGET_64BIT && offset != trunc_int_for_mode (offset, SImode))\n@@ -8521,8 +8618,11 @@ ix86_emit_restore_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n \t  }\n \tmem = adjust_address (base_address, TImode, offset);\n \tset_mem_align (mem, 128);\n-\temit_move_insn (gen_rtx_REG (TImode, regno), mem);\n+\tinsn = emit_move_insn (reg, mem);\n \toffset += 16;\n+\n+\tadd_reg_note (insn, REG_CFA_RESTORE, reg);\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n       }\n }\n \n@@ -8531,10 +8631,11 @@ ix86_emit_restore_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n void\n ix86_expand_epilogue (int style)\n {\n-  int regno;\n   int sp_valid;\n   struct ix86_frame frame;\n   HOST_WIDE_INT offset;\n+  struct machine_cfa_state cfa_state_save = *ix86_cfa_state;\n+  bool using_drap;\n \n   ix86_finalize_stack_realign_flags ();\n \n@@ -8560,6 +8661,9 @@ ix86_expand_epilogue (int style)\n   offset *= -UNITS_PER_WORD;\n   offset -= frame.nsseregs * 16 + frame.padding0;\n \n+  using_drap = crtl->drap_reg && crtl->stack_realign_needed;\n+  gcc_assert (!using_drap || ix86_cfa_state->reg == crtl->drap_reg);\n+\n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n      less work than reloading sp and popping the register.\n@@ -8574,7 +8678,8 @@ ix86_expand_epilogue (int style)\n       || (TARGET_EPILOGUE_USING_MOVE\n \t  && cfun->machine->use_fast_prologue_epilogue\n \t  && ((frame.nregs + frame.nsseregs) > 1 || frame.to_allocate))\n-      || (frame_pointer_needed && !(frame.nregs + frame.nsseregs) && frame.to_allocate)\n+      || (frame_pointer_needed && !(frame.nregs + frame.nsseregs)\n+\t  && frame.to_allocate)\n       || (frame_pointer_needed && TARGET_USE_LEAVE\n \t  && cfun->machine->use_fast_prologue_epilogue\n \t  && (frame.nregs + frame.nsseregs) == 1)\n@@ -8622,13 +8727,28 @@ ix86_expand_epilogue (int style)\n \t    {\n \t      tmp = gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx, sa);\n \t      tmp = plus_constant (tmp, UNITS_PER_WORD);\n-\t      emit_insn (gen_rtx_SET (VOIDmode, sa, tmp));\n+\t      tmp = emit_insn (gen_rtx_SET (VOIDmode, sa, tmp));\n \n \t      tmp = gen_rtx_MEM (Pmode, hard_frame_pointer_rtx);\n-\t      emit_move_insn (hard_frame_pointer_rtx, tmp);\n+\t      tmp = emit_move_insn (hard_frame_pointer_rtx, tmp);\n+\n+\t      /* Note that we use SA as a temporary CFA, as the return\n+\t\t address is at the proper place relative to it.  We\n+\t\t pretend this happens at the FP restore insn because\n+\t\t prior to this insn the FP would be stored at the wrong\n+\t\t offset relative to SA, and after this insn we have no\n+\t\t other reasonable register to use for the CFA.  We don't\n+\t\t bother resetting the CFA to the SP for the duration of\n+\t\t the return insn.  */\n+\t      add_reg_note (tmp, REG_CFA_DEF_CFA,\n+\t\t\t    plus_constant (sa, UNITS_PER_WORD));\n+\t      add_reg_note (tmp, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n+\t      RTX_FRAME_RELATED_P (tmp) = 1;\n+\t      ix86_cfa_state->reg = sa;\n+\t      ix86_cfa_state->offset = UNITS_PER_WORD;\n \n \t      pro_epilogue_adjust_stack (stack_pointer_rtx, sa,\n-\t\t\t\t\t const0_rtx, style);\n+\t\t\t\t\t const0_rtx, style, false);\n \t    }\n \t  else\n \t    {\n@@ -8637,7 +8757,17 @@ ix86_expand_epilogue (int style)\n                                          + frame.nregs * UNITS_PER_WORD\n \t\t\t\t\t + frame.nsseregs * 16\n \t\t\t\t\t + frame.padding0));\n-\t      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, tmp));\n+\t      tmp = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, tmp));\n+\n+\t      gcc_assert (ix86_cfa_state->reg == stack_pointer_rtx);\n+\t      if (ix86_cfa_state->offset != UNITS_PER_WORD)\n+\t\t{\n+\t\t  ix86_cfa_state->offset = UNITS_PER_WORD;\n+\t\t  add_reg_note (tmp, REG_CFA_DEF_CFA,\n+\t\t\t\tplus_constant (stack_pointer_rtx,\n+\t\t\t\t\t       UNITS_PER_WORD));\n+\t\t  RTX_FRAME_RELATED_P (tmp) = 1;\n+\t\t}\n \t    }\n \t}\n       else if (!frame_pointer_needed)\n@@ -8646,18 +8776,18 @@ ix86_expand_epilogue (int style)\n \t\t\t\t\t    + frame.nregs * UNITS_PER_WORD\n \t\t\t\t\t    + frame.nsseregs * 16\n \t\t\t\t\t    + frame.padding0),\n-\t\t\t\t   style);\n+\t\t\t\t   style, !using_drap);\n       /* If not an i386, mov & pop is faster than \"leave\".  */\n       else if (TARGET_USE_LEAVE || optimize_function_for_size_p (cfun)\n \t       || !cfun->machine->use_fast_prologue_epilogue)\n-\temit_insn ((*ix86_gen_leave) ());\n+\tix86_emit_leave ();\n       else\n \t{\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t     hard_frame_pointer_rtx,\n-\t\t\t\t     const0_rtx, style);\n+\t\t\t\t     const0_rtx, style, !using_drap);\n \n-\t  emit_insn ((*ix86_gen_pop1) (hard_frame_pointer_rtx));\n+\t  ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n \t}\n     }\n   else\n@@ -8675,11 +8805,12 @@ ix86_expand_epilogue (int style)\n           gcc_assert (!stack_realign_fp);\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t     hard_frame_pointer_rtx,\n-\t\t\t\t     GEN_INT (offset), style);\n+\t\t\t\t     GEN_INT (offset), style, false);\n           ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n \t\t\t\t\t        frame.to_allocate, style == 2);\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t     GEN_INT (frame.nsseregs * 16), style);\n+\t\t\t\t     GEN_INT (frame.nsseregs * 16),\n+\t\t\t\t     style, false);\n \t}\n       else if (frame.to_allocate || frame.nsseregs)\n \t{\n@@ -8689,18 +8820,18 @@ ix86_expand_epilogue (int style)\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t     GEN_INT (frame.to_allocate\n \t\t\t\t     \t      + frame.nsseregs * 16\n-\t\t\t\t\t      + frame.padding0), style);\n+\t\t\t\t\t      + frame.padding0), style,\n+\t\t\t\t     !using_drap && !frame_pointer_needed);\n \t}\n \n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif (!SSE_REGNO_P (regno) && ix86_save_reg (regno, false))\n-\t  emit_insn ((*ix86_gen_pop1) (gen_rtx_REG (Pmode, regno)));\n+      ix86_emit_restore_regs_using_pop ();\n+\n       if (frame_pointer_needed)\n \t{\n \t  /* Leave results in shorter dependency chains on CPUs that are\n \t     able to grok it fast.  */\n \t  if (TARGET_USE_LEAVE)\n-\t    emit_insn ((*ix86_gen_leave) ());\n+\t    ix86_emit_leave ();\n \t  else\n             {\n               /* For stack realigned really happens, recover stack \n@@ -8709,54 +8840,81 @@ ix86_expand_epilogue (int style)\n               if (stack_realign_fp)\n \t\tpro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t\t   hard_frame_pointer_rtx,\n-\t\t\t\t\t   const0_rtx, style);\n-\t      emit_insn ((*ix86_gen_pop1) (hard_frame_pointer_rtx));\n+\t\t\t\t\t   const0_rtx, style, !using_drap);\n+\t      ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n             }\n \t}\n     }\n \n-  if (crtl->drap_reg && crtl->stack_realign_needed)\n+  if (using_drap)\n     {\n       int param_ptr_offset = (call_used_regs[REGNO (crtl->drap_reg)]\n \t\t\t      ? 0 : UNITS_PER_WORD);\n+      rtx insn;\n+\n       gcc_assert (stack_realign_drap);\n-      emit_insn ((*ix86_gen_add3) (stack_pointer_rtx,\n-\t\t\t\t   crtl->drap_reg,\n-\t\t\t\t   GEN_INT (-(UNITS_PER_WORD\n-\t\t\t\t\t      + param_ptr_offset))));\n-      if (!call_used_regs[REGNO (crtl->drap_reg)])\n-\temit_insn ((*ix86_gen_pop1) (crtl->drap_reg));\n-      \n+\n+      insn = emit_insn ((*ix86_gen_add3) (stack_pointer_rtx,\n+\t\t\t\t\t  crtl->drap_reg,\n+\t\t\t\t\t  GEN_INT (-(UNITS_PER_WORD\n+\t\t\t\t\t\t     + param_ptr_offset))));\n+\n+      ix86_cfa_state->reg = stack_pointer_rtx;\n+      ix86_cfa_state->offset = UNITS_PER_WORD + param_ptr_offset;\n+\n+      add_reg_note (insn, REG_CFA_DEF_CFA,\n+\t\t    gen_rtx_PLUS (Pmode, ix86_cfa_state->reg,\n+\t\t\t\t  GEN_INT (ix86_cfa_state->offset)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      if (param_ptr_offset)\n+\tix86_emit_restore_reg_using_pop (crtl->drap_reg);\n     }\n \n   /* Sibcall epilogues don't want a return instruction.  */\n   if (style == 0)\n-    return;\n+    {\n+      *ix86_cfa_state = cfa_state_save;\n+      return;\n+    }\n \n   if (crtl->args.pops_args && crtl->args.size)\n     {\n       rtx popc = GEN_INT (crtl->args.pops_args);\n \n-      /* i386 can only pop 64K bytes.  If asked to pop more, pop\n-\t return address, do explicit add, and jump indirectly to the\n-\t caller.  */\n+      /* i386 can only pop 64K bytes.  If asked to pop more, pop return\n+\t address, do explicit add, and jump indirectly to the caller.  */\n \n       if (crtl->args.pops_args >= 65536)\n \t{\n \t  rtx ecx = gen_rtx_REG (SImode, CX_REG);\n+\t  rtx insn;\n \n \t  /* There is no \"pascal\" calling convention in any 64bit ABI.  */\n \t  gcc_assert (!TARGET_64BIT);\n \n-\t  emit_insn (gen_popsi1 (ecx));\n-\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, popc));\n+\t  insn = emit_insn (gen_popsi1 (ecx));\n+\t  ix86_cfa_state->offset -= UNITS_PER_WORD;\n+\n+\t  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t\tcopy_rtx (XVECEXP (PATTERN (insn), 0, 1)));\n+\t  add_reg_note (insn, REG_CFA_REGISTER,\n+\t\t\tgen_rtx_SET (VOIDmode, ecx, pc_rtx));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     popc, -1, true);\n \t  emit_jump_insn (gen_return_indirect_internal (ecx));\n \t}\n       else\n \temit_jump_insn (gen_return_pop_internal (popc));\n     }\n   else\n     emit_jump_insn (gen_return_internal ());\n+\n+  /* Restore the state back to the state from the prologue,\n+     so that it's correct for the next epilogue.  */\n+  *ix86_cfa_state = cfa_state_save;\n }\n \n /* Reset from the function's potential modifications.  */\n@@ -30361,8 +30519,6 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #define TARGET_UPDATE_STACK_BOUNDARY ix86_update_stack_boundary\n #undef TARGET_GET_DRAP_RTX\n #define TARGET_GET_DRAP_RTX ix86_get_drap_rtx\n-#undef TARGET_DWARF_HANDLE_FRAME_UNSPEC\n-#define TARGET_DWARF_HANDLE_FRAME_UNSPEC ix86_dwarf_handle_frame_unspec\n #undef TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n "}, {"sha": "fe8544ce3f3b4b481372e13f68ce91da135f7d1c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -2393,6 +2393,15 @@ enum ix86_stack_slot\n \f\n #define FASTCALL_PREFIX '@'\n \f\n+/* Machine specific CFA tracking during prologue/epilogue generation.  */\n+\n+#if !defined(IN_LIBGCC2) && !defined(IN_TARGET_LIBS)\n+struct GTY(()) machine_cfa_state\n+{\n+  rtx reg;\n+  HOST_WIDE_INT offset;\n+};\n+\n struct GTY(()) machine_function {\n   struct stack_local_entry *stack_locals;\n   const char *some_ld_name;\n@@ -2419,8 +2428,10 @@ struct GTY(()) machine_function {\n   int tls_descriptor_call_expanded_p;\n   /* This value is used for amd64 targets and specifies the current abi\n      to be used. MS_ABI means ms abi. Otherwise SYSV_ABI means sysv abi.  */\n-   enum calling_abi call_abi;\n+  enum calling_abi call_abi;\n+  struct machine_cfa_state cfa;\n };\n+#endif\n \n #define ix86_stack_locals (cfun->machine->stack_locals)\n #define ix86_varargs_gpr_size (cfun->machine->varargs_gpr_size)\n@@ -2436,6 +2447,7 @@ struct GTY(()) machine_function {\n    REG_SP is live.  */\n #define ix86_current_function_calls_tls_descriptor \\\n   (ix86_tls_descriptor_calls_expanded_in_cfun && df_regs_ever_live_p (SP_REG))\n+#define ix86_cfa_state (&cfun->machine->cfa)\n \n /* Control behavior of x86_file_start.  */\n #define X86_FILE_START_VERSION_DIRECTIVE false"}, {"sha": "20413966e8423e5a491c25226c038825cb757ad6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -101,7 +101,6 @@\n    (UNSPEC_ADD_CARRY\t\t34)\n    (UNSPEC_FLDCW\t\t35)\n    (UNSPEC_REP\t\t\t36)\n-   (UNSPEC_EH_RETURN\t\t37)\n    (UNSPEC_LD_MPIC\t\t38)\t; load_macho_picbase\n    (UNSPEC_TRUNC_NOOP\t\t39)\n \n@@ -15982,21 +15981,16 @@\n   tmp = gen_rtx_MEM (Pmode, tmp);\n   emit_move_insn (tmp, ra);\n \n-  if (Pmode == SImode)\n-    emit_jump_insn (gen_eh_return_si (sa));\n-  else\n-    emit_jump_insn (gen_eh_return_di (sa));\n+  emit_jump_insn (gen_eh_return_internal ());\n   emit_barrier ();\n   DONE;\n })\n \n-(define_insn_and_split \"eh_return_<mode>\"\n-  [(set (pc)\n-        (unspec [(match_operand:P 0 \"register_operand\" \"c\")]\n-\t         UNSPEC_EH_RETURN))]\n+(define_insn_and_split \"eh_return_internal\"\n+  [(eh_return)]\n   \"\"\n   \"#\"\n-  \"reload_completed\"\n+  \"epilogue_completed\"\n   [(const_int 0)]\n   \"ix86_expand_epilogue (2); DONE;\")\n "}, {"sha": "3c853d466ad78cb7e6189530f5d443fbdada03b5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 345, "deletions": 27, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -247,7 +247,8 @@ typedef struct GTY(()) cfa_loc {\n   HOST_WIDE_INT offset;\n   HOST_WIDE_INT base_offset;\n   unsigned int reg;\n-  int indirect;            /* 1 if CFA is accessed via a dereference.  */\n+  BOOL_BITFIELD indirect : 1;  /* 1 if CFA is accessed via a dereference.  */\n+  BOOL_BITFIELD in_use : 1;    /* 1 if a saved cfa is stored here.  */\n } dw_cfa_location;\n \n /* All call frame descriptions (FDE's) in the GCC generated DWARF\n@@ -404,7 +405,7 @@ static const char *dwarf_cfi_name (unsigned);\n static dw_cfi_ref new_cfi (void);\n static void add_cfi (dw_cfi_ref *, dw_cfi_ref);\n static void add_fde_cfi (const char *, dw_cfi_ref);\n-static void lookup_cfa_1 (dw_cfi_ref, dw_cfa_location *);\n+static void lookup_cfa_1 (dw_cfi_ref, dw_cfa_location *, dw_cfa_location *);\n static void lookup_cfa (dw_cfa_location *);\n static void reg_save (const char *, unsigned, unsigned, HOST_WIDE_INT);\n #ifdef DWARF2_UNWIND_INFO\n@@ -668,7 +669,10 @@ add_cfi (dw_cfi_ref *list_head, dw_cfi_ref cfi)\n \n   /* When DRAP is used, CFA is defined with an expression.  Redefine\n      CFA may lead to a different CFA value.   */\n-  if (fde && fde->drap_reg != INVALID_REGNUM)\n+  /* ??? Of course, this heuristic fails when we're annotating epilogues,\n+     because of course we'll always want to redefine the CFA back to the\n+     stack pointer on the way out.  Where should we move this check?  */\n+  if (0 && fde && fde->drap_reg != INVALID_REGNUM)\n     switch (cfi->dw_cfi_opc)\n       {\n         case DW_CFA_def_cfa_register:\n@@ -774,7 +778,7 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n /* Subroutine of lookup_cfa.  */\n \n static void\n-lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc)\n+lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n {\n   switch (cfi->dw_cfi_opc)\n     {\n@@ -793,6 +797,18 @@ lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc)\n     case DW_CFA_def_cfa_expression:\n       get_cfa_from_loc_descr (loc, cfi->dw_cfi_oprnd1.dw_cfi_loc);\n       break;\n+\n+    case DW_CFA_remember_state:\n+      gcc_assert (!remember->in_use);\n+      *remember = *loc;\n+      remember->in_use = 1;\n+      break;\n+    case DW_CFA_restore_state:\n+      gcc_assert (remember->in_use);\n+      *loc = *remember;\n+      remember->in_use = 0;\n+      break;\n+\n     default:\n       break;\n     }\n@@ -805,19 +821,19 @@ lookup_cfa (dw_cfa_location *loc)\n {\n   dw_cfi_ref cfi;\n   dw_fde_ref fde;\n+  dw_cfa_location remember;\n \n+  memset (loc, 0, sizeof (*loc));\n   loc->reg = INVALID_REGNUM;\n-  loc->offset = 0;\n-  loc->indirect = 0;\n-  loc->base_offset = 0;\n+  remember = *loc;\n \n   for (cfi = cie_cfi_head; cfi; cfi = cfi->dw_cfi_next)\n-    lookup_cfa_1 (cfi, loc);\n+    lookup_cfa_1 (cfi, loc, &remember);\n \n   fde = current_fde ();\n   if (fde)\n     for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n-      lookup_cfa_1 (cfi, loc);\n+      lookup_cfa_1 (cfi, loc, &remember);\n }\n \n /* The current rule for calculating the DWARF2 canonical frame address.  */\n@@ -827,6 +843,9 @@ static dw_cfa_location cfa;\n    from the CFA.  */\n static dw_cfa_location cfa_store;\n \n+/* The current save location around an epilogue.  */\n+static dw_cfa_location cfa_remember;\n+\n /* The running total of the size of arguments pushed onto the stack.  */\n static HOST_WIDE_INT args_size;\n \n@@ -1212,8 +1231,7 @@ compute_barrier_args_size_1 (rtx insn, HOST_WIDE_INT cur_args_size,\n \n   if (! RTX_FRAME_RELATED_P (insn))\n     {\n-      if (prologue_epilogue_contains (insn)\n-\t  || sibcall_epilogue_contains (insn))\n+      if (prologue_epilogue_contains (insn))\n \t/* Nothing */;\n       else if (GET_CODE (PATTERN (insn)) == SET)\n \toffset = stack_adjust_offset (PATTERN (insn), cur_args_size, 0);\n@@ -1386,7 +1404,7 @@ dwarf2out_stack_adjust (rtx insn, bool after_p)\n      with this function.  Proper support would require all frame-related\n      insns to be marked, and to be able to handle saving state around\n      epilogues textually in the middle of the function.  */\n-  if (prologue_epilogue_contains (insn) || sibcall_epilogue_contains (insn))\n+  if (prologue_epilogue_contains (insn))\n     return;\n \n   /* If INSN is an instruction from target of an annulled branch, the\n@@ -1660,6 +1678,156 @@ reg_saved_in (rtx reg)\n    value, not an offset.  */\n static dw_cfa_location cfa_temp;\n \n+/* A subroutine of dwarf2out_frame_debug, process a REG_DEF_CFA note.  */\n+\n+static void\n+dwarf2out_frame_debug_def_cfa (rtx pat, const char *label)\n+{\n+  memset (&cfa, 0, sizeof (cfa));\n+\n+  switch (GET_CODE (pat))\n+    {\n+    case PLUS:\n+      cfa.reg = REGNO (XEXP (pat, 0));\n+      cfa.offset = INTVAL (XEXP (pat, 1));\n+      break;\n+\n+    case REG:\n+      cfa.reg = REGNO (pat);\n+      break;\n+\n+    default:\n+      /* Recurse and define an expression.  */\n+      gcc_unreachable ();\n+    }\n+\n+  def_cfa_1 (label, &cfa);\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_ADJUST_CFA note.  */\n+\n+static void\n+dwarf2out_frame_debug_adjust_cfa (rtx pat, const char *label)\n+{\n+  rtx src, dest;\n+\n+  gcc_assert (GET_CODE (pat) == SET);\n+  dest = XEXP (pat, 0);\n+  src = XEXP (pat, 1);\n+\n+  switch (GET_CODE (src))\n+    {\n+    case PLUS:\n+      gcc_assert (REGNO (XEXP (src, 0)) == cfa.reg);\n+      cfa.offset -= INTVAL (XEXP (src, 1));\n+      break;\n+\n+    case REG:\n+\tbreak;\n+\n+    default:\n+\tgcc_unreachable ();\n+    }\n+\n+  cfa.reg = REGNO (dest);\n+  gcc_assert (cfa.indirect == 0);\n+\n+  def_cfa_1 (label, &cfa);\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_OFFSET note.  */\n+\n+static void\n+dwarf2out_frame_debug_cfa_offset (rtx set, const char *label)\n+{\n+  HOST_WIDE_INT offset;\n+  rtx src, addr, span;\n+\n+  src = XEXP (set, 1);\n+  addr = XEXP (set, 0);\n+  gcc_assert (MEM_P (addr));\n+  addr = XEXP (addr, 0);\n+  \n+  /* As documented, only consider extremely simple addresses.  */\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      gcc_assert (REGNO (addr) == cfa.reg);\n+      offset = -cfa.offset;\n+      break;\n+    case PLUS:\n+      gcc_assert (REGNO (XEXP (addr, 0)) == cfa.reg);\n+      offset = INTVAL (XEXP (addr, 1)) - cfa.offset;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  span = targetm.dwarf_register_span (src);\n+\n+  /* ??? We'd like to use queue_reg_save, but we need to come up with\n+     a different flushing heuristic for epilogues.  */\n+  if (!span)\n+    reg_save (label, DWARF_FRAME_REGNUM (REGNO (src)), INVALID_REGNUM, offset);\n+  else\n+    {\n+      /* We have a PARALLEL describing where the contents of SRC live.\n+   \t Queue register saves for each piece of the PARALLEL.  */\n+      int par_index;\n+      int limit;\n+      HOST_WIDE_INT span_offset = offset;\n+\n+      gcc_assert (GET_CODE (span) == PARALLEL);\n+\n+      limit = XVECLEN (span, 0);\n+      for (par_index = 0; par_index < limit; par_index++)\n+\t{\n+\t  rtx elem = XVECEXP (span, 0, par_index);\n+\n+\t  reg_save (label, DWARF_FRAME_REGNUM (REGNO (elem)),\n+\t\t    INVALID_REGNUM, span_offset);\n+\t  span_offset += GET_MODE_SIZE (GET_MODE (elem));\n+\t}\n+    }\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_REGISTER note.  */\n+\n+static void\n+dwarf2out_frame_debug_cfa_register (rtx set, const char *label)\n+{\n+  rtx src, dest;\n+  unsigned sregno, dregno;\n+\n+  src = XEXP (set, 1);\n+  dest = XEXP (set, 0);\n+\n+  if (src == pc_rtx)\n+    sregno = DWARF_FRAME_RETURN_COLUMN;\n+  else\n+    sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+\n+  dregno = DWARF_FRAME_REGNUM (REGNO (dest));\n+\n+  /* ??? We'd like to use queue_reg_save, but we need to come up with\n+     a different flushing heuristic for epilogues.  */\n+  reg_save (label, sregno, dregno, 0);\n+}\n+\n+/* A subroutine of dwarf2out_frame_debug, process a REG_CFA_RESTORE note.  */\n+\n+static void\n+dwarf2out_frame_debug_cfa_restore (rtx reg, const char *label)\n+{\n+  dw_cfi_ref cfi = new_cfi ();\n+  unsigned int regno = DWARF_FRAME_REGNUM (REGNO (reg));\n+\n+  cfi->dw_cfi_opc = (regno & ~0x3f ? DW_CFA_restore_extended : DW_CFA_restore);\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = regno;\n+\n+  add_fde_cfi (label, cfi);\n+}\n+\n /* Record call frame debugging information for an expression EXPR,\n    which either sets SP or FP (adjusting how we calculate the frame\n    address) or saves a register to the stack or another register.\n@@ -2367,7 +2535,8 @@ void\n dwarf2out_frame_debug (rtx insn, bool after_p)\n {\n   const char *label;\n-  rtx src;\n+  rtx note, n;\n+  bool handled_one = false;\n \n   if (insn == NULL_RTX)\n     {\n@@ -2412,15 +2581,158 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n     }\n \n   label = dwarf2out_cfi_label ();\n-  src = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n-  if (src)\n-    insn = XEXP (src, 0);\n-  else\n-    insn = PATTERN (insn);\n \n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    switch (REG_NOTE_KIND (note))\n+      {\n+      case REG_FRAME_RELATED_EXPR:\n+\tinsn = XEXP (note, 0);\n+\tgoto found;\n+\n+      case REG_CFA_DEF_CFA:\n+\tdwarf2out_frame_debug_def_cfa (XEXP (note, 0), label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_ADJUST_CFA:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  {\n+\t    n = PATTERN (insn);\n+\t    if (GET_CODE (n) == PARALLEL)\n+\t      n = XVECEXP (n, 0, 0);\n+\t  }\n+\tdwarf2out_frame_debug_adjust_cfa (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_OFFSET:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  n = single_set (insn);\n+\tdwarf2out_frame_debug_cfa_offset (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_REGISTER:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  {\n+\t    n = PATTERN (insn);\n+\t    if (GET_CODE (n) == PARALLEL)\n+\t      n = XVECEXP (n, 0, 0);\n+\t  }\n+\tdwarf2out_frame_debug_cfa_register (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      case REG_CFA_RESTORE:\n+\tn = XEXP (note, 0);\n+\tif (n == NULL)\n+\t  {\n+\t    n = PATTERN (insn);\n+\t    if (GET_CODE (n) == PARALLEL)\n+\t      n = XVECEXP (n, 0, 0);\n+\t    n = XEXP (n, 0);\n+\t  }\n+\tdwarf2out_frame_debug_cfa_restore (n, label);\n+\thandled_one = true;\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n+  if (handled_one)\n+    return;\n+\n+  insn = PATTERN (insn);\n+ found:\n   dwarf2out_frame_debug_expr (insn, label);\n }\n \n+/* Determine if we need to save and restore CFI information around this\n+   epilogue.  If SIBCALL is true, then this is a sibcall epilogue.  If\n+   we do need to save/restore, then emit the save now, and insert a\n+   NOTE_INSN_CFA_RESTORE_STATE at the appropriate place in the stream.  */\n+\n+void\n+dwarf2out_begin_epilogue (rtx insn)\n+{\n+  bool saw_frp = false;\n+  rtx i;\n+  dw_cfi_ref cfi;\n+\n+  /* Scan forward to the return insn, noticing if there are possible\n+     frame related insns.  */\n+  for (i = NEXT_INSN (insn); i ; i = NEXT_INSN (i))\n+    {\n+      if (!INSN_P (i))\n+\tcontinue;\n+\n+      /* Look for both regular and sibcalls to end the block.  */\n+      if (returnjump_p (i))\n+\tbreak;\n+      if (CALL_P (i) && SIBLING_CALL_P (i))\n+\tbreak;\n+\n+      if (RTX_FRAME_RELATED_P (i))\n+\tsaw_frp = true;\n+    }\n+\n+  /* If the port doesn't emit epilogue unwind info, we don't need a\n+     save/restore pair.  */\n+  if (!saw_frp)\n+    return;\n+\n+  /* Otherwise, search forward to see if the return insn was the last\n+     basic block of the function.  If so, we don't need save/restore.  */\n+  gcc_assert (i != NULL);\n+  i = next_real_insn (i);\n+  if (i == NULL)\n+    return;\n+\n+  /* Insert the restore before that next real insn in the stream, and before\n+     a potential NOTE_INSN_EPILOGUE_BEG -- we do need these notes to be\n+     properly nested.  This should be after any label or alignment.  This\n+     will be pushed into the CFI stream by the function below.  */\n+  while (1)\n+    {\n+      rtx p = PREV_INSN (i);\n+      if (!NOTE_P (p))\n+\tbreak;\n+      if (NOTE_KIND (p) == NOTE_INSN_BASIC_BLOCK)\n+\tbreak;\n+      i = p;\n+    }\n+  emit_note_before (NOTE_INSN_CFA_RESTORE_STATE, i);\n+\n+  /* Emit the state save.  */\n+  cfi = new_cfi (); \n+  cfi->dw_cfi_opc = DW_CFA_remember_state;\n+  add_fde_cfi (dwarf2out_cfi_label (), cfi);\n+\n+  /* And emulate the state save.  */\n+  gcc_assert (!cfa_remember.in_use);\n+  cfa_remember = cfa;\n+  cfa_remember.in_use = 1;\n+}\n+\n+/* A \"subroutine\" of dwarf2out_begin_epilogue.  Emit the restore required.  */\n+\n+void\n+dwarf2out_frame_debug_restore_state (void)\n+{\n+  dw_cfi_ref cfi = new_cfi (); \n+  const char *label = dwarf2out_cfi_label ();\n+\n+  cfi->dw_cfi_opc = DW_CFA_restore_state;\n+  add_fde_cfi (label, cfi);\n+\n+  gcc_assert (cfa_remember.in_use);\n+  cfa = cfa_remember;\n+  cfa_remember.in_use = 0;\n+}\n+\n #endif\n \n /* Describe for the GTY machinery what parts of dw_cfi_oprnd1 are used.  */\n@@ -2434,6 +2746,8 @@ dw_cfi_oprnd1_desc (enum dwarf_call_frame_info cfi)\n     {\n     case DW_CFA_nop:\n     case DW_CFA_GNU_window_save:\n+    case DW_CFA_remember_state:\n+    case DW_CFA_restore_state:\n       return dw_cfi_oprnd_unused;\n \n     case DW_CFA_set_loc:\n@@ -2448,6 +2762,7 @@ dw_cfi_oprnd1_desc (enum dwarf_call_frame_info cfi)\n     case DW_CFA_def_cfa:\n     case DW_CFA_offset_extended_sf:\n     case DW_CFA_def_cfa_sf:\n+    case DW_CFA_restore:\n     case DW_CFA_restore_extended:\n     case DW_CFA_undefined:\n     case DW_CFA_same_value:\n@@ -2771,6 +3086,13 @@ output_cfi_directive (dw_cfi_ref cfi)\n \t       cfi->dw_cfi_oprnd1.dw_cfi_offset);\n       break;\n \n+    case DW_CFA_remember_state:\n+      fprintf (asm_out_file, \"\\t.cfi_remember_state\\n\");\n+      break;\n+    case DW_CFA_restore_state:\n+      fprintf (asm_out_file, \"\\t.cfi_restore_state\\n\");\n+      break;\n+\n     case DW_CFA_GNU_args_size:\n       fprintf (asm_out_file, \"\\t.cfi_escape 0x%x,\", DW_CFA_GNU_args_size);\n       dw2_asm_output_data_uleb128_raw (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n@@ -12056,6 +12378,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n   dw_cfi_ref cfi;\n   dw_cfa_location last_cfa, next_cfa;\n   const char *start_label, *last_label, *section;\n+  dw_cfa_location remember;\n \n   fde = current_fde ();\n   gcc_assert (fde != NULL);\n@@ -12064,17 +12387,16 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n   list_tail = &list;\n   list = NULL;\n \n+  memset (&next_cfa, 0, sizeof (next_cfa));\n   next_cfa.reg = INVALID_REGNUM;\n-  next_cfa.offset = 0;\n-  next_cfa.indirect = 0;\n-  next_cfa.base_offset = 0;\n+  remember = next_cfa;\n \n   start_label = fde->dw_fde_begin;\n \n   /* ??? Bald assumption that the CIE opcode list does not contain\n      advance opcodes.  */\n   for (cfi = cie_cfi_head; cfi; cfi = cfi->dw_cfi_next)\n-    lookup_cfa_1 (cfi, &next_cfa);\n+    lookup_cfa_1 (cfi, &next_cfa, &remember);\n \n   last_cfa = next_cfa;\n   last_label = start_label;\n@@ -12101,14 +12423,10 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n \n       case DW_CFA_advance_loc:\n \t/* The encoding is complex enough that we should never emit this.  */\n-      case DW_CFA_remember_state:\n-      case DW_CFA_restore_state:\n-\t/* We don't handle these two in this function.  It would be possible\n-\t   if it were to be required.  */\n \tgcc_unreachable ();\n \n       default:\n-\tlookup_cfa_1 (cfi, &next_cfa);\n+\tlookup_cfa_1 (cfi, &next_cfa, &remember);\n \tbreak;\n       }\n "}, {"sha": "85c320dfbd589412d8b7832a884ff6e89fd1ea4e", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n \n extern void dwarf2out_decl (tree);\n extern void dwarf2out_frame_debug (rtx, bool);\n+extern void dwarf2out_begin_epilogue (rtx);\n+extern void dwarf2out_frame_debug_restore_state (void);\n \n extern void debug_dwarf (void);\n struct die_struct;"}, {"sha": "98fb243b612723766b6940eeddd9f9ccb89f52ba", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -3335,6 +3335,10 @@ try_split (rtx pat, rtx trial, int last)\n   rtx insn_last, insn;\n   int njumps = 0;\n \n+  /* We're not good at redistributing frame information.  */\n+  if (RTX_FRAME_RELATED_P (trial))\n+    return trial;\n+\n   if (any_condjump_p (trial)\n       && (note = find_reg_note (trial, REG_BR_PROB, 0)))\n     split_branch_probability = INTVAL (XEXP (note, 0));\n@@ -5050,6 +5054,9 @@ copy_insn_1 (rtx orig)\n   RTX_CODE code;\n   const char *format_ptr;\n \n+  if (orig == NULL)\n+    return NULL;\n+\n   code = GET_CODE (orig);\n \n   switch (code)"}, {"sha": "785b090685a0d350e90e1263b12099983903fef4", "filename": "gcc/final.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -1879,9 +1879,19 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  break;\n \n \tcase NOTE_INSN_EPILOGUE_BEG:\n+#if defined (DWARF2_UNWIND_INFO) && defined (HAVE_epilogue)\n+\t  if (dwarf2out_do_frame ())\n+\t    dwarf2out_begin_epilogue (insn);\n+#endif\n \t  targetm.asm_out.function_begin_epilogue (file);\n \t  break;\n \n+\tcase NOTE_INSN_CFA_RESTORE_STATE:\n+#if defined (DWARF2_UNWIND_INFO)\n+\t  dwarf2out_frame_debug_restore_state ();\n+#endif\n+\t  break;\n+\n \tcase NOTE_INSN_FUNCTION_BEG:\n \t  app_disable ();\n \t  (*debug_hooks->end_prologue) (last_linenum, last_filename);"}, {"sha": "ddf08b04602e76aab7e0ec31f4676dfa4710b5ba", "filename": "gcc/function.c", "status": "modified", "additions": 145, "deletions": 103, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -124,13 +124,11 @@ struct machine_function * (*init_machine_status) (void);\n /* The currently compiled function.  */\n struct function *cfun = 0;\n \n-/* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */\n-static VEC(int,heap) *prologue;\n-static VEC(int,heap) *epilogue;\n-\n-/* Array of INSN_UIDs to hold the INSN_UIDs for each sibcall epilogue\n-   in this function.  */\n-static VEC(int,heap) *sibcall_epilogue;\n+/* These hashes record the prologue and epilogue insns.  */\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n+  htab_t prologue_insn_hash;\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n+  htab_t epilogue_insn_hash;\n \f\n /* Forward declarations.  */\n \n@@ -143,8 +141,8 @@ static tree *get_block_vector (tree, int *);\n extern tree debug_find_var_in_block_tree (tree, tree);\n /* We always define `record_insns' even if it's not used so that we\n    can always export `prologue_epilogue_contains'.  */\n-static void record_insns (rtx, VEC(int,heap) **) ATTRIBUTE_UNUSED;\n-static int contains (const_rtx, VEC(int,heap) **);\n+static void record_insns (rtx, rtx, htab_t *) ATTRIBUTE_UNUSED;\n+static bool contains (const_rtx, htab_t);\n #ifdef HAVE_return\n static void emit_return_into_block (basic_block);\n #endif\n@@ -207,9 +205,9 @@ free_after_parsing (struct function *f)\n void\n free_after_compilation (struct function *f)\n {\n-  VEC_free (int, heap, prologue);\n-  VEC_free (int, heap, epilogue);\n-  VEC_free (int, heap, sibcall_epilogue);\n+  prologue_insn_hash = NULL;\n+  epilogue_insn_hash = NULL;\n+\n   if (crtl->emit.regno_pointer_align)\n     free (crtl->emit.regno_pointer_align);\n \n@@ -4196,18 +4194,11 @@ init_function_start (tree subr)\n     warning (OPT_Waggregate_return, \"function returns an aggregate\");\n }\n \n-/* Make sure all values used by the optimization passes have sane\n-   defaults.  */\n+/* Make sure all values used by the optimization passes have sane defaults.  */\n unsigned int\n init_function_for_compilation (void)\n {\n   reg_renumber = 0;\n-\n-  /* No prologue/epilogue insns yet.  Make sure that these vectors are\n-     empty.  */\n-  gcc_assert (VEC_length (int, prologue) == 0);\n-  gcc_assert (VEC_length (int, epilogue) == 0);\n-  gcc_assert (VEC_length (int, sibcall_epilogue) == 0);\n   return 0;\n }\n \n@@ -4873,16 +4864,42 @@ get_arg_pointer_save_area (void)\n   return ret;\n }\n \f\n-/* Extend a vector that records the INSN_UIDs of INSNS\n-   (a list of one or more insns).  */\n+/* Add a list of INSNS to the hash HASHP, possibly allocating HASHP\n+   for the first time.  */\n \n static void\n-record_insns (rtx insns, VEC(int,heap) **vecp)\n+record_insns (rtx insns, rtx end, htab_t *hashp)\n {\n   rtx tmp;\n+  htab_t hash = *hashp;\n+\n+  if (hash == NULL)\n+    *hashp = hash\n+      = htab_create_ggc (17, htab_hash_pointer, htab_eq_pointer, NULL);\n+\n+  for (tmp = insns; tmp != end; tmp = NEXT_INSN (tmp))\n+    {\n+      void **slot = htab_find_slot (hash, tmp, INSERT);\n+      gcc_assert (*slot == NULL);\n+      *slot = tmp;\n+    }\n+}\n+\n+/* INSN has been duplicated as COPY, as part of duping a basic block.\n+   If INSN is an epilogue insn, then record COPY as epilogue as well.  */\n \n-  for (tmp = insns; tmp != NULL_RTX; tmp = NEXT_INSN (tmp))\n-    VEC_safe_push (int, heap, *vecp, INSN_UID (tmp));\n+void\n+maybe_copy_epilogue_insn (rtx insn, rtx copy)\n+{\n+  void **slot;\n+\n+  if (epilogue_insn_hash == NULL\n+      || htab_find (epilogue_insn_hash, insn) == NULL)\n+    return;\n+\n+  slot = htab_find_slot (epilogue_insn_hash, copy, INSERT);\n+  gcc_assert (*slot == NULL);\n+  *slot = copy;\n }\n \n /* Set the locator of the insn chain starting at INSN to LOC.  */\n@@ -4897,52 +4914,37 @@ set_insn_locators (rtx insn, int loc)\n     }\n }\n \n-/* Determine how many INSN_UIDs in VEC are part of INSN.  Because we can\n-   be running after reorg, SEQUENCE rtl is possible.  */\n+/* Determine if any INSNs in HASH are, or are part of, INSN.  Because\n+   we can be running after reorg, SEQUENCE rtl is possible.  */\n \n-static int\n-contains (const_rtx insn, VEC(int,heap) **vec)\n+static bool\n+contains (const_rtx insn, htab_t hash)\n {\n-  int i, j;\n+  if (hash == NULL)\n+    return false;\n \n-  if (NONJUMP_INSN_P (insn)\n-      && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+  if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     {\n-      int count = 0;\n+      int i;\n       for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\tfor (j = VEC_length (int, *vec) - 1; j >= 0; --j)\n-\t  if (INSN_UID (XVECEXP (PATTERN (insn), 0, i))\n-\t      == VEC_index (int, *vec, j))\n-\t    count++;\n-      return count;\n+\tif (htab_find (hash, XVECEXP (PATTERN (insn), 0, i)))\n+\t  return true;\n+      return false;\n     }\n-  else\n-    {\n-      for (j = VEC_length (int, *vec) - 1; j >= 0; --j)\n-\tif (INSN_UID (insn) == VEC_index (int, *vec, j))\n-\t  return 1;\n-    }\n-  return 0;\n+\n+  return htab_find (hash, insn) != NULL;\n }\n \n int\n prologue_epilogue_contains (const_rtx insn)\n {\n-  if (contains (insn, &prologue))\n+  if (contains (insn, prologue_insn_hash))\n     return 1;\n-  if (contains (insn, &epilogue))\n+  if (contains (insn, epilogue_insn_hash))\n     return 1;\n   return 0;\n }\n \n-int\n-sibcall_epilogue_contains (const_rtx insn)\n-{\n-  if (sibcall_epilogue)\n-    return contains (insn, &sibcall_epilogue);\n-  return 0;\n-}\n-\n #ifdef HAVE_return\n /* Insert gen_return at the end of block BB.  This also means updating\n    block_for_insn appropriately.  */\n@@ -4985,7 +4987,7 @@ thread_prologue_and_epilogue_insns (void)\n \temit_use (hard_frame_pointer_rtx);\n \n       /* Retain a map of the prologue insns.  */\n-      record_insns (seq, &prologue);\n+      record_insns (seq, NULL, &prologue_insn_hash);\n       emit_note (NOTE_INSN_PROLOGUE_END);\n  \n #ifndef PROFILE_BEFORE_PROLOGUE\n@@ -5117,6 +5119,38 @@ thread_prologue_and_epilogue_insns (void)\n \t}\n     }\n #endif\n+\n+  /* A small fib -- epilogue is not yet completed, but we wish to re-use\n+     this marker for the splits of EH_RETURN patterns, and nothing else\n+     uses the flag in the meantime.  */\n+  epilogue_completed = 1;\n+\n+#ifdef HAVE_eh_return\n+  /* Find non-fallthru edges that end with EH_RETURN instructions.  On\n+     some targets, these get split to a special version of the epilogue\n+     code.  In order to be able to properly annotate these with unwind\n+     info, try to split them now.  If we get a valid split, drop an\n+     EPILOGUE_BEG note and mark the insns as epilogue insns.  */\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+    {\n+      rtx prev, last, trial;\n+\n+      if (e->flags & EDGE_FALLTHRU)\n+\tcontinue;\n+      last = BB_END (e->src);\n+      if (!eh_returnjump_p (last))\n+\tcontinue;\n+\n+      prev = PREV_INSN (last);\n+      trial = try_split (PATTERN (last), last, 1);\n+      if (trial == last)\n+\tcontinue;\n+\n+      record_insns (NEXT_INSN (prev), NEXT_INSN (trial), &epilogue_insn_hash);\n+      emit_note_after (NOTE_INSN_EPILOGUE_BEG, prev);\n+    }\n+#endif\n+\n   /* Find the edge that falls through to EXIT.  Other edges may exist\n      due to RETURN instructions, but those don't need epilogues.\n      There really shouldn't be a mixture -- either all should have\n@@ -5137,7 +5171,7 @@ thread_prologue_and_epilogue_insns (void)\n       emit_jump_insn (seq);\n \n       /* Retain a map of the epilogue insns.  */\n-      record_insns (seq, &epilogue);\n+      record_insns (seq, NULL, &epilogue_insn_hash);\n       set_insn_locators (seq, epilogue_locator);\n \n       seq = get_insns ();\n@@ -5199,14 +5233,15 @@ thread_prologue_and_epilogue_insns (void)\n \t}\n \n       start_sequence ();\n+      emit_note (NOTE_INSN_EPILOGUE_BEG);\n       emit_insn (gen_sibcall_epilogue ());\n       seq = get_insns ();\n       end_sequence ();\n \n       /* Retain a map of the epilogue insns.  Used in life analysis to\n \t avoid getting rid of sibcall epilogue insns.  Do this before we\n \t actually emit the sequence.  */\n-      record_insns (seq, &sibcall_epilogue);\n+      record_insns (seq, NULL, &epilogue_insn_hash);\n       set_insn_locators (seq, epilogue_locator);\n \n       emit_insn_before (seq, insn);\n@@ -5240,31 +5275,37 @@ thread_prologue_and_epilogue_insns (void)\n   df_update_entry_exit_and_calls ();\n }\n \n-/* Reposition the prologue-end and epilogue-begin notes after instruction\n-   scheduling and delayed branch scheduling.  */\n+/* Reposition the prologue-end and epilogue-begin notes after\n+   instruction scheduling.  */\n \n void\n reposition_prologue_and_epilogue_notes (void)\n {\n-#if defined (HAVE_prologue) || defined (HAVE_epilogue)\n+#if defined (HAVE_prologue) || defined (HAVE_epilogue) \\\n+    || defined (HAVE_sibcall_epilogue)\n   rtx insn, last, note;\n-  int len;\n+  basic_block bb;\n \n-  if ((len = VEC_length (int, prologue)) > 0)\n+  /* Since the hash table is created on demand, the fact that it is\n+     non-null is a signal that it is non-empty.  */\n+  if (prologue_insn_hash != NULL)\n     {\n+      size_t len = htab_elements (prologue_insn_hash);\n       last = 0, note = 0;\n \n-      /* Scan from the beginning until we reach the last prologue insn.\n-\t We apparently can't depend on basic_block_{head,end} after\n-\t reorg has run.  */\n+      /* Scan from the beginning until we reach the last prologue insn.  */\n+      /* ??? While we do have the CFG intact, there are two problems:\n+\t (1) The prologue can contain loops (typically probing the stack),\n+\t     which means that the end of the prologue isn't in the first bb.\n+\t (2) Sometimes the PROLOGUE_END note gets pushed into the next bb.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n \t  if (NOTE_P (insn))\n \t    {\n \t      if (NOTE_KIND (insn) == NOTE_INSN_PROLOGUE_END)\n \t\tnote = insn;\n \t    }\n-\t  else if (contains (insn, &prologue))\n+\t  else if (contains (insn, prologue_insn_hash))\n \t    {\n \t      last = insn;\n \t      if (--len == 0)\n@@ -5274,14 +5315,17 @@ reposition_prologue_and_epilogue_notes (void)\n \n       if (last)\n \t{\n-\t  /* Find the prologue-end note if we haven't already, and\n-\t     move it to just after the last prologue insn.  */\n-\t  if (note == 0)\n+\t  if (note == NULL)\n \t    {\n-\t      for (note = last; (note = NEXT_INSN (note));)\n-\t\tif (NOTE_P (note)\n-\t\t    && NOTE_KIND (note) == NOTE_INSN_PROLOGUE_END)\n-\t\t  break;\n+\t      /* Scan forward looking for the PROLOGUE_END note.  It should\n+\t\t be right at the beginning of the block, possibly with other\n+\t\t insn notes that got moved there.  */\n+\t      for (note = NEXT_INSN (last); ; note = NEXT_INSN (note))\n+\t\t{\n+\t\t  if (NOTE_P (note)\n+\t\t      && NOTE_KIND (note) == NOTE_INSN_PROLOGUE_END)\n+\t\t    break;\n+\t\t}\n \t    }\n \n \t  /* Avoid placing note between CODE_LABEL and BASIC_BLOCK note.  */\n@@ -5291,41 +5335,39 @@ reposition_prologue_and_epilogue_notes (void)\n \t}\n     }\n \n-  if ((len = VEC_length (int, epilogue)) > 0)\n+  if (epilogue_insn_hash != NULL)\n     {\n-      last = 0, note = 0;\n+      edge_iterator ei;\n+      edge e;\n \n-      /* Scan from the end until we reach the first epilogue insn.\n-\t We apparently can't depend on basic_block_{head,end} after\n-\t reorg has run.  */\n-      for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n \t{\n-\t  if (NOTE_P (insn))\n-\t    {\n-\t      if (NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG)\n-\t\tnote = insn;\n-\t    }\n-\t  else if (contains (insn, &epilogue))\n-\t    {\n-\t      last = insn;\n-\t      if (--len == 0)\n-\t\tbreak;\n-\t    }\n-\t}\n+\t  last = 0, note = 0;\n+\t  bb = e->src;\n \n-      if (last)\n-\t{\n-\t  /* Find the epilogue-begin note if we haven't already, and\n-\t     move it to just before the first epilogue insn.  */\n-\t  if (note == 0)\n+\t  /* Scan from the beginning until we reach the first epilogue insn.\n+\t     Take the cue for whether this is a plain or sibcall epilogue\n+\t     from the kind of note we find first.  */\n+\t  FOR_BB_INSNS (bb, insn)\n \t    {\n-\t      for (note = insn; (note = PREV_INSN (note));)\n-\t\tif (NOTE_P (note)\n-\t\t    && NOTE_KIND (note) == NOTE_INSN_EPILOGUE_BEG)\n-\t\t  break;\n+\t      if (NOTE_P (insn))\n+\t\t{\n+\t\t  if (NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t\t    {\n+\t\t      note = insn;\n+\t\t      if (last)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t      else if (contains (insn, epilogue_insn_hash))\n+\t\t{\n+\t\t  last = insn;\n+\t\t  if (note != NULL)\n+\t\t    break;\n+\t\t}\n \t    }\n-\n-\t  if (PREV_INSN (last) != note)\n+\t     \n+\t  if (last && note && PREV_INSN (last) != note)\n \t    reorder_insns (note, note, PREV_INSN (last));\n \t}\n     }"}, {"sha": "83161ec14b6eb524ee9fe16e01935be9a42cbd41", "filename": "gcc/insn-notes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Finsn-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Finsn-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finsn-notes.def?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -70,4 +70,8 @@ INSN_NOTE (BASIC_BLOCK)\n    between hot and cold text sections.  */\n INSN_NOTE (SWITCH_TEXT_SECTIONS)\n \n+/* Mark the restore point after an epilogue changed CFI data.  Used only\n+   when an epilogue appears in the middle of a function.  */\n+INSN_NOTE (CFA_RESTORE_STATE)\n+\n #undef INSN_NOTE"}, {"sha": "c3af16a06a7ea80b47115a6c372bb2e6a4ceabe1", "filename": "gcc/jump.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -869,8 +869,21 @@ returnjump_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *loc;\n \n-  return x && (GET_CODE (x) == RETURN\n-\t       || (GET_CODE (x) == SET && SET_IS_RETURN_P (x)));\n+  if (x == NULL)\n+    return false;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case RETURN:\n+    case EH_RETURN:\n+      return true;\n+\n+    case SET:\n+      return SET_IS_RETURN_P (x);\n+\n+    default:\n+      return false;\n+    }\n }\n \n int\n@@ -881,6 +894,22 @@ returnjump_p (rtx insn)\n   return for_each_rtx (&PATTERN (insn), returnjump_p_1, NULL);\n }\n \n+/* Return true if INSN is a (possibly conditional) return insn.  */\n+\n+static int\n+eh_returnjump_p_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n+{\n+  return *loc && GET_CODE (*loc) == EH_RETURN;\n+}\n+\n+int\n+eh_returnjump_p (rtx insn)\n+{\n+  if (!JUMP_P (insn))\n+    return 0;\n+  return for_each_rtx (&PATTERN (insn), eh_returnjump_p_1, NULL);\n+}\n+\n /* Return true if INSN is a jump that only transfers control and\n    nothing more.  */\n "}, {"sha": "90b5fde3feb0515da39bd623af662fced3281530", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -118,6 +118,41 @@ REG_NOTE (BR_PRED)\n    instead of intuition.  */\n REG_NOTE (FRAME_RELATED_EXPR)\n \n+/* Attached to insns that are RTX_FRAME_RELATED_P, but are too complex\n+   for FRAME_RELATED_EXPR intuition.  The insn's first pattern must be\n+   a SET, and the destination must be the CFA register.  The attached\n+   rtx is an expression that defines the CFA.  In the simplest case, the\n+   rtx could be just the stack_pointer_rtx; more common would be a PLUS\n+   with a base register and a constant offset.  In the most complicated\n+   cases, this will result in a DW_CFA_def_cfa_expression with the rtx\n+   expression rendered in a dwarf location expression.  */\n+REG_NOTE (CFA_DEF_CFA)\n+\n+/* Attached to insns that are RTX_FRAME_RELATED_P, but are too complex\n+   for FRAME_RELATED_EXPR intuition.  This note adjusts the expression\n+   from which the CFA is computed.  The attached rtx defines a new CFA\n+   expression, relative to the old CFA expression.  This rtx must be of\n+   the form (SET new-cfa-reg (PLUS old-cfa-reg const_int)).  If the note\n+   rtx is NULL, we use the first SET of the insn.  */\n+REG_NOTE (CFA_ADJUST_CFA)\n+\n+/* Similar to FRAME_RELATED_EXPR, with the additional information that\n+   this is a save to memory, i.e. will result in DW_CFA_offset or the\n+   like.  The pattern or the insn should be a simple store relative to\n+   the CFA.  */\n+REG_NOTE (CFA_OFFSET)\n+\n+/* Similar to FRAME_RELATED_EXPR, with the additional information that this\n+   is a save to a register, i.e. will result in DW_CFA_register.  The insn\n+   or the pattern should be simple reg-reg move.  */\n+REG_NOTE (CFA_REGISTER)\n+\n+/* Attached to insns that are RTX_FRAME_RELATED_P, with the information\n+   that this is a restore operation, i.e. will result in DW_CFA_restore\n+   or the like.  Either the attached rtx, or the destination of the insn's\n+   first pattern is the register to be restored.  */\n+REG_NOTE (CFA_RESTORE)\n+\n /* Indicates that REG holds the exception context for the function.\n    This context is shared by inline functions, so the code to acquire\n    the real exception context is delayed until after inlining.  */"}, {"sha": "090546b3ebe599dfda68ff157fa513b92f17d094", "filename": "gcc/rtl.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -281,6 +281,10 @@ DEF_RTL_EXPR(CALL, \"call\", \"ee\", RTX_EXTRA)\n \n DEF_RTL_EXPR(RETURN, \"return\", \"\", RTX_EXTRA)\n \n+/* Special for EH return from subroutine.  */\n+\n+DEF_RTL_EXPR(EH_RETURN, \"eh_return\", \"\", RTX_EXTRA)\n+\n /* Conditional trap.\n    Operand 1 is the condition.\n    Operand 2 is the trap code."}, {"sha": "152761bcb1cc491d39b6ba734acc0d675cbf8ce2", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cd9c1ca866b6aa5041a352e0ed07ae5f91e235e5", "patch": "@@ -2086,6 +2086,7 @@ extern rtx pc_set (const_rtx);\n extern rtx condjump_label (const_rtx);\n extern int simplejump_p (const_rtx);\n extern int returnjump_p (rtx);\n+extern int eh_returnjump_p (rtx);\n extern int onlyjump_p (const_rtx);\n extern int only_sets_cc0_p (const_rtx);\n extern int sets_cc0_p (const_rtx);\n@@ -2198,6 +2199,7 @@ extern int prologue_epilogue_contains (const_rtx);\n extern int sibcall_epilogue_contains (const_rtx);\n extern void mark_temp_addr_taken (rtx);\n extern void update_temp_slot_address (rtx, rtx);\n+extern void maybe_copy_epilogue_insn (rtx, rtx);\n \n /* In stmt.c */\n extern void expand_null_return (void);"}]}