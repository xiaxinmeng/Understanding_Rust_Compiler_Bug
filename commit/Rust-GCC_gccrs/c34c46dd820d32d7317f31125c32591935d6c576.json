{"sha": "c34c46dd820d32d7317f31125c32591935d6c576", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0YzQ2ZGQ4MjBkMzJkNzMxN2YzMTEyNWMzMjU5MTkzNWQ2YzU3Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-09-08T18:15:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-09-08T18:15:49Z"}, "message": "ira.c (update_equiv_regs): Only call set_paradoxical_subreg for non-debug insns.\n\ngcc/\n\t* ira.c (update_equiv_regs): Only call set_paradoxical_subreg\n\tfor non-debug insns.\n\t* lra.c (new_insn_reg): Take the containing insn as a parameter.\n\tOnly modify lra_reg_info[].biggest_mode if it's non-debug insn.\n\t(collect_non_operand_hard_regs, add_regs_to_insn_regno_info): Update\n\taccordingly.\n\ngcc/testsuite/\n\t* g++.dg/debug/ra1.C: New test.\n\nFrom-SVN: r202369", "tree": {"sha": "69f099305b134fbef5cfa2d3f7762f5f23cbda38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69f099305b134fbef5cfa2d3f7762f5f23cbda38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c34c46dd820d32d7317f31125c32591935d6c576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34c46dd820d32d7317f31125c32591935d6c576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34c46dd820d32d7317f31125c32591935d6c576", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34c46dd820d32d7317f31125c32591935d6c576/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3462aa02a699dc716bd366fee8fc1c85f7f94541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3462aa02a699dc716bd366fee8fc1c85f7f94541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3462aa02a699dc716bd366fee8fc1c85f7f94541"}], "stats": {"total": 115, "additions": 102, "deletions": 13}, "files": [{"sha": "7d3867c2c6434cdd939e1d8fd118c0e0ac3310c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c34c46dd820d32d7317f31125c32591935d6c576", "patch": "@@ -1,3 +1,12 @@\n+2013-09-08  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* ira.c (update_equiv_regs): Only call set_paradoxical_subreg\n+\tfor non-debug insns.\n+\t* lra.c (new_insn_reg): Take the containing insn as a parameter.\n+\tOnly modify lra_reg_info[].biggest_mode if it's non-debug insn.\n+\t(collect_non_operand_hard_regs, add_regs_to_insn_regno_info): Update\n+\taccordingly.\n+\n 2013-09-08  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraphunit.c (walk_polymorphic_call_targets): Permit 0 possible"}, {"sha": "44fa0bc2835a2797898674cfbf11dfc2b7e1a67c", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=c34c46dd820d32d7317f31125c32591935d6c576", "patch": "@@ -2944,11 +2944,8 @@ update_equiv_regs (void)\n      prevent access beyond allocated memory for paradoxical memory subreg.  */\n   FOR_EACH_BB (bb)\n     FOR_BB_INSNS (bb, insn)\n-      {\n-\tif (! INSN_P (insn))\n-\t  continue;\n-\tfor_each_rtx (&insn, set_paradoxical_subreg, (void *)pdx_subregs);\n-      }\n+      if (NONDEBUG_INSN_P (insn))\n+\tfor_each_rtx (&insn, set_paradoxical_subreg, (void *) pdx_subregs);\n \n   /* Scan the insns and find which registers have equivalences.  Do this\n      in a separate scan of the insns because (due to -fcse-follow-jumps)"}, {"sha": "ef69526b0ecb771d2cb80ce405c425269879063e", "filename": "gcc/lra.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=c34c46dd820d32d7317f31125c32591935d6c576", "patch": "@@ -480,21 +480,22 @@ init_insn_regs (void)\n     = create_alloc_pool (\"insn regs\", sizeof (struct lra_insn_reg), 100);\n }\n \n-/* Create LRA insn related info about referenced REGNO with TYPE\n-   (in/out/inout), biggest reference mode MODE, flag that it is\n+/* Create LRA insn related info about a reference to REGNO in INSN with\n+   TYPE (in/out/inout), biggest reference mode MODE, flag that it is\n    reference through subreg (SUBREG_P), flag that is early clobbered\n    in the insn (EARLY_CLOBBER), and reference to the next insn reg\n    info (NEXT).\t */\n static struct lra_insn_reg *\n-new_insn_reg (int regno, enum op_type type, enum machine_mode mode,\n+new_insn_reg (rtx insn, int regno, enum op_type type, enum machine_mode mode,\n \t      bool subreg_p, bool early_clobber, struct lra_insn_reg *next)\n {\n   struct lra_insn_reg *ir;\n \n   ir = (struct lra_insn_reg *) pool_alloc (insn_reg_pool);\n   ir->type = type;\n   ir->biggest_mode = mode;\n-  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (lra_reg_info[regno].biggest_mode))\n+  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (lra_reg_info[regno].biggest_mode)\n+      && NONDEBUG_INSN_P (insn))\n     lra_reg_info[regno].biggest_mode = mode;\n   ir->subreg_p = subreg_p;\n   ir->early_clobber = early_clobber;\n@@ -976,7 +977,7 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n \t\t     && ! (FIRST_STACK_REG <= regno\n \t\t\t   && regno <= LAST_STACK_REG));\n #endif\n-\t\tlist = new_insn_reg (regno, type, mode, subreg_p,\n+\t\tlist = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n \t\t\t\t     early_clobber, list);\n \t      }\n \t  }\n@@ -1575,7 +1576,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n       expand_reg_info ();\n       if (bitmap_set_bit (&lra_reg_info[regno].insn_bitmap, uid))\n \t{\n-\t  data->regs = new_insn_reg (regno, type, mode, subreg_p,\n+\t  data->regs = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n \t\t\t\t     early_clobber, data->regs);\n \t  return;\n \t}\n@@ -1587,8 +1588,9 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n \t\tif (curr->subreg_p != subreg_p || curr->biggest_mode != mode)\n \t\t  /* The info can not be integrated into the found\n \t\t     structure.  */\n-\t\t  data->regs = new_insn_reg (regno, type, mode, subreg_p,\n-\t\t\t\t\t     early_clobber, data->regs);\n+\t\t  data->regs = new_insn_reg (data->insn, regno, type, mode,\n+\t\t\t\t\t     subreg_p, early_clobber,\n+\t\t\t\t\t     data->regs);\n \t\telse\n \t\t  {\n \t\t    if (curr->type != type)"}, {"sha": "92eaeabd03e8b97e985b10edb8220d2852163ad7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c34c46dd820d32d7317f31125c32591935d6c576", "patch": "@@ -1,3 +1,7 @@\n+2013-09-08  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* g++.dg/debug/ra1.C: New test.\n+\n 2013-09-08  Jan Hubicka  <jh@suse.cz>\n \n \t* testsuite/g++.dg/ipa/devirt-11.C: Update template."}, {"sha": "b6f7bfc588d8729f7b544264b6540ea9d993f0c4", "filename": "gcc/testsuite/g++.dg/debug/ra1.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fra1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34c46dd820d32d7317f31125c32591935d6c576/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fra1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fra1.C?ref=c34c46dd820d32d7317f31125c32591935d6c576", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-options \"-fcompare-debug\" } */\n+\n+enum signop { SIGNED, UNSIGNED };\n+enum tree_code { FOO, BAR };\n+enum tree_code_class { tcc_type, tcc_other };\n+extern enum tree_code_class tree_code_type[];\n+\n+struct tree_base {\n+  enum tree_code code : 16;\n+  unsigned unsigned_flag : 1;\n+};\n+\n+struct tree_def {\n+  tree_base base;\n+  struct {\n+    int precision;\n+  } type_common;\n+};\n+\n+typedef tree_def *tree;\n+\n+struct storage_ref\n+{\n+  storage_ref (const long *, unsigned int, unsigned int);\n+\n+  const long *val;\n+  unsigned int len;\n+  unsigned int precision;\n+};\n+\n+inline storage_ref::storage_ref (const long *val_in,\n+\t\t\t\t unsigned int len_in,\n+\t\t\t\t unsigned int precision_in)\n+  : val (val_in), len (len_in), precision (precision_in)\n+{\n+}\n+\n+struct hwi_with_prec\n+{\n+  long val;\n+  unsigned int precision;\n+  signop sgn;\n+};\n+\n+inline storage_ref\n+decompose (long *scratch, unsigned int precision,\n+\t   const hwi_with_prec &x)\n+{\n+  scratch[0] = x.val;\n+  if (x.sgn == SIGNED || x.val >= 0 || precision <= sizeof (long) * 8)\n+    return storage_ref (scratch, 1, precision);\n+  scratch[1] = 0;\n+  return storage_ref (scratch, 2, precision);\n+}\n+\n+extern void tree_class_check_failed (int) __attribute__ ((__noreturn__));\n+\n+inline tree\n+tree_class_check (tree t, const enum tree_code_class cls, int x)\n+{\n+  if (tree_code_type[t->base.code] != cls)\n+    tree_class_check_failed (x);\n+  return t;\n+}\n+\n+tree wide_int_to_tree (tree, const storage_ref &);\n+\n+tree\n+build_int_cstu (tree type, unsigned long val)\n+{\n+  hwi_with_prec x;\n+  x.val = val;\n+  x.precision = tree_class_check (type, tcc_type, 1)->type_common.precision;\n+  x.sgn = (signop) tree_class_check (type, tcc_type, 2)->base.unsigned_flag;\n+  long scratch[2];\n+  return wide_int_to_tree (type, decompose (scratch, x.precision, x));\n+}"}]}