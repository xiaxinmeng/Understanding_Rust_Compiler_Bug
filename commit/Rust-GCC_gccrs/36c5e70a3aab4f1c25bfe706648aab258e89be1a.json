{"sha": "36c5e70a3aab4f1c25bfe706648aab258e89be1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZjNWU3MGEzYWFiNGYxYzI1YmZlNzA2NjQ4YWFiMjU4ZTg5YmUxYQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2009-10-26T21:58:06Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2009-10-26T21:58:06Z"}, "message": "tm.texi (TARGET_ADDR_SPACE_KEYWORDS): Document.\n\n2009-10-26  Ben Elliston  <bje@au.ibm.com>\n\t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Ulrich Weigand  <uweigand@de.ibm.com>\n\n\t* doc/tm.texi (TARGET_ADDR_SPACE_KEYWORDS): Document.\n\n\t* c-common.c (c_common_reswords): If TARGET_ADDR_SPACE_KEYWORDS is\n\tdefined, add the named address space keywords.\n\t(c_addr_space_name): New function.\n\t(complete_array_type): Preserve named address space.\n\t(handle_mode_attribute): Use targetm.addr_space.valid_pointer_mode\n\tinstead of targetm.valid_pointer_mode.\n\n\t* c-common.h (enum rid): Add RID_ADDR_SPACE_0 .. RID_ADDR_SPACE_15,\n\tRID_FIRST_ADDR_SPACE and RID_LAST_ADDR_SPACE.\n\t(ADDR_SPACE_KEYWORD): New macro.\n\t(c_addr_space_name): Add prototype.\n\n\t* c-tree.h (struct c_declspecs): Add address_space member.\n\t(declspecs_add_addrspace): Add prototype.\n\n\t* c-pretty-print.c (pp_c_type_qualifier_list): Handle address spaces.\n\n\t* c-parser.c (c_parse_init): Add assertion.\n\t(typedef enum c_id_kind): Add C_ID_ADDRSPACE.\n\t(c_lex_one_token): Handle address space keywords.\n\t(c_token_starts_typename): Likewise.\n\t(c_token_starts_declspecs): Likewise.\n\t(c_parser_declspecs): Likewise.\n\t(c_parser_postfix_expression_after_paren_type): Diagnose compound\n\tliteral within function qualified with named address space.\n\n\t* c-decl.c (diagnose_mismatched_decls): Diagnose conflicting named\n\taddress space qualifiers.\n\t(shadow_tag_warned): Warn about useless address space qualifiers.\n\t(quals_from_declspecs): Handle address space qualifiers.\n\t(grokdeclarator): Likewise.\n\t(build_null_declspecs): Likewise.\n\t(declspecs_add_addrspace): New function.\n\n\t* c-typeck.c (addr_space_superset): New function.\n\t(qualify_type): Handle named address spaces.\n\t(composite_type): Likewise.\n\t(common_pointer_type): Likewise.\n\t(comp_target_types): Likewise.\n\t(build_conditional_expr): Likewise.\n\t(handle_warn_cast_qual): Likewise.\n\t(build_c_cast): Likewise.\n\t(convert_for_assignment): Likewise.\n\t(build_binary_op): Likewise.\n\t(pointer_diff): Handle named address spaces.  Use intermediate\n\tinteger type of sufficient size if required.\n\nCo-Authored-By: Michael Meissner <meissner@linux.vnet.ibm.com>\nCo-Authored-By: Ulrich Weigand <uweigand@de.ibm.com>\n\nFrom-SVN: r153574", "tree": {"sha": "309434d678721acedb299f20cdc2b4778062b180", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/309434d678721acedb299f20cdc2b4778062b180"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36c5e70a3aab4f1c25bfe706648aab258e89be1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36c5e70a3aab4f1c25bfe706648aab258e89be1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36c5e70a3aab4f1c25bfe706648aab258e89be1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36c5e70a3aab4f1c25bfe706648aab258e89be1a/comments", "author": null, "committer": null, "parents": [{"sha": "d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ebfa65c962f1f0b50223e34184dc5a81d907c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4ebfa65c962f1f0b50223e34184dc5a81d907c6"}], "stats": {"total": 582, "additions": 541, "deletions": 41}, "files": [{"sha": "db375c7fb92a1a8a24a29457c3b5a04dc64d8243", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -1,3 +1,56 @@\n+2009-10-26  Ben Elliston  <bje@au.ibm.com>\n+\t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* doc/tm.texi (TARGET_ADDR_SPACE_KEYWORDS): Document.\n+\n+\t* c-common.c (c_common_reswords): If TARGET_ADDR_SPACE_KEYWORDS is\n+\tdefined, add the named address space keywords.\n+\t(c_addr_space_name): New function.\n+\t(complete_array_type): Preserve named address space.\n+\t(handle_mode_attribute): Use targetm.addr_space.valid_pointer_mode\n+\tinstead of targetm.valid_pointer_mode.\n+\n+\t* c-common.h (enum rid): Add RID_ADDR_SPACE_0 .. RID_ADDR_SPACE_15,\n+\tRID_FIRST_ADDR_SPACE and RID_LAST_ADDR_SPACE.\n+\t(ADDR_SPACE_KEYWORD): New macro.\n+\t(c_addr_space_name): Add prototype.\n+\n+\t* c-tree.h (struct c_declspecs): Add address_space member.\n+\t(declspecs_add_addrspace): Add prototype.\n+\n+\t* c-pretty-print.c (pp_c_type_qualifier_list): Handle address spaces.\n+\n+\t* c-parser.c (c_parse_init): Add assertion.\n+\t(typedef enum c_id_kind): Add C_ID_ADDRSPACE.\n+\t(c_lex_one_token): Handle address space keywords.\n+\t(c_token_starts_typename): Likewise.\n+\t(c_token_starts_declspecs): Likewise.\n+\t(c_parser_declspecs): Likewise.\n+\t(c_parser_postfix_expression_after_paren_type): Diagnose compound\n+\tliteral within function qualified with named address space.\n+\n+\t* c-decl.c (diagnose_mismatched_decls): Diagnose conflicting named\n+\taddress space qualifiers.\n+\t(shadow_tag_warned): Warn about useless address space qualifiers.\n+\t(quals_from_declspecs): Handle address space qualifiers.\n+\t(grokdeclarator): Likewise.\n+\t(build_null_declspecs): Likewise.\n+\t(declspecs_add_addrspace): New function.\n+\n+\t* c-typeck.c (addr_space_superset): New function.\n+\t(qualify_type): Handle named address spaces.\n+\t(composite_type): Likewise.\n+\t(common_pointer_type): Likewise.\n+\t(comp_target_types): Likewise.\n+\t(build_conditional_expr): Likewise.\n+\t(handle_warn_cast_qual): Likewise.\n+\t(build_c_cast): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\t(build_binary_op): Likewise.\n+\t(pointer_diff): Handle named address spaces.  Use intermediate\n+\tinteger type of sufficient size if required.\n+\n 2009-10-26  Ben Elliston  <bje@au.ibm.com>\n \t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n \t    Ulrich Weigand  <uweigand@de.ibm.com>"}, {"sha": "1f30d06f4c7bda22ebcc4b37b6a5bea4de13555e", "filename": "gcc/c-common.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -710,6 +710,11 @@ const struct c_common_resword c_common_reswords[] =\n   { \"inout\",\t\tRID_INOUT,\t\tD_OBJC },\n   { \"oneway\",\t\tRID_ONEWAY,\t\tD_OBJC },\n   { \"out\",\t\tRID_OUT,\t\tD_OBJC },\n+\n+#ifdef TARGET_ADDR_SPACE_KEYWORDS\n+  /* Any address space keywords recognized by the target.  */\n+  TARGET_ADDR_SPACE_KEYWORDS,\n+#endif\n };\n \n const unsigned int num_c_common_reswords =\n@@ -840,6 +845,19 @@ const struct attribute_spec c_common_format_attribute_table[] =\n   { NULL,                     0, 0, false, false, false, NULL }\n };\n \n+/* Return identifier for address space AS.  */\n+const char *\n+c_addr_space_name (addr_space_t as)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < num_c_common_reswords; i++)\n+    if (c_common_reswords[i].rid == RID_FIRST_ADDR_SPACE + as)\n+      return c_common_reswords[i].word;\n+\n+  gcc_unreachable ();\n+}\n+\n /* Push current bindings for the function name VAR_DECLS.  */\n \n void\n@@ -6459,9 +6477,10 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \n       if (POINTER_TYPE_P (type))\n \t{\n+\t  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (type));\n \t  tree (*fn)(tree, enum machine_mode, bool);\n \n-\t  if (!targetm.valid_pointer_mode (mode))\n+\t  if (!targetm.addr_space.valid_pointer_mode (mode, as))\n \t    {\n \t      error (\"invalid pointer mode %qs\", p);\n \t      return NULL_TREE;\n@@ -8511,7 +8530,7 @@ complete_array_type (tree *ptype, tree initial_value, bool do_default)\n   if (quals == 0)\n     unqual_elt = elt;\n   else\n-    unqual_elt = c_build_qualified_type (elt, TYPE_UNQUALIFIED);\n+    unqual_elt = c_build_qualified_type (elt, KEEP_QUAL_ADDR_SPACE (quals));\n \n   /* Using build_distinct_type_copy and modifying things afterward instead\n      of using build_array_type to create a new type preserves all of the"}, {"sha": "d91546ff23945d7a2649a0d1c5b2603a23e255b9", "filename": "gcc/c-common.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -126,6 +126,30 @@ enum rid\n   RID_AT_INTERFACE,\n   RID_AT_IMPLEMENTATION,\n \n+  /* Named address support, mapping the keyword to a particular named address\n+     number.  Named address space 0 is reserved for the generic address.  If\n+     there are more than 254 named addresses, the addr_space_t type will need\n+     to be grown from an unsigned char to unsigned short.  */\n+  RID_ADDR_SPACE_0,\t\t/* generic address */\n+  RID_ADDR_SPACE_1,\n+  RID_ADDR_SPACE_2,\n+  RID_ADDR_SPACE_3,\n+  RID_ADDR_SPACE_4,\n+  RID_ADDR_SPACE_5,\n+  RID_ADDR_SPACE_6,\n+  RID_ADDR_SPACE_7,\n+  RID_ADDR_SPACE_8,\n+  RID_ADDR_SPACE_9,\n+  RID_ADDR_SPACE_10,\n+  RID_ADDR_SPACE_11,\n+  RID_ADDR_SPACE_12,\n+  RID_ADDR_SPACE_13,\n+  RID_ADDR_SPACE_14,\n+  RID_ADDR_SPACE_15,\n+\n+  RID_FIRST_ADDR_SPACE = RID_ADDR_SPACE_0,\n+  RID_LAST_ADDR_SPACE = RID_ADDR_SPACE_15,\n+\n   RID_MAX,\n \n   RID_FIRST_MODIFIER = RID_STATIC,\n@@ -263,6 +287,10 @@ struct c_common_resword\n #define D_CXX_OBJC\t0x100\t/* In Objective C, and C++, but not C.  */\n #define D_CXXWARN\t0x200\t/* In C warn with -Wcxx-compat.  */\n \n+/* Macro for backends to define named address keywords.  */\n+#define ADDR_SPACE_KEYWORD(STRING, VALUE) \\\n+  { STRING, RID_FIRST_ADDR_SPACE + (VALUE), D_CONLY | D_EXT }\n+\n /* The reserved keyword table.  */\n extern const struct c_common_resword c_common_reswords[];\n \n@@ -760,6 +788,7 @@ extern const struct attribute_spec c_common_format_attribute_table[];\n \n extern tree (*make_fname_decl) (location_t, tree, int);\n \n+extern const char *c_addr_space_name (addr_space_t as);\n extern tree identifier_global_value (tree);\n extern void record_builtin_type (enum rid, const char *, tree);\n extern tree build_void_list_node (void);"}, {"sha": "492d2e673b72b57964decb157e4451d482042817", "filename": "gcc/c-decl.c", "status": "modified", "additions": 128, "deletions": 7, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -1746,8 +1746,35 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t}\n       else\n \t{\n-\t  if (TYPE_QUALS (newtype) != TYPE_QUALS (oldtype))\n-\t    error (\"conflicting type qualifiers for %q+D\", newdecl);\n+\t  int new_quals = TYPE_QUALS (newtype);\n+\t  int old_quals = TYPE_QUALS (oldtype);\n+\n+\t  if (new_quals != old_quals)\n+\t    {\n+\t      addr_space_t new_addr = DECODE_QUAL_ADDR_SPACE (new_quals);\n+\t      addr_space_t old_addr = DECODE_QUAL_ADDR_SPACE (old_quals);\n+\t      if (new_addr != old_addr)\n+\t\t{\n+\t\t  if (ADDR_SPACE_GENERIC_P (new_addr))\n+\t\t    error (\"conflicting named address spaces (generic vs %s) \"\n+\t\t\t   \"for %q+D\",\n+\t\t\t   c_addr_space_name (old_addr), newdecl);\n+\t\t  else if (ADDR_SPACE_GENERIC_P (old_addr))\n+\t\t    error (\"conflicting named address spaces (%s vs generic) \"\n+\t\t\t   \"for %q+D\",\n+\t\t\t   c_addr_space_name (new_addr), newdecl);\n+\t\t  else\n+\t\t    error (\"conflicting named address spaces (%s vs %s) \"\n+\t\t\t   \"for %q+D\",\n+\t\t\t   c_addr_space_name (new_addr),\n+\t\t\t   c_addr_space_name (old_addr),\n+\t\t\t   newdecl);\n+\t\t}\n+\n+\t      if (CLEAR_QUAL_ADDR_SPACE (new_quals)\n+\t\t  != CLEAR_QUAL_ADDR_SPACE (old_quals))\n+\t\terror (\"conflicting type qualifiers for %q+D\", newdecl);\n+\t    }\n \t  else\n \t    error (\"conflicting types for %q+D\", newdecl);\n \t  diagnose_arglist_conflict (newdecl, olddecl, newtype, oldtype);\n@@ -3605,7 +3632,8 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t  else if (!declspecs->tag_defined_p\n \t\t   && (declspecs->const_p\n \t\t       || declspecs->volatile_p\n-\t\t       || declspecs->restrict_p))\n+\t\t       || declspecs->restrict_p\n+\t\t       || declspecs->address_space))\n \t    {\n \t      if (warned != 1)\n \t\tpedwarn (input_location, 0,\n@@ -3676,7 +3704,8 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \n   if (!warned && !in_system_header && (declspecs->const_p\n \t\t\t\t       || declspecs->volatile_p\n-\t\t\t\t       || declspecs->restrict_p))\n+\t\t\t\t       || declspecs->restrict_p\n+\t\t\t\t       || declspecs->address_space))\n     {\n       warning (0, \"useless type qualifier in empty declaration\");\n       warned = 2;\n@@ -3699,7 +3728,8 @@ quals_from_declspecs (const struct c_declspecs *specs)\n {\n   int quals = ((specs->const_p ? TYPE_QUAL_CONST : 0)\n \t       | (specs->volatile_p ? TYPE_QUAL_VOLATILE : 0)\n-\t       | (specs->restrict_p ? TYPE_QUAL_RESTRICT : 0));\n+\t       | (specs->restrict_p ? TYPE_QUAL_RESTRICT : 0)\n+\t       | (ENCODE_QUAL_ADDR_SPACE (specs->address_space)));\n   gcc_assert (!specs->type\n \t      && !specs->decl_attr\n \t      && specs->typespec_word == cts_none\n@@ -4750,6 +4780,7 @@ grokdeclarator (const struct c_declarator *declarator,\n   bool bitfield = width != NULL;\n   tree element_type;\n   struct c_arg_info *arg_info = 0;\n+  addr_space_t as1, as2, address_space;\n   location_t loc = UNKNOWN_LOCATION;\n   const char *errmsg;\n   tree expr_dummy;\n@@ -4880,6 +4911,10 @@ grokdeclarator (const struct c_declarator *declarator,\n   constp = declspecs->const_p + TYPE_READONLY (element_type);\n   restrictp = declspecs->restrict_p + TYPE_RESTRICT (element_type);\n   volatilep = declspecs->volatile_p + TYPE_VOLATILE (element_type);\n+  as1 = declspecs->address_space;\n+  as2 = TYPE_ADDR_SPACE (element_type);\n+  address_space = ADDR_SPACE_GENERIC_P (as1)? as2 : as1;\n+\n   if (pedantic && !flag_isoc99)\n     {\n       if (constp > 1)\n@@ -4889,11 +4924,17 @@ grokdeclarator (const struct c_declarator *declarator,\n       if (volatilep > 1)\n \tpedwarn (loc, OPT_pedantic, \"duplicate %<volatile%>\");\n     }\n+\n+  if (!ADDR_SPACE_GENERIC_P (as1) && !ADDR_SPACE_GENERIC_P (as2) && as1 != as2)\n+    error_at (loc, \"conflicting named address spaces (%s vs %s)\",\n+\t      c_addr_space_name (as1), c_addr_space_name (as2));\n+\n   if (!flag_gen_aux_info && (TYPE_QUALS (element_type)))\n     type = TYPE_MAIN_VARIANT (type);\n   type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n \t\t| (restrictp ? TYPE_QUAL_RESTRICT : 0)\n-\t\t| (volatilep ? TYPE_QUAL_VOLATILE : 0));\n+\t\t| (volatilep ? TYPE_QUAL_VOLATILE : 0)\n+\t\t| ENCODE_QUAL_ADDR_SPACE (address_space));\n \n   /* Warn about storage classes that are invalid for certain\n      kinds of declarations (parameters, typenames, etc.).  */\n@@ -5309,7 +5350,14 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       it, but here we want to make sure we don't ever\n \t       modify the shared type, so we gcc_assert (itype)\n \t       below.  */\n-\t      type = build_array_type (type, itype);\n+\t      {\n+\t\taddr_space_t as = DECODE_QUAL_ADDR_SPACE (type_quals);\n+\t\tif (!ADDR_SPACE_GENERIC_P (as) && as != TYPE_ADDR_SPACE (type))\n+\t\t  type = build_qualified_type (type,\n+\t\t\t\t\t       ENCODE_QUAL_ADDR_SPACE (as));\n+\n+\t\ttype = build_array_type (type, itype);\n+\t      }\n \n \t    if (type != error_mark_node)\n \t      {\n@@ -5515,6 +5563,59 @@ grokdeclarator (const struct c_declarator *declarator,\n   /* Now TYPE has the actual type, apart from any qualifiers in\n      TYPE_QUALS.  */\n \n+  /* Warn about address space used for things other than static memory or\n+     pointers.  */\n+  address_space = DECODE_QUAL_ADDR_SPACE (type_quals);\n+  if (!ADDR_SPACE_GENERIC_P (address_space))\n+    {\n+      if (decl_context == NORMAL)\n+\t{\n+\t  switch (storage_class)\n+\t    {\n+\t    case csc_auto:\n+\t      error (\"%qs combined with %<auto%> qualifier for %qE\",\n+\t\t     c_addr_space_name (address_space), name);\n+\t      break;\n+\t    case csc_register:\n+\t      error (\"%qs combined with %<register%> qualifier for %qE\",\n+\t\t     c_addr_space_name (address_space), name);\n+\t      break;\n+\t    case csc_none:\n+\t      if (current_function_scope)\n+\t\t{\n+\t\t  error (\"%qs specified for auto variable %qE\",\n+\t\t\t c_addr_space_name (address_space), name);\n+\t\t  break;\n+\t\t}\n+\t      break;\n+\t    case csc_static:\n+\t    case csc_extern:\n+\t    case csc_typedef:\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      else if (decl_context == PARM && TREE_CODE (type) != ARRAY_TYPE)\n+\t{\n+\t  if (name)\n+\t    error (\"%qs specified for parameter %qE\",\n+\t\t   c_addr_space_name (address_space), name);\n+\t  else\n+\t    error (\"%qs specified for unnamed parameter\",\n+\t\t   c_addr_space_name (address_space));\n+\t}\n+      else if (decl_context == FIELD)\n+\t{\n+\t  if (name)\n+\t    error (\"%qs specified for structure field %qE\",\n+\t\t   c_addr_space_name (address_space), name);\n+\t  else\n+\t    error (\"%qs specified for structure field\",\n+\t\t   c_addr_space_name (address_space));\n+\t}\n+    }\n+\n   /* Check the type and width of a bit-field.  */\n   if (bitfield)\n     check_bitfield_type_and_width (&type, width, name);\n@@ -8297,9 +8398,29 @@ build_null_declspecs (void)\n   ret->volatile_p = false;\n   ret->restrict_p = false;\n   ret->saturating_p = false;\n+  ret->address_space = ADDR_SPACE_GENERIC;\n   return ret;\n }\n \n+/* Add the address space ADDRSPACE to the declaration specifiers\n+   SPECS, returning SPECS.  */\n+\n+struct c_declspecs *\n+declspecs_add_addrspace (struct c_declspecs *specs, addr_space_t as)\n+{\n+  specs->non_sc_seen_p = true;\n+  specs->declspecs_seen_p = true;\n+\n+  if (!ADDR_SPACE_GENERIC_P (specs->address_space)\n+      && specs->address_space != as)\n+    error (\"incompatible address space qualifiers %qs and %qs\",\n+\t   c_addr_space_name (as),\n+\t   c_addr_space_name (specs->address_space));\n+  else\n+    specs->address_space = as;\n+  return specs;\n+}\n+\n /* Add the type qualifier QUAL to the declaration specifiers SPECS,\n    returning SPECS.  */\n "}, {"sha": "1a6012e9128c7e2c4fb98c7d2a0ba92e55b26c26", "filename": "gcc/c-parser.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -72,6 +72,10 @@ c_parse_init (void)\n   tree id;\n   int mask = 0;\n \n+  /* Make sure RID_MAX hasn't grown past the 8 bits used to hold the keyword in\n+     the c_token structure.  */\n+  gcc_assert (RID_MAX <= 255);\n+\n   mask |= D_CXXONLY;\n   if (!flag_isoc99)\n     mask |= D_C99;\n@@ -132,6 +136,8 @@ typedef enum c_id_kind {\n   C_ID_TYPENAME,\n   /* An identifier declared as an Objective-C class name.  */\n   C_ID_CLASSNAME,\n+  /* An address space identifier.  */\n+  C_ID_ADDRSPACE,\n   /* Not an identifier.  */\n   C_ID_NONE\n } c_id_kind;\n@@ -226,6 +232,13 @@ c_lex_one_token (c_parser *parser, c_token *token)\n \t\t\t    \"identifier %qE conflicts with C++ keyword\",\n \t\t\t    token->value);\n \t      }\n+\t    else if (rid_code >= RID_FIRST_ADDR_SPACE\n+\t\t     && rid_code <= RID_LAST_ADDR_SPACE)\n+\t      {\n+\t\ttoken->id_kind = C_ID_ADDRSPACE;\n+\t\ttoken->keyword = rid_code;\n+\t\tbreak;\n+\t      }\n \t    else if (c_dialect_objc ())\n \t      {\n \t\tif (!objc_is_reserved_word (token->value)\n@@ -352,6 +365,8 @@ c_token_starts_typename (c_token *token)\n \t{\n \tcase C_ID_ID:\n \t  return false;\n+\tcase C_ID_ADDRSPACE:\n+\t  return true;\n \tcase C_ID_TYPENAME:\n \t  return true;\n \tcase C_ID_CLASSNAME:\n@@ -422,6 +437,8 @@ c_token_starts_declspecs (c_token *token)\n \t{\n \tcase C_ID_ID:\n \t  return false;\n+\tcase C_ID_ADDRSPACE:\n+\t  return true;\n \tcase C_ID_TYPENAME:\n \t  return true;\n \tcase C_ID_CLASSNAME:\n@@ -1411,6 +1428,7 @@ c_parser_asm_definition (c_parser *parser)\n      const\n      restrict\n      volatile\n+     address-space-qualifier\n \n    (restrict is new in C99.)\n \n@@ -1419,6 +1437,12 @@ c_parser_asm_definition (c_parser *parser)\n    declaration-specifiers:\n      attributes declaration-specifiers[opt]\n \n+   type-qualifier:\n+     address-space\n+\n+   address-space:\n+     identifier recognized by the target\n+\n    storage-class-specifier:\n      __thread\n \n@@ -1459,6 +1483,17 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t{\n \t  tree value = c_parser_peek_token (parser)->value;\n \t  c_id_kind kind = c_parser_peek_token (parser)->id_kind;\n+\n+\t  if (kind == C_ID_ADDRSPACE)\n+\t    {\n+\t      addr_space_t as\n+\t\t= c_parser_peek_token (parser)->keyword - RID_FIRST_ADDR_SPACE;\n+\t      declspecs_add_addrspace (specs, as);\n+\t      c_parser_consume_token (parser);\n+\t      attrs_ok = true;\n+\t      continue;\n+\t    }\n+\n \t  /* This finishes the specifiers unless a type name is OK, it\n \t     is declared as a type name and a type name hasn't yet\n \t     been seen.  */\n@@ -5775,6 +5810,14 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   finish_init ();\n   maybe_warn_string_init (type, init);\n \n+  if (type != error_mark_node\n+      && !ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (type))\n+      && current_function_decl)\n+    {\n+      error (\"compound literal qualified by address-space qualifier\");\n+      type = error_mark_node;\n+    }\n+\n   if (!flag_isoc99)\n     pedwarn (start_loc, OPT_pedantic, \"ISO C90 forbids compound literals\");\n   non_const = ((init.value && TREE_CODE (init.value) == CONSTRUCTOR)"}, {"sha": "01770014c21cf13db2a11e371c6c559324b992ed", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -225,7 +225,11 @@ pp_c_space_for_pointer_operator (c_pretty_printer *pp, tree t)\n        const\n        restrict                              -- C99\n        __restrict__                          -- GNU C\n-       volatile    */\n+       address-space-qualifier\t\t     -- GNU C\n+       volatile\n+\n+   address-space-qualifier:\n+       identifier\t\t\t     -- GNU C  */\n \n void\n pp_c_type_qualifier_list (c_pretty_printer *pp, tree t)\n@@ -245,6 +249,12 @@ pp_c_type_qualifier_list (c_pretty_printer *pp, tree t)\n     pp_c_cv_qualifier (pp, \"volatile\");\n   if (qualifiers & TYPE_QUAL_RESTRICT)\n     pp_c_cv_qualifier (pp, flag_isoc99 ? \"restrict\" : \"__restrict__\");\n+\n+  if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (t)))\n+    {\n+      const char *as = c_addr_space_name (TYPE_ADDR_SPACE (t));\n+      pp_c_identifier (pp, as);\n+    }\n }\n \n /* pointer:"}, {"sha": "e71771ae84038414191dd7e3b3147b4488d78de1", "filename": "gcc/c-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -277,6 +277,8 @@ struct c_declspecs {\n   BOOL_BITFIELD restrict_p : 1;\n   /* Whether \"_Sat\" was specified.  */\n   BOOL_BITFIELD saturating_p : 1;\n+  /* The address space that the declaration belongs to.  */\n+  addr_space_t address_space;\n };\n \n /* The various kinds of declarators in C.  */\n@@ -476,6 +478,8 @@ extern struct c_declspecs *declspecs_add_type (location_t,\n \t\t\t\t\t       struct c_typespec);\n extern struct c_declspecs *declspecs_add_scspec (struct c_declspecs *, tree);\n extern struct c_declspecs *declspecs_add_attrs (struct c_declspecs *, tree);\n+extern struct c_declspecs *declspecs_add_addrspace (struct c_declspecs *,\n+\t\t\t\t\t\t    addr_space_t);\n extern struct c_declspecs *finish_declspecs (struct c_declspecs *);\n \n /* in c-objc-common.c */"}, {"sha": "c7d2bc8da22095c34b445c14dc3c5cc4f80e0da9", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 240, "deletions": 31, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -284,14 +284,55 @@ c_type_promotes_to (tree type)\n   return type;\n }\n \n+/* Return true if between two named address spaces, whether there is a superset\n+   named address space that encompasses both address spaces.  If there is a\n+   superset, return which address space is the superset.  */\n+\n+static bool\n+addr_space_superset (addr_space_t as1, addr_space_t as2, addr_space_t *common)\n+{\n+  if (as1 == as2)\n+    {\n+      *common = as1;\n+      return true;\n+    }\n+  else if (targetm.addr_space.subset_p (as1, as2))\n+    {\n+      *common = as2;\n+      return true;\n+    }\n+  else if (targetm.addr_space.subset_p (as2, as1))\n+    {\n+      *common = as1;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n /* Return a variant of TYPE which has all the type qualifiers of LIKE\n    as well as those of TYPE.  */\n \n static tree\n qualify_type (tree type, tree like)\n {\n+  addr_space_t as_type = TYPE_ADDR_SPACE (type);\n+  addr_space_t as_like = TYPE_ADDR_SPACE (like);\n+  addr_space_t as_common;\n+\n+  /* If the two named address spaces are different, determine the common\n+     superset address space.  If there isn't one, raise an error.  */\n+  if (!addr_space_superset (as_type, as_like, &as_common))\n+    {\n+      as_common = as_type;\n+      error (\"%qT and %qT are in disjoint named address spaces\",\n+\t     type, like);\n+    }\n+\n   return c_build_qualified_type (type,\n-\t\t\t\t TYPE_QUALS (type) | TYPE_QUALS (like));\n+\t\t\t\t TYPE_QUALS_NO_ADDR_SPACE (type)\n+\t\t\t\t | TYPE_QUALS_NO_ADDR_SPACE (like)\n+\t\t\t\t | ENCODE_QUAL_ADDR_SPACE (as_common));\n }\n \n /* Return true iff the given tree T is a variable length array.  */\n@@ -371,7 +412,8 @@ composite_type (tree t1, tree t2)\n \tbool t1_complete, t2_complete;\n \n \t/* We should not have any type quals on arrays at all.  */\n-\tgcc_assert (!TYPE_QUALS (t1) && !TYPE_QUALS (t2));\n+\tgcc_assert (!TYPE_QUALS_NO_ADDR_SPACE (t1)\n+\t\t    && !TYPE_QUALS_NO_ADDR_SPACE (t2));\n \n \tt1_complete = COMPLETE_TYPE_P (t1);\n \tt2_complete = COMPLETE_TYPE_P (t2);\n@@ -585,6 +627,8 @@ common_pointer_type (tree t1, tree t2)\n   tree pointed_to_2, mv2;\n   tree target;\n   unsigned target_quals;\n+  addr_space_t as1, as2, as_common;\n+  int quals1, quals2;\n \n   /* Save time if the two types are the same.  */\n \n@@ -616,10 +660,24 @@ common_pointer_type (tree t1, tree t2)\n   /* For function types do not merge const qualifiers, but drop them\n      if used inconsistently.  The middle-end uses these to mark const\n      and noreturn functions.  */\n+  quals1 = TYPE_QUALS_NO_ADDR_SPACE (pointed_to_1);\n+  quals2 = TYPE_QUALS_NO_ADDR_SPACE (pointed_to_2);\n+\n   if (TREE_CODE (pointed_to_1) == FUNCTION_TYPE)\n-    target_quals = TYPE_QUALS (pointed_to_1) & TYPE_QUALS (pointed_to_2);\n+    target_quals = (quals1 & quals2);\n   else\n-    target_quals = TYPE_QUALS (pointed_to_1) | TYPE_QUALS (pointed_to_2);\n+    target_quals = (quals1 | quals2);\n+\n+  /* If the two named address spaces are different, determine the common\n+     superset address space.  This is guaranteed to exist due to the\n+     assumption that comp_target_type returned non-zero.  */\n+  as1 = TYPE_ADDR_SPACE (pointed_to_1);\n+  as2 = TYPE_ADDR_SPACE (pointed_to_2);\n+  if (!addr_space_superset (as1, as2, &as_common))\n+    gcc_unreachable ();\n+\n+  target_quals |= ENCODE_QUAL_ADDR_SPACE (as_common);\n+\n   t1 = build_pointer_type (c_build_qualified_type (target, target_quals));\n   return build_type_attribute_variant (t1, attributes);\n }\n@@ -1103,20 +1161,28 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p)\n   return attrval == 2 && val == 1 ? 2 : val;\n }\n \n-/* Return 1 if TTL and TTR are pointers to types that are equivalent,\n-   ignoring their qualifiers.  */\n+/* Return 1 if TTL and TTR are pointers to types that are equivalent, ignoring\n+   their qualifiers, except for named address spaces.  If the pointers point to\n+   different named addresses, then we must determine if one address space is a\n+   subset of the other.  */\n \n static int\n comp_target_types (location_t location, tree ttl, tree ttr)\n {\n   int val;\n-  tree mvl, mvr;\n+  tree mvl = TREE_TYPE (ttl);\n+  tree mvr = TREE_TYPE (ttr);\n+  addr_space_t asl = TYPE_ADDR_SPACE (mvl);\n+  addr_space_t asr = TYPE_ADDR_SPACE (mvr);\n+  addr_space_t as_common;\n   bool enum_and_int_p;\n \n+  /* Fail if pointers point to incompatible address spaces.  */\n+  if (!addr_space_superset (asl, asr, &as_common))\n+    return 0;\n+\n   /* Do not lose qualifiers on element types of array types that are\n      pointer targets by taking their TYPE_MAIN_VARIANT.  */\n-  mvl = TREE_TYPE (ttl);\n-  mvr = TREE_TYPE (ttr);\n   if (TREE_CODE (mvl) != ARRAY_TYPE)\n     mvl = TYPE_MAIN_VARIANT (mvl);\n   if (TREE_CODE (mvr) != ARRAY_TYPE)\n@@ -3063,11 +3129,43 @@ static tree\n pointer_diff (location_t loc, tree op0, tree op1)\n {\n   tree restype = ptrdiff_type_node;\n+  tree result, inttype;\n \n+  addr_space_t as0 = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (op0)));\n+  addr_space_t as1 = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (op1)));\n   tree target_type = TREE_TYPE (TREE_TYPE (op0));\n   tree con0, con1, lit0, lit1;\n   tree orig_op1 = op1;\n \n+  /* If the operands point into different address spaces, we need to\n+     explicitly convert them to pointers into the common address space\n+     before we can subtract the numerical address values.  */\n+  if (as0 != as1)\n+    {\n+      addr_space_t as_common;\n+      tree common_type;\n+\n+      /* Determine the common superset address space.  This is guaranteed\n+\t to exist because the caller verified that comp_target_types\n+\t returned non-zero.  */\n+      if (!addr_space_superset (as0, as1, &as_common))\n+\tgcc_unreachable ();\n+\n+      common_type = common_pointer_type (TREE_TYPE (op0), TREE_TYPE (op1));\n+      op0 = convert (common_type, op0);\n+      op1 = convert (common_type, op1);\n+    }\n+\n+  /* Determine integer type to perform computations in.  This will usually\n+     be the same as the result type (ptrdiff_t), but may need to be a wider\n+     type if pointers for the address space are wider than ptrdiff_t.  */\n+  if (TYPE_PRECISION (restype) < TYPE_PRECISION (TREE_TYPE (op0)))\n+    inttype = lang_hooks.types.type_for_size\n+\t\t(TYPE_PRECISION (TREE_TYPE (op0)), 0);\n+  else\n+    inttype = restype;\n+\n+\n   if (TREE_CODE (target_type) == VOID_TYPE)\n     pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t     \"pointer of type %<void *%> used in subtraction\");\n@@ -3125,8 +3223,8 @@ pointer_diff (location_t loc, tree op0, tree op1)\n      in case restype is a short type.  */\n \n   op0 = build_binary_op (loc,\n-\t\t\t MINUS_EXPR, convert (restype, op0),\n-\t\t\t convert (restype, op1), 0);\n+\t\t\t MINUS_EXPR, convert (inttype, op0),\n+\t\t\t convert (inttype, op1), 0);\n   /* This generates an error if op1 is pointer to incomplete type.  */\n   if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (orig_op1))))\n     error_at (loc, \"arithmetic on pointer to an incomplete type\");\n@@ -3135,8 +3233,11 @@ pointer_diff (location_t loc, tree op0, tree op1)\n   op1 = c_size_in_bytes (target_type);\n \n   /* Divide by the size, in easiest possible way.  */\n-  return fold_build2_loc (loc, EXACT_DIV_EXPR, restype,\n-\t\t\t  op0, convert (restype, op1));\n+  result = fold_build2_loc (loc, EXACT_DIV_EXPR, inttype,\n+\t\t\t    op0, convert (inttype, op1));\n+\n+  /* Convert to final result type if necessary.  */\n+  return convert (restype, result);\n }\n \f\n /* Construct and perhaps optimize a tree representation\n@@ -3956,12 +4057,22 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n     }\n   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n     {\n+      addr_space_t as1 = TYPE_ADDR_SPACE (TREE_TYPE (type1));\n+      addr_space_t as2 = TYPE_ADDR_SPACE (TREE_TYPE (type2));\n+      addr_space_t as_common;\n+\n       if (comp_target_types (colon_loc, type1, type2))\n \tresult_type = common_pointer_type (type1, type2);\n       else if (null_pointer_constant_p (orig_op1))\n-\tresult_type = qualify_type (type2, type1);\n+\tresult_type = type2;\n       else if (null_pointer_constant_p (orig_op2))\n-\tresult_type = qualify_type (type1, type2);\n+\tresult_type = type1;\n+      else if (!addr_space_superset (as1, as2, &as_common))\n+\t{\n+\t  error_at (colon_loc, \"pointers to disjoint address spaces \"\n+\t\t    \"used in conditional expression\");\n+\t  return error_mark_node;\n+\t}\n       else if (VOID_TYPE_P (TREE_TYPE (type1)))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n@@ -3982,10 +4093,13 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t}\n       else\n \t{\n+\t  int qual = ENCODE_QUAL_ADDR_SPACE (as_common);\n+\n \t  if (!objc_ok)\n \t    pedwarn (colon_loc, 0,\n \t\t     \"pointer type mismatch in conditional expression\");\n-\t  result_type = build_pointer_type (void_type_node);\n+\t  result_type = build_pointer_type\n+\t\t\t  (build_qualified_type (void_type_node, qual));\n \t}\n     }\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n@@ -4144,7 +4258,8 @@ build_compound_expr (location_t loc, tree expr1, tree expr2)\n /* Issue -Wcast-qual warnings when appropriate.  TYPE is the type to\n    which we are casting.  OTYPE is the type of the expression being\n    cast.  Both TYPE and OTYPE are pointer types.  -Wcast-qual appeared\n-   on the command line.  */\n+   on the command line.  Named address space qualifiers are not handled\n+   here, because they result in different warnings.  */\n \n static void\n handle_warn_cast_qual (tree type, tree otype)\n@@ -4170,9 +4285,11 @@ handle_warn_cast_qual (tree type, tree otype)\n \t taken away.  */\n       if (TREE_CODE (in_otype) == FUNCTION_TYPE\n \t  && TREE_CODE (in_type) == FUNCTION_TYPE)\n-\tadded |= (TYPE_QUALS (in_type) & ~TYPE_QUALS (in_otype));\n+\tadded |= (TYPE_QUALS_NO_ADDR_SPACE (in_type)\n+\t\t  & ~TYPE_QUALS_NO_ADDR_SPACE (in_otype));\n       else\n-\tdiscarded |= (TYPE_QUALS (in_otype) & ~TYPE_QUALS (in_type));\n+\tdiscarded |= (TYPE_QUALS_NO_ADDR_SPACE (in_otype)\n+\t\t      & ~TYPE_QUALS_NO_ADDR_SPACE (in_type));\n     }\n   while (TREE_CODE (in_type) == POINTER_TYPE\n \t && TREE_CODE (in_otype) == POINTER_TYPE);\n@@ -4321,6 +4438,36 @@ build_c_cast (location_t loc, tree type, tree expr)\n \t  && TREE_CODE (otype) == POINTER_TYPE)\n \thandle_warn_cast_qual (type, otype);\n \n+      /* Warn about conversions between pointers to disjoint\n+\t address spaces.  */\n+      if (TREE_CODE (type) == POINTER_TYPE\n+\t  && TREE_CODE (otype) == POINTER_TYPE\n+\t  && !null_pointer_constant_p (value))\n+\t{\n+\t  addr_space_t as_to = TYPE_ADDR_SPACE (TREE_TYPE (type));\n+\t  addr_space_t as_from = TYPE_ADDR_SPACE (TREE_TYPE (otype));\n+\t  addr_space_t as_common;\n+\n+\t  if (!addr_space_superset (as_to, as_from, &as_common))\n+\t    {\n+\t      if (ADDR_SPACE_GENERIC_P (as_from))\n+\t\twarning_at (loc, 0, \"cast to %s address space pointer \"\n+\t\t\t    \"from disjoint generic address space pointer\",\n+\t\t\t    c_addr_space_name (as_to));\n+\n+\t      else if (ADDR_SPACE_GENERIC_P (as_to))\n+\t\twarning_at (loc, 0, \"cast to generic address space pointer \"\n+\t\t\t    \"from disjoint %s address space pointer\",\n+\t\t\t    c_addr_space_name (as_from));\n+\n+\t      else\n+\t\twarning_at (loc, 0, \"cast to %s address space pointer \"\n+\t\t\t    \"from disjoint %s address space pointer\",\n+\t\t\t    c_addr_space_name (as_to),\n+\t\t\t    c_addr_space_name (as_from));\n+\t    }\n+\t}\n+\n       /* Warn about possible alignment problems.  */\n       if (STRICT_ALIGNMENT\n \t  && TREE_CODE (type) == POINTER_TYPE\n@@ -4915,7 +5062,8 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t     certain things, it is okay to use a const or volatile\n \t\t     function where an ordinary one is wanted, but not\n \t\t     vice-versa.  */\n-\t\t  if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n+\t\t  if (TYPE_QUALS_NO_ADDR_SPACE (ttl)\n+\t\t      & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))\n \t\t    WARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t\t\t G_(\"passing argument %d of %qE \"\n \t\t\t\t\t    \"makes qualified function \"\n@@ -4929,7 +5077,8 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t\t\t\t G_(\"return makes qualified function \"\n \t\t\t\t\t    \"pointer from unqualified\"));\n \t\t}\n-\t      else if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n+\t      else if (TYPE_QUALS_NO_ADDR_SPACE (ttr)\n+\t\t       & ~TYPE_QUALS_NO_ADDR_SPACE (ttl))\n \t\tWARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t\t     G_(\"passing argument %d of %qE discards \"\n \t\t\t\t\t\"qualifiers from pointer target type\"),\n@@ -4962,6 +5111,8 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n       tree mvr = ttr;\n       bool is_opaque_pointer;\n       int target_cmp = 0;   /* Cache comp_target_types () result.  */\n+      addr_space_t asl;\n+      addr_space_t asr;\n \n       if (TREE_CODE (mvl) != ARRAY_TYPE)\n \tmvl = TYPE_MAIN_VARIANT (mvl);\n@@ -4982,6 +5133,36 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t    \t    \"request for implicit conversion \"\n \t\t    \"from %qT to %qT not permitted in C++\", rhstype, type);\n \n+      /* See if the pointers point to incompatible address spaces.  */\n+      asl = TYPE_ADDR_SPACE (ttl);\n+      asr = TYPE_ADDR_SPACE (ttr);\n+      if (!null_pointer_constant_p (rhs)\n+\t  && asr != asl && !targetm.addr_space.subset_p (asr, asl))\n+\t{\n+\t  switch (errtype)\n+\t    {\n+\t    case ic_argpass:\n+\t      error_at (location, \"passing argument %d of %qE from pointer to \"\n+\t\t\t\"non-enclosed address space\", parmnum, rname);\n+\t      break;\n+\t    case ic_assign:\n+\t      error_at (location, \"assignment from pointer to \"\n+\t\t\t\"non-enclosed address space\");\n+\t      break;\n+\t    case ic_init:\n+\t      error_at (location, \"initialization from pointer to \"\n+\t\t\t\"non-enclosed address space\");\n+\t      break;\n+\t    case ic_return:\n+\t      error_at (location, \"return from pointer to \"\n+\t\t\t\"non-enclosed address space\");\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  return error_mark_node;\n+\t}\n+\n       /* Check if the right-hand side has a format attribute but the\n \t left-hand side doesn't.  */\n       if (warn_missing_format_attribute\n@@ -5045,7 +5226,8 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t  else if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   && TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n-\t      if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n+\t      if (TYPE_QUALS_NO_ADDR_SPACE (ttr)\n+\t\t  & ~TYPE_QUALS_NO_ADDR_SPACE (ttl))\n \t\t{\n \t\t  /* Types differing only by the presence of the 'volatile'\n \t\t     qualifier are acceptable if the 'volatile' has been added\n@@ -5085,7 +5267,8 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t that say the function will not do certain things,\n \t\t it is okay to use a const or volatile function\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n-\t      if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n+\t      if (TYPE_QUALS_NO_ADDR_SPACE (ttl)\n+\t\t  & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))\n \t\tWARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t\t     G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\t\"qualified function pointer \"\n@@ -9193,24 +9376,34 @@ build_binary_op (location_t location, enum tree_code code,\n \t{\n \t  tree tt0 = TREE_TYPE (type0);\n \t  tree tt1 = TREE_TYPE (type1);\n+\t  addr_space_t as0 = TYPE_ADDR_SPACE (tt0);\n+\t  addr_space_t as1 = TYPE_ADDR_SPACE (tt1);\n+\t  addr_space_t as_common = ADDR_SPACE_GENERIC;\n+\n \t  /* Anything compares with void *.  void * compares with anything.\n \t     Otherwise, the targets must be compatible\n \t     and both must be object or both incomplete.  */\n \t  if (comp_target_types (location, type0, type1))\n \t    result_type = common_pointer_type (type0, type1);\n+\t  else if (null_pointer_constant_p (orig_op0))\n+\t    result_type = type1;\n+\t  else if (null_pointer_constant_p (orig_op1))\n+\t    result_type = type0;\n+\t  else if (!addr_space_superset (as0, as1, &as_common))\n+\t    {\n+\t      error_at (location, \"comparison of pointers to \"\n+\t\t\t\"disjoint address spaces\");\n+\t      return error_mark_node;\n+\t    }\n \t  else if (VOID_TYPE_P (tt0))\n \t    {\n-\t      /* op0 != orig_op0 detects the case of something\n-\t\t whose value is 0 but which isn't a valid null ptr const.  */\n-\t      if (pedantic && !null_pointer_constant_p (orig_op0)\n-\t\t  && TREE_CODE (tt1) == FUNCTION_TYPE)\n+\t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE)\n \t\tpedwarn (location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n \t  else if (VOID_TYPE_P (tt1))\n \t    {\n-\t      if (pedantic && !null_pointer_constant_p (orig_op1)\n-\t\t  && TREE_CODE (tt0) == FUNCTION_TYPE)\n+\t      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE)\n \t\tpedwarn (location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"comparison of %<void *%> with function pointer\");\n \t    }\n@@ -9221,7 +9414,11 @@ build_binary_op (location_t location, enum tree_code code,\n \t\t       \"comparison of distinct pointer types lacks a cast\");\n \n \t  if (result_type == NULL_TREE)\n-\t    result_type = ptr_type_node;\n+\t    {\n+\t      int qual = ENCODE_QUAL_ADDR_SPACE (as_common);\n+\t      result_type = build_pointer_type\n+\t\t\t      (build_qualified_type (void_type_node, qual));\n+\t    }\n \t}\n       else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \t{\n@@ -9265,6 +9462,10 @@ build_binary_op (location_t location, enum tree_code code,\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n+\t  addr_space_t as0 = TYPE_ADDR_SPACE (TREE_TYPE (type0));\n+\t  addr_space_t as1 = TYPE_ADDR_SPACE (TREE_TYPE (type1));\n+\t  addr_space_t as_common;\n+\n \t  if (comp_target_types (location, type0, type1))\n \t    {\n \t      result_type = common_pointer_type (type0, type1);\n@@ -9276,9 +9477,17 @@ build_binary_op (location_t location, enum tree_code code,\n \t\tpedwarn (location, OPT_pedantic, \"ISO C forbids \"\n \t\t\t \"ordered comparisons of pointers to functions\");\n \t    }\n+\t  else if (!addr_space_superset (as0, as1, &as_common))\n+\t    {\n+\t      error_at (location, \"comparison of pointers to \"\n+\t\t\t\"disjoint address spaces\");\n+\t      return error_mark_node;\n+\t    }\n \t  else\n \t    {\n-\t      result_type = ptr_type_node;\n+\t      int qual = ENCODE_QUAL_ADDR_SPACE (as_common);\n+\t      result_type = build_pointer_type\n+\t\t\t      (build_qualified_type (void_type_node, qual));\n \t      pedwarn (location, 0,\n \t\t       \"comparison of distinct pointer types lacks a cast\");\n \t    }"}, {"sha": "8df014dad9935c97148f246517571d9dd5fc3c43", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36c5e70a3aab4f1c25bfe706648aab258e89be1a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=36c5e70a3aab4f1c25bfe706648aab258e89be1a", "patch": "@@ -9855,6 +9855,18 @@ Internally, address spaces are represented as a small integer in the\n range 0 to 15 with address space 0 being reserved for the generic\n address space.\n \n+@defmac TARGET_ADDR_SPACE_KEYWORDS\n+A list of @code{ADDR_SPACE_KEYWORD} macros to define each named\n+address keyword.  The @code{ADDR_SPACE_KEYWORD} macro takes two\n+arguments, the keyword string and the number of the named address\n+space.  For example, the SPU port uses the following to declare\n+@code{__ea} as the keyword for named address space #1:\n+@smallexample\n+#define ADDR_SPACE_EA 1\n+#define TARGET_ADDR_SPACE_KEYWORDS ADDR_SPACE_KEYWORD (\"__ea\", ADDR_SPACE_EA)\n+@end smallexample\n+@end defmac\n+\n @deftypefn {Target Hook} {enum machine_mode} TARGET_ADDR_SPACE_POINTER_MODE (addr_space_t @var{address_space})\n Define this to return the machine mode to use for pointers to\n @var{address_space} if the target supports named address spaces."}]}