{"sha": "fe19a83d8a2719459520baa77d240a945c365b5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUxOWE4M2Q4YTI3MTk0NTk1MjBiYWE3N2QyNDBhOTQ1YzM2NWI1Yg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-11-11T17:45:02Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-11-11T17:45:02Z"}, "message": "milli64.S: Fix comment formatting.\n\n\t* config/pa/milli64.S: Fix comment formatting.\n\t* config/pa/pa-64.h: Likewise.\n\t* config/pa/pa-linux.h: Likewise.\n\t* config/pa/pa-protos.h: Likewise.\n\t* config/pa/pa.c: Likewise.\n\t* config/pa/pa.h: Likewise.\n\t* config/pa/pa32-linux.h: Likewise.\n\t* config/pa/pa32-regs.h: Likewise.\n\t* config/pa/pa64-hpux.h: Likewise.\n\t* config/pa/pa64-regs.h: Likewise.\n\t* config/pa/som.h: Likewise.\n\nFrom-SVN: r46930", "tree": {"sha": "fb02cb5536197f3e86e30e92dd6cba7770735eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb02cb5536197f3e86e30e92dd6cba7770735eb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe19a83d8a2719459520baa77d240a945c365b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe19a83d8a2719459520baa77d240a945c365b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe19a83d8a2719459520baa77d240a945c365b5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe19a83d8a2719459520baa77d240a945c365b5b/comments", "author": null, "committer": null, "parents": [{"sha": "b64a6a114ed6ffbde48a1f9bf2af25f31b690b23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b64a6a114ed6ffbde48a1f9bf2af25f31b690b23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b64a6a114ed6ffbde48a1f9bf2af25f31b690b23"}], "stats": {"total": 122, "additions": 68, "deletions": 54}, "files": [{"sha": "9fd73c7a64f36314156bb7e4fc656545d30f2c12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -1,3 +1,17 @@\n+2001-11-11  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/pa/milli64.S: Fix comment formatting.\n+\t* config/pa/pa-64.h: Likewise.\n+\t* config/pa/pa-linux.h: Likewise.\n+\t* config/pa/pa-protos.h: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/pa/pa.h: Likewise.\n+\t* config/pa/pa32-linux.h: Likewise.\n+\t* config/pa/pa32-regs.h: Likewise.\n+\t* config/pa/pa64-hpux.h: Likewise.\n+\t* config/pa/pa64-regs.h: Likewise.\n+\t* config/pa/som.h: Likewise.\n+\n 2001-11-11  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* doc/gcc.texi: Move several chapters out to ..."}, {"sha": "e456d87511000c9ce8eeee0f71789104daeac7a4", "filename": "gcc/config/pa/milli64.S", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fmilli64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fmilli64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fmilli64.S?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -388,7 +388,7 @@ LSYM(small_divisor)\n #if defined(pa64)\n /*  Clear the upper 32 bits of the arg1 register.  We are working with\t*/\n /*  small divisors (and 32 bit integers)   We must not be mislead  */\n-/*  by \"1\" bits left in the upper 32 bits. */\n+/*  by \"1\" bits left in the upper 32 bits.  */\n \tdepd %r0,31,32,%r25\n #endif\n \tblr,n\targ1,r0\n@@ -1765,15 +1765,15 @@ LSYM(l4)\n \tsub,>\t\t0,a1,t0\t\t/* otherwise negate both and */\n \tcombt,<=,n\ta0,t0,LREF(l2)\t/*  swap back if |a0|<|a1| */\n \tsub\t\t0,a0,a1\n-\tmovb,tr,n\tt0,a0,LREF(l2)\t/* 10th inst. */\n+\tmovb,tr,n\tt0,a0,LREF(l2)\t/* 10th inst.  */\n \n LSYM(l0)\tr__r_t0\t\t\t\t/* add in this partial product */\n LSYM(l1)\ta0__256a0\t\t\t/* a0 <<= 8 ****************** */\n LSYM(l2)\tzdep\t\ta1,30,8,t0\t/* t0 = (a1&0xff)<<1 ********* */\n LSYM(l3)\tblr\t\tt0,0\t\t/* case on these 8 bits ****** */\n \t\textru\t\ta1,23,24,a1\t/* a1 >>= 8 ****************** */\n \n-/*16 insts before this. */\n+/*16 insts before this.  */\n /*\t\t\t  a0 <<= 8 ************************** */\n LSYM(x0)\ta1_ne_0_b_l2\t! a0__256a0\t! MILLIRETN\t! nop\n LSYM(x1)\ta1_ne_0_b_l1\t! r__r_a0\t! MILLIRETN\t! nop\n@@ -2031,7 +2031,7 @@ LSYM(x252)\tt0__64a0\t! t0__t0ma0\t! b_e_shift\t! r__r_4t0\n LSYM(x253)\tt0__64a0\t! t0__t0ma0\t! b_e_t0\t! t0__4t0_a0\n LSYM(x254)\tt0__128a0\t! t0__t0ma0\t! b_e_shift\t! r__r_2t0\n LSYM(x255)\tt0__256a0\t! a1_ne_0_b_l0\t! t0__t0ma0\t! b_n_ret_t0\n-/*1040 insts before this. */\n+/*1040 insts before this.  */\n LSYM(ret_t0)\tMILLIRET\n LSYM(e_t0)\tr__r_t0\n LSYM(e_shift)\ta1_ne_0_b_l2"}, {"sha": "a79567af7f50255bd5ecc680703fc92eaa3437a7", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -105,7 +105,7 @@ Boston, MA 02111-1307, USA.  */\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers. */\n+/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n #define MUST_PASS_IN_STACK(MODE,TYPE) \\\n   ((TYPE) != 0\t\t\t\t\t\t\t\\\n    && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\"}, {"sha": "49e167cf824cf91fe35820c72e4bc0160bf18edb", "filename": "gcc/config/pa/pa-linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-linux.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -81,7 +81,7 @@ Boston, MA 02111-1307, USA.  */\n #define BSS_SECTION_ASM_OP \"\\t.section\\t.bss\"\n \n /* Output at beginning of assembler file.  We override the definition\n-   from <linux.h> so that we can get the proper .LEVEL directive. */\n+   from <linux.h> so that we can get the proper .LEVEL directive.  */\n #undef ASM_FILE_START\n #define ASM_FILE_START(FILE) \\\n   do\t\t\t\t\t\t\t\t\\"}, {"sha": "e3487e5a0181f9b80a6af3fe73d48c0b5efa393f", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -19,13 +19,13 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #ifdef RTX_CODE\n-/* Prototype function used in MACHINE_DEPENDENT_REORG macro. */\n+/* Prototype function used in MACHINE_DEPENDENT_REORG macro.  */\n extern void pa_reorg PARAMS ((rtx));\n \n-/* Prototype function used in various macros. */\n+/* Prototype function used in various macros.  */\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n \n-/* Used in insn-*.c. */\n+/* Used in insn-*.c.  */\n extern int following_call PARAMS ((rtx));\n extern int function_label_operand PARAMS ((rtx, enum machine_mode));\n extern int lhs_lshift_cint_operand PARAMS ((rtx, enum machine_mode));\n@@ -126,7 +126,7 @@ extern int insn_refs_are_delayed PARAMS ((rtx));\n /* Prototype function used in macro ASM_OUTPUT_MI_THUNK.  */\n extern void pa_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n \n-/* Prototype function used in macro CONST_OK_FOR_LETTER_P. */\n+/* Prototype function used in macro CONST_OK_FOR_LETTER_P.  */\n extern int zdepi_cint_p PARAMS ((unsigned HOST_WIDE_INT));\n \n extern struct rtx_def *hppa_builtin_saveregs PARAMS ((void));"}, {"sha": "010dfd255433b839dfe50cce4394bada9f8de327", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -245,7 +245,7 @@ symbolic_expression_p (x)\n      register rtx x;\n {\n \n-  /* Strip off any HIGH. */\n+  /* Strip off any HIGH.  */\n   if (GET_CODE (x) == HIGH)\n     x = XEXP (x, 0);\n \n@@ -807,7 +807,7 @@ hppa_legitimize_address (x, oldx, mode)\n   if (flag_pic)\n     return legitimize_pic_address (x, mode, gen_reg_rtx (Pmode));\n \n-  /* Strip off CONST. */\n+  /* Strip off CONST.  */\n   if (GET_CODE (x) == CONST)\n     x = XEXP (x, 0);\n \n@@ -3245,7 +3245,7 @@ load_reg (reg, disp, base)\n    The function epilogue should not depend on the current stack\n    pointer!  It should use the frame pointer only.  This is mandatory\n    because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning. */\n+   adjustments before returning.  */\n \n static void\n pa_output_function_epilogue (file, size)\n@@ -3292,7 +3292,7 @@ hppa_expand_epilogue ()\n \n   /* Try to restore RP early to avoid load/use interlocks when\n      RP gets used in the return (bv) instruction.  This appears to still\n-     be necessary even when we schedule the prologue and epilogue. */\n+     be necessary even when we schedule the prologue and epilogue.  */\n   if (regs_ever_live [2])\n     {\n       ret_off = TARGET_64BIT ? -16 : -20;\n@@ -3992,7 +3992,7 @@ pa_adjust_insn_length (insn, length)\n \treturn 4;\n       /* Adjust dbra insn with short backwards conditional branch with\n \t unfilled delay slot -- only for case where counter is in a\n-\t general register register. */\n+\t general register register.  */\n       else if (GET_CODE (pat) == PARALLEL\n \t       && GET_CODE (XVECEXP (pat, 0, 1)) == SET\n \t       && GET_CODE (XEXP (XVECEXP (pat, 0, 1), 0)) == REG\n@@ -4037,7 +4037,7 @@ print_operand (file, x, code)\n       fputs (reg_names[REGNO (x) + 1], file);\n       return;\n     case 'r':\n-      /* A register or zero. */\n+      /* A register or zero.  */\n       if (x == const0_rtx\n \t  || (x == CONST0_RTX (DFmode))\n \t  || (x == CONST0_RTX (SFmode)))\n@@ -4048,7 +4048,7 @@ print_operand (file, x, code)\n       else\n \tbreak;\n     case 'f':\n-      /* A register or zero (floating point). */\n+      /* A register or zero (floating point).  */\n       if (x == const0_rtx\n \t  || (x == CONST0_RTX (DFmode))\n \t  || (x == CONST0_RTX (SFmode)))\n@@ -4376,7 +4376,7 @@ print_operand (file, x, code)\n     output_addr_const (file, x);\n }\n \n-/* output a SYMBOL_REF or a CONST expression involving a SYMBOL_REF. */\n+/* output a SYMBOL_REF or a CONST expression involving a SYMBOL_REF.  */\n \n void\n output_global_address (file, x, round_constant)\n@@ -4505,7 +4505,7 @@ import_milli (code)\n }\n \n /* The register constraints have put the operands and return value in\n-   the proper registers. */\n+   the proper registers.  */\n \n const char *\n output_mul_insn (unsignedp, insn)\n@@ -4516,15 +4516,15 @@ output_mul_insn (unsignedp, insn)\n   return output_millicode_call (insn, gen_rtx_SYMBOL_REF (Pmode, \"$$mulI\"));\n }\n \n-/* Emit the rtl for doing a division by a constant. */\n+/* Emit the rtl for doing a division by a constant.  */\n \n /* Do magic division millicodes exist for this value? */\n static const int magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0,\n \t\t\t\t 1, 1};\n \n /* We'll use an array to keep track of the magic millicodes and\n    whether or not we've used them already. [n][0] is signed, [n][1] is\n-   unsigned. */\n+   unsigned.  */\n \n static int div_milli[16][2];\n \n@@ -4608,7 +4608,7 @@ output_div_insn (operands, unsignedp, insn)\n \t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, buf));\n \t}\n     }\n-  /* Divisor isn't a special constant. */\n+  /* Divisor isn't a special constant.  */\n   else\n     {\n       if (unsignedp)\n@@ -4626,7 +4626,7 @@ output_div_insn (operands, unsignedp, insn)\n     }\n }\n \n-/* Output a $$rem millicode to do mod. */\n+/* Output a $$rem millicode to do mod.  */\n \n const char *\n output_mod_insn (unsignedp, insn)\n@@ -4836,7 +4836,7 @@ function_arg_padding (mode, type)\n \tsize = int_size_in_bytes (type) * BITS_PER_UNIT;\n       else\n \treturn upward;\t\t/* Don't know if this is right, but */\n-\t\t\t\t/* same as old definition. */\n+\t\t\t\t/* same as old definition.  */\n     }\n   else\n     size = GET_MODE_BITSIZE (mode);\n@@ -4898,7 +4898,7 @@ hppa_builtin_saveregs ()\n \t\t\t\t\toffset, 0, 0, OPTAB_LIB_WIDEN));\n     }\n \n-  /* Store general registers on the stack. */\n+  /* Store general registers on the stack.  */\n   dest = gen_rtx_MEM (BLKmode,\n \t\t      plus_constant (current_function_internal_arg_pointer,\n \t\t\t\t     -16));\n@@ -4949,7 +4949,7 @@ hppa_va_arg (valist, type)\n   if (TARGET_64BIT)\n     {\n       /* Every argument in PA64 is passed by value (including large structs).\n-         Arguments with size greater than 8 must be aligned 0 MOD 16. */\n+         Arguments with size greater than 8 must be aligned 0 MOD 16.  */\n \n       size = int_size_in_bytes (type);\n       if (size > UNITS_PER_WORD)\n@@ -5814,7 +5814,7 @@ output_millicode_call (insn, call_dest)\n       else if (TARGET_PORTABLE_RUNTIME)\n \t{\n \t  xoperands[0] = call_dest;\n-\t  /* Get the address of our target into %r29. */\n+\t  /* Get the address of our target into %r29.  */\n \t  output_asm_insn (\"ldil L%%%0,%%r29\", xoperands);\n \t  output_asm_insn (\"ldo R%%%0(%%r29),%%r29\", xoperands);\n \n@@ -6384,7 +6384,7 @@ non_hard_reg_operand (op, mode)\n }\n \n /* Return 1 if INSN branches forward.  Should be using insn_addresses\n-   to avoid walking through all the insns... */\n+   to avoid walking through all the insns...  */\n static int\n forward_branch_p (insn)\n      rtx insn;\n@@ -7236,7 +7236,7 @@ function_arg (cum, mode, type, named, incoming)\n \n /* If this arg would be passed totally in registers or totally on the stack,\n    then this routine should return zero. It is currently called only for\n-   the 64-bit target. */\n+   the 64-bit target.  */\n int\n function_arg_partial_nregs (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\n@@ -7251,13 +7251,13 @@ function_arg_partial_nregs (cum, mode, type, named)\n     offset = 1;\n \n   if (cum->words + offset + FUNCTION_ARG_SIZE (mode, type) <= max_arg_words)\n-    /* Arg fits fully into registers. */\n+    /* Arg fits fully into registers.  */\n     return 0;\n   else if (cum->words + offset >= max_arg_words)\n-    /* Arg fully on the stack. */\n+    /* Arg fully on the stack.  */\n     return 0;\n   else\n-    /* Arg is split. */\n+    /* Arg is split.  */\n     return max_arg_words - cum->words - offset;\n }\n "}, {"sha": "f6255fae0fe63418d7a666f9e15dd471ac9081da", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -154,7 +154,7 @@ extern int target_flags;\n #define TARGET_64BIT 0\n #endif\n \n-/* Generate code for ELF32 ABI. */\n+/* Generate code for ELF32 ABI.  */\n #ifndef TARGET_ELF32\n #define TARGET_ELF32 0\n #endif\n@@ -340,7 +340,7 @@ extern int target_flags;\n    The definition is be an initializer for an array of structures.  Each\n    array element has have three elements: the switch name, one of the\n    enumeration codes ADD or DELETE to indicate whether the string should be\n-   inserted or deleted, and the string to be inserted or deleted. */\n+   inserted or deleted, and the string to be inserted or deleted.  */\n #define MODIFY_TARGET_NAME {{\"-32\", DELETE, \"64\"}, {\"-64\", ADD, \"64\"}}\n \n /* Make gcc agree with <machine/ansi.h> */\n@@ -438,7 +438,7 @@ extern int target_flags;\n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 64\n \n-/* Get around hp-ux assembler bug, and make strcpy of constants fast. */\n+/* Get around hp-ux assembler bug, and make strcpy of constants fast.  */\n #define CONSTANT_ALIGNMENT(CODE, TYPEALIGN) \\\n   ((TYPEALIGN) < 32 ? 32 : (TYPEALIGN))\n \n@@ -653,7 +653,7 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n /* The weird HPPA calling conventions require a minimum of 48 bytes on\n    the stack: 16 bytes for register saves, and 32 bytes for magic.\n    This is the difference between the logical top of stack and the\n-   actual sp. */\n+   actual sp.  */\n #define STACK_POINTER_OFFSET \\\n   (TARGET_64BIT ? -(current_function_outgoing_args_size + 16): -32)\n \n@@ -740,7 +740,7 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n   (CUM).indirect = 0,\t\t\t\t\\\n   (CUM).nargs_prototype = 1000\n \n-/* Figure out the size in words of the function argument. */\n+/* Figure out the size in words of the function argument.  */\n \n #define FUNCTION_ARG_SIZE(MODE, TYPE)\t\\\n   ((((MODE) != BLKmode \\\n@@ -820,7 +820,7 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n    For args passed entirely in registers or entirely in memory, zero.  */\n \n /* For PA32 there are never split arguments. PA64, on the other hand, can\n-   pass arguments partially in registers and partially in memory. */\n+   pass arguments partially in registers and partially in memory.  */\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   (TARGET_64BIT ? function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED) : 0)\n \n@@ -840,7 +840,7 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n \n /* Arguments larger than eight bytes are passed by invisible reference */\n \n-/* PA64 does not pass anything by invisible reference. */\n+/* PA64 does not pass anything by invisible reference.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n   (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\t\t\\\n@@ -849,7 +849,7 @@ struct hppa_args {int words, nargs_prototype, indirect; };\n  \n /* PA64 does not pass anything by invisible reference.\n    This should be undef'ed for 64bit, but we'll see if this works. The\n-   problem is that we can't test TARGET_64BIT from the preprocessor. */\n+   problem is that we can't test TARGET_64BIT from the preprocessor.  */\n #define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n   (TARGET_64BIT\t\t\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\t\\\n@@ -1004,7 +1004,7 @@ extern int may_call_alloca;\n       emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (FNADDR));\t\\\n       start_addr = memory_address (Pmode, plus_constant ((TRAMP), 64));\t\\\n       emit_move_insn (gen_rtx_MEM (Pmode, start_addr), (CXT));\t\t\\\n-      /* Create a fat pointer for the trampoline. */\t\t\t\\\n+      /* Create a fat pointer for the trampoline.  */\t\t\t\\\n       end_addr = force_reg (Pmode, plus_constant ((TRAMP), 32));\t\\\n       start_addr = memory_address (Pmode, plus_constant ((TRAMP), 16));\t\\\n       emit_move_insn (gen_rtx_MEM (Pmode, start_addr), end_addr);\t\\\n@@ -1470,7 +1470,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n    information).\n \n    On the HP-PA we use this to indicate if a symbol is in text or\n-   data space.  Also, function labels need special treatment. */\n+   data space.  Also, function labels need special treatment.  */\n \n #define TEXT_SPACE_P(DECL)\\\n   (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\t\t\\\n@@ -1569,7 +1569,7 @@ while (0)\n \n /* Add any extra modes needed to represent the condition code.\n \n-   HPPA floating comparisons produce condition codes. */\n+   HPPA floating comparisons produce condition codes.  */\n #define EXTRA_CC_MODES CC(CCFPmode, \"CCFP\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n@@ -1592,7 +1592,7 @@ while (0)\n #define NO_FUNCTION_CSE\n \n /* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits. */\n+   few bits.  */\n #define SHIFT_COUNT_TRUNCATED 1\n \n /* Compute the cost of computing a constant rtl expression RTX"}, {"sha": "8f1fc2d91533d6b7eb634cb8e422d98751861ff2", "filename": "gcc/config/pa/pa32-linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa32-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa32-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-linux.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -18,7 +18,7 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Turn off various SOM crap we don't want. */\n+/* Turn off various SOM crap we don't want.  */\n #undef TARGET_ELF32\n #define TARGET_ELF32 1\n "}, {"sha": "2cd015452390f0deed7b8036eb3cfd3549bb9708", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -17,7 +17,7 @@\n    differently: the left and right halves of registers are addressable\n    as 32 bit registers. So, we will set things up like the 68k which\n    has different fp units: define separate register sets for the 1.0\n-   and 1.1 fp units. */\n+   and 1.1 fp units.  */\n \n #define FIRST_PSEUDO_REGISTER 89  /* 32 general regs + 56 fp regs +\n \t\t\t\t     + 1 shift reg */\n@@ -168,12 +168,12 @@\n    force this to be an even register is it cannot hold the full mode.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n-   /* On 1.0 machines, don't allow wide non-fp modes in fp regs. */\t\\\n+   /* On 1.0 machines, don't allow wide non-fp modes in fp regs.  */\t\\\n    : !TARGET_PA_11 && FP_REGNO_P (REGNO)\t\t\t\t\\\n      ? GET_MODE_SIZE (MODE) <= 4 || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n    : FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n      ? GET_MODE_SIZE (MODE) <= 4 || ((REGNO) & 1) == 0\t\t\t\\\n-   /* Make wide modes be in aligned registers. */\t\t\t\\\n+   /* Make wide modes be in aligned registers.  */\t\t\t\\\n    : (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\t\t\\\n       || (GET_MODE_SIZE (MODE) <= 4 * UNITS_PER_WORD && ((REGNO) & 1) == 0)))\n \n@@ -232,7 +232,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES. Register 0, the \"condition code\" register,\n-   is in no class. */\n+   is in no class.  */\n \n #define REG_CLASS_CONTENTS\t\\\n  {{0x00000000, 0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\"}, {"sha": "ba421fcab4e75b18fc9a8f929dae1cd80ffce7c1", "filename": "gcc/config/pa/pa64-hpux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -107,7 +107,7 @@ do {  \\\n    The definitions say how to change sections to the .init and .fini\n    sections.  This is the same for all known svr4 assemblers.  */\n \n-/* ??? For the time being, we aren't using init sections. */\n+/* ??? For the time being, we aren't using init sections.  */\n #if 0\n #define INIT_SECTION_ASM_OP\t\"\\t.section\\t.init\"\n #define FINI_SECTION_ASM_OP\t\"\\t.section\\t.fini\""}, {"sha": "b193c99b075ed1a75035049d485f686ee55da835", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -161,7 +161,7 @@ Boston, MA 02111-1307, USA.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0\t\t\t\t\t\t\t\t\\\n    ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\t\t\\\n-   /* Make wide modes be in aligned registers. */\t\t\t\\\n+   /* Make wide modes be in aligned registers.  */\t\t\t\\\n    : (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\t\t\\\n       || (GET_MODE_SIZE (MODE) <= 2 * UNITS_PER_WORD && ((REGNO) & 1) == 0)))\n \n@@ -220,7 +220,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FPUPPER_REGS, FP_REGS,\n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES. Register 0, the \"condition code\" register,\n-   is in no class. */\n+   is in no class.  */\n \n #define REG_CLASS_CONTENTS\t\\\n  {{0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\"}, {"sha": "e6ac6fba544a40c0714cc733199f33f79a93a039", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe19a83d8a2719459520baa77d240a945c365b5b/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=fe19a83d8a2719459520baa77d240a945c365b5b", "patch": "@@ -42,7 +42,7 @@ Boston, MA 02111-1307, USA.  */\n     last_function_decl = current_function_decl;\t\t\\\n     sym_lineno += 1; }\n \n-/* gdb needs a null N_SO at the end of each file for scattered loading. */\n+/* gdb needs a null N_SO at the end of each file for scattered loading.  */\n \n #undef\tDBX_OUTPUT_MAIN_SOURCE_FILE_END\n #define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME) \\\n@@ -267,7 +267,7 @@ do {  \\\n    So, we force exception information into the data section.  */\n #define TARGET_ASM_EXCEPTION_SECTION data_section\n \n-/* Define the .bss section for ASM_OUTPUT_LOCAL to use. */\n+/* Define the .bss section for ASM_OUTPUT_LOCAL to use.  */\n \n #define EXTRA_SECTIONS in_readonly_data\n "}]}