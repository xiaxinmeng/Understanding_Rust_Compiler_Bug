{"sha": "468059bcbb8efdb31fd90369dc2ed122126413fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY4MDU5YmNiYjhlZmRiMzFmZDkwMzY5ZGMyZWQxMjIxMjY0MTNmZQ==", "commit": {"author": {"name": "David Daney", "email": "ddaney@caviumnetworks.com", "date": "2009-06-11T23:55:45Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2009-06-11T23:55:45Z"}, "message": "re PR c/39252 (Request new feature __builtin_unreachable ())\n\n2009-06-11  David Daney  <ddaney@caviumnetworks.com>\n\n\tPR c/39252\n\t* doc/extend.texi ( __builtin_unreachable): Document new builtin.\n\t* builtins.c (expand_builtin_unreachable): New function.\n\t(expand_builtin): Handle BUILT_IN_UNREACHABLE case.\n\t* builtins.def (BUILT_IN_UNREACHABLE): Add new builtin.\n\t* cfgcleanup.c (try_optimize_cfg): Delete empty blocks with no\n\tsuccessors.\n\t* cfgrtl.c (rtl_verify_flow_info): Handle empty blocks when\n\tsearching for missing barriers.\n\n2009-06-11  David Daney  <ddaney@caviumnetworks.com>\n\n\tPR c/39252\n\t* gcc.dg/builtin-unreachable-1.c: New test.\n\t* gcc.dg/builtin-unreachable-2.c: Same.\n\nFrom-SVN: r148403", "tree": {"sha": "33e26cb48c7e5455995d1edba975d67cf78cad99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33e26cb48c7e5455995d1edba975d67cf78cad99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/468059bcbb8efdb31fd90369dc2ed122126413fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468059bcbb8efdb31fd90369dc2ed122126413fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468059bcbb8efdb31fd90369dc2ed122126413fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468059bcbb8efdb31fd90369dc2ed122126413fe/comments", "author": null, "committer": null, "parents": [{"sha": "f43def61eaf4f2e1f73c5af6ad806955b8f09949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43def61eaf4f2e1f73c5af6ad806955b8f09949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f43def61eaf4f2e1f73c5af6ad806955b8f09949"}], "stats": {"total": 150, "additions": 144, "deletions": 6}, "files": [{"sha": "7a19b5be40d373a3e1c4f6e03ceb4eaef2720019", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -1,3 +1,15 @@\n+2009-06-11  David Daney  <ddaney@caviumnetworks.com>\n+\n+\tPR c/39252\n+\t* doc/extend.texi ( __builtin_unreachable): Document new builtin.\n+\t* builtins.c (expand_builtin_unreachable): New function.\n+\t(expand_builtin): Handle BUILT_IN_UNREACHABLE case.\n+\t* builtins.def (BUILT_IN_UNREACHABLE): Add new builtin.\n+\t* cfgcleanup.c (try_optimize_cfg): Delete empty blocks with no\n+\tsuccessors.\n+\t* cfgrtl.c (rtl_verify_flow_info): Handle empty blocks when\n+\tsearching for missing barriers.\n+\n 2009-06-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* config/darwin.h (LINK_COMMAND_SPEC): Adjust spec to link libcov"}, {"sha": "98919780e286843fb43bfe33096cbe9c7839754e", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -5298,6 +5298,17 @@ expand_builtin_trap (void)\n   emit_barrier ();\n }\n \n+/* Expand a call to __builtin_unreachable.  We do nothing except emit\n+   a barrier saying that control flow will not pass here.\n+\n+   It is the responsibility of the program being compiled to ensure\n+   that control flow does never reach __builtin_unreachable.  */\n+static void\n+expand_builtin_unreachable (void)\n+{\n+  emit_barrier ();\n+}\n+\n /* Expand EXP, a call to fabs, fabsf or fabsl.\n    Return NULL_RTX if a normal call should be emitted rather than expanding\n    the function inline.  If convenient, the result should be placed\n@@ -6795,6 +6806,10 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       expand_builtin_trap ();\n       return const0_rtx;\n \n+    case BUILT_IN_UNREACHABLE:\n+      expand_builtin_unreachable ();\n+      return const0_rtx;\n+\n     case BUILT_IN_PRINTF:\n       target = expand_builtin_printf (exp, target, mode, false);\n       if (target)"}, {"sha": "8d1693605a6dd7fbc45471d41f09676062be7026", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -698,6 +698,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_SETJMP, \"setjmp\", BT_FN_INT_PTR, ATTR_NULL)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRFMON, \"strfmon\", BT_FN_SSIZE_STRING_SIZE_CONST_STRING_VAR, ATTR_FORMAT_STRFMON_NOTHROW_3_4)\n DEF_LIB_BUILTIN        (BUILT_IN_STRFTIME, \"strftime\", BT_FN_SIZE_STRING_SIZE_CONST_STRING_CONST_PTR, ATTR_FORMAT_STRFTIME_NOTHROW_3_0)\n DEF_GCC_BUILTIN        (BUILT_IN_TRAP, \"trap\", BT_FN_VOID, ATTR_NORETURN_NOTHROW_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_UNREACHABLE, \"unreachable\", BT_FN_VOID, ATTR_NORETURN_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_UNWIND_INIT, \"unwind_init\", BT_FN_VOID, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_UPDATE_SETJMP_BUF, \"update_setjmp_buf\", BT_FN_VOID_PTR_INT, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_VA_COPY, \"va_copy\", BT_FN_VOID_VALIST_REF_VALIST_ARG, ATTR_NOTHROW_LIST)"}, {"sha": "a8b38d7247272cab7d48901bab43351f80cdbf84", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -1873,8 +1873,12 @@ try_optimize_cfg (int mode)\n \t      edge s;\n \t      bool changed_here = false;\n \n-\t      /* Delete trivially dead basic blocks.  */\n-\t      if (EDGE_COUNT (b->preds) == 0)\n+\t      /* Delete trivially dead basic blocks.  This is either\n+\t\t blocks with no predecessors, or empty blocks with no\n+\t\t successors.  Empty blocks may result from expanding\n+\t\t __builtin_unreachable ().  */\n+\t      if (EDGE_COUNT (b->preds) == 0\n+\t\t  || (EDGE_COUNT (b->succs) == 0 && BB_HEAD (b) == BB_END (b)))\n \t\t{\n \t\t  c = b->prev_bb;\n \t\t  if (dump_file)"}, {"sha": "3129ce6bc66c56018bbdcb1e12a571d61471ad44", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -2046,15 +2046,17 @@ rtl_verify_flow_info (void)\n \t  rtx insn;\n \n \t  /* Ensure existence of barrier in BB with no fallthru edges.  */\n-\t  for (insn = BB_END (bb); !insn || !BARRIER_P (insn);\n-\t       insn = NEXT_INSN (insn))\n-\t    if (!insn\n-\t\t|| NOTE_INSN_BASIC_BLOCK_P (insn))\n+\t  for (insn = NEXT_INSN (BB_END (bb)); ; insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (!insn || NOTE_INSN_BASIC_BLOCK_P (insn))\n \t\t{\n \t\t  error (\"missing barrier after block %i\", bb->index);\n \t\t  err = 1;\n \t\t  break;\n \t\t}\n+\t      if (BARRIER_P (insn))\n+\t\tbreak;\n+\t    }\n \t}\n       else if (e->src != ENTRY_BLOCK_PTR\n \t       && e->dest != EXIT_BLOCK_PTR)"}, {"sha": "6817af5d6aa130f1f99a63ece5772114caf83752", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -6815,6 +6815,61 @@ intentionally executing an illegal instruction) or by calling\n you should not rely on any particular implementation.\n @end deftypefn\n \n+@deftypefn {Built-in Function} void __builtin_unreachable (void)\n+If control flow reaches the point of the @code{__builtin_unreachable},\n+the program is undefined.  It is useful in situations where the\n+compiler cannot deduce the unreachability of the code.\n+\n+One such case is immediately following an @code{asm} statement that\n+will either never terminate, or one that transfers control elsewhere\n+and never returns.  In this example, without the\n+@code{__builtin_unreachable}, GCC would issue a warning that control\n+reaches the end of a non-void function.  It would also generate code\n+to return after the @code{asm}.\n+\n+@smallexample\n+int f (int c, int v)\n+@{\n+  if (c)\n+    @{\n+      return v;\n+    @}\n+  else\n+    @{\n+      asm(\"jmp error_handler\");\n+      __builtin_unreachable ();\n+    @}\n+@}\n+@end smallexample\n+\n+Because the @code{asm} statement unconditionally transfers control out\n+of the function, control will never reach the end of the function\n+body.  The @code{__builtin_unreachable} is in fact unreachable and\n+communicates this fact to the compiler.\n+\n+Another use for @code{__builtin_unreachable} is following a call a\n+function that never returns but that is not declared\n+@code{__attribute__((noreturn))}, as in this example:\n+\n+@smallexample\n+void function_that_never_returns (void);\n+\n+int g (int c)\n+@{\n+  if (c)\n+    @{\n+      return 1;\n+    @}\n+  else\n+    @{\n+      function_that_never_returns ();\n+      __builtin_unreachable ();\n+    @}\n+@}\n+@end smallexample\n+\n+@end deftypefn\n+\n @deftypefn {Built-in Function} void __builtin___clear_cache (char *@var{begin}, char *@var{end})\n This function is used to flush the processor's instruction cache for\n the region of memory between @var{begin} inclusive and @var{end}"}, {"sha": "3bb61ce8490844a4f9f07975e0c4179da19910c4", "filename": "gcc/system.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -576,14 +576,20 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n #if ENABLE_ASSERT_CHECKING\n #define gcc_assert(EXPR) \t\t\t\t\t\t\\\n    ((void)(!(EXPR) ? fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0 : 0))\n+#elif (__GNUC__ == 4) && (__GNUC_MINOR__) && 0\n+#define gcc_assert(EXPR) do { if (EXPR) __builtin_unreachable (); } while (0)\n #else\n /* Include EXPR, so that unused variable warnings do not occur.  */\n #define gcc_assert(EXPR) ((void)(0 && (EXPR)))\n #endif\n \n+#if !ENABLE_ASSERT_CHECKING && (__GNUC__ == 4) && (__GNUC_MINOR__) && 0\n+#define gcc_unreachable()  __builtin_unreachable ()\n+#else\n /* Use gcc_unreachable() to mark unreachable locations (like an\n    unreachable default case of a switch.  Do not use gcc_assert(0).  */\n #define gcc_unreachable() (fancy_abort (__FILE__, __LINE__, __FUNCTION__))\n+#endif\n \n /* Provide a fake boolean type.  We make no attempt to use the\n    C99 _Bool, as it may not be available in the bootstrap compiler,"}, {"sha": "8d1a113d6ba92b6c744aeb968b48b05cb6c3f785", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -1,3 +1,9 @@\n+2009-06-11  David Daney  <ddaney@caviumnetworks.com>\n+\n+\tPR c/39252\n+\t* gcc.dg/builtin-unreachable-1.c: New test.\n+\t* gcc.dg/builtin-unreachable-2.c: Same.\n+\n 2009-06-11  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/40402"}, {"sha": "165da3f944c9694dd449071d4c30b6e600fbd85a", "filename": "gcc/testsuite/gcc.dg/builtin-unreachable-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-1.c?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -0,0 +1,17 @@\n+/* Check that __builtin_unreachable() prevents the 'control reaches\n+   end of non-void function' diagnostic.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wreturn-type\" } */\n+int\n+f(int a, int b)\n+{\n+  if (a)\n+    {\n+      return b;\n+    }\n+  else\n+    {\n+      asm (\"bug\");\n+      __builtin_unreachable();\n+    }\n+}"}, {"sha": "13bdb9f7395fc7077697ad190485427b3add48ef", "filename": "gcc/testsuite/gcc.dg/builtin-unreachable-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468059bcbb8efdb31fd90369dc2ed122126413fe/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-unreachable-2.c?ref=468059bcbb8efdb31fd90369dc2ed122126413fe", "patch": "@@ -0,0 +1,20 @@\n+/* Check that __builtin_unreachable() is a no-return function thus\n+   causing the dead call to foo() to be removed.  The comparison is\n+   dead too, and should be removed.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-rtl-cse1\" } */\n+void foo (void);\n+\n+int\n+f (int i)\n+{\n+  if (i > 1)\n+    __builtin_unreachable();\n+  if (i > 1)\n+    foo ();\n+  return 1;\n+}\n+/* { dg-final { scan-tree-dump-not \"foo\" \"optimized\" } } */\n+/* { dg-final { scan-rtl-dump-not \"\\\\(if_then_else\" \"cse1\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-final { cleanup-rtl-dump \"cse1\" } } */"}]}