{"sha": "7d8b9c9990b3e3cc13303e3dd0057ff87994120b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4YjljOTk5MGIzZTNjYzEzMzAzZTNkZDAwNTdmZjg3OTk0MTIwYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-06-06T10:27:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:27:26Z"}, "message": "exp_pakd.adb (Expand_Packed_Not): Use RM_Size rather than ESize to compute masking constant...\n\n2007-04-20  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_pakd.adb (Expand_Packed_Not): Use RM_Size rather than ESize to\n\tcompute masking constant, since we now set Esize properly to the\n\tunderlying size.\n\t(Create_Packed_Array_Type): Set proper Esize value adjusted as required\n\tto match the alignment.\n\t(Create_Packed_Array_Type): Use Short_Short_Unsigned as base type for\n\tpacked arrays of 8 bits or less.\n\n\t* freeze.adb (Freeze_Entity): When freezing the formals of a\n\tsubprogram, freeze the designated type of a parameter of an access type\n\tonly if it is an access parameter.\n\tIncrease size of C convention enumeration object\n\t(Freeze_Entity, array type case): Make sure Esize value is properly\n\tadjusted for the alignment if it is known.\n\t(Freeze_Entity, array type case): When checking bit packed arrays for\n\tthe size being incorrect, check RM_Size, not Esize.\n\t(Freeze_Record_Type): Check for bad discriminated record convention\n\t(In_Exp_Body): Return true if the body is generated for a subprogram\n\trenaming, either an attribute renaming or a renaming as body.\n\t(Check_Itype): If the designated type of an anonymous access component\n\tis a non-protected subprogram type, indicate that it is frozen, to\n\tprevent out-of-scope freeze node at some subsequent call.\n\t(Freeze_Subprogram): On OpenVMS, reject descriptor passing mechanism\n\tonly if the subprogram is neither imported nor exported, as well as the\n\tNCA descriptor class if the subprogram is exported.\n\nFrom-SVN: r125407", "tree": {"sha": "8dbb8956d7b6fae75a458b50ca8d54eb7a6a1441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dbb8956d7b6fae75a458b50ca8d54eb7a6a1441"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d8b9c9990b3e3cc13303e3dd0057ff87994120b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8b9c9990b3e3cc13303e3dd0057ff87994120b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8b9c9990b3e3cc13303e3dd0057ff87994120b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8b9c9990b3e3cc13303e3dd0057ff87994120b/comments", "author": null, "committer": null, "parents": [{"sha": "b545a0f665f17f255262053f9ebf27f718bdfabc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b545a0f665f17f255262053f9ebf27f718bdfabc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b545a0f665f17f255262053f9ebf27f718bdfabc"}], "stats": {"total": 293, "additions": 196, "deletions": 97}, "files": [{"sha": "7e1efa3e30aea62758c84ceec3686b0c558caba1", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8b9c9990b3e3cc13303e3dd0057ff87994120b/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8b9c9990b3e3cc13303e3dd0057ff87994120b/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=7d8b9c9990b3e3cc13303e3dd0057ff87994120b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,6 +30,8 @@ with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Util; use Exp_Util;\n+with Layout;   use Layout;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Rtsfind;  use Rtsfind;\n@@ -772,7 +774,7 @@ package body Exp_Pakd is\n          end if;\n \n          if Scope (Typ) /= Current_Scope then\n-            New_Scope (Scope (Typ));\n+            Push_Scope (Scope (Typ));\n             Pushed_Scope := True;\n          end if;\n \n@@ -785,15 +787,19 @@ package body Exp_Pakd is\n          end if;\n \n          --  Set Esize and RM_Size to the actual size of the packed object\n-         --  Do not reset RM_Size if already set, as happens in the case\n-         --  of a modular type.\n+         --  Do not reset RM_Size if already set, as happens in the case of\n+         --  a modular type.\n \n-         Set_Esize (PAT, PASize);\n+         if Unknown_Esize (PAT) then\n+            Set_Esize (PAT, PASize);\n+         end if;\n \n          if Unknown_RM_Size (PAT) then\n             Set_RM_Size (PAT, PASize);\n          end if;\n \n+         Adjust_Esize_Alignment (PAT);\n+\n          --  Set remaining fields of packed array type\n \n          Init_Alignment                (PAT);\n@@ -874,7 +880,7 @@ package body Exp_Pakd is\n       --  type, since this size clearly belongs to the packed array type. The\n       --  size of the conceptual unpacked type is always set to unknown.\n \n-      PASize := Esize (Typ);\n+      PASize := RM_Size (Typ);\n \n       --  Case of an array where at least one index is of an enumeration\n       --  type with a non-standard representation, but the component size\n@@ -1144,15 +1150,13 @@ package body Exp_Pakd is\n                --      range 0 .. 2 ** ((Typ'Length (1)\n                --                * ... * Typ'Length (n)) * Csize) - 1;\n \n-               --  The bounds are statically known, and btyp is one\n-               --  of the unsigned types, depending on the length. If the\n-               --  type is its first subtype, i.e. it is a user-defined\n-               --  type, no object of the type will be larger, and it is\n-               --  worthwhile to use a small unsigned type.\n+               --  The bounds are statically known, and btyp is one of the\n+               --  unsigned types, depending on the length.\n \n-               if Len_Bits <= Standard_Short_Integer_Size\n-                 and then First_Subtype (Typ) = Typ\n-               then\n+               if Len_Bits <= Standard_Short_Short_Integer_Size then\n+                  Btyp := RTE (RE_Short_Short_Unsigned);\n+\n+               elsif Len_Bits <= Standard_Short_Integer_Size then\n                   Btyp := RTE (RE_Short_Unsigned);\n \n                elsif Len_Bits <= Standard_Integer_Size then\n@@ -2200,7 +2204,7 @@ package body Exp_Pakd is\n       --  one bits of length equal to the size of this packed type and\n       --  rtyp is the actual subtype of the operand\n \n-      Lit := Make_Integer_Literal (Loc, 2 ** Esize (PAT) - 1);\n+      Lit := Make_Integer_Literal (Loc, 2 ** RM_Size (PAT) - 1);\n       Set_Print_In_Hex (Lit);\n \n       if not Is_Array_Type (PAT) then"}, {"sha": "6e448b15305acaad512528a1e4a6627310607880", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 177, "deletions": 82, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8b9c9990b3e3cc13303e3dd0057ff87994120b/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8b9c9990b3e3cc13303e3dd0057ff87994120b/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=7d8b9c9990b3e3cc13303e3dd0057ff87994120b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,7 @@ with Exp_Util; use Exp_Util;\n with Exp_Tss;  use Exp_Tss;\n with Layout;   use Layout;\n with Lib.Xref; use Lib.Xref;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -537,7 +538,7 @@ package body Freeze is\n             if RM_Size (T) < S then\n                Error_Msg_Uint_1 := S;\n                Error_Msg_NE\n-                 (\"size for & is too small, minimum is ^\",\n+                 (\"size for & too small, minimum allowed is ^\",\n                   Size_Clause (T), T);\n \n             elsif Unknown_Esize (T) then\n@@ -1148,7 +1149,7 @@ package body Freeze is\n               and then not Is_Child_Unit (E)\n               and then not Is_Frozen (E)\n             then\n-               New_Scope (E);\n+               Push_Scope (E);\n                Install_Visible_Declarations (E);\n                Install_Private_Declarations (E);\n \n@@ -1162,7 +1163,7 @@ package body Freeze is\n                    or else\n                  Nkind (Parent (E)) = N_Single_Task_Declaration)\n             then\n-               New_Scope (E);\n+               Push_Scope (E);\n                Freeze_All (First_Entity (E), After);\n                End_Scope;\n \n@@ -1384,18 +1385,15 @@ package body Freeze is\n \n       function After_Last_Declaration return Boolean is\n          Spec  : constant Node_Id := Parent (Current_Scope);\n-\n       begin\n          if Nkind (Spec) = N_Package_Specification then\n             if Present (Private_Declarations (Spec)) then\n                return Loc >= Sloc (Last (Private_Declarations (Spec)));\n-\n             elsif Present (Visible_Declarations (Spec)) then\n                return Loc >= Sloc (Last (Visible_Declarations (Spec)));\n             else\n                return False;\n             end if;\n-\n          else\n             return False;\n          end if;\n@@ -1463,26 +1461,32 @@ package body Freeze is\n          --  Set True if we find at least one component with a component\n          --  clause (used to warn about useless Bit_Order pragmas).\n \n-         procedure Check_Itype (Desig : Entity_Id);\n-         --  If the component subtype is an access to a constrained subtype\n-         --  of an already frozen type, make the subtype frozen as well. It\n-         --  might otherwise be frozen in the wrong scope, and a freeze node\n-         --  on subtype has no effect.\n+         procedure Check_Itype (Typ : Entity_Id);\n+         --  If the component subtype is an access to a constrained subtype of\n+         --  an already frozen type, make the subtype frozen as well. It might\n+         --  otherwise be frozen in the wrong scope, and a freeze node on\n+         --  subtype has no effect. Similarly, if the component subtype is a\n+         --  regular (not protected) access to subprogram, set the anonymous\n+         --  subprogram type to frozen as well, to prevent an out-of-scope\n+         --  freeze node at some eventual point of call. Protected operations\n+         --  are handled elsewhere.\n \n          -----------------\n          -- Check_Itype --\n          -----------------\n \n-         procedure Check_Itype (Desig : Entity_Id) is\n+         procedure Check_Itype (Typ : Entity_Id) is\n+            Desig : constant Entity_Id := Designated_Type (Typ);\n+\n          begin\n             if not Is_Frozen (Desig)\n               and then Is_Frozen (Base_Type (Desig))\n             then\n                Set_Is_Frozen (Desig);\n \n                --  In addition, add an Itype_Reference to ensure that the\n-               --  access subtype is elaborated early enough. This cannot\n-               --  be done if the subtype may depend on discriminants.\n+               --  access subtype is elaborated early enough. This cannot be\n+               --  done if the subtype may depend on discriminants.\n \n                if Ekind (Comp) = E_Component\n                  and then Is_Itype (Etype (Comp))\n@@ -1497,16 +1501,21 @@ package body Freeze is\n                      Append (IR, Result);\n                   end if;\n                end if;\n+\n+            elsif Ekind (Typ) = E_Anonymous_Access_Subprogram_Type\n+              and then Convention (Desig) /= Convention_Protected\n+            then\n+               Set_Is_Frozen (Desig);\n             end if;\n          end Check_Itype;\n \n       --  Start of processing for Freeze_Record_Type\n \n       begin\n-         --  If this is a subtype of a controlled type, declared without\n-         --  a constraint, the _controller may not appear in the component\n-         --  list if the parent was not frozen at the point of subtype\n-         --  declaration. Inherit the _controller component now.\n+         --  If this is a subtype of a controlled type, declared without a\n+         --  constraint, the _controller may not appear in the component list\n+         --  if the parent was not frozen at the point of subtype declaration.\n+         --  Inherit the _controller component now.\n \n          if Rec /= Base_Type (Rec)\n            and then Has_Controlled_Component (Rec)\n@@ -1581,8 +1590,9 @@ package body Freeze is\n                      if Inside_A_Generic then\n                         null;\n \n-                     elsif not Size_Known_At_Compile_Time\n-                              (Underlying_Type (Etype (Comp)))\n+                     elsif not\n+                       Size_Known_At_Compile_Time\n+                         (Underlying_Type (Etype (Comp)))\n                      then\n                         Error_Msg_N\n                           (\"component clause not allowed for variable \" &\n@@ -1601,8 +1611,8 @@ package body Freeze is\n \n                      Set_Must_Be_On_Byte_Boundary (Rec);\n \n-                     --  Check for component clause that is inconsistent\n-                     --  with the required byte boundary alignment.\n+                     --  Check for component clause that is inconsistent with\n+                     --  the required byte boundary alignment.\n \n                      if Present (CC)\n                        and then Normalized_First_Bit (Comp) mod\n@@ -1614,8 +1624,8 @@ package body Freeze is\n                      end if;\n                   end if;\n \n-                  --  If component clause is present, then deal with the\n-                  --  non-default bit order case for Ada 95 mode. The required\n+                  --  If component clause is present, then deal with the non-\n+                  --  default bit order case for Ada 95 mode. The required\n                   --  processing for Ada 2005 mode is handled separately after\n                   --  processing all components.\n \n@@ -1833,7 +1843,7 @@ package body Freeze is\n                      end if;\n \n                   elsif Is_Itype (Designated_Type (Etype (Comp))) then\n-                     Check_Itype (Designated_Type (Etype (Comp)));\n+                     Check_Itype (Etype (Comp));\n \n                   else\n                      Freeze_And_Append\n@@ -1844,7 +1854,7 @@ package body Freeze is\n             elsif Is_Access_Type (Etype (Comp))\n               and then Is_Itype (Designated_Type (Etype (Comp)))\n             then\n-               Check_Itype (Designated_Type (Etype (Comp)));\n+               Check_Itype (Etype (Comp));\n \n             elsif Is_Array_Type (Etype (Comp))\n               and then Is_Access_Type (Component_Type (Etype (Comp)))\n@@ -1980,6 +1990,41 @@ package body Freeze is\n                Next_Component (Comp);\n             end loop;\n          end if;\n+\n+         --  Generate warning for applying C or C++ convention to a record\n+         --  with discriminants. This is suppressed for the unchecked union\n+         --  case, since the whole point in this case is interface C.\n+\n+         if Has_Discriminants (E)\n+           and then not Is_Unchecked_Union (E)\n+           and then not Warnings_Off (E)\n+           and then not Warnings_Off (Base_Type (E))\n+           and then (Convention (E) = Convention_C\n+                       or else\n+                     Convention (E) = Convention_CPP)\n+           and then Comes_From_Source (E)\n+         then\n+            declare\n+               Cprag : constant Node_Id := Get_Rep_Pragma (E, Name_Convention);\n+               A2    : Node_Id;\n+\n+            begin\n+               if Present (Cprag) then\n+                  A2 := Next (First (Pragma_Argument_Associations (Cprag)));\n+\n+                  if Convention (E) = Convention_C then\n+                     Error_Msg_N\n+                       (\"?variant record has no direct equivalent in C\", A2);\n+                  else\n+                     Error_Msg_N\n+                       (\"?variant record has no direct equivalent in C++\", A2);\n+                  end if;\n+\n+                  Error_Msg_NE\n+                    (\"\\?use of convention for type& is dubious\", A2, E);\n+               end if;\n+            end;\n+         end if;\n       end Freeze_Record_Type;\n \n    --  Start of processing for Freeze_Entity\n@@ -2048,15 +2093,15 @@ package body Freeze is\n \n       --  Similarly, an inlined instance body may make reference to global\n       --  entities, but these references cannot be the proper freezing point\n-      --  for them, and the the absence of inlining freezing will take place\n+      --  for them, and in the absence of inlining freezing will take place\n       --  in their own scope. Normally instance bodies are analyzed after\n       --  the enclosing compilation, and everything has been frozen at the\n       --  proper place, but with front-end inlining an instance body is\n       --  compiled before the end of the enclosing scope, and as a result\n       --  out-of-order freezing must be prevented.\n \n       elsif Front_End_Inlining\n-        and then  In_Instance_Body\n+        and then In_Instance_Body\n         and then Present (Scope (Test_E))\n       then\n          declare\n@@ -2111,7 +2156,7 @@ package body Freeze is\n                --  If expression is an aggregate, assign to a temporary to\n                --  ensure that the actual assignment is done atomically rather\n                --  than component-wise (the assignment to the temp may be done\n-               --  component-wise, but that is harmless.\n+               --  component-wise, but that is harmless).\n \n                if Nkind (Expr) = N_Aggregate then\n                   Expand_Atomic_Aggregate (Expr, Etype (E));\n@@ -2271,7 +2316,14 @@ package body Freeze is\n                              (\"(Ada 2005): invalid use of unconstrained tagged\"\n                               & \" incomplete type\", E);\n \n-                        elsif Ekind (F_Type) = E_Subprogram_Type then\n+                        --  If the formal is an anonymous_access_to_subprogram\n+                        --  freeze the  subprogram type as well, to prevent\n+                        --  scope anomalies in gigi, because there is no other\n+                        --  clear point at which it could be frozen.\n+\n+                        elsif Is_Itype (Etype (Formal))\n+                          and then Ekind (F_Type) = E_Subprogram_Type\n+                        then\n                            Freeze_And_Append (F_Type, Loc, Result);\n                         end if;\n                      end if;\n@@ -2310,6 +2362,7 @@ package body Freeze is\n                      elsif Ekind (Etype (E)) = E_Incomplete_Type\n                        and then Is_Tagged_Type (Etype (E))\n                        and then No (Full_View (Etype (E)))\n+                       and then not Is_Value_Type (Etype (E))\n                      then\n                         Error_Msg_N\n                           (\"(Ada 2005): invalid use of tagged incomplete type\",\n@@ -2333,7 +2386,7 @@ package body Freeze is\n \n          else\n             --  If entity has a type, and it is not a generic unit, then\n-            --  freeze it first (RM 13.14(10))\n+            --  freeze it first (RM 13.14(10)).\n \n             if Present (Etype (E))\n               and then Ekind (E) /= E_Generic_Function\n@@ -2362,18 +2415,39 @@ package body Freeze is\n                --  for other unrelated reasons). Note that we delayed this\n                --  processing till freeze time so that we can be sure not\n                --  to set the flag if there is an address clause. If there\n-               --  is such a clause, then the only purpose of the import\n+               --  is such a clause, then the only purpose of the Import\n                --  pragma is to suppress implicit initialization.\n \n                if Is_Imported (E)\n                  and then No (Address_Clause (E))\n                then\n                   Set_Is_Public (E);\n                end if;\n+\n+               --  For convention C objects of an enumeration type, warn if\n+               --  the size is not integer size and no explicit size given.\n+               --  Skip warning for Boolean, and Character, assume programmer\n+               --  expects 8-bit sizes for these cases.\n+\n+               if (Convention (E) = Convention_C\n+                    or else\n+                   Convention (E) = Convention_CPP)\n+                 and then Is_Enumeration_Type (Etype (E))\n+                 and then not Is_Character_Type (Etype (E))\n+                 and then not Is_Boolean_Type (Etype (E))\n+                 and then Esize (Etype (E)) < Standard_Integer_Size\n+                 and then not Has_Size_Clause (E)\n+               then\n+                  Error_Msg_Uint_1 := UI_From_Int (Standard_Integer_Size);\n+                  Error_Msg_N\n+                    (\"?convention C enumeration object has size less than ^\",\n+                     E);\n+                  Error_Msg_N (\"\\?use explicit size clause to set size\", E);\n+               end if;\n             end if;\n \n             --  Check that a constant which has a pragma Volatile[_Components]\n-            --  or Atomic[_Components] also has a pragma Import (RM C.6(13))\n+            --  or Atomic[_Components] also has a pragma Import (RM C.6(13)).\n \n             --  Note: Atomic[_Components] also sets Volatile[_Components]\n \n@@ -2465,7 +2539,7 @@ package body Freeze is\n                Freeze_And_Append (Atype, Loc, Result);\n \n             --  Otherwise freeze the base type of the entity before\n-            --  freezing the entity itself, (RM 13.14(15)).\n+            --  freezing the entity itself (RM 13.14(15)).\n \n             elsif E /= Base_Type (E) then\n                Freeze_And_Append (Base_Type (E), Loc, Result);\n@@ -2487,8 +2561,8 @@ package body Freeze is\n                Pnod : Node_Id;\n \n                Non_Standard_Enum : Boolean := False;\n-               --  Set true if any of the index types is an enumeration\n-               --  type with a non-standard representation.\n+               --  Set true if any of the index types is an enumeration type\n+               --  with a non-standard representation.\n \n             begin\n                Freeze_And_Append (Ctyp, Loc, Result);\n@@ -2562,10 +2636,10 @@ package body Freeze is\n                            Csiz := Uint_0;\n                         end if;\n \n-                        --  Set component size up to match alignment if\n-                        --  it would otherwise be less than the alignment.\n-                        --  This deals with cases of types whose alignment\n-                        --  exceeds their sizes (padded types).\n+                        --  Set component size up to match alignment if it\n+                        --  would otherwise be less than the alignment. This\n+                        --  deals with cases of types whose alignment exceeds\n+                        --  their size (padded types).\n \n                         if Csiz /= 0 then\n                            declare\n@@ -2586,9 +2660,9 @@ package body Freeze is\n \n                         Set_Component_Size (Base_Type (E), Csiz);\n \n-                        --  Check for base type of 8,16,32 bits, where the\n+                        --  Check for base type of 8, 16, 32 bits, where the\n                         --  subtype has a length one less than the base type\n-                        --  and is unsigned (e.g. Natural subtype of Integer)\n+                        --  and is unsigned (e.g. Natural subtype of Integer).\n \n                         --  In such cases, if a component size was not set\n                         --  explicitly, then generate a warning.\n@@ -2613,8 +2687,8 @@ package body Freeze is\n                            end if;\n                         end if;\n \n-                        --  Actual packing is not needed for 8,16,32,64\n-                        --  Also not needed for 24 if alignment is 1\n+                        --  Actual packing is not needed for 8, 16, 32, 64.\n+                        --  Also not needed for 24 if alignment is 1.\n \n                         if        Csiz = 8\n                           or else Csiz = 16\n@@ -2626,9 +2700,9 @@ package body Freeze is\n                            --  the packing request had no effect, so Is_Packed\n                            --  is reset.\n \n-                           --  Note: semantically this means that we lose\n-                           --  track of the fact that a derived type inherited\n-                           --  a pack pragma that was non-effective, but that\n+                           --  Note: semantically this means that we lose track\n+                           --  of the fact that a derived type inherited a\n+                           --  pragma Pack that was non-effective, but that\n                            --  seems fine.\n \n                            --  We regard a Pack pragma as a request to set a\n@@ -2654,28 +2728,29 @@ package body Freeze is\n \n                   if Unknown_Alignment (E) then\n                      Set_Alignment (E, Alignment (Base_Type (E)));\n+                     Adjust_Esize_Alignment (E);\n                   end if;\n                end if;\n \n                --  For bit-packed arrays, check the size\n \n                if Is_Bit_Packed_Array (E)\n-                 and then Known_Esize (E)\n+                 and then Known_RM_Size (E)\n                then\n                   declare\n                      Discard : Boolean;\n                      SizC    : constant Node_Id := Size_Clause (E);\n \n                   begin\n                      --  It is not clear if it is possible to have no size\n-                     --  clause at this stage, but this is not worth worrying\n-                     --  about. Post the error on the entity name in the size\n+                     --  clause at this stage, but it is not worth worrying\n+                     --  about. Post error on the entity name in the size\n                      --  clause if present, else on the type entity itself.\n \n                      if Present (SizC) then\n-                        Check_Size (Name (SizC), E, Esize (E), Discard);\n+                        Check_Size (Name (SizC), E, RM_Size (E), Discard);\n                      else\n-                        Check_Size (E, E, Esize (E), Discard);\n+                        Check_Size (E, E, RM_Size (E), Discard);\n                      end if;\n                   end;\n                end if;\n@@ -2714,15 +2789,15 @@ package body Freeze is\n                                     UI_Max (Uint_0, Hiv - Lov + 1);\n                            Rsiz : constant Uint := RM_Size (Ctyp);\n \n-                        --  What we are looking for here is the situation\n-                        --  where the Esize given would be exactly right\n-                        --  if there was a pragma Pack (resulting in the\n-                        --  component size being the same as the RM_Size).\n-                        --  Furthermore, the component type size must be\n-                        --  an odd size (not a multiple of storage unit)\n+                        --  What we are looking for here is the situation where\n+                        --  the RM_Size given would be exactly right if there\n+                        --  was a pragma Pack (resulting in the component size\n+                        --  being the same as the RM_Size). Furthermore, the\n+                        --  component type size must be an odd size (not a\n+                        --  multiple of storage unit)\n \n                         begin\n-                           if Esize (E) = Len * Rsiz\n+                           if RM_Size (E) = Len * Rsiz\n                              and then Rsiz mod System_Storage_Unit /= 0\n                            then\n                               Error_Msg_NE\n@@ -3004,6 +3079,7 @@ package body Freeze is\n             if Ekind (Etype (E)) = E_Incomplete_Type\n               and then Is_Tagged_Type (Etype (E))\n               and then No (Full_View (Etype (E)))\n+              and then not Is_Value_Type (Etype (E))\n             then\n                Error_Msg_N\n                  (\"(Ada 2005): invalid use of tagged incomplete type\", E);\n@@ -3034,6 +3110,7 @@ package body Freeze is\n                if Ekind (Etyp) = E_Incomplete_Type\n                  and then Is_Tagged_Type (Etyp)\n                  and then No (Full_View (Etyp))\n+                 and then not Is_Value_Type (Etype (E))\n                then\n                   Error_Msg_N\n                     (\"(Ada 2005): invalid use of tagged incomplete type\", E);\n@@ -3069,24 +3146,24 @@ package body Freeze is\n                if Small_Value (E) < Ureal_2_M_80 then\n                   Error_Msg_Name_1 := Name_Small;\n                   Error_Msg_N\n-                    (\"`&''%` is too small, minimum is 2.0'*'*(-80)\", E);\n+                    (\"`&''%` too small, minimum allowed is 2.0'*'*(-80)\", E);\n \n                elsif Small_Value (E) > Ureal_2_80 then\n                   Error_Msg_Name_1 := Name_Small;\n                   Error_Msg_N\n-                    (\"`&''%` is too large, maximum is 2.0'*'*80\", E);\n+                    (\"`&''%` too large, maximum allowed is 2.0'*'*80\", E);\n                end if;\n \n                if Expr_Value_R (Type_Low_Bound (E)) < Ureal_M_10_36 then\n                   Error_Msg_Name_1 := Name_First;\n                   Error_Msg_N\n-                    (\"`&''%` is too small, minimum is -10.0'*'*36\", E);\n+                    (\"`&''%` too small, minimum allowed is -10.0'*'*36\", E);\n                end if;\n \n                if Expr_Value_R (Type_High_Bound (E)) > Ureal_10_36 then\n                   Error_Msg_Name_1 := Name_Last;\n                   Error_Msg_N\n-                    (\"`&''%` is too large, maximum is 10.0'*'*36\", E);\n+                    (\"`&''%` too large, maximum allowed is 10.0'*'*36\", E);\n                end if;\n             end if;\n \n@@ -3214,7 +3291,7 @@ package body Freeze is\n \n          --  Now that all types from which E may depend are frozen, see if the\n          --  size is known at compile time, if it must be unsigned, or if\n-         --  strict alignent is required\n+         --  strict alignment is required\n \n          Check_Compile_Time_Size (E);\n          Check_Unsigned_Type (E);\n@@ -3418,15 +3495,16 @@ package body Freeze is\n       function In_Exp_Body (N : Node_Id) return Boolean;\n       --  Given an N_Handled_Sequence_Of_Statements node N, determines whether\n       --  it is the handled statement sequence of an expander-generated\n-      --  subprogram (init proc, or stream subprogram). If so, it returns\n-      --  True, otherwise False.\n+      --  subprogram (init proc, stream subprogram, or renaming as body).\n+      --  If so, this is not a freezing context.\n \n       -----------------\n       -- In_Exp_Body --\n       -----------------\n \n       function In_Exp_Body (N : Node_Id) return Boolean is\n-         P : Node_Id;\n+         P  : Node_Id;\n+         Id : Entity_Id;\n \n       begin\n          if Nkind (N) = N_Subprogram_Body then\n@@ -3439,14 +3517,16 @@ package body Freeze is\n             return False;\n \n          else\n-            P := Defining_Unit_Name (Specification (P));\n-\n-            if Nkind (P) = N_Defining_Identifier\n-              and then (Is_Init_Proc (P)              or else\n-                        Is_TSS (P, TSS_Stream_Input)  or else\n-                        Is_TSS (P, TSS_Stream_Output) or else\n-                        Is_TSS (P, TSS_Stream_Read)   or else\n-                        Is_TSS (P, TSS_Stream_Write))\n+            Id := Defining_Unit_Name (Specification (P));\n+\n+            if Nkind (Id) = N_Defining_Identifier\n+              and then (Is_Init_Proc (Id)              or else\n+                        Is_TSS (Id, TSS_Stream_Input)  or else\n+                        Is_TSS (Id, TSS_Stream_Output) or else\n+                        Is_TSS (Id, TSS_Stream_Read)   or else\n+                        Is_TSS (Id, TSS_Stream_Write)  or else\n+                        Nkind (Original_Node (P)) =\n+                          N_Subprogram_Renaming_Declaration)\n             then\n                return True;\n             else\n@@ -4202,7 +4282,8 @@ package body Freeze is\n       if Actual_Size > 64 then\n          Error_Msg_Uint_1 := UI_From_Int (Actual_Size);\n          Error_Msg_N\n-           (\"size required (^) for type& too large, maximum is 64\", Typ);\n+           (\"size required (^) for type& too large, maximum allowed is 64\",\n+            Typ);\n          Actual_Size := 64;\n       end if;\n \n@@ -4213,7 +4294,7 @@ package body Freeze is\n             Error_Msg_Uint_1 := RM_Size (Typ);\n             Error_Msg_Uint_2 := UI_From_Int (Actual_Size);\n             Error_Msg_NE\n-              (\"size given (^) for type& too small, minimum is ^\",\n+              (\"size given (^) for type& too small, minimum allowed is ^\",\n                Size_Clause (Typ), Typ);\n \n          else\n@@ -4304,7 +4385,7 @@ package body Freeze is\n                Error_Msg_Uint_1 := RM_Size (Typ);\n                Error_Msg_Uint_2 := Minsiz;\n                Error_Msg_NE\n-                 (\"size given (^) for type& too small, minimum is ^\",\n+                 (\"size given (^) for type& too small, minimum allowed is ^\",\n                   Size_Clause (Typ), Typ);\n             end if;\n \n@@ -4624,17 +4705,31 @@ package body Freeze is\n       end if;\n \n       --  For VMS, descriptor mechanisms for parameters are allowed only\n-      --  for imported subprograms.\n+      --  for imported/exported subprograms.  Moreover, the NCA descriptor\n+      --  is not allowed for parameters of exported subprograms.\n \n       if OpenVMS_On_Target then\n-         if not Is_Imported (E) then\n+         if Is_Exported (E) then\n+            F := First_Formal (E);\n+            while Present (F) loop\n+               if Mechanism (F) = By_Descriptor_NCA then\n+                  Error_Msg_N\n+                    (\"'N'C'A' descriptor for parameter not permitted\", F);\n+                  Error_Msg_N\n+                    (\"\\can only be used for imported subprogram\", F);\n+               end if;\n+\n+               Next_Formal (F);\n+            end loop;\n+\n+         elsif not Is_Imported (E) then\n             F := First_Formal (E);\n             while Present (F) loop\n                if Mechanism (F) in Descriptor_Codes then\n                   Error_Msg_N\n                     (\"descriptor mechanism for parameter not permitted\", F);\n                   Error_Msg_N\n-                    (\"\\can only be used for imported subprogram\", F);\n+                    (\"\\can only be used for imported/exported subprogram\", F);\n                end if;\n \n                Next_Formal (F);"}]}