{"sha": "92261ce01d53d2b0ba31eb180e95fdc58427e0b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIyNjFjZTAxZDUzZDJiMGJhMzFlYjE4MGU5NWZkYzU4NDI3ZTBiMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-02-21T09:53:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-02-21T09:53:56Z"}, "message": "re PR tree-optimization/56490 (-Wall triggering infinite loop)\n\n\tPR tree-optimization/56490\n\t* params.def (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS): New param.\n\t* tree-ssa-uninit.c: Include params.h.\n\t(compute_control_dep_chain): Add num_calls argument, return false\n\tif it exceed PARAM_UNINIT_CONTROL_DEP_ATTEMPTS param, pass\n\tnum_calls to recursive call.\n\t(find_predicates): Change dep_chain into normal array,\n\tcur_chain into auto_vec<edge, MAX_CHAIN_LEN + 1>, add num_calls\n\tvariable and adjust compute_control_dep_chain caller.\n\t(find_def_preds): Likewise.\n\nFrom-SVN: r207988", "tree": {"sha": "fd719ad6495d65560c713ce1fb75c59e15ca32e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd719ad6495d65560c713ce1fb75c59e15ca32e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92261ce01d53d2b0ba31eb180e95fdc58427e0b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92261ce01d53d2b0ba31eb180e95fdc58427e0b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92261ce01d53d2b0ba31eb180e95fdc58427e0b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92261ce01d53d2b0ba31eb180e95fdc58427e0b1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aa6ef874510f64ed0c9d2e6a0812cf0731a49899", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6ef874510f64ed0c9d2e6a0812cf0731a49899", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6ef874510f64ed0c9d2e6a0812cf0731a49899"}], "stats": {"total": 82, "additions": 44, "deletions": 38}, "files": [{"sha": "29ed8c833c4c0e8203df890b176bf26e08577906", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92261ce01d53d2b0ba31eb180e95fdc58427e0b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92261ce01d53d2b0ba31eb180e95fdc58427e0b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92261ce01d53d2b0ba31eb180e95fdc58427e0b1", "patch": "@@ -1,3 +1,16 @@\n+2014-02-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/56490\n+\t* params.def (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS): New param.\n+\t* tree-ssa-uninit.c: Include params.h.\n+\t(compute_control_dep_chain): Add num_calls argument, return false\n+\tif it exceed PARAM_UNINIT_CONTROL_DEP_ATTEMPTS param, pass\n+\tnum_calls to recursive call.\n+\t(find_predicates): Change dep_chain into normal array,\n+\tcur_chain into auto_vec<edge, MAX_CHAIN_LEN + 1>, add num_calls\n+\tvariable and adjust compute_control_dep_chain caller.\n+\t(find_def_preds): Likewise.\n+\n 2014-02-21  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* gimple-pretty-print.c (dump_gimple_omp_for) [flags & TDF_RAW]"}, {"sha": "ad63a37a76ff491c7d20427dca6fb1473e30d18f", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92261ce01d53d2b0ba31eb180e95fdc58427e0b1/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92261ce01d53d2b0ba31eb180e95fdc58427e0b1/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=92261ce01d53d2b0ba31eb180e95fdc58427e0b1", "patch": "@@ -1078,6 +1078,12 @@ DEFPARAM (PARAM_ASAN_USE_AFTER_RETURN,\n          \"asan-use-after-return\",\n          \"Enable asan builtin functions protection\",\n          1, 0, 1)\n+\n+DEFPARAM (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS,\n+\t  \"uninit-control-dep-attempts\",\n+\t  \"Maximum number of nested calls to search for control dependencies \"\n+\t  \"during uninitialized variable analysis\",\n+\t  1000, 1, 0)\n /*\n \n Local variables:"}, {"sha": "d9b33b13e9b8ca52d142ab59104433be02ee34ba", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92261ce01d53d2b0ba31eb180e95fdc58427e0b1/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92261ce01d53d2b0ba31eb180e95fdc58427e0b1/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=92261ce01d53d2b0ba31eb180e95fdc58427e0b1", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"tree-pass.h\"\n #include \"diagnostic-core.h\"\n+#include \"params.h\"\n \n /* This implements the pass that does predicate aware warning on uses of\n    possibly uninitialized variables. The pass first collects the set of\n@@ -390,8 +391,8 @@ find_control_equiv_block (basic_block bb)\n \n /* Computes the control dependence chains (paths of edges)\n    for DEP_BB up to the dominating basic block BB (the head node of a\n-   chain should be dominated by it).  CD_CHAINS is pointer to a\n-   dynamic array holding the result chains. CUR_CD_CHAIN is the current\n+   chain should be dominated by it).  CD_CHAINS is pointer to an\n+   array holding the result chains.  CUR_CD_CHAIN is the current\n    chain being computed.  *NUM_CHAINS is total number of chains.  The\n    function returns true if the information is successfully computed,\n    return false if there is no control dependence or not computed.  */\n@@ -400,7 +401,8 @@ static bool\n compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n                            vec<edge> *cd_chains,\n                            size_t *num_chains,\n-                           vec<edge> *cur_cd_chain)\n+\t\t\t   vec<edge> *cur_cd_chain,\n+\t\t\t   int *num_calls)\n {\n   edge_iterator ei;\n   edge e;\n@@ -411,6 +413,10 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n   if (EDGE_COUNT (bb->succs) < 2)\n     return false;\n \n+  if (*num_calls > PARAM_VALUE (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS))\n+    return false;\n+  ++*num_calls;\n+\n   /* Could use a set instead.  */\n   cur_chain_len = cur_cd_chain->length ();\n   if (cur_chain_len > MAX_CHAIN_LEN)\n@@ -450,7 +456,7 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n \n           /* Now check if DEP_BB is indirectly control dependent on BB.  */\n           if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n-                                         num_chains, cur_cd_chain))\n+\t\t\t\t\t num_chains, cur_cd_chain, num_calls))\n             {\n               found_cd_chain = true;\n               break;\n@@ -595,14 +601,12 @@ find_predicates (pred_chain_union *preds,\n                  basic_block use_bb)\n {\n   size_t num_chains = 0, i;\n-  vec<edge> *dep_chains = 0;\n-  vec<edge> cur_chain = vNULL;\n+  int num_calls = 0;\n+  vec<edge> dep_chains[MAX_NUM_CHAINS];\n+  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n   bool has_valid_pred = false;\n   basic_block cd_root = 0;\n \n-  typedef vec<edge> vec_edge_heap;\n-  dep_chains = XCNEWVEC (vec_edge_heap, MAX_NUM_CHAINS);\n-\n   /* First find the closest bb that is control equivalent to PHI_BB\n      that also dominates USE_BB.  */\n   cd_root = phi_bb;\n@@ -615,19 +619,13 @@ find_predicates (pred_chain_union *preds,\n         break;\n     }\n \n-  compute_control_dep_chain (cd_root, use_bb,\n-                             dep_chains, &num_chains,\n-                             &cur_chain);\n+  compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,\n+\t\t\t     &cur_chain, &num_calls);\n \n   has_valid_pred\n-      = convert_control_dep_chain_into_preds (dep_chains,\n-                                              num_chains,\n-                                              preds);\n-  /* Free individual chain  */\n-  cur_chain.release ();\n+    = convert_control_dep_chain_into_preds (dep_chains, num_chains, preds);\n   for (i = 0; i < num_chains; i++)\n     dep_chains[i].release ();\n-  free (dep_chains);\n   return has_valid_pred;\n }\n \n@@ -694,16 +692,13 @@ static bool\n find_def_preds (pred_chain_union *preds, gimple phi)\n {\n   size_t num_chains = 0, i, n;\n-  vec<edge> *dep_chains = 0;\n-  vec<edge> cur_chain = vNULL;\n+  vec<edge> dep_chains[MAX_NUM_CHAINS];\n+  auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n   vec<edge> def_edges = vNULL;\n   bool has_valid_pred = false;\n   basic_block phi_bb, cd_root = 0;\n   pointer_set_t *visited_phis;\n \n-  typedef vec<edge> vec_edge_heap;\n-  dep_chains = XCNEWVEC (vec_edge_heap, MAX_NUM_CHAINS);\n-\n   phi_bb = gimple_bb (phi);\n   /* First find the closest dominating bb to be\n      the control dependence root  */\n@@ -722,37 +717,29 @@ find_def_preds (pred_chain_union *preds, gimple phi)\n   for (i = 0; i < n; i++)\n     {\n       size_t prev_nc, j;\n+      int num_calls = 0;\n       edge opnd_edge;\n \n       opnd_edge = def_edges[i];\n       prev_nc = num_chains;\n-      compute_control_dep_chain (cd_root, opnd_edge->src,\n-                                 dep_chains, &num_chains,\n-                                 &cur_chain);\n-      /* Free individual chain  */\n-      cur_chain.release ();\n+      compute_control_dep_chain (cd_root, opnd_edge->src, dep_chains,\n+\t\t\t\t &num_chains, &cur_chain, &num_calls);\n \n       /* Now update the newly added chains with\n          the phi operand edge:  */\n       if (EDGE_COUNT (opnd_edge->src->succs) > 1)\n         {\n-          if (prev_nc == num_chains\n-              && num_chains < MAX_NUM_CHAINS)\n-            num_chains++;\n+\t  if (prev_nc == num_chains && num_chains < MAX_NUM_CHAINS)\n+\t    dep_chains[num_chains++] = vNULL;\n           for (j = prev_nc; j < num_chains; j++)\n-            {\n-              dep_chains[j].safe_push (opnd_edge);\n-            }\n+\t    dep_chains[j].safe_push (opnd_edge);\n         }\n     }\n \n   has_valid_pred\n-      = convert_control_dep_chain_into_preds (dep_chains,\n-                                              num_chains,\n-                                              preds);\n+    = convert_control_dep_chain_into_preds (dep_chains, num_chains, preds);\n   for (i = 0; i < num_chains; i++)\n     dep_chains[i].release ();\n-  free (dep_chains);\n   return has_valid_pred;\n }\n "}]}