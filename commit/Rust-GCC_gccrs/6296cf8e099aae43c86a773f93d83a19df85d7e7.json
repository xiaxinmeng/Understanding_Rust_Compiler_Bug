{"sha": "6296cf8e099aae43c86a773f93d83a19df85d7e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI5NmNmOGUwOTlhYWU0M2M4NmE3NzNmOTNkODNhMTlkZjg1ZDdlNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-11-16T20:13:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-11-16T20:13:48Z"}, "message": "PR c++/79092 - non-type args of different types are different\n\n\t* tree.c (cp_tree_equal): Check the type of constants.\n\t* pt.c (unify) [TEMPLATE_PARM_INDEX]: Handle UNIFY_ALLOW_INTEGER\n\twhen comparing to previously deduced argument.\n\t(maybe_convert_nontype_argument): New.\n\t(convert_nontype_argument): Call it.\n\t(tsubst_copy_and_build): Handle partial instantiation of\n\tIMPLICIT_CONV_EXPR.\n\t(unify): Ignore type when deducing from array bound.\n\t(dependent_type_p_r): Handle DEFERRED_NOEXCEPT.\n\t(value_dependent_expression_p): Any type-dependent expression is\n\tvalue-dependent.  Handle IMPLICIT_CONV_EXPR.\n\t* cp-tree.h (IMPLICIT_CONV_EXPR_NONTYPE_ARG): New.\n\t* mangle.c (write_template_arg): Strip IMPLICIT_CONV_EXPR.\n\nFrom-SVN: r254843", "tree": {"sha": "f602a84e280c62dd314f2a97321a94ae4ebf7d50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f602a84e280c62dd314f2a97321a94ae4ebf7d50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6296cf8e099aae43c86a773f93d83a19df85d7e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6296cf8e099aae43c86a773f93d83a19df85d7e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6296cf8e099aae43c86a773f93d83a19df85d7e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6296cf8e099aae43c86a773f93d83a19df85d7e7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "285346b5eba02c9a21351355de4cb7fb7d2b91ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/285346b5eba02c9a21351355de4cb7fb7d2b91ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/285346b5eba02c9a21351355de4cb7fb7d2b91ef"}], "stats": {"total": 114, "additions": 97, "deletions": 17}, "files": [{"sha": "e0bb1b1ddd43c4538f83e53ffa6bf8aeadeace30", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6296cf8e099aae43c86a773f93d83a19df85d7e7", "patch": "@@ -1,3 +1,20 @@\n+2017-11-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/79092 - non-type args of different types are different\n+\t* tree.c (cp_tree_equal): Check the type of constants.\n+\t* pt.c (unify) [TEMPLATE_PARM_INDEX]: Handle UNIFY_ALLOW_INTEGER\n+\twhen comparing to previously deduced argument.\n+\t(maybe_convert_nontype_argument): New.\n+\t(convert_nontype_argument): Call it.\n+\t(tsubst_copy_and_build): Handle partial instantiation of\n+\tIMPLICIT_CONV_EXPR.\n+\t(unify): Ignore type when deducing from array bound.\n+\t(dependent_type_p_r): Handle DEFERRED_NOEXCEPT.\n+\t(value_dependent_expression_p): Any type-dependent expression is\n+\tvalue-dependent.  Handle IMPLICIT_CONV_EXPR.\n+\t* cp-tree.h (IMPLICIT_CONV_EXPR_NONTYPE_ARG): New.\n+\t* mangle.c (write_template_arg): Strip IMPLICIT_CONV_EXPR.\n+\n 2017-11-16  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/82836"}, {"sha": "1c19c3d31f82a847a7141a2e750b5a3a162bad7f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6296cf8e099aae43c86a773f93d83a19df85d7e7", "patch": "@@ -382,6 +382,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)\n       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)\n       OVL_USING_P (in OVERLOAD)\n+      IMPLICIT_CONV_EXPR_NONTYPE_ARG (in IMPLICIT_CONV_EXPR)\n    2: IDENTIFIER_KIND_BIT_2 (in IDENTIFIER_NODE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n@@ -4126,6 +4127,11 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define IMPLICIT_CONV_EXPR_DIRECT_INIT(NODE) \\\n   (TREE_LANG_FLAG_0 (IMPLICIT_CONV_EXPR_CHECK (NODE)))\n \n+/* True if NODE represents a dependent conversion of a non-type template\n+   argument.  Set by maybe_convert_nontype_argument.  */\n+#define IMPLICIT_CONV_EXPR_NONTYPE_ARG(NODE) \\\n+  (TREE_LANG_FLAG_1 (IMPLICIT_CONV_EXPR_CHECK (NODE)))\n+\n /* Nonzero means that an object of this type can not be initialized using\n    an initializer list.  */\n #define CLASSTYPE_NON_AGGREGATE(NODE) \\"}, {"sha": "6d4e59101ee3bdb26bd17c787140ff99b2d59cff", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=6296cf8e099aae43c86a773f93d83a19df85d7e7", "patch": "@@ -2836,7 +2836,7 @@ write_expression (tree expr)\n   while (CONVERT_EXPR_CODE_P (code)\n \t /* Parentheses aren't mangled.  */\n \t || code == PAREN_EXPR\n-\t || TREE_CODE (expr) == NON_LVALUE_EXPR)\n+\t || code == NON_LVALUE_EXPR)\n     {\n       expr = TREE_OPERAND (expr, 0);\n       code = TREE_CODE (expr);\n@@ -3407,6 +3407,9 @@ write_template_arg (tree node)\n \t}\n     }\n \n+  /* Strip a conversion added by convert_nontype_argument.  */\n+  if (TREE_CODE (node) == IMPLICIT_CONV_EXPR)\n+    node = TREE_OPERAND (node, 0);\n   if (REFERENCE_REF_P (node))\n     node = TREE_OPERAND (node, 0);\n   if (TREE_CODE (node) == NOP_EXPR"}, {"sha": "2b70969999e00e38516e18bdeb7650a428973a0c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 60, "deletions": 16, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6296cf8e099aae43c86a773f93d83a19df85d7e7", "patch": "@@ -7519,6 +7519,31 @@ convert_wildcard_argument (tree parm, tree arg)\n   return arg;\n }\n \n+/* We can't fully resolve ARG given as a non-type template argument to TYPE,\n+   because one of them is dependent.  But we need to represent the\n+   conversion for the benefit of cp_tree_equal.  */\n+\n+static tree\n+maybe_convert_nontype_argument (tree type, tree arg)\n+{\n+  /* Auto parms get no conversion.  */\n+  if (type_uses_auto (type))\n+    return arg;\n+  /* We don't need or want to add this conversion now if we're going to use the\n+     argument for deduction.  */\n+  if (value_dependent_expression_p (arg))\n+    return arg;\n+\n+  type = cv_unqualified (type);\n+  tree argtype = TREE_TYPE (arg);\n+  if (same_type_p (type, argtype))\n+    return arg;\n+\n+  arg = build1 (IMPLICIT_CONV_EXPR, type, arg);\n+  IMPLICIT_CONV_EXPR_NONTYPE_ARG (arg) = true;\n+  return arg;\n+}\n+\n /* Convert the indicated template ARG as necessary to match the\n    indicated template PARM.  Returns the converted ARG, or\n    error_mark_node if the conversion was unsuccessful.  Error and\n@@ -7774,7 +7799,11 @@ convert_template_argument (tree parm,\n \t   argument specification is valid.  */\n \tval = convert_nontype_argument (t, orig_arg, complain);\n       else\n-\tval = canonicalize_expr_argument (orig_arg, complain);\n+\t{\n+\t  val = canonicalize_expr_argument (orig_arg, complain);\n+\t  val = maybe_convert_nontype_argument (t, val);\n+\t}\n+\n \n       if (val == NULL_TREE)\n \tval = error_mark_node;\n@@ -17097,6 +17126,17 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n \ttree expr = RECUR (TREE_OPERAND (t, 0));\n+\tif (dependent_type_p (type) || type_dependent_expression_p (expr))\n+\t  {\n+\t    retval = copy_node (t);\n+\t    TREE_TYPE (retval) = type;\n+\t    TREE_OPERAND (retval, 0) = expr;\n+\t    RETURN (retval);\n+\t  }\n+\tif (IMPLICIT_CONV_EXPR_NONTYPE_ARG (t))\n+\t  /* We'll pass this to convert_nontype_argument again, we don't need\n+\t     to actually perform any conversion here.  */\n+\t  RETURN (expr);\n \tint flags = LOOKUP_IMPLICIT;\n \tif (IMPLICIT_CONV_EXPR_DIRECT_INIT (t))\n \t  flags = LOOKUP_NORMAL;\n@@ -20886,6 +20926,11 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \n       if (targ)\n \t{\n+\t  if ((strict & UNIFY_ALLOW_INTEGER)\n+\t      && TREE_TYPE (targ) && TREE_TYPE (arg)\n+\t      && CP_INTEGRAL_TYPE_P (TREE_TYPE (targ)))\n+\t    /* We're deducing from an array bound, the type doesn't matter.  */\n+\t    arg = fold_convert (TREE_TYPE (targ), arg);\n \t  int x = !cp_tree_equal (targ, arg);\n \t  if (x)\n \t    unify_inconsistency (explain_p, parm, targ, arg);\n@@ -23704,13 +23749,15 @@ dependent_type_p_r (tree type)\n \tif (dependent_type_p (TREE_VALUE (arg_type)))\n \t  return true;\n       if (cxx_dialect >= cxx17)\n-\t{\n-\t  /* A value-dependent noexcept-specifier makes the type dependent.  */\n-\t  tree spec = TYPE_RAISES_EXCEPTIONS (type);\n-\t  if (spec && TREE_PURPOSE (spec)\n-\t      && value_dependent_expression_p (TREE_PURPOSE (spec)))\n-\t    return true;\n-\t}\n+\t/* A value-dependent noexcept-specifier makes the type dependent.  */\n+\tif (tree spec = TYPE_RAISES_EXCEPTIONS (type))\n+\t  if (tree noex = TREE_PURPOSE (spec))\n+\t    /* Treat DEFERRED_NOEXCEPT as non-dependent, since it doesn't\n+\t       affect overload resolution and treating it as dependent breaks\n+\t       things.  */\n+\t    if (TREE_CODE (noex) != DEFERRED_NOEXCEPT\n+\t\t&& value_dependent_expression_p (noex))\n+\t      return true;\n       return false;\n     }\n   /* -- an array type constructed from any dependent type or whose\n@@ -23875,8 +23922,8 @@ value_dependent_expression_p (tree expression)\n   if (!processing_template_decl || expression == NULL_TREE)\n     return false;\n \n-  /* A name declared with a dependent type.  */\n-  if (DECL_P (expression) && type_dependent_expression_p (expression))\n+  /* A type-dependent expression is also value-dependent.  */\n+  if (type_dependent_expression_p (expression))\n     return true;\n \n   switch (TREE_CODE (expression))\n@@ -23918,13 +23965,12 @@ value_dependent_expression_p (tree expression)\n \t  && (TREE_CODE (DECL_INITIAL (expression)) == TREE_LIST\n \t      /* cp_finish_decl doesn't fold reference initializers.  */\n \t      || TREE_CODE (TREE_TYPE (expression)) == REFERENCE_TYPE\n-\t      || type_dependent_expression_p (DECL_INITIAL (expression))\n \t      || value_dependent_expression_p (DECL_INITIAL (expression))))\n \treturn true;\n       if (DECL_HAS_VALUE_EXPR_P (expression))\n \t{\n \t  tree value_expr = DECL_VALUE_EXPR (expression);\n-\t  if (type_dependent_expression_p (value_expr))\n+\t  if (value_dependent_expression_p (value_expr))\n \t    return true;\n \t}\n       return false;\n@@ -23934,6 +23980,7 @@ value_dependent_expression_p (tree expression)\n     case CONST_CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n     case CAST_EXPR:\n+    case IMPLICIT_CONV_EXPR:\n       /* These expressions are value-dependent if the type to which\n \t the cast occurs is dependent or the expression being casted\n \t is value-dependent.  */\n@@ -24078,10 +24125,7 @@ value_dependent_expression_p (tree expression)\n       }\n \n     case TEMPLATE_ID_EXPR:\n-      /* If a TEMPLATE_ID_EXPR involves a dependent name, it will be\n-\t type-dependent.  */\n-      return type_dependent_expression_p (expression)\n-\t|| variable_concept_p (TREE_OPERAND (expression, 0));\n+      return variable_concept_p (TREE_OPERAND (expression, 0));\n \n     case CONSTRUCTOR:\n       {"}, {"sha": "245657866dfd9b3c3cecfd284f3c5e366cf62bc5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6296cf8e099aae43c86a773f93d83a19df85d7e7", "patch": "@@ -3494,6 +3494,10 @@ cp_tree_equal (tree t1, tree t2)\n   if (code1 != code2)\n     return false;\n \n+  if (CONSTANT_CLASS_P (t1)\n+      && !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+    return false;\n+\n   switch (code1)\n     {\n     case VOID_CST:"}, {"sha": "7bff75c3484a8c8bb505e94c67f1fe325ff01d5a", "filename": "gcc/testsuite/g++.dg/cpp1z/nontype-auto12.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6296cf8e099aae43c86a773f93d83a19df85d7e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fnontype-auto12.C?ref=6296cf8e099aae43c86a773f93d83a19df85d7e7", "patch": "@@ -0,0 +1,6 @@\n+// PR c++/79092\n+// { dg-options -std=c++17 }\n+\n+template<auto V> struct val {};\n+\n+struct type : val<0>, val<0u> {};"}]}