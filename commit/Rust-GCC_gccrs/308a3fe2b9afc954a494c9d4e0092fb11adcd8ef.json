{"sha": "308a3fe2b9afc954a494c9d4e0092fb11adcd8ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA4YTNmZTJiOWFmYzk1NGE0OTRjOWQ0ZTAwOTJmYjExYWRjZDhlZg==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-10-15T16:06:42Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-10-15T16:06:42Z"}, "message": "Cleanup comments in alias.c\n\nWhile reading alias.c, it seemed to me that some comments could use\nsome cleanups.\n\ngcc/\n\n\t* alias.c: Cleanup comments.\n\nFrom-SVN: r192463", "tree": {"sha": "c67c6c3c087bca6e61b29c04791723adf621b2d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c67c6c3c087bca6e61b29c04791723adf621b2d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/308a3fe2b9afc954a494c9d4e0092fb11adcd8ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308a3fe2b9afc954a494c9d4e0092fb11adcd8ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/308a3fe2b9afc954a494c9d4e0092fb11adcd8ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308a3fe2b9afc954a494c9d4e0092fb11adcd8ef/comments", "author": null, "committer": null, "parents": [{"sha": "895e8371269deae98b75c6784cd0def3d8ff4446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/895e8371269deae98b75c6784cd0def3d8ff4446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/895e8371269deae98b75c6784cd0def3d8ff4446"}], "stats": {"total": 31, "additions": 17, "deletions": 14}, "files": [{"sha": "20ed440d22da41edb915d104dc89ccca7b680744", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308a3fe2b9afc954a494c9d4e0092fb11adcd8ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308a3fe2b9afc954a494c9d4e0092fb11adcd8ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=308a3fe2b9afc954a494c9d4e0092fb11adcd8ef", "patch": "@@ -1,3 +1,7 @@\n+2012-10-15  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* alias.c: Cleanup comments.\n+\n 2012-10-15  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/54915"}, {"sha": "09aef1137efeadd1e7b0c5b15e3c785737fba020", "filename": "gcc/alias.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308a3fe2b9afc954a494c9d4e0092fb11adcd8ef/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308a3fe2b9afc954a494c9d4e0092fb11adcd8ef/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=308a3fe2b9afc954a494c9d4e0092fb11adcd8ef", "patch": "@@ -60,14 +60,13 @@ along with GCC; see the file COPYING3.  If not see\n    struct Z z2, *pz;\n \n \n-   py = &px1.y1;\n+   py = &x1.y1;\n    px2 = &x1;\n \n    Consider the four questions:\n \n    Can a store to x1 interfere with px2->y1?\n    Can a store to x1 interfere with px2->z2?\n-   (*px2).z2\n    Can a store to x1 change the value pointed to by with py?\n    Can a store to x1 change the value pointed to by with pz?\n \n@@ -78,24 +77,24 @@ along with GCC; see the file COPYING3.  If not see\n    a store through a pointer to an X can overwrite any field that is\n    contained (recursively) in an X (unless we know that px1 != px2).\n \n-   The last two of the questions can be solved in the same way as the\n-   first two questions but this is too conservative.  The observation\n-   is that in some cases analysis we can know if which (if any) fields\n-   are addressed and if those addresses are used in bad ways.  This\n-   analysis may be language specific.  In C, arbitrary operations may\n-   be applied to pointers.  However, there is some indication that\n-   this may be too conservative for some C++ types.\n+   The last two questions can be solved in the same way as the first\n+   two questions but this is too conservative.  The observation is\n+   that in some cases we can know which (if any) fields are addressed\n+   and if those addresses are used in bad ways.  This analysis may be\n+   language specific.  In C, arbitrary operations may be applied to\n+   pointers.  However, there is some indication that this may be too\n+   conservative for some C++ types.\n \n    The pass ipa-type-escape does this analysis for the types whose\n    instances do not escape across the compilation boundary.\n \n    Historically in GCC, these two problems were combined and a single\n-   data structure was used to represent the solution to these\n+   data structure that was used to represent the solution to these\n    problems.  We now have two similar but different data structures,\n-   The data structure to solve the last two question is similar to the\n-   first, but does not contain have the fields in it whose address are\n-   never taken.  For types that do escape the compilation unit, the\n-   data structures will have identical information.\n+   The data structure to solve the last two questions is similar to\n+   the first, but does not contain the fields whose address are never\n+   taken.  For types that do escape the compilation unit, the data\n+   structures will have identical information.\n */\n \n /* The alias sets assigned to MEMs assist the back-end in determining"}]}