{"sha": "d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "node_id": "C_kwDOANBUbNoAKGQwZWY5ZTA2MTk3ZDE0ZDdiYTYwNDA0ZTM3YmQyN2MyMTc5MWJhM2Q", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-24T13:27:39Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-24T13:27:39Z"}, "message": "c++: set TYPE_CANONICAL for more template types\n\nWhen forming a class template specialization, lookup_template_class\nuses structural equality for the specialized type whenever one of its\ntemplate arguments uses structural equality.  This is the sensible thing\nto do in a vacuum, but given that we already effectively deduplicate class\nspecializations via the type_specializations table, we ought to be able\nto safely assume that each class specialization is unique and therefore\ncanonical, regardless of the canonicity of the template arguments.\n\nTo that end this patch makes us use the canonical type machinery for all\ntype specializations, except for the case where a PARM_DECL appears in\nthe template arguments (this special case was recently added by\nr12-3766-g72394d38d929c7).\n\nAdditionally, this patch makes us use the canonical type machinery for\nTEMPLATE_TEMPLATE_PARMs and BOUND_TEMPLATE_TEMPLATE_PARMs, by extending\ncanonical_type_parameter appropriately.  A comment in tsubst says it's\nunsafe to set TYPE_CANONICAL for a lowered TEMPLATE_TEMPLATE_PARM, but\nI'm not sure this is true anymore.  According to Jason, this comment\n(from r120341) became obsolete when later that year r129844 started to\nsubstitute the template parms of ttps.  Note that r10-7817-ga6f400239d792d\nrecently changed process_template_parm to clear TYPE_CANONICAL for\nTEMPLATE_TEMPLATE_PARM consistent with the tsubst comment; this patch\nchanges both functions to set instead of clear TYPE_CANONICAL for ttps.\n\nThese changes improve compile time of template-heavy code by around 10%\nfor me (with a release compiler).  For instance, compile time for the\nlibstdc++ test std/ranges/adaptors/all.cc drops from 1.45s to 1.25s, and\nfor the range-v3 test test/view/zip.cpp from 5.38s to 4.88s.  The total\nnumber of calls to structural_comptypes for the latter test drops from\n10.5M to 1.8M.  Memory use is unaffected (as expected).\n\nThe new testcase verifies we check the r12-3766 PARM_DECL special case\nin bind_template_template_parm too.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (any_template_arguments_need_structural_equality_p):\n\tDeclare.\n\t* pt.cc (struct ctp_hasher): Define.\n\t(ctp_table): Define.\n\t(canonical_type_parameter): Use it.\n\t(process_template_parm): Set TYPE_CANONICAL for\n\tTEMPLATE_TEMPLATE_PARM too.\n\t(lookup_template_class_1): Remove now outdated comment for the\n\tany_template_arguments_need_structural_equality_p test.\n\t(tsubst) <case TEMPLATE_TEMPLATE_PARM, etc>: Don't specifically\n\tclear TYPE_CANONICAL for ttps.  Set TYPE_CANONICAL on the\n\tsubstituted type later.\n\t(any_template_arguments_need_structural_equality_p): Return\n\ttrue for any_targ_node.  Don't return true just because a\n\ttemplate argument uses structural equality.  Add comment for\n\tthe PARM_DECL special case.\n\t(rewrite_template_parm): Set TYPE_CANONICAL on the rewritten\n\tparm's type later.\n\t* tree.cc (bind_template_template_parm): Set TYPE_CANONICAL\n\twhen safe to do so.\n\t* typeck.cc (structural_comptypes) [check_alias]: Increment\n\tprocessing_template_decl before checking\n\tdependent_alias_template_spec_p.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/constexpr-52830a.C: New test.", "tree": {"sha": "6fb336ae02fc1c1ac897dea02c55f1a7e8332343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fb336ae02fc1c1ac897dea02c55f1a7e8332343"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/comments", "author": null, "committer": null, "parents": [{"sha": "442cf0977a2993940a81aac08134fcdde4fb3035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442cf0977a2993940a81aac08134fcdde4fb3035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442cf0977a2993940a81aac08134fcdde4fb3035"}], "stats": {"total": 149, "additions": 102, "deletions": 47}, "files": [{"sha": "ba986e892b61d37982663a00349bc1ce97d7b1e4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "patch": "@@ -6647,6 +6647,7 @@ extern bool make_safe_copy_elision\t\t(tree, tree);\n extern bool cp_handle_deprecated_or_unavailable (tree, tsubst_flags_t = tf_warning_or_error);\n extern void cp_warn_deprecated_use_scopes\t(tree);\n extern tree get_function_version_dispatcher\t(tree);\n+extern bool any_template_arguments_need_structural_equality_p (tree);\n \n /* in class.cc */\n extern tree build_vfield_ref\t\t\t(tree, tree);"}, {"sha": "b45a29926d2bb2290b2256891011d9ce0d41ffca", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 55, "deletions": 46, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "patch": "@@ -203,7 +203,6 @@ static tree copy_default_args_to_explicit_spec_1 (tree, tree);\n static void copy_default_args_to_explicit_spec (tree);\n static bool invalid_nontype_parm_type_p (tree, tsubst_flags_t);\n static bool dependent_template_arg_p (tree);\n-static bool any_template_arguments_need_structural_equality_p (tree);\n static bool dependent_type_p_r (tree);\n static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n static tree tsubst_decl (tree, tree, tsubst_flags_t);\n@@ -4526,28 +4525,41 @@ build_template_parm_index (int index,\n   return t;\n }\n \n+struct ctp_hasher : ggc_ptr_hash<tree_node>\n+{\n+  static hashval_t hash (tree t)\n+  {\n+    tree_code code = TREE_CODE (t);\n+    hashval_t val = iterative_hash_object (code, 0);\n+    val = iterative_hash_object (TEMPLATE_TYPE_LEVEL (t), val);\n+    val = iterative_hash_object (TEMPLATE_TYPE_IDX (t), val);\n+    if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+      val = iterative_hash_template_arg (TYPE_TI_ARGS (t), val);\n+    return val;\n+  }\n+\n+  static bool equal (tree t, tree u)\n+  {\n+    return comptypes (t, u, COMPARE_STRUCTURAL);\n+  }\n+};\n+\n+static GTY (()) hash_table<ctp_hasher> *ctp_table;\n+\n /* Find the canonical type parameter for the given template type\n    parameter.  Returns the canonical type parameter, which may be TYPE\n    if no such parameter existed.  */\n \n tree\n canonical_type_parameter (tree type)\n {\n-  int idx = TEMPLATE_TYPE_IDX (type);\n+  if (ctp_table == NULL)\n+    ctp_table = hash_table<ctp_hasher>::create_ggc (61);\n \n-  gcc_assert (TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM);\n-\n-  if (vec_safe_length (canonical_template_parms) <= (unsigned) idx)\n-    vec_safe_grow_cleared (canonical_template_parms, idx + 1, true);\n-\n-  for (tree list = (*canonical_template_parms)[idx];\n-       list; list = TREE_CHAIN (list))\n-    if (comptypes (type, TREE_VALUE (list), COMPARE_STRUCTURAL))\n-      return TREE_VALUE (list);\n-\n-  (*canonical_template_parms)[idx]\n-    = tree_cons (NULL_TREE, type, (*canonical_template_parms)[idx]);\n-  return type;\n+  tree& slot = *ctp_table->find_slot (type, INSERT);\n+  if (slot == NULL_TREE)\n+    slot = type;\n+  return slot;\n }\n \n /* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose\n@@ -4720,10 +4732,7 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n \t\t\t\t     current_template_depth,\n \t\t\t\t     decl, TREE_TYPE (parm));\n       TEMPLATE_TYPE_PARAMETER_PACK (t) = is_parameter_pack;\n-      if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n-\tSET_TYPE_STRUCTURAL_EQUALITY (t);\n-      else\n-\tTYPE_CANONICAL (t) = canonical_type_parameter (t);\n+      TYPE_CANONICAL (t) = canonical_type_parameter (t);\n     }\n   DECL_ARTIFICIAL (decl) = 1;\n   SET_DECL_TEMPLATE_PARM_P (decl);\n@@ -10131,9 +10140,6 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t       appropriately. */\n \t    TYPE_CANONICAL (t) = template_type;\n \t  else if (any_template_arguments_need_structural_equality_p (arglist))\n-\t    /* Some of the template arguments require structural\n-\t       equality testing, so this template class requires\n-\t       structural equality testing. */\n \t    SET_TYPE_STRUCTURAL_EQUALITY (t);\n \t}\n       else\n@@ -15908,20 +15914,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t       only instantiated during satisfaction.  */\n \t\t    PLACEHOLDER_TYPE_CONSTRAINTS_INFO (r) = ci;\n \n-\t\tif (TREE_CODE (r) == TEMPLATE_TEMPLATE_PARM)\n-\t\t  /* We have reduced the level of the template\n-\t\t     template parameter, but not the levels of its\n-\t\t     template parameters, so canonical_type_parameter\n-\t\t     will not be able to find the canonical template\n-\t\t     template parameter for this level. Thus, we\n-\t\t     require structural equality checking to compare\n-\t\t     TEMPLATE_TEMPLATE_PARMs. */\n-\t\t  SET_TYPE_STRUCTURAL_EQUALITY (r);\n-\t\telse if (TYPE_STRUCTURAL_EQUALITY_P (t))\n-\t\t  SET_TYPE_STRUCTURAL_EQUALITY (r);\n-\t\telse\n-\t\t  TYPE_CANONICAL (r) = canonical_type_parameter (r);\n-\n \t\tif (code == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n \t\t    tree tinfo = TYPE_TEMPLATE_INFO (t);\n@@ -15939,6 +15931,11 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t    TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (r)\n \t\t      = build_template_info (tmpl, argvec);\n \t\t  }\n+\n+\t\tif (TYPE_STRUCTURAL_EQUALITY_P (t))\n+\t\t  SET_TYPE_STRUCTURAL_EQUALITY (r);\n+\t\telse\n+\t\t  TYPE_CANONICAL (r) = canonical_type_parameter (r);\n \t      }\n \t    break;\n \n@@ -28227,8 +28224,8 @@ find_parm_usage_r (tree *tp, int *walk_subtrees, void*)\n   return NULL_TREE;\n }\n \n-/* Returns true if ARGS (a collection of template arguments) contains\n-   any types that require structural equality testing.  */\n+/* Returns true if a type specialization formed using the template\n+   arguments ARGS needs to use structural equality.  */\n \n bool\n any_template_arguments_need_structural_equality_p (tree args)\n@@ -28266,17 +28263,28 @@ any_template_arguments_need_structural_equality_p (tree args)\n \t\treturn true;\n \t      else if (TREE_CODE (arg) == TEMPLATE_DECL)\n \t\tcontinue;\n-\t      else if (TYPE_P (arg) && TYPE_STRUCTURAL_EQUALITY_P (arg))\n-\t\treturn true;\n-\t      else if (!TYPE_P (arg) && TREE_TYPE (arg)\n-\t\t       && TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (arg)))\n+\t      else if (arg == any_targ_node)\n+\t\t/* An any_targ_node argument (added by add_defaults_to_ttp)\n+\t\t   makes the corresponding specialization not canonicalizable,\n+\t\t   since template_args_equal always return true for it.  We\n+\t\t   may see this when called from bind_template_template_parm.  */\n \t\treturn true;\n \t      /* Checking current_function_decl because this structural\n \t\t comparison is only necessary for redeclaration.  */\n \t      else if (!current_function_decl\n \t\t       && dependent_template_arg_p (arg)\n \t\t       && (cp_walk_tree_without_duplicates\n \t\t\t   (&arg, find_parm_usage_r, NULL)))\n+\t\t/* The identity of a class template specialization that uses\n+\t\t   a function parameter depends on the identity of the function.\n+\t\t   And if this specialization appeared in the trailing return\n+\t\t   type thereof, we don't know the identity of the function\n+\t\t   (e.g. if it's a redeclaration or a new function) until we\n+\t\t   form its signature and go through duplicate_decls.  Thus\n+\t\t   it's unsafe to decide on a canonical type now (which depends\n+\t\t   on the DECL_CONTEXT of the function parameter, which can get\n+\t\t   mutated after the fact by duplicate_decls), so just require\n+\t\t   structural equality in this case (PR52830).  */\n \t\treturn true;\n \t    }\n \t}\n@@ -29144,10 +29152,6 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,\n       TEMPLATE_PARM_PARAMETER_PACK (newidx)\n \t= TEMPLATE_PARM_PARAMETER_PACK (oldidx);\n       TYPE_STUB_DECL (newtype) = TYPE_NAME (newtype) = newdecl;\n-      if (TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (olddecl)))\n-\tSET_TYPE_STRUCTURAL_EQUALITY (newtype);\n-      else\n-\tTYPE_CANONICAL (newtype) = canonical_type_parameter (newtype);\n \n       if (TREE_CODE (olddecl) == TEMPLATE_DECL)\n \t{\n@@ -29189,6 +29193,11 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,\n \t  // All done.\n \t  DECL_TEMPLATE_PARMS (newdecl) = ttparms;\n \t}\n+\n+      if (TYPE_STRUCTURAL_EQUALITY_P (TREE_TYPE (olddecl)))\n+\tSET_TYPE_STRUCTURAL_EQUALITY (newtype);\n+      else\n+\tTYPE_CANONICAL (newtype) = canonical_type_parameter (newtype);\n     }\n   else\n     {"}, {"sha": "09162795801180c6f81d06e77cbeeb1dbb610cb8", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "patch": "@@ -2901,7 +2901,11 @@ bind_template_template_parm (tree t, tree newargs)\n   TYPE_NAME (t2) = decl;\n   TYPE_STUB_DECL (t2) = decl;\n   TYPE_SIZE (t2) = 0;\n-  SET_TYPE_STRUCTURAL_EQUALITY (t2);\n+\n+  if (any_template_arguments_need_structural_equality_p (newargs))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t2);\n+  else\n+    TYPE_CANONICAL (t2) = canonical_type_parameter (t2);\n \n   return t2;\n }"}, {"sha": "385cdf4d7338c3e5e6eb898a806279c3541d4d1a", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "patch": "@@ -1511,8 +1511,10 @@ structural_comptypes (tree t1, tree t2, int strict)\n \t substitute into the specialization arguments at instantiation\n \t time.  And aliases can't be equivalent without being ==, so\n \t we don't need to look any deeper.  */\n+      ++processing_template_decl;\n       tree dep1 = dependent_alias_template_spec_p (t1, nt_transparent);\n       tree dep2 = dependent_alias_template_spec_p (t2, nt_transparent);\n+      --processing_template_decl;\n       if ((dep1 || dep2) && dep1 != dep2)\n \treturn false;\n     }"}, {"sha": "224f2cd50eb8031597343e097c71bd4a58d019de", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-52830a.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-52830a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ef9e06197d14d7ba60404e37bd27c21791ba3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-52830a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-52830a.C?ref=d0ef9e06197d14d7ba60404e37bd27c21791ba3d", "patch": "@@ -0,0 +1,39 @@\n+// PR c++/52830\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-fchecking\" }\n+// A version of constexpr-52830.C that uses an intermediate template template\n+// parameter.\n+\n+template<bool b> struct eif { typedef void type; };\n+template<>       struct eif<false> {};\n+\n+template<class A, class B> struct same\n+{\n+  static constexpr bool value = false;\n+};\n+template<class A>\n+struct same<A, A>\n+{\n+  static constexpr bool value = true;\n+};\n+\n+\n+struct foo {\n+  template<class T, template<class, class> class SAME = same>\n+  void func(T && a,\n+            typename eif<SAME<decltype(a), int&&>::value>::type * = 0);\n+};\n+\n+template<class T, template<class, class> class SAME>\n+void\n+foo::\n+func(T && a,\n+     typename eif<SAME<decltype(a), int&&>::value>::type * )\n+{\n+}\n+\n+void do_stuff()\n+{\n+  foo f;\n+  f.func(12);\n+}"}]}