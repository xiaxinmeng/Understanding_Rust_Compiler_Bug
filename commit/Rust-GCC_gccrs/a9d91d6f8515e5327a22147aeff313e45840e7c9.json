{"sha": "a9d91d6f8515e5327a22147aeff313e45840e7c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTlkOTFkNmY4NTE1ZTUzMjdhMjIxNDdhZWZmMzEzZTQ1ODQwZTdjOQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-04T21:32:44Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-04T21:32:44Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1160", "tree": {"sha": "d574b6b733da30c36c5c8f60249f266b15b3beba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d574b6b733da30c36c5c8f60249f266b15b3beba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9d91d6f8515e5327a22147aeff313e45840e7c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d91d6f8515e5327a22147aeff313e45840e7c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9d91d6f8515e5327a22147aeff313e45840e7c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9d91d6f8515e5327a22147aeff313e45840e7c9/comments", "author": null, "committer": null, "parents": [{"sha": "e38e5ba82f13ad9dac93a5f25e8e98275425c5eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38e5ba82f13ad9dac93a5f25e8e98275425c5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e38e5ba82f13ad9dac93a5f25e8e98275425c5eb"}], "stats": {"total": 105, "additions": 62, "deletions": 43}, "files": [{"sha": "653edd27d18ab2dbfde7974b9f4cb290751843ed", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d91d6f8515e5327a22147aeff313e45840e7c9/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d91d6f8515e5327a22147aeff313e45840e7c9/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a9d91d6f8515e5327a22147aeff313e45840e7c9", "patch": "@@ -1398,31 +1398,10 @@ output_function_prologue (file, size, leaf_function)\n       fprintf (file, \",NO_CALLS\\n\");\n   fprintf (file, \"\\t.ENTRY\\n\");\n \n-  /* Instead of taking one argument, the counter label, as most normal\n-     mcounts do, _mcount appears to behave differently on the HPPA. It\n-     takes the return address of the caller, the address of this\n-     routine, and the address of the label. Also, it isn't magic, so\n-     caller saves have to be preserved. We get around this by calling\n-     our own gcc_mcount, which takes arguments on the stack and saves\n-     argument registers. */\n-  \n-  if (profile_flag)\n-    {\n-      fprintf (file,\"\\tstw 2,-20(30)\\n\\tldo 48(30),30\\n\\\n-\\taddil L'LP$%04d-$global$,27\\n\\tldo R'LP$%04d-$global$(1),1\\n\\\n-\\tbl __gcc_mcount,2\\n\\tstw 1,-16(30)\\n\\tldo -48(30),30\\n\\tldw -20(30),2\\n\",\n-\t       hp_profile_labelno, hp_profile_labelno);\n-    }\n   /* Some registers have places to go in the current stack\n      structure.  */\n \n-#if 0\n-  /* However, according to the hp docs, there's no need to save the\n-     sp.  */\n-  fprintf (file, \"\\tstw 30,-4(30)\\n\");\n-#endif\n-\n-  if (regs_ever_live[2])\n+  if (regs_ever_live[2] || profile_flag)\n     fprintf (file, \"\\tstw 2,-20(0,30)\\n\");\n \n   /* Reserve space for local variables.  */\n@@ -1447,7 +1426,36 @@ output_function_prologue (file, size, leaf_function)\n \tfprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n \t\t actual_fsize, actual_fsize);\n     }\n-  \n+  /* Instead of taking one argument, the counter label, as most normal\n+     mcounts do, _mcount appears to behave differently on the HPPA. It\n+     takes the return address of the caller, the address of this\n+     routine, and the address of the label. Also, it isn't magic, so\n+     argument registers have to be preserved. */\n+\n+  if (profile_flag)\n+    {\n+      unsigned int pc_offset =\n+\t(4 + (frame_pointer_needed\n+\t      ? (VAL_14_BITS_P (actual_fsize) ? 12 : 20)\n+\t      : (VAL_14_BITS_P (actual_fsize) ? 4 : 8)));\n+      int i, arg_offset;\n+\n+      for (i = 26, arg_offset = -36; i >= 23; i--, arg_offset -= 4)\n+\tif (regs_ever_live[i])\n+\t  {\n+\t    print_stw (file, i, arg_offset, 4);\n+\t    pc_offset += 4;\n+\t  }\n+      fprintf (file,\n+\t       \"\\tcopy %%r2,%%r26\\n\\taddil L'LP$%04d-$global$,%%r27\\n\\\n+\\tldo R'LP$%04d-$global$(%%r1),%%r24\\n\\tbl _mcount,%%r2\\n\\\n+\\tldo %d(%%r2),%%r25\\n\",\n+\t       hp_profile_labelno, hp_profile_labelno, -pc_offset - 12 - 8);\n+      for (i = 26, arg_offset = -36; i >= 23; i--, arg_offset -= 4)\n+\tif (regs_ever_live[i])\n+\t  print_ldw (file, i, arg_offset, 4);\n+    }\n+\n   /* Normal register save. */\n   if (frame_pointer_needed)\n     {\n@@ -2192,7 +2200,11 @@ output_arg_descriptor (insn)\n       arg_mode = GET_MODE (XEXP (PATTERN (prev_insn), 0));\n       regno = REGNO (XEXP (PATTERN (prev_insn), 0));\n       if (regno >= 23 && regno <= 26)\n-\targ_regs[26 - regno] = \"GR\";\n+\t{\n+\t  arg_regs[26 - regno] = \"GR\";\n+\t  if (arg_mode == DImode)\n+\t    arg_regs[25 - regno] = \"GR\";\n+\t}\n       else if (!TARGET_SNAKE)\t/* fp args */\n \t{\n \t  if (arg_mode == SFmode)"}, {"sha": "d3a13578c260b8e07c10fb58631ed014a4d147f6", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9d91d6f8515e5327a22147aeff313e45840e7c9/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9d91d6f8515e5327a22147aeff313e45840e7c9/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=a9d91d6f8515e5327a22147aeff313e45840e7c9", "patch": "@@ -441,16 +441,18 @@ extern int leaf_function;\n      1.1 fp regs, and the high 1.1 fp regs, to which the operands of\n      fmpyadd and fmpysub are restricted. */\n \n-enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, HI_SNAKE_FP_REGS,\n- SNAKE_FP_REGS, FP_OR_SNAKE_FP_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n+enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n+  HI_SNAKE_FP_REGS, SNAKE_FP_REGS, GENERAL_OR_SNAKE_FP_REGS,\n+  SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES}; \n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n-  { \"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"HI_SNAKE_FP_REGS\",\\\n-    \"SNAKE_FP_REGS\", \"FP_OR_SNAKE_FP_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n+  { \"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"GENERAL_OR_FP_REGS\",\\\n+    \"HI_SNAKE_FP_REGS\", \"SNAKE_FP_REGS\", \"GENERAL_OR_SNAKE_FP_REGS\",\\\n+    \"SHIFT_REGS\", \"ALL_REGS\"}\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n@@ -462,9 +464,10 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, HI_SNAKE_FP_REGS,\n   {0x2, 0, 0, 0},\t\t/* R1_REGS */\t\t\\\n   {-2, 0, 0, 0},\t\t/* GENERAL_REGS */\t\\\n   {0, 0xffff, 0, 0},\t\t/* FP_REGS */\t\t\\\n+  {-2, 0xffff, 0, 0},\t\t/* GENERAL_OR_FP_REGS */\\\n   {0, 0, 0xffff0000, 0xffff},\t/* HI_SNAKE_FP_REGS */\t\\\n   {0, 0xffff0000, ~0, 0xffff},\t/* SNAKE_FP_REGS */\t\\\n-  {0, ~0, ~0, 0xffff},\t\t/* FP_OR_SNAKE_FP_REGS */\\\n+  {-2, 0xffff0000, ~0, 0xffff},\t/* GENERAL_OR_SNAKE_FP_REGS */\\\n   {0, 0, 0, 0x10000},\t\t/* SHIFT_REGS */\t\\\n   {-2, ~0, ~0, 0x1ffff}}\t/* ALL_REGS */\n \n@@ -774,23 +777,31 @@ extern enum cmp_type hppa_branch_type;\n \t     fputs (\"\\t.EXPORT \", FILE); assemble_name (FILE, NAME);\t\\\n \t     fputs (\",PRIV_LEV=3\", FILE);\t\t\t\t\\\n \t     for (parm = DECL_ARGUMENTS (DECL), i = 0; parm && i < 4;\t\\\n-\t\t  parm = TREE_CHAIN (parm), i++)\t\t\t\\\n+\t\t  parm = TREE_CHAIN (parm))\t\t\t\t\\\n \t       {\t\t\t\t\t\t\t\\\n \t\t if (TYPE_MODE (DECL_ARG_TYPE (parm)) == SFmode)\t\\\n-\t\t   fprintf (FILE, \",ARGW%d=FR\", i);\t\t\t\\\n+\t\t   fprintf (FILE, \",ARGW%d=FR\", i++);\t\t\t\\\n \t\t else if (TYPE_MODE (DECL_ARG_TYPE (parm)) == DFmode)\t\\\n \t\t   {\t\t\t\t\t\t\t\\\n-\t\t     if (i == 0 || i == 2)\t\t\t\t\\\n-\t\t       {\t\t\t\t\t\t\\\n-\t\t\t ASM_DOUBLE_ARG_DESCRIPTORS (FILE, i++, i);\t\\\n-\t\t       }\t\t\t\t\t\t\\\n-\t\t     else if (i == 1)\t\t\t\t\t\\\n+\t\t      if (i == 1) i++;\t\t\t\t        \\\n+\t\t      ASM_DOUBLE_ARG_DESCRIPTORS (FILE, i++, i++);\t\\\n+\t\t   }\t\t\t\t\t\t\t\\\n+\t\t else\t\t\t\t\t\t\t\\\n+\t\t   {\t\t\t\t\t\t\t\\\n+\t\t     int arg_size =\t\t\t\t\t\\\n+\t\t       FUNCTION_ARG_SIZE (TYPE_MODE (DECL_ARG_TYPE (parm)),\\\n+\t\t\t\t\t  DECL_ARG_TYPE (parm));\t\\\n+\t\t     if (arg_size == 2 && i <= 2)\t\t\t\\\n \t\t       {\t\t\t\t\t\t\\\n-\t\t\t ASM_DOUBLE_ARG_DESCRIPTORS (FILE, ++i, ++i);\t\\\n+\t\t\t if (i == 1) i++;\t\t\t\t\\\n+\t\t\t fprintf (FILE, \",ARGW%d=GR\", i++);\t\t\\\n+\t\t\t fprintf (FILE, \",ARGW%d=GR\", i++);\t\t\\\n \t\t       }\t\t\t\t\t\t\\\n+\t\t     else if (arg_size == 1)\t\t\t\t\\\n+\t\t       fprintf (FILE, \",ARGW%d=GR\", i++);\t\t\\\n+\t\t     else\t\t\t\t\t\t\\\n+\t\t       i += arg_size;\t\t\t\t\t\\\n \t\t   }\t\t\t\t\t\t\t\\\n-\t\t else\t\t\t\t\t\t\t\\\n-\t\t   fprintf (FILE, \",ARGW%d=GR\", i);\t\t\t\\\n \t       }\t\t\t\t\t\t\t\\\n \t     /* anonymous args */\t\t\t\t\t\\\n \t     if (TYPE_ARG_TYPES (tree_type) != 0\t\t\t\\\n@@ -840,13 +851,9 @@ extern int apparent_fsize;\n    profiling code in function_prologue. This just stores LABELNO for\n    that. */\n \n-#ifdef hp800\t\t\t/* Don't have the proper libraries yet */\n-#define FUNCTION_PROFILER(FILE, LABELNO) {}\n-#else\n #define PROFILE_BEFORE_PROLOGUE\n #define FUNCTION_PROFILER(FILE, LABELNO) \\\n { extern int hp_profile_labelno; hp_profile_labelno = (LABELNO);}\n-#endif\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in"}]}