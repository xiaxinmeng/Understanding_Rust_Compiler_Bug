{"sha": "56cbbbd71726c8e018202b8b6a163c0187948a58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZjYmJiZDcxNzI2YzhlMDE4MjAyYjhiNmExNjNjMDE4Nzk0OGE1OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-26T12:03:31Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-26T12:03:31Z"}, "message": "(LEGITIMATE_PIC_OPERAND_P): Reject CONST_DOUBLE with MEM with invalid\npic address.\n\nFrom-SVN: r10156", "tree": {"sha": "4d62b4c9fb0b6716d892811da1902ec77f4f08a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d62b4c9fb0b6716d892811da1902ec77f4f08a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56cbbbd71726c8e018202b8b6a163c0187948a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cbbbd71726c8e018202b8b6a163c0187948a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56cbbbd71726c8e018202b8b6a163c0187948a58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cbbbd71726c8e018202b8b6a163c0187948a58/comments", "author": null, "committer": null, "parents": [{"sha": "03c424843cc9eb0926235db1de7a113ddd965fda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c424843cc9eb0926235db1de7a113ddd965fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c424843cc9eb0926235db1de7a113ddd965fda"}], "stats": {"total": 15, "additions": 11, "deletions": 4}, "files": [{"sha": "f748f3fde13d32f5b8c179b52af1d961f1cd560e", "filename": "gcc/config/m68k/hp320.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cbbbd71726c8e018202b8b6a163c0187948a58/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cbbbd71726c8e018202b8b6a163c0187948a58/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=56cbbbd71726c8e018202b8b6a163c0187948a58", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  HP-UX 68000/68020 version.\n-   Copyright (C) 1987, 1988, 1993, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1993, 1994, 1995 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -595,12 +595,16 @@ do { register int i;\t\t\t\\\n \t   (LABEL_NO));\n \n #endif /* not HPUX_ASM */\n+\n /* In m68k svr4, a symbol_ref rtx can be a valid PIC operand if it is an\n    operand of a function call. */\n #undef LEGITIMATE_PIC_OPERAND_P\n #define LEGITIMATE_PIC_OPERAND_P(X) \\\n-  (! symbolic_operand (X, VOIDmode) \\\n-   || ((GET_CODE(X) == SYMBOL_REF) && SYMBOL_REF_FLAG(X)))\n+  ((! symbolic_operand (X, VOIDmode) \\\n+    && ! (GET_CODE (X) == CONST_DOUBLE && CONST_DOUBLE_MEM (X)\t\\\n+\t  && GET_CODE (CONST_DOUBLE_MEM (X)) == MEM\t\t\\\n+\t  && symbolic_operand (XEXP (CONST_DOUBLE_MEM (X), 0), VOIDmode))) \\\n+   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X)))\n \n /* hpux8 and later have C++ compatible include files, so do not\n    pretend they are `extern \"C\"'.  */"}, {"sha": "e54bee36d1ac04be2acd22301eada3d4f600f943", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cbbbd71726c8e018202b8b6a163c0187948a58/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cbbbd71726c8e018202b8b6a163c0187948a58/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=56cbbbd71726c8e018202b8b6a163c0187948a58", "patch": "@@ -1080,7 +1080,10 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n #define LEGITIMATE_PIC_OPERAND_P(X)\t\\\n-  (! symbolic_operand (X, VOIDmode))\n+  (! symbolic_operand (X, VOIDmode)\t\t\t\t\\\n+   && ! (GET_CODE (X) == CONST_DOUBLE && CONST_DOUBLE_MEM (X)\t\\\n+\t && GET_CODE (CONST_DOUBLE_MEM (X)) == MEM\t\t\\\n+\t && symbolic_operand (XEXP (CONST_DOUBLE_MEM (X), 0), VOIDmode)))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class."}]}